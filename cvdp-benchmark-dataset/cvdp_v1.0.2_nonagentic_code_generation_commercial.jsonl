{"id": "cvdp_copilot_32_bit_Brent_Kung_PP_adder_0004", "categories": ["cid012", "medium"], "input": {"prompt": "Complete the given partial System Verilog testbench `tb_brent_kung_adder`. The testbench must instantiate the `brent_kung_adder` RTL module and provide input stimulus for it focusing exclusively on generating comprehensive test vectors rather than building a full testbench. A Brent Kung Adder is a parallel prefix adder engineered for efficiently computing the sum of two 32-bit inputs along with a carry input.\n\n## Description :\n### Inputs :\nRegisters :\n- `sum (32-bit,[31:0])`  - 32-bit sum received from the UUT\n- `carry_out(1-bit)` - 1-bit output carry received from the UUT.\n\n### Outputs :\nRegisters :\n- `a (32-bit,[31:0])` - 32-bit augend generated by TB to UUT.\n- `b(32-bit,[31:0])`  - 32-bit addend generated by TB to UUT.\n- `carry_in(1-bit)`    - 1-bit input carry generated by TB to UUT.\n\n## Instantiation :\nThe testbench instantiates the `brent_kung_adder` module as uut and connects the signals between the module and the testbench. Each input and output from the UUT is connected to its corresponding signal in the testbench.\n\n## Input Generation and Validation:\n- Stimulus: Several test cases are applied to simulate various operations of the brent kung adder. These test cases cover a range of scenarios such as adding with smallest non-zero numbers, adding with largest numbers, random addends and augends, etc. For each case, the relevant signals (`sum`, `carry_out`) are followed immediately after the application of inputs (`a`,`b`,`carry_in`).\n\n**Test Case 1: Zero inputs** :\n   - Description: Test the adder with all inputs set to zero, expecting no sum or carry-out.\n\n**Test Case 2: Large positive numbers with no carry** :\n   - Description: Adds two large positive numbers (`0x7FFFFFFF`) with no carry-in, testing for proper addition without overflow.\n \n**Test Case 3: Adding two large negative numbers, carry-out expected** :\n   - Description: Adds two large negative numbers (`0x80000000`), expecting a carry-out as the sum wraps around.\n   \n**Test Case 4: Numbers with different magnitudes**:\n   - Description: Tests the adder with numbers of different magnitudes (0x0000FFFF and 0xFFFF0000) to verify correct handling of mixed inputs.\n   \n**Test Case 5: Large numbers with carry-in** :\n   - Description: Adds two large numbers (`0xFFFFFFFF`) with carry-in, testing for correct propagation of carry during overflow.\n   \n**Test Case 6: Alternating 1's and 0's, no carry-in** :\n   - Description: Tests the adder with alternating 1's and 0's for each operand without a carry-in, verifying correct addition without any carries.\n   \n**Test Case 7: Random values with carry-in** :\n   - Description: Adds random values with carry-in, testing the adder\u2019s ability to handle arbitrary inputs with carry propagation.\n   \n**Test Case 8: Large hexadecimal numbers** :\n   - Description: Adds large hexadecimal numbers (0xF0F0F0F0 and 0x0F0F0F0F) without carry-in, testing how the adder handles large numbers.\n\n**Test Case 9: Random edge case with carry-in** :\n   - Description: Tests a random edge case with carry-in, checking for correct addition when both operands are large random values.\n\n**Test Case 10: Random edge case, carry-out expected** :\n   - Description: Adds two large random values with carry-out expected, verifying that the adder correctly handles large random numbers and carry propagation.\n\n**Test Case 11: Simple increasing values with carry-in** :\n   - Description: Adds simple increasing values (0x11111111 and 0x22222222) with carry-in, testing the adder with straightforward values and carry propagation.\n\n**Test Case 12: Smallest non-zero inputs with carry-in** :\n   - Description: Adds the smallest non-zero values (0x00000001 and 0x00000001) with carry-in, verifying the adder\u2019s handling of small values and carry propagation.\n\n## Module Functionality :\n- The brent-kung adder uses a parallel prefix tree approach to efficiently calculate the carry signals at each stage, which helps to reduce the delay for carry propagation.\n- The adder computes the sum and carry-out by progressively calculating propagate and generate signals across multiple hierarchical stages (from P1/G1 to P6/G6).\n- The carry signals (`C`) are generated in each stage by combining the results of the previous stage's propagate and generate signals.\n- Finally, the sum is computed using the propagate signals XORed with the carry signals, and the carry-out is the final carry from the last stage.\n\nThe **different hierarchical stages of the brent_kung adder and their operations is as follows** :\n\n**First Stage (P1 and G1 generation)**:\n- The first stage computes the propagate (P1) and generate (G1) signals for each bit of a and b. The P1 signal indicates if there will be a carry from the previous bit, while the G1 signal indicates if there is a generate of carry at the current bit.\n   - `P1[i] = a[i] ^ b[i]`: Propagate signal for bit i.\n   - `G1[i] = a[i] & b[i]`: Generate signal for bit i.\n\n**Second Stage (G2 and P2 generation)**:\n- In this stage, the module generates the G2 and P2 signals for pairs of bits. The second stage is a hierarchical combination of G1 and P1 signals from the first stage.\nFor each pair of bits (i and i+1), the following calculations occur:\n  - `G2[i/2] = G1[i+1] | (P1[i+1] & G1[i])`: This computes the G2 signal, which tells if there is a carry generated by this pair of bits.\n  - `P2[i/2] = P1[i+1] & P1[i]`: This computes the P2 signal for the pair.\n\n**Third Stage (G3 and P3 generation)**:\n- The G3 and P3 signals are generated for groups of four bits.\n   - `G3[i/2] = G2[i+1] | (P2[i+1] & G2[i])`: This generates the G3 signal for each group of two G2 signals.\n   - `P3[i/2] = P2[i+1] & P2[i]`: This generates the P3 signal for each pair of P2 signals.\n\n**Fourth Stage (G4 and P4 generation)**:\n- The G4 and P4 signals are generated for groups of eight bits.\n   - `G4[i/2] = G3[i+1] | (P3[i+1] & G3[i])`: Combines G3 and P3 signals to generate G4.\n   - `P4[i/2] = P3[i+1] & P3[i]`: Combines P3 signals to generate P4.\n\n**Fifth Stage (G5 and P5 generation)**:\n- The next stage computes G5 and P5 signals, each for a group of 16 bits.\n  - `G5[i/2] = G4[i+1] | (P4[i+1] & G4[i])`: Combines G4 and P4 to generate G5.\n  - `P5[i/2] = P4[i+1] & P4[i]`: Combines P4 signals to generate P5.\n\n**Sixth Stage (G6 and P6 generation)**:\n- The final stage computes the G6 and P6 signals:\n   - `G6 = G5[1] | (P5[1] & G5[0])`: Combines G5 and P5 to generate G6.\n   - `P6 = P5[1] & P5[0]`: Combines P5 signals to generate P6.\n\n**Carry Propagation (C array)**:\n- The carry signals (C[i]) are computed by combining the G and P signals at each stage.\nFor example:\n  - `C[1] = G1[0] | (P1[0] & carry_in)`: The carry for the first bit is calculated based on the initial carry-in.\n- Each subsequent C[i] is computed using the corresponding G and P signals from the previous stages, ensuring that carries are propagated through the entire adder.\n\n**Final Sum and Carry-Out**:\n- The final sum is computed as the XOR of the propagate signals and the carry signals:\n   - `sum = P1 ^ {C[31:1], carry_in}`: The sum is the bitwise XOR of the propagate signals (P1) and the carry signals (C).\n- The final carry-out is the carry generated at the last stage:\n   - `carry_out = C[32]`: This is the final carry-out value.\n\n\n**Partial Test Stimulus Generator Code** :\n```verilog\n    module tb_brent_kung_adder;\n\n    \n    logic [31:0] a;\n    logic [31:0] b;\n    logic carry_in;\n    logic [31:0] sum;\n    logic carry_out;\n    logic [31:0] start_time;\n    logic [31:0] end_time; \n    \n    brent_kung_adder uut (\n        .a(a),\n        .b(b),\n        .carry_in(carry_in),\n        .sum(sum),\n        .carry_out(carry_out)\n    );\n\n    task measure_latency(input [31:0] start, input [31:0] end_time);\n        begin\n            $display(\"Latency = %t time units\", end_time - start);\n        end\n    endtask\n\n    \n    initial begin\n        \n        a = 32'b0;\n        b = 32'b0;\n        carry_in = 0;\n\n        start_time = $time;  \n        #10;\n        a = 32'b00000000000000000000000000000000;  \n        b = 32'b00000000000000000000000000000000;  \n        carry_in = 0;      \n        #10;\n        end_time = $time;  \n        measure_latency(start_time, end_time);  \n        $display(\"Test Case 1: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);\n\n        \n        start_time = $time;  \n        #10;\n        a = 32'h7FFFFFFF;  \n        b = 32'h7FFFFFFF;  \n        carry_in = 0;      \n        #10;\n        end_time = $time;  \n        measure_latency(start_time, end_time);  \n        $display(\"Test Case 2: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);       \n\n        // Insert the code for the remaining test stimulus here\n ```       ", "context": {}}, "output": {"response": "", "context": {"verif/tb_brent_kung_adder.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = baf774b3b971bdc4dc0756156ee03da1c42b4ba1\nTARGET = 80\n", "src/brent_kung_adder.sv": "module brent_kung_adder(\n    input  logic [31:0] a,\n    input  logic [31:0] b,\n    input  logic carry_in,\n    output logic [31:0] sum,\n    output logic carry_out\n);\n    logic [31:0] P1, G1;\n    logic [32:1] C;\n    logic [15:0] G2, P2;\n    logic [7:0] G3, P3;\n    logic [3:0] G4, P4;\n    logic [1:0] G5, P5;\n    logic G6, P6;\n    \n    assign P1 = a ^ b;\n    assign G1 = a & b;\n    \n    genvar i;\n    generate\n        for(i=0; i<=30; i=i+2) begin: second_stage  \n            assign G2[i/2] = G1[i+1] | (P1[i+1] & G1[i]);\n            assign P2[i/2] = P1[i+1] & P1[i];\n        end\n    endgenerate\n    \n    generate\n        for(i=0; i<=14; i=i+2) begin: third_stage   \n            assign G3[i/2] = G2[i+1] | (P2[i+1] & G2[i]);\n            assign P3[i/2] = P2[i+1] & P2[i];\n        end\n    endgenerate\n    \n    generate\n        for(i=0; i<=6; i=i+2) begin: fourth_stage  \n            assign G4[i/2] = G3[i+1] | (P3[i+1] & G3[i]);\n            assign P4[i/2] = P3[i+1] & P3[i];\n        end\n    endgenerate\n    \n    generate\n        for(i=0; i<=2; i=i+2) begin: fifth_stage  \n            assign G5[i/2] = G4[i+1] | (P4[i+1] & G4[i]);\n            assign P5[i/2] = P4[i+1] & P4[i];\n        end\n    endgenerate\n        \n    assign G6 = G5[1] | (P5[1] & G5[0]);\n    assign P6 = P5[1] & P5[0];\n       \n    assign C[1] = G1[0] | (P1[0] & carry_in);\n    assign C[2] = G2[0] | (P2[0] & carry_in);\n    assign C[4] = G3[0] | (P3[0] & carry_in);\n    assign C[8] = G4[0] | (P4[0] & carry_in);\n    assign C[16] = G5[0] | (P5[0] & carry_in);\n    assign C[32] = G6 | (P6 & carry_in);\n        \n    assign C[3] = G1[2] | (P1[2] & C[2]);\n    assign C[5] = G1[4] | (P1[4] & C[4]);\n    assign C[6] = G2[2] | (P2[2] & C[4]);\n    assign C[7] = G1[6] | (P1[6] & C[6]);\n    \n    assign C[9] = G1[8] | (P1[8] & C[8]);\n    assign C[10] = G2[4] | (P2[4] & C[8]);\n    assign C[11] = G1[10] | (P1[10] & C[10]);\n    assign C[12] = G3[2] | (P3[2] & C[8]);\n    assign C[13] = G1[12] | (P1[12] & C[12]);\n    assign C[14] = G2[6] | (P2[6] & C[12]);\n    assign C[15] = G1[14] | (P1[14] & C[14]);\n    \n    assign C[17] = G1[16] | (P1[16] & C[16]);\n    assign C[18] = G2[8] | (P2[8] & C[16]);\n    assign C[19] = G1[18] | (P1[18] & C[18]);\n    assign C[20] = G3[4] | (P3[4] & C[16]);\n    assign C[21] = G1[20] | (P1[20] & C[20]);\n    assign C[22] = G2[10] | (P2[10] & C[20]);\n    assign C[23] = G1[22] | (P1[22] & C[22]);\n    assign C[24] = G4[2] | (P4[2] & C[16]);\n    assign C[25] = G1[24] | (P1[24] & C[24]);\n    assign C[26] = G2[12] | (P2[12] & C[24]);\n    assign C[27] = G1[26] | (P1[26] & C[26]);\n    assign C[28] = G3[6] | (P3[6] & C[24]);\n    assign C[29] = G1[28] | (P1[28] & C[28]);\n    assign C[30] = G2[14] | (P2[14] & C[28]);\n    assign C[31] = G1[30] | (P1[30] & C[30]);\n        \n    assign sum = P1 ^ {C[31:1], carry_in};\n    assign carry_out = C[32];\n    \nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n        \n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_32_bit_Brent_Kung_PP_adder_0007", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the SystemVerilog testbench `tb_brent_kung_adder` to add the checker functionality to test the `brent_kung_adder` module. The testbench provided in the context already has a stimulus generator for many test cases. The purpose of the testbench checker is to verify the functionality of the Brent Kung Adder against the given design specification.\n\n## **Design Specification**:\nThe `brent_kung_adder` module implements a 32-bit adder using the Brent-Kung parallel prefix adder architecture. It performs efficient addition of two 32-bit numbers along with a carry-in signal and produces the resulting 32-bit sum and carry-out by going through a series of hierarchical stages. This adder module optimizes the carry propagation and offers better performance for high-speed arithmetic operations.\n\nThe `brent_kung_adder` module has the following interface:\n\n## Interface:\n###  Inputs:\n- `a (32-bit, [31:0])`: A 32-bit input representing the first operand in the addition operation.\n- `b (32-bit, [31:0])`: A 32-bit input representing the second operand in the addition operation.\n- `carry_in (1-bit)`: The input carry bit that is added to the sum. This can be used to perform multi-bit additions.\n\n### Outputs:\n- `sum (32-bit, [31:0])`: The 32-bit sum output after performing the addition of inputs `a`, `b`, and `carry_in`.\n- `carry_out (1-bit)`: The output carry bit that indicates if a carry has been generated during the addition operation.\n\n## Module Functionality: \nThe brent_kung_adder implements the Brent-Kung parallel prefix structure to efficiently calculate carries and sums. It divides the addition into multiple stages where:\n- The first stage generates the propagate and generate signals (P1 and G1).\n- The subsequent stages compute the higher-level propagate and generate signals by recursively combining the results from the previous stage.\n- The carry signals (C[1] to C[32]) are calculated based on the propagate and generate signals.\n- The sum is then computed by XOR'ing the propagate signals with the carry signals.\n- The carry-out is determined by the final carry signal (C[32]).\n\n## Edge Cases and Stress Testing:\n- The testbench includes edge cases such as adding large values, performing overflows, and handling carry-in and carry-out operations.\n- Stress testing involves adding random values to test the correctness of the adder.\n\n## **Checker Requirements**:\n### **Validation Logic** :\n- Implement task (`check_results`)  that compares the actual output against expected results.\n   - Checking operation: (`sum == expected_sum` && `carry_out == expected_carry_out`).\n- Display results (pass/fail) for each test case. \n- Provide and error messages when they actual outputs and expected outputs do not match.\n\n## Deliverables:\nProvide a complete SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `brent_kung_adder` module.", "context": {"verif/tb_brent_kung_adder.sv": "module tb_brent_kung_adder;\n\n    \n    logic [31:0] a;\n    logic [31:0] b;\n    logic carry_in;\n    logic [31:0] sum;\n    logic carry_out;\n    logic [31:0] start_time;\n    logic [31:0] end_time; \n    \n    brent_kung_adder uut (\n        .a(a),\n        .b(b),\n        .carry_in(carry_in),\n        .sum(sum),\n        .carry_out(carry_out)\n    );\n\n    task measure_latency(input [31:0] start, input [31:0] end_time);\n        begin\n            $display(\"Latency = %t time units\", end_time - start);\n        end\n    endtask\n\n    \n    initial begin\n        \n        a = 32'b0;\n        b = 32'b0;\n        carry_in = 0;\n\n        start_time = $time;  \n        #10;\n        a = 32'b00000000000000000000000000000000;  \n        b = 32'b00000000000000000000000000000000;  \n        carry_in = 0;      \n        #10;\n        end_time = $time;  \n        measure_latency(start_time, end_time);  \n        $display(\"Test Case 1: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);\n\n        \n        start_time = $time;  \n        #10;\n        a = 32'h7FFFFFFF;  \n        b = 32'h7FFFFFFF;  \n        carry_in = 0;      \n        #10;\n        end_time = $time;  \n        measure_latency(start_time, end_time);  \n        $display(\"Test Case 2: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);\n\n        \n        start_time = $time;  \n        #10;\n        a = 32'h80000000;  \n        b = 32'h80000000;  \n        carry_in = 0;      \n        #10;\n        end_time = $time;  \n        measure_latency(start_time, end_time);  \n        $display(\"Test Case 3: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);\n\n        \n        start_time = $time;  \n        #10;\n        a = 32'h0000FFFF;  \n        b = 32'hFFFF0000;  \n        carry_in = 0;      \n        #10;\n        end_time = $time;  \n        measure_latency(start_time, end_time);  \n        $display(\"Test Case 4: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);\n\n        \n        start_time = $time;  \n        #10;\n        a = 32'hFFFFFFFF;  \n        b = 32'hFFFFFFFF;  \n        carry_in = 1;      \n        #10;\n        end_time = $time;  \n        measure_latency(start_time, end_time);  \n        $display(\"Test Case 5: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);\n\n        \n        start_time = $time;  \n        #10;\n        a = 32'h55555555;  \n        b = 32'hAAAAAAAA;  \n        carry_in = 0;      \n        #10;\n        end_time = $time;  \n        measure_latency(start_time, end_time);  \n        $display(\"Test Case 6: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);\n\n        \n        start_time = $time;  \n        #10;\n        a = 32'hA1B2C3D4;  \n        b = 32'h4D3C2B1A;  \n        carry_in = 1;      \n        #10;\n        end_time = $time;  \n        measure_latency(start_time, end_time);  \n        $display(\"Test Case 7: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);\n\n        \n        start_time = $time;  \n        #10;\n        a = 32'hF0F0F0F0;  \n        b = 32'h0F0F0F0F;  \n        carry_in = 0;      \n        #10;\n        end_time = $time;  \n        measure_latency(start_time, end_time);  \n        $display(\"Test Case 8: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);\n\n        \n        start_time = $time;  \n        #10;\n        a = 32'h12345678;  \n        b = 32'h87654321;  \n        carry_in = 1;      \n        #10;\n        end_time = $time;  \n        measure_latency(start_time, end_time);  \n        $display(\"Test Case 9: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);\n\n        \n        start_time = $time;  \n        #10;\n        a = 32'hDEADBEEF;  \n        b = 32'hC0FFEE00;  \n        carry_in = 0;      \n        #10;\n        end_time = $time;  \n        measure_latency(start_time, end_time);  \n        $display(\"Test Case 10: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);\n        \n        \n        start_time = $time;\n        #10;\n        a = 32'h11111111;  \n        b = 32'h22222222;  \n        carry_in = 1;     \n        #10;\n        end_time = $time;\n        measure_latency(start_time, end_time);\n        $display(\"Test Case 11: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);\n\n        \n        start_time = $time;\n        #10;\n        a = 32'h00000001;  \n        b = 32'h00000001;  \n        carry_in = 1;     \n        #10;\n        end_time = $time;\n        measure_latency(start_time, end_time);\n        $display(\"Test Case 12: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);\n        $finish;\n        \n    end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_brent_kung_adder.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 4c95a13f9d52ddd98b207729c240aab3260f801f\nNUM_BUGS        = 10\n", "src/brent_kung_adder.sv": "module brent_kung_adder(\n    input  logic [31:0] a,\n    input  logic [31:0] b,\n    input  logic carry_in,\n    output logic [31:0] sum,\n    output logic carry_out\n);\n    logic [31:0] P1, G1;\n    logic [32:1] C;\n    logic [15:0] G2, P2;\n    logic [7:0] G3, P3;\n    logic [3:0] G4, P4;\n    logic [1:0] G5, P5;\n    logic G6, P6;\n    \n    assign P1 = a ^ b;\n    assign G1 = a & b;\n    \n    \n    `ifdef BUG_0\n      initial begin\n        $display(\"BUG_0 is ACTIVE\");\n      end\n    `else\n      initial begin\n       $display(\"BUG_0 is NOT ACTIVE\");\n      end\n     `endif\n\n    `ifdef BUG_1\n      initial begin\n        $display(\"BUG_1 is ACTIVE\");\n      end\n    `else\n      initial begin\n        $display(\"BUG_1 is NOT ACTIVE\");\n      end\n    `endif\n    \n    `ifdef BUG_2\n      initial begin\n        $display(\"BUG_2 is ACTIVE\");\n      end\n    `else\n      initial begin\n        $display(\"BUG_2 is NOT ACTIVE\");\n      end\n    `endif\n    \n    `ifdef BUG_3\n      initial begin\n        $display(\"BUG_3 is ACTIVE\");\n      end\n    `else\n      initial begin\n        $display(\"BUG_3 is NOT ACTIVE\");\n      end\n    `endif\n    \n    `ifdef BUG_4\n      initial begin\n        $display(\"BUG_4 is ACTIVE\");\n      end\n    `else\n      initial begin\n        $display(\"BUG_4 is NOT ACTIVE\");\n      end\n    `endif\n    \n    `ifdef BUG_5\n      initial begin\n        $display(\"BUG_5 is ACTIVE\");\n      end\n    `else\n      initial begin\n        $display(\"BUG_5 is NOT ACTIVE\");\n      end\n    `endif\n    \n    `ifdef BUG_6\n      initial begin\n        $display(\"BUG_6 is ACTIVE\");\n      end\n    `else\n      initial begin\n        $display(\"BUG_6 is NOT ACTIVE\");\n      end\n    `endif\n    \n    `ifdef BUG_7\n      initial begin\n        $display(\"BUG_7 is ACTIVE\");\n      end\n    `else\n      initial begin\n        $display(\"BUG_7 is NOT ACTIVE\");\n      end\n    `endif\n    \n    `ifdef BUG_8\n      initial begin\n        $display(\"BUG_8 is ACTIVE\");\n      end\n    `else\n      initial begin\n        $display(\"BUG_8 is NOT ACTIVE\");\n      end\n    `endif\n    \n    `ifdef BUG_9\n      initial begin\n        $display(\"BUG_9 is ACTIVE\");\n      end\n    `else\n      initial begin\n        $display(\"BUG_9 is NOT ACTIVE\");\n      end\n    `endif\n    \n    genvar i;\n    `ifndef BUG_0\n     generate\n        for(i=0; i<=30; i=i+2) begin: second_stage  \n            assign G2[i/2] = G1[i+1] | (P1[i+1] & G1[i]);\n            assign P2[i/2] = P1[i+1] & P1[i];\n        end\n     endgenerate\n    `else\n      generate\n        for(i=0; i<=30; i=i+2) begin: second_stage  \n            assign G2[i/2] = G1[0] | (P1[0] & G1[0]);\n            assign P2[i/2] = P1[0] & P1[0];\n        end\n      endgenerate\n    `endif\n    \n    `ifndef BUG_1\n     generate\n        for(i=0; i<=14; i=i+2) begin: third_stage   \n            assign G3[i/2] = G2[i+1] | (P2[i+1] & G2[i]);\n            assign P3[i/2] = P2[i+1] & P2[i];\n        end\n     endgenerate\n    `else\n     generate\n        for(i=0; i<=14; i=i+2) begin: third_stage   \n            assign G3[i/2] = G2[1] | (P2[1] & G2[1]);\n            assign P3[i/2] = P2[1] & P2[1];\n        end\n     endgenerate\n    `endif\n    \n    `ifndef BUG_2\n     generate\n        for(i=0; i<=6; i=i+2) begin: fourth_stage  \n            assign G4[i/2] = G3[i+1] | (P3[i+1] & G3[i]);\n            assign P4[i/2] = P3[i+1] & P3[i];\n        end\n     endgenerate\n    `else\n      generate\n        for(i=0; i<=6; i=i+2) begin: fourth_stage  \n            assign G4[i/2] = G3[2] | (P3[2] & G3[2]);\n            assign P4[i/2] = P3[2] & P3[2];\n        end\n     endgenerate\n    `endif\n    \n    `ifndef BUG_3\n     generate\n        for(i=0; i<=2; i=i+2) begin: fifth_stage  \n            assign G5[i/2] = G4[i+1] | (P4[i+1] & G4[i]);\n            assign P5[i/2] = P4[i+1] & P4[i];\n        end\n     endgenerate\n    `else\n     generate\n        for(i=0; i<=2; i=i+2) begin: fifth_stage  \n            assign G5[i/2] = G4[1] | (P4[1] & G4[1]);\n            assign P5[i/2] = P4[1] & P4[1];\n        end\n     endgenerate\n    `endif\n    \n    `ifndef BUG_4    \n      assign G6 = G5[1] | (P5[1] & G5[0]);\n      assign P6 = P5[1] & P5[0];\n    `else\n      assign G6 = G5[0] | (P5[0] & G5[0]);\n      assign P6 = P5[1] ;//& P5[0];\n     `endif\n     \n    `ifndef BUG_5   \n      assign C[1] = G1[0] | (P1[0] & carry_in);\n      assign C[2] = G2[0] | (P2[0] & carry_in);\n      assign C[4] = G3[0] | (P3[0] & carry_in);\n      assign C[8] = G4[0] | (P4[0] & carry_in);\n      assign C[16] = G5[0] | (P5[0] & carry_in);\n      assign C[32] = G6 | (P6 & carry_in);\n    `else\n      assign C[1] = G1[0] | (P1[0]);\n      assign C[2] = G2[0] | (P2[0]);\n      assign C[4] = G3[0] | (P3[0]);\n      assign C[8] = G4[0] | (P4[0]);\n      assign C[16] = G5[0] | (P5[0]);\n      assign C[32] = G6 | P6;\n     `endif\n    \n     `ifndef BUG_6    \n       assign C[3] = G1[2] | (P1[2] & C[2]);\n       assign C[5] = G1[4] | (P1[4] & C[4]);\n       assign C[6] = G2[2] | (P2[2] & C[4]);\n       assign C[7] = G1[6] | (P1[6] & C[6]);\n      `else\n       assign C[3] = G1[2] | (P1[2] & C[2]);\n       assign C[5] = G1[2] | (P1[2] & C[2]);\n       assign C[6] = G2[2] | (P2[2] & C[2]);\n       assign C[7] = G1[2] | (P1[2] & C[2]);\n       `endif\n       \n       `ifndef BUG_7\n         assign C[9] = G1[8] | (P1[8] & C[8]);\n         assign C[10] = G2[4] | (P2[4] & C[8]);\n         assign C[11] = G1[10] | (P1[10] & C[10]);\n         assign C[12] = G3[2] | (P3[2] & C[8]);\n         assign C[13] = G1[12] | (P1[12] & C[12]);\n         assign C[14] = G2[6] | (P2[6] & C[12]);\n         assign C[15] = G1[14] | (P1[14] & C[14]);\n        `else\n         assign C[9] = G1[0] | (P1[0] & C[0]);\n         assign C[10] = G2[0] | (P2[0] & C[0]);\n         assign C[11] = G1[0] | (P1[0] & C[0]);\n         assign C[12] = G3[0] | (P3[0] & C[0]);\n         assign C[13] = G1[0] | (P1[0] & C[0]);\n         assign C[14] = G2[0] | (P2[0] & C[0]);\n         assign C[15] = G1[0] | (P1[0] & C[0]);\n         `endif\n         \n         `ifndef BUG_8 \n           assign C[17] = G1[16] | (P1[16] & C[16]);\n           assign C[18] = G2[8] | (P2[8] & C[16]);\n           assign C[19] = G1[18] | (P1[18] & C[18]);\n           assign C[20] = G3[4] | (P3[4] & C[16]);\n           assign C[21] = G1[20] | (P1[20] & C[20]);\n           assign C[22] = G2[10] | (P2[10] & C[20]);\n           assign C[23] = G1[22] | (P1[22] & C[22]);\n           assign C[24] = G4[2] | (P4[2] & C[16]);\n           assign C[25] = G1[24] | (P1[24] & C[24]);\n           assign C[26] = G2[12] | (P2[12] & C[24]);\n           assign C[27] = G1[26] | (P1[26] & C[26]);\n           assign C[28] = G3[6] | (P3[6] & C[24]);\n           assign C[29] = G1[28] | (P1[28] & C[28]);\n           assign C[30] = G2[14] | (P2[14] & C[28]);\n           assign C[31] = G1[30] | (P1[30] & C[30]);\n          `else\n           assign C[17] = G1[16] | (P1[16] & C[16]);\n           assign C[18] = G2[8] | (P2[8] & C[8]);\n           assign C[19] = G1[18] | (P1[18] & C[18]);\n           assign C[20] = G3[16] | (P3[16] & C[16]);\n           assign C[21] = G1[20] | (P1[20] & C[20]);\n           assign C[22] = G2[10] | (P2[20] & C[20]);\n           assign C[23] = G1[22] | (P1[22] & C[22]);\n           assign C[24] = G4[2] | (P4[1] & C[16]);\n           assign C[25] = G1[24] | (P1[24] & C[24]);\n           assign C[26] = G2[12] | (P2[24] & C[24]);\n           assign C[27] = G1[26] | (P1[26] & C[26]);\n           assign C[28] = G3[6] | (P3[24] & C[24]);\n           assign C[29] = G1[28] | (P1[28] & C[28]);\n           assign C[30] = G2[14] | (P2[7] & C[28]);\n           assign C[31] = G1[30] | (P1[30] & C[30]);\n           `endif\n           \n           \n           `ifndef BUG_9\n             assign sum = P1 ^ {C[31:1], carry_in};\n             assign carry_out = C[32];\n            `else\n             assign sum = P1 | {C[26:1], carry_in};\n             assign carry_out = C[30];\n            `endif\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_32_bit_Brent_Kung_PP_adder_0008", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the Brent-Kung Adder (brent_kung_adder) to ensure its correct functionality during simulation? The assertion should specifically cover the sum and carry out signal validation. This assertion should display error messages when the following condition is violated during simulation:\n\n**Sum and Carry-Out Validation**: \nEnsure that the sum and carry-out signals are correctly calculated as the bitwise sum of `a`, `b`, and `carry_in`. If the result is incorrect, an error message should be displayed.\n\nFollowing should be the interface of the RTL design of Brent Kung Adder module named `brent_kung_adder`.\n## Interface:\n### **Inputs**:\n`clk(1-bit)`: Posedge clk for executing assertion.\n`a(32-bit,[31:0])`: First 32-bit operand or augend of the `brent_kung` adder.\n`b(32-bit,[31:0])`: Second 32-bit operand or addend of the `brent_kung` adder.\n`carry_in(1-bit)` : Input carry of the `brent_kung` adder.\n\n### **Outputs**:\n`sum(32-bit,[31:0])` : 32-bit sum generated by the `brent_kung` adder.\n`carry_out(1-bit)`: Output carry bit generated from the most significant bit of the addition operation.\n", "context": {"rtl/brent_kung_adder.sv": "module brent_kung_adder(\n    input  logic [31:0] a,\n    input  logic [31:0] b,\n    input  logic carry_in,\n    output logic [31:0] sum,\n    output logic carry_out\n);\n    logic [31:0] P1, G1;\n    logic [32:1] C;\n    logic [15:0] G2, P2;\n    logic [7:0] G3, P3;\n    logic [3:0] G4, P4;\n    logic [1:0] G5, P5;\n    logic G6, P6;\n    \n    assign P1 = a ^ b;\n    assign G1 = a & b;\n    \n    genvar i;\n    generate\n        for(i=0; i<=30; i=i+2) begin: second_stage  \n            assign G2[i/2] = G1[i+1] | (P1[i+1] & G1[i]);\n            assign P2[i/2] = P1[i+1] & P1[i];\n        end\n    endgenerate\n    \n    generate\n        for(i=0; i<=14; i=i+2) begin: third_stage   \n            assign G3[i/2] = G2[i+1] | (P2[i+1] & G2[i]);\n            assign P3[i/2] = P2[i+1] & P2[i];\n        end\n    endgenerate\n    \n    generate\n        for(i=0; i<=6; i=i+2) begin: fourth_stage  \n            assign G4[i/2] = G3[i+1] | (P3[i+1] & G3[i]);\n            assign P4[i/2] = P3[i+1] & P3[i];\n        end\n    endgenerate\n    \n    generate\n        for(i=0; i<=2; i=i+2) begin: fifth_stage  \n            assign G5[i/2] = G4[i+1] | (P4[i+1] & G4[i]);\n            assign P5[i/2] = P4[i+1] & P4[i];\n        end\n    endgenerate\n        \n    assign G6 = G5[1] | (P5[1] & G5[0]);\n    assign P6 = P5[1] & P5[0];\n       \n    assign C[1] = G1[0] | (P1[0] & carry_in);\n    assign C[2] = G2[0] | (P2[0] & carry_in);\n    assign C[4] = G3[0] | (P3[0] & carry_in);\n    assign C[8] = G4[0] | (P4[0] & carry_in);\n    assign C[16] = G5[0] | (P5[0] & carry_in);\n    assign C[32] = G6 | (P6 & carry_in);\n        \n    assign C[3] = G1[2] | (P1[2] & C[2]);\n    assign C[5] = G1[4] | (P1[4] & C[4]);\n    assign C[6] = G2[2] | (P2[2] & C[4]);\n    assign C[7] = G1[6] | (P1[6] & C[6]);\n    \n    assign C[9] = G1[8] | (P1[8] & C[8]);\n    assign C[10] = G2[4] | (P2[4] & C[8]);\n    assign C[11] = G1[10] | (P1[10] & C[10]);\n    assign C[12] = G3[2] | (P3[2] & C[8]);\n    assign C[13] = G1[12] | (P1[12] & C[12]);\n    assign C[14] = G2[6] | (P2[6] & C[12]);\n    assign C[15] = G1[14] | (P1[14] & C[14]);\n    \n    assign C[17] = G1[16] | (P1[16] & C[16]);\n    assign C[18] = G2[8] | (P2[8] & C[16]);\n    assign C[19] = G1[18] | (P1[18] & C[18]);\n    assign C[20] = G3[4] | (P3[4] & C[16]);\n    assign C[21] = G1[20] | (P1[20] & C[20]);\n    assign C[22] = G2[10] | (P2[10] & C[20]);\n    assign C[23] = G1[22] | (P1[22] & C[22]);\n    assign C[24] = G4[2] | (P4[2] & C[16]);\n    assign C[25] = G1[24] | (P1[24] & C[24]);\n    assign C[26] = G2[12] | (P2[12] & C[24]);\n    assign C[27] = G1[26] | (P1[26] & C[26]);\n    assign C[28] = G3[6] | (P3[6] & C[24]);\n    assign C[29] = G1[28] | (P1[28] & C[28]);\n    assign C[30] = G2[14] | (P2[14] & C[28]);\n    assign C[31] = G1[30] | (P1[30] & C[30]);\n        \n    assign sum = P1 ^ {C[31:1], carry_in};\n    assign carry_out = C[32];\n    \nendmodule"}}, "output": {"response": "", "context": {"rtl/brent_kung_adder.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/brent_kung_adder.sv\nTOPLEVEL        = brent_kung_adder\nMODULE          = test_brent_kung_adder\nPYTHONPATH      = /src\nHASH            = 8-brent_kung_adder_tb_assertion_generation_issue\n", "src/test_brent_kung_adder.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.regression import TestFactory\nfrom cocotb.triggers import Timer\nfrom random import randint\n\n# Cocotb testbench for Brent-Kung Adder\n@cocotb.test()\nasync def test_brent_kung_adder(dut):\n    \"\"\"Test the 32-bit Brent-Kung Adder for different input cases.\"\"\"\n    dut.clk.value = 0\n      \n       \n    # Clock generation\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    # Define the test vectors based on the SystemVerilog run_test_case task\n    test_vectors = [\n        (0x00000000, 0x00000000, 0, 0x00000000, 0, \"Test Case 1: Zero inputs\"),\n        (0x7FFFFFFF, 0x7FFFFFFF, 0, 0xFFFFFFFE, 0, \"Test Case 2: Large positive numbers with no carry\"),\n        (0x80000000, 0x80000000, 0, 0x00000000, 1, \"Test Case 3: Adding two large negative numbers, carry-out expected\"),\n        (0x0000FFFF, 0xFFFF0000, 0, 0xFFFFFFFF, 0, \"Test Case 4: Numbers with different magnitudes\"),\n        (0xFFFFFFFF, 0xFFFFFFFF, 1, 0xFFFFFFFF, 1, \"Test Case 5: Large numbers with carry-in\"),\n        (0x55555555, 0xAAAAAAAA, 0, 0xFFFFFFFF, 0, \"Test Case 6: Alternating 1's and 0's, no carry-in\"),\n        (0xA1B2C3D4, 0x4D3C2B1A, 1, 0xEEEEEEEF, 0, \"Test Case 7: Random values with carry-in\"),\n        (0xF0F0F0F0, 0x0F0F0F0F, 0, 0xFFFFFFFF, 0, \"Test Case 8: Large hexadecimal numbers\"),\n        (0x12345678, 0x87654321, 1, 0x9999999A, 0, \"Test Case 9: Random edge case with carry-in\"),\n        (0xDEADBEEF, 0xC0FFEE00, 0, 0x9FADACEF, 1, \"Test Case 10: Random edge case, carry-out expected\"),\n        (0x11111111, 0x22222222, 1, 0x33333334, 0, \"Test Case 11: Simple increasing values with carry-in\"),\n        (0x00000001, 0x00000001, 1, 0x00000003, 0, \"Test Case 12: Smallest non-zero inputs with carry-in\"),\n    ]\n\n    # Iterate through the test vectors and apply them to the DUT\n    for a, b, carry_in, expected_sum, expected_carry_out, case_name in test_vectors:\n        # Apply inputs\n        dut.a.value = a\n        dut.b.value = b\n        dut.carry_in.value = carry_in\n        \n        # Wait for the DUT to process the inputs\n        await Timer(10, units=\"ns\")\n\n        # Capture the outputs\n        actual_sum = dut.sum.value\n        actual_carry_out = dut.carry_out.value\n\n        # Convert `LogicArray` to integer for correct formatting\n        actual_sum_int = int(actual_sum)\n        actual_carry_out_int = int(actual_carry_out)\n\n        # Log the test case details\n        dut._log.info(f\"Running test case: {case_name}\")\n        dut._log.info(f\"a: {a:08X}, b: {b:08X}, carry_in: {carry_in}\")\n        dut._log.info(f\"Expected Sum: {expected_sum:08X}, Actual Sum: {actual_sum_int:08X}\")\n        dut._log.info(f\"Expected Carry Out: {expected_carry_out}, Actual Carry Out: {actual_carry_out_int}\")\n\n        # Assertions to check if outputs match expectations\n        assert actual_sum_int == expected_sum, f\"{case_name} - Sum Mismatch: Expected {expected_sum:08X}, Got {actual_sum_int:08X}\"\n        assert actual_carry_out_int == expected_carry_out, f\"{case_name} - Carry Out Mismatch: Expected {expected_carry_out}, Got {actual_carry_out_int}\"\n\n        # Wait for a short time before the next test case\n        await Timer(10, units=\"ns\")\n\n    # Additional random test cases\n    num_random_tests = 10  # Number of random tests to generate\n    for i in range(num_random_tests):\n        # Generate random values for a, b, and carry_in\n        a = randint(0, 0xFFFFFFFF)\n        b = randint(0, 0xFFFFFFFF)\n        carry_in = randint(0, 1)\n\n        # Apply inputs\n        dut.a.value = a\n        dut.b.value = b\n        dut.carry_in.value = carry_in\n\n        # Wait for the DUT to process the inputs\n        await Timer(10, units=\"ns\")\n\n        # Capture the outputs\n        actual_sum = dut.sum.value\n        actual_carry_out = dut.carry_out.value\n        \n        # Convert `LogicArray` to integer for correct formatting\n        actual_sum_int = int(actual_sum)\n        actual_carry_out_int = int(actual_carry_out)\n\n        # Log the random test case details\n        dut._log.info(f\"Random Test Case {i + 1}\")\n        dut._log.info(f\"a: {a:08X}, b: {b:08X}, carry_in: {carry_in}\")\n        dut._log.info(f\"sum: {actual_sum_int:08X}, carry_out: {actual_carry_out_int}\")\n\n               \n        # Wait for a short time before the next random test case\n        await Timer(10, units=\"ns\")\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_64b66b_decoder_0016", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the existing SystemVerilog testbench to include checker generation logic for verifying the functionality of the `decoder_64b66b` module. The testbench already contains a `stimulus_generator` to drive the input signals. The modified testbench should integrate a `checker_generator` module to validate the `decoder_64b66b` module against the given design specification.\n\n### **Design Specification:**\nThe `decoder_64b66b` module decodes 66-bit encoded input data (`decoder_data_in`) into 64-bit output data (`decoder_data_out`) and 8-bit control output (`decoder_control_out`). The module supports two modes of operation based on the sync header:\n1. **Data-only mode (`2'b01`):** The input is treated as data, and the output is the 64-bit data portion of the input.\n2. **Control-only mode (`2'b10`):** The input is treated as control, and the type field and the predefined control characters determine the output.\n\nThe module also handles error detection:\n- **`sync_error`:** Asserted when the sync header is invalid (`2'b00` or `2'b11`).\n- **`decoder_error_out`:** Asserted when the type field is invalid or the decoded data does not match the expected pattern.\n\n### **Sync Header Definition**  \n\nThe **sync header** (`sync_header`) is the first 2 bits of `decoder_data_in` and determines the mode of operation:  \n\n| **Sync Header** | **Mode**                             |\n|-----------------|--------------------------------------|\n| `2'b01`         | **Data-only mode**                   |\n| `2'b10`         | **Control-only mode**                |\n| `2'b00`         | **Invalid sync header** (sync error) |\n| `2'b11`         | **Invalid sync header** (sync error) |\n\n### **Control Characters**\n\n   - The module uses specific control characters to represent special signals in the decoded data. These control characters are defined as follows:\n\n| **Control Character** | **Value** |\n|-----------------------|-----------|\n| `/I/` (Idle)          | `0x07`    |\n| `/S/` (Start of Frame)| `0xFB`    |\n| `/T/` (End of Frame)  | `0xFD`    |\n| `/E/` (Error)         | `0xFE`    |\n| `/Q/` (Ordered Set)   | `0x9C`    |\n\n   - These control characters are inserted into the decoded data output based on the type field and sync header.\n\n### **Type Field Definition**  \n\nThe **type field** (`type_field`) is the next 8 bits of `decoder_data_in`, which determines the control output and how the data is decoded.  \n\n|**Type Field**| **decoder_control_out**  | **decoder_data_out**              |\n|--------------|--------------------------|-----------------------------------|\n| `0x1E`       | `8'b11111111`            | `{E7, E6, E5, E4, E3, E2, E1, E0}`|\n| `0x33`       | `8'b00011111`            | `{D6, D5, D4, S4, I3, I2, I1, I0}`|\n| `0x78`       | `8'b00000001`            | `{D6, D5, D4, D3, D2, D1, D0, S0}`|\n| `0x87`       | `8'b11111110`            | `{I7, I6, I5, I4, I3, I2, I1, T0}`|\n| `0x99`       | `8'b11111110`            | `{I7, I6, I5, I4, I3, I2, T1, D0}`|\n| `0xAA`       | `8'b11111100`            | `{I7, I6, I5, I4, I3, T2, D1, D0}`|\n| `0xB4`       | `8'b11111000`            | `{I7, I6, I5, I4, T3, D2, D1, D0}`|\n| `0xCC`       | `8'b11110000`            | `{I7, I6, I5, T4, D3, D2, D1, D0}`|\n| `0xD2`       | `8'b11100000`            | `{I7, I6, T5, D4, D3, D2, D1, D0}`|\n| `0xE1`       | `8'b11000000`            | `{I7, T6, D5, D4, D3, D2, D1, D0}`|\n| `0xFF`       | `8'b10000000`            | `{T7, D6, D5, D4, D3, D2, D1, D0}`|\n\n### **Testbench Requirements:**\n1. **Testbench Components:**\n   - **Input Signals:** Drive `clk_in`, `rst_in`, `decoder_data_valid_in`, and `decoder_data_in` with various test cases.\n   - **Output Validation:** Monitor and validate the `decoder_data_out`, `decoder_control_out`, `sync_error`, and `decoder_error_out` outputs against expected behavior.\n   - **Stimulus Generator:** Implement a stimulus generation logic to drive various test vectors to the UUT.\n   - **Checker Generator:** Implement a checker logic to verify the correctness of the outputs based on the input `decoder_data_in`.\n\n2. **Checker Logic:**\n   - Implement reference logic to calculate the expected `decoder_data_out` and `decoder_control_out` for a given `decoder_data_in`.\n   - Compare the DUT outputs (`decoder_data_out`, `decoder_control_out`, `sync_error`, and `decoder_error_out`) with the calculated expected outputs.\n   - Log errors if the outputs do not match the expected behavior.\n   - Print success messages for passing test cases.\n\n3. **Functionality:**\n   - Test the following scenarios:\n     - **Data-only mode:** Verify decoding of valid data inputs.\n     - **Control-only mode:** Verify decoding of valid control inputs with various type fields.\n     - **Invalid sync header:** Verify detection of invalid sync headers (`2'b00` or `2'b11`).\n     - **Invalid type field:** Verify detection of invalid type fields in control-only mode.\n     - **Invalid data patterns:** Verify detection of invalid data patterns in control-only mode.\n   - Include edge cases such as:\n     - Reset behavior.\n     - Continuous input streams with mixed data and control modes.\n     - Random input sequences.\n\n4. **Verification:**\n   - Drive `decoder_data_in` and monitor the outputs using the checker logic.\n   - Compare the actual outputs with the expected outputs.\n   - Log results (pass/fail) for each test case.\n\n5. **Simulation:**\n   - Display pass/fail results for each test case.\n   - Complete the simulation once all test cases are verified.\n\n### **Deliverables:**\nProvide a complete SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `decoder_64b66b` module. The testbench should include:\n- A test sequence generator to create input patterns.\n- A checker logic module to validate the outputs.\n- Proper clock generation and reset handling.\n- Logging of test results for each test case.\n\n### **Example Test Cases:**\n**1. Data-only mode:**\n   - Input: `decoder_data_in = {2'b01, 64'hA5A5A5A5A5A5A5A5}`.\n   - Expected Output: `decoder_data_out = 64'hA5A5A5A5A5A5A5A5`, `decoder_control_out = 8'b0`, `sync_error = 0`, `decoder_error_out = 0`.\n\n**2. Control-only mode (valid type field):**\n   - Input: `decoder_data_in = {2'b10, 8'h1E, 56'h1E1E1E1E1E1E1E1E}`.\n   - Expected Output: `decoder_data_out = {8{8'hFE}}`, `decoder_control_out = 8'b11111111`, `sync_error = 0`, `decoder_error_out = 0`.\n\n**3. Invalid sync header:**\n   - Input: `decoder_data_in = {2'b00, 64'h1E3456789ABCDEF0}`.\n   - Expected Output: `sync_error = 1`, `decoder_error_out = 0`.\n\n**4. Invalid type field:**\n   - Input: `decoder_data_in = {2'b10, 8'h77, 56'h3C78F1E3C78F1E3C}`.\n   - Expected Output: `decoder_error_out = 1`.\n\n**5. Invalid data pattern:**\n   - Input: `decoder_data_in = {2'b10, 8'h1E, 56'h123456789ABCDEF0}`.\n   - Expected Output: `decoder_error_out = 1`.\n\n### **Expected Output:**\n- The testbench should:\n  - Apply the input test cases one by one.\n  - Display each test case's comparison results (pass/fail), including detailed information for debugging.\n  - Complete the simulation once all test cases are verified.\n\n---\n\n### **Expected Behavior for Checker Logic:**\n1. **Reference Logic Implementation:**\n   - Use the sync header and type field to determine the expected `decoder_data_out` and `decoder_control_out`.\n   - For invalid sync headers or type fields, ensure the appropriate error flags (`sync_error` and `decoder_error_out`) are asserted.\n\n2. **Error Logging:**\n   - If the outputs do not match the expected behavior, log an error with the following details:\n     - Input values (`decoder_data_in`).\n     - Expected outputs (`decoder_data_out`, `decoder_control_out`, `sync_error`, `decoder_error_out`).\n     - Actual outputs.\n\n3. **Success Logging:**\n   - For passing test cases, log a success message with the same details as above.\n", "context": {"verif/tb_decoder_64b66b.sv": "module tb_decoder_64b66b;\n\n    localparam CLK_PERIOD = 10;\n\n    logic         clk_in;\n    logic         rst_in;\n    logic         decoder_data_valid_in;\n    logic [65:0]  decoder_data_in;\n    logic [63:0]  decoder_data_out;\n    logic [7:0]   decoder_control_out;\n    logic         sync_error;\n    logic         decoder_error_out;\n    logic         done;\n    logic         invalid_data_in;\n\n    decoder_64b66b uut (\n        .clk_in(clk_in),\n        .rst_in(rst_in),\n        .decoder_data_valid_in(decoder_data_valid_in),\n        .decoder_data_in(decoder_data_in),\n        .decoder_data_out(decoder_data_out),\n        .decoder_control_out(decoder_control_out),\n        .sync_error(sync_error),\n        .decoder_error_out(decoder_error_out)\n    );\n\n    stimulus_generator stim_gen (\n        .clk_in(clk_in),\n        .rst_in(rst_in),\n        .decoder_data_valid_in(decoder_data_valid_in),\n        .decoder_data_in(decoder_data_in),\n        .invalid_data_in(invalid_data_in),\n        .done(done)\n    );\n\n    initial begin\n        clk_in = 1;\n        forever #(CLK_PERIOD / 2) clk_in = ~clk_in;\n    end\n\n    initial begin\n        $dumpfile(\"decoder_64b66b.vcd\");\n        $dumpvars(0);\n    end\n\n    initial begin\n        logic [1:0] sync_header;\n        logic [63:0] data;\n\n        @(negedge rst_in);\n        @(posedge clk_in);\n        while (!done && !rst_in) begin\n            sync_header = decoder_data_in[65:64];\n            data = decoder_data_in[63:0];\n            @(posedge clk_in);\n            $display(\"Input: decoder_data_in = %h\", {sync_header, data});\n            $display(\"Output: decoder_data_out = %h, decoder_control_out = %h, sync_error = %b, decoder_error_out = %b\",\n                     decoder_data_out, decoder_control_out, sync_error, decoder_error_out);\n        end\n    end\n\nendmodule\n\nmodule stimulus_generator(\n    input  logic        clk_in,\n    output logic        rst_in,\n    output logic        decoder_data_valid_in,\n    output logic [65:0] decoder_data_in,\n    output logic        invalid_data_in,\n    output logic        done\n);\n\n    logic [1:0] sync_headers[0:3];\n\n    initial begin\n        sync_headers[0] = 2'b01;\n        sync_headers[1] = 2'b10;\n        sync_headers[2] = 2'b00;\n        sync_headers[3] = 2'b11;\n    end\n\n    task automatic generate_stimulus();\n        decoder_data_in       <= 66'b0;\n        invalid_data_in       <= 1'b0;\n        done                  <= 0;\n        decoder_data_valid_in <= 0;\n        rst_in                = 1'b1;\n        repeat (4) @(posedge clk_in);\n        rst_in                = 1'b0;\n\n        decoder_data_in       <= {2'b01, 64'hA5A5A5A5A5A5A5A5};\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 64'hFFFFFFFFFFFFFFFF};\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b11, 64'h123456789ABCDEF0};\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b00, 64'hFEDCBA9876543210};\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        for (int i = 0; i < 5; i++) begin\n            logic [63:0] random_data = $urandom;\n            decoder_data_in          <= {2'b01, random_data};\n            decoder_data_valid_in    <= 1;\n            @(posedge clk_in);\n        end\n\n        // test cases for control-only and mixed modes\n        generate_control_only_testcases();\n        generate_mixed_mode_testcases();\n        generate_mixed_mode_invalid_testcases();\n        generate_mixed_mode_invalid_type();\n        reset_check_state();\n\n        done                  <= 1;\n        decoder_data_valid_in <= 0;\n\n        @(posedge clk_in);\n        @(posedge clk_in);\n        @(posedge clk_in);\n        $display(\"All test cases completed. Ending simulation.\");\n        $finish;\n    endtask\n\n    task automatic generate_control_only_testcases();\n        // Control-only mode test cases\n        decoder_data_in       <= {2'b10, 8'h1E, {8{7'h00}}}; // All control characters\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h1E, {8{7'h1E}}};\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n    endtask\n\n    task automatic reset_check_state();\n        // Control-only mode test cases\n        decoder_data_in       <= 66'b0;\n        done                  <= 0;\n        decoder_data_valid_in <= 0;\n        rst_in                = 1'b1;\n        repeat (4) @(posedge clk_in);\n        rst_in                = 1'b0;\n        @(posedge clk_in);\n    endtask\n\n    task automatic generate_mixed_mode_testcases();\n        // Mixed mode test cases\n        decoder_data_in       <= {2'b10, 8'h33, 56'hddccbb00000000}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h78, 56'h3456789abcdef0}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h87, 56'h00000000000000}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h99, 56'h000000000000AE}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'hAA, 56'h0000000000A5A5}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'hB4, 56'h00000000FEED55}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'hCC, 56'h00000099887766}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'hD2, 56'h00001234567890}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'hE1, 56'h00FFEEDDCCBBAA}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'hFF, 56'h773388229911AA}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h55, 56'h070707FF070707}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h66, 56'h7777770FDEEDDE}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h4B, 56'h0000000ABCDEFF}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h2D, 56'hAAAAAAF0000000}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h1E, 56'h3c78f1e3c78f1e}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h1E, 56'h00000000000000}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n    endtask\n\n    task automatic generate_mixed_mode_invalid_testcases();\n        // Mixed mode test cases\n        invalid_data_in       <= 1'b1;\n        decoder_data_in       <= {2'b10, 8'h33, 56'hddccbb00000012}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h87, 56'h000000000000FF}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h99, 56'h0000000FF000AE}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'hAA, 56'hFF00000000A5A5}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'hB4, 56'hFF000000FEED55}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'hCC, 56'hAA000099887766}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'hD2, 56'hFE001234567890}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'hE1, 56'h11FFEEDDCCBBAA}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h55, 56'h07070700070707}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h66, 56'h77777711DEEDDE}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h4B, 56'h2200000ABCDE00}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h2D, 56'hAAAAAAF0000BC0}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h1E, 56'h1E1E1E00000000}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n\n        decoder_data_in       <= {2'b10, 8'h77, 56'h3c78f1e3c78f1e}; // Mixed mode example\n        decoder_data_valid_in <= 1;\n        @(posedge clk_in);\n    endtask\n\n    task automatic generate_mixed_mode_invalid_type();\n        decoder_data_in       <= {2'b10, 8'h77, 56'h3c78f1e3c78f1e}; // Mixed mode example\n        @(posedge clk_in);\n        decoder_data_valid_in <= 0;\n    endtask\n\n    initial begin\n        generate_stimulus();\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_decoder_64b66b.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = ed9dc3241a71d5afdba83088516bb8de5f2af048\nNUM_BUGS        = 6\n", "src/decoder_64b66b.sv": "module decoder_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic         decoder_data_valid_in, // Input data valid signal\n    input  logic [65:0]  decoder_data_in,     // 66-bit encoded input\n    output logic [63:0]  decoder_data_out,    // Decoded 64-bit data output\n    output logic [7:0]   decoder_control_out, // Decoded 8-bit control output\n    output logic         sync_error,          // Sync error flag\n    output logic         decoder_error_out    // Type field error flag\n);\n\n    logic [1:0] sync_header;\n    logic [7:0] type_field;\n    logic [55:0] data_in;\n    logic type_field_valid;\n    logic decoder_wrong_ctrl_received;\n    logic decoder_wrong_type_field;\n\n    `ifndef BUG_0\n    assign sync_header = decoder_data_in[65:64];\n    assign type_field = decoder_data_in[63:56];\n    assign data_in = decoder_data_in[55:0];\n    `else\n    assign sync_header = decoder_data_in[1:0];\n    assign type_field = decoder_data_in[15:8];\n    assign data_in = decoder_data_in[63:8];\n    `endif\n\n    always_comb begin\n        type_field_valid = 1'b0;\n        if (sync_header == 2'b10) begin\n            case (type_field)\n                8'h1E, 8'h33, 8'h78, 8'h87, 8'h99, 8'hAA, 8'hB4, \n                8'hCC, 8'hD2, 8'hE1, 8'hFF, 8'h2D, 8'h4B, 8'h55, 8'h66: \n                    type_field_valid = 1'b1;\n                default: type_field_valid = 1'b0;\n            endcase\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_control_out <= 8'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            if (sync_header == 2'b10) begin\n                case (type_field)\n                    8'h1E: decoder_control_out <= 8'b11111111;\n                    8'h33: decoder_control_out <= 8'b00011111;\n                    8'h78: decoder_control_out <= 8'b00000001;\n                    8'h87: decoder_control_out <= 8'b11111110;\n                    8'h99: decoder_control_out <= 8'b11111110;\n                    8'hAA: decoder_control_out <= 8'b11111100;\n                    8'hB4: decoder_control_out <= 8'b11111000;\n                    8'hCC: decoder_control_out <= 8'b11110000;\n                    8'hD2: decoder_control_out <= 8'b11100000;\n                    8'hE1: decoder_control_out <= 8'b11000000;\n                    8'hFF: decoder_control_out <= 8'b10000000;\n                    8'h2D: decoder_control_out <= 8'b00011111;\n                    8'h4B: decoder_control_out <= 8'b11110001;\n                    8'h55: decoder_control_out <= 8'b00010001;\n                    8'h66: decoder_control_out <= 8'b00010001;\n                    default: decoder_control_out <= 8'b0;\n                endcase\n            end\n            else begin\n                decoder_control_out <= 8'b0;\n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_data_out <= 64'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            case (sync_header)\n                2'b01: begin\n                    decoder_data_out <= decoder_data_in[63:0];\n                end\n                2'b10: begin\n                    case (type_field)\n\t             `ifndef BUG_1\n                        8'h1E: if (data_in[55:0] == {8{7'h1E}}) decoder_data_out <= {8{8'hFE}};\n                               else decoder_data_out <= {8{8'h07}};\n                        8'h33: decoder_data_out <= {data_in[55:32], 8'hFB, {4{8'h07}}};\n                        8'h78: decoder_data_out <= {data_in[55:0], 8'hFB};\n                        8'h87: decoder_data_out <= {{7{8'h07}},8'hFD};\n                        8'h99: decoder_data_out <= {{6{8'h07}}, 8'hFD, data_in[7:0]};\n                        8'hAA: decoder_data_out <= {{5{8'h07}}, 8'hFD, data_in[15:0]};\n                        8'hB4: decoder_data_out <= {{4{8'h07}}, 8'hFD, data_in[23:0]};\n\t\t     `else\n                        8'h1E: if (data_in[55:0] == {8{7'hEE}}) decoder_data_out <= {8{8'hEF}};\n                               else decoder_data_out <= {8{8'h77}};\n                        8'h33: decoder_data_out <= {data_in[23:0], 8'hFA, {4{8'h01}}};\n                        8'h78: decoder_data_out <= {data_in[55:0], 8'hFA};\n                        8'h87: decoder_data_out <= {{7{8'h17}},8'hFE};\n                        8'h99: decoder_data_out <= {{6{8'h00}}, 8'hFD, data_in[23:16]};\n                        8'hAA: decoder_data_out <= {{5{8'hFF}}, 8'hFD, data_in[15:0]};\n                        8'hB4: decoder_data_out <= {{4{8'hE7}}, 8'h0D, data_in[23:0]};\n\t\t     `endif\n                        8'hCC: decoder_data_out <= {{3{8'h07}}, 8'hFD, data_in[31:0]};\n                        8'hD2: decoder_data_out <= {{2{8'h07}}, 8'hFD, data_in[39:0]};\n                        8'hE1: decoder_data_out <= {8'h07, 8'hFD, data_in[47:0]};\n\t             `ifndef BUG_2\n                        8'hFF: decoder_data_out <= {8'hFD, data_in[55:0]};\n                        8'h2D: decoder_data_out <= {data_in[55:32], 8'h9C, {4{8'h07}}};\n                        8'h4B: decoder_data_out <= {{4{8'h07}}, data_in[28:5], 8'h9C};\n                        8'h55: decoder_data_out <= {data_in[55:32], 8'h9C, data_in[23:0], 8'h9C};\n                        8'h66: decoder_data_out <= {data_in[55:32], 8'hFB, data_in[23:0], 8'h9C};\n\t\t     `else\n                        8'hFF: decoder_data_out <= {8'hFA, data_in[55:0]};\n                        8'h2D: decoder_data_out <= {data_in[55:32], 8'h00, {4{8'h07}}};\n                        8'h4B: decoder_data_out <= {{4{8'h07}}, data_in[28:5], 8'h91};\n                        8'h55: decoder_data_out <= {data_in[55:32], 8'h9A, data_in[23:0], 8'hCC};\n                        8'h66: decoder_data_out <= {data_in[55:32], 8'hFF, data_in[23:0], 8'hED};\n\t\t     `endif\n                        default: decoder_data_out <= 64'b0;\n                    endcase\n                end\n                default: decoder_data_out <= 64'b0;\n            endcase\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_error <= 1'b0;\n        end \n        else if (decoder_data_valid_in) begin\n\t `ifndef BUG_3\n            sync_error <= (sync_header != 2'b01 && sync_header != 2'b10);\n         `else\n            sync_error <= (sync_header != 2'b00 && sync_header != 2'b11);\n         `endif\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_wrong_type_field <= 1'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            if (sync_header == 2'b10) begin\n\t `ifndef BUG_4\n                decoder_wrong_type_field <= ~type_field_valid;\n         `else\n                decoder_wrong_type_field <= 1'b1;\n         `endif\n            end\n            else begin\n                decoder_wrong_type_field <= 1'b0;\n            end\n        end\n    end\n    \n    assign decoder_error_out = decoder_wrong_ctrl_received || decoder_wrong_type_field;\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_wrong_ctrl_received <= 1'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            if (sync_header == 2'b10) begin\n                case (type_field)\n\t `ifndef BUG_5\n                    8'h1E: if ((data_in[55:0] == {8{7'h1E}}) || (data_in[55:0] == {8{7'h00}})) decoder_wrong_ctrl_received <= 1'b0;\n                           else decoder_wrong_ctrl_received <= 1'b1;\n                    8'h33: if (data_in [31:0] != 32'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h87: if (data_in [55:0] != 56'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h99: if (data_in [55:8] != 48'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hAA: if (data_in [55:16] != 40'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n         `else\n                    8'h1E: if ((data_in[55:0] == {8{7'h1E}}) || (data_in[55:0] == {8{7'h00}})) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h33: if (data_in [31:0] != 32'd0) decoder_wrong_ctrl_received <= 1'b0;\n                           else decoder_wrong_ctrl_received <= 1'b1;\n                    8'h87: if (data_in [55:0] != 56'd0) decoder_wrong_ctrl_received <= 1'b0;\n                           else decoder_wrong_ctrl_received <= 1'b1;\n                    8'h99: if (data_in [55:8] != 48'd0) decoder_wrong_ctrl_received <= 1'b0;\n                           else decoder_wrong_ctrl_received <= 1'b1;\n                    8'hAA: if (data_in [55:16] != 40'd0) decoder_wrong_ctrl_received <= 1'b0;\n                           else decoder_wrong_ctrl_received <= 1'b1;\n         `endif\n                    8'hB4: if (data_in [55:24] != 32'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hCC: if (data_in [55:32] != 24'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hD2: if (data_in [55:40] != 16'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hE1: if (data_in [55:48] != 8'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h2D: if (data_in [31:0] != 32'hF0000000) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h4B: if (data_in[55:28] != {4{7'h00}} && data_in[3:0] != 4'b1111) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;              \n                    8'h55: if (data_in[31:24] != 8'hFF) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0; \n                    8'h66: if (data_in[31:24] != 8'h0F) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0; \n                    default: decoder_wrong_ctrl_received <= 1'b0; \n                endcase\n            end\n            else begin\n                decoder_wrong_ctrl_received <= 1'b0;\n            end\n        end\n    end\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_64b66b_decoder_0020", "categories": ["cid014", "medium"], "input": {"prompt": "Create SystemVerilog Assertions to verify the **functional correctness** of the `decoder_64b66b` module. The properties should ensure that:  \n\n1. **Valid Sync Header**: The `sync_header` must be either `2'b01` or `2'b10` when `decoder_data_valid_in` is HIGH.  \n\n2. **Type Field Validity**: When the `sync_header` is `2'b10`, the `type_field` must be valid (i.e., match one of the predefined values).  \n\n3. **Control Output for Non-Data Sync**: The `decoder_control_out` must be `8'b0` when the `sync_header` is not `2'b10`.  \n\n4. **Control Output for Data Sync**: The `decoder_control_out` must be a **non-zero value** when the `sync_header` is `2'b10`.  \n\n5. **Type Field Stability**: The `type_field` must remain stable during valid sync (`sync_header == 2'b10`).  \n\nEach assertion must provide a **detailed failure message**, including the `sync_header`, `type_field`, and `decoder_control_out` where applicable, for debugging purposes.  \n\n---\n\n### RTL Specification  \n\n#### Module Name: `decoder_64b66b`  \n\n1. The module processes the 66-bit input data (`decoder_data_in`) based on the sync header and type field:\n   - The sync header (`sync_header`) is the first 2 bits of the input:\n     - `2'b01`: Data-only mode.\n     - `2'b10`: Control-only or mixed mode.\n   - The type field (`type_field`) is the next 8 bits of the input, which determines the control output and how the data is decoded.\n\n2. The module checks for:\n   - **Synchronization errors**: Invalid sync headers (neither `2'b01` nor `2'b10`).\n   - **Type field errors**: Invalid type fields (not in the predefined list of valid type fields).\n\n3. The outputs include:\n   - Decoded 64-bit data (`decoder_data_out`).\n   - Decoded 8-bit control (`decoder_control_out`).\n   - Error flags (`sync_error` and `decoder_error_out`).\n\n4. Latency:\n   - The module has a **1-cycle latency** for decoding and error checking.\n\n5. Control Characters:\n   - The module uses specific control characters to represent special signals in the decoded data. These control characters are defined as follows:\n\n     | **Control Character** | **Value** |\n     |-----------------------|-----------|\n     | `/I/` (Idle)          | `0x07`    |\n     | `/S/` (Start of Frame)| `0xFB`    |\n     | `/T/` (End of Frame)  | `0xFD`    |\n     | `/E/` (Error)         | `0xFE`    |\n     | `/Q/` (Ordered Set)   | `0x9C`    |\n\n   - These control characters are inserted into the decoded data output based on the type field and sync header.\n\n6. Decoder Table:\n   - The module uses a predefined mapping between the type field and the control output/decoded data output. The table below defines the behavior for each type of field:\n\n     | **Type Field** | **decoder_control_out**  | **decoder_data_out**              |\n     |----------------|--------------------------|-----------------------------------|\n     | `0x1E`         | `8'b11111111`            | `{E7, E6, E5, E4, E3, E2, E1, E0}`|\n     | `0x33`         | `8'b00011111`            | `{D6, D5, D4, S4, I3, I2, I1, I0}`|\n     | `0x78`         | `8'b00000001`            | `{D6, D5, D4, D3, D2, D1, D0, S0}`|\n     | `0x87`         | `8'b11111110`            | `{I7, I6, I5, I4, I3, I2, I1, T0}`|\n     | `0x99`         | `8'b11111110`            | `{I7, I6, I5, I4, I3, I2, T1, D0}`|\n     | `0xAA`         | `8'b11111100`            | `{I7, I6, I5, I4, I3, T2, D1, D0}`|\n     | `0xB4`         | `8'b11111000`            | `{I7, I6, I5, I4, T3, D2, D1, D0}`|\n     | `0xCC`         | `8'b11110000`            | `{I7, I6, I5, T4, D3, D2, D1, D0}`|\n     | `0xD2`         | `8'b11100000`            | `{I7, I6, T5, D4, D3, D2, D1, D0}`|\n     | `0xE1`         | `8'b11000000`            | `{I7, T6, D5, D4, D3, D2, D1, D0}`|\n     | `0xFF`         | `8'b10000000`            | `{T7, D6, D5, D4, D3, D2, D1, D0}`|\n     | `0x2D`         | `8'b00011111`            | `{D6, D5, D4, Q4, I3, I2, I1, I0}`|\n     | `0x4B`         | `8'b11110001`            | `{I7, I6, I5, I4, D2, D1, D0, Q0}`|\n     | `0x55`         | `8'b00010001`            | `{D6, D5, D4, Q4, D2, D1, D0, Q0}`|\n     | `0x66`         | `8'b00010001`            | `{D6, D5, D4, S4, D2, D1, D0, Q0}`|\n\n   - **Explanation**:\n     - `Dx`: Represents data bits from the input.\n     - `Ix`: Represents idle control characters (`/I/`).\n     - `Sx`: Represents start-of-frame control characters (`/S/`).\n     - `Tx`: Represents end-of-frame control characters (`/T/`).\n     - `Ex`: Represents error control characters (`/E/`).\n     - `Qx`: Represents ordered-set control characters (`/Q/`).\n\n#### IO Ports  \n\n| Port Name                    | Direction| Size       | Description                                        |\n|------------------------------|----------|------------|----------------------------------------------------|\n| `clk_in`                     | Input    | 1 bit      | Positive Edge triggered Clock signal               |\n| `rst_in`                     | Input    | 1 bit      | Asynchronous Active-high reset                     |\n| `decoder_data_valid_in`      | Input    | 1 bit      | Input data valid signal                            |\n| `decoder_data_in[65:0]`      | Input    | 66 bits    | 66-bit encoded input                               |\n| `decoder_data_out[63:0]`     | Output   | 64 bits    | Decoded 64-bit data output                         |\n| `decoder_control_out[7:0]`   | Output   | 8 bits     | Decoded 8-bit control output                       |\n| `sync_error`                 | Output   | 1 bit      | Sync error flag                                    |\n| `decoder_error_out`          | Output   | 1 bit      | Type field error flag                              |", "context": {"rtl/decoder_64b66b.sv": "module decoder_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic         decoder_data_valid_in, // Input data valid signal\n    input  logic [65:0]  decoder_data_in,     // 66-bit encoded input\n    output logic [63:0]  decoder_data_out,    // Decoded 64-bit data output\n    output logic [7:0]   decoder_control_out, // Decoded 8-bit control output\n    output logic         sync_error,          // Sync error flag\n    output logic         decoder_error_out    // Type field error flag\n);\n\n    logic [1:0] sync_header;\n    logic [7:0] type_field;\n    logic [63:0] data_in;\n    logic type_field_valid;\n    logic decoder_wrong_ctrl_received;\n    logic decoder_wrong_type_field;\n\n    assign sync_header = decoder_data_in[65:64];\n    assign type_field = decoder_data_in[63:56];\n    assign data_in = decoder_data_in[55:0];\n\n    always_comb begin\n        type_field_valid = 1'b0;\n        if (sync_header == 2'b10) begin\n            case (type_field)\n                8'h1E, 8'h33, 8'h78, 8'h87, 8'h99, 8'hAA, 8'hB4, \n                8'hCC, 8'hD2, 8'hE1, 8'hFF, 8'h2D, 8'h4B, 8'h55, 8'h66: \n                    type_field_valid = 1'b1;\n                default: type_field_valid = 1'b0;\n            endcase\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_control_out <= 8'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            if (sync_header == 2'b10) begin\n                case (type_field)\n                    8'h1E: decoder_control_out <= 8'b11111111;\n                    8'h33: decoder_control_out <= 8'b00011111;\n                    8'h78: decoder_control_out <= 8'b00000001;\n                    8'h87: decoder_control_out <= 8'b11111110;\n                    8'h99: decoder_control_out <= 8'b11111110;\n                    8'hAA: decoder_control_out <= 8'b11111100;\n                    8'hB4: decoder_control_out <= 8'b11111000;\n                    8'hCC: decoder_control_out <= 8'b11110000;\n                    8'hD2: decoder_control_out <= 8'b11100000;\n                    8'hE1: decoder_control_out <= 8'b11000000;\n                    8'hFF: decoder_control_out <= 8'b10000000;\n                    8'h2D: decoder_control_out <= 8'b00011111;\n                    8'h4B: decoder_control_out <= 8'b11110001;\n                    8'h55: decoder_control_out <= 8'b00010001;\n                    8'h66: decoder_control_out <= 8'b00010001;\n                    default: decoder_control_out <= 8'b0;\n                endcase\n            end\n            else begin\n                decoder_control_out <= 8'b0;\n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_data_out <= 64'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            case (sync_header)\n                2'b01: begin\n                    decoder_data_out <= decoder_data_in[63:0];\n                end\n                2'b10: begin\n                    case (type_field)\n                        8'h1E: if (data_in[55:0] == {8{7'h1E}}) decoder_data_out <= {8{8'hFE}};\n                               else decoder_data_out <= {8{8'h07}};\n                        8'h33: decoder_data_out <= {data_in[55:32], 8'hFB, {4{8'h07}}};\n                        8'h78: decoder_data_out <= {data_in[55:0], 8'hFB};\n                        8'h87: decoder_data_out <= {{7{8'h07}},8'hFD};\n                        8'h99: decoder_data_out <= {{6{8'h07}}, 8'hFD, data_in[7:0]};\n                        8'hAA: decoder_data_out <= {{5{8'h07}}, 8'hFD, data_in[15:0]};\n                        8'hB4: decoder_data_out <= {{4{8'h07}}, 8'hFD, data_in[23:0]};\n                        8'hCC: decoder_data_out <= {{3{8'h07}}, 8'hFD, data_in[31:0]};\n                        8'hD2: decoder_data_out <= {{2{8'h07}}, 8'hFD, data_in[39:0]};\n                        8'hE1: decoder_data_out <= {8'h07, 8'hFD, data_in[47:0]};\n                        8'hFF: decoder_data_out <= {8'hFD, data_in[55:0]};\n                        8'h2D: decoder_data_out <= {data_in[55:32], 8'h9C, {4{8'h07}}};\n                        8'h4B: decoder_data_out <= {{4{8'h07}}, data_in[28:5], 8'h9C};\n                        8'h55: decoder_data_out <= {data_in[55:32], 8'h9C, data_in[23:0], 8'h9C};\n                        8'h66: decoder_data_out <= {data_in[55:32], 8'hFB, data_in[23:0], 8'h9C};\n                        default: decoder_data_out <= 64'b0;\n                    endcase\n                end\n                default: decoder_data_out <= 64'b0;\n            endcase\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_error <= 1'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            sync_error <= (sync_header != 2'b01 && sync_header != 2'b10);\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_wrong_type_field <= 1'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            if (sync_header == 2'b10) begin\n                decoder_wrong_type_field <= ~type_field_valid;\n            end\n            else begin\n                decoder_wrong_type_field <= 1'b0;\n            end\n        end\n    end\n    \n    assign decoder_error_out = decoder_wrong_ctrl_received || decoder_wrong_type_field;\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_wrong_ctrl_received <= 1'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            if (sync_header == 2'b10) begin\n                case (type_field)\n                    8'h1E: if ((data_in[55:0] == {8{7'h1E}}) || (data_in[55:0] == {8{7'h00}})) decoder_wrong_ctrl_received <= 1'b0;\n                           else decoder_wrong_ctrl_received <= 1'b1;\n                    8'h33: if (data_in [31:0] != 32'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h87: if (data_in [55:0] != 56'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h99: if (data_in [55:8] != 48'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hAA: if (data_in [55:16] != 40'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hB4: if (data_in [55:24] != 32'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hCC: if (data_in [55:32] != 24'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hD2: if (data_in [55:40] != 16'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hE1: if (data_in [55:48] != 8'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h2D: if (data_in [31:0] != 32'hF0000000) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h4B: if (data_in[55:28] != {4{7'h00}} && data_in[3:0] != 4'b1111) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;              \n                    8'h55: if (data_in[31:24] != 8'hFF) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0; \n                    8'h66: if (data_in[31:24] != 8'h0F) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0; \n                    default: decoder_wrong_ctrl_received <= 1'b0; \n                endcase\n            end\n            else begin\n                decoder_wrong_ctrl_received <= 1'b0;\n            end\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/decoder_64b66b.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/decoder_64b66b.sv\nTOPLEVEL        = decoder_64b66b\nMODULE          = test_decoder_64b66b\nPYTHONPATH      = /src\nHASH            = 350c34ca7fa4211359d2aaff83db4f10db1a0abc\n", "src/test_decoder_64b66b.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n# Helper function to initialize DUT inputs\nasync def dut_initialization(dut):\n    \"\"\" Initialize all inputs for DUT \"\"\"\n    dut.rst_in.value = 1\n    dut.decoder_data_valid_in.value = 0\n    dut.decoder_data_in.value = 0\n    await RisingEdge(dut.clk_in)  # Wait for one clock cycle\n    await RisingEdge(dut.clk_in)  # Wait for one clock cycle\n    await RisingEdge(dut.clk_in)  # Wait for one clock cycle\n\n# Helper function to check the output with debug logging\nasync def check_output(dut, expected_data, expected_sync_error, expected_control_out=0, expected_decoder_error_out=0):\n    \"\"\"Check DUT output against expected values\"\"\"\n    await RisingEdge(dut.clk_in)  # Wait for the output latency of 1 cycle\n    actual_data_out = dut.decoder_data_out.value.integer\n    actual_sync_error = dut.sync_error.value.integer\n    actual_control_out = dut.decoder_control_out.value.integer\n    actual_decoder_error_out = dut.decoder_error_out.value.integer\n    decoder_data_in = dut.decoder_data_in.value.integer\n\n    # Log the actual and expected outputs\n    dut._log.info(f\"Checking output - Input: {hex(decoder_data_in)},  Actual decoder_data_out: {hex(actual_data_out)}, Expected decoder_data_out: {hex(expected_data)}\\n\"\n                  f\"  Actual sync_error: {actual_sync_error}, Expected sync_error: {expected_sync_error}\\n\"\n                  f\"  Actual decoder_control_out: {hex(actual_control_out)}, Expected decoder_control_out: {hex(expected_control_out)}\\n\"\n                  f\"  Actual decoder_error_out: {actual_decoder_error_out}, Expected decoder_error_out: {expected_decoder_error_out}\\n\")\n\n    # Always check sync_error and decoder_error_out\n    assert actual_sync_error == expected_sync_error, \\\n        f\"Sync error mismatch: sync_error={actual_sync_error} (expected {expected_sync_error})\"\n    assert actual_decoder_error_out == expected_decoder_error_out, \\\n        f\"Decoder error mismatch: decoder_error_out={actual_decoder_error_out} (expected {expected_decoder_error_out})\"\n\n    # Check data and control output only if both sync_error and decoder_error_out are 0\n    if expected_sync_error == 0 and expected_decoder_error_out == 0:\n        assert actual_data_out == expected_data, \\\n            f\"Data mismatch: decoder_data_out={hex(actual_data_out)} (expected {hex(expected_data)})\"\n        assert actual_control_out == expected_control_out, \\\n            f\"Control output mismatch: decoder_control_out={hex(actual_control_out)} (expected {hex(expected_control_out)})\"\n\n@cocotb.test()\nasync def reset_test(dut):\n    \"\"\" Test the reset behavior of the decoder \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    \n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    # Log the output after reset\n    dut._log.info(f\"Reset Test:\\n  decoder_data_out: {hex(dut.decoder_data_out.value.integer)}\\n  Expected: 0\")\n\n    # Check that output is zero after reset\n    assert dut.decoder_data_out.value == 0, \"Reset test failed: decoder_data_out should be zero after reset\"\n    assert dut.sync_error.value == 0, \"Reset test failed: sync_error should be zero after reset\"\n\n@cocotb.test()\nasync def valid_data_test(dut):\n    \"\"\" Test decoding when the sync header indicates valid data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    \n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Set test inputs\n    dut.decoder_data_in.value = (0b01 << 64) | 0xA5A5A5A5A5A5A5A5\n    dut.decoder_data_valid_in.value = 1\n\n    await Timer(5, units=\"ns\")\n    # Apply test and check output\n    await RisingEdge(dut.clk_in)\n    dut.decoder_data_valid_in.value = 0\n    dut._log.info(f\"Valid Data Test:\\n\"\n                  f\"  decoder_data_in: {hex(dut.decoder_data_in.value.integer)}\")\n    await check_output(dut, expected_data=0xA5A5A5A5A5A5A5A5, expected_sync_error=0)\n\n\n\n\n\n\n\n@cocotb.test()\nasync def random_valid_data_test(dut):\n    \"\"\" Test decoding with random sync headers and data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    await RisingEdge(dut.clk_in)\n\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    for i in range(5):  # Run 5 random tests\n        random_sync_header = random.choice([0b01])\n        random_data = random.getrandbits(64)\n\n        dut.decoder_data_in.value = (random_sync_header << 64) | random_data\n        dut.decoder_data_valid_in.value = 1\n\n        expected_data = random_data if random_sync_header == 0b01 else 0x0000000000000000\n        expected_sync_error = 0 if random_sync_header == 0b01 else 1\n\n        # Apply test and check output\n        await Timer(5, units=\"ns\")  # Wait before next random test\n        await RisingEdge(dut.clk_in)\n        dut.decoder_data_valid_in.value = 0\n        dut._log.info(f\"Random Test {i+1}:\\n\"\n                      f\"  decoder_data_in: {hex(dut.decoder_data_in.value.integer)}\")\n        await check_output(dut, expected_data=expected_data, expected_sync_error=expected_sync_error)\n\n@cocotb.test()\nasync def control_only_test(dut):\n    \"\"\" Test decoding for control-only mode \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    await RisingEdge(dut.clk_in)\n\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Control-only mode test cases\n    test_cases = [\n        (0b10, 0x1E, 0x3C78F1E3C78F1E, 0xFEFEFEFEFEFEFEFE, 0, 0),  # All control characters\n        (0b10, 0x1E, 0x00000000000000, 0x0707070707070707, 0, 0),  # All control characters\n        (0b10, 0x1E, 0x00000000000000, 0x0707070707070707, 0, 0),  # All control characters\n        (0b10, 0x1E, 0x3C78F1E3C78F1E, 0xFEFEFEFEFEFEFEFE, 0, 0),  # All control characters\n    ]\n\n    for sync_header, type_field, data_in, expected_data, expected_sync_error, expected_decoder_error_out in test_cases:\n        dut.decoder_data_in.value = (sync_header << 64) | (type_field << 56) | data_in\n        dut.decoder_data_valid_in.value = 1\n\n        await Timer(5, units=\"ns\")\n        await RisingEdge(dut.clk_in)\n        dut.decoder_data_valid_in.value = 0\n        dut._log.info(f\"Control-Only Test:\\n\"\n                      f\"  decoder_data_in: {hex(dut.decoder_data_in.value.integer)}\")\n        await check_output(dut, expected_data=expected_data, expected_sync_error=expected_sync_error,\n                           expected_control_out=0xFF, expected_decoder_error_out=expected_decoder_error_out)\n\n@cocotb.test()\nasync def mixed_mode_test(dut):\n    \"\"\" Test decoding for mixed mode \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    await RisingEdge(dut.clk_in)\n\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Mixed mode test cases\n    test_cases = [\n        # Format: (sync_header, type_field, data_in, expected_data, expected_control_out, expected_sync_error, expected_decoder_error_out)\n        (0b10, 0x33, 0xDDCCBB00000000, 0xDDCCBBFB07070707, 0x1F, 0, 0),  # Mixed mode example\n        (0b10, 0x78, 0x3456789ABCDEF0, 0x3456789ABCDEF0FB, 0x01, 0, 0),  # Mixed mode example\n        (0b10, 0x87, 0x00000000000000, 0x07070707070707FD, 0xFE, 0, 0),  # Mixed mode example\n        (0b10, 0x99, 0x000000000000AE, 0x070707070707FDAE, 0xFE, 0, 0),  # Mixed mode example\n        (0b10, 0xAA, 0x0000000000A5A5, 0x0707070707FDA5A5, 0xFC, 0, 0),  # Mixed mode example\n        (0b10, 0xB4, 0x00000000FEED55, 0x07070707FDFEED55, 0xF8, 0, 0),  # Mixed mode example\n        (0b10, 0xCC, 0x00000099887766, 0x070707FD99887766, 0xF0, 0, 0),  # Mixed mode example\n        (0b10, 0xD2, 0x00001234567890, 0x0707FD1234567890, 0xE0, 0, 0),  # Mixed mode example\n        (0b10, 0xE1, 0x00FFEEDDCCBBAA, 0x07FDFFEEDDCCBBAA, 0xC0, 0, 0),  # Mixed mode example\n        (0b10, 0xFF, 0x773388229911AA, 0xFD773388229911AA, 0x80, 0, 0),  # Mixed mode example\n        (0b10, 0x55, 0x070707FF070707, 0x0707079C0707079C, 0x11, 0, 0),  # Mixed mode example\n        (0b10, 0x66, 0x7777770FDEEDDE, 0x777777FBDEEDDE9C, 0x11, 0, 0),  # Mixed mode example\n        (0b10, 0x4B, 0x0000000ABCDEFF, 0x0707070755E6F79C, 0xF1, 0, 0),  # Mixed mode example\n        (0b10, 0x2D, 0xAAAAAAF0000000, 0xAAAAAA9C07070707, 0x1F, 0, 0),  # Mixed mode example\n    ]\n\n    for sync_header, type_field, data_in, expected_data, expected_control_out, expected_sync_error, expected_decoder_error_out in test_cases:\n        # Set inputs\n        dut.decoder_data_in.value = (sync_header << 64) | (type_field << 56) | data_in\n        dut.decoder_data_valid_in.value = 1\n\n        # Wait for the output to stabilize\n        await Timer(5, units=\"ns\")\n        await RisingEdge(dut.clk_in)\n\n        # Check outputs\n        await check_output(dut, expected_data=expected_data, expected_sync_error=expected_sync_error,\n                           expected_control_out=expected_control_out, expected_decoder_error_out=expected_decoder_error_out)\n\n        # Deassert valid signal\n        dut.decoder_data_valid_in.value = 0\n        await RisingEdge(dut.clk_in)\n\n\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_64b66b_encoder_0016", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the existing SystemVerilog testbench to add the **checker generation** logic for verifying the functionality of the `encoder_64b66b` module. The testbench already contains a **stimulus_generator** to drive the input signals. The modified testbench should integrate a **checker_generator** module to validate the `encoder_64b66b` module against the given design specification.\n\n### **Design Specification:**\nThe `encoder_64b66b` module encodes 64-bit input data (`encoder_data_in`) and 8-bit control input (`encoder_control_in`) into a 66-bit output (`encoder_data_out`). The encoding rules are as follows:\n- If `encoder_control_in` is `8'b00000000`, the output is a data block with a sync word of `2'b01` followed by the 64-bit input data.\n- If `encoder_control_in` is not `8'b00000000`, the output is a control block with a sync word of `2'b10` followed by `64'b0`.\n\n### **Testbench Requirements:**\n1. **Testbench Components:**\n   - **Input Signals:** Drive `clk_in`, `rst_in`, `encoder_data_in`, and `encoder_control_in` with various test cases.\n   - **Output Validation:** Monitor and validate the `encoder_data_out` output against expected behavior.\n   - **Checker Generator:** Implement a `checker_generator` module to verify the correctness of `encoder_data_out` based on the input `encoder_data_in` and `encoder_control_in`.\n\n2. **Checker Logic:**\n   - Implement reference logic in the `checker_generator` module to calculate the expected `encoder_data_out` for a given `encoder_data_in` and `encoder_control_in`.\n   - Compare the DUT output (`encoder_data_out`) with the calculated expected output.\n   - Log errors if the outputs do not match.\n   - Print success messages for passing test cases.\n\n3. **Functionality:**\n   - Test all combinations of `encoder_data_in` and `encoder_control_in`, including edge cases such as:\n     - All zeros and all ones for `encoder_data_in`.\n     - All control characters for `encoder_control_in`.\n     - Random data and control inputs.\n   - Include a reset test to ensure proper initialization.\n\n4. **Verification:**\n   - Drive `encoder_data_in` and `encoder_control_in` and monitor `encoder_data_out` using the `checker_generator`.\n   - Compare the actual `encoder_data_out` behavior with the expected behavior.\n   - Log results (pass/fail) for each test case.\n\n5. **Simulation:**\n   - Display pass/fail results for each test case.\n   - Complete the simulation once all test cases are verified.\n\n### **Deliverables:**\nProvide a complete SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `encoder_64b66b` module. The testbench should include:\n- A `stimulus_generator` module to generate test cases.\n- A `checker_generator` module to validate the outputs.\n- Proper clock generation and reset handling.\n- Logging of test results for each test case.\n\n### **Example Test Cases:**\n**1. Data Encoding:**\n   - `encoder_data_in = 64'hA5A5A5A5A5A5A5A5`, `encoder_control_in = 8'b00000000`.\n   - Expected Output: `encoder_data_out = {2'b01, 64'hA5A5A5A5A5A5A5A5}`.\n\n**2. Control Encoding:**\n   - `encoder_data_in = 64'hFFFFFFFFFFFFFFFF`, `encoder_control_in = 8'b11111111`.\n   - Expected Output: `encoder_data_out = {2'b10, 64'b0}`.\n\n**3. Edge Cases:**\n   - `encoder_data_in = 64'h0000000000000000`, `encoder_control_in = 8'b00000000`.\n   - `encoder_data_in = 64'hFFFFFFFFFFFFFFFF`, `encoder_control_in = 8'b00000000`.\n   - `encoder_data_in = 64'hAAAAAAAAAAAAAAAA`, `encoder_control_in = 8'b00000000`.\n   - `encoder_data_in = 64'h5555555555555555`, `encoder_control_in = 8'b00000000`.\n\n**4. Randomized Test:**\n   - Random `encoder_data_in` and `encoder_control_in` values for 1000 iterations.\n\n**5. Reset Test:**\n   - Apply reset and verify initialization of outputs.\n\n### **Expected Output:**\n- The testbench should:\n  - Apply the input test cases one by one.\n  - Display the comparison results (pass/fail) for each test case.\n  - Complete the simulation once all test cases are verified.\n", "context": {"verif/tb_encoder_64b66b.sv": "`timescale 1ns/1ps\n\nmodule tb_encoder_64b66b;\n\n    // Testbench Signals\n    logic clk_in;\n    logic rst_in;\n    logic stim_valid;\n    logic [63:0] encoder_data_in;\n    logic [7:0] encoder_control_in;\n    logic [65:0] encoder_data_out;\n\n    // Instantiate the DUT (Device Under Test)\n    encoder_64b66b dut (\n        .clk_in(clk_in),\n        .rst_in(rst_in),\n        .encoder_data_in(encoder_data_in),\n        .encoder_control_in(encoder_control_in),\n        .encoder_data_out(encoder_data_out)\n    );\n\n    // Instantiate the Stimulus Generator\n    stimulus_generator stim_gen (\n        .clk_in(clk_in),\n        .rst_in(rst_in),\n        .encoder_data_in(encoder_data_in),\n        .encoder_control_in(encoder_control_in),\n        .stim_valid(stim_valid)\n    );\n\n    // Clock Generation: 10ns period (100 MHz)\n    initial begin\n        clk_in = 1;\n        forever #5 clk_in = ~clk_in;\n    end\n\n    // Data Dump Logic\n    initial begin\n        $dumpfile(\"test.vcd\");\n        $dumpvars(0);\n    end\n\n    logic [63:0] encoder_data_reg;\n    logic [7:0] encoder_control_reg;\n    logic stim_valid_reg;\n\n    // Delay Reference Output by 1 Cycle\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoder_data_reg <= 64'b0;\n            encoder_control_reg <= 8'b0;\n            stim_valid_reg <= 8'b0;\n        end else begin\n            encoder_data_reg <= encoder_data_in;\n            encoder_control_reg <= encoder_control_in;\n            stim_valid_reg <= stim_valid;\n        end\n    end\n\n    // Compare DUT output with Reference Logic\n    always_ff @(negedge clk_in) begin\n        if (stim_valid_reg) begin\n            $display(\"Values at time %0t: DUT data input = %h, control_in = %h, DUT Output = %h\", $time, encoder_data_in, encoder_control_in, encoder_data_out);\n        end\n    end\n\nendmodule\n\nmodule stimulus_generator (\n    input logic clk_in,\n    output logic rst_in,\n    output logic [63:0] encoder_data_in,\n    output logic [7:0] encoder_control_in,\n    output logic stim_valid\n);\n\n    // Task to Apply a Reset\n    task apply_reset;\n        begin\n            rst_in = 1;\n            #10;\n            rst_in = 0;\n            #10;\n        end\n    endtask\n\n    // Task to Apply a Test Vector\n    task apply_test_vector(\n        input logic [63:0] data,\n        input logic [7:0] control\n    );\n        begin\n            encoder_data_in = data;\n            encoder_control_in = control;\n            stim_valid = 1'b1;\n            #10; // Wait for a clock cycle\n        end\n    endtask\n\n    // Generate Stimulus\n    initial begin\n        $display(\"Starting Stimulus Generation...\");\n\n        // Initialize signals\n        rst_in = 0;\n        stim_valid = 1'b0;\n        encoder_data_in = 64'b0;\n        encoder_control_in = 8'b0;\n\n        // Apply reset\n        apply_reset;\n\n        // Test Case 1: Data Encoding (All data octets)\n        $display(\"Test Case 1: Data Encoding (All Data Octets)\");\n        apply_test_vector(64'hA5A5A5A5A5A5A5A5, 8'b00000000);\n\n        // Test Case 2: Control Encoding (Control Characters)\n        $display(\"Test Case 2: Control Encoding (Control Characters)\");\n        apply_test_vector(64'hFFFFFFFFFFFFFFFF, 8'b11111111);\n\n        // Test Case 3: Edge Cases for Data Input\n        $display(\"Test Case 3: Edge Cases for Data Input\");\n        apply_test_vector(64'h0000000000000000, 8'b00000000); // All zeros\n        apply_test_vector(64'hFFFFFFFFFFFFFFFF, 8'b00000000); // All ones\n        apply_test_vector(64'hAAAAAAAAAAAAAAAA, 8'b00000000); // Alternating A\n        apply_test_vector(64'h5555555555555555, 8'b00000000); // Alternating 5\n\n        // Test Case 4: Sync Word Transitions\n        $display(\"Test Case 4: Sync Word Transitions\");\n        apply_test_vector(64'h123456789ABCDEF0, 8'b00000000); // Sync word = 2'b01\n        apply_test_vector(64'h123456789ABCDEF0, 8'b11111111); // Sync word = 2'b10\n\n        // Test Case 5: Exhaustive Control Input Test\n        $display(\"Test Case 5: Exhaustive Control Input Test\");\n        for (int i = 0; i < 256; i++) begin\n            encoder_control_in = i;\n            encoder_data_in = $urandom; // Random data\n            stim_valid = 1'b1;\n            #10;\n        end\n\n        // Test Case 6: Randomized Test\n        $display(\"Test Case 6: Randomized Test\");\n        for (int i = 0; i < 1000; i++) begin\n            encoder_control_in = $urandom_range(0, 255); // Random 8-bit value\n            encoder_data_in = {$urandom, $urandom};     // Random 64-bit value\n            stim_valid = 1'b1;\n            #10;\n        end\n        stim_valid = 1'b0;\n        #10;\n\n        // Test Case 7: Reset Scenarios\n        $display(\"Test Case 7: Reset Scenarios\");\n        apply_test_vector(64'hDEADBEEFDEADBEEF, 8'b00000000); // Before reset\n        stim_valid = 1'b0;\n        #10;\n        apply_reset; // Apply reset\n        #10;\n        apply_test_vector(64'hCAFEBABECAFEBABE, 8'b00000000); // Post-reset\n        stim_valid = 1'b0;\n        #10;\n\n        // Finish the simulation\n        $display(\"Test Complete.\");\n        $finish;\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_encoder_64b66b.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 3304d7d0e90e34f96a07d95ff7cc0fc3b5bbe63e\nNUM_BUGS        = 3\n", "src/encoder_64b66b.sv": "`timescale 1ns/1ps\n\nmodule encoder_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic [63:0]  encoder_data_in,     // 64-bit data input\n    input  logic [7:0]   encoder_control_in,  // 8-bit control input\n    output logic [65:0]  encoder_data_out     // 66-bit encoded output\n);\n\n    logic [1:0] sync_word;     \n    logic [63:0] encoded_data; \n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_word <= 2'b00;            \n        end \n        else begin\n\t`ifndef BUG_0\n            if (encoder_control_in == 8'b00000000) begin\n        `else\n            if (encoder_control_in != 8'b00000000) begin\n        `endif\n                sync_word <= 2'b01;         \n            end \n            else begin\n                sync_word <= 2'b10;         \n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_data <= 64'b0;         \n        end \n        else begin\n\t`ifndef BUG_1\n            if (encoder_control_in == 8'b00000000) begin\n        `else\n            if (encoder_control_in != 8'b00000000) begin\n        `endif\n                encoded_data <= encoder_data_in; \n            end\n            else begin\n                encoded_data <= 64'b0; \n            end\n        end\n    end\n\n`ifndef BUG_2\n    assign encoder_data_out = {sync_word, encoded_data};\n`else\n    assign encoder_data_out = {2'b00, encoded_data};\n`endif\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_64b66b_encoder_0018", "categories": ["cid014", "easy"], "input": {"prompt": "The encoder module, `encoder_64b66b`, produces a 66\u2011bit output by concatenating a 2\u2011bit sync_word and a 64\u2011bit encoded_data. The encoder is intended to operate only in \u201cdata mode.\u201d That is, the design supports only data encoding and does not support control encoding. In data mode, the control input (`encoder_control_in`) must be 8'b00000000; when it is zero, the module sets the sync_word to 2'b01 and passes the 64\u2011bit input data through to the output.  \n \n**Requirement**:  \nAdd an immediate assertion to the RTL that checks, on every positive clock edge (when not in reset), that `encoder_control_in` is zero. If `encoder_control_in` is non-zero, the assertion should trigger an error message indicating that only data encoding is supported.\n\n**Interface**:\n- **Inputs**:\n  - `clk_in`: Positive edge-triggered clock signal.\n  - `rst_in`: Asynchronous reset (active high).\n  - `encoder_data_in[63:0]`: 64\u2011bit data input.\n  - `encoder_control_in[7:0]`: 8\u2011bit control input (must be 0 for valid data mode).\n- **Output**:\n  - `encoder_data_out[65:0]` : 66\u2011bit output, consisting of the sync_word([65:64] bits) and encoded_data([63:0] bits).\n", "context": {"rtl/encoder_64b66b.sv": "module encoder_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic [63:0]  encoder_data_in,     // 64-bit data input\n    input  logic [7:0]   encoder_control_in,  // 8-bit control input\n    output logic [65:0]  encoder_data_out     // 66-bit encoded output\n);\n\n    logic [1:0] sync_word;     \n    logic [63:0] encoded_data; \n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_word <= 2'b00;            \n        end \n        else begin\n            if (encoder_control_in == 8'b00000000) begin\n                sync_word <= 2'b01;         \n            end \n            else begin\n                sync_word <= 2'b10;         \n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_data <= 64'b0;         \n        end \n        else begin\n            if (encoder_control_in == 8'b00000000) begin\n                encoded_data <= encoder_data_in; \n            end\n            else begin\n                encoded_data <= 64'b0; \n            end\n        end\n    end\n\n    assign encoder_data_out = {sync_word, encoded_data};\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/encoder_64b66b.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/encoder_64b66b.sv\nTOPLEVEL        = encoder_64b66b\nMODULE          = test_encoder_64b66b\nPYTHONPATH      = /src\nHASH            = e5c1ef6679fc1febf401202f234a17c7034c1e0d\n", "src/test_encoder_64b66b.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n# Helper function to initialize DUT inputs\nasync def dut_initialization(dut):\n    \"\"\" Initialize all inputs for DUT \"\"\"\n    dut.rst_in.value = 1\n    dut.encoder_data_in.value = 0\n    dut.encoder_control_in.value = 0\n    await RisingEdge(dut.clk_in)  # Wait for one clock cycle\n\n# Helper function to check the output with debug logging\nasync def check_output(dut, expected_sync, expected_data):\n    await RisingEdge(dut.clk_in)\n    actual_output = int(dut.encoder_data_out.value)\n    expected_output = (expected_sync << 64) | expected_data\n\n    # Log the actual and expected outputs\n    dut._log.info(f\"Checking output:\\n\"\n                  f\"  Actual encoder_data_out: {hex(actual_output)}\\n\"\n                  f\"  Expected encoder_data_out: {hex(expected_output)}\\n\")\n\n    assert actual_output == expected_output, \\\n        f\"Test failed: encoder_data_out={hex(actual_output)} (expected {hex(expected_output)})\"\n\n@cocotb.test()\nasync def reset_test(dut):\n    \"\"\" Test the reset behavior of the encoder \"\"\"\n    # Start the clock\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    \n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    # Log the output after reset\n    dut._log.info(f\"Reset Test:\\n  encoder_data_out: {hex((int(dut.encoder_data_out.value)))}\\n  Expected: 0\")\n\n    # Check that output is zero after reset\n    assert int(dut.encoder_data_out.value) == 0, \"Reset test failed: encoder_data_out should be zero after reset\"\n\n@cocotb.test()\nasync def data_encoding_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0xA5A5A5A5A5A5A5A5\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0xA5A5A5A5A5A5A5A5)\n\n\n\n@cocotb.test()\nasync def random_data_control_test(dut):\n    \"\"\" Test encoding with random data and control inputs \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    \n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    for i in range(5):  # Run 5 random tests\n        # Generate random data and control inputs\n        random_data = random.getrandbits(64)\n        random_control = 0x00\n\n        dut.encoder_data_in.value = random_data\n        dut.encoder_control_in.value = random_control\n\n        # Determine expected sync word and data based on control input\n        expected_sync = 0b01 if random_control == 0 else 0b10\n        expected_data = random_data if random_control == 0 else 0x0000000000000000\n\n        await RisingEdge(dut.clk_in)\n        # Log inputs for each random test\n        dut._log.info(f\"Random Test {i+1}:\\n\"\n                      f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                      f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n        await check_output(dut, expected_sync=expected_sync, expected_data=expected_data)\n\n        await Timer(10, units=\"ns\")  # Wait for next random test\n\n    dut._log.info(\"Randomized tests completed successfully\")\n\n@cocotb.test()\nasync def random_data_only_test(dut):\n    \"\"\" Test encoding with random data and control inputs \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    \n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    dut.encoder_control_in.value = 0  # All data\n    await RisingEdge(dut.clk_in)\n\n    for i in range(5):  # Run 5 random tests\n        # Generate random data\n        random_data = random.getrandbits(64)\n        dut.encoder_data_in.value = random_data\n\n        # Determine expected sync word and data\n        expected_sync = 0b01\n        expected_data = random_data\n\n        await RisingEdge(dut.clk_in)\n        # Log inputs for each random test\n        dut._log.info(f\"Random Test {i+1}:\\n\"\n                      f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                      f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n        await check_output(dut, expected_sync=expected_sync, expected_data=expected_data)\n\n        await Timer(10, units=\"ns\")  # Wait for next random test\n\n    dut._log.info(\"Randomized tests completed successfully\")\n\n@cocotb.test()\nasync def tc1_data_encoding_bug_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0xFEDCBA9876543210\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0xFEDCBA9876543210)\n    \n  \n@cocotb.test()\nasync def tc2_reset_bug_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0xA5A5A5A5A5A5A5A5\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b00, expected_data=0x0000000000000000)\n\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0xA5A5A5A5A5A5A5A5\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0xA5A5A5A5A5A5A5A5)\n\n@cocotb.test()\nasync def tc3_stuck_at_zero_bug_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0x123456789ABCDEF0\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0x123456789ABCDEF0)\n    \n   \n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_64b66b_encoder_0020", "categories": ["cid014", "medium"], "input": {"prompt": "Create SystemVerilog Assertions to verify the **functional correctness** of the `encoder_64b66b` module. The properties should ensure that:  \n\n1. **Valid `encoder_data_in` for Control Input `8'b11111111`**: When `encoder_control_in == 8'b11111111`, the `encoder_data_in` must be one of the expected patterns:  \n   - `64'h0707070707070707`  \n   - `64'hFEFEFEFEFEFEFEFE`  \n   - `64'h07070707070707FD`  \n2. **Valid `encoder_data_in[39:0]` for Control Input `8'b00011111`**: When `encoder_control_in == 8'b00011111`, the lower 40 bits of `encoder_data_in` must match:  \n   - `40'hFB07070707`  \n   - `40'h9C07070707`  \n3. **Valid `encoder_data_in[63:8]` for Control Input `8'b11111110`**: When `encoder_control_in == 8'b11111110`, the upper 56 bits of `encoder_data_in` must be `56'h070707070707FD`.  \n4. **Valid `encoder_data_in[63:32]` and `encoder_data_in[7:0]` for Control Input `8'b11110001`**: When `encoder_control_in == 8'b11110001`, the concatenation of `encoder_data_in[63:32]` and `encoder_data_in[7:0]` must be `40'h070707079C`.  \n5. **Synchronization Control Word**: When `encoder_control_in` is non-zero, `sync_ctrl_word` must always be set to `2'b10`.  \n6. **No Invalid Values in `encoder_data_out`**: The `encoder_data_out` signal must never contain unknown (`x`) or high-impedance (`z`) values.  \n\nEach assertion must provide a **detailed failure message**, including `encoder_control_in`, `encoder_data_in`, `sync_ctrl_word`, and `encoder_data_out` where applicable, for debugging purposes.\n\n---\n\n### RTL Specification  \n\n#### Module Name: `encoder_64b66b` \n\nThe `encoder_64b66b` is a digital circuit that converts a 64-bit data word and an 8-bit control word into a 66-bit encoded output. The sync word (2 bits) indicates whether the encoded data is purely data or contains control characters. The encoder must support three modes of operation:\n\n1. **Data-Only Mode**:  \n   - If all control input bits (`encoder_control_in`) are `0`, the input data (`encoder_data_in`) is passed unchanged, and the sync word is set to `2'b01`.\n\n2. **Control-Only Mode**:  \n   - If all control input bits (`encoder_control_in`) are `1`, the encoded data includes encoded control characters corresponding to the input control values, and the sync word is set to `2'b10`.\n\n3. **Mixed Mode**:  \n   - If some bits of the control input are `1` and others are `0`, the data input and control characters are combined. The data bytes pass unchanged for control bits set to `0`, while the control characters are encoded for control bits set to `1`. The sync word is set to `2'b10`.\n\n---\n\n### **Encoding Rules**\n\n**1. Sync Word**:\n   - Set to `2'b01` if all control bits are `0` (data-only mode).\n   - Set to `2'b10` if any control bit is `1` (control-only or mixed mode).\n\n**2. Control Character Encoding**:\n   - Control characters in 64-bit input are encoded into respective 7-bit control codes according to the table:\n\n#### **Valid Control Characters in Input and Their Encoding Values**\n\n| **Control Character**  | **Value** | **Encoded Control Code** | \n|------------------------|-----------|--------------------------|\n| `/I/` (Idle)           | `0x07`    | `7'h00`                  |\n| `/S/` (Start of Frame) | `0xfb`    | `4'b0000`                |\n| `/T/` (End of Frame)   | `0xfd`    | `4'b0000`                |\n| `/E/` (Error)          | `0xfe`    | `7'h1e`                  |\n| `/Q/` (Ordered Set)    | `0x9c`    | `4'b1111`                |\n\n---\n\n#### **Valid Control Input Combinations Encoding with Type Field Lookup Table**\n\n| **Data Input [63:0]**            | **Control Input [7:0]**| **Output [65:64]**| **Output [63:56]**| **Output [55:0]**                       |\n|----------------------------------|------------------------|-------------------|-------------------|-----------------------------------------|\n| `I7, I6, I5, I4, I3, I2, I1, I0` | `8'b11111111`          | `2'b10`           | `0x1e`            | `C7, C6, C5, C4, C3, C2, C1, C0`        |\n| `E7, E6, E5, E4, E3, E2, E1, E0` | `8'b11111111`          | `2'b10`           | `0x1e`            | `C7, C6, C5, C4, C3, C2, C1, C0`        |\n| `D7, D6, D5, S4, I3, I2, I1, I0` | `8'b00011111`          | `2'b10`           | `0x33`            | `D7, D6, D5, 4'b0000, C3, C2, C1, C0`   |\n| `D7, D6, D5, D4, D3, D2, D1, S0` | `8'b00000001`          | `2'b10`           | `0x78`            | `D7, D6, D5, D4, D3, D2, D1, D0`        |\n| `I7, I6, I5, I4, I3, I2, I1, T0` | `8'b11111110`          | `2'b10`           | `0x87`            | `C7, C6, C5, C4, C3, C2, C1, 7'b0000000`|\n| `I7, I6, I5, I4, I3, I2, T1, D0` | `8'b11111110`          | `2'b10`           | `0x99`            | `C7, C6, C5, C4, C3, C2, 6'b000000, D0` |\n| `I7, I6, I5, I4, I3, T2, D1, D0` | `8'b11111100`          | `2'b10`           | `0xaa`            | `C7, C6, C5, C4, C3, 5'b00000, D1, D0`  |\n| `I7, I6, I5, I4, T3, D2, D1, D0` | `8'b11111000`          | `2'b10`           | `0xb4`            | `C7, C6, C5, C4, 4'b0000, D2, D1, D0`   |\n| `I7, I6, I5, T4, D3, D2, D1, D0` | `8'b11110000`          | `2'b10`           | `0xcc`            | `C7, C6, C5, 3'b000, D3, D2, D1, D0`    |\n| `I7, I6, T5, D4, D3, D2, D1, D0` | `8'b11100000`          | `2'b10`           | `0xd2`            | `C7, C6, 2'b00, D4, D3, D2, D1, D0`     |\n| `I7, T6, D5, D4, D3, D2, D1, D0` | `8'b11000000`          | `2'b10`           | `0xe1`            | `C7, 1'b0, D5, D4, D3, D2, D1, D0`      |\n| `T7, D6, D5, D4, D3, D2, D1, D0` | `8'b10000000`          | `2'b10`           | `0xff`            | `D6, D5, D4, D3, D2, D1, D0`            |\n| `D7, D6, D5, Q4, I3, I2, I1, I0` | `8'b00011111`          | `2'b10`           | `0x2d`            | `D7, D6, D5, 4'b1111, C3, C2, C1, C0`   |\n| `I7, I6, I5, I4, D3, D2, D1, Q0` | `8'b11110001`          | `2'b10`           | `0x4b`            | `C7, C6, C5, C4, D3, D2, D1, 4'b1111`   |\n| `D7, D6, D5, Q4, D3, D2, D1, Q0` | `8'b00010001`          | `2'b10`           | `0x55`            | `D7, D6, D5, 8'b11111111, D3, D2, D1`   |\n| `D7, D6, D5, S4, D3, D2, D1, Q0` | `8'b00010001`          | `2'b10`           | `0x66`            | `D7, D6, D5, 8'b00001111, D3, D2, D1`   |\n\n---\n\n**3. Mixed Mode Encoding**:\n   - For data bytes (control bit = `0`), pass the corresponding byte from `encoder_data_in`.\n   - For control bytes (control bit = `1`), replace the corresponding byte with its 7-bit control code.\n\n\n### Inputs:\n\n- `clk_in`: Rising-edge triggered clock signal.\n- `rst_in`: 1-bit asynchronous reset, active HIGH.\n- `encoder_data_in[63:0]`: 64-bit input data word.\n- `encoder_control_in[7:0]`: 8-bit control word, where each bit indicates whether the corresponding data byte is control (`1`) or data (`0`).\n\n\n### Outputs:\n\n- `encoder_data_out[65:0]`: 66-bit encoded output consisting of:\n  - 2-bit sync word.\n  - 8-bit Type Filed in case of control/mixed case.\n  - 56-bit encoded data word, including data bytes and/or control characters. In the case of data-only mode, there is no type field. Complete 64 bits are data.\n", "context": {"rtl/encoder_64b66b.sv": "module encoder_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic [63:0]  encoder_data_in,     // 64-bit data input\n    input  logic [7:0]   encoder_control_in,  // 8-bit control input\n    output logic [65:0]  encoder_data_out     // 66-bit encoded output\n);\n\n    logic [1:0] sync_word;\n    logic [63:0] encoded_data;\n\n    // Synchronize sync_word based on encoder_control_in\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_word <= 2'b00;\n        end else begin\n            if (encoder_control_in == 8'b00000000) begin\n                sync_word <= 2'b01;\n            end else begin\n                sync_word <= 2'b10;\n            end\n        end\n    end\n\n    // Synchronize encoded_data based on encoder_control_in\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_data <= 64'b0;\n        end else begin\n            if (encoder_control_in == 8'b00000000) begin\n                encoded_data <= encoder_data_in;\n            end else begin\n                encoded_data <= 64'b0;\n            end\n        end\n    end\n\n    // Function to determine the output based on control and data inputs\n    function [7:0] get_output(input [63:0] data_in, input [7:0] control_input);\n        case (control_input)\n            8'b11111111: begin\n                if (data_in == 64'h0707070707070707) get_output = 8'h1e;\n                else if (data_in == 64'hFEFEFEFEFEFEFEFE) get_output = 8'h1e;\n                else if (data_in == 64'h07070707070707FD) get_output = 8'h87;\n                else get_output = 8'b0;\n            end\n            8'b00011111: begin\n                if (data_in[39:0] == 40'hFB07070707) get_output = 8'h33;\n                else if (data_in[39:0] == 40'h9C07070707) get_output = 8'h2d;\n                else get_output = 8'b0;\n            end\n            8'b00000001: begin\n                if (data_in[7:0] == 8'hFB) get_output = 8'h78;\n                else get_output = 8'b0;\n            end\n            8'b11111110: begin\n                if (data_in[63:8] == 56'h070707070707FD) get_output = 8'h99;\n                else get_output = 8'b0;\n            end\n            8'b11111100: begin\n                if (data_in[63:16] == 48'h0707070707FD) get_output = 8'haa;\n                else get_output = 8'b0;\n            end\n            8'b11111000: begin\n                if (data_in[63:24] == 40'h07070707FD) get_output = 8'hb4;\n                else get_output = 8'b0;\n            end\n            8'b11110000: begin\n                if (data_in[63:32] == 32'h070707FD) get_output = 8'hcc;\n                else get_output = 8'b0;\n            end\n            8'b11100000: begin\n                if (data_in[63:40] == 24'h0707FD) get_output = 8'hd2;\n                else get_output = 8'b0;\n            end\n            8'b11000000: begin\n                if (data_in[63:48] == 16'h07FD) get_output = 8'he1;\n                else get_output = 8'b0;\n            end\n            8'b10000000: begin\n                if (data_in[63:56] == 8'hFD) get_output = 8'hff;\n                else get_output = 8'b0;\n            end\n            8'b11110001: begin\n                if ({data_in[63:32], data_in[7:0]} == 40'h070707079C) get_output = 8'h4b;\n                else get_output = 8'b0;\n            end\n            8'b00010001: begin\n                if ({data_in[39:32], data_in[7:0]} == 16'h9C9C) get_output = 8'h55;\n                else if ({data_in[39:32], data_in[7:0]} == 16'hFB9C) get_output = 8'h66;\n                else get_output = 8'b0;\n            end\n            default: get_output = 8'b0;\n        endcase\n    endfunction\n\n    logic [1:0] sync_ctrl_word;\n    logic [7:0] type_field;\n    logic [55:0] encoded_ctrl_words;\n\n    // Synchronize sync_ctrl_word, type_field, and encoded_ctrl_words based on encoder_control_in\n    always @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_ctrl_words <= 56'b0;\n            sync_ctrl_word <= 2'b00;\n            type_field <= 8'b0;\n        end else begin\n            sync_ctrl_word <= 2'b10;\n            type_field <= get_output(encoder_data_in, encoder_control_in);\n\n            case (encoder_control_in)\n                8'b11111111: begin\n                    if (encoder_data_in == 64'h0707070707070707) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else if (encoder_data_in == 64'hFEFEFEFEFEFEFEFE) encoded_ctrl_words <= {7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E};\n                    else if (encoder_data_in == 64'h07070707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00011111: begin\n                    if (encoder_data_in[39:0] == 40'hFB07070707) encoded_ctrl_words <= {encoder_data_in[63:40], 4'h0, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else if (encoder_data_in[39:0] == 40'h9C07070707) encoded_ctrl_words <= {encoder_data_in[63:40], 4'hF, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00000001: begin\n                    if (encoder_data_in[7:0] == 8'hFB) encoded_ctrl_words <= {encoder_data_in[63:8]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111110: begin\n                    if (encoder_data_in[63:8] == 56'h070707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 6'b000000, encoder_data_in[7:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111100: begin\n                    if (encoder_data_in[63:16] == 48'h0707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 5'b00000, encoder_data_in[15:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111000: begin\n                    if (encoder_data_in[63:24] == 40'h07070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 4'b0000, encoder_data_in[23:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11110000: begin\n                    if (encoder_data_in[63:32] == 32'h070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 3'b000, encoder_data_in[31:0]};\n                    else encoded_ctrl_words <= 56'hFFFFFFF;\n                end\n                8'b11100000: begin\n                    if (encoder_data_in[63:40] == 24'h0707FD) encoded_ctrl_words <= {7'h00, 7'h00, 2'b00, encoder_data_in[39:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11000000: begin\n                    if (encoder_data_in[63:48] == 16'h07FD) encoded_ctrl_words <= {7'h00, 1'b0, encoder_data_in[47:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b10000000: begin\n                    if (encoder_data_in[63:56] == 8'hFD) encoded_ctrl_words <= encoder_data_in[55:0];\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11110001: begin\n                    if ({encoder_data_in[63:32], encoder_data_in[7:0]} == 40'h070707079C) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, encoder_data_in[31:8], 4'b1111};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00010001: begin\n                    if ({encoder_data_in[39:32], encoder_data_in[7:0]} == 16'h9C9C) encoded_ctrl_words <= {encoder_data_in[63:40], 8'hFF, encoder_data_in[31:8]};\n                    else if ({encoder_data_in[39:32], encoder_data_in[7:0]} == 16'hFB9C) encoded_ctrl_words <= {encoder_data_in[63:40], 8'h0F, encoder_data_in[31:8]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                default: encoded_ctrl_words <= 56'h0000000;\n            endcase\n        end\n    end\n\n    assign encoder_data_out = (|encoder_control_in) ? {sync_ctrl_word, type_field, encoded_ctrl_words} : {sync_word, encoded_data};\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/encoder_64b66b.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/encoder_64b66b.sv\nTOPLEVEL        = encoder_64b66b\nMODULE          = test_encoder_64b66b\nPYTHONPATH      = /src\nHASH            = 674e365a3aea9bc142da5e4ba7833ce98333c294\n", "src/test_encoder_64b66b.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n# Helper function to initialize DUT inputs\nasync def dut_initialization(dut):\n    \"\"\" Initialize all inputs for DUT \"\"\"\n    dut.rst_in.value = 1\n    dut.encoder_data_in.value = 0\n    dut.encoder_control_in.value = 0\n    await RisingEdge(dut.clk_in)  # Wait for one clock cycle\n\n# Helper function to check the output with debug logging\nasync def check_output(dut, expected_sync, expected_data):\n    await RisingEdge(dut.clk_in)\n    actual_output = int(dut.encoder_data_out.value)\n    expected_output = (expected_sync << 64) | expected_data\n\n    # Log the actual and expected outputs\n    dut._log.info(f\"Checking output:\\n\"\n                  f\"  Actual encoder_data_out: {hex(actual_output)}\\n\"\n                  f\"  Expected encoder_data_out: {hex(expected_output)}\\n\")\n\n    assert actual_output == expected_output, \\\n        f\"Test failed: encoder_data_out={hex(actual_output)} (expected {hex(expected_output)})\"\n\n@cocotb.test()\nasync def reset_test(dut):\n    \"\"\" Test the reset behavior of the encoder \"\"\"\n    # Start the clock\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    \n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    # Log the output after reset\n    dut._log.info(f\"Reset Test:\\n  encoder_data_out: {hex(int(dut.encoder_data_out.value))}\\n  Expected: 0\")\n\n    # Check that output is zero after reset\n    assert int(dut.encoder_data_out.value) == 0, \"Reset test failed: encoder_data_out should be zero after reset\"\n\n@cocotb.test()\nasync def data_encoding_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0xA5A5A5A5A5A5A5A5\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0xA5A5A5A5A5A5A5A5)\n\n@cocotb.test()\nasync def control_encoding_test(dut):\n    \"\"\" Test encoding when control characters are in the last four octets \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    \n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    # Set test inputs\n    dut.encoder_data_in.value = 0xFFFFFFFFFFFFFFFF\n    dut.encoder_control_in.value = 0x0F  # Control in last four octets\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for control encoding test\n    dut._log.info(f\"Control Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b10, expected_data=0x0000000000000000)  # Expected data output is zero\n\n@cocotb.test()\nasync def mixed_data_control_test(dut):\n    \"\"\" Test encoding when control characters are mixed in the data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Set test inputs\n    dut.encoder_data_in.value = 0x123456789ABCDEF0\n    dut.encoder_control_in.value = 0x81  # Control in first and last octets\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for mixed data and control test\n    dut._log.info(f\"Mixed Data and Control Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await RisingEdge(dut.clk_in)\n    await check_output(dut, expected_sync=0b10, expected_data=0x0000000000000000)  # Expected data output is zero\n\n@cocotb.test()\nasync def all_control_symbols_test(dut):\n    \"\"\" Test encoding when all characters are control \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Set test inputs\n    dut.encoder_data_in.value = 0x0707070707070707\n    dut.encoder_control_in.value = 0xFF  # All control\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for all control symbols test\n    dut._log.info(f\"All Control Symbols Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b10, expected_data=0x1E00000000000000)  # Expected data output is zero\n\n\n@cocotb.test()\nasync def random_data_only_test(dut):\n    \"\"\" Test encoding with random data and control inputs \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    \n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    dut.encoder_control_in.value = 0  # All data\n    await RisingEdge(dut.clk_in)\n\n    for i in range(5):  # Run 5 random tests\n        # Generate random data\n        random_data = random.getrandbits(64)\n        dut.encoder_data_in.value = random_data\n\n        # Determine expected sync word and data\n        expected_sync = 0b01\n        expected_data = random_data\n\n        await RisingEdge(dut.clk_in)\n        # Log inputs for each random test\n        dut._log.info(f\"Random Test {i+1}:\\n\"\n                      f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                      f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n        await check_output(dut, expected_sync=expected_sync, expected_data=expected_data)\n\n        await Timer(10, units=\"ns\")  # Wait for next random test\n\n    dut._log.info(\"Randomized tests completed successfully\")\n\n@cocotb.test()\nasync def tc1_data_encoding_bug_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0xFEDCBA9876543210\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0xFEDCBA9876543210)\n    \n    await RisingEdge(dut.clk_in)\n    # Set test inputs\n    dut.encoder_data_in.value = 0x0707070707070707\n    dut.encoder_control_in.value = 0xFF  # All control\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for all control symbols test\n    dut._log.info(f\"All Control Symbols Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b10, expected_data=0x1E00000000000000)  # Expected data output is zero\n\n\n@cocotb.test()\nasync def tc3_stuck_at_zero_bug_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0x123456789ABCDEF0\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0x123456789ABCDEF0)\n    \n    await RisingEdge(dut.clk_in)\n    # Set test inputs\n    dut.encoder_data_in.value = 0x0707070707070707\n    dut.encoder_control_in.value = 0xFF  # All control\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for all control symbols test\n    dut._log.info(f\"All Control Symbols Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b10, expected_data=0x1E00000000000000)  # Expected data output is zero\n\n\n@cocotb.test()\nasync def test_encoder_all_control_combinations(dut):\n    \"\"\"Cocotb test for 64b/66b encoder with full test cases and expected outputs\"\"\"\n\n    # Start the clock\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Test cases with expected values\n    test_cases = [\n        (0x0707070707070707, 0b11111111, 0x21e00000000000000),\n        (0x070707070707FDAE, 0b11111110, 0x299000000000000ae),\n        (0x0707070707FDA5A5, 0b11111100, 0x2aa0000000000a5a5),\n        (0x07070707FDFEED55, 0b11111000, 0x2b400000000feed55),\n        (0x070707FD99887766, 0b11110000, 0x2cc00000099887766),\n        (0x0707FDAABBCCDDEE, 0b11100000, 0x2d20000aabbccddee),\n        (0x07FDAAAAAA555555, 0b11000000, 0x2e100aaaaaa555555),\n        (0xFD773388229911AA, 0b10000000, 0x2ff773388229911aa),\n        (0xDDCCBBFB07070707, 0b00011111, 0x233ddccbb00000000),\n        (0x0707079C0707079C, 0b00010001, 0x255070707ff070707),\n        (0x3456789ABCDEF0FB, 0b00000001, 0x2783456789abcdef0),\n        (0x777777FBDEEDDE9C, 0b00010001, 0x2667777770fdeedde),\n        (0x07070707ABCDEF9C, 0b11110001, 0x24b0000000abcdeff),\n        (0xAAAAAA9C07070707, 0b00011111, 0x22daaaaaaf0000000),\n        (0xFEFEFEFEFEFEFEFE, 0b11111111, 0x21e3c78f1e3c78f1e),\n        (0x07070707070707FD, 0b11111111, 0x28700000000000000),\n    ]\n\n    # Apply test cases and compare DUT output with expected values\n    for idx, (data_in, control_in, expected_output) in enumerate(test_cases):\n        # Apply inputs\n        await RisingEdge(dut.clk_in)\n        dut.encoder_data_in.value = data_in\n        dut.encoder_control_in.value = control_in\n\n        # Wait for a clock cycle\n        await RisingEdge(dut.clk_in)\n        await RisingEdge(dut.clk_in)\n\n        # Get DUT output\n        dut_output = int(dut.encoder_data_out.value)\n\n        # Compare DUT output with expected output\n        assert dut_output == expected_output, (\n            f\"Test case {idx+1} failed: \"\n            f\"Data: {hex(data_in)}, Control: {bin(control_in)}, \"\n            f\"Expected: {hex(expected_output)}, Got: {hex(dut_output)}\"\n        )\n\n        dut._log.info(\n            f\"Test Case {idx + 1}:\\n\"\n            f\"  encoder_data_in: {hex(data_in)}\\n\"\n            f\"  encoder_control_in: {bin(control_in)}\\n\"\n            f\"  encoder_data_out (DUT): {hex(dut_output)}\\n\"\n            f\"  Expected: {hex(expected_output)}\"\n        )\n\n@cocotb.test()\nasync def test_encoder_all_octets_control(dut):\n    \"\"\"Cocotb test for 64b/66b encoder with full test cases and expected outputs\"\"\"\n\n    # Start the clock\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Test cases with expected values\n    test_cases = [\n        (0x0707070707070707, 0b11111111, 0x21e00000000000000),\n        (0xFEFEFEFEFEFEFEFE, 0b11111111, 0x21e3c78f1e3c78f1e),\n        (0x07070707070707FD, 0b11111111, 0x28700000000000000),\n    ]\n\n    # Apply test cases and compare DUT output with expected values\n    for idx, (data_in, control_in, expected_output) in enumerate(test_cases):\n        # Apply inputs\n        await RisingEdge(dut.clk_in)\n        dut.encoder_data_in.value = data_in\n        dut.encoder_control_in.value = control_in\n\n        # Wait for a clock cycle\n        await RisingEdge(dut.clk_in)\n        await RisingEdge(dut.clk_in)\n\n        # Get DUT output\n        dut_output = int(dut.encoder_data_out.value)\n\n        # Compare DUT output with expected output\n        assert dut_output == expected_output, (\n            f\"Test case {idx+1} failed: \"\n            f\"Data: {hex(data_in)}, Control: {bin(control_in)}, \"\n            f\"Expected: {hex(expected_output)}, Got: {hex(dut_output)}\"\n        )\n\n        dut._log.info(\n            f\"Test Case {idx + 1}:\\n\"\n            f\"  encoder_data_in: {hex(data_in)}\\n\"\n            f\"  encoder_control_in: {bin(control_in)}\\n\"\n            f\"  encoder_data_out (DUT): {hex(dut_output)}\\n\"\n            f\"  Expected: {hex(expected_output)}\"\n        )\n\n@cocotb.test()\nasync def test_encoder_mixed_data_control_octets(dut):\n    \"\"\"Cocotb test for 64b/66b encoder with full test cases and expected outputs\"\"\"\n\n    # Start the clock\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Test cases with expected values\n    test_cases = [\n        (0x070707070707FDAE, 0b11111110, 0x299000000000000ae),\n        (0x0707070707FDA5A5, 0b11111100, 0x2aa0000000000a5a5),\n        (0x07070707FDFEED55, 0b11111000, 0x2b400000000feed55),\n        (0x070707FD99887766, 0b11110000, 0x2cc00000099887766),\n        (0x0707FDAABBCCDDEE, 0b11100000, 0x2d20000aabbccddee),\n        (0x07FDAAAAAA555555, 0b11000000, 0x2e100aaaaaa555555),\n        (0xFD773388229911AA, 0b10000000, 0x2ff773388229911aa),\n        (0xDDCCBBFB07070707, 0b00011111, 0x233ddccbb00000000),\n        (0x0707079C0707079C, 0b00010001, 0x255070707ff070707),\n        (0x3456789ABCDEF0FB, 0b00000001, 0x2783456789abcdef0),\n        (0x777777FBDEEDDE9C, 0b00010001, 0x2667777770fdeedde),\n        (0x07070707ABCDEF9C, 0b11110001, 0x24b0000000abcdeff),\n        (0xAAAAAA9C07070707, 0b00011111, 0x22daaaaaaf0000000),\n    ]\n\n\n    # Apply test cases and compare DUT output with expected values\n    for idx, (data_in, control_in, expected_output) in enumerate(test_cases):\n        # Apply inputs\n        await RisingEdge(dut.clk_in)\n        dut.encoder_data_in.value = data_in\n        dut.encoder_control_in.value = control_in\n\n        # Wait for a clock cycle\n        await RisingEdge(dut.clk_in)\n        await RisingEdge(dut.clk_in)\n\n        # Get DUT output\n        dut_output = int(dut.encoder_data_out.value)\n\n        # Compare DUT output with expected output\n        assert dut_output == expected_output, (\n            f\"Test case {idx+1} failed: \"\n            f\"Data: {hex(data_in)}, Control: {bin(control_in)}, \"\n            f\"Expected: {hex(expected_output)}, Got: {hex(dut_output)}\"\n        )\n\n        dut._log.info(\n            f\"Test Case {idx + 1}:\\n\"\n            f\"  encoder_data_in: {hex(data_in)}\\n\"\n            f\"  encoder_control_in: {bin(control_in)}\\n\"\n            f\"  encoder_data_out (DUT): {hex(dut_output)}\\n\"\n            f\"  Expected: {hex(expected_output)}\"\n        )\n    dut._log.info(\"All test cases passed!\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_8x3_priority_encoder_0018", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the SystemVerilog testbench named `cascaded_encoder_tb` to validate the results for the `cascaded_encoder` module. The testbench should use the stimulus provided and check for the output representing the position of the highest-priority active input. The encoder should follow the priority order from the highest bit (bit 7) to the lowest bit (bit 0).\n\n**Specifications for module cascaded_encoder:**\n\nThe module `cascaded_encoder` consists of another module named `priority_encoder` to support encoding of a parameterized input, allowing it to handle an input of a given width `N` and produce the corresponding output with a width `M = log2(N)`. Using this parameterized `priority_encoder`, the module `cascaded_encoder` handles large input sizes by dividing the input into smaller segments (upper (left) and lower (right) halves). The Most Significant Bit (MSB) of the input has the highest priority and the Least Significant Bit (LSB) of the input has the lowest priority.\n\n#### **`priority_encoder` Module**\n- **Inputs**: `input_signal [N-1:0]` - `N`-bit wide input signal to be encoded. The priority of the inputs decreases from bit N-1 to bit 0.\n\n- **Outputs**: `out [M-1:0]` - `M` bit-wide output vector that represents the index of the highest-priority active input.\n\n- **Behavior**:\n  - Parameterized with `N` (input width) and `M`=`log2(N)`(output width).\n  - Outputs the index of the first active input or defaults to `0` if no inputs are active. The priority encoder should output the binary index of the highest active input line. For example, for N=8, if input_signal[7] is high, the output `out` should be 3'b111 (where M = 3) regardless of the state of the lower-priority bits. If none of the input lines are active (in all zeros), the output should default to 3'b000.\n\n#### **`cascaded_encoder` Module**\n- **Inputs**: `input_signal [N-1:0]` - `N`-bit wide input signal to be encoded\n\n- **Outputs**: \n    - `out [M-1:0]` - `M` bit wide output vector that represents the index of the highest-priority active input\n    - `out_upper_half [M-2:0]` - `M-1` bit-wide output vector that represents the index of the highest-priority active input of the most significant half of data\n    - `out_lower_half [M-2:0]` - `M-1` bit-wide output vector that represents the index of the highest-priority active input of the least significant half of data\n    \n- **Behavior**:\n  - Processes two halves of `input_signal` using two instances of the parameterized `priority_encoder`.\n  - Determines which half contains the first active input.\n  - Produces 2 separate outputs representing the index of the highest priority bit in the two halves of input (for debug purposes)\n  - Combines the outputs of the two `priority_encoder` instances to produce the final result or defaults to `0` if no inputs are active. Outputs are updated combinational.\n\n**Additional Details:**\n\nEnsure that the output is updated combinationally whenever there is a change in the input.\n\n---\n\n### Testbench Requirements:\n\n1. #### Device Under Test (DUT)\n\n   - **Module Instance**: The `cascaded_encoder` module is already instantiated as `dut`, with all input and output signals connected for testing.\n\n2. #### Existing Input Generation\n   - All input bits set to 0.\n   - Single bit set at different positions.\n   - Random input patterns\n   - All bits set \n\n3. #### Validation\n   - **Reference implementation:** \n      - The reference implementation must calculate the expected priority encoding by iterating through the input bits and returning the highest-priority active bit index.\n      - Compare the actual output (`out`) with the expected highest-priority bit index.\n      - Validate that `out_upper_half` and `out_lower_half` reflect the correct indices for each half.\n\n    - **Validate for different scenarios (based on the existing input generation)**\n      - Ensure out = {1'b1, `out_upper_half`} when `input_signal` has active bits only in the upper half.\n      - Ensure out = {1'b0, `out_lower_half`} when only the lower half has active bits.\n      - Ensure the outputs update combinationally without delay.\n      - Ensure out = 0 when no input bits are set.\n\n## Deliverables\nProvide a **complete SystemVerilog testbench** that effectively uses the given stimulus and verifies the `cascaded_encoder` to ensure the correctness of the encoder logic on existing different input scenarios and validating the outputs (`out`, `out_upper_half`, and `out_lower_half`).", "context": {"verif/cascaded_encoder_tb.sv": "module cascaded_encoder_tb;\n\n    // Parameters\n    parameter N = 32;  // Total number of inputs (should be a power of 2)\n    parameter M = 5;   // Output width (log2(N))\n\n    // DUT Signals\n    reg  [N-1:0] input_signal;  \n    wire [M-1:0] out;\n    wire [M-2:0] out_upper_half, out_lower_half;\n\n    // Instantiate the Device Under Test (DUT)\n    cascaded_encoder #(\n        .N(N),\n        .M(M)\n    ) dut (\n        .input_signal(input_signal),\n        .out(out),\n        .out_upper_half(out_upper_half),\n        .out_lower_half(out_lower_half)\n    );\n\n\n    // Test sequence\n    initial begin\n        $display(\"Starting Testbench...\");\n\n        // Test case 1: No active bits (All 0s)\n        input_signal = 0;\n        \n        #2; // Small delay \n\n        // Test case 2: Single bit set at different positions\n        repeat (N) begin\n            input_signal = 1 << $urandom_range(0, N-1);\n            #2; // Small delay\n        end\n\n        #2; // Small delay\n\n        // Test case 3: Multiple random bits set\n        repeat (10) begin\n            input_signal = $random;\n            #2; // Small delay\n        end\n\n        #2; // Small delay\n        // Test case 4: All bits set (should return highest index)\n        input_signal = {N{1'b1}};\n\n        $display(\"Testbench completed successfully!\");\n        $finish;\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/cascaded_encoder_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 18-tb-checker-cascade-priority_encoder\nNUM_BUGS        = 3", "src/cascaded_encoder.v": "module cascaded_encoder #(\n    parameter N = 32,       // Total number of inputs (should be a power of 2)\n    parameter M = 5         // Output width (log2(N) = 5 for 32 inputs)\n)(\n    input  [N-1:0] input_signal,      // Input vector (N bits wide)\n    output reg [M-1:0] out,           // Output vector (M bits wide)\n    output [M-2:0] out_upper_half,    // Output of the upper half encoder\n    output [M-2:0] out_lower_half     // Output of the lower half encoder\n);\n\n    // Internal wires to hold the outputs of the left and right encoders\n    wire [M-2:0] out_left, out_right;  // M-2 width for the left and right submodules' outputs\n    wire enable_left, enable_right;\n\n    // Number of inputs handled by each submodule (half of N)\n    localparam L = N / 2;  // Size of each submodule the cascade\n\n    // First priority encoder for the top half of the inputs (left side)\n    priority_encoder #(\n        .N(L),            // Number of inputs the left encoder (L = N/2)\n        .M(M-1)           // Output width for submodule (M-1)\n    ) left_encoder (\n        .input_signal(input_signal[N-1:L]),   // Top half of the inputs (from bit N-1 to L)\n        .out(out_left)     // Output of the left encoder\n    );\n\n        // Second priority encoder for the bottom half of the inputs (right side)\n    priority_encoder #(\n        .N(L),            // Number of inputs input_signal the right encoder (L = N/2)\n        .M(M-1)           // Output width for submodule (M-1)\n    ) right_encoder (\n        .input_signal(input_signal[L-1:0]),   // Bottom half of the inputs (from bit L-1 to 0)\n        .out(out_right)    // Output of the right encoder\n    );\n\n\n    // Enable signals to determine if there's an active input input_signal each half\n    assign enable_left = |input_signal[N-1:L];  // Left encoder enabled if any active bit input_signal the left half\n    assign enable_right = |input_signal[L-1:0]; // Right encoder enabled if any active bit input_signal the right half\n\n    // Combine the results from both submodules (left and right)\n    always @(*) begin\n        `ifndef BUG_0\n            if (enable_left) begin\n                out = {1'b1, out_left};  // Left encoder has active input, MSB is 1\n            end else if (enable_right) begin\n                out = {1'b0, out_right}; // Right encoder has active input, MSB is 0                \n            `else\n            if (enable_left) begin\n                out = {1'b0, out_left};  // Left encoder has active input, MSB is 1\n            end else if (enable_right) begin\n                out = {1'b1, out_right}; // Right encoder has active input, MSB is 0 \n            `endif\n        end else begin\n            `ifndef BUG_1\n                out = {M{1'b0}};  // No active input\n            `else  \n                out = {M{1'b1}};  // No active input\n            `endif\n        end\n    end\n\n    // Assign the outputs of the left and right encoders \n    assign out_upper_half = out_left;  // Upper half encoder output\n    assign out_lower_half = out_right; // Lower half encoder output\n\nendmodule\n\nmodule priority_encoder #(\n    parameter N = 8,          \n    parameter M = 3          \n)(\n    input  [N-1:0] input_signal,        \n    output reg [M-1:0] out     \n);\n\ninteger i; \nreg found; // Flag to indicate if we have found the first active bit\n\nalways @(*) begin\n    out = {M{1'b0}};  \n    found = 0;        \n      `ifndef BUG_2\n    for (i = N-1; i >= 0; i = i - 1) begin\n        if (input_signal[i] && !found) begin  // Check if this bit is active and no bit has been found yet\n            out = i[M-1:0];  // Set the output to the index of the first active bit\n            found = 1;        // Set the flag to prevent overwriting the output\n        end\n    end\n    `else \n    for (i = M; i >= 0; i = i - 1) begin\n        if (input_signal[i] && !found) begin  // Check if this bit is active and no bit has been found yet\n            out = i[M-1:0];  // Set the output to the index of the first active bit\n            found = 1;        // Set the flag to prevent overwriting the output\n        end\n    end\n    `endif\nend\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/cascaded_encoder.v /code/verif/cascaded_encoder_tb.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_AHB_DDR_0019", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the SystemVerilog testbench `tb_ahb_ddr_bridge` to integrate the checker functionality to test the `ahb_ddr_bridge` module with `encrypt and decrypt IP` instantiated. The modified TB should carry the name `tb_ahb_ddr_bridge_enc_dec`. The testbench provided in the context already has stimulus generator for many test cases. The purpose of the `testbench checker` is to verify the functionality of the AHB bus write data to be written to DDR memory controller interface through DDR bridge and additional data `Fixed security key` check as per the given design specification.\n\n## **Design Specification**:\nThe AHB to DDR Bridge acts as an interface between the Advanced High-Performance Bus (AHB) and DDR Memory (DRAM). It enables efficient data transfer from an AHB master (such as a CPU or DMA controller) to a DDR memory controller.\n\nThe `ahb_ddr_bridge_enc_dec` module has the following interface:\n\n### Interface\n\n#### Inputs\n\n- `hclk(1-bit, Input)`: Positive-edge-triggered AHB clock signal \n- `hready(1-bit, Input)`: Positive-edge-triggered AHB Ready signal\n- `hresetn(1-bit, Input)`: Asynchronous active LOW AHB reset signal. When asserted, the module resets its internal signals to zero\n- `htrans(2-bit, Input)`: Active High AHB Transfer Type\n- `hwdata(32-bit, Input)`: AHB Write Data\n- `hsize(3-bit, Input)`:  Active High AHB Transfer Size\n- `haddr(32-bit, Input)`: Address bus for accessing AHB Address\n- `hwrite(1-bit, Input)`: AHB Write Enable (for writing to AHB slave)\n- `ddr_rdata(32-bit, Input)`: DDR Read Data\n- `ddr_ready(1-bit, Input)`: DDR Ready Signal\n\n#### Outputs\n\n- `hrdata(32-bit, Output)`: AHB Read Data\n- `hresp(2-bit, Output)`: AHB Response\n- `hreadyout(1-bit, Output)`: AHB Ready Output\n- `ddr_clk(1-bit, Output)`: Positive-edge-triggered DDR clock signal\n- `ddr_addr(32-bit, Output)`: DDR Address\n- `ddr_wdata(32-bit, Output)`: DDR Write Data\n- `ddr_wr(1-bit, Output)`: DDR Write Enable\n- `ddr_rd(1-bit, Output)`: DDR Read Enable\n\n## **Module Functionality**:\n### Accepts `AHB` Transactions\n- Supports AHB read and write transactions.\n- Handles burst and single transfers.\n- Manages control signals like `htrans`, `hwrite`, `hsize`, and `hburst`.\n\n### Manages Data Flow to DDR Memory\n- Converts `AHB` transactions into `DDR`-compatible transactions.\n- Ensures data ordering and buffering when necessary.\n- Maintains timing constraints for `DDR` memory access.\n\n### Handles Response & Status\n- Provides `hreadyout` to indicate when the bridge is ready for a new transaction.\n- Generates `hresp` (response signal) to indicate OKAY (0) or ERROR (1).\n\n### Encryption and Decryption Logic in RTL Implementation\n- The `encryption` and `decryption` logic implemented in RTL for the `ahb_ddr_bridge_enc_dec` module follows `XOR-based encryption`, which is a form of `symmetric-key encryption` (`Fixed 128-bit Key`).\n- This is a stream `cipher-like XOR-based` encryption, which is similar to a `One-Time Pad` (OTP).\n\n### Encryption Logic \n- Performs the encryption process in one clock cycle for simplicity:\n\n**Type of Encryption:**\n- Type: Symmetric-key encryption\n- Category: Substitution-based (XOR cipher)\n- Security Level: moderate\n\n**Inputs:**\n- `clk` : System clock\n- `resetn` : Active-low reset\n- `data_in` : 32-bit plaintext input\n\n**Output:**\n- `data_out` : 32-bit encrypted output\n\n### Decryption Logic\n- Reverses the encryption process, ensuring the original plaintext is recovered correctly after reading from DDR memory.\n\n**Inputs:**\n- `clk` : System clock\n- `resetn` : Active-low reset\n- `data_in` : 32-bit encrypted input\n\n**Output:**\n- data_out : 32-bit decrypted output\n\n### Integration\n- Encryption (`encrypt_module`) is used before writing to DDR memory.\n- Decryption (`decrypt_module`) is used after reading from DDR memory.\n- The ahb_ddr_bridge_enc_dec module ensures that the encryption/decryption process is transparent to the AHB interface, meaning that software sees only the original plaintext data.\n\n## **Checker Requirements**:\n**Validation Logic**\n    - Implement tasks that compare the actual output against expected results. \n    - Each task performs the required comparison between data send from AHB and data received on DDR interface after each transaction done.\n    - Display results (pass/fail) for each test case. Provide success messages when expected and actual outputs match, and error messages when they don't.\n    - End the simulation after all test cases are completed.\n\n**Validation Checkers** :\n\n1. Write Transaction Validations with enc (`ahb_write_with_enc` Task)\n- Ensures correctness when writing data from AHB to DDR.\n- Confirm data is latched into DDR correctly\n- Check if write is acknowledged (hreadyout HIGH)\n- Checking operation : (`if (hreadyout !== 1'b1`)  \n\n2. Read Transaction Validations with enc(`ahb_read_with_enc` Task)\n- Ensures correctness when reading data from DDR to AHB.\n- Compare read data (hrdata) with expected written data\n- Checking operation : (`if (read_data !== expected_data`)\n\n3. Burst Write Validations with enc(`ahb_burst_write_with_enc` Task)\n- Ensures correctness for burst writes( 4 incremental addresses), where multiple words are written in a sequence.\n- Check each burst write data written in DDR write memory.\n- Checking operation : (`DDR WRITE: Addr = 0x%h, Data = 0x%h`)\n\n4. Burst Read Validations with enc(`ahb_burst_read_with_enc` Task)\n- Ensures correctness for burst reads( 4 incremental addresses), where multiple words are written in a sequence.\n- Check each burst read data read from DDR write memory.\n- Checking operation : (`AHB READ SUCESS: Addr = 0x%h, Data = 0x%h`)\n\n5. Verify Encryption Task (`verify_encryption`)\n- Writes a known plaintext (32-bit data)\n- Checks if the written data is encrypted before being sent to DDR.\n\n6. Verify decryption Task (`verify_encryption`)\n- Simulates a read from DDR with encrypted data.\n- Ensures that the ahb_ddr_bridge_enc_dec correctly decrypts the data.\n \n## Deliverables:\nProvide a complete SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `ahb_ddr_bridge_enc_dec` module.", "context": {"verif/tb_ahb_ddr_bridge.sv": "`timescale 1ns/1ps\n\nmodule tb_ahb_ddr_bridge;\n    \n    parameter ADDR_WIDTH = 10;\n    parameter DATA_WIDTH = 32;\n\n    \n    // Signals\n    logic hclk, hresetn;\n    logic [ADDR_WIDTH-1:0] haddr;\n    logic [DATA_WIDTH-1:0] hwdata;\n    logic [DATA_WIDTH-1:0] hrdata;\n    logic hwrite;\n    logic [1:0] htrans;\n    logic hreadyout;\n    logic [1:0] hresp;\n    logic ddr_clk;\n    logic [ADDR_WIDTH-1:0] ddr_addr;\n    logic [DATA_WIDTH-1:0] ddr_wdata;\n    logic [DATA_WIDTH-1:0] ddr_rdata;\n    logic ddr_write, ddr_read, ddr_ready;\n    //logic [DATA_WIDTH-1:0] read_data;\n    \n    // Instantiate DUT\n    ahb_ddr_bridge #\n    (\n        .ADDR_WIDTH(ADDR_WIDTH),\n        .DATA_WIDTH(DATA_WIDTH)\n    ) uut (\n        .hclk(hclk), .hresetn(hresetn), .haddr(haddr), .hwdata(hwdata), .hrdata(hrdata),\n        .hwrite(hwrite), .htrans(htrans), .hreadyout(hreadyout), .hresp(),\n        .ddr_clk(ddr_clk), .ddr_addr(ddr_addr), .ddr_wdata(ddr_wdata), .ddr_rdata(ddr_rdata),\n        .ddr_wr(ddr_write), .ddr_read(ddr_read), .ddr_ready(ddr_ready)\n    );\n    \n    // Clock Generation\n    always #5 hclk = ~hclk;\n\n    // DDR Memory Model (Basic Storage)\n    logic [31:0] ddr_memory [0:1023]; // Simulating a DDR memory array\n\n    always_ff @(posedge ddr_clk) begin\n        if (ddr_write) begin\n            ddr_memory[ddr_addr] <= ddr_wdata;\n        end else \n        if (ddr_read) begin\n            ddr_rdata <= ddr_memory[ddr_addr]; // Return correct read data\n        end\n    end\n    \n    task initialization();\n    begin\n        // Initialize\n        hclk = 0;\n        hresetn = 1;\n        haddr = 0;\n        hwdata = 0;\n        hwrite = 0;\n        htrans = 0;\n        ddr_ready = 0; \n        #30;\n        ddr_ready = 1;\n    end\n    endtask\n\n    task drive_reset();\n    begin\n        hresetn = 1'b0;  \n    end\n    endtask\n\n    task clear_reset();\n    begin\n        hresetn = 1'b1;  \n    end\n    endtask\n\n    // Task: AHB Single Write\n    task ahb_write(input logic [9:0] addr, input logic [31:0] data);\n        @(posedge hclk);\n        haddr  = addr;\n        hwdata = data;\n        hwrite = 1'b1;\n        htrans = 2'b10; // NONSEQ\n        ddr_ready = 1'b1; // Simulating DDR ready state\n        wait (hreadyout === 1'b1);\n        @(posedge hclk);\n        hwrite = 1'b0;\n        htrans = 2'b00;\n        $display(\"[%0t] AHB WRITE: Addr = 0x%h, Data = 0x%h\", $time, addr, data);\n    endtask\n\n    // Task: AHB Single Read\n    task ahb_read(input logic [9:0] addr);\n        @(posedge hclk);\n        haddr  = addr;\n        hwrite = 1'b0;\n        htrans = 2'b10; // NONSEQ\n        ddr_ready = 1'b1; // Simulating DDR ready state\n\n        @(posedge hclk);\n            htrans = 2'b00; // IDLE\n\n        wait (uut.ddr_read_d1 === 1'b1);\n        @(posedge hclk);\n        #10;\n        $display(\"[%0t] AHB READ: Addr = 0x%h, Data = 0x%h\", $time, addr, hrdata);\n    endtask\n\n    // Task: Burst Write\n    task ahb_burst_write(input logic [9:0] start_addr);\n        int i;\n        $display (\"Burst Write to DDR memory Starts...\");\n\n        @(posedge hclk);\n        haddr  = start_addr;\n        \n        for (i = 0; i < 4; i++) begin\n            hwrite = 1'b1;\n            htrans = 2'b10; // NONSEQ\n            ddr_ready = 1;\n            hwdata = i + 1;\n            haddr = haddr + 4;\n            htrans = 2'b10;\n            @(posedge hclk);\n            wait (hreadyout === 1'b1);\n            @(posedge hclk);\n            hwrite = 1'b0;\n            htrans = 2'b00; // IDLE\n            #10;\n            $display(\"[%0t] DDR WRITE: Addr = 0x%h, Data = 0x%h\", $time, haddr, hwdata);\n\n        end\n        \n    endtask\n\n    // Task: Burst Read\n    task ahb_burst_read(input logic [9:0] start_addr);\n        int i;\n        $display (\"Burst Read from DDR memory Starts...\");\n        @(posedge hclk);\n        haddr  = start_addr;\n        \n        for (i = 0; i < 4; i++) begin\n        //    hwrite = 1'b0;\n            htrans = 2'b10; // NONSEQ\n            ddr_ready = 1;\n            haddr = haddr + 4; // Next word\n\n        //    @(posedge hclk);\n            wait (uut.read_pending === 1'b1);\n            @(posedge hclk);\n            htrans = 2'b00;\n            #10;\n            wait (uut.ddr_read_d1 === 1'b1);\n            @(posedge hclk);\n                #10;\n                //data_out = hrdata; // hrdata is the delayed version of ddr_rdata\n                $display(\"[%0t] AHB BURST READ: Addr = 0x%h, Data = 0x%h\", $time, haddr, hrdata);\n        end\n        \n    endtask\n\n    // Task: Randomized write/read\n    task ahb_random_write_read();\n        int i;\n        logic [31:0] addr, data, read_data;\n        $display (\"Random write & Read to DDR memory Starts...\");\n        for (i = 0; i < 10; i++) begin\n            addr = $random + 10'h3FF;\n            data = $random;\n            ahb_write(addr, data);\n            #20;\n            ahb_read(addr);  \n        end      \n    endtask\n\n    task ahb_idle_transaction();\n    @(posedge hclk);\n    $display (\"IDLE transaction task Starts...\");\n        haddr  = 10'h100;\n        hwrite = 1'b0;\n        htrans = 2'b00; // IDLE\n        #10;\n        assert (hreadyout === 1'b1) else $display(\"IDLE transaction should not stall\");\n    endtask\n\n    task ahb_busy_transaction();\n    @(posedge hclk);\n    $display (\"Busy transaction task Starts...\");\n        haddr  = 10'h200;\n        hwrite = 1'b1;\n        htrans = 2'b01; // BUSY\n        #10;\n        assert (hreadyout === 1'b1) else $display(\"BUSY transaction should not affect ready signal\");\n    endtask\n\n    task ahb_write_with_ddr_not_ready();\n    @(posedge hclk);\n    $display (\"AHB wr with DDR not ready task Starts...\");\n        haddr  = 10'h300;\n        hwdata = 32'hA5A5A5A5;\n        hwrite = 1'b1;\n        htrans = 2'b10; // NONSEQ\n        ddr_ready = 1'b0; // Force DDR wait\n        #20;\n        ddr_ready = 1'b1; // Now ready\n        #10;\n        assert (ddr_addr == 10'h300) else $display(\"Address not latched correctly when DDR stalled\");\n    endtask\n\n    task ahb_read_after_write();\n    @(posedge hclk);\n    $display (\"Read after write task Starts...\");\n        haddr  = 10'h144;\n        hwdata = 32'hABCD1234;\n        hwrite = 1'b1;\n        htrans = 2'b10; // NONSEQ\n        @(posedge hclk);\n        hwrite = 1'b0;  // Immediately switch to read\n        @(posedge hclk);\n        htrans = 2'b10;\n        @(posedge hclk);\n            wait (uut.read_pending === 1'b1);\n            @(posedge hclk);\n            htrans = 2'b00;\n            #10;\n            wait (uut.ddr_read_d1 === 1'b1);\n            @(posedge hclk);\n                #10;\n                assert (hrdata == 32'hABCD1234) else $display(\"[%0t] Read after write mismatch!\", $time);\n    endtask\n\n    task trigger_hresp1();\n    @(posedge hclk);\n        haddr  = 10'h100; // Random valid address\n        hwrite = 1'b1;\n        htrans = 2'b10; // NONSEQ transaction\n\n        ddr_ready = 1'b0; // Stall DDR to force `hreadyout = 0`\n        wait (uut.hresp === 2'b00)\n        @(posedge hclk);\n            $display(\"SUCCESS: OK response generated.\");\n        \n    /*    wait (hresp === 2'b11)\n        @(posedge hclk);\n            $display(\"SUCCESS: SPLIT response generated.\");\n    */\n        ddr_ready = 1'b1; // Now allow DDR to complete\n    endtask\n\n    task automatic generate_retry();\n        // Initialize signals\n        htrans  = 2'b10;  // NONSEQ transaction\n        hwrite  = 1'b1;   // Write transaction\n        haddr   = 10'h055;\n        hwdata  = 32'hDEADBEEF;\n        ddr_ready = 0;    // Force DDR to be NOT ready\n\n        // Wait for some cycles to allow RETRY generation\n        #20;\n        \n        wait (uut.hresp_reg === 2'b10)\n        @(posedge hclk);\n            $display(\"SUCCESS: RETRY response (hresp=2'b10) generated.\");\n        \n        // Now enable DDR ready and check OKAY response\n        ddr_ready = 1;  \n        #20;\n\n        wait (uut.hresp_reg === 2'b00) \n        @(posedge hclk);\n            $display(\"SUCCESS: OKAY response (hresp=2'b00) after retry.\");\n        \n    endtask\n\n    // Test Sequence\n    initial begin\n        $dumpfile(\"tb_ahb_ddr_bridge.vcd\");\n        $dumpvars(0, tb_ahb_ddr_bridge);  \n        initialization();\n        #30;\n            drive_reset();\n            #20;\n                $display(\"[%0t]FSM Reset Status: State machine in IDLE state on Reset!\", $time);\n        #30;\n            clear_reset();\n        #20;\n\n        // Test Cases\n        #10;\n        ahb_write(10'h010, 32'hDEADBEEF);\n        #40;\n        ahb_read(10'h010);\n        #50;\n\n        ahb_write(10'h020, 32'hCAFEBABE);\n        #30;\n        ahb_read(10'h020);\n        #30;\n\n        ahb_burst_write(10'h030);\n        #30;\n    \n        ahb_burst_read(10'h030);\n        #30;\n    \n        ahb_random_write_read();\n\n        ahb_idle_transaction();\n\n        ahb_busy_transaction();\n\n        ahb_write_with_ddr_not_ready();\n    \n        ahb_read_after_write();\n\n        generate_retry();\n\n        trigger_hresp1();\n        #30;\n\n        // End Simulation\n        #50;\n        $display(\"TESTBENCH COMPLETED\");\n        $finish;\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_ahb_ddr_bridge_enc_dec.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 19-tb-checker-ahb-ddr-with-aes\nNUM_BUGS        = 4", "src/ahb_ddr_bridge_enc_dec.sv": "`timescale 1ns/1ps\n\nmodule ahb_ddr_bridge_enc_dec #(\n    parameter ADDR_WIDTH = 10,\n    parameter DATA_WIDTH = 32\n)(\n    input  logic        hclk,\n    input  logic        hresetn,\n\n    // AHB-Lite Interface\n    input  logic [ADDR_WIDTH-1:0] haddr,\n    input  logic [DATA_WIDTH-1:0] hwdata,\n    output logic [DATA_WIDTH-1:0] hrdata,\n    input  logic        hwrite,\n    input  logic [1:0]  htrans,\n    output logic        hreadyout,\n    output logic [1:0]  hresp,\n\n    // DDR Memory Interface\n    output logic        ddr_clk,\n    output logic [ADDR_WIDTH-1:0] ddr_addr,\n    output logic [DATA_WIDTH-1:0] ddr_wdata, \n    input  logic [DATA_WIDTH-1:0] ddr_rdata,\n    output logic        ddr_wr,\n    output logic        ddr_read,\n    input  logic        ddr_ready\n);\n\n    // Internal Buffers\n    logic [ADDR_WIDTH-1:0] addr_reg;\n    logic [DATA_WIDTH-1:0] data_reg;\n    logic        ddr_read_d1, ddr_wr_d1;\n    logic        hwrite_d1;\n    logic        ddr_read_d2;\n    logic [1:0]  htrans_d1;\n    logic        write_pending, read_pending;\n    logic        ddr_write;\n\n    // AES Encryption Module\n    logic [DATA_WIDTH-1:0] encrypted_wdata;\n    logic [DATA_WIDTH-1:0] decrypted_rdata;\n\n    encrypt_module aes_enc_inst (\n        .clk(hclk),\n        .resetn(hresetn),\n        .data_in(hwdata),\n        .valid(hwrite),\n        .data_out(encrypted_wdata)\n    );\n\n    decrypt_module aes_dec_inst (\n        .clk(hclk),\n        .resetn(hresetn),\n        .data_in(ddr_rdata),\n        .valid(ddr_read_d1),\n        .data_out(decrypted_rdata)\n    );\n\n    // AHB State Tracking\n    typedef enum logic [1:0] {\n        IDLE  = 2'b00,\n        WRITE = 2'b01,\n        READ  = 2'b10\n    } state_t;\n\n    state_t state;\n    \n    assign ddr_clk = hclk;\n\n    // AHB Transaction Processing\n    always_ff @(posedge hclk or negedge hresetn) begin\n    `ifndef BUG_0\n        if (!hresetn) begin\n            state <= IDLE;\n    `else\n        if (!hresetn) begin\n            state <= WRITE; //BUG 0\n    `endif\n            hreadyout    <= 1'b1;\n            addr_reg     <= 'h0;\n            data_reg     <= 'h0;\n            write_pending <= 1'b0;\n            read_pending  <= 1'b0;\n            ddr_write     <= 1'b0;\n            ddr_wdata    <= 'h0;\n            ddr_addr     <= 'h0;\n            ddr_read     <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    ddr_read  <= 1'b0;\n                    ddr_write <= 1'b0;\n                    hreadyout <= 1'b1;\n\n                    if (htrans_d1[1] == 1'b1) begin // Check for valid transaction\n                        addr_reg <= haddr;\n                        if (hwrite_d1) begin\n                            data_reg      <= encrypted_wdata; //hwdata avail after 1 clock delay;\n                            state         <= WRITE;\n                            write_pending <= 1'b1;\n                        end else begin\n                            state         <= READ;\n                            read_pending  <= 1'b1;\n                        end\n                    end\n                end\n\n                WRITE: begin\n                    if (ddr_ready) begin\n                    `ifndef BUG_1\n                        ddr_addr  <= addr_reg;\n                        ddr_wdata <= data_reg; \n                    `else\n                        ddr_addr  <= data_reg; // BUG 1\n                        ddr_wdata <= addr_reg;\n                    `endif\n                        ddr_write <= 1'b1;\n                        write_pending <= 1'b0;\n                        hreadyout  <= 1'b1;\n                        state      <= IDLE;\n                    end else begin\n                        hreadyout <= 1'b0;\n                    end\n                end\n\n                READ: begin\n                    if (ddr_ready) begin\n                        ddr_addr  <= addr_reg;\n                        ddr_read  <= 1'b1;\n                        read_pending <= 1'b0;\n                        hreadyout  <= 1'b1;\n                        state      <= IDLE;\n                    end else begin\n                        hreadyout <= 1'b0;\n                        ddr_read  <= 1'b0;\n                    end\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    // Sequential Delay Registers for Read/Write Signals\n    always_ff @(posedge hclk or negedge hresetn) begin\n        if (!hresetn) begin\n            ddr_read_d1 <= 1'b0;\n            ddr_read_d2 <= 1'b0;\n            ddr_wr_d1   <= 1'b0;\n            hwrite_d1 <= 'b0;\n            htrans_d1 <= 2'b0;\n        end else begin\n            ddr_read_d1 <= ddr_read;\n            ddr_read_d2 <= ddr_read_d1;\n            ddr_wr_d1   <= ddr_write;\n            hwrite_d1 <= hwrite;\n            htrans_d1 <= htrans;\n        end\n    end\n\n    assign ddr_wr = ddr_write & ~ddr_wr_d1;  // Ensuring proper write pulse generation\n\n    // Read Data Capture\n    always_ff @(posedge hclk or negedge hresetn) begin\n        if (!hresetn)\n            hrdata <= 'h0;\n        else if (ddr_read_d2)\n            hrdata <= decrypted_rdata;\n    end\n\n    // HRESP Generation\n    always_ff @(posedge hclk or negedge hresetn) begin\n        if (!hresetn) begin\n            hresp <= 2'b00; // OKAY\n        end else if (state != IDLE && !hreadyout) begin\n            hresp <= (!ddr_ready) ? 2'b10 : 2'b00; // RETRY if DDR is not ready, otherwise OKAY\n        end else begin\n            hresp <= 2'b00; // OKAY\n        end\n    end\n\nendmodule\n", "src/decrypt_module.sv": "`timescale 1ns/1ps\n\nmodule decrypt_module (\n    input logic clk,\n    input logic resetn,\n    input logic [31:0] data_in,\n    input logic valid,\n    output logic [31:0] data_out\n);\n\n    logic [31:0] state;\n\n    // Fixed Key (Example Key: 128-bit)\n    localparam logic [127:0] FIXED_KEY = 128'h2B7E151628AED2A6ABF7158809CF4F3C;\n    \n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            state <= 0;\n        else if (valid)\n        `ifndef BUG_3\n            state <= data_in ^ FIXED_KEY; // XOR with the same key reverses encryption\n        `else\n            state <= data_in ^ data_in; // BUG_3\n        `endif\n    end\n\n    assign data_out = state;\n\nendmodule\n", "src/encrypt_module.sv": "`timescale 1ns/1ps\n\nmodule encrypt_module (\n    input logic clk,\n    input logic resetn,\n    input logic [31:0] data_in,\n    input logic valid,\n    output logic [31:0] data_out\n);\n\n    logic [31:0] state;\n\n    // Fixed key (Example Key: 128-bit)\n    localparam logic [127:0] FIXED_KEY = 128'h2B7E151628AED2A6ABF7158809CF4F3C;\n\n    \n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            state <= 0;\n        else if (valid)\n        `ifndef BUG_2\n            state <= data_in ^ FIXED_KEY; // Simple XOR transformation \n        `else\n            state <= 32'hA5A5A5A5 ^ FIXED_KEY; // BUG_2\n        `endif\n    end\n\n    assign data_out = state;\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/tb_ahb_ddr_bridge_enc_dec.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_Attenuator_0011", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench for the `Attenuator` module, which takes a 5-bit input (`data`) and shifts it out serially after detecting changes, finally latching with `ATTN_LE`.\n\n---\n\n## Description\n\n### Inputs\n\n- **Registers**:\n  - `clk (1 bit)`: Clock signal driving the state machine and internal half-rate clock generation (`clk_div2`).\n  - `reset (1 bit)`: Active-high, synchronous reset. When asserted, all state registers and outputs (`ATTN_CLK`, `ATTN_DATA`, `ATTN_LE`) are forced zero.\n  - `data (5 bits)`: An input register. Any change from the previous value triggers a **LOAD** phase, followed by serial shifting and a final latch.\n\n### Outputs\n\n- **Wires**:\n  - `ATTN_CLK (1 bit)`: A clock-like output pulsed high during the **SHIFT** state to shift bits from the internal register.\n  - `ATTN_DATA (1 bit)`: Serial data output, sending the shifted 5-bit pattern bit by bit.\n  - `ATTN_LE (1 bit)`: Latch enable signal pulsed high for one cycle after shifting completes.\n\n---\n\n## Input Generation\n\n- **Random Input Generation**:  \n  The testbench drives random 5-bit values on `data` to ensure the module sees a range of patterns:\n  - Different bit combinations (e.g., `5'b00000`, `5'b11111`, random).\n  - Consecutive changes that repeatedly trigger LOAD \u2192 SHIFT \u2192 LATCH sequences.\n  - Long intervals without change, remaining in the **IDLE** state.\n\n- **Edge Cases**:  \n  The testbench should also drive specific sequences:\n  - Repeated identical data, ensuring the module stays in **IDLE** (no SHIFT or LATCH).\n  - Patterns that confirm each bit is shifted correctly in order (`ATTN_DATA`) while toggling `ATTN_CLK`.\n  - Observing `ATTN_LE` pulses for one cycle when shifting completes.\n\n---\n\n## Stabilization Period\n\n- The testbench waits a few clock cycles (e.g., 2\u20134 cycles of `clk`) after driving each new `data` value to allow the FSM to step from **LOAD** into **SHIFT** and eventually **LATCH** if 5 bits are shifted.\n\n---\n\n## Instantiation\n\nName the instance of the module as `uut`.\n\n---\n\nFollows the specification for building the RTL of the module, use it as reference for the verification environment too:\n\n### Module Interface\n\n1. **Inputs**:\n   - `clk`: 1-bit clock signal.  \n   - `reset`: 1-bit active-high reset.  \n   - `data [4:0]`: 5-bit register whose changes trigger loading and shifting.\n\n2. **Outputs**:\n   - `ATTN_CLK` (1 bit): Pulsed during SHIFT to clock out each bit.  \n   - `ATTN_DATA` (1 bit): Serial data output from the shift register.  \n   - `ATTN_LE` (1 bit): Asserted for one cycle after all 5 bits shift out, latching the final result externally.\n\n### Module Functionality\n\n- **Clock Division**:  \n  An internal `clk_div2` toggles on every rising edge of `clk`, creating a slower clock domain for shifting.\n\n- **Finite State Machine**:\n  - **IDLE**: Waits if `data == old_data`. On detecting `data != old_data`, transitions to **LOAD**.\n  - **LOAD**: Captures `data` into `shift_reg`, outputs the MSB on `ATTN_DATA`, and prepares for shifting.\n  - **SHIFT**: Toggles `ATTN_CLK` high and left-shifts the remaining bits, decreasing a bit counter until 0.\n  - **LATCH**: Pulses `ATTN_LE` high for one cycle, then returns to **IDLE**.\n\n- **Reset Conditions**:  \n  - While `reset=1`, `current_state` = **IDLE**, `shift_reg` = `5'b00000`, `ATTN_CLK=0`, `ATTN_DATA=0`, `ATTN_LE=0`.\n\n---", "context": {}}, "output": {"response": "", "context": {"verif/Attenuator_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n   xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = c2ed083f1874d8efd5e8d483b74703db7b91de0d\nTARGET          = 90\n", "src/Attenuator.sv": "`timescale 1ns / 1ps\n\nmodule Attenuator (\n    input       clk,\n    input       reset,\n    input [4:0] data,\n    output reg  ATTN_CLK,\n    output reg  ATTN_DATA,\n    output reg  ATTN_LE\n);\n\nreg         clk_div2;\nreg  [1:0]  current_state, next_state;\nreg  [4:0]  shift_reg;\nreg  [2:0]  bit_count;\nreg  [4:0]  old_data;\n\nparameter IDLE  = 2'b00,\n          LOAD  = 2'b01,\n          SHIFT = 2'b10,\n          LATCH = 2'b11;\n\ninitial begin\n    ATTN_CLK  = 1'b0;\n    ATTN_DATA = 1'b0;\n    ATTN_LE   = 1'b0;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        clk_div2 <= 1'b0;\n    end else begin\n        clk_div2 <= ~clk_div2;\n    end\nend\n\nalways @(posedge clk_div2 or posedge reset) begin\n    if (reset) begin\n        current_state <= IDLE;\n        old_data      <= 5'b00000;\n        shift_reg     <= 5'b00000;\n        bit_count     <= 3'd0;\n\n        ATTN_CLK      <= 1'b0;\n        ATTN_DATA     <= 1'b0;\n        ATTN_LE       <= 1'b0;\n    end else begin\n        current_state <= next_state;\n        old_data      <= data;\n\n        ATTN_CLK <= 1'b0;\n        ATTN_LE  <= 1'b0;\n\n        if (current_state == IDLE) begin\n            ATTN_DATA <= 1'b0;\n        end\n\n        case (current_state)\n            LOAD: begin\n                shift_reg <= data;\n                bit_count <= 3'd5;\n\n                ATTN_DATA <= data[4];\n            end\n\n            SHIFT: begin\n                ATTN_CLK <= 1'b1;\n\n                ATTN_DATA = shift_reg[4]; \n                shift_reg = shift_reg << 1; \n                bit_count <= bit_count - 1;\n            end\n\n            LATCH: begin\n                ATTN_LE <= 1'b1;\n            end\n        endcase\n    end\nend\n\nalways @(*) begin\n    next_state = current_state;\n    case (current_state)\n        IDLE:   if (data != old_data) next_state = LOAD;\n        LOAD:   next_state = SHIFT;\n        SHIFT:  if (bit_count == 0)   next_state = LATCH;\n        LATCH:  next_state = IDLE;\n    endcase\nend\n\nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_IIR_filter_0012", "categories": ["cid012", "medium"], "input": {"prompt": "Complete the Given Partial SystemVerilog Testbench `iir_filt_tb`. The testbench must instantiate the `iir_filt` RTL module and provide input stimulus for it, focusing exclusively on generating comprehensive test vectors rather than building a full testbench. The IIR filter processes three input signals and outputs three corresponding filtered signals based on a selectable filter configuration.\n\n---\n\n## **Module Interface**\n### **1. Inputs:**\n- **`clk (1-bit)`**: Active high Clock signal that synchronizes operations within the filter logic.\n- **` reset (1-bit)`**: Active-high Asynchronous reset signal that clears the internal states of the filter.\n- **`in_1 [15:0] (16-bit, signed)`**: First input signal to the filter.\n- **`in_2  [15:0] (16-bit, signed)`**: Second input signal to the filter.\n- **`in_3  [15:0] (16-bit, signed)`**: Third input signal to the filter.\n- **`filter_select [1:0] (2-bit, unsigned)`**: Filter selection signal that determines which filter coefficients are applied.\n\n### **2. Outputs:**\n- **`out_1  [15:0] (16-bit, signed)`**: Filtered output corresponding to `in_1`.\n- **`out_2  [15:0] (16-bit, signed)`**: Filtered output corresponding to `in_2`.\n- **`out_3  [15:0] (16-bit, signed)`**: Filtered output corresponding to `in_3`.\n\n---\n\n## **Instantiation:**\nThe testbench instantiates the `iir_filt` module as `uut` and connects the signals between the module and the testbench. Each input and output from the DUT is connected to its corresponding signal in the testbench.\n\n---\n\n## **Input Generation and:**\n- **Clock Generation:** Active high clock signal `clk` toggles every 5 time units to simulate a 100 MHz clock.\n- **Reset:** The reset signal `reset` is asserted at the beginning of the simulation to initialize the filter to a known state. After 20 time units, the reset is deasserted.\n- **Stimulus:** Several test cases are applied to different filtering operations. These test cases, edge cases, stress conditions, dynamic switching, invalid input handling, to filter coefficient changes.\n\n---\n\n## **Test Cases:**\n### **1. Edge Case Testing**\n- Test extreme values such as maximum (`16'h7FFF`), minimum (`16'h8000`), alternating patterns (`16'hAAAA`), and zero (`16'h0000`).\n\n### **2. Stress Testing**\n- Apply 500 cycles of randomized input signals and `filter_select` values.\n\n### **3. Dynamic Switching Test**\n- Randomly change `filter_select` every 10 cycles while continuously providing input data.\n- Ensure the filter transitions smoothly without abrupt artifacts.\n\n### **4. Invalid `filter_select` Test**\n- Iterate through all possible `filter_select` values (0 to 3), including out-of-range values.\n\n### **5. Step Test**\n- Apply a step input (`16'h1000`) and observe how the filter responds over multiple cycles.\n- Reset input to zero and monitor the settling behavior.\n\n### **6. Coefficient Transition Test**\n- Apply a constant input and cycle through different `filter_select` values to test filter coefficient switching behavior.\n\n### **7. Single Channel Test**\n- Provide input to one channel at a time (`in_1`, `in_2`, `in_3`) while keeping the others zero.\n\n### **8. All-Zero Input Test**\n- Feed all-zero inputs and ensure that outputs remain zero across different filter selections.\n\n### **9. Post-Reset Behavior Test**\n- Apply input after reset, if the filter starts processing correctly.\n\n### **10. Arithmetic Overflow Test**\n- Test filter behavior when inputs are at saturation limits (`16'h7FFF` and `16'h8000`).\n\n### **11. Filter Coefficient Combinations Test**\n- Apply known values to the inputs and cycle through filter selections.\n\n---\n\n## **Module Functionality:**\n- **Reset Handling:** The filter should correctly initialize all internal states upon reset.\n- **Filter Processing:** The selected filter should be applied to the inputs, and the outputs should reflect the processed values.\n- **Coefficient Switching:** Changing `filter_select` should update the filter behavior smoothly.\n- **Input Dependency:** Each output should primarily depend on its respective input (`out_1` on `in_1`, `out_2` on `in_2`, etc.).\n- **Saturation and Stability:** The filter should handle extreme values without causing instability.\n\n---\n```verilog\nmodule iir_filt_tb();\n\n    // DUT Inputs\n    reg clk;\n    reg reset;\n    reg signed [15:0] in_1;\n    reg signed [15:0] in_2;\n    reg signed [15:0] in_3;\n    reg [1:0] filter_select;\n\n    // DUT Outputs\n    wire signed [15:0] out_1;\n    wire signed [15:0] out_2;\n    wire signed [15:0] out_3;\n\n    // Instantiate the DUT\n    iir_filt #(.WIDTH(16)) uut (\n        .clk(clk),\n        .reset(reset),\n        .in_1(in_1),\n        .in_2(in_2),\n        .in_3(in_3),\n        .filter_select(filter_select),\n        .out_1(out_1),\n        .out_2(out_2),\n        .out_3(out_3)\n    );\n\n    // Clock generation\n    initial clk = 0;\n    always #5 clk = ~clk; // 100 MHz clock\n\n    // Test procedure\n    initial begin\n        // Initialize inputs\n        reset = 1;\n        #20;\n        reset = 0;\n        $display(\"[%0t] DUT reset completed\", $time);\n\n        // Edge case testing\n        $display(\"[%0t] Starting edge case testing\", $time);\n        in_1 = 16'h7FFF; in_2 = 16'h8000; in_3 = 16'h7FFF; filter_select = 2'b00; #20;\n        in_1 = -16'h8000; in_2 = -16'h7FFF; in_3 = 16'h7FFF; filter_select = 2'b01; #20;\n        in_1 = 16'hAAAA; in_2 = 16'h5555; in_3 = 16'hAAAA; filter_select = 2'b10; #20;\n        in_1 = 16'h0000; in_2 = 16'h0000; in_3 = 16'h0000; filter_select = 2'b11; #20;\n        in_1 = 16'h1234; in_2 = 16'h5678; in_3 = 16'h9ABC; filter_select = 2'b00; #20;\n        $display(\"[%0t] Edge case testing completed\", $time);\n\n        // Stress testing\n        $display(\"[%0t] Starting stress testing\", $time);\n        reset = 1; #20; reset = 0;\n        repeat (500) begin\n            filter_select = $random % 4;\n            in_1 = $random;\n            in_2 = $random;\n            in_3 = $random;\n            #20;\n        end\n        $display(\"[%0t] Stress testing completed\", $time);\n\n        // Insert the code for the remaining test cases here\n\n\n        // Finish simulation\n        $display(\"[%0t] Testbench simulation completed\", $time);\n        $finish;\n    end\n\nendmodule\n```", "context": {}}, "output": {"response": "", "context": {"verif/tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = dabea0d1a8dd24f3dafa8148110d07f59eba2126\nTARGET = 80\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/iir_filt.sv": "module iir_filt #(parameter WIDTH = 16)(\n    input clk,\n    input reset,\n    input signed [WIDTH-1:0] in_1,\n    input signed [WIDTH-1:0] in_2,\n    input signed [WIDTH-1:0] in_3,\n    input [1:0] filter_select, // 00: Butterworth, 01: Chebyshev, 10: Elliptic\n    output reg signed [WIDTH-1:0] out_1,\n    output reg signed [WIDTH-1:0] out_2,\n    output reg signed [WIDTH-1:0] out_3\n);\n\n    reg signed [WIDTH-1:0] butterworth_a_0, butterworth_a_1;\n    reg signed [WIDTH-1:0] butterworth_b_0, butterworth_b_1;\n\n    reg signed [WIDTH-1:0] chebyshev_a_0, chebyshev_a_1;\n    reg signed [WIDTH-1:0] chebyshev_b_0, chebyshev_b_1;\n\n    reg signed [WIDTH-1:0] elliptic_a_0, elliptic_a_1;\n    reg signed [WIDTH-1:0] elliptic_b_0, elliptic_b_1;\n\n    reg signed [WIDTH-1:0] x_1_0, x_1_1, y_1_0, y_1_1;\n    reg signed [WIDTH-1:0] x_2_0, x_2_1, y_2_0, y_2_1;\n    reg signed [WIDTH-1:0] x_3_0, x_3_1, y_3_0, y_3_1;\n\n    integer i;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Initialize all delay lines and outputs\n            x_1_0 <= 0; x_1_1 <= 0; y_1_0 <= 0; y_1_1 <= 0;\n            x_2_0 <= 0; x_2_1 <= 0; y_2_0 <= 0; y_2_1 <= 0;\n            x_3_0 <= 0; x_3_1 <= 0; y_3_0 <= 0; y_3_1 <= 0;\n\n            out_1 <= 0;\n            out_2 <= 0;\n            out_3 <= 0;\n        end else begin\n            // Shift delay lines\n            x_1_1 <= x_1_0; x_1_0 <= in_1;\n            y_1_1 <= y_1_0;\n\n            x_2_1 <= x_2_0; x_2_0 <= in_2;\n            y_2_1 <= y_2_0;\n\n            x_3_1 <= x_3_0; x_3_0 <= in_3;\n            y_3_1 <= y_3_0;\n\n            case (filter_select)\n                2'b00: begin \n                    y_1_0 <= butterworth_b_0 * x_1_0 + butterworth_b_1 * x_1_1 - butterworth_a_1 * y_1_1;\n                    y_2_0 <= butterworth_b_0 * x_2_0 + butterworth_b_1 * x_2_1 - butterworth_a_1 * y_2_1;\n                    y_3_0 <= butterworth_b_0 * x_3_0 + butterworth_b_1 * x_3_1 - butterworth_a_1 * y_3_1;\n                end\n                2'b01: begin \n                    y_1_0 <= chebyshev_b_0 * x_1_0 + chebyshev_b_1 * x_1_1 - chebyshev_a_1 * y_1_1;\n                    y_2_0 <= chebyshev_b_0 * x_2_0 + chebyshev_b_1 * x_2_1 - chebyshev_a_1 * y_2_1;\n                    y_3_0 <= chebyshev_b_0 * x_3_0 + chebyshev_b_1 * x_3_1 - chebyshev_a_1 * y_3_1;\n                end\n                2'b10: begin \n                    y_1_0 <= elliptic_b_0 * x_1_0 + elliptic_b_1 * x_1_1 - elliptic_a_1 * y_1_1;\n                    y_2_0 <= elliptic_b_0 * x_2_0 + elliptic_b_1 * x_2_1 - elliptic_a_1 * y_2_1;\n                    y_3_0 <= elliptic_b_0 * x_3_0 + elliptic_b_1 * x_3_1 - elliptic_a_1 * y_3_1;\n                end\n                default: begin\n                    y_1_0 <= 0;\n                    y_2_0 <= 0;\n                    y_3_0 <= 0;\n                end\n            endcase\n\n            out_1 <= y_1_0;\n            out_2 <= y_2_0;\n            out_3 <= y_3_0;\n        end\n    end\n\n    always @(*) begin\n        case (filter_select)\n            2'b00: begin \n                butterworth_a_0 = 16'h0000; butterworth_a_1 = 16'h0001;\n                butterworth_b_0 = 16'h0001; butterworth_b_1 = 16'h0002;\n            end\n            2'b01: begin \n                chebyshev_a_0 = 16'h0000; chebyshev_a_1 = 16'h0003;\n                chebyshev_b_0 = 16'h0004; chebyshev_b_1 = 16'h0005;\n            end\n            2'b10: begin\n                elliptic_a_0 = 16'h0000; elliptic_a_1 = 16'h0006;\n                elliptic_b_0 = 16'h0007; elliptic_b_1 = 16'h0008;\n            end\n            default: begin\n                butterworth_a_0 = 0; butterworth_a_1 = 0;\n                butterworth_b_0 = 0; butterworth_b_1 = 0;\n\n                chebyshev_a_0 = 0; chebyshev_a_1 = 0;\n                chebyshev_b_0 = 0; chebyshev_b_1 = 0;\n\n                elliptic_a_0 = 0; elliptic_a_1 = 0;\n                elliptic_b_0 = 0; elliptic_b_1 = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_IIR_filter_0015", "categories": ["cid014", "medium"], "input": {"prompt": "\nCan you add assertions in the RTL design of the  `iir_filter` module based on the following requirements:  \n\n---\n\n### **Assertion Requirements:**  \n1. **Reset Check**  \n   - Ensure all filter state variables (`x_prev1` to `x_prev6`, `y_prev1` to `y_prev6`, and `y`) **reset to zero** when `rst` is asserted.  \n   - If any register does not reset properly, an **error message should be displayed**.  \n\n2. **Input Stability Check**  \n   - Verify that **`x_prev1` always captures `x` correctly** on every clock cycle.  \n   - If `x_prev1` does not match the previous value of `x,` the assertion should trigger a warning.  \n\n3. **Shift Register Integrity**  \n   - Ensure that **input samples correctly shift across registers (`x_prev6` to `x_prev1`)**.  \n   - If the shift order is incorrect, an **error message should be displayed**.  \n\n4. **Output Range Check**  \n   - Ensure the filter **output `y` remains within the valid signed 16-bit range** (`-32768` to `32767`).  \n   - If `y` exceeds this range, a **warning message should be triggered** to indicate possible overflow.  \n\n### **Interface:**  \n#### **Inputs:**  \n- `clk (1-bit)`: The **positive-edged clock signal** driving the module.  \n- `rst (1-bit)`: The **active-high synchronous reset signal**, which resets the filter state.  \n- `x (16-bit, signed [15:0])`: A **signed 16-bit input sample** representing the current input to the IIR filter.  \n\n#### **Outputs:**  \n- `y (16-bit, signed [15:0])`: A **signed 16-bit output sample** representing the current filtered value.  \n\n---\n\n", "context": {"rtl/iir_filter.sv": "module iir_filter (\n    input logic clk,\n    input logic rst,\n    input logic signed [15:0] x,    // Input sample\n    output logic signed [15:0] y    // Output sample\n);\n\n    // Filter coefficients\n    parameter signed [15:0] b0 = 16'h0F00;\n    parameter signed [15:0] b1 = 16'h0E00;\n    parameter signed [15:0] b2 = 16'h0D00;\n    parameter signed [15:0] b3 = 16'h0C00;\n    parameter signed [15:0] b4 = 16'h0B00;\n    parameter signed [15:0] b5 = 16'h0A00;\n    parameter signed [15:0] b6 = 16'h0900;\n    parameter signed [15:0] a1 = -16'h0800;\n    parameter signed [15:0] a2 = -16'h0700;\n    parameter signed [15:0] a3 = -16'h0600;\n    parameter signed [15:0] a4 = -16'h0500;\n    parameter signed [15:0] a5 = -16'h0400;\n    parameter signed [15:0] a6 = -16'h0300;\n\n    // Explicitly declare each state variable\n    logic signed [15:0] x_prev1, x_prev2, x_prev3, x_prev4, x_prev5, x_prev6;\n    logic signed [15:0] y_prev1, y_prev2, y_prev3, y_prev4, y_prev5, y_prev6;\n\n    // Temporary accumulator (40-bit to prevent overflow)\n    logic signed [39:0] acc;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            x_prev1 <= 0; x_prev2 <= 0; x_prev3 <= 0;\n            x_prev4 <= 0; x_prev5 <= 0; x_prev6 <= 0;\n            y_prev1 <= 0; y_prev2 <= 0; y_prev3 <= 0;\n            y_prev4 <= 0; y_prev5 <= 0; y_prev6 <= 0;\n            y <= 0;\n        end else begin\n            // 40-bit accumulation\n            acc = (b0 * x) + (b1 * x_prev1) + (b2 * x_prev2) + (b3 * x_prev3) +\n                  (b4 * x_prev4) + (b5 * x_prev5) + (b6 * x_prev6) -\n                  (a1 * y_prev1) - (a2 * y_prev2) - (a3 * y_prev3) -\n                  (a4 * y_prev4) - (a5 * y_prev5) - (a6 * y_prev6);\n\n            // Scaling\n            acc = acc >>> 16;\n\n            // Saturation logic\n            if (acc > 16'sh7FFF) acc = 16'sh7FFF;\n            else if (acc < -16'sh8000) acc = -16'sh8000;\n            y <= acc[15:0];\n\n            // Update the historical data (shift registers)\n            x_prev6 <= x_prev5; x_prev5 <= x_prev4; x_prev4 <= x_prev3;\n            x_prev3 <= x_prev2; x_prev2 <= x_prev1; x_prev1 <= x;\n            y_prev6 <= y_prev5; y_prev5 <= y_prev4; y_prev4 <= y_prev3;\n            y_prev3 <= y_prev2; y_prev2 <= y_prev1; y_prev1 <= y;\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/iir_filter.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/iir_filter.sv\nTOPLEVEL        = iir_filter\nMODULE          = test_iir_filter\nPYTHONPATH      = /src\nHASH            = e14308b6d07bfe0bdf9dd1042187e6b968d41376\n", "src/test_iir_filter.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n@cocotb.test()\nasync def test_iir_filter(dut):\n    \"\"\"Test the IIR filter with various input patterns and monitor assertions.\"\"\"\n\n    # Start the clock (10ns period = 100MHz)\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Apply reset\n    dut.rst.value = 1\n    dut.x.value = 0\n    print(\"[INFO] Applying reset\")\n    await Timer(20, units=\"ns\")  # Wait for two clock cycles\n    dut.rst.value = 0\n    print(\"[INFO] Deasserting reset\")\n\n    # Wait for the system to stabilize\n    for _ in range(3):\n        await RisingEdge(dut.clk)\n\n    # Apply an impulse response (dirac delta function)\n    dut.x.value = 1 << 14  # Large single impulse\n    print(f\"[STIM] Impulse applied: {dut.x.value.signed_integer}\")\n    await RisingEdge(dut.clk)\n    dut.x.value = 0  # Zero input after impulse\n    print(f\"[STIM] Input set to zero after impulse\")\n\n    # Wait for response propagation\n    for _ in range(10):\n        await RisingEdge(dut.clk)\n\n    # Apply random noise input\n    print(\"[INFO] Applying random noise input\")\n    for _ in range(20):\n        rand_val = random.randint(-32768, 32767)\n        dut.x.value = rand_val\n        print(f\"[STIM] Random input: {rand_val}\")\n        await RisingEdge(dut.clk)\n\n    # Ensure shift registers are updating correctly (wait a few cycles)\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)  # Extra cycle for propagation\n\n    print(f\"[CHECK] x_prev1: {dut.x_prev1.value.signed_integer}, Expected: {dut.x.value.signed_integer}\")\n    print(f\"[CHECK] x_prev2: {dut.x_prev2.value.signed_integer}, Expected: {dut.x_prev1.value.signed_integer}\")\n    \n    assert dut.x_prev1.value.signed_integer == dut.x.value.signed_integer, \"Shift register failure in x_prev1\"\n    assert dut.x_prev2.value.signed_integer == dut.x_prev1.value.signed_integer, \"Shift register failure in x_prev2\"\n\n    print(\"[TEST PASSED] IIR filter shift registers updated correctly.\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_IIR_filter_0016", "categories": ["cid012", "medium"], "input": {"prompt": "Create a SystemVerilog testbench module named **`iir_filter_tb`** that instantiates the `iir_filter` module and applies stimulus to the instantiated module for different test scenarios. \n\n---\n### **Inputs**  \n\n- **Clock Signal**:  \n  - `clk`: Positive edge-triggered clock signal driving the IIR filter.  \n\n- **Reset Signal**:  \n  - `rst`: Asynchronous active-high reset signal to initialize the module.  \n\n- **Input Sample**:  \n  - `x[15:0]`: A signed **16-bit input signal** representing the input samples to the filter.  \n\n### **Outputs**  \n\n- **Filtered Output**:  \n  - `y[15:0]`: A signed **16-bit output signal** representing the filter's processed output.  \n\n---\n\n## **Input Generation**  \n\n### **Test Stimulus**  \n\nThe testbench systematically has to apply various input waveforms to the IIR filter under different conditions:  \n\n1. **Impulse  Test**  \n   - Apply a single nonzero value (`16'h4000`) followed by zeros.  \n\n2. **Step Test**  \n   - Apply a **constant step input** (`16'h3000`) for a duration.  \n   - filter stabilization and steady-state.  \n\n3. **Sinusoidal Input Test**  \n   - Apply a **sine wave signal** at different frequencies and amplitudes.  \n   - Evaluates frequency and phase shift characteristics.  \n\n4. **Ramp Input Test**  \n   - Apply a **gradually increasing input** from a negative to positive value.  \n   - Observes filter behavior in linear input variations.  \n\n5. **Noise Test**  \n   - Apply **random noise samples** within a predefined amplitude range.  \n   - Ensures the filter does not amplify undesired noise excessively.  \n\n6. **Stability Test**  \n   - Apply a **constant DC input** and monitor output over an extended period.  \n   - Ensures no instability, drift, or oscillations occur.  \n\n7. **Overflow Test**  \n   - Apply **maximum and minimum possible values** (`16'h7FFF` and `16'h8000`).  \n   - saturation handling and prevents wraparound errors.  \n\n8. **Frequency Sweep Test**  \n   - Apply a **gradual frequency sweep** from a low to high frequency.  \n   - Analyzes frequency over the full spectrum.  \n\n9. **Alternating Step Test**  \n   - Alternates between two amplitude levels (`16'h3000` and `-16'h3000`).  \n   - Checks transient to abrupt changes in input.\n      \n10. **Double Impulse Test**  \n    - Sends **two impulses** separated by a specific delay.  \n    - Evaluates filter behavior when multiple transient events occur.\n     \n11. **Max Amplitude Test**  \n    - Continuously apply **maximum amplitude samples** (`16'h7FFF` and `16'h8000`).  \n    - Ensures the filter does not produce unstable behavior.  \n\n---\n\n## **Instantiation**  \n\n- The **`iir_filter`** instance in the testbench is named **`dut`**.  \n\n---\n\n## **Module Interface**  \n\n### **Inputs**  \n\n- `clk`: Clock signal.  \n- `rst`: Asynchronous active-high reset.  \n- `x[15:0]`: 16-bit signed input sample.  \n\n### **Outputs**  \n\n- `y[15:0]`: 16-bit signed output sample.  \n\n---\n\n## **Module Functionality**  \n\n1. **Filter Processing**  \n   - The `iir_filter` processes the input sample `x` and produces a filtered output `y`.  \n\n2. **Reset Behavior**  \n   - When `rst` is HIGH, the filter resets internal states, and `y` is cleared to `0`.  \n\n3. **Edge Cases**  \n   - Handling of large amplitude signals without overflow.  \n   - Stability under constant or repetitive input patterns.  \n\n---", "context": {}}, "output": {"response": "", "context": {"verif/tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 7c483196daf6dbfaa7399ec5ac1882fe1e77bd42\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/iir_filter.sv": "module iir_filter (\n    input logic clk,\n    input logic rst,\n    input logic signed [15:0] x,    // Input sample\n    output logic signed [15:0] y    // Output sample\n);\n\n    // Filter coefficients\n    parameter signed [15:0] b0 = 16'h0F00;\n    parameter signed [15:0] b1 = 16'h0E00;\n    parameter signed [15:0] b2 = 16'h0D00;\n    parameter signed [15:0] b3 = 16'h0C00;\n    parameter signed [15:0] b4 = 16'h0B00;\n    parameter signed [15:0] b5 = 16'h0A00;\n    parameter signed [15:0] b6 = 16'h0900;\n    parameter signed [15:0] a1 = -16'h0800;\n    parameter signed [15:0] a2 = -16'h0700;\n    parameter signed [15:0] a3 = -16'h0600;\n    parameter signed [15:0] a4 = -16'h0500;\n    parameter signed [15:0] a5 = -16'h0400;\n    parameter signed [15:0] a6 = -16'h0300;\n\n    // Explicitly declare each state variable\n    logic signed [15:0] x_prev1, x_prev2, x_prev3, x_prev4, x_prev5, x_prev6;\n    logic signed [15:0] y_prev1, y_prev2, y_prev3, y_prev4, y_prev5, y_prev6;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            x_prev1 <= 0; x_prev2 <= 0; x_prev3 <= 0;\n            x_prev4 <= 0; x_prev5 <= 0; x_prev6 <= 0;\n            y_prev1 <= 0; y_prev2 <= 0; y_prev3 <= 0;\n            y_prev4 <= 0; y_prev5 <= 0; y_prev6 <= 0;\n            y <= 0;\n        end else begin\n            // Calculate the filter output\n            y <= (b0 * x + b1 * x_prev1 + b2 * x_prev2 + b3 * x_prev3 +\n                  b4 * x_prev4 + b5 * x_prev5 + b6 * x_prev6 -\n                  a1 * y_prev1 - a2 * y_prev2 - a3 * y_prev3 -\n                  a4 * y_prev4 - a5 * y_prev5 - a6 * y_prev6) >>> 16;\n\n            // Update the historical data\n            x_prev6 <= x_prev5; x_prev5 <= x_prev4; x_prev4 <= x_prev3;\n            x_prev3 <= x_prev2; x_prev2 <= x_prev1; x_prev1 <= x;\n            y_prev6 <= y_prev5; y_prev5 <= y_prev4; y_prev4 <= y_prev3;\n            y_prev3 <= y_prev2; y_prev2 <= y_prev1; y_prev1 <= y;\n        end\n    end\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_MSHR_0003", "categories": ["cid012", "medium"], "input": {"prompt": "Develop a SystemVerilog module named `tb_cache_mshr` that only generates input stimulus to a `cache_mshr` module. `cache_mshr` module implements Miss Status Handling Registers (MSHR). The MSHR is a critical component of a **non-blocking cache architecture**, enabling the system to handle multiple outstanding cache misses concurrently. \n\n---\n\n## RTL Specification\n\n### **Parameters**\n- **`INSTANCE_ID`** *(default = \"mo_mshr\")*:  \n  A string identifier for the MSHR instance. This parameter allows users to assign a unique name to each instance of the MSHR module.\n\n- **`MSHR_SIZE`** *(default = 32)*:  \n  Specifies the total number of entries available in the MSHR. This defines how many pending requests can be tracked simultaneously.\n\n- **`CS_LINE_ADDR_WIDTH`** *(default = 10)*:  \n  The bit-width required to represent the cache line address. This parameter determines the number of unique cache lines that can be indexed.\n\n- **`WORD_SEL_WIDTH`** *(default = 4)*:  \n  Specifies the number of bits needed to select a specific word within a cache line. For example, with a cache line containing 16 words, ( log<sub>2</sub>(16) = 4 ) bits are required.\n\n- **`WORD_SIZE`** *(default = 4)*:  \n  Word size in **bytes**. It represents the number of bits in the byte enable signal for a word. This indicates which bytes within the word are active during a write operation.\n\n---\n\n### **Derived Parameters**\n- **`TAG_WIDTH`**:  \n  The bit-width of the tag portion of the address. It is calculated as:\n 32 - `CS_LINE_ADDR_WIDTH`+ log2(`WORD_SIZE`) + `WORD_SEL_WIDTH` \n\n- **`CS_WORD_WIDTH`**: \n   word width in bits . It is calculated as WORD_SIZE * 8 \n    \n- **`DATA_WIDTH`**:  \n  Defines the total data width for each MSHR entry. It is calculated as:\n `WORD_SEL_WIDTH` + `WORD_SIZE` + `CS_WORD_WIDTH` + `TAG_WIDTH` \n\n- **`MSHR_ADDR_WIDTH`**:  \n  Defines the number of bits required to address all entries in the MSHR. It is calculated as:\n `$clog2(MSHR_SIZE)` \n---\n\n### Port List\n\n| **Port Name**                           | **Direction** | **Description**                                                                                |\n|-----------------------------------------|---------------|------------------------------------------------------------------------------------------------|\n| `clk`                                   | Input         | Clock signal.  The design registers are triggered on its positive edge.                        |\n| `reset`                                 | Input         | Active high synchronous reset signal                                                           |\n| `allocate_valid`                        | Input         | Active high signal indicating a new core request for allocation.                               |\n| `allocate_addr[CS_LINE_ADDR_WIDTH-1:0]` | Input         | Cache line address of the new request.                                                         |\n| `allocate_data[DATA_WIDTH-1:0]`         | Input         | Request data containing the word address, byte enable signal, write data, and tag information. |\n| `allocate_rw`                           | Input         | Read/write operation type for the new request. 1'b1 = write request, 1'b0 = read request       | \n| `allocate_id[MSHR_ADDR_WIDTH-1:0]`      | Output        | ID of the allocated slot.                                                                      |\n| `allocate_pending`                      | Output        | Active high signal indicating if a new request is for a cache line that is already pending.    |\n| `allocate_previd[MSHR_ADDR_WIDTH-1:0]`  | Output        | ID of the previous entry for the same cache line if `allocate_pending` asserted.               |\n| `allocate_ready`                        | Output        | Active high signal indicating if a new request can be allocated. If MSHR isn't full            |\n| `finalize_valid`                        | Input         | Active high signal indicating a finalize operation is being requested.                         |\n| `finalize_id[MSHR_ADDR_WIDTH-1:0]`      | Input         | ID of the entry being finalized.                                                               |\n\n\n### Functional description:\nThis design should integrate seamlessly into a non-blocking cache system with a 32-bit address system, where tag access and MSHR access occur in parallel.\n- On core request, `allocate_valid`, the MSHR allocates an entry for the incoming core request, regardless of whether it is a hit or miss. `allocate_valid` could only be asserted when `allocate_ready` is asserted, indicating there is an available MSHR entry\n- In the subsequent cycle, the cache tag access determines if the request is a hit or miss. If the request is a cache hit, the allocated MSHR entry is immediately marked invalid. `finalize_valid` will be asserted only on cache hit, `finalize_id` should be one of the allocated indexes.\n\n---\n## Testbench Requirements\n\n### Instantiation\n\nName the instance of the RTL as `dut`.\n\n### Required Stimulus Description:\nThe objective is to achieve **100% code and toggle coverage** for the `cache_mshr` module by systematically exercising its functionality. The stimulus should ensure that all key features and transitions of the module are exercised while maintaining coverage goals.\n- Use a `cache_mshr` instance named `dut` in the testbench. \n- Supply stimulus to ensure that all MSHR entries are allocated during simulation, randomly asserting  `allocate_valid` at random clock negative edges and randomize input signals: `allocate_addr`, `allocate_data`, and `allocate_rw`.\n- Supply stimulus to ensure that all MSHR entries are finalized during simulation, randomly asserting  `finalize_valid` at random clock negative with `finalize_id` one of the allocated slots.\n- Fully exercise state transitions for every entry, including toggling between **write** and **read** operations.\n- Fully exercise cases where each entry points to the next request for the same cache line ( eg: use a fixed cache line)\n- Cover the module\u2019s behavior when the MSHR reaches full capacity, including the deassertion of `allocate_ready`.\n- Cover that `allocate_ready` is reasserted when entries are finalized and space becomes available.\n- Generate stimuli for both cache hit and miss scenarios randomly to ensure proper entry finalization and release.\n\n### Latency:\n- Allocation Requests: The module introduces a latency of 1 clock cycle for each allocation request.\n- Finalize Requests: The module introduces a latency of 1 clock cycle for each finalize release request.", "context": {}}, "output": {"response": "", "context": {"verif/tb_cache_mshr.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = \"feature/verification_dp_1\"\nTARGET = 100\n", "src/cache_mshr.sv": "`define NOTCONNECTED_PIN(x)   /* verilator lint_off PINCONNECTEMPTY */ \\\n                        . x () \\\n                        /* verilator lint_on PINCONNECTEMPTY */\n\nmodule cache_mshr #(\n    parameter INSTANCE_ID            = \"mo_mshr\"             ,\n    parameter MSHR_SIZE                     = 32                    ,\n    parameter CS_LINE_ADDR_WIDTH            = 10                    ,\n    parameter WORD_SEL_WIDTH                = 4                     ,\n    parameter WORD_SIZE                     = 4                     ,\n    // Derived parameters\n    parameter MSHR_ADDR_WIDTH               = $clog2(MSHR_SIZE)     , // default = 5\n    parameter TAG_WIDTH                     = 32 - (CS_LINE_ADDR_WIDTH+ $clog2(WORD_SIZE) + WORD_SEL_WIDTH), // default = 16\n    parameter CS_WORD_WIDTH                 = WORD_SIZE * 8 ,// default = 32 \n    parameter DATA_WIDTH                    = WORD_SEL_WIDTH + WORD_SIZE + CS_WORD_WIDTH + TAG_WIDTH // default =  4 + 4 + 32 + 16 = 56\n\n    ) (\n    input wire clk,\n    input wire reset,\n\n    // allocate\n    input wire                          allocate_valid,\n    output wire                         allocate_ready,\n    input wire [CS_LINE_ADDR_WIDTH-1:0] allocate_addr,\n    input wire                          allocate_rw,\n    input wire [DATA_WIDTH-1:0]         allocate_data,\n    output wire [MSHR_ADDR_WIDTH-1:0]   allocate_id,\n    output wire                         allocate_pending,\n    output wire [MSHR_ADDR_WIDTH-1:0]   allocate_previd,\n\n    // finalize\n    input wire                          finalize_valid,\n    input wire [MSHR_ADDR_WIDTH-1:0]    finalize_id\n);\n\n    reg [CS_LINE_ADDR_WIDTH-1:0] cs_line_addr_table [0:MSHR_SIZE-1];\n    reg [MSHR_SIZE-1:0] entry_valid_table_q, entry_valid_table_d;\n    reg [MSHR_SIZE-1:0] is_write_table;\n\n    reg [MSHR_SIZE-2:0] next_ptr_valid_table_q, next_ptr_valid_table_d;\n    reg [MSHR_ADDR_WIDTH-1:0] next_index_ptr [0:MSHR_SIZE-1]; // ptr to the next index\n\n    reg                         allocate_pending_q, allocate_pending_d;\n\n\n    reg [MSHR_ADDR_WIDTH-1:0] allocate_id_q, allocate_id_d;\n\n\n    \n    wire [MSHR_ADDR_WIDTH-1:0] prev_idx ;\n    reg [MSHR_ADDR_WIDTH-1:0]  prev_idx_q;\n\n    wire allocate_fire = allocate_valid && allocate_ready;\n    \n    // Address lookup to find matches If there is a match ... link the latest req next ptr to the newly allocated idx\n    wire [MSHR_SIZE-1:0] addr_matches;\n    for (genvar i = 0; i < MSHR_SIZE; ++i) begin : g_addr_matches\n        assign addr_matches[i] = entry_valid_table_q[i] && (cs_line_addr_table[i] == allocate_addr) && allocate_fire;\n    end\n\n    wire [MSHR_SIZE-1:0] match_with_no_next = addr_matches & ~next_ptr_valid_table_q ;\n    wire full_d ; \n\n    leading_zero_cnt #(\n            .DATA_WIDTH (MSHR_SIZE),\n            .REVERSE (1)\n    ) allocate_idx (\n            .data   (~entry_valid_table_q),\n            .leading_zeros  (allocate_id_d),\n            .all_zeros (full_d)\n    );\n\n    leading_zero_cnt #(\n            .DATA_WIDTH (MSHR_SIZE),\n            .REVERSE (1)\n    ) allocate_prev_idx (\n            .data   (match_with_no_next),\n            .leading_zeros  (prev_idx),\n            `NOTCONNECTED_PIN(all_zeros) // not connected\n    );\n    \n    always @(*) begin\n        entry_valid_table_d     = entry_valid_table_q;\n        next_ptr_valid_table_d  = next_ptr_valid_table_q;\n        \n    \n        if (finalize_valid) begin\n            entry_valid_table_d[finalize_id] = 0;\n        end\n\n        if (allocate_fire) begin\n            entry_valid_table_d[allocate_id_d] = 1;\n            next_ptr_valid_table_d[allocate_id_d] = 0;\n        end\n\n        if (allocate_pending_d) begin\n            next_ptr_valid_table_d[prev_idx] = 1;\n        end\n    end\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            entry_valid_table_q  <= '0;\n            next_ptr_valid_table_q  <=  0;\n            allocate_pending_q <= 0 ;\n        end else begin\n            entry_valid_table_q  <= entry_valid_table_d;\n            next_ptr_valid_table_q  <= next_ptr_valid_table_d;\n            allocate_pending_q <= allocate_pending_d ; \n        end\n\n        if (allocate_fire) begin\n            cs_line_addr_table[allocate_id_d]   <= allocate_addr;\n            is_write_table[allocate_id_d]       <= allocate_rw;\n        end\n\n        if (allocate_pending_d) begin\n            next_index_ptr[prev_idx] <= allocate_id_d;\n        end\n\n\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            allocate_id_q       <=  0 ;\n            prev_idx_q          <= 0 ;\n        end else begin\n            if (allocate_fire) begin\n                allocate_id_q       <=  allocate_id_d       ;\n                prev_idx_q          <= prev_idx ;\n            end \n        end\n    end\n\n    // SP RAM\n    reg [DATA_WIDTH-1:0] ram [0:MSHR_SIZE-1];\n    always @(posedge clk) begin\n        if (allocate_fire) begin\n            ram[allocate_id_d] <= allocate_data ;\n        end\n    end\n\n    \n    \n    assign  allocate_pending_d = |addr_matches;\n    assign allocate_id = allocate_id_q ;\n    assign allocate_ready = ~full_d ;\n    assign allocate_previd = prev_idx_q;\n\n    assign allocate_pending = allocate_pending_q;\n`ifdef DEBUG_PRINT \n    reg show_table;\n    always @(posedge clk) begin\n        if (reset) begin\n            show_table <= 0;\n        end else begin\n            show_table <= allocate_fire || finalize_valid ;\n        end\n        if (allocate_fire) begin\n            $write(\"%t: %s allocate: addr=0x%0h, id=%0d, pending=%b, prev=%0d \\n\", $time, INSTANCE_ID,\n                allocate_addr, allocate_id, allocate_pending_d, prev_idx) ;\n        end\n        if (finalize_valid ) begin\n            $write(\"%t: %s release: id=%0d \\n\", $time, INSTANCE_ID, finalize_id);\n        end\n        \n        if (show_table) begin\n            $write(\"%t: %s table\", $time, INSTANCE_ID);\n            for (integer i = 0; i < MSHR_SIZE; ++i) begin\n                if (entry_valid_table_q[i]) begin\n                    $write(\" %0d=0x%0h\", i, cs_line_addr_table[i]);\n                    if (is_write_table[i]) begin\n                        $write(\"(w)\");\n                    end else begin\n                        $write(\"(r)\");\n                    end\n                    if (next_ptr_valid_table_q[i])  begin\n                        $write(\"->%d\", next_index_ptr[i] );\n                    end\n                end\n            end\n            $write(\"\\n\");\n        end\n    end\n`endif\n\n\nendmodule\n\n\nmodule leading_zero_cnt #(\n    parameter DATA_WIDTH = 32,\n    parameter REVERSE = 0 \n)(\n    input  [DATA_WIDTH -1:0] data,\n    output  [$clog2(DATA_WIDTH)-1:0] leading_zeros,\n    output all_zeros \n);\n    localparam NIBBLES_NUM = DATA_WIDTH/4 ; \n    reg [NIBBLES_NUM-1 :0] all_zeros_flag ;\n    reg [1:0]  zeros_cnt_per_nibble [NIBBLES_NUM-1 :0]  ;\n\n    genvar i;\n    integer k ;\n    // Assign data/nibble \n    reg [3:0]  data_per_nibble [NIBBLES_NUM-1 :0]  ;\n    generate\n        for (i=0; i < NIBBLES_NUM ; i=i+1) begin\n            always @* begin\n                data_per_nibble[i] = data[(i*4)+3: (i*4)] ;\n            end\n        end\n    endgenerate\n   \n    generate\n        for (i=0; i < NIBBLES_NUM ; i=i+1) begin : g_nibble\n            if (REVERSE) begin : g_trailing\n                always @* begin\n                        zeros_cnt_per_nibble[i] [1] = ~(data_per_nibble[i][1] | data_per_nibble[i][0]); \n                        zeros_cnt_per_nibble[i] [0] = (~data_per_nibble[i][0]) &\n                                                      ((~data_per_nibble[i][2]) | data_per_nibble[i][1]);\n                        all_zeros_flag[i] = (data_per_nibble[i] == 4'b0000);\n                end\n            end else begin :g_leading\n                always @* begin\n                    zeros_cnt_per_nibble[NIBBLES_NUM-1-i][1] = ~(data_per_nibble[i][3] | data_per_nibble[i][2]); \n                    zeros_cnt_per_nibble[NIBBLES_NUM-1-i][0] = (~data_per_nibble[i][3]) &\n                                     ((~data_per_nibble[i][1]) | data_per_nibble[i][2]);\n                    \n                    all_zeros_flag[NIBBLES_NUM-1-i] = (data_per_nibble[i] == 4'b0000);\n                end\n            end\n        end\n    endgenerate\n\n    \n    \n    reg [$clog2(NIBBLES_NUM)-1:0] index ; \n    reg [1:0]    choosen_nibbles_zeros_count ;\n    reg [ $clog2(NIBBLES_NUM*4)-1:0] zeros_count_result ;\n    wire [NIBBLES_NUM-1:0]         all_zeros_flag_decoded;\n    \n    assign all_zeros_flag_decoded[0] = all_zeros_flag[0] ;\n    genvar j;\n        generate\n            for (j=1; j < NIBBLES_NUM; j=j+1) begin\n                assign all_zeros_flag_decoded[j] = all_zeros_flag_decoded[j-1] & all_zeros_flag[j];\n            end\n        endgenerate\n\n    always@ * begin\n        index = 0 ;\n        for ( k =0 ; k< NIBBLES_NUM ; k =k +1) begin\n            index = index + all_zeros_flag_decoded[k] ;\n        end\n    end\n    \n    always@* begin\n        choosen_nibbles_zeros_count = zeros_cnt_per_nibble[index]  ;  \n        zeros_count_result = choosen_nibbles_zeros_count + (index <<2) ; \n    end\n    \n    assign leading_zeros =  zeros_count_result ;\n    assign all_zeros = (data ==0) ;\n\nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Simulation didn't run correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage merge didn't run correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    try:\n        with open(\"/code/rundir/coverage.log\") as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage.log file.\")\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    print(\"Parsed Metrics:\")\n    print(metrics)\n\n    # Ensure TARGET environment variable is set\n    target = os.getenv(\"TARGET\")\n    if not target:\n        raise ValueError(\"TARGET environment variable is not set.\")\n    target = float(target)\n\n    # Check coverage for the DUT or specific key\n    dut = \"dut\"  # Replace this with the DUT key you want to check\n    if dut in metrics and \"Overall Average\" in metrics[dut]:\n        assert float(metrics[dut][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        # Log available keys for debugging\n        print(f\"Available keys in metrics: {metrics.keys()}\")\n        assert False, f\"Coverage data for '{dut}' is not available.\"\n"}}}
{"id": "cvdp_copilot_Serial_Line_Converter_0006", "categories": ["cid012", "easy"], "input": {"prompt": "Complete the given partial SystemVerilog testbench `serial_line_code_converter_tb`. The testbench must instantiate the `serial_line_code_converter` RTL module and provide input stimulus to validate its functionality. This module implements various serial line coding techniques. The testbench should include different input scenarios, such as different encoding schemes, edge cases, and invalid input handling. \n\n---\n\n## Description\n\nThe serial_line_code_converter module is a Verilog-based design that converts serial input data into different encoding formats based on the selected mode. The module utilizes clock division, edge detection, and various encoding techniques to modify the serial input and produce the corresponding encoded serial output.\n\n### Encoding Implementations\n1. **NRZ (Non-Return-to-Zero)**: Direct pass-through of `serial_in`.\n2. **RZ (Return-to-Zero)**: Outputs high only during the first half of the clock cycle when `serial_in` is high.\n3. **Differential Encoding**: Outputs the XOR of the current and previous serial input.\n4. **Inverted NRZ**: Outputs the inverted value of `serial_in`.\n5. **NRZ with Alternating Bit Inversion**: Inverts every alternate bit of `serial_in`.\n6. **Parity Bit Output (Odd Parity)**: Generates an odd parity bit based on the serial input.\n7. **Scrambled NRZ**: XORs `serial_in` with the least significant bit of the clock counter for scrambling.\n8. **Edge-Triggered NRZ**: Detects rising edges of `serial_in` and outputs accordingly.\n\n### Parameters\n- **`CLK_DIV`**: Specifies the clock divider for generating clk_pulse. The default value is 16. It must be a positive integer greater than or equal to 2.\n\n### Inputs:\n- **clk**: System clock signal. The design operates synchronously with the rising edge of `clk`.\n- **reset_n**:  Active-low asynchronous reset signal. When asserted low, it resets all internal states and outputs.\n- **serial_in**:  1-bit Input signal carrying the serial data stream to be encoded according to the selected mode.\n- **mode [2:0]**: A 3-bit input that determines the encoding mode. Possible values:\n  - `000`: NRZ (Non-Return-to-Zero).\n  - `001`: RZ (Return-to-Zero).\n  - `010`: Differential Encoding.\n  - `011`: Inverted NRZ.\n  - `100`: NRZ with Alternating Bit Inversion.\n  - `101`: Parity Bit Output (Odd Parity).\n  - `110`: Scrambled NRZ.\n  - `111`: Edge-Triggered NRZ.\n\n### Outputs:\n- **serial_out**: Encoded  1-bit output signal. The encoding applied to `serial_in` is determined by the value of the `mode` input. The output updates on every clock cycle based on the selected encoding method.\n\n---\n\n## Testbench Setup\n\n### Clock Generation:\n- Generate a clock with a period of 10ns using an `always` block.\n\n### Reset Signal:\n- Apply an active-low reset signal at the beginning of the simulation to initialize the DUT.\n\n### Signal Initialization:\n- Initialize all testbench signals, including registers and tracking signals for the DUT behavior.\n\n### Feature Mode Identification:\n- Maintain an array of strings to define and identify the different encoding techniques implemented in the DUT.\n\n### DUT Instantiation:\n- Create an instance of the `serial_line_code_converter` module with appropriate connections for inputs and outputs.\n\n---\n\n## Behavioral Logic\n\n### Clock Division:\n- Simulate clock division logic in the testbench to mimic DUT timing for certain modes like RZ.\n\n### Previous State Tracking:\n- Track previous input values and states to validate encoding techniques like Differential and Edge-Triggered NRZ.\n\n### Special Mode Handling:\n- Implement specific logic for modes such as Alternate Inversion, Parity-Added, and Scrambled NRZ.\n\n---\n\n## Input Generation \n\n### Stimulus Generation:\n- Randomly generate serial input values (`serial_in`) for each encoding mode.\n- Iterate through all 8 modes, applying input stimuli and observing DUT behavior.\n\n---\n\n## Waveform Analysis\n- Generate a VCD file (`serial_line_code_converter.vcd`) to enable waveform analysis for debugging and verification.\n\n---\n\n## Test Scenarios\n\n### Test All Modes:\n- Test all 8 encoding modes in sequence.\n- For each mode, generate multiple input patterns.\n\n### Edge Case Validation:\n- Generate the inputs for edge cases such as alternating inputs, random noise, and reset behavior.\n\n### Partial Test Stimulus Generator Code :\n\n```verilog\nmodule serial_line_code_converter_tb;\n    parameter CLK_DIV = 6; // Clock division parameter for timing\n\n    // Testbench signals\n    logic clk, reset_n, serial_in, serial_out;\n    logic [2:0] mode;\n\n    // Tracking signals to mimic DUT behavior\n    logic [3:0] tb_counter;\n    logic tb_clk_pulse, tb_prev_serial_in, tb_alt_invert_state, tb_parity_out, tb_prev_value;\n\n    // Instantiate the Device Under Test\n    serial_line_code_converter #(CLK_DIV) dut (\n        .clk(clk),\n        .reset_n(reset_n),\n        .serial_in(serial_in),\n        .mode(mode),\n        .serial_out(serial_out)\n    );\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk; // Clock period of 10ns\n    end\n\n    // Initialize signals\n    initial begin\n        tb_counter = 0;\n        tb_clk_pulse = 0;\n        tb_prev_serial_in = 0;\n        tb_prev_value = 0;\n        tb_alt_invert_state = 0;\n        tb_parity_out = 0;\n        reset_n = 0;\n        serial_in = 0;\n        mode = 3'b000;\n\n        // Apply reset\n        @(negedge clk) reset_n = 1;\n        @(posedge clk);\n    end\n\n    // Insert the code for the remaining test stimulus here\n\nendmodule\n```", "context": {}}, "output": {"response": "", "context": {"verif/serial_line_code_converter_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro \n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 86d1e0a9c5f887d24e620a0a017f8bb02a9bba39\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n", "src/serial_line_code_converter.sv": "module serial_line_code_converter #(parameter CLK_DIV = 16)(\n    input  logic clk,             // System clock\n    input  logic reset_n,         // Active-low reset\n    input  logic serial_in,       // Serial input signal\n    input  logic [2:0] mode,      // Mode selector\n    output logic serial_out       // Serial output signal\n);\n\n    // Internal signals\n    logic [3:0] clk_counter;      // Clock divider counter\n    logic clk_pulse;              // Clock pulse for sampling\n    logic prev_serial_in;         // Previous serial input for edge detection\n    logic prev_value;             // Holds the previous value of serial_in\n    logic nrz_out;                // NRZ encoding output\n    logic rz_out;                 // Return-to-Zero encoding output\n    logic diff_out;               // Differential encoding output\n    logic inv_nrz_out;            // Inverted NRZ output\n    logic alt_invert_out;         // NRZ with alternating bit inversion output\n    logic alt_invert_state;       // State for alternating inversion\n    logic parity_out;             // Parity Bit Output\n    logic scrambled_out;          // Scrambled NRZ output\n    logic edge_triggered_out;     // Edge-Triggered NRZ output\n\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            clk_counter <= 0;\n            clk_pulse <= 0;\n        end else if (clk_counter == CLK_DIV - 1) begin\n            clk_counter <= 0;\n            clk_pulse <= 1;\n        end else begin\n            clk_counter <= clk_counter + 1;\n            clk_pulse <= 0;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            prev_value <= 0;\n            prev_serial_in <= 0;\n        end else begin\n            prev_value <= serial_in;\n            prev_serial_in <= prev_value;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            nrz_out <= 0;\n        end else begin\n            nrz_out <= serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            rz_out <= 0;\n        end else begin\n            rz_out <= serial_in & clk_pulse; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            diff_out <= 0;\n        end else  begin\n            diff_out <= serial_in ^ prev_serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            inv_nrz_out <= 0;\n        end else  begin\n            inv_nrz_out <= ~serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            alt_invert_out <= 0;\n            alt_invert_state <= 0;\n        end else  begin\n            alt_invert_state <= ~alt_invert_state; \n            alt_invert_out <= alt_invert_state ? ~serial_in : serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            parity_out <= 0;\n        end else  begin\n            parity_out <= serial_in ^ parity_out; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            scrambled_out <= 0;\n        end else  begin\n            scrambled_out <= serial_in ^ clk_counter[0]; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            edge_triggered_out <= 0;\n        end else  begin\n            edge_triggered_out <= (serial_in & ~prev_serial_in);\n        end\n    end\n\n    always_comb begin\n        case (mode)\n            3'b000: serial_out = nrz_out;                // NRZ\n            3'b001: serial_out = rz_out;                 // Return-to-Zero\n            3'b010: serial_out = diff_out;               // Differential Encoding\n            3'b011: serial_out = inv_nrz_out;            // Inverted NRZ\n            3'b100: serial_out = alt_invert_out;         // NRZ with alternating bit inversion\n            3'b101: serial_out = parity_out;             // Parity Bit Output\n            3'b110: serial_out = scrambled_out;          // Scrambled NRZ\n            3'b111: serial_out = edge_triggered_out;     // Edge-Triggered NRZ\n            default: serial_out = 0;                     // Default to 0\n        endcase\n    end\n\nendmodule"}}}
{"id": "cvdp_copilot_Serial_Line_Converter_0019", "categories": ["cid014", "medium"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the `serial_line_code_converter` module based on the design specifications provided? Please ensure that your assertions include clear error messages for simulation failures and follow industry standards for concise, effective verification.\n\n## Interface\n\n### Parameters\n- **`CLK_DIV`**: Specifies the clock divider for generating clk_pulse. The default value is 16. It must be a positive integer greater than or equal to 2.\n\n### Inputs\n- **`clk`**: System clock signal. The design operates synchronously with the rising edge of `clk`.\n- **`reset_n`**: Active-low asynchronous reset signal. When asserted low, it resets all internal states and outputs.\n- **`serial_in`**: Input signal carrying the serial data stream to be encoded according to the selected mode.\n- **`mode [2:0] `**: A 3-bit input that determines the encoding mode. Possible values:\n  - `000`: NRZ (Non-Return-to-Zero).\n  - `001`: RZ (Return-to-Zero).\n  - `010`: Differential Encoding.\n  - `011`: Inverted NRZ.\n  - `100`: NRZ with Alternating Bit Inversion.\n  - `101`: Parity Bit Output (Odd Parity).\n  - `110`: Scrambled NRZ.\n  - `111`: Edge-Triggered NRZ.\n\n### Outputs\n- **`serial_out`**: Encoded output signal. The encoding applied to `serial_in` is determined by the value of the `mode` input. The output updates on every clock cycle based on the selected encoding method.\n\n## Design Specifications\n\nThe module implements several encoding schemes and uses internal signals and registers to capture previous input values, generate a clock pulse via a divider, and compute various encoded outputs:\n\n### Clock Divider and Sampling Pulse:\n\n- A counter increments on each clock cycle and resets when it reaches CLK_DIV - 1.\n- A sampling pulse is generated high for one clock cycle when the counter resets; this pulse is used for the Return-to-Zero mode.\n\n### Edge Detection and Input History:\n\n- The module captures previous values of serial_in in registers (prev_value and prev_serial_in) to facilitate edge detection and differential encoding.\n\n### Encoding Implementations\n1. **NRZ (Non-Return-to-Zero)**: Direct pass-through of `serial_in`.\n2. **RZ (Return-to-Zero)**: Outputs high only during the first half of the clock cycle when `serial_in` is high.\n3. **Differential Encoding**: Outputs the XOR of the current and previous serial input.\n4. **Inverted NRZ**: Outputs the inverted value of `serial_in`.\n5. **NRZ with Alternating Bit Inversion**: Inverts every alternate bit of `serial_in`.\n6. **Parity Bit Output (Odd Parity)**: Generates an odd parity bit based on the serial input.\n7. **Scrambled NRZ**: XORs `serial_in` with the least significant bit of the clock counter for scrambling.\n8. **Edge-Triggered NRZ**: Detects rising edges of `serial_in` and outputs accordingly.\n\n## Assertion Requirements\n\nDevelop a set of SystemVerilog assertions to validate the following behaviors: All assertions are evaluated on the rising edge of clk and assertions are disabled when reset_n is low.\n\n#### NRZ Mode (3'b000):\n- **Condition**: Mode is `3'b000`.\n- **Expected Behavior**: `serial_out` must equal the current sampled value of `serial_in`.\n\n#### Return-to-Zero (RZ) Mode (3'b001):\n- **Condition**: Mode is `3'b001`.\n- **Expected Behavior**: `serial_out` must equal the logical AND of `serial_in` and `clk_pulse`.\n\n#### Differential Encoding Mode (3'b010):\n- **Condition**: Mode is `3'b010`.\n- **Expected Behavior**: `serial_out` must be the XOR of the current `serial_in` and its previous state.\n\n#### Inverted NRZ Mode (3'b011):\n- **Condition**: Mode is `3'b011`.\n- **Expected Behavior**: `serial_out` must equal the inverted `serial_in`.\n\n#### Alternating Inversion Mode (3'b100):\n- **Condition**: Mode is `3'b100`.\n- **Expected Behavior**: `serial_out` must alternate between `serial_in` and its inverted value on successive clock cycles.\n\n#### Parity Mode (3'b101):\n- **Condition**: Mode is `3'b101`.\n- **Expected Behavior**: `serial_out` should equal the XOR of `serial_in` and the accumulated parity bit.\n\n#### Scrambled NRZ Mode (3'b110):\n- **Condition**: Mode is `3'b110`.\n- **Expected Behavior**: `serial_out` must equal the XOR of `serial_in` and the least-significant bit of the clock divider counter.\n\n#### Edge-Triggered NRZ Mode (3'b111):\n- **Condition**: Mode is `3'b111`.\n- **Expected Behavior**: `serial_out` must be high only when a rising edge is detected on `serial_in`.\n\nCan you add SystemVerilog assertions to this RTL design to validate all of the specified behaviors and ensure that each encoding mode operates according to the detailed specifications? Please include descriptive error messages for any simulation failures and follow industry standards for concise, effective verification.", "context": {"rtl/serial_line_code_converter.sv": "module serial_line_code_converter #(parameter CLK_DIV = 16)(\n    input  logic clk,             // System clock\n    input  logic reset_n,         // Active-low reset\n    input  logic serial_in,       // Serial input signal\n    input  logic [2:0] mode,      // Mode selector\n    output logic serial_out       // Serial output signal\n);\n\n    // Internal signals\n    logic [3:0] clk_counter;      // Clock divider counter\n    logic clk_pulse;              // Clock pulse for sampling\n    logic prev_serial_in;         // Previous serial input for edge detection\n    logic prev_value;             // Holds the previous value of serial_in\n    logic nrz_out;                // NRZ encoding output\n    logic rz_out;                 // Return-to-Zero encoding output\n    logic diff_out;               // Differential encoding output\n    logic inv_nrz_out;            // Inverted NRZ output\n    logic alt_invert_out;         // NRZ with alternating bit inversion output\n    logic alt_invert_state;       // State for alternating inversion\n    logic parity_out;             // Parity Bit Output\n    logic scrambled_out;          // Scrambled NRZ output\n    logic edge_triggered_out;     // Edge-Triggered NRZ output\n\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            clk_counter <= 0;\n            clk_pulse <= 0;\n        end else if (clk_counter == CLK_DIV - 1) begin\n            clk_counter <= 0;\n            clk_pulse <= 1;\n        end else begin\n            clk_counter <= clk_counter + 1;\n            clk_pulse <= 0;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            prev_value <= 0;\n            prev_serial_in <= 0;\n        end else begin\n            prev_value <= serial_in;\n            prev_serial_in <= prev_value;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            nrz_out <= 0;\n        end else begin\n            nrz_out <= serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            rz_out <= 0;\n        end else begin\n            rz_out <= serial_in & clk_pulse; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            diff_out <= 0;\n        end else  begin\n            diff_out <= serial_in ^ prev_serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            inv_nrz_out <= 0;\n        end else  begin\n            inv_nrz_out <= ~serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            alt_invert_out <= 0;\n            alt_invert_state <= 0;\n        end else  begin\n            alt_invert_state <= ~alt_invert_state; \n            alt_invert_out <= alt_invert_state ? ~serial_in : serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            parity_out <= 0;\n        end else  begin\n            parity_out <= serial_in ^ parity_out; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            scrambled_out <= 0;\n        end else  begin\n            scrambled_out <= serial_in ^ clk_counter[0]; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            edge_triggered_out <= 0;\n        end else  begin\n            edge_triggered_out <= (serial_in & ~prev_serial_in);\n        end\n    end\n\n    always_comb begin\n        case (mode)\n            3'b000: serial_out = nrz_out;                \n            3'b001: serial_out = rz_out;                 \n            3'b010: serial_out = diff_out;               \n            3'b011: serial_out = inv_nrz_out;            \n            3'b100: serial_out = alt_invert_out;         \n            3'b101: serial_out = parity_out;             \n            3'b110: serial_out = scrambled_out;          \n            3'b111: serial_out = edge_triggered_out;     \n            default: serial_out = 0;                     \n        endcase\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/serial_line_code_converter.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/serial_line_code_converter.sv\nTOPLEVEL        = serial_line_code_converter\nMODULE          = test_serial_line_code_converter\nPYTHONPATH      = /src\nRANDOM_SEED     = 1735141348\nHASH            = c1de9d38616f093f828f98be1e471e224e3b1141", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_serial_line_code_converter.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ReadOnly, Timer\n\nimport harness_library as hrs_lb\nimport random\n\n# Function to calculate the expected output based on mode\ndef calculate_expected_output(serial_in, prev_serial_in, mode, clk_pulse, counter, parity_state, invert_state):\n    if mode == 0:  # NRZ\n        return serial_in\n    elif mode == 1:  # Return-to-Zero\n        return serial_in and clk_pulse\n    elif mode == 2:  # Differential Encoding\n        return serial_in ^ prev_serial_in\n    elif mode == 3:  # Inverted NRZ\n        return not serial_in\n    elif mode == 4:  # Alternate Inversion\n        return not serial_in if invert_state else serial_in\n    elif mode == 5:  # Parity-Added\n        return parity_state ^ serial_in\n    elif mode == 6:  # Scrambled NRZ\n        return serial_in ^ (counter % 2)\n    elif mode == 7:  # Edge-Triggered NRZ\n        return serial_in and not prev_serial_in\n    return 0\n\n@cocotb.test()\nasync def test_serial_line_code_converter(dut):\n    CLK_DIV = int(dut.CLK_DIV.value)\n\n    # Start the clock with a 10ns time period (100 MHz clock)\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n\n    # Local variables to simulate RTL behavior\n    tb_counter = 0\n    tb_clk_pulse = 0\n    tb_parity_state = 0\n    tb_alt_invert_state = 0\n    prev_serial_in = 0\n\n    await Timer(10, units=\"ns\")\n\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=True)\n\n    await RisingEdge(dut.clk) \n\n\n    # Handle reset behavior\n    if dut.reset_n.value == 0:\n        tb_counter = 0\n        tb_clk_pulse = 0\n        tb_parity_state = 0\n        tb_alt_invert_state = 0\n        expected_output = 0\n    else:\n        # Update the clock counter and pulse\n        if tb_counter == CLK_DIV - 1:\n            tb_counter = 0\n            tb_clk_pulse = 1\n        else:\n            tb_counter += 1\n            tb_clk_pulse = 0\n\n        # Generate a random serial input\n        serial_in = random.randint(0, 1)\n        dut.serial_in.value = serial_in\n\n        # Update parity state for odd parity\n        tb_parity_state ^= serial_in\n\n        # Update alternating inversion state\n        tb_alt_invert_state = not tb_alt_invert_state\n\n    # Iterate over all modes\n    for mode in range(8):\n        dut.mode.value = mode\n\n        # Simulate for 10 cycles per mode\n        for i in range(10):\n            # Update test state variables\n\n            await FallingEdge(dut.clk)\n            serial_in = random.randint(0, 1)\n            dut.serial_in.value = serial_in\n\n\n            # Calculate expected output\n            expected_output = calculate_expected_output(\n                serial_in,\n                prev_serial_in,\n                mode,\n                tb_clk_pulse,\n                tb_counter,\n                tb_parity_state,\n                tb_alt_invert_state\n            )\n            \n\n            # Display current state and DUT outputs\n            dut._log.info(\n                f\"Mode: {mode} | serial_in: {serial_in} | prev_serial_in: {prev_serial_in} | serial_out: {int(dut.serial_out.value)} \"\n            )\n            await FallingEdge(dut.clk)\n            # Check DUT output\n            assert int(dut.serial_out.value) == expected_output, (\n                f\"Mode {mode}: Expected {expected_output}, Got {int(dut.serial_out.value)} \"\n                f\"for serial_in={serial_in}, prev_serial_in={prev_serial_in}, clk_pulse={int(tb_clk_pulse)}, counter={tb_counter}\"\n            )\n\n            # Update previous serial input\n            prev_serial_in = serial_in\n        \n\n\n        # Add separation between modes\n        await RisingEdge(dut.clk)\n\n    # Final message\n    dut._log.info(\"All modes and test cases passed.\")\n    await RisingEdge(dut.clk)\n    dut.reset_n.value = 0\n    await FallingEdge(dut.clk)\n    assert dut.serial_out.value == 0, \"serial_out should be 0 during reset\"\n    assert dut.clk_pulse.value == 0, \"clk_pulse should be 0 during reset\"\n    assert dut.clk_counter.value == 0, \"clk_counter should be 0 during reset\"\n    assert dut.prev_serial_in.value == 0, \"prev_serial_in should be 0 during reset\"\n    assert dut.alt_invert_state.value == 0, \"alt_invert_state should be 0 during reset\"\n    assert dut.parity_out.value == 0, \"parity_out should be 0 during reset\"\n    await RisingEdge(dut.clk)\n    dut.reset_n.value = 1\n    dut._log.info(\"Reset behavior passed. Resuming normal operation...\")\n\n    dut.mode.value = 0\n\n    await FallingEdge(dut.clk)\n    serial_in = random.randint(0, 1)\n    dut.serial_in.value = serial_in\n\n\n    # Calculate expected output\n    expected_output = calculate_expected_output(\n        serial_in,\n        prev_serial_in,\n        int(dut.mode.value),\n        tb_clk_pulse,\n        tb_counter,\n        tb_parity_state,\n        tb_alt_invert_state\n    )\n            \n    await FallingEdge(dut.clk)\n    # Check DUT output\n    assert int(dut.serial_out.value) == expected_output, (\n        f\"Mode {mode}: Expected {expected_output}, Got {int(dut.serial_out.value)} \"\n        f\"for serial_in={serial_in}, prev_serial_in={prev_serial_in}, clk_pulse={int(dut.clk_pulse.value)}, counter={tb_counter}\"\n    )\n\n    # Update previous serial input\n    prev_serial_in = serial_in\n        \n\n\n    # Add separation between modes\n    await RisingEdge(dut.clk)\n"}}}
{"id": "cvdp_copilot_Serial_Line_Converter_0021", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the SystemVerilog testbench `tb_serial_line_code_converter` to integrate a checker that verifies the functionality of the `serial_line_code_converter` module. The testbench already includes a stimulus generator for various test cases. The purpose of the testbench checker is to ensure that the `serial_line_code_converter` correctly implements all eight distinct serial encoding modes and that all associated status outputs (such as the diagnostic bus and error flags) behave as specified in the design requirements.\n\n\n## Design Specification\n\nThe Serial Line Code Converter module is responsible for transforming serial input data into different encoding schemes based on the selected mode. It supports various encoding techniques, including Non-Return-to-Zero (NRZ), Return-to-Zero (RZ), Differential, Inverted NRZ, Alternate Inversion, Parity-Added, Scrambled NRZ, and Edge-Triggered NRZ. The module ensures proper signal representation and error detection by monitoring the input and generating an appropriate serial output.\n\n### 1. Clock Pulse Generation\n- The module generates a clock pulse by dividing the system clock using the `CLK_DIV` parameter.\n- This pulse is used for timing and certain encoding schemes like Return-to-Zero (RZ).\n\n### 2. Previous Serial Input Tracking\n- The module uses two registers, `prev_serial_in` and `prev_value`, to remember the current and previous values of `serial_in`.\n- These values help detect edges or changes in the input signal for specific encoding modes.\n\n### 3. Encoding Implementations\n\n1. **NRZ (Non-Return-to-Zero)**:\n   - Directly passes the `serial_in` value to the output.\n  \n2. **RZ (Return-to-Zero)**:\n   - Outputs high  only during the clock pulse if `serial_in` is high.\n  \n3. **Differential Encoding**:\n   - Outputs the XOR of the current and previous `serial_in` values.\n  \n4. **Inverted NRZ**:\n   - Outputs the inverted value of `serial_in`.\n  \n5. **NRZ with Alternating Bit Inversion**:\n   - Alternates between inverting and not inverting the `serial_in` value.\n  \n6. **Parity Bit Output (Odd Parity)**:\n   - Generates a parity bit that ensures the total number of 1s in the data stream is odd.\n  \n7. **Scrambled NRZ**:\n   - XORs `serial_in` with a bit from the clock counter to create a scrambled output.\n  \n8. **Edge-Triggered NRZ**:\n   - Outputs high only when there is a rising edge in the `serial_in` signal.\n\n### 4. Enable Signal\n- **Enable Signal Control**:\n  - When disabled, the output is set to `0` and encoding is paused.\n  - When enabled , the module performs encoding based on the selected mode.\n\n### 5. Error Detection\n- The module detects invalid values (`1'bx` or `1'bz`) in `serial_in`.\n- If an error is found:\n  - The `error_flag` is set to `1`.\n  - The `error_counter` increments to track the total number of errors.\n\n### 6. Diagnostic Output Bus\nThe `diagnostic_bus` is a 16-bit output signal that provides detailed real-time status and debug information about the module's operation. Each bit or group of bits serves a specific purpose:\n  - **[15:13]**: Current encoding mode. Indicates the selected encoding mode is applied to the `serial_in` signal.\n  - **[12]**: Error flag. Signals whether an error (`1'bx` or `1'bz`) has been detected.\n  - **[11:4]**: Error counter. An 8-bit counter that tracks the total number of errors detected in `serial_in`.\n  - **[3]**: Clock divider pulse. It indicates the current state of the clock pulse.\n  - **[2]**: Encoded output. Reflects the current output of the selected encoding scheme.\n  - **[1]**: NRZ with Alternating Bit Inversion output. Shows the output of the NRZ encoding with alternating bit inversion.\n  - **[0]**: Parity bit output. Displays the computed odd parity bit for the input signal.\n\n## Testbench Components\n\n### Parameters:\n- **CLK_DIV**: Specifies the clock division factor for generating a clock pulse used in timing-specific encodings. The default value is 16, and it must be a positive integer greater than or equal to 2\n\n### Inputs:\n- **clk**: System clock signal. The design operates synchronously with the rising edge of `clk`.\n- **reset_n**: Active-low asynchronous reset signal. When asserted low, it resets all internal states and outputs.\n- **serial_in**: Input signal carrying the serial data stream to be encoded according to the selected mode.\n- **enable**: Enable signal to activate or deactivate the module's functionality; when low, the module outputs are disabled.\n- **mode [2:0]**: A 3-bit input that determines the encoding mode. Possible values:\n  - `000`: NRZ (Non-Return-to-Zero).\n  - `001`: RZ (Return-to-Zero).\n  - `010`: Differential Encoding.\n  - `011`: Inverted NRZ.\n  - `100`: NRZ with Alternating Bit Inversion.\n  - `101`: Parity Bit Output (Odd Parity).\n  - `110`: Scrambled NRZ.\n  - `111`: Edge-Triggered NRZ.\n\n### Outputs:\n- **serial_out**: Encoded output signal. The encoding applied to `serial_in` is determined by the value of the `mode` input. The output updates on every clock cycle based on the selected encoding method.\n- **error_flag**: Flag output indicating the presence of an error, set when `serial_in` is invalid (`1'bx` or `1'bz`).\n- **diagnostic_bus [15:0]**: A diagnostic bus providing debug and status information.\n\n---\n## Checker Requirements\n\nA dedicated checker as to be implemented in the testbench to verify the correctness of the output signals from the DUT (Device Under Test). The verification process ensures that the module adheres to expected behavior by validating outputs, error conditions, and diagnostic bus values.\n\n### 1. Output Verification\n\n- Compares the module\u2019s output with the expected value.\n- If there is a mismatch, an error is reported along with relevant details like the test feature, iteration number, and time.\n- If the output is correct, a success message is displayed.\n\n### 2. Enable Behavior Check\n\n- Ensures that when the module is disabled, it remains inactive.\n- If the module still produces an output or raises an error, an error message is logged.\n- When enabled, the module should function normally without unexpected errors.\n\n### 3. Error Flag Handling\n\n- Detects whether the module properly identifies invalid inputs.\n- If an invalid input is given, the module should raise an error flag.\n- If the input is valid, the error flag should remain inactive.\n- Any incorrect behavior triggers an error log.\n\n### 4. Diagnostic Bus Validation\n\n- Verifies that the diagnostic bus accurately represents the module\u2019s operating state.\n- Checks whether the module\u2019s mode, error status, and error counter are correctly reflected.\n- Ensures that when the module is disabled, the diagnostic bus remains inactive.\n- Any mismatch in expected and actual diagnostic values results in an error log.\n\n### Verification and Reporting\n\n- Each check runs automatically during the simulation.\n- If all conditions match expectations, the test case passes, and a confirmation message is printed.\n- If any condition fails, an error is logged, showing what was expected versus what was observed.\n- The system tracks test results, helping in debugging and ensuring the module works as intended.\n\n---\n\n## Deliverables\n\n1. **Complete SystemVerilog Testbench Code**\n   - DUT Instantiation: Correct parameterization and signal connections.\n   - Clock & Reset Logic: Proper clock generation and reset handling.\n   - Encoding Mode Tests: Validation of all 8 encoding modes.\n   - Enable & Error Handling Tests: Verification of module behavior.\n   - Diagnostic Bus Tests: Check diagnostic signal correctness.\n   - Assertions & Logging: Detailed error messages and pass/fail tracking.\n   - Waveform & Log Files: VCD output for post-simulation debugging.\n\n2. **Example Outputs**\n   - For each test case, the testbench should:\n     - Verify that `serial_out` behaves as expected.\n     - Confirm that `error_flag` is asserted correctly for invalid input.\n     - Ensure that `diagnostic_bus` correctly represents the module state.\n     - Log results in a structured format.\n", "context": {"verif/serial_line_code_converter_tb.sv": "`timescale 1ns/1ps\nmodule serial_line_code_converter_tb;\n    parameter CLK_DIV = 6; // Clock division parameter for timing\n\n    // Testbench signals\n    logic clk, reset_n, serial_in, enable;\n    logic [2:0] mode;\n    logic serial_out, error_flag;\n    logic [15:0] diagnostic_bus;\n    logic expected_out;\n\n    // Define the array for feature names\n    string features [7:0];\n\n    // Tracking signals to mimic DUT behavior\n    logic [3:0] tb_counter;\n    logic tb_clk_pulse, tb_prev_serial_in, tb_alt_invert_state, tb_parity_out, tb_prev_value;\n\n    // Instantiate the Device Under Test\n    serial_line_code_converter #(CLK_DIV) dut (\n        .clk(clk),\n        .reset_n(reset_n),\n        .serial_in(serial_in),\n        .enable(enable),\n        .mode(mode),\n        .serial_out(serial_out),\n        .error_flag(error_flag),\n        .diagnostic_bus(diagnostic_bus)\n    );\n\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk; \n    end\n\n    // Initialize signals and feature names\n    initial begin\n        tb_counter = 0;\n        tb_clk_pulse = 0;\n        tb_prev_serial_in = 0;\n        tb_prev_value = 0;\n        tb_alt_invert_state = 0;\n        tb_parity_out = 0;\n        reset_n = 0;\n        serial_in = 0;\n        mode = 3'b000;\n        enable = 0;\n        // Initialize feature names\n        features[0] = \"NRZ\";\n        features[1] = \"RZ\";\n        features[2] = \"Differential\";\n        features[3] = \"Inverted NRZ\";\n        features[4] = \"Alternate Inversion\";\n        features[5] = \"Parity-Added\";\n        features[6] = \"Scrambled NRZ\";\n        features[7] = \"Edge-Triggered NRZ\";\n\n        // Apply reset\n        @(negedge clk) reset_n = 1;\n        @(posedge clk);\n    end\n\n    // Logic to mimic DUT's clock division and pulse generation\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            tb_counter <= 0;\n            tb_clk_pulse <= 0;\n        end else if (tb_counter == CLK_DIV - 1) begin\n            tb_counter <= 0;\n            tb_clk_pulse <= 1;\n        end else begin\n            tb_counter <= tb_counter + 1;\n            tb_clk_pulse <= 0;\n        end\n    end\n\n    // Logic to update previous serial input state\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            tb_prev_value <= 0;\n            tb_prev_serial_in <= 0;\n        end else begin\n            tb_prev_value <= serial_in;\n            tb_prev_serial_in <= tb_prev_value;\n        end\n    end\n\n    // Logic for alternate inversion and parity bit calculation\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            tb_alt_invert_state <= 0;\n        end else begin\n            tb_alt_invert_state <= ~tb_alt_invert_state;\n        end\n    end\n\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            tb_parity_out <= 0;\n        end else begin\n            tb_parity_out <= tb_parity_out ^ serial_in; // Update parity bit with serial input\n        end\n    end\n\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            expected_out = 0;\n        end else begin\n            case (mode)\n                3'b000: expected_out = serial_in; // NRZ\n                3'b001: expected_out = serial_in & tb_clk_pulse; // RZ\n                3'b010: expected_out = serial_in ^ tb_prev_serial_in; // Differential\n                3'b011: expected_out = ~serial_in; // Inverted NRZ\n                3'b100: expected_out = tb_alt_invert_state ? ~serial_in : serial_in; // Alternate Inversion\n                3'b101: expected_out = tb_parity_out ^ serial_in; // Parity-Added\n                3'b110: expected_out = serial_in ^ tb_counter[0]; // Scrambled NRZ\n                3'b111: expected_out = serial_in & ~tb_prev_serial_in; // Edge-Triggered NRZ\n                default: expected_out = 0;\n            endcase\n        end\n    end\n\n    function string get_feature_name(input logic [2:0] mode);\n        if (!reset_n) begin\n            get_feature_name = \"Reset\";\n        end else begin\n            case (mode)\n                3'b000: get_feature_name = \"NRZ\";\n                3'b001: get_feature_name = \"RZ\";\n                3'b010: get_feature_name = \"Differential\";\n                3'b011: get_feature_name = \"Inverted NRZ\";\n                3'b100: get_feature_name = \"Alternate Inversion\";\n                3'b101: get_feature_name = \"Parity-Added\";\n                3'b110: get_feature_name = \"Scrambled NRZ\";\n                3'b111: get_feature_name = \"Edge-Triggered NRZ\";\n                default: get_feature_name = \"Unknown Mode\";\n            endcase\n        end\n    endfunction\n\n\n    task generate_invalid_inputs_test();\n        for (int i = 0; i < 5; i++) begin\n            serial_in = 1'bx;\n            enable = 1;\n            @(posedge clk);\n\n            @(negedge clk);\n            serial_in = 1'bz;\n            enable = 1;\n            @(posedge clk);\n\n        end\n    endtask\n\n\n    // Function to generate random input with enable testing\n    task generate_test_inputs();\n        for (int i = 0; i < 10; i++) begin\n            @(negedge clk);\n            serial_in = $random;\n            enable = $random & 1;\n            @(posedge clk);\n        end\n    endtask\n    task test_diagnostic_bus();\n        for (int i = 0; i < 20; i++) begin\n            @(negedge clk);\n            serial_in = $random;\n            mode = $random % 8;\n            enable = 1;\n            @(posedge clk);\n        end\n    endtask\n\n    initial begin\n\n        for (int m = 0; m < 8; m++) begin\n            enable = 1;\n            @(negedge clk);\n            mode = m;\n            $display(\"\\nTesting %s Encoding...\", get_feature_name(mode));\n            @(posedge clk); // Wait one cycle after mode change\n\n            for (int i = 0; i < 9; i++) begin\n                @(negedge clk);\n                serial_in = $random;\n                @(posedge clk);\n            end\n\n            #50;\n        end\n\n        @(posedge clk);\n        $display(\"\\nTesting enable behavior...\");\n        generate_test_inputs();\n        #50;\n        @(posedge clk);\n        $display(\"\\nTesting diagnostic bus...\");\n        test_diagnostic_bus();\n        @(posedge clk);\n        $display(\"Testing invalid inputs for error flag...\");\n        generate_invalid_inputs_test();\n        $display(\"\\nAll tests completed.\");\n        #100;\n        $finish;\n    end\n    // Generate VCD waveform file (optional)\n    initial begin\n        $dumpfile(\"serial_line_code_converter.vcd\");\n        $dumpvars(0, serial_line_code_converter_tb);\n    end\nendmodule"}}, "output": {"response": "", "context": {"verif/serial_line_code_converter_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH            = d6316ac494aad11b9fc97d8e1c0c9008ccaa008b\nNUM_BUGS        = 13", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"", "src/serial_line_code_converter.sv": "module serial_line_code_converter #(parameter CLK_DIV = 16)(\n    input  logic clk,                  // System clock\n    input  logic reset_n,              // Active-low reset\n    input  logic serial_in,            // Serial input signal\n    input  logic enable,               // Enable signal for the module\n    input  logic [2:0] mode,           // Mode selector\n    output logic serial_out,           // Serial output signal\n    output logic error_flag,           // Error flag\n    output logic [15:0] diagnostic_bus // New Diagnostic Output Bus\n);\n\n    // Internal signals\n    logic [3:0] clk_counter;      // Clock divider counter\n    logic clk_pulse;              // Clock pulse for sampling\n    logic prev_serial_in;         // Previous serial input for edge detection\n    logic prev_value;             // Holds the previous value of serial_in\n    logic nrz_out;                // NRZ encoding output\n    logic rz_out;                 // Return-to-Zero encoding output\n    logic diff_out;               // Differential encoding output\n    logic inv_nrz_out;            // Inverted NRZ output\n    logic alt_invert_out;         // NRZ with alternating bit inversion output\n    logic alt_invert_state;       // State for alternating inversion\n    logic parity_out;             // Parity Bit Output\n    logic scrambled_out;          // Scrambled NRZ output\n    logic edge_triggered_out;     // Edge-Triggered NRZ output\n    logic [7:0] error_counter;    // Error counter for diagnostics\n\n    // Clock divider with bug injection (BUG_0)\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            clk_counter <= 0;\n            clk_pulse <= 0;\n        end else if (clk_counter == CLK_DIV - 1) begin\n    `ifndef BUG_0\n            clk_counter <= 0;\n            clk_pulse <= 1;\n    `else\n            clk_counter <= clk_counter; // Bug: counter not reset\n            clk_pulse <= 0;             // Bug: pulse not asserted\n    `endif\n        end else begin\n            clk_counter <= clk_counter + 1;\n            clk_pulse <= 0;\n        end\n    end\n\n    // Previous value capture with bug injection (BUG_1)\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            prev_value <= 0;\n            prev_serial_in <= 0;\n        end else begin\n    `ifndef BUG_1\n            prev_value <= serial_in;\n            prev_serial_in <= prev_value;\n    `else\n            prev_value <= serial_in;\n            prev_serial_in <= serial_in; // Bug: no delay, causing edge detection issues\n    `endif\n        end\n    end\n\n    // Error detection with bug injection (BUG_2)\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            error_flag <= 0;\n            error_counter <= 0;\n        end else if (enable) begin\n    `ifndef BUG_2\n            if (serial_in === 1'bx || serial_in === 1'bz) begin\n                error_flag <= 1;\n                error_counter <= error_counter + 1;\n            end else begin\n                error_flag <= 0;\n            end\n    `else\n            // Bug: flag error when serial_in is 0 (even if legal)\n            if (serial_in === 1'b0) begin\n                error_flag <= 1;\n                error_counter <= error_counter + 1;\n            end else begin\n                error_flag <= 0;\n            end\n    `endif\n        end\n    end\n\n    // NRZ encoder with bug injection (BUG_3)\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            nrz_out <= 0;\n        end else begin\n    `ifndef BUG_3\n            nrz_out <= serial_in;\n    `else\n            nrz_out <= ~serial_in; // Bug: output inverted compared to intended behavior\n    `endif\n        end\n    end\n\n    // Return-to-Zero (RZ) encoder with bug injection (BUG_4)\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            rz_out <= 0;\n        end else begin\n    `ifndef BUG_4\n            rz_out <= serial_in & clk_pulse; \n    `else\n            rz_out <= serial_in | clk_pulse; // Bug: using OR instead of AND\n    `endif\n        end\n    end\n\n    // Differential encoder with bug injection (BUG_5)\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            diff_out <= 0;\n        end else begin\n    `ifndef BUG_5\n            diff_out <= serial_in ^ prev_serial_in;\n    `else\n            diff_out <= serial_in & prev_serial_in; \n    `endif\n        end\n    end\n\n    // Inverted NRZ encoder with bug injection (BUG_6)\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            inv_nrz_out <= 0;\n        end else begin\n    `ifndef BUG_6\n            inv_nrz_out <= ~serial_in;\n    `else\n            inv_nrz_out <= serial_in; // Bug: not inverting the input\n    `endif\n        end\n    end\n\n    // NRZ with alternating inversion with bug injection (BUG_7)\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            alt_invert_out <= 0;\n            alt_invert_state <= 0;\n        end else begin\n    `ifndef BUG_7\n            alt_invert_state <= ~alt_invert_state; \n            alt_invert_out <= alt_invert_state ? ~serial_in : serial_in;\n    `else\n            // Bug: state is not toggled, so no alternating inversion occurs\n            alt_invert_state <= alt_invert_state;\n            alt_invert_out <= serial_in;\n    `endif\n        end\n    end\n\n    // Parity generation with bug injection (BUG_8)\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            parity_out <= 0;\n        end else begin\n    `ifndef BUG_8\n            parity_out <= serial_in ^ parity_out; \n    `else\n            parity_out <= serial_in; // Bug: parity not accumulated\n    `endif\n        end\n    end\n\n    // Scrambler with bug injection (BUG_9)\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            scrambled_out <= 0;\n        end else begin\n    `ifndef BUG_9\n            scrambled_out <= serial_in ^ clk_counter[0]; \n    `else\n            scrambled_out <= serial_in ^ clk_counter[1]; // Bug: using a different bit of counter\n    `endif\n        end\n    end\n\n    // Edge-triggered NRZ with bug injection (BUG_10)\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            edge_triggered_out <= 0;\n        end else begin\n    `ifndef BUG_10\n            edge_triggered_out <= (serial_in & ~prev_serial_in);\n    `else\n            edge_triggered_out <= (serial_in & prev_serial_in); // Bug: logic reversed\n    `endif\n        end\n    end\n\n    // Multiplexer for serial_out with bug injection (BUG_11)\n    always_comb begin\n        if (!enable) begin\n            serial_out = 0;\n        end else begin\n            case (mode)\n                3'b000: serial_out = nrz_out;\n    `ifndef BUG_11\n                3'b001: serial_out = rz_out;\n                3'b010: serial_out = diff_out;\n                3'b011: serial_out = inv_nrz_out;\n    `else\n                // Bug: Swap RZ and Inverted NRZ for modes 1 and 3\n                3'b001: serial_out = inv_nrz_out;\n                3'b010: serial_out = diff_out;\n                3'b011: serial_out = rz_out;\n    `endif\n                3'b100: serial_out = alt_invert_out;\n                3'b101: serial_out = parity_out;\n                3'b110: serial_out = scrambled_out;\n                3'b111: serial_out = edge_triggered_out;\n                default: serial_out = 0;\n            endcase\n        end\n    end\n\n    // Diagnostic bus assignment with bug injection (BUG_12)\n    always_comb begin\n    `ifndef BUG_12\n        diagnostic_bus[15:13] = mode;\n    `else\n        diagnostic_bus[15:13] = 3'b000; // Bug: diagnostic always shows raw input\n    `endif\n        diagnostic_bus[12]    = error_flag;\n        diagnostic_bus[11:4]  = error_counter;\n        diagnostic_bus[3]     = clk_pulse;\n        diagnostic_bus[2] = (mode == 3'b000) ? nrz_out : \n                            (mode == 3'b001) ? rz_out : \n                            (mode == 3'b010) ? diff_out : \n                            (mode == 3'b011) ? inv_nrz_out : \n                            (mode == 3'b100) ? alt_invert_out : \n                            (mode == 3'b101) ? parity_out : \n                            (mode == 3'b110) ? scrambled_out : \n                            (mode == 3'b111) ? edge_triggered_out : 0;\n        diagnostic_bus[1] = alt_invert_out;\n        diagnostic_bus[0] = parity_out;\n    end\n\nendmodule\n"}}}
{"id": "cvdp_copilot_Synchronous_Muller_C_Element_0003", "categories": ["cid012", "easy"], "input": {"prompt": "Write a SystemVerilog testbench to only generate stimulus for a `sync_muller_c_element` design with configurable inputs and pipeline depth. This design processes input signals through a configurable pipeline and produces a single-bit output based on the state of the inputs in the final pipeline stage, outputting 1 only when all inputs are 1 and 0 only when all inputs are 0, while maintaining its state otherwise. \n\n---\n\n## Design Details\n\n### **Parameterization**\n1. **NUM_INPUT**: Specifies the number of input signals.\n   - Default: 2\n2. **PIPE_DEPTH**: Defines the number of pipeline stages.\n   - Default: 1\n\n### **Functional Behavior**\n1. **Pipeline Operation**:\n   - The pipeline captures and shifts the input states through `PIPE_DEPTH` stages.\n   - Inputs propagate stage by stage until they reach the final stage.\n2. **Output Logic**:\n   - The output signal is set based on the status of propagated input signals at the last pipeline stage.\n3. **Control Signal Behavior**:\n   - **Reset (`srst`)**: Active-high synchronous reset that clears the pipeline and output.\n   - **Clear (`clr`)**: Clears the pipeline and output without resetting.\n   - **Clock Enable (`clk_en`)**: Controls whether the pipeline registers update on the rising edge of the clock.\n\n### **Inputs and Outputs**\n- **Inputs**:\n  - `clk`: Clock signal.\n  - `srst`: Synchronous reset signal (active high).\n  - `clr`: Active high clear signal.\n  - `clk_en`: Active high clock enable signal.\n  - `inp[NUM_INPUT-1:0]`: NUM_INPUT-width vector representing the input signals.\n- **Outputs**:\n  - `out`: Output signal based on the logical state of the inputs in the last pipeline stage.\n\n---\n\n### Testbench Requirements:\n\n#### Instantiation\n\n- **Module Instance**: The `sync_muller_c_element` module must be instantiated as `sync_muller_c_element_inst`, with all input and output signals connected for testing.\n\n---\n\n#### Input Generation\n\n- **Input Patterns**: The testbench should continuously drive various input patterns to `inp` to cover all possibilities including:\n  - All `0`s, all `1`s, alternating patterns, and other corner cases.\n  - Randomized input patterns to exercise pipeline behavior.\n\n- **Control Signals**:\n  - Assert `srst` at the start of the simulation to reset the pipeline and output.\n  - Toggle `clr` during operation to clear the pipeline and output.\n  - Drive `clk_en` high and low during operation to test its effect on pipeline propagation.\n\n- **Output Latency**: Outputs will reflect the processed state of the inputs after a latency of `PIPE_DEPTH + 1` clock cycles. New inputs do not have to wait for this latency and can continue to be applied every clock cycle.", "context": {}}, "output": {"response": "", "context": {"verif/tb_sync_muller_c_element.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 3-create-the-tb-to-test-synchronous-muller-c-element-3\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Simulation didn't run correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage merge didn't run correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    try:\n        with open(\"/code/rundir/coverage.log\") as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage.log file.\")\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    print(\"Parsed Metrics:\")\n    print(metrics)\n\n    # Ensure TARGET environment variable is set\n    target = os.getenv(\"TARGET\")\n    if not target:\n        raise ValueError(\"TARGET environment variable is not set.\")\n    target = float(target)\n\n    # Check coverage for the DUT or specific key\n    dut = \"sync_muller_c_element_inst\"  # Replace this with the DUT key you want to check\n    if dut in metrics and \"Overall Average\" in metrics[dut]:\n        assert float(metrics[dut][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        # Log available keys for debugging\n        print(f\"Available keys in metrics: {metrics.keys()}\")\n        assert False, f\"Coverage data for '{dut}' is not available.\"\n", "src/sync_muller_c_element.sv": "module sync_muller_c_element #(\n  parameter NUM_INPUT  = 2, // Number of input signals\n  parameter PIPE_DEPTH = 1  // Number of pipeline stages\n) (\n  input  logic                  clk   , // Clock signal\n  input  logic                  srst  , // Synchronous reset signal\n  input  logic                  clr   , // Clear pipeline and output\n  input  logic                  clk_en, // Clock enable signal\n  input  logic  [NUM_INPUT-1:0] inp   , // Input signals (NUM_INPUT-width vector)\n  output logic                  out     // Output signal\n);\n\n  // Pipeline to store intermediate states of inputs\n  logic [(PIPE_DEPTH*NUM_INPUT)-1:0] pipe; \n  genvar i;\n\n  // Generate block for pipeline implementation\n  generate\n    for (i = 0; i < PIPE_DEPTH; i = i + 1) begin : pipeline_stage\n      always_ff @(posedge clk) begin\n        if (srst | clr) begin\n          // Reset the pipeline stage\n          pipe[i*NUM_INPUT+:NUM_INPUT] <= '0;\n        end\n        else if (clk_en) begin\n          if (i == 0) begin\n            // Load inputs into the first stage of the pipeline\n            pipe[i*NUM_INPUT+:NUM_INPUT] <= inp;\n          end\n          else begin\n            // Shift data from the previous stage to the current stage\n            pipe[i*NUM_INPUT+:NUM_INPUT] <= pipe[(i-1)*NUM_INPUT+:NUM_INPUT];\n          end\n        end\n      end\n    end\n  endgenerate\n\n  // Always block to compute the output signal\n  always_ff @(posedge clk) begin\n    if (srst | clr) begin\n      // Reset the output signal\n      out <= 1'b0;\n    end\n    else if (clk_en) begin\n      // Output logic: High if all inputs in the last pipeline stage are high\n      // Low if all inputs in the last pipeline stage are low\n      if (&pipe[(PIPE_DEPTH-1)*NUM_INPUT+:NUM_INPUT]) begin\n        out <= 1'b1; \n      end\n      else if (!(|pipe[(PIPE_DEPTH-1)*NUM_INPUT+:NUM_INPUT])) begin\n        out <= 1'b0;\n      end\n    end\n  end\n\nendmodule"}}}
{"id": "cvdp_copilot_Synchronous_Muller_C_Element_0008", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the given SystemVerilog testbench to include checkers to validate the output of a **synchronous Muller C-element** module `sync_muller_c_element`, which processes input signals through a configurable pipeline and produces a single-bit output based on the state of the inputs in the final pipeline stage. The **stimulus is provided**, and the modified testbench should add the logic to verify that the **DUT (Design Under Test)** correctly computes the output according to the expected behavior.\n\n---\n\n## **Design Details**\n\n### **1. Parameterization**\n1. **NUM_INPUT**: Specifies the number of input signals.\n   - Default: `5`\n2. **PIPE_DEPTH**: Defines the number of pipeline stages.\n   - Default: `4`\n\n### **2. Functional Behavior**\n1. **Pipeline Operation**:\n   - The pipeline captures and shifts the input states through `PIPE_DEPTH` stages.\n   - Inputs propagate stage by stage until they reach the final stage.\n   - **Latency:** The output reflects the processed state of the inputs **after `PIPE_DEPTH + 1` clock cycles**.\n2. **Output Logic**:\n   - The output signal is set high (`1`) if all inputs in the last pipeline stage are high.\n   - The output signal is set low (`0`) if all inputs in the last pipeline stage are low.\n   - Otherwise, the output maintains its previous state.\n3. **Control Signal Behavior**:\n   - **Reset (`srst`)**: Active-high synchronous reset that clears the pipeline and output.\n   - **Clear (`clr`)**: Active high signal, clears the pipeline and output without resetting.\n   - **Clock Enable (`clk_en`)**: Active high signal, controls whether the pipeline registers update on the rising edge of the clock.\n\n### **Inputs and Outputs**\n- **Inputs**:\n  - `clk`: Clock signal.\n  - `srst`: Synchronous reset signal (active high).\n  - `clr`: Clear signal.\n  - `clk_en`: Clock enable signal.\n  - `inp[NUM_INPUT-1:0]`: NUM_INPUT-width vector representing the input signals.\n- **Outputs**:\n  - `out`: Output signal based on the logical state of the inputs in the last pipeline stage.\n\n---\n\n## **Testbench Requirements**\n\n### **1. Instantiation**\n- `sync_muller_c_element` is already instantiated as `sync_muller_c_element_inst`, with all input and output signals connected.\n\n### **2. Clock Generation**\n- Testbench generates a **500 MHz clock** to synchronize the DUT.\n- The **clock period is 2 ns**, meaning the signal toggles **every 1 ns**.\n\n### **3. Testbench Components**\n\n#### **Parameters**\n- `NUM_INPUT`: Number of Inputs\n- `PIPE_DEPTH`: Number of Pipeline stages.\n\n#### **Signals**\n- `clk`: Clock signal.  \n- `srst`: Synchronous reset.  \n- `clr`: Clear signal.  \n- `clk_en`: Clock enable signal.  \n- `[NUM_INPUT-1:0] inp`: Input vector.  \n- `out`: DUT output.  \n- `out_expected`: Expected output for verification.  \n- `[NUM_INPUT-1:0] in_queue`: **Queue** to store input values applied to the DUT.  \n- `out_matched`: Indicates whether `out` matches `out_expected`.  \n\n### **4. Design Under Test (DUT)**\n- The **stimulus is provided**, which applies test patterns to the DUT.  \n- The testbench should focus on enhancing this by **writing a checker** that verifies correctness.\n\n---\n\n## **5. Use of Queues in Verification**\n- **Queues enable continuous input driving** without waiting for previous results.  \n- **How it works**:\n  1. Every new input applied to the DUT is **pushed** into `in_queue`.  \n  2. When the expected output appears **after `PIPE_DEPTH + 1` cycles**, the **corresponding input is popped** from `in_queue`.  \n  3. The **expected output (`out_expected`) is generated** from the popped input.  \n  4. The **actual DUT output (`out`) is compared** with `out_expected`.  \n  5. If mismatched, `$error` is raised.  \n\n---\n\n## **6. Test Procedure**\n\n### **Test Cases to be Verified**\nThe checker must validate the **following test cases**:\n\n#### **1. Reset Behavior**\n- Given stimulus applies `srst = 1` for multiple cycles. Add checker logic to verify that:\n  - The output (`out`) is cleared to `0`.\n\n#### **2. Normal Operation**\n- Apply a sequence of random `inp` values.\n- Ensure that the **output updates after `PIPE_DEPTH + 1` cycles**.\n- Verify that:\n  - `out = 1` when **all inputs in the final pipeline stage are `1`**.\n  - `out = 0` when **all inputs in the final pipeline stage are `0`**.\n  - `out` holds its **previous value** when inputs are mixed.\n\n#### **3. Clock Enable Behavior**\n- Hold `clk_en = 0` while applying inputs.\n- Verify that the pipeline **does not update** and `out` remains unchanged.\n- Set `clk_en = 1` and check if **pipeline processing resumes**.\n\n#### **4. Clear Signal (`clr`) Behavior**\n- Set `clr = 1` mid-operation and ensure that:\n  - The output are cleared.\n  - Normal operation resumes after `clr` is de-asserted.\n\n---\n\n### **7. Checker Functionality**\n- Implement a **checker logic** that:\n  - Computes the **expected output** using a reference model based on the **Muller C-element logic**.\n  - **Accounts for the pipeline delay (`PIPE_DEPTH + 1` cycles)** when determining expected results.\n  - Compares the **DUT output (`out`)** against the expected result (`out_expected`).\n  - Reports errors using `$error` when mismatches occur.\n\n### **8. Simulation Control**\n- Use `$display` statements to log test case execution.\n- Print **\"All tests passed.\"** if all cases pass; otherwise, report errors and stop the simulation.\n\n---\n\n## **Expected Deliverables**\n- Modified testbench with **SystemVerilog checker** that verifies the `sync_muller_c_element` module's output against expected results.", "context": {"verif/tb_sync_muller_c_element.sv": "module tb_sync_muller_c_element ();\n\n// Uncomment only one define at a time for specific test configurations\n// `define TEST_2_INPUTS_PIPE_DEPTH_3\n// `define TEST_3_INPUTS_PIPE_DEPTH_2\n// `define TEST_4_INPUTS_PIPE_DEPTH_3\n// `define TEST_2_INPUTS_PIPE_DEPTH_1\n\n// -------------------------------------------------------------------------\n// Parameter Declarations\n// -------------------------------------------------------------------------\n// NUM_INPUT   - Number of inputs\n// PIPE_DEPTH  - Depth of the internal pipeline\n// -------------------------------------------------------------------------\n`ifdef TEST_2_INPUTS_PIPE_DEPTH_3\n  parameter NUM_INPUT  = 2;\n  parameter PIPE_DEPTH = 3;\n`elsif TEST_3_INPUTS_PIPE_DEPTH_2\n  parameter NUM_INPUT  = 3;\n  parameter PIPE_DEPTH = 2;\n`elsif TEST_4_INPUTS_PIPE_DEPTH_3\n  parameter NUM_INPUT  = 4;\n  parameter PIPE_DEPTH = 3;\n`elsif TEST_2_INPUTS_PIPE_DEPTH_1\n  parameter NUM_INPUT  = 2;\n  parameter PIPE_DEPTH = 1;\n`else\n  parameter NUM_INPUT  = 5; // Default configuration\n  parameter PIPE_DEPTH = 4;\n`endif\n\nparameter NUM_SAMPLES = 30;\n\n// -------------------------------------------------------------------------\n// Signal Declarations\n// -------------------------------------------------------------------------\nlogic                  clk                  = 0; // Clock signal\nlogic                  srst                    ; // Reset signal (synchronous, active high)\nlogic                  clr                     ; // Clear signal\nlogic                  clk_en                  ; // Clock enable signal\nlogic [ NUM_INPUT-1:0] inp                     ; // Input signals\nlogic                  out                     ; // Output signal\nlogic                  start_test              ; // Signal to start input generation\nlogic [PIPE_DEPTH+2:0] start_test_reg          ; // Shift register for test control\nlogic                  constant_clk_en         ;\nlogic [          31:0] num_samples             ;\nlogic                  reset_num_samples       ;\nlogic                  constant_clr            ;\n// -------------------------------------------------------------------------\n// Module Instantiation\n// -------------------------------------------------------------------------\nsync_muller_c_element #(\n  .NUM_INPUT(NUM_INPUT),\n  .PIPE_DEPTH(PIPE_DEPTH)\n) sync_muller_c_element_inst (\n  .clk      (clk      ),\n  .srst     (srst     ),\n  .clr      (clr      ),\n  .clk_en   (clk_en   ),\n  .inp      (inp      ),\n  .out      (out      )\n);\n\n// -------------------------------------------------------------------------\n// Clock generation\n// -------------------------------------------------------------------------\n// Toggle clock every 1ns (Clock Period = 2ns)\nalways\n    #1 clk = !clk;\n\n// -------------------------------------------------------------------------\n// Initial block to define testbench stimulus\n// -------------------------------------------------------------------------\ninitial\nbegin\n  // Initialize the signals\n  srst = 1'b0;\n  constant_clr = 1'b1;\n  start_test = 0;\n  constant_clk_en = 0;\n  reset_num_samples = 0;\n  #10;\n  // Apply synchronous reset\n  srst = 1'b1; // Assert reset\n  repeat(20) @(posedge clk); // Hold reset for 20 clock cycles\n  srst = 1'b0; // De-assert reset\n  repeat(20) @(posedge clk); // Wait additional cycles after reset\n\n  $display(\"Applying Stimulus . . . .\");\n\n  // Test Case 1: Drive inputs and verify output\n  $display(\"INFO: Test Case 1: Input driving\");\n  constant_clr = 1'b1; // Configure clear\n  constant_clk_en = 1'b1; // Configure clock enable\n  repeat(2) @(posedge clk);\n  start_test = 1'b1; // Start generating inputs\n  repeat(NUM_SAMPLES) @(posedge clk);\n  start_test = 1'b0; // Stop input generation\n  repeat(PIPE_DEPTH+4) @(posedge clk); // Wait for pipeline to flush\n  \n  reset_num_samples = 1;\n\n  // Apply synchronous reset\n  srst = 1'b1; // Assert reset\n  repeat(20) @(posedge clk); // Hold reset for 20 clock cycles\n  srst = 1'b0; // De-assert reset\n  repeat(20) @(posedge clk); // Wait additional cycles after reset\n\n  // Test Case 2: Drive inputs and verify output with Clock enable toggle\n  $display(\"INFO: Test Case 2: Input driving with clock enable toggle\");\n  constant_clr = 1'b1; // Configure clear\n  constant_clk_en = 1'b0; // Configure clock enable\n  repeat(2) @(posedge clk);\n  reset_num_samples = 0;\n  start_test = 1'b1; // Start generating inputs\n  repeat(NUM_SAMPLES) @(posedge clk);\n  start_test = 1'b0; // Stop input generation\n  repeat(PIPE_DEPTH+4) @(posedge clk); // Wait for pipeline to flush\n  \n  reset_num_samples = 1;\n\n  // Apply synchronous reset\n  srst = 1'b1; // Assert reset\n  repeat(20) @(posedge clk); // Hold reset for 20 clock cycles\n  srst = 1'b0; // De-assert reset\n  repeat(20) @(posedge clk); // Wait additional cycles after reset\n\n  // Test Case 3: Drive inputs and verify output with Clear toggle\n  $display(\"INFO: Test Case 3: Input driving with clear toggle\");\n  constant_clr = 1'b0; // Configure clear\n  constant_clk_en = 1'b1; // Configure clock enable\n  repeat(2) @(posedge clk);\n  reset_num_samples = 0;\n  start_test = 1'b1; // Start generating inputs\n  repeat(NUM_SAMPLES) @(posedge clk);\n  start_test = 1'b0; // Stop input generation\n  repeat(PIPE_DEPTH+4) @(posedge clk); // Wait for pipeline to flush\n  \n  $display(\"INFO: Stimulus has been applied!\");\n\n  // Wait for one more clock cycle before terminating the simulation\n  @(posedge clk);\n  $finish;\nend\n\n// -------------------------------------------------------------------------\n// Input generation and queues\n// -------------------------------------------------------------------------\n\nalways_ff @(posedge clk)\n  if (srst)\n    num_samples <= '0;\n  else if (reset_num_samples)\n    num_samples <= '0;\n  else if (start_test_reg[0])\n    num_samples <= num_samples + 1;\n\nalways_ff @(posedge clk)\n  if (srst)\n    start_test_reg <= '0;\n  else\n    start_test_reg <= {start_test_reg[PIPE_DEPTH+1:0],start_test};\n\nalways_ff @(posedge clk)\n  if (srst)\n    inp <= '0; // Reset input\n  else if (start_test_reg[0] && num_samples > 19)\n    inp <= ($urandom_range(0,1) == 0) ? '0 : (1 << NUM_INPUT)-1; // Generate all 1's or all 0's\n  else if (start_test_reg[0])\n    inp <= weighted_random(); // Generate random inputs\n  else\n    inp <= '0;\n\nalways_ff @(posedge clk)\n  if (srst)\n    clk_en <= 1'b0;\n  else if (start_test_reg[0] && constant_clk_en)\n    clk_en <= 1'b1 ;\n  else if (start_test_reg[0] && num_samples <= 9)\n    clk_en <= 1'b1 ;\n  else if (start_test_reg[0] && num_samples > 9 && num_samples <= 19)\n    clk_en <= 1'b0 ;\n  else if (start_test_reg[0] && num_samples > 19)\n    clk_en <= 1'b1 ;\n\nalways_ff @(posedge clk)\n  if (srst)\n    clr <= 1'b0;\n  else if (start_test_reg[0] && constant_clr)\n    clr <= 1'b0 ;\n  else if (start_test_reg[0] && num_samples > 19)\n    clr <= 1'b1 ;\n  else\n    clr <= 1'b0;\n\n// Function to generate weighted random inputs\nfunction logic [NUM_INPUT-1:0] weighted_random();\n    int rand_val;\n    rand_val = $urandom_range(1, 10); // Generate random number in range [1, 10]\n    if (rand_val < 7)\n        return ($urandom_range(0,1) == 0) ? '0 : (1 << NUM_INPUT)-1; // 60% chance for all 1's or all 0's\n    else\n        return $urandom_range(0, (1 << NUM_INPUT)-1); // 40% chance for random pattern\nendfunction\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_sync_muller_c_element.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 8-tb-checker-generation-for-synchronous-muller-c-element-4\nNUM_BUGS        = 3", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n", "src/sync_muller_c_element.sv": "module sync_muller_c_element #(\n  parameter NUM_INPUT  = 5, // Number of input signals\n  parameter PIPE_DEPTH = 4  // Number of pipeline stages\n) (\n  input  logic                  clk   , // Clock signal\n  input  logic                  srst  , // Synchronous reset signal\n  input  logic                  clr   , // Clear pipeline and output\n  input  logic                  clk_en, // Clock enable signal\n  input  logic  [NUM_INPUT-1:0] inp   , // Input signals (NUM_INPUT-width vector)\n  output logic                  out     // Output signal\n);\n\n  // Pipeline to store intermediate states of inputs\n  logic [(PIPE_DEPTH*NUM_INPUT)-1:0] pipe; \n  genvar i;\n\n  // Generate block for pipeline implementation\n  generate\n    for (i = 0; i < PIPE_DEPTH; i = i + 1) begin : pipeline_stage\n      always_ff @(posedge clk) begin\n      `ifndef BUG_0\n        if (srst | clr) begin\n      `else\n        if (srst) begin\n      `endif\n          // Reset the pipeline stage\n          pipe[i*NUM_INPUT+:NUM_INPUT] <= '0;\n        end\n        else if (clk_en) begin\n          if (i == 0) begin\n            // Load inputs into the first stage of the pipeline\n            pipe[i*NUM_INPUT+:NUM_INPUT] <= inp;\n          end\n          else begin\n            // Shift data from the previous stage to the current stage\n          `ifndef BUG_1\n            pipe[i*NUM_INPUT+:NUM_INPUT] <= pipe[(i-1)*NUM_INPUT+:NUM_INPUT];\n          `else \n            pipe[i*NUM_INPUT+:NUM_INPUT] <= pipe[(i)*NUM_INPUT+:NUM_INPUT];\n          `endif\n          end\n        end\n      end\n    end\n  endgenerate\n\n  // Always block to compute the output signal\n  always_ff @(posedge clk) begin\n    `ifndef BUG_0\n      if (srst | clr) begin\n    `else\n      if (srst) begin\n    `endif\n      // Reset the output signal\n      out <= 1'b0;\n    end\n    else if (clk_en) begin\n      // Output logic: High if all inputs in the last pipeline stage are high\n      // Low if all inputs in the last pipeline stage are low\n\n      if (&pipe[(PIPE_DEPTH-1)*NUM_INPUT+:NUM_INPUT]) begin\n      `ifndef BUG_2\n        out <= 1'b1; \n      `else\n        out <= 1'b0; \n      `endif\n      end\n      else if (!(|pipe[(PIPE_DEPTH-1)*NUM_INPUT+:NUM_INPUT])) begin\n      `ifndef BUG_2\n        out <= 1'b0; \n      `else\n        out <= 1'b1; \n      `endif\n      end\n    end\n  end\n\nendmodule\n"}}}
{"id": "cvdp_copilot_Synchronous_Muller_C_Element_0013", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `sync_muller_c_element` module. The assertions should ensure correct reset behavior, pipeline data retention, and output conditions based on the input signals.  \n\n## **RTL Design Overview**  \nThe `sync_muller_c_element` module implements a **Synchronous Muller C-element with pipeline stages**. It synchronizes Multi-bit input signals (`inp`) through a **pipeline of configurable depth (`PIPE_DEPTH`)** and produces an output (`out`) based on the logical states of the last pipeline stage.  \n\n### **Key Components of the Module**  \n- **`pipe`**: A pipeline register array storing intermediate states of input signals.  \n- **`clk_en`**: Acive high signal. Enables pipeline updates and output on clock edges.  \n- **`clr`**: Acive high signal. Clears the pipeline and output.  \n- **`srst`**: Synchronous active high reset signal.  \n- **`out`**: The final computed output based on the last stage of the pipeline.  \n- **`clk`** Clock signal. Design is synchronized to the posedge of this clock\n- **`[NUM_INPUT-1:0] inp`**: Input signals (NUM_INPUT-width vector)\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n\n- **Clear signal Behavior:**  \n  - When `clr` is asserted, `out` should be **cleared to `0`** on the next clock cycle.  \n\n- **Clock Enable Control:**  \n  - When `clk_en` is **low**, the pipeline should **retain** its previous state.  \n\n- **Output High Condition:**  \n  - If all inputs in the **last pipeline stage** are **high**, then `out` should be `1`.  \n\n- **Output Low Condition:**  \n  - If all inputs in the **last pipeline stage** are **low**, then `out` should be `0`.  \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.  ", "context": {"rtl/sync_muller_c_element.sv": "module sync_muller_c_element #(\n  parameter NUM_INPUT  = 2, // Number of input signals\n  parameter PIPE_DEPTH = 1  // Number of pipeline stages\n) (\n  input  logic                  clk   , // Clock signal\n  input  logic                  srst  , // Synchronous reset signal\n  input  logic                  clr   , // Clear pipeline and output\n  input  logic                  clk_en, // Clock enable signal\n  input  logic  [NUM_INPUT-1:0] inp   , // Input signals (NUM_INPUT-width vector)\n  output logic                  out     // Output signal\n);\n\n  // Pipeline to store intermediate states of inputs\n  logic [(PIPE_DEPTH*NUM_INPUT)-1:0] pipe; \n  genvar i;\n\n  // Generate block for pipeline implementation\n  generate\n    for (i = 0; i < PIPE_DEPTH; i = i + 1) begin : pipeline_stage\n      always_ff @(posedge clk) begin\n        if (srst | clr) begin\n          // Reset the pipeline stage\n          pipe[i*NUM_INPUT+:NUM_INPUT] <= '0;\n        end\n        else if (clk_en) begin\n          if (i == 0) begin\n            // Load inputs into the first stage of the pipeline\n            pipe[i*NUM_INPUT+:NUM_INPUT] <= inp;\n          end\n          else begin\n            // Shift data from the previous stage to the current stage\n            pipe[i*NUM_INPUT+:NUM_INPUT] <= pipe[(i-1)*NUM_INPUT+:NUM_INPUT];\n          end\n        end\n      end\n    end\n  endgenerate\n\n  // Always block to compute the output signal\n  always_ff @(posedge clk) begin\n    if (srst | clr) begin\n      // Reset the output signal\n      out <= 1'b0;\n    end\n    else if (clk_en) begin\n      // Output logic: High if all inputs in the last pipeline stage are high\n      // Low if all inputs in the last pipeline stage are low\n      if (&pipe[(PIPE_DEPTH-1)*NUM_INPUT+:NUM_INPUT]) begin\n        out <= 1'b1; \n      end\n      else if (!(|pipe[(PIPE_DEPTH-1)*NUM_INPUT+:NUM_INPUT])) begin\n        out <= 1'b0;\n      end\n    end\n  end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sync_muller_c_element.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sync_muller_c_element.sv\nTOPLEVEL        = sync_muller_c_element\nMODULE          = test_sync_muller_c_element\nPYTHONPATH      = /src\nHASH            = 13-rtl-assertion-generation-for-synchronous-muller-c-element", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner(NUM_INPUT: int=2, PIPE_DEPTH: int=1):\n    parameters = {\n        \"NUM_INPUT\": NUM_INPUT,\n        \"PIPE_DEPTH\": PIPE_DEPTH,\n    }\n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n\n# Random Synchronous Muller C Element Tests\n# Generate random parameters for the Synchronous Muller C Element testbench and run the test multiple times\n@pytest.mark.parametrize(\"random_test\", range(3))\ndef test_random_sync_muller_c_element(random_test):\n  # Generate random dimensions for the matrices\n  NUM_INPUT = random.randint(1, 8)\n  PIPE_DEPTH = random.randint(1, 8)\n\n  # Run the test with the generated parameters\n  call_runner(NUM_INPUT=NUM_INPUT, PIPE_DEPTH=PIPE_DEPTH)\n\n", "src/test_sync_muller_c_element.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport harness_library as hrs_lb\nimport math\n\n# ----------------------------------------\n# - Synchornous Muller C Element Test\n# ----------------------------------------\n\nasync def reset_dut(dut, duration_ns=10):\n    \"\"\"\n    Perform a synchronous reset on the Design Under Test (DUT).\n\n    - Sets the reset signal high for the specified duration.\n    - Ensures all output signals are zero during the reset.\n    - Deactivates the reset signal and stabilizes the DUT.\n\n    Args:\n        dut: The Design Under Test (DUT).\n        duration_ns: The time duration in nanoseconds for which the reset signal will be held high.\n    \"\"\"\n    dut.srst.value = 1  # Activate reset (set to high)\n    await Timer(duration_ns, units=\"ns\")  # Hold reset high for the specified duration\n    await Timer(1, units=\"ns\")\n\n    # Verify that outputs are zero during reset\n    assert dut.out.value == 0, f\"[ERROR] out is not zero during reset: {dut.out.value}\"\n\n    dut.srst.value = 0  # Deactivate reset (set to low)\n    await Timer(duration_ns, units='ns')  # Wait for the reset to stabilize\n    dut.srst._log.debug(\"Reset complete\")\n\ndef weighted_random_input(num_inputs):\n    \"\"\"\n    Generate weighted random inputs.\n\n    Args:\n        num_inputs: Number of input bits.\n\n    Returns:\n        An integer representing the input vector.\n    \"\"\"\n    if random.random() < 0.6:  # 60% chance to generate all 0's or all 1's\n        return 0 if random.random() < 0.5 else (1 << num_inputs) - 1\n    else:  # 40% chance to generate other combinations\n        return random.randint(0, (1 << num_inputs) - 1)\n\n\n@cocotb.test()\nasync def test_sync_muller_c_element(dut):\n  \"\"\"\n  Verify the functionality of the sync_muller_c_element module with weighted random input vectors.\n\n  Test Steps:\n  1. Perform a synchronous reset.\n  2. Drive the DUT with weighted random inputs.\n  3. Verify correctness of the output based on input logic.\n  4. Cover scenarios including reset and stable input combinations.\n  \"\"\"\n\n  # Start the clock with a 10ns period\n  cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few clock cycles to ensure proper initialization\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve DUT configuration parameters\n  num_inputs = int(dut.NUM_INPUT.value)\n  pipe_depth = int(dut.PIPE_DEPTH.value)\n  num_samples = 20\n\n  # Print parameters for debugging\n  print(f\"NUM_INPUT: {num_inputs}\")\n  print(f\"PIPE_DEPTH: {pipe_depth}\")\n\n  # Test with weighted random input vectors\n  in_queue = []\n  out_queue = []\n  dut.clk_en.value = 1\n\n  for i in range(num_samples):\n    # Generate a random input\n    random_input = weighted_random_input(num_inputs)\n    dut.inp.value = random_input\n    # Add input to the queue for later verification\n    in_queue.append(random_input)\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Handle pipeline delay outputs\n  for i in range(pipe_depth):\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Remove outputs corresponding to initial pipeline latency\n  for i in range(pipe_depth):\n    prev_out = out_queue.pop(0)\n\n  # Perform verification of DUT outputs\n  for i in range(num_samples):\n    # Retrieve the input and output from the queues\n    in_temp = in_queue.pop(0)\n    out_temp = out_queue.pop(0)\n    \n    # Compute the expected output\n    all_high = (1 << num_inputs) - 1\n    all_low  = 0\n\n    expected_output = 1 if (in_temp == all_high) else (0 if (in_temp == all_low) else prev_out)\n\n    # Verify that the DUT output matches the expected output\n    assert out_temp == expected_output, f\"Test {i+1}: Output does not match the expected result: {out_temp} != {expected_output}\"\n\n    print(f\"Test {i+1} passed\")\n    prev_out = out_temp\n\n  # Wait for a few cycles before performing a final reset\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply a final reset to the DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles after reset to stabilize\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n\n@cocotb.test()\nasync def test_sync_muller_c_element_with_clk_en_toggle(dut):\n  \"\"\"\n  Verify the functionality of sync_muller_c_element with clock enable toggling.\n\n  Test Steps:\n  1. Perform a synchronous reset.\n  2. Toggle clock enable at specific intervals.\n  3. Drive inputs and verify outputs during enabled and disabled periods.\n  \"\"\"\n\n  # Start the clock with a 10ns period\n  cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few clock cycles to ensure proper initialization\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve DUT configuration parameters\n  num_inputs = int(dut.NUM_INPUT.value)\n  pipe_depth = int(dut.PIPE_DEPTH.value)\n  num_samples = 30\n\n  # Print parameters for debugging\n  print(f\"NUM_INPUT: {num_inputs}\")\n  print(f\"PIPE_DEPTH: {pipe_depth}\")\n\n  # Test with clock enable toggle\n  in_queue = []\n  out_queue = []\n  clk_en = 1\n  dut.clk_en.value = clk_en\n\n  for i in range(num_samples):\n\n    if (i  == 10):\n      clk_en = 0\n    elif (i  == 20):\n      clk_en = 1\n\n    dut.clk_en.value = clk_en\n\n    # Generate a random input\n    random_input = weighted_random_input(num_inputs)\n    dut.inp.value = random_input\n    # Add input to the queue for later verification\n    if (clk_en):\n      in_queue.append(random_input)\n\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Handle pipeline delay outputs\n  for i in range(pipe_depth):\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Remove outputs corresponding to initial pipeline latency\n  for i in range(pipe_depth):\n    prev_out = out_queue.pop(0)\n\n  # Perform verification of DUT outputs\n  for i in range(num_samples):\n    if (i >= (10 - pipe_depth) and i <= (19 - pipe_depth)):\n      expected_output = prev_out\n      out_temp = out_queue.pop(0)\n    else:\n      # Retrieve the input and output from the queues\n      in_temp = in_queue.pop(0)\n      out_temp = out_queue.pop(0)\n      \n      # Compute the expected output\n      all_high = (1 << num_inputs) - 1\n      all_low  = 0\n      expected_output = 1 if (in_temp == all_high) else (0 if (in_temp == all_low) else prev_out)\n\n    # Verify that the DUT output matches the expected output\n    assert out_temp == expected_output, f\"Test {i+1}: Output does not match the expected result: {out_temp} != {expected_output}\"\n\n    print(f\"Test {i+1} passed\")\n    prev_out = out_temp\n\n  # Wait for a few cycles before performing a final reset\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply a final reset to the DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles after reset to stabilize\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n\n\n@cocotb.test()\nasync def test_sync_muller_c_element_with_clr_toggle(dut):\n  \"\"\"\n  Verify the functionality of sync_muller_c_element with clear signal toggling.\n\n  Test Steps:\n  1. Perform a synchronous reset.\n  2. Drive inputs with random data.\n  3. Toggle the clear signal and verify output behavior.\n  \"\"\"\n\n  # Start the clock with a 10ns period\n  cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few clock cycles to ensure proper initialization\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve DUT configuration parameters\n  num_inputs = int(dut.NUM_INPUT.value)\n  pipe_depth = int(dut.PIPE_DEPTH.value)\n  num_samples = 30\n\n  # Print parameters for debugging\n  print(f\"NUM_INPUT: {num_inputs}\")\n  print(f\"PIPE_DEPTH: {pipe_depth}\")\n\n  # Test with clear signal toggling\n  in_queue = []\n  out_queue = []\n  dut.clk_en.value = 1\n  clr = 0\n  dut.clr.value = clr\n\n  for i in range(num_samples):\n    # Generate a random input\n    random_input = weighted_random_input(num_inputs)\n    dut.inp.value = random_input\n    # Add input to the queue for later verification\n    in_queue.append(random_input)\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n    if (i == 20):\n      clr = 1\n      dut.clr.value = clr\n\n  # Handle pipeline delay outputs\n  for i in range(pipe_depth):\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Remove outputs corresponding to initial pipeline latency\n  for i in range(pipe_depth):\n    prev_out = out_queue.pop(0)\n\n  # Perform verification for DUT Outputs\n  for i in range(num_samples):\n    # Retrieve the input and output from the queues\n    in_temp = in_queue.pop(0)\n    out_temp = out_queue.pop(0)\n    \n    # Compute the expected output\n    all_high = (1 << num_inputs) - 1\n    all_low  = 0\n\n    if (i > (20 - pipe_depth)):\n      expected_output = 0\n    else:\n      expected_output = 1 if (in_temp == all_high) else (0 if (in_temp == all_low) else prev_out)\n\n    # Verify that the DUT output matches the expected output\n    assert out_temp == expected_output, f\"Test {i+1}: Output does not match the expected result: {out_temp} != {expected_output}\"\n\n    print(f\"Test {i+1} passed\")\n    prev_out = out_temp\n\n  # Wait for a few cycles before performing a final reset\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply a final reset to the DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles after reset to stabilize\n  for k in range(2):\n    await RisingEdge(dut.clk)"}}}
{"id": "cvdp_copilot_adc_data_rotate_0009", "categories": ["cid012", "easy"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named  `adc_data_rotate` module by applying exhaustive test scenarios. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage. The testbench should not create checkers to verify the MUT.\n\n\n---\n## **Instantiation**\nName the instance of the RTL as `dut`.\n\n## **RTL Parameter Inputs - Outputs and Functional behaviour**\n\n### Parameterization\n- The module supports parameterized data width, `DATA_WIDTH`, with a default value of 8 bits. This allows the module to handle various input data sizes.\n\n### Inputs\n- **`i_clk`** (logic): Clock signal to synchronize the module\u2019s operation.\n- **`i_rst_n`** (logic): Active-low reset signal. When asserted (`i_rst_n = 0`), all outputs reset to their idle state.\n- **`i_adc_data_in`** (logic [`DATA_WIDTH`-1:0]): Input data to be rotated.\n- **`i_shift_count`** (logic [3:0]): Specifies the number of bits to rotate. Supports up to 15-bit rotation.\n- **`i_shift_direction`** (logic): Controls the rotation direction:\n  - `0`: Left Rotate\n  - `1`: Right Rotate\n\n### Outputs\n- **`o_processed_data`** (logic [`DATA_WIDTH`-1:0]): The rotated result of the input `i_adc_data_in`.\n- **`o_operation_status`** (logic): Indicates the operation state:\n  - `0`: Reset state\n  - `1`: Active rotation\n\n### Reset Behavior\n- When `i_rst_n` is asserted (`i_rst_n = 0`):\n  - `o_processed_data` resets to `0`.\n  - `o_operation_status` resets to `0`.\n\n### Rotation Behavior\n- On the rising edge of `i_clk` and when `i_rst_n = 1`, the module performs:\n  - **Left Rotate** (`i_shift_direction = 0`): Bits shifted out from the left re-enter on the right.\n  - **Right Rotate** (`i_shift_direction = 1`): Bits shifted out from the right re-enter on the left.\n\n### Operation Status\n- During rotation, `o_operation_status` is set to `1` to indicate an active state.\n## Constraints and Edge Cases\n\n### **Edge Cases**:\n  - Handle rotation amounts of 0 and `DATA_WIDTH` effectively (e.g., rotation by `0` bits should result in no change).\n  - Ensure correct behavior when `i_shift_count` exceeds `DATA_WIDTH`. This means any shift count above **DATA_WIDTH** automatically wraps to the equivalent smaller shift.\n---\n## Stimulus generation\n\n1. Reset and Initialization\n- **Reset Assert/Deassert**: Set `i_rst_n = 0`, then `1`.\n- **Repeated Resets**: Assert/deassert `i_rst_n` multiple times quickly.\n \n 2. No Shift (Shift Count = 0)\n- **Left and Right Directions**: `i_shift_count = 0`, both directions.\n- **Data Patterns**: All-0s, all-1s, and alternating bits (e.g., `10101010`).\n\n3. Single-Bit Shifts\n- **Left Shift by 1**: `i_shift_count = 1`, `i_shift_direction = 0`. \n- **Right Shift by 1**: `i_shift_count = 1`, `i_shift_direction = 1.\n\n4. Multiple Bit Shifts\n- **Mid-Range Counts**: For `i_shift_count` like `3`, `4`, and `7`, apply various `i_adc_data_in` values.\n- **Full-Range Counts**: Sweep `i_shift_count` from `0` to `15`. \n\n5. Special Edge Cases\n- **Shift = Data Width** (e.g., 8): complete rotation.\n- **Shift = 15**: Highest valid count. Wrap-around for both directions.\n- **All 1s / All 0s**: Rotation uniform bit patterns.\n- **Alternating Bits**: Wrap-around (`10101010`, `01010101`) under all shift counts/directions.\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_adc_data_rotate.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 9-tb-stimulus\nTARGET = 92\n", "src/adc_data_rotate.sv": "module adc_data_rotate #(\n    parameter DATA_WIDTH = 8 // Parameterized data width (default = 8)\n)(\n    // Inputs\n    input  logic                     i_clk,             // Clock signal\n    input  logic                     i_rst_n,           // Active-low reset\n    input  logic [DATA_WIDTH-1:0]    i_adc_data_in,     // Input ADC data\n    input  logic [3:0]               i_shift_count,     // Number of bits to rotate\n    input  logic                     i_shift_direction, // Shift direction (0: Left, 1: Right)\n\n    // Outputs\n    output logic [DATA_WIDTH-1:0]    o_processed_data,  // Rotated output data\n    output logic                     o_operation_status // Operation status\n);\n\n    // Internal signal to hold the effective shift count\n    // Taking modulo with DATA_WIDTH ensures correct behavior for shifts > DATA_WIDTH\n    logic [DATA_WIDTH-1:0] shift_count_mod;\n\n    // Calculate effective shift count\n    // Since i_shift_count is 4 bits, the maximum shift count is 15.\n    // We only need to limit it to DATA_WIDTH-1 if DATA_WIDTH < 16.\n    assign shift_count_mod = i_shift_count % DATA_WIDTH;\n\n    // Synchronous logic\n    always_ff @(posedge i_clk or negedge i_rst_n) begin\n        if (!i_rst_n) begin\n            // Reset condition: outputs go to idle states\n            o_processed_data   <= '0;\n            o_operation_status <= 1'b0;\n        end\n        else begin\n            // Set operation_status high to indicate active rotation\n            o_operation_status <= 1'b1;\n\n            // Perform rotation based on i_shift_direction\n            if (i_shift_direction == 1'b0) begin\n                // Left rotate\n                // Bits shifted out of the left re-enter on the right\n                o_processed_data <= (i_adc_data_in << shift_count_mod) |\n                                    (i_adc_data_in >> (DATA_WIDTH - shift_count_mod));\n            end\n            else begin\n                // Right rotate\n                // Bits shifted out of the right re-enter on the left\n                o_processed_data <= (i_adc_data_in >> shift_count_mod) |\n                                    (i_adc_data_in << (DATA_WIDTH - shift_count_mod));\n            end\n        end\n    end\n\nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/adc_data_rotate.sv /code/verif/tb_adc_data_rotate.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_afi_ptr_0004", "categories": ["cid012", "medium"], "input": {"prompt": "Write a SystemVerilog testbench to only generate stimulus for a `cmprs_afi_mux_ptr_tb` module is responsible for managing pointer updates for multiple channels in a memory compression system. It handles resetting pointers, arbitrating between competing channels, and updating pointers based on increments while ensuring correct rollover behavior. \n\n## **Design Specification**\n\nThe **cmprs_afi_mux_ptr** module is responsible for managing pointer updates for multiple channels in a memory compression system. It handles resetting pointers, arbitrating between competing channels, and updating pointers based on increments while ensuring correct rollover behavior. \n\nThe testbench **cmprs_afi_mux_ptr_tb** must generate stimuli to validate the FSM transitions, pointer updates, reset behavior, and interaction with the busy signal for arbitration.\n\n### **Inputs:**\n- `hclk` (1-bit): **Clock signal**, used for synchronous operations.\n- `reset` (1-bit): **Active-high reset**, initializes the system state.\n- `sa_len_di` (27-bit): **Write data** for the `sa_len_ram`.\n- `sa_len_wa` (3-bit): **Write address** for the `sa_len_ram`.\n- `sa_len_we` (1-bit): **Write enable** for `sa_len_ram`.\n- `en` (1-bit): **Enable signal**, determines whether the module is active.\n- `reset_pointers` (4-bit): **Per-channel reset** control for pointers.\n- `pre_busy_w` (1-bit): **Indicates if a write operation is occurring**.\n- `pre_winner_channel` (2-bit): **Channel ID that won arbitration**.\n- `need_to_bother` (1-bit): **Indicates whether an update is required**.\n- `chunk_inc_want_m1` (2-bit): **Increment request value (minus one)**.\n- `last_burst_in_frame` (1-bit): **Indicates the last burst in a frame**.\n- `busy` (4-bit): **Busy flags for different channels**.\n\n### **Outputs:**\n- `ptr_resetting` (1-bit): **Indicates if pointers are resetting**.\n- `chunk_addr` (27-bit): **Computed chunk address**.\n- `max_wlen` (3-bit): **Maximum write length per channel**.\n\n## **FSM States & Behavior**\n- **IDLE**: Waits for reset pointers or arbitration start (`pre_busy_w`).\n- **RESETTING**: Resets the requested channel pointers to zero.\n- **ARBITRATION**: Determines if a pointer update is needed (`need_to_bother`).\n- **UPDATE**: Updates the selected pointer, handling overflow conditions.\n\n---\n\n## **Testbench Requirements**\n\n### **Instantiation**\n- Module Instance: The module **cmprs_afi_mux_ptr** should be instantiated as **uut**, with all input and output signals connected for testing.\n\n### **Input Generation**\n\n#### **1. sa_len_ram Writing**\n- The testbench must write values to all `sa_len_ram` entries.\n- Verify that each entry is correctly stored.\n\n#### **2. Pointer Resetting**\n- The testbench should initiate pointer resets (`reset_pointers`).\n- Verify that only the selected pointers are reset.\n\n#### **3. Arbitration and Pointer Increment**\n- Set `pre_busy_w` to initiate arbitration.\n- Assign a channel (`pre_winner_channel`) and increment (`chunk_inc_want_m1`).\n- Verify that the pointer updates correctly.\n\n#### **4. Rollover Condition Testing**\n- Initialize a pointer close to its maximum value.\n- Assign an increment that causes rollover.\n- Verify that the pointer wraps around correctly.\n\n#### **5. FSM Transition Verification**\n- Ensure that transitions between **IDLE**, **RESETTING**, **ARBITRATION**, and **UPDATE** follow expected conditions.\n- Confirm that after `pre_busy_w` is deasserted, the FSM returns to **IDLE**.\n\n#### **6. Reset During Active Update**\n- Apply `reset` while in the **UPDATE** state.\n- Verify that all registers return to their default values.\n\n---\n\n## **Control Signal Handling**\n- The testbench must ensure that inputs such as `pre_busy_w`, `pre_winner_channel`, `chunk_inc_want_m1`, and `reset_pointers` are asserted at the correct moments.\n- The FSM must be given enough cycles to transition and perform pointer updates before moving to the next test case.\n\nThis testbench will ensure the **cmprs_afi_mux_ptr** module functions correctly under various conditions, including normal operation, pointer resets, and overflow scenarios.", "context": {}}, "output": {"response": "", "context": {"verif/cmprs_afi_mux_ptr_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 9ceda5f77db02367cfe5d44905d09ded7a93a668\nTARGET = 80\n", "src/cmprs_afi_mux_ptr.sv": "`timescale 1ns / 1ps\n\nmodule cmprs_afi_mux_ptr(\n    input                         hclk,                // Clock signal\n    input                         reset,               // Synchronous reset input\n    input                  [26:0] sa_len_di,           // Data input for sa_len_ram\n    input                  [ 2:0] sa_len_wa,           // Write address for sa_len_ram\n    input                         sa_len_we,           // Write enable for sa_len_ram\n    input                         en,                  // Enable signal for FSM\n    input                  [ 3:0] reset_pointers,      // Reset pointers for specific channels\n    input                         pre_busy_w,          // Arbitration start signal\n    input                  [ 1:0] pre_winner_channel,  // Active channel for arbitration\n    input                         need_to_bother,      // Indicates whether an update is required\n    input                   [1:0] chunk_inc_want_m1,   // Increment value for the pointer\n    input                         last_burst_in_frame, // Indicates the last burst in frame\n    input                  [ 3:0] busy,                // Busy signals for channels\n    output                        ptr_resetting,       // Indicates the FSM is in RESETTING state\n    output reg             [26:0] chunk_addr,          // Current pointer address\n    output                 [ 2:0] max_wlen             // Maximum word length\n);\n\n    // Internal signals\n    reg [1:0] state, next_state;         // Current and next states of FSM\n    localparam IDLE        = 2'b00,      // FSM state: IDLE\n               RESETTING   = 2'b01,      // FSM state: RESETTING\n               ARBITRATION = 2'b10,      // FSM state: ARBITRATION\n               UPDATE      = 2'b11;      // FSM state: UPDATE\n\n    reg [26:0] ptr_ram[0:7];             // Pointer values for 8 channels\n    reg [26:0] sa_len_ram[0:7];          // Buffer sizes for 8 channels\n    reg [ 2:0] max_inc_ram[0:3];         // Maximum increment values for 4 channels\n    reg [3:0] reset_rq;                  // Tracks reset requests for pointers\n    reg rollover_flag;                   // Indicates rollover condition for pointer\n\n    integer i;                           // Loop variable for initialization\n\n    assign ptr_resetting = (state == RESETTING); \n    assign max_wlen = max_inc_ram[pre_winner_channel]; \n\n    always @(posedge hclk) begin\n        if (reset) begin\n            for (i = 0; i < 8; i = i + 1) begin\n                ptr_ram[i] <= 27'd0;       \n                sa_len_ram[i] <= 27'd64;  \n            end\n            for (i = 0; i < 4; i = i + 1) begin\n                max_inc_ram[i] <= 3'd0;   \n            end\n            reset_rq <= 4'b0000;          \n            rollover_flag <= 1'b0;        \n            chunk_addr <= 27'd0;          \n            state <= IDLE;                \n        end else begin\n            state <= next_state;          \n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (|reset_pointers)\n                    next_state = RESETTING;\n                else if (pre_busy_w)\n                    next_state = ARBITRATION;\n                else\n                    next_state = IDLE;    \n            end\n            RESETTING: begin\n                if (!reset_rq)\n                    next_state = IDLE;\n                else\n                    next_state = RESETTING; \n            end\n            ARBITRATION: begin\n                if (need_to_bother)\n                    next_state = UPDATE;\n                else\n                    next_state = IDLE;    \n            end\n            UPDATE: begin\n                if (!busy[pre_winner_channel])\n                    next_state = IDLE;\n                else\n                    next_state = UPDATE;\n            end\n            default: next_state = IDLE;    \n        endcase\n    end\n\n    always @(posedge hclk) begin\n        if (!reset) begin \n            case (state)\n                IDLE: begin\n                    if (sa_len_we) begin\n                        sa_len_ram[sa_len_wa] <= sa_len_di;\n                    end\n                    reset_rq <= reset_pointers;\n                end\n                RESETTING: begin\n                    if (reset_rq != 4'b0000) begin\n                        if (reset_rq[0]) ptr_ram[0] <= 27'd0;\n                        if (reset_rq[1]) ptr_ram[1] <= 27'd0;\n                        if (reset_rq[2]) ptr_ram[2] <= 27'd0;\n                        if (reset_rq[3]) ptr_ram[3] <= 27'd0;\n                        reset_rq <= 4'b0000; \n                    end\n                end\n                ARBITRATION: begin\n                    rollover_flag <= (ptr_ram[pre_winner_channel] + chunk_inc_want_m1 >= sa_len_ram[pre_winner_channel]);\n                end\n                UPDATE: begin\n                    if (busy[pre_winner_channel]) begin\n                        if (rollover_flag) begin\n                            ptr_ram[pre_winner_channel] <= ptr_ram[pre_winner_channel] + chunk_inc_want_m1 - sa_len_ram[pre_winner_channel];\n                            chunk_addr <= ptr_ram[pre_winner_channel] + chunk_inc_want_m1 - sa_len_ram[pre_winner_channel];\n                        end else begin\n                            ptr_ram[pre_winner_channel] <= ptr_ram[pre_winner_channel] + chunk_inc_want_m1;\n                            chunk_addr <= ptr_ram[pre_winner_channel] + chunk_inc_want_m1;\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_ahb_clk_counter_0004", "categories": ["cid014", "easy"], "input": {"prompt": "Create an SVA Assertion for Counter Overflow Reset in `ahb_clock_counter`\n\n## Description\nWe need a **SystemVerilog Assertion (SVA)** to validate the behavior of the `COUNTER` in the `ahb_clock_counter` module. Specifically, the assertion should ensure that when the counter reaches the `max_count` value, it resets to `0` on the next clock cycle if the `enable` signal is active.\n\n## Assertion Details\nThe assertion should follow these conditions:\n- It should trigger on the rising edge of `HCLK`.\n- It must be disabled when `HRESETn` is de-asserted.\n- The `COUNTER` should reset to `0` once it reaches the value of `max_count` and `enable` is active.\n\n## Expected Behavior\nIf the property fails, the assertion should report the current values of `COUNTER` and `max_count` to help debug the issue.", "context": {"rtl/ahb_clock_counter.sv": "module ahb_clock_counter #(\n    parameter ADDR_WIDTH = 32, // Width of the address bus\n    parameter DATA_WIDTH = 32  // Width of the data bus\n)(\n    input wire HCLK,                       // AHB Clock\n    input wire HRESETn,                    // AHB Reset (Active Low)\n    input wire HSEL,                       // AHB Select\n    input wire [ADDR_WIDTH-1:0] HADDR,     // AHB Address\n    input wire HWRITE,                     // AHB Write Enable\n    input wire [DATA_WIDTH-1:0] HWDATA,    // AHB Write Data\n    input wire HREADY,                     // AHB Ready Signal\n    output reg [DATA_WIDTH-1:0] HRDATA,    // AHB Read Data\n    output reg HRESP,                      // AHB Response\n    output reg [DATA_WIDTH-1:0] COUNTER    // Counter Output\n);\n\n    // Internal Registers\n    reg [DATA_WIDTH-1:0] max_count;          // Maximum value before overflow\n    reg overflow;                            // Overflow flag\n    reg enable;                              // Enable signal for counter\n\n    // Address Map\n    localparam [ADDR_WIDTH-1:0] ADDR_START    = {ADDR_WIDTH{1'b0}};          // 0x00000000\n    localparam [ADDR_WIDTH-1:0] ADDR_STOP     = {ADDR_WIDTH{1'b0}} + 4;      // 0x00000004\n    localparam [ADDR_WIDTH-1:0] ADDR_COUNTER  = {ADDR_WIDTH{1'b0}} + 8;      // 0x00000008\n    localparam [ADDR_WIDTH-1:0] ADDR_OVERFLOW = {ADDR_WIDTH{1'b0}} + 12;     // 0x0000000C\n    localparam [ADDR_WIDTH-1:0] ADDR_MAXCNT   = {ADDR_WIDTH{1'b0}} + 16;     // 0x00000010\n\n    // AHB Write Operation\n    always @(posedge HCLK or negedge HRESETn) begin\n        if (!HRESETn) begin\n            enable <= 1'b0;\n            max_count <= {DATA_WIDTH{1'b1}}; // Default max count to max possible value\n        end else if (HSEL && HWRITE && HREADY) begin\n            case (HADDR)\n                ADDR_START:    enable <= HWDATA[0]; // Set start signal\n                ADDR_STOP:     enable <= !HWDATA[0];  // Set stop signal\n                ADDR_MAXCNT:   max_count <= HWDATA; // Update max_count\n                default:       ; // Do nothing for undefined addresses\n            endcase\n        end\n    end\n\n    // Counter and Overflow Logic\n    always @(posedge HCLK or negedge HRESETn) begin\n        if (!HRESETn) begin\n            COUNTER <= {DATA_WIDTH{1'b0}};\n            overflow <= 1'b0;\n        end else begin\n            if (enable) begin\n                if (COUNTER < max_count) begin\n                    COUNTER <= COUNTER + 1; // Increment counter\n                end else begin\n                    COUNTER <= {DATA_WIDTH{1'b0}}; // Reset counter on overflow\n                    overflow <= 1'b1; // Set overflow flag\n                end\n            end\n        end\n    end\n\n    // AHB Read Operation\n    always @(*) begin\n        if (HSEL && !HWRITE && HREADY) begin\n            case (HADDR)\n                ADDR_START:    HRDATA = {{DATA_WIDTH-1{1'b0}}, enable};\n                ADDR_STOP:     HRDATA = {{DATA_WIDTH-1{1'b0}}, !enable};\n                ADDR_COUNTER:  HRDATA = COUNTER;\n                ADDR_OVERFLOW: HRDATA = {{DATA_WIDTH-1{1'b0}}, overflow};\n                ADDR_MAXCNT:   HRDATA = max_count;\n                default:       HRDATA = {DATA_WIDTH{1'b0}}; // Default read value\n            endcase\n        end else begin\n            HRDATA = {DATA_WIDTH{1'b0}};\n        end\n        HRESP = 1'b0; // Always OKAY response\n    end\n\nendmodule : ahb_clock_counter"}}, "output": {"response": "", "context": {"rtl/ahb_clock_counter.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ahb_clock_counter.sv\nTOPLEVEL        = ahb_clock_counter\nMODULE          = test_ahb_clock_counter\nPYTHONPATH      = /src\nHASH            = 4894af918a89a58a4e83db2e94c85b22fd970e73", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n", "src/test_ahb_clock_counter.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nimport math\n\n@cocotb.test()\nasync def test_ahb_clock_counter(dut):\n    \"\"\"Test AHB Clock Counter module functionality.\"\"\"\n\n    # Start clock with a period of 10 ns\n    cocotb.start_soon(Clock(dut.HCLK, 10, units='ns').start())\n\n    # Reset the design\n    dut.HRESETn.value = 1\n    await Timer(5, units='ns')\n    dut.HRESETn.value = 0\n    await Timer(10, units='ns')\n    dut.HRESETn.value = 1\n\n    # Initialize inputs\n    dut.HSEL.value = 0\n    dut.HWRITE.value = 0\n    dut.HREADY.value = 1\n    dut.HADDR.value = 0\n    dut.HWDATA.value = 0\n\n    # Wait for the reset to complete\n    await RisingEdge(dut.HCLK)\n\n    # Write to the ADDR_MAXCNT to set a maximum count\n    max_count = 10\n    assert max_count <= int(math.pow(2, int(dut.DATA_WIDTH.value)) - 1)\n    dut.HSEL.value = 1\n    dut.HWRITE.value = 1\n    dut.HADDR.value = 0x10  # ADDR_MAXCNT\n    dut.HWDATA.value = max_count\n    await RisingEdge(dut.HCLK)\n\n    # Start the counter by writing to ADDR_START\n    dut.HADDR.value = 0x00  # ADDR_START\n    dut.HWDATA.value = 1\n    await RisingEdge(dut.HCLK)\n\n    # Monitor the COUNTER output\n    dut.HWRITE.value = 0  # Set to read mode\n    counter_val = 0\n    for i in range(max_count + 5):  # Run for max_count + extra cycles\n        dut.HADDR.value = 0x08  # ADDR_COUNTER\n        await RisingEdge(dut.HCLK)\n        if 0 < counter_val < (max_count - 2):\n            assert int(dut.HRDATA.value) == counter_val + 2\n            assert int(dut.HRDATA.value) == int(dut.COUNTER.value)\n            assert int(dut.HRESP.value) == 0 # HRESP returned ok\n        counter_val = int(dut.HRDATA.value)\n        print(f\"Cycle {i}, Counter: {counter_val}\")\n\n        # Check for overflow\n        dut.HADDR.value = 0x0C  # ADDR_OVERFLOW\n        await RisingEdge(dut.HCLK)\n        assert int(dut.HRESP.value) == 0  # HRESP returned ok\n        overflow = int(dut.HRDATA.value)\n        print(f\"Cycle {i}, Overflow: {overflow}\")\n\n        if i == max_count:\n            assert overflow == 1, \"Overflow should occur at max_count\"\n\n    # Stop the counter by writing to ADDR_STOP\n    dut.HWRITE.value = 1\n    dut.HADDR.value = 0x04  # ADDR_STOP\n    dut.HWDATA.value = 1\n    await RisingEdge(dut.HCLK)\n\n    # Verify the counter stops\n    dut.HWRITE.value = 0  # Set to read mode\n    for _ in range(3):  # Check for a few cycles\n        dut.HADDR.value = 0x08  # ADDR_COUNTER\n        await RisingEdge(dut.HCLK)\n        assert int(dut.HRESP.value) == 0  # HRESP returned ok\n        assert int(dut.HRDATA.value) == int(dut.COUNTER.value)\n        stopped_value = int(dut.HRDATA.value)\n        print(f\"Stopped Counter: {stopped_value}\")\n\n    max_count = int(math.pow(2, int(dut.DATA_WIDTH.value)) - 1)\n\n    # Restrict this part of the test to instances where the maximum counter value is small (<= 255),\n    # to avoid excessively long runtimes for the test.\n    if max_count <= 255:\n        print(\"Running test for Max Counter\")\n\n        # Write to the ADDR_MAXCNT to set a maximum count\n        dut.HSEL.value = 1\n        dut.HWRITE.value = 1\n        dut.HADDR.value = 0x10  # ADDR_MAXCNT\n        dut.HWDATA.value = max_count\n        await RisingEdge(dut.HCLK)\n        print(f\"Set the new Max Counter={max_count}\")\n\n        # Start the counter by writing to ADDR_START\n        dut.HADDR.value = 0x00  # ADDR_START\n        dut.HWDATA.value = 1\n        await RisingEdge(dut.HCLK)\n        print(\"Started the Counter\")\n\n        dut.HADDR.value = 0x08  # ADDR_COUNTER\n        dut.HWRITE.value = 0  # Switch to read mode\n        await RisingEdge(dut.HCLK)\n\n        while int(dut.HRDATA.value) < max_count:\n            print(f\"Counter={int(dut.HRDATA.value)}\")\n            await RisingEdge(dut.HCLK)\n\n        print(\"Reached the Max Counter\")\n\n        dut.HADDR.value = 0x0C  # ADDR_OVERFLOW\n        await RisingEdge(dut.HCLK)\n        assert int(dut.HRDATA.value) == 1\n\n\n@cocotb.test()\nasync def test_ahb_clock_counter_overflow_persistence_and_post_overflow_reset(dut):\n    \"\"\"Test overflow persistence and counter behavior after an overflow.\"\"\"\n\n    # Start clock with a period of 10 ns\n    cocotb.start_soon(Clock(dut.HCLK, 10, units='ns').start())\n\n    # Reset the design\n    dut.HRESETn.value = 1\n    await Timer(5, units='ns')\n    dut.HRESETn.value = 0\n    await Timer(10, units='ns')\n    dut.HRESETn.value = 1\n\n    # Initialize inputs\n    dut.HSEL.value = 0\n    dut.HWRITE.value = 0\n    dut.HREADY.value = 1\n    dut.HADDR.value = 0\n    dut.HWDATA.value = 0\n\n    # Wait for reset to complete\n    await RisingEdge(dut.HCLK)\n\n    # Set a maximum count value\n    max_count = 3\n    dut.HSEL.value = 1\n    dut.HWRITE.value = 1\n    dut.HADDR.value = 0x10  # ADDR_MAXCNT\n    dut.HWDATA.value = max_count\n    await RisingEdge(dut.HCLK)\n\n    # Start the counter\n    dut.HADDR.value = 0x00  # ADDR_START\n    dut.HWDATA.value = 1\n    await RisingEdge(dut.HCLK)\n\n    # Run until overflow\n    dut.HWRITE.value = 0  # Switch to read mode\n    for i in range(max_count + 1):\n        # Read counter value\n        dut.HADDR.value = 0x08  # ADDR_COUNTER\n        await RisingEdge(dut.HCLK)\n        assert int(dut.HRESP.value) == 0  # HRESP returned ok\n        assert int(dut.HRDATA.value) == int(dut.COUNTER.value)\n        counter_val = int(dut.HRDATA.value)\n        print(f\"Cycle {i}, Counter: {counter_val}\")\n\n        if i == max_count:\n            # Check if overflow is set correctly\n            dut.HADDR.value = 0x0C  # ADDR_OVERFLOW\n            await RisingEdge(dut.HCLK)\n            assert int(dut.HRESP.value) == 0 # HRESP returned ok\n            overflow = int(dut.HRDATA.value)\n            assert overflow == 1, \"Overflow flag should be set at max_count\"\n            print(\"Overflow flag correctly set at max_count.\")\n\n    # Verify overflow flag persists\n    dut.HADDR.value = 0x0C  # ADDR_OVERFLOW\n    await RisingEdge(dut.HCLK)\n    assert int(dut.HRESP.value) == 0  # HRESP returned ok\n    overflow_persistent = int(dut.HRDATA.value)\n    assert overflow_persistent == 1, \"Overflow flag should persist until reset\"\n\n    # Perform manual reset of the overflow flag\n    dut.HRESETn.value = 0\n    await Timer(10, units='ns')\n    dut.HRESETn.value = 1\n\n    # Verify overflow flag is cleared after reset\n    await RisingEdge(dut.HCLK)\n    dut.HADDR.value = 0x0C  # ADDR_OVERFLOW\n    await RisingEdge(dut.HCLK)\n    assert int(dut.HRESP.value) == 0  # HRESP returned ok\n    overflow_after_reset = int(dut.HRDATA.value)\n    assert overflow_after_reset == 0, \"Overflow flag should reset to 0 after manual reset\"\n\n    # Restart the counter and validate proper operation\n    dut.HADDR.value = 0x00  # ADDR_START\n    dut.HWDATA.value = 1\n    dut.HWRITE.value = 1\n    await RisingEdge(dut.HCLK)\n\n    dut.HWRITE.value = 0\n    dut.HADDR.value = 0x08  # ADDR_COUNTER\n    for i in range(3):\n        await RisingEdge(dut.HCLK)\n        assert int(dut.HRESP.value) == 0  # HRESP returned ok\n        assert int(dut.HRDATA.value) == int(dut.COUNTER.value)\n        counter_val = int(dut.HRDATA.value)\n        print(f\"Cycle {i}, Counter After Restart: {counter_val}\")\n        assert counter_val == i, f\"Counter mismatch after restart at cycle {i}: expected {i}, got {counter_val}\"\n\n    print(\"Test for overflow persistence and post-overflow behavior completed successfully.\")\n\n", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner(data_width: int = 32, addr_width: int = 32):\n    parameters = {\n        \"ADDR_WIDTH\": addr_width,\n        \"DATA_WIDTH\": data_width\n    }\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n\n# random test\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_run(test):\n    call_runner()\n\n    # Test with different parameter values\n    call_runner(8, 8)\n    call_runner(8, 16)\n    call_runner(8, 32)\n    call_runner(16, 32)\n"}}}
{"id": "cvdp_copilot_ahb_lite_srom_0001", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add concurrent assertions in the RTL design of the `ahb_lite_srom` module to enforce correct behavior for both read and write transactions?\n**1. Read Transaction-Based Assertion** :\n - For read transactions, the module must immediately produce an OKAY response (i.e. `hresp_o` equals `H_OKAY` and `hreadyout_o` is asserted HIGH ) when a valid transaction is initiated. A valid transaction is signaled by `hsel_i` being high, `htrans_i` being a valid transfer, and `hwrite_i` being de-asserted. \n\n**2. Write Transaction-Based Assertion** :\n - For write transactions\u2014since the memory is read-only\u2014the module should trigger a two\u2011cycle error response: one cycle with `hresp_o` set to `H_ERROR` and `hreadyout_o` de-asserted to LOW, followed by a cycle where `hresp_o` remains at `H_ERROR` and `hreadyout_o` is reasserted to HIGH. \n\nProvide the appropriate SystemVerilog property\u2011based concurrent assertions to be inserted into the RTL code.\n\n## Interface:\n### **Inputs:**\n- `hclk (1-bit)`: The positive edge clock signal that drives the module.\n- `hreset_n (1-bit)`: Active-low asynchronous reset signal which initializes the module.\n- `haddr_i (32-bit,[31:0])`: The address bus input from the AHB bus used to select the memory location.\n- `hwdata_i (64-bit,[63:0])`: Data input for write transactions coming from the AHB bus.\n- `hsel_i (1-bit)`: AHB slave select signal indicating that the device is being addressed.\n- `hwrite_i (1-bit)`: Write enable signal; when high, it indicates a write transaction, and when low, a read transaction.\n- `hready_i (1-bit)`: Indicates that the AHB bus is ready for a new transaction.\n- `htrans_i (2-bit,[1:0])`: Transfer type signal that specifies the nature of the transaction (idle, sequential, or non-sequential).\n- `hsize_i (3-bit,[2:0])`: Specifies the size (in bytes) of the current transfer.\n- `rdata (64-bit,[63:0])`: Data input coming from the SROM, which is passed to the AHB bus during read transactions.\n\n### **Outputs**:\n- `hresp_o (1-bit)`: AHB response signal that indicates the status of the transaction\u2014H_OKAY (0) for successful operations or H_ERROR (1) for errors.\n- `hreadyout_o (1-bit)`: Indicates whether the SROM is ready to complete the current transaction.\n- `hrdata_o (64-bit,[63:0])`: Data output to the AHB bus, directly passed from the SROM.\n- `cs (1-bit)`: Chip select signal for the SROM, activated when a valid transaction is initiated.\n- `addr (32-bit,[31:0])`: Address output to the SROM, derived from the AHB address input by shifting right by the number of byte-select bits.", "context": {"rtl/ahb_lite_srom.sv": "module ahb_lite_srom \n #(\n    parameter AHB_DATA_WIDTH    = 64,\n    parameter AHB_ADDR_WIDTH    = 32,\n    parameter CLIENT_ADDR_WIDTH = 32,\n    parameter H_OKAY=1'b0,\n    parameter H_ERROR=1'b1)(\n\n    input logic                          hclk,\n    input logic                          hreset_n,\n    input logic [AHB_ADDR_WIDTH-1:0]     haddr_i,\n    input logic [AHB_DATA_WIDTH-1:0]     hwdata_i,\n    input logic                          hsel_i,\n    input logic                          hwrite_i,\n    input logic                          hready_i,\n    input logic [1:0]                    htrans_i,\n    input logic [2:0]                    hsize_i,\n    input logic [AHB_DATA_WIDTH-1:0]     rdata,\n\n    output logic                         hresp_o,\n    output logic                         hreadyout_o,\n    output logic [AHB_DATA_WIDTH-1:0]    hrdata_o,\n    output logic                         cs,\n    output logic [CLIENT_ADDR_WIDTH-1:0] addr\n);\n\n    logic    sram_error, sram_error_data_ph, sram_error_data_ph_f;\n\n    assign cs = hready_i & hsel_i & ((htrans_i == 2'b10) || (htrans_i == 2'b11));\n    assign addr = haddr_i >> $clog2(AHB_DATA_WIDTH/8);\n\n    assign sram_error = cs & hwrite_i; \n\n    assign hrdata_o = rdata;\n\n    always_comb begin : response_block\n      hreadyout_o = 1'b1;\n      hresp_o = H_OKAY;\n      if (sram_error_data_ph & ~sram_error_data_ph_f) begin\n        hreadyout_o = 1'b0;\n        hresp_o = H_ERROR;\n      end else if (sram_error_data_ph_f) begin\n        hreadyout_o = 1'b1;\n        hresp_o = H_ERROR;\n      end\n    end\n\n    always_ff @(posedge hclk or negedge hreset_n) begin\n      if (~hreset_n) begin\n        sram_error_data_ph <= '0;\n        sram_error_data_ph_f <= '0;\n      end else begin\n        sram_error_data_ph <= sram_error;\n        sram_error_data_ph_f <= sram_error_data_ph;\n      end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/ahb_lite_srom.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ahb_lite_srom.sv\nTOPLEVEL        = ahb_lite_srom\nMODULE          = test_ahb_lite_srom\nPYTHONPATH      = /src\nHASH            = 1-ahb_lite_srom_tb_assertion_generation\n", "src/test_ahb_lite_srom.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nimport math\n\n# AHB response definitions matching DUT parameters\nH_OKAY  = 0\nH_ERROR = 1\n\n# Calculate the address-shift amount based on AHB_DATA_WIDTH (assumes power-of-2)\nADDR_SHIFT = int(math.log2(64//8))  # For 64-bit data: 64/8 = 8, shift by 3\n\nasync def drive_rdata(dut):\n    \"\"\" Continuously drive rdata with a known 64-bit value. \"\"\"\n    while True:\n        dut.rdata.value = 0x0123456789ABCDEF\n        await Timer(1, units=\"ns\")\n\n@cocotb.test()\nasync def test_srom_read(dut):\n    \"\"\"\n    Test reading from the SROM.\n    This test verifies:\n      - The read response is OKAY and hreadyout is asserted.\n      - hrdata_o follows rdata.\n      - The chip select (cs) is asserted when a valid read transfer is initiated.\n      - The ROM address (addr) is computed correctly from haddr_i.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.hclk, 10, units=\"ns\").start())\n    cocotb.start_soon(drive_rdata(dut))\n\n    # Apply reset (active low)\n    dut.hreset_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.hclk)\n    dut.hreset_n.value = 1\n    await RisingEdge(dut.hclk)\n\n    # Drive default bus values\n    dut.hsel_i.value   = 0\n    dut.hwrite_i.value = 0  # Read transaction\n    dut.hready_i.value = 1\n    dut.htrans_i.value = 0\n    dut.haddr_i.value  = 0\n    dut.hwdata_i.value = 0\n    dut.hsize_i.value  = 0\n\n    num_reads = 5\n    for addr in range(num_reads):\n        # Initiate a read transfer\n        dut.hsel_i.value   = 1\n        dut.hwrite_i.value = 0\n        dut.htrans_i.value = 2  # NONSEQ transfer (2'b10)\n        dut.haddr_i.value  = addr\n        dut._log.info(f\"Initiating READ from address 0x{addr:08X}\")\n\n        await RisingEdge(dut.hclk)\n        await Timer(1, units=\"ns\")  # Allow combinational logic to settle\n\n        # Capture DUT outputs\n        hresp     = int(dut.hresp_o.value)\n        hreadyout = int(dut.hreadyout_o.value)\n        read_data = int(dut.hrdata_o.value)\n        cs_val    = int(dut.cs.value)\n        calc_addr = int(dut.addr.value)\n        expected_addr = addr >> ADDR_SHIFT\n\n        dut._log.info(f\"Address 0x{addr:08X}: hresp_o={hresp}, hreadyout_o={hreadyout}, hrdata_o=0x{read_data:016X}\")\n        dut._log.info(f\"Chip Select (cs) = {cs_val}, Computed addr = 0x{calc_addr:08X} (expected: 0x{expected_addr:08X})\")\n        assert hresp == H_OKAY, f\"Expected H_OKAY (0), got {hresp}\"\n        assert hreadyout == 1, f\"Expected hreadyout_o=1, got {hreadyout}\"\n        assert read_data == 0x0123456789ABCDEF, \"hrdata_o does not match rdata\"\n        assert cs_val == 1, f\"Expected cs to be asserted (1), got {cs_val}\"\n        assert calc_addr == expected_addr, f\"Expected addr = (haddr_i >> {ADDR_SHIFT}) = {expected_addr}, got {calc_addr}\"\n\n    # End the read transaction\n    dut.hsel_i.value = 0\n    dut._log.info(\"Read test completed successfully.\")\n\n@cocotb.test()\nasync def test_srom_write(dut):\n    \"\"\"\n    Test writing to the SROM.\n    Since the SROM is read-only, a write transaction should produce a two-cycle error:\n      - First error cycle: hresp_o = H_ERROR and hreadyout_o = 0.\n      - Second error cycle: hresp_o = H_ERROR and hreadyout_o = 1.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.hclk, 10, units=\"ns\").start())\n    cocotb.start_soon(drive_rdata(dut))\n\n    # Apply reset (active low)\n    dut.hreset_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.hclk)\n    dut.hreset_n.value = 1\n    await RisingEdge(dut.hclk)\n\n    # Set default bus values\n    dut.hready_i.value = 1\n    dut.haddr_i.value  = 0\n    dut.hwdata_i.value = 0\n    dut.hsize_i.value  = 0\n\n    # Pulse a write transaction for one clock cycle\n    dut.hsel_i.value   = 1\n    dut.hwrite_i.value = 1  # Write transaction\n    dut.htrans_i.value = 2  # NONSEQ transfer (2'b10)\n    dut.haddr_i.value  = 0\n    dut.hwdata_i.value = 0xDEADBEEFDEADBEEF\n    dut._log.info(\"Initiating WRITE transaction to read-only memory for one clock cycle...\")\n\n    await RisingEdge(dut.hclk)  # Transaction active in this cycle\n\n    # Deassert transaction signals immediately after one cycle\n    dut.hsel_i.value   = 0\n    dut.hwrite_i.value = 0\n    dut.htrans_i.value = 0\n\n    # Wait for the first error cycle: wait for the next rising edge and a delta cycle for combinational updates\n    await RisingEdge(dut.hclk)\n    await Timer(0, units=\"ns\")  # Allow delta cycles to settle\n    hresp_cycle1     = int(dut.hresp_o.value)\n    hreadyout_cycle1 = int(dut.hreadyout_o.value)\n    dut._log.info(f\"First error cycle => hresp_o={hresp_cycle1}, hreadyout_o={hreadyout_cycle1}\")\n    assert hresp_cycle1 == H_ERROR, f\"Expected H_ERROR (1) in first error cycle, got {hresp_cycle1}\"\n    assert hreadyout_cycle1 == 0, f\"Expected hreadyout_o=0 in first error cycle, got {hreadyout_cycle1}\"\n\n    # Wait for the second error cycle (next rising edge)\n    await RisingEdge(dut.hclk)\n    await Timer(0, units=\"ns\")\n    hresp_cycle2     = int(dut.hresp_o.value)\n    hreadyout_cycle2 = int(dut.hreadyout_o.value)\n    dut._log.info(f\"Second error cycle => hresp_o={hresp_cycle2}, hreadyout_o={hreadyout_cycle2}\")\n    assert hresp_cycle2 == H_ERROR, f\"Expected H_ERROR (1) in second error cycle, got {hresp_cycle2}\"\n    assert hreadyout_cycle2 == 1, f\"Expected hreadyout_o=1 in second error cycle, got {hreadyout_cycle2}\"\n\n    dut._log.info(\"Write-to-ROM error response test completed successfully.\")\n\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_ahb_lite_srom_0003", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add concurrent assertions in the RTL design of the `ahb_lite_srom` module to ensure that the module correctly implements its control and data path functions? Specifically:\n\n**1. Chip Select Generation Assertion**:\nWhen a valid AHB transaction is initiated\u2014i.e., when `hsel_i` is high, `htrans_i` indicates a valid transfer when it holds 2'b10 or 2'b11, and `hready_i` is asserted HIGH \u2014the chip select output (cs) should be asserted HIGH.\n\n**2. Address Calculation Assertion**:\nWhen the chip select (`cs`) is LOGIC HIGH, the address output (`addr`) must equal the AHB address input (`haddr_i`) shifted right by the number of byte-selection bits (`64 bits`).\n\n**3. Data Pass-Through Assertion**:\nThe read data output (`hrdata_o`) should always follow the SROM data input (`rdata`).\n\nProvide the appropriate SystemVerilog property\u2011based concurrent assertions to be inserted into the RTL code.\n\n## Interface:\n### **Inputs:**\n- `hclk (1-bit)`: The positive edge clock signal that drives the module.\n- `hreset_n (1-bit)`: Active-low asynchronous reset signal which initializes the module.\n- `haddr_i (32-bit,[31:0])`: The address bus input from the AHB bus used to select the memory location.\n- `hwdata_i (64-bit,[63:0])`: Data input for write transactions coming from the AHB bus.\n- `hsel_i (1-bit)`: AHB slave select signal indicating that the device is being addressed.\n- `hwrite_i (1-bit)`: Write enable signal; when high, it indicates a write transaction, and when low, a read transaction.\n- `hready_i (1-bit)`: Indicates that the AHB bus is ready for a new transaction.\n- `htrans_i (2-bit,[1:0])`: Transfer type signal that specifies the nature of the transaction (idle, sequential, or non-sequential).\n- `hsize_i (3-bit,[2:0])`: Specifies the size (in bytes) of the current transfer.\n- `rdata (64-bit,[63:0])`: Data input coming from the SROM, which is passed to the AHB bus during read transactions.\n\n### **Outputs**:\n- `hresp_o (1-bit)`: AHB response signal that indicates the status of the transaction\u2014H_OKAY (0) for successful operations or H_ERROR (1) for errors.\n- `hreadyout_o (1-bit)`: Indicates whether the SROM is ready to complete the current transaction.\n- `hrdata_o (64-bit,[63:0])`: Data output to the AHB bus, directly passed from the SROM.\n- `cs (1-bit)`: Chip select signal for the SROM, activated when a valid transaction is initiated.\n- `addr (32-bit,[31:0])`: Address output to the SROM, derived from the AHB address input by shifting right by the number of byte-select bits.", "context": {"rtl/ahb_lite_srom.sv": "module ahb_lite_srom \n #(\n    parameter AHB_DATA_WIDTH    = 64,\n    parameter AHB_ADDR_WIDTH    = 32,\n    parameter CLIENT_ADDR_WIDTH = 32,\n    parameter H_OKAY=1'b0,\n    parameter H_ERROR=1'b1)(\n\n    input logic                          hclk,\n    input logic                          hreset_n,\n    input logic [AHB_ADDR_WIDTH-1:0]     haddr_i,\n    input logic [AHB_DATA_WIDTH-1:0]     hwdata_i,\n    input logic                          hsel_i,\n    input logic                          hwrite_i,\n    input logic                          hready_i,\n    input logic [1:0]                    htrans_i,\n    input logic [2:0]                    hsize_i,\n    input logic [AHB_DATA_WIDTH-1:0]     rdata,\n    \n    output logic                         hresp_o,\n    output logic                         hreadyout_o,\n    output logic [AHB_DATA_WIDTH-1:0]    hrdata_o,\n    output logic                         cs,\n    output logic [CLIENT_ADDR_WIDTH-1:0] addr\n);\n\n    logic    sram_error, sram_error_data_ph, sram_error_data_ph_f;\n\n    assign cs = hready_i & hsel_i & ((htrans_i == 2'b10) || (htrans_i == 2'b11));\n    assign addr = haddr_i >> $clog2(AHB_DATA_WIDTH/8);\n\n    assign sram_error = cs & hwrite_i; \n\n    assign hrdata_o = rdata;\n\n    always@(*) begin : response_block\n      hreadyout_o = 1'b1;\n      hresp_o = H_OKAY;\n      if (sram_error_data_ph & ~sram_error_data_ph_f) begin\n        hreadyout_o = 1'b0;\n        hresp_o = H_ERROR;\n      end else if (sram_error_data_ph_f) begin\n        hreadyout_o = 1'b1;\n        hresp_o = H_ERROR;\n      end\n    end\n\n    always@(posedge hclk or negedge hreset_n) begin\n      if (~hreset_n) begin\n        sram_error_data_ph <= '0;\n        sram_error_data_ph_f <= '0;\n      end else begin\n        sram_error_data_ph <= sram_error;\n        sram_error_data_ph_f <= sram_error_data_ph;\n      end\n    end\n\n    \nendmodule"}}, "output": {"response": "", "context": {"rtl/ahb_lite_srom.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ahb_lite_srom.sv\nTOPLEVEL        = ahb_lite_srom\nMODULE          = test_ahb_lite_srom\nPYTHONPATH      = /src\nHASH            = 3-ahb_lite_srom_tb_assertion_generation_2\n", "src/test_ahb_lite_srom.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nimport math\n\n# AHB response definitions matching DUT parameters\nH_OKAY  = 0\nH_ERROR = 1\n\n# Calculate the address-shift amount based on AHB_DATA_WIDTH (assumes power-of-2)\nADDR_SHIFT = int(math.log2(64//8))  # For 64-bit data: 64/8 = 8, shift by 3\n\nasync def drive_rdata(dut):\n    \"\"\" Continuously drive rdata with a known 64-bit value. \"\"\"\n    while True:\n        dut.rdata.value = 0x0123456789ABCDEF\n        await Timer(1, units=\"ns\")\n\n@cocotb.test()\nasync def test_srom_read(dut):\n    \"\"\"\n    Test reading from the SROM.\n    This test verifies:\n      - The read response is OKAY and hreadyout is asserted.\n      - hrdata_o follows rdata.\n      - The chip select (cs) is asserted when a valid read transfer is initiated.\n      - The ROM address (addr) is computed correctly from haddr_i.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.hclk, 10, units=\"ns\").start())\n    cocotb.start_soon(drive_rdata(dut))\n\n    # Apply reset (active low)\n    dut.hreset_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.hclk)\n    dut.hreset_n.value = 1\n    await RisingEdge(dut.hclk)\n\n    # Drive default bus values\n    dut.hsel_i.value   = 0\n    dut.hwrite_i.value = 0  # Read transaction\n    dut.hready_i.value = 1\n    dut.htrans_i.value = 0\n    dut.haddr_i.value  = 0\n    dut.hwdata_i.value = 0\n    dut.hsize_i.value  = 0\n\n    num_reads = 5\n    for addr in range(num_reads):\n        # Initiate a read transfer\n        dut.hsel_i.value   = 1\n        dut.hwrite_i.value = 0\n        dut.htrans_i.value = 2  # NONSEQ transfer (2'b10)\n        dut.haddr_i.value  = addr\n        dut._log.info(f\"Initiating READ from address 0x{addr:08X}\")\n\n        await RisingEdge(dut.hclk)\n        await Timer(1, units=\"ns\")  # Allow combinational logic to settle\n\n        # Capture DUT outputs\n        hresp     = int(dut.hresp_o.value)\n        hreadyout = int(dut.hreadyout_o.value)\n        read_data = int(dut.hrdata_o.value)\n        cs_val    = int(dut.cs.value)\n        calc_addr = int(dut.addr.value)\n        expected_addr = addr >> ADDR_SHIFT\n\n        dut._log.info(f\"Address 0x{addr:08X}: hresp_o={hresp}, hreadyout_o={hreadyout}, hrdata_o=0x{read_data:016X}\")\n        dut._log.info(f\"Chip Select (cs) = {cs_val}, Computed addr = 0x{calc_addr:08X} (expected: 0x{expected_addr:08X})\")\n        assert hresp == H_OKAY, f\"Expected H_OKAY (0), got {hresp}\"\n        assert hreadyout == 1, f\"Expected hreadyout_o=1, got {hreadyout}\"\n        assert read_data == 0x0123456789ABCDEF, \"hrdata_o does not match rdata\"\n        assert cs_val == 1, f\"Expected cs to be asserted (1), got {cs_val}\"\n        assert calc_addr == expected_addr, f\"Expected addr = (haddr_i >> {ADDR_SHIFT}) = {expected_addr}, got {calc_addr}\"\n\n    # End the read transaction\n    dut.hsel_i.value = 0\n    dut._log.info(\"Read test completed successfully.\")\n\n@cocotb.test()\nasync def test_srom_write(dut):\n    \"\"\"\n    Test writing to the SROM.\n    Since the SROM is read-only, a write transaction should produce a two-cycle error:\n      - First error cycle: hresp_o = H_ERROR and hreadyout_o = 0.\n      - Second error cycle: hresp_o = H_ERROR and hreadyout_o = 1.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.hclk, 10, units=\"ns\").start())\n    cocotb.start_soon(drive_rdata(dut))\n\n    # Apply reset (active low)\n    dut.hreset_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.hclk)\n    dut.hreset_n.value = 1\n    await RisingEdge(dut.hclk)\n\n    # Set default bus values\n    dut.hready_i.value = 1\n    dut.haddr_i.value  = 0\n    dut.hwdata_i.value = 0\n    dut.hsize_i.value  = 0\n\n    # Pulse a write transaction for one clock cycle\n    dut.hsel_i.value   = 1\n    dut.hwrite_i.value = 1  # Write transaction\n    dut.htrans_i.value = 2  # NONSEQ transfer (2'b10)\n    dut.haddr_i.value  = 0\n    dut.hwdata_i.value = 0xDEADBEEFDEADBEEF\n    dut._log.info(\"Initiating WRITE transaction to read-only memory for one clock cycle...\")\n\n    await RisingEdge(dut.hclk)  # Transaction active in this cycle\n\n    # Deassert transaction signals immediately after one cycle\n    dut.hsel_i.value   = 0\n    dut.hwrite_i.value = 0\n    dut.htrans_i.value = 0\n\n    # Wait for the first error cycle: wait for the next rising edge and a delta cycle for combinational updates\n    await RisingEdge(dut.hclk)\n    await Timer(0, units=\"ns\")  # Allow delta cycles to settle\n    hresp_cycle1     = int(dut.hresp_o.value)\n    hreadyout_cycle1 = int(dut.hreadyout_o.value)\n    dut._log.info(f\"First error cycle => hresp_o={hresp_cycle1}, hreadyout_o={hreadyout_cycle1}\")\n    assert hresp_cycle1 == H_ERROR, f\"Expected H_ERROR (1) in first error cycle, got {hresp_cycle1}\"\n    assert hreadyout_cycle1 == 0, f\"Expected hreadyout_o=0 in first error cycle, got {hreadyout_cycle1}\"\n\n    # Wait for the second error cycle (next rising edge)\n    await RisingEdge(dut.hclk)\n    await Timer(0, units=\"ns\")\n    hresp_cycle2     = int(dut.hresp_o.value)\n    hreadyout_cycle2 = int(dut.hreadyout_o.value)\n    dut._log.info(f\"Second error cycle => hresp_o={hresp_cycle2}, hreadyout_o={hreadyout_cycle2}\")\n    assert hresp_cycle2 == H_ERROR, f\"Expected H_ERROR (1) in second error cycle, got {hresp_cycle2}\"\n    assert hreadyout_cycle2 == 1, f\"Expected hreadyout_o=1 in second error cycle, got {hreadyout_cycle2}\"\n\n    dut._log.info(\"Write-to-ROM error response test completed successfully.\")\n\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_apb_dsp_op_0006", "categories": ["cid012", "medium"], "input": {"prompt": "Create a SystemVerilog test bench for a module named `apb_dsp_op`. The test bench should systematically generate input vectors, apply them to the design under test (DUT), and aim to achieve 100% coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **apb_dsp_op_dut**.\n\n## **RTL Interface and Parameters**\n\n| Signal     | Width | Samples | In/Out | Description                              |\n|------------|-------|---------|--------|------------------------------------------|\n| clk_dsp    | 1     | 1       | Input  | Faster clock of 500 MHz to DSP operation |\n| en_clk_dsp | 1     | 1       | Input  | Enable faster DSP clock                  |\n| PCLK       | 1     | 1       | Input  | APB clock of 50 MHz                      |\n| PRESETn    | 1     | 1       | Input  | Active low asynchronous APB Reset        |\n| PADDR      | 6     | 1       | Input  | APB address                              |\n| PWRITE     | 1     | 1       | Input  | Write/Read enable                        |\n| PWDATA     | 32    | 1       | Input  | Write data                               |\n| PSEL       | 1     | 1       | Input  | DSP selector                             |\n| PENABLE    | 1     | 1       | Input  | APB enable                               |\n| PRDATA     | 32    | 1       | Output | Read data                                |\n| PREADY     | 1     | 1       | Output | Ready signal                             |\n| PSLVERR    | 1     | 1       | Output | Error signal                             |\n\n### Parameters\n- **ADDR_WIDTH**: Width of the address (6 bits).\n- **DATA_WIDTH**: Width of the data (32 bits).\n\n---\n### Functional Behavior\n\n**Internal Blocks**\n\n1. **Control Unit**: \n   - Is responsible for controlling the APB interface, internal registers, SRAM operations and DSP behavior.\n2. **DSP Processing**: \n   - Can operate with the APB interface clock or with an alternative clock 10 times higher and performs the following operation: O = A * B + C.\n3. **SRAM Memory**: \n   - Has 64 addresses of 32 bits each.\n \n### Register Bank\n| Register       | Address | Default Value | Permission | Description                                              |\n|----------------|---------|---------------|------------|----------------------------------------------------------|\n| REG_OPERAND_A  | 0x00    | 32'h0         | W/R        | Holds the SRAM address to read the value for operand A   |\n| REG_OPERAND_B  | 0x01    | 32'h0         | W/R        | Holds the SRAM address to read the value for operand B   |\n| REG_OPERAND_C  | 0x02    | 32'h0         | W/R        | Holds the SRAM address to read the value for operand C   |\n| REG_OPERAND_O  | 0x03    | 32'h0         | W/R        | Holds the SRAM address to write the value for operand O  |\n| REG_CONTROL    | 0x04    | 32'h0         | W/R        | Holds the value equivalent to the operation control mode |\n| REG_WDATA_SRAM | 0x05    | 32'h0         | W/R        | Holds the data to be written to SRAM                     |\n| REG_ADDR_SRAM  | 0x06    | 32'h0         | W/R        | Holds the address to be read or written to SRAM          |\n\n### Control Modes\n\nThe module's operation has control modes configured according to the value in the internal register ```reg_control```. The operating modes are described below:\n   - 32'd1: Enables writing to SRAM.\n   - 32'd2: Enables reading from SRAM.\n   - 32'd3: Enables reading the A operand.\n   - 32'd4: Enables reading the B operand.\n   - 32'd5: Enables reading the C operand.\n   - 32'd6: Enables writing the O operand.\n   - Other values: Only performs write and read operations on internal registers.\n\n---\n### TB Implementation Notes\n\n1. **APB Interface**\n\nImplement simple APB driver tasks that does the following:\n- Drives PADDR, PWDATA, PWRITE when PSEL is asserted.\n- Asserts PENABLE for the second phase of the transfer.\n- Ensure the testbench stimulates correct read data at the right cycle.\n- Ensure the testbench stimulates out-of-range access.\n\n2. **SRAM Operations**\n\nImplement simple SRAM driver tasks configured by the APB registers:\n- Ensure the testbench stimulates correct read data at the right cycle.\n- Ensure the testbench stimulates out-of-range access.\n- Wait for clock synchronization after writing to SRAM.\n- Waiting for multiple PCLK cycles after SRAM requests.\n\n3. **DSP Processing**\n\nThe testbench ensures proper synchronization between PCLK and clk_dsp by:\n- Waiting for multiple PCLK cycles after DSP control registers are set.\n- Introducing additional @(posedge PCLK); waits before reading computed values.\n- Set different address values for REG_OPERAND_A, REG_OPERAND_B, REG_OPERAND_C, and REG_OPERAND_O before DSP execution.\n\n4. **Invalid Transactions**\n\nThe testbench ensures testing of invalid transactions by:\n- Creating a task for accessing invalid APB register addresses.\n- Creating a task for operating the SRAM at invalid addresses.\n- Creating a task for performing DSP operations using an invalid address.\n\n---\n### Stimulus Generation\n\nThe testbench writes to the following APB registers before initiating DSP operations:\nREG_OPERAND_A (0x00): Stores operand A address.\nREG_OPERAND_B (0x01): Stores operand B address.\nREG_OPERAND_C (0x02): Stores operand C address.\nREG_OPERAND_O (0x03): Stores operand O (result) address.\nREG_CONTROL (0x04): Triggers DSP operations and sets control modes.\nREG_WDATA_SRAM (0x05): Writes a value to SRAM.\nREG_ADDR_SRAM (0x06): Sets the SRAM address for reads and writes.\n\n1. **Basic scripts:**\n- Write to control registers.\n- Write to SRAM address & data registers.\n- Trigger DSP operation.\n- Read back final result.\n\n2. **Invalid Address Stimulus:**\nThe test bench stimulates invalid address by:\n- Writing and reading from an invalid APB register address.\n- Writing and reading from an invalid SRAM address.\n- Performing a DSP operation with an invalid REG_OPERAND_O address.\n\n3. **Signals Stimulus:**\n- Randomize signals when it makes sense.\n- Randomize valid and invalid stimuli across different tasks.\n- Wait for PCLK rising edge after reset deassertion.\n- Wait for CDC synchronization (insert some delay or additional posedge clocks commands in the test).", "context": {"rtl/apb_dsp_op.sv": "// APB DSP Operation Module\nmodule apb_dsp_op #(\n    parameter ADDR_WIDTH = 'd8,\n    parameter DATA_WIDTH = 'd32\n) (\n    input  logic                  clk_dsp,    // Faster clock to DSP operation\n    input  logic                  en_clk_dsp, // Enable DSP operation with faster clock\n    input  logic                  PCLK,       // APB clock\n    input  logic                  PRESETn,    // Active low asynchronous APB Reset\n    input  logic [ADDR_WIDTH-1:0] PADDR,      // APB address\n    input  logic                  PWRITE,     // Write/Read enable\n    input  logic [DATA_WIDTH-1:0] PWDATA,     // Write data\n    input  logic                  PSEL,       // DSP selector\n    input  logic                  PENABLE,    // APB enable\n    output logic [DATA_WIDTH-1:0] PRDATA,     // Read data\n    output logic                  PREADY,     // Ready signal\n    output logic                  PSLVERR     // Error signal\n);\n\n    // Synchronize en_clk_dsp signal to clk_dsp domain to avoid CDC issues\n    logic clk_dsp_sel;\n    logic en_clk_dsp_ff;\n    logic en_clk_dsp_sync_ff;\n\n    always_ff @(posedge clk_dsp or negedge PRESETn) begin\n        if (!PRESETn) begin\n            en_clk_dsp_ff      <= 1'b0;\n            en_clk_dsp_sync_ff <= 1'b0;\n        end else begin\n            en_clk_dsp_ff      <= en_clk_dsp;\n            en_clk_dsp_sync_ff <= en_clk_dsp_ff;\n        end\n    end\n\n    // Clock selection\n    assign clk_dsp_sel = (en_clk_dsp_ff) ? clk_dsp : PCLK;\n\n    // Internal registers address map\n    localparam ADDRESS_A         = 32'h0;  // 0x00\n    localparam ADDRESS_B         = 32'h4;  // 0x04\n    localparam ADDRESS_C         = 32'h8;  // 0x08\n    localparam ADDRESS_O         = 32'hC;  // 0x0C\n    localparam ADDRESS_CONTROL   = 32'h10; // 0x10\n    localparam ADDRESS_WDATA     = 32'h14; // 0x14\n    localparam ADDRESS_SRAM_ADDR = 32'h18; // 0x18\n\n    // Control modes\n    localparam SRAM_WRITE     = 32'd1;\n    localparam SRAM_READ      = 32'd2;\n    localparam DSP_READ_OP_A  = 32'd3;\n    localparam DSP_READ_OP_B  = 32'd4;\n    localparam DSP_READ_OP_C  = 32'd5;\n    localparam DSP_WRITE_OP_O = 32'd6;\n\n    // Internal APB-side registers\n    logic [DATA_WIDTH-1:0] reg_operand_a;\n    logic [DATA_WIDTH-1:0] reg_operand_b;\n    logic [DATA_WIDTH-1:0] reg_operand_c;\n    logic [DATA_WIDTH-1:0] reg_operand_o;\n    logic [DATA_WIDTH-1:0] reg_control;\n    logic [DATA_WIDTH-1:0] reg_wdata_sram;\n    logic [DATA_WIDTH-1:0] reg_addr_sram;\n\n    // DSP-side pipeline regs and signals\n    logic signed [DATA_WIDTH-1:0] dsp_op_a;\n    logic signed [DATA_WIDTH-1:0] dsp_op_b;\n    logic signed [DATA_WIDTH-1:0] dsp_op_c;\n    logic signed [DATA_WIDTH-1:0] dsp_result;\n\n    // SRAM signals\n    logic [DATA_WIDTH-1:0] sram_data_in;\n    logic                  sram_we;\n    logic [DATA_WIDTH-1:0] sram_addr;\n    logic [DATA_WIDTH-1:0] sram_data_out;\n    logic [DATA_WIDTH-1:0] sram_data_out_sync_1;\n    logic [DATA_WIDTH-1:0] sram_data_out_sync_2;\n    \n    // SRAM local memory\n    logic [DATA_WIDTH-1:0] mem [63:0];\n\n    // APB interface logic\n    always_ff @(posedge PCLK or negedge PRESETn) begin\n        if (!PRESETn) begin\n            reg_operand_a  <= 'd0;\n            reg_operand_b  <= 'd0;\n            reg_operand_c  <= 'd0;\n            reg_operand_o  <= 'd0;\n            reg_control    <= 'd0;\n            reg_wdata_sram <= 'd0;\n            reg_addr_sram  <= 'd0;\n            PRDATA         <= 'd0;\n            PREADY         <= 1'b0;\n            PSLVERR        <= 1'b0;\n        end else if (PENABLE & PSEL) begin\n            // Default value\n            PREADY <= 1'b1;\n\n            // Check addresses\n            if (((reg_control == SRAM_WRITE) || (reg_control == DSP_WRITE_OP_O) || (reg_control == SRAM_READ)) && (sram_addr > 63)) begin\n                PSLVERR <= 1'b1;\n            end else begin\n                case (PADDR)\n                    ADDRESS_A         : PSLVERR <= 1'b0;\n                    ADDRESS_B         : PSLVERR <= 1'b0;\n                    ADDRESS_C         : PSLVERR <= 1'b0;\n                    ADDRESS_O         : PSLVERR <= 1'b0;\n                    ADDRESS_CONTROL   : PSLVERR <= 1'b0;\n                    ADDRESS_WDATA     : PSLVERR <= 1'b0;\n                    ADDRESS_SRAM_ADDR : PSLVERR <= 1'b0;\n                    default           : PSLVERR <= 1'b1;\n                endcase\n            end\n\n            // Internal register operation\n            if (PWRITE) begin\n                case (PADDR)\n                    ADDRESS_A         : reg_operand_a  <= PWDATA;\n                    ADDRESS_B         : reg_operand_b  <= PWDATA;\n                    ADDRESS_C         : reg_operand_c  <= PWDATA;\n                    ADDRESS_O         : reg_operand_o  <= PWDATA;\n                    ADDRESS_CONTROL   : reg_control    <= PWDATA;\n                    ADDRESS_WDATA     : reg_wdata_sram <= PWDATA;\n                    ADDRESS_SRAM_ADDR : reg_addr_sram  <= PWDATA;\n                endcase\n            end else begin\n                if (reg_control == SRAM_READ) begin\n                    PRDATA <= sram_data_out_sync_2;\n                end else begin\n                    case (PADDR)\n                        ADDRESS_A         : PRDATA  <= reg_operand_a;\n                        ADDRESS_B         : PRDATA  <= reg_operand_b;\n                        ADDRESS_C         : PRDATA  <= reg_operand_c;\n                        ADDRESS_O         : PRDATA  <= reg_operand_o;\n                        ADDRESS_CONTROL   : PRDATA  <= reg_control;\n                        ADDRESS_WDATA     : PRDATA  <= reg_wdata_sram;\n                        ADDRESS_SRAM_ADDR : PRDATA  <= reg_addr_sram;\n                    endcase\n                end               \n            end\n        end\n    end\n\n    // CDC synchronization for safe SRAM reads\n    always_ff @(posedge clk_dsp_sel or negedge PRESETn) begin\n        if (!PRESETn) begin\n            sram_data_out_sync_1 <= 'd0;\n            sram_data_out_sync_2 <= 'd0;\n        end else begin\n            sram_data_out_sync_1 <= sram_data_out;\n            sram_data_out_sync_2 <= sram_data_out_sync_1;\n        end        \n    end\n\n    // SRAM logic synchronization\n    always_ff @(posedge clk_dsp_sel) begin\n        sram_data_in <= (reg_control == SRAM_WRITE) ? reg_wdata_sram : dsp_result;\n\n        if ((reg_control == SRAM_WRITE) || (reg_control == DSP_WRITE_OP_O)) begin\n            sram_we <= 1'b1;\n        end else begin\n            sram_we <= 1'b0;\n        end\n\n        case (reg_control)\n            DSP_READ_OP_A  : sram_addr <= reg_operand_a;\n            DSP_READ_OP_B  : sram_addr <= reg_operand_b;\n            DSP_READ_OP_C  : sram_addr <= reg_operand_c;\n            DSP_WRITE_OP_O : sram_addr <= reg_operand_o;\n            default        : sram_addr <= reg_addr_sram;\n        endcase\n    end\n\n    // SRAM operation\n    always_ff @(posedge clk_dsp_sel) begin\n        if (sram_we) begin\n            mem[sram_addr] <= sram_data_in;\n        end else begin\n            sram_data_out <= mem[sram_addr];\n        end\n    end\n    \n    // DSP operation\n    always_ff @(posedge clk_dsp_sel) begin\n        case (reg_control)\n            DSP_READ_OP_A  : dsp_op_a <= sram_data_out;\n            DSP_READ_OP_B  : dsp_op_b <= sram_data_out;\n            DSP_READ_OP_C  : dsp_op_c <= sram_data_out;\n        endcase\n    end\n    \n    assign dsp_result = (dsp_op_a * dsp_op_b) + dsp_op_c;\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_apb_dsp_op.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 6-tb-stimulus\nTARGET = 100", "src/apb_dsp_op.sv": "// APB DSP Operation Module\nmodule apb_dsp_op #(\n    parameter ADDR_WIDTH = 'd8,\n    parameter DATA_WIDTH = 'd32\n) (\n    input  logic                  clk_dsp,    // Faster clock to DSP operation\n    input  logic                  en_clk_dsp, // Enable DSP operation with faster clock\n    input  logic                  PCLK,       // APB clock\n    input  logic                  PRESETn,    // Active low asynchronous APB Reset\n    input  logic [ADDR_WIDTH-1:0] PADDR,      // APB address\n    input  logic                  PWRITE,     // Write/Read enable\n    input  logic [DATA_WIDTH-1:0] PWDATA,     // Write data\n    input  logic                  PSEL,       // DSP selector\n    input  logic                  PENABLE,    // APB enable\n    output logic [DATA_WIDTH-1:0] PRDATA,     // Read data\n    output logic                  PREADY,     // Ready signal\n    output logic                  PSLVERR     // Error signal\n);\n\n    // Synchronize en_clk_dsp signal to clk_dsp domain to avoid CDC issues\n    logic clk_dsp_sel;\n    logic en_clk_dsp_ff;\n    logic en_clk_dsp_sync_ff;\n\n    always_ff @(posedge clk_dsp or negedge PRESETn) begin\n        if (!PRESETn) begin\n            en_clk_dsp_ff      <= 1'b0;\n            en_clk_dsp_sync_ff <= 1'b0;\n        end else begin\n            en_clk_dsp_ff      <= en_clk_dsp;\n            en_clk_dsp_sync_ff <= en_clk_dsp_ff;\n        end\n    end\n\n    // Clock selection\n    assign clk_dsp_sel = (en_clk_dsp_ff) ? clk_dsp : PCLK;\n\n    // Internal registers address map\n    localparam ADDRESS_A         = 32'h0;  // 0x00\n    localparam ADDRESS_B         = 32'h4;  // 0x04\n    localparam ADDRESS_C         = 32'h8;  // 0x08\n    localparam ADDRESS_O         = 32'hC;  // 0x0C\n    localparam ADDRESS_CONTROL   = 32'h10; // 0x10\n    localparam ADDRESS_WDATA     = 32'h14; // 0x14\n    localparam ADDRESS_SRAM_ADDR = 32'h18; // 0x18\n\n    // Control modes\n    localparam SRAM_WRITE     = 32'd1;\n    localparam SRAM_READ      = 32'd2;\n    localparam DSP_READ_OP_A  = 32'd3;\n    localparam DSP_READ_OP_B  = 32'd4;\n    localparam DSP_READ_OP_C  = 32'd5;\n    localparam DSP_WRITE_OP_O = 32'd6;\n\n    // Internal APB-side registers\n    logic [DATA_WIDTH-1:0] reg_operand_a;\n    logic [DATA_WIDTH-1:0] reg_operand_b;\n    logic [DATA_WIDTH-1:0] reg_operand_c;\n    logic [DATA_WIDTH-1:0] reg_operand_o;\n    logic [DATA_WIDTH-1:0] reg_control;\n    logic [DATA_WIDTH-1:0] reg_wdata_sram;\n    logic [DATA_WIDTH-1:0] reg_addr_sram;\n\n    // DSP-side pipeline regs and signals\n    logic signed [DATA_WIDTH-1:0] dsp_op_a;\n    logic signed [DATA_WIDTH-1:0] dsp_op_b;\n    logic signed [DATA_WIDTH-1:0] dsp_op_c;\n    logic signed [DATA_WIDTH-1:0] dsp_result;\n\n    // SRAM signals\n    logic [DATA_WIDTH-1:0] sram_data_in;\n    logic                  sram_we;\n    logic [DATA_WIDTH-1:0] sram_addr;\n    logic [DATA_WIDTH-1:0] sram_data_out;\n    logic [DATA_WIDTH-1:0] sram_data_out_sync_1;\n    logic [DATA_WIDTH-1:0] sram_data_out_sync_2;\n    \n    // SRAM local memory\n    logic [DATA_WIDTH-1:0] mem [63:0];\n\n    // APB interface logic\n    always_ff @(posedge PCLK or negedge PRESETn) begin\n        if (!PRESETn) begin\n            reg_operand_a  <= 'd0;\n            reg_operand_b  <= 'd0;\n            reg_operand_c  <= 'd0;\n            reg_operand_o  <= 'd0;\n            reg_control    <= 'd0;\n            reg_wdata_sram <= 'd0;\n            reg_addr_sram  <= 'd0;\n            PRDATA         <= 'd0;\n            PREADY         <= 1'b0;\n            PSLVERR        <= 1'b0;\n        end else if (PENABLE & PSEL) begin\n            // Default value\n            PREADY <= 1'b1;\n\n            // Check addresses\n            if (((reg_control == SRAM_WRITE) || (reg_control == DSP_WRITE_OP_O) || (reg_control == SRAM_READ)) && (sram_addr > 63)) begin\n                PSLVERR <= 1'b1;\n            end else begin\n                case (PADDR)\n                    ADDRESS_A         : PSLVERR <= 1'b0;\n                    ADDRESS_B         : PSLVERR <= 1'b0;\n                    ADDRESS_C         : PSLVERR <= 1'b0;\n                    ADDRESS_O         : PSLVERR <= 1'b0;\n                    ADDRESS_CONTROL   : PSLVERR <= 1'b0;\n                    ADDRESS_WDATA     : PSLVERR <= 1'b0;\n                    ADDRESS_SRAM_ADDR : PSLVERR <= 1'b0;\n                    default           : PSLVERR <= 1'b1;\n                endcase\n            end\n\n            // Internal register operation\n            if (PWRITE) begin\n                case (PADDR)\n                    ADDRESS_A         : reg_operand_a  <= PWDATA;\n                    ADDRESS_B         : reg_operand_b  <= PWDATA;\n                    ADDRESS_C         : reg_operand_c  <= PWDATA;\n                    ADDRESS_O         : reg_operand_o  <= PWDATA;\n                    ADDRESS_CONTROL   : reg_control    <= PWDATA;\n                    ADDRESS_WDATA     : reg_wdata_sram <= PWDATA;\n                    ADDRESS_SRAM_ADDR : reg_addr_sram  <= PWDATA;\n                endcase\n            end else begin\n                if (reg_control == SRAM_READ) begin\n                    PRDATA <= sram_data_out_sync_2;\n                end else begin\n                    case (PADDR)\n                        ADDRESS_A         : PRDATA  <= reg_operand_a;\n                        ADDRESS_B         : PRDATA  <= reg_operand_b;\n                        ADDRESS_C         : PRDATA  <= reg_operand_c;\n                        ADDRESS_O         : PRDATA  <= reg_operand_o;\n                        ADDRESS_CONTROL   : PRDATA  <= reg_control;\n                        ADDRESS_WDATA     : PRDATA  <= reg_wdata_sram;\n                        ADDRESS_SRAM_ADDR : PRDATA  <= reg_addr_sram;\n                    endcase\n                end               \n            end\n        end\n    end\n\n    // CDC synchronization for safe SRAM reads\n    always_ff @(posedge clk_dsp_sel or negedge PRESETn) begin\n        if (!PRESETn) begin\n            sram_data_out_sync_1 <= 'd0;\n            sram_data_out_sync_2 <= 'd0;\n        end else begin\n            sram_data_out_sync_1 <= sram_data_out;\n            sram_data_out_sync_2 <= sram_data_out_sync_1;\n        end        \n    end\n\n    // SRAM logic synchronization\n    always_ff @(posedge clk_dsp_sel) begin\n        sram_data_in <= (reg_control == SRAM_WRITE) ? reg_wdata_sram : dsp_result;\n\n        if ((reg_control == SRAM_WRITE) || (reg_control == DSP_WRITE_OP_O)) begin\n            sram_we <= 1'b1;\n        end else begin\n            sram_we <= 1'b0;\n        end\n\n        case (reg_control)\n            DSP_READ_OP_A  : sram_addr <= reg_operand_a;\n            DSP_READ_OP_B  : sram_addr <= reg_operand_b;\n            DSP_READ_OP_C  : sram_addr <= reg_operand_c;\n            DSP_WRITE_OP_O : sram_addr <= reg_operand_o;\n            default        : sram_addr <= reg_addr_sram;\n        endcase\n    end\n\n    // SRAM operation\n    always_ff @(posedge clk_dsp_sel) begin\n        if (sram_we) begin\n            mem[sram_addr] <= sram_data_in;\n        end else begin\n            sram_data_out <= mem[sram_addr];\n        end\n    end\n    \n    // DSP operation\n    always_ff @(posedge clk_dsp_sel) begin\n        case (reg_control)\n            DSP_READ_OP_A  : dsp_op_a <= sram_data_out;\n            DSP_READ_OP_B  : dsp_op_b <= sram_data_out;\n            DSP_READ_OP_C  : dsp_op_c <= sram_data_out;\n        endcase\n    end\n    \n    assign dsp_result = (dsp_op_a * dsp_op_b) + dsp_op_c;\n\nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/apb_dsp_op.sv /code/verif/tb_apb_dsp_op.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"apb_dsp_op_dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_apb_dsp_unit_0003", "categories": ["cid012", "medium"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `apb_dsp_unit`. The module serves as an APB interface for configuring internal registers. These registers specify which memory addresses are used for arithmetic operations (addition or multiplication). The computed result is then made available through a designated register. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameters, Inputs - Outputs and Functional behavior**\n\n\n---\n\n### Register Descriptions\n\n1. **`r_operand_1`**  \n   - **Address:** 0x0  \n   - **Function:** Holds the memory address of the first operand.\n\n2. **`r_operand_2`**  \n   - **Address:** 0x1  \n   - **Function:** Holds the memory address of the second operand.\n\n3. **`r_Enable`**  \n   - **Address:** 0x2  \n   - **Values:**  \n     - `0`: DSP disabled  \n     - `1`: Addition mode  \n     - `2`: Multiplication mode  \n     - `3`: Data Writing mode  \n\n4. **`r_write_address`**  \n   - **Address:** 0x3  \n   - **Function:** Specifies the address in memory where data will be written.  \n   - **Default Value:** 0x00000000  \n   - **Usage:** If `r_Enable` = 3, the data in the `r_write_data` register is written to the address specified by this register.\n\n5. **`r_write_data`**  \n   - **Address:** 0x4  \n   - **Function:** Specifies the data to be written into memory.  \n   - **Default Value:** 0x00000000  \n   - **Usage:** If `r_Enable` = 3, the data in this register is written to the address specified by `r_write_address`.\n\n---\n\n### APB Interface: \n#### Clock & Reset Signals\n- `pclk`: APB clock input for synchronous operations.  \n- `presetn`: Active-low asynchronous reset signal for system initialization.\n\n#### APB Signals\n- `paddr` (input, 10 bits): Address bus for accessing internal CSR registers and Memory.  \n- `pselx` (input): APB select signal, indicating CSR and Memory selection.  \n- `penable` (input): APB enable signal, marking transaction progression.  \n- `pwrite` (input): Write-enable signal, distinguishing read from write operations, high for write and low for read operation.\n- `pwdata` (input, 8 bits): Write data bus for sending data to CSR registers and Memory.  \n- `pready` (output, reg): Ready signal, indicating the completion of a transaction.  \n- `prdata` (output, reg, 8 bits): Read data bus for retrieving data.  \n- `pslverr` (output, reg): Error signal for invalid addresses or unsupported operations.\n\n### SRAM Interface:\n- `sram_valid`: At positive edge of this signal, data in `r_write_data` is latched to address in `r_write_address`.\n\n---\n\n### APB Protocol\n\n1. **Read Operations**  \n   - In the **READ_STATE**, drive `prdata` with the register value corresponding to `paddr`.\n   - After operation, return to **IDLE**.\n\n2. **Write Operations**  \n   - In the **WRITE_STATE**, update the register selected by `paddr` with `pwdata`.  \n   - After updating the register, return to **IDLE**.\n\n3. **Reset Behavior**  \n   - When `presetn` is deasserted (active-low), reset all outputs and internal registers to their default values:\n     - Set `pready` and `pslverr` to 0.  \n     - Clear `prdata`.  \n     - Initialize `r_operand_1`, `r_operand_2`, `r_Enable`, `r_write_address`, and `r_write_data` to 0.\n\n---\n\n### Functional Behavior\n\n1. **APB Interface Control**  \n   - Memory is accessed via the APB interface.  \n   - The operational mode is controlled by **`r_Enable`**:\n     - **Default (0x0):** DSP is disabled.  \n     - **Write Mode (0x3):** Data can be written to memory.  \n     - **Addition Mode (0x1):** Values at the addresses specified by **`r_operand_1`** and **`r_operand_2`** are added. The result is stored at address **0x5**.  \n     - **Multiplication Mode (0x2):** Values at the addresses specified by **`r_operand_1`** and **`r_operand_2`** are multiplied. The result is stored at address **0x5**.  \n   - To read computed data directly via APB, use address **0x5** and retrieve it through **`PRDATA`**.\n\n2. **Error Handling**  \n   - If a read or write operation is attempted on an address outside the defined registers, **`PSLVERR`** is driven high (`1'b1`).\n\n3. **Wait States**  \n   - This design does not support wait states. All APB read/write operations complete in two clock cycles, with **`PREADY`** always driven high (`1'b1`).\n\n4. **Memory Interface**  \n   - A 1 KB SRAM module serves as the memory.\n\n**Note:** Addresses from **0x00** to **0x05** are reserved for configuration registers.\n\n## Test Bench Requirements\n\n### Stimulus Generation\n\n#### 1. **Reset and Initialization**\n\n1. Drive `presetn` low for a defined interval.\n2. Drive `presetn` high to release reset.\n\n#### 2. **APB Write Stimulus**\n\n1. Access each **valid register** address (`0x0` to `0x4`) with:\n   - `pselx` = 1\n   - `penable` toggled appropriately\n   - `pwrite` = 1\n   - Various `pwdata` patterns (e.g., minimum, maximum, random).\n2. Perform **consecutive writes** to different registers in rapid succession.\n3. Issue a **write** to an **invalid address** (greater than `0x5`).\n4. Attempt memory writes under various `r_Enable` states, including values outside the valid range of modes.\n\n#### 3. **APB Read Stimulus**\n\n1. Read from **each valid register** address (`0x0` to `0x5`) with:\n   - `pselx` = 1\n   - `penable` toggled appropriately\n   - `pwrite` = 0\n2. Perform **back-to-back** reads of the same register and different registers.\n3. Issue a **read** to an **invalid address** (greater than `0x5`).\n4. Vary APB handshake signals, including cases with missing or incorrect enable signals.\n\n#### 4. **DSP Arithmetic Stimulus**\n\n### 4.1 **Addition Mode**\n1. Set `r_Enable` to indicate addition mode.\n2. Provide valid addresses in `r_operand_1` and `r_operand_2` that point to memory locations.\n3. Use data-writing transactions to load different data patterns into those memory addresses.\n4. Include minimal, maximal, and intermediate values to explore potential overflow and boundary conditions.\n\n##### 4.2 **Multiplication Mode**\n1. Set `r_Enable` to indicate multiplication mode.\n2. Provide valid addresses in `r_operand_1` and `r_operand_2`.\n3. Use memory transactions to populate these locations with a variety of patterns.\n4. Include edge cases that might trigger overflow scenarios.\n\n#### 5. **Memory Write Stimulus**\n\n1. Set `r_Enable` to indicate write mode.\n2. Vary `r_write_address` and `r_write_data` across:\n   - Low, high, and random valid addresses.\n   - Low, high, and random data values.\n3. Drive `sram_valid` high to trigger the memory-write mechanism.\n4. Attempt writing beyond the valid memory range.\n\n#### 6. **Error Condition Stimulus**\n\n1. Drive **invalid `r_Enable`** values beyond the defined modes.\n2. Perform APB **read/write operations** without correctly asserting `penable` or `pselx`.\n3. Access invalid or out-of-range addresses with and without proper handshake signals.\n\n#### 7. **Stress and Concurrency Stimulus**\n\n1. Issue **rapid sequences** of APB transactions (reads and writes) to valid and invalid addresses.\n2. Continuously switch `r_Enable` among different modes (addition, multiplication, write, disabled, and any invalid code).\n3. Randomize APB signals (within protocol constraints) to test corner cases of back-to-back operations.\n\n#### 8. **Full Coverage Stimulus**\n\n1. Stimulate **every register** in both read and write directions.\n2. Exercise **all operational modes** defined in the design, plus invalid ones.\n3. Drive memory addresses across the **entire valid range** and some out-of-range values.\n4. Include data patterns that explore arithmetic boundary conditions (such as overflow scenarios).\n\n#### 9. Additional Test Cases for Complete Coverage\n\n##### 9.1. Full Bit Toggling on Registers\n- Write `0xFF` and `0x00` to:\n  - `r_operand_1`\n  - `r_operand_2`\n  - `r_enable`\n  - `r_write_address`\n  - `r_write_data`\n\n##### 9.2. Memory Boundary Testing\n- Write to the **maximum valid memory address** (`10'h3FF` = 1023).\n- Attempt an **out-of-range write** (`10'h401` = 1025) when `r_enable = MODE_WRITE`.\n\n##### 9.3. Repeated Reset to Toggle Related Signals\n- Assert and deassert `presetn` **mid-test** to toggle:\n  - `pready`\n  - `pslverr`\n\n##### 9.4. Out-of-Range Address Read\n- **Read from `10'h401`** after an out-of-range write to verify `PSLVERR`.", "context": {}}, "output": {"response": "", "context": {"verif/tb_apb_dsp_unit.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 3-tb-stimulus\nTARGET = 98", "src/apb_dsp_unit.v": "module apb_dsp_unit (\n    // APB clock & reset\n    input  wire         pclk,\n    input  wire         presetn,  // Active-low reset\n\n    // APB signals\n    input  wire [9:0]   paddr,\n    input  wire         pselx,\n    input  wire         penable,\n    input  wire         pwrite,\n    input  wire [7:0]   pwdata,\n    input  wire         sram_valid,\n    output reg          pready,\n    output reg  [7:0]   prdata,\n    output reg          pslverr\n);\n\n    //---------------------------------------------\n    // Parameter Definitions\n    //---------------------------------------------\n    // Register address map\n    localparam ADDR_OPERAND1     = 10'h0;  // 0x0\n    localparam ADDR_OPERAND2     = 10'h1;  // 0x1\n    localparam ADDR_ENABLE       = 10'h2;  // 0x2\n    localparam ADDR_WRITE_ADDR   = 10'h3;  // 0x3\n    localparam ADDR_WRITE_DATA   = 10'h4;  // 0x4\n    localparam ADDR_RESULT       = 10'h5;  // 0x5 (used for storing DSP results)\n\n    // DSP Modes\n    localparam MODE_DISABLED     = 8'h0;   // DSP disabled\n    localparam MODE_ADD          = 8'h1;   // Addition mode\n    localparam MODE_MULT         = 8'h2;   // Multiplication mode\n    localparam MODE_WRITE        = 8'h3;   // Data Writing mode\n\n    // Memory size (1KB = 1024 bytes)\n    localparam MEM_SIZE          = 1024;\n\n    //---------------------------------------------\n    // Internal Registers (CSR)\n    //---------------------------------------------\n    reg [7:0] r_operand_1;\n    reg [7:0] r_operand_2;\n    reg [7:0] r_enable;\n    reg [7:0] r_write_address;\n    reg [7:0] r_write_data;\n\n    //---------------------------------------------\n    // Memory (1 KB SRAM)\n    //---------------------------------------------\n    reg [7:0] sram_mem [0:MEM_SIZE-1];\n\n    //---------------------------------------------\n    // APB Read/Write Logic\n    //---------------------------------------------\n    wire apb_valid;\n    assign apb_valid = pselx & penable;    // Indicates active APB transaction\n\n    // By spec, no wait states => PREADY always high after reset\n    always @(posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            pready   <= 1'b0;\n            pslverr  <= 1'b0;\n        end else begin\n            // PREADY is always asserted (no wait states) once out of reset\n            pready   <= 1'b1;\n            pslverr  <= 1'b0;\n\n            // If transaction is valid, check address range\n            if (apb_valid) begin\n                if(r_enable==MODE_WRITE) begin\n                    if (paddr > MEM_SIZE) begin\n                        pslverr <= 1'b1;\n                    end\n                end\n                else begin\n                    // Check if address is valid (0x0 through 0x5 are used, everything else => PSLVERR)\n                    if (paddr > ADDR_RESULT) begin\n                        pslverr <= 1'b1;\n                    end\n                end\n            end\n        end\n    end\n\n    // Handle writes to CSR or memory\n    // Note: The design writes immediately in the cycle when penable=1.\n    always @(posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            // Reset all registers\n            r_operand_1    <= 8'h00;\n            r_operand_2    <= 8'h00;\n            r_enable       <= 8'h00;\n            r_write_address<= 8'h00;\n            r_write_data   <= 8'h00;\n        end else begin\n            if (apb_valid && pwrite) begin\n                case (paddr)\n                    ADDR_OPERAND1:     r_operand_1     <= pwdata;\n                    ADDR_OPERAND2:     r_operand_2     <= pwdata;\n                    ADDR_ENABLE:       r_enable        <= pwdata;\n                    ADDR_WRITE_ADDR:   r_write_address <= pwdata;\n                    ADDR_WRITE_DATA:   r_write_data    <= pwdata;\n                    // If the address is outside defined range => PSLVERR is set, no write\n                endcase\n            end\n        end\n    end\n\n    // Handle read from CSR or memory\n    always @(posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            prdata <= 8'h00;\n        end else begin\n            if (apb_valid && !pwrite) begin\n                if(r_enable==MODE_WRITE) begin\n                    prdata <= sram_mem[paddr];\n                end\n                else begin\n                    case (paddr)\n                        ADDR_OPERAND1:     prdata <= r_operand_1;\n                        ADDR_OPERAND2:     prdata <= r_operand_2;\n                        ADDR_ENABLE:       prdata <= r_enable;\n                        ADDR_WRITE_ADDR:   prdata <= r_write_address;\n                        ADDR_WRITE_DATA:   prdata <= r_write_data;\n                        ADDR_RESULT:       prdata <= sram_mem[ADDR_RESULT];  // Read the result from memory[0x5]\n                        default:           prdata <= 8'h00; // Invalid => PSLVERR, but can set prdata to 0\n                    endcase\n                end\n            end else if (!apb_valid) begin\n                // When no valid read, clear prdata (optional behavior)\n                prdata <= 8'h00;\n            end\n        end\n    end\n\n    //---------------------------------------------\n    // SRAM write Behavior\n    //---------------------------------------------\n    always @(posedge sram_valid or negedge presetn) begin\n        if (!presetn) begin\n            // Initialize memory location for result\n            sram_mem[ADDR_RESULT] <= 8'h00;\n        end else begin\n            // If r_Enable = WRITE (0x3), write r_write_data into memory[r_write_address]\n            if (r_enable == MODE_WRITE) begin\n                // Write data to memory at r_write_address\n                sram_mem[r_write_address] <= r_write_data;\n            end\n        end\n    end\n\n    //---------------------------------------------\n    // DSP Functional Behavior\n    //---------------------------------------------\n    always @(posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            // Initialize memory location for result\n            sram_mem[ADDR_RESULT] <= 8'h00;\n        end else begin\n            // If r_Enable = ADD (0x1), add contents of memory[r_operand_1] and memory[r_operand_2]\n            if (r_enable == MODE_ADD) begin\n                sram_mem[ADDR_RESULT] <= sram_mem[r_operand_1] + sram_mem[r_operand_2];\n            end\n            // If r_Enable = MULT (0x2), multiply contents of memory[r_operand_1] and memory[r_operand_2]\n            else if (r_enable == MODE_MULT) begin\n                sram_mem[ADDR_RESULT] <= sram_mem[r_operand_1] * sram_mem[r_operand_2];\n            end\n            // If r_Enable = DISABLED (0x0), no operation\n            // else do nothing\n        end\n    end\n\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/apb_dsp_unit.v /code/verif/tb_apb_dsp_unit.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_apb_dsp_unit_0005", "categories": ["cid013", "medium"], "input": {"prompt": "Create a **SystemVerilog testbench checker** with detailed stimulus to test that checker and to validate the `apb_dsp_unit` module by applying exhaustive test scenarios. The module serves as an APB interface for configuring internal registers. These registers specify which memory addresses are used for arithmetic operations (addition or multiplication). The computed result is then made available through a designated register. The testbench should ensure:\n\n- Comprehensive **input stimulus** generation covering all possible cases.\n- **Checker generation** of the FSM output.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameter Inputs - Outputs and Functional behaviour**\n\n---\n\n### Register Descriptions\n\n1. **`r_operand_1`**  \n   - **Address:** 0x0  \n   - **Function:** Holds the memory address of the first operand.\n\n2. **`r_operand_2`**  \n   - **Address:** 0x1  \n   - **Function:** Holds the memory address of the second operand.\n\n3. **`r_Enable`**  \n   - **Address:** 0x2  \n   - **Values:**  \n     - `0`: DSP disabled  \n     - `1`: Addition mode  \n     - `2`: Multiplication mode  \n     - `3`: Data Writing mode  \n\n4. **`r_write_address`**  \n   - **Address:** 0x3  \n   - **Function:** Specifies the address in memory where data will be written.  \n   - **Default Value:** 0x00000000  \n   - **Usage:** If `r_Enable` = 3, the data in the `r_write_data` register is written to the address specified by this register.\n\n5. **`r_write_data`**  \n   - **Address:** 0x4  \n   - **Function:** Specifies the data to be written into memory.  \n   - **Default Value:** 0x00000000  \n   - **Usage:** If `r_Enable` = 3, the data in this register is written to the address specified by `r_write_address`.\n\n---\n\n### APB Interface: \n#### Clock & Reset Signals\n- `pclk`: APB clock input for synchronous operations.  \n- `presetn`: Active-low asynchronous reset signal for system initialization.\n\n#### APB Signals\n- `paddr` (input, 10 bits): Address bus for accessing internal CSR registers and Memory.  \n- `pselx` (input): APB select signal, indicating CSR and Memory selection.  \n- `penable` (input): APB enable signal, marking transaction progression.  \n- `pwrite` (input): Write-enable signal, distinguishing read from write operations, high for write and low for read operation.\n- `pwdata` (input, 8 bits): Write data bus for sending data to CSR registers and Memory.  \n- `pready` (output, reg): Ready signal, indicating the completion of a transaction.  \n- `prdata` (output, reg, 8 bits): Read data bus for retrieving data.  \n- `pslverr` (output, reg): Error signal for invalid addresses or unsupported operations.\n\n### SRAM Interface:\n- `sram_valid`: At positive edge of this signal, data in `r_write_data` is latched to address in `r_write_address`.\n\n---\n\n### APB Protocol\n\n1. **Read Operations**  \n   - In the **READ_STATE**, drive `prdata` with the register value corresponding to `paddr`.\n   - After operation, return to **IDLE**.\n\n2. **Write Operations**  \n   - In the **WRITE_STATE**, update the register selected by `paddr` with `pwdata`.  \n   - After updating the register, return to **IDLE**.\n\n3. **Reset Behavior**  \n   - When `presetn` is deasserted (active-low), reset all outputs and internal registers to their default values:\n     - Set `pready` and `pslverr` to 0.  \n     - Clear `prdata`.  \n     - Initialize `r_operand_1`, `r_operand_2`, `r_Enable`, `r_write_address`, and `r_write_data` to 0.\n\n---\n\n### Functional Behavior\n\n1. **APB Interface Control**  \n   - Memory is accessed via the APB interface.  \n   - The operational mode is controlled by **`r_Enable`**:\n     - **Default (0x0):** DSP is disabled.  \n     - **Write Mode (0x3):** Data can be written to memory.  \n     - **Addition Mode (0x1):** Values at the addresses specified by **`r_operand_1`** and **`r_operand_2`** are added. The result is stored at address **0x5**.  \n     - **Multiplication Mode (0x2):** Values at the addresses specified by **`r_operand_1`** and **`r_operand_2`** are multiplied. The result is stored at address **0x5**.  \n   - To read computed data directly via APB, use address **0x5** and retrieve it through **`PRDATA`**.\n\n2. **Error Handling**  \n   - If a read or write operation is attempted on an address outside the defined registers, **`PSLVERR`** is driven high (`1'b1`).\n\n3. **Wait States**  \n   - This design does not support wait states. All APB read/write operations complete in two clock cycles, with **`PREADY`** always driven high (`1'b1`).\n\n4. **Memory Interface**  \n   - A 1 KB SRAM module serves as the memory.\n\n**Note:** Addresses from **0x00** to **0x05** are reserved for configuration registers.\n\n## Test Bench Requirements\n\n### Stimulus and checker Generation\n\n### 1. Reset and Initialization\n\n#### Test Steps\n\n| **Test Step** | **Stimulus**                                                                   | **Expected Module Output**                                                                                                                                                  |\n|---------------|--------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **1.1**       | - Assert `presetn = 0` for at least 2 clock cycles while `pclk` runs normally. | - After reset, module outputs should be quiet: <br> \u2022 `PREADY = 0` (or deasserted) <br> \u2022 `PSLVERR = 0` <br> \u2022 `PRDATA = 0`                                                 |\n| **1.2**       | - Deassert `presetn = 1` to release reset.                                     | - The module begins normal operation. <br> \u2022 `PREADY` will be high on valid transactions. <br> \u2022 **Do not issue APB read transactions to memory immediately after reset.**  |\n\n> **Note:** Unwritten memory addresses (and registers with default values) are not read because their data is considered corrupted or undefined.\n\n### 2. APB Write Stimulus\n\nAll write transactions follow proper APB handshakes (with `PSELX`, `PENABLE`, etc.). Subsequent reads to verify a write occur only on locations that have been written._\n\n| **Test Step** | **Stimulus**                                                                                         | **Expected Module Output**                                                                                                                 |\n|---------------|------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|\n| **2.1**       | Write operation to a valid register (e.g., address `0x0` with `PWDATA = 0xAA`).                      | - Transaction completes with: <br> \u2022 `PREADY = 1` <br> \u2022 `PSLVERR = 0`                                                                     |\n| **2.2**       | Write to another valid register (e.g., address `0x1` with `PWDATA = 0x55`).                          | - Transaction finishes with `PREADY = 1` and `PSLVERR = 0`.                                                                                |\n| **2.3**       | Rapid consecutive writes (addresses `0x0`, `0x1`, `0x2`, etc.) using valid APB handshakes.           | - Each write transaction completes with `PREADY = 1` and no error (`PSLVERR = 0`).                                                         |\n| **2.4**       | Write to an invalid register address (e.g., `paddr = 0x6` or any address greater than `0x5`).        | - Transaction completes with `PREADY = 1` and signals an error: `PSLVERR = 1`.                                                             |\n| **2.5**       | Write an unsupported mode value (e.g., writing `0x04` to the mode register).                         | - Although the module may accept the value, subsequent related transactions might show abnormal behavior. <br> \u2022 `PSLVERR` may be flagged. |\n\n---\n\n### 3. APB Read Stimulus\n\nRead transactions are only performed on registers and memory locations that have been previously written to._\n\n| **Test Step** | **Stimulus**                                                                                          | **Expected Module Output**                                                                                                  |\n|---------------|-------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------|\n| **3.1**       | Read from a valid register (e.g., address `0x0`) **after it has been written**.                       | - The module drives `PRDATA` with the value last written (e.g., `0xAA`). <br> \u2022 `PREADY = 1` and `PSLVERR = 0`.             |\n| **3.2**       | Back-to-back reads from the same valid register (e.g., two consecutive reads from address `0x0`).     | - `PRDATA` remains constant between transactions. <br> \u2022 Each transaction completes with `PREADY = 1` and `PSLVERR = 0`.    |\n| **3.3**       | Read from a sequence of valid registers (e.g., addresses `0x0`, `0x1`, `0x2`) that have been written. | - `PRDATA` reflects the correct values based on prior writes. <br> \u2022 `PREADY = 1` and `PSLVERR = 0` for each transaction.   |\n| **3.4**       | Read from a register holding computed results (e.g., address `0x5` after an arithmetic operation).    | - `PRDATA` shows the computed result. <br> \u2022 `PREADY = 1` and `PSLVERR = 0`.                                                |\n| **3.5**       | Attempt a read from an invalid register (e.g., `paddr = 0x6`).                                        | - Transaction returns with `PSLVERR = 1` and `PRDATA` is undefined or zero.                                                 |\n| **3.6**       | **Do not read** from memory addresses that have not been written.                                     | - No read operation is issued, avoiding corrupted data.                                                                     |\n\n> **Important:** APB reads on memory are performed only after a valid write.\n\n---\n\n### 4. DSP Arithmetic Stimulus\n\nArithmetic tests use APB transactions to trigger computations. Reads for the computed result at address `0x5` occur only after a valid arithmetic operation is triggered._\n\n#### 4.1 Addition Mode\n\n| **Test Step**   | **Stimulus**                                                                                                                | **Expected Module Output**                                                                                               |\n|-----------------|-----------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|\n| **4.1.1**       | Set mode to addition by writing `0x01` to the mode register.                                                                | - Write completes with `PREADY = 1` and `PSLVERR = 0`.                                                                   |\n| **4.1.2**       | Perform memory writes (via write mode) to two specific memory addresses (as set by the operand registers) with valid data.  | - APB writes complete correctly (verified by `PREADY = 1` and `PSLVERR = 0`).                                            |\n| **4.1.3**       | Trigger the arithmetic operation by writing to the mode register.                                                           | - The computed result becomes available externally at address `0x5`.                                                     |\n| **4.1.4**       | Read from address `0x5` **after the arithmetic operation is complete**.                                                     | - `PRDATA` outputs the sum (e.g., if memory held `0x11` and `0x22`, then `PRDATA = 0x33`).                               |\n| **4.1.5**       | Test with boundary values (values that could cause overflow).                                                               | - `PRDATA` reflects the sum, showing any overflow behavior (e.g., `0xFF + 0x01` may yield `0x00` if truncated to 8-bit). |\n\n#### 4.2 Multiplication Mode\n\n| **Test Step**   | **Stimulus**                                                                                                       | **Expected Module Output**                                                                             |\n|-----------------|--------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------|\n| **4.2.1**       | Set mode to multiplication by writing `0x02` to the mode register.                                                 | - Write completes with `PREADY = 1` and `PSLVERR = 0`.                                                 |\n| **4.2.2**       | Perform memory writes to two valid memory addresses (as indicated by the operand registers) with specified data.   | - Memory write transactions complete normally.                                                         |\n| **4.2.3**       | Trigger the multiplication operation by writing to the mode register.                                              | - The computed product is made available at address `0x5`.                                             |\n| **4.2.4**       | Read from address `0x5` to capture the multiplication result.                                                      | - `PRDATA` shows the product (e.g., if data values are `0x05` and `0x06`, then `PRDATA = 0x1E`).       |\n| **4.2.5**       | Test edge cases with data that might cause overflow.                                                               | - `PRDATA` shows the computed product with any defined overflow behavior.                              |\n\n---\n\n### 5. Memory Write Stimulus\n\n_Memory write tests use APB write mode. Reads are issued **only after a valid write** has been performed._\n\n| **Test Step** | **Stimulus**                                                                                                      | **Expected Module Output**                                                                                                        |\n|---------------|-------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------|\n| **5.1**       | Set the module to write mode and issue a write to a valid memory address (e.g., address `0x20` with data `0xAB`). | - Write transaction completes with `PREADY = 1` and `PSLVERR = 0`. <br> \u2022 A subsequent read (if supported) should return `0xAB`.  |\n| **5.2**       | Write to boundary memory addresses (e.g., `0x00` and `0x3FF`), and only read these addresses after writing.       | - Both transactions complete with `PREADY = 1` and `PSLVERR = 0`. <br> \u2022 Subsequent reads confirm expected data.                  |\n| **5.3**       | Attempt to write to an out-of-range memory address (e.g., `r_write_address = 0x400` or `0x401`).                  | - Transaction results in `PSLVERR = 1` and no write is applied.                                                                   |\n\n---\n\n### 6. Error Condition Stimulus\n\nThese cases intentionally violate protocol or access rules to verify error signaling via external outputs.\n\n| **Test Step** | **Stimulus**                                                                                                   | **Expected Module Output**                                                                                                     |\n|---------------|----------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------|\n| **6.1**       | Write using an invalid mode value (e.g., writing `0x04` or `0x07` to the mode register).                       | - Write completes with `PREADY = 1`, but subsequent operations may reflect abnormal behavior. <br> \u2022 `PSLVERR` may be flagged. |\n| **6.2**       | Issue an APB read/write without proper handshake signals (e.g., omitting `PENABLE` after `PSELX`).             | - Transaction does not complete correctly, resulting in no valid `PRDATA` and possible protocol errors.                        |\n| **6.3**       | Attempt a write to a valid register using an out-of-range address (e.g., `paddr > 0x5`).                       | - Module returns `PSLVERR = 1` while `PREADY` remains high, indicating error detection.                                        |\n\n---\n\n### 7. Stress and Concurrency Stimulus\n\nRapid sequences test external outputs under stress, ensuring only valid addresses with written data are read.\n\n| **Test Step** | **Stimulus**                                                                                                                     | **Expected Module Output**                                                                                                        |\n|---------------|----------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------|\n| **7.1**       | Rapidly issue a mix of valid and invalid APB transactions (reads and writes) **only on addresses known to contain valid data**.  | - Valid transactions complete with `PREADY = 1` and correct `PRDATA` on reads. <br> \u2022 Invalid transactions produce `PSLVERR = 1`. |\n| **7.2**       | Continuously toggle the mode (disabled, addition, multiplication, write, invalid) while issuing transactions.                    | - Module outputs corresponding results or errors as each mode is exercised.                                                       |\n| **7.3**       | Randomize APB signal timing (within protocol limits) to simulate back-to-back operations.                                        | - Module continues to correctly produce `PREADY`, `PRDATA`, and `PSLVERR` based on transaction validity.                          |\n\n---\n\n### 8. Full Coverage Stimulus\n\n_This set ensures every externally observable behavior is exercised while reading only from locations that have been explicitly written._\n\n| **Test Step** | **Stimulus**                                                                                                                        | **Expected Module Output**                                                                                   |\n|---------------|-------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------|\n| **8.1**       | Execute APB transactions to every register address (`0x0` to `0x5`) in write and subsequent read operations (only after writing).   | - For valid addresses, each transaction yields `PREADY = 1` and `PSLVERR = 0` with expected `PRDATA` values. |\n| **8.2**       | Issue APB transactions across the memory range, ensuring each memory address read is preceded by a valid write.                     | - Valid memory reads (post-write) produce correct data; out-of-range accesses produce `PSLVERR = 1`.         |\n| **8.3**       | Include arithmetic tests (addition and multiplication) with boundary data written before reading the result from `0x5`.             | - `PRDATA` shows the arithmetic result with any defined overflow behavior.                                   |\n\n---\n\n### 9. Additional Specific Test Cases\n\n#### 9.1 Full Bit Toggling via External Reads\n\n| **Test Step**   | **Stimulus**                                                                                        | **Expected Module Output**                                                                           |\n|-----------------|-----------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|\n| **9.1.1**       | Write `0xFF` to each valid register via APB writes, then read them back (only after writes).        | - Reads yield `PRDATA = 0xFF` for each register.                                                     |\n| **9.1.2**       | Similarly, write `0x00` to registers and read them back after the write.                            | - All reads yield `PRDATA = 0x00`.                                                                   |\n\n#### 9.2 Memory Boundary Testing via External Interface\n\n| **Test Step** | **Stimulus**                                                                                                         | **Expected Module Output**                                                                           |\n|---------------|----------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|\n| **9.2.1**     | Write to the maximum valid memory address (e.g., `r_write_address = 0x3FF`) using a valid APB write, then read back. | - Transaction completes with `PREADY = 1` and no error; subsequent read confirms the data.           |\n| **9.2.2**     | Attempt a write to an out-of-range memory address (e.g., `r_write_address = 0x401`).                                 | - Transaction results in `PSLVERR = 1` and no data is written.                                       |\n\n#### 9.3 Repeated Reset During Operation\n\n| **Test Step** | **Stimulus**                                                                                        | **Expected Module Output**                                                                           |\n|---------------|-----------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|\n| **9.3.1**     | During a sequence of transactions, assert `presetn = 0` briefly and then deassert it again.         | - Immediately after reset, outputs revert to default (`PRDATA = 0`, `PREADY = 0`, `PSLVERR = 0`).    |\n| **9.3.2**     | Resume APB transactions only on addresses that have been explicitly written post-reset.             | - Valid transactions perform as expected (with `PREADY = 1` and no errors).                          |\n\n#### 9.4 Out-of-Range Read\n\n| **Test Step** | **Stimulus**                                                                                                            | **Expected Module Output**                                                                           |\n|---------------|-------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|\n| **9.4.1**     | After an invalid write to a non-existent register, issue a read from that out-of-range address (e.g., `paddr = 0x401`). | - Read returns `PRDATA` as undefined or zero with `PSLVERR = 1`, confirming the error condition.     |\n\n---\n\n## Simulation\n- Reset the dut and initialize inputs.\n- Apply the test cases sequentially.\n- Log errors if any discrepancies are found between dut outputs and the model.\n\n## Deliverables\nProvide the complete SystemVerilog testbench code with:\n1. dut instantiation.\n2. Implement a behavioral model to replicate the expected functionality.\n3. Test scenarios validating the dut against the expected behavior.\n4. Compare the outputs from the DUT with the model using checkers\n5. Log messages indicating pass/fail status for each test case.", "context": {}}, "output": {"response": "", "context": {"verif/apb_dsp_unit_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/apb_dsp_unit.v\nHASH            = 5-tb-checker\nNUM_BUGS        = 6", "src/apb_dsp_unit.v": "module apb_dsp_unit (\n    // APB clock & reset\n    input  wire         pclk,\n    input  wire         presetn,  // Active-low reset\n\n    // APB signals\n    input  wire [9:0]   paddr,\n    input  wire         pselx,\n    input  wire         penable,\n    input  wire         pwrite,\n    input  wire [7:0]   pwdata,\n    input  wire         sram_valid,\n    output reg          pready,\n    output reg  [7:0]   prdata,\n    output reg          pslverr\n);\n\n    //---------------------------------------------\n    // Parameter Definitions\n    //---------------------------------------------\n    // Register address map\n\n    localparam ADDR_OPERAND1     = 10'h0;  // 0x0\n    localparam ADDR_OPERAND2     = 10'h1;  // 0x1\n    localparam ADDR_ENABLE       = 10'h2;  // 0x2\n    localparam ADDR_WRITE_ADDR   = 10'h3;  // 0x3\n    localparam ADDR_WRITE_DATA   = 10'h4;  // 0x4\n    localparam ADDR_RESULT       = 10'h5;  // 0x5 (used for storing DSP results)\n\n    // DSP Modes\n    localparam MODE_DISABLED     = 8'h0;   // DSP disabled\n    localparam MODE_ADD          = 8'h1;   // Addition mode\n    localparam MODE_MULT         = 8'h2;   // Multiplication mode\n    localparam MODE_WRITE        = 8'h3;   // Data Writing mode\n\n    // Memory size (1KB = 1024 bytes)\n    localparam MEM_SIZE          = 1024;\n\n    //---------------------------------------------\n    // Internal Registers (CSR)\n    //---------------------------------------------\n    reg [7:0] r_operand_1;\n    reg [7:0] r_operand_2;\n    reg [7:0] r_enable;\n    reg [7:0] r_write_address;\n    reg [7:0] r_write_data;\n\n    //---------------------------------------------\n    // Memory (1 KB SRAM)\n    //---------------------------------------------\n    reg [7:0] sram_mem [0:MEM_SIZE-1];\n\n    //---------------------------------------------\n    // APB Read/Write Logic\n    //---------------------------------------------\n    wire apb_valid;\n    assign apb_valid = pselx & penable;    // Indicates active APB transaction\n\n    // By spec, no wait states => PREADY always high after reset\n    always @(posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            `ifdef BUG_0\n                pready   <= 1'b1;\n                pslverr  <= 1'b1;\n            `else\n                pready   <= 1'b0;\n                pslverr  <= 1'b0;\n            `endif\n        end else begin\n            // PREADY is always asserted (no wait states) once out of reset\n            `ifdef BUG_1\n                pready   <= 1'b0;\n                pslverr  <= 1'b1;\n            `else\n                pready   <= 1'b1;\n                pslverr  <= 1'b0;\n            `endif\n            \n            \n\n            // If transaction is valid, check address range\n            `ifdef BUG_2\n                if (!apb_valid) begin\n                    if(r_enable==MODE_WRITE) begin\n                        if (paddr > MEM_SIZE) begin\n                            pslverr <= 1'b1;\n                        end\n                    end\n                    else begin\n                        // Check if address is valid (0x0 through 0x5 are used, everything else => PSLVERR)\n                        if (paddr > ADDR_RESULT) begin\n                            pslverr <= 1'b1;\n                        end\n                    end\n                end\n            `elsif BUG_3\n                if (apb_valid) begin\n                    if(r_enable==MODE_WRITE) begin\n                        if (paddr > MEM_SIZE) begin\n                            pslverr <= 1'b1;\n                        end\n                    end\n                    else begin\n                        // Check if address is valid (0x0 through 0x5 are used, everything else => PSLVERR)\n                        if (paddr > ADDR_RESULT) begin\n                            pslverr <= 1'b0;\n                        end\n                    end\n                end\n            `elsif BUG_4\n                if (!apb_valid) begin\n                    if(r_enable!=MODE_WRITE) begin\n                        if (paddr > MEM_SIZE) begin\n                            pslverr <= 1'b1;\n                        end\n                    end\n                    else begin\n                        // Check if address is valid (0x0 through 0x5 are used, everything else => PSLVERR)\n                        if (paddr > ADDR_RESULT) begin\n                            pslverr <= 1'b1;\n                        end\n                    end\n                end\n            `else\n                if (apb_valid) begin\n                    if(r_enable==MODE_WRITE) begin\n                        if (paddr > MEM_SIZE) begin\n                            pslverr <= 1'b1;\n                        end\n                    end\n                    else begin\n                        // Check if address is valid (0x0 through 0x5 are used, everything else => PSLVERR)\n                        if (paddr > ADDR_RESULT) begin\n                            pslverr <= 1'b1;\n                        end\n                    end\n                end\n            `endif\n                \n            end\n        end\n\n    // Handle writes to CSR or memory\n    // Note: The design writes immediately in the cycle when penable=1.\n    always @(posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            // Reset all registers\n            r_operand_1    <= 8'h00;\n            r_operand_2    <= 8'h00;\n            r_enable       <= 8'h00;\n            r_write_address<= 8'h00;\n            r_write_data   <= 8'h00;\n        end else begin\n            if (apb_valid && pwrite) begin\n                case (paddr)\n                    ADDR_OPERAND1:     r_operand_1     <= pwdata;\n                    ADDR_OPERAND2:     r_operand_2     <= pwdata;\n                    ADDR_ENABLE:       r_enable        <= pwdata;\n                    ADDR_WRITE_ADDR:   r_write_address <= pwdata;\n                    ADDR_WRITE_DATA:   r_write_data    <= pwdata;\n                    // If the address is outside defined range => PSLVERR is set, no write\n                endcase\n            end\n        end\n    end\n\n    // Handle read from CSR or memory\n    always @(posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            `ifdef BUG_5\n                prdata <= 8'h11;\n            `else\n                prdata <= 8'h00;\n            `endif\n        end else begin\n            if (apb_valid && !pwrite) begin\n                if(r_enable==MODE_WRITE) begin\n                    prdata <= sram_mem[paddr];\n                end\n                else begin\n                    case (paddr)\n                        ADDR_OPERAND1:     prdata <= r_operand_1;\n                        ADDR_OPERAND2:     prdata <= r_operand_2;\n                        ADDR_ENABLE:       prdata <= r_enable;\n                        ADDR_WRITE_ADDR:   prdata <= r_write_address;\n                        ADDR_WRITE_DATA:   prdata <= r_write_data;\n                        ADDR_RESULT:       prdata <= sram_mem[ADDR_RESULT];  // Read the result from memory[0x5]\n                        default:           prdata <= 8'h00; // Invalid => PSLVERR, but can set prdata to 0\n                    endcase\n                end\n            end else if (!apb_valid) begin\n                // When no valid read, clear prdata (optional behavior)\n                prdata <= 8'h00;\n            end\n        end\n    end\n\n    //---------------------------------------------\n    // SRAM write Behavior\n    //---------------------------------------------\n    always @(posedge sram_valid or negedge presetn) begin\n        if (!presetn) begin\n            // Initialize memory location for result\n            sram_mem[ADDR_RESULT] <= 8'h00;\n        end else begin\n            // If r_Enable = WRITE (0x3), write r_write_data into memory[r_write_address]\n            if (r_enable == MODE_WRITE) begin\n                // Write data to memory at r_write_address\n                sram_mem[r_write_address] <= r_write_data;\n            end\n        end\n    end\n\n    //---------------------------------------------\n    // DSP Functional Behavior\n    //---------------------------------------------\n    always @(posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            // Initialize memory location for result\n            sram_mem[ADDR_RESULT] <= 8'h00;\n        end else begin\n            // If r_Enable = ADD (0x1), add contents of memory[r_operand_1] and memory[r_operand_2]\n            if (r_enable == MODE_ADD) begin\n                sram_mem[ADDR_RESULT] <= sram_mem[r_operand_1] + sram_mem[r_operand_2];\n            end\n            // If r_Enable = MULT (0x2), multiply contents of memory[r_operand_1] and memory[r_operand_2]\n            else if (r_enable == MODE_MULT) begin\n                sram_mem[ADDR_RESULT] <= sram_mem[r_operand_1] * sram_mem[r_operand_2];\n            end\n            // If r_Enable = DISABLED (0x0), no operation\n            // else do nothing\n        end\n    end\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.v /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\""}}}
{"id": "cvdp_copilot_apb_history_shift_register_0003", "categories": ["cid012", "medium"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `APBGlobalHistoryRegister`. The register updates synchronously on every gated rising edge of the `history_shift_valid` clock, shifting in predicted outcomes or restoring history on mispredictions. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameters, Inputs - Outputs and Functional behavior**\n\n---\n\n### 1. Interface\n\n#### 1.1 Clock & Reset Signals\n- **`pclk`** (input): APB clock input used for all synchronous operations.  \n- **`presetn`** (input, active-low): Asynchronous reset for system initialization.\n\n#### 1.2 APB Signals\n- **`paddr`** (input, 10 bits): Address bus for accessing internal CSR registers.  \n- **`pselx`** (input): APB select signal, indicates CSR/memory selection.  \n- **`penable`** (input): APB enable signal, marks transaction progression.  \n- **`pwrite`** (input): Write-enable signal. High for writes, low for reads.  \n- **`pwdata`** (input, 8 bits): Write data bus for sending data to CSR registers or memory.  \n- **`pready`** (output, reg): Ready signal, driven high to indicate the end of a transaction.  \n- **`prdata`** (output, reg, 8 bits): Read data bus for retrieving data from the module.  \n- **`pslverr`** (output, reg): Error signal, asserted on invalid addresses.\n\n#### 1.3 History Shift Interface\n- **`history_shift_valid`** (input): On the rising edge of this signal, the values in `control_register` and `train_history` are considered valid and will trigger an update of the predict_history register.\n#### 1.4 Clock Gating Enable\n- **`clk_gate_en`** (input): Signal in domain of `pclk`, which will be toggle only on negative edge of `pclk` to avoid glitches. Assertion of this signal will gate the `pclk` internally to minimize switching power.\n#### 1.4 Status & Interrupt Signals\n- **`history_full`** (output): Indicates if the 8-bit shift register is full (all bits set to 1).\n- **`history_empty`** (output): Indicates if the 8-bit shift register is empty (all bits cleared to 0).\n- **`error_flag`** (output): Indicates detected errors for invalid address.\n- **`interrupt_full`** (output): Asserted high to signal an interrupt when history_full is set.\n- **`interrupt_error`** (output): Asserted high to signal an interrupt when error_flag is set.\n---\n\n### 2. Register Descriptions\n\n1. **`control_register`**  \n   - **Address:** `0x0`  \n   - Bit fields (from LSB to MSB):\n     - `predict_valid` (control_register[0]): Indicates a valid branch prediction.  \n     - `predict_taken` (control_register[1]): Predicted direction of the branch (1 = taken, 0 = not taken).  \n     - `train_mispredicted` (control_register[2]): Indicates a branch misprediction occurred.  \n     - `train_taken` (control_register[3]): Actual direction of the mispredicted branch (1 = taken, 0 = not taken).  \n     - control_register[7:4]: Reserved and will be read 0.\n     - Read and write register.\n2. **`train_history`**  \n   - **Address:** `0x1`  \n   - 7 bits (`train_history[6:0]`) representing the recorded branch history prior to the mispredicted branch.\n   - train_history[7]: Reserved and will be read 0.\n   - Read and write register.\n\n3. **`predict_history`**  \n   - **Address:** `0x2`  \n   - 8-bit register representing the current state of the branch history shift register.\n   - Updated only on the rising edge of `history_shift_valid`.\n   - Can be read via the APB interface (using `prdata`).\n   - Can't be written via APB interface.\n\n---\n\n### 3. Functional Description\n\n#### 3.1 APB Protocol\n\n1. **Read Operations**  \n   - In the **READ_STATE**:  \n     - Drive `prdata` with the register value corresponding to `paddr`.  \n   - After the read completes, return to **IDLE**.\n\n2. **Write Operations**  \n   - In the **WRITE_STATE**:  \n     - Update the register selected by `paddr` with `pwdata`.  \n   - After the write completes, return to **IDLE**.\n\n3. **Reset Behavior**  \n   - When `presetn` is deasserted (active-low):  \n     - Reset `pready` and `pslverr` to 0.  \n     - Clear `prdata`.  \n     - Initialize `control_register` and `train_history` to 0.  \n     - Reset the shift register to zero (`predict_history = 8'b0`).\n\n#### 3.2 APB Interface Control\n\n1. **Basics**  \n   - Registers are accessed via the APB interface using `paddr`.  \n   - To read the computed prediction history, use address **0x2**; the data is returned on `prdata`.\n\n2. **Error Handling**  \n   - If `paddr` does not correspond to a valid register, assert `pslverr` (`1'b1`).\n\n3. **Wait States**  \n   - This design does not support wait states. All read/write operations complete in two clock cycles, and `pready` is always driven high (`1'b1`).\n\n---\n\n### 4. Prediction Update Logic\n\n1. **Normal Update**  \n   - If `predict_valid = 1` and no misprediction occurs (`train_mispredicted = 0`), the shift register updates by shifting in `predict_taken` from the least significant bit (LSB). The youngest branch direction is stored in `predict_history[0]`.\n\n2. **Misprediction Handling**  \n   - If `train_mispredicted = 1`, the shift register is updated synchronously with `history_shift_valid` to load the concatenation of `train_history` (7 bits) with `train_taken` (1 bit). This restores the history state before the mispredicted branch while incorporating the actual outcome of the mispredicted branch.\n\n\n3. **Priority**  \n   - If both `predict_valid` and `train_mispredicted` are asserted simultaneously, `train_mispredicted` takes precedence. The misprediction state overrides any prediction to ensure correct recovery of the pipeline state.\n\n4. **Output Behavior**  \n   - `predict_history` (the shift register) is updated only on the rising edge of `history_shift_valid`.\n   - `history_full` is asserted if predict_history contains all ones (8'hFF) else it will be deasserted.\n   - `history_empty` is asserted if predict_history contains all zeros (8'h00)  else it will be deasserted.\n   - `interrupt_full` is directly driven by history_full.\n   - `interrupt_error` is directly driven by error_flag.\n\nNote: Need not to worry about mixing synchronous (pclk) and asynchronous (history_shift_valid) control which can lead to metastability and timing issues. The history_shift_valid will trigger only in absense of pclk.\n\n## Test Bench Requirements\n\n### Stimulus Generation\n\n## 1. **Reset & Initialization Stimuli**\n\n- **Apply and Release Reset**  \n  1. Deassert the active-low reset (`presetn`) after a certain period while the clock toggles, ensuring all internal registers begin at default states.  \n  2. Keep clock transitions valid during reset deassertion.\n\n---\n\n## 2. **APB Interface Stimuli**\n\n### 2.1 **Valid Register Accesses**\n\n- **Write to Control Register**  \n  1. Present the address corresponding to `control_register` on `paddr`.  \n  2. Drive APB signals (`pselx`, `penable`, `pwrite`) for a valid write transaction.  \n  3. Provide varied data patterns on `pwdata` that affect bits `[3:0]` of `control_register`.\n\n- **Write to Train History Register**  \n  1. Present the address corresponding to `train_history` on `paddr`.  \n  2. Drive valid APB write signals.  \n  3. Send multiple data patterns that affect bits `[6:0]`.\n\n- **Read from Control/Register/Train History/Predict History**  \n  1. Present each valid address in turn (`0x0`, `0x1`, `0x2`).  \n  2. Drive APB signals for read transactions.  \n\n### 2.2 **Invalid Register Access**\n\n- **Access Addresses Beyond Valid Range**  \n  1. Set `paddr` to a value beyond the defined valid set (greater than `0x2`).  \n  2. Drive an APB read or write cycle.  \n\n---\n\n## 3. **Clock Gating Stimuli**\n\n- **Toggle `clk_gate_en`**  \n  1. Drive `clk_gate_en` active and inactive at different moments, including while issuing valid APB transactions.  \n  2. Ensure transitions occur on safe clock edges, demonstrating partial or no internal updates under gating.\n\n---\n\n## 4. **Shift Register Update Stimuli**\n\n### 4.1 **No Update Condition**\n\n- **Drive Control Bits for No-Action**  \n  1. Set `predict_valid` and `train_mispredicted` to inactive states.  \n  2. Pulse the `history_shift_valid` signal.\n\n### 4.2 **Normal Prediction Updates**\n\n- **Drive Valid Prediction**  \n  1. Set `predict_valid` active in `control_register`.  \n  2. Alternate the predicted direction bit (`predict_taken`) across multiple pulses of `history_shift_valid`.  \n  3. Repeat for various patterns of taken/not-taken.\n\n### 4.3 **Misprediction Handling**\n\n- **Restore from Train History**  \n  1. Write desired values into `train_history`.  \n  2. Set `train_mispredicted` active, along with a chosen `train_taken` bit.  \n  3. Drive `history_shift_valid` to force the restore path.\n\n- **Simultaneous Valid Prediction & Misprediction**  \n  1. Set both `predict_valid` and `train_mispredicted` active in the same cycle.  \n  2. Pulse `history_shift_valid`.\n\n---\n\n## 5. **Edge Conditions for the Shift Register**\n\n- **All-Zero to All-One Transitions**  \n  1. Repeatedly provide inputs (via normal prediction or misprediction) so that the shift register transitions from all zeros to all ones.  \n  2. Similarly, drive it back from all ones to all zeros with a series of stimuli.\n\n---\n\n## 6. **Error & Interrupt Stimuli**\n\n- **Trigger Invalid APB Transactions**  \n  1. Provide out-of-range addresses and drive write or read cycles.  \n\n- **Generate Interrupt Conditions**  \n  1. Fill the shift register to all ones (to drive any \u201cfull\u201d interrupt).  \n  2. Cause invalid address access (to drive error interrupt).\n\n---\n\n## 7. **Combined Complex Sequences**\n\n- **Integrated Flow**  \n  1. Begin with reset cycling.  \n  2. Perform valid reads and writes to internal registers.  \n  3. Toggle `clk_gate_en`.  \n  4. Issue valid predictions and a series of mispredictions.  \n  5. Drive the shift register from empty to full.  \n  6. Include at least one invalid address access mid-sequence.  \n\n## 8. **Additional Test Scenarios**  \n\n- **Reset During Operation** \u2013 Ensures the system can reinitialize correctly when reset is asserted dynamically, not just at startup.  \n\n- **Reserved Bit Handling** \u2013 Toggles unused register fields to confirm they remain stable and do not interfere with functionality.  \n\n- **Expanded Address Access** \u2013 Interacts with a broader address range to verify correct handling of both valid and invalid accesses.  \n\n- **Repeated Prediction History Reads** \u2013 Ensures the stored history updates correctly and all bits are exercised across different states.  \n\n- **Response Signal Validation** \u2013 Checks readiness and status transitions across reset, transactions, and different operating conditions.  ", "context": {}}, "output": {"response": "", "context": {"verif/tb_APBGlobalHistoryRegister.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 3-tb-stimulus\nTARGET = 98", "src/APBGlobalHistoryRegister.v": "module APBGlobalHistoryRegister (\n    // APB clock & reset\n    input  wire         pclk,\n    input  wire         presetn,  // Active-low reset\n\n    // APB signals\n    input  wire [9:0]   paddr,\n    input  wire         pselx,\n    input  wire         penable,\n    input  wire         pwrite,\n    input  wire [7:0]   pwdata,\n    input  wire         history_shift_valid,\n    input  wire         clk_gate_en,\n    output reg          pready,\n    output reg  [7:0]   prdata,\n    output reg          pslverr,\n    output reg          history_full,\n    output reg          history_empty,\n    output reg          error_flag,\n    output reg          interrupt_full,\n    output reg          interrupt_error\n);\n\n    //---------------------------------------------\n    // Parameter Definitions\n    //---------------------------------------------\n    // Register address map\n    localparam ADDR_CTRL_REG     = 10'h0;  // 0x0\n    localparam ADDR_TRAIN_HIS    = 10'h1;  // 0x1\n    localparam ADDR_PREDICT_HIS  = 10'h2;  // 0x2\n\n    localparam WIDTH             = 8;\n\n    //---------------------------------------------\n    // Internal Registers (CSR)\n    //---------------------------------------------\n    reg [WIDTH-1:0] control_register;\n    reg [WIDTH-1:0] train_history;\n    reg [WIDTH-1:0] predict_history;\n    //---------------------------------------------\n    // Internal wires\n    //---------------------------------------------\n    wire        predict_valid;\n    wire        predict_taken;\n    wire        train_mispredicted;\n    wire        train_taken;\n    //---------------------------------------------\n    // APB Read/Write Logic\n    //---------------------------------------------\n    wire apb_valid;\n    assign apb_valid = pselx & penable;    // Indicates active APB transaction\n    assign pclk_gated = !clk_gate_en&pclk;\n    // By spec, no wait states => PREADY always high after reset\n    always @(posedge pclk_gated or negedge presetn) begin\n      if (!presetn) begin\n        pready   <= 1'b0;\n        pslverr  <= 1'b0;\n      end else begin\n        // PREADY is always asserted (no wait states) once out of reset\n        pready   <= 1'b1;\n        // If transaction is valid, check address range\n        if (apb_valid) begin\n          // Check if address is valid (0x0 through 0x2 are used, everything else => PSLVERR)\n          if (paddr > ADDR_PREDICT_HIS) begin\n            pslverr <= 1'b1;\n          end\n          else begin\n            pslverr  <= 1'b0;\n          end\n        end\n      end\n    end\n\n    // Handle writes to CSR or memory\n    // Note: The design writes immediately in the cycle when penable=1.\n    always @(posedge pclk_gated or negedge presetn) begin\n      if (!presetn) begin\n        // Reset all registers\n        control_register  <= 0;\n        train_history     <= 0;\n      end else begin\n        if (apb_valid && pwrite) begin\n          case (paddr)\n              ADDR_CTRL_REG:    control_register[3:0]  <= pwdata[3:0];\n              ADDR_TRAIN_HIS:   train_history[6:0]     <= pwdata[6:0];\n              // If the address is outside defined range => PSLVERR is set, no write\n          endcase\n        end\n      end\n    end\n\n    // Handle read from CSR or memory\n    always @(posedge pclk_gated or negedge presetn) begin\n      if (!presetn) begin\n        prdata <= 0;\n      end \n      else begin\n        if (apb_valid) begin\n          case (paddr)\n            ADDR_CTRL_REG:    prdata <= {4'b0,control_register[3:0]};\n            ADDR_TRAIN_HIS:   prdata <= {1'b0,train_history[6:0]};\n            ADDR_PREDICT_HIS: prdata <= predict_history;\n            default:          prdata <= 0; // Invalid => PSLVERR, but can set prdata to 0\n          endcase\n        end\n        else begin\n          // When no valid read, clear prdata\n          prdata <= 0;\n        end\n      end\n    end\n\n\n    //---------------------------------------------\n    // GHSR Behavior\n    //---------------------------------------------\n\n    assign  predict_valid       = control_register[0];     // valid branch prediction\n    assign  predict_taken       = control_register[1];     // predicted direction (1=taken, 0=not taken)\n    assign  train_mispredicted  = control_register[2];     // branch misprediction occurred\n    assign  train_taken         = control_register[3];     // actual branch direction for mispredicted branch\n\n\n\n    always @(posedge history_shift_valid or negedge presetn) begin\n      if (!presetn) begin\n        // 1) active low Asynchronous reset\n        //    Clear the entire history register.\n        predict_history <= 0;\n      end\n      else begin\n        // 2) Misprediction Handling (highest priority)\n        //    If a misprediction is flagged, restore the old history from train_history\n        //    and incorporate the correct outcome (train_taken) as the newest bit.\n        if (train_mispredicted) begin\n          predict_history <= {train_history[WIDTH-2:0], train_taken};\n        end\n        // 3) Normal Prediction Update\n        //    If the prediction is valid and there is no misprediction,\n        //    shift in predict_taken at the LSB (bit[0] is the youngest branch).\n        else if (predict_valid) begin\n          // \"Shifting in from the LSB\" while keeping the newest branch in predict_history[0]\n          // is typically done by moving predict_history[31:1] up one bit\n          // and placing predict_taken in bit[0].\n          predict_history <= {predict_history[WIDTH-2:0], predict_taken};\n        end\n      end\n    end\n    \n    always @(*) begin\n      error_flag=pslverr;\n      interrupt_error=pslverr;\n      if(predict_history==8'hff) begin\n        history_full=1'b1;\n        interrupt_full=1'b1;\n        history_empty=1'b0;\n      end\n      else if (predict_history==8'h00) begin\n        history_full=1'b0;\n        interrupt_full=1'b0;\n        history_empty=1'b1;\n      end\n      else begin\n        history_full=1'b0;\n        interrupt_full=1'b0;\n        history_empty=1'b0;\n      end\n    end\n\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/APBGlobalHistoryRegister.v /code/verif/tb_APBGlobalHistoryRegister.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_asyc_reset_0001", "categories": ["cid014", "easy"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the `async_reset` module based on the design specifications provided? Below are the module details and design requirements for assertion development.\n\n---\n\n### Specifications\n\n#### **Module IO Specifications**\n- **Inputs**:\n  - `clk`: Positive edge-triggered clock signal.\n  - `reset`: Asynchronous reset signal (active-high). When asserted, it initializes the module.\n  \n- **Outputs**:\n  - `release_reset_o`: Indicates when the reset can be safely released (asserted when `cnt_q < 8`).\n  - `gate_clk_o`: Controls clock gating (asserted when `(cnt_q < 14)` and `(cnt_q != 0)`).\n  - `cnt_q`: a 5-bit counter that decrements to zero when reset is de-asserted.\n\n#### **Design Specifications**\nThe circuit takes an asynchronous reset as input, which is synchronized to the clock (`clk`) domain. The circuit drives two critical output signals:\n\n1. **`release_reset_o`**: This signal indicates when it is safe to deassert the reset for the rest of the circuit.\n2. **`gate_clk_o`**: This signal gates the clock to the rest of the circuit.\n\nThe design must meet the following specifications:\n- **Reset Deassertion Safety**:\n  - The reset should only be released if the asynchronous reset input (`reset`) has been de-asserted (driven low) for at least 5 cycles.\n- **Clock and Reset Tree Timing**:\n  - The clock tree time is 7 cycles, while the reset tree time is 8 cycles. These timing requirements must be accounted for in the logic driving `release_reset_o` and `gate_clk_o`.\n\n---\n\n### Assertion Requirements\n\n1. **Asynchronous Reset Behavior**:\n   - Validate that the counter (`cnt_q`) initializes to `5'h11` (decimal 17) when the asynchronous `reset` is asserted.\n\n2. **Reset Synchronization**:\n   - Ensure that the reset is held low for at least 5 cycles before deasserting the `release_reset_o` signal.\n\n3. **Counter Behavior**:\n   - Verify that the counter decrements correctly until it reaches 0.\n   - Ensure that the counter does not decrement below 0.\n\n4. **Output Signal Validation**:\n   - Validate the correct behavior of `release_reset_o` (asserted when reset deassertion conditions are satisfied).\n   - Verify the correct behavior of `gate_clk_o` (asserted when `(cnt_q < 14)` and `(cnt_q != 0)`).\n\n---\n\n### RTL Code (Without Assertions)\n\n```systemverilog\nmodule async_reset (\n  input   logic        clk,\n  input   logic        reset,\n\n  output  logic        release_reset_o,\n  output  logic        gate_clk_o,\n  output  logic [4:0]  cnt_q  \n);\n\n  // --------------------------------------------------------\n  // Asynchronous reset and counter logic\n  // --------------------------------------------------------\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n      cnt_q <= 5'h11; // Initialize to 17\n    end else begin\n      if (cnt_q > 0) begin\n        cnt_q <= cnt_q - 1;\n      end else begin\n        cnt_q <= cnt_q; // Hold at 0\n      end\n    end\n  end\n\n  // --------------------------------------------------------\n  // Output assignments\n  // --------------------------------------------------------\n  assign gate_clk_o      = (cnt_q < 5'hE) && (cnt_q != 0); // (cnt_q < 14) && (cnt_q != 0)\n  assign release_reset_o = (cnt_q < 5'h8);                  // (cnt_q < 8)\n\nendmodule\n```\n\n---\n\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.", "context": {}}, "output": {"response": "", "context": {"rtl/async_reset.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    environment:\n      - PYTHONPATH=/code/harness/lib\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/async_reset.sv\nTOPLEVEL        = async_reset\nMODULE          = test_async_reset\nPYTHONPATH      = /src\nHASH            = 1-rtl-assertions-addition", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\n\nasync def access_hit(dut, index_a, way_select_a):\n    await FallingEdge(dut.clock)\n    dut.access.value = 1\n    dut.hit.value = 1\n    dut.index.value = index_a\n    dut.way_select.value = way_select_a\n\n    await FallingEdge(dut.clock)\n    print(f\"[DEBUG] way_replace: {dut.way_replace.value}\")\n    dut.access.value = 0\n    dut.hit.value = 0\n\n\nasync def access_miss(dut, index_a, way_select_a):\n    await FallingEdge(dut.clock)\n    dut.access.value = 1\n    dut.hit.value = 0\n    dut.index.value = index_a\n    dut.way_select.value = way_select_a\n\n    await FallingEdge(dut.clock)\n    print(f\"[DEBUG] way_replace: 0b{dut.way_replace.value.integer:04b}\")\n    dut.access.value = 0\n    dut.hit.value = 0\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n", "src/test_async_reset.py": "# test_async_reset.py\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nfrom cocotb.result import TestFailure\n\n@cocotb.test()\nasync def test_async_reset(dut):\n    \"\"\"Testbench for async_reset module using cocotb.\"\"\"\n\n    # Initialize test counters\n    test_pass = 0\n    test_fail = 0\n    total_tests = 0\n\n    # Function to check conditions\n    async def check_condition(test_name, condition):\n        nonlocal test_pass, test_fail, total_tests\n        total_tests += 1\n        if condition:\n            dut._log.info(f\"[PASS] {test_name}\")\n            test_pass += 1\n        else:\n            dut._log.error(f\"[FAIL] {test_name}\")\n            test_fail += 1\n\n    # Start the clock at 100MHz (10ns period)\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Initialize signals\n    dut.reset.value = 1\n    # cnt_q and other outputs are not driven by the testbench\n\n    dut._log.info(\"Starting async_reset cocotb Testbench...\")\n\n    # Wait for 6 posedges clk to hold reset high\n    for i in range(6):\n        await RisingEdge(dut.clk)\n        dut._log.info(f\"Holding reset high. Cycle: {i+1}, Time: {cocotb.utils.get_sim_time(units='ns')}, cnt_q: {dut.cnt_q.value}\")\n\n    # Deassert reset on FallingEdge clk to ensure it's low before next posedge clk\n    await FallingEdge(dut.clk)\n    dut.reset.value = 0\n    dut._log.info(f\"Deasserting reset on falling edge at time {cocotb.utils.get_sim_time(units='ns')} ns.\")\n\n    # Wait for a small delay to allow reset to propagate\n    await Timer(5, units='ns')  # Increased delay for better synchronization\n\n    # Immediately check cnt_q ==0x11 after reset deassertion\n    await check_condition(\n        \"Test 1: cnt_q initialized to 0x11 after reset deassertion\",\n        dut.cnt_q.value.integer == 0x11\n    )\n\n    # Log current state\n    await RisingEdge(dut.clk)\n    dut._log.info(f\"After first posedge clk post-reset deassertion. Time: {cocotb.utils.get_sim_time(units='ns')} ns, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # Wait for next posedge clk to allow cnt_q to decrement\n    await RisingEdge(dut.clk)\n    dut._log.info(f\"After second posedge clk post-reset deassertion. Time: {cocotb.utils.get_sim_time(units='ns')} ns, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # Now, check that cnt_q has decremented to 0x10\n    await check_condition(\n        \"Test 2: cnt_q decremented to 0x10 after reset\",\n        dut.cnt_q.value.integer == 0x10\n    )\n\n    # Test Case 3: Check release_reset_o is inactive (cnt_q >=8)\n    await check_condition(\n        \"Test 3: release_reset_o is inactive (cnt_q >= 8)\",\n        dut.release_reset_o.value.integer == 0\n    )\n\n    # Wait until cnt_q reaches 0x07\n    while dut.cnt_q.value.integer > 0x7:\n        await RisingEdge(dut.clk)\n        dut._log.info(f\"Counting down. Time: {cocotb.utils.get_sim_time(units='ns')}, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # Test Case 4: Check release_reset_o is active (cnt_q <8)\n    await check_condition(\n        \"Test 4: release_reset_o is active (cnt_q < 8)\",\n        dut.release_reset_o.value.integer == 1\n    )\n\n    # Wait until cnt_q reaches 0\n    while dut.cnt_q.value.integer > 0x0:\n        await RisingEdge(dut.clk)\n        dut._log.info(f\"Counting down. Time: {cocotb.utils.get_sim_time(units='ns')}, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # Test Case 5: Check that cnt_q does not go below 0\n    await check_condition(\n        \"Test 5: cnt_q is 0 and does not decrement further\",\n        dut.cnt_q.value.integer == 0x0\n    )\n\n    # Check outputs when cnt_q is 0\n    await check_condition(\n        \"Test 6: gate_clk_o is inactive when cnt_q is 0\",\n        dut.gate_clk_o.value.integer == 0\n    )\n    await check_condition(\n        \"Test 6: release_reset_o is active when cnt_q is 0\",\n        dut.release_reset_o.value.integer == 1\n    )\n\n    # Test Case 7: Assert reset asynchronously\n    dut.reset.value = 1\n    dut._log.info(f\"Asserting reset asynchronously at time {cocotb.utils.get_sim_time(units='ns')} ns.\")\n\n    # Wait for 5 ns to allow reset to propagate\n    await Timer(5, units='ns')\n\n    # Deassert reset on FallingEdge clk to ensure it's low before next posedge clk\n    await FallingEdge(dut.clk)\n    dut.reset.value = 0\n    dut._log.info(f\"Deasserting reset asynchronously on falling edge at time {cocotb.utils.get_sim_time(units='ns')} ns.\")\n\n    # Wait for a small delay to allow reset to propagate\n    await Timer(5, units='ns')  # Increased delay for better synchronization\n\n    # Immediately check cnt_q ==0x11 after reset deassertion\n    await check_condition(\n        \"Test 7: cnt_q initialized to 0x11 after reset deassertion\",\n        dut.cnt_q.value.integer == 0x11\n    )\n\n    # Log current state\n    await RisingEdge(dut.clk)\n    dut._log.info(f\"After first posedge clk post-reset deassertion. Time: {cocotb.utils.get_sim_time(units='ns')} ns, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # Wait for next posedge clk to allow cnt_q to decrement\n    await RisingEdge(dut.clk)\n    dut._log.info(f\"After second posedge clk post-reset deassertion. Time: {cocotb.utils.get_sim_time(units='ns')} ns, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # Now, check that cnt_q has decremented to 0x10\n    await check_condition(\n        \"Test 8: cnt_q decremented to 0x10 after reset\",\n        dut.cnt_q.value.integer == 0x10\n    )\n\n    # Test Case 9: Hold reset for exactly 6 cycles (to satisfy min_reset_duration)\n    dut.reset.value = 1\n    dut._log.info(f\"Asserting reset for exactly 6 cycles at time {cocotb.utils.get_sim_time(units='ns')} ns.\")\n\n    for i in range(6):\n        await RisingEdge(dut.clk)\n        dut._log.info(f\"Holding reset high. Cycle: {i+1}, Time: {cocotb.utils.get_sim_time(units='ns')} ns, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # Deassert reset on FallingEdge clk to satisfy min_reset_duration\n    await FallingEdge(dut.clk)\n    dut.reset.value = 0\n    dut._log.info(f\"Deasserting reset after holding for 6 cycles on falling edge at posedge clk {cocotb.utils.get_sim_time(units='ns')} ns.\")\n\n    # Wait for a small delay to allow reset to propagate\n    await Timer(5, units='ns')  # Increased delay for better synchronization\n\n    # Immediately check cnt_q ==0x11 after reset deassertion\n    await check_condition(\n        \"Test 9: cnt_q reset to 0x11 after 6-cycle reset\",\n        dut.cnt_q.value.integer == 0x11\n    )\n\n    # Wait for next posedge clk\n    await RisingEdge(dut.clk)\n    dut._log.info(f\"After posedge clk post-6-cycle reset deassertion. Time: {cocotb.utils.get_sim_time(units='ns')} ns, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # ---------------------------\n    # Final Results\n    # ---------------------------\n    dut._log.info(\"==================================\")\n    dut._log.info(\"Cocotb Testbench Completed\")\n    dut._log.info(f\"Total Tests: {total_tests}\")\n    dut._log.info(f\"Passed: {test_pass}\")\n    dut._log.info(f\"Failed: {test_fail}\")\n    dut._log.info(\"==================================\")\n\n    # Use assert statements to reflect test results\n    assert test_fail == 0, f\"Some tests failed: {test_fail} failed out of {total_tests}\"\n", "src/test_runner.py": "import cocotb\nimport os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nfrom cocotb.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef call_runner():\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n    # Run the simulation\n    call_runner()"}}}
{"id": "cvdp_copilot_asyc_reset_0004", "categories": ["cid012", "easy"], "input": {"prompt": "Create a **testbench** to apply **stimulus** to the `async_reset` module. This module implements an asynchronous reset mechanism along with a countdown counter. The counter initializes to `5'h1F` upon reset and decrements on each clock cycle until reaching zero. The module also provides gated clock and reset release signals based on specific counter thresholds.\n\n---\n\n### **Inputs:**\n\n- `clk`: **Clock input** for driving the module\u2019s sequential logic.\n- `reset`: **Active-high, asynchronous reset signal**. When asserted, the counter resets to `5'h1F`.\n\n### **Outputs:**\n\n- `cnt_q [4:0]`: **5-bit counter output**, representing the current counter value.\n- `gate_clk_o`: **Gated clock output**, enabled when the counter is greater than zero and less than `5'hE`.\n- `release_reset_o`: **Reset release output**, active when the counter is less than `5'h8`.\n\n---\n\n### **Instantiation**\n\nThe testbench must instantiate a single instance of the `async_reset` module:\n\n- **Asynchronous Reset Module (`dut`)**: Instantiated with its default configuration to verify correct counter behavior and reset handling.\n\n---\n\n### **Testbench Requirements**\n\nThe testbench must apply a **wide range of test patterns** to verify the module\u2019s response to various reset and counter conditions:\n\n1. **Clock Generation:**\n   - `clk` must toggle every **5 time units**, ensuring a **10 ns clock period**.\n\n2. **Reset Handling:**\n   - `reset` must be **asserted for multiple clock cycles** before being de-asserted.\n   - The module must correctly initialize `cnt_q` to `5'h1F` when `reset` is de-asserted.\n\n3. **Stimulus Generation Strategy:**\n   - The testbench **must not verify outputs** (only generate inputs).\n   - The following test sequences must be executed:\n     - **Counter decrement sequence**: Verify decrement from `5'h1F` to `0`.\n     - **Mid-count reset**: Apply reset when `cnt_q = 5'hF` and ensure re-initialization.\n     - **Gate clock boundary**: Ensure `gate_clk_o` transitions correctly when `cnt_q` moves from `5'hE` to `5'hD`.\n     - **Release reset boundary**: Validate `release_reset_o` activation when `cnt_q` moves below `5'h8`.\n     - **Counter stability at zero**: Ensure `cnt_q` holds at `0` after reaching the minimum value.\n     - **Reset during critical transitions**: Apply reset at `cnt_q = 5'hE` and `cnt_q = 5'h8`.\n\n4. **Handling Continuous and Edge Cases:**\n   - The testbench must ensure a **full countdown cycle** occurs correctly.\n   - **Edge case transitions** must be included to verify correct signal toggling.\n\n5. **Waveform Generation:**\n   - The testbench must generate a `.vcd` waveform file to allow waveform analysis.\n\n---\n\n### **Coverage and Compliance**\n\n- The testbench must ensure **high coverage** across all counter states and transitions.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n\n---\n\n### **Test Plan Overview**\n\nThe testbench must ensure **comprehensive RTL coverage** by applying:\n\n- **Full counter sequence testing** (from `5'h1F` to `0`).\n- **Timing-based reset checks** (handling valid reset during key transitions).\n- **Mid-count resets** to ensure proper re-initialization.\n- **Boundary conditions** for `gate_clk_o` and `release_reset_o`.\n- **Reset handling** to verify asynchronous behavior and re-initialization integrity.\n\nThis testbench will provide a **comprehensive input stimulus environment** for `async_reset`, ensuring correct operation under various test conditions.\n\n---\n\n### **Note:**\n- The testbench **must only generate stimulus** without verifying outputs.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n- **Ensure the maximum possible input coverage** without adding assertions or comparisons.\n\nCan you implement a **SystemVerilog testbench** with the above stimulus requirements?\n", "context": {}}, "output": {"response": "", "context": {"verif/async_reset_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 4-tb-for-async-reset-rtl\nTARGET = 100", "src/async_reset.sv": "module async_reset (\n  input   logic        clk,\n  input   logic        reset,\n\n  output  logic        release_reset_o,\n  output  logic        gate_clk_o,\n  output  logic [4:0]  cnt_q\n);\n\n// --------------------------------------------------------\n// Asynchronous reset and counter logic\n// --------------------------------------------------------\nalways_ff @(posedge clk or posedge reset) begin\n  if (reset) begin\n    cnt_q <= 5'h1F; // Initialize to 31\n  end else begin\n    if (cnt_q > 0) begin\n      cnt_q <= cnt_q - 1;\n    end else begin\n      cnt_q <= cnt_q; // Hold at 0\n    end\n  end\nend\n\n// --------------------------------------------------------\n// Output assignments\n// --------------------------------------------------------\nassign gate_clk_o      = (cnt_q < 5'hE) && (cnt_q != 0); // (cnt_q < 14) && (cnt_q != 0)\nassign release_reset_o = (cnt_q < 5'h8);                  // (cnt_q < 8)\n\nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_axi_dsp_op_0018", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the given SystemVerilog testbench to include checkers to validate the output of **axi_dsp_op** module, that calculates the multiply accumulate operation inside DSP unit and is communicating through AXI lite interface. In this design, the control unit is triggered externally and is responsible to start and stop the DSP unit. The dual port RAM stores the operands (A,B,C and O) and gives read/write access to DSP unit and AXI lite channels. The **stimulus is provided**, and the modified testbench should add the logic to verify that the **DUT (Design Under Test)** correctly computes the output according to the expected behavior.\n\n---\n\n## **1. Design Details**\n\n### **1.1 Parameterization**\n\n| Parameter | Description                                           | Default Value | Sizing         |\n|-----------|-------------------------------------------------------|---------------|----------------|\n| `ADDR_W`  | Address width of AXI read and write channels (global) | 2 bits        | Multiples of 2 |\n| `DATA_W`  | Data width of AXI read and write channels (local)     | 32 bits       | User Dependent |\n| `STRB_W`  | Strobe width of AXI write channel (local)             | 4 bits        | DATA_W/8       |\n| `OPR_A_W` | Operand A width for DSP MAC operation (local)         | 32 bits       | Same as DATA_W |\n| `OPR_B_W` | Operand B width for DSP MAC operation (local)         | 32 bits       | Same as DATA_W |\n| `OPR_C_W` | Operand C width for DSP MAC operation (local)         | 32 bits       | Same as DATA_W |\n| `OPR_O_W` | Operand O width for DSP MAC operation (local)         | 32 bits       | Same as DATA_W |\n\n---\n\n### **1.2 Functional Behavior**\n\n#### **AXI Handshakes**\n- **Read Handshakes**:  \n  - Read address and data valid/ready handshakes occur for **valid memory addresses**.\n  - **Out-of-range addresses** result in a read response (`SLVERR`).\n\n- **Write Handshakes**:  \n  - Write address and data valid/ready handshakes occur for **valid memory addresses (first four word addresses)**.\n  - **Out-of-range or invalid addresses** result in a write response (`SLVERR`).\n\n#### **Reading and Writing to Dual-Port RAM**\n- **Operands (`A, B, C`)** are written to RAM via AXI and fetched by the DSP unit.\n- **Operand `O` (output)** is written by the DSP unit and read by AXI.\n\n#### **Strobe Behavior**\n- Each bit of write strobe is a byte enable for data. \n- In case of inactive strobe bit, the byte data will retain its previous state and is not made zero.\n\n#### **Control Unit Behavior**\n- **`trigger_ctrl`**: Starts the control unit.\n- **`start`**: Starts the DSP unit.\n- **`stop`**: Stops the DSP unit and clears the result register.\n\n#### **DSP Unit Behavior**\n- Performs **multiplication**, **accumulation**, and **truncation** of registered operands and stores the result.\n\n#### **Reset Behavior**\n- **`ARESET_n` (Active-low reset)**: Clears registers/memory and sets `ready's` of channels from the slave to high.\n\n### **1.3 Timing Behavior**\n   - Fetching the operands from DPRAM to DSP take 3 consecutive read cycles. \n   - The result is registered \n   - The RDATA is sequential which takes a cycle\n\nThe overall result read latency is **5 cycles**\n\n---\n\n## **2. Interface Details**\n\n### **2.1 Inputs**\n| Signal Name    | Description                                 |\n|----------------|---------------------------------------------|\n| `ACLK`         | Global clock signal (rising-edge triggered) |\n| `ARESET_n`     | Active-low asynchronous reset               |\n| `trigger_ctrl` | External signal to start the control unit   |\n| `AWADDR`       | Write address                               |\n| `AWVALID`      | Write address valid                         |\n| `WDATA`        | Write data                                  |\n| `WSTRB`        | Write strobe (byte enables)                 |\n| `WVALID`       | Write data valid                            |\n| `BREADY`       | Write response ready                        |\n| `ARADDR`       | Read address                                |\n| `ARVALID`      | Read address valid                          |\n| `RREADY`       | Read data ready                             |\n\n### **2.2 Outputs**\n| Signal Name | Description                             |\n|-------------|-----------------------------------------|\n| `AWREADY`   | Write address ready                     |\n| `WREADY`    | Write data ready                        |\n| `BRESP`     | Write response (`OKAY = 0, SLVERR = 2`) |\n| `BVALID`    | Write response valid                    |\n| `ARREADY`   | Read address ready                      |\n| `RDATA`     | Read data                               |\n| `RRESP`     | Read response (`OKAY = 0, SLVERR = 2`)  |\n| `RVALID`    | Read data valid                         |\n\n---\n\n## **3. Testbench Requirements**\n\n### **3.1 Instantiation**\n- `axi_dsp_op` is already instantiated as `u_axi_dsp_op` with all necessary **input and output connections**.\n\n### **3.2. Clock and Reset Generation**\n- The clock is already generated with time period of **10ns**.\n- The reset is active-low which is asserted after **50ns**.\n\n### **3.3. Testbench Components**\n\n#### **Local Parameters**\n- `RES_RD_LATENCY`: The latency of valid read data from trigger.\n- All other design parameters with default values declared as localparameters\n\n#### **Internal Signals**\n- `clk`: Clock signal.  \n- `arst_n`: Asynchronous reset.  \n- All the module interface signals in lower case\n- `out_data`: Obtained data from module\n- `exp_result`: Expected result\n- `A_rand`: A signal to hold random data generated for operand a that can be passed to DUT and reference/ expected data function.\n- `B_rand`: A signal to hold random data generated for operand b that can be passed to DUT and reference/ expected data function.\n- `C_rand`: A signal to hold random data generated for operand c that can be passed to DUT and reference/ expected data function.\n\n### **3.4. Design Under Test (DUT)**\n- The **stimulus is provided**, which applies test patterns to the DUT.  \n- The testbench should focus on enhancing this by **writing a checker** that verifies correctness.\n\n---\n\n## **4. Test Procedure**\n\nThe testbench must validate the **following test cases**:\n#### **1. Writing through AXI**\n- Make sure to check the `bresp` if it is `OKAY` or `SLVERR` . \n#### **2. Reading through AXI**\n- Make sure to check the `rresp` if it is `OKAY` or `SLVERR` and return the data read from design for comparison with expected data\n#### **3. Edge Cases**\n- Check the expected results of **0s** and **maximum signal width values** for address, data, and strobe.\n- Check the **invalid write addresses** (memory addresses > 3 are **read-only**).\n\n\n### **4.1 Checker Functionality**\n- Implement a **checker logic** that:\n  - Computes the **expected output** using a reference model based on the **Multiply Accumulate Operation** and the result truncated to use only 32bits LSB of result. The computation should be done in a function and it should take operands and strobe as arguments. The functions should return the expected result. Note that the design retains the previous state of data in case of inactive strobe bit so the memory address where the masked data is to be written to should be read with cross referencing from design.\n  - Compares the **DUT output (`out_data`)** against the expected result (`exp_result`).\n  - Reports errors using `$error` when mismatches occur and display the failing result with operands otherwise only display the passing result.\n\n### **4.2 Simulation Control**\n- Use `$display` statements to log test case execution.\n- Print **\"All tests passed.\"** if all cases pass; otherwise, report errors and stop the simulation.\n\n---\n\n## **Expected Deliverables**\n- Modified testbench with **SystemVerilog checker** that verifies the `axi_dsp_op` module's output against expected results.", "context": {"verif/tb_axi_dsp_op.sv": "module tb_axi_dsp_op;\n\n    // ----------------------------------------\n    // - Local Parameters\n    // ----------------------------------------\n    localparam ADDR_W         = 2;\n    localparam DATA_W         = 32;\n    localparam STRB_W         = 4;\n    localparam OPR_A_W        = 32;\n    localparam OPR_B_W        = 32;\n    localparam OPR_C_W        = 32;\n    localparam OPR_O_W        = 32;\n    localparam RES_RD_LATENCY = 5;\n\n    // ----------------------------------------\n    // - Interface Signals\n    // ----------------------------------------\n    logic                 clk;\n    logic                 arst_n;\n    \n    // AXI-Lite Write Address Channel\n    logic [ADDR_W-1:0]    awaddr;\n    logic                 awvalid;\n    logic                 awready;\n\n    // AXI-Lite Write Data Channel\n    logic [DATA_W-1:0]    wdata;\n    logic [STRB_W-1:0]    wstrb;\n    logic                 wvalid;\n    logic                 wready;\n\n    // AXI-Lite Write Response Channel\n    logic [1:0]           bresp;\n    logic                 bvalid;\n    logic                 bready;\n\n    // AXI-Lite Read Address Channel\n    logic [ADDR_W-1:0]    araddr;\n    logic                 arvalid;\n    logic                 arready;\n\n    // AXI-Lite Read Data Channel\n    logic [DATA_W-1:0]    rdata;\n    logic [1:0]           rresp;\n    logic                 rvalid;\n    logic                 rready;\n\n    // External Trigger\n    logic                 trigger_ctrl;\n\n    // ----------------------------------------\n    // - DUT Instantiation\n    // ----------------------------------------\n    axi_dsp_op #(\n        .ADDR_W   (ADDR_W)\n    ) u_axi_dsp_op (\n        .ACLK       (clk),\n        .ARESET_n   (arst_n),\n        .AWADDR     (awaddr),\n        .AWVALID    (awvalid),\n        .AWREADY    (awready),\n        .WDATA      (wdata),\n        .WSTRB      (wstrb),\n        .WVALID     (wvalid),\n        .WREADY     (wready),\n        .BRESP      (bresp),\n        .BVALID     (bvalid),\n        .BREADY     (bready),\n        .ARADDR     (araddr),\n        .ARVALID    (arvalid),\n        .ARREADY    (arready),\n        .RDATA      (rdata),\n        .RRESP      (rresp),\n        .RVALID     (rvalid),\n        .RREADY     (rready),\n        .trigger_ctrl (trigger_ctrl)\n    );\n\n    // ----------------------------------------\n    // - Clock & Reset\n    // ----------------------------------------\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;  // 10 ns period\n    end\n\n    // Active-low reset sequence\n    initial begin\n        arst_n = 0;\n        #50; // Wait 50 ns\n        arst_n = 1;\n    end\n\n    // ----------------------------------------\n    // - AXI Write Task\n    // ----------------------------------------\n    task axi_write(\n        input logic [ADDR_W-1:0] write_addr,\n        input logic [DATA_W-1:0] write_data,\n        input logic [STRB_W-1:0] write_strb\n    );\n        // Address phase\n        @(posedge clk);\n        awvalid <= 1'b1;\n        awaddr  <= write_addr;\n\n        // Data phase\n        wvalid  <= 1'b1;\n        wdata   <= write_data;\n        wstrb   <= write_strb;\n        \n        // Deassert signals\n        @(posedge clk);\n        awvalid <= 1'b0;\n        wvalid  <= 1'b0;\n        awaddr  <= '0;\n        wdata   <= '0;\n        wstrb   <= '0;\n        \n        // random delay before asserting BREADY\n        repeat($urandom_range(1,10)) @(posedge clk);\n        bready <= 1'b1;\n\n        // Wait for valid BVALID\n        while (bvalid !== 1'b1) begin\n            @(posedge clk);\n        end\n        $display(\"[WRITE] Address=%0d Data=0x%h\", write_addr, write_data);\n        // Deassert BREADY after handshake\n        @(posedge clk);\n        bready <= 1'b0;\n    endtask\n\n    // ----------------------------------------\n    // - AXI Read Task\n    // ----------------------------------------\n    task axi_read(\n        input  logic [ADDR_W-1:0] read_addr\n    );\n        // Address phase\n        @(posedge clk);\n        arvalid <= 1'b1;\n        araddr  <= read_addr;\n\n        // Deassert ARVALID\n        @(posedge clk);\n        arvalid <= 1'b0;\n        araddr  <= '0;\n\n        while (rvalid !== 1'b1) begin\n            @(posedge clk);\n        end\n        // Wait for result read latency\n        repeat(RES_RD_LATENCY) @(posedge clk);\n        // Random delay before asserting RREADY\n        repeat($urandom_range(1,10)) @(posedge clk);\n        rready <= 1'b1;\n\n        // Display Rd Addr and Data\n        $display(\"[READ ] Address=%0d Data=0x%h\", read_addr, rdata);\n\n        // Deassert RREADY\n        @(posedge clk);\n        rready <= 1'b0;\n    endtask\n\n    // ----------------------------------------\n    // - Test Sequences\n    // ----------------------------------------\n    initial begin\n        // Wait until reset de-asserts\n        @(posedge arst_n);\n        @(posedge clk);\n\n        // 1) Simple writes & read-back\n        $display(\"\\n--- Test 1: Simple writes and read-back\");\n        axi_write(0, 32'h0000_0005, 4'hF);\n        axi_write(1, 32'h0000_000A, 4'hF);\n        axi_write(2, 32'h0000_000F, 4'hF);\n\n        // Trigger Control\n        $display(\"[CTRL ] Triggering Control Unit\");\n        trigger_ctrl <= 1'b1;\n        @(posedge clk);\n        trigger_ctrl <= 1'b0;\n\n        // Read result\n        axi_read(3);\n\n        // 2) Random tests (multiple transactions)\n        $display(\"\\n--- Test 2: Multiple random transactions\");\n        for (int i = 0; i < 5; i++) begin\n\n            // Write transactions\n            axi_write(0, $urandom, $urandom_range(0,15));\n            axi_write(1, $urandom, $urandom_range(0,15));\n            axi_write(2, $urandom, $urandom_range(0,15));\n\n            // Trigger\n            trigger_ctrl <= 1'b1;\n            @(posedge clk);\n            trigger_ctrl <= 1'b0;\n            axi_read(3);\n        end\n\n        // 3) Edge cases: 0, max values\n        $display(\"\\n--- Test 3: Edge cases (0 and max 32'hFFFF_FFFF)\");\n        axi_write(0, 32'h0000_0000, 4'hF);\n        axi_write(1, 32'hFFFF_FFFF, 4'hF);\n        axi_write(2, 32'h0000_0000, 4'hF);\n        trigger_ctrl <= 1'b1;\n        @(posedge clk);\n        trigger_ctrl <= 1'b0;\n        axi_read(3);\n\n        // Edge case 2\n        axi_write(0, 32'hFFFF_FFFF, 4'hF);\n        axi_write(1, 32'hFFFF_FFFF, 4'hF);\n        axi_write(2, 32'hFFFF_FFFF, 4'hF);\n        trigger_ctrl <= 1'b1;\n        @(posedge clk);\n        trigger_ctrl <= 1'b0;\n        axi_read(3);\n\n        // 4) Invalid address writes\n        $display(\"\\n--- Test 4: Invalid address writes\");\n        // As address space is at default = 2b, so no invalid addresses \n        axi_write(2'b11, 32'h12345678, 4'hF); \n        axi_write(2'b10, 32'hA5A5A5A5, 4'hF);\n        axi_read(3);\n\n        // 5) Consecutive reads/writes\n        $display(\"\\n--- Test 5: Consecutive read/write to the same addresses\");\n        for (int j = 0; j < 3; j++) begin\n            axi_write(0, 32'h0000_000A, 4'hF);\n        end\n        // Read back from the same address\n        for (int k = 0; k < 3; k++) begin\n            axi_read(0);\n        end\n\n        $display(\"\\nAll tests completed.\");\n        arst_n = 0;\n        $finish;\n    end\n\n    // ----------------------------------------\n    // - Dump\n    // ----------------------------------------\n    initial begin\n        $dumpfile(\"tb_axi_dsp_op.vcd\");\n        $dumpvars(0, tb_axi_dsp_op);\n    end\n\n    // Initialize signals\n    initial begin\n        awvalid     = 0;\n        awaddr      = '0;\n        wvalid      = 0;\n        wdata       = '0;\n        wstrb       = '0;\n        bready      = 0;\n        arvalid     = 0;\n        araddr      = '0;\n        rready      = 0;\n        trigger_ctrl= 0;\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_axi_dsp_op.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 18-tb-checker-for-axi-dsp-op\nNUM_BUGS        = 3", "src/axi_dsp_op.sv": "package axi_dsp_op_pkg;\n\n    localparam ADDR_W = 2;\n    localparam DATA_W = 32;\n    localparam STRB_W = 4;\n    localparam OPR_A_W = 32;\n    localparam OPR_B_W = 32;\n    localparam OPR_C_W = 32;\n    localparam OPR_O_W = 32;\n\n    typedef enum logic [1:0] { \n        IDLE = 2'b00,\n        ON   = 2'b01,\n        BUSY = 2'b10,\n        DONE = 2'b11\n    } st_state_t;\n\n    typedef enum logic [1:0] { \n        RD_IDLE=2'b00,\n        RD_ADDR=2'b01,\n        RD_DATA=2'b10\n    } rd_state_t;\n\nendpackage : axi_dsp_op_pkg\n\nmodule axi_dsp_op\n    import axi_dsp_op_pkg::*;\n#(\n    parameter ADDR_W = axi_dsp_op_pkg::ADDR_W\n) (\n    input logic ACLK,\n    input logic ARESET_n,\n    \n    // AXI Interface Signals\n    input  logic [ADDR_W-1:0] AWADDR,\n    input  logic AWVALID,\n    output logic AWREADY,\n    \n    input  logic [DATA_W-1:0] WDATA,\n    input  logic [STRB_W-1:0] WSTRB,\n    input  logic WVALID,\n    output logic WREADY,\n    \n    output logic [1:0] BRESP,\n    output logic BVALID,\n    input  logic BREADY,\n    \n    input  logic [ADDR_W-1:0] ARADDR,\n    input  logic ARVALID,\n    output logic ARREADY,\n    \n    output logic [DATA_W-1:0] RDATA,\n    output logic [1:0] RRESP,\n    output logic RVALID,\n    input  logic RREADY,\n\n    // To Trigger Control Unit\n    input  logic trigger_ctrl\n);\n\n    //--- Out of range Address Check Function ---\n    function automatic logic is_out_of_range_addr(logic [ADDR_W-1:0] addr);\n        return (addr >= (2**ADDR_W));\n    endfunction\n\n    // We can write operands upto 'd3 [opr_a = 0, opr_b = 1, opr_c = 2, opr_o = 3]\n    function automatic logic is_invalid_wr(logic [ADDR_W-1:0] addr);\n        return (addr > 'd3);\n    endfunction\n\n    // Internal Signals\n    logic start;\n    logic stop;\n    st_state_t status;\n    logic [DATA_W-1:0] wdata_with_strb, wdata;\n    logic we_dsp, we_axi, busy_dsp, w_val;\n    logic [ADDR_W-1:0] addr_dsp, addr_axi;\n    logic [DATA_W-1:0] din_dsp, din_axi;\n    logic [DATA_W-1:0] dout_dsp, dout_axi;\n    logic [STRB_W-1:0] wstrb;\n    rd_state_t         rd_state;\n    logic              aw_done;\n\n    // Control and Status Unit\n    control_status_unit #(\n        .ADDR_W (ADDR_W)\n    ) ctrl_unit (\n        .clk         (ACLK),\n        .rst_n       (ARESET_n),\n        .trigger_ctrl(trigger_ctrl),\n        .start       (start),\n        .status      (status),\n        .stop        (stop),\n        .addr_dpram  (addr_dsp),\n        .busy        (busy_dsp)\n    );\n    \n    // DSP Operation Block\n    dsp_operation_unit #(\n        .ADDR_W (ADDR_W)\n    ) dsp_unit (\n        .clk        (ACLK),\n        .rst_n      (ARESET_n),\n        .start      (start),\n        .stop       (stop),\n        .status     (status),\n        .addr_dpram (addr_dsp),\n        .opr_dpram  (dout_dsp),\n        .busy       (busy_dsp),\n        .opr_o      (din_dsp),\n        .opr_o_val  (we_dsp)\n    );\n    \n    // Dual Port RAM\n    dual_port_ram #(\n        .ADDR_W (ADDR_W)\n    ) dpram (\n        .clk  (ACLK),\n        .rst_n(ARESET_n),\n        .we_dsp(we_dsp),\n        .we_axi(we_axi),\n        .addr_dsp(addr_dsp),\n        .addr_axi(addr_axi),\n        .din_dsp(din_dsp),\n        .din_axi(din_axi),\n        .dout_dsp(dout_dsp),\n        .dout_axi(dout_axi)\n    );\n\n    // AXI <---> DPRAM\n    // AWREADY and WREADY control\n    always_ff @(posedge ACLK or negedge ARESET_n) begin\n        if (!ARESET_n) begin\n            AWREADY <= 1'b1;\n            WREADY <= 1'b1;\n        end\n        else begin\n            if (AWVALID && AWREADY) begin\n                AWREADY <= 1'b0;\n            end\n\n            if (WVALID && WREADY) begin\n                WREADY <= 1'b0;\n            end\n            else if (BVALID && BREADY) begin\n                WREADY <= 1'b1;\n                AWREADY <= 1'b1;\n            end\n        end\n    end\n    // WSTRB masking combinational logic\n    always_comb begin\n        wdata_with_strb = dout_axi; // Retain unmasked bytes from memory\n        for (int i = 0; i < STRB_W; i++) begin\n            if (wstrb[i]) begin\n                wdata_with_strb[(i*8) +: 8] = wdata[(i*8) +: 8];\n            end\n        end\n    end\n\n    always_ff @(posedge ACLK or negedge ARESET_n) begin\n        if (!ARESET_n) begin\n            rd_state   <= RD_IDLE;\n            addr_axi   <= 'd0;\n            ARREADY    <= 1'b1;\n            RVALID     <= 'd0;\n            RDATA      <= 'd0;\n            RRESP      <= 2'b00;\n            BRESP      <= 2'b00;\n            BVALID     <= 1'b0;\n            din_axi    <= 'd0;\n            we_axi     <= 1'b0;\n            aw_done    <= 0;\n            wdata      <= 'd0;\n            wstrb      <= 'd0;\n            w_val      <= 0;\n        end \n        else begin           \n            // Handle write address\n            if (AWVALID && AWREADY) begin\n                if (is_out_of_range_addr(AWADDR) || is_invalid_wr(AWADDR)) begin\n                    BRESP <= 2'b10; // SLVERR\n                    BVALID <= 1'b1;\n                    aw_done <= 0;\n                end\n                else begin\n                    addr_axi <= AWADDR;\n                    `ifndef BUG_1\n                        BRESP <= 2'b00;\n                    `else\n                        BRESP <= 2'b10;\n                    `endif\n                    aw_done <= 1;\n                end\n            end\n            else\n            begin\n                aw_done <= 0;\n            end\n\n           // Handle write data\n            if (WVALID && WREADY) begin\n                wdata   <= WDATA;\n                wstrb   <= WSTRB;\n                w_val   <= 1;\n            end\n\n            if (aw_done & w_val) begin\n                din_axi <= wdata_with_strb;\n                we_axi <= 1;\n                BVALID <= 1'b1;\n            end\n            else begin\n                we_axi <= 0;\n            end\n\n            // Clear BVALID when handshake completes\n            if (BVALID && BREADY) begin\n                BVALID <= 1'b0;\n            end\n\n            // Read Address/Data Handling\n            case (rd_state)\n                RD_IDLE: begin\n                    if (ARVALID && ARREADY) begin\n                        if (is_out_of_range_addr(ARADDR)) begin\n                            RRESP <= 2'b10; // SLVERR\n                            RVALID <= 1'b1;\n                        end\n                        else begin\n                            addr_axi <= ARADDR;\n                            rd_state <= RD_DATA;\n                            ARREADY <= 1'b0;\n                        end\n                    end\n                end\n\n                RD_DATA: begin\n                    RVALID <= 1'b1;\n                    RDATA <= dout_axi;\n                    `ifndef BUG_0\n                        RRESP   <= 2'b00;\n                    `else\n                        RRESP   <= 2'b10;\n                    `endif\n\n                    if (RVALID && RREADY) begin\n                        RVALID <= 1'b0;\n                        ARREADY <= 1'b1;\n                        rd_state <= RD_IDLE;\n                    end\n                end\n                default: rd_state <= RD_IDLE;\n            endcase\n        end\n    end\n\n    \nendmodule : axi_dsp_op\n\n// Control and Status Unit\nmodule control_status_unit\n    import axi_dsp_op_pkg::*;\n#(\n    parameter ADDR_W = axi_dsp_op_pkg::ADDR_W\n)\n(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic trigger_ctrl,\n    output logic start,\n    output st_state_t status,\n    output logic stop,\n    output logic [ADDR_W-1:0] addr_dpram,\n    input  logic busy\n);\n    st_state_t next_status;\n    logic [ADDR_W-1:0] next_addr_dpram;\n    logic              control_reg;\n    logic              next_control_reg;\n\n    assign start = control_reg;\n    assign stop  = (status==DONE) || (status==IDLE);\n\n    always_comb begin\n        next_status = status;\n        next_addr_dpram = addr_dpram;\n        next_control_reg = control_reg;\n        case (status)\n            IDLE:\n            begin\n                next_status = st_state_t'((trigger_ctrl) ? ON : IDLE);\n                next_addr_dpram = (trigger_ctrl) ? 'd0 : addr_dpram;\n            end\n            ON:\n            begin\n                next_status = st_state_t'((start) ? BUSY : ON);\n                next_addr_dpram =  (next_status == ON) ? addr_dpram + 'd1 : addr_dpram;\n                next_control_reg = (next_addr_dpram == 'd3);\n            end\n            BUSY:\n            begin\n                next_status = st_state_t'((busy) ? BUSY : DONE);\n            end\n            DONE:\n            begin\n                next_status = IDLE;\n                next_control_reg = 'd0;\n            end\n            default: begin\n                next_status = IDLE;\n            end\n        endcase\n    end\n\n    always_ff @(posedge clk or negedge rst_n)\n    begin\n        if(!rst_n)\n        begin\n            status      <= IDLE;\n            addr_dpram  <= 'd0;\n            control_reg <= 1'b0;\n        end\n        else\n        begin\n            status      <= next_status;\n            addr_dpram  <= next_addr_dpram;\n            control_reg <= next_control_reg;\n        end\n    end\n\nendmodule\n\n// DSP Operation Unit\nmodule dsp_operation_unit\n    import axi_dsp_op_pkg::*;\n#(\n    parameter ADDR_W = axi_dsp_op_pkg::ADDR_W\n)\n(\n    input logic                clk,\n    input logic                rst_n,\n    input logic                start,\n    input logic                stop,\n    input st_state_t           status,\n    input logic [ADDR_W-1:0]   addr_dpram,\n    input logic [DATA_W-1:0]   opr_dpram,\n    output logic               busy,\n    output logic [OPR_O_W-1:0] opr_o,\n    output logic               opr_o_val\n);\n\n    logic [OPR_A_W-1:0] opr_a;\n    logic [OPR_B_W-1:0] opr_b;\n    logic [OPR_C_W-1:0] opr_c;\n    logic [OPR_O_W-1:0] next_opr_o;\n    logic               next_opr_o_val;\n    logic [64:0]        accum;\n    logic [31:0]        truncated_accum;\n    `ifndef BUG_2\n        assign accum = (opr_a * opr_b) + opr_c;\n    `else\n        assign accum = (opr_a * opr_b);\n    `endif\n    assign truncated_accum = accum[31:0];\n    always_ff @(posedge clk or negedge rst_n) begin\n        if(!rst_n)\n        begin\n            opr_a <= 0;\n            opr_b <= 0;\n            opr_c <= 0;\n            busy <= 'b0;\n        end\n        else\n        begin\n            case (addr_dpram)\n                2'h0:\n                begin\n                    opr_a   <= opr_dpram;\n                    busy <= 1'b1;\n                end\n                2'h1:\n                begin\n                    opr_b   <= opr_dpram;\n                    busy <= 1'b1;\n                end\n                2'h2:\n                begin\n                    opr_c   <= opr_dpram;\n                    busy <= 1'b0;\n                end\n                default: ;\n            endcase\n        end\n    end\n\n    // Result Registering\n    always_comb\n    begin\n        next_opr_o     = opr_o;\n        next_opr_o_val = opr_o_val;\n        if(start)\n        begin\n            next_opr_o     = truncated_accum;\n            next_opr_o_val = 1'b1;\n        end\n        else if (stop)\n        begin\n            next_opr_o     = 'd0;\n            next_opr_o_val = 1'b0;\n        end\n    end\n\n    always_ff @(posedge clk or negedge rst_n) begin\n        if(!rst_n)\n        begin\n            opr_o     <= 'd0;\n            opr_o_val <= 'b0;\n        end\n        else\n        begin\n            opr_o     <= next_opr_o;\n            opr_o_val <= next_opr_o_val;\n        end\n    end\n\nendmodule\n\n// Dual Port RAM\nmodule dual_port_ram\n    import axi_dsp_op_pkg::*;\n#(\n    parameter ADDR_W = axi_dsp_op_pkg::ADDR_W\n)(\n    input logic clk,\n    input logic rst_n,\n    input logic we_dsp,\n    input logic we_axi,\n    input logic [ADDR_W-1:0] addr_dsp,\n    input logic [ADDR_W-1:0] addr_axi,\n    input logic [DATA_W-1:0] din_dsp,\n    input logic [DATA_W-1:0] din_axi,\n    output logic [DATA_W-1:0] dout_dsp,\n    output logic [DATA_W-1:0] dout_axi\n);\n    logic [DATA_W-1:0] ram [0:(2**ADDR_W)-1];\n\n    assign dout_axi = ram[addr_axi];\n    assign dout_dsp = ram[addr_dsp];\n    \n    always_ff @(posedge clk, negedge rst_n) begin\n        if(!rst_n)\n        begin\n            for (int i=0; i<(2**ADDR_W); ++i) begin\n                ram[i] <= 'd0;\n            end\n        end\n        else\n        begin\n            if (we_dsp)\n            begin\n                ram[addr_dsp] <= din_dsp;\n            end\n            if (we_axi)\n            begin\n                ram[addr_axi] <= din_axi;\n            end\n        end\n    end\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_axi_protocol_checkers_0001", "categories": ["cid013", "medium"], "input": {"prompt": "Develop a **SystemVerilog testbench checker** to validate the **AXI Stream protocol compliance** of the **`axi_stream_basic`** module. The testbench must serve as a **protocol checker**, ensuring that the DUT correctly follows **AXI-Stream handshake rules** and maintains data integrity across different scenarios. The testbench must generate **input transactions** covering all AXI-Stream handshake conditions and implement checker logic to verify the DUT\u2019s correctness based on expected behavior.\n\n---\n\n## **Design Details**  \n\n### **1. Functional Behavior**  \n\nThe **AXI-Stream** interface follows a **valid-ready handshake** protocol to facilitate data transfer between components. The DUT **`axi_stream_basic`** processes input signals and passes them through to its outputs while ensuring protocol integrity.\n\n#### **1.1 Parameters**  \n- `DATA_WIDTH` = 8 \u2192 Defines the width of the data signal.  \n- `ID_WIDTH` = 4 \u2192 Specifies the width of the ID field.  \n- `USER_WIDTH` = 2 \u2192 Specifies the width of the user signal.  \n\n#### **1.2 Input Ports**  \n- `clk`: Clock signal controlling data transfer.  \n- `ready_in`: Indicates that the receiver is ready to accept data.  \n- `valid_in`: Indicates that the sender has valid data.  \n- `last_in`: Indicates the last transfer in a transaction.  \n- `data_in`: Input data bus.  \n- `strobe_in`: Strobe signal indicating valid bytes.  \n- `id_in`: Transaction ID field.  \n- `user_in`: User-defined sideband signal.  \n\n#### **1.3 Output Ports**  \n- `ready_out`: Ready signal propagated from input.  \n- `valid_out`: Valid signal propagated from input.  \n- `last_out`: Last signal propagated from input.  \n- `data_out`: Data output bus.  \n- `strobe_out`: Strobe output bus.  \n- `id_out`: ID field output.  \n- `user_out`: User signal output.  \n\n---\n\n## **Testbench Structure**  \n\n### **1. Clock Generation**  \n- Generate a **100 MHz clock** (`clk`) by toggling it **every 5 ns** (`CLK_PERIOD/2 = 5 ns`).  \n\n### **2. Reset Sequencing**  \n- Ensure **proper reset behavior** before initiating test sequences.  \n\n### **3. AXI Stream Stimulus Generation**  \n- Generate **valid and invalid** AXI Stream transactions for verification.  \n\n### **4. Checker Implementation**  \n- Implement assertion-based checkers to verify:  \n  - **Stable Data When No Handshake (`valid_out=1` & `ready_out=0`)**  \n  - **Valid Signal Stability (`valid_out` should not drop unless `ready_out=1`)**  \n  - **Correct Transmission of `last_out`**  \n  - **Ensuring No Undefined (`X` or `Z`) Values in Handshake Signals**  \n  - **Ensuring `data_out`, `strobe_out`, `id_out`, and `user_out` Stay Constant Without Handshake**  \n\n---\n\n## **Test Scenarios**  \n\n### **Scenario 1: Normal Handshake**  \n- `valid_in` asserted, `ready_in` asserted.  \n- Expect proper data transmission (`data_out = data_in`).  \n\n### **Scenario 2: Valid Held High Without Handshake**  \n- `valid_in` remains high, `ready_in` deasserted.  \n- `valid_out` remains high, and `data_out` remains unchanged.  \n\n### **Scenario 3: Data Must Not Change Without Handshake**  \n- `valid_in` remains high, `ready_in` deasserted.  \n- `data_out`, `strobe_out`, `id_out`, and `user_out` remain unchanged.  \n\n### **Scenario 4: No Spurious `valid_out` Drops**  \n- Ensure `valid_out` does not fall unless `ready_out` was asserted.  \n\n---\n\n## **Checker Functionality**  \n\nThe protocol checker must:  \n- Monitor **valid-ready handshake** rules.  \n- Detect **unexpected transitions** in `valid_out` and `ready_out`.  \n- Ensure **data consistency** during handshake delays.  \n- Generate **error messages (`$error`)** if any protocol violations occur.  \n\nThe following checkers must be implemented:\n\n1. **Check `valid_out` and `ready_out` for Undefined Values (`X` or `Z`)**  \n   - The `valid_out` and `ready_out` signals should **never be undefined (`X` or `Z`)**.  \n   - If either signal is in an **invalid state**, the testbench must trigger an **error message (`$error`)**.  \n\n2. **Ensure `valid_out` Does Not Fall Without a Handshake**  \n   - `valid_out` should **not transition from `1 \u2192 0` unless `ready_out` was `1` in the previous cycle**.  \n   - If `valid_out` falls while `ready_out` was `0`, the testbench must flag an error.  \n\n3. **Ensure `last_out` Does Not Change Without a Handshake**  \n   - The **last transaction signal (`last_out`) must remain stable** if `valid_out` is high but `ready_out` is low.  \n   - If `last_out` changes without a handshake, the testbench should trigger an error.  \n\n4. **Ensure `strobe_out` Remains Stable Without a Handshake**  \n   - `strobe_out` must **not change** if `valid_out` remains high while `ready_out` is low.  \n   - If a handshake occurs (`valid_out` and `ready_out` both high), `strobe_out` should be valid and **not contain `X` or `Z` values**.  \n\n5. **Ensure `data_out`, `id_out`, and `user_out` Remain Stable Without a Handshake**  \n   - If `valid_out=1` and `ready_out=0`, all these signals must **retain their previous values**.  \n   - Any unexpected change must trigger an **error (`$error`)**.  \n\n---\n\nDevelop a **testbench** that:  \n- Generates **stimulus** to drive valid and invalid AXI Stream transactions.  \n- Implements **checkers** to verify DUT compliance with AXI-Stream protocol constraints.  \n- Reports **violations via `$error` messages** for incorrect valid-ready handshakes, unexpected drops, and unstable signals.  ", "context": {}}, "output": {"response": "", "context": {"verif/axi_stream_protocol_checker.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 1-axi-stream-protocol-checker\nNUM_BUGS        = 2", "src/axi_stream_basic.sv": "`timescale 1ns/1ps\n\nmodule axi_stream_basic #(\n    parameter int DATA_WIDTH  = 8,\n    parameter int ID_WIDTH    = 4,\n    parameter int USER_WIDTH  = 2\n)(\n    input  logic                     clk,\n\n    // AXI-Stream inputs\n    input  logic                     ready_in,\n    input  logic                     valid_in,\n    input  logic                     last_in,\n    input  logic [DATA_WIDTH-1:0]   data_in,\n    input  logic [(DATA_WIDTH/8)-1:0] strobe_in,\n    input  logic [ID_WIDTH-1:0]     id_in,\n    input  logic [USER_WIDTH-1:0]   user_in,\n\n    // AXI-Stream outputs\n    output logic                     ready_out,\n    output logic                     valid_out,\n    output logic                     last_out,\n    output logic [DATA_WIDTH-1:0]   data_out,\n    output logic [(DATA_WIDTH/8)-1:0] strobe_out,\n    output logic [ID_WIDTH-1:0]     id_out,\n    output logic [USER_WIDTH-1:0]   user_out\n);\n\n   // ------------------------------------------------------------------\n   // By default, signals from the input side flow directly to outputs.\n   // If certain conditions (bug macros) are enabled, corresponding\n   // changes are made to reflect potential protocol issues.\n   // ------------------------------------------------------------------\n   always_comb begin\n      ready_out  = ready_in;\n      valid_out  = valid_in;\n      last_out   = last_in;\n      data_out   = data_in;\n      strobe_out = strobe_in;\n      id_out     = id_in;\n      user_out   = user_in;\n\n      //----------------------------------------------------------------\n      // BUG_0 introduces an intentional data alteration when\n      // the module sees specific inputs in scenario #2:\n      //  (data_in = 0x55, valid_in=1, ready_in=0).\n      // This leads to a \"data changed without transaction\" issue\n      // in the protocol checker for that scenario only.\n      //----------------------------------------------------------------\n      `ifdef BUG_0\n         if (valid_in && !ready_in && (data_in == 8'h55)) begin\n            data_out = data_in ^ 8'hAA;\n         end\n      `endif\n\n      //----------------------------------------------------------------\n      // BUG_1 takes effect after a particular simulation time (140 ns)\n      // if valid_in is high. This forces valid_out to drop, causing\n      // exactly one handshake violation in scenario #4 of the testbench.\n      //----------------------------------------------------------------\n      `ifdef BUG_1\n         if ($realtime >= 140 && valid_in) begin\n            valid_out = 1'b0;\n         end\n      `endif\n\n   end\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/axi_stream_protocol_checker.sv -seed random\"\n#sim = f\"xrun /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\""}}}
{"id": "cvdp_copilot_axi_protocol_checkers_0004", "categories": ["cid013", "medium"], "input": {"prompt": "Develop a **SystemVerilog testbench checker** to validate the **AXI Read request compliance** of the **`axi_read_dut`** module. The testbench must serve as a **range checker**, ensuring that the DUT correctly enforces **address, ID, size, and length constraints** in an AXI read transaction. The testbench must generate **input transactions** covering all AXI Read request scenarios and implement checker logic to verify the DUT\u2019s correctness based on expected behavior.\n\n---\n\n## **Design Details**  \n\n### **1. Functional Behavior**  \n\nThe **AXI Read request interface** allows a master to send read requests to a memory-mapped peripheral. The DUT **`axi_read_dut`** processes incoming requests and forwards them unchanged to the monitoring logic.\n\n#### **1.1 Parameters**  \n- `ADDRESS_PHYS_WIDTH` = 16 \u2192 Defines the **physical** width of the address signal.  \n- `ID_PHYS_WIDTH` = 8 \u2192 Defines the **physical** width of the ID field.  \n- `LOGICAL_ADDRESS_WIDTH` = 8 \u2192 Defines the **logical** width of the address signal.  \n- `LOGICAL_ID_WIDTH` = 4 \u2192 Defines the **logical** portion of the ID field that is valid.  \n- `SUPPORTS_NARROW_BURST` \u2192 Determines whether transfer sizes less than `NATURAL_SIZE` are allowed.  \n- `ENABLE_AXI3` \u2192 If enabled, **upper 4 bits of `ar_len_out` must remain zero**.  \n\n#### **1.2 Input Ports**  \n- `clk`: Clock signal controlling data transfer.  \n- `ar_valid_in`: Indicates a valid read address request.  \n- `ar_addr_in [ADDRESS_PHYS_WIDTH-1:0]`: Read address request.  \n- `ar_id_in [ID_PHYS_WIDTH-1:0]`: Transaction ID associated with the request.  \n- `ar_size_in [2:0]`: Specifies the number of bytes in each transfer within the burst.  \n- `ar_len_in [7:0]`: Number of transfers in the burst transaction.  \n\n#### **1.3 Output Ports**  \n- `ar_valid_out`: Read request valid signal propagated to the next stage.  \n- `ar_addr_out [ADDRESS_PHYS_WIDTH-1:0]`: Forwarded read address request.  \n- `ar_id_out [ID_PHYS_WIDTH-1:0]`: Forwarded transaction ID.  \n- `ar_size_out [2:0]`: Forwarded transfer size.  \n- `ar_len_out [7:0]`: Forwarded burst length.  \n- `ar_ready`: Indicates DUT readiness to accept read transactions.  \n\n---\n\n## **Testbench Structure**  \n\n### **1. Clock Generation**  \n- Generate a **100 MHz clock** (`clk`) by toggling it **every 5 ns** (`CLK_PERIOD/2 = 5 ns`).  \n\n### **2. Reset Sequencing**  \n- Ensure **proper reset behavior** before initiating test sequences.  \n\n### **3. AXI Read Stimulus Generation**  \n- Generate **valid and invalid** AXI Read transactions for verification.  \n\n### **4. Checker Implementation**  \n- Implement assertion-based checkers to verify:  \n  - **Address validity** (`ar_addr_out` should not exceed `LOGICAL_ADDRESS_WIDTH`).  \n  - **ID validity** (`ar_id_out` must remain within `LOGICAL_ID_WIDTH`).  \n  - **Transfer size correctness** based on `SUPPORTS_NARROW_BURST`.  \n  - **Burst length constraints** based on AXI3 protocol.  \n\n---\n\n## **Test Scenarios**  \n\n### **Scenario 1: Valid Read Request**  \n- Generate a **correct read transaction** within AXI constraints.  \n- Expect all outputs to propagate correctly without triggering any assertion failures.  \n\n### **Scenario 2: Address Field Exceeding Allowed Range (Bug 0)**  \n- Assign an **out-of-range address** in `ar_addr_in` (bit exceeding `LOGICAL_ADDRESS_WIDTH`).  \n- Expect the checker to flag an **address range violation**.  \n\n### **Scenario 3: ID Field Exceeding Allowed Range (Bug 1)**  \n- Assign an **out-of-range ID** in `ar_id_in` (bit exceeding `LOGICAL_ID_WIDTH`).  \n- Expect the checker to flag an **ID range violation**.  \n\n### **Scenario 4: Transfer Size Violation (Bug 2)**  \n- Provide an `ar_size_in` value **greater than `NATURAL_SIZE`** when `SUPPORTS_NARROW_BURST=1`.  \n- Expect the checker to raise a **size violation error**.  \n\n### **Scenario 5: AXI3 Length Restriction Violation**  \n- Set `ar_len_in` with **top 4 bits nonzero** when `ENABLE_AXI3 = 1`.  \n- Expect the checker to flag a **burst length violation**.  \n\n---\n\n## **Checker Functionality**  \n\nThe range checker must:  \n- Validate **address, ID, size, and burst length** constraints.  \n- Detect **invalid upper bits** in `ar_addr_out`, `ar_id_out`, and `ar_len_out`.  \n- Enforce **transfer size rules** based on `SUPPORTS_NARROW_BURST`.  \n- Generate **error messages (`$error`)** if any protocol violations occur.  \n\nThe following checkers must be implemented:\n\n1. **Check `ar_addr_out` for Out-of-Range Bits**  \n   - Bits **above `LOGICAL_ADDRESS_WIDTH` in `ar_addr_out`** must be zero.  \n   - If any higher bit is set, flag an error.  \n\n2. **Check `ar_id_out` for Out-of-Range Bits**  \n   - Bits **above `LOGICAL_ID_WIDTH` in `ar_id_out`** must be zero.  \n   - If any higher bit is set, an error will be raised.  \n\n3. **Validate `ar_size_out` Against `NATURAL_SIZE`**  \n   - If `SUPPORTS_NARROW_BURST = 1`, `ar_size_out` **must be \u2264 NATURAL_SIZE**.  \n   - If `SUPPORTS_NARROW_BURST = 0`, `ar_size_out` **must be exactly equal to NATURAL_SIZE**.  \n   - Any violation should raise an error.  \n\n4. **Enforce AXI3 Burst Length Constraints**  \n   - If `ENABLE_AXI3 = 1`, **top 4 bits of `ar_len_out` must be zero**.  \n   - Any non-zero bit in `ar_len_out[7:4]` should trigger an error.  \n\n---\n\nDevelop a **testbench** that:  \n- Generates **stimulus** to drive valid and invalid AXI Read transactions.  \n- Implements **checkers** to verify DUT compliance with AXI protocol constraints.  \n- Reports **violations via `$error` messages** for incorrect address, ID, size, and burst length settings.  ", "context": {}}, "output": {"response": "", "context": {"verif/tb_axi_read_range_checker.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 4-axi-read-range-checker\nNUM_BUGS        = 3", "src/axi_read_dut.sv": "`timescale 1ns/1ps\n\nmodule axi_read_dut #(\n   parameter int ADDRESS_PHYS_WIDTH = 16,\n   parameter int ID_PHYS_WIDTH      = 8\n)(\n   input  logic                     clk,\n\n   // Inputs coming from the testbench\n   input  logic                     ar_valid_in,\n   input  logic [ADDRESS_PHYS_WIDTH-1:0] ar_addr_in,\n   input  logic [ID_PHYS_WIDTH-1:0]      ar_id_in,\n   input  logic [2:0]               ar_size_in,\n   input  logic [7:0]               ar_len_in,\n\n   // Outputs that the monitoring logic will observe\n   output logic                     ar_valid_out,\n   output logic [ADDRESS_PHYS_WIDTH-1:0] ar_addr_out,\n   output logic [ID_PHYS_WIDTH-1:0]      ar_id_out,\n   output logic [2:0]               ar_size_out,\n   output logic [7:0]               ar_len_out\n);\n\n   // By default, pass input signals unaltered to outputs.\n   // If certain defines are set, corresponding signals\n   // will be intentionally adjusted to introduce protocol issues.\n   always_comb begin\n      ar_valid_out = ar_valid_in;\n      ar_addr_out  = ar_addr_in;\n      ar_id_out    = ar_id_in;\n      ar_size_out  = ar_size_in;\n      ar_len_out   = ar_len_in;\n\n      //-----------------------------------------------------\n      // BUG_0: Cause an address bit beyond the intended range\n      //        to be set high if ar_valid_in is active.\n      //-----------------------------------------------------\n      `ifdef BUG_0\n         if (ar_valid_in) begin\n            // This flips a bit that is above the typical range\n            // the monitoring logic will consider valid.\n            ar_addr_out[10] = 1'b1;\n         end\n      `endif\n\n      //-----------------------------------------------------\n      // BUG_1: Introduce an ID bit that is above the typical\n      //        limit recognized by the checker.\n      //-----------------------------------------------------\n      `ifdef BUG_1\n         if (ar_valid_in) begin\n            // Setting bit 6 ensures the ID extends beyond\n            // the recognized logical width.\n            ar_id_out[6] = 1'b1;\n         end\n      `endif\n\n      //-----------------------------------------------------\n      // BUG_2: Modify the read length register to trigger\n      //        an AXI3 length violation in the monitoring logic.\n      //-----------------------------------------------------\n      `ifdef BUG_2\n         if (ar_valid_in) begin\n            // Force one of the upper bits in ar_len to 1\n            // so the AXI3 overhead bits check fails.\n            ar_len_out[5] = 1'b1;\n         end\n      `endif\n   end\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/tb_axi_read_range_checker.sv -seed random\"\n#sim = f\"xrun /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\""}}}
{"id": "cvdp_copilot_axi_protocol_checkers_0007", "categories": ["cid013", "medium"], "input": {"prompt": "Develop a **SystemVerilog testbench checker** to validate the **AXI Write request compliance** of the **`axi_write_dut`** module. The testbench must serve as a **range checker**, ensuring that the DUT correctly enforces **address, ID, size, length, and strobe constraints** in an AXI write transaction. The testbench must generate **input transactions** covering all AXI Write request scenarios and implement checker logic to verify the DUT\u2019s correctness based on expected behavior.\n\n---\n\n## **Design Details**  \n\n### **1. Functional Behavior**  \n\nThe **AXI Write request interface** allows a master to send write requests to a memory-mapped peripheral. The DUT **`axi_write_dut`** processes incoming requests and forwards them unchanged to the monitoring logic.\n\n#### **1.1 Parameters**  \n- `ADDRESS_WIDTH` = 64 \u2192 Defines the **physical** width of the address signal.  \n- `ID_WIDTH` = 8 \u2192 Defines the **physical** width of the ID field.  \n- `DATA_WIDTH` = 32 \u2192 Specifies the **data width** for write transactions.  \n- `LOGICAL_ADDRESS_WIDTH` = 32 \u2192 Defines the **logical** width of the address signal.  \n- `LOGICAL_ID_WIDTH` = 4 \u2192 Defines the **logical** portion of the ID field that is valid.  \n- `SUPPORTS_NARROW_BURST` \u2192 Determines whether transfer sizes less than `NATURAL_SIZE` are allowed.  \n- `ENABLE_AXI3` \u2192 If enabled, **upper 4 bits of `aw_len_out` must remain zero**.  \n\n#### **1.2 Input Ports**  \n- `clk`: Clock signal controlling data transfer.  \n- `aw_valid_in`: Indicates a valid write address request.  \n- `aw_addr_in [ADDRESS_WIDTH-1:0]`: Write address request.  \n- `aw_id_in [ID_WIDTH-1:0]`: Transaction ID associated with the request.  \n- `aw_size_in [2:0]`: Specifies the number of bytes in each transfer within the burst.  \n- `aw_len_in [7:0]`: Number of transfers in the burst transaction.  \n- `w_valid_in`: Indicates that valid write data is available.  \n- `w_strb_in [(DATA_WIDTH/8)-1:0]`: Write a strobe signal indicating which bytes of `w_data` are valid.  \n\n#### **1.3 Output Ports**  \n- `aw_valid_out`: Write request valid signal propagated to the next stage.  \n- `aw_addr_out [ADDRESS_WIDTH-1:0]`: Forwarded write address request.  \n- `aw_id_out [ID_WIDTH-1:0]`: Forwarded transaction ID.  \n- `aw_size_out [2:0]`: Forwarded transfer size.  \n- `aw_len_out [7:0]`: Forwarded burst length.  \n- `w_valid_out`: Write data valid signal.  \n- `w_strb_out [(DATA_WIDTH/8)-1:0]`: Forwarded write strobe signal.  \n- `aw_ready`: Indicates DUT readiness to accept address transactions.  \n- `w_ready`: Indicates DUT readiness to accept write transactions.  \n\n---\n\n## **Testbench Structure**  \n\n### **1. Clock Generation**  \n- Generate a **100 MHz clock** (`clk`) by toggling it **every 5 ns** (`CLK_PERIOD/2 = 5 ns`).  \n\n### **2. Reset Sequencing**  \n- Ensure **proper reset behavior** before initiating test sequences.  \n\n### **3. AXI Write Stimulus Generation**  \n- Generate **valid and invalid** AXI Write transactions for verification.  \n\n### **4. Checker Implementation**  \n- Implement assertion-based checkers to verify:  \n  - **Address validity** (`aw_addr_out` should not exceed `LOGICAL_ADDRESS_WIDTH`).  \n  - **ID validity** (`aw_id_out` must remain within `LOGICAL_ID_WIDTH`).  \n  - **Transfer size correctness** based on `SUPPORTS_NARROW_BURST`.  \n  - **Burst length constraints** based on AXI3 protocol.  \n  - **Write strobe constraints** ensuring only valid bits are asserted.  \n\n---\n\n## **Test Scenarios**  \n\n### **Scenario 1: Valid Write Request**  \n- Generate a **correct write transaction** within AXI constraints.  \n- Expect all outputs to propagate correctly without triggering any assertion failures.  \n\n### **Scenario 2: Address Field Exceeding Allowed Range (Bug 0)**  \n- Assign an **out-of-range address** in `aw_addr_in` (bit exceeding `LOGICAL_ADDRESS_WIDTH`).  \n- Expect the checker to flag an **address range violation**.  \n\n### **Scenario 3: ID Field Exceeding Allowed Range (Bug 1)**  \n- Assign an **out-of-range ID** in `aw_id_in` (bit exceeding `LOGICAL_ID_WIDTH`).  \n- Expect the checker to flag an **ID range violation**.  \n\n### **Scenario 4: Transfer Size Violation (Bug 2)**  \n- Provide an `aw_size_in` value **greater than `NATURAL_SIZE`** when `SUPPORTS_NARROW_BURST=1`.  \n- Expect the checker to raise a **size violation error**.  \n\n### **Scenario 5: AXI3 Length Restriction Violation**  \n- Set `aw_len_in` with **top 4 bits nonzero** when `ENABLE_AXI3 = 1`.  \n- Expect the checker to flag a **burst length violation**.  \n\n### **Scenario 6: Write Strobe Violation**  \n- Assign bits outside the valid range in `w_strb_in`.  \n- Expect the checker to flag an **invalid strobe bit error**.  \n\n---\n\n## **Simulation Control**  \n- Use `$display` statements to track test case execution.  \n- Print `\"All AXI Write range checks passed successfully.\"` if all cases pass.  \n- Terminate the simulation with an `$error` message if any protocol violation occurs.  \n\n---\n\nDevelop a **testbench** that:  \n- Generates **stimulus** to drive valid and invalid AXI Write transactions.  \n- Implements **checkers** to verify DUT compliance with AXI protocol constraints.  \n- Reports **violations via `$error` messages** for incorrect address, ID, size, burst length, or strobe settings.  ", "context": {}}, "output": {"response": "", "context": {"verif/tb_axi_write_range_checker.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 7-axi-write-range-checker-testbench\nNUM_BUGS        = 3", "src/axi_write_dut.sv": "`timescale 1ns/1ps\n\nmodule axi_write_dut #(\n   parameter int ADDRESS_WIDTH = 64,\n   parameter int ID_WIDTH      = 8,     // physically 8 bits, logical usage restricted to fewer\n   parameter int DATA_WIDTH    = 32\n)(\n   input  logic                      clk,\n\n   // Inputs from the test environment\n   input  logic                      aw_valid_in,\n   input  logic [ADDRESS_WIDTH-1:0] aw_addr_in,\n   input  logic [ID_WIDTH-1:0]      aw_id_in,\n   input  logic [2:0]               aw_size_in,\n   input  logic [7:0]               aw_len_in,\n\n   input  logic                      w_valid_in,\n   input  logic [(DATA_WIDTH/8)-1:0] w_strb_in,\n\n   // Outputs to the monitoring logic\n   output logic                      aw_valid_out,\n   output logic [ADDRESS_WIDTH-1:0] aw_addr_out,\n   output logic [ID_WIDTH-1:0]      aw_id_out,\n   output logic [2:0]               aw_size_out,\n   output logic [7:0]               aw_len_out,\n\n   output logic                      w_valid_out,\n   output logic [(DATA_WIDTH/8)-1:0] w_strb_out\n);\n\n   // Pass inputs straight to outputs, unless certain bug conditions apply.\n   always_comb begin\n      aw_valid_out = aw_valid_in;\n      aw_addr_out  = aw_addr_in;\n      aw_id_out    = aw_id_in;\n      aw_size_out  = aw_size_in;\n      aw_len_out   = aw_len_in;\n      w_valid_out  = w_valid_in;\n      w_strb_out   = w_strb_in;\n\n      //--------------------------------------------------------------------\n      // BUG_0: Raise a bit in the address space above the normally permitted\n      //        range, prompting an out-of-range address in the monitoring logic.\n      //--------------------------------------------------------------------\n      `ifdef BUG_0\n         if (aw_valid_in) begin\n            // Setting bit 40 is valid physically (64-bit bus),\n            // but the checker sees bits above 31 as beyond its threshold.\n            aw_addr_out[40] = 1'b1;\n         end\n      `endif\n\n      //--------------------------------------------------------------------\n      // BUG_1: Introduce an ID bit that extends beyond the portion\n      //        recognized by the monitoring logic.\n      //--------------------------------------------------------------------\n      `ifdef BUG_1\n         if (aw_valid_in) begin\n            aw_id_out[5] = 1'b1; \n         end\n      `endif\n\n      //--------------------------------------------------------------------\n      // BUG_2: Choose a size value that the monitoring logic flags \n      //        as invalid for 32-bit data without narrow burst support.\n      //--------------------------------------------------------------------\n      `ifdef BUG_2\n         if (aw_valid_in) begin\n            aw_size_out = 3'd3;\n         end\n      `endif\n   end\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/tb_axi_write_range_checker.sv -seed random\"\n#sim = f\"xrun /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\""}}}
{"id": "cvdp_copilot_bcd_adder_0007", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench to generate stimulus for the `bcd_adder` module, which performs Binary Coded Decimal (BCD) addition on two 4-bit inputs, a and b. \n\n## Testbench Description\n\n### Inputs\n- Registers: a and b are 4-bit registers that provide the two BCD numbers to be added.\n\n### Outputs\n- The outputs from the BCD adder include a 4-bit sum (`sum`) and a carry-out signal (`cout`).\n\n### Instantiation\n- The bcd_adder module is instantiated as uut, with the input and output signals connected for testing.\n\n## Input Generation \n- Input Data Generation: The testbench generates all possible combinations of a and b in the range from 0 to 9 (since the inputs are BCD digits).\n\n---\nFollows the specification for building the RTL of the module, use it as a reference for the verification environment too:\n\n### Inputs\n- [3:0] a: 4-bit input representing a BCD value.\n- [3:0] b: 4-bit input representing another BCD value.\n\n### Outputs\n- [3:0] sum: 4-bit output representing the BCD-corrected sum of `a` and `b`.\n- cout: Single-bit output indicating if a carry is generated during the BCD addition.\n\n---\n### Design Description\nThe `bcd_adder` module performs Binary Coded Decimal (BCD) addition. It consists of three primary blocks:\n\n1. **Binary Adder:** A 4-bit binary adder calculates the intermediate sum (`binary_sum`) and carry (`binary_cout`).\n2. **Logic Block:** Detects whether BCD correction is needed based on the upper bits of the intermediate binary sum.\n3. **BCD Correction:** If correction is required, adds 6 to the intermediate sum to produce the final BCD-corrected output.\n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_bcd_adder.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro \n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 25ea6d785482e96e616407411d8d1405833db4d9\nTARGET = 95", "src/bcd_adder.sv": "module bcd_adder(                \n                 input  [3:0] a,             // 4-bit BCD input\n                 input  [3:0] b,             // 4-bit BCD input\n                 output [3:0] sum,           // The corrected 4-bit BCD result of the addition\n                 output       cout           // Carry-out to indicate overflow beyond BCD range (i.e., when the result exceeds 9)\n                );\n    \nwire [3:0] binary_sum;         // Intermediate binary sum\nwire binary_cout;              // Intermediate binary carry\nwire z1, z2;                   // Intermediate wires for BCD correction\nwire carry;                    // Carry for the second adder\n   \n// Instantiate the first four-bit adder for Binary Addition\nfour_bit_adder adder1(         \n                      .a(a),            \n                      .b(b),            \n                      .cin(1'b0),       \n                      .sum(binary_sum), \n                      .cout(binary_cout) \n                     );\n       \n// Logic to determine BCD correction condition\nassign z1 = (binary_sum[3] & binary_sum[2]); \nassign z2 = (binary_sum[3] & binary_sum[1]); \nassign cout = (z1 | z2 | binary_cout);        \n\n// Instantiate the second four-bit adder for BCD correction\nfour_bit_adder adder2(         \n                      .a(binary_sum),     \n                      .b({1'b0, cout, cout, 1'b0}), \n                      .cin(1'b0),         \n                      .sum(sum),          \n                      .cout(carry)        \n                     );\n\nendmodule     \n\n\n//module of four_bit_adder\nmodule four_bit_adder(        \n                      input [3:0] a,           // 4-bit input a\n                      input [3:0] b,           // 4-bit input b\n                      input cin,               // Carry input\n                      output [3:0] sum,        // 4-bit sum output\n                      output cout              // Carry output\n                     );\n\n  wire [2:0] carry;         // Intermediate carry wires\n\n  genvar i;                 // Declare a variable for the generate loop\n\n  generate\n    for (i = 0; i < 4; i = i + 1) begin: adder \n\n      if (i == 0) begin\n        // Instantiate the first full adder\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(cin),          \n                       .sum(sum[i]),       \n                       .cout(carry[i])     \n                      );\n      end \n\n      else if (i < 3) begin\n        // Instantiate the full adder for intermediate bits\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(carry[i-1]),   \n                       .sum(sum[i]),       \n                       .cout(carry[i])     \n                      );\n      end\n\n      else begin\n        // Instantiate the last full adder\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(carry[i-1]),   \n                       .sum(sum[i]),       \n                       .cout(cout)         \n                     );\n      end\n    end\n  endgenerate\n\nendmodule     \n\n//module of full_adder\nmodule full_adder(       \n                  input a,     // First Addend input\n                  input b,     // Second Addend input\n                  input cin,   // Carry input\n                  output sum,  // Sum output\n                  output cout  // Carry output\n                );\n                  \n  assign sum = a ^ b ^ cin;                      // Calculate sum using XOR\n  assign cout = (a & b) | (b & cin) | (a & cin); // Calculate carry-out\n  \nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/bcd_adder.sv /code/verif/tb_bcd_adder.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        while len(info) < 3:\n            info.append(\"0%\")\n\n        inst = re.sub(r'[\\W]', '', info[0])\n\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'dut' is missing in the coverage log.\")\n\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))  \n\n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['dut']['Average']}, Target: {target}\"\n\n"}}}
{"id": "cvdp_copilot_bcd_adder_0029", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the SystemVerilog testbench named `tb_bcd_adder`  to add the functionality of a checker to test the `bcd_adder` module. The testbench already includes a stimulus generator for various test cases. The purpose of the testbench checker is to verify the correctness of the BCD addition, ensure proper handling of carry correction scenarios, and confirm that the computed results match the expected outputs as per the design specification.\n\n## Design Specification\nThe `bcd_adder` module performs Binary-Coded Decimal (BCD) addition on two 4-bit inputs (`a` and `b`) and generates a 4-bit sum along with a carry-out (`cout`). The module ensures proper BCD correction when the sum exceeds nine by adjusting the result and asserting the carry-out signal.\n\n### Functionality\n- Adds two BCD values and ensures that the sum remains within the valid BCD range.\n- If the sum exceeds nine, the result is corrected by subtracting ten, and the carry-out signal is asserted.\n- If the sum is nine or below, it remains unchanged, and the carry-out signal stays low.\n\n### Inputs\n- a [3:0] : 4-bit input representing a BCD value.\n- b [3:0]: 4-bit input representing another BCD value.\n\n### Outputs\n-  sum[ 3:0]: 4-bit output representing the BCD-corrected sum of `a` and `b`.\n- cout: Single-bit output indicating if a carry is generated during the BCD addition.\n\n## Checker Requirements\n- A task is implemented to compare the DUT output with the expected BCD sum and carry-out values.\n- The task verifies whether the computed sum and carry-out match the expected results.\n- If the values match, the test is marked as passed; otherwise, it is marked as failed.\n- The log displays a pass/fail message for each test case, indicating the expected and actual results.\n\n### Logging and Summary Reporting\n- The total number of tests, passed cases, and failed cases are tracked throughout the simulation.\n- A summary is displayed at the end, indicating whether all tests passed successfully or if any failures occurred.\n\n## Deliverables\n- Complete SystemVerilog Testbench Code.\n- DUT instantiation as `uut`.\n- Simulation stimulus generation for all valid input combinations.\n- Checker to validate DUT outputs against expected values.\n- Validation of BCD sum and carry-out behavior.\n- Waveform file generation for analysis.\n- Summary report of test results, including pass and fail counts.\n\n## Example Outputs\nFor each test case, the testbench should:\n- Verify the correctness of the BCD sum and carry-out signal.\n- Display pass or fail messages based on expected versus actual values.\n- Provide a final test summary with the number of successful and failed cases.", "context": {"verif/tb_bcd_adder.sv": "module tb_bcd_adder();\n    \n    // Inputs\n    reg [3:0] a;\n    reg [3:0] b;\n\n    // Outputs\n    wire [3:0] sum;\n    wire cout;\n\n    // Instantiate the BCD adder\n    bcd_adder uut (\n        .a(a),\n        .b(b),\n        .sum(sum),\n        .cout(cout)\n    );\n\n    // Task to validate the BCD addition\n    task run_bcd_addition(\n        input [3:0] in_a,\n        input [3:0] in_b\n    );\n    begin\n        a = in_a;\n        b = in_b;\n        #10;\n        // Display test case information\n        $display(\" A: %d | B: %d | Sum: %d | Cout: %b\", a, b, sum, cout);\n    end\n    endtask\n\n    // Task to run all test cases\n    task run_tests;\n    begin\n        $display(\"Starting BCD Adder Tests...\");\n        \n        for (integer i = 0; i < 10; i = i + 1) begin\n            for (integer j = 0; j < 10; j = j + 1) begin\n                run_bcd_addition(i, j);\n            end\n        end\n    end\n    endtask\n\n    // Initial block to run tests\n    initial begin\n        run_tests();\n        #50;\n        $finish;\n    end\n\n    // Generate VCD waveform file\n    initial begin\n        $dumpfile(\"bcd_adder.vcd\");\n        $dumpvars(0, tb_bcd_adder);\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_bcd_adder.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/bcd_adder.sv \nHASH            = f42304fa652eed5d6c4d31cfd9b8caf6ba4d3bf3\nNUM_BUGS        = 3\n", "src/bcd_adder.sv": "module bcd_adder(                \n                 input  [3:0] a,             // 4-bit input a\n                 input  [3:0] b,             // 4-bit input b\n                 output [3:0] sum,           // 4-bit sum output\n                 output       cout           // Carry output\n                );\n\nwire [3:0] binary_sum;         // Intermediate binary sum\nwire binary_cout;              // Intermediate binary carry\nwire z1, z2;                   // Intermediate wires for BCD correction\nwire carry;                    // Carry for the second adder\n   \n// Instantiate the first four-bit adder for Binary Addition\nfour_bit_adder adder1(         \n                      .a(a),            \n                      .b(b),            \n                      .cin(1'b0),       \n                      .sum(binary_sum), \n                      .cout(binary_cout) \n                     );\n\n// Logic to determine BCD correction condition\nassign z1 = (binary_sum[3] & binary_sum[2]); \nassign z2 = (binary_sum[3] & binary_sum[1]); \n\n`ifndef BUG_0\n  assign cout = (z1 | z2 | binary_cout);        \n`else\n  assign cout = binary_cout | (binary_sum[2] & binary_sum[1]); \n`endif\n\n// Instantiate the second four-bit adder for BCD correction\nfour_bit_adder adder2(         \n                      .a(binary_sum),     \n                    `ifndef BUG_1\n                      .b({1'b0, cout, cout, 1'b0}), \n                    `else\n                      .b({1'b0, binary_cout, binary_cout, 1'b0}), // Incorrect carry adjustment\n                    `endif\n                      .cin(1'b0),         \n                      .sum(sum),          \n                    `ifndef BUG_2\n                      .cout(carry)        \n                    `else\n                      .cout(carry | 1'b1) // Correcting the syntax error\n                    `endif\n                     );\n\nendmodule\n//module of four_bit_adder\nmodule four_bit_adder(        \n                      input [3:0] a,           // 4-bit input a\n                      input [3:0] b,           // 4-bit input b\n                      input cin,               // Carry input\n                      output [3:0] sum,        // 4-bit sum output\n                      output cout              // Carry output\n                     );\n\n  wire [2:0] carry;         // Intermediate carry wires\n\n  genvar i;                 // Declare a variable for the generate loop\n\n  generate\n    for (i = 0; i < 4; i = i + 1) begin: adder \n\n      if (i == 0) begin\n        // Instantiate the first full adder\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(cin),          \n                       .sum(sum[i]),       \n                       .cout(carry[i])     \n                      );\n      end \n\n      else if (i < 3) begin\n        // Instantiate the full adder for intermediate bits\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(carry[i-1]),   \n                       .sum(sum[i]),       \n                       .cout(carry[i])     \n                      );\n      end\n\n      else begin\n        // Instantiate the last full adder\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(carry[i-1]),   \n                       .sum(sum[i]),       \n                       .cout(cout)         \n                     );\n      end\n    end\n  endgenerate\n\nendmodule     \n\n//module of full_adder\nmodule full_adder(       \n                  input a,     // First Addend input\n                  input b,     // Second Addend input\n                  input cin,   // Carry input\n                  output sum,  // Sum output\n                  output cout  // Carry output\n                );\n                  \n  assign sum = a ^ b ^ cin;                      // Calculate sum using XOR\n  assign cout = (a & b) | (b & cin) | (a & cin); // Calculate carry-out\n  \nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random +define+DATA_WIDTH=8\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=0\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\""}}}
{"id": "cvdp_copilot_bcd_adder_0033", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the SystemVerilog testbench `tb_multi_digit_bcd_add_sub` to add the functionality of a checker to test the `multi_digit_bcd_add_sub` module. The testbench already includes a stimulus generator for various test cases. The purpose of the testbench checker is to verify the functionality of the `multi_digit_bcd_add_sub` module against the given design specification. The checker should assess the module\u2019s performance across different scenarios, including simple additions and subtractions, operations resulting in carry or borrow, and edge cases involving zero and maximum BCD values.\n\n## Design Specification\nThe `multi_digit_bcd_add_sub` module is responsible for performing addition and subtraction on multi-digit BCD numbers. It takes two N-digit BCD numbers as inputs and produces a BCD-corrected sum or difference along with a carry/borrow signal.\n\n#### Parameters:\n- **N**: Defines the number of BCD digits to process, with a default value of 4. This must be a positive integer greater than or equal to 1.\n\n#### Inputs\n\n- `A [4*N-1:0]`: N-digit BCD input representing the first operand.\n- `B [4*N-1:0]`: N-digit BCD input representing the second operand.\n- `add_sub`: Single-bit input that determines the operation (1 for addition, 0 for subtraction).\n\n#### Outputs\n\n- `result [4*N-1:0]`: N-digit BCD-corrected sum or difference.\n- `carry_borrow`: Single-bit output indicating a carry-out in addition or borrow-in subtraction.\n\n## Checker Requirements \n\n### Implementation of a Verification Task\n\n- A dedicated checker is included in the testbench to verify whether the outputs from the multi_digit_bcd_add_sub module match the expected results. \n- It compares the computed BCD result and the carry/borrow flag against the expected values.\n\n### Expected Result Calculation\n\n#### Addition\n- When performing addition, the inputs are first converted into integer values. \n- The sum is then computed, and if it exceeds the maximum value that can be represented in BCD, a carry-out is expected. The final result is converted back into BCD format before comparison.\n\n#### Subtraction\n- When performing subtraction, the difference is calculated. If the result is negative, an adjustment is made to simulate a borrow condition. \n- If the result is valid without requiring an adjustment, the borrow flag is set accordingly. The final value is then converted back into BCD format for verification.\n\n### Verification of Computed vs. Expected Output\n\nThe computed BCD output from the DUT and the carry/borrow flag are checked against the expected values.\n\n- If both match, the test case is considered passed, and a success message is displayed.\n- If there is a mismatch, the test case is marked as failed, and an error message is logged, showing the expected and actual values.\n\n### Tracking Test Statistics\n\n- A counter keeps track of the total number of test cases executed. A separate counter records the number of passed tests and another for failed tests to help in test coverage analysis.\n\n### Logging and Reporting\n\nFor every test case, the results are printed to the log.\n\n- If the test passes, a message confirms that the expected and actual results match.\n- If the test fails, a message highlights the discrepancy, showing both the expected and actual values for debugging.\n\n\n## Deliverables\n\n### 1. Complete SystemVerilog Testbench Code\n\n- **DUT Instantiation:** Correct parameterization and signal connections.\n- **Test Scenarios:** Comprehensive test cases covering all functional aspects and edge cases.\n- **Checkers and Assertions:** Implement assertion-based verification to automatically check DUT outputs against expected values.\n- **Waveform and Log Files:** Generate waveform files (.vcd) for post-simulation analysis.\n- **Summary Reporting:** Print a summary of all tests, including the number of tests passed and failed.\n\n### 2. Example Outputs\n\n- For each test case, the testbench should:\n  - **Verify Functionality:** Confirm that `result` and `carry_borrow` are as expected based on inputs and operation.\n  - **Log Results:** Display `[PASS]` or `[FAIL]` messages for each assertion, providing detailed information on failures, including expected and actual signal values.", "context": {"verif/tb_bcd_adder.sv": "module tb_multi_digit_bcd_add_sub();\n\n  // Parameters\n  parameter N = 4;  // Number of BCD digits\n\n  // Inputs\n  reg [4*N-1:0] A;        // N-digit BCD input A\n  reg [4*N-1:0] B;        // N-digit BCD input B\n  reg           add_sub;  // 1 for addition, 0 for subtraction\n\n  // Outputs\n  wire [4*N-1:0] result;       // N-digit result\n  wire           carry_borrow; // Carry-out or borrow-out\n\n  integer i;             \n\n  // Declare max_value as a module-level variable\n  integer max_value;\n\n\n  // Instantiate the multi-digit BCD adder-subtractor\n  multi_digit_bcd_add_sub #(.N(N)) uut (\n      .A(A),\n      .B(B),\n      .add_sub(add_sub),\n      .result(result),\n      .carry_borrow(carry_borrow)\n  );\n\n  initial begin\n    input_data();        \n    #10;              \n    $finish;             \n  end\n\n  // Function to convert integer to BCD\n  function [4*N-1:0] int_to_bcd(input integer value);\n    integer idx;\n    reg [3:0] digits [N-1:0];\n    reg [4*N-1:0] bcd_result;\n    begin\n      bcd_result = 0; \n      for (idx = 0; idx < N; idx = idx + 1) begin\n        digits[idx] = value % 10; \n        value = value / 10;     \n      end\n      for (idx = 0; idx < N; idx = idx + 1) begin\n        bcd_result = bcd_result | (digits[idx] << (4 * idx)); \n      end\n      int_to_bcd = bcd_result;\n    end\n  endfunction\n\n  // Function to convert BCD to string for display\n  function [8*N-1:0] bcd_to_str(input [4*N-1:0] bcd);\n    integer idx;\n    reg [3:0] digit;\n    reg [8*N-1:0] str;\n    begin\n      str = \"\";\n      for (idx = N-1; idx >= 0; idx = idx - 1) begin\n        digit = bcd[4*idx +: 4]; \n        str = {str, digit + 8'h30}; \n      end\n      bcd_to_str = str;\n    end\n  endfunction\n\n  // Task to execute a test case\n  task test_case(input integer test_num, input integer A_int, input integer B_int, input reg add_sub_op, input string goal);\n    begin\n      $display(\"Test Case %0d: %s\", test_num, goal);\n      A = int_to_bcd(A_int);\n      B = int_to_bcd(B_int);\n      add_sub = add_sub_op;\n      #10;\n      $display(\"add_sub = %b,A=%0d,B=%0d result=%s and  carry_borrow=%b\", add_sub_op,A,B, bcd_to_str(result),carry_borrow);\n    end\n  endtask\n\n  // Task to generate input data \n  task input_data();\n    integer A_int, B_int;\n    begin\n      max_value = 1;\n      for (i = 0; i < N; i = i + 1)\n        max_value = max_value * 10; \n\n\n      test_case(1, 0, $urandom_range(1, max_value - 1), 0, \"Validate subtraction when A = 0 and B is non-zero\");\n      test_case(2, $urandom_range(1, max_value - 1), 0, 0, \"Validate subtraction when A is non-zero and B = 0\");\n      A_int = $urandom_range(0, max_value - 1);\n      test_case(3, A_int, A_int, 0, \"Validate subtraction when A = B (should result in 0)\");\n      test_case(4, max_value - 1, 1, 1, \"Validate addition with overflow condition\");\n      test_case(5, max_value / 2, max_value / 2 - 1, 1, \"Validate addition without overflow\");\n      test_case(6, max_value - 1, max_value - 1, 1, \"Validate addition with full overflow\");\n      test_case(7, 1, max_value - 1, 0, \"Validate subtraction with negative borrow\");\n      if (N >= 4) begin\n        test_case(8, 9999, 9999, 1, \"Validate addition when A and B are both maximum values\");\n        test_case(9, 9999, 9999, 0, \"Validate subtraction when A and B are both maximum values\");\n      end\n      if (N >= 1) begin\n        test_case(10, 9, 1, 1, \"Validate single-digit wrap around during addition\");\n      end\n      if (N >= 4) begin\n        test_case(11, 1000, 1, 0, \"Validate borrow propagation across multiple digits\");\n      end\n\n      // Random Tests (Existing Code)\n      for (i = 0; i < 100; i = i + 1) begin\n        A_int = $urandom % max_value;\n        B_int = $urandom % max_value;\n\n        test_case(i + 12, A_int, B_int, $urandom % 2, \"Random test case\");\n      end\n    end\n  endtask\n\n  initial begin\n    $dumpfile(\"multi_digit_bcd_add_sub.vcd\"); // Specify the VCD file for waveform dumping\n    $dumpvars(0, tb_multi_digit_bcd_add_sub); // Dump all variables in the testbench\n  end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_bcd_adder.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/bcd_adder.sv \nHASH            = 33-testbench-checker-for-multi_digit_bcd_add_sub\nNUM_BUGS        = 5", "src/bcd_adder.sv": "module multi_digit_bcd_add_sub #(parameter N = 4)(\n    input  [4*N-1:0] A,           // N-digit BCD number\n    input  [4*N-1:0] B,           // N-digit BCD number\n    input            add_sub,     // 1 for addition, 0 for subtraction\n    output [4*N-1:0] result,      // Result (sum or difference)\n    output           carry_borrow // Carry-out for addition or Borrow-out for subtraction\n);\n    wire [N:0] carry;          // Carry between digits\n    wire [4*N-1:0] B_comp;     // Complemented B for subtraction\n    wire [4*N-1:0] operand_B;  // Operand B after considering addition or subtraction\n\n    // Carry initialization with a bug\n    `ifndef BUG_0\n      assign carry[0] = add_sub ? 1'b0 : 1'b1;\n    `else\n      assign carry[0] = add_sub ? 1'b1 : 1'b0; // Incorrect carry initialization\n    `endif\n\n    // Generate 9's complement of B for subtraction with a bug\n    genvar i;\n    generate\n        for (i = 0; i < N; i = i + 1) begin \n            `ifndef BUG_1\n              assign B_comp[4*i+3:4*i] = 4'b1001 - B[4*i+3:4*i]; \n            `else\n              assign B_comp[4*i+3:4*i] = B[4*i+3:4*i] - 4'b1001; // Incorrect subtraction order\n            `endif\n        end\n    endgenerate\n\n    // Operand selection with a bug\n    `ifndef BUG_2\n      assign operand_B = add_sub ? B : B_comp;\n    `else\n      assign operand_B = add_sub ? B_comp : B; // Swapped operand selection\n    `endif\n\n    generate\n        for (i = 0; i < N; i = i + 1) begin \n            bcd_adder bcd_adder_inst(\n                .a(A[4*i+3:4*i]),\n                .b(operand_B[4*i+3:4*i]),\n                `ifndef BUG_3\n                  .cin(carry[i]),\n                `else\n                  .cin(1'b0), // Incorrectly fixing carry input to 0\n                `endif\n                .sum(result[4*i+3:4*i]),\n                .cout(carry[i+1])\n            );\n        end\n    endgenerate\n\n    // Carry/Borrow output with a bug\n    `ifndef BUG_4\n      assign carry_borrow = carry[N]; \n    `else\n      assign carry_borrow = carry[N] ^ 1'b1; // Incorrectly inverting the carry-borrow output\n    `endif\n\nendmodule\n\n//module of bcd_adder\nmodule bcd_adder(                \n                 input  [3:0] a,             // 4-bit BCD input\n                 input  [3:0] b,             // 4-bit BCD input\n                 input        cin,           // Carry-in\n                 output [3:0] sum,           // The corrected 4-bit BCD result of the addition\n                 output       cout           // Carry-out to indicate overflow beyond BCD range (i.e., when the result exceeds 9)\n                );\n    \nwire [3:0] binary_sum;         \nwire binary_cout;              \nwire z1, z2;                   \nwire carry;                    \n   \nfour_bit_adder adder1(         \n                      .a(a),            \n                      .b(b),            \n                      .cin(cin),       \n                      .sum(binary_sum), \n                      .cout(binary_cout) \n                     );\n       \nassign z1 = (binary_sum[3] & binary_sum[2]); \nassign z2 = (binary_sum[3] & binary_sum[1]); \nassign cout = (z1 | z2 | binary_cout);        \n\nfour_bit_adder adder2(         \n                      .a(binary_sum),     \n                      .b({1'b0, cout, cout, 1'b0}), \n                      .cin(1'b0),         \n                      .sum(sum),          \n                      .cout(carry)        \n                     );\n\nendmodule     \n\n\n//module of four_bit_adder\nmodule four_bit_adder(        \n                      input [3:0] a,           // 4-bit input a\n                      input [3:0] b,           // 4-bit input b\n                      input cin,               // Carry input\n                      output [3:0] sum,        // 4-bit sum output\n                      output cout              // Carry output\n                     );\n\n  wire [2:0] carry;         \n\n  genvar i;                 \n\n  generate\n    for (i = 0; i < 4; i = i + 1) begin: adder \n\n      if (i == 0) begin\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(cin),          \n                       .sum(sum[i]),       \n                       .cout(carry[i])     \n                      );\n      end \n      else if (i < 3) begin\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(carry[i-1]),   \n                       .sum(sum[i]),       \n                       .cout(carry[i])     \n                      );\n      end\n      else begin\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(carry[i-1]),   \n                       .sum(sum[i]),       \n                       .cout(cout)         \n                     );\n      end\n    end\n  endgenerate\n\nendmodule     \n\n//module of full_adder\nmodule full_adder(       \n                  input a,     // First Addend input\n                  input b,     // Second Addend input\n                  input cin,   // Carry input\n                  output sum,  // Sum output\n                  output cout  // Carry output\n                );\n                  \n  assign sum = a ^ b ^ cin;                      \n  assign cout = (a & b) | (b & cin) | (a & cin); \n  \nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random +define+DATA_WIDTH=8\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=0\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\""}}}
{"id": "cvdp_copilot_bcd_adder_0038", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add an immediate assertion in the RTL design of the `multi_digit_bcd_add_sub` module to verify the correctness of the BCD addition and subtraction outputs? The assertion should check the following conditions:\n\n## 1. Valid BCD Result:\nEnsure that each digit in the result remains within the valid BCD range (0\u20139). If any digit exceeds 9, the assertion should trigger an error.\n\n## 2. Carry/Borrow Behavior:\n- **Addition:** The carry-out (`carry_borrow`) should correctly reflect the propagated carry from the final digit.\n- **Subtraction:** The borrow-out (`carry_borrow`) should either be asserted correctly or the result should not be zero, preventing an invalid subtraction case.\n\n## 3. Valid Parameter N:\nEnsure that the parameter `N` (number of BCD digits) is always greater than zero.\n\nAdditionally, the design uses a register check_done to delay the assertions until all inputs (a and b) have stabilized. The check_done register is set to 1'b1 whenever inputs are updated, ensuring that the assertions are evaluated only after input stabilization. This mechanism prevents false assertion failures during transitional states of the inputs.\n\nThe assertion should use System Verilog constructs and display appropriate error messages if any of the above conditions are violated.\n\n## Interface\n\n### Module Name:\nThe module must be named `multi_digit_bcd_add_sub`.\n\n### Parameters:\n- **N**: Defines the number of BCD digits to process, with a default value of 4. This must be a positive integer greater than or equal to 1.\n\n### Inputs:\n- `[4*N-1:0] A`: N-digit Binary-Coded Decimal (BCD) input, with each digit represented as a 4-bit binary value\n- `[4*N-1:0] B`: N-digit Binary-Coded Decimal (BCD) input, with each digit represented as a 4-bit binary value\n- `add_sub`: Operation selection signal. A high signal (1) selects addition, and a low signal (0) selects subtraction.\n  \n### Outputs:\n- `[4*N-1:0] result`: N-digit Binary-Coded Decimal (BCD) result of the operation, each digit represented as a 4-bit binary value\n- `carry_borrow`: Indicates a carry-out from addition or a borrow-out from subtraction.\n     - For addition (add_sub = 1), carry_borrow is high when there is a carry-out from the most significant digit, otherwise remains low\n     - For subtraction (add_sub = 0), carry_borrow is high when no borrow is required (i.e., when A \u2265 B), and low when a borrow is required (i.e., when A < B).\n\nThe assertion should be integrated into the RTL design to verify these constraints during simulation and trigger error messages when violations occur.", "context": {"rtl/bcd_adder.sv": "module multi_digit_bcd_add_sub #(parameter N = 4)(\n    input  [4*N-1:0] A,           // N-digit BCD number\n    input  [4*N-1:0] B,           // N-digit BCD number\n    input            add_sub,     // 1 for addition, 0 for subtraction\n    output [4*N-1:0] result,      // Result (sum or difference)\n    output           carry_borrow // Carry-out for addition or Borrow-out for subtraction\n);\n    wire [N:0] carry;          // Carry between digits\n    wire [4*N-1:0] B_comp;     // Complemented B for subtraction\n    wire [4*N-1:0] operand_B;  // Operand B after considering addition or subtraction\n\n    assign carry[0] = add_sub ? 1'b0 : 1'b1; \n\n    // Generate 9's complement of B for subtraction\n    genvar i;\n    generate\n        for (i = 0; i < N; i = i + 1) begin \n            assign B_comp[4*i+3:4*i] = 4'b1001 - B[4*i+3:4*i]; \n        end\n    endgenerate\n\n    assign operand_B = add_sub ? B : B_comp;\n\n    generate\n        for (i = 0; i < N; i = i + 1) begin \n            bcd_adder bcd_adder_inst(\n                .a(A[4*i+3:4*i]),\n                .b(operand_B[4*i+3:4*i]),\n                .cin(carry[i]),\n                .sum(result[4*i+3:4*i]),\n                .cout(carry[i+1])\n            );\n        end\n    endgenerate\n\n    assign carry_borrow = carry[N]; \nendmodule\n\n//module of bcd_adder\nmodule bcd_adder(                \n                 input  [3:0] a,             // 4-bit BCD input\n                 input  [3:0] b,             // 4-bit BCD input\n                 input        cin,           // Carry-in\n                 output [3:0] sum,           // The corrected 4-bit BCD result of the addition\n                 output       cout           // Carry-out to indicate overflow beyond BCD range (i.e., when the result exceeds 9)\n                );\n    \nwire [3:0] binary_sum;         \nwire binary_cout;              \nwire z1, z2;                   \nwire carry;                    \n   \nfour_bit_adder adder1(         \n                      .a(a),            \n                      .b(b),            \n                      .cin(cin),       \n                      .sum(binary_sum), \n                      .cout(binary_cout) \n                     );\n       \nassign z1 = (binary_sum[3] & binary_sum[2]); \nassign z2 = (binary_sum[3] & binary_sum[1]); \nassign cout = (z1 | z2 | binary_cout);        \n\nfour_bit_adder adder2(         \n                      .a(binary_sum),     \n                      .b({1'b0, cout, cout, 1'b0}), \n                      .cin(1'b0),         \n                      .sum(sum),          \n                      .cout(carry)        \n                     );\n\nendmodule     \n\n\n//module of four_bit_adder\nmodule four_bit_adder(        \n                      input [3:0] a,           // 4-bit input a\n                      input [3:0] b,           // 4-bit input b\n                      input cin,               // Carry input\n                      output [3:0] sum,        // 4-bit sum output\n                      output cout              // Carry output\n                     );\n\n  wire [2:0] carry;         \n\n  genvar i;                 \n\n  generate\n    for (i = 0; i < 4; i = i + 1) begin: adder \n\n      if (i == 0) begin\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(cin),          \n                       .sum(sum[i]),       \n                       .cout(carry[i])     \n                      );\n      end \n      else if (i < 3) begin\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(carry[i-1]),   \n                       .sum(sum[i]),       \n                       .cout(carry[i])     \n                      );\n      end\n      else begin\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(carry[i-1]),   \n                       .sum(sum[i]),       \n                       .cout(cout)         \n                     );\n      end\n    end\n  endgenerate\n\nendmodule     \n\n//module of full_adder\nmodule full_adder(       \n                  input a,     // First Addend input\n                  input b,     // Second Addend input\n                  input cin,   // Carry input\n                  output sum,  // Sum output\n                  output cout  // Carry output\n                );\n                  \n  assign sum = a ^ b ^ cin;                      \n  assign cout = (a & b) | (b & cin) | (a & cin); \n  \nendmodule"}}, "output": {"response": "", "context": {"rtl/bcd_adder.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 90\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/bcd_adder.sv\nTOPLEVEL        = multi_digit_bcd_add_sub\nMODULE          = test_multi_dig_bcd_add_sub\nPYTHONPATH      = /src\nHASH            = cba61cf00e638af325ae223a8a8119752506742a\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_multi_dig_bcd_add_sub.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ReadOnly , Timer\n\nimport harness_library as hrs_lb\nimport random\n\ndef int_to_bcd(value, N):\n\n    bcd = 0\n    for i in range(N):\n        digit = value % 10\n        value = value // 10\n        bcd |= (digit << (4 * i))\n    return bcd\n\ndef bcd_to_str(bcd, N):\n\n    digits = []\n    for i in reversed(range(N)):\n        digit = (bcd >> (4 * i)) & 0xF\n        digits.append(str(digit))\n    return ''.join(digits)\n\n@cocotb.test()\nasync def test_multi_digit_bcd_add_sub(dut):\n\n    # Initialize the DUT signals\n    dut.A.value = 0\n    dut.B.value = 0\n    dut.add_sub.value = 0\n    # Determine the number of digits (N) from the width of input A\n    N = len(dut.A.value) // 4\n    max_value = 10 ** N\n    for _ in range(100):  \n\n        # Generate random integers within the range of N-digit numbers\n        A_int = random.randint(0, max_value - 1)\n        B_int = random.randint(0, max_value - 1)\n        add_sub = random.randint(0, 1)  # 1 for addition, 0 for subtraction\n\n        # Convert integers to BCD representation\n        A_bcd = int_to_bcd(A_int, N)\n        B_bcd = int_to_bcd(B_int, N)\n\n        # Assign values to DUT\n        dut.A.value = A_bcd\n        dut.B.value = B_bcd\n        dut.add_sub.value = add_sub\n\n        # Wait for the combinational logic to settle\n        await Timer(1, units='ns')\n\n        # Read outputs\n        result_bcd = int(dut.result.value)\n        carry_borrow = int(dut.carry_borrow.value)\n\n        # Compute expected result\n        if add_sub == 1:\n            # Addition\n            expected_result_int = A_int + B_int\n            expected_carry_out = 1 if expected_result_int >= max_value else 0\n            expected_result_int = expected_result_int % max_value\n        else:\n            # Subtraction\n            expected_result_int = A_int - B_int\n            if expected_result_int < 0:\n                expected_result_int += max_value\n                expected_carry_out = 0\n            else:\n                expected_carry_out = 1\n\n        # Convert expected result to BCD\n        expected_result_bcd = int_to_bcd(expected_result_int, N)\n\n        # Compare DUT outputs with expected values\n        if result_bcd != expected_result_bcd or carry_borrow != expected_carry_out:\n            A_str = bcd_to_str(A_bcd, N)\n            B_str = bcd_to_str(B_bcd, N)\n            result_str = bcd_to_str(result_bcd, N)\n            expected_str = bcd_to_str(expected_result_bcd, N)\n            operation = 'Addition' if add_sub else 'Subtraction'\n            error_msg = (f\"Test failed for A={A_str}, B={B_str}, Operation={operation}.\\n\"\n                         f\"Expected result={expected_str}, carry_out={expected_carry_out}, \"\n                         f\"Got result={result_str}, carry_out={carry_borrow}\")\n            raise AssertionError(error_msg)\n        else:\n            if add_sub:\n                # Addition\n                dut._log.info(f\"Addition: A={bcd_to_str(A_bcd, N)}, B={bcd_to_str(B_bcd, N)}, \"\n                              f\"Result={bcd_to_str(result_bcd, N)}, Carry_Out={carry_borrow}\")\n            else:\n                # Subtraction\n                dut._log.info(f\"Subtraction: A={bcd_to_str(A_bcd, N)}, B={bcd_to_str(B_bcd, N)}, \"\n                              f\"Result={bcd_to_str(result_bcd, N)}, Borrow_Out={carry_borrow}\")\n\n        # Wait before next iteration\n        await Timer(1, units='ns')", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\nN               = [4] \n@pytest.mark.parametrize(\"N\", N)\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate(N):\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\",\n        parameters={\"N\": N} \n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_binary_search_tree_sorting_0015", "categories": ["cid012", "medium"], "input": {"prompt": "Write a SystemVerilog testbench named `bst_sort_tb` that generates only stimulus for a binary search tree (BST) based sorting algorithm design `binary_search_tree_sort` that processes an array of unsigned integers with a parameterizable size, ARRAY_SIZE (number of elements in the array, will be greater than 0).  The stimulus should be generated for a design that sorts an input array in ascending order using the BST insertion and in-order traversal logic. The sorting process should be driven by control signals and should be tested for various input arrays. \n\nA BST is a data structure where each node has a key, and its left child contains keys less than or equal to the node, while its right child contains keys greater than the node and thereby constructs a tree. The algorithm organizes the integers into a binary search tree and traverses the tree to produce a sorted output array.\n\n### Design Details\n\n**Parameterization**\n\n- **ARRAY_SIZE**: Specifies the number of elements in the input array.\n  - Default: 7\n- **DATA_WIDTH**: Specifies the bit-width of each array element.\n  - Default: 8\n\n**Functionality**\n\n- **Array Processing**:\n The design takes an unsorted array and constructs a binary search tree (BST). It then performs an in-order tree traversal to produce a sorted array. The sorting process is controlled using the start and done signals. The input array, **data_in**, should remain unchanged once the sorting process begins. Any changes to the input during the sorting operation would not be considered.\n\n- **Control Signals**: \n  - **start**: An active-high signal indicating the start of the sorting operation. When asserted, the sorting begins.\n  - **done**: An active-high signal that indicates the sorting operation has been completed. It is asserted after the sorting process is finished.\n  \n**Inputs and Outputs**\n\n**Inputs:**\n\n- **clk**: Clock signal for synchronization. The design is synchronized to the positive edge of this clock.\n- **reset**: Active-high asynchronous reset.When asserted, it immediately resets all outputs (**sorted_out** array and **done**) to zero.\n- **start**: Active-high signal for 1 clock cycle to initiate the sorting process.\n- **data_in [ARRAY_SIZE*DATA_WIDTH-1:0]**: The unsorted input array that will be sorted by the BST-based algorithm.\n\n**Outputs:**\n\n- **done**: An active high signal for 1 clock cycle indicates when the sorting operation is complete.\n- **sorted_out [ARRAY_SIZE*DATA_WIDTH-1:0]**: The sorted array output in ascending order, such that the smallest element is at index 0 and the largest element is at index ARRAY_SIZE-1.\n\n### Requirements:\n\n**Instantiation**\n\n- **Module Instance**: The BST-based sorting module should be instantiated as `dut`, with all input and output signals connected for testing.\n\n**Input Generation and Validation**\n\n- **Array Generation**: The testbench must generate multiple test cases with different values for **data_in**, including edge cases such as an array with all elements the same, an already sorted array, and a reverse-sorted array.\n  \n**Control Signal Handling**:\n\n- The **start** signal should be asserted to trigger the sorting process, and the testbench must wait until the **done** signal is asserted (to wait for the sorting to be completed).\n- The new input **data_in** along with the start signal must only be asserted after the **done**  signal for the previous input array is asserted to high (after **done** asserts and deasserts). This process must be repeated to cover different sequences of input_data. It must be noted that while the done signal is high, the new input **data_in**  and **start** must not be asserted to avoid loss of **start** and new input **data_in**. \n\n**Test Coverage**\n\n- Test with all possible combinations of elements within input array **data_in** via randomization as well as corner cases such as :\n  - **data_in** with all values equal.\n  - **data_in** that is already sorted.\n  - **data_in** in descending order.", "context": {}}, "output": {"response": "", "context": {"verif/bst_sort_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = d9fad48979f519bae3ac26519d78d8dc887a3810\nTARGET = 97\n", "src/binary_search_tree_sort.sv": "module binary_search_tree_sort #(\n    parameter DATA_WIDTH = 32,\n    parameter ARRAY_SIZE = 15\n) (\n    input clk,\n    input reset,\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in, // Input data to be sorted\n    input start,\n    output reg [ARRAY_SIZE*DATA_WIDTH-1:0] sorted_out, // Sorted output\n    output reg done\n);\n\n    // Parameters for top-level FSM states\n    parameter IDLE = 2'b00, BUILD_TREE = 2'b01, SORT_TREE = 2'b10;\n\n    // Parameters for nested FSM states (Build Tree)\n    parameter INIT = 2'b00, INSERT = 2'b01, TRAVERSE = 2'b10, COMPLETE = 2'b11;\n\n    // Parameters for nested FSM states (Sort Tree)\n    parameter S_INIT = 2'b00, S_SORT_LEFT_RIGHT = 2'b01, S_MERGE_RESULTS = 2'b10;\n    // Registers for FSM states\n    reg [1:0] top_state, build_state, sort_state;\n\n    // BST representation\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in_copy;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys; // Array to store node keys\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child; // Left child pointers\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child; // Right child pointers\n    reg [$clog2(ARRAY_SIZE):0] root; // Root node pointer\n    reg [$clog2(ARRAY_SIZE)-1:0] next_free_node; // Pointer to the next free node\n\n    // Working registers\n    reg [$clog2(ARRAY_SIZE)-1:0] current_node; // Current node being processed\n    reg [$clog2(ARRAY_SIZE):0] input_index; // Index for input data\n    reg [DATA_WIDTH-1:0] temp_data; // Temporary data register\n\n    // Intermediate buffers for storing sorted values of left and right subtrees\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] left_sorted;  // Buffer for left subtree sorted values\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] right_sorted; // Buffer for right subtree sorted values\n\n    // Stack and pointers for left and right subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_stack; // Stack for left subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_stack; // Stack for right subtree traversal\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_left; // Stack pointer for left subtree\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_right; // Stack pointer for right subtree\n\n    // Current node pointers for left and right subtrees\n    reg [$clog2(ARRAY_SIZE):0] current_left_node; // Current node in left subtree\n    reg [$clog2(ARRAY_SIZE):0] current_right_node; // Current node in right subtree\n\n    // Flags to indicate when sorting of left and right subtrees is done\n    reg left_done; // Flag for completion of left subtree sorting\n    reg right_done; // Flag for completion of right subtree sorting\n\n    // Output indices for left and right subtree buffers\n    reg [$clog2(ARRAY_SIZE)-1:0] left_output_index; // Output index for left_sorted buffer\n    reg [$clog2(ARRAY_SIZE)-1:0] right_output_index; // Output index for right_sorted buffer\n\n    // Initialize all variables\n    integer i, j;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all states and variables\n            top_state <= IDLE;\n            build_state <= INIT;\n            sort_state <= S_INIT;\n            root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; ; // Null pointer\n            next_free_node <= 0;\n            input_index <= 0;\n            done <= 0;\n\n            // Clear tree arrays\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                left_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                right_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n            end\n\n        end \n        else begin\n            case (top_state)\n                IDLE: begin\n                    done <= 0;\n                    input_index <= 0;\n                    root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; ; // Null pointer\n                    next_free_node <= 0;\n                    for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                        keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                        right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        left_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        right_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                    end\n                    if (start) begin\n                        // Load input data into input array\n                        top_state <= BUILD_TREE;\n                        build_state <= INIT;\n                        data_in_copy <= data_in;\n                    end\n                end\n\n                BUILD_TREE: begin\n                    case (build_state)\n                        INIT: begin\n                            if (input_index < ARRAY_SIZE) begin\n                                temp_data <= data_in_copy[input_index*DATA_WIDTH +: DATA_WIDTH]; \n                                input_index <= input_index + 1;\n                                build_state <= INSERT;\n                            end else begin\n                                build_state <= COMPLETE;\n                            end\n                        end\n\n                        INSERT: begin\n                            if (root == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                // Tree is empty, insert at root\n                                root <= next_free_node;\n                                keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                next_free_node <= next_free_node + 1; \n                                build_state <= INIT;\n                            end else begin\n                                // Traverse the tree to find the correct position\n                                current_node <= root; \n                                build_state <= TRAVERSE;\n                            end\n                        end\n\n                        TRAVERSE: begin      \n                            if ((temp_data < keys[current_node*DATA_WIDTH +: DATA_WIDTH]) || (temp_data == keys[current_node*DATA_WIDTH +: DATA_WIDTH])) begin\n                                if (left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                    left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                                    keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                    next_free_node <= next_free_node + 1;\n                                    build_state <= INIT;\n                                end else begin\n                                    current_node <= left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                                end\n                            end else begin\n                                if (right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                    right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                                    keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data; \n                                    next_free_node <= next_free_node + 1;\n                                    build_state <= INIT;\n                                end else begin\n                                    current_node <= right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                                end\n                            end\n                        end\n\n                        COMPLETE: begin\n                            // Tree construction complete\n                            top_state <= SORT_TREE;\n                            sort_state <= S_INIT;\n                        end\n\n                    endcase\n                end\n\n                SORT_TREE: begin\n                    case (sort_state)\n                        S_INIT: begin\n                            // Start parallel sorting for left and right subtrees\n                            left_output_index <= 0;\n                            right_output_index <= 0;\n                            sp_left <= 0;\n                            sp_right <= 0;\n                            left_done <= 0;\n                            right_done <= 0;\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            current_right_node <= right_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            sort_state <= S_SORT_LEFT_RIGHT;\n                        end\n\n                        S_SORT_LEFT_RIGHT: begin\n                            // Sort left subtree in parallel\n                            if (!left_done && current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                                sp_left <= sp_left + 1;\n                                current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!left_done && sp_left > 0) begin\n                                sp_left <= sp_left - 1;\n                                current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                left_sorted[left_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH];\n                                left_output_index <= left_output_index + 1;\n                                current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!left_done) begin\n                                left_done <= 1;\n                            end\n\n                            // Sort right subtree in parallel\n                            if (!right_done && current_right_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                right_stack[sp_right*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_right_node;\n                                sp_right <= sp_right + 1;\n                                current_right_node <= left_child[current_right_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!right_done && sp_right > 0) begin\n                                sp_right <= sp_right - 1;\n                                current_right_node <= right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                right_sorted[right_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH];\n                                right_output_index <= right_output_index + 1;\n                                current_right_node <= right_child[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!right_done) begin\n                                right_done <= 1;\n                            end\n\n                            // Transition to merging once both left and right sorting are done\n                            if (left_done && right_done) begin\n                                sort_state <= S_MERGE_RESULTS;\n                            end\n                        end\n\n                        S_MERGE_RESULTS: begin\n\n                            // Merge left_sorted, root, and right_sorted into final sorted output\n                            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                                if (i < left_output_index) begin\n                                    sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= left_sorted[i*DATA_WIDTH +: DATA_WIDTH];\n                                end\n                            end\n\n                            // Insert the root into `sorted_out`\n                            sorted_out[left_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[root*DATA_WIDTH +: DATA_WIDTH];\n\n                            // Copy `right_sorted` into `sorted_out`\n                            for (j = 0; j < ARRAY_SIZE; j = j + 1) begin\n                                if (j < right_output_index) begin\n                                    sorted_out[(left_output_index + 1 + j)*DATA_WIDTH +: DATA_WIDTH] <= right_sorted[j*DATA_WIDTH +: DATA_WIDTH];\n                                end\n                            end\n\n                            done <= 1; // Sorting complete\n                            top_state <= IDLE;\n\n                        end\n\n                        default: begin\n                            sort_state <= S_INIT; // Reset to initial sort state\n                        end\n                    endcase\n                end\n\n                default: begin\n                    top_state <= IDLE; // Default behavior for top-level FSM\n                end\n                \n            endcase\n        end\n    end\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Simulation didn't run correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage merge didn't run correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    try:\n        with open(\"/code/rundir/coverage.log\") as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage.log file.\")\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    print(\"Parsed Metrics:\")\n    print(metrics)\n\n    # Ensure TARGET environment variable is set\n    target = os.getenv(\"TARGET\")\n    if not target:\n        raise ValueError(\"TARGET environment variable is not set.\")\n    target = float(target)\n\n    # Check coverage for the DUT or specific key\n    dut = \"dut\"  # Replace this with the DUT key you want to check\n    if dut in metrics and \"Overall Average\" in metrics[dut]:\n        assert float(metrics[dut][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        # Log available keys for debugging\n        print(f\"Available keys in metrics: {metrics.keys()}\")\n        assert False, f\"Coverage data for '{dut}' is not available.\"\n"}}}
{"id": "cvdp_copilot_binary_search_tree_sorting_0025", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the given SystemVerilog testbench `bst_sort_tb` that contains a module `tb_bst_sorter` to validate the output for a binary search tree (BST) based sorting algorithm design `binary_search_tree_sort`. The design processes an array of unsigned integers with a parameterizable size, ARRAY_SIZE (number of elements in the array, will be greater than 0). The testbench should be for a design that sorts an input array in ascending order using the BST insertion and in-order traversal logic. The stimulus for testing the design is already provided and based on this given list of test cases, the testbench should be modified to add checkers that thoroughly test the module's capability to sort arrays of various sizes and data values correctly.\n\nA BST is a data structure where each node has a key, and its left child contains keys less than or equal to the node, while its right child contains keys greater than the node and thereby constructs a tree. The algorithm organizes the integers into a binary search tree and traverses the tree to produce a sorted output array.\n\n### Design Details\n\n**Parameterization**\n\n- **ARRAY_SIZE**: Specifies the number of elements in the input array.\n  - Default: 15\n- **DATA_WIDTH**: Specifies the bit-width of each array element.\n  - Default: 32\n\n**Functionality**\n\n- **Sorting Process**: \n  The design takes an unsorted array and constructs a binary search tree (BST). It then performs an in-order traversal of the tree to produce a sorted array. The sorting process is controlled using the `start` and `done` signals.\n\n   - For constructing a BST from an input array, each number in the array is processed one at a time. For each node comparison with the current node (the node to be traversed and checked for insertion of the new node), the algorithm decides whether to move left or right. If the chosen child pointer is NULL, it inserts the new key there, and if the child node already exists, the current node is updated to that child so the process can repeat until a NULL position is found.\n\n  - For traversing a previously constructed binary search tree (BST) and producing a sorted array as output, stack and stack pointer (sp) are used to efficiently manage the recursive in-order traversal of the tree. The traversal begins concurrently with both the left and right subtree of the root node, continues by processing and storing the current_node, and finally merges the left and right sub-tree with the keys from the left subtree at the lower index followed by the root node and then the keys from the right subtree.\n  \n- **Control Signals**: \n  - **start**: An active-high signal indicating the start of the sorting operation. When asserted, the sorting begins.\n  - **done**: An active-high signal that indicates the sorting operation has been completed. It is asserted after the sorting process is finished.\n  \n- **Array Processing**:\n  The input array, **data_in**, should remain unchanged once the sorting process begins. Any changes to the input during the sorting operation should not be considered.\n  \n**Inputs and Outputs**\n\n**Inputs:**\n\n- **clk**: Clock signal for synchronization. The design is synchronized to the positive edge of this clock.\n- **reset**: Active-high asynchronous reset.When asserted, it immediately resets all outputs to zero, including the **sorted_out** array and **done** signal.\n- **start**: Active-high signal for 1 clock cycle to initiate the sorting process.\n- **data_in [ARRAY_SIZE*DATA_WIDTH-1:0]**: The unsorted input array that will be sorted by the BST-based algorithm.\n\n**Outputs:**\n\n- **done**: Active-high signal for 1 clock cycle that indicates when the sorting operation is complete.\n- **sorted_out [ARRAY_SIZE*DATA_WIDTH-1:0]**: The sorted array output in ascending order, such that the smallest element is at index 0 and the largest element is at index ARRAY_SIZE.\n\n**Latency Analysis**\n\n- After the **start** signal is asserted, one clock cycle is required to transition to the state where the construction of the BST starts.\n\n- **Construction of BST from the given \u2018data_in\u2019**: The total latency for building the tree depends on the **ARRAY_SIZE** and involves multiple clock cycles for each insertion and comparison of nodes in the tree.\n\n - **In-order traversal of the constructed BST to sort the given \u2018data_in\u2019**: The latency for sorting is dependent on the depth of the tree and the traversal logic.\n\n- **Latency Scenarios**: In all the following scenarios, an additional one clock cycle is to be considered for handling the **start** signal and transitioning to BST construction.\n\n    - **Scenario 1: For an array with ARRAY_SIZE = 1**:\n**BST construction latency**: For any node, 2 * ARRAY_SIZE is the total latency for all nodes for initialization and insertion while constructing the BST. Additionally, Initialization and completion take an additional 2 clock cycles.  For a single node, ARRAY_SIZE=1, so BST construction latency is equal to 4.\n**In-order BST traversal and sorting latency**: The sorting operation for one node will involve initialization, processing the node, identifying that traversal is complete, and setting the **done** signal. This results in a latency of 4 clock cycles\n \n       Total Latency =  1 + 4 + 4 \n\n    - **Scenario 2: For a reverse-sorted array**:\n**BST construction latency**: The total latency involves inserting each node and traversing the tree to find the correct insertion position. For each node except the root, the depth of the node increases with each insertion. The total latency can be calculated as ((ARRAY_SIZE - 1) * ARRAY_SIZE)/2 + 2 * ARRAY_SIZE + 2 clock cycles for the BST construction.\n**In-order BST traversal and sorting latency**: In the case of reverse sorted arrays, only the left subtree is traversed, with each node in the left subtree taking 2 clock cycles: one for checking the node and one for checking its right child. The latency is then calculated as 4 + 2 * (ARRAY_SIZE - 1) where the additional four clock cycles are similar to the one in Scenario 1 for ARRAY_SIZE = 1.\n\n       Total Latency = 1 + (((ARRAY_SIZE - 1) * ARRAY_SIZE)/2 + 2 * ARRAY_SIZE + 2) + 2 * (ARRAY_SIZE - 1) + 4\n\n   - **Scenario 3: For a sorted array (ascending order)**:\n**BST construction latency**: The tree will still be built node-by-node, with each node being inserted at a depth determined by the current state of the tree. The total latency follows the same formula as for a reverse-sorted array, so the latency depends on the depth of the insertion.\n**In-order BST traversal and sorting latency**: In the case of sorted arrays, only the right subtree is traversed, with each node in the right subtree taking 2 clock cycles: one for checking the node and one for checking its left child. The latency is then calculated as 4 + 2 * (ARRAY_SIZE - 1) clock cycles for the in-order traversal of constructed BST similar to the reverse sorted array. Since the latency for constructing the tree and in-order traversal is similar for both sorted and reverse-sorted scenarios, then their total latency is also the same. \n\n### Testbench Requirements:\n\n**Instantiation**\n\n- **Module Instance**: The BST-based sorting module `binary_search_tree_sort` is already instantiated as `dut`, with all input and output signals connected for testing.\n\n**Device Under Test (DUT)**\n\n- BST-based sorting module `binary_search_tree_sort` has been configured with the parameters for `ARRAY_SIZE` and `DATA_WIDTH`.\n- DUT is connected to the testbench signals for clock, reset, control, and data handling.\n\n**Existing Input Generation**\n\n- **Array Generation**: The testbench generates multiple test cases with different values for **data_in**, including edge cases such as an array with the same elements, an already sorted array, and a reverse-sorted array.\n- **Clock Generation**: Generate a continuous clock with a period of 10 ns (100 MHz frequency).\n\n**Validation**\n- **Sorting Reference Model**: Modify the testbench to implement reference sorting of an array using a standard sorting algorithm that repeatedly scans the array, comparing each element with all subsequent elements and swapping them if they are out of order to arrange the numbers in ascending order and generate expected results for verification.\n\n**Control Signal Handling**:\n\n- The **start** signal has already been asserted to trigger the sorting process. The testbench must wait until the **done** signal is asserted ( to wait for the sorting to be completed) to validate the actual output against the expected one. \n- The new input **data_in** along with the start signal is asserted after the **done**  signal for the previous input array is asserted to high. This process is repeated to cover different sequences of input_data. \n- Testbench must validate the output and the latency once the **done** signal is asserted signaling that the sorting is completed.\n- The testbench should validate that the **sorted_out** array matches the expected sorted order of **data_in**.\n\n**Latency Validation**:\n\n- The testbench should verify the latency by counting the clock cycle right after the **start** signal is set and stop the count when the **done** signal is asserted. The number of clock cycles between the **start** and **done** signal is checked against the expected latency. Due to the complex nature of the `binary_search_tree_sort` design,  it is difficult to calculate latency for different input scenarios. The testbench must, therefore, restrict the expected latency calculation to only worst-case scenarios (arrays sorted in ascending and descending order). The expected latency must be calculated as a sum for both **BST construction** and **In-order traversal and sorting** and the additional one clock cycle after the **start** is asserted.\n\n## Simulation Control\n- Execute the test cases using procedural blocks, monitoring the process with appropriate delays and synchronization methods.\n- Use `$display` for logging results and `$error` for mismatches to facilitate debugging.\n\n## Test Procedure\n\n1. Initialization and Reset: Apply an initial reset to the DUT before starting the test sequence.\n2. Provide the given set of test cases as inputs to the design.\n  - Different sets of test cases include random values and worst-case scenarios such as input as a sorted array, reverse sorted array, and and duplicates.\n3. Execute the reference sorting implementation on the provided input array.\n4. The sorted output **sorted_out** must be checked for all of its indices against the calculated expected output from the reference sorting implementation after the **done** signal is asserted\n4. Validate the latency calculated against the expected latency only for the worst-case scenarios. \n\n## Deliverables\nModified the testbench that uses the provided tests and verifies the `binary_search_tree_sort` module's functionality to ensure it correctly sorts the given input array provided in the testcases.  ", "context": {"verif/bst_sort_tb.sv": "module tb_bst_sorter;\n\n    // Parameters\n    parameter DATA_WIDTH = 32;\n    parameter ARRAY_SIZE = 15;\n\n    // DUT Signals\n    logic clk;\n    logic reset;\n    logic start;\n    logic [ARRAY_SIZE*DATA_WIDTH-1:0] data_in;\n    logic done;\n    logic [ARRAY_SIZE*DATA_WIDTH-1:0] sorted_out;\n\n    // Instantiate DUT\n    binary_search_tree_sort #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .ARRAY_SIZE(ARRAY_SIZE)\n    ) dut (\n        .clk(clk),\n        .reset(reset),\n        .start(start),\n        .data_in(data_in),\n        .done(done),\n        .sorted_out(sorted_out)\n    );\n\n    // Clock generation\n    initial clk = 0;\n    always #5 clk = ~clk; // 10ns clock period\n\n    // Testbench Variables\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] input_array;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] expected_output;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] ordered_array;\n\n    // Reset Task\n    task reset_dut;\n        begin\n            reset = 1;\n            @(posedge clk);\n            @(posedge clk);\n            reset = 0;\n        end\n    endtask\n\n\n    // Sort Array (Reference Model)\n    task sort_array;\n        input reg [ARRAY_SIZE*DATA_WIDTH-1:0] input_array;\n        output reg [ARRAY_SIZE*DATA_WIDTH-1:0] sorted_array;\n        integer i, j;\n        reg [DATA_WIDTH-1:0] temp;\n        begin\n            sorted_array = input_array;\n            for (i = 0; i < ARRAY_SIZE; i++) begin\n                for (j = i + 1; j < ARRAY_SIZE; j++) begin\n                    if (sorted_array[i*DATA_WIDTH +: DATA_WIDTH] > sorted_array[j*DATA_WIDTH +: DATA_WIDTH]) begin\n                        temp = sorted_array[i*DATA_WIDTH +: DATA_WIDTH];\n                        sorted_array[i*DATA_WIDTH +: DATA_WIDTH] = sorted_array[j*DATA_WIDTH +: DATA_WIDTH];\n                        sorted_array[j*DATA_WIDTH +: DATA_WIDTH] = temp;\n                    end\n                end\n            end\n        end\n    endtask\n\n    // Test Procedure\n    task run_test;\n        input string test_name;\n        input reg [ARRAY_SIZE*DATA_WIDTH-1:0] test_data;\n        integer i;\n        integer cycle_count;\n        begin\n            $display(\"Running Test: %s\", test_name);\n\n            data_in = test_data; \n\n            // Wait for some time after one data_in is sorted to avoid start and \n            // done to be set at the same clock cycle\n            repeat(3) @(posedge clk);\n\n            // Start the sorting by setting start for one clock cycle\n            start = 1;\n            @(posedge clk);\n            start = 0;\n\n            // Wait until the array has been sorted - done signal is set\n            @(posedge done);\n\n            // Wait for some time\n            #10;\n\n            // For debugging\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                $display(\"test_data input:%d\",test_data[i*DATA_WIDTH +: DATA_WIDTH]);\n            end\n \n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                $display(\"actual output: %d\", sorted_out[i*DATA_WIDTH +: DATA_WIDTH]);\n            end\n\n        end\n    endtask\n\n    // Main Testbench Process\n    initial begin\n        integer i, j;\n        integer seed;\n        integer random_value;\n\n        // Initialize signals\n        reset = 0;\n        start = 0;\n        data_in = 0;\n\n        \n        // Reset DUT\n        reset_dut();\n\n        $display(\"ARRAY_SIZE:%d, DATA_WIDTH:%d\",ARRAY_SIZE, DATA_WIDTH );\n\n        // Test 1 - random values\n        for (i = 0; i < ARRAY_SIZE; i++) begin\n            input_array[i*DATA_WIDTH +: DATA_WIDTH] = $urandom_range(0, 2**(DATA_WIDTH)-1);  \n        end\n\n        run_test(\"Test case 1\", input_array);\n\n        // Test 2: Skewed tree  \n        for (i = 0; i < ARRAY_SIZE; i++) begin\n            input_array[i*DATA_WIDTH +: DATA_WIDTH] = $urandom_range(0, 2**(DATA_WIDTH)-1);  \n        end\n\n        // Sort the array to be constructed as Skewed tree\n        sort_array(input_array, ordered_array);\n\n        run_test(\"Test case 2\", ordered_array);\n\n        // Test 3: Skewed tree\n        for (i = 0; i < ARRAY_SIZE; i++) begin\n            input_array[i*DATA_WIDTH +: DATA_WIDTH] = $urandom_range(0, 2**(DATA_WIDTH)-1);  \n        end\n\n        // Sort the array to be constructed as Skewed tree\n        sort_array(input_array, ordered_array);\n\n        // Reverse the sorting process\n        for (i = 0; i < ARRAY_SIZE; i++) begin\n            input_array[i*DATA_WIDTH +: DATA_WIDTH] = ordered_array[(ARRAY_SIZE - i - 1)*DATA_WIDTH +: DATA_WIDTH];\n        end\n\n        run_test(\"Test case 3\", input_array);\n     \n\n        // Test 4: Duplicates\n        random_value = $urandom_range(0, 2**(DATA_WIDTH)-1);  \n        for (i = 0; i < ARRAY_SIZE; i++) begin\n            input_array[i*DATA_WIDTH +: DATA_WIDTH] = random_value;  \n        end\n\n        run_test(\"Test case 4\", input_array);\n\n        // Test 5 set: Random values\n        for (j = 0; j < 50; j++) begin\n\n            for (i = 0; i < ARRAY_SIZE; i++) begin\n                input_array[i*DATA_WIDTH +: DATA_WIDTH] = $urandom_range(0, 2**(DATA_WIDTH)-1);  \n            end\n\n            run_test(\"Test case set 5\", input_array);\n        end\n\n        reset_dut();\n        #10;\n\n        // Test 6: min/max alternating values\n        for (i = 0; i < ARRAY_SIZE; i++) begin\n            input_array[i*DATA_WIDTH +: DATA_WIDTH] = (i % 2 == 0) ? 0 : (1 << DATA_WIDTH) - 1;  \n        end\n        run_test(\"Test case 6\", input_array);\n\n        // Test 7: max values\n        for (i = 0; i < ARRAY_SIZE; i++) begin\n            input_array[i*DATA_WIDTH +: DATA_WIDTH] = 2**(DATA_WIDTH)-1;  \n        end\n        run_test(\"Test case 7\", input_array);\n\n        // Test 8: all zeros\n        for (i = 0; i < ARRAY_SIZE; i++) begin\n            input_array[i*DATA_WIDTH +: DATA_WIDTH] = 0;  \n        end\n        run_test(\"Test case 8\", input_array);\n\n        // Test 9: root as max/2 and above\n        random_value = $urandom_range(2**(DATA_WIDTH)/2, 2**(DATA_WIDTH)-1);\n        input_array[0*DATA_WIDTH +: DATA_WIDTH] = random_value; \n        for (i = 1; i < ARRAY_SIZE; i++) begin\n            input_array[i*DATA_WIDTH +: DATA_WIDTH] = $urandom_range(0, random_value);  \n        end\n        run_test(\"Test case 9\", input_array);\n\n        // Test 10 : root as max/2 and below\n        random_value = $urandom_range(0, 2**(DATA_WIDTH)/2); \n        input_array[0*DATA_WIDTH +: DATA_WIDTH] = random_value;\n        for (i = 1; i < ARRAY_SIZE; i++) begin\n            input_array[i*DATA_WIDTH +: DATA_WIDTH] = $urandom_range(random_value, 2**(DATA_WIDTH)-1);  \n        end\n        run_test(\"Test case 10\", input_array);\n\n        $display(\"All Tests Completed.\");\n        $finish;\n    end\n\n    // -------------------------------------------------------------------------\n    // Dump waveforms to a file for analysis\n    // Generate a VCD (Value Change Dump) file named \"test.vcd\" for post-simulation analysis.\n    // The dumpvars command tracks all signals in the simulation.\n    // -------------------------------------------------------------------------\n    initial begin\n        $dumpfile(\"test.vcd\");          \n        $dumpvars(0, tb_bst_sorter); \n    end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/bst_sort_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 25-tb-checker-binary-search-tree-sort\nNUM_BUGS        = 3", "src/binary_search_tree_sort.sv": "module binary_search_tree_sort #(\n    parameter DATA_WIDTH = 32,\n    parameter ARRAY_SIZE = 15\n) (\n    input clk,\n    input reset,\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in, // Input data to be sorted\n    input start,\n    output reg [ARRAY_SIZE*DATA_WIDTH-1:0] sorted_out, // Sorted output\n    output reg done\n);\n\n    // Parameters for top-level FSM states\n    parameter IDLE = 2'b00, BUILD_TREE = 2'b01, SORT_TREE = 2'b10;\n\n    // Parameters for nested FSM states (Build Tree)\n    parameter INIT = 2'b00, INSERT = 2'b01, TRAVERSE = 2'b10, COMPLETE = 2'b11;\n\n    // Parameters for nested FSM states (Sort Tree)\n    parameter S_INIT = 2'b00, S_SORT_LEFT_RIGHT = 2'b01, S_MERGE_RESULTS = 2'b10;\n    // Registers for FSM states\n    reg [1:0] top_state, build_state, sort_state;\n\n    // BST representation\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in_copy;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys; // Array to store node keys\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child; // Left child pointers\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child; // Right child pointers\n    reg [$clog2(ARRAY_SIZE):0] root; // Root node pointer\n    reg [$clog2(ARRAY_SIZE)-1:0] next_free_node; // Pointer to the next free node\n\n    // Working registers\n    reg [$clog2(ARRAY_SIZE)-1:0] current_node; // Current node being processed\n    reg [$clog2(ARRAY_SIZE):0] input_index; // Index for input data\n    reg [DATA_WIDTH-1:0] temp_data; // Temporary data register\n\n    // Intermediate buffers for storing sorted values of left and right subtrees\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] left_sorted;  // Buffer for left subtree sorted values\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] right_sorted; // Buffer for right subtree sorted values\n\n    // Stack and pointers for left and right subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_stack; // Stack for left subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_stack; // Stack for right subtree traversal\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_left; // Stack pointer for left subtree\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_right; // Stack pointer for right subtree\n\n    // Current node pointers for left and right subtrees\n    reg [$clog2(ARRAY_SIZE):0] current_left_node; // Current node in left subtree\n    reg [$clog2(ARRAY_SIZE):0] current_right_node; // Current node in right subtree\n\n    // Flags to indicate when sorting of left and right subtrees is done\n    reg left_done; // Flag for completion of left subtree sorting\n    reg right_done; // Flag for completion of right subtree sorting\n\n    // Output indices for left and right subtree buffers\n    reg [$clog2(ARRAY_SIZE)-1:0] left_output_index; // Output index for left_sorted buffer\n    reg [$clog2(ARRAY_SIZE)-1:0] right_output_index; // Output index for right_sorted buffer\n\n    // Initialize all variables\n    integer i, j;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all states and variables\n            top_state <= IDLE;\n            build_state <= INIT;\n            sort_state <= S_INIT;\n            root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; ; // Null pointer\n            next_free_node <= 0;\n            input_index <= 0;\n            done <= 0;\n\n            // Clear tree arrays\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                left_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                right_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n            end\n\n        end \n        else begin\n            case (top_state)\n                IDLE: begin\n                    done <= 0;\n                    input_index <= 0;\n                    root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; ; // Null pointer\n                    next_free_node <= 0;\n                    for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                        keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                        right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        left_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        right_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                    end\n                    if (start) begin\n                        // Load input data into input array\n                        top_state <= BUILD_TREE;\n                        build_state <= INIT;\n                        data_in_copy <= data_in;\n                    end\n                end\n\n                BUILD_TREE: begin\n                    case (build_state)\n                        INIT: begin\n                            if (input_index < ARRAY_SIZE) begin\n                                temp_data <= data_in_copy[input_index*DATA_WIDTH +: DATA_WIDTH]; \n                                input_index <= input_index + 1;\n                                build_state <= INSERT;\n                            end else begin\n                                build_state <= COMPLETE;\n                            end\n                        end\n\n                        INSERT: begin\n                            if (root == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                // Tree is empty, insert at root\n                                root <= next_free_node;\n                                keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                next_free_node <= next_free_node + 1; \n                                build_state <= INIT;\n                            end else begin\n                                // Traverse the tree to find the correct position\n                                current_node <= root; \n                                build_state <= TRAVERSE;\n                            end\n                        end\n\n                        TRAVERSE: begin      \n                            if ((temp_data < keys[current_node*DATA_WIDTH +: DATA_WIDTH]) || (temp_data == keys[current_node*DATA_WIDTH +: DATA_WIDTH])) begin\n                                if (left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                    left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                                    `ifndef BUG_0\n                                        keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                    `else\n                                        keys[current_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                    `endif\n                                    next_free_node <= next_free_node + 1;\n                                    build_state <= INIT;\n                                end else begin\n                                    current_node <= left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                                end\n                            end else begin\n                                if (right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                    right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                                    keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data; \n                                    // Transition to merging once both left and right sorting are done\n                                    next_free_node <= next_free_node + 1;\n                                    build_state <= INIT;\n                                end else begin\n                                    current_node <= right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                                end\n                            end\n                        end\n\n                        COMPLETE: begin\n                            // Tree construction complete\n                            top_state <= SORT_TREE;\n                            sort_state <= S_INIT;\n                        end\n\n                    endcase\n                end\n\n                SORT_TREE: begin\n                    case (sort_state)\n                        S_INIT: begin\n                            // Start parallel sorting for left and right subtrees\n                            left_output_index <= 0;\n                            right_output_index <= 0;\n                            sp_left <= 0;\n                            sp_right <= 0;\n                            left_done <= 0;\n                            right_done <= 0;\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            current_right_node <= right_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            sort_state <= S_SORT_LEFT_RIGHT;\n                        end\n\n                        S_SORT_LEFT_RIGHT: begin\n                            // Sort left subtree in parallel\n                            if (!left_done && current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                                sp_left <= sp_left + 1;\n                                current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!left_done && sp_left > 0) begin\n                                sp_left <= sp_left - 1;\n                                current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                left_sorted[left_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH];\n                                left_output_index <= left_output_index + 1;\n                                current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!left_done) begin\n                                left_done <= 1;\n                            end\n\n                            // Sort right subtree in parallel\n                            if (!right_done && current_right_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                right_stack[sp_right*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_right_node;\n                                sp_right <= sp_right + 1;\n                                current_right_node <= left_child[current_right_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!right_done && sp_right > 0) begin\n                                sp_right <= sp_right - 1;\n                                current_right_node <= right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                right_sorted[right_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH];\n                                right_output_index <= right_output_index + 1;\n                                current_right_node <= right_child[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!right_done) begin\n                                right_done <= 1;\n                            end\n\n\n                            // Transition to merging once both left and right sorting are done\n                            `ifndef BUG_1\n                                if (left_done && right_done) begin\n                                    sort_state <= S_MERGE_RESULTS;\n                                end\n                            `else\n                               if (left_done || right_done) begin\n                                   sort_state <= S_MERGE_RESULTS;\n                               end\n                            `endif\n                        end\n\n                        S_MERGE_RESULTS: begin\n\n                            // Merge left_sorted, root, and right_sorted into final sorted output\n                            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                                if (i < left_output_index) begin\n                                    sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= left_sorted[i*DATA_WIDTH +: DATA_WIDTH];\n                                end\n                            end\n\n                            `ifndef BUG_2\n                                 // Insert the root into `sorted_out`\n                                sorted_out[left_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[root*DATA_WIDTH +: DATA_WIDTH];\n                            `else\n                                // Insert the root into `sorted_out`\n                                sorted_out[left_output_index*DATA_WIDTH +: DATA_WIDTH] <= root;\n                            `endif\n\n                            // Copy `right_sorted` into `sorted_out`\n                            for (j = 0; j < ARRAY_SIZE; j = j + 1) begin\n                                if (j < right_output_index) begin\n                                    sorted_out[(left_output_index + 1 + j)*DATA_WIDTH +: DATA_WIDTH] <= right_sorted[j*DATA_WIDTH +: DATA_WIDTH];\n                                end\n                            end\n\n                            done <= 1; // Sorting complete\n                            top_state <= IDLE;\n\n                        end\n\n                        default: begin\n                            sort_state <= S_INIT; // Reset to initial sort state\n                        end\n                    endcase\n                end\n\n                default: begin\n                    top_state <= IDLE; // Default behavior for top-level FSM\n                end\n                \n            endcase\n        end\n    end\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/binary_search_tree_sort.sv /code/verif/bst_sort_tb.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_binary_search_tree_sorting_0030", "categories": ["cid012", "medium"], "input": {"prompt": "Implement a System Verilog testbench named `binary_search_tree_search_node_tb` to generate stimuli for a `search_binary_search_tree` module that performs a search for a given key in a binary search tree (BST). \n\n## Design Specification:\n\nThe BST is a structure formed where each node contains a key, with its `left_child` containing `keys` less than or equal to the node, and its `right_child` containing `keys` greater than the node. The module locates the position of the `search_key` in the array sorted with the constructed BST. The position where the `search_key` is located is based on its **position in the sorted array** (sorted such that the smallest element is at index 0 and the largest element is at index `ARRAY_SIZE`-1). The array is not sorted in this module. However, the BST is constructed in a way that traversing to the nodes results in a sorted array. The module doesn't wait for the complete BST to be traversed. As soon as the `search_key` is found and its position is located, the module stops its search and transitions to the final state. \n\n**Parameterization**\n\n- **ARRAY_SIZE**: Specifies the number of elements in the input array.\n  - Default: 15\n- **DATA_WIDTH**: Specifies the bit-width of each array element.\n  - Default: 16\n\n### Inputs:\n- `[ARRAY_SIZE*DATA_WIDTH-1:0] keys`: A packed array containing the node values of the BST.\n- `[ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child`: A packed array containing the left child pointers for each node in the BST.\n- `[ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child`: A packed array containing the right child pointers for each node in the BST.\n- `[$clog2(ARRAY_SIZE):0] root`: The index of the root node (always 0 except for an empty BST, assuming the BST is constructed such that the first element in the arrays corresponds to the root node).  For an empty BST, `root` is assigned an invalid index where all bits are set to 1; Eg: 15 (for ARRAY_SIZE = 7) \n- `[DATA_WIDTH-1:0] search_key`: The key to search for in the BST.\n- `start`: 1-Bit active high signal to initiate the search (1 clock cycle in duration).\n- `clk`: Clock Signal. The design is synchronized to the positive edge of this clock.\n- `reset`: Asynchronous active high reset to reset all control signal outputs to zero and `key_position` to null pointer (all 1s).\n\n### Outputs\n- `[$clog2(ARRAY_SIZE):0] key_position`: The position of the `search_key` in the BST with respect to its sorted position. Updated at the same time when the `complete_found` is asserted.  If the `search_key` is not found in the constructed BST or if the tree is empty (indicated by all entries in `left_child`, `right_child` being null pointers, and all `keys` being zero) the module sets all the bits of `key_position` to 1 (null position)\n- `complete_found`: 1-Bit active high signal that is asserted once the search is complete, indicating that the key was found (1 clock cycle in duration). If the `search_key` is not found in the constructed BST or if the tree is empty `complete_found` remains at 0.\n- `search_invalid`: 1-bit Active high signal that is asserted when the BST is empty or when the `search_key` doesn't exist in the given BST (1 clock cycle in duration). \n\n### Testbench Requirements:\n\n**Instantiation**\n\n- **Module Instance**: The module `search_binary_search_tree` should be instantiated as `dut`, with all input and output signals connected for testing.\n\n**Input Generation**\n\n- **BST Generation**: \n    - The testbench must generate multiple test cases with different random values for `keys`, `left_child`, and `right_child` which abides by the structure of the BST where each node contains a key, with its `left_child` containing `keys` less than the node, and its `right_child` containing `keys` greater than the node. \n    - To accurately construct a BST including `keys`, `left_child`, and `right_child`, create a separate submodule that generates different BSTs based on the input array provided. \n    - To generate a BST, different input arrays can be provided as input to the new submodule responsible for constructing the BST.\n    - Test with all possible combinations to achieve maximum coverage. Include the corner cases, such as input arrays with all values equal and already sorted arrays in ascending or descending order.\n    - Testbench must also include a scenario with an empty tree where all bits of `root`, `left_child`, and `right_child` are set to one, and `keys` are set to 0.\n \n- **Search Key (`search_key`) Generation**: \n    - The testbench must generate different random values of `search_key` where the random values generated must be one of the values in the `keys` for a given BST input. To be able to traverse the tree in worst-case scenarios, tests should include `search_key` generation for the smallest, largest value in the given BST. \n    - To handle the invalid case (`search_invalid`), the testbench must generate `search_key`, which is not present within the given BST. \n  \n**Control Signal Handling**:\n\n- The `start` signal should be asserted to trigger the searching process, and the testbench must wait until the `complete_found` signal is asserted (to wait for the searching to be completed) when the search is valid or wait until the `search_invalid` is asserted when the `search_key` is not found within the tree or when the tree is empty. \n- The new inputs `keys`, `left_child`,  `right_child`, and `search_key`  along with the `start` signal must only be asserted after the `complete_found` or `search_invalid` signal for the previous input array is asserted to high. This process must be repeated to cover different sequences of input array, which means different BSTs will be generated. It must be noted that while the `complete_found` or `search_invalid` signal is high, the new input `keys`, `left_child`, `right_child`, `search_key`, and `start` must not be asserted to avoid loss of `start` and new inputs. ", "context": {}}, "output": {"response": "", "context": {"verif/binary_search_tree_search_node_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 30-tb-stimulus-search-node-in-binary-search-tree\nTARGET = 96\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/search_binary_search_tree.sv /code/verif/binary_search_tree_search_node_tb.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/search_binary_search_tree.sv": "module search_binary_search_tree #(\n    parameter DATA_WIDTH = 16,         // Width of the data\n    parameter ARRAY_SIZE = 15          // Maximum number of elements in the BST\n) (\n\n    input clk,                         // Clock signal\n    input reset,                       // Reset signal\n    input reg start,                   // Start signal to initiate the search\n    input reg [DATA_WIDTH-1:0] search_key, // Key to search in the BST\n    input reg [$clog2(ARRAY_SIZE):0] root, // Root node of the BST\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys, // Node keys in the BST\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child, // Left child pointers\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child, // Right child pointers\n    output reg [$clog2(ARRAY_SIZE):0] key_position, // Position of the found key\n    output reg complete_found,         // Signal indicating search completion\n    output reg search_invalid\n);\n                                                                                                                                        \n    // Parameters for FSM states\n    parameter S_IDLE = 3'b000,                 // Idle state\n              S_INIT = 3'b001,                 // Initialization state\n              S_SEARCH_LEFT = 3'b010,          // Search in left subtree\n              S_SEARCH_LEFT_RIGHT = 3'b011,    // Search in both left and right subtrees\n              S_COMPLETE_SEARCH = 3'b100;      // Search completion state\n   \n    // Registers to store the current FSM state\n    reg [2:0] search_state;\n\n    // Variables to manage traversal\n    reg [$clog2(ARRAY_SIZE):0] position;       // Position of the current node\n    reg found;                                 // Indicates if the key is found\n\n    reg left_done, right_done;                 // Flags to indicate completion of left and right subtree traversals\n\n    // Stacks for managing traversal of left and right subtrees\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_stack;  // Stack for left subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_stack; // Stack for right subtree traversal\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_left;         // Stack pointer for left subtree\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_right;        // Stack pointer for right subtree\n\n    // Pointers for the current nodes in left and right subtrees\n    reg [$clog2(ARRAY_SIZE):0] current_left_node;  // Current node in the left subtree\n    reg [$clog2(ARRAY_SIZE):0] current_right_node; // Current node in the right subtree\n\n    // Output indices for traversal\n    reg [$clog2(ARRAY_SIZE)-1:0] left_output_index;  // Output index for left subtree\n    reg [$clog2(ARRAY_SIZE)-1:0] right_output_index; // Output index for right subtree\n\n    // Integer for loop iterations\n    integer i;\n\n    // Always block triggered on the rising edge of the clock or reset signal\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all states and variables\n            search_state <= S_IDLE;  // Set state to IDLE\n            found <= 0;              // Reset found flag\n            position <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Invalid position\n            complete_found <= 0;     // Reset complete_found signal\n            key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Invalid key position\n            left_output_index <= 0;  // Reset left output index\n            right_output_index <= 0; // Reset right output index\n            sp_left <= 0;            // Reset left stack pointer\n            sp_right <= 0;           // Reset right stack pointer\n            left_done <= 0;          // Reset left_done flag\n            right_done <= 0;         // Reset right_done flag\n            search_state <= S_IDLE;  // Set state to IDLE\n            search_invalid <= 0;        // Set invalid_key to 0\n            \n            // Clear the stacks\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n            end\n\n        end else begin\n            // Main FSM logic\n            case (search_state)\n                S_IDLE: begin\n                    // Reset intermediate variables\n                    for (i = 0; i < ARRAY_SIZE+1; i = i + 1) begin\n                        left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                    end\n                    complete_found <= 0;\n                    search_invalid <= 0;\n\n                    if (start) begin\n                        // Start the search\n                        left_output_index <= 0;\n                        right_output_index <= 0;\n                        sp_left <= 0;\n                        sp_right <= 0;\n                        left_done <= 0;\n                        right_done <= 0;\n                        found <= 0;\n                        position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        search_state <= S_INIT; // Move to INIT state\n                        $display(\"ROOT NODE: %0h\", root);\n                    end\n                end\n\n                S_INIT: begin\n                    if (root != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        // Compare the search key with the root key\n                        if (search_key == keys[root*DATA_WIDTH +: DATA_WIDTH]) begin\n                            found <= 1;\n                            if (left_child[0*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                position <= 0;\n                                search_state <= S_COMPLETE_SEARCH; // Move to complete search state\n                            end else begin\n                                search_state <= S_SEARCH_LEFT; // Search in the left subtree\n                                current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end\n                        end else if (keys[0*DATA_WIDTH +: DATA_WIDTH] > search_key) begin\n                            search_state <= S_SEARCH_LEFT;\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else begin\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            current_right_node <= right_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            search_state <= S_SEARCH_LEFT_RIGHT; // Search in both left and right subtrees\n                        end\n                    end else begin\n                        search_state <= S_COMPLETE_SEARCH; // Root is null\n                    end\n                end\n\n                S_SEARCH_LEFT: begin\n                    // Traverse the left subtree\n                    if (current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                        sp_left <= sp_left + 1;\n                        current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (sp_left > 0) begin\n                        sp_left <= sp_left - 1;\n                        current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        if (search_key == keys[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]) begin\n                            found <= 1;\n                            position <= left_output_index;   \n                            search_state <= S_COMPLETE_SEARCH; // Move to complete search state\n                        end\n                        left_output_index <= left_output_index + 1;\n                        current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else begin //if (!left_done) begin\n                        if (found == 1) begin\n                            position <= left_output_index;\n                        end \n                        left_done <= 1;\n                        search_state <= S_COMPLETE_SEARCH;\n                    end\n                end\n\n                S_SEARCH_LEFT_RIGHT: begin\n                    // Traverse both left and right subtrees\n                    if (!left_done && current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                        sp_left <= sp_left + 1;\n                        current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done && sp_left > 0) begin\n                        sp_left <= sp_left - 1;\n                        current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        left_output_index <= left_output_index + 1;\n                        current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done) begin\n                        left_done <= 1;\n                    end\n\n                    if (!found) begin\n                        if (!right_done && current_right_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                            right_stack[sp_right*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_right_node;\n                            sp_right <= sp_right + 1;\n                            current_right_node <= left_child[current_right_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else if (!right_done && sp_right > 0) begin\n                            sp_right <= sp_right - 1;\n                            current_right_node <= right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                if (search_key == keys[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]) begin\n                                    found <= 1;\n                                end\n                            right_output_index <= right_output_index + 1;\n                            current_right_node <= right_child[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else if (!right_done) begin\n                            right_done <= 1;\n                        end\n\n                    end else if (left_done) begin\n                        position <= left_output_index + right_output_index;\n                        search_state <= S_COMPLETE_SEARCH;  \n                    end\n\n                    if (right_done && left_done && !found) begin\n                        search_state <= S_COMPLETE_SEARCH;\n                    end\n                end\n\n                S_COMPLETE_SEARCH: begin\n                    // Complete the search\n                    if (!found) begin\n                        complete_found <= 0;\n                        key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        search_invalid <= 1;\n                    end else begin\n                        complete_found  <= 1;\n                        key_position <= position;\n                        search_invalid <= 0;\n                    end\n                    search_state <= S_IDLE; // Return to IDLE state\n                end\n\n                default: begin\n                    search_state <= S_IDLE; // Default to IDLE state\n                end\n            endcase\n        end\n    end\n\nendmodule\n"}}}
{"id": "cvdp_copilot_binary_search_tree_sorting_0032", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the System Verilog testbench named `binary_search_tree_search_node_tb` to implement a checker that validates output for a `search_binary_search_tree` module that performs a search for a given key in a binary search tree (BST). The stimulus is already provided and the task is to implement checker logic to validate the correctness of the output of the given stimulus.\n\n## Design Specification:\n\nThe BST is a structure formed where each node contains a key, with its `left_child` containing `keys` less than or equal to the node, and its `right_child` containing `keys` greater than the node. The module should locate the position of the `search_key` in the array sorted with the constructed BST. The position where the `search_key` is located is based on its **position in the sorted array** (sorted such that the smallest element is at index 0 and the largest element is at index `ARRAY_SIZE`-1). For duplicate keys, the position of the duplicated key present at the lowest index of the sorted array is returned. The array is not sorted in this module. However, the BST is constructed in a way that traversing to the nodes results in a sorted array. The module doesn't wait for the complete BST to be traversed. As soon as the `search_key` is found and its position is located, the module stops its search and transitions to the final state. \n\n**Parameterization**\n\n- **ARRAY_SIZE**: Specifies the number of elements in the input array.\n  - Default: 15\n- **DATA_WIDTH**: Specifies the bit-width of each array element.\n  - Default: 16\n\n### Inputs:\n- `[ARRAY_SIZE*DATA_WIDTH-1:0] keys`: A packed array containing the node values of the BST.\n- `[ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child`: A packed array containing the left child pointers for each node in the BST.\n- `[ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child`: A packed array containing the right child pointers for each node in the BST.\n- `[$clog2(ARRAY_SIZE):0] root`: The index of the root node (always 0 except for an empty BST, assuming the BST is constructed such that the first element in the arrays corresponds to the root node). For an empty BST, `root` is assigned an invalid index where all bits are set to 1; Eg: 15 (for ARRAY_SIZE = 7) \n- `[DATA_WIDTH-1:0] search_key`: The key to search for in the BST.\n- `start`: 1-Bit active high signal to initiate the search (1 clock cycle in duration).\n- `clk`: Clock signal. The design is synchronized to the positive edge of this clock.\n- `reset`: Asynchronous active high reset to reset all control signal outputs to zero and `key_position` to null pointer (all 1s).\n\n### Outputs\n- `[$clog2(ARRAY_SIZE):0] key_position`: The position of the `search_key` in the BST with respect to its sorted position. Updated at the same time when the `complete_found` is asserted. If the `search_key` is not found in the constructed BST or if the tree is empty (indicated by all entries in `left_child`, `right_child` being null pointers, and all `keys` being zero) the module sets all the bits of `key_position` to 1 (null position). Value is held stable until the next search starts and is reset to the null pointer when `start` is asserted until the new search operation is complete.\n- `complete_found`: 1-Bit active high signal that is asserted once the search is complete, indicating that the key was found (1 clock cycle in duration). If the `search_key` is not found in the constructed BST or if the tree is empty `complete_found` remains at 0.\n- `search_invalid`: 1-Bit active high signal that is asserted when the BST is empty or when the `search_key` doesn't exist in the given BST (1 clock cycle in duration). \n\n**FSM (Finite State Machine) Design**:\nThe search process is controlled by an FSM with the following states:\n\n1. **S_IDLE**: The system resets intermediate variables and the outputs (`complete_found`, `key_position`, `search_invalid`) and waits for the `start` signal. \n2. **S_INIT**: The search begins by comparing the `search_key` with the root node and decides the direction of traversal (left or right). The FSM progresses correctly based on the comparison of the `search_key` with the `root` node in the BST, updating the traversal direction accordingly or stopping if there exists no left sub-tree and if the key at `root` = `search_key`.\n3. **S_SEARCH_LEFT**: The FSM traverses the left subtree if the `search_key` is less than the `root` node.\n4. **S_SEARCH_LEFT_RIGHT**: The FSM traverses both left and right subtrees if the `search_key` is greater than the `root` node.\n5. **S_COMPLETE_SEARCH**: The FSM outputs the signals `complete_found`, `key_position`, and  `search_invalid`. Thus, asserts the correct output based on whether the `search_key` is found. \n\n**Search Process**:\n- If the `search_key` is less than the current node\u2019s key, the FSM moves to the left child (**S_SEARCH_LEFT**).\n- If the `search_key` is greater than the current node\u2019s key, the FSM moves to the right child (**S_SEARCH_LEFT_RIGHT**).\n- If the `search_key` equals the `root` node\u2019s key, the search is complete. However to find the `key_position`, it is required to traverse through the left sub-tree if it exists. \n- If while traversing the left sub-tree, the `search_key` is found, the traversing is stopped and the `key_position` is updated. However, for the right sub-tree, traversing for both the left sub-tree needs to be completed as the position of the left sub-tree is required to find the position of the key found in the right sub-tree.\n- If the `search_key` is not found within the expected latency (i.e., the search does not complete after traversing the entire tree), the `complete_found` signal should not be asserted, indicating the key is not present, and `search_invalid` should be set to 1. \n- When the tree is empty (all zero `keys` and all 1s in `left_child` and `right_child`), the module should detect that the tree has no valid root and not proceed with traversal. `search_invalid` should be set to 1 in 3 clock cycles from the assertion of `start`.\n\n**Latency Analysis**:\n- The latency for the search depends on the depth of the tree. In the worst case, the FSM will traverse the depth of the tree. Additionally, it takes 2 clock cycles in the **S_INIT** and **S_COMPLETE_SEARCH** states.\n\n- Example 1 (Right-skewed tree):\n    -  **Largest node**: The worst case scenario is for searching the largest node in the right-skewed tree (BST with no left sub-tree and all the elements are present in the right sub-tree. Each node only has a right child). The design traverses the entire depth of the tree (`ARRAY_SIZE`) until a child of a node does not exist (until the largest key is reached) and re-traverses the depth of the tree again until the key of the node matches the `search_key` to update the `key_position`. This leads to a latency of `ARRAY_SIZE` * 2 number of clock cycles. Additionally, it takes 2 clock cycles in the **S_INIT** and **S_COMPLETE_SEARCH** states. So total latency is `ARRAY_SIZE` * 2 + 2.\n    -  **Smallest node**: Searching for the smallest node in the right-skewed tree is a simple scenario as the smallest node is the root node and it takes 3 clock cycles to move to the **S_INIT**, check if the `search_key`= root and move to the **S_COMPLETE_SEARCH** state to set the control signals. \n\n- Example 2 (Left-skewed tree): \n    - **Largest node**: The largest node in the left-skewed tree (a tree where each node only has a left child) is the root node. The total latency in searching for the largest nodes involves traversing up to the depth and retraversing back to the root node which takes `ARRAY_SIZE` * 2 clock cycles. Additionally, it takes 2 clock cycles in the **S_INIT** and **S_COMPLETE_SEARCH** states. So total latency is `ARRAY_SIZE` * 2 + 2.\n    - **Smallest node**: If the `search_key` matches the smallest node in the left skewed tree (BST with no right sub-tree and all the elements are present in the left sub-tree). The latency for all keys to be traversed once until the depth of the left sub-tree (until the smallest key) is equal to `ARRAY_SIZE`. The process is then stopped and the `key_position` is updated for the smallest key which takes 1 more clock cycle. Similar to other cases, it takes 2 clock cycles in the **S_INIT** and **S_COMPLETE_SEARCH** states. So total latency is `ARRAY_SIZE` + 1 + 2.\n\n- Example 3 (Empty tree or tree with only root node present):\n    -  An empty tree or a tree with only a root node present takes approx 3 clock cycles to move to the **S_INIT**, check if the `search_key` is equal to the key of the root or if the tree is empty, and move to the **S_COMPLETE_SEARCH** state to set the control signals. \n\n## Testbench Requirements:\n\n### Instantiation\n\n- **Module Instance**: The module `search_binary_search_tree` is already instantiated as `dut` in the given testbench, with all input and output signals connected for testing.\n\n### Existing Input Generation\n\n- **BST Generation**: \n  - The testbench already contains stimulus that generates multiple BSTs with random `keys`, `left_child`, and `right_child`, ensuring a valid BST structure.  \n  - It covers various cases, including:  \n     - All values equal  \n     - Sorted arrays (ascending/descending)  \n     - An empty tree where `root`, `left_child`, and `right_child` are set to one, and `keys` are zero  \n\n- **Search Key (`search_key`) Generation**: \n  - The testbench also has logic for random selection of `search_key` from the BST\u2019s `keys`, including worst-case scenarios (smallest/largest values).  \n  - An invalid `search_key` is generated to test scenarios where the value is absent from the BST.  \n\n- **Control Signal Handling**:\n  - The `start` signal triggers the search, and the testbench waits for either:  \n     - `complete_found` (valid search)  \n     - `search_invalid` (key not found or empty tree)  \n  - New inputs are asserted only after the previous search completes, ensuring sequential execution.  \n\n### Output Validation: \n\nThe testbench should be updated to add the following checker logic.\n\n - **Validating assertion of Control signals**:  The assertion of the control signals `complete_found` and `search_invalid` should be validated. Check if for a valid `search_key`, `complete_found` = 1 and `search_invalid` = 0, and for an invalid `search_key`, `search_invalid` = 1 and `complete_found` = 0. \n \n - **Sorting Reference Model**: Use the reference model `sort_array` that sorts a given array. After the input array is sorted, match each element of the sorted array against the `search_key` to find the position of the `search_key` in the sorted array which should be validated against the `key_position` generated from the design.  \n\n### Latency Validation:\n\n- The testbench should verify the latency by counting the clock cycle right after the `start` signal is set and stop the count when either the `complete_found` signal or the `search_invalid` signal is asserted. The number of clock cycles between the `start` and `complete_found` or `search_invalid` signals should be checked against the expected latency. Due to the complex nature of the `search_binary_search_tree` design, it is difficult to calculate latency for different input scenarios. The testbench must, therefore, restrict the expected latency calculation to only some simple and worst-case scenarios (where BST is for right and left skewed trees, empty tree, a tree with only a root node and the keys to be searched (`search_key`) should only be the largest and the smallest value for that BST). The expected latency for these scenarios should be calculated as per the analysis mentioned in the section **Latency Analysis**\n\n-----\n\n### Simulation Control\n- Execute the test cases using procedural blocks, monitoring the process with appropriate delays and synchronization methods.\n- Use `$display` for logging results and `$error` for mismatches to facilitate debugging.\n\n### Test Procedure\n\n1. Initialization and Reset: An initial reset to the DUT before starting the test sequence is already applied.\n2. Provide the given set of test cases as inputs to the design.\n3. Use the reference sorting implementation on the provided `search_key` and the **BST** to find out if the `search_key` is present and, if yes, the position where the `search_key` is located based on its **position in the sorted array**\n4. For a non-existing `search_key` in the BST, check if the `search_invalid` is set to 1 and the `complete_found` is set to 0. \n5. Validate the latency calculated against the expected latency only for the above-mentioned scenarios. \n\n## Deliverables\nProvide a **complete SystemVerilog testbench** that effectively uses the existing testcases and includes logic that verifies the `search_binary_search_tree` module's functionality to ensure it correctly sorts the given input array provided in the test cases. ", "context": {"verif/binary_search_tree_search_node_tb.sv": "module binary_search_tree_search_node_tb;\n\n    parameter DATA_WIDTH = 16;\n    parameter ARRAY_SIZE = 15;\n\n    // Inputs\n    reg clk;\n    reg reset;\n    reg start;\n    reg [DATA_WIDTH-1:0] search_key;\n    reg [$clog2(ARRAY_SIZE):0] root;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys;\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child;\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys_input;\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child_input;\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child_input;\n\n    reg [DATA_WIDTH-1:0] input_array [ARRAY_SIZE-1:0];\n\n    // Outputs\n    wire [$clog2(ARRAY_SIZE):0] key_position;\n    wire complete_found;\n    wire search_invalid;\n    wire done;\n    reg done_bst;\n    reg start_bst;\n\n\n    // Instantiate the search_binary_search_tree module\n    search_binary_search_tree #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .ARRAY_SIZE(ARRAY_SIZE)\n    ) dut (\n        .clk(clk),\n        .reset(reset),\n        .start(start),\n        .search_key(search_key),\n        .root(root),\n        .keys(keys),\n        .left_child(left_child),\n        .right_child(right_child),\n        .key_position(key_position),\n        .complete_found(complete_found),\n        .search_invalid(search_invalid)\n    );\n\n    // Instantiate the BST_SUB_TREE module to generate BST\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] random_data;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] ordered_array;\n\n    BST_SUB_TREE #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .ARRAY_SIZE(ARRAY_SIZE)\n    ) bst_generator (\n        .clk(clk),\n        .reset(reset),\n        .data_in(data_in),\n        .start(start_bst),\n        .keys(keys_input),\n        .left_child(left_child_input),\n        .right_child(right_child_input),\n        .done(done_bst)\n    );\n\n\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk; // Clock period of 10 units\n    end\n\n    // Reset generation\n    initial begin\n        reset = 0;\n        #20 reset = 1;\n\n        # 20 reset = 0;\n    end\n\n    // Function to generate a random number not in an excluded list\n    function int generate_unique_random(logic [ARRAY_SIZE*DATA_WIDTH-1:0] excluded_values);\n        int rand_num, is_excluded, i;\n        do begin\n            rand_num = $urandom_range(0, (2**DATA_WIDTH)-1);\n            is_excluded = 0;\n            for( i=0; i<ARRAY_SIZE; i++) begin\n                if (rand_num == excluded_values[i*DATA_WIDTH +: DATA_WIDTH]) begin\n                    is_excluded = 1;\n                    break;\n            end\n            end\n        end while (is_excluded);\n        return rand_num;\n    endfunction\n\n\n     // Sort Array \n    task sort_array;\n        input reg [ARRAY_SIZE*DATA_WIDTH-1:0] input_array;\n        output reg [ARRAY_SIZE*DATA_WIDTH-1:0] sorted_array;\n        integer i, j;\n        reg [DATA_WIDTH-1:0] temp;\n        begin\n            sorted_array = input_array;\n            for (i = 0; i < ARRAY_SIZE; i++) begin\n                for (j = i + 1; j < ARRAY_SIZE; j++) begin\n                    if (sorted_array[i*DATA_WIDTH +: DATA_WIDTH] > sorted_array[j*DATA_WIDTH +: DATA_WIDTH]) begin\n                        temp = sorted_array[i*DATA_WIDTH +: DATA_WIDTH];\n                        sorted_array[i*DATA_WIDTH +: DATA_WIDTH] = sorted_array[j*DATA_WIDTH +: DATA_WIDTH];\n                        sorted_array[j*DATA_WIDTH +: DATA_WIDTH] = temp;\n                    end\n                end\n            end\n        end\n    endtask\n\n    // Test Procedure\n    task run_test;\n        input string test_name;\n        input reg [DATA_WIDTH-1:0] key_input;\n        input reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys;\n        input reg not_valid;\n\n        integer i;\n        int ref_position;\n\n        begin\n\n            repeat(3) @(posedge clk);\n\n            $display(\"Running Test: %s\", test_name);\n\n            // Assign the key\n            search_key = key_input; \n\n            // Start the searching of the node\n            start = 1;\n            @(posedge clk);\n            start = 0;\n\n            wait(complete_found || search_invalid);\n\n            // For debugging\n            for (i = 0; i < ARRAY_SIZE; i=i+1) begin\n                $display(\"Input_data %d: %d\", i, keys[i*DATA_WIDTH +: DATA_WIDTH]);\n            end\n            \n            $display(\"complete_found: %b, search_invalid:%b\", complete_found, search_invalid);\n\n        end\n\n    endtask\n\n    // Test procedure\n    initial begin\n        int i, j;\n        int random_index;\n        int bst_type;\n        reg [DATA_WIDTH-1:0] key_to_search;\n        \n        #100;\n\n        for (j=0; j<60; j++) begin\n\n            bst_type = $urandom_range(0, 4);\n\n            for (i = 0; i < ARRAY_SIZE; i=i+1) begin\n                random_data[i*DATA_WIDTH +: DATA_WIDTH] = $urandom_range(0, 2**(DATA_WIDTH)-1);  \n            end\n\n            if (bst_type==0) begin\n                $display(\"------------Input_data: Sorted Array--------------------------\");\n                sort_array(random_data, data_in);\n            end else if (bst_type==1) begin\n                $display(\"------------Input_data: Reverse Sorting Array-----------------\");\n                sort_array(random_data, ordered_array);\n                // Reverse the sorting process\n                for (i = 0; i < ARRAY_SIZE; i++) begin\n                    data_in[i*DATA_WIDTH +: DATA_WIDTH] = ordered_array[(ARRAY_SIZE - i - 1)*DATA_WIDTH +: DATA_WIDTH];\n                end\n            end else if (bst_type==2) begin\n                $display(\"--------------Input_data: Duplicate the Values----------------\");\n                // Duplicate the values\n                for (i = 0; i < ARRAY_SIZE; i++) begin\n                    data_in[i*DATA_WIDTH +: DATA_WIDTH] = random_data[0*DATA_WIDTH +: DATA_WIDTH];  \n                end\n            end else if (bst_type==3) begin\n                $display(\"-----------------Input_data: All MAX values-------------------\");\n                // All Max values\n                for (i = 0; i < ARRAY_SIZE; i++) begin\n                    data_in[i*DATA_WIDTH +: DATA_WIDTH] = 2**(DATA_WIDTH)-1;  \n                end\n            end else begin\n                $display(\"----------------Input_data: Random Values---------------------\");\n                data_in = random_data;\n            end\n\n\n            @(posedge clk);\n            // start the BST \n            start_bst = 1;\n            @(posedge clk);\n            start_bst = 0;\n\n            // wait for BST to be completed\n            @(posedge done_bst);\n            @(posedge clk);\n\n            left_child = left_child_input;\n            right_child = right_child_input;\n            keys = keys_input;\n            root = 0;\n\n            //  To generate search_key with smaller larger value\n            sort_array(data_in, random_data);\n        \n            if (bst_type != 2 && bst_type != 3) begin\n                // Random values  \n                for (i = 0; i < ARRAY_SIZE-3; i=i+1) begin  \n                    random_index = $urandom_range(0, ARRAY_SIZE-1);\n                    key_to_search = data_in[random_index*DATA_WIDTH +: DATA_WIDTH]; \n                    run_test(\"Random values \", key_to_search, data_in, 0);\n                end\n\n                // Lowest value\n                key_to_search = random_data[0*DATA_WIDTH +: DATA_WIDTH]; \n                run_test(\"Lowest value\", key_to_search, data_in, 0);\n            end\n\n            // Largest value\n            key_to_search = random_data[(ARRAY_SIZE-1)*DATA_WIDTH +: DATA_WIDTH]; \n            run_test(\"Largest value\", key_to_search, data_in, 0);\n\n            // Key not present\n            key_to_search = generate_unique_random(data_in);\n            run_test(\"Not Valid\", key_to_search, data_in, 1);\n\n            repeat(3) @(posedge clk);\n\n        end\n\n        $display(\"----------------Empty Tree ---------------------\");\n\n        // Empty Tree \n        root = {($clog2(ARRAY_SIZE)+1){1'b1}}; // Null pointer\n        for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n            keys[i*DATA_WIDTH +: DATA_WIDTH] = 0;\n            left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] = {($clog2(ARRAY_SIZE)+1){1'b1}}; // Null pointer\n            right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] = {($clog2(ARRAY_SIZE)+1){1'b1}}; // Null pointer\n        end\n\n        key_to_search = $urandom_range(0, 2**DATA_WIDTH-1);\n        run_test(\"Random values \", key_to_search, keys, 1);\n\n        $display(\"---------special case to cover left skewed tree in right sub-tree ---------------------\");\n\n        data_in[0*DATA_WIDTH +: DATA_WIDTH] = $urandom_range(((2**(DATA_WIDTH))-1)/4, ((2**(DATA_WIDTH))-1)/3);\n        data_in[1*DATA_WIDTH +: DATA_WIDTH] = $urandom_range(data_in[0*DATA_WIDTH +: DATA_WIDTH] + 1 , (2**(DATA_WIDTH)-1)/2);\n        data_in[2*DATA_WIDTH +: DATA_WIDTH] = $urandom_range(data_in[0*DATA_WIDTH +: DATA_WIDTH] + 1 , data_in[1*DATA_WIDTH +: DATA_WIDTH] - 1);  \n\n        for (i = 3; i < ARRAY_SIZE; i=i+1) begin\n            data_in[i*DATA_WIDTH +: DATA_WIDTH] = data_in[(i-1)*DATA_WIDTH +: DATA_WIDTH] - 1;  \n        end\n\n        for (i = 0; i < ARRAY_SIZE; i=i+1) begin\n            $display(\"Input:%d\", data_in[i*DATA_WIDTH +: DATA_WIDTH]);\n        end\n\n        @(posedge clk);\n        // start the BST \n        start_bst = 1;\n        @(posedge clk);\n        start_bst = 0;\n\n        // wait for BST to be completed\n        @(posedge done_bst);\n        @(posedge clk);\n\n        left_child = left_child_input;\n        right_child = right_child_input;\n        keys = keys_input;\n        root = 0;\n\n        random_index = $urandom_range(0, ARRAY_SIZE-1);\n        key_to_search = data_in[random_index*DATA_WIDTH +: DATA_WIDTH]; \n        run_test(\"Random value \", key_to_search, data_in, 0);\n\n        random_index = $urandom_range(0, ARRAY_SIZE-1);\n        key_to_search = data_in[random_index*DATA_WIDTH +: DATA_WIDTH]; \n        run_test(\"Random value \", key_to_search, data_in, 0);\n\n        $finish;\n    end\n\n    // Dump waveforms for analysis\n    initial begin\n        $dumpfile(\"test.vcd\");\n        $dumpvars(0, binary_search_tree_search_node_tb);\n    end\n\nendmodule\n\n\n// BST_SUB_TREE Module: Constructs a binary search tree from the input array\nmodule BST_SUB_TREE #(\n    parameter DATA_WIDTH = 32,\n    parameter ARRAY_SIZE = 15\n\n) (\n    input clk,\n    input reset,\n    input [ARRAY_SIZE*DATA_WIDTH-1:0] data_in, // Input array for constructing BST\n    input reg start,\n    output reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys, // Node keys in the BST\n    output reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child, // Left child pointers\n    output reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child, // Right child pointers\n    output reg done // Done signal\n    \n);\n    // BST representation\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in_copy;\n\n    // FSM states\n    parameter IDLE = 3'b000, INIT = 3'b001, INSERT = 3'b010, TRAVERSE = 3'b011, COMPLETE = 3'b100;\n\n    reg [2:0] state;\n    reg [$clog2(ARRAY_SIZE):0] current_node;\n    reg [$clog2(ARRAY_SIZE):0] next_free_node;\n    reg [$clog2(ARRAY_SIZE):0] input_index;\n    reg [DATA_WIDTH-1:0] temp_data;\n    reg [$clog2(ARRAY_SIZE):0] root; // Root node pointer\n\n    integer i;\n\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset logic\n            state <= IDLE;\n            root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Null pointer\n            next_free_node <= 0;\n            input_index <= 0;\n            done <= 0;\n\n            // Clear tree arrays\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Null pointer\n                keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Null pointer\n                right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Null pointer\n            end\n\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Null pointer\n                    next_free_node <= 0;\n                    input_index <= 0;\n                    if (start) begin\n                        for (i = 0; i < ARRAY_SIZE+1; i = i + 1) begin\n                            keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                            left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                            right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        end\n                        // Load input data into input array\n                        state <= INIT;\n                        data_in_copy <= data_in;\n                    end\n                end\n\n                INIT: begin\n                    if (input_index < ARRAY_SIZE) begin\n                        temp_data <= data_in_copy[input_index*DATA_WIDTH +: DATA_WIDTH]; \n                        input_index <= input_index + 1;\n                        state <= INSERT;\n                    end else begin\n                        state <= COMPLETE;\n                    end\n                end\n\n                INSERT: begin\n                    if (root == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        // Tree is empty, insert at root\n                        root <= next_free_node;\n                        keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                        next_free_node <= next_free_node + 1; \n                        state <= INIT;\n                    end else begin\n                        // Traverse the tree to find the correct position\n                        current_node <= root; \n                        state <= TRAVERSE;\n                    end\n                end\n\n                TRAVERSE: begin      \n                    if ((temp_data < keys[current_node*DATA_WIDTH +: DATA_WIDTH]) || (temp_data == keys[current_node*DATA_WIDTH +: DATA_WIDTH])) begin\n                        if (left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                            left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                            keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                            next_free_node <= next_free_node + 1;\n                            state <= INIT;\n                        end else begin\n                            current_node <= left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                        end\n                    end else begin\n                        if (right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                            right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                            keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data; \n                            next_free_node <= next_free_node + 1;\n                            state <= INIT;\n                        end else begin\n                            current_node <= right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                        end\n                    end\n                end\n\n               COMPLETE: begin\n                    // Tree construction complete\n                    state <= IDLE;\n                    done <= 1;\n                end\n\n                default: begin\n                    state <= IDLE; // Default behavior for top-level FSM\n                end\n\n            endcase\n        end\n    end\nendmodule"}}, "output": {"response": "", "context": {"verif/binary_search_tree_search_node_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 32-tb-checker-search-node-in-binary-search-tree\nNUM_BUGS        = 3", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/binary_search_tree_search_node_tb.sv -seed random -access +rwc\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n", "src/search_binary_search_tree.sv": "module search_binary_search_tree #(\n    parameter DATA_WIDTH = 16,         // Width of the data\n    parameter ARRAY_SIZE = 15          // Maximum number of elements in the BST\n) (\n\n    input clk,                         // Clock signal\n    input reset,                       // Reset signal\n    input reg start,                   // Start signal to initiate the search\n    input reg [DATA_WIDTH-1:0] search_key, // Key to search in the BST\n    input reg [$clog2(ARRAY_SIZE):0] root, // Root node of the BST\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys, // Node keys in the BST\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child, // Left child pointers\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child, // Right child pointers\n    output reg [$clog2(ARRAY_SIZE):0] key_position, // Position of the found key\n    output reg complete_found,         // Signal indicating search completion\n    output reg search_invalid\n);\n                                                                                                                                        \n    // Parameters for FSM states\n    parameter S_IDLE = 3'b000,                 // Idle state\n              S_INIT = 3'b001,                 // Initialization state\n              S_SEARCH_LEFT = 3'b010,          // Search in left subtree\n              S_SEARCH_LEFT_RIGHT = 3'b011,    // Search in both left and right subtrees\n              S_COMPLETE_SEARCH = 3'b100;      // Search completion state\n   \n    // Registers to store the current FSM state\n    reg [2:0] search_state;\n\n    // Variables to manage traversal\n    reg [$clog2(ARRAY_SIZE):0] position;       // Position of the current node\n    reg found;                                 // Indicates if the key is found\n\n    reg left_done, right_done;                 // Flags to indicate completion of left and right subtree traversals\n\n    // Stacks for managing traversal of left and right subtrees\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_stack;  // Stack for left subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_stack; // Stack for right subtree traversal\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_left;         // Stack pointer for left subtree\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_right;        // Stack pointer for right subtree\n\n    // Pointers for the current nodes in left and right subtrees\n    reg [$clog2(ARRAY_SIZE):0] current_left_node;  // Current node in the left subtree\n    reg [$clog2(ARRAY_SIZE):0] current_right_node; // Current node in the right subtree\n\n    // Output indices for traversal\n    reg [$clog2(ARRAY_SIZE)-1:0] left_output_index;  // Output index for left subtree\n    reg [$clog2(ARRAY_SIZE)-1:0] right_output_index; // Output index for right subtree\n\n    // Integer for loop iterations\n    integer i;\n\n    // Always block triggered on the rising edge of the clock or reset signal\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all states and variables\n            search_state <= S_IDLE;  // Set state to IDLE\n            found <= 0;              // Reset found flag\n            position <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Invalid position\n            complete_found <= 0;     // Reset complete_found signal\n            key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Invalid key position\n            left_output_index <= 0;  // Reset left output index\n            right_output_index <= 0; // Reset right output index\n            sp_left <= 0;            // Reset left stack pointer\n            sp_right <= 0;           // Reset right stack pointer\n            left_done <= 0;          // Reset left_done flag\n            right_done <= 0;         // Reset right_done flag\n            search_state <= S_IDLE;  // Set state to IDLE\n            search_invalid <= 0;        // Set invalid_key to 0\n            \n            // Clear the stacks\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n            end\n\n        end else begin\n            // Main FSM logic\n            case (search_state)\n                S_IDLE: begin\n                    // Reset intermediate variables\n                    for (i = 0; i < ARRAY_SIZE+1; i = i + 1) begin\n                        left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                    end\n                    complete_found <= 0;\n                    search_invalid <= 0;\n\n                    if (start) begin\n                        // Start the search\n                        left_output_index <= 0;\n                        right_output_index <= 0;\n                        sp_left <= 0;\n                        sp_right <= 0;\n                        left_done <= 0;\n                        right_done <= 0;\n                        found <= 0;\n                        position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        search_state <= S_INIT; // Move to INIT state\n                        $display(\"ROOT NODE: %0h\", root);\n                    end\n                end\n\n                S_INIT: begin\n                    if (root != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        // Compare the search key with the root key\n                        if (search_key == keys[root*DATA_WIDTH +: DATA_WIDTH]) begin\n                            found <= 1;\n                            `ifndef BUG_0\n                            if (left_child[0*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                position <= 0;\n                                search_state <= S_COMPLETE_SEARCH; // Move to complete search state\n                            end else begin\n                                search_state <= S_SEARCH_LEFT; // Search in the left subtree\n                                current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end\n                            `else\n                            search_state <= S_SEARCH_LEFT; // Search in the left subtree\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            `endif\n                        end else if (keys[0*DATA_WIDTH +: DATA_WIDTH] > search_key) begin\n                            search_state <= S_SEARCH_LEFT;\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else begin\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            current_right_node <= right_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            search_state <= S_SEARCH_LEFT_RIGHT; // Search in both left and right subtrees\n                        end\n                    end else begin\n                        search_state <= S_COMPLETE_SEARCH; // Root is null\n                    end\n                end\n\n                S_SEARCH_LEFT: begin\n                    // Traverse the left subtree\n                    if (current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                        sp_left <= sp_left + 1;\n                        current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (sp_left > 0) begin\n                        sp_left <= sp_left - 1;\n                        current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        if (search_key == keys[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]) begin\n                            found <= 1;\n                            position <= left_output_index;   \n                            search_state <= S_COMPLETE_SEARCH; // Move to complete search state\n                        end\n                        left_output_index <= left_output_index + 1;\n                        current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else begin //if (!left_done) begin\n                        if (found == 1) begin\n                            position <= left_output_index;\n                        end \n                        left_done <= 1;\n                        search_state <= S_COMPLETE_SEARCH;\n                    end\n                end\n\n                S_SEARCH_LEFT_RIGHT: begin\n                    // Traverse both left and right subtrees\n                    if (!left_done && current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                        sp_left <= sp_left + 1;\n                        current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done && sp_left > 0) begin\n                        sp_left <= sp_left - 1;\n                        current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        left_output_index <= left_output_index + 1;\n                        current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done) begin\n                        left_done <= 1;\n                    end\n\n                    if (!found) begin\n                        if (!right_done && current_right_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                            right_stack[sp_right*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_right_node;\n                            sp_right <= sp_right + 1;\n                            current_right_node <= left_child[current_right_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else if (!right_done && sp_right > 0) begin\n                            sp_right <= sp_right - 1;\n                            current_right_node <= right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                `ifndef BUG_2\n                                if (search_key == keys[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]) begin\n                                    found <= 1;\n                                end\n                                `else\n                                if (search_key == keys[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]) begin\n                                    found <= 1;\n                                    search_state <= S_COMPLETE_SEARCH; \n                                end\n                                `endif\n                            right_output_index <= right_output_index + 1;\n                            current_right_node <= right_child[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else if (!right_done) begin\n                            right_done <= 1;\n                        end\n\n                    end else if (left_done) begin\n                         `ifndef BUG_1\n                        position <= left_output_index + right_output_index;\n                        `else\n                        position <= right_output_index;\n                        `endif\n                        search_state <= S_COMPLETE_SEARCH; \n\n                    end\n\n                    if (right_done && left_done && !found) begin\n                        search_state <= S_COMPLETE_SEARCH;\n                    end\n                end\n\n                S_COMPLETE_SEARCH: begin\n                    // Complete the search\n                    if (!found) begin\n                        complete_found <= 0;\n                        key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        search_invalid <= 1;\n                    end else begin\n                        complete_found  <= 1;\n                        key_position <= position;\n                        search_invalid <= 0;\n                    end\n                    search_state <= S_IDLE; // Return to IDLE state\n                end\n\n                default: begin\n                    search_state <= S_IDLE; // Default to IDLE state\n                end\n            endcase\n        end\n    end\n\nendmodule\n"}}}
{"id": "cvdp_copilot_binary_search_tree_sorting_0044", "categories": ["cid014", "medium"], "input": {"prompt": "Implement SystemVerilog Assertions (SVA) to validate the behaviour of the given `binary_search_tree_sort` module that processes an array of unsigned integers with a parameterizable size, ARRAY_SIZE (number of elements in the array, will be greater than 0) and sorts the array in ascending order via the Binary Search Tree (BST) algorithm. \n\n## Design Specification:\n\nA BST is a data structure where each node has a key, and its left child contains keys less than or equal to the node, while its right child contains keys greater than the node and thereby constructs a tree. The algorithm organizes the integers into a binary search tree and traverses the tree to produce a sorted output array. The maximum data value possible for an element within the array can be set with the parameter DATA_WIDTH (width of a single element, greater than 0). Sorting arranges the elements of the array in ascending order, such that the smallest element is at index 0 and the largest element is at index ARRAY_SIZE-1. `sorted_out` holds the sorted array when the `done` signal asserts high. Both `done` and `sorted_out` are set to 0 after 1 clock cycle.\n\n### Design Details\n\n**Parameterization**\n\n- **ARRAY_SIZE**: Specifies the number of elements in the input array.\n  - Default: 15\n- **DATA_WIDTH**: Specifies the bit-width of each array element.\n  - Default: 32\n \n**Inputs and Outputs**\n\n**Inputs:**\n\n- **clk**: Clock signal for synchronization. The design is synchronized to the positive edge of this clock.\n- **reset**: Active-high asynchronous reset.When asserted, it immediately resets all outputs (**sorted_out** array and **done**) to zero.\n- **start**: Active-high signal for 1 clock cycle to initiate the sorting process.\n- **data_in [ARRAY_SIZE*DATA_WIDTH-1:0]**: The unsorted input array that will be sorted by the BST-based algorithm.\n\n**Outputs:**\n\n- **done**: An active high signal for 1 clock cycle indicates when the sorting operation is complete.\n- **sorted_out [ARRAY_SIZE*DATA_WIDTH-1:0]**: The sorted array output in ascending order, such that the smallest element is at index 0 and the largest element is at index ARRAY_SIZE-1.\n\n### Note: \n- An index or a node in the `left_child` or `right_child` is considered to be invalid or does not exist when all the bits are set to 1. \n- A left-skewed tree is a BST where every node only consists of a left_child and no right_child. \n- A right-skewed tree is a BST where every node only consists of a right_child and no left_child. \n- In the following section describing the required assertions, if `data_in` is referred to as sorted in ascending or descending order (reverse sorted), assume there are no duplicate keys.\n\n## Assertions: \n\n1. Sorted data input results in the same array as input: When `data_in` is a sorted array in ascending order, the output `sorted_out` is the same as `data_in`.\n\n2. Output array is always sorted: For any given `data_in`, the output `sorted_out` should be sorted in ascending order (with or without duplicate keys).\n \n3. Duplicated data input results in the same array as input: When `data_in` consists of identical values across all nodes, the output `sorted_out` remains identical to `data_in`.\n \n4. Total latency of the worst case scenarios: For worst-case scenarios, including left-skewed trees, right-skewed trees, and arrays with duplicate values, and when ARRAY_SIZE > 1, the total number of clock cycles from the moment `start` is asserted until `done` is set high is equal to ((ARRAY_SIZE - 1) * ARRAY_SIZE)/2 + 4 * ARRAY_SIZE + 5.\n\n5. Latency for constructing a BST from an already sorted array (ascending order) and check the condition for the constructed right-skewed BST: \n   - When `data_in` is sorted in ascending order and ARRAY_SIZE > 1, the total latency for constructing the BST is ((ARRAY_SIZE - 1) * ARRAY_SIZE) / 2 + 2 * ARRAY_SIZE + 2 clock cycles.\n   - The constructed BST must be a right-skewed tree where all the indices of the `left_child` are invalid, indicating that no left child exists, and at least one index of `right_child` is valid.\n\n6.  Latency for constructing a BST from an already sorted array (ascending order) and check the condition for the constructed left-skewed BST: \n     - When `data_in` is sorted in descending order or is duplicated throughout and ARRAY_SIZE > 1, the total latency for constructing the BST is ((ARRAY_SIZE - 1) * ARRAY_SIZE) / 2 + 2 * ARRAY_SIZE + 2 clock cycles.\n     - The constructed BST must be a left-skewed tree where all the indices of the `right_child` are invalid, indicating that no right child exists, and at least one index of `left_child` is valid.\n\n7. Construction of the BST is complete when all the indices in the input array are traversed: When the tree is complete, all the indices of the `data_in` must be traversed (`input_index` is equal to ARRAY_SIZE).\n\n8. Maximum depth of a sorted array: A sorted array forms a right-skewed tree. The maximum depth of `right_child` in the right-skewed BST is ARRAY_SIZE - 1. This depth is determined by index ARRAY_SIZE - 1 of `right_child` being invalid and index  ARRAY_SIZE - 2 of `right_child` being valid (as it implies all indices up to ARRAY_SIZE - 2 are valid).\n\n9. Maximum depth of a reverse sorted or duplicated array: An array that is sorted in reverse order or containing identical keys, forms a left-skewed binary search tree (BST). The maximum depth of `left_child` in the left-skewed BST is ARRAY_SIZE - 1. This depth is determined by index ARRAY_SIZE - 1 of `left_child` being invalid and index  ARRAY_SIZE - 2 of `left_child` being valid (as it implies all indices up to ARRAY_SIZE - 2 are valid).", "context": {"rtl/binary_search_tree_sort.sv": "module binary_search_tree_sort #(\n    parameter DATA_WIDTH = 32,\n    parameter ARRAY_SIZE = 15\n) (\n    input clk,\n    input reset,\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in, // Input data to be sorted\n    input start,\n    output reg [ARRAY_SIZE*DATA_WIDTH-1:0] sorted_out, // Sorted output\n    output reg done\n);\n\n    // Parameters for top-level FSM states\n    parameter IDLE = 2'b00, BUILD_TREE = 2'b01, SORT_TREE = 2'b10;\n\n    // Parameters for nested FSM states (Build Tree)\n    parameter INIT = 2'b00, INSERT = 2'b01, TRAVERSE = 2'b10, COMPLETE = 2'b11;\n\n    // Parameters for nested FSM states (Sort Tree)\n    parameter S_INIT = 2'b00, S_SORT_LEFT_RIGHT = 2'b01, S_MERGE_RESULTS = 2'b10;\n    // Registers for FSM states\n    reg [1:0] top_state, build_state, sort_state;\n\n    // BST representation\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in_copy;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys; // Array to store node keys\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child; // Left child pointers\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child; // Right child pointers\n    reg [$clog2(ARRAY_SIZE):0] root; // Root node pointer\n    reg [$clog2(ARRAY_SIZE):0] next_free_node; // Pointer to the next free node\n\n    // Working registers\n    reg [$clog2(ARRAY_SIZE):0] current_node; // Current node being processed\n    reg [$clog2(ARRAY_SIZE):0] input_index; // Index for input data\n    reg [DATA_WIDTH-1:0] temp_data; // Temporary data register\n\n    // Intermediate buffers for storing sorted values of left and right subtrees\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] left_sorted;  // Buffer for left subtree sorted values\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] right_sorted; // Buffer for right subtree sorted values\n\n    // Stack and pointers for left and right subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_stack; // Stack for left subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_stack; // Stack for right subtree traversal\n    reg [$clog2(ARRAY_SIZE):0] sp_left; // Stack pointer for left subtree\n    reg [$clog2(ARRAY_SIZE):0] sp_right; // Stack pointer for right subtree\n\n    // Current node pointers for left and right subtrees\n    reg [$clog2(ARRAY_SIZE):0] current_left_node; // Current node in left subtree\n    reg [$clog2(ARRAY_SIZE):0] current_right_node; // Current node in right subtree\n\n    // Flags to indicate when sorting of left and right subtrees is done\n    reg left_done; // Flag for completion of left subtree sorting\n    reg right_done; // Flag for completion of right subtree sorting\n\n    // Output indices for left and right subtree buffers\n    reg [$clog2(ARRAY_SIZE):0] left_output_index; // Output index for left_sorted buffer\n    reg [$clog2(ARRAY_SIZE):0] right_output_index; // Output index for right_sorted buffer\n\n    // Initialize all variables\n    integer i, j;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all states and variables\n            top_state <= IDLE;\n            build_state <= INIT;\n            sort_state <= S_INIT;\n            root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; ; // Null pointer\n            next_free_node <= 0;\n            input_index <= 0;\n            done <= 0;\n\n            // Clear tree arrays\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                left_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                right_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n            end\n\n        end \n        else begin\n            case (top_state)\n                IDLE: begin\n                    done <= 0;\n                    input_index <= 0;\n                    root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; ; // Null pointer\n                    next_free_node <= 0;\n                    for (i = 0; i < ARRAY_SIZE+1; i = i + 1) begin\n                        keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                        right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        left_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        right_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                    end\n                    if (start) begin\n                        // Load input data into input array\n                        top_state <= BUILD_TREE;\n                        build_state <= INIT;\n                        data_in_copy <= data_in;\n                    end\n                end\n\n                BUILD_TREE: begin\n                    case (build_state)\n                        INIT: begin\n                            if (input_index < ARRAY_SIZE) begin\n                                temp_data <= data_in_copy[input_index*DATA_WIDTH +: DATA_WIDTH]; \n                                input_index <= input_index + 1;\n                                build_state <= INSERT;\n                            end else begin\n                                build_state <= COMPLETE;\n                            end\n                        end\n\n                        INSERT: begin\n                            if (root == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                // Tree is empty, insert at root\n                                root <= next_free_node;\n                                keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                next_free_node <= next_free_node + 1; \n                                build_state <= INIT;\n                            end else begin\n                                // Traverse the tree to find the correct position\n                                current_node <= root; \n                                build_state <= TRAVERSE;\n                            end\n                        end\n\n                        TRAVERSE: begin      \n                            if ((temp_data < keys[current_node*DATA_WIDTH +: DATA_WIDTH]) || (temp_data == keys[current_node*DATA_WIDTH +: DATA_WIDTH])) begin\n                                if (left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                    left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                                    keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                    next_free_node <= next_free_node + 1;\n                                    build_state <= INIT;\n                                end else begin\n                                    current_node <= left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                                end\n                            end else begin\n                                if (right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                    right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                                    keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data; \n                                    next_free_node <= next_free_node + 1;\n                                    build_state <= INIT;\n                                end else begin\n                                    current_node <= right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                                end\n                            end\n                        end\n\n                        COMPLETE: begin\n                            // Tree construction complete\n                            top_state <= SORT_TREE;\n                            sort_state <= S_INIT;\n                        end\n\n                    endcase\n                end\n\n                SORT_TREE: begin\n                    case (sort_state)\n                        S_INIT: begin\n                            if (root != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                // Start parallel sorting for left and right subtrees\n                                left_output_index <= 0;\n                                right_output_index <= 0;\n                                sp_left <= 0;\n                                sp_right <= 0;\n                                left_done <= 0;\n                                right_done <= 0;\n                                current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                current_right_node <= right_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                sort_state <= S_SORT_LEFT_RIGHT;\n                            end else begin\n                                done <= 1; // No tree to sort\n                                top_state <= IDLE;\n                            end\n                        end\n\n                        S_SORT_LEFT_RIGHT: begin\n                            // Sort left subtree in parallel\n                            if (!left_done && current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                                sp_left <= sp_left + 1;\n                                current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!left_done && sp_left > 0) begin\n                                sp_left <= sp_left - 1;\n                                current_left_node <= left_stack[({{(32-$bits(sp_left)){1'b0}}, sp_left} - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                left_sorted[left_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[left_stack[({{(32-$bits(sp_left)){1'b0}}, sp_left} - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH];\n                                left_output_index <= left_output_index + 1;\n                                current_left_node <= right_child[left_stack[({{(32-$bits(sp_left)){1'b0}}, sp_left} - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!left_done) begin\n                                left_done <= 1;\n                            end\n\n                            // Sort right subtree in parallel\n                            if (!right_done && current_right_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                right_stack[sp_right*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_right_node;\n                                sp_right <= sp_right + 1;\n                                current_right_node <= left_child[current_right_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!right_done && sp_right > 0) begin\n                                sp_right <= sp_right - 1;\n                                current_right_node <= right_stack[({{(32-$bits(sp_right)){1'b0}}, sp_right} - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                right_sorted[right_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[right_stack[({{(32-$bits(sp_right)){1'b0}}, sp_right} - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH];\n                                right_output_index <= right_output_index + 1;\n                                current_right_node <= right_child[right_stack[({{(32-$bits(sp_right)){1'b0}}, sp_right} - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!right_done) begin\n                                right_done <= 1;\n                            end\n\n                            // Transition to merging once both left and right sorting are done\n                            if (left_done && right_done) begin\n                                sort_state <= S_MERGE_RESULTS;\n                            end\n                        end\n\n                        S_MERGE_RESULTS: begin\n\n                            // Merge left_sorted, root, and right_sorted into final sorted output\n                            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                                if (i < left_output_index) begin\n                                    sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= left_sorted[i*DATA_WIDTH +: DATA_WIDTH];\n                                end\n                            end\n\n                            // Insert the root into `sorted_out`\n                            sorted_out[left_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[root*DATA_WIDTH +: DATA_WIDTH];\n\n                            // Copy `right_sorted` into `sorted_out`\n                            for (j = 0; j < ARRAY_SIZE; j = j + 1) begin\n                                if (j < right_output_index) begin\n                                    sorted_out[(({{(32-$bits(left_output_index)){1'b0}}, left_output_index} + 1) + j)*DATA_WIDTH +: DATA_WIDTH] <= right_sorted[j*DATA_WIDTH +: DATA_WIDTH];\n                                end\n                            end\n\n                            done <= 1; // Sorting complete\n                            top_state <= IDLE;\n\n                        end\n\n                        default: begin\n                            sort_state <= S_INIT; // Reset to initial sort state\n                        end\n                    endcase\n                end\n\n                default: begin\n                    top_state <= IDLE; // Default behavior for top-level FSM\n                end\n                \n            endcase\n        end\n    end\nendmodule"}}, "output": {"response": "", "context": {"rtl/binary_search_tree_sort.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/binary_search_tree_sort.sv \nTOPLEVEL        = binary_search_tree_sort\nMODULE          = test_binary_search_tree_sort\nPYTHONPATH      = /src\nHASH            = 44-rtl-assertion-bst-sorter", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/binary_search_tree_sort.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build -vcd dumpon\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0", "src/test_binary_search_tree_sort.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\ndef create_balanced_array(sorted_array):\n    # Recursive function to create a balanced array\n    if not sorted_array:\n        return []\n    mid = len(sorted_array) // 2\n    return [sorted_array[mid]] + create_balanced_array(sorted_array[:mid]) + create_balanced_array(sorted_array[mid + 1:])\n\ndef calculate_latency(array_size, sorted):\n    if array_size == 1: \n        # (INIT + INSERT = 2) + (INIT + Complete (for any node)) + IDLE \n        latency_build_tree = 5\n        # (INIT +  check for right/left + left/right done + 1(done set))\n        latency_sort_tree = 4\n    \n    if sorted:\n        # For any node (INIT + INSERT = 2) = 2 * array_size + 2 (INIT + Complete (final))\n        # for sorted(for each node traverse until current depth) = (sum of array_size-1) = (array_size -1) * array_size / 2\n        latency_build_tree = ((array_size - 1) * array_size)/2 + 2 * array_size + 2\n\n        # (Every node (except root) goes through traverse left + process node) + Set Root Node + Set Done + Move to Merge Results + Merge\n        # An additional clcok as the count is incremented when the done signal sets\n        latency_sort_tree = 2 * (array_size - 1) + 4 + 1\n\n    total_latency = latency_build_tree + latency_sort_tree\n\n    return total_latency\n\n\n@cocotb.test()\nasync def test_bst_sorter(dut):\n    ARRAY_SIZE = int(dut.ARRAY_SIZE.value)\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n\n    clk_period = 10  # ns\n    random.seed(0)  # For reproducibility\n\n    cocotb.start_soon(clock(dut, clk_period))\n\n    await reset_dut(dut, 5)\n    dut.start.value = 0\n\n    # Increase the count for more tests\n    test_count = 2\n    for idx in range(test_count):\n        arr = [random.randint(0, (1 << DATA_WIDTH)-1) for _ in range(ARRAY_SIZE)]\n        cocotb.log.info(f\"Random: {arr}!\")\n        await run_test_case(f\"Random {idx}\", dut, arr, DATA_WIDTH, ARRAY_SIZE, 0)\n\n    # Worst case scenario for BST (descending)\n    arr = random.sample(range(1 << DATA_WIDTH), ARRAY_SIZE)\n    cocotb.log.info(f\"Worst case scenario for BST (descending): {sorted(arr)}!\")\n    await run_test_case(f\" Worst case scenario (descending)\", dut, sorted(arr), DATA_WIDTH, ARRAY_SIZE, 1)\n    \n    # Worst case scenario for BST (ascending)\n    name = \"Worst case scenario (ascending)\"\n    arr = random.sample(range(1 << DATA_WIDTH), ARRAY_SIZE)\n    cocotb.log.info(f\"Worst case scenario for BST (ascending): {sorted(arr, reverse=True)}!\")\n    await run_test_case(f\"{name}\", dut, sorted(arr, reverse=True), DATA_WIDTH, ARRAY_SIZE, 1)\n    \n    # Best case scenario for BST (Balanced Tree)\n    elements = sorted(random.sample(range(1 << DATA_WIDTH), ARRAY_SIZE))\n    balanced_array = lambda nums: nums[len(nums)//2:len(nums)//2+1] + balanced_array(nums[:len(nums)//2]) + balanced_array(nums[len(nums)//2+1:]) if nums else []\n    balanced_tree_array = balanced_array(elements)\n    cocotb.log.info(f\"Balanced_tree_array: {balanced_tree_array}!\")\n    await run_test_case(f\"Balanced Tree\", dut, balanced_tree_array, DATA_WIDTH, ARRAY_SIZE, 0)\n\n    # Mixed min/max pattern \n    arr = [0 if i % 2 == 0 else (1 << DATA_WIDTH)-1 for i in range(ARRAY_SIZE)]\n    cocotb.log.info(f\"Mixed min/max pattern: {arr}!\")\n    await run_test_case(\"Min-Max Alternating\", dut, arr, DATA_WIDTH, ARRAY_SIZE, 0)\n\n    # All duplicates - check for latency as it traverses only left tree similar to sorted input array in ascending order\n    random_val = random.randint(0, (1 << DATA_WIDTH)-1)\n    cocotb.log.info(f\"All duplicates: {[random_val] * ARRAY_SIZE}!\")\n    await run_test_case(\"All Duplicates\", dut, [random_val] * ARRAY_SIZE, DATA_WIDTH, ARRAY_SIZE, 1)\n\n\nasync def reset_dut(dut, duration):\n    dut.reset.value = 1\n    for _ in range(duration):\n        await RisingEdge(dut.clk)\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\nasync def clock(dut, clk_period):\n        while True:\n            dut.clk.value = 0\n            await Timer(clk_period/2, units='ns')\n            dut.clk.value = 1\n            await Timer(clk_period/2, units='ns')\n\nasync def run_test_case(name, dut, input_array, data_width, array_size, sort):\n        cocotb.log.info(f\"Running Test: {name}\")\n        packed_input = 0\n        for idx, val in enumerate(input_array):\n            packed_input |= (val << (idx * data_width))\n        dut.data_in.value = packed_input\n     \n        await RisingEdge(dut.clk)\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        cycle_count = 0\n        while True:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n            if dut.done.value == 1:\n                break\n\n        cocotb.log.info(f\"Total Latency {cycle_count}\")\n        out_data_val = int(dut.sorted_out.value)\n\n        output_array = [ (out_data_val >> (i * data_width)) & ((1 << data_width) - 1) for i in range(array_size)]\n        expected_output = sorted(input_array)\n        \n        assert output_array == expected_output, f\"[{name}] Output incorrect. Got: {output_array}, Expected: {expected_output}\"\n        \n        # Check for Latency\n        if ((sort) or (array_size == 1)):\n            cocotb.log.debug(f\"{name}: Total Latency for BUILD_TREE and SORT_TREE FSM: {cycle_count}, expected : {calculate_latency(array_size, 1)}\")\n            assert calculate_latency(array_size, 1) == cycle_count, f\"[{name}] Latency incorrect. Got: {cycle_count}, Expected: {calculate_latency(array_size, 1)}\"\n\n        cocotb.log.info(f\"Test {name} passed.\")\n", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\n\ndef call_runner(DATA_WIDTH, ARRAY_SIZE):\n   \n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            parameter={'DATA_WIDTH': DATA_WIDTH, 'ARRAY_SIZE' : ARRAY_SIZE},\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n        hrs_lb.xrun_tb()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n\n# Parametrize test for different WIDTH and SIGNED_EN\n@pytest.mark.parametrize(\"DATA_WIDTH\", [6,32])\n@pytest.mark.parametrize(\"ARRAY_SIZE\", [8,15])\n\ndef test_bst(DATA_WIDTH, ARRAY_SIZE):\n    # Log the randomized WIDTH\n    print(f'Running with: DATA_WIDTH = {DATA_WIDTH}, ARRAY_SIZE = {ARRAY_SIZE}')\n\n    # Call the runner function with the randomized WIDTH\n    call_runner(DATA_WIDTH,ARRAY_SIZE)\n"}}}
{"id": "cvdp_copilot_binary_to_BCD_0030", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench for `binary_to_bcd` module, which converts an 8-bit binary input into a 12-bit BCD output using the Double Dabble algorithm, ensuring correct shifting, adjustment, and final conversion while validating that each BCD digit remains within the valid range (0-9). The testbench must have the instantiation of RTL module and generate stimulus for various test conditions.\n\n___\nThe interface of `binary_to_bcd` RTL module is given below:\n\n**Input:**\n  - `binary_in` [7:0] [8-Bit]: The binary number to be converted into BCD.\n  \n**Output:**\n  - `bcd_out` [11:0] [12-Bit]: The corresponding BCD output where each 4-bit group represents a decimal digit.\n\n___\n\n### Input Generation and Validation\n**Input Generation:**\n\n1. Fixed Test Cases:\n    - Test a variety of binary inputs, including boundary values, random values, and power-of-two values to validate correct behavior.\n    - Example test values: `0`, `1`,`9`, `10`, `15`, `45`, `99`, `123`, `200`, `255`.\n2. Randomized Testing:\n    - Generate random binary values within the range `0\u2013255` and compare against a reference function.\n\n3. Edge Cases:\n    - Minimum input (`binary_in = 0`):  BCD output `0000 0000 0000` (0).\n    - Maximum input (`binary_in = 255`):  BCD output `0010 0101 0101` (255).\n    - Near-boundary conditions (`binary_in` = `9`, `10`, `99`, `100`, `199`) to verify correct BCD adjustments.\n\n___\n### Instantiation\nName the instance of RTL as `uut`.\n\n##\n### Module Functionality\n**Shift and Adjust Logic:**\n  - Shift Register:\n    - The module uses a 20-bit shift register where the lower 8 bits hold the binary input, and the upper 12 bits store the BCD result.\n  - Adjustment Condition (`>= 5`):\n    - Before each shift, BCD digits are checked; if `\u2265 5`, `+3` is added to prevent invalid values.\n  - Final Output Extraction:\n    - After 8 shifts, the upper 12 bits of the shift register (`shift_reg[19:8]`) contain the final BCD result.", "context": {}}, "output": {"response": "", "context": {"verif/tb_binary_to_bcd.sv": ""}}, "harness": {"files": {"docker-compose.yml": "\nservices:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = d9425cbf44311ca8ccf0b0f82c28e8097057c086\nTARGET = 90\n", "src/binary_to_bcd.sv": "`timescale 1ns / 1ps\n\nmodule binary_to_bcd (\n    input logic [7:0] binary_in,  // 8-bit binary input\n    output logic [11:0] bcd_out  // 12-bit BCD output (3 digits)\n);\n\n  // Intermediate shift register to hold binary and BCD values\n  logic [19:0] shift_reg;  // 20-bit register: 12 for BCD and 8 for binary input\n  integer i;\n\n  always_comb begin\n    // Step 1: Initialize the shift register\n    shift_reg = {12'd0, binary_in};  // Concatenate 12 zeros and binary input\n\n    // Step 2: Perform the Double Dabble process\n    for (i = 0; i < 8; i = i + 1) begin\n      // Check if each BCD digit is 5 or greater; if so, add 3\n      if (shift_reg[11:8] >= 5) shift_reg[11:8] = shift_reg[11:8] + 3;\n      if (shift_reg[15:12] >= 5) shift_reg[15:12] = shift_reg[15:12] + 3;\n      if (shift_reg[19:16] >= 5) shift_reg[19:16] = shift_reg[19:16] + 3;\n\n      // Shift the entire register left by 1 bit\n      shift_reg = shift_reg << 1;\n    end\n\n    // Step 3: Assign the upper 12 bits of the shift register to BCD output\n    bcd_out = shift_reg[19:8];\n  end\n\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\r\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\r\nimport re\r\nimport subprocess\r\nimport pytest\r\n\r\n# ----------------------------------------\r\n# - Simulate\r\n# ----------------------------------------\r\n\r\n@pytest.mark.usefixtures(scope='session')\r\ndef test_simulate():\r\n\r\n    cmd = \"xrun -coverage all /src/binary_to_bcd.sv /code/verif/tb_binary_to_bcd.sv -covtest test -seed random -covoverwrite\"\r\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\r\n\r\n# ----------------------------------------\r\n# - Generate Coverage\r\n# ----------------------------------------\r\n\r\n@pytest.mark.usefixtures(scope='test_simulate')\r\ndef test_coverage():\r\n\r\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\r\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\r\n\r\n# ----------------------------------------\r\n# - Report\r\n# ----------------------------------------\r\n\r\n@pytest.mark.usefixtures(scope='test_coverage')\r\ndef test_report():\r\n\r\n    metrics = {}\r\n\r\n    with open(\"/code/rundir/coverage.log\") as f:\r\n        lines = f.readlines()\r\n\r\n    # ----------------------------------------\r\n    # - Evaluate Report\r\n    # ----------------------------------------\r\n\r\n    for line in lines[2:]:\r\n        info = line.split()\r\n\r\n        inst = info [0]\r\n        avg  = info [1]\r\n        cov  = info [2]\r\n\r\n        inst = re.sub(r'[\\W]', '', inst)\r\n\r\n        metrics [inst] = {\r\n            \"Average\" : float(avg[:-1]),\r\n            \"Covered\" : float(cov[:-1])\r\n        }\r\n\r\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_binary_to_BCD_0032", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the SystemVerilog testbench `tb_binary_to_bcd.sv` to integrate the functionality of a checker to verify the `binary_to_bcd` module. The testbench provided in the context already includes a stimulus generator for various test cases. The purpose of the testbench checker is to validate the correctness of the Binary-to-BCD conversion by comparing the DUT output `bcd_out` against a reference function implementing the Double Dabble algorithm and flagging any mismatches.\n___\n### Design Specification\n\nThe `binary_to_bcd` module converts an 8-bit binary input (`binary_in`) into a 12-bit BCD (Binary-Coded Decimal) output (`bcd_out`) using the Double Dabble algorithm. The module processes the binary input bit by bit, shifting and adjusting the BCD digits to ensure accurate decimal representation.\n\n___\n### Summary of Operations\n##\n**1. Binary-to-BCD Conversion Using Double Dabble Algorithm:**\n\n  - The binary input is shifted into a 20-bit shift register (`8-bit binary + 12-bit BCD` storage).\n  - Before each shift, each BCD digit is checked; if \u2265 5, +3 is added to ensure valid decimal representation.\n  - After 8 iterations (one per binary bit), the upper 12 bits of the shift register hold the final BCD output.\n  \n**2. Edge Cases:**\n  - `binary_in = 0` should produce a BCD output of `000000000000`.\n  - `binary_in = 255` (max 8-bit value) should produce BCD output of `001001010101` (255 in decimal).\n  - Binary values near BCD transition points (`4`, `5`, `9`, `10`, `99`, `100`, `199`) should be validated for proper digit adjustments.\n  - Randomized binary inputs should be tested against a reference function.\n___\n### Example Computation\n\n1. For `binary_in = 45` (00101101 in binary):\n    - Expected BCD Output (`bcd_out`) = `000001000101` (45 in BCD).\n2. For `binary_in = 99` (01100011 in binary):\n    - Expected BCD Output (`bcd_out`) = `000010011001` (99 in BCD).\n3. For `binary_in = 255` (11111111 in binary):\n    - Expected BCD Output (`bcd_out`) = `001001010101` (255 in BCD).\n___\n### Requirements\n\n### 1. Testbench Components\n  - Input Signals:\n      - `binary_in` (7:0): A 8-bit binary input to be converted.\n  - Output Validation:\n      - `bcd_out` (11:0): A 12-bit computed BCD output from the DUT.\n\n### 2. Validation Logic\n  - Implement a reference function (`binary_to_bcd_ref`) to compute the expected BCD output for any given binary input using the Double Dabble algorithm.\n  - Compare the DUT output (`bcd_out`) with the expected output.\n  - Flag mismatches and log error messages.\n\n### 3. Functionality\n  - Exhaustively test values covering:\n    - All BCD transition points (`5`, `10`, `99`, `100`, etc.).\n    - Maximum binary value (`255`).\n    - Random binary values (`0\u2013255`).\n  - Ensure each BCD digit stays within `0 to 9`.\n\n### 4. Verification\n  - Apply test vectors with various binary inputs (`binary_in`).\n  - Compute the expected BCD output.\n  - Compare expected vs. actual DUT outputs.\n  - Print pass/fail messages for each test.\n\n### 5. Simulation\n  - Display pass/fail results for each test.\n  - Log input settings (`binary_in`) and the corresponding expected vs. actual BCD outputs.\n  - End the simulation after verifying all test vectors.\n___\n\n### Expected Output:\n  - Pass/Fail messages for each test scenario.\n  - Log of input values and corresponding BCD outputs.\n___ \n### Deliverables\n  - Provide a complete SystemVerilog testbench (`tb_binary_to_bcd.sv`) that meets all the above requirements.", "context": {"verif/tb_binary_to_bcd.sv": "`timescale 1ns / 1ps\n\nmodule tb_binary_to_bcd ();\n  // Inputs\n  logic [ 7:0] binary_in;\n  // Outputs\n  logic [11:0] bcd_out;\n  // Instantiate the Binary to BCD Converter\n  binary_to_bcd uut (\n      .binary_in(binary_in),\n      .bcd_out  (bcd_out)\n  );\n\n  // Task to display the results\n  task display_result;\n    input [7:0] binary;\n    input [11:0] bcd;\n    begin\n      $display(\"Binary Input: %b (%0d) | BCD Output: %b (%0d)\", binary, binary, bcd, {\n               bcd[11:8], bcd[7:4], bcd[3:0]});\n    end\n  endtask\n\n  initial begin\n    $display(\"Starting Binary-to-BCD Testbench...\");\n\n    // Test case 1\n    binary_in = 8'd0;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 2\n    binary_in = 8'd1; \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 3\n    binary_in = 8'd5; \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 4\n    binary_in = 8'd7;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 5\n    binary_in = 8'd9;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 6\n    binary_in = 8'd10;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 7\n    binary_in = 8'd20; \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 8\n    binary_in = 8'd22; \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 9\n    binary_in = 8'd33;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 10\n    binary_in = 8'd44;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 11\n    binary_in = 8'd49; \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 12\n    binary_in = 8'd50;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 13\n    binary_in = 8'd55;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 14\n    binary_in = 8'd77;  \n    #10;\n    display_result(binary_in, bcd_out);\n  \n    // Test case 15\n    binary_in = 8'd99;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 16\n    binary_in = 8'd100; \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 17\n    binary_in = 8'd123;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 18\n    binary_in = 8'd128;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 19\n    binary_in = 8'd150;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 20\n    binary_in = 8'd166;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 21\n    binary_in = 8'd177;\n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 22\n    binary_in = 8'd188;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 23\n    binary_in = 8'd199; \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 24\n    binary_in = 8'd200;  \n    #10;\n    display_result(binary_in, bcd_out);    \n\n    // Test case 25\n    binary_in = 8'd211;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 26\n    binary_in = 8'd219; \n    #10;\n    display_result(binary_in, bcd_out);\n\n    // Test case 27\n    binary_in = 8'd222;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 28\n    binary_in = 8'd225; \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 29\n    binary_in = 8'd237;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 30\n    binary_in = 8'd247;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 31\n    binary_in = 8'd250; \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 32\n    binary_in = 8'd255;  \n    #10;\n    display_result(binary_in, bcd_out);\n    \n    // Test case 33\n    $display(\"Randomized Binary-to-BCD Testing...\");\n    for (int i = 0; i < 50; i++) begin\n      binary_in = $urandom_range(0, 255);\n      #10;\n      display_result(binary_in, bcd_out);\n    end\n\n    // Test case 34\n    $display(\"Full-Range Binary-to-BCD Testing...\");\n    for (int i = 0; i < 256; i = i + 1) begin\n      binary_in = i;\n      #10;\n      display_result(binary_in, bcd_out);\n    end\n\n    $display(\"Binary-to-BCD Testbench Completed Successfully!\");\n    $finish;\n  end\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_binary_to_bcd.sv": ""}}, "harness": {"files": {"docker-compose.yml": "\nservices:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "VERILOG_SOURCES = ./rtl/binary_to_bcd.sv\nHASH            = ac9f9e1901f321d67bd3730538590c5b0c3a0b9e\nNUM_BUGS        = 4\n", "src/binary_to_bcd.sv": "`timescale 1ns / 1ps\n\nmodule binary_to_bcd (\n    input logic [7:0] binary_in,  // 8-bit binary input\n    output logic [11:0] bcd_out  // 12-bit BCD output (3 digits)\n);\n\n  // Intermediate shift register to hold binary and BCD values\n  logic [19:0] shift_reg;  // 20-bit register: 12 for BCD + 8 for binary input\n  integer i;\n\n  always @(*) begin\n    // Step 1: Initialize the shift register\n`ifndef BUG_0\n    shift_reg = {12'd0, binary_in};  // Concatenate 12 zeros and binary input\n`else\n    shift_reg = {binary_in, 12'd0};  // Incorrect placement of binary input\n`endif\n\n    // Step 2: Perform the Double Dabble process\n    for (i = 0; i < 8; i = i + 1) begin\n\n      // BCD Adjustment Logic\n`ifndef BUG_1\n      if (shift_reg[11:8] >= 5) shift_reg[11:8] = shift_reg[11:8] + 3;\n      if (shift_reg[15:12] >= 5) shift_reg[15:12] = shift_reg[15:12] + 3;\n      if (shift_reg[19:16] >= 5) shift_reg[19:16] = shift_reg[19:16] + 3;\n`else\n      // Bug: Missing BCD adjustment, causing incorrect output\n`endif\n\n      // Shift left by 1 bit, shifting in a zero at the LSB\n`ifndef BUG_2\n      shift_reg = shift_reg << 1;\n`else\n      shift_reg = {1'b0, shift_reg[19:1]};  // Incorrect right shift instead of left shift\n`endif\n    end\n\n    // Step 3: Assign the upper 12 bits of the shift register to BCD output\n`ifndef BUG_3\n    bcd_out = shift_reg[19:8];  // Correct extraction of BCD output\n`else\n    bcd_out = shift_reg[15:4];  // Bug: Extracting wrong bits\n`endif\n  end\n\nendmodule\n", "src/process.py": "import os\r\nimport re\r\nimport subprocess\r\nimport pytest\r\n\r\n# ----------------------------------------\r\n# - Simulate\r\n# ----------------------------------------\r\n\r\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\r\n\r\ndef check_log(filename = \"sim.log\", expected = 0):\r\n\r\n    # ----------------------------------------\r\n    # - Check for errors in the log\r\n    # ----------------------------------------\r\n\r\n    with open(filename) as f:\r\n        lines = f.readlines()\r\n\r\n    errors = []\r\n    for line in lines[3:]:\r\n        errors.append(re.findall(r'*E', line))\r\n\r\n    # ----------------------------------------\r\n    # - Evaluate Report\r\n    # ----------------------------------------\r\n\r\n    assert len(errors) == expected, \"Simulation ended with error.\"\r\n\r\n@pytest.mark.usefixtures(scope='session')\r\ndef test_sanity():\r\n\r\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\r\n    assert(res.returncode == 0), \"Simulation ended with error.\"\r\n\r\n# ----------------------------------------\r\n# - Generate Bug Simulations\r\n# ----------------------------------------\r\n\r\n@pytest.mark.usefixtures(scope='test_sanity')\r\ndef test_errors():\r\n\r\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\r\n\r\n    for i in range(num_bugs):\r\n        bug = f\"-define BUG_{i}=1\"\r\n        cmd = f\"{sim} {bug}\"\r\n\r\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\r\n        assert(res.returncode != 0), \"Simulation ended without error.\""}}}
{"id": "cvdp_copilot_binary_to_BCD_0034", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the `binary_to_bcd` module to ensure its correct functionality during simulation? The assertions should cover the key aspects of the Double Dabble algorithm, ensuring that the output (`bcd_out`) remains within valid bounds (each 4-bit BCD digit should be between `0 to 9`) after the binary-to-BCD conversion process.\n___\n### Key Assertions\n##\n**1. BCD Output Validity**\n  - Condition:\n    - Each 4-bit BCD digit must be within the valid decimal range (`0\u20139`).\n    - If any BCD digit exceeds `1001`, the assertion should trigger an error message that includes:\n      - Binary input (`binary_in`).\n      - Faulty BCD output (`bcd_out`).\n  -  Assertion Implementation:\n     - Check each BCD digit (hundreds, tens, ones):\n      - `bcd_out[11:8]` (Hundreds)\n      - `bcd_out[7:4]` (Tens)\n      - `bcd_out[3:0]` (Ones)\n  - Error Message:\n    - The display message of actual value of result.\n\n___\n### Implementation Requirements\n**1. Placement**\n  - Assertions must be placed inside the RTL module (`binary_to_bcd`) to check for violations at runtime.\n\n**2. Immediate Assertions**\n  - Use `assert()` inside `always` for real-time verification of the BCD conversion.\n\n**3. Failure Handling**\n  - If an assertion fails, the simulation should:\n    - Display debug information (`$display`).\n\n___\n### Interface\n##\n**INPUT**\n  - `binary_in[7:0]`: A 8-bit Binary input value to be converted into BCD.\n\n**OUTPUT**\n  - `bcd_out[11:0]`: A 3-digit BCD output converted from binary input, each digit represented by 4 bits.\n___", "context": {"rtl/binary_to_bcd.sv": "module binary_to_bcd (\n    input logic [7:0] binary_in,  // 8-bit binary input\n    output logic [11:0] bcd_out  // 12-bit BCD output (3 digits)\n);\n\n  logic [19:0] shift_reg;  \n  integer i;\n\n  always @* begin\n    shift_reg = {12'd0, binary_in};  \n    for (i = 0; i < 8; i = i + 1) begin\n      if (shift_reg[11:8] >= 5) shift_reg[11:8] = shift_reg[11:8] + 3;\n      if (shift_reg[15:12] >= 5) shift_reg[15:12] = shift_reg[15:12] + 3;\n      if (shift_reg[19:16] >= 5) shift_reg[19:16] = shift_reg[19:16] + 3;\n\n      shift_reg = shift_reg << 1;\n    end\n\n    bcd_out = shift_reg[19:8];\n\n  end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/binary_to_bcd.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/binary_to_bcd.sv\nTOPLEVEL        = binary_to_bcd\nMODULE          = test_binary_to_bcd\nPYTHONPATH      = /src\nHASH            = 34-assertion-for-binary-to-bcd-converter\n", "src/test_binary_to_bcd.py": "\nimport cocotb\nfrom cocotb.triggers import Timer\nimport random\n\n\ndef binary_to_bcd(binary_in):\n    \"\"\" Reference function for binary to BCD conversion using Double Dabble algorithm in Python \"\"\"\n    bcd_digits = [0, 0, 0]  # Initialize 3 BCD digits\n    for i in range(8):  # 8-bit binary input\n        # Add 3 if any BCD digit is 5 or greater\n        if bcd_digits[2] >= 5:\n            bcd_digits[2] += 3\n        if bcd_digits[1] >= 5:\n            bcd_digits[1] += 3\n        if bcd_digits[0] >= 5:\n            bcd_digits[0] += 3\n        # Shift left and add next binary bit\n        bcd_digits[2] = (bcd_digits[2] << 1) | (bcd_digits[1] >> 3)\n        bcd_digits[1] = ((bcd_digits[1] << 1) & 0xF) | (bcd_digits[0] >> 3)\n        bcd_digits[0] = ((bcd_digits[0] << 1) & 0xF) | ((binary_in >> (7 - i)) & 0x1)\n    return (bcd_digits[2] << 8) | (bcd_digits[1] << 4) | bcd_digits[0]\n\n\n@cocotb.test()\nasync def test_binary_to_bcd(dut):\n    \"\"\" Test binary to BCD conversion using a reference model, with predefined and random test cases \"\"\"\n    \n    # Define a range of predefined test cases\n    test_cases = [0, 20, 99, 128, 255]\n    \n    # Generate additional random test cases\n    random_test_cases = [random.randint(0, 255) for _ in range(5)]\n    \n    # Combine predefined and random test cases\n    all_test_cases = test_cases + random_test_cases\n\n    for binary_value in all_test_cases:\n        # Apply the binary input to the DUT\n        dut.binary_in.value = binary_value\n        await Timer(10, units=\"ns\")\n\n        # Calculate the expected BCD output using the reference model\n        expected_bcd = binary_to_bcd(binary_value)\n\n        # Retrieve the actual BCD output from the DUT\n        bcd_out = int(dut.bcd_out.value)\n\n        # Check if the DUT output matches the expected BCD output\n        assert bcd_out == expected_bcd, f\"Test failed for binary {binary_value}: Expected {expected_bcd:012b}, got {bcd_out:012b}\"\n        \n        # Print results\n        dut._log.info(f\"Binary Input: {binary_value} | Expected BCD Output: {expected_bcd:012b} | DUT BCD Output: {bcd_out:012b}\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}}
{"id": "cvdp_copilot_binary_to_gray_0011", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the `binary_to_gray` module to ensure its correct functionality during simulation? The assertions should validate the correctness of the Binary to Gray code conversion, ensuring that the Gray code output (`gray_out`) follows the expected XOR-based transformation rules and maintains one-bit change property between successive binary inputs.\n\n___\nKey Assertions\n**1. Correct Gray Code Conversion**\n  - **Condition:**\n    - Each bit of the Gray code output should follow the rule:\n                                   `G[i]=B[i+1] XOR B[i]`\n     where the most significant bit (MSB) remains unchanged:\n                              `G[WIDTH\u22121]=B[WIDTH\u22121]`\n    - If the computed `gray_out` does not match the expected value, the assertion should trigger an error message that includes:\n      - Binary input (`binary_in`).\n      - Faulty Gray code output (`gray_out`).\n      - Expected correct Gray code value.\n\n  - **Assertion Implementation:**\n    - Verify that the generated Gray code follows the `XOR` transformation for all bits.\n    - Ensure the `MSB` remains the same as the binary input's `MSB`.\n \n  - **Error Message:**\n    - The assertion should display the actual and expected values to aid debugging.\n\n___\n### Implementation Requirements\n\n  **1. Placement**\n   - Assertions must be placed inside the RTL module (`binary_to_gray`) to validate real-time behavior during simulation.\n\n  **2. Immediate Assertions**\n   - Use `assert()` inside an always block for real-time validation of Gray code conversion logic.\n\n  **3. Failure Handling**\n   - If an assertion fails, the simulation should:\n   - Display debug information (`$display`).\n   - Identify the incorrect transformation and indicate the expected behavior.\n\n___\n### Interface: \n  **PARAMETER**\n   - `WIDTH`: Define the bit width of the input(Default: 6)\n\n  **INPUT**\n   - `binary_in[5:0]`: A 6-bit binary input value to be converted into Gray code.\n  \n  **OUTPUT**\n   - `gray_out[5:0]`: A 6-bit Gray code output derived from the binary input.", "context": {"rtl/binary_to_gray.sv": "module binary_to_gray #(\n    parameter WIDTH = 6 \n    input  wire [WIDTH-1:0] binary_in,  \n    output wire [WIDTH-1:0] gray_out    \n);\n\n \n  assign gray_out[WIDTH-1] = binary_in[WIDTH-1];\n\n  generate\n    genvar i;\n    for (i = 0; i < WIDTH - 1; i = i + 1) begin\n      assign gray_out[i] = binary_in[i+1] ^ binary_in[i];\n    end\n  endgenerate\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/binary_to_gray.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/binary_to_gray.sv\nTOPLEVEL        = binary_to_gray\nMODULE          = test_binary_to_gray\nPYTHONPATH      = /src\nHASH            = 11-assertion-generation-for-binary-to-gray-converter\n", "src/test_binary_to_gray.py": "import cocotb\nfrom cocotb.triggers import Timer\nimport random\nimport os\n\n@cocotb.test()\nasync def test_binary_to_gray(dut):\n    \"\"\"Test Binary to Gray Code Conversion\"\"\"\n\n    # Read width parameter from DUT\n    WIDTH = int(dut.WIDTH.value)\n\n    # Function to calculate Gray code in Python\n    def binary_to_gray(binary):\n        return binary ^ (binary >> 1)\n\n    # Predefined test cases based on WIDTH\n    predefined_cases = [i for i in range(2 ** WIDTH)]  # All possible values for WIDTH bits\n\n    # Run predefined test cases\n    dut._log.info(f\"Running predefined test cases with WIDTH={WIDTH}\")\n    for binary in predefined_cases:\n        dut.binary_in.value = binary\n        await Timer(10, units=\"ns\")  # Wait for 10 ns\n        gray = binary_to_gray(binary)\n        dut_gray = int(dut.gray_out.value)  # Convert LogicArray to integer\n        cocotb.log.info(f\"Pushed Binary: {binary:0{WIDTH}b}, Expected Gray: {gray:0{WIDTH}b}, DUT Gray: {dut_gray:0{WIDTH}b}\")\n        assert dut_gray == gray, \\\n            f\"Predefined Test Failed: Binary={binary:0{WIDTH}b}, Expected Gray={gray:0{WIDTH}b}, Got={dut_gray:0{WIDTH}b}\"\n\n    # Print message to indicate transition to random cases\n    dut._log.info(\"--- Printing Random Values ---\")\n\n    # Random test cases\n    for _ in range(16):\n        binary = random.randint(0, (1 << WIDTH) - 1)  # Generate random WIDTH-bit binary\n        dut.binary_in.value = binary\n        await Timer(10, units=\"ns\")  # Wait for 10 ns\n        gray = binary_to_gray(binary)\n        dut_gray = int(dut.gray_out.value)  # Convert LogicArray to integer\n        cocotb.log.info(f\"Pushed Binary: {binary:0{WIDTH}b}, Expected Gray: {gray:0{WIDTH}b}, DUT Gray: {dut_gray:0{WIDTH}b}\")\n        assert dut_gray == gray, \\\n            f\"Random Test Failed: Binary={binary:0{WIDTH}b}, Expected Gray={gray:0{WIDTH}b}, Got={dut_gray:0{WIDTH}b}\"\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}}
{"id": "cvdp_copilot_binary_to_one_hot_decoder_0009", "categories": ["cid013", "easy"], "input": {"prompt": "Create a **SystemVerilog testbench checker** with detailed stimulus to test using checker and to validate the `binary_to_one_hot_decoder` module by applying exhaustive test scenarios and verifying the correctness of its **one-hot encoded** output. The testbench should ensure:\n\n- Comprehensive **input stimulus** generation covering all possible cases.\n- **Checker generation** of the one-hot output.\n---\n## **Instantiation**\nName the instance of the RTL as `dut`.\n\n## **RTL Inputs - Outputs and Functional behaviour**\n\n### **Inputs:**  \n- **`binary_in` (BINARY_WIDTH bits)**  \n  - Represents an unsigned binary number in the range `[0, 2^BINARY_WIDTH - 1]`.  \n  - Example: For `BINARY_WIDTH = 5`, valid inputs range from `5'b00000` to `5'b11111`.  \n\n### **Outputs:**  \n- **`one_hot_out` (OUTPUT_WIDTH bits)**  \n  - A one-hot representation where the bit at index `binary_in` is set (`1`), while all others remain `0`.  \n  - Example: If `binary_in = 5'd3`, the expected output is:  \n    ```verilog\n    one_hot_out = 32'b00000000000000000000000000001000;\n    ```\n    (assuming `OUTPUT_WIDTH >= 4`).  \n  - If `binary_in` is **out of range** (`binary_in >= OUTPUT_WIDTH`), then `one_hot_out` should be all `0`s.  \n\n---\n\n## Stimulus and checker generation\n\n### **1. Functional Verification**  \n- Iterate through **all valid `binary_in` values** and check that `one_hot_out` has exactly **one bit set** at the correct position.  \n\n### **2. Edge Case Testing**  \n- **Lower boundary:** `binary_in = 0` \u2192 Expect `one_hot_out = 1 at index 0`.  \n- **Upper boundary:** `binary_in = 2^BINARY_WIDTH - 1` \u2192 Expect `one_hot_out = 1 at index (2^BINARY_WIDTH - 1)`.  \n\n## Simulation\n- Apply the test cases sequentially.\n- Log errors if any discrepancies are found between dut outputs and the model using `$error`.\n\n## Deliverables\nProvide the complete SystemVerilog testbench code with:\n1. dut instantiation.\n2. Implement a behavioral model to replicate the expected functionality.\n3. Test scenarios validating the dut against the expected behavior.\n4. Compare the outputs from the DUT with the model using checkers.\n5. Log messages indicating for error status for each test case.\n---", "context": {}}, "output": {"response": "", "context": {"verif/tb_binary_to_one_hot_decoder.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/binary_to_one_hot_decoder.v\nHASH            = 9-tb-checker\nNUM_BUGS        = 3", "src/binary_to_one_hot_decoder.v": "\nmodule binary_to_one_hot_decoder #(\n    parameter       BINARY_WIDTH        = 5,   \n    parameter       OUTPUT_WIDTH        = 32   \n) (\n    input   wire    [BINARY_WIDTH-1:0]  binary_in,   \n    output  reg    [OUTPUT_WIDTH-1:0]  one_hot_out  \n);\n    genvar i;\n    generate\n        `ifdef BUG_0\n            for (i = 0; i < OUTPUT_WIDTH; i = i + 2) begin : per_output\n                \n                always @(*) begin\n                    \n                    one_hot_out[i] = (binary_in == i);\n                end\n            end\n        `elsif BUG_1\n            for (i = 0; i < OUTPUT_WIDTH; i = i + 1) begin : per_output\n                \n                always @(*) begin\n                    \n                    one_hot_out[OUTPUT_WIDTH-i-1] = (binary_in == i);\n                end\n            end\n        `elsif BUG_2\n            for (i = 0; i < OUTPUT_WIDTH; i = i + 1) begin : per_output\n                \n                always @(*) begin\n                    \n                    one_hot_out[i] = (binary_in == OUTPUT_WIDTH-i );\n                end\n            end\n        `else\n            for (i = 0; i < OUTPUT_WIDTH; i = i + 1) begin : per_output\n                \n                always @(*) begin\n                    \n                    one_hot_out[i] = (binary_in == i);\n                end\n            end\n        `endif\n    endgenerate\n\nendmodule\n\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.v /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\""}}}
{"id": "cvdp_copilot_cache_lru_0027", "categories": ["cid014", "easy"], "input": {"prompt": "Create a SystemVerilog Assertion to verify that for a given index, once one of its way counters has reached the\nmaximum frequency, it remains possible for this same way to eventually be selected for replacement in the future.\nThis is a liveness check. The assertion should be designed to allow verification of any index or way during\nsimulation.\n\n## Design Specifications\n\n### Module Name: `lfu_counter_policy`\n\n### Parameters\n1. **NWAYS**: Number of ways in the cache (default: 4). Must be a power of 2 and at least 4.\n2. **NINDEXES**: Number of indexes in the cache (default: 32). Must be a power of 2.\n3. **COUNTERW**: Width of frequency counters for LFU (default: 2). Must be at least 2.\n\n### Ports\n\n| Port Name       | Direction | Size                          | Description                                          |\n|-----------------|-----------|-------------------------------|------------------------------------------------------|\n| `clock`         | Input     | 1 bit                         | Clock signal (rising edge)                           |\n| `reset`         | Input     | 1 bit                         | Asynchronous reset signal, active high               |\n| `index`         | Input     | `ceil(log2(NINDEXES))` bits   | Index to select the cache set                        |\n| `way_select`    | Input     | `ceil(log2(NWAYS))` bits      | Cache way selected for access                        |\n| `access`        | Input     | 1 bit                         | Signal indicating a cache access                     |\n| `hit`           | Input     | 1 bit                         | Signal indicating a cache hit                        |\n| `way_replace`   | Output    | `ceil(log2(NWAYS))` bits      | Way selected for replacement                         |\n\n### Relevant Code Details\n\nThe `lfu_counter_policy` module maintains a frequency file that stores bit arrays for each cache index. Each bit array\ncontains one counter per way, with the counter size defined by `COUNTERW`.\n\n```sv\n    reg [(NWAYS * COUNTERW)-1:0] frequency [NINDEXES-1:0];\n```\n\n### Expected Behavior\n\nAn assertion failure must include an error message with details helpful for debugging.", "context": {"rtl/lfu_counter_policy.sv": "module lfu_counter_policy #(\n    parameter NWAYS = 4,\n    parameter NINDEXES = 32,\n    parameter COUNTERW = 2\n)(\n    input clock,\n    input reset,\n    input [$clog2(NINDEXES)-1:0] index,\n    input [$clog2(NWAYS)-1:0] way_select,\n    input access,\n    input hit,\n    output [$clog2(NWAYS)-1:0] way_replace\n);\n\n    localparam int unsigned MAX_FREQUENCY = $pow(2, COUNTERW) - 1;\n\n    // Frequency array to track next way to be replaced\n    reg [(NWAYS * COUNTERW)-1:0] frequency [NINDEXES-1:0];\n\n    integer i, n;\n\n    // Sequential logic for reset and frequency updates\n    always_ff @ (posedge clock or posedge reset) begin\n        if (reset) begin\n            for (i = 0; i < NINDEXES; i = i + 1) begin\n                for (n = 0; n < NWAYS; n = n + 1) begin\n                    frequency[i][(n * COUNTERW) +: COUNTERW] <= COUNTERW'(0);\n                end\n            end\n        end else begin\n            if (access) begin\n                if (hit) begin\n                    // Set the frequency counter of the accessed way\n                    if (frequency[index][(way_select * COUNTERW) +: COUNTERW] < COUNTERW'(MAX_FREQUENCY)) begin\n                        frequency[index][(way_select * COUNTERW) +: COUNTERW] <= frequency[index][(way_select * COUNTERW) +: COUNTERW] + COUNTERW'(1);\n                    end else begin\n                        for (n = 0; n < NWAYS; n = n + 1) begin\n                            if (n != way_select && frequency[index][(n * COUNTERW) +: COUNTERW] > COUNTERW'(2)) begin\n                                frequency[index][(n * COUNTERW) +: COUNTERW] <= frequency[index][(n * COUNTERW) +: COUNTERW] - COUNTERW'(1);\n                            end\n                        end\n                    end\n                end else begin\n                    // Set the frequency counter of the replaced way\n                    frequency[index][(way_replace * COUNTERW) +: COUNTERW] <= COUNTERW'(1);\n                end\n            end\n        end\n    end\n\n    // Select the LFU slot\n    slot_select_lfu_counter #(\n        .NWAYS (NWAYS),\n        .COUNTERW (COUNTERW)\n    ) slot_select_unit (\n        .array (frequency[index]),\n        .index (way_replace)\n    );\n\nendmodule : lfu_counter_policy\n\nmodule slot_select_lfu_counter #(\n    parameter NWAYS = 4,\n    parameter COUNTERW = $clog2(NWAYS)\n)(\n    input logic [(NWAYS * COUNTERW)-1:0] array,\n    output logic [$clog2(NWAYS)-1:0] index\n);\n\n    integer i;\n\n    always_comb begin\n        // Default outputs\n        index = $clog2(NWAYS)'(0);\n\n        // Find the index of the first counter with minimum frequency\n        for (i = 0; i < NWAYS; i++) begin\n            if (array[(i * COUNTERW) +: COUNTERW] < array[(index * COUNTERW) +: COUNTERW]) begin\n                index = $clog2(NWAYS)'(i);\n            end\n        end\n    end\n\nendmodule : slot_select_lfu_counter"}}, "output": {"response": "", "context": {"rtl/lfu_counter_policy.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    image: verification_image\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/lfu_counter_policy.sv\nTOPLEVEL        = lfu_counter_policy\nMODULE          = test_lfu_counter_policy\nPYTHONPATH      = /src\nHASH            = 26782beaeb59212a70be799bd32493b75c05abf2", "src/coverage.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n", "src/test_lfu_counter_policy.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\n\nasync def test_lfu_max_frequency(dut):\n    \"\"\"Test behavior when counters reach MAX_FREQUENCY.\"\"\"\n    cocotb.log.info(\"Starting test_lfu_max_frequency...\")\n\n    nways = int(dut.NWAYS.value)\n    index = int(dut.VERIFY_INDEX.value)\n    target_way = int(dut.VERIFY_WAY.value)\n    max_frequency = int(dut.MAX_FREQUENCY.value)\n\n    await hrs_lb.reset(dut)\n\n    cocotb.log.debug(f\"Target index: {index}, Target way: {target_way}, MAX_FREQUENCY: {max_frequency}\")\n\n    await FallingEdge(dut.clock)\n    dut.way_select.value = target_way\n    dut.index.value = index\n    dut.access.value = 1\n    dut.hit.value = 1\n\n    # Set selected way counter to the max frequency value\n    for i in range(max_frequency):\n        await FallingEdge(dut.clock)\n\n    # Set max frequency to another way, so the target way has its counter decreased\n    for n in reversed(range(nways)):\n        if n == target_way:\n            continue\n        dut.way_select.value = n\n        assert n != target_way\n\n    iterations = max_frequency * 2\n    for i in range(iterations):\n        await FallingEdge(dut.clock)\n\n    # Set the frequency to at least 3 in the other ways\n    for n in reversed(range(nways)):\n        if n == target_way:\n            continue\n        dut.way_select.value = n\n        iterations = 3\n        for i in range(iterations):\n            await FallingEdge(dut.clock)\n\n\n@cocotb.test()\nasync def test_policy_working(dut):\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_policy_working...\")\n\n    clock_period = 10  # ns\n    await cocotb.start(Clock(dut.clock, clock_period, units=\"ns\").start())\n    await hrs_lb.dut_init(dut)\n\n    nways = int(dut.NWAYS.value)\n    nindexes = int(dut.NINDEXES.value)\n    max_frequency = int(dut.MAX_FREQUENCY.value)\n    counter_width = int(dut.COUNTERW.value)\n    cocotb.log.info(f\"NWAYS: {nways}  NINDEXES: {nindexes}  COUNTERW: {counter_width}  MAX_FREQUENCY: {max_frequency}\")\n\n    await test_lfu_max_frequency(dut)\n    cocotb.log.info(\"Test 1: MAX_FREQUENCY passed.\")\n\n    cocotb.log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nimport random\nimport pytest\nimport coverage\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef call_runner(NWAYS: int = 4, NINDEXES: int = 32, COUNTERW: int = 2):\n    parameters = {\n        \"NWAYS\": NWAYS,\n        \"NINDEXES\": NINDEXES,\n        \"COUNTERW\": COUNTERW,\n        \"VERIFY_WAY\": random.randint(0, NWAYS-1),\n        \"VERIFY_INDEX\": random.randint(0, NINDEXES-1)\n    }\n\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        coverage.coverage_report(\"assertion\")\n        coverage.covt_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n    # Run the simulation\n    call_runner()\n\n    # # Run the simulation with different parameters\n    call_runner(8, 16, math.ceil(math.log2(8)))\n    call_runner(8, 16, math.ceil(math.log2(8))+1)\n    call_runner(8, 16, math.ceil(math.log2(8))-1)\n    call_runner(16, 64)\n    call_runner(16, 64, math.ceil(math.log2(16)))\n"}}}
{"id": "cvdp_copilot_cache_lru_0028", "categories": ["cid014", "easy"], "input": {"prompt": "Create a SystemVerilog Assertion to verify the **FIFO behavior** in the `fifo_policy` module. The module implements a FIFO-based cache replacement policy. Please verify that once one way is selected for replacement, after a new batch of miss cycles (not necessarily in consecutive cycles), the same way is selected for replacement again.\n\n## Design Specifications\n\n### Module Name: `fifo_policy`\n\n### Parameters:\n- **NWAYS**: Number of cache ways.\n- **NINDEXES**: Number of cache indexes.\n\n### Inputs:\n- **clock**: System clock (rising edge).\n- **reset**: Reset signal for initializing the FIFO state. Reset is active-high and asynchronous.\n- **index**: Cache index, selects the set in the cache.\n- **way_select**: Currently selected cache way (input, but not directly used in the FIFO logic).\n- **access**: Indicates an access to the cache.\n- **hit**: Indicates whether the access was a cache hit. A value of `0` indicates a miss.\n\n### Outputs:\n- **way_replace**: The cache way to be replaced is determined based on the FIFO policy. After reset, it remains unchanged until the first miss for the index occurs.\n\n### Relevant Code Details\n\nThe `fifo_policy` module maintains a **FIFO array** that stores a pointer to the next way to be replaced for each cache index. **The pointer functions as a counter that increments on each miss.** When it reaches `NWAYS-1`, it overflows and restarts, **pointing to position `0`**.\n\n```sv\n    reg [$clog2(NWAYS)-1:0] fifo_array [NINDEXES-1:0];    \n```\n\n### Expected Behavior\n\nAn assertion failure must include an error message to help debugging.", "context": {"rtl/fifo_policy.sv": "module fifo_policy #(\n    parameter NWAYS = 4,\n    parameter NINDEXES = 32\n)(\n    input clock,\n    input reset,\n    input [$clog2(NINDEXES)-1:0] index,\n    input [$clog2(NWAYS)-1:0] way_select,\n    input access,\n    input hit,\n    output [$clog2(NWAYS)-1:0] way_replace\n);\n\n    // FIFO array to track next way to be replaced\n    reg [$clog2(NWAYS)-1:0] fifo_array [NINDEXES-1:0];\n\n    integer i;\n\n    // Sequential logic for reset and fifo_array updates\n    always_ff @ (posedge clock or posedge reset) begin\n        if (reset) begin\n            for (i = 0; i < NINDEXES; i++) begin\n                fifo_array[i] <= $clog2(NWAYS)'(0);\n            end\n        end else begin\n            if (access && ~hit) begin\n                // Set the fifo_array position for the next replacement\n                fifo_array[index] <= fifo_array[index] + $clog2(NWAYS)'(1);\n            end\n        end\n    end\n\n    assign way_replace = fifo_array[index];\n\nendmodule : fifo_policy"}}, "output": {"response": "", "context": {"rtl/fifo_policy.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    image: verification_image\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/fifo_policy.sv\nTOPLEVEL        = fifo_policy\nMODULE          = test_fifo_policy\nPYTHONPATH      = /src\nHASH            = c3f6c3ed031df38d5820fef5cfe4afffed1fb171", "src/coverage.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\n\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\n\nasync def access_hit(dut, index_a, way_select_a):\n    dut.access.value = 1\n    dut.hit.value = 1\n    dut.index.value = index_a\n    dut.way_select.value = way_select_a\n\n    await FallingEdge(dut.clock)\n    print(f\"[DEBUG] way_replace: {dut.way_replace.value}\")\n    dut.access.value = 0\n    dut.hit.value = 0\n\n\nasync def access_miss(dut, index_a, way_select_a):\n    dut.access.value = 1\n    dut.hit.value = 0\n    dut.index.value = index_a\n    dut.way_select.value = way_select_a\n\n    await FallingEdge(dut.clock)\n    print(f\"[DEBUG] way_replace: 0b{dut.way_replace.value.integer:04b}\")\n    dut.access.value = 0\n    dut.hit.value = 0\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n", "src/test_fifo_policy.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nimport harness_library as hrs_lb\nimport random\n\n\nasync def test_fifo_behavior(dut):\n    \"\"\"Test the replacement order.\"\"\"\n    cocotb.log.info(\"Starting test_fifo_behavior...\")\n\n    await hrs_lb.dut_init(dut)\n    await hrs_lb.reset(dut)\n\n    nindexes = int(dut.NINDEXES.value)\n    nways = int(dut.NWAYS.value)\n\n    index = random.randint(0, nindexes-1)\n    target_way = random.randint(0, nways-1)\n\n    dut.index.value = index\n    dut.way_select.value = target_way\n\n    for n in range((nways * 2) + 1):\n        cocotb.log.debug(f\"Target index: {index}, Target way: {target_way}\")\n        if n > nways - 2:\n            await hrs_lb.access_hit(dut, index, target_way)\n        else:\n            await hrs_lb.access_miss(dut, index, target_way)\n\n    cocotb.log.debug(f\"Target index: {index}, Target way: {target_way}\")\n    await hrs_lb.access_miss(dut, index, target_way)\n    await hrs_lb.access_miss(dut, index, target_way)\n\n    cocotb.log.info(\"test_fifo_behavior passed.\")\n\n\n@cocotb.test()\nasync def test_policy_working(dut):\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_policy_working...\")\n\n    clock_period = 10  # ns\n    await cocotb.start(Clock(dut.clock, clock_period, units=\"ns\").start())\n\n    nways = int(dut.NWAYS.value)\n    nindexes = int(dut.NINDEXES.value)\n    cocotb.log.info(f\"NWAYS: {nways}  NINDEXES: {nindexes}\")\n\n    await test_fifo_behavior(dut)\n\n    cocotb.log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nimport random\nimport pytest\nimport coverage\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef call_runner(NWAYS: int = 4, NINDEXES: int = 32):\n    parameters = {\n        \"NWAYS\": NWAYS,\n        \"NINDEXES\": NINDEXES\n    }\n\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        coverage.coverage_report(\"assertion\")\n        coverage.covt_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n    # Run the simulation\n    call_runner()\n\n    # # Run the simulation with different parameters\n    call_runner(8, 32)\n    call_runner(16, 32)\n    call_runner(32, 32)\n"}}}
{"id": "cvdp_copilot_caesar_cipher_0036", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the SystemVerilog testbench to verify the encryption and decryption of ASCII phrases, where the phrase length can be parameterized.\n\n---\n\n## **Design Specification**\n\n### **Parameters**\n\n- **`PHRASE_WIDTH`**  \n  Defines the total bit-width for the input and output phrase. Each ASCII character is 8 bits, so a larger width accommodates more characters. Default: **16** bits.\n\n- **`PHRASE_LEN`**  \n  Defines the number of characters in the phrase. Typically computed as `PHRASE_WIDTH / 8`. Default leads to **2** characters.\n\n- **`KEY_WIDTH`**  \n  Defines the total bit-width for the key phrase. Typically `PHRASE_LEN * 5`. Each character is shifted by a 5-bit key (range 0 to 31).\n\n### **Inputs**\n\n- **`input_phrase [PHRASE_WIDTH-1:0]`**: Carries one or more 8-bit ASCII characters, concatenated.  \n- **`key_phrase [KEY_WIDTH-1:0]`**: Contains the 5-bit shift key for each character, concatenated.  \n- **`decrypt`**: 1-bit control signal; 0 for encryption, 1 for decryption.\n\n### **Outputs**\n\n- **`output_phrase [PHRASE_WIDTH-1:0]`**: Contains the resulting shifted ASCII characters after encryption or decryption.\n\n### **Behavior**\n\n- **Encryption (`decrypt=0`)**  \n  1. **Uppercase Letters (`A..Z`)**: The design shifts each letter by its key value, wrapping within `[A..Z]`.  \n  2. **Lowercase Letters (`a..z`)**: The design shifts within `[a..z]` in a similar manner.  \n  3. **Non-Alphabetic**: The design adds the key to the character code directly.\n\n- **Decryption (`decrypt=1`)**  \n  1. **Uppercase Letters (`A..Z`)**: The design subtracts the key, wrapping within `[A..Z]`.  \n  2. **Lowercase Letters (`a..z`)**: The design subtracts the key within `[a..z]`.  \n  3. **Non-Alphabetic**: The design subtracts the key from the ASCII code.\n\n---\n\n## **Testbench Requirements**\n\n1. **Testbench Components**  \n   - **Input Generation**: Provide a variety of ASCII phrases of parameterized length, along with matching 5-bit subkeys for each character. Toggle `decrypt` between 0 and 1.  \n   - **Reference Checker**: Implement a function or task to compute the expected encrypted/decrypted output for each character, aligning with the Caesar cipher rules above.  \n   - **Comparison**: Compare the DUT\u2019s `output_phrase` with the reference result per test.  \n   - **Reporting**: Print pass/fail details, including input phrase, key phrase, decrypt mode, expected output, and actual output.\n\n2. **Key Test Scenarios**  \n   - **Uppercase**: Check wrap-around near `A` and `Z`.  \n   - **Lowercase**: Check wrap-around near `a` and `z`.  \n   - **Mixed Cases**: Strings with uppercase, lowercase, and non-letter symbols.  \n   - **Non-Alphabetic**: Verify additions/subtractions for digits, punctuation, etc.  \n   - **Random Tests**: Random phrase data and random 5-bit keys.  \n   - **Various Phrase Lengths**: If `PHRASE_WIDTH` > 16, test multiple characters.\n\n3. **Simulation**  \n   - Initialize signals.  \n   - Apply sequences of predefined test vectors covering alphabets, wrap-around, random data, and different key patterns.  \n   - For each test, compute expected output, compare with DUT, and report pass/fail.  \n   - Conclude the simulation (`$finish`) after verifying all tests.\n\n---\n\n## **Example Test Cases**\n\n1. **Simple Encrypt**  \n   - Input phrase: `\"AB\"`, each letter having a 5-bit key.  \n   - Check correct shifting of uppercase letters.\n\n2. **Simple Decrypt**  \n   - Input phrase: `\"Az\"` with a suitable key for each character.  \n   - Confirm wrapping for uppercase `'A'` and lowercase `'z'`.\n\n3. **Non-Alphabetic**  \n   - Input phrase: `\"?!\"`, keys for each character.  \n   - Verify addition or subtraction of key from ASCII codes.\n\n4. **Random**  \n   - Random ASCII characters over the parameterized width.  \n   - Random key bits, random `decrypt=0/1`.\n\n5. **Extended Phrases**  \n   - Larger `PHRASE_WIDTH` for more than 2 characters.  \n   - Validate each character is shifted properly by its corresponding 5-bit segment of the key phrase.\n\n---\n\n## **Expected Output**\n\n- For each test, display:  \n  - **Test ID**  \n  - **Input Phrase**  \n  - **Key Phrase**  \n  - **Mode** (encrypt or decrypt)  \n  - **Expected vs. DUT Output**  \n  - Pass or Fail message  \n- If any test fails, log an error and possibly terminate the simulation.  \n- End simulation after all tests complete, with a summary of pass/fail status.\n\n---\n\n## **Deliverables**\n\n1. Generate **test sequences** spanning uppercase, lowercase, punctuation, numbers, wrap-around near boundaries, random data, and varying phrase lengths.  \n2. Implement a **checker** that calculates the reference Caesar cipher output for each character.  \n3. Compare the **DUT outputs** with the reference and **log** pass/fail results.  \n4. End **simulation** once all tests finish.  ", "context": {"verif/caesar_cipher_tb.sv": "module caesar_cipher_tb;\nparameter PHRASE_WIDTH = 16;\nlocalparam PHRASE_LEN = PHRASE_WIDTH / 8;\nlocalparam KEY_WIDTH = PHRASE_LEN * 5;\n\nreg [PHRASE_WIDTH-1:0] input_phrase;\nreg [KEY_WIDTH-1:0] key_phrase;\nreg decrypt;\nwire [PHRASE_WIDTH-1:0] output_phrase;\ninteger i, test_count;\n\ncaesar_cipher #(\n    .PHRASE_WIDTH(PHRASE_WIDTH),\n    .PHRASE_LEN(PHRASE_LEN)\n) uut (\n    .input_phrase(input_phrase),\n    .key_phrase(key_phrase),\n    .decrypt(decrypt),\n    .output_phrase(output_phrase)\n);\n\ntask print_result(\n    input integer tcount,\n    input [PHRASE_WIDTH-1:0] in_phrase,\n    input [PHRASE_WIDTH-1:0] out_phrase,\n    input [KEY_WIDTH-1:0] keyph,\n    input reg dec\n);\n    integer idx;\n    reg [7:0] ch_in, ch_out;\n    reg [8*PHRASE_LEN-1:0] disp_in;\n    reg [8*PHRASE_LEN-1:0] disp_out;\n    integer k_hi, k_lo;\nbegin\n    disp_in  = {PHRASE_LEN*8{1'b0}};\n    disp_out = {PHRASE_LEN*8{1'b0}};\n    for (idx = 0; idx < PHRASE_LEN; idx = idx + 1) begin\n        ch_in = in_phrase[idx*8 +: 8];\n        ch_out = out_phrase[idx*8 +: 8];\n        disp_in[idx*8 +: 8]  = (ch_in  >= 32 && ch_in  < 127) ? ch_in  : 8'h2E;\n        disp_out[idx*8 +: 8] = (ch_out >= 32 && ch_out < 127) ? ch_out : 8'h2E;\n    end\n    k_hi = keyph[KEY_WIDTH-1:KEY_WIDTH-5];\n    k_lo = keyph[KEY_WIDTH-6:0];\n    $display(\"Test=%0d Time=%0t decrypt=%b input_phrase='%s' key_phrase=(%0d,%0d) output_phrase='%s'\",\n             tcount, $time, dec, disp_in, k_hi, k_lo, disp_out);\nend\nendtask\n\ntask do_test(\n    input [PHRASE_WIDTH-1:0] t_input_phrase,\n    input [KEY_WIDTH-1:0] t_key_phrase,\n    input t_decrypt\n);\nbegin\n    input_phrase = t_input_phrase;\n    key_phrase   = t_key_phrase;\n    decrypt      = t_decrypt;\n    #5;\n    test_count = test_count + 1;\n    print_result(test_count, input_phrase, output_phrase, key_phrase, decrypt);\nend\nendtask\n\ninitial begin\n    test_count = 0;\n    input_phrase = 0;\n    key_phrase = 0;\n    decrypt = 0;\n    #10;\n\n    do_test(\"AB\", 10'h21, 0);\n    do_test(\"AB\", 10'h21, 1);\n    do_test(\"AZ\", 10'h45, 0);\n    do_test(\"AZ\", 10'h45, 1);\n    do_test(\"az\", 10'h23, 0);\n    do_test(\"az\", 10'h23, 1);\n    do_test(\"zz\", 10'h3ff, 0);\n    do_test(\"zz\", 10'h3ff, 1);\n    do_test(\"HI\", 10'ha5, 0);\n    do_test(\"HI\", 10'ha5, 1);\n    do_test(\"Z?\", 10'h86, 0);\n    do_test(\"Z?\", 10'h86, 1);\n    do_test(\"z(\", 10'h61, 0);\n    do_test(\"z(\", 10'h61, 1);\n    do_test(\"Aa\", 10'ha1, 0);\n    do_test(\"Aa\", 10'ha1, 1);\n    do_test(\"09\", 10'h42, 0);\n    do_test(\"09\", 10'h42, 1);\n    do_test(\"!!\", 10'h21, 0);\n    do_test(\"!!\", 10'h21, 1);\n\n    for (i = 0; i < 20; i = i + 1) begin\n        do_test({$random,$random} & {PHRASE_WIDTH{1'b1}}, {$random} & {KEY_WIDTH{1'b1}}, $random % 2);\n    end\n\n    do_test(16'h5a5a, 10'h15a, 0);\n    do_test(16'h5a5a, 10'h15a, 1);\n    do_test(\"ZZ\", 10'h3e0, 0);\n    do_test(\"ZZ\", 10'h3e0, 1);\n    do_test(\"zz\", 10'h1f, 0);\n    do_test(\"zz\", 10'h1f, 1);\n    do_test(\"{|\", 10'h3ff, 0);\n    do_test(\"{|\", 10'h3ff, 1);\n    do_test(\"`a\", 10'h21, 0);\n    do_test(\"`a\", 10'h21, 1);\n    do_test(\"zZ\", 10'h34a, 0);\n    do_test(\"zZ\", 10'h34a, 1);\n    do_test(\"ab\", 10'h3f, 0);\n    do_test(\"ab\", 10'h3f, 1);\n    do_test(\"Ay\", 10'h1d, 0);\n    do_test(\"Ay\", 10'h1d, 1);\n    do_test(\"Zz\", 10'h3a2, 0);\n    do_test(\"Zz\", 10'h3a2, 1);\n    do_test(\"XY\", 10'ha6, 0);\n    do_test(\"XY\", 10'ha6, 1);\n    do_test(\"xy\", 10'h324, 0);\n    do_test(\"xy\", 10'h324, 1);\n\n    #10;\n    $finish;\nend\n\nendmodule"}}, "output": {"response": "", "context": {"verif/caesar_cipher_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/caesar_cipher.sv\nHASH            = fb2a4a57b5e0c9522208b54b895b4541cc857854\nNUM_BUGS        = 4\n", "src/caesar_cipher.sv": "`timescale 1ns/1ps\n\nmodule caesar_cipher #(\n    parameter PHRASE_WIDTH = 8,\n    parameter PHRASE_LEN   = PHRASE_WIDTH / 8\n)(\n    input  wire [PHRASE_WIDTH-1:0]       input_phrase,\n    input  wire [(PHRASE_LEN * 5) - 1:0] key_phrase,\n    input  wire                          decrypt,\n    output reg  [PHRASE_WIDTH-1:0]       output_phrase\n);\n    integer i;\n    reg [7:0] current_char;\n    reg [4:0] current_key;\n\n    always @(*) begin\n        output_phrase = {PHRASE_WIDTH{1'b0}};\n        if (PHRASE_LEN > 0) begin\n            for (i = 0; i < PHRASE_LEN; i = i + 1) begin\n                current_char = input_phrase[i*8 +: 8];\n                current_key  = key_phrase[i*5 +: 5];\n                if (decrypt) begin\n                    if (current_char >= \"A\" && current_char <= \"Z\") begin\n                        `ifndef BUG_0\n                            output_phrase[i*8 +: 8] = ((current_char - \"A\" - current_key + 26) % 26) + \"A\";\n                        `else\n                            output_phrase[i*8 +: 8] = ((current_char - \"A\" + current_key + 26) % 26) + \"A\";\n                        `endif\n                    end\n                    else if (current_char >= \"a\" && current_char <= \"z\")\n                        output_phrase[i*8 +: 8] = ((current_char - \"a\" - current_key + 26) % 26) + \"a\";\n                    else begin\n                        `ifndef BUG_2\n                            output_phrase[i*8 +: 8] = current_char - current_key;\n                        `else\n                            output_phrase[i*8 +: 8] = current_char + current_key;\n                        `endif\n                    end\n                end\n                else begin\n                    if (current_char >= \"A\" && current_char <= \"Z\") begin\n                        `ifndef BUG_1\n                            output_phrase[i*8 +: 8] = ((current_char - \"A\" + current_key) % 26) + \"A\";\n                        `else\n                            output_phrase[i*8 +: 8] = ((current_char - \"A\" - current_key) % 26) + \"A\";\n                        `endif\n                    end\n                    else if (current_char >= \"a\" && current_char <= \"z\")\n                        output_phrase[i*8 +: 8] = ((current_char - \"a\" + current_key) % 26) + \"a\";\n                    else begin\n                        `ifndef BUG_3\n                            output_phrase[i*8 +: 8] = current_char + current_key;\n                        `else\n                            output_phrase[i*8 +: 8] = current_char - current_key;\n                        `endif\n                    end\n                end\n            end\n        end\n    end\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_cascaded_adder_0021", "categories": ["cid013", "medium"], "input": {"prompt": "Create a **SystemVerilog testbench** for the `cascaded_adder` module. This testbench is designed to validate the functionality of cascading adders that compute the sum of multiple input data streams.\n\n## Cascaded Adder Overview:\nThis module named `cascaded_adder` performs the summation of multiple input data elements, synchronized to the clock, and supports asynchronous reset functionality. The input data is received as a flattened 1D vector, and the output provides the cumulative sum of all the input elements.\n\n## Parameters:\n - **`IN_DATA_WIDTH` (default = 16):** Specifies the bit-width of each individual input data element.\n - **`IN_DATA_NS` (default = 4):** Defines the number of input data elements to be summed.\n\n## Input Ports:\n- `clk`: Clock signal. The design registers are triggered on its positive edge.\n- `rst_n`: An active-low asynchronous reset signal. When low, the module is held in a reset state, and both `o_valid` and `o_data` are driven low.\n- `i_valid`: An active-high input signal that indicates the availability of valid data for processing. It is assumed to be synchronous to the positive edge of `clk` signal.\n- `i_data` [`IN_DATA_WIDTH` * `IN_DATA_NS` - 1 : 0]: Input data provided as a flattened 1D vector. This vector contains `IN_DATA_NS` elements, each `IN_DATA_WIDTH` bits wide. It is assumed to be synchronous to the positive edge of `clk` signal.\n\n## Output Ports:\n- `o_valid`: Active-high signal indicating that the output sum has been computed and is ready to be read. It is driven on the rising edge of the `clk`\n- `o_data` [(`IN_DATA_WIDTH` + $clog2(`IN_DATA_NS`)) - 1 : 0]: Output data representing the cumulative sum of all input elements. The output width is designed to accommodate the full sum **without overflow**. It is driven on the rising edge of the `clk`\n\n## Functional Description:\n\n### Input Data Structure:\n- The input data is a flattened 1D vector `i_data` with a total width of `IN_DATA_WIDTH` * `IN_DATA_NS`. \n- For instance, with `IN_DATA_NS` = 4 and `IN_DATA_WIDTH` = 16, the 64-bit wide `i_data` contains four 16-bit elements.\n- The input data is latched when i_valid is asserted, synchronized to the positive edge of the clock.\n\n### Cascaded Addition Process:\n- The summation is performed on the registered data in a cascaded manner using combinational logic, where each element is progressively added in sequence to the accumulated total.\n- Each stage adds the next element in the sequence to the cumulative result of the previous stages, ultimately producing the final sum.\n- The design includes an output register that latches the cumulative result at the positive edge of the clock.\n\n---\n```mermaid\ngraph LR;\n    A1((0)) --> B1(('+'))\n    A2((1)) --> B1\n    B1 --> B2(('+'))\n    A3((2)) --> B2\n    B2 --> B3\n    A4((3)) --> B3(('+'))\n    B3 --> Result[Result]\n```\n----\n\n### Latency:\nThe module introduces a total latency of two clock cycles. One cycle is added for registering the input data, and another for registering the output sum.\n\n## Requirements\n\n### 1. Testbench Components\n- **Parameters**:\n  - `IN_DATA_WIDTH`: Specifies the width of each individual data input.\n  - `IN_DATA_NS`: Number of separate data inputs to be summed.\n- **Local Parameters**:\n  - `INPUT_WIDTH`: Total width of the combined input data.\n  - `OUTPUT_WIDTH`: Width of the output data, accounting for the possible overflow from the sum.\n- **Signals**:\n  - `clk`: Clock signal with a 100 MHz frequency.\n  - `rst_n`: Active-low reset signal.\n  - `i_valid`: Input valid signal.\n  - `i_data`: Flattened array containing all input data streams.\n  - `o_valid`: Output valid signal.\n  - `o_data`: Output data containing the computed sum.\n\n### 2. Device Under Test (DUT)\n- Instantiate the **Cascaded Adder** with specified parameters for data width and number of inputs.\n\n### 3. Simulation and Validation\n- **Clock Generation**:\n  - Generate a continuous clock with a period of 10 ns.\n- **Reset Logic**:\n  - Initially hold the DUT in reset and release after 15 ns.\n- **Input Generation and Expectation Calculation**:\n  - Use tasks to generate random inputs (`generate_input`) and compute the expected sum (`calculate_expected_output`).\n- **Output Verification**:\n  - Compare the DUT's output with the expected result using another task (`check_output`). Log the result or raise an error if the output is incorrect.\n\n### 4. Test Procedures\n- **Task `run_test`**:\n  - Run multiple test iterations (e.g., 10 tests).\n  - For each test, generate input data, calculate the expected output, drive the inputs, and verify the output when `o_valid` is asserted.\n\n### 5. Detailed Test Scenarios\n- **Random Input Generation**:\n  - Generate test vectors with random values within the specified range of `IN_DATA_WIDTH`.\n- **Expected Sum Calculation**:\n  - Sum the inputs in the order they are concatenated and handle any potential overflow.\n- **Output Check**:\n  - Ensure the output accurately reflects the sum of the inputs, considering the propagation delay of the adder.\n\n### 6. Simulation Control\n- Begin the simulation with initialization and reset.\n- Execute the test procedure, which includes the generation, driving, and checking of inputs and outputs.\n- Display messages indicating test pass or fail status.\n- Terminate the simulation with `$finish` after all tests.\n\n## Expected Output\nThe testbench should:\n1. Apply generated inputs to the DUT and verify the outputs against expected sums.\n2. Log detailed information about each test case, including input values and comparison results.\n3. Complete the simulation successfully with an indication of pass/fail for each test case.\n\n## Deliverables\nProvide a **complete SystemVerilog testbench** that rigorously tests the `cascaded_adder` module across a variety of input conditions to ensure its correct functionality.", "context": {"docs/RTL_spec.md": "# Functional Specification Document\n\n## Module Name: `cascaded_adder`\n\n### Overview\n\nThe `cascaded_adder` module is a parameterized adder tree that sums multiple input data elements. Each stage of the adder can be configured as either a registered or combinational stage, determined by a control parameter (`REG`). The module produces the cumulative sum of input data elements and provides a valid output signal to indicate when the sum is ready.\n\n### Parameters\n\n- `IN_DATA_WIDTH` (integer): Bit width of each individual input data element.\n- `IN_DATA_NS` (integer): Number of input data elements.\n- `REG` (bit vector of `IN_DATA_NS` width): Control bits for each stage in the adder tree; a `1` enables a registered (clocked) stage, and a `0` enables a combinational stage.\n\n### I/O Ports\n\n- **Inputs:**\n  - `clk`: Clock signal for synchronous operations.\n  - `rst_n`: Active-low reset signal.\n  - `i_valid`: Indicates when the input data is valid.\n  - `i_data`: Flattened input data array containing `IN_DATA_NS` data elements, each of width `IN_DATA_WIDTH` bits.\n\n- **Outputs:**\n  - `o_valid`: Indicates when the output data (`o_data`) is valid.\n  - `o_data`: Sum of all input data elements, with width adjusted to prevent overflow.\n\n### Functionality\n\n1. **Data Input and Latching:**\n   - Upon receiving a valid input signal (`i_valid`), the input data array is latched to enable summation processing. The flattened input data is converted into an internal array for accessibility by each stage in the adder tree.\n\n2. **Adder Tree Logic:**\n   - The adder tree consists of multiple stages, each configurable as either a registered or combinational stage, based on the `REG` parameter.\n   - **Stage Operation**:\n     - If configured as a registered stage, the stage accumulates the sum of the current data element and the previous stage's result synchronously on the clock.\n     - If configured as a combinational stage, the stage performs the addition immediately without waiting for a clock edge.\n     - Note: The first stage of the adder tree is a pass-through without performing any calculation. This is reflected in both registered and combinational configurations for the first stage.\n   - The adder tree thus produces the cumulative sum in a sequential manner, with data propagated through each stage until the final sum is calculated.\n\n3. **Valid Signal Propagation:**\n   - The `i_valid` signal is latched similarly to the input data and assigned to a shift register.\n   - This valid signal shift register mirrors the configuration of the adder tree, where each stage can be either registered or combinational based on the `REG` parameter.\n   - The final valid output, `o_valid`, reflects the valid state of the cumulative sum in the final stage, ensuring synchronization with `o_data`.\n\n4. **Output Assignment:**\n   - The cumulative sum from the final adder stage is output on `o_data`, and `o_valid` is asserted when the sum is ready, indicating valid data at the output.\n\n### Timing and Latency\n\n- **Combinational and Registered Stages:** \n  - The `REG` parameter controls whether each stage in the adder tree is registered or combinational. Registered stages add a clock-cycle latency per stage, while combinational stages provide immediate results without clock delay.\n- **Critical Path Delay and Latency Calculation:** \n  - The overall delay is determined by the total combinational delay across the stages and the clock-cycle latency of the registered stages. The timing of `o_valid` aligns with the availability of the final sum in `o_data`.\n\n### Reset Behavior\n\n- When `rst_n` is low, all internal registers are reset to zero, ensuring a known state before data processing begins.\n\n### Key Points\n\n- The `cascaded_adder` module is highly configurable, with flexible control over each stage\u2019s timing behavior.\n- Valid signal propagation is synchronized with data latching, ensuring correct timing and valid output indication.\n- The final output signals, `o_data` and `o_valid`, provide the cumulative sum and its validity, respectively, upon completion of all adder stages.", "rtl/cascaded_adder.sv": "module cascaded_adder #(\n    parameter int IN_DATA_WIDTH = 16,  // Width of each input data\n    parameter int IN_DATA_NS = 4       // Number of input data elements\n) (\n   input  logic clk,\n   input  logic rst_n,\n   input  logic i_valid, \n   input  logic [IN_DATA_WIDTH*IN_DATA_NS-1:0] i_data,  // Flattened input data array\n   output logic o_valid,\n   output logic [(IN_DATA_WIDTH+$clog2(IN_DATA_NS))-1:0] o_data // Output data (sum)\n);\n\n   // Internal signals for the adder tree\n   logic [IN_DATA_WIDTH*IN_DATA_NS-1:0] i_data_ff;                             // Flattened input data array register\n   logic [IN_DATA_WIDTH-1:0] in_data_2d [IN_DATA_NS-1:0];                      // Intermediate 2D array\n   logic [(IN_DATA_WIDTH+$clog2(IN_DATA_NS))-1:0] sum_stage [IN_DATA_NS-1:0];  // Intermediate sum array\n   logic valid_ff;\n   \n   always_ff @(posedge clk or negedge rst_n) begin : reg_indata\n\t   if(!rst_n) begin\n\t\t   i_data_ff <= 0 ;\n\t   end\n\t   else begin\n\t\t   if(i_valid) begin\n\t\t\t   i_data_ff <= i_data;\n\t\t   end\n\t   end\n   end\n\n   // Convert flattened input to 2D array\n   always_comb begin\n       for (int i = 0; i < IN_DATA_NS; i++) begin : conv_1d_to_2d\n           in_data_2d[i] = i_data_ff[(i+1)*IN_DATA_WIDTH-1 -: IN_DATA_WIDTH];\n       end\n   end\n   // Initial stage: assign input data to the first stage of the adder tree\n   always_comb begin\n       sum_stage[0] = in_data_2d[0];\n       for (int i = 1; i < IN_DATA_NS; i++) begin\n           sum_stage[i] = sum_stage[i-1] + in_data_2d[i];\n       end\n   end\n\n   always_ff @(posedge clk or negedge rst_n) begin :reg_valid\n      if(!rst_n) begin\n         valid_ff <= 1'b0;\n         o_valid  <= 1'b0;\n      end\n      else begin\n         valid_ff <= i_valid;\n         o_valid  <= valid_ff;\n      end\n   end\n\n   always_ff @(posedge clk or negedge rst_n) begin : reg_outdata\n      if(!rst_n) begin\n         o_data <= 0 ; \n      end\n      else begin\n         o_data <= sum_stage[IN_DATA_NS-1];\n      end\n      \n      \n   end\n\nendmodule", "verif/tb_adder_tree.sv": "`timescale 1ns / 1ps\n\nmodule tb_adder_tree;\n\n   // Par\u00e2metros\n   parameter IN_DATA_WIDTH = 16;\n   parameter IN_DATA_NS = 4;\n\n   // Sinais\n   logic clk;\n   logic rst_n;\n   logic i_valid;\n   logic [IN_DATA_WIDTH*IN_DATA_NS-1:0] i_data;\n   logic o_valid;\n   logic [(IN_DATA_WIDTH+$clog2(IN_DATA_NS))-1:0] o_data;\n\n   // Instancia\u00e7\u00e3o do DUT (Device Under Test)\n   adder_tree #(\n      .IN_DATA_WIDTH(IN_DATA_WIDTH),\n      .IN_DATA_NS(IN_DATA_NS)\n   ) dut (\n      .clk(clk),\n      .rst_n(rst_n),\n      .i_valid(i_valid),\n      .i_data(i_data),\n      .o_valid(o_valid),\n      .o_data(o_data)\n   );\n\n   // Clock (per\u00edodo de 10 ns)\n   always #5 clk = ~clk;\n\n   // Sequ\u00eancia de testes\n   initial begin\n      // Gera\u00e7\u00e3o do arquivo VCD\n      $dumpfile(\"adder_tree_test.vcd\");   // Nome do arquivo VCD gerado\n      $dumpvars(0, tb_adder_tree);        // Registrar todas as vari\u00e1veis do m\u00f3dulo tb_adder_tree\n\n      // Inicializa\u00e7\u00e3o\n      clk = 0;\n      rst_n = 0;\n      i_valid = 0;\n      i_data = 0;\n\n      // Reset\n      #10;\n      rst_n = 1;\n\n      // Aplica\u00e7\u00e3o de dados de entrada\n      #10;\n      i_data = {16'd5, 16'd10, 16'd15, 16'd20}; // Soma esperada: 5 + 10 + 15 + 20 = 50\n      i_valid = 1;\n\n      // Esperar 1 ciclo de clock\n      #10;\n      i_valid = 0;\n\n      // Aguardar o sinal o_valid\n      wait(o_valid == 1);\n\n      // Exibir o resultado\n      $display(\"Soma: %0d\", o_data);\n\n      repeat(10) @(posedge clk);\n      // Finalizar simula\u00e7\u00e3o\n      #10;\n      $finish;\n   end\nendmodule"}}, "output": {"response": "", "context": {"verif/cascaded_adder_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n      \nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/cascaded_adder.sv \nHASH            = 21-checker-for-cascaded-adder\nNUM_BUGS        = 2", "src/cascaded_adder.sv": "module cascaded_adder #(\n    parameter int IN_DATA_WIDTH = 16,  // Width of each input data\n    parameter int IN_DATA_NS = 4       // Number of input data elements\n) (\n   input  logic clk,\n   input  logic rst_n,\n   input  logic i_valid, \n   input  logic [IN_DATA_WIDTH*IN_DATA_NS-1:0] i_data,  // Flattened input data array\n   output logic o_valid,\n   output logic [(IN_DATA_WIDTH+$clog2(IN_DATA_NS))-1:0] o_data // Output data (sum)\n);\n\n   // Internal signals for the adder tree\n   logic [IN_DATA_WIDTH*IN_DATA_NS-1:0] i_data_ff;                             // Flattened input data array register\n   logic [IN_DATA_WIDTH-1:0] in_data_2d [IN_DATA_NS-1:0];                      // Intermediate 2D array\n   logic [(IN_DATA_WIDTH+$clog2(IN_DATA_NS))-1:0] sum_stage [IN_DATA_NS-1:0];  // Intermediate sum array\n   logic valid_ff;\n   \n   always_ff @(posedge clk or negedge rst_n) begin : reg_indata\n\t   if(!rst_n) begin\n\t\t   i_data_ff <= 0 ;\n\t   end\n\t   else begin\n\t\t   if(i_valid) begin\n\t\t\t   i_data_ff <= i_data;\n\t\t   end\n\t   end\n   end\n\n   // Convert flattened input to 2D array\n   always_comb begin\n       for (int i = 0; i < IN_DATA_NS; i++) begin : conv_1d_to_2d\n           in_data_2d[i] = i_data_ff[(i+1)*IN_DATA_WIDTH-1 -: IN_DATA_WIDTH];\n       end\n   end\n   // Initial stage: assign input data to the first stage of the adder tree\n   always_comb begin\n    `ifndef BUG_0\n       sum_stage[0] = in_data_2d[0];\n    `else \n       sum_stage[0] = in_data_2d[1];\n    `endif\n       for (int i = 1; i < IN_DATA_NS; i++) begin\n       `ifndef BUG_1\n           sum_stage[i] = sum_stage[i-1] + in_data_2d[i];\n       `else \n           sum_stage[i] = sum_stage[i-1] - in_data_2d[i];\n       `endif\n       end\n   end\n\n   always_ff @(posedge clk or negedge rst_n) begin :reg_valid\n      if(!rst_n) begin\n         valid_ff <= 1'b0;\n         o_valid  <= 1'b0;\n      end\n      else begin\n         valid_ff <= i_valid;\n         o_valid  <= valid_ff;\n      end\n   end\n\n   always_ff @(posedge clk or negedge rst_n) begin : reg_outdata\n      if(!rst_n) begin\n         o_data <= 0 ; \n      end\n      else begin\n         o_data <= sum_stage[IN_DATA_NS-1];\n      end\n      \n      \n   end\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun -timescale 1ns/1ps /src/*.sv /code/verif/cascaded_adder_tb.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_cascaded_adder_0028", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `cascaded_adder` module. The assertions should ensure correct reset behavior, data latching, valid signal propagation, and output correctness.  \n\n## **RTL Design Overview**  \nThe `cascaded_adder` module implements a **multi-stage adder tree** that sums `IN_DATA_NS` input values. It registers the input, processes the sum based on **pipeline register control bits (`REG`)**, and propagates the valid signal through a pipeline.  \n\n### **Parameters**\n - **`IN_DATA_WIDTH` (default = 16):** Specifies the bit-width of each individual input data element.\n - **`IN_DATA_NS` (default = 4):** Defines the number of input data elements to be summed.\n - **REG (default = 4'b1010):** Controls whether each intermediate stage in the adder tree will be registered or combinational. Each bit of REG corresponds to one summation stage, starting from the least significant bit (LSB) at the first stage.\n     - **`1`**: The stage will be registered, introducing a clock cycle latency.\n     - **`0`**: The stage will be combinational, with no added latency.\n     - The width of REG should match `IN_DATA_NS` to allow control over each stage in the adder tree. \n     \n### **Key Components of the Module**  \n\n- **`i_data_ff`**: Stores the registered input data.  \n- **`in_data_2d`**: Converts the flattened input array into a 2D structure for addition.  \n- **`sum_stage`**: Stores intermediate sum results in a cascaded manner.  \n- **`valid_ff`**: Registers the input `i_valid` signal.  \n- **`valid_pipeline`**: Propagates `valid_ff` with configurable latency based on `REG`.  \n- **`o_valid`**: Active high signal indicating when output data is valid.  \n- **`o_data`**: Final output sum after cascading through `sum_stage`.  \n- **`clk`**: Clock signal. Design is synchronized to the posedge of this clock.  \n- **`srst`**: Synchronous active-high reset signal.  \n- **`i_valid`**: Active-high signal indicating valid input data.  \n- **`i_data`**: Flattened array of `IN_DATA_NS` input values.  \n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n\n- **Reset Initialization Behavior:**  \n  - When `srst` is asserted, `i_data_ff` and `valid_ff` should be **cleared to `0`** on the next clock cycle.  \n\n- **Input Data Registration:**  \n  - When `i_valid` is asserted, `i_data_ff` should **capture the value of `i_data`** on the next clock cycle.  \n\n- **Valid Signal Latency:**  \n  - The output `o_valid` should **assert after the expected latency**.  \n  - The **expected latency** is determined by the **number of 1's in `REG` + 2**.  \n  - To compute the number of 1's in `REG`, a function named **`count_ones`** can be implemented.  \n\n\n- **Output Data Correctness:**  \n  - When `o_valid` is high, `o_data` should **match `sum_stage[IN_DATA_NS-1]`** at the same time, ensuring correct summation.  \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.  ", "comments": [], "context": {"rtl/cascaded_adder.sv": "module cascaded_adder #(\n    parameter int IN_DATA_WIDTH = 16,  // Width of each input data\n    parameter int IN_DATA_NS = 4,      // Number of input data elements\n    parameter [IN_DATA_NS-1:0] REG = 4'b1010        // Control bits for register insertion\n) (\n   input  logic clk,\n   input  logic srst,\n   input  logic i_valid, \n   input  logic [IN_DATA_WIDTH*IN_DATA_NS-1:0] i_data,  // Flattened input data array\n   output logic o_valid,\n   output logic [(IN_DATA_WIDTH+$clog2(IN_DATA_NS))-1:0] o_data // Output data (sum)\n);\n\n   // Internal signals for the adder tree\n   logic [IN_DATA_WIDTH*IN_DATA_NS-1:0] i_data_ff;                             // Flattened input data array register\n   logic [IN_DATA_WIDTH-1:0] in_data_2d [IN_DATA_NS-1:0];                      // Intermediate 2D array\n   logic [(IN_DATA_WIDTH+$clog2(IN_DATA_NS))-1:0] sum_stage [IN_DATA_NS-1:0];  // Intermediate sum array\n   logic valid_ff;\n   logic valid_pipeline [IN_DATA_NS-1:0];  // Pipeline to handle the valid signal latencies based on REG\n   \n   // Register the input data on valid signal\n   always_ff @(posedge clk) begin : reg_indata\n      if(srst)\n         i_data_ff <= 0;\n      else begin\n         if(i_valid) begin\n            i_data_ff <= i_data;\n         end\n      end\n   end\n\n   // Convert flattened input to 2D array\n   always_comb begin\n      for (int i = 0; i < IN_DATA_NS; i++) begin : conv_1d_to_2d\n         in_data_2d[i] = i_data_ff[(i+1)*IN_DATA_WIDTH-1 -: IN_DATA_WIDTH];\n      end\n   end\n\n   // Generate logic for the adder tree using generate statement\n   genvar i;\n   generate\n      for (i = 0; i < IN_DATA_NS ; i++) begin : sum_stage_gen\n         if(i == 0) begin\n            if(REG[i]) begin\n               always_ff @(posedge clk) begin\n                  if (srst) begin\n                     sum_stage[i] <= 0 ;\n                  end\n                  else begin\n                      sum_stage[i] <= in_data_2d[i];\n                  end\n               end\n            end\n            else begin\n               always_comb sum_stage[i] = in_data_2d[i];\n            end\n         end\n         else begin\n            if(REG[i]) begin\n               always_ff @(posedge clk) begin\n                  if (srst) begin\n                     sum_stage[i] <= 0 ;\n                  end\n                  else begin\n                      sum_stage[i] <= sum_stage[i-1] + in_data_2d[i];\n                  end\n               end\n            end\n            else begin\n               always_comb sum_stage[i] = sum_stage[i-1] + in_data_2d[i];\n            end\n         end\n      end\n   endgenerate\n\n   always_ff @(posedge clk) begin\n      if(srst)\n         valid_ff <= 1'b0;\n      else \n         valid_ff <= i_valid;\n   end\n\n\n   // Valid signal propagation with latency based on REG\n   generate\n      for (i = 0; i < IN_DATA_NS; i++) begin : valid_latency_gen\n         if (i == 0) begin\n            if (REG[0]) begin\n               always_ff @(posedge clk) begin\n                  if (srst)\n                     valid_pipeline[0] <= 1'b0;\n                  else\n                     valid_pipeline[0] <= valid_ff;  // Register valid_ff if REG[0] == 1\n               end\n            end\n            else begin\n               always_comb begin\n                  valid_pipeline[0] = valid_ff;  // Combinational if REG[0] == 0\n               end\n            end\n         end\n         else begin\n            if (REG[i]) begin\n               always_ff @(posedge clk) begin\n                  if (srst)\n                     valid_pipeline[i] <= 1'b0;\n                  else\n                     valid_pipeline[i] <= valid_pipeline[i-1];  // Shift the valid signal based on REG\n               end\n            end\n            else begin\n               always_comb begin\n                  valid_pipeline[i] = valid_pipeline[i-1];  // No clock latency if REG[i] is 0\n               end\n            end\n         end\n      end\n   endgenerate\n\n\n   // Assign the final stage of valid_pipeline to o_valid\n   always_ff @(posedge clk) begin\n      if(srst)\n         o_valid <= 1'b0;\n      else\n         o_valid <= valid_pipeline[IN_DATA_NS-1];\n   end\n\n   // Output data assignment\n   always_ff @(posedge clk) begin : reg_outdata\n      if (srst) begin\n         o_data <= 0 ;\n      end else if (valid_pipeline[IN_DATA_NS-1]) begin\n         o_data <= sum_stage[IN_DATA_NS-1];\n      end\n   end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/cascaded_adder.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cascaded_adder.sv\nTOPLEVEL        = cascaded_adder\nMODULE          = test_cascaded_adder\nPYTHONPATH      = /src\nHASH            = 28-rtl-assertion-generation-for-cascaded-adder", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clk)\n    dut.srst.value = 1\n\n    await FallingEdge(dut.clk)\n    dut.srst.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\ndef random_stim_generator(IN_DATA_NS, IN_DATA_WIDTH, StimType):\n    golden_output = 0 \n    input_1d = 0 \n    for _ in range (IN_DATA_NS):\n        if StimType == \"RANDOM\":\n            random_value = random.randint(0, (1 << IN_DATA_WIDTH) - 1)\n        elif StimType == \"DIRECT_MAX\":\n            random_value = (1 << IN_DATA_WIDTH) - 1\n        elif StimType == \"DIRECT_MIN\":\n            random_value = 0    \n        golden_output = golden_output + random_value \n        input_1d = (input_1d << IN_DATA_WIDTH) | random_value\n    \n    return (input_1d, golden_output)\n", "src/test_cascaded_adder.py": "import cocotb\nfrom cocotb.triggers import  Timer, RisingEdge, ReadOnly\nfrom cocotb.clock import Clock\nimport harness_library as util\nimport random\n\n@cocotb.test()\nasync def test_cascaded_adder(dut):\n    # Generate  random period clock \n    DUT_CLK = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(DUT_CLK.start())\n    dut._log.info(f\"DUT_CLK STARTED\")\n\n    # Initialize DUT\n    await util.dut_init(dut) \n    dut.srst.value = 1\n    # Apply reset and enable\n    await util.reset(dut)\n\n    # Wait for a couple of cycles to stabilize\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n    # Dut parameters\n    IN_DATA_WIDTH = int(dut.IN_DATA_WIDTH.value)\n    IN_DATA_NS = int(dut.IN_DATA_NS.value)\n    REG = int(dut.REG.value) & 0xFFFFFFFF  # Treat REG as unsigned 32-bit\n    LATENCY = 2 + bin(REG).count('1')\n    \n    # overflow TC\n    stimulus= util.random_stim_generator(IN_DATA_NS, IN_DATA_WIDTH, \"DIRECT_MAX\")\n    input_data = stimulus[0]\n    golden_output = stimulus[1]\n    await RisingEdge(dut.clk)\n    dut.i_data.value = input_data\n    dut.i_valid.value = 1  \n    await RisingEdge(dut.clk)\n    dut.i_valid.value = 0\n\n    latency = 0\n    while (dut.o_valid.value != 1):\n        await RisingEdge(dut.clk)\n        latency = latency + 1\n\n    assert latency == LATENCY, f\"Valid output should have latency of {LATENCY} clk cycles\"\n    assert dut.o_data.value == golden_output , f\"Outpud doesn't match golden output: dut_output {hex(dut.o_data.value)}, Expected output {hex(golden_output)}\"\n    \n\n    for i in range(50):\n        stimulus= util.random_stim_generator(IN_DATA_NS, IN_DATA_WIDTH, \"RANDOM\")\n        input_data = stimulus[0]\n        golden_output = stimulus[1]\n        await RisingEdge(dut.clk)\n        dut.i_data.value = input_data\n        dut.i_valid.value = 1  \n        await RisingEdge(dut.clk)\n        dut.i_valid.value = 0\n\n        latency = 0\n        while (dut.o_valid.value != 1):\n            await RisingEdge(dut.clk)\n            latency = latency + 1\n\n        assert latency == LATENCY, f\"Valid output should have latency of {LATENCY} clk cycles\"\n        assert dut.o_data.value == golden_output , f\"Outpud doesn't match golden output: dut_output {hex(dut.o_data.value)}, Expected output {hex(golden_output)}\"  \n\n\n    await util.reset(dut)\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner(IN_DATA_NS, IN_DATA_WIDTH, REG):\n    parameters = {\n        \"IN_DATA_NS\": IN_DATA_NS,\n        \"IN_DATA_WIDTH\": IN_DATA_WIDTH,\n        \"REG\": REG,\n    }\n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"random_test\", range(3))\ndef test_tree_adder(random_test):\n    IN_DATA_NS = (random.randint(1, 32))\n    IN_DATA_WIDTH = (random.randint(1, 64))\n    REG_random = random.getrandbits(IN_DATA_NS)\n    print(f'Running with: IN_DATA_NS = {IN_DATA_NS}, IN_DATA_WIDTH = {IN_DATA_WIDTH}, REG (random) = {REG_random}')\n    call_runner(IN_DATA_NS, IN_DATA_WIDTH, REG_random)\n", "src/test_sync_muller_c_element.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport harness_library as hrs_lb\nimport math\n\n# ----------------------------------------\n# - Synchornous Muller C Element Test\n# ----------------------------------------\n\nasync def reset_dut(dut, duration_ns=10):\n    \"\"\"\n    Perform a synchronous reset on the Design Under Test (DUT).\n\n    - Sets the reset signal high for the specified duration.\n    - Ensures all output signals are zero during the reset.\n    - Deactivates the reset signal and stabilizes the DUT.\n\n    Args:\n        dut: The Design Under Test (DUT).\n        duration_ns: The time duration in nanoseconds for which the reset signal will be held high.\n    \"\"\"\n    dut.srst.value = 1  # Activate reset (set to high)\n    await Timer(duration_ns, units=\"ns\")  # Hold reset high for the specified duration\n    await Timer(1, units=\"ns\")\n\n    # Verify that outputs are zero during reset\n    assert dut.out.value == 0, f\"[ERROR] out is not zero during reset: {dut.out.value}\"\n\n    dut.srst.value = 0  # Deactivate reset (set to low)\n    await Timer(duration_ns, units='ns')  # Wait for the reset to stabilize\n    dut.srst._log.debug(\"Reset complete\")\n\ndef weighted_random_input(num_inputs):\n    \"\"\"\n    Generate weighted random inputs.\n\n    Args:\n        num_inputs: Number of input bits.\n\n    Returns:\n        An integer representing the input vector.\n    \"\"\"\n    if random.random() < 0.6:  # 60% chance to generate all 0's or all 1's\n        return 0 if random.random() < 0.5 else (1 << num_inputs) - 1\n    else:  # 40% chance to generate other combinations\n        return random.randint(0, (1 << num_inputs) - 1)\n\n\n@cocotb.test()\nasync def test_sync_muller_c_element(dut):\n  \"\"\"\n  Verify the functionality of the sync_muller_c_element module with weighted random input vectors.\n\n  Test Steps:\n  1. Perform a synchronous reset.\n  2. Drive the DUT with weighted random inputs.\n  3. Verify correctness of the output based on input logic.\n  4. Cover scenarios including reset and stable input combinations.\n  \"\"\"\n\n  # Start the clock with a 10ns period\n  cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few clock cycles to ensure proper initialization\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve DUT configuration parameters\n  num_inputs = int(dut.NUM_INPUT.value)\n  pipe_depth = int(dut.PIPE_DEPTH.value)\n  num_samples = 20\n\n  # Print parameters for debugging\n  print(f\"NUM_INPUT: {num_inputs}\")\n  print(f\"PIPE_DEPTH: {pipe_depth}\")\n\n  # Test with weighted random input vectors\n  in_queue = []\n  out_queue = []\n  dut.clk_en.value = 1\n\n  for i in range(num_samples):\n    # Generate a random input\n    random_input = weighted_random_input(num_inputs)\n    dut.inp.value = random_input\n    # Add input to the queue for later verification\n    in_queue.append(random_input)\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Handle pipeline delay outputs\n  for i in range(pipe_depth):\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Remove outputs corresponding to initial pipeline latency\n  for i in range(pipe_depth):\n    prev_out = out_queue.pop(0)\n\n  # Perform verification of DUT outputs\n  for i in range(num_samples):\n    # Retrieve the input and output from the queues\n    in_temp = in_queue.pop(0)\n    out_temp = out_queue.pop(0)\n    \n    # Compute the expected output\n    all_high = (1 << num_inputs) - 1\n    all_low  = 0\n\n    expected_output = 1 if (in_temp == all_high) else (0 if (in_temp == all_low) else prev_out)\n\n    # Verify that the DUT output matches the expected output\n    assert out_temp == expected_output, f\"Test {i+1}: Output does not match the expected result: {out_temp} != {expected_output}\"\n\n    print(f\"Test {i+1} passed\")\n    prev_out = out_temp\n\n  # Wait for a few cycles before performing a final reset\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply a final reset to the DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles after reset to stabilize\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n\n@cocotb.test()\nasync def test_sync_muller_c_element_with_clk_en_toggle(dut):\n  \"\"\"\n  Verify the functionality of sync_muller_c_element with clock enable toggling.\n\n  Test Steps:\n  1. Perform a synchronous reset.\n  2. Toggle clock enable at specific intervals.\n  3. Drive inputs and verify outputs during enabled and disabled periods.\n  \"\"\"\n\n  # Start the clock with a 10ns period\n  cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few clock cycles to ensure proper initialization\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve DUT configuration parameters\n  num_inputs = int(dut.NUM_INPUT.value)\n  pipe_depth = int(dut.PIPE_DEPTH.value)\n  num_samples = 30\n\n  # Print parameters for debugging\n  print(f\"NUM_INPUT: {num_inputs}\")\n  print(f\"PIPE_DEPTH: {pipe_depth}\")\n\n  # Test with clock enable toggle\n  in_queue = []\n  out_queue = []\n  clk_en = 1\n  dut.clk_en.value = clk_en\n\n  for i in range(num_samples):\n\n    if (i  == 10):\n      clk_en = 0\n    elif (i  == 20):\n      clk_en = 1\n\n    dut.clk_en.value = clk_en\n\n    # Generate a random input\n    random_input = weighted_random_input(num_inputs)\n    dut.inp.value = random_input\n    # Add input to the queue for later verification\n    if (clk_en):\n      in_queue.append(random_input)\n\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Handle pipeline delay outputs\n  for i in range(pipe_depth):\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Remove outputs corresponding to initial pipeline latency\n  for i in range(pipe_depth):\n    prev_out = out_queue.pop(0)\n\n  # Perform verification of DUT outputs\n  for i in range(num_samples):\n    if (i >= (10 - pipe_depth) and i <= (19 - pipe_depth)):\n      expected_output = prev_out\n      out_temp = out_queue.pop(0)\n    else:\n      # Retrieve the input and output from the queues\n      in_temp = in_queue.pop(0)\n      out_temp = out_queue.pop(0)\n      \n      # Compute the expected output\n      all_high = (1 << num_inputs) - 1\n      all_low  = 0\n      expected_output = 1 if (in_temp == all_high) else (0 if (in_temp == all_low) else prev_out)\n\n    # Verify that the DUT output matches the expected output\n    assert out_temp == expected_output, f\"Test {i+1}: Output does not match the expected result: {out_temp} != {expected_output}\"\n\n    print(f\"Test {i+1} passed\")\n    prev_out = out_temp\n\n  # Wait for a few cycles before performing a final reset\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply a final reset to the DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles after reset to stabilize\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n\n\n@cocotb.test()\nasync def test_sync_muller_c_element_with_clr_toggle(dut):\n  \"\"\"\n  Verify the functionality of sync_muller_c_element with clear signal toggling.\n\n  Test Steps:\n  1. Perform a synchronous reset.\n  2. Drive inputs with random data.\n  3. Toggle the clear signal and verify output behavior.\n  \"\"\"\n\n  # Start the clock with a 10ns period\n  cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few clock cycles to ensure proper initialization\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve DUT configuration parameters\n  num_inputs = int(dut.NUM_INPUT.value)\n  pipe_depth = int(dut.PIPE_DEPTH.value)\n  num_samples = 30\n\n  # Print parameters for debugging\n  print(f\"NUM_INPUT: {num_inputs}\")\n  print(f\"PIPE_DEPTH: {pipe_depth}\")\n\n  # Test with clear signal toggling\n  in_queue = []\n  out_queue = []\n  dut.clk_en.value = 1\n  clr = 0\n  dut.clr.value = clr\n\n  for i in range(num_samples):\n    # Generate a random input\n    random_input = weighted_random_input(num_inputs)\n    dut.inp.value = random_input\n    # Add input to the queue for later verification\n    in_queue.append(random_input)\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n    if (i == 20):\n      clr = 1\n      dut.clr.value = clr\n\n  # Handle pipeline delay outputs\n  for i in range(pipe_depth):\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Remove outputs corresponding to initial pipeline latency\n  for i in range(pipe_depth):\n    prev_out = out_queue.pop(0)\n\n  # Perform verification for DUT Outputs\n  for i in range(num_samples):\n    # Retrieve the input and output from the queues\n    in_temp = in_queue.pop(0)\n    out_temp = out_queue.pop(0)\n    \n    # Compute the expected output\n    all_high = (1 << num_inputs) - 1\n    all_low  = 0\n\n    if (i > (20 - pipe_depth)):\n      expected_output = 0\n    else:\n      expected_output = 1 if (in_temp == all_high) else (0 if (in_temp == all_low) else prev_out)\n\n    # Verify that the DUT output matches the expected output\n    assert out_temp == expected_output, f\"Test {i+1}: Output does not match the expected result: {out_temp} != {expected_output}\"\n\n    print(f\"Test {i+1} passed\")\n    prev_out = out_temp\n\n  # Wait for a few cycles before performing a final reset\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply a final reset to the DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles after reset to stabilize\n  for k in range(2):\n    await RisingEdge(dut.clk)"}}}
{"id": "cvdp_copilot_cascaded_adder_0030", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the existing SystemVerilog testbench to include a **SystemVerilog checker** to validate the output of a **cascaded adder module** `cascaded_adder`, which performs the summation of multiple input data elements. The **stimulus is provided**, and the checker should verify that the **DUT (Design Under Test)** correctly computes the cumulative sum of all input elements.\n\n---\n## **Design Functionality**\n\n1. **Cascaded addition process of the design**:  \n   - The module receives `IN_DATA_NS` elements, each `IN_DATA_WIDTH` bits wide, as a **flattened 1D vector (`i_data`)**.  \n   - Parameter REG (default = 4'b1010) Controls whether each intermediate stage in the adder tree will be registered or combinational. Each bit of REG corresponds to one summation stage, starting from the least significant bit (LSB) at the first stage.\n       - 1: The stage will be registered, introducing a clock cycle latency.\n       - 0: The stage will be combinational, with no added latency.\n       - The width of REG should match IN_DATA_NS to allow control over each stage in the adder tree.\n   - The sum of the elements is computed using **cascaded addition**, where each stage accumulates the sum from the previous stage.  \n   - The final sum is stored in `o_data`.\n\n2. **Latency**:  \n   - Minimum latency: The minimum latency for `o_valid` is a fixed latency of 2 clock cycles (Example: when REG = 4'b0000, all stages of the adder tree are combinational,with input-output latching adding the 2 clock cycle latency.).\n    - Maximum latency: The maximum latency for `o_valid` when all bits of REG are 1, is IN_DATA_NS+2 clock cycles (Example: when REG = 4'b1111 all stages registered. There will be a 4 cycle latency for the stages in the adder + 2 cycles for input and output latching)\n\n3. **Control signal behavior**:  \n   - **Reset (`srst`)**: Active-high synchronous reset that clears all registers and sets `o_valid` and `o_data` to zero.  \n   - **Input Valid (`i_valid`)**: Active-high signal that indicates valid input data.  \n   - **Output Valid (`o_valid`)**: Active-high signal that indicates when `o_data` contains valid summed output data.  \n\n### **Inputs and Outputs of the RTL design**\n\n#### **Inputs**\n- `clk`: Clock signal (positive edge-triggered).  \n- `srst`: Active-high synchronous reset.  \n- `i_valid`: Active-high signal indicating valid input.  \n- `[IN_DATA_WIDTH*IN_DATA_NS-1:0] i_data`: Flattened 1D representation of `IN_DATA_NS` input elements.  \n\n#### **Outputs**\n- `o_valid`: Active-high signal indicating valid output.  \n- `[(IN_DATA_WIDTH+$clog2(IN_DATA_NS))-1:0] o_data`: Computed sum of `IN_DATA_NS` input elements.  \n\n### **Example of input data flattening**\n\nSuppose the module processes `IN_DATA_NS = 4` elements per cycle, each `IN_DATA_WIDTH = 16` bits:\n\n- **Input Data Elements**:  \n\n```text\ni_data = {data4, data3, data2, data1}\n```\n\nWhere data1 is the least significant element and data4 is the most significant.\n\n- **Summation Example**:  \n```text\no_data = data1 + data2 + data3 + data4\n```\n\n---\n\n## **Testbench Details**\n\n### **1. Instantiation**\n-  `cascaded_adder` is instantiated as `dut`, with all input and output signals connected.\n\n### **2. Clock generation**\n- The testbench uses a **500 MHz clock** to synchronize the DUT.\n- The **clock period is 2 ns**, meaning the signal toggles **every 1 ns**.\n\n### **3. Testbench components**\n\n#### **Parameters**\n- IN_DATA_WIDTH, IN_DATA_NS: Define input data size and number of elements.\n- REG: Controls whether each intermediate stage in the adder tree should be registered or combinational.\n- NUM_SAMPLES: Number of test samples for verification.\n\n#### **Signals**\n- clk: Clock signal.\n- srst: Active-high synchronous reset.\n- i_valid: Input valid signal.\n- i_data: Input data containing IN_DATA_NS elements.\n- o_valid: Output valid signal.\n- o_data: Computed sum of input elements.\n- i_data_queue: Queue storing input data samples for verification.\n- o_data_queue: Queue storing expected output sums for verification.\n- o_data_expected: Expected sum for verification.\n- i_valid_cnt: Counter tracking the number of valid inputs processed.\n- give_input: Signal to enable data input\n- give_input_reg: Shift register controlling input enable.\n\n### **4. Stimulus provided**\n- The existing testbench randomly generates stimulus for the following input signals:\n  - i_data: Provide randomized input data.\n  - i_valid: Toggle the input valid signal randomly to simulate realistic input patterns.\n- Ensures input data is applied:\n  - Every next clock cycle if `count_ones(REG) < 2`.\n  - After `count_ones(REG)` cycles if `count_ones(REG) \u2265 2`.\n- Testbench uses `give_input_reg` as a shift register to control input enable timing.\n     \n### **5. Modification required with the use of queues in verification and checker functionality**\n- Queues enable continuous input processing without waiting for prior results.\n- This allows new inputs to be applied every clock cycle, while previous results are still in computation.\n- The process works as follows:\n  1. When `i_valid` is asserted, push `i_data` into `i_data_queue`.\n  2. After(count_ones(REG)+2) cycles when `o_valid` is asserted:\n     - Pop the corresponding `i_data` from `i_data_queue`.\n     - Compute `o_data_expected` as the sum of all elements in `i_data`.\n     - Compare `o_data_expected` with `o_data`.\n  3. If a mismatch occurs, log an error using `$error` and end the simulation, reporting errors\n\n### **6. Simulation control**\n- Use `$display` statements to log test case execution.  \n- Print a message if all cases pass; otherwise, report errors.  \n\n---\n\n## **Expected Deliverables**\n- **SystemVerilog checker** that uses existing stimulus and verifies the `cascaded_adder` module\u2019s output against expected results with added checker logic.", "context": {"verif/cascaded_adder_tb.sv": "module cascaded_adder_tb;\n\n  // Testbench parameters\n  parameter int IN_DATA_WIDTH = 16;\n  parameter int IN_DATA_NS = 4;\n  parameter [IN_DATA_NS-1:0] REG = 4'b1010;\n  parameter NUM_SAMPLES = 100;\n\n  // Local parameters\n  localparam int INPUT_WIDTH = IN_DATA_WIDTH * IN_DATA_NS;\n  localparam int OUTPUT_WIDTH = IN_DATA_WIDTH + $clog2(IN_DATA_NS);\n  localparam INPUT_CYCLES = (count_ones(REG) == 0) ? 1 :  \n                            (count_ones(REG) == 1) ? 1 : (count_ones(REG));\n\n  // Signals\n  logic                                           clk                = 0;\n  logic                                           srst                  ;\n  logic                                           i_valid               ;\n  logic [ INPUT_WIDTH-1:0]                        i_data                ;\n  logic                                           o_valid               ;\n  logic [OUTPUT_WIDTH-1:0]                        o_data                ;\n  logic                                           give_input         = 0; // Signal to enable data input\n  logic [((INPUT_CYCLES>=2)?INPUT_CYCLES-2:0) :0] give_input_reg        ; // Shift register for input control\n  logic [31:0]                                    i_valid_cnt           ;\n\n  // DUT instantiation\n  cascaded_adder #(\n    .IN_DATA_WIDTH(IN_DATA_WIDTH),\n    .IN_DATA_NS(IN_DATA_NS),\n    .REG(REG)\n  ) dut (\n    .clk(clk),\n    .srst(srst),\n    .i_valid(i_valid),\n    .i_data(i_data),\n    .o_valid(o_valid),\n    .o_data(o_data)\n  );\n\n\n  // Clock generation: Toggle clock every 1ns (Clock Period = 2ns)\n  always\n    #1 clk = ~clk;\n\n\n  // Initial block to define testbench stimulus\n  initial\n  begin\n    // ---------------------------------------------------------------------\n    // Step 1: Initialize the signals\n    // ---------------------------------------------------------------------\n    give_input = '0;\n\n    // ---------------------------------------------------------------------\n    // Step 2: Apply reset\n    // Keep the reset signal low for 20 clock cycles, then release it.\n    // ---------------------------------------------------------------------\n    srst = 1'b1;\n    repeat(20) @(posedge clk);\n    srst = 1'b0;\n    repeat(20) @(posedge clk);\n\n    $display(\"Applying stimulus . . .\");\n\n    give_input = 1'b1; // Start input signal\n\n    // ---------------------------------------------------------------------\n    // Step 3: Process multiple samples\n    // Wait for NUM_SAMPLES valids, then disable input\n    // ---------------------------------------------------------------------\n\n    wait(i_valid_cnt == NUM_SAMPLES)\n    give_input = 1'b0;\n\n    repeat(count_ones(REG)+2) @(posedge clk);\n\n    $display(\"Stimulus has been applied!\");\n    \n\n    // Wait for one more clock cycle before terminating the simulation\n    @(posedge clk);\n\n    $finish;\n  end\n\n  always_ff @(posedge clk)\n    if (srst)\n      give_input_reg <= 1'b0;\n    else if (!(|give_input_reg))\n      give_input_reg <= (INPUT_CYCLES > 2) ? {give_input,{INPUT_CYCLES-2{1'b0}}} : {give_input};\n    else if (INPUT_CYCLES >= 2)\n      give_input_reg <= {1'b0,give_input_reg} >> 1;\n\n  always_ff @(posedge clk)\n    if (srst)\n      i_valid_cnt <= '0;\n    else if (i_valid) begin\n      i_valid_cnt <= i_valid_cnt + 1;\n    end\n\n  always_ff @(posedge clk)\n    if (srst)\n      i_valid <= '0;\n    else if (give_input_reg[0] && (i_valid_cnt != NUM_SAMPLES))\n      i_valid <= $urandom_range(0,1);\n    else\n      i_valid <= '0;\n\n  always_ff @(posedge clk)\n    if (srst)\n      i_data <= '0; // Reset input data\n    else if (give_input_reg[0])\n      i_data <= generate_random_input(); // Assign random values\n\n  function automatic logic [INPUT_WIDTH-1:0] generate_random_input();\n    logic [IN_DATA_WIDTH-1:0] input_array [0:IN_DATA_NS-1];\n    logic [INPUT_WIDTH-1:0] flattened_data='0;\n    begin\n      for (int i = 0; i < IN_DATA_NS; i++) begin\n        input_array[i] = $urandom_range(0, (1 << IN_DATA_WIDTH) - 1);\n        flattened_data = flattened_data | (input_array[i] << (i * IN_DATA_WIDTH));\n      end\n      return flattened_data;\n    end\n  endfunction\n\n  // Function to count number of set bits in REG\n  function automatic int count_ones(bit [IN_DATA_NS-1:0] reg_value);\n       int count;\n       count = 0;\n       for (int i = 0; i < IN_DATA_NS; i++) begin\n           if (reg_value[i]) count++;\n       end\n       return count;\n   endfunction\n\n\nendmodule"}}, "output": {"response": "", "context": {"verif/cascaded_adder_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 30-checker-for-cascaded-adder\nNUM_BUGS        = 3", "src/cascaded_adder.sv": "module cascaded_adder #(\n    parameter int IN_DATA_WIDTH = 16,  // Width of each input data\n    parameter int IN_DATA_NS = 4,      // Number of input data elements\n    parameter int OUT_DATA_WIDTH = IN_DATA_WIDTH+$clog2(IN_DATA_NS),\n    parameter [IN_DATA_NS-1:0] REG = 4'b1010        // Control bits for register insertion\n) (\n   input  logic clk,\n   input  logic srst,\n   input  logic i_valid, \n   input  logic [IN_DATA_WIDTH*IN_DATA_NS-1:0] i_data,  // Flattened input data array\n   output logic o_valid,\n   output logic [(IN_DATA_WIDTH+$clog2(IN_DATA_NS))-1:0] o_data // Output data (sum)\n);\n\n   // Internal signals for the adder tree\n   logic [IN_DATA_WIDTH*IN_DATA_NS-1:0] i_data_ff;                             // Flattened input data array register\n   logic [IN_DATA_WIDTH-1:0] in_data_2d [IN_DATA_NS-1:0];                      // Intermediate 2D array\n   logic [(IN_DATA_WIDTH+$clog2(IN_DATA_NS))-1:0] sum_stage [IN_DATA_NS-1:0];  // Intermediate sum array\n   logic valid_ff;\n   logic valid_pipeline [IN_DATA_NS-1:0];  // Pipeline to handle the valid signal latencies based on REG\n   \n   // Register the input data on valid signal\n   always_ff @(posedge clk) begin : reg_indata\n      if(srst)\n         i_data_ff <= 0;\n      else begin\n         if(i_valid) begin\n            i_data_ff <= i_data;\n         end\n      end\n   end\n\n   // Convert flattened input to 2D array\n   always_comb begin\n      for (int i = 0; i < IN_DATA_NS; i++) begin : conv_1d_to_2d\n         in_data_2d[i] = i_data_ff[(i+1)*IN_DATA_WIDTH-1 -: IN_DATA_WIDTH];\n      end\n   end\n\n   // Generate logic for the adder tree using generate statement\n   genvar i;\n   generate\n      for (i = 0; i < IN_DATA_NS ; i++) begin : sum_stage_gen\n         if(i == 0) begin\n            if(REG[i]) begin\n               always_ff @(posedge clk) begin\n                  if (srst) begin\n                  `ifndef BUG_0\n                     sum_stage[i] <= '0 ;\n                  `else \n                     sum_stage[i] <= '1 ;\n                  `endif\n                  end\n                  else begin\n                      sum_stage[i] <= in_data_2d[i];\n                  end\n               end\n            end\n            else begin\n               always_comb sum_stage[i] = in_data_2d[i];\n            end\n         end\n         else begin\n            if(REG[i]) begin\n               always_ff @(posedge clk) begin\n                  if (srst) begin\n                     sum_stage[i] <= '0 ;\n                  end\n                  else begin\n                  `ifndef BUG_0\n                     sum_stage[i] <= sum_stage[i-1] + in_data_2d[i];\n                  `else \n                     sum_stage[i] <= sum_stage[i-1] - in_data_2d[i];\n                  `endif\n                  end\n               end\n            end\n            else begin\n            `ifndef BUG_0\n               always_comb sum_stage[i] = sum_stage[i-1] + in_data_2d[i];\n            `else \n               always_comb sum_stage[i] = sum_stage[i-1] - in_data_2d[i];\n            `endif\n            end\n         end\n      end\n   endgenerate\n\n   always_ff @(posedge clk) begin\n      if(srst)\n         valid_ff <= 1'b0;\n      else \n         valid_ff <= i_valid;\n   end\n\n\n   // Valid signal propagation with latency based on REG\n   generate\n      for (i = 0; i < IN_DATA_NS; i++) begin : valid_latency_gen\n         if (i == 0) begin\n            if (REG[0]) begin\n               always_ff @(posedge clk) begin\n                  if (srst)\n                     valid_pipeline[0] <= 1'b0;\n                  else\n                     valid_pipeline[0] <= valid_ff;  // Register valid_ff if REG[0] == 1\n               end\n            end\n            else begin\n               always_comb begin\n                  valid_pipeline[0] = valid_ff;  // Combinational if REG[0] == 0\n               end\n            end\n         end\n         else begin\n            if (REG[i]) begin\n               always_ff @(posedge clk) begin\n                  if (srst)\n                     valid_pipeline[i] <= 1'b0;\n                  else\n                  `ifndef BUG_1\n                     valid_pipeline[i] <= valid_pipeline[i-1];  // Shift the valid signal based on REG\n                  `else\n                     valid_pipeline[i] <= valid_pipeline[0];  // Shift the valid signal based on REG\n                  `endif\n               end\n            end\n            else begin\n               always_comb begin\n               `ifndef BUG_1\n                  valid_pipeline[i] = valid_pipeline[i-1];  // No clock latency if REG[i] is 0\n               `else\n                  valid_pipeline[i] = 1'b1;  // No clock latency if REG[i] is 0\n               `endif\n               end\n            end\n         end\n      end\n   endgenerate\n\n\n   // Assign the final stage of valid_pipeline to o_valid\n   always_ff @(posedge clk) begin\n      if(srst)\n         o_valid <= 1'b0;\n      else\n         o_valid <= valid_pipeline[IN_DATA_NS-1];\n   end\n\n   // Output data assignment\n   always_ff @(posedge clk) begin : reg_outdata\n      if (srst) begin\n         o_data <= 0 ;\n      end else if (valid_pipeline[IN_DATA_NS-1]) begin\n      `ifndef BUG_2\n         o_data <= sum_stage[IN_DATA_NS-1];\n      `else\n         o_data <= sum_stage[0];\n      `endif\n      end\n   end\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_cdc_pulse_synchronizer_0017", "categories": ["cid012", "easy"], "input": {"prompt": "Complete the given SystemVerilog testbench for the `cdc_pulse_synchronizer` module. The testbench currently instantiates the UUT and should include a stimulus generator (`stimulus_generator`) that dynamically produces a wide range of test scenarios to ensure 100% functional and code coverage. The stimulus generator should validate the design under various conditions, including the below module functionality.\n\n---\n## Description\n\n### Inputs\n\n  - `src_clock`: Source clock signal driving the source domain(positive edge triggered). \n  - `des_clock`: The destination clock signal drives the destination domain(positive edge triggered).\n  - `rst_in`: The Asynchronous reset signal (active high) to reset the synchronizer.\n  - `src_pulse`: The input pulse signal is generated in the source clock domain. High for one clock cycle.\n\n### Outputs\n\n  - `des_pulse`: Synchronized pulse output in the destination clock domain. High for one des_clock cycle.\n\n\n## Input Generation\n\n### Input Generation\n\n- **Clock Frequencies**:\n  - Generate random frequencies for `src_clock` and `des_clock` to cover a wide range, including:\n    - Low frequencies (e.g., 1 MHz).\n    - High frequencies (e.g., 250 MHz).\n    - Closely matched frequencies (e.g., 90 MHz vs. 100 MHz).\n    - Extreme frequency disparities (e.g., 1 MHz vs. 100 MHz).\n\n- **Random Scenarios**:\n  - Create diverse patterns for `src_pulse`, such as:\n    - Random Frequencies.\n\n- **Reset Behavior**:\n  - Apply resets during various states, including:\n    - Idle state.\n    - Active pulse synchronization.\n    - Clock alignment and misalignment scenarios.\n\n---\n\nFollows the specification for building the RTL of the module, use it as a reference for the verification environment too:\n\n## Module Functionality\n\n1. **Pulse Synchronization**:\n   - The module uses a toggle flip-flop mechanism in the source domain and a double flip-flop synchronizer in the destination domain to synchronize `src_pulse` with `des_clock`.\n\n2. **Reset Behavior**:\n   - When `rst_in` is asserted, all internal states (`pls_toggle`, `pls_toggle_synca`, `pls_toggle_syncb`, and `pls_toggle_syncc`) are cleared to zero, ensuring proper initialization.\n\n3. **Edge Cases**:\n   - Correct synchronization under extreme clock frequency mismatches.\n   - Reset during pulse synchronization and at random intervals.\n\n---\n```verilog\nmodule tb_cdc_pulse_synchronizer;\n\n    // Testbench signals\n    logic src_clock;\n    logic des_clock;\n    logic rst_in;\n    logic src_pulse;\n    logic des_pulse;\n\n    // Instantiate the DUT\n    cdc_pulse_synchronizer uut (\n        .src_clock(src_clock),\n        .des_clock(des_clock),\n        .rst_in(rst_in),\n        .src_pulse(src_pulse),\n        .des_pulse(des_pulse)\n    );\n\n    // Insert the code here to generate stimulus generation logic\n\nendmodule\n```", "context": {}}, "output": {"response": "", "context": {"verif/tb_cdc_pulse_synchronizer.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = f1c831e3c00dea1a289c5a4754b9079cf5db6efb\nTARGET = 100\n", "src/cdc_pulse_synchronizer.sv": "module cdc_pulse_synchronizer (\n    input  logic src_clock,   // Source Clock Domain\n    input  logic des_clock,   // Destination Clock Domain\n    input  logic rst_in,      // Reset\n    input  logic src_pulse,   // Source Pulse\n    output logic des_pulse    // Destination Pulse\n);\n\n    logic pls_toggle;      \n    logic pls_toggle_synca;\n    logic pls_toggle_syncb;\n    logic pls_toggle_syncc;\n\n    //--------------------------------------------------\n    //   Toggle Flop Circuit\n    //---------------------------------------------------\n\n    always_ff @(posedge src_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle <= 1'b0;\n        end else if (src_pulse) begin\n            pls_toggle <= ~pls_toggle;\n        end else begin\n            pls_toggle <= pls_toggle;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Double Flop Bit Synchronizer\n    //---------------------------------------------------\n\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle_synca <= 1'b0;\n            pls_toggle_syncb <= 1'b0;\n        end else begin\n            pls_toggle_synca <= pls_toggle;\n            pls_toggle_syncb <= pls_toggle_synca;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Delay Logic of Output signal\n    //---------------------------------------------------\n\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle_syncc <= 1'b0;\n        end else begin\n            pls_toggle_syncc <= pls_toggle_syncb;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Assign Statement for posedge and negedge detection\n    //---------------------------------------------------\n\n    assign des_pulse = pls_toggle_syncc ^ pls_toggle_syncb;\n\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_cdc_pulse_synchronizer_0020", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the existing SystemVerilog testbench to add the **checker generation** logic for verifying the functionality of the `cdc_pulse_synchronizer` module. The testbench already contains a **stimulus_generator** to drive the input signals. The modified testbench should integrate a **stimulus_checker** module to validate the `cdc_pulse_synchronizer` module against the given design specification.\n\n### **Design Specification:**\nThe `cdc_pulse_synchronizer` module synchronizes a pulse from a source clock domain (`src_clock`) to a destination clock domain (`des_clock`). The module uses a toggle-based synchronization mechanism to ensure proper pulse transfer across clock domains.\n\n### **Testbench Requirements:**\n1. **Testbench Components:**\n   - **Input Signals:** Drive `src_clock`, `des_clock`, `rst_in`, and `src_pulse` with various test cases.\n   - **Output Validation:** Monitor and validate the `des_pulse` output against expected behavior.\n   - **Checker Generator:** Implement a `stimulus_checker` module to verify the correctness of `des_pulse` based on the input `src_pulse` and clock domains.\n\n2. **Checker Logic:**\n   - Implement a task in the `stimulus_checker` module to monitor `des_pulse` after each `src_pulse` is applied.\n   - Ensure that `des_pulse` is asserted within five `des_clock` cycles after `src_pulse` is applied.\n   - Log errors if `des_pulse` is not received within the expected time frame.\n   - Print success messages for passing test cases.\n\n3. **Functionality:**\n   - Test all combinations of `src_clock` and `des_clock` frequencies, including edge cases such as:\n     - Same frequency, same phase.\n     - Same frequency, different phase.\n     - Source clock faster than destination clock.\n     - Destination clock faster than source clock.\n     - Random clock frequencies.\n   - Include a reset test to ensure proper initialization.\n\n4. **Verification:**\n   - Drive `src_pulse` and monitor `des_pulse` using the `stimulus_checker`.\n   - Compare the actual `des_pulse` behavior with the expected behavior.\n   - Log results (pass/fail) for each test case.\n\n5. **Simulation:**\n   - Display pass/fail results for each test case.\n   - Complete the simulation once all test cases are verified.\n\n### **Deliverables:**\nProvide a complete SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `cdc_pulse_synchronizer` module. The testbench should include:\n- A `stimulus_generator` module to generate test cases.\n- A `stimulus_checker` module to validate the outputs.\n- Proper clock generation and reset handling.\n- Logging of test results for each test case.\n\n### **Example Test Cases:**\n1. `src_clock = 100 MHz`, `des_clock = 100 MHz` (same phase).\n2. `src_clock = 100 MHz`, `des_clock = 50 MHz` (source faster than destination).\n3. `src_clock = 50 MHz`, `des_clock = 100 MHz` (destination faster than source).\n4. `src_clock = 100 MHz`, `des_clock = 100 MHz` (different phase).\n5. Random clock frequencies and reset scenarios.\n\n### **Expected Output:**\n- The testbench should:\n  - Apply the input test cases one by one.\n  - Display the comparison results (pass/fail) for each test case.\n  - Complete the simulation once all test cases are verified.", "context": {"verif/tb_cdc_pulse_synchronizer.sv": "module tb_cdc_pulse_synchronizer;\n\n    // Testbench signals\n    logic src_clock;\n    logic des_clock;\n    logic rst_in;\n    logic src_pulse;\n    logic des_pulse;\n\n    // Instantiate the DUT\n    cdc_pulse_synchronizer uut (\n        .src_clock(src_clock),\n        .des_clock(des_clock),\n        .rst_in(rst_in),\n        .src_pulse(src_pulse),\n        .des_pulse(des_pulse)\n    );\n\n    // Instantiate the stimulus generator\n    stimulus_generator stim_gen (\n        .src_clock(src_clock),\n        .des_clock(des_clock),\n        .rst_in(rst_in),\n        .src_pulse(src_pulse)\n    );\n\n    // Main test sequence\n    initial begin\n        $dumpfile(\"test.vcd\");\n        $dumpvars(0, tb_cdc_pulse_synchronizer);\n    end\n\nendmodule\n\nmodule stimulus_generator (\n    output logic src_clock,\n    output logic des_clock,\n    output logic rst_in,\n    output logic src_pulse\n);\n\n    // Clock periods (default values)\n    int src_clock_period = 10; // 100 MHz\n    int des_clock_period = 10; // 100 MHz\n\n    // Clock generation\n    initial begin\n        src_clock = 1;\n        forever #(src_clock_period / 2) src_clock = ~src_clock;\n    end\n\n    initial begin\n        des_clock = 1;\n        forever #(des_clock_period / 2) des_clock = ~des_clock;\n    end\n\n    // Common test logic\n    task automatic run_test();\n        rst_in <= 1;\n        src_pulse <= 0;\n        repeat (2) @(posedge src_clock);\n\n        rst_in <= 0;\n        @(posedge src_clock);\n        src_pulse <= 1;\n        @(posedge src_clock);\n        src_pulse <= 0;\n        @(posedge des_clock);\n        @(posedge des_clock);\n        @(posedge des_clock);\n        @(posedge des_clock);\n        @(posedge des_clock);\n        @(posedge des_clock);\n    endtask\n\n    // Test Case 1: src_clock and des_clock same speed, same phase\n    task automatic test_src_100MHz_des_100MHz_same_phase();\n        src_clock_period = 10; // 100 MHz\n        des_clock_period = 10; // 100 MHz\n        $display(\"Test Case 1: src_clock = 100 MHz, des_clock = 100 MHz (same phase)\");\n        run_test();\n    endtask\n\n    // Test Case 2: src_clock fast, des_clock slow\n    task automatic test_src_100MHz_des_50MHz();\n        src_clock_period = 10; // 100 MHz\n        des_clock_period = 20; // 50 MHz\n        $display(\"Test Case 2: src_clock = 100 MHz, des_clock = 50 MHz\");\n        run_test();\n    endtask\n\n    // Test Case 3: src_clock slow, des_clock fast\n    task automatic test_src_50MHz_des_100MHz();\n        src_clock_period = 20; // 50 MHz\n        des_clock_period = 10; // 100 MHz\n        $display(\"Test Case 3: src_clock = 50 MHz, des_clock = 100 MHz\");\n        run_test();\n    endtask\n\n    // Test Case 4: src_clock and des_clock same speed, different phase\n    task automatic test_src_100MHz_des_100MHz_different_phase();\n        src_clock_period = 10; // 100 MHz\n        des_clock_period = 10; // 100 MHz\n        #5; // Introduce phase shift\n        $display(\"Test Case 4: src_clock = 100 MHz, des_clock = 100 MHz (different phase)\");\n        run_test();\n    endtask\n\n    // Test Case 5: src_clock slow, des_clock fast\n    task automatic test_src_100MHz_des_250MHz();\n        src_clock_period = 10; // 100 MHz\n        des_clock_period = 4;  // 250 MHz\n        $display(\"Test Case 5: src_clock = 100 MHz, des_clock = 250 MHz\");\n        run_test();\n    endtask\n\n    // Test Case 6: Random clock frequencies and reset src_pulse\n    task automatic test_random_clocks_and_reset();\n        for (int i = 0; i < 10; i++) begin\n            src_clock_period = $urandom_range(3, 20); // Random period between 3 and 20 ns\n            des_clock_period = $urandom_range(3, 20); // Random period between 3 and 20 ns\n            $display(\"Test Case 6 (Iteration %0d): src_clock = %0d MHz, des_clock = %0d MHz\",\n                     i, 1000 / src_clock_period, 1000 / des_clock_period);\n            run_test();\n        end\n    endtask\n\n    // Test Case 7: Reset Test\n    task automatic test_reset();\n        src_clock_period = 10; // 100 MHz\n        des_clock_period = 10; // 100 MHz\n        $display(\"Test Case 7: src_clock = 100 MHz, des_clock = 100 MHz (Reset Test)\");\n        run_test();\n    endtask\n\n    // Test Case 8: Close frequencies\n    task automatic test_src_90MHz_des_100MHz();\n        src_clock_period = 11; // ~90.9 MHz\n        des_clock_period = 10; // 100 MHz\n        $display(\"Test Case 8: src_clock = ~90.9 MHz, des_clock = 100 MHz\");\n        run_test();\n    endtask\n\n    // Test Case 9: Prime frequencies\n    task automatic test_src_111p1MHz_des_83p33MHz();\n        src_clock_period = 9;  // ~111.1 MHz\n        des_clock_period = 12; // ~83.33 MHz\n        $display(\"Test Case 9: src_clock = ~111.1 MHz, des_clock = ~83.33 MHz\");\n        run_test();\n    endtask\n\n    // Test Case 10: Distance frequencies\n    task automatic test_src_1MHz_des_100MHz();\n        src_clock_period = 1000; // 1 MHz\n        des_clock_period = 10;   // 100 MHz\n        $display(\"Test Case 10: src_clock = 1 MHz, des_clock = 100 MHz\");\n        run_test();\n    endtask\n\n    // Test Case 11: Inverse frequencies\n    task automatic test_src_100MHz_des_1MHz();\n        src_clock_period = 10;   // 100 MHz\n        des_clock_period = 1000; // 1 MHz\n        $display(\"Test Case 11: src_clock = 100 MHz, des_clock = 1 MHz\");\n        run_test();\n    endtask\n\n    // Main test sequence\n    initial begin\n        test_src_100MHz_des_100MHz_same_phase();\n        test_src_100MHz_des_50MHz();\n        test_src_50MHz_des_100MHz();\n        test_src_100MHz_des_100MHz_different_phase();\n        test_src_100MHz_des_250MHz();\n        test_random_clocks_and_reset();\n        test_reset();\n        test_src_90MHz_des_100MHz();\n        test_src_111p1MHz_des_83p33MHz();\n        test_src_1MHz_des_100MHz();\n        test_src_100MHz_des_1MHz();\n\n        $display(\"All tests completed.\");\n        $finish;\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_cdc_pulse_synchronizer.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/cdc_pulse_synchronizer.sv \nHASH            = 4797e44a29e516e89ca4b9c001432ef218b79f19\nNUM_BUGS        = 3\n", "src/cdc_pulse_synchronizer.sv": "module cdc_pulse_synchronizer (\n    input  logic src_clock,   // Source Clock Domain\n    input  logic des_clock,   // Destination Clock Domain\n    input  logic rst_in,      // Reset\n    input  logic src_pulse,   // Source Pulse\n    output logic des_pulse    // Destination Pulse\n);\n\n    logic pls_toggle;      \n    logic pls_toggle_synca;\n    logic pls_toggle_syncb;\n    logic pls_toggle_syncc;\n\n    always_ff @(posedge src_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle <= 1'b0;\n        end else if (src_pulse) begin\n        `ifndef BUG_0\n            pls_toggle <= ~pls_toggle;\n        `else\n            pls_toggle <= 1'b0;\n        `endif\n        end else begin\n            pls_toggle <= pls_toggle;\n        end\n    end\n\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle_synca <= 1'b0;\n            pls_toggle_syncb <= 1'b0;\n        end else begin\n        `ifndef BUG_1\n            pls_toggle_synca <= pls_toggle;\n        `else\n            pls_toggle_synca <= ~pls_toggle; \n        `endif\n            pls_toggle_syncb <= pls_toggle_synca;\n        end\n    end\n\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle_syncc <= 1'b0;\n        end else begin\n            pls_toggle_syncc <= pls_toggle_syncb;\n        end\n    end\n\n\n    `ifndef BUG_2\n        assign des_pulse = pls_toggle_syncc ^ pls_toggle_syncb;\n    `else\n        assign des_pulse = 1'b0;\n    `endif\n\nendmodule\n\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_cdc_pulse_synchronizer_0022", "categories": ["cid014", "easy"], "input": {"prompt": "We have a `cdc_pulse_synchronizer` module designed to synchronize a single\u2010cycle pulse (`src_pulse`) from a source clock domain (`src_clock`) to a destination clock domain (`des_clock`). The module includes a reset (`rst_in`) that asynchronously initializes internal flip\u2010flops. To ensure robust pulse synchronization, below two checks are required. Hence, Add two immediate SystemVerilog assertions inside the `cdc_pulse_synchronizer` module:\n\n1. **Reset\u2010based assertion**: If `rst_in` is high on a rising edge of `src_clock`, then `src_pulse` must be `0`. If it is `1`, display an error message indicating that `src_pulse` is incorrectly asserted during reset.  \n2. **Single\u2010cycle pulse assertion**: Verify that `src_pulse` never stays high across two consecutive rising edges of `src_clock`. If `src_pulse` is still high on the next clock cycle, display an error message indicating an invalid multi\u2010cycle pulse.  \n\n---\n\n### **Inputs**:\n- `src_clock (1-bit)`: Rising edge triggered source clock domain.  \n- `des_clock (1-bit)`: Rising edge triggered destination clock domain.  \n- `rst_in (1-bit)`: Asynchronous reset input (active high).  \n- `src_pulse (1-bit)`: A single\u2010cycle pulse in the source domain.  \n\n### **Output**:\n- `des_pulse (1-bit)`: The synchronized pulse output in the destination domain.  ", "context": {"rtl/cdc_pulse_synchronizer.sv": "module cdc_pulse_synchronizer (\n    input  logic src_clock,   // Source Clock Domain\n    input  logic des_clock,   // Destination Clock Domain\n    input  logic rst_in,      // Reset\n    input  logic src_pulse,   // Source Pulse\n    output logic des_pulse    // Destination Pulse\n);\n\n    logic pls_toggle;      \n    logic pls_toggle_synca;\n    logic pls_toggle_syncb;\n    logic pls_toggle_syncc;\n\n    //--------------------------------------------------\n    //   Toggle Flop Circuit\n    //---------------------------------------------------\n    always_ff @(posedge src_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle <= 1'b0;\n        end \n        else if (src_pulse) begin\n            pls_toggle <= ~pls_toggle;\n        end \n        else begin\n            pls_toggle <= pls_toggle;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Double Flop Bit Synchronizer\n    //---------------------------------------------------\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle_synca <= 1'b0;\n            pls_toggle_syncb <= 1'b0;\n        end \n        else begin\n            pls_toggle_synca <= pls_toggle;\n            pls_toggle_syncb <= pls_toggle_synca;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Delay Logic of Output signal\n    //---------------------------------------------------\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle_syncc <= 1'b0;\n        end \n        else begin\n            pls_toggle_syncc <= pls_toggle_syncb;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Assign Statement for posedge and negedge detection\n    //---------------------------------------------------\n    assign des_pulse = pls_toggle_syncc ^ pls_toggle_syncb;\n\nendmodule\n\n"}}, "output": {"response": "", "context": {"rtl/cdc_pulse_synchronizer.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cdc_pulse_synchronizer.sv\nTOPLEVEL        = cdc_pulse_synchronizer\nMODULE          = test_cdc_pulse_synchronizer\nPYTHONPATH      = /src\nHASH            = cf1d4dba198b79a5245c75daca44e3b73c75ad6c\n", "src/test_cdc_pulse_synchronizer.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n# Initialize DUT\nasync def init_dut(dut):\n    dut.rst_in.value = 1\n    dut.src_pulse.value = 0\n    await RisingEdge(dut.src_clock)\n    await RisingEdge(dut.src_clock)\n    await RisingEdge(dut.src_clock)\n    await RisingEdge(dut.src_clock)\n\n# Test Case Run: src_pulse toggles and observe des_pulse\nasync def run_test(dut):\n    await RisingEdge(dut.src_clock)\n    dut.rst_in.value = 0\n\n    # Toggle src_pulse once\n    for _ in range(1):\n        await RisingEdge(dut.src_clock)\n        dut.src_pulse.value = 1\n        await RisingEdge(dut.src_clock)\n        dut.src_pulse.value = 0\n\n    # Monitor des_pulse\n    des_pulse_received = False\n    des_clock_cycles = 0\n    while not des_pulse_received and des_clock_cycles < 5:\n        await RisingEdge(dut.des_clock)\n        des_clock_cycles += 1\n        dut._log.info(f\"des_pulse = {dut.des_pulse.value}\")\n        if dut.des_pulse.value == 1:\n            des_pulse_received = True\n\n    assert des_pulse_received, \"des_pulse was not received within 4 des_clock cycles\"\n\n# Test Case 1: src_clock and des_clock same speed, same phase\n@cocotb.test()\nasync def test_src_100MHz_des_100MHz_same_phase(dut):\n    cocotb.start_soon(Clock(dut.src_clock, 10, units='ns').start())  # src_clock, 100MHz\n    cocotb.start_soon(Clock(dut.des_clock, 10, units='ns').start())  # des_clock, 100MHz same phase\n    await init_dut(dut)\n    await run_test(dut)\n\n# Test Case 2: src_clock fast, des_clock slow\n@cocotb.test()\nasync def test_src_100MHz_des_50MHz(dut):\n    cocotb.start_soon(Clock(dut.src_clock, 10, units='ns').start())  # Fast src_clock, 100 MHz\n    cocotb.start_soon(Clock(dut.des_clock, 20, units='ns').start())  # Slow des_clock, 50 MHz\n    await init_dut(dut)\n    await run_test(dut)\n\n# Test Case 3: src_clock slow, des_clock fast\n@cocotb.test()\nasync def test_src_50MHz_des_100MHz(dut):\n    cocotb.start_soon(Clock(dut.src_clock, 20, units='ns').start())  # Slow src_clock, 50MHz\n    cocotb.start_soon(Clock(dut.des_clock, 10, units='ns').start())   # Fast des_clock, 100MHz\n    await init_dut(dut)\n    await run_test(dut)\n\n# Test Case 4: src_clock and des_clock same speed, different phase\n@cocotb.test()\nasync def test_src_100MHz_des_100MHz_and_different_phase(dut):\n    cocotb.start_soon(Clock(dut.src_clock, 10, units='ns').start())  # src_clock, 100MHz\n    await Timer(5, units='ns')  # Add manual phase shift\n    cocotb.start_soon(Clock(dut.des_clock, 10, units='ns').start())  # des_clock, 100MHz with phase shift\n    await init_dut(dut)\n    await run_test(dut)\n\n# Test Case 5: src_clock slow, des_clock fast\n@cocotb.test()\nasync def test_RTL_Bug_src_100MHz_des_250MHz(dut):\n    cocotb.start_soon(Clock(dut.src_clock, 10, units='ns').start())  # Slow src_clock, 100MHz\n    cocotb.start_soon(Clock(dut.des_clock, 4, units='ns').start())   # Fast des_clock, 250MHz\n    await init_dut(dut)\n    await run_test(dut)\n\n\n# Test Case 6: Reset Test\n@cocotb.test()\nasync def test_reset(dut):\n    src_period = 10  # Fixed period for src_clock\n    des_period = 10  # Fixed period for des_clock\n\n    cocotb.start_soon(Clock(dut.src_clock, src_period, units='ns').start())\n    cocotb.start_soon(Clock(dut.des_clock, des_period, units='ns').start())\n\n    # Initialize DUT with reset\n    await init_dut(dut)\n\n    # De-assert reset and toggle src_pulse\n    dut.rst_in.value = 0\n    await RisingEdge(dut.src_clock)\n    dut.src_pulse.value = 1\n    await RisingEdge(dut.src_clock)\n    dut.src_pulse.value = 0\n\n    # Assert & De-assert reset\n    await RisingEdge(dut.src_clock)\n    await RisingEdge(dut.src_clock)\n    dut.rst_in.value = 1\n    await RisingEdge(dut.src_clock)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.src_clock)\n\n\n    # Ensure des_pulse is not asserted after reset\n    des_pulse_received = False\n    des_clock_cycles = 0\n    while not des_pulse_received and des_clock_cycles < 5:\n        await RisingEdge(dut.des_clock)\n        des_clock_cycles += 1\n        dut._log.info(f\"des_pulse = {dut.des_pulse.value}\")\n        if dut.des_pulse.value == 0:\n            des_pulse_received = True\n\n    assert des_pulse_received, \"des_pulse should not be asserted after reset\"\n\n\n# Test Case 7: distance frequencies\n@cocotb.test()\nasync def test_src_1MHz_des_100MHz(dut):\n    cocotb.start_soon(Clock(dut.src_clock, 1000, units='ns').start())  # Slow src_clock, 1MHz\n    cocotb.start_soon(Clock(dut.des_clock, 10, units='ns').start())   # Fast des_clock, 100MHz\n    await init_dut(dut)\n    await run_test(dut)\n\n# Test Case 8: Inverse frequencies\n@cocotb.test()\nasync def test_src_100MHz_des_1MHz(dut):\n    cocotb.start_soon(Clock(dut.src_clock, 10, units='ns').start())  # Slow src_clock, 100MHz\n    cocotb.start_soon(Clock(dut.des_clock, 1000, units='ns').start())   # Fast des_clock, 1MHz\n    await init_dut(dut)\n    await run_test(dut)\n\n\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_cellular_automata_0002", "categories": ["cid012", "easy"], "input": {"prompt": "Complete the given partial System Verilog testbench `tb_pseudoRandGenerator_ca`.The testbench must instantiate the `pseudoRandGenerator_ca`  RTL module and provide input stimulus for it, focusing exclusively on generating test vectors rather than building a full testbench.\nThe `pseudoRandGenerator_ca` module simulates a simple pseudo-random number generator using a cellular automata algorithm with a 16-bit seed input.\n\n## Description:\n### **Inputs** :\n\nRegisters :\n`CA_out` (16-bit,[15:0]): 16-bit pseudo-random output received from the **DUT**.\n\n### **Outputs** :\n\nRegisters :\n`clock (1-bit)`: Posedge Clock signal that toggles every 10ns (100 MHz) supplied to the **DUT** \n`reset (1-bit)`: Active-high synchronous reset signal that resets the output  of **DUT** to the initial seed value\n`CA_seed` (16-bit,[15:0]): 16-bit seed value for initializing the cellular automata **DUT**.\n\n## **Instantiation**:\nThe testbench instantiates the `pseudoRandGenerator_ca` module as dut and connects the signals between the module and the testbench. Each input and output from the **DUT** is connected to its corresponding signal in the testbench.\n\n## **Input Generation and Validation**:\n**Clock Generation**: \nThe clock signal clock is generated using an always block that toggles the clock every 10ns.\n\n**Reset**: \nThe reset signal reset is asserted at the beginning of the simulation to ensure the DUT initializes to the correct seed. After a short period (150ns), the reset is de-asserted.\n\n**Stimulus**: \nMultiple test cases are applied to simulate various initial seed values for the Cellular Automata algorithm. The output from the DUT is monitored to ensure the proper sequence of pseudo-random numbers is generated.\n \n-  **Test Case 1:**\n         **CA_Seed**: 16'hA5A5\n         This case tests the cellular automata algorithm with a specific seed to observe the random output.\n-  **Test Case 2:**\n         **CA_Seed**: 16'h3C3C\n         This case tests a different seed to ensure the correct random sequence is generated.\n-  **Test Case 3:**\n          **CA_Seed**: 16'h1234\n          This case checks the behavior of the generator with a hexadecimal seed value.\n-  **Test Case 4:**\n          **CA_Seed**: 16'h4444\n           This case evaluates the algorithm with another specific seed.\n-  **Test Case 5:**\n           **CA_Seed**: 16'h5BEF\n           Testing with a random 16-bit seed value to observe variation in the random output.\n-  **Test Case 6:**\n           **CA_Seed**: 16'h0001\n           Verifies edge case where the seed is the smallest non-zero value.\n-  **Test Case 7:**\n          **CA_Seed**: 16'hFFFF\n          Verifies the upper boundary seed to ensure the algorithm handles high values correctly.\n-  **Test Case 8:**\n           CA_Seed: 16'hAAAA\n           Verifies the cellular automata's ability to handle seeds with alternating bits.\n-  **Test Case 9:**\n            **CA_Seed**: 16'h5555\n            Similar to the previous case, but with alternating low/high bits.\n\n\n## **Reset Handling**:\nAfter running the test cases, a reset is asserted again to ensure the generator is properly reset to its initial seed state and the output is as expected.\n\n**Partial Test Stimulus Generator Code** :\n```verilog\nmodule tb_pseudoRandGenerator_ca;\n\nlogic clk;\nlogic reset;\nlogic [15:0] CA_seed;      // 16-bit seed input\nlogic [15:0] CA_out;       // 16-bit output for Cellular Automata\n\n\npseudoRandGenerator_ca dut (\n    .clock(clk),       \n    .reset(reset),     \n    .CA_seed(CA_seed), \n    .CA_out(CA_out)    \n);\n\n\nalways begin\n    #10 clk = ~clk; \nend\n\n\ntask initialization();\n    begin\n        clk = 1'b0;\n        reset = 1'b1;  \n        CA_seed = 16'hA5A5;  \n    end\nendtask\n\n\ntask drive_reset();\n    begin\n        reset = 1'b1;  \n    end\nendtask\n\n\ntask clear_reset();\n    begin\n        reset = 1'b0;  \n    end\nendtask\n\n\ntask run_test_case(input [15:0] test_seed);\n    begin\n        CA_seed = test_seed;  \n        #1000;                \n        $display(\"Test case with seed %h finished\", test_seed);\n    end\nendtask\n\n\ninitial begin\n    $dumpfile(\"tb_pseudoRandGenerator_ca.vcd\");\n    $dumpvars(0, tb_pseudoRandGenerator_ca);  \n\n    initialization();  \n    #150;\n    clear_reset();\n    run_test_case(16'hA5A5);  \n    // Insert the code for the remaining test cases here\n```    \n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_pseudoRandGenerator_ca.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = fcc6f07e2b215bcbd7f1090a50190bceefbecb13\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n        \n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n", "src/pseudoRandGenerator_ca.sv": "module pseudoRandGenerator_ca (\n    input  logic       clock,    // Clock input\n    input  logic       reset,    // Active-high synchronous Reset\n    input  logic [15:0] CA_seed,  // 16-bit Cellular Automata seed\n    output logic [15:0] CA_out    // 16-bit Cellular Automata output\n);\n\n    logic q1, q2, q3, q4, q5, q6, q7, q8;\n    logic q9, q10, q11, q12, q13, q14, q15, q16;\n\n    assign q1  = CA_out[14];                             \n    assign q2  = CA_out[15] ^ CA_out[13];                \n    assign q3  = CA_out[14] ^ CA_out[13] ^ CA_out[12];   \n    assign q4  = CA_out[13] ^ CA_out[11];                \n    assign q5  = CA_out[12] ^ CA_out[11] ^ CA_out[10];   \n    assign q6  = CA_out[11] ^ CA_out[9];                 \n    assign q7  = CA_out[10] ^ CA_out[9] ^ CA_out[8];     \n    assign q8  = CA_out[9] ^ CA_out[7];                  \n    assign q9  = CA_out[8] ^ CA_out[7] ^ CA_out[6];      \n    assign q10 = CA_out[7] ^ CA_out[5];                  \n    assign q11 = CA_out[6] ^ CA_out[5] ^ CA_out[4];      \n    assign q12 = CA_out[5] ^ CA_out[3];                  \n    assign q13 = CA_out[4] ^ CA_out[3] ^ CA_out[2];      \n    assign q14 = CA_out[3] ^ CA_out[1];                  \n    assign q15 = CA_out[2] ^ CA_out[1] ^ CA_out[0];      \n    assign q16 = CA_out[1];                              \n\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            CA_out <= CA_seed;\n        end else begin\n            CA_out[15] <= q1;\n            CA_out[14] <= q2;\n            CA_out[13] <= q3;\n            CA_out[12] <= q4;\n            CA_out[11] <= q5;\n            CA_out[10] <= q6;\n            CA_out[9]  <= q7;\n            CA_out[8]  <= q8;\n            CA_out[7]  <= q9;\n            CA_out[6]  <= q10;\n            CA_out[5]  <= q11;\n            CA_out[4]  <= q12;\n            CA_out[3]  <= q13;\n            CA_out[2]  <= q14;\n            CA_out[1]  <= q15;\n            CA_out[0]  <= q16;\n        end\n    end\n\nendmodule"}}}
{"id": "cvdp_copilot_cellular_automata_0014", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add an immediate assertion in the RTL design of the Cellular Automata (`pseudoRandGenerator_ca`) module to check whether the `CA_seed` is initialized to all zeros (16'd0)? Add a suitable SystemVerilog assertion statement in the RTL code that displays an error message when the Cellular Automata is loaded with an all-zero seed. The assertion should check that `CA_seed` is not equal to zero during reset, as initializing the Cellular Automata with an all-zero seed will cause the `CA_out` to remain at zero indefinitely, which is invalid for generating pseudorandom outputs.\n\nThe assertion should be added to ensure the `CA_seed` is a non-zero value before the module begins operating. If the `CA_seed` is zero, the assertion should trigger an error message and display an error message during the simulation.\n\n## Interface:\n### **Inputs**:\n- `clock (1-bit)`: The positive edged clock signal driving the module.\n- `reset (1-bit)`: The active-high synchronous reset signal, which resets the Cellular Automata to the `CA_seed`.\n- `CA_seed (16-bit,[15:0])`: A 16-bit input seed used for initialization and subsequent operations of the Cellular Automata.\n### **Outputs**:\n- `CA_out (16-bit,[15:0])`: The 16-bit output representing the current state of the Cellular Automata.\n", "context": {"rtl/pseudoRandGenerator_ca.sv": "module pseudoRandGenerator_ca (\n    input  logic       clock,    // Clock input\n    input  logic       reset,    // Active-high synchronous Reset\n    input  logic [15:0] CA_seed,  // 16-bit Cellular Automata seed\n    output logic [15:0] CA_out    // 16-bit Cellular Automata output\n);\n\n    logic q1, q2, q3, q4, q5, q6, q7, q8;\n    logic q9, q10, q11, q12, q13, q14, q15, q16;\n\n    assign q1  = CA_out[14];                             \n    assign q2  = CA_out[15] ^ CA_out[13];                \n    assign q3  = CA_out[14] ^ CA_out[13] ^ CA_out[12];   \n    assign q4  = CA_out[13] ^ CA_out[11];                \n    assign q5  = CA_out[12] ^ CA_out[11] ^ CA_out[10];   \n    assign q6  = CA_out[11] ^ CA_out[9];                 \n    assign q7  = CA_out[10] ^ CA_out[9] ^ CA_out[8];     \n    assign q8  = CA_out[9] ^ CA_out[7];                  \n    assign q9  = CA_out[8] ^ CA_out[7] ^ CA_out[6];      \n    assign q10 = CA_out[7] ^ CA_out[5];                  \n    assign q11 = CA_out[6] ^ CA_out[5] ^ CA_out[4];      \n    assign q12 = CA_out[5] ^ CA_out[3];                  \n    assign q13 = CA_out[4] ^ CA_out[3] ^ CA_out[2];      \n    assign q14 = CA_out[3] ^ CA_out[1];                  \n    assign q15 = CA_out[2] ^ CA_out[1] ^ CA_out[0];      \n    assign q16 = CA_out[1];                              \n\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            CA_out <= CA_seed;\n        end else begin\n            CA_out[15] <= q1;\n            CA_out[14] <= q2;\n            CA_out[13] <= q3;\n            CA_out[12] <= q4;\n            CA_out[11] <= q5;\n            CA_out[10] <= q6;\n            CA_out[9]  <= q7;\n            CA_out[8]  <= q8;\n            CA_out[7]  <= q9;\n            CA_out[6]  <= q10;\n            CA_out[5]  <= q11;\n            CA_out[4]  <= q12;\n            CA_out[3]  <= q13;\n            CA_out[2]  <= q14;\n            CA_out[1]  <= q15;\n            CA_out[0]  <= q16;\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/pseudoRandGenerator_ca.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/pseudoRandGenerator_ca.sv\nTOPLEVEL        = pseudoRandGenerator_ca\nMODULE          = test_pseudoRandGenerator_ca\nPYTHONPATH      = /src\nHASH            = 14-cellular_automata_tb_assertion_generation\n", "src/test_pseudoRandGenerator_ca.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport random\n\nasync def is_maximal_length_sequence(dut, cycles):\n    \"\"\"\n    Check whether the sequence generated by the DUT is a maximal-length sequence.\n    A maximal-length sequence for a 16-bit CA visits all 2^16 - 1 = 65535 unique states before repeating.\n    \"\"\"\n    visited_states = set()\n\n    for i in range(cycles):\n        await RisingEdge(dut.clock)\n        current_value = int(dut.CA_out.value)\n\n        # Track visited states\n        visited_states.add(current_value)\n\n    # A maximal-length sequence for a 16-bit CA should have 65535 unique states\n    expected_length = 2**16 - 1\n    if len(visited_states) == expected_length:\n        dut._log.info(f\"Maximal-length sequence achieved with {len(visited_states)} unique states.\")\n        return True\n    else:\n        dut._log.warning(f\"Sequence is not maximal-length. Only {len(visited_states)} unique states visited.\")\n        return False\n\n\n@cocotb.test()\nasync def display_CA_out_and_check_sequence(dut):\n    \"\"\"\n    Display the value of CA_out at each clock cycle, count repeated values, \n    and check whether the sequence is maximal-length.\n    \"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clock, 10, units=\"ns\").start())\n\n    # Initialize the DUT\n    seed = 0b0001000100100011  # Non-zero seed\n    dut.reset.value = 1\n    dut.CA_seed.value = seed\n    await RisingEdge(dut.clock)  # Apply reset\n    dut.reset.value = 0\n    await RisingEdge(dut.clock)  # Allow one clock cycle after deasserting reset\n    dut._log.info(f\"Initialized with seed: {seed:#06x}\")\n\n    # Dictionary to track the count of each value\n    value_count = {}\n\n    # Number of cycles to run\n    cycles = 65536  # Set to 2^16 for maximal-length sequence check\n\n    for i in range(cycles):\n        await RisingEdge(dut.clock)\n        current_value = int(dut.CA_out.value)\n\n        # Update the count for the current value\n        if current_value in value_count:\n            value_count[current_value] += 1\n        else:\n            value_count[current_value] = 1\n\n        # Display the value and the current count for it\n        dut._log.info(f\"Cycle {i+1}: CA_out = {current_value:#06x}, Count = {value_count[current_value]}\")\n\n    # Log the values that were repeated\n    repeated_values = {val: count for val, count in value_count.items() if count > 1}\n    if repeated_values:\n        dut._log.warning(\"Repeated values detected:\")\n        for val, count in repeated_values.items():\n            dut._log.warning(f\"Value {val:#06x} repeated {count} times.\")\n    else:\n        dut._log.info(\"No repeated values detected.\")\n\n    # Check if the sequence is maximal-length\n    maximal_length = await is_maximal_length_sequence(dut, cycles)\n    if maximal_length:\n        dut._log.info(\"The sequence generated by the DUT is maximal-length.\")\n    else:\n        dut._log.warning(\"The sequence generated by the DUT is not maximal-length.\")\n\n\n@cocotb.test()\nasync def test_fixed_seed(dut):\n    \"\"\"\n    Test the DUT with a fixed seed value.\n    \"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clock, 10, units=\"ns\").start())\n\n    # Use a fixed seed\n    seed = 0x1234  # Example fixed seed\n    dut.reset.value = 1\n    dut.CA_seed.value = seed\n    await RisingEdge(dut.clock)  # Apply reset\n    dut.reset.value = 0\n    await RisingEdge(dut.clock)  # Allow one clock cycle after deasserting reset\n    dut._log.info(f\"Initialized with fixed seed: {seed:#06x}\")\n\n    # Observe behavior for 20 cycles\n    for i in range(20):\n        await RisingEdge(dut.clock)\n        dut._log.info(f\"Cycle {i + 1}: CA_out = {int(dut.CA_out.value):#06x}\")\n\n\n@cocotb.test()\nasync def test_incremental_seeds(dut):\n    \"\"\"\n    Test the DUT with incremental seed values.\n    \"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clock, 10, units=\"ns\").start())\n\n    # Test for seeds from 0x0001 to 0x0010\n    for seed in range(0x0001, 0x0011):\n        dut.reset.value = 1\n        dut.CA_seed.value = seed\n        await RisingEdge(dut.clock)  # Apply reset\n        dut.reset.value = 0\n        await RisingEdge(dut.clock)  # Allow one clock cycle after deasserting reset\n        dut._log.info(f\"Initialized with incremental seed: {seed:#06x}\")\n\n        # Observe behavior for 10 cycles\n        for i in range(10):\n            await RisingEdge(dut.clock)\n            dut._log.info(f\"Cycle {i + 1}: CA_out = {int(dut.CA_out.value):#06x}\")\n\n\n@cocotb.test()\nasync def test_random_seeds(dut):\n    \"\"\"\n    Test the DUT with random seed values.\n    \"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clock, 10, units=\"ns\").start())\n\n    # Test for 5 random seeds\n    for _ in range(5):\n        seed = random.randint(1, 0xFFFF)  # Non-zero random seed\n        dut.reset.value = 1\n        dut.CA_seed.value = seed\n        await RisingEdge(dut.clock)  # Apply reset\n        dut.reset.value = 0\n        await RisingEdge(dut.clock)  # Allow one clock cycle after deasserting reset\n        dut._log.info(f\"Initialized with random seed: {seed:#06x}\")\n\n        # Observe behavior for 10 cycles\n        for i in range(10):\n            await RisingEdge(dut.clock)\n            dut._log.info(f\"Cycle {i + 1}: CA_out = {int(dut.CA_out.value):#06x}\")\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_coffee_machine_0003", "categories": ["cid014", "medium"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `coffee_machine` module. The assertions should ensure correct reset behavior, proper operation sequencing, and correct output conditions based on the input signals.\n\n## **RTL Design Overview**  \nThe `coffee_machine` module implements a **state-based coffee brewing system** that processes input commands and sensor data to control the coffee-making process. It takes parameters for operation delays and bean selection and generates output signals to control different steps of coffee preparation.\n\n### **Key Components of the Module**\n- **`clk`**: Clock signal, synchronizing operations.\n- **`rst_async_n`**: Asynchronous active-low reset.\n- **`i_operation_sel`**: Defines the operation to be performed (grinding, heating, pouring, etc.).\n- **`i_start`**: Start signal initiating the coffee-making process.\n- **`i_sensor`**: Sensor data input for monitoring machine status.\n- **`i_grind_delay`**: Configures the delay of the GRIND operation.\n- **`i_heat_delay`**: Configures the delay of the HEAT operation.\n- **`i_pour_delay`**: Configures the delay of the POUR operation.\n- **`i_bean_sel`**: Selects which bean to use.\n- **`o_bean_sel`**: Output representing the selected bean type for grinding.\n- **`o_grind_beans`**: Output signal controlling bean grinding.\n- **`o_use_powder`**: Output signal for using pre-ground powder instead of beans.\n- **`o_heat_water`**: Output controlling the water heating process.\n- **`o_pour_coffee`**: Output controlling the water pouring process.\n- **`o_error`**: Error output. Indicates an error either during the operation or prior to its start.\n- **`state_ff`**: Tracks the current state of the internal FSM.\n- **`state_nx`**: Tracks the next state of the internal FSM.\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:\n\n1. **Reset Behavior:**\n  - When `rst_async_n` is asserted (goes low), all output control signals (`o_bean_sel`, `o_grind_beans`, `o_use_powder`, `o_heat_water`, `o_pour_coffee`) and the internal FSM `state_ff` must be reset to `0` immediately.\n\n2. **State Number of Cycles Tracking:**\n  - When entering _BEAN_SEL_ state, the FSM must stay in it for `SEL_CYCLES` cycles. (SEL_CYCLES is an internal parameter, set to 3).\n  - When entering _POWDER_ state, the FSM must stay in it for `POWDER_CYCLES` cycles. (POWDER_CYCLES is an internal parameter, set to 2).\n\n3. **State Changes**\n  - The FSM state transition must follow these rules:\n     1. From _IDLE_, it can go to _HEAT_, _BEAN_SEL_, _POWDER_, _POUR_ or _IDLE_.\n     2. From _BEAN_SEL_, it can go to _BEAN_SEL_, _GRIND_ or _IDLE_.\n     3. From _GRIND_, it can go to _GRIND_, _HEAT_, _POWDER_ or _IDLE_.\n     4. From _POWDER_, it can go to _POWDER_, _POUR_ or _IDLE_.\n     5. From _HEAT_, it can go to _HEAT_, _POWDER_, _POUR_ or _IDLE_.\n     6. From _POUR_, it can go to _POUR_ or _IDLE_.\n  - All states can be active for more than 1 clock cycles.\n\n4. **Error behavior**\n  - When `i_sensor[3]` is asserted, `o_error` must always be asserted.\n  - When the FSM state is not _IDLE_ and `i_sensor[3] == 0`, `o_error` can never be 1.\n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating incorrect operation sequencing or violations of expected conditions.  ", "context": {"rtl/coffee_machine.sv": "module coffee_machine #(\n    parameter NBW_DLY    = 'd5,\n    parameter NBW_BEANS  = 'd2,\n    parameter NS_BEANS   = 'd4,\n    parameter NS_OP      = 'd3, // Fixed\n    parameter NS_SENSOR  = 'd4  // Fixed\n) (\n    input  logic                 clk,\n    input  logic                 rst_async_n,\n    input  logic [NBW_DLY-1:0]   i_grind_delay,\n    input  logic [NBW_DLY-1:0]   i_heat_delay,\n    input  logic [NBW_DLY-1:0]   i_pour_delay,\n    input  logic [NBW_BEANS-1:0] i_bean_sel,\n    input  logic [NS_OP-1:0]     i_operation_sel,\n    input  logic                 i_start,\n    input  logic [NS_SENSOR-1:0] i_sensor,\n    output logic [NS_BEANS-1:0]  o_bean_sel,\n    output logic                 o_grind_beans,\n    output logic                 o_use_powder,\n    output logic                 o_heat_water,\n    output logic                 o_pour_coffee,\n    output logic                 o_error\n);\n\n// Fixed delays (bean selection and powder usage)\nlocalparam SEL_CYCLES    = 'd3;\nlocalparam POWDER_CYCLES = 'd2;\n\ntypedef enum logic [2:0] {\n    IDLE     = 3'b000,\n    BEAN_SEL = 3'b001,\n    GRIND    = 3'b011,\n    POWDER   = 3'b111,\n    HEAT     = 3'b110,\n    POUR     = 3'b100\n} state_t;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nstate_t state_ff, state_nx;\nlogic [NS_BEANS-1:0]  bean_sel_out_ff, bean_sel_out_nx;\nlogic [NBW_DLY:0]     counter_ff, counter_nx;\nlogic [NBW_DLY-1:0]   grind_delay_ff, heat_delay_ff, pour_delay_ff;\nlogic [NS_OP-1:0]     operation_sel_ff;\nlogic [NBW_BEANS-1:0] bean_sel_in_ff;\nlogic                 start_ff;\n\n// Output assignment (error conditions)\nalways_comb begin : error_logic\n    if(state_ff == IDLE) begin\n        o_error = (i_sensor[0] | i_sensor[3]) | (&i_operation_sel[2:1]) | (i_operation_sel[1] & i_sensor[1]) | ((i_operation_sel == 3'b100 || i_operation_sel == 3'b001) & i_sensor[2]);\n    end else begin\n        o_error = i_sensor[3];\n    end\nend\n\n// ----------------------------------------\n// - Registers\n// ----------------------------------------\nalways_ff @(posedge clk) begin : data_regs\n    start_ff <= i_start & ~(i_sensor[0] | i_sensor[3]) & ~(&i_operation_sel[2:1]) & ~(i_operation_sel[1] & i_sensor[1]) & ~((i_operation_sel == 3'b100 || i_operation_sel == 3'b001) & i_sensor[2]);\n\n    if(i_start && state_ff == IDLE) begin\n        operation_sel_ff <= i_operation_sel;\n        grind_delay_ff   <= i_grind_delay;\n        heat_delay_ff    <= i_heat_delay;\n        pour_delay_ff    <= i_pour_delay;\n        bean_sel_in_ff   <= i_bean_sel;\n    end\n\n    counter_ff      <= counter_nx;\n    bean_sel_out_ff <= bean_sel_out_nx;\nend\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : reset_regs\n    if(~rst_async_n) begin\n        state_ff <= IDLE;\n    end else begin\n        state_ff <= state_nx;\n    end\nend\n\n// ----------------------------------------\n// - FSM update\n// ----------------------------------------\nalways_comb begin\n    case(state_ff)\n        IDLE: begin\n            counter_nx = 0;\n\n            if(start_ff) begin\n                if(~(|i_operation_sel[2:1])) begin\n                    state_nx = HEAT;\n                end else if(i_operation_sel[1]) begin\n                    state_nx = BEAN_SEL;\n                end else if(i_operation_sel[0]) begin\n                    state_nx = POUR;\n                end else begin\n                    state_nx = POWDER;\n                end\n            end else begin\n                state_nx = IDLE;\n            end\n        end\n        BEAN_SEL: begin\n            if(i_sensor[3]) begin\n                counter_nx = 0;\n                state_nx   = IDLE;\n            end else begin\n                if(counter_ff >= SEL_CYCLES-1) begin\n                    counter_nx = 0;\n                    state_nx   = GRIND;\n                end else begin\n                    counter_nx = counter_ff + 1'b1;\n                    state_nx   = BEAN_SEL;\n                end\n            end\n        end\n        GRIND: begin\n            if(i_sensor[3]) begin\n                counter_nx = 0;\n                state_nx   = IDLE;\n            end else begin\n                if(counter_ff >= grind_delay_ff-1) begin\n                    counter_nx = 0;\n                    if(operation_sel_ff[0]) begin\n                        state_nx = POWDER;\n                    end else begin\n                        state_nx = HEAT;\n                    end\n                end else begin\n                    counter_nx = counter_ff + 1'b1;\n                    state_nx   = GRIND;\n                end\n            end\n        end\n        POWDER: begin\n            if(i_sensor[3]) begin\n                counter_nx = 0;\n                state_nx   = IDLE;\n            end else begin\n                if(counter_ff >= POWDER_CYCLES-1) begin\n                    counter_nx = 0;\n                    state_nx   = POUR;\n                end else begin\n                    counter_nx = counter_ff + 1'b1;\n                    state_nx   = POWDER;\n                end\n            end\n        end\n        HEAT: begin\n            if(i_sensor[3]) begin\n                counter_nx = 0;\n                state_nx   = IDLE;\n            end else begin\n                if(counter_ff >= heat_delay_ff-1) begin\n                    counter_nx = 0;\n                    if(|operation_sel_ff[1:0]) begin\n                        state_nx = POWDER;\n                    end else begin\n                        state_nx = POUR;\n                    end\n                end else begin\n                    counter_nx = counter_ff + 1'b1;\n                    state_nx   = HEAT;\n                end\n            end\n        end\n        POUR: begin\n            if(i_sensor[3]) begin\n                counter_nx = 0;\n                state_nx   = IDLE;\n            end else begin\n                if(counter_ff >= pour_delay_ff-1) begin\n                    counter_nx = 0;\n                    state_nx   = IDLE;\n                end else begin\n                    counter_nx = counter_ff + 1'b1;\n                    state_nx   = POUR;\n                end\n            end\n        end\n        default: begin\n            counter_nx = 0;\n            state_nx   = IDLE;\n        end\n    endcase\nend\n\n// ----------------------------------------\n// - Controller outputs\n// ----------------------------------------\nalways_comb begin\n    case(state_ff)\n        IDLE: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_use_powder    = 1'b0;\n            o_grind_beans   = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n            bean_sel_out_nx = {NS_BEANS{1'b0}};\n        end\n        BEAN_SEL: begin\n            o_bean_sel                      = 1'b0; // Set all bits to 0\n            o_bean_sel[bean_sel_in_ff]      = 1'b1; // Only the position of bean_sel_ff should be 1\n            o_grind_beans                   = 1'b0;\n            o_use_powder                    = 1'b0;\n            o_heat_water                    = 1'b0;\n            o_pour_coffee                   = 1'b0;\n            bean_sel_out_nx                 = 1'b0;\n            bean_sel_out_nx[bean_sel_in_ff] = 1'b1;\n        end\n        GRIND: begin\n            o_bean_sel      = bean_sel_out_ff;\n            o_grind_beans   = 1'b1;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n            bean_sel_out_nx = bean_sel_out_ff;\n        end\n        POWDER: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b1;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n            bean_sel_out_nx = {NS_BEANS{1'b0}};\n        end\n        HEAT: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b1;\n            o_pour_coffee   = 1'b0;\n            bean_sel_out_nx = {NS_BEANS{1'b0}};\n        end\n        POUR: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b1;\n            bean_sel_out_nx = {NS_BEANS{1'b0}};\n        end\n        default: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n            bean_sel_out_nx = {NS_BEANS{1'b0}};\n        end\n    endcase\nend\n \nendmodule : coffee_machine"}}, "output": {"response": "", "context": {"rtl/coffee_machine.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nSIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/coffee_machine.sv\nTOPLEVEL        = coffee_machine\nMODULE          = test_coffee_machine\nPYTHONPATH      = /src\nHASH            = 3-coffee-marchine-assertions\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport os\nimport subprocess\nimport re\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nclass CoffeeMachine:\n    def __init__(self, operation=0, i_grind_delay=1, i_heat_delay=1, i_pour_delay=1, i_bean_sel=0, num_beans=4):\n        self.state = \"IDLE\"\n        self.o_bean_sel = 0\n        self.o_grind_beans = 0\n        self.o_use_powder = 0\n        self.o_heat_water = 0\n        self.o_pour_coffee = 0\n        self.o_error = 0\n        self.i_sensor = 0\n        self.operation = operation\n        self.step = 0  # Track progress in operation sequence\n        self.i_grind_delay = i_grind_delay\n        self.i_heat_delay = i_heat_delay\n        self.i_pour_delay = i_pour_delay\n        self.state_counter = 0  # Counter for state delays\n        self.POWDER_DELAY = 2  # Fixed delay for POWDER state\n        self.BEAN_SEL_DELAY = 3  # Fixed delay for BEAN_SEL state\n        self.i_bean_sel = i_bean_sel\n        self.num_beans = num_beans\n    \n    def reset(self):\n        self.state = \"IDLE\"\n        self.reset_outputs()\n        \n    \n    def update_error(self):\n        if self.i_sensor & 0b1000:  # Generic error\n            self.o_error = 1\n        elif self.state == \"IDLE\":\n            if self.i_sensor & 0b0001:  # No water error\n                self.o_error = 1\n            elif (self.i_sensor & 0b0010) and (self.operation == 0b010 or self.operation == 0b011):  # No beans error\n                self.o_error = 1\n            elif (self.i_sensor & 0b0100) and (self.operation == 0b100 or self.operation == 0b001):  # No powder error\n                self.o_error = 1\n            elif self.operation == 0b110 or self.operation == 0b111:\n                self.o_error = 1\n            else:\n                self.o_error = 0\n        else:\n            self.o_error = 0\n    \n    def update_state(self, operation, i_sensor, i_grind_delay, i_heat_delay, i_pour_delay, i_bean_sel):\n        self.i_sensor = i_sensor\n        if self.state == \"IDLE\":\n            self.operation = operation\n            self.i_grind_delay = i_grind_delay\n            self.i_heat_delay = i_heat_delay\n            self.i_pour_delay = i_pour_delay\n            self.i_bean_sel = i_bean_sel\n            self.step = 0  # Reset step counter\n            self.state_counter = 0\n        self.update_error()\n\n        steps = {\n            0b000: [self.heat, self.pour, self.idle],\n            0b001: [self.heat, self.powder, self.pour, self.idle],\n            0b010: [self.bean_sel, self.grind, self.heat, self.powder, self.pour, self.idle],\n            0b011: [self.bean_sel, self.grind, self.powder, self.pour, self.idle],\n            0b100: [self.powder, self.pour, self.idle],\n            0b101: [self.pour, self.idle],\n        }\n        \n        if self.o_error:\n            current_state = steps[self.operation][self.step]\n            current_state()\n            self.state = \"IDLE\"\n            return\n\n        \n        if self.operation in steps and self.step < len(steps[self.operation]):\n            current_state = steps[self.operation][self.step]\n            \n            if self.state == \"BEAN_SEL\" and self.state_counter < self.BEAN_SEL_DELAY-1:\n                self.state_counter += 1\n            elif self.state == \"GRIND\" and self.state_counter < self.i_grind_delay-1:\n                self.state_counter += 1\n            elif self.state == \"HEAT\" and self.state_counter < self.i_heat_delay-1:\n                self.state_counter += 1\n            elif self.state == \"POWDER\" and self.state_counter < self.POWDER_DELAY-1:\n                self.state_counter += 1\n            elif self.state == \"POUR\" and self.state_counter < self.i_pour_delay-1:\n                self.state_counter += 1\n            else:\n                self.state_counter = 0\n                current_state()\n                self.step += 1  # Move to next step in the sequence\n        \n        return 0\n    \n    def idle(self):\n        self.state = \"IDLE\"\n        self.reset_outputs()\n    \n    def bean_sel(self):\n        self.reset_outputs()\n        self.state = \"BEAN_SEL\"\n        self.o_bean_sel = 1 << self.i_bean_sel  # One-hot encoding\n    \n    def grind(self):\n        self.reset_outputs()\n        self.state = \"GRIND\"\n        self.o_grind_beans = 1\n        self.o_bean_sel = 1 << self.i_bean_sel  # Maintain bean selection in one-hot encoding\n    \n    def powder(self):\n        self.reset_outputs()\n        self.state = \"POWDER\"\n        self.o_use_powder = 1\n    \n    def heat(self):\n        self.reset_outputs()\n        self.state = \"HEAT\"\n        self.o_heat_water = 1\n    \n    def pour(self):\n        self.reset_outputs()\n        self.state = \"POUR\"\n        self.o_pour_coffee = 1\n    \n    def reset_outputs(self):\n        self.o_bean_sel = 0\n        self.o_grind_beans = 0\n        self.o_use_powder = 0\n        self.o_heat_water = 0\n        self.o_pour_coffee = 0\n    \n    def get_status(self):\n        return {\n            \"state\": self.state,\n            \"o_bean_sel\": self.o_bean_sel,\n            \"o_grind_beans\": self.o_grind_beans,\n            \"o_use_powder\": self.o_use_powder,\n            \"o_heat_water\": self.o_heat_water,\n            \"o_pour_coffee\": self.o_pour_coffee,\n            \"o_error\": self.o_error,\n            \"step\": self.step,\n            \"state_counter\": self.state_counter,\n        }\n\n    \n#################    ASSERTIONS STUFF        ###############\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n", "src/test_coffee_machine.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_bean_sel = dut.o_bean_sel.value\n    dut_grind_beans = dut.o_grind_beans.value\n    dut_use_powder = dut.o_use_powder.value\n    dut_heat_water = dut.o_heat_water.value\n    dut_pour_coffee = dut.o_pour_coffee.value\n    dut_error = dut.o_error.value\n\n    model_output = model.get_status()\n    model_bean_sel    = int(model_output[\"o_bean_sel\"])\n    model_grind_beans = int(model_output[\"o_grind_beans\"])\n    model_use_powder  = int(model_output[\"o_use_powder\"])\n    model_heat_water  = int(model_output[\"o_heat_water\"])\n    model_pour_coffee = int(model_output[\"o_pour_coffee\"])\n    model_error       = int(model_output[\"o_error\"])\n\n    if debug == 1:\n        print(\"\\nINPUTS\")\n        print(f\"DUT i_grind_delay   = {dut.i_grind_delay.value} MODEL i_grind_delay   = {model.i_grind_delay}\")\n        print(f\"DUT i_heat_delay    = {dut.i_heat_delay.value} MODEL i_heat_delay    = {model.i_heat_delay}\")\n        print(f\"DUT i_pour_delay    = {dut.i_pour_delay.value} MODEL i_pour_delay    = {model.i_pour_delay}\")\n        print(f\"DUT i_bean_sel      = {dut.i_bean_sel.value} MODEL i_bean_sel      = {model.i_bean_sel}\")\n        print(f\"DUT i_operation_sel = {dut.i_operation_sel.value} MODEL i_operation_sel = {model.operation}\")\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_bean_sel    = {dut_bean_sel} MODEL o_bean_sel    = {model_bean_sel}\")\n        print(f\"DUT o_grind_beans = {dut_grind_beans} MODEL o_grind_beans = {model_grind_beans}\")\n        print(f\"DUT o_use_powder  = {dut_use_powder} MODEL o_use_powder  = {model_use_powder}\")\n        print(f\"DUT o_heat_water  = {dut_heat_water} MODEL o_heat_water  = {model_heat_water}\")\n        print(f\"DUT o_pour_coffee = {dut_pour_coffee} MODEL o_pour_coffee = {model_pour_coffee}\")\n        print(f\"DUT o_error = {dut_error} MODEL o_error = {model_error}\")\n        print(f\"DUT state = {dut.state_ff.value} MODEL state = {model.state}\")\n\n    assert dut_bean_sel    == model_bean_sel,    f\"[ERROR] DUT o_bean_sel does not match model o_bean_sel: {dut_bean_sel} != {model_bean_sel}\"\n    assert dut_grind_beans == model_grind_beans, f\"[ERROR] DUT o_grind_beans does not match model o_grind_beans: {dut_grind_beans} != {model_grind_beans}\"\n    assert dut_use_powder  == model_use_powder,  f\"[ERROR] DUT o_use_powder does not match model o_use_powder: {dut_use_powder} != {model_use_powder}\"\n    assert dut_heat_water  == model_heat_water,  f\"[ERROR] DUT o_heat_water does not match model o_heat_water: {dut_heat_water} != {model_heat_water}\"\n    assert dut_pour_coffee == model_pour_coffee, f\"[ERROR] DUT o_pour_coffee does not match model o_pour_coffee: {dut_pour_coffee} != {model_pour_coffee}\"\n    assert dut_error       == model_error,       f\"[ERROR] DUT o_error does not match model o_error: {dut_error} != {model_error}\"\n\n\n\n@cocotb.test()\nasync def test_coffee_machine(dut):\n    \"\"\"Test the Coffee Machine module with edge cases and random data.\"\"\"\n\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    model = hrs_lb.CoffeeMachine()\n\n    # Retrieve parameters from the DUT\n    NBW_DLY   = dut.NBW_DLY.value\n    NBW_BEANS = dut.NBW_BEANS.value\n    NS_BEANS  = dut.NS_BEANS.value\n    \n    model.num_beans = NS_BEANS\n\n    # Range for input values\n    delay_min = 2\n    delay_max = int(2**NBW_DLY - 1)\n\n    beans_min = 1\n    beans_max = int(2**NBW_BEANS - 1)\n\n    resets = 5\n    runs = 5\n\n    await hrs_lb.dut_init(dut)\n\n    for k in range(resets):\n        # Reset the DUT\n        \n        # Set all inputs to zero\n        dut.i_grind_delay.value   = 0\n        dut.i_heat_delay.value    = 0\n        dut.i_pour_delay.value    = 0\n        dut.i_bean_sel.value      = 0\n        dut.i_operation_sel.value = 0\n        dut.i_start.value         = 0\n        dut.i_sensor.value        = 0\n        dut.rst_async_n.value     = 0\n        await RisingEdge(dut.clk)\n\n        model.reset()\n        model.i_sensor = 0\n        model.update_error()\n        \n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n        # Compare reset values\n        compare_values(dut, model)\n\n        await RisingEdge(dut.clk)\n        \n        ## Test errors\n\n        # Generic error\n        dut.i_sensor.value = 8\n        model.i_sensor = 8\n        model.update_error()\n\n        await RisingEdge(dut.clk)\n        compare_values(dut, model)\n\n        # No water error\n        dut.i_sensor.value = 1\n        operation = random.randint(0,5)\n        dut.i_operation_sel.value = operation\n        model.i_sensor = 1\n        model.operation = operation\n        model.update_error()\n\n        await RisingEdge(dut.clk)\n        compare_values(dut, model)\n\n        # No beans error\n        dut.i_sensor.value = 2\n        operation = random.randint(2,3)\n        dut.i_operation_sel.value = operation\n        model.i_sensor = 2\n        model.operation = operation\n        model.update_error()\n\n        await RisingEdge(dut.clk)\n        compare_values(dut, model)\n\n        # No powder error (op = 1)\n        dut.i_sensor.value = 4\n        dut.i_operation_sel.value = 1\n        model.i_sensor = 4\n        model.operation = 1\n        model.update_error()\n\n        await RisingEdge(dut.clk)\n        compare_values(dut, model)\n\n        # No powder error (op = 4)\n        dut.i_sensor.value = 4\n        dut.i_operation_sel.value = 4\n        model.i_sensor = 4\n        model.operation = 4\n        model.update_error()\n\n        await RisingEdge(dut.clk)\n        compare_values(dut, model)\n\n        # Wrong operation error\n        dut.i_sensor.value = 0\n        operation = random.randint(6,7)\n        dut.i_operation_sel.value = operation\n        model.i_sensor = 0\n        model.operation = operation\n        model.update_error()\n\n        await RisingEdge(dut.clk)\n        compare_values(dut, model)\n\n        for i in range(runs):\n            # Generate random delay\n            grind_delay = random.randint(delay_min, delay_max)\n            heat_delay  = random.randint(delay_min, delay_max)\n            pour_delay  = random.randint(delay_min, delay_max)\n            bean_sel    = random.randint(beans_min, beans_max)\n            operation   = random.randint(0,5)\n\n            dut.i_sensor.value        = 0\n            dut.i_grind_delay.value   = grind_delay\n            dut.i_heat_delay.value    = heat_delay\n            dut.i_pour_delay.value    = pour_delay\n            dut.i_bean_sel.value      = bean_sel\n            dut.i_operation_sel.value = operation\n            dut.i_start.value         = 1\n\n            model.i_sensor  = 0\n            model.operation = operation\n            model.update_error()\n\n            await RisingEdge(dut.clk)\n            dut.i_start.value         = 0\n            compare_values(dut, model)\n            await RisingEdge(dut.clk)\n            compare_values(dut, model)\n            while dut.o_pour_coffee.value == 0:\n                await RisingEdge(dut.clk)\n                model.update_state(operation=operation, i_sensor=0, i_grind_delay=grind_delay, i_heat_delay=heat_delay, i_pour_delay=pour_delay, i_bean_sel=bean_sel)\n                compare_values(dut, model)\n            \n            while dut.o_pour_coffee.value == 1:\n                await RisingEdge(dut.clk)\n                model.update_state(operation=operation, i_sensor=0, i_grind_delay=grind_delay, i_heat_delay=heat_delay, i_pour_delay=pour_delay, i_bean_sel=bean_sel)\n                compare_values(dut, model)\n\n        # Create a test to validate that i_sensor[3] stops the opeartion\n        # Generate random delay\n        grind_delay = random.randint(delay_min, delay_max)\n        heat_delay  = random.randint(delay_min, delay_max)\n        pour_delay  = random.randint(delay_min, delay_max)\n        bean_sel    = random.randint(beans_min, beans_max)\n        operation   = random.randint(0,5)\n\n        dut.i_sensor.value        = 0\n        dut.i_grind_delay.value   = grind_delay\n        dut.i_heat_delay.value    = heat_delay\n        dut.i_pour_delay.value    = pour_delay\n        dut.i_bean_sel.value      = bean_sel\n        dut.i_operation_sel.value = operation\n        dut.i_start.value         = 1\n\n        model.i_sensor  = 0\n        model.operation = operation\n        model.update_error()\n\n        await RisingEdge(dut.clk)\n        dut.i_start.value = 0\n        compare_values(dut, model)\n\n        await RisingEdge(dut.clk)\n        compare_values(dut, model)\n        # Set sensor value to 8 -> Generic error\n        dut.i_sensor.value = 8\n        model.update_state(operation=operation, i_sensor=8, i_grind_delay=grind_delay, i_heat_delay=heat_delay, i_pour_delay=pour_delay, i_bean_sel=bean_sel)\n\n        await RisingEdge(dut.clk)\n        # o_error should be 1 here\n        compare_values(dut, model)\n\n        await RisingEdge(dut.clk)\n        # DUT must be back in IDLE\n        model.idle()\n        compare_values(dut, model)\n        \n", "src/test_runner.py": "import os\n\nfrom cocotb.runner import get_runner\n\nimport harness_library as hrs_lb\nimport pytest\nimport random\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(NBW_DLY: int = 5, NBW_BEANS: int = 2, NS_BEANS: int = 4):\n    # Simulation parameters\n    parameter = {\n        \"NBW_DLY\": NBW_DLY,\n        \"NBW_BEANS\": NBW_BEANS,\n        \"NS_BEANS\": NS_BEANS\n    }\n\n    # Debug information\n    print(f\"\\n[DEBUG] Running simulation with NBW_DLY={NBW_DLY}\")\n    print(f\"[DEBUG] Running simulation with NBW_BEANS={NBW_BEANS}\")\n    print(f\"[DEBUG] Running simulation with NS_BEANS={NS_BEANS}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    print(\"Inside Runner\")\n    runner = get_runner(\"xcelium\")\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        build_args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\"),\n        parameters = parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=False,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    print(\"Running\")    \n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n    hrs_lb.coverage_report(\"assertion\")\n    hrs_lb.covt_report_check()\n\n# Generate default and a random size\nrandom_nbw_dly   = [5] + [random.randint(3, 8) for _ in range(1)]\nrandom_nbw_beans = [2] + [random.randint(3, 8) for _ in range(1)]\n\n# Parametrize test for different random data sizes\n@pytest.mark.parametrize(\"NBW_DLY\", random_nbw_dly)\n@pytest.mark.parametrize(\"NBW_BEANS\", random_nbw_beans)\ndef test_data(NBW_DLY, NBW_BEANS):\n    random_ns_beans = 2**NBW_BEANS\n    # Run the simulation with specified parameters\n    runner(NBW_DLY=NBW_DLY, NBW_BEANS=NBW_BEANS, NS_BEANS=random_ns_beans)\n"}}}
{"id": "cvdp_copilot_concatenate_0003", "categories": ["cid012", "easy"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `enhanced_fsm_signal_processor` module by applying exhaustive test scenarios. The module uses a finite state machine (FSM) to manage signal processing operations, handle fault conditions, and report the FSM's current status. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage. The testbench should not create checkers to verify the MUT.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameter Inputs - Outputs and Functional behaviour**\n\n### **Inputs**  \n- `i_clk`: Clock signal for sequential operation.  \n- `i_rst_n`: Active-low reset signal that resets the FSM and clears outputs.  \n- `i_enable`(1 bit): Enable signal to start processing; when low, the FSM remains in IDLE.  \n- `i_clear`(1 bit): Signal to clear outputs and reset the fault state.  \n- `i_ack`(1 bit): Acknowledgment signal to transition the FSM from READY to IDLE after processing is complete. It will be a pulse of 1 clock cycle. \n- `i_fault`(1 bit): Signal indicating a fault condition during operation.  \n- `i_vector_1`: 5-bit input vector.  \n- `i_vector_2`: 5-bit input vector.  \n- `i_vector_3`: 5-bit input vector.  \n- `i_vector_4`: 5-bit input vector.  \n- `i_vector_5`: 5-bit input vector.  \n- `i_vector_6`: 5-bit input vector.  \n\n### **Outputs**  \n- `o_ready`(1 bit): Signal that indicates when outputs are valid and processing is complete. Default 0.\n- `o_error`(1 bit): Signal that asserts when a fault condition is detected. Default 0.\n- `o_fsm_status`(2 bits): Current FSM state, encoded as a 2-bit signal, representing one of the FSM states: IDLE(00), PROCESS(01), READY(10), or FAULT(11). Default is IDLE.\n- `o_vector_1`: 8-bit output vector. Default 0.\n- `o_vector_2`: 8-bit output vector. Default 0.\n- `o_vector_3`: 8-bit output vector. Default 0.\n- `o_vector_4`: 8-bit output vector. Default 0.\n\n---\n\n### **FSM States and Functionality**  \n\n#### **States**  \n1. **IDLE**:  \n   - Default state. \n   - FSM waits for `i_enable` to assert high to transition to PROCESS. \n   - If `i_fault` is detected, FSM transitions to FAULT.  \n\n2. **PROCESS**:  \n   - Concatenates six 5-bit input vectors into a single 30-bit bus, appends two `1` bits at the LSB to form a 32-bit bus, and splits it into four 8-bit output vectors.  \n   - `o_vector_1` to `o_vector_4` maps from MSB to LSB of concatenation bus.\n   - If `i_fault` is detected during this state, FSM transitions to FAULT.  \n\n3. **READY**:  \n   - Indicates processing is complete by asserting `o_ready`.  \n   - FSM waits for `i_ack` to transition back to IDLE.  \n   - If `i_fault` is detected, FSM transitions to FAULT.  \n\n4. **FAULT**:  \n   - Asserts `o_error` to indicate a fault condition.  \n   - Outputs are set to default.\n   - FSM transitions to IDLE only when `i_clear` is asserted and `i_fault` is deasserted.\n\n---\n\n### **Operational Rules**  \n- The FSM must progress through states sequentially, synchronized to `i_clk`.  \n- When `i_rst_n` is low, FSM resets to IDLE, clears outputs, and resets the fault state.  \n- When in FAULT, the `i_clear` signal must clear the fault condition and reset the FSM to IDLE.  \n- Outputs (`o_vector_1`, `o_vector_2`, `o_vector_3`, `o_vector_4`) must strictly adhere to the concatenation and splitting logic specified.  \n- Fault handling (`o_error` and FAULT state) must take precedence over other operations.  \n- All the outputs are synchronous to `i_clk`.\n- `i_fault` always take precedence over any other input except `i_clk` and `i_rst_n`.\n- All the input are synchronous to `i_clk`.\n\n## Stimulus Generation\n\n### **Test Case 1: Reset and Idle Check**\n\n- **Stimulus**  \n  1. `i_rst_n=0` (active-low reset), `i_enable=0`, `i_clear=0`, `i_ack=0`, `i_fault=0`  \n  2. Release reset: `i_rst_n=1`\n\n---\n\n### **Test Case 2: Basic Enable \u2192 Process \u2192 Ready \u2192 Acknowledge \u2192 Idle**\n\n- **Stimulus**  \n  1. From IDLE, set example inputs (five-bit vectors).  \n     - For instance:\n       - `i_vector_1 = 5'b00111`\n       - `i_vector_2 = 5'b01010`\n       - `i_vector_3 = 5'b10101`\n       - `i_vector_4 = 5'b11100`\n       - `i_vector_5 = 5'b00001`\n       - `i_vector_6 = 5'b11000`\n  2. `i_enable=1` \u2192 transitions to PROCESS.  \n  3. After one PROCESS cycle, FSM moves to READY (`o_ready=1`).  \n  4. Pulse `i_ack=1` \u2192 returns FSM to IDLE.\n\n---\n\n### **Test Case 3: Fault in IDLE State**\n\n- **Stimulus**  \n  1. FSM in IDLE (`i_enable=0`, etc.).  \n  2. Assert `i_fault=1`.\n\n- **Sample Input Vectors**  \n  - Can be any values;\n\n---\n\n### **Test Case 4: Fault in PROCESS State**\n\n- **Stimulus**  \n  1. From IDLE, assert `i_enable=1` to enter PROCESS.  \n  2. While in PROCESS, assert `i_fault=1`.\n\n- **Sample Input Vectors**  \n  - Similar to Test Case 2 or any other 5-bit patterns;\n\n\n---\n\n### **Test Case 5: Fault in READY State**\n\n- **Stimulus**  \n  1. Complete a normal PROCESS \u2192 READY cycle.  \n  2. While `o_ready=1`, assert `i_fault=1`.\n  3. Hold the FSM is explicitly in the READY state by not asserting i_ack immediately, then i_fault is pulsed. This ensures that the READY -> FAULT transition is covered.\n\n- **Sample Input Vectors**  \n  - Use any 5-bit patterns leading into READY. Then trigger fault.\n\n\n---\n\n### **Test Case 6: Clear from FAULT State**\n\n- **Stimulus**  \n  1. Enter FAULT (any prior scenario).  \n  2. Assert `i_clear=1` but keep `i_fault=1` \u2192 still in FAULT.  \n  3. Deassert `i_fault=0` (with `i_clear=1`) \u2192 FSM \u2192 IDLE.\n\n- **Sample Input Vectors**  \n  - Irrelevant once in FAULT; \n\n---\n\n### **Test Case 7: Repeated Enable Pulses**\n\n- **Stimulus**  \n  1. Rapidly toggle `i_enable` (1\u21920\u21921\u21920) starting from IDLE.  \n  2. Check FSM behavior in PROCESS or READY; it should ignore extra enables.\n\n- **Sample Input Vectors**  \n  - Use any stable 5-bit inputs;\n---\n\n### **Test Case 8: Repeated Fault Pulses**\n\n- **Stimulus**  \n  1. Cause a FAULT (any state).  \n  2. Rapidly toggle `i_fault` high/low without clearing.\n\n- **Sample Input Vectors**  \n  - Not critical here;\n---\n\n### **Test Case 9: Data Path Validation**\n\n- **Stimulus**  \n  1. Vary each `i_vector_n` (5 bits) across these patterns:\n     - **All-zero**: `5'b00000`\n     - **All-ones**: `5'b11111`\n     - **Mixed**: e.g. `5'b10101`, `5'b01010`\n     - **Boundary**: e.g. `5'b00001`, `5'b10000`\n  2. For each pattern, do IDLE \u2192 PROCESS \u2192 READY cycle.\n", "context": {}}, "output": {"response": "", "context": {"verif/enhanced_fsm_signal_processor_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 3-tb-stimulus\nTARGET = 99", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/enhanced_fsm_signal_processor.v": "// Verilog RTL Design for enhanced_fsm_signal_processor\n\nmodule enhanced_fsm_signal_processor (\n    input wire i_clk,            // Clock signal\n    input wire i_rst_n,          // Active-low reset signal\n    input wire i_enable,         // Enable signal to start processing\n    input wire i_clear,          // Signal to clear fault state and reset outputs\n    input wire i_ack,            // Acknowledge signal to transition from READY to IDLE\n    input wire i_fault,          // Fault condition signal\n    input wire [4:0] i_vector_1, // Input vector 1\n    input wire [4:0] i_vector_2, // Input vector 2\n    input wire [4:0] i_vector_3, // Input vector 3\n    input wire [4:0] i_vector_4, // Input vector 4\n    input wire [4:0] i_vector_5, // Input vector 5\n    input wire [4:0] i_vector_6, // Input vector 6\n\n    output reg o_ready,          // Indicates when processing is complete\n    output reg o_error,          // Indicates fault condition\n    output reg [1:0] o_fsm_status, // Current FSM state\n    output reg [7:0] o_vector_1, // Processed output vector 1\n    output reg [7:0] o_vector_2, // Processed output vector 2\n    output reg [7:0] o_vector_3, // Processed output vector 3\n    output reg [7:0] o_vector_4  // Processed output vector 4\n);\n\n// FSM state definitions\nlocalparam IDLE   = 2'b00;\nlocalparam PROCESS = 2'b01;\nlocalparam READY   = 2'b10;\nlocalparam FAULT   = 2'b11;\n\n// Internal registers\nreg [1:0] current_state, next_state;\nreg [31:0] concatenated_vector;\n\n// Synchronous state transition and reset handling\nalways @(posedge i_clk or negedge i_rst_n) begin\n    if (!i_rst_n) begin\n        current_state <= IDLE;   // Reset state to IDLE\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        IDLE: begin\n            if (i_fault) begin\n                next_state = FAULT;\n            end \n            else begin\n                if (i_enable) begin\n                next_state = PROCESS;\n                end\n                else next_state = current_state;\n            end\n        end\n        PROCESS: begin\n            if (i_fault) begin\n                next_state = FAULT;\n            end else begin\n                next_state = READY;\n            end\n        end\n        READY: begin\n            if (i_fault) begin\n                next_state = FAULT;\n            end \n            else begin\n                if (i_ack) begin\n                    next_state = IDLE;\n                end\n                else next_state = current_state;\n            end\n        end\n        FAULT: begin\n            if (i_clear && !i_fault) begin\n                next_state = IDLE;\n            end\n            else next_state = current_state;\n        end\n    endcase\nend\n\n// Output logic and processing\nalways @(posedge i_clk or negedge i_rst_n) begin\n    if (!i_rst_n) begin\n        o_ready <= 0;\n        o_error <= 0;\n        o_fsm_status <= IDLE;\n        o_vector_1 <= 0;\n        o_vector_2 <= 0;\n        o_vector_3 <= 0;\n        o_vector_4 <= 0;\n        concatenated_vector <= 0;\n    end else begin\n        o_fsm_status <= current_state;  // Update FSM status\n        case (current_state)\n            IDLE: begin\n                o_ready <= 0;\n                o_error <= 0;\n                o_vector_1 <= 0;\n                o_vector_2 <= 0;\n                o_vector_3 <= 0;\n                o_vector_4 <= 0;\n            end\n            PROCESS: begin\n                concatenated_vector <= {i_vector_1, i_vector_2, i_vector_3, i_vector_4, i_vector_5, i_vector_6, 2'b11};\n                end\n            READY: begin\n                o_vector_1 <= concatenated_vector[31:24]; // MSB\n                o_vector_2 <= concatenated_vector[23:16];\n                o_vector_3 <= concatenated_vector[15:8];\n                o_vector_4 <= concatenated_vector[7:0];  // LSB\n                o_ready <= 1;\n            end\n            FAULT: begin\n                o_error <= 1;\n                o_ready <= 0;\n                o_vector_1 <= 0;\n                o_vector_2 <= 0;\n                o_vector_3 <= 0;\n                o_vector_4 <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/enhanced_fsm_signal_processor.v /code/verif/enhanced_fsm_signal_processor_tb.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_concatenate_0004", "categories": ["cid013", "easy"], "input": {"prompt": "Create a **SystemVerilog testbench checker** with detailed stimulus to test and validate the `enhanced_fsm_signal_processor` module by applying exhaustive test scenarios. The module uses a finite state machine (FSM) to manage signal processing operations, handle fault conditions, and report the FSM's current status. The testbench should ensure:\n\n- Comprehensive **input stimulus** generation covering all possible cases.\n- **Checker generation** of the FSM output.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameter Inputs - Outputs and Functional behaviour**\n\n### **Inputs**  \n- `i_clk`: Clock signal for sequential operation.  \n- `i_rst_n`: Active-low reset signal that resets the FSM and clears outputs.  \n- `i_enable`(1 bit): Enable signal to start processing; when low, the FSM remains in IDLE.  \n- `i_clear`(1 bit): Signal to clear outputs and reset the fault state.  \n- `i_ack`(1 bit): Acknowledgment signal to transition the FSM from READY to IDLE after processing is complete. It will be a pulse of 1 clock cycle. \n- `i_fault`(1 bit): Signal indicating a fault condition during operation.  \n- `i_vector_1`: 5-bit input vector.  \n- `i_vector_2`: 5-bit input vector.  \n- `i_vector_3`: 5-bit input vector.  \n- `i_vector_4`: 5-bit input vector.  \n- `i_vector_5`: 5-bit input vector.  \n- `i_vector_6`: 5-bit input vector.  \n\n### **Outputs**  \n- `o_ready`(1 bit): Signal that indicates when outputs are valid and processing is complete. Default 0.\n- `o_error`(1 bit): Signal that asserts when a fault condition is detected. Default 0.\n- `o_fsm_status`(2 bits): Current FSM state, encoded as a 2-bit signal, representing one of the FSM states: IDLE(00), PROCESS(01), READY(10), or FAULT(11). Default is IDLE.\n- `o_vector_1`: 8-bit output vector. Default 0.\n- `o_vector_2`: 8-bit output vector. Default 0.\n- `o_vector_3`: 8-bit output vector. Default 0.\n- `o_vector_4`: 8-bit output vector. Default 0.\n\n---\n\n### **FSM States and Functionality**  \n\n#### **States**  \n1. **IDLE**:  \n   - Default state. \n   - FSM waits for `i_enable` to assert high to transition to PROCESS. \n   - If `i_fault` is detected, FSM transitions to FAULT.  \n\n2. **PROCESS**:  \n   - Concatenates six 5-bit input vectors into a single 30-bit bus, appends two `1` bits at the LSB to form a 32-bit bus, and splits it into four 8-bit output vectors.  \n   - `o_vector_1` to `o_vector_4` maps from MSB to LSB of concatenation bus.\n   - If `i_fault` is detected during this state, FSM transitions to FAULT.  \n\n3. **READY**:  \n   - Indicates processing is complete by asserting `o_ready`.  \n   - FSM waits for `i_ack` to transition back to IDLE.  \n   - If `i_fault` is detected, FSM transitions to FAULT.  \n\n4. **FAULT**:  \n   - Asserts `o_error` to indicate a fault condition.  \n   - Outputs are set to default.\n   - FSM transitions to IDLE only when `i_clear` is asserted and `i_fault` is deasserted.\n\n---\n\n### **Operational Rules**  \n- The FSM must progress through states sequentially, synchronized to `i_clk`.  \n- When `i_rst_n` is low, FSM resets to IDLE, clears outputs, and resets the fault state.  \n- When in FAULT, the `i_clear` signal must clear the fault condition and reset the FSM to IDLE.  \n- Outputs (`o_vector_1`, `o_vector_2`, `o_vector_3`, `o_vector_4`) must strictly adhere to the concatenation and splitting logic specified.  \n- Fault handling (`o_error` and FAULT state) must take precedence over other operations.  \n- All the outputs are synchronous to `i_clk`.\n- `i_fault` always take precedence over any other input except `i_clk` and `i_rst_n`.\n- All the input are synchronous to `i_clk`.\n\n## Stimulus and Checker Generation\n\n### **Test Case 1: Reset and Idle Check**\n\n- **Stimulus**  \n  1. `i_rst_n=0` (active-low reset), `i_enable=0`, `i_clear=0`, `i_ack=0`, `i_fault=0`  \n  2. Release reset: `i_rst_n=1`\n\n- **Sample Input Vectors**  \n  - In this scenario, `i_vector_1..6` can be any values (e.g., all zeros: `5'b00000`). They do not affect the output under reset.\n\n- **Expected Output**  \n  - During reset: `o_ready=0`, `o_error=0`, `o_vector_1=0x00`, `o_vector_2=0x00`, `o_vector_3=0x00`, `o_vector_4=0x00`  \n  - After reset (IDLE): same as above (all zeros, no ready/error)\n\n---\n\n### **Test Case 2: Basic Enable \u2192 Process \u2192 Ready \u2192 Acknowledge \u2192 Idle**\n\n- **Stimulus**  \n  1. From IDLE, set example inputs (five-bit vectors).  \n     - For instance:\n       - `i_vector_1 = 5'b00111`\n       - `i_vector_2 = 5'b01010`\n       - `i_vector_3 = 5'b10101`\n       - `i_vector_4 = 5'b11100`\n       - `i_vector_5 = 5'b00001`\n       - `i_vector_6 = 5'b11000`\n  2. `i_enable=1` \u2192 transitions to PROCESS.  \n  3. After one PROCESS cycle, FSM moves to READY (`o_ready=1`).  \n  4. Pulse `i_ack=1` \u2192 returns FSM to IDLE.\n\n- **Expected Output**  \n  - **IDLE**: `o_vector_1=0x00`, `o_vector_2=0x00`, `o_vector_3=0x00`, `o_vector_4=0x00`, `o_ready=0`, `o_error=0`.  \n  - **READY**: `o_ready=1`, output vectors match concatenation logic.  \n  - **After `i_ack`**: back to IDLE, outputs cleared.\n\n---\n\n### **Test Case 3: Fault in IDLE State**\n\n- **Stimulus**  \n  1. FSM in IDLE (`i_enable=0`, etc.).  \n  2. Assert `i_fault=1`.\n\n- **Sample Input Vectors**  \n  - Can be any values; main check is fault response in IDLE.\n\n- **Expected Output**  \n  - FSM \u2192 FAULT immediately.  \n  - `o_error=1`, `o_ready=0`, `o_vector_1=0x00`, `o_vector_2=0x00`, `o_vector_3=0x00`, `o_vector_4=0x00`.\n\n---\n\n### **Test Case 4: Fault in PROCESS State**\n\n- **Stimulus**  \n  1. From IDLE, assert `i_enable=1` to enter PROCESS.  \n  2. While in PROCESS, assert `i_fault=1`.\n\n- **Sample Input Vectors**  \n  - Similar to Test Case 2 or any other 5-bit patterns; focus is fault detection mid-process.\n\n- **Expected Output**  \n  - FSM \u2192 FAULT, `o_error=1`, `o_ready=0`, `o_vector_1=0x00`, `o_vector_2=0x00`, `o_vector_3=0x00`, `o_vector_4=0x00`\n\n---\n\n### **Test Case 5: Fault in READY State**\n\n- **Stimulus**  \n  1. Complete a normal PROCESS \u2192 READY cycle.  \n  2. While `o_ready=1`, assert `i_fault=1`.\n\n- **Sample Input Vectors**  \n  - Use any 5-bit patterns leading into READY. Then trigger fault.\n\n- **Expected Output**  \n  - FSM \u2192 FAULT, `o_error=1`, `o_ready=0`, `o_vector_1=0x00`, `o_vector_2=0x00`, `o_vector_3=0x00`, `o_vector_4=0x00`\n\n---\n\n### **Test Case 6: Clear from FAULT State**\n\n- **Stimulus**  \n  1. Enter FAULT (any prior scenario).  \n  2. Assert `i_clear=1` but keep `i_fault=1` \u2192 still in FAULT.  \n  3. Deassert `i_fault=0` (with `i_clear=1`) \u2192 FSM \u2192 IDLE.\n\n- **Sample Input Vectors**  \n  - Irrelevant once in FAULT; main check is clearing fault.\n\n- **Expected Output**  \n  - In FAULT: `o_error=1`, `o_vector_1=0x00`, `o_vector_2=0x00`, `o_vector_3=0x00`, `o_vector_4=0x00`  \n  - Return to IDLE once `i_fault=0` and `i_clear=1` \u2192 `o_error=0`, outputs cleared.\n\n---\n\n### **Test Case 7: Repeated Enable Pulses**\n\n- **Stimulus**  \n  1. Rapidly toggle `i_enable` (1\u21920\u21921\u21920) starting from IDLE.  \n  2. Check FSM behavior in PROCESS or READY; it should ignore extra enables.\n\n- **Sample Input Vectors**  \n  - Use any stable 5-bit inputs; the main check is repeated enables.\n\n- **Expected Output**  \n  - Only the **first** enable pulse from IDLE triggers PROCESS.  \n  - Outputs in READY as expected, then cleared upon `i_ack`.\n\n---\n\n### **Test Case 8: Repeated Fault Pulses**\n\n- **Stimulus**  \n  1. Cause a FAULT (any state).  \n  2. Rapidly toggle `i_fault` high/low without clearing.\n\n- **Sample Input Vectors**  \n  - Not critical here; main check is fault toggling.\n\n- **Expected Output**  \n  - Stays in FAULT until `i_fault=0` **and** `i_clear=1`.  \n  - Then FSM \u2192 IDLE, `o_error=0`, `o_vector_1=0x00`, `o_vector_2=0x00`, `o_vector_3=0x00`, `o_vector_4=0x00`\n\n---\n\n### **Test Case 9: Data Path Validation**\n\n- **Stimulus**  \n  1. Vary each `i_vector_n` (5 bits) across these patterns:\n     - **All-zero**: `5'b00000`\n     - **All-ones**: `5'b11111`\n     - **Mixed**: e.g. `5'b10101`, `5'b01010`\n     - **Boundary**: e.g. `5'b00001`, `5'b10000`\n  2. For each pattern, do IDLE \u2192 PROCESS \u2192 READY cycle.\n\n- **Expected Output**  \n  - `o_ready=1` in READY, `o_vector_1`, `o_vector_2`, `o_vector_3`, `o_vector_4` match the 8-bit segments of `{i_vector_1..6, 2'b11}`.  \n  - No fault: `o_error=0`; on `i_ack`, return to IDLE (outputs cleared).\n\n## Simulation\n- Reset the dut and initialize inputs.\n- Apply the test cases sequentially.\n- Log errors if any discrepancies are found between dut outputs and the model using `$error`.\n\n## Deliverables\nProvide the complete SystemVerilog testbench code with:\n1. dut instantiation.\n2. Implement a behavioral model to replicate the expected functionality.\n3. Test scenarios validating the dut against the expected behavior.\n4. Compare the outputs from the DUT with the model using checkers\n5. Log messages indicating pass/fail status for each test case.\n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_enhanced_fsm_signal_processor.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/enhanced_fsm_signal_processor.v\nHASH            = 5-tb-checker\nNUM_BUGS        = 5", "src/enhanced_fsm_signal_processor.v": "// Verilog RTL Design for enhanced_fsm_signal_processor\n\nmodule enhanced_fsm_signal_processor (\n    input wire i_clk,            // Clock signal\n    input wire i_rst_n,          // Active-low reset signal\n    input wire i_enable,         // Enable signal to start processing\n    input wire i_clear,          // Signal to clear fault state and reset outputs\n    input wire i_ack,            // Acknowledge signal to transition from READY to IDLE\n    input wire i_fault,          // Fault condition signal\n    input wire [4:0] i_vector_1, // Input vector 1\n    input wire [4:0] i_vector_2, // Input vector 2\n    input wire [4:0] i_vector_3, // Input vector 3\n    input wire [4:0] i_vector_4, // Input vector 4\n    input wire [4:0] i_vector_5, // Input vector 5\n    input wire [4:0] i_vector_6, // Input vector 6\n\n    output reg o_ready,          // Indicates when processing is complete\n    output reg o_error,          // Indicates fault condition\n    output reg [1:0] o_fsm_status, // Current FSM state\n    output reg [7:0] o_vector_1, // Processed output vector 1\n    output reg [7:0] o_vector_2, // Processed output vector 2\n    output reg [7:0] o_vector_3, // Processed output vector 3\n    output reg [7:0] o_vector_4  // Processed output vector 4\n);\n\n// FSM state definitions\nlocalparam IDLE   = 2'b00;\nlocalparam PROCESS = 2'b01;\nlocalparam READY   = 2'b10;\nlocalparam FAULT   = 2'b11;\n\n// Internal registers\nreg [1:0] current_state, next_state;\nreg [31:0] concatenated_vector;\n\n// Synchronous state transition and reset handling\nalways @(posedge i_clk or negedge i_rst_n) begin\n    if (!i_rst_n) begin\n        current_state <= IDLE;   // Reset state to IDLE\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        IDLE: begin\n            if (i_fault) begin\n                next_state = FAULT;\n            end \n            else begin\n                if (i_enable) begin\n                next_state = PROCESS;\n                end\n                else next_state = current_state;\n            end\n        end\n        PROCESS: begin\n            if (i_fault) begin\n                next_state = FAULT;\n            end else begin\n                next_state = READY;\n            end\n        end\n        READY: begin\n            if (i_fault) begin\n                next_state = FAULT;\n            end \n            else begin\n                if (i_ack) begin\n                    next_state = IDLE;\n                end\n                else next_state = current_state;\n            end\n        end\n        FAULT: begin\n            if (i_clear && !i_fault) begin\n                next_state = IDLE;\n            end\n            else next_state = current_state;\n        end\n    endcase\nend\n\n// Output logic and processing\nalways @(posedge i_clk or negedge i_rst_n) begin\n    if (!i_rst_n) begin\n        `ifdef BUG_0\n            o_ready <= 1;\n            o_error <= 1;\n            o_fsm_status <= PROCESS;\n            o_vector_1 <= 1;\n            o_vector_2 <= 1;\n            o_vector_3 <= 1;\n            o_vector_4 <= 1;\n            concatenated_vector <= 1;\n        `else\n            o_ready <= 0;\n            o_error <= 0;\n            o_fsm_status <= IDLE;\n            o_vector_1 <= 0;\n            o_vector_2 <= 0;\n            o_vector_3 <= 0;\n            o_vector_4 <= 0;\n            concatenated_vector <= 0;\n        `endif\n    end else begin\n        o_fsm_status <= current_state;  // Update FSM status\n        case (current_state)\n            IDLE: begin\n                `ifdef BUG_1\n                    o_ready <= 1;\n                    o_error <= 1;\n                    o_vector_1 <= 1;\n                    o_vector_2 <= 1;\n                    o_vector_3 <= 1;\n                    o_vector_4 <= 1;\n                `else\n                    o_ready <= 0;\n                    o_error <= 0;\n                    o_vector_1 <= 0;\n                    o_vector_2 <= 0;\n                    o_vector_3 <= 0;\n                    o_vector_4 <= 0;\n                `endif\n\n            end\n            PROCESS: begin\n                `ifdef BUG_2\n                    concatenated_vector <= {i_vector_1, i_vector_2, i_vector_3, i_vector_4, i_vector_5, i_vector_6, 2'b00};\n\n                `else\n                    concatenated_vector <= {i_vector_1, i_vector_2, i_vector_3, i_vector_4, i_vector_5, i_vector_6, 2'b11};\n                `endif\n    \n            end\n            READY: begin\n                `ifdef BUG_3\n                    o_vector_1 <= concatenated_vector[7:0]; // MSB\n                    o_vector_2 <= concatenated_vector[15:8];\n                    o_vector_3 <= concatenated_vector[23:16];\n                    o_vector_4 <= concatenated_vector[31:24];  // LSB\n                    o_ready <= 0;\n                `else\n                    o_vector_1 <= concatenated_vector[31:24]; // MSB\n                    o_vector_2 <= concatenated_vector[23:16];\n                    o_vector_3 <= concatenated_vector[15:8];\n                    o_vector_4 <= concatenated_vector[7:0];  // LSB\n                    o_ready <= 1;\n                `endif\n\n            end\n            FAULT: begin\n                `ifdef BUG_4\n                    o_error <= 1;\n                    o_vector_1 <= concatenated_vector[31:24]; // MSB\n                    o_vector_2 <= concatenated_vector[23:16];\n                    o_vector_3 <= concatenated_vector[15:8];\n                    o_vector_4 <= concatenated_vector[7:0];  // LSB\n                    o_ready <= 1;\n                `else\n                    o_error <= 1;\n                    o_ready <= 0;\n                    o_vector_1 <= 0;\n                    o_vector_2 <= 0;\n                    o_vector_3 <= 0;\n                    o_vector_4 <= 0;\n                `endif\n\n            end\n        endcase\n    end\nend\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.v /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\""}}}
{"id": "cvdp_copilot_cont_adder_0040", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the `continuous_adder` RTL to ensure signals remain valid during simulation? Specifically, the assertions should check:\n\n1. **That `sum_out` and `sum_accum` remain within 8-bit bounds**, and  \n2. **That `sum_ready` is always either 0 or 1**, reflecting a proper single-bit signal.\n\nWhenever one of these conditions is violated, the assertion should print an error message with the current simulation time and the offending signal values.\n\n---\n\n## **Key Assertions**\n\n### **1. 8-bit Range Checks**\n- **Condition**:  \n  - `sum_out` must stay below 256 (since it is an 8-bit output).  \n  - `sum_accum` must stay below 256 (since it is an 8-bit internal accumulator).\n- **Assertion**:  \n  - If `sum_out` or `sum_accum` exceed `255`, display an error message with the offending signal value.\n\n### **2. Valid `sum_ready` Signal**\n- **Condition**:  \n  - `sum_ready` should always be exactly 0 or 1. \n- **Assertion**:  \n  - Check that `(sum_ready === 1'b0) || (sum_ready === 1'b1)`. If not, display an error.\n\n---\n\n## **Interface**\n\n### **Inputs**\n1. `clk` : Clock signal (1-bit).  \n2. `reset` : Synchronous reset (active high, 1-bit).  \n3. `data_in [7:0]` : 8-bit input to be added into the accumulator.  \n4. `data_valid` : Indicates when `data_in` should be accumulated.\n\n### **Outputs**\n1. `sum_out [7:0]` : 8-bit total when crossing the threshold of 100.  \n2. `sum_ready` : Signals that `sum_out` is valid and `sum_accum` has reset.\n\n---\n\n\nIf the assertion fails, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/cont_adder.sv": "`timescale 1ns/1ps\n\nmodule continuous_adder (\n    input logic         clk,         // Clock signal\n    input logic         reset,       // Reset signal, Active high and Synchronous\n    input logic [7:0]   data_in,     // Input data stream (8-bit)\n    input logic         data_valid,  // Input data valid signal\n    output logic [7:0]  sum_out,     // Output the accumulated sum\n    output logic        sum_ready    // Signal to indicate sum is output and accumulator is reset\n);\n\n    logic [7:0] sum_accum;\n\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            sum_accum         <= 8'd0;\n            sum_ready         <= 1'b0;\n            sum_out           <= 8'h0;\n        end\n        else begin\n            if (data_valid) begin\n                sum_accum     <= sum_accum + data_in;\n\n                if (sum_accum + data_in >= 8'd100) begin\n                    sum_out   <= sum_accum + data_in;\n                    sum_ready <= 1'b1;\n                    sum_accum <= 8'd0;\n                end\n                else begin\n                    sum_ready <= 1'b0;\n                end\n            end\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/cont_adder.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cont_adder.sv\nTOPLEVEL        = continuous_adder\nMODULE          = test_cont_adder\nPYTHONPATH      = /src\nHASH            = 40-cont-adder-assertion\n", "src/test_cont_adder.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\nasync def reset_dut(dut, cycles=2):\n    dut.reset.value = 1\n    dut.data_in.value = 0\n    dut.data_valid.value = 0\n    for _ in range(cycles):\n        await RisingEdge(dut.clk)\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\nasync def apply_input(dut, data_val, valid_val=1, wait_cycles=1):\n    dut.data_in.value = data_val\n    dut.data_valid.value = valid_val\n    for _ in range(wait_cycles):\n        await RisingEdge(dut.clk)\n    dut.data_valid.value = 0\n    cocotb.log.info(\n        f\"[{cocotb.utils.get_sim_time('ns')} ns] data_in={data_val}, data_valid={valid_val}, \"\n        f\"sum_out={int(dut.sum_out.value)}, sum_ready={int(dut.sum_ready.value)}, sum_accum={int(dut.sum_accum.value)}\"\n    )\n\n@cocotb.test()\nasync def direct_test(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await reset_dut(dut)\n    cocotb.log.info(\"Starting DIRECT test\")\n    await apply_input(dut, 50)\n    await apply_input(dut, 10)\n    await apply_input(dut, 40)\n    await apply_input(dut, 5)\n    # Wait a bit to see final results\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n@cocotb.test()\nasync def boundary_test(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await reset_dut(dut)\n    cocotb.log.info(\"Starting BOUNDARY test\")\n    await apply_input(dut, 99)\n    await apply_input(dut, 1)\n    await apply_input(dut, 100)\n    await apply_input(dut, 0)\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n@cocotb.test()\nasync def random_test(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await reset_dut(dut)\n    cocotb.log.info(\"Starting RANDOM test\")\n    for i in range(10):\n        val = random.randint(0, 255)\n        # Toggle data_valid every iteration or randomly\n        valid = 1 if (i % 2 == 0) else 0\n        await apply_input(dut, val, valid)\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}}
{"id": "cvdp_copilot_crypto_0013", "categories": ["cid014", "easy"], "input": {"prompt": "Elaborate assertion properties to ensure that the `CTRL_IDLE` state of the `sha1_core` module's FSM is safe. The properties should verify the following conditions:\n\n1. The design **must** enter the `CTRL_IDLE` state immediately after an asynchronous reset.  \n2. The `CTRL_IDLE` state **must** indicate that the design is ready to process new data.  \n3. The design **must** return to the `CTRL_IDLE` state after completing a computation.  \n\nIt is necessary to address the requirements described below.\n\n- The properties should be placed in a separate module named `sha1_core_rounds_safety_check` that instantiates `sha1_core` as a DUT (Device Under Test).  \n- The properties should directly reference internal DUT signals to perform verification.  \n\n## **Design Specifications**  \n\n### **Module Name:** `sha1_core`  \n\n### **Inputs:**  \n- **clk**: System clock (rising edge).  \n- **reset_n**: Active-low asynchronous reset.  \n- **init**: Signal to start hashing with a new block.  \n- **next**: Signal to continue hashing with a new block after initialization.  \n- **block** (`[511:0]`): 512-bit input data block.  \n\n### **Outputs:**  \n- **ready**: Indicates when the core is ready to process a new block.  \n- **digest** (`[159:0]`): The 160-bit computed hash value.  \n- **digest_valid**: Indicates that the digest output is valid.  \n\n### **Functional Overview:**  \n- When **init** is asserted, the core initializes the hash state using SHA-1 constants and begins processing the input block.  \n- When **next** is asserted, the core continues processing with the new block.  \n- The FSM transitions through:  \n  - **CTRL_IDLE**: Waiting for `init` or `next`.  \n  - **CTRL_ROUNDS**: Processing 80 rounds of SHA-1.  \n  - **CTRL_DONE**: Finalizing the hash and updating the digest.  \n- When processing is complete, **digest_valid** is asserted, and **ready** becomes high.  \n- The core uses a **W memory scheduler** (`sha1_w_mem` module) to expand the input block into 80 words dynamically.  \n\nInternally, the FSM state transitions are controlled by the `sha1_ctrl_reg` register, which holds the current state, and `sha1_ctrl_new`, which represents the next state. The `sha1_ctrl_we` signal determines when the state register updates. These registers ensure that the core progresses through the expected SHA-1 processing stages and returns to `CTRL_IDLE` upon completion.  \n\nThere is a threshold (`SHA1_ROUNDS`) for the number of cycles in the `CTRL_ROUNDS` state, and an internal counter named `round_ctr_reg` is used to control the rounds, limited to the threshold.\n\n### **Note:**  \n- An **assertion failure** must include a **descriptive error message** to aid debugging", "context": {"rtl/sha1_core.v": "//======================================================================\n//\n// sha1_core.v\n// -----------\n// Verilog 2001 implementation of the SHA-1 hash function.\n// This is the internal core with wide interfaces.\n//\n//\n// Copyright (c) 2013 Secworks Sweden AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\n`default_nettype none\n\nmodule sha1_core(\n                 input wire            clk,\n                 input wire            reset_n,\n\n                 input wire            init,\n                 input wire            next,\n\n                 input wire [511 : 0]  block,\n\n                 output wire           ready,\n\n                 output wire [159 : 0] digest,\n                 output wire           digest_valid\n                );\n\n\n  //----------------------------------------------------------------\n  // Internal constant and parameter definitions.\n  //----------------------------------------------------------------\n  parameter H0_0 = 32'h67452301;\n  parameter H0_1 = 32'hefcdab89;\n  parameter H0_2 = 32'h98badcfe;\n  parameter H0_3 = 32'h10325476;\n  parameter H0_4 = 32'hc3d2e1f0;\n\n  parameter SHA1_ROUNDS = 79;\n\n  parameter CTRL_IDLE   = 0;\n  parameter CTRL_ROUNDS = 1;\n  parameter CTRL_DONE   = 2;\n\n\n  //----------------------------------------------------------------\n  // Registers including update variables and write enable.\n  //----------------------------------------------------------------\n  reg [31 : 0] a_reg;\n  reg [31 : 0] a_new;\n  reg [31 : 0] b_reg;\n  reg [31 : 0] b_new;\n  reg [31 : 0] c_reg;\n  reg [31 : 0] c_new;\n  reg [31 : 0] d_reg;\n  reg [31 : 0] d_new;\n  reg [31 : 0] e_reg;\n  reg [31 : 0] e_new;\n  reg          a_e_we;\n\n  reg [31 : 0] H0_reg;\n  reg [31 : 0] H0_new;\n  reg [31 : 0] H1_reg;\n  reg [31 : 0] H1_new;\n  reg [31 : 0] H2_reg;\n  reg [31 : 0] H2_new;\n  reg [31 : 0] H3_reg;\n  reg [31 : 0] H3_new;\n  reg [31 : 0] H4_reg;\n  reg [31 : 0] H4_new;\n  reg          H_we;\n\n  reg [6 : 0] round_ctr_reg;\n  reg [6 : 0] round_ctr_new;\n  reg         round_ctr_we;\n  reg         round_ctr_inc;\n  reg         round_ctr_rst;\n\n  reg digest_valid_reg;\n  reg digest_valid_new;\n  reg digest_valid_we;\n\n  reg [1 : 0] sha1_ctrl_reg;\n  reg [1 : 0] sha1_ctrl_new;\n  reg         sha1_ctrl_we;\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg           digest_init;\n  reg           digest_update;\n  reg           state_init;\n  reg           state_update;\n  reg           first_block;\n  reg           ready_flag;\n  reg           w_init;\n  reg           w_next;\n  wire [31 : 0] w;\n\n\n  //----------------------------------------------------------------\n  // Module instantiantions.\n  //----------------------------------------------------------------\n  sha1_w_mem w_mem_inst(\n                        .clk(clk),\n                        .reset_n(reset_n),\n\n                        .block(block),\n\n                        .init(w_init),\n                        .next(w_next),\n\n                        .w(w)\n                       );\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign ready        = ready_flag;\n  assign digest       = {H0_reg, H1_reg, H2_reg, H3_reg, H4_reg};\n  assign digest_valid = digest_valid_reg;\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  // Update functionality for all registers in the core.\n  // All registers are positive edge triggered with\n  // asynchronous active low reset.\n  //----------------------------------------------------------------\n  always @ (posedge clk or negedge reset_n)\n    begin : reg_update\n      if (!reset_n)\n        begin\n          a_reg            <= 32'h0;\n          b_reg            <= 32'h0;\n          c_reg            <= 32'h0;\n          d_reg            <= 32'h0;\n          e_reg            <= 32'h0;\n          H0_reg           <= 32'h0;\n          H1_reg           <= 32'h0;\n          H2_reg           <= 32'h0;\n          H3_reg           <= 32'h0;\n          H4_reg           <= 32'h0;\n          digest_valid_reg <= 1'h0;\n          round_ctr_reg    <= 7'h0;\n          sha1_ctrl_reg    <= CTRL_IDLE;\n        end\n      else\n        begin\n          if (a_e_we)\n            begin\n              a_reg <= a_new;\n              b_reg <= b_new;\n              c_reg <= c_new;\n              d_reg <= d_new;\n              e_reg <= e_new;\n            end\n\n          if (H_we)\n            begin\n              H0_reg <= H0_new;\n              H1_reg <= H1_new;\n              H2_reg <= H2_new;\n              H3_reg <= H3_new;\n              H4_reg <= H4_new;\n            end\n\n          if (round_ctr_we)\n            round_ctr_reg <= round_ctr_new;\n\n          if (digest_valid_we)\n            digest_valid_reg <= digest_valid_new;\n\n          if (sha1_ctrl_we)\n            sha1_ctrl_reg <= sha1_ctrl_new;\n        end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // digest_logic\n  //\n  // The logic needed to init as well as update the digest.\n  //----------------------------------------------------------------\n  always @*\n    begin : digest_logic\n      H0_new = 32'h0;\n      H1_new = 32'h0;\n      H2_new = 32'h0;\n      H3_new = 32'h0;\n      H4_new = 32'h0;\n      H_we = 0;\n\n      if (digest_init)\n        begin\n          H0_new = H0_0;\n          H1_new = H0_1;\n          H2_new = H0_2;\n          H3_new = H0_3;\n          H4_new = H0_4;\n          H_we = 1;\n        end\n\n      if (digest_update)\n        begin\n          H0_new = H0_reg + a_reg;\n          H1_new = H1_reg + b_reg;\n          H2_new = H2_reg + c_reg;\n          H3_new = H3_reg + d_reg;\n          H4_new = H4_reg + e_reg;\n          H_we = 1;\n        end\n    end // digest_logic\n\n\n  //----------------------------------------------------------------\n  // state_logic\n  //\n  // The logic needed to init as well as update the state during\n  // round processing.\n  //----------------------------------------------------------------\n  always @*\n    begin : state_logic\n      reg [31 : 0] a5;\n      reg [31 : 0] f;\n      reg [31 : 0] k;\n      reg [31 : 0] t;\n\n      a5     = 32'h0;\n      f      = 32'h0;\n      k      = 32'h0;\n      t      = 32'h0;\n      a_new  = 32'h0;\n      b_new  = 32'h0;\n      c_new  = 32'h0;\n      d_new  = 32'h0;\n      e_new  = 32'h0;\n      a_e_we = 1'h0;\n\n      if (state_init)\n        begin\n          if (first_block)\n            begin\n              a_new  = H0_0;\n              b_new  = H0_1;\n              c_new  = H0_2;\n              d_new  = H0_3;\n              e_new  = H0_4;\n              a_e_we = 1;\n            end\n          else\n            begin\n              a_new  = H0_reg;\n              b_new  = H1_reg;\n              c_new  = H2_reg;\n              d_new  = H3_reg;\n              e_new  = H4_reg;\n              a_e_we = 1;\n            end\n        end\n\n      if (state_update)\n        begin\n          if (round_ctr_reg <= 19)\n            begin\n              k = 32'h5a827999;\n              f =  ((b_reg & c_reg) ^ (~b_reg & d_reg));\n            end\n          else if ((round_ctr_reg >= 20) && (round_ctr_reg <= 39))\n            begin\n              k = 32'h6ed9eba1;\n              f = b_reg ^ c_reg ^ d_reg;\n            end\n          else if ((round_ctr_reg >= 40) && (round_ctr_reg <= 59))\n            begin\n              k = 32'h8f1bbcdc;\n              f = ((b_reg | c_reg) ^ (b_reg | d_reg) ^ (c_reg | d_reg));\n            end\n          else if (round_ctr_reg >= 60)\n            begin\n              k = 32'hca62c1d6;\n              f = b_reg ^ c_reg ^ d_reg;\n            end\n\n          a5 = {a_reg[26 : 0], a_reg[31 : 27]};\n          t = a5 + e_reg + f + k + w;\n\n          a_new  = t;\n          b_new  = a_reg;\n          c_new  = {b_reg[1 : 0], b_reg[31 : 2]};\n          d_new  = c_reg;\n          e_new  = d_reg;\n          a_e_we = 1;\n        end\n    end // state_logic\n\n\n  //----------------------------------------------------------------\n  // round_ctr\n  //\n  // Update logic for the round counter, a monotonically\n  // increasing counter with reset.\n  //----------------------------------------------------------------\n  always @*\n    begin : round_ctr\n      round_ctr_new = 7'h0;\n      round_ctr_we  = 1'h0;\n\n      if (round_ctr_rst)\n        begin\n          round_ctr_new = 7'h0;\n          round_ctr_we  = 1'h1;\n        end\n\n      if (round_ctr_inc)\n        begin\n          round_ctr_new = round_ctr_reg + 1'h1;\n          round_ctr_we  = 1;\n        end\n    end // round_ctr\n\n\n  //----------------------------------------------------------------\n  // sha1_ctrl_fsm\n  // Logic for the state machine controlling the core behaviour.\n  //----------------------------------------------------------------\n  always @*\n    begin : sha1_ctrl_fsm\n      digest_init      = 1'h0;\n      digest_update    = 1'h0;\n      state_init       = 1'h0;\n      state_update     = 1'h0;\n      first_block      = 1'h0;\n      ready_flag       = 1'h0;\n      w_init           = 1'h0;\n      w_next           = 1'h0;\n      round_ctr_inc    = 1'h0;\n      round_ctr_rst    = 1'h0;\n      digest_valid_new = 1'h0;\n      digest_valid_we  = 1'h0;\n      sha1_ctrl_new    = CTRL_IDLE;\n      sha1_ctrl_we     = 1'h0;\n\n      case (sha1_ctrl_reg)\n        CTRL_IDLE:\n          begin\n            ready_flag = 1;\n\n            if (init)\n              begin\n                digest_init      = 1'h1;\n                w_init           = 1'h1;\n                state_init       = 1'h1;\n                first_block      = 1'h1;\n                round_ctr_rst    = 1'h1;\n                digest_valid_new = 1'h0;\n                digest_valid_we  = 1'h1;\n                sha1_ctrl_new    = CTRL_ROUNDS;\n                sha1_ctrl_we     = 1'h1;\n              end\n\n            if (next)\n              begin\n                w_init           = 1'h1;\n                state_init       = 1'h1;\n                round_ctr_rst    = 1'h1;\n                digest_valid_new = 1'h0;\n                digest_valid_we  = 1'h1;\n                sha1_ctrl_new    = CTRL_ROUNDS;\n                sha1_ctrl_we     = 1'h1;\n              end\n          end\n\n\n        CTRL_ROUNDS:\n          begin\n            state_update  = 1'h1;\n            round_ctr_inc = 1'h1;\n            w_next        = 1'h1;\n\n            if (round_ctr_reg == SHA1_ROUNDS)\n              begin\n                sha1_ctrl_new = CTRL_DONE;\n                sha1_ctrl_we  = 1'h1;\n              end\n          end\n\n\n        CTRL_DONE:\n          begin\n            digest_update    = 1'h1;\n            digest_valid_new = 1'h1;\n            digest_valid_we  = 1'h1;\n            sha1_ctrl_new    = CTRL_IDLE;\n            sha1_ctrl_we     = 1'h1;\n          end\n      endcase // case (sha1_ctrl_reg)\n    end // sha1_ctrl_fsm\n\nendmodule // sha1_core\n\n//======================================================================\n// EOF sha1_core.v\n//======================================================================", "rtl/sha1_w_mem.v": "//======================================================================\n//\n// sha1_w_mem_reg.v\n// -----------------\n// The SHA-1 W memory. This memory includes functionality to\n// expand the block into 80 words.\n//\n//\n// Copyright (c) 2013 Secworks Sweden AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\n`default_nettype none\n\nmodule sha1_w_mem(\n                  input wire           clk,\n                  input wire           reset_n,\n\n                  input wire [511 : 0] block,\n\n                  input wire           init,\n                  input wire           next,\n\n                  output wire [31 : 0] w\n                 );\n\n\n  //----------------------------------------------------------------\n  // Registers including update variables and write enable.\n  //----------------------------------------------------------------\n  reg [31 : 0] w_mem [0 : 15];\n  reg [31 : 0] w_mem00_new;\n  reg [31 : 0] w_mem01_new;\n  reg [31 : 0] w_mem02_new;\n  reg [31 : 0] w_mem03_new;\n  reg [31 : 0] w_mem04_new;\n  reg [31 : 0] w_mem05_new;\n  reg [31 : 0] w_mem06_new;\n  reg [31 : 0] w_mem07_new;\n  reg [31 : 0] w_mem08_new;\n  reg [31 : 0] w_mem09_new;\n  reg [31 : 0] w_mem10_new;\n  reg [31 : 0] w_mem11_new;\n  reg [31 : 0] w_mem12_new;\n  reg [31 : 0] w_mem13_new;\n  reg [31 : 0] w_mem14_new;\n  reg [31 : 0] w_mem15_new;\n  reg          w_mem_we;\n\n  reg [6 : 0] w_ctr_reg;\n  reg [6 : 0] w_ctr_new;\n  reg         w_ctr_we;\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg [31 : 0] w_tmp;\n  reg [31 : 0] w_new;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign w = w_tmp;\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //\n  // Update functionality for all registers in the core.\n  // All registers are positive edge triggered with\n  // asynchronous active low reset.\n  //----------------------------------------------------------------\n  always @ (posedge clk or negedge reset_n)\n    begin : reg_update\n      integer i;\n\n      if (!reset_n)\n        begin\n          for (i = 0 ; i < 16 ; i = i + 1)\n            w_mem[i] <= 32'h0;\n\n          w_ctr_reg <= 7'h0;\n        end\n      else\n        begin\n          if (w_mem_we)\n            begin\n              w_mem[00] <= w_mem00_new;\n              w_mem[01] <= w_mem01_new;\n              w_mem[02] <= w_mem02_new;\n              w_mem[03] <= w_mem03_new;\n              w_mem[04] <= w_mem04_new;\n              w_mem[05] <= w_mem05_new;\n              w_mem[06] <= w_mem06_new;\n              w_mem[07] <= w_mem07_new;\n              w_mem[08] <= w_mem08_new;\n              w_mem[09] <= w_mem09_new;\n              w_mem[10] <= w_mem10_new;\n              w_mem[11] <= w_mem11_new;\n              w_mem[12] <= w_mem12_new;\n              w_mem[13] <= w_mem13_new;\n              w_mem[14] <= w_mem14_new;\n              w_mem[15] <= w_mem15_new;\n            end\n\n          if (w_ctr_we)\n            w_ctr_reg <= w_ctr_new;\n        end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // select_w\n  //\n  // W word selection logic. Returns either directly from the\n  // memory or the next w value calculated.\n  //----------------------------------------------------------------\n  always @*\n    begin : select_w\n      if (w_ctr_reg < 16)\n        w_tmp = w_mem[w_ctr_reg[3 : 0]];\n      else\n        w_tmp = w_new;\n    end // select_w\n\n\n  //----------------------------------------------------------------\n  // w_mem_update_logic\n  //\n  // Update logic for the W memory. This is where the scheduling\n  // based on a sliding window is implemented.\n  //----------------------------------------------------------------\n  always @*\n    begin : w_mem_update_logic\n      reg [31 : 0] w_0;\n      reg [31 : 0] w_2;\n      reg [31 : 0] w_8;\n      reg [31 : 0] w_13;\n      reg [31 : 0] w_16;\n\n      w_mem00_new = 32'h0;\n      w_mem01_new = 32'h0;\n      w_mem02_new = 32'h0;\n      w_mem03_new = 32'h0;\n      w_mem04_new = 32'h0;\n      w_mem05_new = 32'h0;\n      w_mem06_new = 32'h0;\n      w_mem07_new = 32'h0;\n      w_mem08_new = 32'h0;\n      w_mem09_new = 32'h0;\n      w_mem10_new = 32'h0;\n      w_mem11_new = 32'h0;\n      w_mem12_new = 32'h0;\n      w_mem13_new = 32'h0;\n      w_mem14_new = 32'h0;\n      w_mem15_new = 32'h0;\n      w_mem_we    = 1'h0;\n\n      w_0   = w_mem[0];\n      w_2   = w_mem[2];\n      w_8   = w_mem[8];\n      w_13  = w_mem[13];\n      w_16  = w_13 ^ w_8 ^ w_2 ^ w_0;\n      w_new = {w_16[30 : 0], w_16[31]};\n\n      if (init)\n        begin\n          w_mem00_new = block[511 : 480];\n          w_mem01_new = block[479 : 448];\n          w_mem02_new = block[447 : 416];\n          w_mem03_new = block[415 : 384];\n          w_mem04_new = block[383 : 352];\n          w_mem05_new = block[351 : 320];\n          w_mem06_new = block[319 : 288];\n          w_mem07_new = block[287 : 256];\n          w_mem08_new = block[255 : 224];\n          w_mem09_new = block[223 : 192];\n          w_mem10_new = block[191 : 160];\n          w_mem11_new = block[159 : 128];\n          w_mem12_new = block[127 :  96];\n          w_mem13_new = block[95  :  64];\n          w_mem14_new = block[63  :  32];\n          w_mem15_new = block[31  :   0];\n          w_mem_we    = 1'h1;\n        end\n\n      if (next && (w_ctr_reg > 15))\n        begin\n          w_mem00_new = w_mem[01];\n          w_mem01_new = w_mem[02];\n          w_mem02_new = w_mem[03];\n          w_mem03_new = w_mem[04];\n          w_mem04_new = w_mem[05];\n          w_mem05_new = w_mem[06];\n          w_mem06_new = w_mem[07];\n          w_mem07_new = w_mem[08];\n          w_mem08_new = w_mem[09];\n          w_mem09_new = w_mem[10];\n          w_mem10_new = w_mem[11];\n          w_mem11_new = w_mem[12];\n          w_mem12_new = w_mem[13];\n          w_mem13_new = w_mem[14];\n          w_mem14_new = w_mem[15];\n          w_mem15_new = w_new;\n          w_mem_we    = 1'h1;\n        end\n    end // w_mem_update_logic\n\n\n  //----------------------------------------------------------------\n  // w_ctr\n  //\n  // W schedule adress counter. Counts from 0x10 to 0x3f and\n  // is used to expand the block into words.\n  //----------------------------------------------------------------\n  always @*\n    begin : w_ctr\n      w_ctr_new = 7'h0;\n      w_ctr_we  = 1'h0;\n\n      if (init)\n        begin\n          w_ctr_new = 7'h0;\n          w_ctr_we  = 1'h1;\n        end\n\n      if (next)\n        begin\n          w_ctr_new = w_ctr_reg + 7'h01;\n          w_ctr_we  = 1'h1;\n        end\n    end // w_ctr\nendmodule // sha1_w_mem\n\n//======================================================================\n// sha1_w_mem.v\n//======================================================================", "verif/sha1_core_idle_state_safety_check.sv": "module sha1_core_idle_state_safety_check (\n    input wire            clk,\n    input wire            reset_n,\n    input wire            init,\n    input wire            next,\n    input wire [511 : 0]  block,\n    output wire           ready,\n    output wire [159 : 0] digest,\n    output wire           digest_valid\n);\n\n    sha1_core dut (\n        .clk(clk),\n        .reset_n(reset_n),\n        .init(init),\n        .next(next),\n        .block(block),\n        .ready(ready),\n        .digest(digest),\n        .digest_valid(digest_valid)\n    );\n\nendmodule : sha1_core_idle_state_safety_check"}}, "output": {"response": "", "context": {"verif/sha1_core_idle_state_safety_check.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    image: verification_image\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/verif/sha1_core_idle_state_safety_check.sv /code/rtl/sha1_core.v /code/rtl/sha1_w_mem.v\nTOPLEVEL        = sha1_core_idle_state_safety_check\nMODULE          = test_sha1_core\nPYTHONPATH      = /src\nHASH            = 507245a74efc0a20ee506da956c8005006f0c9bf", "src/coverage.py": "from cocotb.runner import get_runner\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_clear():\n    covt_report_file=\"/code/rundir/coverage.log\"\n    if os.path.isfile(covt_report_file):\n        os.remove(covt_report_file)\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "\nfrom cocotb.binary import BinaryValue\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\n\nCLK_HALF_PERIOD = 1\nCLK_PERIOD = CLK_HALF_PERIOD * 2\nCLK_TIME_UNIT = 'ns'\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def init_sim(dut):\n    dut.reset_n.value = 1\n    dut.init.value = 0\n    dut.next.value = 0\n    dut.block.value = 0\n\nasync def reset_dut(dut):\n    dut.reset_n.value = 0\n    await Timer(4 * CLK_HALF_PERIOD, units=CLK_TIME_UNIT)\n    dut.reset_n.value = 1\n\nasync def wait_ready(dut):\n    while dut.ready.value.integer != 1:\n        await FallingEdge(dut.clk)\n\nasync def single_block_test(dut, block: BinaryValue, expected: BinaryValue):\n    dut.block.value = block\n    dut.init.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.init.value = 0\n    await wait_ready(dut)\n\n    assert dut.digest.value == expected, \"didn't get the expected digest output\"\n\nasync def double_block_test(dut, blocks: list[BinaryValue], expected: list[BinaryValue]):\n    dut.block.value = blocks[0]\n    dut.init.value = 1\n    await FallingEdge(dut.clk)\n\n    dut.init.value = 0\n    await wait_ready(dut)\n\n    assert dut.digest.value == expected[0], \"didn't get the expected digest output for block1\"\n\n    dut.block.value = blocks[1]\n    dut.next.value = 1\n    await FallingEdge(dut.clk)\n\n    dut.next.value = 0\n    await wait_ready(dut)\n\n    assert dut.digest.value == expected[1], \"didn't get the expected digest output for block2\"\n\n", "src/test_runner.py": "import os\nimport pytest\nimport coverage\nimport random\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef call_runner():\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.covt_report_clear()\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter={}\n        )\n        coverage.coverage_report(\"assertion\")\n        coverage.covt_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n    # Run the simulation\n    call_runner()\n", "src/test_sha1_core.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.binary import BinaryValue\nimport harness_library as hrs_lb\n\n\n@cocotb.test()\nasync def test_dut(dut):\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_dut...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    # TC1: Single block message: \"abc\".\n    # tc1 = 512'h61626380000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000018;\n    # res1 = 160'ha9993e364706816aba3e25717850c26c9cd0d89d;\n\n    tc1 = int('61626380000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000018', 16)\n    res1 = int('a9993e364706816aba3e25717850c26c9cd0d89d', 16)\n    tc1_bin = BinaryValue(tc1, 512, False)\n    res1_bin = BinaryValue(res1, 160, False)\n    await hrs_lb.single_block_test(dut, tc1_bin, res1_bin)\n\n    # TC2: Double block message.\n    # \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    # tc2_1 = 512'h6162636462636465636465666465666765666768666768696768696A68696A6B696A6B6C6A6B6C6D6B6C6D6E6C6D6E6F6D6E6F706E6F70718000000000000000;\n    # res2_1 = 160'hf4286818c37b27ae0408f581846771484a566572;\n    # tc2_2 = 512'h000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001C0;\n    # res2_2 = 160'h84983e441c3bd26ebaae4aa1f95129e5e54670f1;\n\n    tc2 = [\n        int('6162636462636465636465666465666765666768666768696768696A68696A6B696A6B6C6A6B6C6D6B6C6D6E6C6D6E6F6D6E6F706E6F70718000000000000000', 16),\n        int('000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001C0', 16)\n    ]\n    res2 = [\n        int('f4286818c37b27ae0408f581846771484a566572', 16),\n        int('84983e441c3bd26ebaae4aa1f95129e5e54670f1', 16)\n    ]\n    tc2_bin = [\n        BinaryValue(tc2[0], 512, False),\n        BinaryValue(tc2[1], 512, False)\n    ]\n    res2_bin = [\n        BinaryValue(res2[0], 160, False),\n        BinaryValue(res2[1], 160, False)\n    ]\n    await hrs_lb.double_block_test(dut, tc2_bin, res2_bin)\n\n    cocotb.log.info(\"All tests passed.\")\n"}}}
{"id": "cvdp_copilot_crypto_0019", "categories": ["cid014", "medium"], "input": {"prompt": "Add an assertion to verify that the `prince_core` module can **cipher** and **decipher** a given data block using a given key, considering the conditions described below.  \n\n- The property must be placed in a separate module named `prince_core_cipher_operations_check`, which instantiates `prince_core` as `dut` (Device Under Test).  \n- The property must directly reference internal DUT signals for verification.  \n\n### **Design Specification: `prince_core`**\n\n#### **Inputs:**  \n- **clk**: System clock (rising edge).  \n- **reset_n**: Active-low asynchronous reset.  \n- **encdec**: Mode selection (1 = encryption, 0 = decryption).  \n- **next**: Starts encryption/decryption when asserted.  \n- **key** (`[127:0]`): 128-bit encryption key.  \n- **block** (`[63:0]`): 64-bit input (plaintext or ciphertext).  \n\n#### **Outputs:**  \n- **ready**: High when the core is idle and ready for a new operation.  \n- **result** (`[63:0]`): 64-bit processed output (ciphertext or plaintext).  \n\n---\n\n### **Functional Overview:**  \n- Implements **PRINCE**, a lightweight 64-bit block cipher with a **128-bit key**.  \n- Uses a **12-round transformation**, split into forward and inverse rounds for encryption and decryption.  \n- Computes the result over multiple clock cycles, updating internal registers.  \n- The **FSM state** is controlled by:  \n  - `core_ctrl_reg`: Holds the current state.  \n  - `core_ctrl_new`: Stores the next state before updating.  \n\n---\n\n### **FSM (Finite State Machine) States:**  \n1. **CTRL_IDLE**: Waits for `next` to start processing. (`ready = 1`)  \n2. **CTRL_PIPE0 \u2192 CTRL_PIPE1 \u2192 CTRL_PIPE2**: Sequential processing stages applying encryption/decryption transformations.  \n3. **CTRL_UPDATE**: Writes the final result, sets `ready = 1`, and returns to `CTRL_IDLE`.  \n\n`core_ctrl_reg` updates to `core_ctrl_new` on each clock cycle when a transition occurs.  \n\n---\n\n### **Signal Behavior:**  \n\n| **Signal**   | **Description**                               |\n|--------------|-----------------------------------------------|\n| **clk**      | Drives all internal operations.               |\n| **reset_n**  | Resets internal registers.                    |\n| **next**     | Triggers processing when asserted.            |\n| **encdec**   | Selects encryption (`1`) or decryption (`0`). |\n| **key**      | 128-bit secret key.                           |\n| **block**    | Input data (plaintext/ciphertext).            |\n| **ready**    | High when idle, low during processing.        |\n| **result**   | Outputs the processed 64-bit data.            |\n\n---\n\n### **Processing Flow:**  \n1. **Idle:** `ready = 1`, waits for `next`.  \n2. **Pipeline Processing:** Transitions through `PIPE0 \u2192 PIPE1 \u2192 PIPE2`.  \n3. **Update:** Stores result, sets `ready = 1`, returns to `CTRL_IDLE`.  \n\n**Key Features:**  \n- **Low-latency:** Optimized for fast encryption/decryption.  \n- **Encryption & Decryption Support:** Controlled via `encdec`.  \n- **FSM Control:** `core_ctrl_reg` determines state transitions.  \n- **Internal Key Schedule:** Uses `k0`, `k1`, and derived `kp` for transformations.  \n\n---\n\n### **Note:**  \n- An **assertion failure** must include a **descriptive error message** to aid debugging.  ", "context": {"rtl/prince_core.v": "//======================================================================\n//\n// prince_core.v\n// -------------\n// Prince block cipher core.\n//\n//\n// Author: Joachim Strombergson\n// Copyright (c) 2019, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\n`default_nettype none\n\nmodule prince_core(\n                   input wire           clk,\n                   input wire           reset_n,\n\n                   input wire           encdec,\n                   input wire           next,\n                   output wire          ready,\n\n                   input wire [127 : 0] key,\n\n                   input wire [63 : 0]  block,\n                   output wire [63 : 0] result\n                  );\n\n\n  //----------------------------------------------------------------\n  // Internal constant and parameter definitions.\n  //----------------------------------------------------------------\n  localparam CTRL_IDLE   = 3'h0;\n  localparam CTRL_PIPE0  = 3'h1;\n  localparam CTRL_PIPE1  = 3'h2;\n  localparam CTRL_PIPE2  = 3'h3;\n  localparam CTRL_UPDATE = 3'h4;\n\n  localparam ALPHA = 64'hc0ac29b7c97c50dd;\n\n\n  //----------------------------------------------------------------\n  // Registers including update variables and write enable.\n  //----------------------------------------------------------------\n  reg [63 : 0] k0_reg;\n  reg [63 : 0] k0_new;\n  reg [63 : 0] k1_reg;\n  reg [63 : 0] k1_new;\n  reg [63 : 0] kp_reg;\n  reg [63 : 0] kp_new;\n  reg          k_we;\n\n  reg          ready_reg;\n  reg          ready_new;\n  reg          ready_we;\n\n  reg [63 : 0] state_reg;\n  reg [63 : 0] state_new;\n  reg          state_we;\n\n  reg [63 : 0] r3_reg;\n  reg [63 : 0] r3_new;\n\n  reg [63 : 0] r8_reg;\n  reg [63 : 0] r8_new;\n\n  reg [63 : 0] mr_reg;\n  reg [63 : 0] mr_new;\n\n  reg [2 : 0]  core_ctrl_reg;\n  reg [2 : 0]  core_ctrl_new;\n  reg          core_ctrl_we;\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg init_state;\n  reg update_state;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign ready  = ready_reg;\n  assign result = state_reg;\n\n\n  //----------------------------------------------------------------\n  // Internal functions.\n  //----------------------------------------------------------------\n//`include \"prince_round_functions.vh\"\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //\n  // Update functionality for all registers in the core.\n  // All registers are positive edge triggered with asynchronous\n  // active low reset.\n  //----------------------------------------------------------------\n  always @ (posedge clk or negedge reset_n)\n    begin: reg_update\n      if (!reset_n)\n        begin\n          ready_reg     <= 1'h1;\n          k0_reg        <= 64'h0;\n          k1_reg        <= 64'h0;\n          kp_reg        <= 64'h0;\n          r3_reg        <= 64'h0;\n          r8_reg        <= 64'h0;\n          mr_reg        <= 64'h0;\n          state_reg     <= 64'h0;\n          core_ctrl_reg <= CTRL_IDLE;\n        end\n      else\n        begin\n          r3_reg <= r3_new;\n          r8_reg <= r8_new;\n          mr_reg <= mr_new;\n\n          if (ready_we)\n            ready_reg <= ready_new;\n\n          if (state_we)\n            state_reg <= state_new;\n\n          if (k_we)\n            begin\n              k0_reg <= k0_new;\n              k1_reg <= k1_new;\n              kp_reg <= kp_new;\n            end\n\n          if (core_ctrl_we)\n            core_ctrl_reg <= core_ctrl_new;\n        end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // prince_core_dp\n  //\n  // Datapath with state update logic.\n  //----------------------------------------------------------------\n  always @*\n    begin : prince_core_dp\n\n      reg [63 : 0] core_input;\n      reg [63 : 0] core_output;\n\n      reg [63 : 0] r0;\n      reg [63 : 0] r1;\n      reg [63 : 0] r2;\n      reg [63 : 0] r4;\n      reg [63 : 0] r5;\n      reg [63 : 0] r6;\n      reg [63 : 0] r7;\n      reg [63 : 0] r9;\n      reg [63 : 0] r10;\n      reg [63 : 0] r11;\n\n      state_new = 64'h0;\n      state_we  = 1'h0;\n      k0_new    = 64'h0;\n      k1_new    = 64'h0;\n      kp_new    = 64'h0;\n      k_we      = 1'h0;\n\n\n      // Pipeline stages.\n      core_input = state_reg ^ k0_reg;\n      r0 = round0(core_input, k1_reg);\n      r1 = round(r0, k1_reg, 1);\n      r2 = round(r1, k1_reg, 2);\n      r3_new = round(r2, k1_reg, 3);\n\n      r4 = round(r3_reg, k1_reg, 4);\n      r5 = round(r4, k1_reg, 5);\n      mr_new = middle_round(r5);\n\n      r6 = iround(mr_reg, k1_reg, 6);\n      r7 = iround(r6, k1_reg, 7);\n      r8_new = iround(r7, k1_reg, 8);\n\n      r9  = iround(r8_reg, k1_reg, 9);\n      r10 = iround(r9, k1_reg, 10);\n      r11 = round11(r10, k1_reg);\n      core_output = r11 ^ kp_reg;\n\n\n      if (init_state)\n        begin\n          k_we      = 1'h1;\n          state_new = block;\n          state_we  = 1'h1;\n\n          if (encdec)\n            begin\n              k0_new = key[127 : 64];\n              kp_new = {k0_new[0], k0_new[63 : 2], (k0_new[1] ^ k0_new[63])};\n              k1_new = key[63 : 0];\n            end\n          else\n            begin\n              kp_new = key[127 : 64];\n              k0_new = {kp_new[0], kp_new[63 : 2], (kp_new[1] ^ kp_new[63])};\n              k1_new = key[63 : 0] ^ ALPHA;\n            end\n        end\n\n      if (update_state)\n        begin\n          state_new = core_output;\n          state_we  = 1'h1;\n        end\n    end // prince_core_dp\n\n\n  //----------------------------------------------------------------\n  // prince_core_ctrl\n  //\n  // Control FSM for aes core.\n  //----------------------------------------------------------------\n  always @*\n    begin : prince_core_ctrl\n      ready_new     = 1'h0;\n      ready_we      = 1'h0;\n      init_state    = 1'h0;\n      update_state  = 1'h0;\n      core_ctrl_new = CTRL_IDLE;\n      core_ctrl_we  = 1'h0;\n\n      case (core_ctrl_reg)\n        CTRL_IDLE:\n          begin\n            if (next)\n              begin\n                ready_new     = 1'h0;\n                ready_we      = 1'h1;\n                init_state    = 1'h1;\n                core_ctrl_new = CTRL_PIPE0;\n                core_ctrl_we  = 1'h1;\n              end\n          end\n\n        CTRL_PIPE0:\n          begin\n            core_ctrl_new = CTRL_PIPE1;\n            core_ctrl_we  = 1'h1;\n          end\n\n        CTRL_PIPE1:\n          begin\n            core_ctrl_new = CTRL_PIPE2;\n            core_ctrl_we  = 1'h1;\n          end\n\n        CTRL_PIPE2:\n          begin\n            core_ctrl_new = CTRL_UPDATE;\n            core_ctrl_we  = 1'h1;\n          end\n\n        CTRL_UPDATE:\n          begin\n            ready_new     = 1'h1;\n            ready_we      = 1'h1;\n            update_state  = 1'h1;\n            core_ctrl_new = CTRL_IDLE;\n            core_ctrl_we  = 1'h1;\n          end\n\n        default:\n          begin\n          end\n      endcase // case (core_ctrl_reg)\n    end // prince_core_ctrl\n\nendmodule // prince_core\n\n//======================================================================\n// EOF prince_core.v\n//======================================================================", "rtl/prince_round_functions.vh": "//======================================================================\n//\n// prince_round_functions.v\n// ------------------------\n// Functions used in the prince core.\n//\n//\n// Author: Joachim Strombergson\n// Copyright (c) 2023, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\n  function [3 : 0] sb(input [3 : 0] x);\n    case(x)\n      4'h0: sb = 4'hb;\n      4'h1: sb = 4'hf;\n      4'h2: sb = 4'h3;\n      4'h3: sb = 4'h2;\n      4'h4: sb = 4'ha;\n      4'h5: sb = 4'hc;\n      4'h6: sb = 4'h9;\n      4'h7: sb = 4'h1;\n      4'h8: sb = 4'h6;\n      4'h9: sb = 4'h7;\n      4'ha: sb = 4'h8;\n      4'hb: sb = 4'h0;\n      4'hc: sb = 4'he;\n      4'hd: sb = 4'h5;\n      4'he: sb = 4'hd;\n      4'hf: sb = 4'h4;\n    endcase // case (x)\n  endfunction // sb\n\n  function [63 : 0] s(input [63 : 0] x);\n    s = {sb(x[63 : 60]), sb(x[59 : 56]),\n         sb(x[55 : 52]), sb(x[51 : 48]),\n         sb(x[47 : 44]), sb(x[43 : 40]),\n         sb(x[39 : 36]), sb(x[35 : 32]),\n         sb(x[31 : 28]), sb(x[27 : 24]),\n         sb(x[23 : 20]), sb(x[19 : 16]),\n         sb(x[15 : 12]), sb(x[11 : 08]),\n         sb(x[07 : 04]), sb(x[03 : 00])};\n  endfunction // s\n\n  function [3 : 0] isb(input [3 : 0] x);\n    case(x)\n      4'h0: isb = 4'hb;\n      4'h1: isb = 4'h7;\n      4'h2: isb = 4'h3;\n      4'h3: isb = 4'h2;\n      4'h4: isb = 4'hf;\n      4'h5: isb = 4'hd;\n      4'h6: isb = 4'h8;\n      4'h7: isb = 4'h9;\n      4'h8: isb = 4'ha;\n      4'h9: isb = 4'h6;\n      4'ha: isb = 4'h4;\n      4'hb: isb = 4'h0;\n      4'hc: isb = 4'h5;\n      4'hd: isb = 4'he;\n      4'he: isb = 4'hc;\n      4'hf: isb = 4'h1;\n    endcase // case (x)\n  endfunction // isb\n\n  function [63 : 0] si(input [63 : 0] x);\n    si = {isb(x[63 : 60]), isb(x[59 : 56]),\n          isb(x[55 : 52]), isb(x[51 : 48]),\n          isb(x[47 : 44]), isb(x[43 : 40]),\n          isb(x[39 : 36]), isb(x[35 : 32]),\n          isb(x[31 : 28]), isb(x[27 : 24]),\n          isb(x[23 : 20]), isb(x[19 : 16]),\n          isb(x[15 : 12]), isb(x[11 : 08]),\n          isb(x[07 : 04]), isb(x[03 : 00])};\n  endfunction // si\n\n  function [63 : 0] rc(input [3 : 0] round);\n    begin\n      case(round)\n        00: rc = 64'h0000000000000000;\n        01: rc = 64'h13198a2e03707344;\n        02: rc = 64'ha4093822299f31d0;\n        03: rc = 64'h082efa98ec4e6c89;\n        04: rc = 64'h452821e638d01377;\n        05: rc = 64'hbe5466cf34e90c6c;\n        06: rc = 64'h7ef84f78fd955cb1;\n        07: rc = 64'h85840851f1ac43aa;\n        08: rc = 64'hc882d32f25323c54;\n        09: rc = 64'h64a51195e0e3610d;\n        10: rc = 64'hd3b5a399ca0c2399;\n        11: rc = 64'hc0ac29b7c97c50dd;\n        default:\n          rc = 64'h0;\n      endcase // case (round)\n    end\n  endfunction // rc\n\n  function [63 : 0] mp(input [63 : 0] b);\n    begin\n      mp[63] = b[59] ^ b[55] ^ b[51];\n      mp[62] = b[62] ^ b[54] ^ b[50];\n      mp[61] = b[61] ^ b[57] ^ b[49];\n      mp[60] = b[60] ^ b[56] ^ b[52];\n      mp[59] = b[63] ^ b[59] ^ b[55];\n      mp[58] = b[58] ^ b[54] ^ b[50];\n      mp[57] = b[61] ^ b[53] ^ b[49];\n      mp[56] = b[60] ^ b[56] ^ b[48];\n      mp[55] = b[63] ^ b[59] ^ b[51];\n      mp[54] = b[62] ^ b[58] ^ b[54];\n      mp[53] = b[57] ^ b[53] ^ b[49];\n      mp[52] = b[60] ^ b[52] ^ b[48];\n      mp[51] = b[63] ^ b[55] ^ b[51];\n      mp[50] = b[62] ^ b[58] ^ b[50];\n      mp[49] = b[61] ^ b[57] ^ b[53];\n      mp[48] = b[56] ^ b[52] ^ b[48];\n      mp[47] = b[47] ^ b[43] ^ b[39];\n      mp[46] = b[42] ^ b[38] ^ b[34];\n      mp[45] = b[45] ^ b[37] ^ b[33];\n      mp[44] = b[44] ^ b[40] ^ b[32];\n      mp[43] = b[47] ^ b[43] ^ b[35];\n      mp[42] = b[46] ^ b[42] ^ b[38];\n      mp[41] = b[41] ^ b[37] ^ b[33];\n      mp[40] = b[44] ^ b[36] ^ b[32];\n      mp[39] = b[47] ^ b[39] ^ b[35];\n      mp[38] = b[46] ^ b[42] ^ b[34];\n      mp[37] = b[45] ^ b[41] ^ b[37];\n      mp[36] = b[40] ^ b[36] ^ b[32];\n      mp[35] = b[43] ^ b[39] ^ b[35];\n      mp[34] = b[46] ^ b[38] ^ b[34];\n      mp[33] = b[45] ^ b[41] ^ b[33];\n      mp[32] = b[44] ^ b[40] ^ b[36];\n      mp[31] = b[31] ^ b[27] ^ b[23];\n      mp[30] = b[26] ^ b[22] ^ b[18];\n      mp[29] = b[29] ^ b[21] ^ b[17];\n      mp[28] = b[28] ^ b[24] ^ b[16];\n      mp[27] = b[31] ^ b[27] ^ b[19];\n      mp[26] = b[30] ^ b[26] ^ b[22];\n      mp[25] = b[25] ^ b[21] ^ b[17];\n      mp[24] = b[28] ^ b[20] ^ b[16];\n      mp[23] = b[31] ^ b[23] ^ b[19];\n      mp[22] = b[30] ^ b[26] ^ b[18];\n      mp[21] = b[29] ^ b[25] ^ b[21];\n      mp[20] = b[24] ^ b[20] ^ b[16];\n      mp[19] = b[27] ^ b[23] ^ b[19];\n      mp[18] = b[30] ^ b[22] ^ b[18];\n      mp[17] = b[29] ^ b[25] ^ b[17];\n      mp[16] = b[28] ^ b[24] ^ b[20];\n      mp[15] = b[11] ^ b[07] ^ b[03];\n      mp[14] = b[14] ^ b[06] ^ b[02];\n      mp[13] = b[13] ^ b[09] ^ b[01];\n      mp[12] = b[12] ^ b[08] ^ b[04];\n      mp[11] = b[15] ^ b[11] ^ b[07];\n      mp[10] = b[10] ^ b[06] ^ b[02];\n      mp[09] = b[13] ^ b[05] ^ b[01];\n      mp[08] = b[12] ^ b[08] ^ b[00];\n      mp[07] = b[15] ^ b[11] ^ b[03];\n      mp[06] = b[14] ^ b[10] ^ b[06];\n      mp[05] = b[09] ^ b[05] ^ b[01];\n      mp[04] = b[12] ^ b[04] ^ b[00];\n      mp[03] = b[15] ^ b[07] ^ b[03];\n      mp[02] = b[14] ^ b[10] ^ b[02];\n      mp[01] = b[13] ^ b[09] ^ b[05];\n      mp[00] = b[08] ^ b[04] ^ b[00];\n    end\n  endfunction // mp\n\n  function [63 : 0] m(input [63 : 0] b);\n    begin : m_func\n      reg [63 : 0] t;\n      t = mp(b);\n\n      m = {t[63 : 60], t[43 : 40], t[23 : 20], t[03 : 00],\n           t[47 : 44], t[27 : 24], t[07 : 04], t[51 : 48],\n           t[31 : 28], t[11 : 08], t[55 : 52], t[35 : 32],\n           t[15 : 12], t[59 : 56], t[39 : 36], t[19 : 16]};\n    end\n  endfunction // m\n\n  function [63 : 0] mi(input [63 : 0] b);\n    begin : mi_func\n      reg [63 : 0] t;\n\n      t = {b[63 : 60], b[11 : 08], b[23 : 20], b[35 : 32],\n           b[47 : 44], b[59 : 56], b[07 : 04], b[19 : 16],\n           b[31 : 28], b[43 : 40], b[55 : 52], b[03 : 00],\n           b[15 : 12], b[27 : 24], b[39 : 36], b[51 : 48]};\n\n      mi = mp(t);\n    end\n  endfunction // m\n\n  function [63 : 0] round0(input [63 : 0] b, input [63 : 0] k);\n    begin\n      round0 = b ^ k ^ rc(0);\n    end\n  endfunction // round0\n\n  function [63 : 0] round11(input [63 : 0] b, input [63 : 0] k);\n    begin\n      round11 =  b ^ k ^ rc(11);\n    end\n  endfunction // round11\n\n  function [63 : 0] round(input [63 : 0] b, input [63 : 0] k, input [3 : 0] n);\n    begin\n      round = m(s(b)) ^ rc(n) ^ k;\n    end\n  endfunction // round\n\n  function [63 : 0] middle_round(input [63 : 0] b);\n    begin\n      middle_round = si(mp(s(b)));\n    end\n  endfunction // middle_round\n\n  function [63 : 0] iround(input [63 : 0] b, input [63 : 0] k, input [3 : 0] n);\n    begin\n      iround = si(mi(rc(n) ^ k ^ b));\n    end\n  endfunction // iround\n\n//======================================================================\n// EOF prince_round_functions.vh\n//======================================================================", "verif/prince_core_cipher_operations_check.sv": "module prince_core_cipher_operations_check (\n    input wire           clk,\n    input wire           reset_n,\n    input wire           encdec,\n    input wire           next,\n    output wire          ready,\n    input wire [127 : 0] key,\n    input wire [63 : 0]  block,\n    output wire [63 : 0] result\n);\n\n    prince_core dut (\n        .clk(clk),\n        .reset_n(reset_n),\n        .encdec(encdec),\n        .next(next),\n        .ready(ready),\n        .key(key),\n        .block(block),\n        .result(result)\n    );\n\nendmodule : prince_core_cipher_operations_check"}}, "output": {"response": "", "context": {"verif/prince_core_cipher_operations_check.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    image: verification_image\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/verif/prince_core_cipher_operations_check.sv /code/rtl/prince_core.v /code/rtl/prince_round_functions.vh\nTOPLEVEL        = prince_core_cipher_operations_check\nMODULE          = test_prince_core\nPYTHONPATH      = /src\nHASH            = aa7b0ed0e861ccab67e24332414fb028024c4377", "src/coverage.py": "from cocotb.runner import get_runner\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_clear():\n    covt_report_file=\"/code/rundir/coverage.log\"\n    if os.path.isfile(covt_report_file):\n        os.remove(covt_report_file)\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "\nfrom cocotb.binary import BinaryValue\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\n\nCLK_HALF_PERIOD = 1\nCLK_PERIOD = CLK_HALF_PERIOD * 2\nCLK_TIME_UNIT = 'ns'\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def init_sim(dut):\n    dut.reset_n.value = 1\n    dut.encdec.value = 0\n    dut.next.value = 0\n    dut.key.value = 0\n    dut.block.value = 0\n\nasync def reset_dut(dut):\n    dut.reset_n.value = 0\n    await Timer(2 * CLK_PERIOD, units=CLK_TIME_UNIT)\n    dut.reset_n.value = 1\n\nasync def wait_ready(dut):\n    while dut.ready.value.integer != 1:\n        await FallingEdge(dut.clk)\n\nasync def block_test(dut, key: BinaryValue, block: BinaryValue, ciphertext: BinaryValue):\n    dut.key.value = key\n    dut.encdec.value = 1\n    dut.block.value = block\n    dut.next.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.next.value = 0\n    await wait_ready(dut)\n\n    assert dut.result.value == ciphertext, \"didn't get the expected ciphertext result\"\n\n    dut.block.value = ciphertext\n    dut.encdec.value = 0\n    dut.next.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.next.value = 0\n    await wait_ready(dut)\n\n    assert dut.result.value == block, \"didn't get the expected block result\"\n", "src/test_prince_core.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.binary import BinaryValue\nimport harness_library as hrs_lb\n\n\n@cocotb.test()\nasync def test_dut(dut):\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_dut...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    # test(1, 128'h00000000_00000000_00000000_00000000,\n    #      64'h00000000_00000000, 64'h818665aa_0d02dfda);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('00000000000000000000000000000000', 16), 128, False),\n        BinaryValue(int('0000000000000000', 16), 64, False),\n        BinaryValue(int('818665aa0d02dfda', 16), 64, False)\n    )\n\n    # test(2, 128'h00000000_00000000_00000000_00000000,\n    #      64'hffffffff_ffffffff, 64'h604ae6ca_03c20ada);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('00000000000000000000000000000000', 16), 128, False),\n        BinaryValue(int('ffffffffffffffff', 16), 64, False),\n        BinaryValue(int('604ae6ca03c20ada', 16), 64, False)\n    )\n\n    # test(3, 128'hffffffff_ffffffff_00000000_00000000,\n    #      64'h00000000_00000000, 64'h9fb51935_fc3df524);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('ffffffffffffffff0000000000000000', 16), 128, False),\n        BinaryValue(int('0000000000000000', 16), 64, False),\n        BinaryValue(int('9fb51935fc3df524', 16), 64, False)\n    )\n\n    # test(4, 128'h00000000_00000000_ffffffff_ffffffff,\n    #      64'h00000000_00000000, 64'h78a54cbe_737bb7ef);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0000000000000000ffffffffffffffff', 16), 128, False),\n        BinaryValue(int('0000000000000000', 16), 64, False),\n        BinaryValue(int('78a54cbe737bb7ef', 16), 64, False)\n    )\n\n    # test(5, 128'h00000000_00000000_fedcba98_76543210,\n    #      64'h01234567_89abcdef, 64'hae25ad3c_a8fa9ccf);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0000000000000000fedcba9876543210', 16), 128, False),\n        BinaryValue(int('0123456789abcdef', 16), 64, False),\n        BinaryValue(int('ae25ad3ca8fa9ccf', 16), 64, False)\n    )\n\n    # test(6, 128'h00112233_44556677_8899aabb_ccddeeff,\n    #      64'h01234567_89abcdef, 64'hd6dcb597_8de756ee);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('00112233445566778899aabbccddeeff', 16), 128, False),\n        BinaryValue(int('0123456789abcdef', 16), 64, False),\n        BinaryValue(int('d6dcb5978de756ee', 16), 64, False)\n    )\n\n    # test(7, 128'h01122334_45566778_899aabbc_cddeeff0,\n    #      64'h01234567_89abcdef, 64'h392f599f_46761cd3);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0112233445566778899aabbccddeeff0', 16), 128, False),\n        BinaryValue(int('0123456789abcdef', 16), 64, False),\n        BinaryValue(int('392f599f46761cd3', 16), 64, False)\n    )\n\n    # test(8, 128'h01122334_45566778_899aabbc_cddeeff0,\n    #      64'hf0123456_789abcde, 64'h4fb5e332_b9b409bb);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0112233445566778899aabbccddeeff0', 16), 128, False),\n        BinaryValue(int('f0123456789abcde', 16), 64, False),\n        BinaryValue(int('4fb5e332b9b409bb', 16), 64, False)\n    )\n\n    #\n    # test(9, 128'hd8cdb780_70b4c55a_818665aa_0d02dfda,\n    #      64'h69c4e0d8_6a7b0430, 64'h43c6b256_d79de7e8);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('d8cdb78070b4c55a818665aa0d02dfda', 16), 128, False),\n        BinaryValue(int('69c4e0d86a7b0430', 16), 64, False),\n        BinaryValue(int('43c6b256d79de7e8', 16), 64, False)\n    )\n\n    cocotb.log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nimport pytest\nimport coverage\nimport random\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef call_runner():\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.covt_report_clear()\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter={}\n        )\n        coverage.coverage_report(\"assertion\")\n        coverage.covt_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n    # Run the simulation\n    call_runner()\n"}}}
{"id": "cvdp_copilot_crypto_0022", "categories": ["cid014", "medium"], "input": {"prompt": "Elaborate on assertion properties to ensure that the `CTRL_UPDATE` state of the `prince_core` module's FSM is safe. The properties should check the following:\n\n1. The `CTRL_UPDATE` state must be reachable from a valid previous state when the design is ready and a new computation starts, assuming the necessary clock cycles have elapsed.\n2. After reaching the `CTRL_UPDATE` state, the design must be ready for a new computation in the next cycle.\n3. The design must transition to a new state in the cycle following its entry into the `CTRL_UPDATE` state.\n\nThe following requirements must be addressed:\n- The properties must be placed in a separate module named `prince_core_update_state_safety_check`, which instantiates `prince_core` as the DUT (Device Under Test) for verification.\n- The properties must directly reference internal DUT signals to perform verification.\n\n---\n\n### **Design Specification: `prince_core`**\n\n#### **Inputs:**  \n- **clk**: System clock (rising edge).  \n- **reset_n**: Active-low asynchronous reset.  \n- **encdec**: Mode selection (1 = encryption, 0 = decryption).  \n- **next**: Starts encryption/decryption when asserted.  \n- **key** (`[127:0]`): 128-bit encryption key.  \n- **block** (`[63:0]`): 64-bit input (plaintext or ciphertext).  \n\n#### **Outputs:**  \n- **ready**: High when the core is idle and ready for a new operation.  \n- **result** (`[63:0]`): 64-bit processed output (ciphertext or plaintext).  \n\n---\n\n### **Functional Overview:**  \n- Implements **PRINCE**, a lightweight 64-bit block cipher with a **128-bit key**.  \n- Uses a **12-round transformation**, split into forward and inverse rounds for encryption and decryption.  \n- Computes the result over multiple clock cycles, updating internal registers.  \n- The **FSM state** is controlled by:  \n  - `core_ctrl_reg`: Holds the current state.  \n  - `core_ctrl_new`: Stores the next state before updating.  \n\n---\n\n### **FSM (Finite State Machine) States:**  \n1. **CTRL_IDLE**: Waits for `next` to start processing. (`ready = 1`)  \n2. **CTRL_PIPE0 \u2192 CTRL_PIPE1 \u2192 CTRL_PIPE2**: Sequential processing stages applying encryption/decryption transformations.  \n3. **CTRL_UPDATE**: Writes the final result, sets `ready = 1`, and returns to `CTRL_IDLE`.  \n\n`core_ctrl_reg` updates to `core_ctrl_new` on each clock cycle when a transition occurs.  \n\n---\n\n### **Signal Behavior:**  \n\n| **Signal**   | **Description**                               |\n|--------------|-----------------------------------------------|\n| **clk**      | Drives all internal operations.               |\n| **reset_n**  | Resets internal registers.                    |\n| **next**     | Triggers processing when asserted.            |\n| **encdec**   | Selects encryption (`1`) or decryption (`0`). |\n| **key**      | 128-bit secret key.                           |\n| **block**    | Input data (plaintext/ciphertext).            |\n| **ready**    | High when idle, low during processing.        |\n| **result**   | Outputs the processed 64-bit data.            |\n\n---\n\n### **Processing Flow:**  \n1. **Idle:** `ready = 1`, waits for `next`.  \n2. **Pipeline Processing:** Transitions through `PIPE0 \u2192 PIPE1 \u2192 PIPE2`.  \n3. **Update:** Stores result, sets `ready = 1`, returns to `CTRL_IDLE`.  \n\n**Key Features:**  \n- **Low-latency:** Optimized for fast encryption/decryption.  \n- **Encryption & Decryption Support:** Controlled via `encdec`.  \n- **FSM Control:** `core_ctrl_reg` determines state transitions.  \n- **Internal Key Schedule:** Uses `k0`, `k1`, and derived `kp` for transformations.  \n\n---\n\n### **Note:**  \n- An **assertion failure** must include a **descriptive error message** to aid debugging.  ", "context": {"rtl/prince_core.v": "//======================================================================\n//\n// prince_core.v\n// -------------\n// Prince block cipher core.\n//\n//\n// Author: Joachim Strombergson\n// Copyright (c) 2019, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\n`default_nettype none\n\nmodule prince_core(\n                   input wire           clk,\n                   input wire           reset_n,\n\n                   input wire           encdec,\n                   input wire           next,\n                   output wire          ready,\n\n                   input wire [127 : 0] key,\n\n                   input wire [63 : 0]  block,\n                   output wire [63 : 0] result\n                  );\n\n\n  //----------------------------------------------------------------\n  // Internal constant and parameter definitions.\n  //----------------------------------------------------------------\n  localparam CTRL_IDLE   = 3'h0;\n  localparam CTRL_PIPE0  = 3'h1;\n  localparam CTRL_PIPE1  = 3'h2;\n  localparam CTRL_PIPE2  = 3'h3;\n  localparam CTRL_UPDATE = 3'h4;\n\n  localparam ALPHA = 64'hc0ac29b7c97c50dd;\n\n\n  //----------------------------------------------------------------\n  // Registers including update variables and write enable.\n  //----------------------------------------------------------------\n  reg [63 : 0] k0_reg;\n  reg [63 : 0] k0_new;\n  reg [63 : 0] k1_reg;\n  reg [63 : 0] k1_new;\n  reg [63 : 0] kp_reg;\n  reg [63 : 0] kp_new;\n  reg          k_we;\n\n  reg          ready_reg;\n  reg          ready_new;\n  reg          ready_we;\n\n  reg [63 : 0] state_reg;\n  reg [63 : 0] state_new;\n  reg          state_we;\n\n  reg [63 : 0] r3_reg;\n  reg [63 : 0] r3_new;\n\n  reg [63 : 0] r8_reg;\n  reg [63 : 0] r8_new;\n\n  reg [63 : 0] mr_reg;\n  reg [63 : 0] mr_new;\n\n  reg [2 : 0]  core_ctrl_reg;\n  reg [2 : 0]  core_ctrl_new;\n  reg          core_ctrl_we;\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg init_state;\n  reg update_state;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign ready  = ready_reg;\n  assign result = state_reg;\n\n\n  //----------------------------------------------------------------\n  // Internal functions.\n  //----------------------------------------------------------------\n//`include \"prince_round_functions.vh\"\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //\n  // Update functionality for all registers in the core.\n  // All registers are positive edge triggered with asynchronous\n  // active low reset.\n  //----------------------------------------------------------------\n  always @ (posedge clk or negedge reset_n)\n    begin: reg_update\n      if (!reset_n)\n        begin\n          ready_reg     <= 1'h1;\n          k0_reg        <= 64'h0;\n          k1_reg        <= 64'h0;\n          kp_reg        <= 64'h0;\n          r3_reg        <= 64'h0;\n          r8_reg        <= 64'h0;\n          mr_reg        <= 64'h0;\n          state_reg     <= 64'h0;\n          core_ctrl_reg <= CTRL_IDLE;\n        end\n      else\n        begin\n          r3_reg <= r3_new;\n          r8_reg <= r8_new;\n          mr_reg <= mr_new;\n\n          if (ready_we)\n            ready_reg <= ready_new;\n\n          if (state_we)\n            state_reg <= state_new;\n\n          if (k_we)\n            begin\n              k0_reg <= k0_new;\n              k1_reg <= k1_new;\n              kp_reg <= kp_new;\n            end\n\n          if (core_ctrl_we)\n            core_ctrl_reg <= core_ctrl_new;\n        end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // prince_core_dp\n  //\n  // Datapath with state update logic.\n  //----------------------------------------------------------------\n  always @*\n    begin : prince_core_dp\n\n      reg [63 : 0] core_input;\n      reg [63 : 0] core_output;\n\n      reg [63 : 0] r0;\n      reg [63 : 0] r1;\n      reg [63 : 0] r2;\n      reg [63 : 0] r4;\n      reg [63 : 0] r5;\n      reg [63 : 0] r6;\n      reg [63 : 0] r7;\n      reg [63 : 0] r9;\n      reg [63 : 0] r10;\n      reg [63 : 0] r11;\n\n      state_new = 64'h0;\n      state_we  = 1'h0;\n      k0_new    = 64'h0;\n      k1_new    = 64'h0;\n      kp_new    = 64'h0;\n      k_we      = 1'h0;\n\n\n      // Pipeline stages.\n      core_input = state_reg ^ k0_reg;\n      r0 = round0(core_input, k1_reg);\n      r1 = round(r0, k1_reg, 1);\n      r2 = round(r1, k1_reg, 2);\n      r3_new = round(r2, k1_reg, 3);\n\n      r4 = round(r3_reg, k1_reg, 4);\n      r5 = round(r4, k1_reg, 5);\n      mr_new = middle_round(r5);\n\n      r6 = iround(mr_reg, k1_reg, 6);\n      r7 = iround(r6, k1_reg, 7);\n      r8_new = iround(r7, k1_reg, 8);\n\n      r9  = iround(r8_reg, k1_reg, 9);\n      r10 = iround(r9, k1_reg, 10);\n      r11 = round11(r10, k1_reg);\n      core_output = r11 ^ kp_reg;\n\n\n      if (init_state)\n        begin\n          k_we      = 1'h1;\n          state_new = block;\n          state_we  = 1'h1;\n\n          if (encdec)\n            begin\n              k0_new = key[127 : 64];\n              kp_new = {k0_new[0], k0_new[63 : 2], (k0_new[1] ^ k0_new[63])};\n              k1_new = key[63 : 0];\n            end\n          else\n            begin\n              kp_new = key[127 : 64];\n              k0_new = {kp_new[0], kp_new[63 : 2], (kp_new[1] ^ kp_new[63])};\n              k1_new = key[63 : 0] ^ ALPHA;\n            end\n        end\n\n      if (update_state)\n        begin\n          state_new = core_output;\n          state_we  = 1'h1;\n        end\n    end // prince_core_dp\n\n\n  //----------------------------------------------------------------\n  // prince_core_ctrl\n  //\n  // Control FSM for aes core.\n  //----------------------------------------------------------------\n  always @*\n    begin : prince_core_ctrl\n      ready_new     = 1'h0;\n      ready_we      = 1'h0;\n      init_state    = 1'h0;\n      update_state  = 1'h0;\n      core_ctrl_new = CTRL_IDLE;\n      core_ctrl_we  = 1'h0;\n\n      case (core_ctrl_reg)\n        CTRL_IDLE:\n          begin\n            if (next)\n              begin\n                ready_new     = 1'h0;\n                ready_we      = 1'h1;\n                init_state    = 1'h1;\n                core_ctrl_new = CTRL_PIPE0;\n                core_ctrl_we  = 1'h1;\n              end\n          end\n\n        CTRL_PIPE0:\n          begin\n            core_ctrl_new = CTRL_PIPE1;\n            core_ctrl_we  = 1'h1;\n          end\n\n        CTRL_PIPE1:\n          begin\n            core_ctrl_new = CTRL_PIPE2;\n            core_ctrl_we  = 1'h1;\n          end\n\n        CTRL_PIPE2:\n          begin\n            core_ctrl_new = CTRL_UPDATE;\n            core_ctrl_we  = 1'h1;\n          end\n\n        CTRL_UPDATE:\n          begin\n            ready_new     = 1'h1;\n            ready_we      = 1'h1;\n            update_state  = 1'h1;\n            core_ctrl_new = CTRL_IDLE;\n            core_ctrl_we  = 1'h1;\n          end\n\n        default:\n          begin\n          end\n      endcase // case (core_ctrl_reg)\n    end // prince_core_ctrl\n\nendmodule // prince_core\n\n//======================================================================\n// EOF prince_core.v\n//======================================================================", "rtl/prince_round_functions.vh": "//======================================================================\n//\n// prince_round_functions.v\n// ------------------------\n// Functions used in the prince core.\n//\n//\n// Author: Joachim Strombergson\n// Copyright (c) 2023, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\n  function [3 : 0] sb(input [3 : 0] x);\n    case(x)\n      4'h0: sb = 4'hb;\n      4'h1: sb = 4'hf;\n      4'h2: sb = 4'h3;\n      4'h3: sb = 4'h2;\n      4'h4: sb = 4'ha;\n      4'h5: sb = 4'hc;\n      4'h6: sb = 4'h9;\n      4'h7: sb = 4'h1;\n      4'h8: sb = 4'h6;\n      4'h9: sb = 4'h7;\n      4'ha: sb = 4'h8;\n      4'hb: sb = 4'h0;\n      4'hc: sb = 4'he;\n      4'hd: sb = 4'h5;\n      4'he: sb = 4'hd;\n      4'hf: sb = 4'h4;\n    endcase // case (x)\n  endfunction // sb\n\n  function [63 : 0] s(input [63 : 0] x);\n    s = {sb(x[63 : 60]), sb(x[59 : 56]),\n         sb(x[55 : 52]), sb(x[51 : 48]),\n         sb(x[47 : 44]), sb(x[43 : 40]),\n         sb(x[39 : 36]), sb(x[35 : 32]),\n         sb(x[31 : 28]), sb(x[27 : 24]),\n         sb(x[23 : 20]), sb(x[19 : 16]),\n         sb(x[15 : 12]), sb(x[11 : 08]),\n         sb(x[07 : 04]), sb(x[03 : 00])};\n  endfunction // s\n\n  function [3 : 0] isb(input [3 : 0] x);\n    case(x)\n      4'h0: isb = 4'hb;\n      4'h1: isb = 4'h7;\n      4'h2: isb = 4'h3;\n      4'h3: isb = 4'h2;\n      4'h4: isb = 4'hf;\n      4'h5: isb = 4'hd;\n      4'h6: isb = 4'h8;\n      4'h7: isb = 4'h9;\n      4'h8: isb = 4'ha;\n      4'h9: isb = 4'h6;\n      4'ha: isb = 4'h4;\n      4'hb: isb = 4'h0;\n      4'hc: isb = 4'h5;\n      4'hd: isb = 4'he;\n      4'he: isb = 4'hc;\n      4'hf: isb = 4'h1;\n    endcase // case (x)\n  endfunction // isb\n\n  function [63 : 0] si(input [63 : 0] x);\n    si = {isb(x[63 : 60]), isb(x[59 : 56]),\n          isb(x[55 : 52]), isb(x[51 : 48]),\n          isb(x[47 : 44]), isb(x[43 : 40]),\n          isb(x[39 : 36]), isb(x[35 : 32]),\n          isb(x[31 : 28]), isb(x[27 : 24]),\n          isb(x[23 : 20]), isb(x[19 : 16]),\n          isb(x[15 : 12]), isb(x[11 : 08]),\n          isb(x[07 : 04]), isb(x[03 : 00])};\n  endfunction // si\n\n  function [63 : 0] rc(input [3 : 0] round);\n    begin\n      case(round)\n        00: rc = 64'h0000000000000000;\n        01: rc = 64'h13198a2e03707344;\n        02: rc = 64'ha4093822299f31d0;\n        03: rc = 64'h082efa98ec4e6c89;\n        04: rc = 64'h452821e638d01377;\n        05: rc = 64'hbe5466cf34e90c6c;\n        06: rc = 64'h7ef84f78fd955cb1;\n        07: rc = 64'h85840851f1ac43aa;\n        08: rc = 64'hc882d32f25323c54;\n        09: rc = 64'h64a51195e0e3610d;\n        10: rc = 64'hd3b5a399ca0c2399;\n        11: rc = 64'hc0ac29b7c97c50dd;\n        default:\n          rc = 64'h0;\n      endcase // case (round)\n    end\n  endfunction // rc\n\n  function [63 : 0] mp(input [63 : 0] b);\n    begin\n      mp[63] = b[59] ^ b[55] ^ b[51];\n      mp[62] = b[62] ^ b[54] ^ b[50];\n      mp[61] = b[61] ^ b[57] ^ b[49];\n      mp[60] = b[60] ^ b[56] ^ b[52];\n      mp[59] = b[63] ^ b[59] ^ b[55];\n      mp[58] = b[58] ^ b[54] ^ b[50];\n      mp[57] = b[61] ^ b[53] ^ b[49];\n      mp[56] = b[60] ^ b[56] ^ b[48];\n      mp[55] = b[63] ^ b[59] ^ b[51];\n      mp[54] = b[62] ^ b[58] ^ b[54];\n      mp[53] = b[57] ^ b[53] ^ b[49];\n      mp[52] = b[60] ^ b[52] ^ b[48];\n      mp[51] = b[63] ^ b[55] ^ b[51];\n      mp[50] = b[62] ^ b[58] ^ b[50];\n      mp[49] = b[61] ^ b[57] ^ b[53];\n      mp[48] = b[56] ^ b[52] ^ b[48];\n      mp[47] = b[47] ^ b[43] ^ b[39];\n      mp[46] = b[42] ^ b[38] ^ b[34];\n      mp[45] = b[45] ^ b[37] ^ b[33];\n      mp[44] = b[44] ^ b[40] ^ b[32];\n      mp[43] = b[47] ^ b[43] ^ b[35];\n      mp[42] = b[46] ^ b[42] ^ b[38];\n      mp[41] = b[41] ^ b[37] ^ b[33];\n      mp[40] = b[44] ^ b[36] ^ b[32];\n      mp[39] = b[47] ^ b[39] ^ b[35];\n      mp[38] = b[46] ^ b[42] ^ b[34];\n      mp[37] = b[45] ^ b[41] ^ b[37];\n      mp[36] = b[40] ^ b[36] ^ b[32];\n      mp[35] = b[43] ^ b[39] ^ b[35];\n      mp[34] = b[46] ^ b[38] ^ b[34];\n      mp[33] = b[45] ^ b[41] ^ b[33];\n      mp[32] = b[44] ^ b[40] ^ b[36];\n      mp[31] = b[31] ^ b[27] ^ b[23];\n      mp[30] = b[26] ^ b[22] ^ b[18];\n      mp[29] = b[29] ^ b[21] ^ b[17];\n      mp[28] = b[28] ^ b[24] ^ b[16];\n      mp[27] = b[31] ^ b[27] ^ b[19];\n      mp[26] = b[30] ^ b[26] ^ b[22];\n      mp[25] = b[25] ^ b[21] ^ b[17];\n      mp[24] = b[28] ^ b[20] ^ b[16];\n      mp[23] = b[31] ^ b[23] ^ b[19];\n      mp[22] = b[30] ^ b[26] ^ b[18];\n      mp[21] = b[29] ^ b[25] ^ b[21];\n      mp[20] = b[24] ^ b[20] ^ b[16];\n      mp[19] = b[27] ^ b[23] ^ b[19];\n      mp[18] = b[30] ^ b[22] ^ b[18];\n      mp[17] = b[29] ^ b[25] ^ b[17];\n      mp[16] = b[28] ^ b[24] ^ b[20];\n      mp[15] = b[11] ^ b[07] ^ b[03];\n      mp[14] = b[14] ^ b[06] ^ b[02];\n      mp[13] = b[13] ^ b[09] ^ b[01];\n      mp[12] = b[12] ^ b[08] ^ b[04];\n      mp[11] = b[15] ^ b[11] ^ b[07];\n      mp[10] = b[10] ^ b[06] ^ b[02];\n      mp[09] = b[13] ^ b[05] ^ b[01];\n      mp[08] = b[12] ^ b[08] ^ b[00];\n      mp[07] = b[15] ^ b[11] ^ b[03];\n      mp[06] = b[14] ^ b[10] ^ b[06];\n      mp[05] = b[09] ^ b[05] ^ b[01];\n      mp[04] = b[12] ^ b[04] ^ b[00];\n      mp[03] = b[15] ^ b[07] ^ b[03];\n      mp[02] = b[14] ^ b[10] ^ b[02];\n      mp[01] = b[13] ^ b[09] ^ b[05];\n      mp[00] = b[08] ^ b[04] ^ b[00];\n    end\n  endfunction // mp\n\n  function [63 : 0] m(input [63 : 0] b);\n    begin : m_func\n      reg [63 : 0] t;\n      t = mp(b);\n\n      m = {t[63 : 60], t[43 : 40], t[23 : 20], t[03 : 00],\n           t[47 : 44], t[27 : 24], t[07 : 04], t[51 : 48],\n           t[31 : 28], t[11 : 08], t[55 : 52], t[35 : 32],\n           t[15 : 12], t[59 : 56], t[39 : 36], t[19 : 16]};\n    end\n  endfunction // m\n\n  function [63 : 0] mi(input [63 : 0] b);\n    begin : mi_func\n      reg [63 : 0] t;\n\n      t = {b[63 : 60], b[11 : 08], b[23 : 20], b[35 : 32],\n           b[47 : 44], b[59 : 56], b[07 : 04], b[19 : 16],\n           b[31 : 28], b[43 : 40], b[55 : 52], b[03 : 00],\n           b[15 : 12], b[27 : 24], b[39 : 36], b[51 : 48]};\n\n      mi = mp(t);\n    end\n  endfunction // m\n\n  function [63 : 0] round0(input [63 : 0] b, input [63 : 0] k);\n    begin\n      round0 = b ^ k ^ rc(0);\n    end\n  endfunction // round0\n\n  function [63 : 0] round11(input [63 : 0] b, input [63 : 0] k);\n    begin\n      round11 =  b ^ k ^ rc(11);\n    end\n  endfunction // round11\n\n  function [63 : 0] round(input [63 : 0] b, input [63 : 0] k, input [3 : 0] n);\n    begin\n      round = m(s(b)) ^ rc(n) ^ k;\n    end\n  endfunction // round\n\n  function [63 : 0] middle_round(input [63 : 0] b);\n    begin\n      middle_round = si(mp(s(b)));\n    end\n  endfunction // middle_round\n\n  function [63 : 0] iround(input [63 : 0] b, input [63 : 0] k, input [3 : 0] n);\n    begin\n      iround = si(mi(rc(n) ^ k ^ b));\n    end\n  endfunction // iround\n\n//======================================================================\n// EOF prince_round_functions.vh\n//======================================================================", "verif/prince_core_update_state_safety_check.sv": "module prince_core_update_state_safety_check (\n    input wire           clk,\n    input wire           reset_n,\n    input wire           encdec,\n    input wire           next,\n    output wire          ready,\n    input wire [127 : 0] key,\n    input wire [63 : 0]  block,\n    output wire [63 : 0] result\n);\n\n    prince_core dut (\n        .clk(clk),\n        .reset_n(reset_n),\n        .encdec(encdec),\n        .next(next),\n        .ready(ready),\n        .key(key),\n        .block(block),\n        .result(result)\n    );\n\nendmodule : prince_core_update_state_safety_check"}}, "output": {"response": "", "context": {"verif/prince_core_update_state_safety_check.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    image: verification_image\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/verif/prince_core_update_state_safety_check.sv /code/rtl/prince_core.v /code/rtl/prince_round_functions.vh\nTOPLEVEL        = prince_core_update_state_safety_check\nMODULE          = test_prince_core\nPYTHONPATH      = /src\nHASH            = b7f087632e76423cb75981b16e6e9aa1018f78d1", "src/coverage.py": "from cocotb.runner import get_runner\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_clear():\n    covt_report_file=\"/code/rundir/coverage.log\"\n    if os.path.isfile(covt_report_file):\n        os.remove(covt_report_file)\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "\nfrom cocotb.binary import BinaryValue\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\n\nCLK_HALF_PERIOD = 1\nCLK_PERIOD = CLK_HALF_PERIOD * 2\nCLK_TIME_UNIT = 'ns'\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def init_sim(dut):\n    dut.reset_n.value = 1\n    dut.encdec.value = 0\n    dut.next.value = 0\n    dut.key.value = 0\n    dut.block.value = 0\n\nasync def reset_dut(dut):\n    dut.reset_n.value = 0\n    await Timer(2 * CLK_PERIOD, units=CLK_TIME_UNIT)\n    dut.reset_n.value = 1\n\nasync def wait_ready(dut):\n    while dut.ready.value.integer != 1:\n        await FallingEdge(dut.clk)\n\nasync def block_test(dut, key: BinaryValue, block: BinaryValue, ciphertext: BinaryValue):\n    dut.key.value = key\n    dut.encdec.value = 1\n    dut.block.value = block\n    dut.next.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.next.value = 0\n    await wait_ready(dut)\n\n    assert dut.result.value == ciphertext, \"didn't get the expected ciphertext result\"\n\n    dut.block.value = ciphertext\n    dut.encdec.value = 0\n    dut.next.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.next.value = 0\n    await wait_ready(dut)\n\n    assert dut.result.value == block, \"didn't get the expected block result\"\n", "src/test_prince_core.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.binary import BinaryValue\nimport harness_library as hrs_lb\n\n\n@cocotb.test()\nasync def test_dut(dut):\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_dut...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    # test(1, 128'h00000000_00000000_00000000_00000000,\n    #      64'h00000000_00000000, 64'h818665aa_0d02dfda);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('00000000000000000000000000000000', 16), 128, False),\n        BinaryValue(int('0000000000000000', 16), 64, False),\n        BinaryValue(int('818665aa0d02dfda', 16), 64, False)\n    )\n\n    # test(2, 128'h00000000_00000000_00000000_00000000,\n    #      64'hffffffff_ffffffff, 64'h604ae6ca_03c20ada);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('00000000000000000000000000000000', 16), 128, False),\n        BinaryValue(int('ffffffffffffffff', 16), 64, False),\n        BinaryValue(int('604ae6ca03c20ada', 16), 64, False)\n    )\n\n    # test(3, 128'hffffffff_ffffffff_00000000_00000000,\n    #      64'h00000000_00000000, 64'h9fb51935_fc3df524);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('ffffffffffffffff0000000000000000', 16), 128, False),\n        BinaryValue(int('0000000000000000', 16), 64, False),\n        BinaryValue(int('9fb51935fc3df524', 16), 64, False)\n    )\n\n    # test(4, 128'h00000000_00000000_ffffffff_ffffffff,\n    #      64'h00000000_00000000, 64'h78a54cbe_737bb7ef);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0000000000000000ffffffffffffffff', 16), 128, False),\n        BinaryValue(int('0000000000000000', 16), 64, False),\n        BinaryValue(int('78a54cbe737bb7ef', 16), 64, False)\n    )\n\n    # test(5, 128'h00000000_00000000_fedcba98_76543210,\n    #      64'h01234567_89abcdef, 64'hae25ad3c_a8fa9ccf);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0000000000000000fedcba9876543210', 16), 128, False),\n        BinaryValue(int('0123456789abcdef', 16), 64, False),\n        BinaryValue(int('ae25ad3ca8fa9ccf', 16), 64, False)\n    )\n\n    # test(6, 128'h00112233_44556677_8899aabb_ccddeeff,\n    #      64'h01234567_89abcdef, 64'hd6dcb597_8de756ee);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('00112233445566778899aabbccddeeff', 16), 128, False),\n        BinaryValue(int('0123456789abcdef', 16), 64, False),\n        BinaryValue(int('d6dcb5978de756ee', 16), 64, False)\n    )\n\n    # test(7, 128'h01122334_45566778_899aabbc_cddeeff0,\n    #      64'h01234567_89abcdef, 64'h392f599f_46761cd3);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0112233445566778899aabbccddeeff0', 16), 128, False),\n        BinaryValue(int('0123456789abcdef', 16), 64, False),\n        BinaryValue(int('392f599f46761cd3', 16), 64, False)\n    )\n\n    # test(8, 128'h01122334_45566778_899aabbc_cddeeff0,\n    #      64'hf0123456_789abcde, 64'h4fb5e332_b9b409bb);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0112233445566778899aabbccddeeff0', 16), 128, False),\n        BinaryValue(int('f0123456789abcde', 16), 64, False),\n        BinaryValue(int('4fb5e332b9b409bb', 16), 64, False)\n    )\n\n    #\n    # test(9, 128'hd8cdb780_70b4c55a_818665aa_0d02dfda,\n    #      64'h69c4e0d8_6a7b0430, 64'h43c6b256_d79de7e8);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('d8cdb78070b4c55a818665aa0d02dfda', 16), 128, False),\n        BinaryValue(int('69c4e0d86a7b0430', 16), 64, False),\n        BinaryValue(int('43c6b256d79de7e8', 16), 64, False)\n    )\n\n    cocotb.log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nimport pytest\nimport coverage\nimport random\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef call_runner():\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.covt_report_clear()\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter={}\n        )\n        coverage.coverage_report(\"assertion\")\n        coverage.covt_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n    # Run the simulation\n    call_runner()\n"}}}
{"id": "cvdp_copilot_csr_using_apb_0005", "categories": ["cid012", "medium"], "input": {"prompt": "Write a SystemVerilog testbench to only generate stimulus for a `csr_apb_interface` module, which is responsible for data transactions over the Advanced Peripheral Bus (APB) interface.\n\n## Interface: **csr_using_apb**\n\n**Clock & Reset**:\n`pclk`: APB clock input for synchronous operations.\n`presetn`: Active-low asynchronous reset signal, used to initialize the system.\n\n**Inputs & Outputs Ports**:\n**APB Signals:**\n`paddr` (input, 32 bits): Address bus to access the internal CSR registers.\n`pselx` (input): APB select signal, indicates CSR selection.\n`penable` (input): APB enable signal, signals transaction progression.\n`pwrite` (input): Write enable signal, differentiating read and write operations.\n`pwdata` (input, 32 bits): Write data bus to send data to CSR registers.\n`pready` (output, reg): Ready signal indicating transaction completion.\n`prdata` (output, reg, 32 bits): Read data bus for CSR data retrieval.\n`pslverr` (output, reg): Error signal for invalid addresses or unsupported operations.\n\n**Internal Registers**:\n\n`DATA_REG (0x10)`: Stores two 10-bit values, data1 and data2, and a 12-bit reserved section.\n`CONTROL_REG (0x14)`: Contains a control enable bit, mode bit, and 30 reserved bits.\n`INTERRUPT_REG (0x18)`: Holds interrupt enable flags for various conditions and 28 reserved bits.\n\n## Specifications\n\n**Read Operations**:\n\n- During the READ_STATE, assert pready and load prdata with the register value based on paddr.\n\n- Return to IDLE after asserting pready for one cycle.\n\n**Write Operations**:\n\n- During the WRITE_STATE, assert pready and update the register selected by paddr with pwdata.\n\n- For DATA_REG, split pwdata into fields for data1, data2, and the reserved section.\n\n- For CONTROL_REG and INTERRUPT_REG, update only specified bits.\n\n- Return to IDLE after asserting pready for one cycle.\n\n**Reset Behavior**:\n\n- On presetn deassertion, reset all outputs and internal registers to their default values:\n\n- Set pready and pslverr to 0.\n\n- Clear prdata.\n\n- Initialize data1, data2, overflow_ie, sign_ie, parity_ie, and zero_ie to 0.\n\n---\n\n## **Testbench Requirements**\n### **Instantiation**\n- **Module Instance:** The **csr_apb_interface** module is instantiated as `uut`, with all input and output signals connected.\n\n---\n\n### **Input Generation**\n#### **1. Writing to `DATA_REG`**\n- The testbench writes a **random 32-bit value** to `DATA_REG`.\n\n#### **2. Reading from `DATA_REG`**\n- A read operation is performed from `DATA_REG`.\n\n#### **3. Writing and Reading from `CONTROL_REG`**\n- A **random 32-bit value** is written to `CONTROL_REG`.\n- The value is read back.\n\n#### **4. Writing and Reading from `INTERRUPT_REG`**\n- A **random 32-bit value** is written to `INTERRUPT_REG`.\n- The value is read back.\n\n#### **5. Invalid Address Access**\n- A write is attempted to an **unknown address (`0x20`)**.\n\n#### **6. Read Transaction Without `pselx` Asserted**\n- A read is attempted from `DATA_REG` **without asserting `pselx`**.\n\n#### **7. Write Transaction Without `penable` Asserted**\n- A write is performed to `CONTROL_REG` **without `penable` assertion**.\n\n#### **8. Corner Cases for Write Data**\n- **All 1s (`0xFFFFFFFF`)** and **all 0s (`0x00000000`)** are written to `DATA_REG`.\n\n#### **9. Reset Behavior**\n- The reset signal (`presetn = 0`) is applied in the middle of operations.\n\n---", "context": {}}, "output": {"response": "", "context": {"verif/csr_apb_interface_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 27d0484bbda710c62a7f87ce0a03f0926a77d91b\nTARGET = 90", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/csr_apb_interface.sv": "`timescale 1ns / 1ps\nmodule csr_apb_interface (\n    input                    pclk,              // Clock input for synchronization\n    input                    presetn,           // Active-low asynchronous reset input\n    input [31:0]             paddr,             // APB address bus, 32-bit for register addressing\n    input                    pselx,             // APB peripheral select signal\n    input                    penable,           // APB enable signal for transactions\n    input                    pwrite,            // APB write enable signal\n    input [31:0]             pwdata,            // APB write data bus\n\n    output reg               pready,            // APB ready signal, indicates end of transaction\n    output reg [31:0]        prdata,            // APB read data bus\n    output reg               pslverr            // APB slave error signal\n);\n\n    // Define register addresses\n    localparam DATA_REG      = 32'h10; // Data register\n    localparam CONTROL_REG   = 32'h14; // Control register\n    localparam INTERRUPT_REG = 32'h18; // Interrupt configuration register\n\n    // Define state machine states\n    localparam IDLE          = 2'b00;\n    localparam SETUP         = 2'b01;\n    localparam READ_STATE    = 2'b10;\n    localparam WRITE_STATE   = 2'b11;\n\n    // Internal state registers\n    reg [1:0]                present_state, next_state;\n\n    // Signals for state transitions and outputs\n    reg                      next_pready;\n    reg [31:0]               next_prdata;\n    reg                      next_pslverr;\n\n    // Internal storage registers and next-state values\n    reg [9:0]                data1, next_data1;\n    reg [9:0]                data2, next_data2;\n    reg [11:0]               data_reserived, data_next_reserived;\n\n    // Control register bits and their next-state values\n    reg                      enable;            // Control register: Enable bit\n    reg                      mode;              // Control register: Mode selection bit\n    reg [29:0]               CONTROL_reserived; // Reserved bits in control register\n\n    // Interrupt flags and next-state values\n    reg                      overflow_ie, next_overflow_ie;\n    reg                      sign_ie, next_sign_ie;\n    reg                      parity_ie, next_parity_ie;\n    reg                      zero_ie, next_zero_ie;\n    reg [27:0]               INTERRUPT_reserived, next_INTERRUPT_reserived;\n\n    // Combinational logic to determine next state and outputs\n    always @ (*) begin\n        // Set default values for the next state outputs\n        next_pready = pready;\n        next_prdata = prdata;\n        next_pslverr = pslverr;\n\n        next_data1 = data1;\n        next_data2 = data2;\n        next_overflow_ie = overflow_ie;\n        next_sign_ie = sign_ie;\n        next_parity_ie = parity_ie;\n        next_zero_ie = zero_ie;\n        next_state = present_state;\n        next_INTERRUPT_reserived = INTERRUPT_reserived;\n        data_next_reserived = data_reserived;\n\n        // State machine handling APB interface operations\n        case (present_state)\n            IDLE: begin\n                if (pselx)\n                    next_state = SETUP; // Transition to setup on select\n            end\n            \n            SETUP: begin\n                if (penable && pwrite)\n                    next_state = WRITE_STATE; // Handle write transactions\n                else if (penable)\n                    next_state = READ_STATE; // Handle read transactions\n            end\n\n            READ_STATE: begin\n                if (pready) begin\n                    next_state = IDLE; // Return to IDLE after read\n                    next_pready = 1'b0;\n                end else begin\n                    next_pready = 1'b1;\n                    case (paddr) // Output data based on address\n                        DATA_REG:      next_prdata = {data_reserived, data1, data2};\n                        CONTROL_REG:   next_prdata = {CONTROL_reserived, enable, mode};\n                        INTERRUPT_REG: next_prdata = {INTERRUPT_reserived, overflow_ie, sign_ie, parity_ie, zero_ie};\n                        default:       next_pslverr = 1'b1; // Unknown address error\n                    endcase\n                end\n            end\n\n            WRITE_STATE: begin\n                if (pready) begin\n                    next_state = IDLE; // Return to IDLE after write\n                    next_pready = 1'b0;\n                end else begin\n                    next_pready = 1'b1;\n                    case (paddr) // Handle data based on address\n                        DATA_REG: begin\n                            next_data1 = pwdata[19:10];\n                            next_data2 = pwdata[9:0];\n                            data_next_reserived = pwdata[31:20];\n                        end\n                        CONTROL_REG: begin\n                            enable = pwdata[1];\n                            mode = pwdata[0];\n                            CONTROL_reserived = pwdata[31:2];\n                        end\n                        INTERRUPT_REG: begin\n                            next_overflow_ie = pwdata[3];\n                            next_sign_ie = pwdata[2];\n                            next_parity_ie = pwdata[1];\n                            next_zero_ie = pwdata[0];\n                            next_INTERRUPT_reserived = pwdata[31:4];\n                        end\n                        default: next_pslverr = 1'b1; \n                    endcase\n                end\n            end\n        endcase\n    end\n\n    // Sequential logic to update state and outputs at clock edges or reset\n    always @ (posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            // Initialize registers on reset\n            pready          <= 1'b0;\n            prdata          <= 32'h0;\n            pslverr         <= 1'b0;\n\n            data1           <= 10'd0;\n            data2           <= 10'd0;\n            overflow_ie     <= 1'b0;\n            sign_ie         <= 1'b0;\n            parity_ie       <= 1'b0;\n            zero_ie         <= 1'b0;\n            INTERRUPT_reserived       <= 28'b0;\n            data_reserived       <= 12'b0;\n\n            present_state   <= IDLE;\n        end else begin\n            // Update internal state and outputs based on next state values\n            pready          <= next_pready;\n            prdata          <= next_prdata;\n            pslverr         <= next_pslverr;\n\n            data1           <= next_data1;\n            data2           <= next_data2;\n            overflow_ie     <= next_overflow_ie;\n            sign_ie         <= next_sign_ie;\n            parity_ie       <= next_parity_ie;\n            zero_ie         <= next_zero_ie;\n            data_reserived  <= data_next_reserived;\n            INTERRUPT_reserived  <= next_INTERRUPT_reserived;\n\n            present_state   <= next_state;\n        end\n    end\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_decode_firstbit_0017", "categories": ["cid012", "medium"], "input": {"prompt": "Create a **testbench** to apply **stimulus** to the `cvdp_copilot_decode_firstbit` module. This module detects the first set bit in a **32-bit binary input** and outputs its position in either **binary or one-hot encoding**. The testbench must generate a diverse set of input patterns while ensuring compliance with the module\u2019s **clocking, reset, and pipeline behavior**.\n\n---\n\n### **Inputs:**\n\n- `Clk`: **1-bit clock signal**, toggling every **5 time units** (100MHz operation).\n- `Rst`: **Active-high reset signal** to initialize the module.\n- `In_Data`: **32-bit input bus** for data values.\n- `In_Valid`: **Signal indicating valid input data**.\n\n### **Outputs:**\n\n- `Out_FirstBit`: **Position of the first set bit** (Binary or One-Hot encoded).\n- `Out_Found`: **Indicates if a set bit was found**.\n- `Out_Valid`: **Indicates valid output data**.\n\n---\n\n### **Module Specifications for Stimulus Generation**\n\nThe `cvdp_copilot_decode_firstbit` module supports configurable first-bit detection with the following key parameters:\n\n- **Input Processing:**\n  - Detects **first set bit** from LSB to MSB.\n  - Supports **optional input registers (`InReg_g`)**.\n- **Output Processing:**\n  - Provides index in **Binary or One-Hot encoding (`OutputFormat_g`)**.\n  - Supports **optional output registers (`OutReg_g`)**.\n- **Pipeline Stages:**\n  - Configurable **pipeline registers (`PlRegs_g`)** for adjustable latency.\n- **Clock and Reset Behavior:**\n  - Operates on the **rising edge** of `Clk`.\n  - Initializes internal registers upon `Rst` assertion.\n\n---\n\n### **Instantiation**\n\nThe testbench must instantiate a single instance of the `cvdp_copilot_decode_firstbit` module with instantiation name `dut`:\n\n- **Decode First Bit Module (`dut`)**: Instantiated with the following parameter values:\n  - `InWidth_g = 32`\n  - `InReg_g = 0`\n  - `OutReg_g = 0`\n  - `PlRegs_g = 0`\n  - `OutputFormat_g = 0` (Binary Encoding)\n\n---\n\n### **Testbench Requirements**\n\nThe testbench must apply a **wide range of test patterns** covering various input scenarios:\n\n1. **Clock Generation:**\n   - `Clk` must toggle every **5 time units**, ensuring a **100MHz clock period**.\n\n2. **Reset Handling:**\n   - `Rst` must be **asserted at the beginning** of the simulation for **three cycles**.\n   - The module must be **initialized properly** before input stimulus is applied.\n\n3. **Stimulus Generation Strategy:**\n   - The testbench **must not verify outputs** (only generate inputs).\n   - Generate input patterns covering:\n     - **Single-bit set inputs**.\n     - **All-zero inputs**.\n     - **Multiple-bit patterns**.\n     - **Random bit patterns**.\n     - **First-bit at different positions**.\n     - **First and last bit set**.\n     - **Changing valid input sequences**.\n     - **Pipeline latency variations**.\n\n4. **Handling Consecutive and Random Inputs:**\n   - The testbench must ensure **continuous valid input scenarios** are covered.\n   - Include **randomized sequences** to simulate realistic DUT behavior.\n\n5. **Reset in Mid-Operation:**\n   - The testbench should **toggle reset during execution** to ensure the module properly re-initializes.\n\n---\n\n### **Coverage and Compliance**\n\n- The testbench must ensure **high coverage** across all input variations.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n- The **RTL should not be in context** but will be provided in `/harness/<issue number>/src/`.\n\n---\n\n### **Test Plan Overview**\n\n- **Basic input cases** (all zeros, single-bit set, multiple bits set).\n- **Timing-based tests** (handling valid input over consecutive cycles).\n- **Randomized patterns** to ensure robustness.\n- **Pipeline configuration tests** to validate latency effects.\n- **Reset handling** to verify re-initialization integrity.\n\nThis testbench should provide a **comprehensive input stimulus environment** for `cvdp_copilot_decode_firstbit`, ensuring correct operation across multiple configurations.\n\n---\n\n### **Note:**\n- The testbench **must only generate stimulus** without verifying outputs.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n- **Ensure the maximum possible input coverage** without adding assertions or comparisons.\n\nCan you implement a **SystemVerilog testbench** with the above stimulus requirements?\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_cvdp_copilot_decode_firstbit.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 17-tb-stimulus-generation\nTARGET = 90 ", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite\n\n# Merge multiple coverage databases\nmerge {test_*} -out merged_cov -overwrite \n\n# Load the merged coverage database\nload merged_cov\n\n# Generate a coverage report\nreport -text -out merged_cov_report.txts", "src/cvdp_copilot_decode_firstbit.sv": "module cvdp_copilot_decode_firstbit #(\n    parameter integer InWidth_g = 32,\n    parameter InReg_g = 1,\n    parameter OutReg_g = 1,\n    parameter integer PlRegs_g = 1,\n    parameter OutputFormat_g = 0  // 0: Binary, 1: One-Hot Encoding\n)(\n    input wire Clk,\n    input wire Rst,\n    input wire [InWidth_g-1:0] In_Data,\n    input wire In_Valid,\n\n    output reg [InWidth_g-1:0] Out_FirstBit,   // Binary index or one-hot bit\n    output reg Out_Found,\n    output reg Out_Valid\n);\n\n    // Local parameters\n    localparam integer BinBits_c = $clog2(InWidth_g);\n\n    // Internal signals\n    reg [InWidth_g-1:0] In_Data_r;\n    reg In_Valid_r;\n    reg [PlRegs_g:0] Valid_pipeline;\n    reg [PlRegs_g:0] Found_pipeline;\n    reg [BinBits_c-1:0] FirstBit_pipeline [PlRegs_g:0];\n    reg [InWidth_g-1:0] OneHotBit_pipeline [PlRegs_g:0];\n\n    // Optional input register\n    generate\n    if (InReg_g == 1) begin : input_reg_block\n        always @(posedge Clk or posedge Rst) begin\n            if (Rst) begin\n                In_Data_r <= {InWidth_g{1'b0}};\n                In_Valid_r <= 1'b0;\n            end else begin\n                In_Data_r <= In_Data;\n                In_Valid_r <= In_Valid;\n            end\n        end\n    end else begin : no_input_reg_block\n        always @(*) begin\n            In_Data_r = In_Data;\n            In_Valid_r = In_Valid;\n        end\n    end\n    endgenerate\n\n    // Function to find the index of the first '1' bit from LSB to MSB\n    function [BinBits_c-1:0] find_first_one(input [InWidth_g-1:0] data_in);\n        integer i;\n        reg found;\n        begin\n            find_first_one = {BinBits_c{1'b0}};\n            found = 0;\n            for (i = 0; i < InWidth_g; i = i + 1) begin\n                if (!found && data_in[i]) begin\n                    find_first_one = i[BinBits_c-1:0];\n                    found = 1;\n                end\n            end\n        end\n    endfunction\n\n    // Function to generate one-hot encoding of the first set bit\n    function [InWidth_g-1:0] one_hot_encode(input [BinBits_c-1:0] binary_index);\n        begin\n            one_hot_encode = {InWidth_g{1'b0}};\n            one_hot_encode[binary_index] = 1'b1;\n        end\n    endfunction\n\n    // Stage 0: Compute the first '1' bit position and its one-hot encoding\n    always @(posedge Clk or posedge Rst) begin\n        if (Rst) begin\n            Valid_pipeline[0] <= 1'b0;\n            Found_pipeline[0] <= 1'b0;\n            FirstBit_pipeline[0] <= {BinBits_c{1'b0}};\n            OneHotBit_pipeline[0] <= {InWidth_g{1'b0}};\n        end else begin\n            Valid_pipeline[0] <= In_Valid_r;\n            Found_pipeline[0] <= |In_Data_r;\n            if (|In_Data_r) begin\n                FirstBit_pipeline[0] <= find_first_one(In_Data_r);\n                OneHotBit_pipeline[0] <= one_hot_encode(find_first_one(In_Data_r));\n            end else begin\n                FirstBit_pipeline[0] <= {BinBits_c{1'b0}};\n                OneHotBit_pipeline[0] <= {InWidth_g{1'b0}};\n            end\n        end\n    end\n\n    // Pipeline stages\n    genvar k;\n    generate\n        for (k = 1; k <= PlRegs_g; k = k + 1) begin : pipeline_stages\n            always @(posedge Clk or posedge Rst) begin\n                if (Rst) begin\n                    Valid_pipeline[k] <= 1'b0;\n                    Found_pipeline[k] <= 1'b0;\n                    FirstBit_pipeline[k] <= {BinBits_c{1'b0}};\n                    OneHotBit_pipeline[k] <= {InWidth_g{1'b0}};\n                end else begin\n                    Valid_pipeline[k] <= Valid_pipeline[k-1];\n                    Found_pipeline[k] <= Found_pipeline[k-1];\n                    FirstBit_pipeline[k] <= FirstBit_pipeline[k-1];\n                    OneHotBit_pipeline[k] <= OneHotBit_pipeline[k-1];\n                end\n            end\n        end\n    endgenerate\n\n    // Optional output register\n    generate\n    if (OutReg_g == 1) begin : output_reg_block\n        always @(posedge Clk or posedge Rst) begin\n            if (Rst) begin\n                Out_Valid <= 1'b0;\n                Out_Found <= 1'b0;\n                Out_FirstBit <= {InWidth_g{1'b0}};\n            end else begin\n                Out_Valid <= Valid_pipeline[PlRegs_g];\n                Out_Found <= Found_pipeline[PlRegs_g];\n                if (OutputFormat_g == 0) begin\n                    // Binary encoding: Zero-extend to match width\n                    Out_FirstBit <= {{(InWidth_g - BinBits_c){1'b0}}, FirstBit_pipeline[PlRegs_g]};\n                end else begin\n                    // One-hot encoding\n                    Out_FirstBit <= OneHotBit_pipeline[PlRegs_g];\n                end\n            end\n        end\n    end else begin : no_output_reg_block\n        always @(*) begin\n            Out_Valid = Valid_pipeline[PlRegs_g];\n            Out_Found = Found_pipeline[PlRegs_g];\n            if (OutputFormat_g == 0) begin\n                // Binary encoding: Zero-extend to match width\n                Out_FirstBit = {{(InWidth_g - BinBits_c){1'b0}}, FirstBit_pipeline[PlRegs_g]};\n            end else begin\n                // One-hot encoding\n                Out_FirstBit = OneHotBit_pipeline[PlRegs_g];\n            end\n        end\n    end\n    endgenerate\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    # Check the process return code instead of just the object\n    sim_result = subprocess.run(cmd, shell=True)\n    assert sim_result.returncode == 0, \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    cov_result = subprocess.run(cmd, shell=True)\n    assert cov_result.returncode == 0, \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    # Start parsing from the third line to skip headers and separators\n    for line in lines[2:]:\n        info = line.split()\n\n        # Skip lines that don't have at least three columns\n        if len(info) < 3:\n            continue\n\n        # Skip lines if the second or third columns do not end with '%'\n        # (which indicates they do not contain valid coverage data)\n        if not info[1].endswith('%') or not info[2].endswith('%'):\n            continue\n\n        inst = info[0]\n        avg  = info[1]\n        cov  = info[2]\n\n        # Clean up instance name (remove special chars/pipes/dashes)\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics[inst] = {\n            \"Average\": float(avg[:-1]),   # remove '%' and convert to float\n            \"Covered\": float(cov[:-1])    # remove '%' and convert to float\n        }\n\n    # Finally, ensure the coverage for 'dut' is at least the target\n    assert metrics[\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_decoder_8b10b_0021", "categories": ["cid014", "easy"], "input": {"prompt": "We have an 8b10b decoder module, `decoder_8b10b`, which receives a 10\u2010bit input (`decoder_in`) and outputs an 8\u2010bit decoded value (`decoder_out`) plus a 1\u2010bit control flag (`control_out`). The decoder logic uses a `decode_8b10b()` function, mapping certain valid 10\u2010bit patterns to a specific 8\u2010bit code (and setting the control bit to `1`). Any 10\u2010bit pattern not recognized results in `control_out == 0` and `decoder_out == 8\u2019h00`.  \n\n| **10-bit Input**      | **8-bit Output** | **Symbol** | **DEC Value** | **HEX Value** |\n|-----------------------|------------------|------------|---------------|---------------|\n| 001111 0100           | 000 11100        | K.28.0     | 28            | 1C            |\n| 110000 1011           | 000 11100        | K.28.0     | 28            | 1C            |\n| 001111 1001           | 001 11100        | K.28.1     | 60            | 3C            |\n| 110000 0110           | 001 11100        | K.28.1     | 60            | 3C            |\n| 001111 0101           | 010 11100        | K.28.2     | 92            | 5C            |\n| 110000 1010           | 010 11100        | K.28.2     | 92            | 5C            |\n| 001111 0011           | 011 11100        | K.28.3     | 124           | 7C            |\n| 110000 1100           | 011 11100        | K.28.3     | 124           | 7C            |\n| 001111 0010           | 100 11100        | K.28.4     | 156           | 9C            |\n| 110000 1101           | 100 11100        | K.28.4     | 156           | 9C            |\n| 001111 1010           | 101 11100        | K.28.5     | 188           | BC            |\n| 110000 0101           | 101 11100        | K.28.5     | 188           | BC            |\n| 001111 0110           | 110 11100        | K.28.6     | 220           | DC            |\n| 110000 1001           | 110 11100        | K.28.6     | 220           | DC            |\n| 001111 1000           | 111 11100        | K.28.7     | 252           | FC            |\n| 110000 0111           | 111 11100        | K.28.7     | 252           | FC            |\n| 111010 1000           | 111 10111        | K.23.7     | 247           | F7            |\n| 000101 0111           | 111 10111        | K.23.7     | 247           | F7            |\n| 110110 1000           | 111 11011        | K.27.7     | 251           | FB            |\n| 001001 0111           | 111 11011        | K.27.7     | 251           | FB            |\n| 101110 1000           | 111 11101        | K.29.7     | 253           | FD            |\n| 010001 0111           | 111 11101        | K.29.7     | 253           | FD            |\n| 011110 1000           | 111 11110        | K.30.7     | 254           | FE            |\n| 100001 0111           | 111 11110        | K.30.7     | 254           | FE            |\n\nTo verify correct operation, we need two **Concurrent SystemVerilog assertions**:\n\n1. **Valid Output Range for Data Characters**  \n   If `control_out` is `0` (indicating a data character), then `decoder_out` must be within the valid 8-bit range (`8'h00` to `8'hFF`).  \n\n2. **Consistency Between Input and Output**  \n   If the input does not change between two consecutive clock cycles, then the output (`decoder_out` and `control_out`) must remain the same.  \n\nThese assertions ensure that the decoder behaves predictably and produces valid outputs for control characters while maintaining consistency for repeated inputs.\n\n---\n\n### **Inputs**:\n- `clk_in`: Positive\u2010edge clock.  \n- `reset_in`: Asynchronous reset (active high).  \n- `decoder_in[9:0]`: The 10\u2010bit encoded input to be decoded.\n\n### **Outputs**:\n- `decoder_out[7:0]`: The decoded 8\u2010bit output.  \n- `control_out`: Indicates if the decoded word is a recognized control code (`1`) or data (`0`).", "context": {"rtl/decoder_8b10b.sv": "module decoder_8b10b (\n    input  logic        clk_in,       // trigger on rising edge\n    input  logic        reset_in,     // reset_in, assert HI\n    input  logic [9:0]  decoder_in,   // 10bit input\n    output logic [7:0]  decoder_out,  // 8bit decoded output\n    output logic        control_out   // control char, assert HI for control words\n);\n\n    logic [9:0] s_in_10b_reg;  \n    logic [7:0] s_decoder_out; \n    logic       s_control_out;       \n\n    function automatic [8:0] decode_8b10b(input logic [9:0] in);\n        case (in)\n            // recognized patterns => top bit=1 (control_out), plus 8-bit code\n            10'b0011110100, 10'b1100001011: decode_8b10b = {1'b1, 8'h1C};\n            10'b0011110010, 10'b1100001101: decode_8b10b = {1'b1, 8'h9C};\n            10'b0011111000, 10'b1100000111: decode_8b10b = {1'b1, 8'hFC};\n            10'b1110101000, 10'b0001010111: decode_8b10b = {1'b1, 8'hF7};\n            10'b1101101000, 10'b0010010111: decode_8b10b = {1'b1, 8'hFB};\n            10'b1011101000, 10'b0100010111: decode_8b10b = {1'b1, 8'hFD};\n            10'b0111101000, 10'b1000010111: decode_8b10b = {1'b1, 8'hFE};\n            10'b0011111001, 10'b1100000110: decode_8b10b = {1'b1, 8'h3C};\n            10'b0011110101, 10'b1100001010: decode_8b10b = {1'b1, 8'h5C};\n            10'b0011110011, 10'b1100001100: decode_8b10b = {1'b1, 8'h7C};\n            10'b0011111010, 10'b1100000101: decode_8b10b = {1'b1, 8'hBC};\n            10'b0011110110, 10'b1100001001: decode_8b10b = {1'b1, 8'hDC};\n\n            // unrecognized pattern => top bit=0 (control_out=0), decoded=0\n            default: decode_8b10b = {1'b0, 8'b00000000};\n        endcase\n    endfunction\n\n    always_comb begin\n        {s_control_out, s_decoder_out} = decode_8b10b(s_in_10b_reg);\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            s_in_10b_reg <= 10'b0000000000;\n        end \n        else begin\n            s_in_10b_reg <= decoder_in;\n        end\n    end\n\n    assign decoder_out = s_decoder_out;\n    assign control_out = s_control_out;\nendmodule"}}, "output": {"response": "", "context": {"rtl/decoder_8b10b.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/decoder_8b10b.sv\nTOPLEVEL        = decoder_8b10b\nMODULE          = test_decoder_8b10b\nPYTHONPATH      = /src\nHASH            = 0c1a9be8b0ee7149733e3d41644a4879aa18e399\n", "src/test_decoder_8b10b.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nfrom collections import deque\n\n# Special character code values\nK28d0_RD0 = \"0011110100\"\nK28d0_RD1 = \"1100001011\"\nK28d1_RD0 = \"0011111001\"\nK28d1_RD1 = \"1100000110\"\nK28d2_RD0 = \"0011110101\"\nK28d2_RD1 = \"1100001010\"\nK28d3_RD0 = \"0011110011\"\nK28d3_RD1 = \"1100001100\"\nK28d4_RD0 = \"0011110010\"\nK28d4_RD1 = \"1100001101\"\nK28d5_RD0 = \"0011111010\"\nK28d5_RD1 = \"1100000101\"\nK28d6_RD0 = \"0011110110\"\nK28d6_RD1 = \"1100001001\"\nK28d7_RD0 = \"0011111000\"\nK28d7_RD1 = \"1100000111\"\nK23d7_RD0 = \"1110101000\"\nK23d7_RD1 = \"0001010111\"\nK27d7_RD0 = \"1101101000\"\nK27d7_RD1 = \"0010010111\"\nK29d7_RD0 = \"1011101000\"\nK29d7_RD1 = \"0100010111\"\nK30d7_RD0 = \"0111101000\"\nK30d7_RD1 = \"1000010111\"\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and start the clock.\"\"\"\n    dut.reset_in.value = 1\n    dut.decoder_in.value = 0\n\n    clock = Clock(dut.clk_in, 50, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    dut.reset_in.value = 0\n\nasync def check_output(dut, expected_value, expected_control, input_value):\n    \"\"\"Check the output of the DUT against the expected value.\"\"\"\n    expected_value_bin = f\"{int(expected_value, 16):08b}\"  # Convert hex to binary\n    print(f\"Expected: {hex(int(expected_value, 16)):>4}, Got: {hex(int(str(dut.decoder_out.value), 2)):>4}, Input: {input_value}\")\n    assert str(dut.decoder_out.value) == expected_value_bin, f\"Expected {expected_value_bin}, got {str(dut.decoder_out.value)}\"\n    assert dut.control_out.value == expected_control, f\"Expected control {expected_control}, got {dut.control_out.value}\"\n\ndef calculate_expected_value(codeword):\n    \"\"\"Calculate the expected value based on the 10-bit codeword.\"\"\"\n    if codeword in [K28d0_RD0, K28d0_RD1]:\n        return \"1C\"\n    elif codeword in [K28d1_RD0, K28d1_RD1]:\n        return \"3C\"\n    elif codeword in [K28d2_RD0, K28d2_RD1]:\n        return \"5C\"\n    elif codeword in [K28d3_RD0, K28d3_RD1]:\n        return \"7C\"\n    elif codeword in [K28d4_RD0, K28d4_RD1]:\n        return \"9C\"\n    elif codeword in [K28d5_RD0, K28d5_RD1]:\n        return \"BC\"\n    elif codeword in [K28d6_RD0, K28d6_RD1]:\n        return \"DC\"\n    elif codeword in [K28d7_RD0, K28d7_RD1]:\n        return \"FC\"\n    elif codeword in [K23d7_RD0, K23d7_RD1]:\n        return \"F7\"\n    elif codeword in [K27d7_RD0, K27d7_RD1]:\n        return \"FB\"\n    elif codeword in [K29d7_RD0, K29d7_RD1]:\n        return \"FD\"\n    elif codeword in [K30d7_RD0, K30d7_RD1]:\n        return \"FE\"\n    else:\n        return \"00\"\n\n@cocotb.test()\nasync def test_decoder_8b10b_reset(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols and reset HIGH.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        print(f\"Delayed decoder_in: {delayed_decoder_in}\")  # Debug print\n\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n    dut.reset_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    expected_value = \"00\"\n    expected_control = 0\n    await check_output(dut, expected_value, expected_control, \"0000000000\")\n\n@cocotb.test()\nasync def test_continuous_control_symbol(dut):\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(28):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n    await Timer(100, units=\"ns\")\n\n\n@cocotb.test()\nasync def test_random_control_symbol(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n@cocotb.test()\nasync def test_same_control_symbol(dut):\n    \"\"\"Test sending the same control symbol continuously.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d6_RD0, K28d6_RD1]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(20):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n@cocotb.test()\nasync def test_random_invalid_control_input(dut):\n    \"\"\"Test sending any 10-bit input other than 12 control symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_data = random.randint(0, 1023)\n        while f\"{random_data:010b}\" in control_symbols:\n            random_data = random.randint(0, 1023)\n        dut.decoder_in.value = random_data\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n    await Timer(100, units=\"ns\")\n\n@cocotb.test()\nasync def test_random_imbalanced_control_symbol(dut):\n    \"\"\"Test sending any random control symbol continuously out of 5 imbalanced symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(20):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_decoder_8b10b_0023", "categories": ["cid014", "medium"], "input": {"prompt": "Create SystemVerilog Assertions to verify the **functional correctness** of the `decoder_8b10b` module. The properties should ensure that:  \n\n1. **Valid Output for Data Characters**: When `control_out` is LOW, the `decoder_out` must be a valid 8-bit data value (i.e., within the range `8'h00` to `8'hFF`).  \n\n2. **Output Consistency for Repeated Inputs**: If the input (`s_in_10b_reg`) remains unchanged, the output (`decoder_out` and `control_out`) must also remain unchanged.  \n\n3. **Valid Output Follows Valid Input**: The `decoder_valid_out` signal must be asserted in the cycle immediately following a valid input (`decoder_valid_in`).  \n\n4. **Stable Output When No New Input**: If no new valid input is provided (`decoder_valid_in` is LOW), the `decoder_out` must remain stable.  \n\n5. **Control Symbol Detection**: When `control_in` is HIGH and `decoder_valid_in` is HIGH, the `s_control_out` signal must be asserted.  \n\n6. **No x or z in Outputs**: The outputs (`decoder_out`, `decoder_valid_out`, and `control_out`) must never contain unknown (`x`) or high-impedance (`z`) values.  \n\n7. **Invalid Control Codeword Detection**: When `control_in` is HIGH and `decoder_valid_out` is HIGH, the `decoder_out` must not be `8'h00` or `8'hFF`.  \n\nEach assertion must provide a **detailed failure message**, including the relevant signals and their values for debugging purposes.  \n\n---\n\n### RTL Specification  \n\n#### Module Name: `decoder_8b10b`\n\nThe 8b10b decoder is a digital circuit that converts a 10-bit encoded word back into its corresponding 8-bit data or control symbol. This decoder identifies whether the input is a control or data symbol and ensures the correct decoding of both types. The module must maintain compatibility with control symbols while extending its functionality to decode data symbols accurately.\n\n#### **Symbol Types**:\n- **Control Symbols**: These are special synchronization and protocol management symbols. Control symbols are indicated by the `control_in` signal being HIGH.\n- **Data Symbols**: These are standard 8-bit data inputs encoded as 10-bit words. Data symbols are indicated by the `control_in` signal being LOW.\n\n#### **Data Symbol Decoding Rules**\n\n1. **Data Symbol Decoding**:  \n   - Split the 10-bit encoded input into its 6-bit and 4-bit segments.\n   - Decode the 6-bit segment (`abcdei`) into 5 bits (`EDCBA`) and the 4-bit segment (`fghj`) into 3 bits (`HGF`).\n   - Combine the decoded results into the final 8-bit output.\n   - Set `control_out` LOW for data symbols.\n\n3. **Validation**:  \n   - Verify the 10-bit encoded input against the 8b/10b decoding rules.\n   - Invalidate the output (`decoder_valid_out = 0`) for invalid inputs.\n\n\n#### Decoding Tables\n\n\n#### **5b/6b Decoding Table**\n\nThe MSB 6-bit of the 10-bit input is mapped back to its corresponding 5-bit (`EDCBA`).\n\n| Encoded 6-bit (abcdei)       | Decoded 5-bit (EDCBA) |\n|------------------------------|-----------------------|\n| 100111, 011000               | 00000                 |\n| 011101, 100010               | 00001                 |\n| 101101, 010010               | 00010                 |\n| 110001                       | 00011                 |\n| 110101, 001010               | 00100                 |\n| 101001                       | 00101                 |\n| 011001                       | 00110                 |\n| 111000, 000111               | 00111                 |\n| 111001, 000110               | 01000                 |\n| 100101                       | 01001                 |\n| 010101                       | 01010                 |\n| 110100                       | 01011                 |\n| 001101                       | 01100                 |\n| 101100                       | 01101                 |\n| 011100                       | 01110                 |\n| 010111, 101000               | 01111                 |\n| 011011, 100100               | 10000                 |\n| 100011                       | 10001                 |\n| 010011                       | 10010                 |\n| 110010                       | 10011                 |\n| 001011                       | 10100                 |\n| 101010                       | 10101                 |\n| 011010                       | 10110                 |\n| 111010, 000101               | 10111                 |\n| 110011, 001100               | 11000                 |\n| 100110                       | 11001                 |\n| 010110                       | 11010                 |\n| 110110, 001001               | 11011                 |\n| 001110                       | 11100                 |\n| 101110, 010001               | 11101                 |\n| 011110, 100001               | 11110                 |\n| 101011, 010100               | 11111                 |\n\n\n\n#### **3b/4b Decoding Table**\n\nThe LSB 4-bit of the 10-bit input is mapped back to its corresponding 3-bit (`HGF`).\n\n| Encoded 4-bit (fghj)         | Decoded 3-bit (HGF) |\n|------------------------------|---------------------|\n| 0100, 1011                   | 000                 |\n| 1001                         | 001                 |\n| 0101                         | 010                 |\n| 0011, 1100                   | 011                 |\n| 0010, 1101                   | 100                 |\n| 1010                         | 101                 |\n| 0110                         | 110                 |\n| 1110, 0001                   | 111                 |\n  \n\n#### IO Ports  \n\n| Port Name              | Direction| Size       | Description                                        |\n|------------------------|----------|------------|----------------------------------------------------|\n| `clk_in`               | Input    | 1 bit      | Positive Edge triggered Clock signal               |\n| `reset_in`             | Input    | 1 bit      | Asynchronous Active-high reset                     |\n| `control_in`           | Input    | 1 bit      | Control symbol indicator: HIGH for control words   |\n| `decoder_in`           | Input    | 10 bits    | 10-bit encoded input                               |\n| `decoder_valid_in`     | Input    | 1 bit      | Input valid signal, active high                    |\n| `decoder_out`          | Output   | 8 bits     | 8-bit decoded output                               |\n| `decoder_valid_out`    | Output   | 1 bit      | Output valid signal, active high                   |\n| `control_out`          | Output   | 1 bit      | Control symbol output, active high for control words|\n\n", "context": {"rtl/decoder_8b10b.sv": "module decoder_8b10b (\n    input  logic        clk_in,             // Clock signal, triggers on rising edge\n    input  logic        reset_in,           // Reset signal, active high\n    input  logic        control_in,         // Control symbol indicator: HIGH for control, LOW for data\n    input  logic [9:0]  decoder_in,         // 10-bit encoded input\n    input  logic        decoder_valid_in,   // Input valid signal, active high\n    output logic [7:0]  decoder_out,        // 8-bit decoded output\n    output logic        decoder_valid_out,  // Output valid signal, active high\n    output logic        control_out         // Control symbol output, active high for control words\n);\n\n    logic [9:0] s_in_10b_reg;  \n    logic [7:0] s_decoder_out; \n    logic s_control_out;\n    logic [7:0] decoder_data_out;\n    logic control_data_out;    \n    logic decoder_control_valid;    \n    logic decoder_data_valid;    \n    logic a,b,c,d,e,i,f,g,h,j;  \n    logic w_aeqb, w_ceqd, w_p22, w_p13, w_p31;\n    logic eeqi, c_d_e_i, cn_dn_en_in;\n    logic w_p22_a_c_eeqi, w_p22_an_cn_eeqi;\n    logic w_p22_b_c_eeqi, w_p22_bn_cn_eeqi, an_bn_en_in;\n    logic a_b_e_i, w_p13_d_e_i, w_p13_in, w_p13_en, w_p31_i;\n    logic w_or12_1, w_or12_2, w_or12_3, w_or12_4, w_or12_5, w_or12_6, w_or12_7;\n    logic A, B, C, D, E;\n    logic K, F, G, H, K28p, w_ka, w_kb, w_kc;\n\n    function automatic [8:0] decode_8b10b(input logic [9:0] in);\n        case (in)\n            10'b0011110100, 10'b1100001011: decode_8b10b = {1'b1, 8'h1C};\n            10'b0011110010, 10'b1100001101: decode_8b10b = {1'b1, 8'h9C};\n            10'b0011111000, 10'b1100000111: decode_8b10b = {1'b1, 8'hFC};\n            10'b1110101000, 10'b0001010111: decode_8b10b = {1'b1, 8'hF7};\n            10'b1101101000, 10'b0010010111: decode_8b10b = {1'b1, 8'hFB};\n            10'b1011101000, 10'b0100010111: decode_8b10b = {1'b1, 8'hFD};\n            10'b0111101000, 10'b1000010111: decode_8b10b = {1'b1, 8'hFE};\n            10'b0011111001, 10'b1100000110: decode_8b10b = {1'b1, 8'h3C};\n            10'b0011110101, 10'b1100001010: decode_8b10b = {1'b1, 8'h5C};\n            10'b0011110011, 10'b1100001100: decode_8b10b = {1'b1, 8'h7C};\n            10'b0011111010, 10'b1100000101: decode_8b10b = {1'b1, 8'hBC};\n            10'b0011110110, 10'b1100001001: decode_8b10b = {1'b1, 8'hDC};\n            default: decode_8b10b = {1'b0, 8'b00000000};\n        endcase\n    endfunction\n\n    always_comb begin\n        {s_control_out, s_decoder_out} = decode_8b10b(s_in_10b_reg);  \n    end\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            s_in_10b_reg <= 10'b0000000000;\n            decoder_control_valid <= 1'b0;\n        end else if (decoder_valid_in) begin\n            s_in_10b_reg <= decoder_in;  \n            decoder_control_valid <= 1'b1;  \n        end else begin\n            decoder_control_valid <= 1'b0;\n        end\n    end\n\n    assign {a,b,c,d,e,i,f,g,h,j} = decoder_in[9:0];\n\n    assign K28p = ! (c | d | e | i);\n    assign F = (j & !f & (h | !g | K28p)) | (f & !j & (!h | g | !K28p)) | (K28p & g & h) | (!K28p & !g & !h);\n    assign G = (j & !f & (h | !g | !K28p)) | (f & !j & (!h | g |K28p)) | (!K28p & g & h) | (K28p & !g & !h);\n    assign H = ((j ^ h) & ! ((!f & g & !h & j & !K28p) | (!f & g & h & !j & K28p) | (f & !g & !h & j & !K28p) | (f & !g & h & !j & K28p))) | (!f & g & h & j) | (f & !g & !h & !j);\n\n    assign w_aeqb = (a & b) | (!a & !b);\n    assign w_ceqd = (c & d) | (!c & !d);\n    assign w_p22 = (a & b & !c & !d) | (c & d & !a & !b) | ( !w_aeqb & !w_ceqd);\n    assign w_p13 = ( !w_aeqb & !c & !d) | ( !w_ceqd & !a & !b);\n    assign w_p31 = ( !w_aeqb & c & d) | ( !w_ceqd & a & b);\n\n    assign eeqi = (e == i);\n    assign w_p22_a_c_eeqi = w_p22 & a & c & eeqi;\n    assign w_p22_an_cn_eeqi = w_p22 & !a & !c & eeqi;\n    assign cn_dn_en_in = (!c & !d & !e & !i);\n    assign c_d_e_i = (c & d & e & i);\n    assign w_ka = c_d_e_i | cn_dn_en_in;\n    assign w_kb = w_p13 & (!e & i & g & h & j);\n    assign w_kc = w_p31 & (e & !i & !g & !h & !j);\n    assign K = w_ka | w_kb | w_kc;\n    assign w_p22_b_c_eeqi = w_p22 & b & c & eeqi;\n    assign w_p22_bn_cn_eeqi = w_p22 & !b & !c & eeqi;\n    assign an_bn_en_in = !a & !b & !e & !i;\n    assign a_b_e_i = a & b & e & i;\n    assign w_p13_d_e_i = w_p13 & d & e & i;\n    assign w_p13_in = w_p13 & !i;\n    assign w_p13_en = w_p13 & !e;\n    assign w_p31_i = w_p31 & i;\n\n    assign w_or12_1 = w_p22_an_cn_eeqi | w_p13_en;\n    assign w_or12_2 = a_b_e_i | cn_dn_en_in | w_p31_i;\n    assign w_or12_3 = w_p31_i | w_p22_b_c_eeqi | w_p13_d_e_i;\n    assign w_or12_4 = w_p22_a_c_eeqi | w_p13_en;\n    assign w_or12_5 = w_p13_en | cn_dn_en_in | an_bn_en_in;\n    assign w_or12_6 = w_p22_an_cn_eeqi | w_p13_in;\n    assign w_or12_7 = w_p13_d_e_i | w_p22_bn_cn_eeqi;\n\n    assign A = a ^ (w_or12_7 | w_or12_1 | w_or12_2);\n    assign B = b ^ (w_or12_2 | w_or12_3 | w_or12_4);\n    assign C = c ^ (w_or12_1 | w_or12_3 | w_or12_5);\n    assign D = d ^ (w_or12_2 | w_or12_4 | w_or12_7);\n    assign E = e ^ (w_or12_5 | w_or12_6 | w_or12_7);\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            control_data_out <= 0; \n            decoder_data_out <= 8'b0;\n            decoder_data_valid <= 0; \n        end else begin\n            control_data_out <= K; \n            decoder_data_out <= { H, G, F, E, D, C, B, A };\n            decoder_data_valid <= decoder_valid_in;\n        end\n    end\n    \n    assign decoder_out = (control_in) ? s_decoder_out  : decoder_data_out;\n    assign control_out = (control_in) ? s_control_out  : control_data_out;\n    assign decoder_valid_out = (control_in) ? decoder_control_valid  : decoder_data_valid;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/decoder_8b10b.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/decoder_8b10b.sv \nTOPLEVEL        = decoder_8b10b\nMODULE          = test_decoder_8b10b\nPYTHONPATH      = /src\nHASH            = bc92750b200432446a29bd251f1ca1f83811567d\n", "src/test_decoder_8b10b.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nfrom collections import deque\n\n# Special character code values\nK28d0_RD0 = \"0011110100\"\nK28d0_RD1 = \"1100001011\"\nK28d1_RD0 = \"0011111001\"\nK28d1_RD1 = \"1100000110\"\nK28d2_RD0 = \"0011110101\"\nK28d2_RD1 = \"1100001010\"\nK28d3_RD0 = \"0011110011\"\nK28d3_RD1 = \"1100001100\"\nK28d4_RD0 = \"0011110010\"\nK28d4_RD1 = \"1100001101\"\nK28d5_RD0 = \"0011111010\"\nK28d5_RD1 = \"1100000101\"\nK28d6_RD0 = \"0011110110\"\nK28d6_RD1 = \"1100001001\"\nK28d7_RD0 = \"0011111000\"\nK28d7_RD1 = \"1100000111\"\nK23d7_RD0 = \"1110101000\"\nK23d7_RD1 = \"0001010111\"\nK27d7_RD0 = \"1101101000\"\nK27d7_RD1 = \"0010010111\"\nK29d7_RD0 = \"1011101000\"\nK29d7_RD1 = \"0100010111\"\nK30d7_RD0 = \"0111101000\"\nK30d7_RD1 = \"1000010111\"\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and start the clock.\"\"\"\n    dut.reset_in.value = 1\n    dut.decoder_in.value = 0\n    dut.decoder_valid_in.value = 0\n    dut.control_in.value = 0\n\n    clock = Clock(dut.clk_in, 50, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    dut.reset_in.value = 0\n\nasync def check_output(dut, expected_value, expected_control, input_value):\n    \"\"\"Check the output of the DUT against the expected value.\"\"\"\n    expected_value_bin = f\"{int(expected_value, 16):08b}\"  # Convert hex to binary\n    print(f\"Expected: {hex(int(expected_value, 16)):>4}, Got: {hex(int(str(dut.decoder_out.value), 2)):>4}, Input: {input_value}\")\n    assert str(dut.decoder_out.value) == expected_value_bin, f\"Expected {expected_value_bin}, got {str(dut.decoder_out.value)}\"\n    assert dut.control_out.value == expected_control, f\"Expected control {expected_control}, got {dut.control_out.value}\"\n\ndef calculate_expected_value(codeword):\n    \"\"\"Calculate the expected value based on the 10-bit codeword.\"\"\"\n    if codeword in [K28d0_RD0, K28d0_RD1]:\n        return \"1C\"\n    elif codeword in [K28d1_RD0, K28d1_RD1]:\n        return \"3C\"\n    elif codeword in [K28d2_RD0, K28d2_RD1]:\n        return \"5C\"\n    elif codeword in [K28d3_RD0, K28d3_RD1]:\n        return \"7C\"\n    elif codeword in [K28d4_RD0, K28d4_RD1]:\n        return \"9C\"\n    elif codeword in [K28d5_RD0, K28d5_RD1]:\n        return \"BC\"\n    elif codeword in [K28d6_RD0, K28d6_RD1]:\n        return \"DC\"\n    elif codeword in [K28d7_RD0, K28d7_RD1]:\n        return \"FC\"\n    elif codeword in [K23d7_RD0, K23d7_RD1]:\n        return \"F7\"\n    elif codeword in [K27d7_RD0, K27d7_RD1]:\n        return \"FB\"\n    elif codeword in [K29d7_RD0, K29d7_RD1]:\n        return \"FD\"\n    elif codeword in [K30d7_RD0, K30d7_RD1]:\n        return \"FE\"\n    else:\n        return \"00\"\n\n# Data symbols for 8b10b decoder\nDATA_SYMBOLS = [\n     \"1001110100\", \"0110001011\", \"0111010010\", \"1000101101\", \"1011010101\", \"0100100101\", \"1100010110\", \"1100010110\",\n     \"0111010100\", \"1000101011\", \"1011010010\", \"0100101101\", \"1100010101\", \"1100010101\", \"1101010110\", \"0010100110\",\n     \"1011010100\", \"0100101011\", \"1100011101\", \"1100010010\", \"1101010101\", \"0010100101\", \"1010010110\", \"1010010110\",\n     \"1100011011\", \"1100010100\", \"1101010010\", \"0010101101\", \"1010010101\", \"1010010101\", \"0110010110\", \"0110010110\",\n     \"1101010100\", \"0010101011\", \"1010011101\", \"1010010010\", \"0110010101\", \"0110010101\", \"1110000110\", \"0001110110\",\n     \"1010011011\", \"1010010100\", \"0110011101\", \"0110010010\", \"1110000101\", \"0001110101\", \"1110010110\", \"0001100110\",\n     \"0110011011\", \"0110010100\", \"1110001101\", \"0001110010\", \"1110010101\", \"0001100101\", \"1001010110\", \"1001010110\",\n     \"1110001011\", \"0001110100\", \"1110010010\", \"0001101101\", \"1001010101\", \"1001010101\", \"0101010110\", \"0101010110\",\n     \"1110010100\", \"0001101011\", \"1001011101\", \"1001010010\", \"0101010101\", \"0101010101\", \"1101000110\", \"1101000110\",\n     \"1001011011\", \"1001010100\", \"0101011101\", \"0101010010\", \"1101000101\", \"1101000101\", \"0011010110\", \"0011010110\",\n     \"0101011011\", \"0101010100\", \"1101001101\", \"1101000010\", \"0011010101\", \"0011010101\", \"1011000110\", \"1011000110\",\n     \"1101001011\", \"1101000100\", \"0011011101\", \"0011010010\", \"1011000101\", \"1011000101\", \"0111000110\", \"0111000110\",\n     \"0011011011\", \"0011010100\", \"1011001101\", \"1011000010\", \"0111000101\", \"0111000101\", \"0101110110\", \"1010000110\",\n     \"1011001011\", \"1011000100\", \"0111001101\", \"0111000010\", \"0101110101\", \"1010000101\", \"0110110110\", \"1001000110\",\n     \"0111001011\", \"0111000100\", \"0101110010\", \"1010001101\", \"0110110101\", \"1001000101\", \"1000110110\", \"1000110110\",\n     \"0101110100\", \"1010001011\", \"0110110010\", \"1001001101\", \"1000110101\", \"1000110101\", \"0100110110\", \"0100110110\",\n     \"0110110100\", \"1001001011\", \"1000111101\", \"1000110010\", \"0100110101\", \"0100110101\", \"1100100110\", \"1100100110\",\n     \"1000111011\", \"1000110100\", \"0100111101\", \"0100110010\", \"1100100101\", \"1100100101\", \"0010110110\", \"0010110110\",\n     \"0100111011\", \"0100110100\", \"1100101101\", \"1100100010\", \"0010110101\", \"0010110101\", \"1010100110\", \"1010100110\",\n     \"1100101011\", \"1100100100\", \"0010111101\", \"0010110010\", \"1010100101\", \"1010100101\", \"0110100110\", \"0110100110\",\n     \"0010111011\", \"0010110100\", \"1010101101\", \"1010100010\", \"0110100101\", \"0110100101\", \"1110100110\", \"0001010110\",\n     \"1010101011\", \"1010100100\", \"0110101101\", \"0110100010\", \"1110100101\", \"0001010101\", \"1100110110\", \"0011000110\",\n     \"0110101011\", \"0110100100\", \"1110100010\", \"0001011101\", \"1100110101\", \"0011000101\", \"1001100110\", \"1001100110\",\n     \"1110100100\", \"0001011011\", \"1100110010\", \"0011001101\", \"1001100101\", \"1001100101\", \"0101100110\", \"0101100110\",\n     \"1100110100\", \"0011001011\", \"1001101101\", \"1001100010\", \"0101100101\", \"0101100101\", \"1101100110\", \"0010010110\",\n     \"1001101011\", \"1001100100\", \"0101101101\", \"0101100010\", \"1101100101\", \"0010010101\", \"0011100110\", \"0011100110\",\n     \"0101101011\", \"0101100100\", \"1101100010\", \"0010011101\", \"0011100101\", \"0011100101\", \"1011100110\", \"0100010110\",\n     \"1101100100\", \"0010011011\", \"0011101101\", \"0011100010\", \"1011100101\", \"0100010101\", \"0111100110\", \"1000010110\",\n     \"0011101011\", \"0011100100\", \"1011100010\", \"0100011101\", \"0111100101\", \"1000010101\", \"1010110110\", \"0101000110\",\n     \"1011100100\", \"0100011011\", \"0111100010\", \"1000011101\", \"1010110101\", \"0101000101\", \"1001110001\", \"0110001110\",\n     \"0111100100\", \"1000011011\", \"1010110010\", \"0101001101\", \"1001110011\", \"0110001100\", \"0111010001\", \"1000101110\",\n     \"1010110100\", \"0101001011\", \"1001111010\", \"0110001010\", \"0111010011\", \"1000101100\", \"1011010001\", \"0100101110\",\n     \"1001111001\", \"0110001001\", \"0111011010\", \"1000101010\", \"1011010011\", \"0100101100\", \"1100011110\", \"1100010001\",\n     \"0111011001\", \"1000101001\", \"1011011010\", \"0100101010\", \"1100011100\", \"1100010011\", \"1101010001\", \"0010101110\",\n     \"1011011001\", \"0100101001\", \"1100011010\", \"1100011010\", \"1101010011\", \"0010101100\", \"1010011110\", \"1010010001\",\n     \"1100011001\", \"1100011001\", \"1101011010\", \"0010101010\", \"1010011100\", \"1010010011\", \"0110011110\", \"0110010001\",\n     \"1101011001\", \"0010101001\", \"1010011010\", \"1010011010\", \"0110011100\", \"0110010011\", \"1110001110\", \"0001110001\",\n     \"1010011001\", \"1010011001\", \"0110011010\", \"0110011010\", \"1110001100\", \"0001110011\", \"1110010001\", \"0001101110\",\n     \"0110011001\", \"0110011001\", \"1110001010\", \"0001111010\", \"1110010011\", \"0001101100\", \"1001011110\", \"1001010001\",\n     \"1110001001\", \"0001111001\", \"1110011010\", \"0001101010\", \"1001011100\", \"1001010011\", \"0101011110\", \"0101010001\",\n     \"1110011001\", \"0001101001\", \"1001011010\", \"1001011010\", \"0101011100\", \"0101010011\", \"1101001110\", \"1101001000\",\n     \"1001011001\", \"1001011001\", \"0101011010\", \"0101011010\", \"1101001100\", \"1101000011\", \"0011011110\", \"0011010001\",\n     \"0101011001\", \"0101011001\", \"1101001010\", \"1101001010\", \"0011011100\", \"0011010011\", \"1011001110\", \"1011001000\",\n     \"1101001001\", \"1101001001\", \"0011011010\", \"0011011010\", \"1011001100\", \"1011000011\", \"0111001110\", \"0111001000\",\n     \"0011011001\", \"0011011001\", \"1011001010\", \"1011001010\", \"0111001100\", \"0111000011\", \"0101110001\", \"1010001110\",\n     \"1011001001\", \"1011001001\", \"0111001010\", \"0111001010\", \"0101110011\", \"1010001100\", \"0110110001\", \"1001001110\",\n     \"0111001001\", \"0111001001\", \"0101111010\", \"1010001010\", \"0110110011\", \"1001001100\", \"1000110111\", \"1000110001\",\n     \"0101111001\", \"1010001001\", \"0110111010\", \"1001001010\", \"1000111100\", \"1000110011\", \"0100110111\", \"0100110001\",\n     \"0110111001\", \"1001001001\", \"1000111010\", \"1000111010\", \"0100111100\", \"0100110011\", \"1100101110\", \"1100100001\",\n     \"1000111001\", \"1000111001\", \"0100111010\", \"0100111010\", \"1100101100\", \"1100100011\", \"0010110111\", \"0010110001\",\n     \"0100111001\", \"0100111001\", \"1100101010\", \"1100101010\", \"0010111100\", \"0010110011\", \"1010101110\", \"1010100001\",\n     \"1100101001\", \"1100101001\", \"0010111010\", \"0010111010\", \"1010101100\", \"1010100011\", \"0110101110\", \"0110100001\",\n     \"0010111001\", \"0010111001\", \"1010101010\", \"1010101010\", \"0110101100\", \"0110100011\", \"1110100001\", \"0001011110\",\n     \"1010101001\", \"1010101001\", \"0110101010\", \"0110101010\", \"1110100011\", \"0001011100\", \"1100110001\", \"0011001110\",\n     \"0110101001\", \"0110101001\", \"1110101010\", \"0001011010\", \"1100110011\", \"0011001100\", \"1001101110\", \"1001100001\",\n     \"1110101001\", \"0001011001\", \"1100111010\", \"0011001010\", \"1001101100\", \"1001100011\", \"0101101110\", \"0101100001\",\n     \"1100111001\", \"0011001001\", \"1001101010\", \"1001101010\", \"0101101100\", \"0101100011\", \"1101100001\", \"0010011110\",\n     \"1001101001\", \"1001101001\", \"0101101010\", \"0101101010\", \"1101100011\", \"0010011100\", \"0011101110\", \"0011100001\",\n     \"0101101001\", \"0101101001\", \"1101101010\", \"0010011010\", \"0011101100\", \"0011100011\", \"1011100001\", \"0100011110\",\n     \"1101101001\", \"0010011001\", \"0011101010\", \"0011101010\", \"1011100011\", \"0100011100\", \"0111100001\", \"1000011110\",\n     \"0011101001\", \"0011101001\", \"1011101010\", \"0100011010\", \"0111100011\", \"1000011100\", \"1010110001\", \"0101001110\",\n     \"1011101001\", \"0100011001\", \"0111101010\", \"1000011010\", \"1010110011\", \"0101001100\", \"1001110010\", \"0110001101\",\n     \"0111101001\", \"1000011001\", \"1010111010\", \"0101001010\", \"1001110101\", \"0110000101\", \"0111010110\", \"1000100110\",\n     \"1010111001\", \"0101001001\", \"1001110110\", \"0110000110\", \"0111010101\", \"1000100101\", \"1011010110\", \"0100100110\" \n]\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and start the clock.\"\"\"\n    dut.reset_in.value = 1\n    dut.decoder_in.value = 0\n    dut.decoder_valid_in.value = 0\n    dut.control_in.value = 0\n\n    clock = Clock(dut.clk_in, 50, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    dut.reset_in.value = 0\n\ndef calculate_doi(d):\n    d = [int(bit) for bit in f\"{int(d, 2):010b}\"][::-1] \n    def not_(x): return 1 if x == 0 else 0\n\n    doi = [0] * 8\n\n    doi[7] = (((d[0] ^ d[1]) & not_(\n        (not_(d[3]) & d[2] & not_(d[1]) & d[0] & not_(not_(d[7] | d[6] | d[5] | d[4]))) |\n        (not_(d[3]) & d[2] & d[1] & not_(d[0]) & not_(d[7] | d[6] | d[5] | d[4])) |\n        (d[3] & not_(d[2]) & not_(d[1]) & d[0] & not_(not_(d[7] | d[6] | d[5] | d[4]))) |\n        (d[3] & not_(d[2]) & d[1] & not_(d[0]) & not_(d[7] | d[6] | d[5] | d[4]))\n    ))) | (not_(d[3]) & d[2] & d[1] & d[0]) | (d[3] & not_(d[2]) & not_(d[1]) & not_(d[0]))\n\n    doi[6] = ((d[0] & not_(d[3]) & (d[1] | not_(d[2]) | not_(not_(d[7] | d[6] | d[5] | d[4])))) |\n              (d[3] & not_(d[0]) & (not_(d[1]) | d[2] | not_(d[7] | d[6] | d[5] | d[4]))) |\n              (not_(not_(d[7] | d[6] | d[5] | d[4])) & d[2] & d[1]) |\n              (not_(d[7] | d[6] | d[5] | d[4]) & not_(d[2]) & not_(d[1])))\n\n    doi[5] = ((d[0] & not_(d[3]) & (d[1] | not_(d[2]) | not_(d[7] | d[6] | d[5] | d[4]))) |\n              (d[3] & not_(d[0]) & (not_(d[1]) | d[2] | not_(not_(d[7] | d[6] | d[5] | d[4])))) |\n              (not_(d[7] | d[6] | d[5] | d[4]) & d[2] & d[1]) |\n              (not_(not_(d[7] | d[6] | d[5] | d[4])) & not_(d[2]) & not_(d[1])))\n\n    \n\n    term32 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term33 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term34 = (term32 | term33) & not_(d[5])\n    term35 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term36 = not_(d[9]) & not_(d[8]) & not_(d[5]) & not_(d[4])\n    term37 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term38 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term39 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term40 = (term37 | term38 | term39) & not_(d[9]) & not_(d[7]) & not_(d[5] ^ d[4])\n    term41 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term42 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term43 = (term41 | term42) & not_(d[4])\n    term44 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term45 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term46 = (term44 | term45) & d[6] & d[5] & d[4]\n    term47 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term48 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term49 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term50 = (term47 | term48 | term49) & not_(d[8]) & not_(d[7]) & not_(d[5] ^ d[4])\n\n    doi[4] = d[5] ^ (term34 | term35 | term36 | term40 | term43 | term46 | term50)\n\n    term1 = d[9] & d[8] & d[5] & d[4]\n    term2 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term3 = (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6])\n    term4 = (not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8])\n    term5 = (term3 | term4) & d[4]\n\n    term6 = (\n        ((d[9] & d[8] & not_(d[7]) & not_(d[6])) |\n         (d[7] & d[6] & not_(d[9]) & not_(d[8])) |\n         (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))))\n        ) & d[9] & d[7] & not_(d[5] ^ d[4])\n    )\n    term7 = (\n        (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])) |\n        (not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8]))\n    ) & not_(d[5])\n    term8 = (\n        (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])) |\n        (not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8]))\n    ) & d[6] & d[5] & d[4]\n    term9 = (\n        ((d[9] & d[8] & not_(d[7]) & not_(d[6])) |\n         (d[7] & d[6] & not_(d[9]) & not_(d[8])) |\n         (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))))\n        ) & not_(d[8]) & not_(d[7]) & not_(d[5] ^ d[4])\n    )\n\n    doi[3] = d[6] ^ (term1 | term2 | term5 | term6 | term7 | term8 | term9)\n\n\n    \n    term10 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term11 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term12 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term13 = (term10 | term11 | term12) & not_(d[9]) & not_(d[7]) & not_(d[5] ^ d[4])\n    term14 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term15 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term16 = (term14 | term15) & not_(d[5])\n    term17 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6]\n    term18 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8]\n    term19 = (term17 | term18) & d[4]\n    term20 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term21 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term22 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term23 = (term20 | term21 | term22) & d[8] & d[7] & not_(d[5] ^ d[4])\n    term24 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term25 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term26 = (term24 | term25) & d[6] & d[5] & d[4]\n    term27 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term28 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term29 = (term27 | term28) & not_(d[5])\n    term30 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term31 = not_(d[9]) & not_(d[8]) & not_(d[5]) & not_(d[4])\n\n    doi[2] = d[7] ^ (term13 | term16 | term19 | term23 | term26 | term29 | term30 | term31)\n\n       \n    term51 = d[9] & d[8] & d[5] & d[4]\n    term52 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term53 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6]\n    term54 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8]\n    term55 = (term53 | term54) & d[4]\n    term56 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6]\n    term57 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8]\n    term58 = (term56 | term57) & d[4]\n    term59 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term60 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term61 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term62 = (term59 | term60 | term61) & d[8] & d[7] & not_(d[5] ^ d[4])\n    term63 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term64 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term65 = (term63 | term64) & d[6] & d[5] & d[4]\n    term66 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term67 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term68 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term69 = (term66 | term67 | term68) & d[9] & d[7] & not_(d[5] ^ d[4])\n    term70 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term71 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term72 = (term70 | term71) & not_(d[5])\n\n    doi[1] = d[8] ^ (term51 | term52 | term55 | term58 | term62 | term65 | term69 | term72)\n\n   \n    term73 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term74 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term75 = (term73 | term74) & d[6] & d[5] & d[4]\n    term76 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term77 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term78 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term79 = (term76 | term77 | term78) & not_(d[8]) & not_(d[7]) & not_(d[5] ^ d[4])\n    term80 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term81 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term82 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term83 = (term80 | term81 | term82) & not_(d[9]) & not_(d[7]) & not_(d[5] ^ d[4])\n    term84 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term85 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term86 = (term84 | term85) & not_(d[5])\n    term87 = d[9] & d[8] & d[5] & d[4]\n    term88 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term89 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6]\n    term90 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8]\n    term91 = (term89 | term90) & d[4]\n\n    doi[0] = d[9] ^ (term75 | term79 | term83 | term86 | term87 | term88 | term91)\n\n       \n    return \"\".join(map(str, reversed(doi)))\n\n\n@cocotb.test()\nasync def test_decoder_8b10b_reset(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols and reset HIGH.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n    dut.reset_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    expected_value = \"00\"\n    expected_control = 0\n    await check_output(dut, expected_value, expected_control, \"0000000000\")\n\n@cocotb.test()\nasync def test_continuous_control_symbol(dut):\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(28):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n    await Timer(100, units=\"ns\")\n\n\n@cocotb.test()\nasync def test_random_control_symbol(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n@cocotb.test()\nasync def test_same_control_symbol(dut):\n    \"\"\"Test sending the same control symbol continuously.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d6_RD0, K28d6_RD1]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(20):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n\n@cocotb.test()\nasync def test_random_imbalanced_control_symbol(dut):\n    \"\"\"Test sending any random control symbol continuously out of 5 imbalanced symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(20):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n@cocotb.test()\nasync def test_tc1_seq_data_symbols(dut):\n    \"\"\"Test sequential data symbols.\"\"\"\n    await initialize_dut(dut)\n\n    default_value = int('1001110100', 2)  # This will be 628\n\n    # Initialize the deque with the default value\n    decoder_in_queue = deque([default_value, default_value], maxlen=2)\n\n    for symbol in DATA_SYMBOLS:  # Iterate through all symbols in DATA_SYMBOLS\n        dut.decoder_in.value = int(symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 0  # Data symbols\n        await RisingEdge(dut.clk_in)\n        decoder_in_queue.append(dut.decoder_in.value)\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n\n        # Wait for decoder_valid_out to be HIGH\n        while not dut.decoder_valid_out.value:\n            await RisingEdge(dut.clk_in)\n\n        expected_value = calculate_doi(delayed_decoder_in)\n        dut_doi = f\"{int(dut.decoder_out.value):08b}\"\n\n        print(f\"Expected: {hex(int(expected_value, 2)):>4}, Got: {hex(int(str(dut_doi), 2)):>4}, Got control: {hex(int(str(dut.control_out.value), 2)):>4}, Input: {delayed_decoder_in}\")\n\n        assert (dut_doi == expected_value) and (dut.control_out.value == 0), f\"Mismatch: Input={symbol}, Expected DOI={expected_value}, Got DOI={dut_doi}, Control Out={dut.control_out.value}\"\n\n@cocotb.test()\nasync def test_tc3_incrementing_data_symbols(dut):\n    \"\"\"Test data symbols using the allowed_values array for 10 cycles\"\"\"\n    await initialize_dut(dut)\n    allowed_values = [\n    0x274, 0x1d4, 0x2d4, 0x31b, 0x0ab, 0x294, 0x19b, 0x074,\n    0x394, 0x25b, 0x154, 0x34b, 0x0d4, 0x2cb, 0x1c4, 0x174,\n    0x1b4, 0x23b, 0x134, 0x32b, 0x0b4, 0x2ab, 0x1a4, 0x3a4\n    ]\n\n    default_value = int('1001110100', 2)  # This will be 628\n\n    # Initialize the deque with the default value\n    decoder_in_queue = deque([default_value, default_value], maxlen=2)\n\n    for i in range(24):  # Run for 10 cycles\n        symbol = allowed_values[i % len(allowed_values)]\n\n        dut.decoder_in.value = symbol\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 0  # Data symbols\n        await RisingEdge(dut.clk_in)\n        decoder_in_queue.append(dut.decoder_in.value)\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n\n        # Wait for decoder_valid_out to be HIGH\n        while not dut.decoder_valid_out.value:\n            await RisingEdge(dut.clk_in)\n\n        expected_value = calculate_doi(delayed_decoder_in)\n        dut_doi = f\"{int(dut.decoder_out.value):08b}\"\n\n        print(f\"Expected: {hex(int(expected_value, 2)):>4}, Got: {hex(int(str(dut_doi), 2)):>4}, Got control: {hex(int(str(dut.control_out.value), 2)):>4}, Input: {delayed_decoder_in}\")\n\n        assert (dut_doi == expected_value) and (dut.control_out.value == 0), f\"Mismatch: Input={symbol}, Expected DOI={expected_value}, Got DOI={dut_doi}, Control Out={dut.control_out.value}\"\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_decoder_8b10b_0027", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the existing SystemVerilog testbench to include checker generation logic for verifying the functionality of the `decoder_8b10b` module. The testbench already contains a `stimulus generator` logic to drive the input signals. The modified testbench should integrate a `checker generator` logic to validate the `decoder_8b10b` module against the given design specification.\n\n---\n\n### **Design Specification:**\n\nThe `decoder_8b10b` module decodes a 10-bit encoded input (`decoder_in`) into an 8-bit output (`decoder_out`). The module supports both control and data symbols and asserts `decoder_valid_out` when the decoded data is valid. The module also outputs a `control_out` signal to indicate whether the decoded symbol is a control symbol.\n\n#### **Decoding Rules:**\n1. **Control Symbols:**\n   - Specific 10-bit patterns are mapped to predefined 8-bit control codes.\n   - The module asserts `control_out` HIGH when a control symbol is decoded.\n\n2. **Data Symbols:**\n   - Valid 10-bit data patterns are decoded into 8-bit data values.\n   - The module asserts `control_out` LOW for data symbols.\n\n3. **Invalid Patterns:**\n   - Any 10-bit pattern that does not match a valid control or data symbol is treated as an error, and the output is set to `8'h00`.\n\n4. **Reset Behavior:**\n   - On reset (`reset_in = 1`), the module clears all outputs and waits for valid input.\n\n### Latency:\n\n- Output latency is 1 clock cycle.\n\n---\n\n### Decoding Tables\n\n#### **5b/6b Decoding Table**\n\nThe MSB 6-bit of the 10-bit input is mapped back to its corresponding 5-bit (`EDCBA`).\n\n| Encoded 6-bit (abcdei)       | Decoded 5-bit (EDCBA) |\n|------------------------------|-----------------------|\n| 100111, 011000               | 00000                 |\n| 011101, 100010               | 00001                 |\n| 101101, 010010               | 00010                 |\n| 110001                       | 00011                 |\n| 110101, 001010               | 00100                 |\n| 101001                       | 00101                 |\n| 011001                       | 00110                 |\n| 111000, 000111               | 00111                 |\n| 111001, 000110               | 01000                 |\n| 100101                       | 01001                 |\n| 010101                       | 01010                 |\n| 110100                       | 01011                 |\n| 001101                       | 01100                 |\n| 101100                       | 01101                 |\n| 011100                       | 01110                 |\n| 010111, 101000               | 01111                 |\n| 011011, 100100               | 10000                 |\n| 100011                       | 10001                 |\n| 010011                       | 10010                 |\n| 110010                       | 10011                 |\n| 001011                       | 10100                 |\n| 101010                       | 10101                 |\n| 011010                       | 10110                 |\n| 111010, 000101               | 10111                 |\n| 110011, 001100               | 11000                 |\n| 100110                       | 11001                 |\n| 010110                       | 11010                 |\n| 110110, 001001               | 11011                 |\n| 001110                       | 11100                 |\n| 101110, 010001               | 11101                 |\n| 011110, 100001               | 11110                 |\n| 101011, 010100               | 11111                 |\n\n---\n\n#### **3b/4b Decoding Table**\n\nThe LSB 4-bit of the 10-bit input is mapped back to its corresponding 3-bit (`HGF`).\n\n| Encoded 4-bit (fghj)         | Decoded 3-bit (HGF) |\n|------------------------------|---------------------|\n| 0100, 1011                   | 000                 |\n| 1001                         | 001                 |\n| 0101                         | 010                 |\n| 0011, 1100                   | 011                 |\n| 0010, 1101                   | 100                 |\n| 1010                         | 101                 |\n| 0110                         | 110                 |\n| 1110, 0001                   | 111                 |\n\n---\n\n### **Testbench Requirements:**\n\n1. **Testbench Components:**\n   - **Input Signals:** Drive `clk_in`, `reset_in`, `control_in`, `decoder_in`, and `decoder_valid_in` with various test cases.\n   - **Output Validation:** Monitor and validate the `decoder_out`, `control_out`, and `decoder_valid_out` outputs against expected behavior.\n   - **Checker Generator:** Implement a checker logic to verify the correctness of the outputs based on the input `decoder_in` and `control_in`.\n\n2. **Checker Logic:**\n   - Implement reference logic to calculate the expected `decoder_out` and `control_out` for given `decoder_in` and `control_in`.\n   - Compare the UUT outputs (`decoder_out`, `control_out`, and `decoder_valid_out`) with the calculated expected outputs.\n   - Log errors if the outputs do not match the expected behavior.\n   - Print success messages for passing test cases.\n\n3. **Functionality:**\n   - Test the following scenarios:\n     - **Control Symbols:** Verify decoding of valid control symbol inputs.\n     - **Data Symbols:** Verify decoding of valid data symbol inputs.\n     - **Invalid Patterns:** Verify decoding of invalid 10-bit patterns.\n     - **Reset Behavior:** Verify the behavior of the decoder during and after reset.\n     - **Continuous Input Streams:** Test continuous input streams with mixed control and data symbols.\n     - **Random Input Sequences:** Test random input sequences to ensure robustness.\n\n4. **Verification:**\n   - Drive `decoder_in` and `control_in` and monitor the outputs using the checker logic.\n   - Compare the actual outputs with the expected outputs.\n   - Log results (pass/fail) for each test case.\n\n5. **Simulation:**\n   - Display pass/fail results for each test case.\n   - Complete the simulation once all test cases are verified.\n\n---\n\n### **Deliverables:**\n\nProvide a complete SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `decoder_8b10b` module. The testbench should include:\n- A test sequence generation logic to create input patterns.\n- A checker logic with expected output to validate the outputs.\n- Proper clock generation and reset handling.\n- Logging of test results for each test case.\n\n---\n\n### **Example Test Cases:**\n\n**1. Control Symbol Test:**\n   - Input: `decoder_in = 10'b0011110100`, `control_in = 1`.\n   - Expected Output: `decoder_out = 8'h1C`, `control_out = 1`, `decoder_valid_out = 1`.\n\n**2. Data Symbol Test:**\n   - Input: `decoder_in = 10'b1001110100`, `control_in = 0`.\n   - Expected Output: `decoder_out = 8'h00`, `control_out = 0`, `decoder_valid_out = 1`.\n\n**3. Invalid Pattern Test:**\n   - Input: `decoder_in = 10'b1111111111`, `control_in = 0`.\n   - Expected Output: `decoder_out = 8'h00`, `control_out = 0`, `decoder_valid_out = 1`.\n\n**4. Reset Behavior Test:**\n   - Input: `reset_in = 1`.\n   - Expected Output: `decoder_out = 8'h00`, `control_out = 0`, `decoder_valid_out = 0`.\n\n---\n\n### **Expected Output:**\n- The testbench should:\n  - Apply the input test cases one by one.\n  - Display each test case's comparison results (pass/fail), including detailed information for debugging.\n  - Complete the simulation once all test cases are verified.", "context": {"verif/tb_decoder_8b10b.sv": "\nmodule tb_decoder_8b10b;\n\n    logic clk_in;\n    logic reset_in;\n    logic [9:0] decoder_in;\n    logic [7:0] decoder_out;\n    logic control_in;\n    logic control_out;\n    logic decoder_valid_in;\n    logic decoder_valid_out;\n    logic [9:0] control_symbols [0:23];\n\n    initial begin\n        clk_in = 1;\n        forever #5 clk_in = ~clk_in; // 100 MHz clock\n    end\n\n    decoder_8b10b uut (\n        .clk_in(clk_in),\n        .reset_in(reset_in),\n        .control_in(control_in),\n        .decoder_in(decoder_in),\n        .decoder_valid_in(decoder_valid_in),\n        .decoder_out(decoder_out),\n        .decoder_valid_out(decoder_valid_out),\n        .control_out(control_out)\n    );\n\n    initial begin\n        $dumpfile(\"tb_decoder_8b10b.vcd\");\n        $dumpvars(0, tb_decoder_8b10b);\n\n        test_reset_behavior();\n        test_continuous_control_symbol();\n        test_random_control_symbol();\n        test_same_control_symbol();\n        test_random_invalid_control_input();\n        test_random_imbalanced_control_symbol();\n        test_seq_data_symbol();\n        test_random_data_symbol();\n        test_incremental_data_symbol();\n\n        #1000;\n        $display(\"All tests completed successfully\");\n        $finish;\n    end\n\n    always @(negedge clk_in) begin\n        if (decoder_valid_out) begin \n            $display(\"Stimulus sent: Decoder Input = %b, Decoder control Input = %b, Decoder valid Input = %b\",\n                     decoder_in, control_in, decoder_valid_in);\n        end\n    end\n\n    int i;\n\n    initial begin\n        decoder_valid_in = 0;\n        control_in = 0;\n        reset_in = 1;\n        @(posedge clk_in);\n        @(posedge clk_in);\n        reset_in = 0;\n        $display(\"DUT Initialized\");\n\n        control_symbols[0]  = 10'b0011110100; // K28d0_RD0\n        control_symbols[1]  = 10'b1100001011; // K28d0_RD1\n        control_symbols[2]  = 10'b0011111001; // K28d1_RD0\n        control_symbols[3]  = 10'b1100000110; // K28d1_RD1\n        control_symbols[4]  = 10'b0011110101; // K28d2_RD0\n        control_symbols[5]  = 10'b1100001010; // K28d2_RD1\n        control_symbols[6]  = 10'b0011110011; // K28d3_RD0\n        control_symbols[7]  = 10'b1100001100; // K28d3_RD1\n        control_symbols[8]  = 10'b0011110010; // K28d4_RD0\n        control_symbols[9]  = 10'b1100001101; // K28d4_RD1\n        control_symbols[10] = 10'b0011111010; // K28d5_RD0\n        control_symbols[11] = 10'b1100000101; // K28d5_RD1\n        control_symbols[12] = 10'b0011110110; // K28d6_RD0\n        control_symbols[13] = 10'b1100001001; // K28d6_RD1\n        control_symbols[14] = 10'b0011111000; // K28d7_RD0\n        control_symbols[15] = 10'b1100000111; // K28d7_RD1\n        control_symbols[16] = 10'b1110101000; // K23d7_RD0\n        control_symbols[17] = 10'b0001010111; // K23d7_RD1\n        control_symbols[18] = 10'b1101101000; // K27d7_RD0\n        control_symbols[19] = 10'b0010010111; // K27d7_RD1\n        control_symbols[20] = 10'b1011101000; // K29d7_RD0\n        control_symbols[21] = 10'b0100010111; // K29d7_RD1\n        control_symbols[22] = 10'b0111101000; // K30d7_RD0\n        control_symbols[23] = 10'b1000010111; // K30d7_RD1\n    end\n\n    task test_reset_behavior();\n        begin\n            $display(\"Running Test: Reset Behavior\");\n            decoder_in <= 10'b0;\n            decoder_valid_in <= 0;\n            @(posedge clk_in);\n            reset_in <= 1;\n            @(posedge clk_in);\n            reset_in <= 0;\n            @(posedge clk_in);\n        end\n    endtask\n\n    task test_continuous_control_symbol();\n        begin\n            $display(\"Running Test: Continuous Control Symbols\");\n            decoder_valid_in <= 0;\n            decoder_in <= 10'b0;\n            reset_in <= 1;\n            control_in <= 0;\n            @(posedge clk_in);\n            @(posedge clk_in);\n            for (i = 0; i < 24; i++) begin\n                @(posedge clk_in);\n                decoder_in <= control_symbols[i];\n                reset_in <= 0;\n                control_in <= 1;\n                decoder_valid_in <= 1;\n            end\n        end\n    endtask\n\n    task test_random_control_symbol();\n        begin\n            $display(\"Running Test: Random Control Symbols\");\n            decoder_valid_in <= 0;\n            decoder_in <= 10'b0;\n            reset_in <= 1;\n            control_in <= 0;\n            @(posedge clk_in);\n            @(posedge clk_in);\n\n            for (i = 0; i < 10; i++) begin\n                @(posedge clk_in);\n                decoder_in <= control_symbols[$urandom_range(0, 23)];\n                reset_in <= 0;\n                control_in <= 1;\n                decoder_valid_in <= 1;\n            end\n        end\n    endtask\n\n    task test_same_control_symbol();\n        begin\n            $display(\"Running Test: Same Control Symbol\");\n            decoder_valid_in <= 0;\n            decoder_in <= 10'b0;\n            reset_in <= 1;\n            control_in <= 0;\n            @(posedge clk_in);\n            @(posedge clk_in);\n            for (i = 0; i < 20; i++) begin\n                @(posedge clk_in);\n                decoder_in <= 10'b0011110110;\n                reset_in <= 0;\n                control_in <= 1;\n                decoder_valid_in <= 1;\n            end\n        end\n    endtask\n\n    task test_random_invalid_control_input();\n        logic [9:0] invalid_control_symbols [0:9];\n        begin\n            $display(\"Running Test: Random Invalid Control Inputs\");\n\n            \n            invalid_control_symbols[0] = 10'b1111111111;\n            invalid_control_symbols[1] = 10'b0000000000;\n            invalid_control_symbols[2] = 10'b1010101010;\n            invalid_control_symbols[3] = 10'b0101010101;\n            invalid_control_symbols[4] = 10'b1110001110;\n            invalid_control_symbols[5] = 10'b1101101101;\n            invalid_control_symbols[6] = 10'b0010010010;\n            invalid_control_symbols[7] = 10'b1000000001;\n            invalid_control_symbols[8] = 10'b0111100000;\n            invalid_control_symbols[9] = 10'b1100011110;\n\n            \n            decoder_valid_in <= 0;\n            decoder_in <= 10'b0;\n            reset_in <= 1;\n            control_in <= 0;\n            @(posedge clk_in);\n            @(posedge clk_in);\n            reset_in <= 0;\n\n            \n            for (i = 0; i < 10; i++) begin\n                @(posedge clk_in);\n                control_in <= 1;\n                decoder_valid_in <= 1;\n                decoder_in <= invalid_control_symbols[i]; \n            end\n\n            \n            @(posedge clk_in);\n            decoder_valid_in <= 0;\n            control_in <= 0;\n            decoder_in <= 10'b0;\n        end\n    endtask\n\n    task test_random_imbalanced_control_symbol();\n        logic [9:0] imbalanced_control_symbols [0:9];\n        begin\n            $display(\"Running Test: Random Imbalanced Control Symbols\");\n\n            \n            imbalanced_control_symbols[0] = 10'b0011111001; \n            imbalanced_control_symbols[1] = 10'b1100000110; \n            imbalanced_control_symbols[2] = 10'b0011110101; \n            imbalanced_control_symbols[3] = 10'b1100001010; \n            imbalanced_control_symbols[4] = 10'b0011110011; \n            imbalanced_control_symbols[5] = 10'b1100001100; \n            imbalanced_control_symbols[6] = 10'b0011111010; \n            imbalanced_control_symbols[7] = 10'b1100000101; \n            imbalanced_control_symbols[8] = 10'b0011110110; \n            imbalanced_control_symbols[9] = 10'b1100001001; \n\n            decoder_valid_in <= 0;\n            decoder_in <= 10'b0;\n            reset_in <= 1;\n            control_in <= 0;\n            @(posedge clk_in);\n            @(posedge clk_in);\n            reset_in <= 0;\n\n            for (i = 0; i < 10; i++) begin\n                @(posedge clk_in);\n                decoder_in <= imbalanced_control_symbols[$urandom_range(0, 9)];\n                control_in <= 1;\n                decoder_valid_in <= 1;\n            end\n\n            @(posedge clk_in);\n            decoder_valid_in <= 0;\n            control_in <= 0;\n            decoder_in <= 10'b0;\n        end\n    endtask\n\n    task test_seq_data_symbol();\n        logic [9:0] imbalanced_control_symbols [0:9]; \n        begin\n            $display(\"Running Test: Random 10 data Symbols\");\n\n            imbalanced_control_symbols[0] = 10'b1001110100; \n            imbalanced_control_symbols[1] = 10'b1000101011; \n            imbalanced_control_symbols[2] = 10'b0110011011; \n            imbalanced_control_symbols[3] = 10'b1010010011; \n            imbalanced_control_symbols[4] = 10'b1000110101; \n            imbalanced_control_symbols[5] = 10'b0011101110; \n            imbalanced_control_symbols[6] = 10'b0100011110; \n            imbalanced_control_symbols[7] = 10'b1011100001; \n            imbalanced_control_symbols[8] = 10'b0111100001; \n            imbalanced_control_symbols[9] = 10'b0100011110; \n\n            decoder_valid_in <= 0;\n            decoder_in <= 10'b0;\n            reset_in <= 1;\n            control_in <= 0;\n            @(posedge clk_in);\n            @(posedge clk_in);\n            reset_in <= 0;\n\n            for (i = 0; i < 10; i++) begin\n                @(posedge clk_in);\n                decoder_in <= imbalanced_control_symbols[$urandom_range(0, 9)];\n                control_in <= 0;\n                decoder_valid_in <= 1;\n            end\n\n            @(posedge clk_in);\n            decoder_valid_in <= 0;\n            control_in <= 0;\n            decoder_in <= 10'b0;\n        end\n    endtask\n\n    task test_random_data_symbol();\n        logic [9:0] allowed_values [0:511] = '{\n            10'b1001110100, 10'b0110001011, 10'b0111010010, 10'b1000101101, 10'b1011010101, 10'b0100100101, 10'b1100010110, 10'b1100010110,\n            10'b0111010100, 10'b1000101011, 10'b1011010010, 10'b0100101101, 10'b1100010101, 10'b1100010101, 10'b1101010110, 10'b0010100110,\n            10'b1011010100, 10'b0100101011, 10'b1100011101, 10'b1100010010, 10'b1101010101, 10'b0010100101, 10'b1010010110, 10'b1010010110,\n            10'b1100011011, 10'b1100010100, 10'b1101010010, 10'b0010101101, 10'b1010010101, 10'b1010010101, 10'b0110010110, 10'b0110010110,\n            10'b1101010100, 10'b0010101011, 10'b1010011101, 10'b1010010010, 10'b0110010101, 10'b0110010101, 10'b1110000110, 10'b0001110110,\n            10'b1010011011, 10'b1010010100, 10'b0110011101, 10'b0110010010, 10'b1110000101, 10'b0001110101, 10'b1110010110, 10'b0001100110,\n            10'b0110011011, 10'b0110010100, 10'b1110001101, 10'b0001110010, 10'b1110010101, 10'b0001100101, 10'b1001010110, 10'b1001010110,\n            10'b1110001011, 10'b0001110100, 10'b1110010010, 10'b0001101101, 10'b1001010101, 10'b1001010101, 10'b0101010110, 10'b0101010110,\n            10'b1110010100, 10'b0001101011, 10'b1001011101, 10'b1001010010, 10'b0101010101, 10'b0101010101, 10'b1101000110, 10'b1101000110,\n            10'b1001011011, 10'b1001010100, 10'b0101011101, 10'b0101010010, 10'b1101000101, 10'b1101000101, 10'b0011010110, 10'b0011010110,\n            10'b0101011011, 10'b0101010100, 10'b1101001101, 10'b1101000010, 10'b0011010101, 10'b0011010101, 10'b1011000110, 10'b1011000110,\n            10'b1101001011, 10'b1101000100, 10'b0011011101, 10'b0011010010, 10'b1011000101, 10'b1011000101, 10'b0111000110, 10'b0111000110,\n            10'b0011011011, 10'b0011010100, 10'b1011001101, 10'b1011000010, 10'b0111000101, 10'b0111000101, 10'b0101110110, 10'b1010000110,\n            10'b1011001011, 10'b1011000100, 10'b0111001101, 10'b0111000010, 10'b0101110101, 10'b1010000101, 10'b0110110110, 10'b1001000110,\n            10'b0111001011, 10'b0111000100, 10'b0101110010, 10'b1010001101, 10'b0110110101, 10'b1001000101, 10'b1000110110, 10'b1000110110,\n            10'b0101110100, 10'b1010001011, 10'b0110110010, 10'b1001001101, 10'b1000110101, 10'b1000110101, 10'b0100110110, 10'b0100110110,\n            10'b0110110100, 10'b1001001011, 10'b1000111101, 10'b1000110010, 10'b0100110101, 10'b0100110101, 10'b1100100110, 10'b1100100110,\n            10'b1000111011, 10'b1000110100, 10'b0100111101, 10'b0100110010, 10'b1100100101, 10'b1100100101, 10'b0010110110, 10'b0010110110,\n            10'b0100111011, 10'b0100110100, 10'b1100101101, 10'b1100100010, 10'b0010110101, 10'b0010110101, 10'b1010100110, 10'b1010100110,\n            10'b1100101011, 10'b1100100100, 10'b0010111101, 10'b0010110010, 10'b1010100101, 10'b1010100101, 10'b0110100110, 10'b0110100110,\n            10'b0010111011, 10'b0010110100, 10'b1010101101, 10'b1010100010, 10'b0110100101, 10'b0110100101, 10'b1110100110, 10'b0001010110,\n            10'b1010101011, 10'b1010100100, 10'b0110101101, 10'b0110100010, 10'b1110100101, 10'b0001010101, 10'b1100110110, 10'b0011000110,\n            10'b0110101011, 10'b0110100100, 10'b1110100010, 10'b0001011101, 10'b1100110101, 10'b0011000101, 10'b1001100110, 10'b1001100110,\n            10'b1110100100, 10'b0001011011, 10'b1100110010, 10'b0011001101, 10'b1001100101, 10'b1001100101, 10'b0101100110, 10'b0101100110,\n            10'b1100110100, 10'b0011001011, 10'b1001101101, 10'b1001100010, 10'b0101100101, 10'b0101100101, 10'b1101100110, 10'b0010010110,\n            10'b1001101011, 10'b1001100100, 10'b0101101101, 10'b0101100010, 10'b1101100101, 10'b0010010101, 10'b0011100110, 10'b0011100110,\n            10'b0101101011, 10'b0101100100, 10'b1101100010, 10'b0010011101, 10'b0011100101, 10'b0011100101, 10'b1011100110, 10'b0100010110,\n            10'b1101100100, 10'b0010011011, 10'b0011101101, 10'b0011100010, 10'b1011100101, 10'b0100010101, 10'b0111100110, 10'b1000010110,\n            10'b0011101011, 10'b0011100100, 10'b1011100010, 10'b0100011101, 10'b0111100101, 10'b1000010101, 10'b1010110110, 10'b0101000110,\n            10'b1011100100, 10'b0100011011, 10'b0111100010, 10'b1000011101, 10'b1010110101, 10'b0101000101, 10'b1001110001, 10'b0110001110,\n            10'b0111100100, 10'b1000011011, 10'b1010110010, 10'b0101001101, 10'b1001110011, 10'b0110001100, 10'b0111010001, 10'b1000101110,\n            10'b1010110100, 10'b0101001011, 10'b1001111010, 10'b0110001010, 10'b0111010011, 10'b1000101100, 10'b1011010001, 10'b0100101110,\n            10'b1001111001, 10'b0110001001, 10'b0111011010, 10'b1000101010, 10'b1011010011, 10'b0100101100, 10'b1100011110, 10'b1100010001,\n            10'b0111011001, 10'b1000101001, 10'b1011011010, 10'b0100101010, 10'b1100011100, 10'b1100010011, 10'b1101010001, 10'b0010101110,\n            10'b1011011001, 10'b0100101001, 10'b1100011010, 10'b1100011010, 10'b1101010011, 10'b0010101100, 10'b1010011110, 10'b1010010001,\n            10'b1100011001, 10'b1100011001, 10'b1101011010, 10'b0010101010, 10'b1010011100, 10'b1010010011, 10'b0110011110, 10'b0110010001,\n            10'b1101011001, 10'b0010101001, 10'b1010011010, 10'b1010011010, 10'b0110011100, 10'b0110010011, 10'b1110001110, 10'b0001110001,\n            10'b1010011001, 10'b1010011001, 10'b0110011010, 10'b0110011010, 10'b1110001100, 10'b0001110011, 10'b1110010001, 10'b0001101110,\n            10'b0110011001, 10'b0110011001, 10'b1110001010, 10'b0001111010, 10'b1110010011, 10'b0001101100, 10'b1001011110, 10'b1001010001,\n            10'b1110001001, 10'b0001111001, 10'b1110011010, 10'b0001101010, 10'b1001011100, 10'b1001010011, 10'b0101011110, 10'b0101010001,\n            10'b1110011001, 10'b0001101001, 10'b1001011010, 10'b1001011010, 10'b0101011100, 10'b0101010011, 10'b1101001110, 10'b1101001000,\n            10'b1001011001, 10'b1001011001, 10'b0101011010, 10'b0101011010, 10'b1101001100, 10'b1101000011, 10'b0011011110, 10'b0011010001,\n            10'b0101011001, 10'b0101011001, 10'b1101001010, 10'b1101001010, 10'b0011011100, 10'b0011010011, 10'b1011001110, 10'b1011001000,\n            10'b1101001001, 10'b1101001001, 10'b0011011010, 10'b0011011010, 10'b1011001100, 10'b1011000011, 10'b0111001110, 10'b0111001000,\n            10'b0011011001, 10'b0011011001, 10'b1011001010, 10'b1011001010, 10'b0111001100, 10'b0111000011, 10'b0101110001, 10'b1010001110,\n            10'b1011001001, 10'b1011001001, 10'b0111001010, 10'b0111001010, 10'b0101110011, 10'b1010001100, 10'b0110110001, 10'b1001001110,\n            10'b0111001001, 10'b0111001001, 10'b0101111010, 10'b1010001010, 10'b0110110011, 10'b1001001100, 10'b1000110111, 10'b1000110001,\n            10'b0101111001, 10'b1010001001, 10'b0110111010, 10'b1001001010, 10'b1000111100, 10'b1000110011, 10'b0100110111, 10'b0100110001,\n            10'b0110111001, 10'b1001001001, 10'b1000111010, 10'b1000111010, 10'b0100111100, 10'b0100110011, 10'b1100101110, 10'b1100100001,\n            10'b1000111001, 10'b1000111001, 10'b0100111010, 10'b0100111010, 10'b1100101100, 10'b1100100011, 10'b0010110111, 10'b0010110001,\n            10'b0100111001, 10'b0100111001, 10'b1100101010, 10'b1100101010, 10'b0010111100, 10'b0010110011, 10'b1010101110, 10'b1010100001,\n            10'b1100101001, 10'b1100101001, 10'b0010111010, 10'b0010111010, 10'b1010101100, 10'b1010100011, 10'b0110101110, 10'b0110100001,\n            10'b0010111001, 10'b0010111001, 10'b1010101010, 10'b1010101010, 10'b0110101100, 10'b0110100011, 10'b1110100001, 10'b0001011110,\n            10'b1010101001, 10'b1010101001, 10'b0110101010, 10'b0110101010, 10'b1110100011, 10'b0001011100, 10'b1100110001, 10'b0011001110,\n            10'b0110101001, 10'b0110101001, 10'b1110101010, 10'b0001011010, 10'b1100110011, 10'b0011001100, 10'b1001101110, 10'b1001100001,\n            10'b1110101001, 10'b0001011001, 10'b1100111010, 10'b0011001010, 10'b1001101100, 10'b1001100011, 10'b0101101110, 10'b0101100001,\n            10'b1100111001, 10'b0011001001, 10'b1001101010, 10'b1001101010, 10'b0101101100, 10'b0101100011, 10'b1101100001, 10'b0010011110,\n            10'b1001101001, 10'b1001101001, 10'b0101101010, 10'b0101101010, 10'b1101100011, 10'b0010011100, 10'b0011101110, 10'b0011100001,\n            10'b0101101001, 10'b0101101001, 10'b1101101010, 10'b0010011010, 10'b0011101100, 10'b0011100011, 10'b1011100001, 10'b0100011110,\n            10'b1101101001, 10'b0010011001, 10'b0011101010, 10'b0011101010, 10'b1011100011, 10'b0100011100, 10'b0111100001, 10'b1000011110,\n            10'b0011101001, 10'b0011101001, 10'b1011101010, 10'b0100011010, 10'b0111100011, 10'b1000011100, 10'b1010110001, 10'b0101001110,\n            10'b1011101001, 10'b0100011001, 10'b0111101010, 10'b1000011010, 10'b1010110011, 10'b0101001100, 10'b1001110010, 10'b0110001101,\n            10'b0111101001, 10'b1000011001, 10'b1010111010, 10'b0101001010, 10'b1001110101, 10'b0110000101, 10'b0111010110, 10'b1000100110,\n            10'b1010111001, 10'b0101001001, 10'b1001110110, 10'b0110000110, 10'b0111010101, 10'b1000100101, 10'b1011010110, 10'b0100100110\n        };\n        begin\n            $display(\"Running Test: Random data Symbols\");\n            decoder_valid_in <= 0;\n            decoder_in <= 10'b0;\n            reset_in <= 1;\n            control_in <= 0;\n\n            @(posedge clk_in);\n            @(posedge clk_in);\n\n            for (i = 0; i < 512; i++) begin\n                @(posedge clk_in);\n                decoder_in <= allowed_values[$urandom_range(0, 511)];\n                reset_in <= 0;\n                control_in <= 0;\n                decoder_valid_in <= 1;\n            end\n\n            @(posedge clk_in);\n            decoder_valid_in <= 0;\n            control_in <= 0;\n            decoder_in <= 10'b0;\n        end\n    endtask\n\n    task test_incremental_data_symbol();\n        logic [9:0] allowed_values [0:23] = '{\n            10'h274, 10'h1d4, 10'h2d4, 10'h31b, 10'h0ab, 10'h294, 10'h19b, 10'h074,\n            10'h394, 10'h25b, 10'h154, 10'h34b, 10'h0d4, 10'h2cb, 10'h1c4, 10'h174,\n            10'h1b4, 10'h23b, 10'h134, 10'h32b, 10'h0b4, 10'h2ab, 10'h1a4, 10'h3a4\n        };\n        begin\n            $display(\"Running Test: incremental data Symbols\");\n            decoder_valid_in <= 0;\n            decoder_in <= 10'b0;\n            reset_in <= 1;\n            control_in <= 0;\n\n            @(posedge clk_in);\n            @(posedge clk_in);\n\n            for (i = 0; i < 24; i++) begin\n                @(posedge clk_in);\n                decoder_in <= allowed_values[i];\n                reset_in <= 0;\n                control_in <= 0;\n                decoder_valid_in <= 1;\n            end\n\n            @(posedge clk_in);\n            decoder_valid_in <= 0;\n            control_in <= 0;\n            decoder_in <= 10'b0;\n        end\n    endtask\n\nendmodule\n"}}, "output": {"response": "", "context": {"verif/tb_decoder_8b10b.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = d9e3e93ca23dec57cc56eeaafb2cfb2c1718cfd9\nNUM_BUGS        = 6\n", "src/decoder_8b10b.sv": "module decoder_8b10b (\n    input  logic        clk_in,             // Clock signal, triggers on rising edge\n    input  logic        reset_in,           // Reset signal, active high\n    input  logic        control_in,         // Control symbol indicator: HIGH for control, LOW for data\n    input  logic [9:0]  decoder_in,         // 10-bit encoded input\n    input  logic        decoder_valid_in,   // Input valid signal, active high\n    output logic [7:0]  decoder_out,        // 8-bit decoded output\n    output logic        decoder_valid_out,  // Output valid signal, active high\n    output logic        control_out         // Control symbol output, active high for control words\n);\n\n    logic [9:0] s_in_10b_reg;  \n    logic [7:0] s_decoder_out; \n    logic s_control_out;\n    logic [7:0] decoder_data_out;\n    logic control_data_out;    \n    logic decoder_control_valid;    \n    logic decoder_data_valid;    \n    logic a,b,c,d,e,i,f,g,h,j;  \n    logic w_aeqb, w_ceqd, w_p22, w_p13, w_p31;\n    logic eeqi, c_d_e_i, cn_dn_en_in;\n    logic w_p22_a_c_eeqi, w_p22_an_cn_eeqi;\n    logic w_p22_b_c_eeqi, w_p22_bn_cn_eeqi, an_bn_en_in;\n    logic a_b_e_i, w_p13_d_e_i, w_p13_in, w_p13_en, w_p31_i;\n    logic w_or12_1, w_or12_2, w_or12_3, w_or12_4, w_or12_5, w_or12_6, w_or12_7;\n    logic A, B, C, D, E;\n    logic K, F, G, H, K28p, w_ka, w_kb, w_kc;\n\n    function automatic [8:0] decode_8b10b(input logic [9:0] in);\n        case (in)\n\t`ifndef BUG_0\n            10'b0011110100, 10'b1100001011: decode_8b10b = {1'b1, 8'h1C};\n            10'b0011110010, 10'b1100001101: decode_8b10b = {1'b1, 8'h9C};\n            10'b0011111000, 10'b1100000111: decode_8b10b = {1'b1, 8'hFC};\n            10'b1110101000, 10'b0001010111: decode_8b10b = {1'b1, 8'hF7};\n            10'b1101101000, 10'b0010010111: decode_8b10b = {1'b1, 8'hFB};\n            10'b1011101000, 10'b0100010111: decode_8b10b = {1'b1, 8'hFD};\n            10'b0111101000, 10'b1000010111: decode_8b10b = {1'b1, 8'hFE};\n            10'b0011111001, 10'b1100000110: decode_8b10b = {1'b1, 8'h3C};\n            10'b0011110101, 10'b1100001010: decode_8b10b = {1'b1, 8'h5C};\n            10'b0011110011, 10'b1100001100: decode_8b10b = {1'b1, 8'h7C};\n            10'b0011111010, 10'b1100000101: decode_8b10b = {1'b1, 8'hBC};\n            10'b0011110110, 10'b1100001001: decode_8b10b = {1'b1, 8'hDC};\n\t`else\n            10'b0011110100, 10'b1100001011: decode_8b10b = {1'b1, 8'hCC};\n            10'b0011110010, 10'b1100001101: decode_8b10b = {1'b1, 8'h99};\n            10'b0011111000, 10'b1100000111: decode_8b10b = {1'b1, 8'h00};\n            10'b1110101000, 10'b0001010111: decode_8b10b = {1'b1, 8'h01};\n            10'b1101101000, 10'b0010010111: decode_8b10b = {1'b1, 8'hFF};\n            10'b1011101000, 10'b0100010111: decode_8b10b = {1'b1, 8'hFE};\n            10'b0111101000, 10'b1000010111: decode_8b10b = {1'b1, 8'hF0};\n            10'b0011111001, 10'b1100000110: decode_8b10b = {1'b1, 8'h12};\n            10'b0011110101, 10'b1100001010: decode_8b10b = {1'b1, 8'h34};\n            10'b0011110011, 10'b1100001100: decode_8b10b = {1'b1, 8'h56};\n            10'b0011111010, 10'b1100000101: decode_8b10b = {1'b1, 8'h89};\n            10'b0011110110, 10'b1100001001: decode_8b10b = {1'b1, 8'hDD};\n        `endif\n            default: decode_8b10b = {1'b0, 8'b00000000};\n        endcase\n    endfunction\n\n    always_comb begin\n        {s_control_out, s_decoder_out} = decode_8b10b(s_in_10b_reg);  \n    end\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            s_in_10b_reg <= 10'b0000000000;\n            decoder_control_valid <= 1'b0;\n        end else if (decoder_valid_in) begin\n\t`ifndef BUG_1\n            s_in_10b_reg <= decoder_in;  \n\t`else\n            s_in_10b_reg <= 'd0;  \n        `endif\n            decoder_control_valid <= 1'b1;  \n        end else begin\n            decoder_control_valid <= 1'b0;\n        end\n    end\n\n`ifndef BUG_2\n    assign {a,b,c,d,e,i,f,g,h,j} = decoder_in[9:0];\n`else\n    assign {a,b,c,d,e,i,f,g,h,j} = ~decoder_in[9:0];\n`endif\n    \n`ifndef BUG_3\n    assign K28p = ! (c | d | e | i);\n`else\n    assign K28p =  (c | d | e | i);\n`endif\n    assign F = (j & !f & (h | !g | K28p)) | (f & !j & (!h | g | !K28p)) | (K28p & g & h) | (!K28p & !g & !h);\n    assign G = (j & !f & (h | !g | !K28p)) | (f & !j & (!h | g |K28p)) | (!K28p & g & h) | (K28p & !g & !h);\n    assign H = ((j ^ h) & ! ((!f & g & !h & j & !K28p) | (!f & g & h & !j & K28p) | (f & !g & !h & j & !K28p) | (f & !g & h & !j & K28p))) | (!f & g & h & j) | (f & !g & !h & !j);\n    \n    assign w_aeqb = (a & b) | (!a & !b);\n    assign w_ceqd = (c & d) | (!c & !d);\n    assign w_p22 = (a & b & !c & !d) | (c & d & !a & !b) | ( !w_aeqb & !w_ceqd);\n    assign w_p13 = ( !w_aeqb & !c & !d) | ( !w_ceqd & !a & !b);\n    assign w_p31 = ( !w_aeqb & c & d) | ( !w_ceqd & a & b);\n    \n    assign eeqi = (e == i);\n    assign w_p22_a_c_eeqi = w_p22 & a & c & eeqi;\n    assign w_p22_an_cn_eeqi = w_p22 & !a & !c & eeqi;\n    assign cn_dn_en_in = (!c & !d & !e & !i);\n    assign c_d_e_i = (c & d & e & i);\n    assign w_ka = c_d_e_i | cn_dn_en_in;\n    assign w_kb = w_p13 & (!e & i & g & h & j);\n    assign w_kc = w_p31 & (e & !i & !g & !h & !j);\n    assign K = w_ka | w_kb | w_kc;\n    assign w_p22_b_c_eeqi = w_p22 & b & c & eeqi;\n    assign w_p22_bn_cn_eeqi = w_p22 & !b & !c & eeqi;\n    assign an_bn_en_in = !a & !b & !e & !i;\n    assign a_b_e_i = a & b & e & i;\n    assign w_p13_d_e_i = w_p13 & d & e & i;\n    assign w_p13_in = w_p13 & !i;\n    assign w_p13_en = w_p13 & !e;\n    assign w_p31_i = w_p31 & i;\n\n    assign w_or12_1 = w_p22_an_cn_eeqi | w_p13_en;\n    assign w_or12_2 = a_b_e_i | cn_dn_en_in | w_p31_i;\n    assign w_or12_3 = w_p31_i | w_p22_b_c_eeqi | w_p13_d_e_i;\n    assign w_or12_4 = w_p22_a_c_eeqi | w_p13_en;\n    assign w_or12_5 = w_p13_en | cn_dn_en_in | an_bn_en_in;\n    assign w_or12_6 = w_p22_an_cn_eeqi | w_p13_in;\n    assign w_or12_7 = w_p13_d_e_i | w_p22_bn_cn_eeqi;\n    \n`ifndef BUG_4\n    assign A = a ^ (w_or12_7 | w_or12_1 | w_or12_2);\n    assign B = b ^ (w_or12_2 | w_or12_3 | w_or12_4);\n    assign C = c ^ (w_or12_1 | w_or12_3 | w_or12_5);\n    assign D = d ^ (w_or12_2 | w_or12_4 | w_or12_7);\n    assign E = e ^ (w_or12_5 | w_or12_6 | w_or12_7);\n`else\n    assign A = a & (w_or12_7 | w_or12_1 & w_or12_2);\n    assign B = b & (w_or12_2 & w_or12_3 | w_or12_4);\n    assign C = c & (w_or12_1 | w_or12_3 & w_or12_5);\n    assign D = d & (w_or12_2 | w_or12_4 );\n    assign E = e & (w_or12_5 & w_or12_6 & w_or12_7);\n`endif\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            control_data_out <= 0; \n            decoder_data_out <= 8'b0;\n            decoder_data_valid <= 0; \n        end else begin\n            control_data_out <= K; \n`ifndef BUG_5\n            decoder_data_out <= { H, G, F, E, D, C, B, A };\n`else\n            decoder_data_out <= { A, B, C, D, E, F, G, H };\n`endif\n            decoder_data_valid <= decoder_valid_in;\n        end\n    end\n\n    assign decoder_out = (control_in) ? s_decoder_out  : decoder_data_out;\n    assign control_out = (control_in) ? s_control_out  : control_data_out;\n    assign decoder_valid_out = (control_in) ? decoder_control_valid  : decoder_data_valid;\n\nendmodule\n\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_digital_stopwatch_0017", "categories": ["cid012", "easy"], "input": {"prompt": "Complete the given partial SystemVerilog testbench`dig_stopwatch_tb`. The testbench must instantiate the `dig_stopwatch` RTL module and provide input stimulus to observe its behavior. This module implements a parameterized stopwatch with seconds, minutes, and hour tracking functionality. The testbench should include different input scenarios like start, stop, and reset operations.\n\n## **Description**\n\nThe `dig_stopwatch` module is a stopwatch that tracks elapsed time with inputs for clock, reset, and a start/stop control signal. It provides outputs for seconds, minutes, and hours, with appropriate rollovers and tracking behavior. The module operates based on a parameterized clock frequency (`CLK_FREQ`), which determines the timebase of the stopwatch.\n\n## **Parameters**\n- **CLK_FREQ**: Defines the input clock frequency in Hz, with a default value of 200 Hz. This frequency should be an integer value in Hz greater than the minimum value of 1 Hz. The clock divider within the module uses this parameter to generate a one-second pulse (`one_sec_pulse`).\n\n---\n\n## **Inputs**\n- **`clk`**: Clock signal for synchronizing operations. The design is synchronized to the positive edge of this clock.\n- **`reset`**: Asynchronous active-high reset signal to reset all counters to zero.\n- **`start_stop`**: Start/stop is a 1 bit control signal that controls if the stopwatch is running or paused. \n\n---\n\n## **Outputs**\n- **`seconds [5:0] `**: 6-bit output representing seconds (range: 0\u201359).\n- **`minutes [5:0]`**: 6-bit output representing minutes (range: 0\u201359).\n- **`hour`**: Represents a one-bit signal that updates to 1 when one hour has passed.\n\n---\n### **PERIOD Calculation**\nThe `PERIOD` is calculated using the formula `PERIOD = (1_000_000_000 / CLK_FREQ)`, where:\n- `1_000_000_000` represents 1 second in nanoseconds.\n- `CLK_FREQ` is the input clock frequency in Hz.\n- For `CLK_FREQ = 200`, the resulting `PERIOD = 5_000_000` nanoseconds (5 ms per clock cycle).\n\n## **Testbench Verification Features**\n\n### **Instantiation**\nThe `dig_stopwatch` module is instantiated as `uut`, with its inputs and outputs connected to corresponding testbench signals. The parameter `CLK_FREQ` is set explicitly for the testbench to validate the module under different clock frequency conditions.\n\n\n### **Clock Generation**:\n   - A clock signal is generated with a period of `PERIOD`, ensuring a frequency of `CLK_FREQ`.\n\n### **Reset Operation**:\n   - `reset` is asserted at the beginning to initialize the stopwatch and deasserted after 100 nanoseconds.\n\n### **Start and Stop Operations**:\n   - The stopwatch starts with `start_stop = 1` and stops with `start_stop = 0`.\n\n### **Wait for Specific Duration**:\n   - The testbench uses the one-second pulse from the stopwatch to simulate precise elapsed time durations.\n\n### **Test Sequences**:\n   - **Run for 1000 seconds**: The stopwatch runs with `start_stop = 1`.\n   - **Pause for 200 clock cycles**: The stopwatch is paused with `start_stop = 0`.\n   - **Run for 3000 seconds**: The stopwatch resumes operation.\n   - **Pause for 500 clock cycles**: The stopwatch is paused again.\n   - **Reset during operation**: The `reset` signal is asserted for 5 clock cycles to reset the counters.\n   - **Run for 100 seconds**: After the reset, the stopwatch resumes.\n\n### **Waveform Dumping**:\n   - Simulation data is saved to a `.vcd` file for waveform analysis.\n\n### Partial Test Stimulus Generator Code :\n``` verilog\nmodule dig_stopwatch_tb;\n\n    // Parameters\n    parameter  CLK_FREQ = 200;              //  200 Hz clock \n    localparam PERIOD = (1_000_000_000 / CLK_FREQ);\n\n    // Testbench Signals\n    reg clk;\n    reg reset;\n    reg start_stop;\n    wire [5:0] seconds;\n    wire [5:0] minutes;\n    wire hour;\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #(PERIOD/2) clk = ~clk;\n    end\n\n    // Instantiate the stopwatch module\n    dig_stopwatch #(\n        .CLK_FREQ(CLK_FREQ)\n    ) uut (\n        .clk(clk),\n        .reset(reset),\n        .start_stop(start_stop),\n        .seconds(seconds),\n        .minutes(minutes),\n        .hour(hour)\n    );\n\n    // Task to wait for a specific number of seconds\n    task wait_seconds(input integer num_seconds);\n        integer i;\n        begin\n            for (i = 0; i < num_seconds; i = i + 1) begin\n                @(posedge uut.one_sec_pulse);  \n                $display(\"Hour = %0d, Minutes = %0d , Seconds= %0d \", hour,minutes,seconds);\n            end\n        end\n    endtask\n    \n    // Insert the code for the remaining test stimulus here\n\nendmodule\n```\n", "context": {}}, "output": {"response": "", "context": {"verif/dig_stopwatch_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro \n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = f9b2a65e91a681af690aa937070032192e2e7567\nTARGET = 85\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nadd_scope -name dig_stopwatch*", "src/dig_stopwatch.sv": "module dig_stopwatch #(\n    parameter CLK_FREQ = 50000000  // Default clock frequency is 50 MHz\n)(\n    input wire clk,                // Input clock (parameterized frequency)\n    input wire reset,              // Reset signal\n    input wire start_stop,         // Start/Stop control\n    output reg [5:0] seconds,      // Seconds counter (0-59)\n    output reg [5:0] minutes,      // Minutes counter (0-59)\n    output reg hour                // Hour counter \n);\n\n    localparam COUNTER_MAX = CLK_FREQ - 1;  // Calculate max counter value\n    reg [$clog2(COUNTER_MAX):0] counter;    // Clock divider counter width based on CLK_FREQ\n    reg one_sec_pulse;                      // One second pulse signal\n\n    // Clock divider to create a 1 Hz clock pulse from parameterized frequency\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter <= 0;\n            one_sec_pulse <= 0;\n        end else begin\n            if (start_stop) begin\n                if (counter == COUNTER_MAX) begin\n                    counter <= 0;\n                    one_sec_pulse <= 1'b1;        // Generate a pulse every second\n                end else begin\n                    counter <= counter + 1;\n                    one_sec_pulse <= 1'b0;\n                end\n            end else begin\n                one_sec_pulse <= 1'b0;           // Ensure one_sec_pulse is cleared if paused\n            end\n        end\n    end\n\n    // Stopwatch logic\n    always @(posedge one_sec_pulse or posedge reset) begin\n        if (reset) begin\n            seconds <= 5'b0;\n            minutes <= 5'b0;\n            hour <= 1'b0;\n        end else if (start_stop == 1 && hour == 0) begin\n            if (seconds < 59) begin\n                seconds <= seconds + 1'b1;\n            end else begin\n                seconds <= 5'b0;\n                if (minutes < 59) begin\n                    minutes <= minutes + 1'b1;\n                end else begin\n                    minutes <= 5'b0;\n                    hour <= 1'b1;\n                end\n            end\n        end\n    end\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all -define CLK_FREQ=200 /src/dig_stopwatch.sv /code/verif/dig_stopwatch_tb.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_dot_product_0014", "categories": ["cid014", "medium"], "input": {"prompt": "Create SystemVerilog Assertions to verify the **functional correctness** of the `dot_product` module. The properties should ensure that:  \n\n1. **Start Signal Restrictions**: The `start_in` signal should not be asserted HIGH during the `COMPUTE`, `OUTPUT`, or `ERROR` states.  \n2. **Single Cycle Start Pulse**: The `start_in` signal must be asserted for only **one clock cycle** at the start of computation.  \n3. **Valid Dot Product Length**: When transitioning from `IDLE` to `COMPUTE` state (`start_in` asserted HIGH), `dot_length_in` must be nonzero.  \n4. **Error Flag Stability**: The `dot_product_error_out` signal should not be HIGH **if both `vector_a_valid_in` and `vector_b_valid_in` remain stable** throughout the `COMPUTE` state.  \n\nEach assertion must provide a **detailed failure message**, including `state`, `start_in`, `dot_length_in`, and `dot_product_error_out` where applicable, for debugging purposes.\n\n---\n\n### RTL Specification  \n\n#### Module Name: `dot_product` \n\nThe `dot_product` module computes the dot product of two input vectors (A and B) with configurable lengths and complexities (real or complex). The module supports three modes of operation: real-only, complex-only, and mixed (one real and one complex). The output format is dynamically adjusted based on the input configuration, providing either a 32-bit real result or concatenated real and imaginary components.\n\n#### **Modes of Operation**:\n1. **Real-Only Mode**:  \n   - Both vectors are real. The dot product is calculated as the summation of element-wise multiplication:  \n     `Dot Product = SUM(A \u00d7 B)`.\n\n2. **Complex-Only Mode**:  \n   - Both vectors are complex, represented as `{Imaginary[31:16], Real[15:0]}`.  \n   - Dot product is computed as:  \n     - Real part: `SUM (A_re \u00d7 B_re - A_im \u00d7 B_im)`  \n     - Imaginary part: `SUM (A_re \u00d7 B_im + A_im \u00d7 B_re)`  \n\n3. **Mixed Mode**:  \n   - One vector is complex, and the other is real. The dot product is computed as:  \n     - Real part: `SUM (A_re \u00d7 B_re)`  \n     - Imaginary part: `SUM (A_im \u00d7 B_re)` (or vice versa depending on input).\n \n#### IO Ports  \n\n| Port Name              | Direction| Size       | Description                                        |\n|------------------------|----------|------------|----------------------------------------------------|\n| `clk_in`               | Input    | 1 bit      | Positive Edge triggered Clock signal               |\n| `reset_in`             | Input    | 1 bit      | Asynchronous Active-high reset                     |\n| `start_in`             | Input    | 1 bit      | Start computation signal                           |\n| `dot_length_in[7:0]`   | Input    | 8 bits     | Length of the dot product vectors                  |\n| `vector_a_in[31:0]`    | Input    | 32 bits    | Input vector A (32-bit)                            |\n| `vector_a_valid_in`    | Input    | 1 bit      | Valid signal for vector A                          |\n| `vector_b_in[31:0]`    | Input    | 32 bits    | Input vector B (32-bit)                            |\n| `vector_b_valid_in`    | Input    | 1 bit      | Valid signal for vector B                          |\n| `a_complex_in`         | Input    | 1 bit      | Is vector A complex? (1 = complex, 0 = real)       |\n| `b_complex_in`         | Input    | 1 bit      | Is vector B complex? (1 = complex, 0 = real)       |\n| `dot_product_out[31:0]`| Output   | 32 bits    | Output dot product result (32-bit)                 |\n| `dot_product_error_out`| Output   | 1 bit      | Error signal for invalid input conditions          |\n| `dot_product_valid_out`| Output   | 1 bit      | Valid signal for dot product output                |", "context": {"rtl/dot_product.sv": "module dot_product (\n    input               clk_in,                     // Clock signal\n    input               reset_in,                   // Asynchronous Reset signal, Active HIGH\n    input               start_in,                   // Start computation signal\n    input       [7:0]   dot_length_in,              // Length of the dot product vectors\n    input       [31:0]  vector_a_in,                // Input vector A (32-bit)\n    input               vector_a_valid_in,          // Valid signal for vector A\n    input       [31:0]  vector_b_in,                // Input vector B (32-bit)\n    input               vector_b_valid_in,          // Valid signal for vector B\n    input               a_complex_in,               // Is vector A complex? (1 = complex, 0 = real)\n    input               b_complex_in,               // Is vector B complex? (1 = complex, 0 = real)\n    output logic [31:0] dot_product_out,            // Output dot product result (32-bit)\n    output logic        dot_product_error_out,      // Error signal for invalid input conditions\n    output logic        dot_product_valid_out       // Valid signal for dot product output\n);\n\n    typedef enum logic [1:0] {\n        IDLE    = 2'b00,\n        COMPUTE = 2'b01,\n        OUTPUT  = 2'b10,\n        ERROR   = 2'b11\n    } state_t;\n\n    state_t state;\n    logic [31:0] acc;\n    logic signed [31:0] acc_re, acc_im;\n    logic [7:0] cnt;\n    logic [7:0] dot_length_reg;\n    logic a_complex_reg;\n    logic b_complex_reg;\n    logic vector_a_valid_in_prev;\n    logic vector_b_valid_in_prev;\n\n    wire signed [15:0] a_re, a_im;\n    wire signed [15:0] b_re, b_im;\n\n    logic               start_d1;\n    logic       [7:0]   dot_length_d1;\n    logic       [31:0]  vector_a_d1;\n    logic               vector_a_valid_d1;\n    logic       [31:0]  vector_b_d1;\n    logic               vector_b_valid_d1;\n    logic               a_complex_d1;\n    logic               b_complex_d1;\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            start_d1           <= 1'b0;\n            dot_length_d1      <= 8'b0;\n            vector_a_d1        <= 32'b0;\n            vector_a_valid_d1  <= 1'b0;\n            vector_b_d1        <= 32'b0;\n            vector_b_valid_d1  <= 1'b0;\n            a_complex_d1      <= 1'b0;\n            b_complex_d1       <= 1'b0;\n        end else begin\n            start_d1           <= start_in;\n            dot_length_d1      <= dot_length_in;\n            vector_a_d1        <= vector_a_in;\n            vector_a_valid_d1  <= vector_a_valid_in;\n            vector_b_d1        <= vector_b_in;\n            vector_b_valid_d1  <= vector_b_valid_in;\n            a_complex_d1       <= a_complex_in;\n            b_complex_d1       <= b_complex_in;\n        end\n    end\n\n    assign a_re = a_complex_reg ? vector_a_d1[15:0] : vector_a_d1;\n    assign a_im = a_complex_reg ? vector_a_d1[31:16] : 0;\n    assign b_re = b_complex_reg ? vector_b_d1[15:0] : vector_b_d1;\n    assign b_im = b_complex_reg ? vector_b_d1[31:16] : 0;\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            state <= IDLE;\n            acc <= 0;\n            acc_re <= 0;\n            acc_im <= 0;\n            cnt <= 0;\n            dot_product_out <= 0;\n            dot_product_valid_out <= 0;\n            dot_length_reg <= 0;\n            a_complex_reg <= 0;\n            b_complex_reg <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    dot_product_valid_out <= 0;\n                    dot_length_reg <= dot_length_d1;\n                    a_complex_reg <= a_complex_d1;\n                    b_complex_reg <= b_complex_d1;\n                    if (start_d1) begin\n                        state <= COMPUTE;\n                        acc <= 0;\n                        acc_re <= 0;\n                        acc_im <= 0;\n                        cnt <= 0;\n                    end\n                end\n                COMPUTE: begin\n                    if (vector_a_valid_d1 && vector_b_valid_d1) begin\n                        if (a_complex_reg || b_complex_reg) begin\n                            if (a_complex_reg && b_complex_reg) begin\n                                acc_re <= acc_re + (a_re * b_re - a_im * b_im);\n                                acc_im <= acc_im + (a_re * b_im + a_im * b_re);\n                            end else if (a_complex_reg) begin\n                                acc_re <= acc_re + (a_re * b_re);\n                                acc_im <= acc_im + (a_im * b_re);\n                            end else if (b_complex_reg) begin\n                                acc_re <= acc_re + (a_re * b_re);\n                                acc_im <= acc_im + (a_re * b_im);\n                            end\n                        end else begin\n                            acc <= acc + (vector_a_d1 * vector_b_d1);\n                        end\n                        cnt <= cnt + 1;\n                    end\n                    if (cnt == dot_length_reg - 1) begin\n                        state <= OUTPUT;\n                    end else if (dot_product_error_out) begin\n                        state <= ERROR;\n                    end else begin\n                        state <= COMPUTE;\n                    end\n                end\n                OUTPUT: begin\n                    if (a_complex_reg || b_complex_reg) begin\n                        dot_product_out <= {acc_im[15:0], acc_re[15:0]};\n                    end else begin\n                        dot_product_out <= acc;\n                    end\n                    dot_product_valid_out <= 1;\n                    state <= IDLE;\n                end\n                ERROR: begin\n                    dot_product_out <= 0;\n                    dot_product_valid_out <= 0;\n                    state <= IDLE;\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            dot_product_error_out <= 0;\n        end else begin\n            if (state == IDLE && start_d1) begin\n                dot_product_error_out <= 0;\n            end\n            if (state == COMPUTE) begin\n                if ((vector_a_valid_in_prev && !vector_a_valid_d1) || (vector_b_valid_in_prev && !vector_b_valid_d1)) begin\n                    dot_product_error_out <= 1;\n                end\n            end\n        end\n    end\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            vector_a_valid_in_prev <= 0;\n            vector_b_valid_in_prev <= 0;\n        end else begin\n            vector_a_valid_in_prev <= vector_a_valid_d1;\n            vector_b_valid_in_prev <= vector_b_valid_d1;\n        end\n    end\n    \nendmodule"}}, "output": {"response": "", "context": {"rtl/dot_product.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/dot_product.sv\nTOPLEVEL        = dot_product\nMODULE          = test_dot_product\nPYTHONPATH      = /src\nHASH            = 6cdca0186b81b95992b89e30c8e71739ef596152\n", "src/test_dot_product.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n# Parameters\nA_DW = 32\nB_DW = 32\nOUT_DW = 32\nrandom.seed(42)  # Ensures reproducibility of random values\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and set all inputs to their default values.\"\"\"\n    dut.reset_in.setimmediatevalue(1)\n    dut.vector_a_valid_in.value = 0\n    dut.dot_length_in.value = 0\n    dut.vector_b_valid_in.value = 0\n    dut.start_in.value = 0\n    dut.vector_a_in.value = 0\n    dut.vector_b_in.value = 0\n    dut.a_complex_in.value = 0\n    dut.b_complex_in.value = 0\n\n    # Start the clock\n    clock = Clock(dut.clk_in, 20, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Reset procedure\n    await RisingEdge(dut.clk_in)\n    dut.reset_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.reset_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut._log.info(\"DUT Initialized: Reset completed and inputs set to default.\")\n\nasync def send_vector(dut, vec_a, vec_b, length, a_complex=0, b_complex=0, interrupt_valid=False):\n    \"\"\"Send vector inputs to the DUT.\"\"\"\n    dut.dot_length_in.value = length\n    dut.a_complex_in.value = a_complex\n    dut.b_complex_in.value = b_complex\n    await RisingEdge(dut.clk_in)\n    dut.start_in.value = 1\n\n    dut._log.info(f\"Sending Vectors: Length = {length}, a_complex = {a_complex}, b_complex = {b_complex}\")\n    for i in range(length):\n        await RisingEdge(dut.clk_in)\n        dut.start_in.value = 0\n        dut.vector_a_in.value = vec_a[i]\n        dut.vector_b_in.value = vec_b[i]\n        dut.vector_a_valid_in.value = 1\n        dut.vector_b_valid_in.value = 1\n# Print the input vectors and valid signals in hex format\n        if interrupt_valid and i == length // 2:\n            # Simulate an interruption\n            dut.vector_a_valid_in.value = 0\n            dut.vector_b_valid_in.value = 0\n            await RisingEdge(dut.clk_in)\n        dut._log.info(f\"Cycle {i + 1}: vector_a_in = {hex(vec_a[i])}, \"\n                      f\"vector_b_in = {hex(vec_b[i])}, \"\n                      f\"vector_a_valid_in = {hex(int(dut.vector_a_valid_in.value))}, \"\n                      f\"vector_b_valid_in = {hex(int(dut.vector_b_valid_in.value))}\")\n\n    await RisingEdge(dut.clk_in)\n    dut.vector_a_valid_in.value = 0\n    dut.vector_b_valid_in.value = 0\n\nasync def check_result(dut, expected_result, expected_error=False):\n    \"\"\"Check the DUT result and validate correctness.\"\"\"\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    valid = int(dut.dot_product_valid_out.value)\n    error = int(dut.dot_product_error_out.value)\n    result = int(dut.dot_product_out.value)\n\n    dut._log.info(f\"DUT Output: result = {result}, valid = {valid}, error = {error}\")\n\n    if error:\n        if not expected_error:\n            dut._log.error(\"Unexpected error detected! Dot product error asserted when it shouldn't be.\")\n            assert False\n        else:\n            dut._log.info(\"Dot product error correctly asserted as expected.\")\n    elif valid:\n        if expected_error:\n            dut._log.error(\"Expected dot product error, but valid_out is HIGH.\")\n            assert False\n        elif result != expected_result:\n            dut._log.error(f\"Result mismatch! Expected: {expected_result}, Got: {result}\")\n            assert False\n        else:\n            dut._log.info(f\"Result matches expected value: {expected_result}\")\n    else:\n        dut._log.error(\"Unexpected state: Neither valid_out nor error_out is asserted.\")\n        assert False\n\n# Original Tests (Updated to include a_complex and b_complex)\n\n@cocotb.test()\nasync def test_case_reset_assert(dut):\n    \"\"\"Test Case: Reset behavior during computation.\"\"\"\n    await initialize_dut(dut)\n\n    vec_a = [1, 1, 1, 1]\n    vec_b = [1, 2, 3, 4]\n\n    await send_vector(dut, vec_a, vec_b, 4, a_complex=0, b_complex=0)\n\n    # Assert reset during computation\n    dut.reset_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    dut._log.info(f\"Inputs after reset: vector_a_in = {dut.vector_a_in.value}, vector_b_in = {dut.vector_b_in.value}\")\n    dut._log.info(f\"Outputs after reset: dot_product_out = {dut.dot_product_out.value}, dot_product_valid_out = {dut.dot_product_valid_out.value}\")\n\n    assert dut.dot_product_out.value == 0, f\"dot_product_out expected to be 0, got {int(dut.dot_product_out.value)}\"\n    assert dut.dot_product_valid_out.value == 0, \"dot_product_valid_out expected to be 0, but it is HIGH\"\n\n    dut._log.info(\"Reset behavior verified: Outputs reset to 0 as expected.\")\n\n@cocotb.test()\nasync def test_case_length_4(dut):\n    \"\"\"Test Case : Length 4.\"\"\"\n    await initialize_dut(dut)\n\n    vec_a = [1, 1, 1, 1]\n    vec_b = [1, 2, 3, 4]\n    expected_result = sum(a * b for a, b in zip(vec_a, vec_b))\n\n    await send_vector(dut, vec_a, vec_b, 4, a_complex=0, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def test_case_length_8(dut):\n    \"\"\"Test Case : Length 8.\"\"\"\n    await initialize_dut(dut)\n\n    vec_a = [2] * 8\n    vec_b = [i + 1 for i in range(8)]\n    expected_result = sum(a * b for a, b in zip(vec_a, vec_b))\n\n    await send_vector(dut, vec_a, vec_b, 8, a_complex=0, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def test_case_random_length_6(dut):\n    \"\"\"Test Case : Random Length 6.\"\"\"\n    await initialize_dut(dut)\n\n    vec_a = [random.randint(0, 255) for _ in range(6)]\n    vec_b = [random.randint(0, 65535) for _ in range(6)]\n    expected_result = sum(a * b for a, b in zip(vec_a, vec_b))\n\n    await send_vector(dut, vec_a, vec_b, 6, a_complex=0, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def test_case_random_length_127(dut):\n    \"\"\"Test Case : Random Length 127.\"\"\"\n    await initialize_dut(dut)\n\n    vec_a = [random.randint(0, 255) for _ in range(127)]\n    vec_b = [random.randint(0, 65535) for _ in range(127)]\n    expected_result = sum(a * b for a, b in zip(vec_a, vec_b))\n\n    await send_vector(dut, vec_a, vec_b, 127, a_complex=0, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def test_case_random_length_99(dut):\n    \"\"\"Test Case : Random Length 99.\"\"\"\n    await initialize_dut(dut)\n\n    vec_a = [random.randint(0, 255) for _ in range(99)]\n    vec_b = [random.randint(0, 65535) for _ in range(99)]\n    expected_result = sum(a * b for a, b in zip(vec_a, vec_b))\n\n    await send_vector(dut, vec_a, vec_b, 99, a_complex=0, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def test_case_random_vectors_and_length(dut):\n    \"\"\"Test Case : Random Length.\"\"\"\n    await initialize_dut(dut)\n\n    length = random.randint(1, 127)\n    vec_a = [random.randint(0, 255) for _ in range(length)]\n    vec_b = [random.randint(0, 65535) for _ in range(length)]\n    expected_result = sum(a * b for a, b in zip(vec_a, vec_b))\n\n    dut._log.info(f\"Random Length: {length}\")\n\n    await send_vector(dut, vec_a, vec_b, length, a_complex=0, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n# New Tests (Appended)\n@cocotb.test()\nasync def dot_product_complex_vecb_test(dut):\n    \"\"\"Test Case: Complex Mode for Vector B\"\"\"\n    await initialize_dut(dut)\n\n    LEN = 4\n    vec_a = [1] * LEN\n    vec_b = [-x for x in range(LEN)]\n\n    # Correctly pack vec_b: MSB = Imaginary, LSB = Real\n    vec_b_twos_complex = [(b & 0xFFFF) | ((b & 0xFFFF) << 16) for b in vec_b]\n\n    # Calculate expected result\n    acc_re, acc_im = 0, 0\n    for a, b in zip(vec_a, vec_b_twos_complex):\n        b_re = b & 0xFFFF\n        b_im = (b >> 16) & 0xFFFF\n\n        b_re = b_re if b_re < 0x8000 else b_re - 0x10000\n        b_im = b_im if b_im < 0x8000 else b_im - 0x10000\n\n        acc_re += a * b_re\n        acc_im += a * b_im\n\n    acc_re &= 0xFFFF\n    acc_im &= 0xFFFF\n    expected_result = (acc_im << 16) | acc_re\n\n    await send_vector(dut, vec_a, vec_b_twos_complex, LEN, a_complex=0, b_complex=1, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def dot_product_complex_veca_test(dut):\n    \"\"\"Test Case: Complex Mode for Vector A\"\"\"\n    await initialize_dut(dut)\n\n    LEN = 4\n    vec_a = [-x for x in range(LEN)]\n    vec_b = [1] * LEN\n\n    # Correctly pack vec_a: MSB = Imaginary, LSB = Real\n    vec_a_twos_complex = [(a & 0xFFFF) | ((a & 0xFFFF) << 16) for a in vec_a]\n\n    acc_re, acc_im = 0, 0\n    for a, b in zip(vec_a_twos_complex, vec_b):\n        a_re = a & 0xFFFF\n        a_im = (a >> 16) & 0xFFFF\n\n        a_re = a_re if a_re < 0x8000 else a_re - 0x10000\n        a_im = a_im if a_im < 0x8000 else a_im - 0x10000\n\n        acc_re += a_re * b\n        acc_im += a_im * b\n\n    acc_re &= 0xFFFF\n    acc_im &= 0xFFFF\n    expected_result = (acc_im << 16) | acc_re\n\n    await send_vector(dut, vec_a_twos_complex, vec_b, LEN, a_complex=1, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def dot_product_both_vec_complex_test(dut):\n    \"\"\"Test Case: Both Vectors in Complex Mode\"\"\"\n    await initialize_dut(dut)\n\n    LEN = 8\n    vec_a = [-x for x in range(LEN)]\n    vec_b = [-x for x in range(LEN)]\n\n    # Correctly pack vec_a and vec_b into unsigned 32-bit format\n    vec_a_twos_complex = [(a & 0xFFFF) | ((a & 0xFFFF) << 16) for a in vec_a]\n    vec_b_twos_complex = [(b & 0xFFFF) | ((b & 0xFFFF) << 16) for b in vec_b]\n\n    # Calculate expected result\n    acc_re = 0\n    acc_im = 0\n    for a, b in zip(vec_a_twos_complex, vec_b_twos_complex):\n        # Extract real and imaginary parts\n        a_re = a & 0xFFFF\n        a_im = (a >> 16) & 0xFFFF\n        b_re = b & 0xFFFF\n        b_im = (b >> 16) & 0xFFFF\n\n        # Convert to signed 16-bit\n        a_re = a_re if a_re < 0x8000 else a_re - 0x10000\n        a_im = a_im if a_im < 0x8000 else a_im - 0x10000\n        b_re = b_re if b_re < 0x8000 else b_re - 0x10000\n        b_im = b_im if b_im < 0x8000 else b_im - 0x10000\n\n        # Accumulate real and imaginary parts\n        acc_re += a_re * b_re - a_im * b_im\n        acc_im += a_re * b_im + a_im * b_re\n\n    # Convert to 16-bit two's complement\n    acc_re &= 0xFFFF\n    acc_im &= 0xFFFF\n\n    # Combine into 32-bit result\n    expected_result = (acc_im << 16) | acc_re\n\n    # Send vectors to the DUT and check the result\n    await send_vector(dut, vec_a_twos_complex, vec_b_twos_complex, LEN, a_complex=1, b_complex=1, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n\n@cocotb.test()\nasync def dot_product_complex_veca_random_vecb_test(dut):\n    \"\"\"Test Case: Complex Mode for Vector A with Random Length and Values for Vector B\"\"\"\n    await initialize_dut(dut)\n\n    # Randomize length and vectors\n    LEN = random.randint(2, 128)  # Random length between 2 and 128\n    vec_a = [-x for x in range(LEN)]  # Deterministic values for vector A\n    vec_b = [random.randint(-128, 127) for _ in range(LEN)]  # Random values for vector B\n\n    # Correctly pack vec_a: MSB = Imaginary, LSB = Real\n    vec_a_twos_complex = [(a & 0xFFFF) | ((a & 0xFFFF) << 16) for a in vec_a]\n\n    acc_re, acc_im = 0, 0\n    for a, b in zip(vec_a_twos_complex, vec_b):\n        a_re = a & 0xFFFF\n        a_im = (a >> 16) & 0xFFFF\n\n        # Convert to signed 16-bit\n        a_re = a_re if a_re < 0x8000 else a_re - 0x10000\n        a_im = a_im if a_im < 0x8000 else a_im - 0x10000\n\n        # Accumulate real and imaginary parts\n        acc_re += a_re * b\n        acc_im += a_im * b\n\n    # Truncate results to 16-bit and combine into 32-bit output\n    acc_re &= 0xFFFF\n    acc_im &= 0xFFFF\n    expected_result = (acc_im << 16) | acc_re\n\n    # Log the test details for debugging\n    dut._log.info(f\"Test Parameters: LEN = {LEN}\")\n    dut._log.info(f\"Expected Result: 0x{expected_result:08X}\")\n\n    # Send vectors to the DUT and check the result\n    await send_vector(dut, vec_a_twos_complex, vec_b, LEN, a_complex=1, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def dot_product_error_insert_test(dut):\n    \"\"\"Test Case: Complex Mode for Vector B\"\"\"\n    await initialize_dut(dut)\n\n    LEN = 4\n    vec_a = [1] * LEN\n    vec_b = [-x for x in range(LEN)]\n\n    # Correctly pack vec_b: MSB = Imaginary, LSB = Real\n    vec_b_twos_complex = [(b & 0xFFFF) | ((b & 0xFFFF) << 16) for b in vec_b]\n\n    # Calculate expected result\n    acc_re, acc_im = 0, 0\n    for a, b in zip(vec_a, vec_b_twos_complex):\n        b_re = b & 0xFFFF\n        b_im = (b >> 16) & 0xFFFF\n\n        b_re = b_re if b_re < 0x8000 else b_re - 0x10000\n        b_im = b_im if b_im < 0x8000 else b_im - 0x10000\n\n        acc_re += a * b_re\n        acc_im += a * b_im\n\n    acc_re &= 0xFFFF\n    acc_im &= 0xFFFF\n    expected_result = (acc_im << 16) | acc_re\n\n    await send_vector(dut, vec_a, vec_b_twos_complex, LEN, a_complex=0, b_complex=1, interrupt_valid=True)\n    await check_result(dut, expected_result, expected_error=True)\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_edge_detector_0014", "categories": ["cid013", "easy"], "input": {"prompt": "Create a **SystemVerilog testbench checker** with detailed stimulus to test using checker and to validate the `sync_pos_neg_edge_detector` module by applying exhaustive test scenarios and verifying the correctness of its **edge detected** output. The testbench should ensure:\n\n- Comprehensive **input stimulus** generation covering all possible cases.\n- **Correctness verification** of the edge detected output.\n- **Checker generation** to confirm all relevant scenarios are tested.\n\n---\n## **Instantiation**\nName the instance of the RTL as `dut`.\n\n## **RTL Inputs & Expected Outputs with behavioral Definitions**\n\n### Inputs:\n- `i_clk`: Clock signal (active on rising edge).\n- `i_rstb`: Asynchronous reset signal (active low).\n- `i_detection_signal`: Glitch-free, debounced signal whose edges are to be detected.\n\n### Outputs:\n- `o_positive_edge_detected`: Asserted for one clock cycle when a positive edge is detected on `i_detection_signal`.\n- `o_negative_edge_detected`: Asserted for one clock cycle when a negative edge is detected on `i_detection_signal`.\n\n### Behavioral Definition\n- When the module detects a **positive edge** (rising transition) on `i_detection_signal`, the output `o_positive_edge_detected` should be asserted high for **one clock cycle**.\n- When the module detects a **negative edge** (falling transition) on `i_detection_signal`, the output `o_negative_edge_detected` should be asserted high for **one clock cycle**.\n- The design assumes that `i_detection_signal` is **glitch-free and debounced**, so no additional debouncing logic is required.\n\n### Reset Behavior\n- When the asynchronous reset (`i_rstb`) is active (low), all outputs (`o_positive_edge_detected` and `o_negative_edge_detected`) should be reset to `0`, and internal state should be cleared.\n- When the reset is de-asserted, normal edge detection should resume.\n\n## Stimulus and checker Generation\n\n- **Reset Asserted (Cycle 0):**  \n  - `i_rstb` = 0, `i_detection_signal` = 0  \n  - Expect both outputs = 0\n\n- **Release Reset with Input Low (Cycle 1):**  \n  - `i_rstb` \u2192 1, `i_detection_signal` = 0  \n  - No edge yet, both outputs = 0\n\n- **Hold Input Low (Cycles 2\u20133):**  \n  - `i_detection_signal` = 0  \n  - No edges, both outputs remain 0\n\n- **Positive Edge (Cycle 4):**  \n  - `i_detection_signal` \u2192 1 (0\u21921)  \n  - Expect `o_positive_edge_detected` = 1 for one cycle, `o_negative_edge_detected` = 0\n\n- **Hold Input High (Cycles 5\u20136):**  \n  - `i_detection_signal` = 1  \n  - No further edges, both outputs = 0\n\n- **Negative Edge (Cycle 7):**  \n  - `i_detection_signal` \u2192 0 (1\u21920)  \n  - Expect `o_positive_edge_detected` = 0, `o_negative_edge_detected` = 1 for one cycle\n\n- **Hold Input Low (Cycles 8\u20139):**  \n  - `i_detection_signal` = 0  \n  - Both outputs = 0\n\n- **Back-to-Back Edges (Cycles 10\u201311):**  \n  - Cycle 10: `i_detection_signal` = 0 \u2192 1  \n    - Expect `o_positive_edge_detected` = 1  \n  - Cycle 11: `i_detection_signal` = 1 \u2192 0  \n    - Expect `o_negative_edge_detected` = 1\n\n- **Asynchronous Reset During Low (Cycle 12):**  \n  - `i_rstb` \u2192 0 (reset asserted), `i_detection_signal` = 0  \n  - Expect outputs = 0\n\n- **Stay in Reset (Cycle 13):**  \n  - `i_rstb` = 0, `i_detection_signal` = 0  \n  - Outputs remain 0\n\n- **Release Reset (Cycle 14):**  \n  - `i_rstb` \u2192 1, `i_detection_signal` = 0  \n  - No edges, outputs = 0\n\n- **Positive Edge After Reset (Cycle 15):**  \n  - `i_detection_signal` = 0 \u2192 1  \n  - Expect `o_positive_edge_detected` = 1, `o_negative_edge_detected` = 0\n\n- **Short Pulse (Cycle 16):**  \n  - `i_detection_signal` = 1 \u2192 0  \n  - Expect `o_positive_edge_detected` = 0, `o_negative_edge_detected` = 1\n\n- **Final Stable Condition (Cycle 17+):**  \n  - `i_detection_signal` = 0, `i_rstb` = 1  \n  - Outputs remain 0\n\n## Simulation\n- Reset the dut and initialize inputs.\n- Apply the test cases sequentially.\n- Log errors if any discrepancies are found between dut outputs and the model using `$error`.\n\n## Deliverables\nProvide the complete SystemVerilog testbench code with:\n1. dut instantiation.\n2. Implement a behavioral model to replicate the expected functionality.\n3. Test scenarios validating the dut against the expected behavior.\n4. Compare the outputs from the DUT with the model using checkers\n5. Log messages indicating pass/fail status for each test case.\n---", "context": {}}, "output": {"response": "", "context": {"verif/tb_sync_pos_neg_edge_detector.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/sync_pos_neg_edge_detector.sv\nHASH            = 14-tb-checker\nNUM_BUGS        = 4", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"", "src/sync_pos_neg_edge_detector.sv": "module sync_pos_neg_edge_detector (\n    input i_clk,                                // Clock\n    input i_rstb,                               // Async reset, active low\n    input i_detection_signal,                   // Sync input signal whose edge will be detected (glitch-free, debounced)\n    output reg o_positive_edge_detected,        // Single clock period output if positive edge detected on i_detection_signal\n    output reg o_negative_edge_detected         // Single clock period output if negative edge detected on i_detection_signal\n);\n\n    // State register to hold the delayed version of the input signal\n    reg r_delayed_input_signal; \n\n    // Logic for detecting positive and negative edges\n    always @(posedge i_clk or negedge i_rstb) begin\n        if (!i_rstb) begin\n            `ifdef BUG_0\n                r_delayed_input_signal <= 1'b1;        // Reset the delayed signal\n                o_positive_edge_detected <= 1'b1;      // Reset positive edge detection output\n                o_negative_edge_detected <= 1'b1;      // Reset negative edge detection output\n            `else\n                r_delayed_input_signal <= 1'b0;        // Reset the delayed signal\n                o_positive_edge_detected <= 1'b0;      // Reset positive edge detection output\n                o_negative_edge_detected <= 1'b0;      // Reset negative edge detection output\n            `endif\n            // Reset logic\n            \n        end else begin\n            \n            `ifdef BUG_1\n                // Positive edge detection\n                o_positive_edge_detected <= !i_detection_signal && (r_delayed_input_signal); \n            `elsif BUG_2\n                // Negative edge detection\n                o_negative_edge_detected <= (i_detection_signal) && r_delayed_input_signal; \n            `elsif BUG_3\n                // Update delayed input signal\n                r_delayed_input_signal <= !i_detection_signal; \n            `else\n                o_positive_edge_detected <= i_detection_signal && (!r_delayed_input_signal); \n                o_negative_edge_detected <= (!i_detection_signal) && r_delayed_input_signal; \n                r_delayed_input_signal <= i_detection_signal; \n            `endif\n        end\n    end\n\nendmodule"}}}
{"id": "cvdp_copilot_encoder_8b10b_0023", "categories": ["cid014", "easy"], "input": {"prompt": "We have an 8b10b encoder module intended for control-symbol encoding only. The encoder converts an 8\u2011bit input into a 10\u2011bit encoded output and tracks running disparity. Internally, it registers the 8\u2011bit input and the control flag. When the control flag is asserted HIGH, the encoder uses a lookup table to map the 8\u2011bit value to a 10\u2011bit control code. Only 12 valid control codes are supported (8'h1C, 8'h3C, 8'h5C, 8'h7C, 8'h9C, 8'hBC, 8'hDC, 8'hFC, 8'hF7, 8'hFB, 8'hFD, and 8'hFE). If an unrecognized control code is detected while the control flag is high, the design defaults to a zero codeword. The encoding behavior is as follows:\n\n- In **data mode** (when no `control_in` is indicated), the encoder output is zero.\n- In **control mode** (when `control_in` is indicated, i.e. when the registered control input, `s_ctrl_reg`, is 1), the encoder uses a lookup based on the 8\u2011bit registered input (`s_in_8b_reg`) to produce a corresponding 10\u2011bit control code. If `s_in_8b_reg` does not match any recognized control code, the design will produce a zero codeword. \n\n**Requirement**:  \nAdd an immediate assertion to this RTL code to verify that the design supports only valid control encoding. The recognized codes are:  \n- 8'h1C, 8'h3C, 8'h5C, 8'h7C, 8'h9C, 8'hBC, 8'hDC, 8'hFC, 8'hF7, 8'hFB, 8'hFD, and 8'hFE.\n\n**Interface**:\n\n- **Inputs**:\n  - `clk_in` (1-bit): Clock signal (active on the rising edge).\n  - `reset_in` (1-bit): Asynchronous reset (active high).\n  - `encoder_in` (8-bit): Data input for encoding.\n  - `control_in` (1-bit): Control input; when high, the encoder should use a control code.\n  \n- **Outputs**:\n  - `disparity_out` (1-bit): Running disparity output (1 indicates positive, 0 indicates negative).\n  - `encoder_out` (10-bit): 10-bit encoded output, which is a concatenation of a 2-bit sync_word and a 64-bit encoded_data.", "context": {"rtl/encoder_8b10b.sv": "module encoder_8b10b (\n    input  logic        clk_in,       // trigger on rising edge\n    input  logic        reset_in,     // reset_in, assert HI\n    input  logic        control_in,   // control char, assert HI for control words\n    input  logic [7:0]  encoder_in,   // 8bit input\n    output logic        disparity_out,// running disparity_out: HI = +1, LO = 0\n    output logic [9:0]  encoder_out   // 10bit codeword output\n);\n\n    typedef enum logic [1:0] {RD_MINUS, RD_PLUS} t_state_type;\n    t_state_type s_RunDisp;\n\n    logic [31:0] c_disPar_6b = 32'b11101000100000011000000110010111;\n    logic [7:0]  c_disPar_4b = 8'b10001001;\n    logic        s_dpTrack;\n    logic [7:0]  s_in_8b_reg;\n    logic        s_ctrl_reg;\n    logic [2:0]  s_ind3b;\n    logic        s_dP4bit;\n    logic [4:0]  s_ind5b;\n    logic        s_dP6bit;\n\n    assign s_ind3b       = s_in_8b_reg[7:5];\n    assign s_dP4bit      = c_disPar_4b[s_ind3b];\n    assign s_ind5b       = s_in_8b_reg[4:0];\n    assign s_dP6bit      = c_disPar_6b[s_ind5b];\n    assign disparity_out = s_dpTrack;\n\n    always_comb begin\n        logic [9:0] v_ctrl_code;\n\n        if (s_ctrl_reg == 1'b1) begin\n            case (s_in_8b_reg)\n                8'h1C: v_ctrl_code = (10'b0011110100);\n                8'h3C: v_ctrl_code = (10'b0011111001);\n                8'h5C: v_ctrl_code = (10'b0011110101);\n                8'h7C: v_ctrl_code = (10'b0011110011);\n                8'h9C: v_ctrl_code = (10'b0011110010);\n                8'hBC: v_ctrl_code = (10'b0011111010);\n                8'hDC: v_ctrl_code = (10'b0011110110);\n                8'hFC: v_ctrl_code = (10'b0011111000);\n                8'hF7: v_ctrl_code = (10'b1110101000);\n                8'hFB: v_ctrl_code = (10'b1101101000);\n                8'hFD: v_ctrl_code = (10'b1011101000);\n                8'hFE: v_ctrl_code = (10'b0111101000);\n                default: v_ctrl_code = (10'b0000000000);\n            endcase\n\n            if (s_RunDisp == RD_MINUS) begin\n                encoder_out = v_ctrl_code;\n                s_dpTrack   = 1'b0;\n            end else begin\n                encoder_out = ~v_ctrl_code;\n                s_dpTrack   = 1'b1;\n            end\n        end else begin\n            encoder_out = 10'b0000000000;\n            v_ctrl_code = 10'b0;\n            s_dpTrack   = 1'b0;\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            s_RunDisp <= RD_MINUS;\n        end else begin\n            if ((s_in_8b_reg[1:0] != 2'b00) && (s_ctrl_reg == 1'b1)) begin\n                s_RunDisp <= s_RunDisp;\n            end else begin\n                case (s_RunDisp)\n                    RD_MINUS: begin\n                        if ((s_ctrl_reg ^ s_dP6bit ^ s_dP4bit) != 1'b0) begin\n                            s_RunDisp <= RD_PLUS;\n                        end\n                    end\n                    RD_PLUS: begin\n                        if ((s_ctrl_reg ^ s_dP6bit ^ s_dP4bit) != 1'b0) begin\n                            s_RunDisp <= RD_MINUS;\n                        end\n                    end\n                    default: s_RunDisp <= RD_MINUS;\n                endcase\n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            s_in_8b_reg <= 8'b00000000;\n        end else begin\n            s_in_8b_reg <= encoder_in;\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            s_ctrl_reg <= 1'b0;\n        end else begin\n            s_ctrl_reg <= control_in;\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/encoder_8b10b.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/encoder_8b10b.sv\nTOPLEVEL        = encoder_8b10b\nMODULE          = test_encoder_8b10b\nPYTHONPATH      = /src\nHASH            = e42a9d46c58335f898d923553c46316a8b523ff8\n", "src/test_encoder_8b10b.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nfrom collections import deque\nimport random\n\n# Special character code values\nK28d0 = \"00011100\"\nK28d1 = \"00111100\"\nK28d2 = \"01011100\"\nK28d3 = \"01111100\"\nK28d4 = \"10011100\"\nK28d5 = \"10111100\"\nK28d6 = \"11011100\"\nK28d7 = \"11111100\"\nK23d7 = \"11110111\"\nK27d7 = \"11111011\"\nK29d7 = \"11111101\"\nK30d7 = \"11111110\"\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and start the clock.\"\"\"\n    dut.reset_in.value = 1\n    dut.control_in.value = 0\n    dut.encoder_in.value = 0\n\n    clock = Clock(dut.clk_in, 50, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    dut.reset_in.value = 0\n\nasync def check_output(dut, expected_value, expected_disparity, input_value):\n    \"\"\"Check the output of the DUT against the expected value.\"\"\"\n    print(f\"Expected: {hex(int(expected_value, 2)):>6}, Got: {hex(int(dut.encoder_out.value.binstr, 2)):>6}, Input: {hex(int(input_value, 2)):>6}\")\n    assert dut.encoder_out.value.binstr == expected_value, f\"Expected {expected_value}, got {dut.encoder_out.value.binstr}\"\n    assert dut.disparity_out.value == expected_disparity, f\"Expected disparity {expected_disparity}, got {dut.disparity_out.value}\"\n\ndef calculate_expected_value(control_symbol, rd):\n    \"\"\"Calculate the expected value based on the control symbol and running disparity.\"\"\"\n    if control_symbol == K28d0:\n        return \"0011110100\" if rd == -1 else \"1100001011\"\n    elif control_symbol == K28d1:\n        return \"0011111001\" if rd == -1 else \"1100000110\"\n    elif control_symbol == K28d2:\n        return \"0011110101\" if rd == -1 else \"1100001010\"\n    elif control_symbol == K28d3:\n        return \"0011110011\" if rd == -1 else \"1100001100\"\n    elif control_symbol == K28d4:\n        return \"0011110010\" if rd == -1 else \"1100001101\"\n    elif control_symbol == K28d5:\n        return \"0011111010\" if rd == -1 else \"1100000101\"\n    elif control_symbol == K28d6:\n        return \"0011110110\" if rd == -1 else \"1100001001\"\n    elif control_symbol == K28d7:\n        return \"0011111000\" if rd == -1 else \"1100000111\"\n    elif control_symbol == K23d7:\n        return \"1110101000\" if rd == -1 else \"0001010111\"\n    elif control_symbol == K27d7:\n        return \"1101101000\" if rd == -1 else \"0010010111\"\n    elif control_symbol == K29d7:\n        return \"1011101000\" if rd == -1 else \"0100010111\"\n    elif control_symbol == K30d7:\n        return \"0111101000\" if rd == -1 else \"1000010111\"\n    else:\n        return \"0000000000\"\n\n\ndef calculate_expected_rd(codeword):\n    #Calculate the expected running disparity (RD) for a given 10-bit codeword.\n    \n    # Hardcoded values from the table\n    rd_0_table = {\n        \"0011110100\": 0, \"0011111001\": 0, \"0011110101\": 0, \"0011110011\": 0,\n        \"0011110010\": 0, \"0011111010\": 0, \"0011110110\": 0, \"0011111000\": 0,\n        \"1110101000\": 0, \"1101101000\": 0, \"1011101000\": 0, \"0111101000\": 0\n    }\n    rd_1_table = {\n        \"1100001011\": 1, \"1100000110\": 1, \"1100001010\": 1, \"1100001100\": 1,\n        \"1100001101\": 1, \"1100000101\": 1, \"1100001001\": 1, \"1100000111\": 1,\n        \"0001010111\": 1, \"0010010111\": 1, \"0100010111\": 1, \"1000010111\": 1\n    }\n    \n    # Check if the codeword exists in either of the tables\n    if codeword in rd_0_table:\n        return rd_0_table[codeword]  # RD = 0\n    elif codeword in rd_1_table:\n        return rd_1_table[codeword]  # RD = 1\n    else:\n        return 0  # Default to RD=0 if no match is found\n\n\n@cocotb.test()\nasync def test_encoder_8b10b_reset(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols and reset HIGH.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d0, K28d1, K28d2, K28d3, K28d4, K28d5, K28d6, K28d7, K23d7, K27d7, K29d7, K30d7]\n    rd = -1  # Initial running disparity\n\n    # Queue to store previous ebi values\n    ebi_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.control_in.value = 1\n        dut.encoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current ebi value in the queue\n        ebi_queue.append(dut.encoder_in.value)\n\n        ebi_binstr = f\"{int(ebi_queue[0]):08b}\"  # Use the delayed ebi value\n        if dut.disparity_out.value == 1:\n            rd = 1\n        else:\n            rd = -1\n                \n    dut.reset_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    expected_value = \"0000000000\"\n    expected_disparity = calculate_expected_rd(expected_value)\n    await check_output(dut, expected_value, expected_disparity, str(dut.encoder_in.value))\n\n    await RisingEdge(dut.clk_in)\n\n@cocotb.test()\nasync def test_continuous_control_symbol(dut):\n    await initialize_dut(dut)\n\n    # Initialize signals for TestBench control functions\n    kcounter = 0\n    dcounter = 0\n    tks = 1\n    dk = 0\n    rd = -1  # Initial running disparity\n\n    # Queue to store previous ebi values\n    ebi_queue = deque([0, 0], maxlen=2)\n\n    # List to store KXX values\n    k_values = [\n        int(K28d0, 2), int(K28d1, 2), int(K28d2, 2), int(K28d3, 2),\n        int(K28d4, 2), int(K28d5, 2), int(K28d6, 2), int(K28d7, 2),\n        int(K23d7, 2), int(K27d7, 2), int(K29d7, 2), int(K30d7, 2)\n    ]\n\n    # Test loop\n    for _ in range(28):  # Adjust the range as needed\n\n        # Update control signals\n        dk = tks\n        dut.control_in.value = dk\n\n        if tks:  # Output K characters\n            dcounter = 0\n            case_value = kcounter % 12\n            dut.encoder_in.value = k_values[case_value]\n        else:  # Output D values\n            dcounter += 1\n            dut.encoder_in.value = dcounter\n            if dcounter == 255:\n                tks = 1  # Repeat K portion\n                kcounter = 0  # Reset K counter\n\n        # Store the current ebi value in the queue\n        ebi_queue.append(dut.encoder_in.value)\n\n        ebi_binstr = f\"{int(ebi_queue[0]):08b}\"  # Use the delayed ebi value\n        \n        if tks:\n            # Control characters\n            expected_value = calculate_expected_value(ebi_binstr, rd)\n            expected_disparity = calculate_expected_rd(str(dut.encoder_out.value))\n        else:\n            # Data characters\n            high_nibble = ebi_binstr[:5]\n            low_nibble = ebi_binstr[5:]\n            expected_value = high_encoded + low_encoded\n\n        await check_output(dut, expected_value, expected_disparity, ebi_binstr)\n        await RisingEdge(dut.clk_in)\n        if dut.disparity_out.value == 1:\n           rd = 1\n        else:\n           rd = -1\n\n        kcounter += 1\n    await Timer(100, units=\"ns\")\n\n@cocotb.test()\nasync def test_initial_default_output(dut):\n    \"\"\"Test initial default output if no input/control input is given.\"\"\"\n    await initialize_dut(dut)\n\n    dut.control_in.value = 0\n    dut.encoder_in.value = 0\n    await RisingEdge(dut.clk_in)\n    expected_value = \"0000000000\"\n    expected_disparity = calculate_expected_rd(str(dut.encoder_out.value))\n    await check_output(dut, expected_value, expected_disparity, str(dut.encoder_in.value))\n\n@cocotb.test()\nasync def test_random_control_symbol(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d0, K28d1, K28d2, K28d3, K28d4, K28d5, K28d6, K28d7, K23d7, K27d7, K29d7, K30d7]\n    rd = -1  # Initial running disparity\n\n    # Queue to store previous ebi values\n    ebi_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.control_in.value = 1\n        dut.encoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current ebi value in the queue\n        ebi_queue.append(dut.encoder_in.value)\n\n        ebi_binstr = f\"{int(ebi_queue[0]):08b}\"  # Use the delayed ebi value\n        if dut.disparity_out.value == 1:\n            rd = 1\n        else:\n            rd = -1\n        # Calculate the expected value based on the control symbol and running disparity\n        expected_value = calculate_expected_value(ebi_binstr, rd)\n        expected_disparity = calculate_expected_rd(str(dut.encoder_out.value))\n        await check_output(dut, expected_value, expected_disparity, str(dut.encoder_in.value))\n        \n@cocotb.test()\nasync def test_same_control_symbol(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d6]\n    rd = -1  # Initial running disparity\n\n    # Queue to store previous ebi values\n    ebi_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(20):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.control_in.value = 1\n        dut.encoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current ebi value in the queue\n        ebi_queue.append(dut.encoder_in.value)\n\n        ebi_binstr = f\"{int(ebi_queue[0]):08b}\"  # Use the delayed ebi value\n        if dut.disparity_out.value == 1:\n            rd = 1\n        else:\n            rd = -1\n        # Calculate the expected value based on the control symbol and running disparity\n        expected_value = calculate_expected_value(ebi_binstr, rd)\n        expected_disparity = calculate_expected_rd(str(dut.encoder_out.value))\n        await check_output(dut, expected_value, expected_disparity, str(dut.encoder_in.value))\n\n\n@cocotb.test()\nasync def test_random_invalid_control_input(dut):\n    \"\"\"Test sending any 8-bit input other than 12 control symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d0, K28d1, K28d2, K28d3, K28d4, K28d5, K28d6, K28d7, K23d7, K27d7, K29d7, K30d7]\n    rd = -1  # Initial running disparity\n\n    for _ in range(10):  # Adjust the range as needed\n        random_data = random.randint(0, 255)\n        while f\"{random_data:08b}\" in control_symbols:\n            random_data = random.randint(0, 255)\n        dut.control_in.value = 0\n        dut.encoder_in.value = random_data\n        await RisingEdge(dut.clk_in)\n        expected_value = \"0000000000\"  # Example for data characters\n        expected_disparity = calculate_expected_rd(str(dut.encoder_out.value))\n        await check_output(dut, expected_value, expected_disparity, f\"{random_data:08b}\")\n\n        if dut.disparity_out.value == 1:\n            rd = 1\n        else:\n            rd = -1\n\n    await Timer(100, units=\"ns\")\n\n@cocotb.test()\nasync def test_rtl_continuous_control_symbol_encoding(dut):\n    \"\"\"Test continuous input encoding issue for specific control inputs (K28d7, K28d6).\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d7, K28d6]\n    rd = -1  # Initial running disparity\n\n    ebi_queue = deque([0, 0], maxlen=2)\n\n    for symbol in control_symbols:\n        cycle_count = 10 if symbol == K28d7 else 11  # K28d7 for 4 cycles, K28d6 for 5 cycles\n        for _ in range(cycle_count):  # Send each symbol for the specified number of clock cycles\n            dut.control_in.value = 1  # Assert control input\n            dut.encoder_in.value = int(symbol, 2)  # Set the control symbol\n            await RisingEdge(dut.clk_in)\n\n            ebi_queue.append(dut.encoder_in.value)\n\n            ebi_binstr = f\"{int(ebi_queue[0]):08b}\"\n            if dut.disparity_out.value == 1:\n                rd = 1\n            else:\n                rd = -1\n\n            expected_value = calculate_expected_value(ebi_binstr, rd)\n            expected_disparity = calculate_expected_rd(str(dut.encoder_out.value))\n\n            await check_output(dut, expected_value, expected_disparity, str(dut.encoder_in.value))\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_encoder_8b10b_0025", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the existing SystemVerilog testbench to include **checker generation logic** for verifying the functionality of the `encoder_8b10b` module. The testbench already contains a **stimulus generator** logic to drive the input signals. The modified testbench should integrate a **checker generator** logic to validate the `encoder_8b10b` module against the given design specification.\n\n---\n\n### **Design Specification:**\n\nAn 8b10b encoder is a digital circuit that converts an 8-bit word into a 10-bit encoded codeword, used in telecommunications to maintain Digital Control (DC) balance (equal number of 1s and 0s) and provide error detection capabilities. The encoder supports both **control synbols** and **data symbols** encoding.\n\n#### **Functionality**:\n1. **Control and Data Symbol Encoding**:\n   - When `control_in` is HIGH: Encode `encoder_in` as a control character based on predefined control symbols and update the running disparity for control encoding.\n   - When `control_in` is LOW: Encode `encoder_in` as a data symbol based on the 8b/10b data encoding scheme. Use `disparity_data_in` to run disparity tracking and generate a valid 10-bit encoded data symbol while updating the running disparity.\n\n2. **Latency**:\n   - Ensure the module introduces a single clock cycle latency for control or data symbol encoding.\n\n3. **Control Encoding Compatibility**:\n   - Maintain compatibility with existing control symbol encoding implementation.\n   - Use modular components to handle control and data symbol encoding separately for maintainability.\n\nBelow are the 5b/6b and 3b/4b encoding tables used for encoding data symbols in the design.\n\n### **5b/6b Encoding Table**\n\nThe lower 5 bits of the 8-bit input are mapped to 6 bits based on the current running disparity (`RD`).\n\n| Input 5-bit(LSB) | RD = 0 | RD = 1  |\n|------------------|--------|---------|\n| 00000            | 100111 | 011000  |\n| 00001            | 011101 | 100010  |\n| 00010            | 101101 | 010010  |\n| 00011            | 110001 | 110001  |\n| 00100            | 110101 | 001010  |\n| 00101            | 101001 | 101001  |\n| 00110            | 011001 | 011001  |\n| 00111            | 111000 | 000111  |\n| 01000            | 111001 | 000110  |\n| 01001            | 100101 | 100101  |\n| 01010            | 010101 | 010101  |\n| 01011            | 110100 | 110100  |\n| 01100            | 001101 | 001101  |\n| 01101            | 101100 | 101100  |\n| 01110            | 011100 | 011100  |\n| 01111            | 010111 | 101000  |\n| 10000            | 011011 | 100100  |\n| 10001            | 100011 | 100011  |\n| 10010            | 010011 | 010011  |\n| 10011            | 110010 | 110010  |\n| 10100            | 001011 | 001011  |\n| 10101            | 101010 | 101010  |\n| 10110            | 011010 | 011010  |\n| 10111            | 111010 | 000101  |\n| 11000            | 110011 | 001100  |\n| 11001            | 100110 | 100110  |\n| 11010            | 010110 | 010110  |\n| 11011            | 110110 | 001001  |\n| 11100            | 001110 | 001110  |\n| 11101            | 101110 | 010001  |\n| 11110            | 011110 | 100001  |\n| 11111            | 101011 | 010100  |\n\n\n### **3b/4b Encoding Table**\n\nThe upper 3 bits of the 8-bit input are mapped to 4 bits based on the current running disparity (`RD`).\n\n| Input (MSB) | RD = 0  | RD = 1  |\n|-------------|---------|---------|\n| 000         | 0100    | 1011    |\n| 001         | 1001    | 1001    |\n| 010         | 0101    | 0101    |\n| 011         | 0011    | 1100    |\n| 100         | 0010    | 1101    |\n| 101         | 1010    | 1010    |\n| 110         | 0110    | 0110    |\n| 111         | 1110    | 0001    |\n\n\n---\n\n### **Testbench Requirements:**\n\n1. **Testbench Components:**\n   - **Input Signals:** Drive `clk_in`, `reset_in`, `control_in`, `encoder_in`, and `disparity_data_in` with various test cases.\n   - **Output Validation:** Monitor and validate the `encoder_out` and `disparity_out` outputs against expected behavior.\n   - **Checker Generator:** Implement a checker logic to verify the correctness of the outputs based on the input `encoder_in` and `control_in`.\n\n2. **Checker Logic:**\n   - Implement reference logic to calculate the expected `encoder_out` and `disparity_out` for given `encoder_in` and `control_in`.\n   - Compare the UUT outputs (`encoder_out` and `disparity_out`) with the calculated expected outputs.\n   - Log errors if the outputs do not match the expected behavior.\n   - Print success messages for passing test cases.\n\n3. **Functionality:**\n   - Test the following scenarios:\n     - **Data Symbols:** Verify encoding of valid data inputs.\n     - **Control Symbols:** Verify encoding of valid control symbol inputs.\n     - **Reset Behavior:** Verify the behavior of the encoder during and after reset.\n     - **Running Disparity:** Verify the correct update of the running disparity.\n     - **Continuous Input Streams:** Test continuous input streams with mixed data and control symbols.\n     - **Random Input Sequences:** Test random input sequences to ensure robustness.\n\n4. **Verification:**\n   - Drive `encoder_in` and `control_in` and monitor the outputs using the checker logic.\n   - Compare the actual outputs with the expected outputs.\n   - Log results (pass/fail) for each test case.\n\n5. **Simulation:**\n   - Display pass/fail results for each test case.\n   - Complete the simulation once all test cases are verified.\n\n---\n\n### **Deliverables:**\n\nProvide a complete SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `encoder_8b10b` module. The testbench should include:\n- A test sequence generator to create input patterns.\n- A checker logic module to validate the outputs.\n- Proper clock generation and reset handling.\n- Logging of test results for each test case.", "context": {"verif/tb_encoder_8b10b.sv": "\nmodule tb_encoder_8b10b;\n\n    logic clk_in;\n    logic reset_in;\n    logic control_in;\n    logic control_in_reg;\n    logic [7:0] encoder_in;\n    logic [7:0] encoder_in_reg;\n    logic disparity_out_reg;\n    logic disparity_reg;\n    logic [9:0] encoder_out;\n    logic stim_enable_in;\n    logic enable_in;\n\n    encoder_8b10b uut (\n        .clk_in(clk_in),\n        .reset_in(reset_in),\n        .control_in(control_in),\n        .encoder_in(encoder_in),\n        .disparity_data_in(disparity_reg),\n        .disparity_out(disparity_reg),\n        .encoder_out(encoder_out)\n    );\n\n    initial begin\n        clk_in = 0;\n        forever #5 clk_in = ~clk_in;\n    end\n\n    //stimulus generation logic\n    logic [7:0] control_symbols [0:11];\n    int i;\n\n    initial begin\n        control_symbols[0]  = 8'h1C;\n        control_symbols[1]  = 8'h3C;\n        control_symbols[2]  = 8'h5C;\n        control_symbols[3]  = 8'h7C;\n        control_symbols[4]  = 8'h9C;\n        control_symbols[5]  = 8'hBC;\n        control_symbols[6]  = 8'hDC;\n        control_symbols[7]  = 8'hFC;\n        control_symbols[8]  = 8'hF7;\n        control_symbols[9]  = 8'hFB;\n        control_symbols[10] = 8'hFD;\n        control_symbols[11] = 8'hFE;\n\n\treset_in = 1;\n        encoder_in <= 8'b0;\n        enable_in <= 0;\n        control_in <= 0;\n        #20 reset_in = 0;\n\n        @(posedge stim_enable_in);\n        test_reset_in_behavior();\n        test_control_symbols();\n        test_initial_default_output();\n        test_random_control_symbols();\n        test_same_control_symbol();\n        test_invalid_control_input();\n        test_rtl_bug_behavior();\n        test_rtl_continuous_control_symbol_encoding();\n        test_rtl_continuous_data_symbol_encoding();\n        test_random_data_symbol_input();\n        test_same_random_data_symbol_input();\n    end\n\n    task test_reset_in_behavior();\n        $display(\"TC1\");\n        @(posedge clk_in);\n        reset_in <= 1;\n        #20;\n        reset_in <= 0;\n        control_in <= 1;\n        enable_in <= 1;\n        encoder_in <= 8'b0;\n        @(posedge clk_in);\n    endtask\n\n    task test_control_symbols();\n        $display(\"TC2\");\n        for (i = 0; i < 12; i++) begin\n            @(posedge clk_in);\n            control_in <= 1;\n            enable_in <= 1;\n            encoder_in <= control_symbols[i];\n        end\n        @(posedge clk_in);\n        enable_in <= 0;\n    endtask\n\n    task test_initial_default_output();\n        $display(\"TC3\");\n        @(posedge clk_in);\n        control_in <= 0;\n        enable_in <= 0;\n        encoder_in <= 8'b0;\n        @(posedge clk_in);\n    endtask\n\n    task test_random_control_symbols();\n        $display(\"TC4\");\n        for (int j = 0; j < 20; j++) begin\n            @(posedge clk_in);\n            control_in <= 1;\n            enable_in <= 1;\n            encoder_in <= control_symbols[$urandom % 12];\n        end\n    endtask\n\n    task test_same_control_symbol();\n        $display(\"TC5\");\n        for (int j = 0; j < 20; j++) begin\n            @(posedge clk_in);\n            control_in <= 1;\n            enable_in <= 1;\n            encoder_in <= 8'hDC;\n        end\n    endtask\n\n    task test_invalid_control_input();\n        $display(\"TC6\");\n        @(posedge clk_in);\n        enable_in <= 0;\n        control_in <= 0;\n        reset_in <= 1;\n        @(posedge clk_in);\n        @(posedge clk_in);\n        reset_in <= 0;\n        for (int k = 0; k < 20; k++) begin\n            @(posedge clk_in);\n            control_in <= 1;\n            enable_in <= 1;\n            encoder_in <= 8'hFF;\n        end\n    endtask\n\n    task test_rtl_bug_behavior();\n        $display(\"TC7\");\n        @(posedge clk_in);\n        control_in <= 0;\n        enable_in <= 0;\n        encoder_in <= 8'h1C;\n        @(posedge clk_in);\n        encoder_in <= 8'h00;\n    endtask\n\n    task test_rtl_continuous_control_symbol_encoding();\n        $display(\"TC8\");\n        @(posedge clk_in);\n        enable_in <= 0;\n        control_in <= 0;\n        reset_in <= 1;\n        @(posedge clk_in);\n        @(posedge clk_in);\n        reset_in <= 0;\n        for (int l = 0; l < 20; l++) begin\n            @(posedge clk_in);\n            control_in <= 1;\n            enable_in <= 1;\n            encoder_in <= (l > 9) ? 8'hDC : 8'hFC;\n        end\n    endtask\n\n    task test_rtl_continuous_data_symbol_encoding();\n        $display(\"TC9\");\n        @(posedge clk_in);\n        enable_in <= 0;\n        control_in <= 0;\n        encoder_in <= 0;\n        reset_in <= 1;\n        @(posedge clk_in);\n        @(posedge clk_in);\n        control_in <= 0;\n        reset_in <= 0;\n        for (int l = 0; l < 256; l++) begin\n            control_in <= 0;\n            enable_in <= 1;\n            encoder_in <= l;\n            @(posedge clk_in);\n        end\n        encoder_in <= 0;\n    endtask\n\n    task test_random_data_symbol_input();\n        $display(\"TC10\");\n        @(posedge clk_in);\n        enable_in <= 0;\n        control_in <= 0;\n        reset_in <= 1;\n        @(posedge clk_in);\n        @(posedge clk_in);\n        reset_in <= 0;\n        for (int k = 0; k < 100; k++) begin\n            control_in <= 0;\n            enable_in <= 1;\n            encoder_in <= $urandom % 256;\n            @(posedge clk_in);\n        end\n    endtask\n\n    task test_same_random_data_symbol_input();\n        $display(\"TC11\");\n        @(posedge clk_in);\n        enable_in <= 0;\n        control_in <= 0;\n        reset_in <= 1;\n        @(posedge clk_in);\n        @(posedge clk_in);\n        reset_in <= 0;\n        encoder_in <= $urandom % 256;\n        for (int k = 0; k < 10; k++) begin\n            control_in <= 0;\n            enable_in <= 1;\n            @(posedge clk_in);\n        end\n    endtask\n    \n    initial begin\n        stim_enable_in = 0;\n        #200 stim_enable_in = 1;\n        #5000 $finish;\n    end\n    \n    initial begin\n        $dumpfile(\"test.vcd\");\n        $dumpvars(0, tb_encoder_8b10b);\n    end\n\n    initial begin\n        @(posedge stim_enable_in);\n        forever @(posedge clk_in) begin\n            $display(\"Stimulus Sent: encoder_in = %b, encoder_out = %b,control=%b\",encoder_in, encoder_out, control_in);\n        end\n    end\n\nendmodule\n\n"}}, "output": {"response": "", "context": {"verif/tb_encoder_8b10b.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 227b80176dd89096a0f47b71b98356f5f5d00cf2\nNUM_BUGS        = 6\n", "src/encoder_8b10b.sv": "module encoder_8b10b (\n    input  logic        clk_in,           // Trigger on rising edge\n    input  logic        reset_in,         // Reset, assert HI\n    input  logic        control_in,       // Control character, assert HI for control words\n    input  logic        disparity_data_in,// Current running disparity input for data\n    input  logic [7:0]  encoder_in,       // 8-bit input\n    output logic        disparity_out,    // Running disparity: HI = +1, LO = 0\n    output logic [9:0]  encoder_out       // 10-bit codeword output\n);\n\n    logic disparity_control_out;\n    logic disparity_data_out;\n    logic [9:0] encoder_control_out;\n    logic [9:0] encoder_data_out;\n\n    assign disparity_out = control_in ? disparity_control_out : disparity_data_out;\n    assign encoder_out   = control_in ? encoder_control_out : encoder_data_out;\n\n    encoder_8b10b_control enc_control (\n        .clk_in(clk_in),\n        .reset_in(reset_in),\n        .control_in(control_in),\n        .encoder_in(encoder_in),\n        .disparity_out(disparity_control_out),\n        .encoder_out(encoder_control_out)\n    );\n\n    encoder_8b10b_data enc_data (\n        .clk_in(clk_in),\n        .reset_in(reset_in),\n        .control_in(control_in),\n        .encoder_in(encoder_in),\n        .ein_rd(disparity_data_in),\n        .disparity_out(disparity_data_out),\n        .encoder_out(encoder_data_out)\n    );\n\nendmodule\n\nmodule encoder_8b10b_control (\n    input  logic        clk_in,\n    input  logic        reset_in,\n    input  logic        control_in,\n    input  logic [7:0]  encoder_in,\n    output logic        disparity_out,\n    output logic [9:0]  encoder_out\n);\n\n    typedef enum logic [1:0] {RD_MINUS, RD_PLUS} t_state_type;\n    t_state_type current_disparity;\n\n    logic [31:0] disparity_table_6b = 32'b11101000100000011000000110010111;\n    logic [7:0]  disparity_table_4b = 8'b10001001;\n\n    logic        disparity_track;\n    logic [7:0]  registered_input;\n    logic        registered_control;\n    logic [2:0]  index_3b;\n    logic        disparity_4b;\n    logic [4:0]  index_5b;\n    logic        disparity_6b;\n\n    assign index_3b     = registered_input[7:5];\n    assign disparity_4b = disparity_table_4b[index_3b];\n    assign index_5b     = registered_input[4:0];\n    assign disparity_6b = disparity_table_6b[index_5b];\n    assign disparity_out = disparity_track;\n\n    always_comb begin\n        logic [9:0] control_code;\n\n        if (registered_control) begin\n            case (registered_input)\n        `ifndef BUG_0\n                8'h1C: control_code = 10'b0011110100;\n                8'h3C: control_code = 10'b0011111001;\n                8'h5C: control_code = 10'b0011110101;\n                8'h7C: control_code = 10'b0011110011;\n                8'h9C: control_code = 10'b0011110010;\n                8'hBC: control_code = 10'b0011111010;\n                8'hDC: control_code = 10'b0011110110;\n                8'hFC: control_code = 10'b0011111000;\n                8'hF7: control_code = 10'b1110101000;\n                8'hFB: control_code = 10'b1101101000;\n                8'hFD: control_code = 10'b1011101000;\n                8'hFE: control_code = 10'b0111101000;\n\t`else\n                8'h1C: control_code = 10'b1111110100;\n                8'h3C: control_code = 10'b0011111111;\n                8'h5C: control_code = 10'b1111111111;\n                8'h7C: control_code = 10'b0000000011;\n                8'h9C: control_code = 10'b0000000010;\n                8'hBC: control_code = 10'b0011001010;\n                8'hDC: control_code = 10'b0011010110;\n                8'hFC: control_code = 10'b0011011000;\n                8'hF7: control_code = 10'b1110001000;\n                8'hFB: control_code = 10'b1101101100;\n                8'hFD: control_code = 10'b1011101110;\n                8'hFE: control_code = 10'b0111101110;\n\t`endif\n                default: control_code = 10'b0000000000;\n            endcase\n\n            if (current_disparity == RD_MINUS) begin\n                encoder_out = control_code;\n                disparity_track = 1'b0;\n            end else begin\n                encoder_out = ~control_code;\n                disparity_track = 1'b1;\n            end\n        end else begin\n            encoder_out = 10'b0000000000;\n            control_code = 10'b0;\n            disparity_track = 1'b0;\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            current_disparity <= RD_MINUS;\n        end else begin\n            if ((registered_input[1:0] != 2'b00) && registered_control) begin\n                current_disparity <= current_disparity;\n            end else begin\n                case (current_disparity)\n                    RD_MINUS: begin\n                        if ((registered_control ^ disparity_6b ^ disparity_4b) != 1'b0) begin\n                            current_disparity <= RD_PLUS;\n                        end\n                    end\n                    RD_PLUS: begin\n                        if ((registered_control ^ disparity_6b ^ disparity_4b) != 1'b0) begin\n                            current_disparity <= RD_MINUS;\n                        end\n                    end\n                    default: current_disparity <= RD_MINUS;\n                endcase\n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            registered_input  <= 8'b00000000;\n            registered_control <= 1'b0;\n        end else begin\n        `ifndef BUG_1\n            registered_input  <= encoder_in;\n            registered_control <= control_in;\n\t`else\n            registered_input  <= 'd0;\n            registered_control <= control_in;\n\t`endif\n        end\n    end\n\nendmodule\n\nmodule encoder_8b10b_data (\n    input  logic        clk_in,\n    input  logic        reset_in,\n    input  logic        control_in,\n    input  logic        ein_rd,\n    input  logic [7:0]  encoder_in,\n    output logic        disparity_out,\n    output logic [9:0]  encoder_out\n);\n\n    wire [7:0] encoder_in_w;\n    wire K;\n\n    wire is_all_low;\n    wire is_three_low;\n    wire is_two_low_two_high;\n    wire is_three_high;\n    wire is_all_high;\n\n    wire disparity_case_0;\n    wire disparity_case_1;\n    wire disparity_case_2;\n    wire disparity_case_3;\n    wire invert_a_i;\n    wire disp4, disp5, disp6, invert_fj;\n    \n    logic a_w, b_w, c_w, d_w, e_w, i_w, f_w, g_w, h_w, j_w;\n    logic a, b, c, d, e, i, f, g, h, j;\n    logic rd1_part, rd1;\n    logic disparity_reg;\n    logic SorK;\n   `ifndef BUG_2\n    assign encoder_in_w = encoder_in;\n   `else\n    assign encoder_in_w = 'd0;\n   `endif\n    assign K = control_in;\n\n    assign is_all_low          = (!encoder_in_w[0] & !encoder_in_w[1] & !encoder_in_w[2] & !encoder_in_w[3]);\n    assign is_three_low        = (!encoder_in_w[0] & !encoder_in_w[1] & !encoder_in_w[2] &  encoder_in_w[3]) |\n                                 (!encoder_in_w[0] & !encoder_in_w[1] &  encoder_in_w[2] & !encoder_in_w[3]) |\n                                 (!encoder_in_w[0] &  encoder_in_w[1] & !encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] & !encoder_in_w[1] & !encoder_in_w[2] & !encoder_in_w[3]);\n    assign is_two_low_two_high = (!encoder_in_w[0] & !encoder_in_w[1] &  encoder_in_w[2] &  encoder_in_w[3]) |\n                                 (!encoder_in_w[0] &  encoder_in_w[1] &  encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] &  encoder_in_w[1] & !encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] & !encoder_in_w[1] &  encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] & !encoder_in_w[1] & !encoder_in_w[2] &  encoder_in_w[3]) |\n                                 (!encoder_in_w[0] &  encoder_in_w[1] & !encoder_in_w[2] &  encoder_in_w[3]);\n    assign is_three_high       = ( encoder_in_w[0] &  encoder_in_w[1] &  encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] &  encoder_in_w[1] & !encoder_in_w[2] &  encoder_in_w[3]) |\n                                 ( encoder_in_w[0] & !encoder_in_w[1] &  encoder_in_w[2] &  encoder_in_w[3]) |\n                                 (!encoder_in_w[0] &  encoder_in_w[1] &  encoder_in_w[2] &  encoder_in_w[3]);\n    assign is_all_high         = ( encoder_in_w[0] &  encoder_in_w[1] &  encoder_in_w[2] &  encoder_in_w[3]);\n\n    assign disparity_case_0    = (!is_two_low_two_high & !is_three_high & !encoder_in_w[4]);\n    assign disparity_case_1    = (is_three_high & !encoder_in_w[3] & !encoder_in_w[4]);\n    assign disparity_case_2    = (is_three_low &  encoder_in_w[3] &  encoder_in_w[4]);\n    assign disparity_case_3    = (!is_two_low_two_high & !is_three_low &  encoder_in_w[4]);\n   `ifndef BUG_3\n    assign invert_a_i          = !(ein_rd ? (disparity_case_3 | disparity_case_1 | K) : (disparity_case_0 | disparity_case_2));\n   `else\n    assign invert_a_i          = 'd1;\n   `endif\n\n    always_comb begin\n        a_w = !encoder_in_w[0];\n        b_w = ((is_all_low) ? 1'b0 : (is_all_high) ? 1'b1 : !encoder_in_w[1]);\n        c_w = ((is_all_low) ? 1'b0 : (is_three_low & encoder_in_w[3] & encoder_in_w[4]) ? 1'b0 : !encoder_in_w[2]);\n        d_w = ((is_all_high) ? 1'b1 : !encoder_in_w[3]);\n        e_w = ((is_three_low & !encoder_in_w[4]) ? 1'b0 : (is_three_low & encoder_in_w[3] & encoder_in_w[4]) ? 1'b1 : !encoder_in_w[4]);\n        i_w = ((is_two_low_two_high & !encoder_in_w[4]) ? 1'b0 : (is_all_low & encoder_in_w[4]) ? 1'b0 : \n               (is_three_low & !encoder_in_w[3] & encoder_in_w[4]) ? 1'b0 : (is_all_high & encoder_in_w[4]) ? 1'b0 : \n               (is_two_low_two_high & K) ? 1'b0 : 1'b1);\n\n        rd1_part = (disparity_case_0 | disparity_case_2 | disparity_case_3);\n        rd1 = (rd1_part | K) ^ ein_rd;\n    end\n\n   `ifndef BUG_4\n    assign {a, b, c, d, e, i} = (~invert_a_i) ? {a_w, b_w, c_w, d_w, e_w, i_w} : ~{a_w, b_w, c_w, d_w, e_w, i_w};\n   `else\n    assign {a, b, c, d, e, i} = 'd0;\n   `endif\n\n    always_comb begin\n        SorK = (e & i & !rd1) | (!e & !i & rd1) | K;\n    end\n\n    assign disp4 = (!encoder_in_w[5] & !encoder_in_w[6]);\n    assign disp5 = (encoder_in_w[5] & encoder_in_w[6]);\n    assign disp6 = ((encoder_in_w[5] ^ encoder_in_w[6])) | K;\n    assign invert_fj = !(rd1 ? disp5 : (disp4 | disp6));\n\n    always_comb begin\n        f_w = ((encoder_in_w[5] & encoder_in_w[6] & encoder_in_w[7] & SorK) ? 1'b1 : !encoder_in_w[5]);\n        g_w = ((!encoder_in_w[5] & !encoder_in_w[6] & !encoder_in_w[7]) ? 1'b0 : !encoder_in_w[6]);\n        h_w = !encoder_in_w[7];\n        j_w = (((encoder_in_w[5] ^ encoder_in_w[6]) & !encoder_in_w[7]) ? 1'b0 : (encoder_in_w[5] & encoder_in_w[6] & encoder_in_w[7] & SorK) ? 1'b0 : 1'b1);\n    end\n\n   `ifndef BUG_5\n    assign {f, g, h, j} = (invert_fj | disp6) ? ~{f_w, g_w, h_w, j_w} : {f_w, g_w, h_w, j_w};\n   `else\n    assign {f, g, h, j} = {f_w, g_w, h_w, 1'b0};\n   `endif\n\n    assign disparity_reg = (reset_in) ? 1'b0 : (disp4 | (encoder_in_w[5] & encoder_in_w[6] & encoder_in_w[7])) ^ rd1;\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            disparity_out <= 1'b0;\n            encoder_out <= 10'b0000000000;\n        end else begin\n            if (!control_in) begin\n                disparity_out <= disparity_reg;\n                encoder_out <= {a, b, c, d, e, i, f, g, h, j};\n            end else begin\n                disparity_out <= 1'b0;\n                encoder_out <= 10'b0000000000;\n            end\n        end\n    end\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_encoder_8b10b_0026", "categories": ["cid012", "medium"], "input": {"prompt": "Create a SystemVerilog testbench module named `tb_encoder_8b10b` that instantiates the `encoder_8b10b` module as the Unit Under test (UUT). This testbench module must include the `stimulus generation` logic only, which systematically drives different input conditions to the `encoder_8b10b` module to achieve **100% functional and code coverage**.  The `encoder_8b10b` module supports encoding of control and data symbols as given in the below functionality.\n\n---\n## **Input Stimulus Generation**\n\n### **Encoder Inputs**\n- Generate diverse patterns for `encoder_in`, including:\n  - Standard **control symbols** (`8'h1C`, `8'h3C`, `8'h5C`, `8'h7C`, etc.).\n  - Random **valid data symbols** (`8'h00` to `8'hFF`).\n  - Repeated control symbols.\n  - Invalid control inputs.\n  - **Imbalanced** control symbols to check running disparity handling.\n  - **Continuous data symbols** covering the entire range.\n  - **Sequential and random data symbols**.\n\n### **Edge Case Testing**\n- Drive encoder inputs with:\n  - **Repeated** control symbol sequences.\n  - **Back-to-back** transitions between control and data symbols.\n  - **Random invalid 8-bit values** fed into the encoder.\n\n### **Stabilization Period**\n- **Wait 1 clock cycle** after each input change before checking `encoder_out` and `disparity_out` to ensure stable results.\n\n---\n\n## **Instantiation**\n- The instance of the **RTL module** should be named **`uut`**.\n\nFollowing the RTL specification for building the RTL of the module, and using it as a reference for the testbench environment too:\n\n---\n\n## **Module Interface**\n\n### **Inputs**\n- `clk_in`: **Rising-edge triggered clock** signal with a 50% duty cycle.\n- `reset_in`: **Active-HIGH asynchronous reset**.\n- `control_in`: **1-bit input**, HIGH for control symbols, LOW for data symbols.\n- `encoder_in[7:0]`: **8-bit input symbol** to be encoded.\n- `disparity_data_in`: **1-bit input**, representing the current running disparity.\n\n### **Outputs**\n- `encoder_out[9:0]`: **10-bit encoded output**.\n- `disparity_out`: **1-bit output**, representing the running disparity after encoding.\n\n---\n\n## **Module Functionality**  \n\nAn 8b10b encoder is a digital circuit that converts an 8-bit word into a 10-bit encoded codeword, used in telecommunications to maintain Digital Control (DC) balance (equal number of 1s and 0s) and provide error detection capabilities. The encoder is extended to support **data symbols**, which are standard data inputs distinct from control symbols.\n\n1. **Control and Data Symbol Encoding**:\n   - When `control_in` is HIGH: Encode `encoder_in` as a control character based on predefined control symbols and update the running disparity for control encoding.\n   - When `control_in` is LOW: Encode `encoder_in` as a data symbol based on the 8b/10b data encoding scheme. Use `disparity_data_in` to run disparity tracking and generate a valid 10-bit encoded data symbol while updating the running disparity.\n\n2. **Latency**:\n   - Ensure the module introduces a single clock cycle latency for control or data symbol encoding.\n\n3. **Control Encoding Compatibility**:\n   - Maintain compatibility with existing control symbol encoding implementation.\n   - Use modular components to handle control and data symbol encoding separately for maintainability.\n\nBelow are the 5b/6b and 3b/4b encoding tables used for encoding data symbols in the design.\n\n### **5b/6b Encoding Table**\n\nThe lower 5 bits of the 8-bit input are mapped to 6 bits based on the current running disparity (`RD`).\n\n| Input 5-bit(LSB) | RD = 0 | RD = 1  |\n|------------------|--------|---------|\n| 00000            | 100111 | 011000  |\n| 00001            | 011101 | 100010  |\n| 00010            | 101101 | 010010  |\n| 00011            | 110001 | 110001  |\n| 00100            | 110101 | 001010  |\n| 00101            | 101001 | 101001  |\n| 00110            | 011001 | 011001  |\n| 00111            | 111000 | 000111  |\n| 01000            | 111001 | 000110  |\n| 01001            | 100101 | 100101  |\n| 01010            | 010101 | 010101  |\n| 01011            | 110100 | 110100  |\n| 01100            | 001101 | 001101  |\n| 01101            | 101100 | 101100  |\n| 01110            | 011100 | 011100  |\n| 01111            | 010111 | 101000  |\n| 10000            | 011011 | 100100  |\n| 10001            | 100011 | 100011  |\n| 10010            | 010011 | 010011  |\n| 10011            | 110010 | 110010  |\n| 10100            | 001011 | 001011  |\n| 10101            | 101010 | 101010  |\n| 10110            | 011010 | 011010  |\n| 10111            | 111010 | 000101  |\n| 11000            | 110011 | 001100  |\n| 11001            | 100110 | 100110  |\n| 11010            | 010110 | 010110  |\n| 11011            | 110110 | 001001  |\n| 11100            | 001110 | 001110  |\n| 11101            | 101110 | 010001  |\n| 11110            | 011110 | 100001  |\n| 11111            | 101011 | 010100  |\n\n### **3b/4b Encoding Table**\n\nThe upper 3 bits of the 8-bit input are mapped to 4 bits based on the current running disparity (`RD`).\n\n| Input (MSB) | RD = 0  | RD = 1  |\n|-------------|---------|---------|\n| 000         | 0100    | 1011    |\n| 001         | 1001    | 1001    |\n| 010         | 0101    | 0101    |\n| 011         | 0011    | 1100    |\n| 100         | 0010    | 1101    |\n| 101         | 1010    | 1010    |\n| 110         | 0110    | 0110    |\n| 111         | 1110    | 0001    |\n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_encoder_8b10b.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = c98c7c91f06a3ddcbc54f442017cf310ac99d7a9\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite\n", "src/encoder_8b10b.sv": "module encoder_8b10b (\n    input  logic        clk_in,           // Trigger on rising edge\n    input  logic        reset_in,         // Reset, assert HI\n    input  logic        control_in,       // Control character, assert HI for control words\n    input  logic        disparity_data_in,// Current running disparity input for data\n    input  logic [7:0]  encoder_in,       // 8-bit input\n    output logic        disparity_out,    // Running disparity: HI = +1, LO = 0\n    output logic [9:0]  encoder_out       // 10-bit codeword output\n);\n\n    logic disparity_control_out;\n    logic disparity_data_out;\n    logic [9:0] encoder_control_out;\n    logic [9:0] encoder_data_out;\n\n    assign disparity_out = control_in ? disparity_control_out : disparity_data_out;\n    assign encoder_out   = control_in ? encoder_control_out : encoder_data_out;\n\n    encoder_8b10b_control enc_control (\n        .clk_in(clk_in),\n        .reset_in(reset_in),\n        .control_in(control_in),\n        .encoder_in(encoder_in),\n        .disparity_out(disparity_control_out),\n        .encoder_out(encoder_control_out)\n    );\n    \n    encoder_8b10b_data enc_data (\n        .clk_in(clk_in),\n        .reset_in(reset_in),\n        .control_in(control_in),\n        .encoder_in(encoder_in),\n        .ein_rd(disparity_data_in),\n        .disparity_out(disparity_data_out),\n        .encoder_out(encoder_data_out)\n    );\n\nendmodule\n\nmodule encoder_8b10b_control (\n    input  logic        clk_in,\n    input  logic        reset_in,\n    input  logic        control_in,\n    input  logic [7:0]  encoder_in,\n    output logic        disparity_out,\n    output logic [9:0]  encoder_out\n);\n\n    typedef enum logic [1:0] {RD_MINUS, RD_PLUS} t_state_type;\n    t_state_type current_disparity;\n\n    parameter [31:0] disparity_table_6b = 32'b11101000100000011000000110010111;\n    parameter [7:0]  disparity_table_4b = 8'b10001001;\n\n    logic        disparity_track;\n    logic [7:0]  registered_input;\n    logic        registered_control;\n    logic [2:0]  index_3b;\n    logic        disparity_4b;\n    logic [4:0]  index_5b;\n    logic        disparity_6b;\n\n    assign index_3b     = registered_input[7:5];\n    assign disparity_4b = disparity_table_4b[index_3b];\n    assign index_5b     = registered_input[4:0];\n    assign disparity_6b = disparity_table_6b[index_5b];\n    assign disparity_out = disparity_track;\n\n    always_comb begin\n        logic [9:0] control_code;\n\n        if (registered_control) begin\n            case (registered_input)\n                8'h1C: control_code = 10'b0011110100;\n                8'h3C: control_code = 10'b0011111001;\n                8'h5C: control_code = 10'b0011110101;\n                8'h7C: control_code = 10'b0011110011;\n                8'h9C: control_code = 10'b0011110010;\n                8'hBC: control_code = 10'b0011111010;\n                8'hDC: control_code = 10'b0011110110;\n                8'hFC: control_code = 10'b0011111000;\n                8'hF7: control_code = 10'b1110101000;\n                8'hFB: control_code = 10'b1101101000;\n                8'hFD: control_code = 10'b1011101000;\n                8'hFE: control_code = 10'b0111101000;\n                default: control_code = 10'b0000000000;\n            endcase\n\n            if (current_disparity == RD_MINUS) begin\n                encoder_out = control_code;\n                disparity_track = 1'b0;\n            end else begin\n                encoder_out = ~control_code;\n                disparity_track = 1'b1;\n            end\n        end else begin\n            encoder_out = 10'b0000000000;\n            control_code = 10'b0;\n            disparity_track = 1'b0;\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            current_disparity <= RD_MINUS;\n        end else begin\n            if ((registered_input[1:0] != 2'b00) && registered_control) begin\n                current_disparity <= current_disparity;\n            end else begin\n                case (current_disparity)\n                    RD_MINUS: begin\n                        if ((registered_control ^ disparity_6b ^ disparity_4b) != 1'b0) begin\n                            current_disparity <= RD_PLUS;\n                        end\n                    end\n                    RD_PLUS: begin\n                        if ((registered_control ^ disparity_6b ^ disparity_4b) != 1'b0) begin\n                            current_disparity <= RD_MINUS;\n                        end\n                    end\n                    default: current_disparity <= RD_MINUS;\n                endcase\n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            registered_input  <= 8'b00000000;\n            registered_control <= 1'b0;\n        end else begin\n            registered_input  <= encoder_in;\n            registered_control <= control_in;\n        end\n    end\n\nendmodule\n\nmodule encoder_8b10b_data (\n    input  logic        clk_in,\n    input  logic        reset_in,\n    input  logic        control_in,\n    input  logic        ein_rd,\n    input  logic [7:0]  encoder_in,\n    output logic        disparity_out,\n    output logic [9:0]  encoder_out\n);\n\n    wire [7:0] encoder_in_w;\n    wire K;\n\n    wire is_all_low;\n    wire is_three_low;\n    wire is_two_low_two_high;\n    wire is_three_high;\n    wire is_all_high;\n\n    wire disparity_case_0;\n    wire disparity_case_1;\n    wire disparity_case_2;\n    wire disparity_case_3;\n    wire invert_a_i;\n    wire disp4, disp5, disp6, invert_fj;\n    \n    logic a_w, b_w, c_w, d_w, e_w, i_w, f_w, g_w, h_w, j_w;\n    logic a, b, c, d, e, i, f, g, h, j;\n    logic rd1_part, rd1;\n    logic disparity_reg;\n    logic SorK;\n\n    assign encoder_in_w = encoder_in;\n    assign K = control_in;\n    assign is_all_low          = (!encoder_in_w[0] & !encoder_in_w[1] & !encoder_in_w[2] & !encoder_in_w[3]);\n    assign is_three_low        = (!encoder_in_w[0] & !encoder_in_w[1] & !encoder_in_w[2] &  encoder_in_w[3]) |\n                                 (!encoder_in_w[0] & !encoder_in_w[1] &  encoder_in_w[2] & !encoder_in_w[3]) |\n                                 (!encoder_in_w[0] &  encoder_in_w[1] & !encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] & !encoder_in_w[1] & !encoder_in_w[2] & !encoder_in_w[3]);\n    assign is_two_low_two_high = (!encoder_in_w[0] & !encoder_in_w[1] &  encoder_in_w[2] &  encoder_in_w[3]) |\n                                 (!encoder_in_w[0] &  encoder_in_w[1] &  encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] &  encoder_in_w[1] & !encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] & !encoder_in_w[1] &  encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] & !encoder_in_w[1] & !encoder_in_w[2] &  encoder_in_w[3]) |\n                                 (!encoder_in_w[0] &  encoder_in_w[1] & !encoder_in_w[2] &  encoder_in_w[3]);\n    assign is_three_high       = ( encoder_in_w[0] &  encoder_in_w[1] &  encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] &  encoder_in_w[1] & !encoder_in_w[2] &  encoder_in_w[3]) |\n                                 ( encoder_in_w[0] & !encoder_in_w[1] &  encoder_in_w[2] &  encoder_in_w[3]) |\n                                 (!encoder_in_w[0] &  encoder_in_w[1] &  encoder_in_w[2] &  encoder_in_w[3]);\n    assign is_all_high         = ( encoder_in_w[0] &  encoder_in_w[1] &  encoder_in_w[2] &  encoder_in_w[3]);\n\n    assign disparity_case_0    = (!is_two_low_two_high & !is_three_high & !encoder_in_w[4]);\n    assign disparity_case_1    = (is_three_high & !encoder_in_w[3] & !encoder_in_w[4]);\n    assign disparity_case_2    = (is_three_low &  encoder_in_w[3] &  encoder_in_w[4]);\n    assign disparity_case_3    = (!is_two_low_two_high & !is_three_low &  encoder_in_w[4]);\n    assign invert_a_i          = !(ein_rd ? (disparity_case_3 | disparity_case_1 | K) : (disparity_case_0 | disparity_case_2));\n\n    always_comb begin\n        a_w = !encoder_in_w[0];\n        b_w = ((is_all_low) ? 1'b0 : (is_all_high) ? 1'b1 : !encoder_in_w[1]);\n        c_w = ((is_all_low) ? 1'b0 : (is_three_low & encoder_in_w[3] & encoder_in_w[4]) ? 1'b0 : !encoder_in_w[2]);\n        d_w = ((is_all_high) ? 1'b1 : !encoder_in_w[3]);\n        e_w = ((is_three_low & !encoder_in_w[4]) ? 1'b0 : (is_three_low & encoder_in_w[3] & encoder_in_w[4]) ? 1'b1 : !encoder_in_w[4]);\n        i_w = ((is_two_low_two_high & !encoder_in_w[4]) ? 1'b0 : (is_all_low & encoder_in_w[4]) ? 1'b0 : \n               (is_three_low & !encoder_in_w[3] & encoder_in_w[4]) ? 1'b0 : (is_all_high & encoder_in_w[4]) ? 1'b0 : \n               (is_two_low_two_high & K) ? 1'b0 : 1'b1);\n\n        rd1_part = (disparity_case_0 | disparity_case_2 | disparity_case_3);\n        rd1 = (rd1_part | K) ^ ein_rd;\n    end\n\n    assign {a, b, c, d, e, i} = (~invert_a_i) ? {a_w, b_w, c_w, d_w, e_w, i_w} : ~{a_w, b_w, c_w, d_w, e_w, i_w};\n\n    always_comb begin\n        SorK = (e & i & !rd1) | (!e & !i & rd1) | K;\n    end\n\n    assign disp4 = (!encoder_in_w[5] & !encoder_in_w[6]);\n    assign disp5 = (encoder_in_w[5] & encoder_in_w[6]);\n    assign disp6 = ((encoder_in_w[5] ^ encoder_in_w[6])) | K;\n    assign invert_fj = !(rd1 ? disp5 : (disp4 | disp6));\n\n    always_comb begin\n        f_w = ((encoder_in_w[5] & encoder_in_w[6] & encoder_in_w[7] & SorK) ? 1'b1 : !encoder_in_w[5]);\n        g_w = ((!encoder_in_w[5] & !encoder_in_w[6] & !encoder_in_w[7]) ? 1'b0 : !encoder_in_w[6]);\n        h_w = !encoder_in_w[7];\n        j_w = (((encoder_in_w[5] ^ encoder_in_w[6]) & !encoder_in_w[7]) ? 1'b0 : (encoder_in_w[5] & encoder_in_w[6] & encoder_in_w[7] & SorK) ? 1'b0 : 1'b1);\n    end\n\n    assign {f, g, h, j} = (invert_fj | disp6) ? ~{f_w, g_w, h_w, j_w} : {f_w, g_w, h_w, j_w};\n\n    assign disparity_reg = (reset_in) ? 1'b0 : (disp4 | (encoder_in_w[5] & encoder_in_w[6] & encoder_in_w[7])) ^ rd1;\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            disparity_out <= 1'b0;\n            encoder_out <= 10'b0000000000;\n        end else begin\n            if (!control_in) begin\n                disparity_out <= disparity_reg;\n                encoder_out <= {a, b, c, d, e, i, f, g, h, j};\n            end else begin\n                disparity_out <= 1'b0;\n                encoder_out <= 10'b0000000000;\n            end\n        end\n    end\n\nendmodule\n\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    for line in lines[2:]:\n        info = line.split()\n        while len(info) < 3:\n            info.append(\"0%\")\n        inst = re.sub(r'[\\W]', '', info[0])\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'uut' is missing in the coverage log.\")\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))\n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['uut']['Average']}, Target: {target}\"\n"}}}
{"id": "cvdp_copilot_endian_swapper_0004", "categories": ["cid012", "medium"], "input": {"prompt": "Develop a **SystemVerilog testbench** to generate **input stimulus** for the **`endian_swapper`** module with **DATA_BYTES = 8** (64-bit data). The testbench must systematically **apply input sequences** to exercise different functional behaviors of the DUT, ensuring that **all edge cases, control signals, and buffering mechanisms are triggered**. The testbench **must not include any checker logic or pass/fail criteria**\u2014it is purely **stimulus-driven**.\n\n---\n\n## **Design Details**  \n\n### **1. Functional Behavior**  \n\nThe endian swapper module processes input data and optionally swaps byte order based on control register settings. It follows an AXI Stream-based handshake mechanism to handle input and output transactions while maintaining buffering for flow control.\n\n#### **1.1 Parameters**  \n- **`DATA_BYTES = 8`** \u2192 Defines the **byte width** of the data stream (`64 bits`).  \n- **`CLK_PERIOD = 10 ns`** \u2192 The system runs at **100 MHz** (`clk` toggles every `5 ns`).  \n- **`TIMEOUT = 1000`** \u2192 Defines the **maximum wait cycles** for handshake events.  \n\n#### **1.2 Input Ports**  \n- `clk` \u2192 **100 MHz clock** controlling data transfer.  \n- `reset_n` \u2192 **Active-low reset** for DUT initialization.  \n- `stream_in_data [63:0]` \u2192 **64-bit input data bus**.  \n- `stream_in_empty [2:0]` \u2192 **Indicates number of unused bytes** in input.  \n- `stream_in_valid` \u2192 **Asserted when input data is valid**.  \n- `stream_in_startofpacket` \u2192 **Marks start of packet** in input stream.  \n- `stream_in_endofpacket` \u2192 **Marks end of packet** in input stream.  \n- `stream_out_ready` \u2192 **Downstream ready signal** for output transfer.  \n- `csr_address [1:0]` \u2192 **CSR register address**.  \n- `csr_read` \u2192 **CSR read enable**.  \n- `csr_write` \u2192 **CSR write enable**.  \n- `csr_writedata [31:0]` \u2192 **32-bit CSR write data**.  \n\n#### **1.3 Output Ports**  \n- `stream_in_ready` \u2192 **DUT ready to accept input data**.  \n- `stream_out_data [63:0]` \u2192 **64-bit output data bus**.  \n- `stream_out_empty [2:0]` \u2192 **Number of unused bytes** in output.  \n- `stream_out_valid` \u2192 **Asserted when output data is valid**.  \n- `stream_out_startofpacket` \u2192 **Start of packet in output stream**.  \n- `stream_out_endofpacket` \u2192 **End of packet in output stream**.  \n- `csr_readdata [31:0]` \u2192 **CSR readback value**.  \n- `csr_readdatavalid` \u2192 **Indicates valid CSR read response**.  \n- `csr_waitrequest` \u2192 **Indicates CSR access is stalled**.  \n\n---\n\n## **Testbench Structure**  \n\n### **1. Clock Generation**  \n- Generate a **100 MHz clock** (`clk`) by toggling it **every 5 ns** (`CLK_PERIOD/2`).  \n\n### **2. Reset Sequencing**  \n- Assert `reset_n = 0` for a few clock cycles, then deassert it to **initialize the DUT**.  \n\n### **3. DUT Instantiation**  \n- Instantiate the `endian_swapper` module with **DATA_BYTES = 8** and connect all required input/output signals.  \n\n### **4. Stimulus Sequences**  \nThe testbench must **apply a variety of test cases** to exercise input conditions, buffer behavior, and CSR interactions.\n\n#### **4.1 AXI Stream Data Transfers**  \n- **Basic Operation (No Swap)** \u2192 Send a **64-bit word** with byte-swapping disabled.  \n- **Byte Swapping Enabled** \u2192 Enable byte-swapping via CSR and resend test data.  \n- **Packet Boundary Handling** \u2192 Send **multi-word packets** with `startofpacket` and `endofpacket` signals toggling.  \n\n#### **4.2 Flow Control and Buffering**  \n- **Flow Control Handling** \u2192 Deassert `stream_out_ready` while sending data, then re-enable it to test backpressure handling.  \n- **Buffering Mechanism** \u2192 Send **multiple packets** while `stream_out_ready` is **low**, then assert it to drain data.  \n\n#### **4.3 CSR Operations**  \n- **CSR Read/Write** \u2192 Perform CSR **write and readback** operations to configure DUT settings.  \n- **CSR Access in Middle of Packet** \u2192 Issue a **CSR read while data transfer is ongoing**, ensuring the DUT handles CSR operations correctly.  \n\n#### **4.4 Edge Cases**  \n- **Zero Data Handling** \u2192 Send an **all-zero 64-bit word** and observe behavior.  \n- **Maximum Data Handling** \u2192 Send an **all-ones 64-bit word** (`0xFFFFFFFFFFFFFFFF`).  \n- **Partial Empty Bytes** \u2192 Vary `stream_in_empty` values and observe how the DUT processes incomplete words.  \n\n---\n\n## **Simulation Requirements**  \n\n### **1. Waveform Generation**  \n- Generate a **VCD waveform file** (`endian_swapper_tb.vcd`) for **post-simulation analysis**.  \n\n### **2. AXI Stream transactions**  \n- Ensure **proper handshake mechanisms** (`valid`-`ready` interactions) during **data transfer sequences**.  \n\n### **3. CSR and Data Processing Interactions**  \n- The testbench should **issue CSR commands mid-packet** and observe how the DUT handles **simultaneous control and data operations**.  \n\n---\n\nDevelop a **testbench** that:  \n- **Generates stimulus** to exercise `endian_swapper` across multiple functional scenarios.  \n- **Ensures input variations cover** normal operation, byte-swapping, packet boundaries, flow control, and CSR interactions.  \n- **Executes all predefined stimulus sequences** without assertions, output verification, or pass/fail conditions.  ", "context": {}}, "output": {"response": "", "context": {"verif/endian_swapper_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 4-tb-stimulus\nTARGET = 92 ", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite\n", "src/endian_swapper.sv": "module endian_swapper #(\n    parameter DATA_BYTES = 8\n) (\n    input  wire                          clk,\n    input  wire                          reset_n,\n\n    input  wire [(DATA_BYTES*8)-1:0]     stream_in_data,\n    input  wire [$clog2(DATA_BYTES)-1:0] stream_in_empty,\n    input  wire                          stream_in_valid,\n    input  wire                          stream_in_startofpacket,\n    input  wire                          stream_in_endofpacket,\n    output reg                           stream_in_ready,\n\n    output reg [(DATA_BYTES*8)-1:0]      stream_out_data,\n    output reg [$clog2(DATA_BYTES)-1:0]  stream_out_empty,\n    output reg                           stream_out_valid,\n    output reg                           stream_out_startofpacket,\n    output reg                           stream_out_endofpacket,\n    input  wire                          stream_out_ready,\n\n    input  wire [1:0]                    csr_address,\n    output reg  [31:0]                   csr_readdata,\n    output reg                           csr_readdatavalid,\n    input  wire                          csr_read,\n    input  wire                          csr_write,\n    output reg                           csr_waitrequest,\n    input  wire [31:0]                   csr_writedata\n);\n\n////////////////////////////////////////////////////////////////////////////////\n// Localparams to define bit widths explicitly\n////////////////////////////////////////////////////////////////////////////////\nlocalparam DATA_WIDTH  = DATA_BYTES * 8;\nlocalparam EMPTY_WIDTH = $clog2(DATA_BYTES);\n\n// --------------------------------------------------------------------\n// Internal Signals\n// --------------------------------------------------------------------\n\n// TWO-slot buffering\nreg [DATA_WIDTH-1:0]   buffer0_data, buffer1_data;\nreg [EMPTY_WIDTH-1:0]  buffer0_empty, buffer1_empty;\nreg                    buffer0_start, buffer0_end, buffer1_start, buffer1_end;\nreg                    buffer0_valid, buffer1_valid;\n\n// CSR-related\nreg                    byteswapping;\nreg [31:0]             packet_count;\nreg                    in_packet;\nreg                    csr_waitrequest_reg;\n\n// --------------------------------------------------------------------\n// stream_in_ready: at least one buffer slot is free\n// --------------------------------------------------------------------\nalways @* begin\n    if ((buffer0_valid == 1'b0) || (buffer1_valid == 1'b0))\n        stream_in_ready = 1'b1;\n    else\n        stream_in_ready = 1'b0;\nend\n\n// --------------------------------------------------------------------\n// TWO-BUFFER Storage & Shifting\n// --------------------------------------------------------------------\n// Each cycle:\n// 1) If we are consuming the data in buffer0 (stream_out_ready & valid),\n//    then shift buffer1 into buffer0 (if buffer1_valid).\n// 2) If stream_in_valid & stream_in_ready, accept new data into\n//    whichever buffer slot is free (0 if free, else 1).\n// --------------------------------------------------------------------\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        // Clear Buffer0\n        buffer0_valid <= 1'b0;\n        buffer0_data  <= {DATA_WIDTH{1'b0}};\n        buffer0_empty <= {EMPTY_WIDTH{1'b0}};\n        buffer0_start <= 1'b0;\n        buffer0_end   <= 1'b0;\n\n        // Clear Buffer1\n        buffer1_valid <= 1'b0;\n        buffer1_data  <= {DATA_WIDTH{1'b0}};\n        buffer1_empty <= {EMPTY_WIDTH{1'b0}};\n        buffer1_start <= 1'b0;\n        buffer1_end   <= 1'b0;\n    end\n    else begin\n        //-----------------------------------------\n        // 1) Pop / Shift if buffer0 is consumed\n        //-----------------------------------------\n        if ((stream_out_ready == 1'b1) && (stream_out_valid == 1'b1) && (buffer0_valid == 1'b1)) begin\n            if (buffer1_valid == 1'b1) begin\n                // SHIFT buffer1 -> buffer0 (blocking assignment)\n                buffer0_data  <= buffer1_data;\n                buffer0_empty <= buffer1_empty;\n                buffer0_start <= buffer1_start;\n                buffer0_end   <= buffer1_end;\n                buffer0_valid <= 1'b1;\n\n                // Clear buffer1\n                buffer1_valid <= 1'b0;\n                buffer1_data  <= {DATA_WIDTH{1'b0}};\n                buffer1_empty <= {EMPTY_WIDTH{1'b0}};\n                buffer1_start <= 1'b0;\n                buffer1_end   <= 1'b0;\n            end\n            else begin\n                // Buffer1 empty => buffer0 now empty\n                buffer0_valid <= 1'b0;\n            end\n        end\n\n        //-----------------------------------------\n        // 2) Accept new data if there's a free slot\n        //-----------------------------------------\n        if ((stream_in_ready == 1'b1) && (stream_in_valid == 1'b1)) begin\n            // If buffer0 is free, store in buffer0\n            if (buffer0_valid == 1'b0) begin\n                buffer0_valid <= 1'b1;\n                buffer0_data  <= stream_in_data;\n                buffer0_empty <= stream_in_empty;\n                buffer0_start <= stream_in_startofpacket;\n                buffer0_end   <= stream_in_endofpacket;\n            end\n            // Else if buffer1 is free, store in buffer1\n            else if (buffer1_valid == 1'b0) begin\n                buffer1_valid <= 1'b1;\n                buffer1_data  <= stream_in_data;\n                buffer1_empty <= stream_in_empty;\n                buffer1_start <= stream_in_startofpacket;\n                buffer1_end   <= stream_in_endofpacket;\n            end\n            // else: both full => no-op\n        end\n    end\nend\n\n// --------------------------------------------------------------------\n// Packet Counting\n//   - We watch SOP/EOP on output side to track # of packets\n// --------------------------------------------------------------------\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        in_packet    <= 1'b0;\n        packet_count <= 32'd0;\n    end\n    else begin\n        if ((stream_out_valid == 1'b1) && (stream_out_ready == 1'b1)) begin\n            // Start-of-packet\n            if (stream_out_startofpacket == 1'b1) begin\n                packet_count <= packet_count + 32'd1;\n                in_packet    <= 1'b1;\n            end\n            // End-of-packet\n            if (stream_out_endofpacket == 1'b1) begin\n                in_packet <= 1'b0;\n            end\n        end\n    end\nend\n\n// --------------------------------------------------------------------\n// Output Data & Control\n//   - If buffer0_valid => output from buffer0\n//   - If byteswapping=1 => test expects empty=0\n// --------------------------------------------------------------------\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        stream_out_data          <= {DATA_WIDTH{1'b0}};\n        stream_out_empty         <= {EMPTY_WIDTH{1'b0}};\n        stream_out_valid         <= 1'b0;\n        stream_out_startofpacket <= 1'b0;\n        stream_out_endofpacket   <= 1'b0;\n    end\n    else begin\n        if (buffer0_valid == 1'b1) begin\n            // Drive buffer0 contents\n            stream_out_valid <= 1'b1;\n            if (byteswapping == 1'b1) begin\n                for (int i = 0; i < DATA_BYTES; i = i + 1) begin\n                    stream_out_data[i*8 +: 8] <= buffer0_data[(DATA_BYTES-1-i)*8 +: 8];\n                end            \n                stream_out_empty <= {EMPTY_WIDTH{1'b0}};\n            end else begin\n                stream_out_data  <= buffer0_data;\n                stream_out_empty <= buffer0_empty;\n            end\n            stream_out_startofpacket <= buffer0_start;\n            stream_out_endofpacket   <= buffer0_end;\n        end\n        else begin\n            // No data => invalid\n            stream_out_valid         <= 1'b0;\n            stream_out_data          <= {DATA_WIDTH{1'b0}};\n            stream_out_empty         <= {EMPTY_WIDTH{1'b0}};\n            stream_out_startofpacket <= 1'b0;\n            stream_out_endofpacket   <= 1'b0;\n        end\n    end\nend\n\n// --------------------------------------------------------------------\n// CSR Interface\n// --------------------------------------------------------------------\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        byteswapping         <= 1'b0;\n        csr_readdata         <= 32'd0;\n        csr_readdatavalid    <= 1'b0;\n        csr_waitrequest_reg  <= 1'b1;\n    end\n    else begin\n        // The testbench checks that we stall CSR if we're in_packet\n        csr_waitrequest_reg <= in_packet;\n\n        csr_readdatavalid <= 1'b0;\n        // CSR Read\n        if ((csr_read == 1'b1) && (csr_waitrequest_reg == 1'b0)) begin\n            csr_readdatavalid <= 1'b1;\n            case (csr_address)\n                2'b00: csr_readdata <= {31'b0, byteswapping};\n                2'b01: csr_readdata <= packet_count;\n                default: csr_readdata <= 32'd0;\n            endcase\n        end\n\n        // CSR Write\n        if ((csr_write == 1'b1) && (csr_waitrequest_reg == 1'b0)) begin\n            case (csr_address)\n                2'b00: byteswapping <= csr_writedata[0];\n                // 2'b01 => read-only, ignore\n            endcase\n        end\n    end\nend\n\n// Waitrequest output\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n)\n        csr_waitrequest <= 1'b1;\n    else\n        csr_waitrequest <= csr_waitrequest_reg;\nend\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_events_to_apb_0021", "categories": ["cid012", "medium"], "input": {"prompt": "Write a SystemVerilog testbench named `tb_apb_controller` that only generates stimuli for an `apb_controller` module. The testbench should generate input stimuli for different operating conditions and sequences, including the handling of multiple simultaneous events (Event A, Event B, and Event C), proper prioritization, and the built-in timeout mechanism.\n\n---\n\n### Module Overview\n\nThe `apb_controller` is an Advanced Peripheral Bus (APB) write controller that manages write transactions triggered by three independent events (A, B, and C). Each event carries its 32-bit address and 32-bit data input. The controller follows the APB protocol with a three-phase state machine consisting of **IDLE**, **SETUP**, and **ACCESS** phases. Events are triggered by  `select_a_i`, `select_b_i`, and `select_c_i` signals for events A, B, and C respectively. Additionally, it implements a timeout mechanism to prevent indefinite stalling if the peripheral fails to respond within a specified period. it supports multiple event queuing and prioritization, ensuring that events are processed in order while dynamically adjusting their priority based on previous transactions.\n\n---\n\n#### Inputs:\n- **`clk`**: System clock. The design is synchronized to the positive edge of this clock.\n- **`reset_n`**: Active-low asynchronous reset signal that resets the controller to the `IDLE` state, clears the timeout counter, and sets all registers and outputs to 0.\n- **`select_a_i`**: Active-high control signal to initiate a transaction for Event A.\n- **`select_b_i`**: Active-high control signal to initiate a transaction for Event B.\n- **`select_c_i`**: Active-high control signal to initiate a transaction for Event C.\n- **`addr_a_i [31:0]`**: Address input for Event A.\n- **`data_a_i [31:0]`**: Data input for Event A.\n- **`addr_b_i [31:0]`**: Address input for Event B.\n- **`data_b_i [31:0]`**: Data input for Event B.\n- **`addr_c_i [31:0]`**: Address input for Event C.\n- **`data_c_i [31:0]`**: Data input for Event C.\n- **`apb_pready_i`**:  Ready signal from the peripheral, active high. It indicates when the peripheral is ready to complete the transaction. The controller checks this signal in the `ACCESS` phase to determine transaction completion.\n\n#### Outputs:\n- **`apb_psel_o`**: An active-high signal, asserted during `SETUP`, to select the peripheral for an APB transaction.\n- **`apb_penable_o`**: An active-high signal, asserted during the `ACCESS` phase, indicating the transaction is in progress.\n- **`apb_pwrite_o`**: An active-high signal indicating a write operation, asserted during the `SETUP` and maintained in the `ACCESS` phase.\n- **`apb_paddr_o [31:0]`**: 32-bit address output for the transaction, determined by the selected event's address input (`addr_a_i`, `addr_b_i`, or `addr_c_i`). Defaults to 0 in the `IDLE` state.\n- **`apb_pwdata_o [31:0]`**: 32-bit data output for the write operation, based on the selected event's data input (`data_a_i`, `data_b_i`, or `data_c_i`). Defaults to 0 in the `IDLE` state.\n\n### Multiple Simultaneous Behaviour Handling:\n\n#### **1. Event Queuing**\n- The module can track multiple simultaneous events (select_a_i, select_b_i, select_c_i) in an event queue. \n- Once a transaction for a higher-priority event is granted, it gets the lowest priority if triggered again before the queue is emptied.\n\n#### **2. Event Processing**\n- The module processes **one event at a time** from the queue.\n- After completing an event's APB transaction, it is removed from the queue and then the module proceeds to the next event. \n\n#### Transaction Flow and Timing:\n\nThe transactions follow a three-state flow:\n\n1. **IDLE**:\n     - If multiple select signals are asserted simultaneously, the controller prioritizes them as `select_a_i` (highest priority), followed by `select_b_i`, and then `select_c_i` (lowest priority).\n     - Evaluates the event queue to determine the next event to process.\n     - Transition to the `SETUP` state when an event is available.\n     - The **IDLE** phase lasts for one clock cycle when the queue is not empty. \n     - The default state is **IDLE** state, which it enters after a reset and remains in when no transactions are active   \n\n2. **SETUP**:\n   - After the **IDLE** phase, the controller transitions to the **SETUP** phase.\n   - in the **SETUP** phase the controller asserts `apb_psel_o`, and `apb_pwrite_o` and set up `apb_paddr_o` and `apb_pwdata_o` with the selected address and data.\n   - In this phase, `apb_penable_o` remains de-asserted.\n   - The **SETUP** phase lasts for one clock cycle.\n\n3. **ACCESS**:\n   - After the **SETUP** phase, the controller transitions to the **ACCESS** phase.\n   - In **ACCESS**, `apb_penable_o` is asserted high to signal that the data transfer is in progress.\n   - The controller remains in this phase, waiting for `apb_pready_i` from the peripheral to be asserted high.\n   - In **ACCESS** phase, the signals `apb_psel_o`, `apb_pwrite_o`, `apb_paddr_o`, and `apb_pwdata_o` remains stable.\n   - **Write Transfer with Wait**: If `apb_pready_i` is delayed, the controller stays in **ACCESS** until `apb_pready_i` goes high.\n   - **Write Transfer without Wait**: If  `apb_pready_i` goes high in the same clock cycle that the controller enters the **ACCESS** phase, the controller completes the transaction within the same cycle.\n   - **Timeout Mechanism**:\n       - In the **ACCESS** phase, a 4-bit timeout counter increments each clock cycle if `apb_pready_i` remains low.\n       - If `apb_pready_i` is not asserted within 15 cycles after entering the **ACCESS** state, the timeout counter resets the controller to the **IDLE** state and sets all outputs to 0 at the next positive edge, effectively aborting the transaction and preventing indefinite stalling.\n       - The timeout counter resets to zero after a successful transaction or when the controller returns to the **IDLE** state.\n   - After a successful transaction (when `apb_pready_i` is asserted), the controller returns to the **IDLE** state, with both `apb_psel_o` and `apb_penable_o` getting deasserted.\n   - After returning to the IDLE state after the APB transaction of a specific event gets completed (timeout or assertion of `apb_pready_i` to 1) the design processes the next event in the queue in case of multiple simultaneous events and the queue is not empty. If the queue is empty, a new transaction can only start by asserting a select signal (`select_a_i`, `select_b_i`, or `select_c_i`) while both `apb_psel_o` and `apb_penable_o` are low.\n\n### Total Latency for the Transaction:\n\n- **Minimum Latency**: From the triggering of an event when the queue is empty, the latency from the event assertion to the `apb_psel_o` assertion is **3 clock cycles**. (1 cycle each for latching the event signal, updating the queue, and asserting `apb_psel_o` for the triggered event).\n- However, when the queue is not empty, the latency for the `apb_psel_o` assertion for the next event to be processed is **1 clock cycle** after the completion of the first transaction (after de-assertion of all output signals).\n- When an event is retriggered after the completion of its previous APB transaction while the last event in the queue has just started, the latency for asserting `apb_psel_o` for the next event to be processed is 2. This is because the event signal is latched previously (at trigger) and only updating the queue and asserting `apb_psel_o` is required. \n- Signals `apb_pwrite_o`, `apb_paddr_o` and `apb_pwdata_o` are asserted in **SETUP** phase along with `apb_psel_o` and thus have similar latency as `apb_psel_o`.\n- Signal `apb_penable_o` takes one additional clock cycle than `apb_psel_o` as ` apb_penable_o` is asserted one clock cycle later (in the **ACCESS** state).\n- When the event queue is not empty, each STATE requires one cycle except if `apb_pready_i` is delayed, additional cycles are spent in the `ACCESS` state until the peripheral is ready or a timeout occurs\n- After an APB Transaction is completed, it takes 1 cycle to de-assert signals and to return to `IDLE`.\n\n### Constraints:\n- Assume that event signals `select_a_i`, `select_b_i`, and `select_c_i` are pulse signals high for one clock cycle and are synchronous to the clock.\n- Assume that input data and addresses will be stable inputs when the events are triggered.\n- If multiple events are triggered simultaneously, the highest-priority event will be processed first, followed by the other events based on their priority.\n- If any event (`select_a_i`, `select_b_i`, `select_c_i`) is asserted, the same input will not reassert until at least one clock cycle after its previous APB transaction is completed. Once the previous event from a specific input is completed, the next event from the same input can trigger at any time and will be added to the queue for execution after all previously queued events.\n\n---\n\n### Stimulus Generation Requirements:\n\nInstantiate the `apb_controller` module as the `dut` with all required ports connected. The testbench must cover all possible scenarios to achieve 100% coverage.\n\n#### 1. Clock and Reset:\n- Generate a continuous `clk` signal.\n- Drive an active-low asynchronous reset signal to initialize the `dut` in the **IDLE** state.\n\n#### 2. Event Triggering and Priority:\n- Create pulse stimuli for the event select inputs (`select_a_i`, `select_b_i`, and `select_c_i`) that are one clock cycle wide.\n- Generate random stimuli for different scenarios, including simultaneous assertion of multiple event signals (for internal prioritization) and isolated single-event activations (for one event at a time).\n- Generate stimuli for the 32-bit address and data signals for each event (`addr_a_i`, `data_a_i`, `addr_b_i`, `data_b_i`, `addr_c_i`, and `data_c_i`) with fixed or varying values.\n\n#### 3. APB Peripheral Ready Signal:\n- Generate stimuli of the `apb_pready_i` input for:\n    - When `apb_pready_i` is asserted quickly (immediate response) to mimic minimum transaction latency.\n    - When `apb_pready_i` is delayed, causing the `dut` to remain longer in the **ACCESS** state and eventually leading to the timeout mechanism.\n\n---\n\n**Deliverables:**\n\nA SystemVerilog testbench that generates varied input stimuli for the `apb_controller` module according to the above specifications and allows different corner cases for extended testing scenarios.", "context": {}}, "output": {"response": "", "context": {"verif/tb_apb_controller.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 21-tb-stimulus-apb-1\nTARGET = 99\n", "src/apb_controller.sv": "module apb_controller(\n    input  logic         clk,              // Clock signal\n    input  logic         reset_n,          // Active low asynchronous reset signal\n    input  logic         select_a_i,       // Select signal for event A\n    input  logic         select_b_i,       // Select signal for event B\n    input  logic         select_c_i,       // Select signal for event C\n    input  logic [31:0]  addr_a_i,         // 32-bit address for event A transaction\n    input  logic [31:0]  data_a_i,         // 32-bit data for event A transaction\n    input  logic [31:0]  addr_b_i,         // 32-bit address for event B transaction\n    input  logic [31:0]  data_b_i,         // 32-bit data for event B transaction\n    input  logic [31:0]  addr_c_i,         // 32-bit address for event C transaction\n    input  logic [31:0]  data_c_i,         // 32-bit data for event C transaction\n    output logic         apb_psel_o,       // APB select signal\n    output logic         apb_penable_o,    // APB enable signal\n    output logic [31:0]  apb_paddr_o,      // 32-bit APB address output\n    output logic         apb_pwrite_o,     // APB write signal\n    output logic [31:0]  apb_pwdata_o,     // 32-bit APB write data output\n    input  logic         apb_pready_i      // APB ready signal from the peripheral\n);\n\n    // State definitions\n    typedef enum logic [1:0] {\n       IDLE,   \n       SETUP,  \n       ACCESS\n    } state_t; \n\n    logic [3:0]  count;\n    logic [2:0]  event_sel; \n    logic [2:0]  event_sel_ff; \n    logic [2:0]  event_list;    \n    state_t      current_state, next_state;\n    logic [31:0] sel_addr_next, sel_data_next;  \n    logic [31:0] sel_addr, sel_data;          \n    logic select_a_pulse, select_b_pulse, select_c_pulse;\n\n    assign apb_psel_o    = (current_state == SETUP || current_state == ACCESS) ? 1'b1 : 1'b0;\n    assign apb_penable_o = (current_state == ACCESS) ? 1'b1 : 1'b0;\n    assign apb_pwrite_o  = (current_state == SETUP || current_state == ACCESS) ? 1'b1 : 1'b0;\n    assign apb_paddr_o   = (current_state == SETUP || current_state == ACCESS) ? sel_addr : 32'b0;\n    assign apb_pwdata_o  = (current_state == SETUP || current_state == ACCESS) ? sel_data : 32'b0;\n\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            current_state <= IDLE;\n            event_list    <= 3'b000; \n            event_sel_ff    <= 3'b000; \n            select_a_pulse  <= 1'b0;  \n            select_b_pulse  <= 1'b0; \n            select_c_pulse  <= 1'b0;             \n        end else begin\n            select_a_pulse <= (select_a_i) ? 1'b1 : select_a_pulse;\n            select_b_pulse <= (select_b_i) ? 1'b1 : select_b_pulse;\n            select_c_pulse <= (select_c_i) ? 1'b1 : select_c_pulse;      \n            event_sel_ff   <= event_sel;              \n            current_state  <= next_state;\n            if (current_state == IDLE) begin\n               event_list <= (select_a_pulse ? 3'b001 : 3'b000) | \n                               (select_b_pulse ? 3'b010 : 3'b000) |\n                               (select_c_pulse ? 3'b100 : 3'b000); \n            end \n            else if (next_state == IDLE) begin\n               select_a_pulse <= (event_sel[0]) ? 1'b0 : select_a_pulse;\n               select_b_pulse <= (event_sel[1]) ? 1'b0 : select_b_pulse;\n               select_c_pulse <= (event_sel[2]) ? 1'b0 : select_c_pulse;    \n               event_list   <= event_list & ~event_sel; \n            end            \n        end\n    end\n\n\n    always @(*) begin\n        // Default values\n        next_state = current_state;\n        event_sel  = event_sel_ff; \n        case (current_state)\n            IDLE: begin\n                if (event_list[0]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b001;\n                end else if (event_list[1]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b010;\n                end else if (event_list[2]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b100;\n                end else begin\n                   next_state = IDLE;\n                   event_sel  = 3'b000;\n                end\n            end\n            SETUP: begin\n                next_state = ACCESS;\n            end\n            ACCESS: begin\n                if (apb_pready_i || count == 15) begin\n                    next_state = IDLE;\n                end    \n            end\n            default: begin\n                next_state = IDLE; \n                event_sel  = 3'b000;                 \n            end    \n        endcase\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            count <= 0;\n        end else if (current_state == ACCESS && !apb_pready_i) begin\n            count <= count + 1;\n        end else begin\n            count <= 0;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            sel_addr <= 32'b0;\n            sel_data <= 32'b0;\n        end else if (current_state == IDLE) begin\n            sel_addr <= sel_addr_next;\n            sel_data <= sel_data_next;\n        end\n    end\n    \n    always @(*) begin\n        if (!reset_n) begin\n           sel_addr_next = sel_addr;\n           sel_data_next = sel_data;       \n        end \n        else begin \n            if (next_state == SETUP || next_state == ACCESS) begin\n                case (event_sel)\n                    3'b001: begin    \n                       sel_addr_next = addr_a_i; \n                       sel_data_next = data_a_i;                     \n                    end    \n                    3'b010: begin                    \n                       sel_addr_next = addr_b_i; \n                       sel_data_next = data_b_i;    \n                    end\n                    3'b100: begin                      \n                       sel_addr_next = addr_c_i; \n                       sel_data_next = data_c_i; \n                    end\n                    default: begin\n                       sel_addr_next = 32'b0; \n                       sel_data_next = 32'b0;                     \n                    end \n                endcase           \n            end     \n        end        \n    end    \n\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    print(\"average\",metrics [\"dut\"][\"Average\"])\n    print(\"target\",float(os.getenv(\"TARGET\")))\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_events_to_apb_0023", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the given SystemVerilog testbench named `tb_apb_controller` to add checker logic that validates the result for the `apb_controller` module. The testbench should check for the outputs for different operating conditions and sequences, including the handling of multiple simultaneous events (Event A, Event B, and Event C), proper prioritization, and the built-in timeout mechanism. The stimulus is already provided in the testbench, and the modification should update it to add the necessary checkers.\n\n---\n\n### Module Overview\n\nThe `apb_controller` is an Advanced Peripheral Bus (APB) write controller that manages write transactions triggered by three independent events (A, B, and C). Each event carries its 32-bit address and 32-bit data input. The controller follows the APB protocol with a three-phase state machine consisting of **IDLE**, **SETUP**, and **ACCESS** phases. Events are triggered by  `select_a_i`, `select_b_i`, and `select_c_i` signals for events A, B, and C, respectively. Additionally, it implements a timeout mechanism to prevent indefinite stalling if the peripheral fails to respond within a specified period. It supports multiple event queuing and prioritization, ensuring that events are processed in order while dynamically adjusting their priority based on previous transactions.\n\n---\n\n#### Inputs:\n- **`clk`**: System clock. The design is synchronized to the positive edge of this clock.\n- **`reset_n`**: Active-low asynchronous reset signal that resets the controller to the `IDLE` state, clears the timeout counter, and sets all registers and outputs to 0.\n- **`select_a_i`**: Active-high control signal to initiate a transaction for Event A.\n- **`select_b_i`**: Active-high control signal to initiate a transaction for Event B.\n- **`select_c_i`**: Active-high control signal to initiate a transaction for Event C.\n- **`addr_a_i [31:0]`**: Address input for Event A.\n- **`data_a_i [31:0]`**: Data input for Event A.\n- **`addr_b_i [31:0]`**: Address input for Event B.\n- **`data_b_i [31:0]`**: Data input for Event B.\n- **`addr_c_i [31:0]`**: Address input for Event C.\n- **`data_c_i [31:0]`**: Data input for Event C.\n- **`apb_pready_i`**:  Ready signal from the peripheral, active high. It indicates when the peripheral is ready to complete the transaction. The controller checks this signal in the `ACCESS` phase to determine transaction completion.\n\n#### Outputs:\n- **`apb_psel_o`**: An active-high signal, asserted during `SETUP`, to select the peripheral for an APB transaction.\n- **`apb_penable_o`**: An active-high signal, asserted during the `ACCESS` phase, indicating the transaction is in progress.\n- **`apb_pwrite_o`**: An active-high signal indicating a write operation, asserted during the `SETUP` and maintained in the `ACCESS` phase.\n- **`apb_paddr_o [31:0]`**: 32-bit address output for the transaction, determined by the selected event's address input (`addr_a_i`, `addr_b_i`, or `addr_c_i`). Defaults to 0 in the `IDLE` state.\n- **`apb_pwdata_o [31:0]`**: 32-bit data output for the write operation, based on the selected event's data input (`data_a_i`, `data_b_i`, or `data_c_i`). Defaults to 0 in the `IDLE` state.\n\n### Multiple Simultaneous Behaviour Handling:\n\n#### **1. Event Queuing**\n- The module can track multiple simultaneous events (`select_a_i`, `select_b_i`, `select_c_i`) in an event queue. \n- Once a transaction for a higher-priority event is granted, it should get the lowest priority if triggered again before the queue is emptied.\n\n#### **2. Event Processing**\n- The module processes **one event at a time** from the queue.\n- After completing an event's APB transaction, it is removed from the queue, and then the module proceeds to the next event. This requires evaluating the event queue to determine the next event to process and to enable APB transaction (asserting `apb_psel_o` to 1) when an event is available. \n\n#### Transaction Flow and Timing:\n\nThe transactions follow a three-state flow:\n\n1. **IDLE**:\n     - If multiple select signals are asserted simultaneously, the controller prioritizes them as `select_a_i` (highest priority), followed by `select_b_i`, and then `select_c_i` (lowest priority).\n     - It evaluates the event queue to determine the next event to process.\n     - Transitions to the `SETUP` state when an event is available.\n     - The **IDLE** phase lasts for one clock cycle when the queue is not empty. \n     - The default state is **IDLE** state, which it enters after a reset and remains in when no transactions are active   \n\n2. **SETUP**:\n   - After the **IDLE** phase, the controller transitions to the **SETUP** phase.\n   - In the **SETUP** phase the controller asserts `apb_psel_o`, and `apb_pwrite_o` and set up `apb_paddr_o` and `apb_pwdata_o` with the selected address and data.\n   - In this phase, `apb_penable_o` remains de-asserted.\n   - The **SETUP** phase lasts for one clock cycle.\n\n3. **ACCESS**:\n   - After the **SETUP** phase, the controller transitions to the **ACCESS** phase.\n   - In **ACCESS**, `apb_penable_o` is asserted high to signal that the data transfer is in progress.\n   - The controller remains in this phase, waiting for `apb_pready_i` from the peripheral to be asserted high.\n   - In **ACCESS** phase, the signals `apb_psel_o`, `apb_pwrite_o`, `apb_paddr_o`, and `apb_pwdata_o` must remain stable.\n   - **Write Transfer with Wait**: If `apb_pready_i` is delayed, the controller stays in **ACCESS** until `apb_pready_i` goes high.\n   - **Write Transfer without Wait**: If  `apb_pready_i` goes high in the same clock cycle that the controller enters the **ACCESS** phase, the controller completes the transaction within the same cycle.\n   - **Timeout Mechanism**:\n       - In the **ACCESS** phase, a 4-bit timeout counter increments each clock cycle if `apb_pready_i` remains low.\n       - If `apb_pready_i` is not asserted within 15 cycles after entering the **ACCESS** state, the timeout counter resets the controller to the **IDLE** state and sets all outputs to 0 at the next positive edge, effectively aborting the transaction and preventing indefinite stalling.\n       - The timeout counter resets to zero after a successful transaction or when the controller returns to the **IDLE** state.\n   - After a successful transaction (when `apb_pready_i` is asserted), the controller returns to the **IDLE** state, with both `apb_psel_o` and `apb_penable_o` getting deasserted.\n   - The design returns to the IDLE state after the APB transaction of a specific event gets completed (timeout or assertion of `apb_pready_i` to 1) to process the next event in the queue in case of multiple simultaneous events and the queue is not empty. If the queue is empty, a new transaction can only start when a select signal (`select_a_i`, `select_b_i`, or `select_c_i`) is asserted and both `apb_psel_o` and `apb_penable_o` are low, ensuring only one transaction occurs at a time. \n\n\n### Total Latency for the Transaction:\n\n- **Minimum Latency**: From the triggering of an event when the queue is empty, the latency from the event assertion to the `apb_psel_o` assertion is **3 clock cycles**. (1 cycle each for latching the event signal, updating the queue, and asserting `apb_psel_o` for the triggered event).\n- However, when the queue is not empty,  the latency for the `apb_psel_o` assertion for the next event to be processed is **1 clock cycle** after completing the first transaction (after de-assertion of all output signals from the previous transaction) because latching the event and updating the queue is already completed. \n- When an input is reasserted after the completion of its previous APB transaction, while the last event in the queue has just started, the latency for asserting `apb_psel_o` for the next event to be processed is 2. This is because the event signal is latched previously (at trigger) and only updating the queue and asserting `apb_psel_o` is required. \n- Signals `apb_pwrite_o`, `apb_paddr_o` and `apb_pwdata_o` are asserted in **SETUP** phase along with `apb_psel_o` and thus have similar latency as `apb_psel_o`.\n- Signal `apb_penable_o` takes one additional clock cycle than `apb_psel_o` as ` apb_penable_o` is asserted one clock cycle later (in the **ACCESS** state). \n- When the event queue is not empty, each STATE requires one cycle except if `apb_pready_i` is delayed, additional cycles are spent in the `ACCESS` state until the peripheral is ready or a timeout occurs\n- After an APB Transaction is completed, it takes 1 cycle to de-assert signals and to return to `IDLE`.\n\n### Constraints:\n- Assume that event signals `select_a_i`, `select_b_i`, and `select_c_i` are pulse signals high for one clock cycle and are synchronous to the clock. \n- Assume that input data and addresses will be stable inputs when the events are triggered.\n- If multiple events are triggered simultaneously, the highest-priority event will be processed first, followed by the other events based on their priority.\n- If any event (`select_a_i`, `select_b_i`, `select_c_i`) is asserted, the same input will not reassert until at least one clock cycle after its previous APB transaction is completed. Once the previous event from a specific input is completed, the next event from the same input can trigger at any time and will be added to the queue for execution after all previously queued events\n\n---\n\n### Testbench Requirements:\n\n1. #### Device Under Test (DUT)\n\n   - **Module Instance**: The  `apb_controller` module is already instantiated as `dut`, with all input and output signals connected for testing.\n\n2. #### Existing Input Generation\n\n   - **Clock and Reset**:\n      - Testbench generates a continuous `clk` signal.\n      - It drives an active-low asynchronous reset signal to initialize the `dut` in the **IDLE** state.\n\n   - **Event Triggering and Priority**:\n      - A pulse stimuli that is one clock cycle wide are generated for the event select inputs (`select_a_i`, `select_b_i`, and `select_c_i`).\n      - The testbench generates random stimuli for different scenarios, including simultaneous assertion of multiple event signals (for internal prioritization) and isolated single-event activations (for one event at a time).\n      - The stimuli for the 32-bit address and data signals for each event (`addr_a_i`, `data_a_i`, `addr_b_i`, `data_b_i`, `addr_c_i`, and `data_c_i`) with fixed or varying values are also taken into consideration for stimulus generation in the testbench.\n      - When the event queue is not empty, a different random event select input is triggered after the  APB transaction of the same event has been processed to check the priority pattern of the module, as mentioned in its specification. \n      - The stimuli of the `apb_pready_i` input are generated for two conditions:\n          - When `apb_pready_i` is asserted quickly (immediate response) to mimic minimum transaction latency.\n          - When `apb_pready_i` is delayed, causing the `dut` to remain longer in the **ACCESS** state and eventually leading to the timeout mechanism.\n\n3. #### Validation\n   - **Latency of output signals**: `apb_psel_o`, `apb_pwrite_o`, `apb_penable_o`, `apb_addr_o`, `apb_data_o`\n       - The latency of the signals - `apb_psel_o`, `apb_pwrite_o`, `apb_addr_o`, and `apb_data_o` must be validated against the expected latency which is equal to 3 clock cycles for the first event in the event queue (just after the events are triggered) and 1 clock cycle for the rest of the events in the queue. All of these output signals are changed at the same time except `apb_penable_o`, which is asserted one clock cycle after the assertion of `apb_psel_o`, `apb_pwrite_o`, `apb_addr_o`, and `apb_data_o`.\n       - The total latency from triggering of an event to the point when the `apb_ready_i` is asserted/ timeout occurs must be verified against the expected latency, which is equal to\n           - For first event: 3 ( `abp_psel_o` assertion) + 1 (`apb_penable_o` assertion) + total delay in asserting the `apb_ready_i`. \n           - For subsequent events in the queue: 1 ( `abp_psel_o` assertion) + 1 (`apb_penable_o` assertion) + total delay in asserting the `apb_ready_i`.\n           - The maximum latency is when the timeout occurs, which is equal to 4 + 15(timeout). \n       - The latency and priority for corner cases must be validated. (Eg: retriggering of an event when the last event in the queue has just started) to validate for the change in the latency from the normal scenario due to the previous latching of the retriggered event (2 clock cycles from the previous event completion to `abp_psel_o` assertion for the retriggered event). \n   - **Priority of the events**: It is required to check if the module `apb_controller` follows the priority as `A, B, C` when multiple simultaneous events are triggered. In the case when the retriggering of specific input takes place when its transaction has been completed and during the ongoing transaction for other events, the testbench must be able to check that the priority is still maintained and the retriggered input is processed after all the events present in the queue are processed. \n\n###  Simulation Control\n  - Execute the test cases using procedural blocks, monitoring the process with appropriate delays and synchronization methods.\n  - Use `$display` for logging results and `$error` for mismatches to facilitate debugging.\n\n### Test Procedure\n\n1. Initialization and Reset: Apply an initial reset to the DUT before starting the test sequence and also after some transactions have been processed\n2. Provide the given set of test cases as inputs to the design: Different sets of test cases include random addresses and data values and random simultaneous/single stimulation of events.\n3. Implement the reference priority detection of the events based on different input stimuli.\n4. Validate the latency calculated against the expected latency mentioned in the description of the module `apb_controller` for different input scenarios. \n\n## Deliverables\nProvide a **complete SystemVerilog testbench** that effectively used the stimulus given and verifies the `apb_controller` module's functionality to manage write transactions triggered by three independent events (A, B, and C). ", "context": {"verif/tb_apb_controller.sv": "module tb_apb_controller;\n  logic tb_clk, tb_reset_n;\n  logic tb_select_a_i, tb_select_b_i, tb_select_c_i;\n  logic [31:0] tb_addr_a_i, tb_addr_b_i, tb_addr_c_i;\n  logic [31:0] tb_data_a_i, tb_data_b_i, tb_data_c_i;\n  logic tb_apb_pready_i;\n  logic tb_apb_psel_o, tb_apb_penable_o, tb_apb_pwrite_o;\n  logic [31:0] tb_apb_paddr_o;\n  logic [31:0] tb_apb_pwdata_o;\n  int count;\n  int count_idle;\n  \n  apb_controller dut (\n    .clk           (tb_clk),\n    .reset_n       (tb_reset_n),\n    .select_a_i    (tb_select_a_i),\n    .select_b_i    (tb_select_b_i),\n    .select_c_i    (tb_select_c_i),\n    .addr_a_i      (tb_addr_a_i),\n    .data_a_i      (tb_data_a_i),\n    .addr_b_i      (tb_addr_b_i),\n    .data_b_i      (tb_data_b_i),\n    .addr_c_i      (tb_addr_c_i),\n    .data_c_i      (tb_data_c_i),\n    .apb_psel_o    (tb_apb_psel_o),\n    .apb_penable_o (tb_apb_penable_o),\n    .apb_paddr_o   (tb_apb_paddr_o),\n    .apb_pwrite_o  (tb_apb_pwrite_o),\n    .apb_pwdata_o  (tb_apb_pwdata_o),\n    .apb_pready_i  (tb_apb_pready_i)\n  );\n\n  initial begin\n    tb_clk = 1;\n    forever #5 tb_clk = ~tb_clk; \n  end\n\n  task init;\n    begin\n      tb_select_a_i   = 'h0;\n      tb_select_b_i   = 'h0;\n      tb_select_c_i   = 'h0;\n      tb_addr_a_i     = 'h0;\n      tb_data_a_i     = 'h0;\n      tb_addr_b_i     = 'h0;\n      tb_data_b_i     = 'h0;\n      tb_addr_c_i     = 'h0;\n      tb_data_c_i     = 'h0;\n      tb_apb_pready_i = 'h0;\n    end\n  endtask\n  \n  task reset_dut;\n    begin\n      tb_reset_n = 0;\n      @(posedge tb_clk);\n      tb_reset_n = 1;\n    end\n  endtask\n\n  task wait_apb;\n    begin\n      wait (tb_apb_psel_o == 1'b1 && tb_apb_pwrite_o == 1'b1);\n      @(posedge tb_clk);\n      wait (tb_apb_penable_o == 1'b1);    \n      count = $urandom_range(0, 16); \n      repeat (count) @(posedge tb_clk);  \n      tb_apb_pready_i <= 1'b1;    \n      @(posedge tb_clk);\n      tb_apb_pready_i <= 1'b0;       \n      @(posedge tb_clk);         \n    end\n  endtask\n\n\n  task multi_event_task(\n      input logic          event_a,\n      input logic          event_b,\n      input logic          event_c,\n      input logic  [31:0]  addr_a,\n      input logic  [31:0]  data_a,\n      input logic  [31:0]  addr_b,\n      input logic  [31:0]  data_b,\n      input logic  [31:0]  addr_c,\n      input logic  [31:0]  data_c,\n      input logic select_event\n  );\n    integer num_events;\n    integer j;\n    int rand_idx, rand_event;\n  \n    begin\n      num_events = (event_a ? 1 : 0) + (event_b ? 1 : 0) + (event_c ? 1 : 0);\n\n      // when a new event is triggered in middle when queue is not empty, num_events increases by 1\n      if (select_event) begin\n        rand_event = $urandom_range(0, num_events-1);\n        rand_idx = $urandom_range(0, 2);\n        // To avoid triggering the event at the same time when the event is to be processed\n        if (rand_idx < rand_event+1) begin\n          $display(\"Retriggering an event after it's previous transaction is complete, \\\n                  rand_event:%d, rand_id:%d , num_events:%d\", rand_event, rand_idx, num_events);\n          num_events += 1;\n        end else begin\n          select_event = 0;\n        end\n      end\n\n      if (num_events == 0) return;\n\n      @(posedge tb_clk);\n      tb_select_a_i <= event_a;\n      tb_select_b_i <= event_b;\n      tb_select_c_i <= event_c;\n      @(posedge tb_clk);\n      tb_select_a_i <= 1'b0;\n      tb_select_b_i <= 1'b0;\n      tb_select_c_i <= 1'b0;\n      tb_addr_a_i   <= event_a ? addr_a : 32'h0;\n      tb_data_a_i   <= event_a ? data_a : 32'h0;\n      tb_addr_b_i   <= event_b ? addr_b : 32'h0;\n      tb_data_b_i   <= event_b ? data_b : 32'h0;\n      tb_addr_c_i   <= event_c ? addr_c : 32'h0;\n      tb_data_c_i   <= event_c ? data_c : 32'h0;\n      for (integer j = 0; j < num_events; j++) begin\n        wait_apb(); \n        if (select_event && rand_event == j) begin\n          // Trigger after one clock cycle to obey input trigger constraint\n          @(posedge tb_clk);\n          fork \n            \n            begin\n            \n              case (rand_idx)\n                0: begin\n                  tb_select_a_i <= 1'b1; \n                  @(posedge tb_clk);\n                  tb_select_a_i <= 1'b0;       \n                end\n                1: begin\n                  tb_select_b_i <= 1'b1; \n                  @(posedge tb_clk);\n                  tb_select_b_i <= 1'b0;           \n                end\n                2: begin\n                  tb_select_c_i <= 1'b1;   \n                  @(posedge tb_clk);\n                  tb_select_c_i <= 1'b0;          \n                end\n              endcase\n            end\n\n          join_none\n        end\n      end       \n      repeat (10) @(posedge tb_clk);\n    end\n  endtask\n\n  task generate_inputs(input integer num_tests);\n    integer i;\n    logic [31:0] rand_addr_a, rand_data_a, rand_addr_b, rand_data_b, rand_addr_c, rand_data_c;\n    logic rand_sel_a, rand_sel_b, rand_sel_c;\n    begin\n      for (i = 0; i < num_tests; i = i + 1) begin\n        rand_sel_a  = $random % 2; \n        rand_sel_b  = $random % 2; \n        rand_sel_c  = $random % 2;        \n        rand_addr_a = $random;\n        rand_data_a = $random;\n        rand_addr_b = $random;\n        rand_data_b = $random;\n        rand_addr_c = $random;\n        rand_data_c = $random;\n        $display(\"Trigger A:%d, B:%d , C:%d\", rand_sel_a, rand_sel_b, rand_sel_c);\n        multi_event_task(rand_sel_a, rand_sel_b, rand_sel_c, rand_addr_a, rand_data_a, rand_addr_b, rand_data_b, rand_addr_c, rand_data_c, 0);\n      end\n    end\n  endtask  \n\n  task test_trigger_input_queue_not_empty();\n    logic [31:0] rand_addr_a, rand_data_a, rand_addr_b, rand_data_b, rand_addr_c, rand_data_c;\n    logic rand_sel_a, rand_sel_b, rand_sel_c;\n    begin\n      // Test for events to be triggered in middle when the queue is not empty\n      repeat(3) begin\n        rand_sel_a  = 1;\n        rand_sel_b  = 1;\n        rand_sel_c  = 1;        \n        rand_addr_a = $random;\n        rand_data_a = $random;\n        rand_addr_b = $random;\n        rand_data_b = $random;\n        rand_addr_c = $random;\n        rand_data_c = $random;\n        $display(\"Trigger A:%d, B:%d , C:%d\", rand_sel_a, rand_sel_b, rand_sel_c);\n        multi_event_task(rand_sel_a, rand_sel_b, rand_sel_c, rand_addr_a, rand_data_a, rand_addr_b, rand_data_b, rand_addr_c, rand_data_c, 1);\n      end\n    end\n  endtask \n\n  initial begin\n    init();\n    reset_dut();\n    @(posedge tb_clk);\n    generate_inputs(10); \n   \n    reset_dut();\n    @(posedge tb_clk);\n    test_trigger_input_queue_not_empty();\n\n    repeat(5) @(posedge tb_clk);\n    generate_inputs(5); \n    \n    $finish();\n  end\n\n  initial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0, tb_apb_controller);\n  end\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_apb_controller.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            =  23-tb-checker-apb-controller\nNUM_BUGS        = 3", "src/apb_controller.sv": "module apb_controller(\n    input  logic         clk,              // Clock signal\n    input  logic         reset_n,          // Active low asynchronous reset signal\n    input  logic         select_a_i,       // Select signal for event A\n    input  logic         select_b_i,       // Select signal for event B\n    input  logic         select_c_i,       // Select signal for event C\n    input  logic [31:0]  addr_a_i,         // 32-bit address for event A transaction\n    input  logic [31:0]  data_a_i,         // 32-bit data for event A transaction\n    input  logic [31:0]  addr_b_i,         // 32-bit address for event B transaction\n    input  logic [31:0]  data_b_i,         // 32-bit data for event B transaction\n    input  logic [31:0]  addr_c_i,         // 32-bit address for event C transaction\n    input  logic [31:0]  data_c_i,         // 32-bit data for event C transaction\n    output logic         apb_psel_o,       // APB select signal\n    output logic         apb_penable_o,    // APB enable signal\n    output logic [31:0]  apb_paddr_o,      // 32-bit APB address output\n    output logic         apb_pwrite_o,     // APB write signal\n    output logic [31:0]  apb_pwdata_o,     // 32-bit APB write data output\n    input  logic         apb_pready_i      // APB ready signal from the peripheral\n);\n\n    // State definitions\n    typedef enum logic [1:0] {\n       IDLE,   \n       SETUP,  \n       ACCESS\n    } state_t; \n\n    logic [3:0]  count;\n    logic [2:0]  event_sel; \n    logic [2:0]  event_sel_ff; \n    logic [2:0]  event_list;    \n    state_t      current_state, next_state;\n    logic [31:0] sel_addr_next, sel_data_next;  \n    logic [31:0] sel_addr, sel_data;          \n    logic select_a_pulse, select_b_pulse, select_c_pulse;\n\n    `ifndef BUG_0\n        assign apb_psel_o    = (current_state == SETUP || current_state == ACCESS) ? 1'b1 : 1'b0;\n    `else  \n        assign apb_psel_o    = (current_state == ACCESS) ? 1'b1 : 1'b0;\n    `endif \n\n    assign apb_penable_o = (current_state == ACCESS) ? 1'b1 : 1'b0;\n    assign apb_pwrite_o  = (current_state == SETUP || current_state == ACCESS) ? 1'b1 : 1'b0;\n    \n    assign apb_paddr_o   = (current_state == SETUP || current_state == ACCESS) ? sel_addr : 32'b0;\n    `ifndef BUG_1\n        assign apb_pwdata_o  = (current_state == SETUP || current_state == ACCESS) ? sel_data : 32'b0;\n    `else  \n    `endif \n    \n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            current_state <= IDLE;\n            event_list    <= 3'b000; \n            event_sel_ff    <= 3'b000; \n            select_a_pulse  <= 1'b0;  \n            select_b_pulse  <= 1'b0; \n            select_c_pulse  <= 1'b0;             \n        end else begin\n            select_a_pulse <= (select_a_i) ? 1'b1 : select_a_pulse;\n            select_b_pulse <= (select_b_i) ? 1'b1 : select_b_pulse;\n            select_c_pulse <= (select_c_i) ? 1'b1 : select_c_pulse;      \n            event_sel_ff   <= event_sel;              \n            current_state  <= next_state;\n            if (current_state == IDLE) begin\n               event_list <= (select_a_pulse ? 3'b001 : 3'b000) | \n                               (select_b_pulse ? 3'b010 : 3'b000) |\n                               (select_c_pulse ? 3'b100 : 3'b000); \n            end \n             `ifndef BUG_2\n                else if (next_state == IDLE) begin\n                    select_a_pulse <= (event_sel[0]) ? 1'b0 : select_a_pulse;\n                    select_b_pulse <= (event_sel[1]) ? 1'b0 : select_b_pulse;\n                    select_c_pulse <= (event_sel[2]) ? 1'b0 : select_c_pulse;    \n                    event_list   <= event_list & ~event_sel; \n                end    \n            `else  \n                else if (next_state == IDLE) begin   \n                    event_list   <= event_list & ~event_sel; \n                end\n            `endif          \n        end\n    end\n\n\n    always @(*) begin\n        // Default values\n        next_state = current_state;\n        event_sel  = event_sel_ff; \n        case (current_state)\n            IDLE: begin\n                if (event_list[0]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b001;\n                end else if (event_list[1]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b010;\n                end else if (event_list[2]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b100;\n                end else begin\n                   next_state = IDLE;\n                   event_sel  = 3'b000;\n                end\n            end\n            SETUP: begin\n                next_state = ACCESS;\n            end\n            ACCESS: begin\n                if (apb_pready_i || count == 15) begin\n                    next_state = IDLE;\n                end    \n            end\n            default: begin\n                next_state = IDLE; \n                event_sel  = 3'b000;                 \n            end    \n        endcase\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            count <= 0;\n        end else if (current_state == ACCESS && !apb_pready_i) begin\n            count <= count + 1;\n        end else begin\n            count <= 0;\n        end\n    end\n\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            sel_addr <= 32'b0;\n            sel_data <= 32'b0;\n        end else if (current_state == IDLE) begin\n            sel_addr <= sel_addr_next;\n            sel_data <= sel_data_next;\n        end\n    end\n    \n    always @(*) begin\n        if (!reset_n) begin\n           sel_addr_next = sel_addr;\n           sel_data_next = sel_data;       \n        end \n        else begin \n            if (next_state == SETUP || next_state == ACCESS) begin\n                case (event_sel)\n                    3'b001: begin    \n                       sel_addr_next = addr_a_i; \n                       sel_data_next = data_a_i;                     \n                    end    \n                    3'b010: begin                    \n                       sel_addr_next = addr_b_i; \n                       sel_data_next = data_b_i;    \n                    end\n                    3'b100: begin                      \n                       sel_addr_next = addr_c_i; \n                       sel_data_next = data_c_i; \n                    end\n                    default: begin\n                       sel_addr_next = 32'b0; \n                       sel_data_next = 32'b0;                     \n                    end \n                endcase           \n            end     \n        end        \n    end \n   \nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_events_to_apb_0026", "categories": ["cid014", "easy"], "input": {"prompt": "Add SystemVerilog Assertions (SVA) to validate the result for the apb_controller module. The testbench should check for the outputs for different operating conditions and sequences, including the handling of multiple simultaneous events (Event A, Event B, and Event C), the appropriate assertion of output signals at the correct time, and the built-in timeout mechanism.\n\n#### Inputs:\n- **`clk`**: System clock. The design is synchronized to the positive edge of this clock.\n- **`reset_n`**: Active-low asynchronous reset signal that resets the controller to the `IDLE` state, clears the timeout counter, and sets all registers and outputs to 0.\n- **`select_a_i`**: Active-high control signal to initiate a transaction for Event A.\n- **`select_b_i`**: Active-high control signal to initiate a transaction for Event B.\n- **`select_c_i`**: Active-high control signal to initiate a transaction for Event C.\n- **`addr_a_i [31:0]`**: Address input for Event A.\n- **`data_a_i [31:0]`**: Data input for Event A.\n- **`addr_b_i [31:0]`**: Address input for Event B.\n- **`data_b_i [31:0]`**: Data input for Event B.\n- **`addr_c_i [31:0]`**: Address input for Event C.\n- **`data_c_i [31:0]`**: Data input for Event C.\n- **`apb_pready_i`**:  Ready signal from the peripheral, active high. It indicates when the peripheral is ready to complete the transaction. The controller checks this signal in the `ACCESS` phase to determine transaction completion.\n\n#### Outputs:\n- **`apb_psel_o`**: An active-high signal, asserted during `SETUP`, to select the peripheral for an APB transaction.\n- **`apb_penable_o`**: An active-high signal, asserted during the `ACCESS` phase, indicating the transaction is in progress.\n- **`apb_pwrite_o`**: An active-high signal indicating a write operation, asserted during the `SETUP` and maintained in the `ACCESS` phase.\n- **`apb_paddr_o [31:0]`**: 32-bit address output for the transaction, determined by the selected event's address input (`addr_a_i`, `addr_b_i`, or `addr_c_i`). Defaults to 0 in the `IDLE` state.\n- **`apb_pwdata_o [31:0]`**: 32-bit data output for the write operation, based on the selected event's data input (`data_a_i`, `data_b_i`, or `data_c_i`). Defaults to 0 in the `IDLE` state.\n\n#### Assertion Generation: \n\n1. Setting of `apb_psel_o` and latency validation when the queue is empty: When the queue is empty (`event_list == 0`) and new events are triggered (`select_a_i` or  `select_b_i` or `select_c_i`),  the latency from the event assertion to the first `apb_psel_o` assertion is 3 clock cycles.\n\n2. Setting of `apb_psel_o` and latency validation when the queue is not empty: When the queue is not empty (`event_list != 0`) and the transaction from the previous event has just been completed ( `apb_penable_o` is de-asserted), the latency from the end of the previous event to the `apb_psel_o` assertion for the next event in the queue is 1 clock cycles.    \n\n4. Setting of `apb_psel_o` and latency validation when the queue is empty and another one of the events has already been latched: When the queue is empty (`event_list` is equal to 0 ), and the transaction from the previous event has just been completed (`apb_penable_o` is de-asserted),  but another of the events has already been latched (`select_a_pulse` or  `select_b_pulse` or `select_c_pulse`),  the latency from the end of the previous event to the `apb_psel_o` assertion is 2 clock cycles.   \n \n5. Setting of `apb_penable_o`: When `apb_psel_o` is set, the `apb_penable_o` is asserted 1 clock cycle after the `apb_psel_o`.\n\n6. The setting of `apb_pwrite_o`: When `apb_psel_o` is set, the `apb_pwrite_o` is also asserted in the same cycle. \n\n7. Maximum timeout for `apb_pready_i`: When `apb_penable_o` is asserted for an event, `apb_pready_i` must be asserted within 15 clock cycles to complete the transaction. If `apb_pready_i` remains low for 15 cycles, both `apb_psel_o` and `apb_penable_o` must be de-asserted before for next event to begin.\n\n8. Checking of the priority of events which follows A > B > C based on if the event is selected: If all three events (`select_a_i`, `select_b_i`, `select_c_i`) are selected and the queue is empty (`event_list == 0`), `apb_paddr_o` must be set to `addr_a_i` after 3 clock cycles, ensuring event A has the highest priority. If only events B and C are selected and the queue is empty, `apb_paddr_o` must be set to `addr_b_i` after 3 clock cycles, confirming event B takes priority over event C.", "context": {"rtl/apb_controller.sv": "module apb_controller(\n    input  logic         clk,              // Clock signal\n    input  logic         reset_n,          // Active low asynchronous reset signal\n    input  logic         select_a_i,       // Select signal for event A\n    input  logic         select_b_i,       // Select signal for event B\n    input  logic         select_c_i,       // Select signal for event C\n    input  logic [31:0]  addr_a_i,         // 32-bit address for event A transaction\n    input  logic [31:0]  data_a_i,         // 32-bit data for event A transaction\n    input  logic [31:0]  addr_b_i,         // 32-bit address for event B transaction\n    input  logic [31:0]  data_b_i,         // 32-bit data for event B transaction\n    input  logic [31:0]  addr_c_i,         // 32-bit address for event C transaction\n    input  logic [31:0]  data_c_i,         // 32-bit data for event C transaction\n    output logic         apb_psel_o,       // APB select signal\n    output logic         apb_penable_o,    // APB enable signal\n    output logic [31:0]  apb_paddr_o,      // 32-bit APB address output\n    output logic         apb_pwrite_o,     // APB write signal\n    output logic [31:0]  apb_pwdata_o,     // 32-bit APB write data output\n    input  logic         apb_pready_i      // APB ready signal from the peripheral\n);\n\n    // State definitions\n    typedef enum logic [1:0] {\n       IDLE,   \n       SETUP,  \n       ACCESS\n    } state_t; \n\n    logic [3:0]  count;\n    logic [2:0]  event_sel; \n    logic [2:0]  event_sel_ff; \n    logic [2:0]  event_list;    \n    state_t      current_state, next_state;\n    logic [31:0] sel_addr_next, sel_data_next;  \n    logic [31:0] sel_addr, sel_data;          \n    logic select_a_pulse, select_b_pulse, select_c_pulse;\n\n    assign apb_psel_o    = (current_state == SETUP || current_state == ACCESS) ? 1'b1 : 1'b0;\n    assign apb_penable_o = (current_state == ACCESS) ? 1'b1 : 1'b0;\n    assign apb_pwrite_o  = (current_state == SETUP || current_state == ACCESS) ? 1'b1 : 1'b0;\n    assign apb_paddr_o   = (current_state == SETUP || current_state == ACCESS) ? sel_addr : 32'b0;\n    assign apb_pwdata_o  = (current_state == SETUP || current_state == ACCESS) ? sel_data : 32'b0;\n\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            current_state <= IDLE;\n            event_list    <= 3'b000; \n            event_sel_ff    <= 3'b000; \n            select_a_pulse  <= 1'b0;  \n            select_b_pulse  <= 1'b0; \n            select_c_pulse  <= 1'b0;             \n        end else begin\n            select_a_pulse <= (select_a_i) ? 1'b1 : select_a_pulse;\n            select_b_pulse <= (select_b_i) ? 1'b1 : select_b_pulse;\n            select_c_pulse <= (select_c_i) ? 1'b1 : select_c_pulse;      \n            event_sel_ff   <= event_sel;              \n            current_state  <= next_state;\n            if (current_state == IDLE) begin\n               event_list <= (select_a_pulse ? 3'b001 : 3'b000) | \n                               (select_b_pulse ? 3'b010 : 3'b000) |\n                               (select_c_pulse ? 3'b100 : 3'b000); \n            end \n            else if (next_state == IDLE) begin\n               select_a_pulse <= (event_sel[0]) ? 1'b0 : select_a_pulse;\n               select_b_pulse <= (event_sel[1]) ? 1'b0 : select_b_pulse;\n               select_c_pulse <= (event_sel[2]) ? 1'b0 : select_c_pulse;    \n               event_list   <= event_list & ~event_sel; \n            end            \n        end\n    end\n\n\n    always @(*) begin\n        // Default values\n        next_state = current_state;\n        event_sel  = event_sel_ff; \n        case (current_state)\n            IDLE: begin\n                if (event_list[0]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b001;\n                end else if (event_list[1]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b010;\n                end else if (event_list[2]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b100;\n                end else begin\n                   next_state = IDLE;\n                   event_sel  = 3'b000;\n                end\n            end\n            SETUP: begin\n                next_state = ACCESS;\n            end\n            ACCESS: begin\n                if (apb_pready_i || count == 15) begin\n                    next_state = IDLE;\n                end    \n            end\n            default: begin\n                next_state = IDLE; \n                event_sel  = 3'b000;                 \n            end    \n        endcase\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            count <= 0;\n        end else if (current_state == ACCESS && !apb_pready_i) begin\n            count <= count + 1;\n        end else begin\n            count <= 0;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            sel_addr <= 32'b0;\n            sel_data <= 32'b0;\n        end else if (current_state == IDLE) begin\n            sel_addr <= sel_addr_next;\n            sel_data <= sel_data_next;\n        end\n    end\n    \n    always @(*) begin\n        if (!reset_n) begin\n           sel_addr_next = sel_addr;\n           sel_data_next = sel_data;       \n        end \n        else begin \n            if (next_state == SETUP || next_state == ACCESS) begin\n                case (event_sel)\n                    3'b001: begin    \n                       sel_addr_next = addr_a_i; \n                       sel_data_next = data_a_i;                     \n                    end    \n                    3'b010: begin                    \n                       sel_addr_next = addr_b_i; \n                       sel_data_next = data_b_i;    \n                    end\n                    3'b100: begin                      \n                       sel_addr_next = addr_c_i; \n                       sel_data_next = data_c_i; \n                    end\n                    default: begin\n                       sel_addr_next = 32'b0; \n                       sel_data_next = 32'b0;                     \n                    end \n                endcase           \n            end     \n        end        \n    end    \n\nendmodule"}}, "output": {"response": "", "context": {"rtl/apb_controller.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/apb_controller.sv\nTOPLEVEL        = apb_controller\nMODULE          = test_apb_controller\nPYTHONPATH      = /src\nHASH            = 26-assertion-events-to-ap", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build -vcd dumpon\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n\ndef generate_random_event(base_addr):\n    addr = random.randint(base_addr, base_addr + 0x0FFF_FFFF)\n    data = random.randint(0x0000_0000, 0xFFFF_FFFF)\n    return addr, data\n\nasync def async_reset_dut(dut):\n    dut.reset_n.value = 1\n    await FallingEdge(dut.clk)\n    dut.reset_n.value = 0\n    await Timer(2, units=\"ns\")  # Small delay\n    assert dut.apb_psel_o.value == 0, \"APB select should be 0 at reset\"\n    assert dut.apb_penable_o.value == 0, \"APB enable should be 0 at reset\"\n    assert dut.apb_pwrite_o.value == 0, \"APB write signal should be 0 at reset\"\n    assert dut.apb_paddr_o.value == 0, \"APB address should be 0 at reset\"\n    assert dut.apb_pwdata_o.value == 0, \"APB data should be 0 at reset\"\n    await RisingEdge(dut.clk)\n    dut.reset_n.value = 1\n    await RisingEdge(dut.clk)\n\nasync def run_apb_test_with_delay(dut, select_signal, expected_addr, expected_data):\n    select_signal.value = 1\n    dut.apb_pready_i.value = 0\n\n    await RisingEdge(dut.clk)\n    select_signal.value = 0\n\n    latency_sel = 0\n    while dut.apb_psel_o.value == 0:\n        await RisingEdge(dut.clk)\n        latency_sel += 1\n\n    assert latency_sel == 3, f\"Latency from `apb_psel_o` should be 3 cycles, got {latency_sel}\"\n    assert dut.apb_psel_o.value == 1, \"APB select signal should be high in SETUP state\"\n    assert dut.apb_paddr_o.value == expected_addr, f\"APB address mismatch: {hex(expected_addr)}\"\n    assert dut.apb_pwdata_o.value == expected_data, f\"APB data mismatch: {hex(expected_data)}\"\n\n    latency_enable = 0\n    while dut.apb_penable_o.value == 0:\n        await RisingEdge(dut.clk)\n        latency_enable += 1\n\n    assert latency_enable == 1, f\"Latency from `apb_psel_o` to `apb_penable_o` is wrong, got {latency_enable}\"\n    assert dut.apb_penable_o.value == 1, \"APB enable signal should be asserted in ACCESS state\"\n    assert dut.apb_pwrite_o.value == 1, \"APB write signal should be high in SETUP state\"\n\n    await Timer(3, units=\"ns\")\n    dut.apb_pready_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.apb_pready_i.value = 0\n\n    latency_rdy = 0\n    while dut.apb_penable_o.value == 1:\n        await RisingEdge(dut.clk)\n        latency_rdy += 1\n\n    assert latency_rdy == 1, f\"Latency from `apb_penable_o` deassertion is wrong, got {latency_rdy}\"\n    assert dut.apb_psel_o.value == 0, \"APB select signal should be deasserted after ACCESS\"\n    assert dut.apb_penable_o.value == 0, \"APB enable signal should be deasserted after ACCESS state\"    \n    assert dut.apb_pwrite_o.value == 0, \"APB write signal should be deasserted after ACCESS state\"  \n    assert dut.apb_paddr_o.value == 0, \"APB address should be deasserted after ACCESS state\"\n    assert dut.apb_pwdata_o.value == 0, \"APB data should be deasserted after ACCESS state\"        \n\nasync def run_apb_test_without_delay(dut, select_signal, expected_addr, expected_data):\n    select_signal.value = 1\n    dut.apb_pready_i.value = 0\n\n    await RisingEdge(dut.clk)\n    select_signal.value = 0\n\n    latency_sel = 0  \n    while dut.apb_psel_o.value == 0:\n        await RisingEdge(dut.clk)\n        latency_sel += 1\n\n    dut.apb_pready_i.value = 1  \n    assert latency_sel == 3, f\"Latency from `apb_psel_o` should be 3 cycles, got {latency_sel}\"\n    assert dut.apb_psel_o.value == 1, \"APB select signal should be high in SETUP state\"\n    assert dut.apb_paddr_o.value == expected_addr, f\"APB address mismatch: {hex(expected_addr)}\"\n    assert dut.apb_pwdata_o.value == expected_data, f\"APB data mismatch: {hex(expected_data)}\"\n\n    await RisingEdge(dut.clk)\n    assert dut.apb_penable_o.value == 1, \"APB enable signal should be asserted in ACCESS state\"\n    assert dut.apb_pwrite_o.value == 1, \"APB write signal should be high in SETUP state\"\n    dut.apb_pready_i.value = 0  \n    \n    latency_rdy = 0\n    while dut.apb_penable_o.value == 1:\n        await RisingEdge(dut.clk)\n        latency_rdy += 1\n\n    assert latency_rdy == 1, f\"Latency from `apb_penable_o` deassertion is wrong, got {latency_rdy}\"\n    assert dut.apb_psel_o.value == 0, \"APB select signal should be deasserted after ACCESS\"\n    assert dut.apb_penable_o.value == 0, \"APB enable signal should be deasserted after ACCESS state\"    \n    assert dut.apb_pwrite_o.value == 0, \"APB write signal should be deasserted after ACCESS state\" \n    assert dut.apb_paddr_o.value == 0, \"APB address should be deasserted after ACCESS state\"\n    assert dut.apb_pwdata_o.value == 0, \"APB data should be deasserted after ACCESS state\"       \n\nasync def test_timeout(dut, select_signal, expected_addr, expected_data):\n    select_signal.value = 1\n    dut.apb_pready_i.value = 0\n\n    await RisingEdge(dut.clk)\n    select_signal.value = 0\n    for _ in range(5): \n        await RisingEdge(dut.clk)\n\n    timeout_cycles = 15\n    for _ in range(timeout_cycles):\n        await RisingEdge(dut.clk)\n\n    assert dut.apb_psel_o.value == 0, \"APB select should be deasserted after timeout\"\n    assert dut.apb_penable_o.value == 0, \"APB enable should be deasserted after timeout\"  \n    assert dut.apb_pwrite_o.value == 0, \"APB write signal should be deasserted after timeout\" \n    assert dut.apb_paddr_o.value == 0, \"APB address should be deasserted after timeout\"\n    assert dut.apb_pwdata_o.value == 0, \"APB data should be deasserted after timeout\"          \n\nasync def check_apb_output_order_first_in_queue(dut, events):\n    for event in events:\n        select_signal = event['select']\n        addr = event['addr']\n        data = event['data']\n        \n        for _ in range(3):\n            await RisingEdge(dut.clk) \n        assert dut.apb_psel_o.value == 1, \"APB select signal should be high\"\n\n        await RisingEdge(dut.clk)\n        assert dut.apb_penable_o.value == 1, \"APB enable should be high during transaction\"\n        assert int(dut.apb_paddr_o.value) == addr, f\"APB address should match {hex(addr)}. Found: {hex(int(dut.apb_paddr_o.value))}\"\n        assert int(dut.apb_pwdata_o.value) == data, f\"APB data should match {hex(data)}. Found: {hex(int(dut.apb_pwdata_o.value))}\"\n\n        for _ in range(3,8):\n            await RisingEdge(dut.clk)\n        dut.apb_pready_i.value = 1\n        await RisingEdge(dut.clk)\n        dut.apb_pready_i.value = 0\n        \n        await RisingEdge(dut.clk)\n        assert dut.apb_psel_o.value == 0, \"APB select should be deasserted after transaction\"\n        assert dut.apb_penable_o.value == 0, \"APB enable should be deasserted after transaction\"\n        assert dut.apb_paddr_o.value == 0, \"APB address should be deasserted after transaction\"\n        assert dut.apb_pwdata_o.value == 0, \"APB data should be deasserted after transaction\"\n\n\nasync def check_apb_output_order_subsequent_1(dut, events):\n    for event in events:\n        select_signal = event['select']\n        addr = event['addr']\n        data = event['data']\n        \n        \n        assert dut.apb_psel_o.value == 1, \"APB select signal should be high\"\n\n        await RisingEdge(dut.clk)\n        assert dut.apb_penable_o.value == 1, \"APB enable should be high during transaction\"\n        assert int(dut.apb_paddr_o.value) == addr, f\"APB address should match {hex(addr)}. Found: {hex(int(dut.apb_paddr_o.value))}\"\n        assert int(dut.apb_pwdata_o.value) == data, f\"APB data should match {hex(data)}. Found: {hex(int(dut.apb_pwdata_o.value))}\"\n\n        for _ in range(3,8):\n            await RisingEdge(dut.clk)\n        dut.apb_pready_i.value = 1\n        await RisingEdge(dut.clk)\n        dut.apb_pready_i.value = 0\n        \n        await RisingEdge(dut.clk)\n        assert dut.apb_psel_o.value == 0, \"APB select should be deasserted after transaction\"\n        assert dut.apb_penable_o.value == 0, \"APB enable should be deasserted after transaction\"\n        assert dut.apb_paddr_o.value == 0, \"APB address should be deasserted after transaction\"\n        assert dut.apb_pwdata_o.value == 0, \"APB data should be deasserted after transaction\"\n\n\nasync def check_apb_output_order_subsequent_2(dut, events):\n    for event in events:\n        select_signal = event['select']\n        addr = event['addr']\n        data = event['data']\n        \n        await RisingEdge(dut.clk)\n        assert dut.apb_psel_o.value == 1, \"APB select signal should be high\"\n\n        await RisingEdge(dut.clk)\n        assert dut.apb_penable_o.value == 1, \"APB enable should be high during transaction\"\n        assert int(dut.apb_paddr_o.value) == addr, f\"APB address should match {hex(addr)}. Found: {hex(int(dut.apb_paddr_o.value))}\"\n        assert int(dut.apb_pwdata_o.value) == data, f\"APB data should match {hex(data)}. Found: {hex(int(dut.apb_pwdata_o.value))}\"\n\n        for _ in range(3,8):\n            await RisingEdge(dut.clk)\n        dut.apb_pready_i.value = 1\n        await RisingEdge(dut.clk)\n        dut.apb_pready_i.value = 0\n        \n        await RisingEdge(dut.clk)\n        assert dut.apb_psel_o.value == 0, \"APB select should be deasserted after transaction\"\n        assert dut.apb_penable_o.value == 0, \"APB enable should be deasserted after transaction\"\n        assert dut.apb_paddr_o.value == 0, \"APB address should be deasserted after transaction\"\n        assert dut.apb_pwdata_o.value == 0, \"APB data should be deasserted after transaction\"\n\n", "src/test_apb_controller.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\nimport harness_library as hrs_lb\nfrom collections import deque\n\n@cocotb.test()\nasync def test_apb_controller_with_delay(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.async_reset_dut(dut)\n\n    dut.select_a_i.value = 0\n    dut.select_b_i.value = 0\n    dut.select_c_i.value = 0\n\n    for _ in range(5):\n        addr = random.randint(0x10000000, 0x1FFFFFFF)\n        data = random.randint(0x00000000, 0xFFFFFFFF)\n        dut.addr_a_i.value = addr\n        dut.data_a_i.value = data\n        await hrs_lb.run_apb_test_with_delay(dut, dut.select_a_i, addr, data)\n\n@cocotb.test()\nasync def test_apb_controller_without_delay(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.async_reset_dut(dut)\n\n    dut.select_a_i.value = 0\n    dut.select_b_i.value = 0\n    dut.select_c_i.value = 0\n\n    for _ in range(5):\n        addr = random.randint(0x10000000, 0x1FFFFFFF)\n        data = random.randint(0x00000000, 0xFFFFFFFF)\n        dut.addr_b_i.value = addr\n        dut.data_b_i.value = data\n        await hrs_lb.run_apb_test_without_delay(dut, dut.select_b_i, addr, data)\n\n@cocotb.test()\nasync def test_apb_controller_with_timeout(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.async_reset_dut(dut)\n\n    dut.select_a_i.value = 0\n    dut.select_b_i.value = 0\n    dut.select_c_i.value = 0\n\n    addr = random.randint(0x10000000, 0x1FFFFFFF)\n    data = random.randint(0x00000000, 0xFFFFFFFF)\n    dut.addr_c_i.value = addr\n    dut.data_c_i.value = data\n    await hrs_lb.test_timeout(dut, dut.select_c_i, addr, data)\n\n\n@cocotb.test()\nasync def test_apb_controller_varied_events(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.async_reset_dut(dut)\n\n    # Scenario 1: All three select signals asserted simultaneously\n    addr_a, data_a = hrs_lb.generate_random_event(0x1000_0000)\n    addr_b, data_b = hrs_lb.generate_random_event(0x2000_0000)\n    addr_c, data_c = hrs_lb.generate_random_event(0x3000_0000)\n\n    dut.addr_a_i.value = addr_a\n    dut.data_a_i.value = data_a\n    dut.addr_b_i.value = addr_b\n    dut.data_b_i.value = data_b\n    dut.addr_c_i.value = addr_c\n    dut.data_c_i.value = data_c\n\n    dut.select_a_i.value = 1\n    dut.select_b_i.value = 1\n    dut.select_c_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_a_i.value = 0\n    dut.select_b_i.value = 0\n    dut.select_c_i.value = 0\n\n    await hrs_lb.check_apb_output_order_first_in_queue(dut, [\n        {'select': dut.select_a_i, 'addr': addr_a, 'data': data_a}      \n    ])\n\n    await hrs_lb.check_apb_output_order_subsequent_2(dut, [\n        {'select': dut.select_b_i,'addr': addr_b, 'data': data_b}, \n        {'select': dut.select_c_i,'addr': addr_c, 'data': data_c}   \n    ])\n\n    # Scenario 2: Two select signals (A and B)\n    addr_a, data_a = hrs_lb.generate_random_event(0x1000_0000)\n    addr_b, data_b = hrs_lb.generate_random_event(0x2000_0000)\n\n    dut.addr_a_i.value = addr_a\n    dut.data_a_i.value = data_a\n    dut.addr_b_i.value = addr_b\n    dut.data_b_i.value = data_b\n\n    dut.select_a_i.value = 1\n    dut.select_b_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_a_i.value = 0\n    dut.select_b_i.value = 0\n\n    await hrs_lb.check_apb_output_order_first_in_queue(dut, [\n        {'select': dut.select_a_i, 'addr': addr_a, 'data': data_a}      \n    ])\n\n    await hrs_lb.check_apb_output_order_subsequent_2(dut, [\n        {'select': dut.select_b_i,'addr': addr_b, 'data': data_b}  \n    ])\n\n    # Scenario 3: Two select signals (B and C)\n    addr_b, data_b = hrs_lb.generate_random_event(0x2000_0000)\n    addr_c, data_c = hrs_lb.generate_random_event(0x3000_0000)\n\n    dut.addr_b_i.value = addr_b\n    dut.data_b_i.value = data_b\n    dut.addr_c_i.value = addr_c\n    dut.data_c_i.value = data_c\n\n    dut.select_b_i.value = 1\n    dut.select_c_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_b_i.value = 0\n    dut.select_c_i.value = 0\n\n    await hrs_lb.check_apb_output_order_first_in_queue(dut, [\n        {'select': dut.select_b_i, 'addr': addr_b, 'data': data_b}      \n    ])\n\n    await hrs_lb.check_apb_output_order_subsequent_2(dut, [\n        {'select': dut.select_c_i,'addr': addr_c, 'data': data_c}  \n    ])\n \n\n    # Scenario 4: Overlapping Event Reassertion\n    addr_a, data_a = hrs_lb.generate_random_event(0x1000_0000)\n    addr_b, data_b = hrs_lb.generate_random_event(0x2000_0000)\n    addr_c, data_c = hrs_lb.generate_random_event(0x3000_0000)\n\n    dut.addr_a_i.value = addr_a\n    dut.data_a_i.value = data_a\n    dut.addr_b_i.value = addr_b\n    dut.data_b_i.value = data_b\n    dut.addr_c_i.value = addr_c\n    dut.data_c_i.value = data_c\n\n    dut.select_a_i.value = 1\n    dut.select_b_i.value = 1\n    dut.select_c_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_a_i.value = 0\n    dut.select_b_i.value = 0\n    dut.select_c_i.value = 0\n\n    await hrs_lb.check_apb_output_order_first_in_queue(dut, [\n        {'select': dut.select_a_i, 'addr': addr_a, 'data': data_a}      \n    ])\n\n    dut.select_a_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_a_i.value = 0\n\n    await hrs_lb.check_apb_output_order_subsequent_1(dut, [\n        {'select': dut.select_b_i,'addr': addr_b, 'data': data_b}\n    ])\n\n    dut.select_b_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_b_i.value = 0    \n\n    await hrs_lb.check_apb_output_order_subsequent_1(dut, [\n        {'select': dut.select_c_i,'addr': addr_c, 'data': data_c}   \n    ])\n\n    dut.select_c_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_c_i.value = 0    \n\n    await hrs_lb.check_apb_output_order_subsequent_1(dut, [\n        {'select': dut.select_a_i,'addr': addr_a, 'data': data_a} \n    ])\n\n    await hrs_lb.check_apb_output_order_subsequent_2(dut, [\n        {'select': dut.select_b_i,'addr': addr_b, 'data': data_b}, \n        {'select': dut.select_c_i,'addr': addr_c, 'data': data_c}   \n    ])\n  \n     # Scenario 5: Overlapping Event Reassertion with an select signal already latched\n    addr_a, data_a = hrs_lb.generate_random_event(0x1000_0000)\n    addr_b, data_b = hrs_lb.generate_random_event(0x2000_0000)\n    addr_c, data_c = hrs_lb.generate_random_event(0x3000_0000)\n\n    dut.addr_a_i.value = addr_a\n    dut.data_a_i.value = data_a\n    dut.addr_b_i.value = addr_b\n    dut.data_b_i.value = data_b\n    dut.addr_c_i.value = addr_c\n    dut.data_c_i.value = data_c\n\n    dut.select_a_i.value = 1\n    dut.select_b_i.value = 1\n    dut.select_c_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_a_i.value = 0\n    dut.select_b_i.value = 0\n    dut.select_c_i.value = 0\n\n    await hrs_lb.check_apb_output_order_first_in_queue(dut, [\n        {'select': dut.select_a_i, 'addr': addr_a, 'data': data_a}      \n    ])\n\n    await RisingEdge(dut.clk)\n\n    await hrs_lb.check_apb_output_order_subsequent_1(dut, [\n        {'select': dut.select_b_i,'addr': addr_b, 'data': data_b}\n    ])\n\n    dut.select_b_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_b_i.value = 0     \n\n    await hrs_lb.check_apb_output_order_subsequent_1(dut, [\n        {'select': dut.select_c_i,'addr': addr_c, 'data': data_c} \n    ])\n\n    dut.select_a_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_a_i.value = 0  \n\n    await RisingEdge(dut.clk)\n\n    await hrs_lb.check_apb_output_order_subsequent_1(dut, [\n        {'select': dut.select_b_i,'addr': addr_b, 'data': data_b}\n    ])\n  ", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner():\n   \n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n        hrs_lb.xrun_tb()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n\ndef test_apb():\n    # Run the simulation\n    call_runner()   "}}}
{"id": "cvdp_copilot_filo_0036", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertion in the RTL design of the `FILO_RTL` module to ensure its correct functionality during simulation? The assertion should cover key aspects of the `FILO` (First-In-Last-Out) stack operation, ensuring that the stack pointer remains within bounds, push and pop operations occur under valid conditions, and the full/empty flags are correctly asserted.\n\n___\n### Key Assertion\n**1. Stack Pointer Validity**\n  - Condition:\n    - The top pointer must always remain within the valid range  `FILO_DEPTH`.\n    - If top exceeds `FILO_DEPTH` or becomes negative, an assertion should trigger an error message.\n\n  - Assertion Implementation:\n    - Check top value during every clock cycle.\n\n  - Error Message:\n    - Display current top pointer value and simulation time when the assertion fails.\n\n##\n### Implementation Requirements\n\n**1. Placement**\n  - Assertions must be placed inside the RTL module (`FILO_RTL`) to ensure violations are detected in real-time during simulation.\n\n**2. Immediate Assertions**\n  - Use `assert()` inside `always` blocks to check for invalid conditions at every clock cycle.\n\n**3. Failure Handling**\n  - If an assertion fails, the simulation should:\n    - Display debug information using `$display()`, including `$time`.\n    - Provide a clear error message to help identify the issue.\n___\n### Interface\n\n**Parameters**\n  - `DATA_WIDTH`: Defines the width of the data stored in the FILO stack (`Default: 8`).\n  - `FILO_DEPTH`: Defines the depth of the FILO stack, determining how many elements it can hold (`Default: 16`).\n\n**Inputs:**\n  - `clk(1-bit)`: This signal drives the FILO operation. All operations (push, pop) happen on the rising edge of the clock.\n  - `reset(1-bit)`: Resets the FILO stack, clearing all stored data and setting the top pointer to 0. \n  - `push(1-bit)`: When high (1), a new data value (`data_in`) is pushed onto the FILO stack.\n  - `pop(1-bit)`: When high (1), the last stored value is popped from the FILO stack.\n  - `data_in [DATA_WIDTH-1:0]`: Data to be pushed into the FILO stack.\n\n**Outputs:**\n  - `data_out [DATA_WIDTH-1:0]`: Data popped from the FILO stack.\n  - `full(1-bit)`: Indicates if the FILO is full.\n  - `empty(1-bit)`: Indicates if the FILO is empty.", "context": {"rtl/FILO_RTL.sv": "module FILO_RTL #(\n    parameter DATA_WIDTH = 8,\n    parameter FILO_DEPTH = 16\n) (\n    input logic clk,\n    input logic reset,\n    input logic push,\n    input logic pop,\n    input logic [DATA_WIDTH-1:0] data_in,\n    output logic [DATA_WIDTH-1:0] data_out,\n    output logic full,\n    output logic empty\n);\n\n  // Internal signals\n  logic [DATA_WIDTH-1:0] stack_mem[0:FILO_DEPTH-1];\n  logic [$clog2(FILO_DEPTH)-1:0] top;\n  logic [DATA_WIDTH-1:0] data_reg;\n\n  // Stack memory and status management\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      top   <= 0;\n      full  <= 0;\n      empty <= 1;\n    end else begin\n      if (push && !full) begin\n        stack_mem[top] <= data_in;\n        top <= top + 1;\n        empty <= 0;  \n\n        // Correct full flag update\n        if (top + 1 == FILO_DEPTH) begin\n          full <= 1;\n        end else begin\n          full <= 0;\n        end\n\n      end else if (pop && !empty) begin\n        top <= top - 1;\n        data_reg <= stack_mem[top-1];\n        full <= 0;  \n\n        if (top - 1 == 0) begin\n          empty <= 1;\n        end else begin\n          empty <= 0;\n        end\n      end\n    end\n  end\n\n  // Output assignments\n  assign data_out = data_reg;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/FILO_RTL.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/FILO_RTL.sv\nTOPLEVEL        = FILO_RTL\nMODULE          = test_filo\nPYTHONPATH      = /src\nHASH            = 36-assertion-generation-for-first-in-last-outfilo\n", "src/test_filo.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n\n@cocotb.test()\nasync def test_filo_rtl(dut):\n    \"\"\" Test FILO RTL behavior \"\"\"\n\n    # Initialize clock\n    clock = Clock(dut.clk, 10, units=\"ns\")  # Create a 10ns period clock\n    cocotb.start_soon(clock.start())        # Start the clock\n\n    # Reset the design\n    await reset_filo(dut)\n\n    # Push values into the FILO\n    data_to_push = [random.randint(0, 99) for _ in range(16)]\n    await push_values(dut, data_to_push)\n\n    # Pop values from the FILO and check the order\n    await pop_values(dut, data_to_push)\n\n\nasync def reset_filo(dut):\n    \"\"\" Reset the FILO module \"\"\"\n    dut.reset.value = 1\n    await Timer(20, units=\"ns\")  # Wait for a few clock cycles\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)    # Sync to clock edge\n\n    assert dut.empty.value == 1, \"FILO should be empty after reset\"\n    assert dut.full.value == 0, \"FILO should not be full after reset\"\n\n\nasync def push_values(dut, values):\n    \"\"\" Push values into the FILO \"\"\"\n    push_count = 0  # Initialize push count\n    \n    # Use enumerate to get both index (i) and value\n    for i, value in enumerate(values):\n        dut.push.value = 1\n        dut.pop.value = 0\n        dut.data_in.value = value\n        await RisingEdge(dut.clk)\n        dut.push.value = 0\n        await RisingEdge(dut.clk)\n        \n        push_count += 1  # Increment push count\n\n        # Debugging info, include push count\n        dut._log.info(f\"Push #{push_count}: pushed_value={value}, top={dut.top.value}, full={dut.full.value}, empty={dut.empty.value}\")\n\n        # Check if full when pushing the last element\n        if i == len(values) - 1:\n            assert dut.full.value == 1, \"FILO should be full after pushing maximum elements\"\n        else:\n            assert dut.full.value == 0, \"FILO should not be full before maximum elements are pushed\"\n        assert dut.empty.value == 0, \"FILO should not be empty after pushing\"\n\n\nasync def pop_values(dut, expected_values):\n    \"\"\" Pop values from the FILO and verify the popped data \"\"\"\n    \n    data_out_value = 0\n    pop_count = 0  # Initialize pop count\n    \n    # Ensure that you pop all the values in reverse order (since FILO is LIFO)\n    for i in range(len(expected_values)):\n        expected_value = expected_values[-(i + 1)]  # Get values in reverse order\n\n        # Assert the pop signal\n        dut.pop.value = 1\n        dut.push.value = 0\n        data_out_value = expected_value\n        await RisingEdge(dut.clk)\n        \n        # Deassert the pop signal after one clock cycle\n        dut.pop.value = 0\n        await RisingEdge(dut.clk)\n        \n        pop_count += 1  # Increment pop count\n\n        # Wait for one clock cycle to allow data_out to stabilize\n        await RisingEdge(dut.clk)\n        \n        # Log the values for debugging, including the register value\n        dut._log.info(f\"Pop #{pop_count}: pushed_value={expected_value}, data_out={data_out_value}, top={dut.top.value}, empty={dut.empty.value}, full={dut.full.value}\")\n        \n        # Check if the data_out matches the expected value stored in the register\n        assert data_out_value == expected_value, f\"Expected {expected_value}, but got {data_out_value}\"\n\n        # Check for the correct empty condition after the last pop\n        if i == len(expected_values) - 1:\n            assert dut.empty.value == 1, \"FILO should be empty after popping all elements\"\n        else:\n            assert dut.empty.value == 0, \"FILO should not be empty before all elements are popped\"\n        \n        # Assert full is 0 after a pop\n        assert dut.full.value == 0, \"FILO should not be full after popping\"\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}}
{"id": "cvdp_copilot_fixed_arbiter_0004", "categories": ["cid012", "easy"], "input": {"prompt": "Write a SystemVerilog testbench to generate stimulus for the `fixed_priority_arbiter` module. The testbench should validate the priority-based grant mechanism by applying different request patterns, including single, multiple, and no request scenarios. Additionally, it should verify the reset functionality and ensure the grant signal is correctly assigned based on priority.\n\n\n## Design Details\n\n1. **Inputs**:  \n   - `clk`: 1-bit clock signal for synchronization.  \n   - `reset`: 1-bit active-high reset signal to initialize the arbiter.  \n   - `req`: 8-bit request signal, where each bit represents a request from a unique source.  \n\n2. **Output**:  \n   - `grant`: 8-bit grant signal, where one bit is set high to indicate the granted request based on a **fixed priority scheme**.  \n\n3. **Module Functionality**:  \n  \n    - **Single Request Handling**:  \n         - Assert one request bit at a time in `req` and verify the corresponding bit in `grant` is set high.  \n    - **Multiple Requests Handling**:  \n        - Simultaneously assert multiple request bits and verify that the arbiter grants access to the **highest-priority request**.  \n    - **No Requests**:  \n        - Assert `req = 8'b00000000` and verify that `grant` is cleared to `8'b00000000`.  \n    - **Reset Behavior**:  \n        - Apply an active reset (`reset = 1`) during active requests and verify that `grant` is cleared to `8'b00000000`.  \n\n---\n\n## **Testbench Requirements**\n\n### **Instantiation**\nThe testbench must instantiate the **fixed_priority_arbiter** module as **dut** with proper connections for all signals.\n\n### **Input Generation**\nThe testbench should generate different request patterns to verify correct priority handling, including:\n- Single Requests: Apply requests one at a time to check correct grant assignment.\n- Multiple Requests: Apply overlapping requests to ensure the arbiter always grants the highest-priority request.\n- No Requests: Ensure the grant signal remains `00000000` when no requests are present.\n- Reset Behavior: Apply reset during active requests to verify that `grant` is cleared.\n\n### **Tasks for Test Stimulus**\n- Apply Reset (`apply_reset`)  \n  - A task to assert `reset`, wait for a few clock cycles, and deassert it to verify correct initialization.\n- Drive Request (`drive_request`)  \n  - A task to apply a specific request pattern, hold it for a few cycles, and check the corresponding grant output.\n\n---\n\nThis testbench will validate the **fixed_priority_arbiter** functionality and ensure its behavior under various input conditions.\n\n", "context": {}}, "output": {"response": "", "context": {"verif/fixed_priority_arbiter_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 1d85e9e4f08880640add8d58fe50caa12b7be21a\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/fixed_priority_arbiter.sv": "`timescale 1ns / 1ps\n\nmodule fixed_priority_arbiter(\n    input clk,             // Clock signal\n    input reset,           // Active high reset signal\n    input [7:0] req,       // 8-bit request signal; each bit represents a request from a different source\n    output reg [7:0] grant // 8-bit grant signal; only one bit will be set high based on priority\n); \n  \n    always @(posedge clk or posedge reset) begin\n    \n        if (reset) \n            grant <= 8'b00000000;\n        else begin\n            if (req[0])\n                grant <= 8'b00000001;\n            else if (req[1])\n                grant <= 8'b00000010;\n            else if (req[2])\n                grant <= 8'b00000100;\n            else if (req[3])\n                grant <= 8'b00001000;\n            else if (req[4])\n                grant <= 8'b00010000;\n            else if (req[5])\n                grant <= 8'b00100000;\n            else if (req[6])\n                grant <= 8'b01000000;\n            else if (req[7])\n                grant <= 8'b10000000;\n            else\n                grant <= 8'b00000000;\n        end\n    end\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_fixed_arbiter_0023", "categories": ["cid014", "easy"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the `fixed-priority arbiter` module based on the design specifications provided? The module details and design requirements for assertion development are outlined below.\n\n---\n\n## **Design Specifications**\n- The arbiter operates **synchronously** on the **positive edge of the clock (`clk`)**.\n- It includes an **active-high reset (`reset`)**, which clears the grant signal.\n- If **multiple requests** are active, the **lowest indexed request** is granted.\n- If **no requests** are active, the `grant` signal remains `0`.\n- The **grant output** must be **one-hot encoded** or `0` when no request is active.\n\n## **Inputs and Outputs**\n| Signal Name | Direction | Width  | Description                            |\n|-------------|-----------|--------|----------------------------------------|\n| `clk`       | Input     | 1 bit  | Clock signal (positive edge triggered) |\n| `reset`     | Input     | 1 bit  | Active-high reset, clears grant output |\n| `req`       | Input     | 8 bits | Request signals (one bit per source)   |\n| `grant`     | Output    | 8 bits | Grant signal (one-hot encoded)         |\n\n## **Behavioral Definitions**\n- **Reset Behavior:**  \n  - When `reset = 1`, `grant` should be `8'b00000000`.\n  \n- **Grant Logic:**  \n  - The **lowest active request bit** (`req[i]`) is granted access (`grant[i] = 1`).\n  - If multiple `req[i]` bits are active, the **lowest-indexed** request is selected.\n  - If `req = 0`, `grant = 0` (no active request).\n\n- **Priority Scheme:**  \n  - `req[0]` has **highest priority**, `req[7]` has **lowest priority**.\n  - If `req[3] = 1` and `req[5] = 1`, then `grant[3] = 1` (since `req[3]` has higher priority).\n\n- **One-Hot Encoding:**  \n  - `grant` must always have **only one bit set** (`one-hot`) or be `0` when no request is active.\n\n## **Assertion Requirements**\n1. **Reset Clears Grant**  \n   - When `reset` is asserted, `grant` must be `0`.  \n\n2. **One-Hot or Zero Grant**  \n   - `grant` must be **one-hot or zero** at all times.  \n\n3. **Priority Enforcement**  \n   - If `req[i] = 1` and `req[i-1] = 0`, then `grant[i] = 1` only if all lower-priority requests (`req[i-1:0]`) are `0`.  \n\n4. **No Grant When No Request**  \n   - If `req = 0`, then `grant = 0`.  \n\n## **Summary**\nThe **Fixed-Priority Arbiter** ensures that the lowest-indexed request is always granted first among multiple requesters. It operates synchronously, with an active-high reset and an 8-bit one-hot encoded grant output. The design must pass rigorous assertions to validate reset behavior, priority enforcement, and one-hot encoding compliance. ", "context": {"rtl/fixed_priority_arbiter.sv": "module fixed_priority_arbiter(\n    input clk,             // Clock signal\n    input reset,           // Active high reset signal\n    input [7:0] req,       // 8-bit request signal; each bit represents a request from a different source\n    output reg [7:0] grant // 8-bit grant signal; only one bit will be set high based on priority\n); \n  \n    always @(posedge clk or posedge reset) begin\n    \n        if (reset) \n            grant <= 8'b00000000;\n        else begin\n            if (req[0])\n                grant <= 8'b00000001;\n            else if (req[1])\n                grant <= 8'b00000010;\n            else if (req[2])\n                grant <= 8'b00000100;\n            else if (req[3])\n                grant <= 8'b00001000;\n            else if (req[4])\n                grant <= 8'b00010000;\n            else if (req[5])\n                grant <= 8'b00100000;\n            else if (req[6])\n                grant <= 8'b01000000;\n            else if (req[7])\n                grant <= 8'b10000000;\n            else\n                grant <= 8'b00000000;\n        end\n    end\nendmodule"}}, "output": {"response": "", "context": {"rtl/fixed_priority_arbiter.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 80\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/fixed_priority_arbiter.sv\nTOPLEVEL        = fixed_priority_arbiter\nMODULE          = test_fixed_priority_arbiter\nPYTHONPATH      = /src\nHASH            = d73367c408360a929c2c0b49653161f252205a36\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 2, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_fixed_priority_arbiter.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb  \n\n@cocotb.test()\nasync def test_fixed_priority_arbiter(dut):\n    \"\"\"Test the fixed_priority_arbiter module.\"\"\"\n\n    # Start the clock with a period of 10ns\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals\n    await hrs_lb.dut_init(dut)\n\n    # Task: Apply reset (Active High)\n    async def reset_dut(active=True, duration_ns=10):\n        dut.reset.value =  active\n        await Timer(10, units=\"ns\")\n        dut.reset.value = not active\n        #await RisingEdge(dut.clk)  # Wait for one clock edge after reset is de-asserted\n\n    # Task: Drive request\n    async def drive_request(request):\n        dut.req.value = request\n        #await RisingEdge(dut.clk)\n        await Timer(10, units=\"ns\")  # Wait to observe the output\n\n    # Monitor the signals\n    cocotb.log.info(\"Starting simulation\")\n\n    # Apply a reset to the DUT before starting the test cases\n    # Reset duration is 25ns and reset is active low\n    await reset_dut(active=True, duration_ns=25)\n\n    # ---------------- Test Case 1: Single Request ----------------\n    # Apply individual requests and verify that the grant signal matches the request\n    await drive_request(0b00000001)  # Expect grant = 0b00000001\n    await Timer(10, units=\"ns\")  # Wait to observe the output\n    assert dut.grant.value == 0b00000001, f\"Test Case 1 failed: grant={dut.grant.value}\"\n    dut._log.info(f\"Test Case 1 Single request: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n\n    await drive_request(0b00000010)  # Expect grant = 0b00000010\n    assert dut.grant.value == 0b00000010, f\"Test Case 1 failed: grant={dut.grant.value}\"\n\n    await drive_request(0b00000100)  # Expect grant = 0b00000100\n    assert dut.grant.value == 0b00000100, f\"Test Case 1 failed: grant={dut.grant.value}\"\n\n    await drive_request(0b00000000)  # Expect grant = 0b00000000\n    assert dut.grant.value == 0b00000000, f\"Test Case 1 failed: grant={dut.grant.value}\"\n\n    # ---------------- Test Case 2: Multiple Requests ----------------\n    # Apply multiple active requests and check if the highest-priority request is granted\n    await drive_request(0b00001101)  # Expect grant = 0b00000001 (highest priority)\n    assert dut.grant.value == 0b00000001, f\"Test Case 2 failed: grant={dut.grant.value}\"\n    #dut._log.info(f\"Test Case 2 Multiple request: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n\n    await drive_request(0b10010000)  # Expect grant = 0b00010000\n    assert dut.grant.value == 0b00010000, f\"Test Case 2 failed: grant={dut.grant.value}\"\n\n    # ---------------- Test Case 3: No Requests ----------------\n    # Verify that the grant signal is zero when no requests are active\n    await drive_request(0b00000000)  # Expect grant = 0b00000000\n    await Timer(10, units=\"ns\")\n    assert dut.grant.value == 0b00000000, f\"Test Case 3 failed: grant={dut.grant.value}\"\n    dut._log.info(f\"Test Case 3 No request: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n\n    # ---------------- Test Case 4: Reset During Active Requests ----------------\n    # Apply active requests, then reset the DUT and check that the grant is cleared\n    await drive_request(0b00011000)  # Expect grant = 0b00001000\n    assert dut.grant.value == 0b00001000, f\"Test Case 4 failed: grant={dut.grant.value}\"\n\n    # Log the successful completion of the simulation\n    cocotb.log.info(\"Simulation completed successfully\")\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_fixed_arbiter_0027", "categories": ["cid014", "easy"], "input": {"prompt": "Create a SystemVerilog Assertion (SVA) to verify the arbitration behavior in the `fixed_priority_arbiter` module. The module implements a fixed-priority arbitration policy, where the lowest-indexed request (`req[0]`) has the highest priority, and the highest-indexed request (`req[7]`) has the lowest priority. The arbiter locks the granted request until it is released.\n\n## **Design Specifications**\n### **Module Name:** `fixed_priority_arbiter`  \n\n### **Inputs:**\n- `clk`: System clock (rising edge).\n- `reset`: Active-high reset signal.\n- `enable`: Enables the arbitration process.\n- `clear`: Clears the current grant when asserted.\n- `req [7:0]`: 8-bit request signal where each bit represents a request from a different source.\n\n### **Outputs:**\n- `grant [7:0]`: 8-bit grant signal, where only one bit is set high, indicating which request is granted.\n- `active_grant [2:0]`: Encodes the granted request index.\n\n## **Expected Behavior**\n1. **Single Grant Guarantee**: At any given time, at most one grant bit should be set.\n2. **Priority Enforcement**: The request with the lowest index should always be granted when multiple requests are active.\n3. **Grant Locking**: Once a request is granted, it remains locked until the corresponding request is deasserted or `clear` is asserted.\n4. **Enable Signal Compliance**: If `enable` is deasserted, `grant` must be cleared.\n5. **Clear Signal Compliance**: When `clear` is asserted, `grant` must reset to zero.\n6. **Grant Consistency**: The `active_grant` index must correctly correspond to the granted request.\n\n## **Assertion Requirements**\n- Implement an assertion that verifies only one grant bit is set at any given time.\n- Ensure that the granted request follows the fixed-priority scheme.\n- Verify that `grant` is cleared when `enable` is de-asserted.\n- Check that the `clear` signal properly resets the grant.\n- Validate that `active_grant` matches the granted request.\n\n## **Assertion Failure Handling**\nEach assertion failure must trigger an error message to aid debugging.", "context": {"rtl/fixed_priority_arbiter.sv": "module fixed_priority_arbiter(\n    input clk,                    // Clock signal\n    input reset,                  // Active high reset signal\n    input enable,                 // Enable signal for the arbiter\n    input clear,                  // Clear signal to manually clear the grant\n    input [7:0] req,              // 8-bit request signal; each bit represents a request from a different source\n    output reg [7:0] grant,       // 8-bit grant signal; only one bit will be set high based on priority\n    output reg [2:0] active_grant // Binary encoded grant index\n);\n    reg locked;                   // Lock signal to hold the grant\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all signals\n            grant <= 8'b00000000;\n            locked <= 1'b0;\n            active_grant <= 3'b000;\n        end else if (!enable) begin\n            // Disable arbiter operation, clear grant\n            grant <= 8'b00000000;\n            locked <= 1'b0;\n            active_grant <= 3'b000;\n        end else if (clear) begin\n            grant <= 8'b00000000;\n            active_grant <= 3'b000;\n            locked <= 1'b0;\n        end else begin\n            if (locked) begin\n                if (req[active_grant]) begin\n                    grant <= (8'b00000001 << active_grant);\n                end else begin\n                    grant <= 8'b00000000;\n                    locked <= 1'b0;\n                end\n            end else begin\n                if (req[0]) begin\n                    grant <= 8'b00000001;\n                    locked <= 1'b1;\n                    active_grant <= 3'b000;\n                end else if (req[1]) begin\n                    grant <= 8'b00000010;\n                    locked <= 1'b1;\n                    active_grant <= 3'b001;\n                end else if (req[2]) begin\n                    grant <= 8'b00000100;\n                    locked <= 1'b1;\n                    active_grant <= 3'b010;\n                end else if (req[3]) begin\n                    grant <= 8'b00001000;\n                    locked <= 1'b1;\n                    active_grant <= 3'b011;\n                end else if (req[4]) begin\n                    grant <= 8'b00010000;\n                    locked <= 1'b1;\n                    active_grant <= 3'b100;\n                end else if (req[5]) begin\n                    grant <= 8'b00100000;\n                    locked <= 1'b1;\n                    active_grant <= 3'b101;\n                end else if (req[6]) begin\n                    grant <= 8'b01000000;\n                    locked <= 1'b1;\n                    active_grant <= 3'b110;\n                end else if (req[7]) begin\n                    grant <= 8'b10000000;\n                    locked <= 1'b1;\n                    active_grant <= 3'b111;\n                end else begin\n                    // No requests active\n                    grant <= 8'b00000000;\n                end\n            end\n        end\n    end\nendmodule"}}, "output": {"response": "", "context": {"rtl/fixed_priority_arbiter.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 80\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/fixed_priority_arbiter.sv\nTOPLEVEL        = fixed_priority_arbiter\nMODULE          = test_fixed_priority_arbiter\nPYTHONPATH      = /src\nHASH            = 40a2b507c9f8b5f3c4885eebc1771a76099be670\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 2, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_fixed_priority_arbiter.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb  \n\n# Task to apply reset\nasync def apply_reset(dut):\n    \"\"\"Apply reset to the DUT.\"\"\"\n    dut.reset.value = 1  # Set reset signal high\n    dut.enable.value = 0  \n    dut.clear.value = 0  \n    dut.req.value = 0  # Clear all request signals\n    await Timer(10, units=\"ns\")  # Wait for 10 ns\n    dut.reset.value = 0  # De-assert reset\n    dut.enable.value = 1  \n    await RisingEdge(dut.clk)  # Wait for a clock edge\n\n# Task to drive request and check outputs\nasync def drive_request(dut, request, expected_grant, expected_active_grant):\n    \"\"\"Drive the request and check grant outputs.\"\"\"\n    dut.req.value = request  # Apply the request signal\n    await RisingEdge(dut.clk)  # Wait for a clock edge\n    await Timer(10, units=\"ns\")  # Wait for grant to stabilize\n\n    # Verify the grant matches the expected value\n    assert dut.grant.value == expected_grant, (\n        f\"Grant mismatch: Req={bin(request)} | Expected Grant={bin(expected_grant)}, Observed Grant={bin(dut.grant.value)}\"\n    )\n\n    # Verify the active grant index matches the expected value\n    assert dut.active_grant.value == expected_active_grant, (\n        f\"Active Grant mismatch: Req={bin(request)} | Expected Active Grant={bin(expected_active_grant)}, Observed Active Grant={bin(dut.active_grant.value)}\"\n    )\n\n@cocotb.test()\nasync def test_fixed_priority_arbiter(dut):\n    \"\"\"Cocotb testbench for fixed_priority_arbiter.\"\"\"\n\n    # Generate the clock with a 10 ns period\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Initialize the DUT signals using a predefined library function\n    await hrs_lb.dut_init(dut)\n\n    # Apply reset\n    dut._log.info(\"Applying reset\")\n    await apply_reset(dut)\n\n    # Test Case 1: Single request\n    dut._log.info(\"Starting Test Case 1: Single request\")\n    # Apply a single request and verify the grant and active grant index\n    await drive_request(dut, 0b00000001, 0b00000001, 0b000)\n    dut._log.info(f\"Test Case 1 Single request: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n\n    # Test Case 2: Multiple requests (priority handling)\n    dut._log.info(\"Starting Test Case 2: Multiple requests\")\n    # Apply multiple requests and verify the highest-priority request is granted\n    await drive_request(dut, 0b00001101, 0b00000001, 0b000)  # Priority: Req[0]\n    dut._log.info(f\"Test Case 2 Multiple request: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n\n    # Test Case 3: Clear grant manually\n    dut._log.info(\"Starting Test Case 3: Clear grant manually\")\n    # Apply a request, then manually clear the grant\n    dut.req.value = 0b00000100  # Active request\n    dut.clear.value = 1  # Set clear signal high\n    await Timer(10, units=\"ns\") \n    dut.clear.value = 0 \n    await RisingEdge(dut.clk)  \n    # Verify the grant is cleared\n    assert dut.grant.value == 0, f\"Clear failed. Grant={bin(dut.grant.value)} (Expected 0)\"\n    dut._log.info(f\"Test Case 3 Clear grant manually: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n\n    # Test Case 4: Disable arbiter\n    dut._log.info(\"Starting Test Case 4: Disable arbiter\")\n    # Disable the arbiter and verify no grant is provided\n    dut.enable.value = 0  # Disable the arbiter\n    dut.req.value = 0b00000100  # Active request\n    await Timer(15, units=\"ns\")\n    # Verify the grant is not provided when disabled\n    assert dut.grant.value == 0, f\"Arbiter not disabled. Grant={dut.grant.value}\"\n    dut._log.info(f\"Test Case 4 Disable arbiter: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n    dut.enable.value = 1  # Re-enable the arbiter\n\n    # Test Case 5: No requests active\n    dut._log.info(\"Starting Test Case 5: No requests active\")\n    # Apply no request and verify no grant is provided\n    await drive_request(dut, 0b00000000, 0b00000000, 0b000)\n    dut._log.info(f\"Test Case 5 No requests active: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n\n    # Finish simulation\n    dut._log.info(\"All test cases completed.\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_fsm_seq_detector_0031", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the existing SystemVerilog testbench to include checker generation logic for verifying the functionality of the `fsm_seq_detector` module. The testbench already contains stimulus generation logic to drive the input signals. The modified testbench should incorporate a checker logic to validate the `fsm_seq_detector` module against the given design specification.\n\n\n### **Design Specification:**\nThe `fsm_seq_detector` module is a finite state machine (FSM) that detects the 10110001 sequence in a continuous 1-bit input stream (`seq_in`). The module has the following inputs and outputs:\n- **Inputs:**\n  - `clk_in`: Positive edge-triggered clock signal.\n  - `rst_in`: Active HIGH asynchronous reset signal.\n  - `seq_in`: Continuous 1-bit sequence input.\n- **Outputs:**\n  - `seq_detected`: A 1-bit signal that goes HIGH for one clock cycle when the sequence `10110001` is detected.\n\nThe FSM has eight states (`S0` to `S7`) and transitions based on the input `seq_in`. The sequence detection is overlapping, meaning the sequence can start before the previous sequence ends.\n\n### **Testbench Requirements:**\n1. **Testbench Components:**\n   - **Input Signals:** Drive `clk_in`, `rst_in`, and `seq_in` with various test cases.\n   - **Output Validation:** Monitor and validate the `seq_detected` output against expected behavior.\n   - **Checker Generator:** Implement a checker logic to verify the correctness of `seq_detected` based on the input `seq_in`.\n\n2. **Checker Logic:**\n   - Implement a shift register to track the last 8 bits of `seq_in`.\n   - Compare the shift register value with the target sequence `10110001`.\n   - If the shift register matches the target sequence, ensure `seq_detected` is HIGH for one clock cycle.\n   - If the shift register does not match the target sequence, ensure `seq_detected` remains LOW.\n   - Log errors if the outputs do not match the expected behavior.\n   - Print success messages for passing test cases.\n\n3. **Functionality:**\n   - Test the following scenarios:\n     - **Full Sequence Test:** Verify detection of the sequence `10110001` in a long input stream.\n     - **Sequence at End:** Verify detection when the sequence appears at the end of the input stream.\n     - **Sequence at Start:** Verify detection when the sequence appears at the start of the input stream.\n     - **Sequence in Middle:** Verify detection when the sequence appears in the middle of the input stream.\n     - **Overlapping Sequences:** Verify detection of overlapping sequences.\n   - Include edge cases such as:\n     - Reset behavior.\n     - Random input sequences.\n     - Continuous input streams without the target sequence.\n\n4. **Verification:**\n   - Drive `seq_in` and monitor `seq_detected` using the checker logic.\n   - Compare the actual `seq_detected` behavior with the expected behavior.\n   - Log results (pass/fail) for each test case.\n\n5. **Simulation:**\n   - Display pass/fail results for each test case.\n   - Complete the simulation once all test cases are verified.\n\n### **Deliverables:**\nProvide a complete SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `fsm_seq_detector` module. The testbench should include:\n- A test sequence generator to create input patterns.\n- A checker logic module to validate the outputs.\n- Proper clock generation and reset handling.\n- Logging of test results for each test case.\n\n### **Example Test Cases:**\n**1. Full Sequence Test:**\n   - Input: A long sequence containing `10110001`.\n   - Expected Output: `seq_detected` goes HIGH for one clock cycle when the sequence is detected.\n\n**2. Sequence at End:**\n   - Input: A sequence where `10110001` appears at the end.\n   - Expected Output: `seq_detected` goes HIGH for one clock cycle at the end.\n\n**3. Sequence at Start:**\n   - Input: A sequence where `10110001` appears at the start.\n   - Expected Output: `seq_detected` goes HIGH for one clock cycle at the start.\n\n**4. Sequence in Middle:**\n   - Input: A sequence where `10110001` appears in the middle.\n   - Expected Output: `seq_detected` goes HIGH for one clock cycle in the middle.\n\n**5. Overlapping Sequences:**\n   - Input: A sequence with overlapping `10110001` patterns (e.g., `101100010110001`).\n   - Expected Output: `seq_detected` goes HIGH for one clock cycle for each detected sequence.\n\n### **Expected Output:**\n- The testbench should:\n  - Apply the input test cases one by one.\n  - Display each test case's comparison results (pass/fail), including detailed information for debugging.\n  - Complete the simulation once all test cases are verified.\n\n---\n\n### **Expected behavior for Checker Logic:**\n1. **Shift Register Implementation:**\n   - Use an 8-bit shift register to track the last 8 bits of `seq_in`.\n   - Update the shift register on every clock cycle.\n\n2. **Sequence Comparison:**\n   - Compare the shift register value with the target sequence `10110001`.\n   - If the shift register matches the target sequence, ensure `seq_detected` is HIGH for one clock cycle.\n   - If the shift register does not match the target sequence, ensure `seq_detected` remains LOW.\n\n3. **Error Logging:**\n   - If `seq_detected` does not match the expected behavior, log an error with the following details:\n     - Input sequence.\n     - Expected `seq_detected` value.\n     - Actual `seq_detected` value.\n\n4. **Success Logging:**\n   - For passing test cases, log a success message with the same details as above.", "context": {"verif/tb_fsm_seq_detector.sv": "module tb_fsm_seq_detector;\n\n  logic clk_in, rst_in, seq_in;\n  logic seq_detected;\n  \n  // Sequencer Generation Signal Declaration\n  logic [7:0] Pattern0  = 8'b10110001; // Fixed Patterns 0 to 16 to feed DUT\n  logic [7:0] Pattern1  = 8'b10100111;\n  logic [7:0] Pattern2  = 8'b10110001;\n  logic [7:0] Pattern3  = 8'b10011100;\n  logic [7:0] Pattern4  = 8'b10011100;\n  logic [7:0] Pattern5  = 8'b01010011;\n  logic [7:0] Pattern6  = 8'b10010011;\n  logic [7:0] Pattern7  = 8'b01111111;\n  logic [7:0] Pattern8  = 8'b10110001;\n  logic [7:0] Pattern9  = 8'b01010011;\n  logic [7:0] Pattern10 = 8'b10110001;  \n  logic [7:0] Pattern11 = 8'b10110100;  \n  logic [7:0] Pattern12 = 8'b10110010;  \n  logic [7:0] Pattern13 = 8'b00000000;  \n  logic [7:0] Pattern14 = 8'b10110000;  \n  logic [7:0] Pattern15 = 8'b10110001;  \n  logic [7:0] Pattern16 = 8'b01100011;  \n  logic [135:0] complete_pat;\n  logic start_seq;\n\n  parameter [4:0] Length = 8;\n  parameter [Length-1:0] informed_seq = 8'b10110001;\n\n  fsm_seq_detector uut (\n    .clk_in(clk_in), \n    .rst_in(rst_in), \n    .seq_in(seq_in), \n    .seq_detected(seq_detected)\n  );\n   \n  initial clk_in = 1;   \n  always #5 clk_in = ~clk_in;\n  \n  assign complete_pat = { Pattern0, Pattern1, Pattern2, Pattern3, Pattern4, Pattern5, Pattern6, Pattern7, Pattern8, Pattern9, Pattern10, Pattern11, Pattern12, Pattern13, Pattern14, Pattern15, Pattern16 }; \n\n  integer i;\n\n  task run_test_case();\n    begin\n      $display(\"Starting Test Case: Full Sequence Test\");\n      seq_in <= 0;\n      start_seq <= 0;\n      rst_in <= 1;\n      \n      repeat (5) @(posedge clk_in);\n      rst_in <= 0;\n      start_seq <= 1;\n      for (i = 0; i < 136; i = i + 1) begin\n        seq_in <= complete_pat[135 - i];\n        @(posedge clk_in);\n      end\n      repeat (3) @(posedge clk_in);\n    end\n  endtask\n\n  task run_test_case_sequence_at_end();\n    begin\n      $display(\"Starting Test Case: Sequence at End\");\n      seq_in <= 0;\n      start_seq <= 0;\n      rst_in <= 1;\n      \n      repeat (5) @(posedge clk_in);\n      rst_in <= 0;\n      start_seq <= 1;\n      for (i = 0; i < 8; i = i + 1) begin\n        seq_in <= $random;\n        @(posedge clk_in);\n      end\n      for (i = 0; i < 8; i = i + 1) begin\n        seq_in <= informed_seq[7 - i];\n        @(posedge clk_in);\n      end\n      repeat (3) @(posedge clk_in);\n    end\n  endtask\n\n  task run_test_case_sequence_at_start();\n    begin\n      $display(\"Starting Test Case: Sequence at Start\");\n      seq_in <= 0;\n      start_seq <= 0;\n      rst_in <= 1;\n      \n      repeat (5) @(posedge clk_in);\n      rst_in <= 0;\n      start_seq <= 1;\n      for (i = 0; i < 8; i = i + 1) begin\n        seq_in <= informed_seq[7 - i];\n        @(posedge clk_in);\n      end\n      for (i = 0; i < 8; i = i + 1) begin\n        seq_in <= $random;\n        @(posedge clk_in);\n      end\n      repeat (3) @(posedge clk_in);\n    end\n  endtask\n\n  task run_test_case_sequence_in_middle();\n    begin\n      $display(\"Starting Test Case: Sequence in Middle\");\n      seq_in <= 0;\n      start_seq <= 0;\n      rst_in <= 1;\n      \n      repeat (5) @(posedge clk_in);\n      rst_in <= 0;\n      start_seq <= 1;\n      for (i = 0; i < 8; i = i + 1) begin\n        seq_in <= $random;\n        @(posedge clk_in);\n      end\n      for (i = 0; i < 8; i = i + 1) begin\n        seq_in <= informed_seq[7 - i];\n        @(posedge clk_in);\n      end\n      for (i = 0; i < 8; i = i + 1) begin\n        seq_in <= $random;\n        @(posedge clk_in);\n      end\n      repeat (3) @(posedge clk_in);\n    end\n  endtask\n\n  task run_test_case_overlapping_sequences();\n    begin\n      $display(\"Starting Test Case: Overlapping Sequences\");\n      seq_in <= 0;\n      start_seq <= 0;\n      rst_in <= 1;\n      \n      repeat (5) @(posedge clk_in);\n      rst_in <= 0;\n      start_seq <= 1;\n      for (i = 0; i < 16; i = i + 1) begin\n        seq_in <= complete_pat[15 - i];\n        @(posedge clk_in);\n      end\n      repeat (3) @(posedge clk_in);\n    end\n  endtask\n\n  initial begin\n    run_test_case();\n    run_test_case_sequence_at_end();\n    run_test_case_sequence_at_start();\n    run_test_case_sequence_in_middle();\n    run_test_case_overlapping_sequences();\n    $finish;\n  end\n\n  always @(negedge clk_in) begin\n    $display(\"Time: %0t | reset input: %b | sequence input: %b | sequence detected out: %b \", \n             $time, rst_in, seq_in, seq_detected);\n  end\n\n  initial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0);\n  end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_fsm_seq_detector.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 4b77e280db8810dc45c2a0493b4ff2d16449361e\nNUM_BUGS        = 4\n", "src/fsm_seq_detector.sv": "////////////// RTL code for Sequence Detector //////////////////\n\nmodule fsm_seq_detector\n(\n    input   bit     clk_in,         // Free Running Clock\n    input   logic   rst_in,         // Active HIGH reset\n    input   logic   seq_in,         // Continuous 1-bit Sequence Input\n    output  logic   seq_detected    // '0': Not Detected. '1': Detected. Will be HIGH for 1 Clock cycle Only\n);\n\n    // FSM States Declaration, with S0 being reset State\n    typedef enum logic [2:0] {S0, S1, S2, S3, S4, S5, S6, S7} state_t;\n    state_t cur_state, next_state;\n\n    // Register Declaration\n    logic seq_detected_w;  // Wire used in combinational always block\n\n    // FSM State assignment Logic\n    always @(posedge clk_in or posedge rst_in) begin\n        if (rst_in)\n            cur_state <= S0;\n        else\n\t`ifndef BUG_0\n            cur_state <= next_state;\n\t`else\n            cur_state <= cur_state;\n\t`endif\n    end\n\n    // Combinational Always Block with FSM Logic For Detecting Sequence\n    always_comb begin\n        if (rst_in) begin\n            seq_detected_w = 1'b0;\n            next_state = S0;\n        end\n        else begin\n            case (cur_state)\n                S0: begin                   // reset or default State\n                    if (seq_in) begin\n                        next_state = S1;\n                        seq_detected_w = 1'b0;\n                    end\n                    else begin\n                        seq_detected_w = 1'b0;\n                        next_state = S0;\n                    end\n                end\n                S1: begin                   // enter this state if Hit 1\n                    if (seq_in) begin\n                        next_state = S1;\n                        seq_detected_w = 1'b0;\n                    end\n                    else begin\n                        next_state = S2;\n                        seq_detected_w = 1'b0;\n                    end\n                end\n                S2: begin                   // enter this state if Hit 10\n                    if (seq_in) begin\n                        next_state = S3;\n                        seq_detected_w = 1'b0;\n                    end\n                    else begin\n                        next_state = S0;\n                        seq_detected_w = 1'b0;\n                    end\n                end\n                S3: begin                   // enter this state if Hit 101\n                    if (seq_in) begin\n                        next_state = S4;\n                        seq_detected_w = 1'b0;\n                    end\n                    else begin\n                        next_state = S2;\n                        seq_detected_w = 1'b0;\n                    end\n                end\n                S4: begin                   // enter this state if Hit 1011\n                    if (seq_in) begin\n                        next_state = S1;\n                        seq_detected_w = 1'b0;\n                    end\n                    else begin\n                        next_state = S5;\n                        seq_detected_w = 1'b0;\n                    end\n                end\n                S5: begin                   // enter this state if Hit 10110\n                    if (seq_in) begin\n                        next_state = S3;\n                        seq_detected_w = 1'b0;\n                    end\n                    else begin\n                        next_state = S6;\n                        seq_detected_w = 1'b0;\n                    end\n                end\n                S6: begin                   // enter this state if Hit 101100\n                    if (seq_in) begin\n                        next_state = S1;\n                        seq_detected_w = 1'b0;\n                    end\n                    else begin\n\t            `ifndef BUG_1\n                        next_state = S7;\n                        seq_detected_w = 1'b0;\n\t\t    `else\n                        next_state = S0;\n                        seq_detected_w = 1'b0;\n\t            `endif\n                    end\n                end\n                S7: begin                   // enter this state if Hit 1011000\n                    if (seq_in) begin\n\t            `ifndef BUG_2\n                        next_state = S1;    // Overlapping case\n                        seq_detected_w = 1'b1; // Output HIGH if Sequence matches with 10110001\n\t\t    `else\n                        next_state = S0;    // Overlapping case\n                        seq_detected_w = 1'b1; // Output HIGH if Sequence matches with 10110001\n\t            `endif\n                    end\n                    else begin\n                        next_state = S0;\n                        seq_detected_w = 1'b0; // Output LOW if Sequence does not match\n                    end\n                end\n                default: begin              // Default state\n                    next_state = S0;\n                    seq_detected_w = 1'b0;\n                end\n            endcase\n        end\n    end\n\n    // Sequential Always Block for registering Output to Avoid Glitches\n    always @(posedge clk_in or posedge rst_in) begin\n        if (rst_in)\n            seq_detected <= 1'b0;\n        else\n\t`ifndef BUG_3\n            seq_detected <= seq_detected_w;\n        `else\n            seq_detected <= 1'b0;\n\t`endif\n    end\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_gaussian_rounding_div_0014", "categories": ["cid012", "easy"], "input": {"prompt": "Write a testbench to only generate stimulus for a `divider` that performs non-restoring division for two unsigned positive integer inputs, and generates the output `quotient`, `remainder` and `valid` when computation is completed for the inputs `dividend` and `divisor` when `start` is asserted. In this design, the outputs are generated after WIDTH + 2 clock cycles and the output is considered valid when `valid` is asserted.\n\nThe non-restoring division is a division technique for unsigned binary values that simplifies the procedure by eliminating the restoring phase.\n\n## Design Details\n\n### Parameters\n\n- **`WIDTH`**  \n  - *Default*: 32\n  - *Constraint*: Must be greater than 1  \n  - *Description*: Bit-width of the `dividend` and `divisor`, and thus of the `quotient` and `remainder`.\n\n---\n\n### Port List\n\n| **Port Name**  | **Direction** | **Width**       | **Description and Constraints**                                                                                                                                                             |\n|----------------|---------------|-----------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **`clk`**      | input         | 1 bit           | Main clock input. All operations occur on the rising edge of this signal.                                                                                                                   |\n| **`rst_n`**    | input         | 1 bit           | Active-low asynchronous reset. When asserted (0), resets the internal state machine, outputs and registers to their initial states.                                                         |\n| **`start`**    | input         | 1 bit           | When asserted high, it indicates that valid inputs (`dividend` and `divisor`) are available and a new division operation should begin on the next rising clock edge.                        |\n| **`dividend`** | input         | `WIDTH` bits    | Dividend (the numerator) for the division operation. Must be greater than or equal to 0 and Less than 2<sup>(WIDTH)</sup>-1                                                                 |\n| **`divisor`**  | input         | `WIDTH` bits    | Divisor (the denominator) for the division operation. Must be greater than 0 and Less than 2<sup>(WIDTH-1)</sup>-1.                                                                         |\n| **`quotient`** | output        | `WIDTH` bits    | The integer division result, valid once the module completes the division and `valid` is asserted. The output value is held till the computation of the next set of inputs is completed.    |\n| **`remainder`**| output        | `WIDTH` bits    | The remainder from the division, valid once the module completes the division and `valid` is asserted. The output value is held till the computation of the next set of inputs is completed.|\n| **`valid`**    | output        | 1 bit           | Asserted high when the output (`quotient` and `remainder`) is valid. Remains asserted after the calculation is completed till the `start` input is driven low.                              |\n\n---\n\n## The design follows the following Finite-State Machine (FSM) for division\n\n1. **IDLE**  \n   - **Default/Reset state**.  \n   - Waits for `start` to be asserted.  \n   - On `start`, loads the `dividend` and `divisor` into internal registers, resets the `quotient` and `remainder` registers, and transitions to **BUSY**.\n\n2. **BUSY**  \n   - Performs the **non-restoring** algorithm for `WIDTH` clock cycles.  \n\n3. **DONE**  \n   - Asserts `valid` to indicate outputs are ready.  \n   - Stays in **DONE** until `start` is de-asserted, then returns to **IDLE**.\n\n---\n\n### Latency Considerations of the DUT\nTotal Latency = WIDTH + 2 cycles\n\n### Notes:\n- Division by 0 is not handled in this design\n- When `start` signal is is asserted, the design latches the input `dividend` and `divisor` at the next clock edge.\n- Inputs `dividend` and `divisor` will remain stable until the calculation is complete.\n \n## Testbench requirements:\n\n### Instantiation\n\n- Module Instance: The `divider` module is instantiated as `dut`, with the input and output signals connected for testing.\n---\n\n### Input Generation\n\n- Input Generation: The testbench must generate inputs of WIDTH-bit binary values for `dividend` and `divisor` and 1-bit `start` to cover all possibilities, including the corner cases.\n- Computation Period: After setting each pair of inputs, the testbench waits till assertion of `valid` to ensure the outputs have stabilized, before asserting new values.", "context": {}}, "output": {"response": "", "context": {"verif/divider_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 14-tb-stimulus-non-restoring-divison\nTARGET = 99\n", "src/coverage.cmd": "report -metrics overall -out coverage.log -overwrite\nreport -html -metrics all -out coverage_html -overwrite", "src/divider.sv": "`timescale 1ns/1ps\nmodule divider #\n(\n    parameter WIDTH = 32\n)\n(\n    input  wire                  clk,\n    input  wire                  rst_n,      // Active-low asynchronous reset\n    input  wire                  start,      // Start signal for new operation\n    input  wire [WIDTH-1 : 0]    dividend,   // Dividend (numerator)\n    input  wire [WIDTH-1 : 0]    divisor,    // Divisor (denominator)\n    output wire [WIDTH-1 : 0]    quotient,   // Result of the division\n    output wire [WIDTH-1 : 0]    remainder,  // Remainder after division\n    output wire                  valid       // Indicates output is valid\n);\n\n    // Simple 3-state FSM\n    localparam IDLE = 2'b00;\n    localparam BUSY = 2'b01;\n    localparam DONE = 2'b10;\n\n    reg [1:0] state_reg, state_next;\n\n    // A+Q combined into one 2*WIDTH register:\n    reg [2*WIDTH-1:0] aq_reg, aq_next;\n\n    // Divisor register\n    reg [WIDTH-1:0] m_reg, m_next;\n\n    // Iterate exactly WIDTH times\n    reg [$clog2(WIDTH)-1:0] n_reg, n_next;\n\n    // Final outputs\n    reg [WIDTH-1:0] quotient_reg, quotient_next;\n    reg [WIDTH-1:0] remainder_reg, remainder_next;\n    reg valid_reg, valid_next;\n\n    // Assign the top-level outputs\n    assign quotient  = quotient_reg;\n    assign remainder = remainder_reg;\n    assign valid     = valid_reg;\n\n    //------------------------------------------------\n    // SEQUENTIAL: State & register updates\n    //------------------------------------------------\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg     <= IDLE;\n            aq_reg        <= 0;\n            m_reg         <= 0;\n            n_reg         <= 0;\n            quotient_reg  <= 0;\n            remainder_reg <= 0;\n            valid_reg     <= 0;\n        end\n        else begin\n            state_reg     <= state_next;\n            aq_reg        <= aq_next;\n            m_reg         <= m_next;\n            n_reg         <= n_next;\n            quotient_reg  <= quotient_next;\n            remainder_reg <= remainder_next;\n            valid_reg     <= valid_next;\n        end\n    end\n\n    //------------------------------------------------\n    // COMBINATIONAL: Next-state logic\n    //------------------------------------------------\n    always @* begin\n        // Default \"hold\" behavior\n        state_next     = state_reg;\n        aq_next        = aq_reg;\n        m_next         = m_reg;\n        n_next         = n_reg;\n        quotient_next  = quotient_reg;\n        remainder_next = remainder_reg;\n        valid_next     = valid_reg;\n\n        case (state_reg)\n        //---------------------------------------------\n        // IDLE: Wait for start\n        //---------------------------------------------\n        IDLE: begin\n            // Outputs not valid yet\n            valid_next = 1'b0;\n\n            if (start) begin\n                // Step-1: Initialize\n                // A=0 => top WIDTH bits of aq_reg = 0\n                // Q=dividend => lower WIDTH bits\n                aq_next  = { {WIDTH{1'b0}}, dividend };\n                m_next   = divisor;\n                n_next   = WIDTH;\n                // We do not set the final quotient/remainder yet\n                // Move to BUSY\n                state_next = BUSY;\n            end\n        end\n\n        //---------------------------------------------\n        // BUSY: Perform the N iterations\n        //---------------------------------------------\n        BUSY: begin\n            // 1) SHIFT LEFT\n            aq_next = aq_reg << 1;\n\n            // 2) If sign bit of old A == 1 => add M; else => subtract M.\n            if (aq_reg[2*WIDTH-1] == 1'b1) begin\n                aq_next[2*WIDTH-1 : WIDTH] = aq_next[2*WIDTH-1 : WIDTH] + m_reg;\n            end\n            else begin\n                aq_next[2*WIDTH-1 : WIDTH] = aq_next[2*WIDTH-1 : WIDTH] - m_reg;\n            end\n\n            // 3) Check the new sign bit of A (after the add/sub).\n            //    If sign(A) = 1 => Q[0] = 0; else => Q[0] = 1.\n            if (aq_next[2*WIDTH-1] == 1'b1) begin\n                aq_next[0] = 1'b0;\n            end\n            else begin\n                aq_next[0] = 1'b1;\n            end\n\n            // Decrement iteration count\n            n_next = n_reg - 1;\n\n            // Step-7: if n != 0 => repeat, else => next step\n            if (n_next == 0) begin\n                state_next = DONE;\n            end\n        end\n\n        //---------------------------------------------\n        // DONE: Final correction + output\n        //---------------------------------------------\n        DONE: begin\n            // Step-8: If sign bit of A == 1 => A = A + M\n            if (aq_reg[2*WIDTH-1] == 1'b1) begin\n                aq_next = aq_reg;  // default\n                aq_next[2*WIDTH-1 : WIDTH] = aq_reg[2*WIDTH-1 : WIDTH] + m_reg;\n            end\n\n            // Step-9: \n            //   - The final quotient is the lower WIDTH bits of aq_reg\n            //   - The final remainder is the upper WIDTH bits of aq_reg\n            quotient_next  = aq_next[WIDTH-1 : 0];\n            remainder_next = aq_next[2*WIDTH-1 : WIDTH];\n\n            // Output becomes valid\n            valid_next = 1'b1;\n\n            // Return to IDLE when 'start' goes low\n            if (!start) begin\n                state_next = IDLE;\n            end else begin\n                state_next = DONE;\n            end\n        end\n\n        default: begin\n            state_next = IDLE;\n        end\n        endcase\n    end\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Simulation didn't run correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage merge didn't run correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    try:\n        with open(\"/code/rundir/coverage.log\") as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage.log file.\")\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    print(\"Parsed Metrics:\")\n    print(metrics)\n\n    # Ensure TARGET environment variable is set\n    target = os.getenv(\"TARGET\")\n    if not target:\n        raise ValueError(\"TARGET environment variable is not set.\")\n    target = float(target)\n\n    # Check coverage for the DUT or specific key\n    dut = \"dut\"  # Replace this with the DUT key you want to check\n    if dut in metrics and \"Overall Average\" in metrics[dut]:\n        assert float(metrics[dut][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        # Log available keys for debugging\n        print(f\"Available keys in metrics: {metrics.keys()}\")\n        assert False, f\"Coverage data for '{dut}' is not available.\""}}}
{"id": "cvdp_copilot_gcd_0028", "categories": ["cid012", "easy"], "input": {"prompt": "Write a testbench to only generate stimulus for a `gcd_3_ip` that calculates the greatest common divisor (GCD) for three signed inputs, using the Euclidean algorithm, and generates the output `OUT` and `done` sequentially when `go` is asserted and inputs `A`, `B` and `C` are applied. In this design, the `OUT` output is generated over multiple clock cycles, and the output is considered valid when `done` is asserted.\n\nThe Euclidean algorithm calculates the GCD by iteratively replacing the larger of two numbers with the difference between the two numbers. This process is repeated, reducing the larger number each time, until the two numbers become equal. At this point, the value of either number is the GCD of the original inputs.\n\n## Design Details\n\n**Parameterization**  \n- `WIDTH` (Default 32, must be greater than 0 and less than 33): Bit-width of `A`, `B`, `C` and `OUT `.\n- `SIGNED_EN` (Default 1):  Enable (SIGNED_EN=1) or disable (SIGNED_EN=0) signed input handling.\n\n**Functionality**  \n1. **Computation, Accumulation, and Output Stage**\n   - Computes the GCD of the three inputs and assigns to `OUT`, making it available as the final output.\n\n2. **Done Signal Behavior**\n   - The `done` signal goes high after the `OUT` is fully computed and valid.\n\n3. **Reset Behavior**\n   - `rst`: Active-high synchronous reset. When asserted high, it immediately clears all registers and outputs to 0, including `OUT`, `done`.\n\n### Inputs and Outputs\n- **Inputs**:\n  - `clk`: Clock signal. The design should be synchronized to the positive edge of this clock signal..\n  - `rst`: Active high synchronous reset signal.\n  - `A [WIDTH-1:0]`: Input value A.\n  - `B [WIDTH-1:0]`: Input value B.\n  - `C [WIDTH-1:0]`: Input value C.\n  - `go`: Start signal to initiate GCD calculation. Active high.\n\n- **Outputs**:\n  - `OUT [WIDTH-1:0]`: Output for the calculated GCD.\n  - `done`: Active high signal that indicates when the computation is complete. \n\n### Additional Details\n\n- **Control Signal Behavior**:\n  - Both `go` and `done` are asserted high for one cycle.\n  - Once `done` is asserted, new inputs will be fed to the system on the current rising edge of `clk` following this assertion. \n\n\n## Testbench requirements:\n\n**Instantiation**\n\n- Module Instance: The gcd_3_ip module should be instantiated as `dut`, with the input and output signals connected for testing.\n---\n\n**Input Generation**\n\n- Input Generation: The testbench must generate inputs of WIDTH-bit binary values for `A`, `B` and `C` and 1-bit `go`  to cover all possibilities, including the corner cases. Include negative values if SIGNED_EN is 1. Also test for input value 0.\n- Computation Period: After setting each pair of inputs, the testbench should wait till assertion of `done` to ensure the outputs have stabilized, before asserting new values.", "context": {}}, "output": {"response": "", "context": {"verif/gcd_top_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 28-tb-for-gcd-3-ip-with-0-and-signed-input\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log -overwrite\nreport -html -metrics all -out coverage_html -overwrite", "src/gcd_top.sv": "`timescale 1ns/1ps\nmodule gcd_3_ip #(\n   parameter WIDTH = 32,\n   parameter SIGNED_EN = 1\n   )(\n   input                     clk,\n   input                     rst,\n   input  [WIDTH-1:0]        A,\n   input  [WIDTH-1:0]        B,\n   input  [WIDTH-1:0]        C,\n   input                     go,\n   output logic  [WIDTH-1:0] OUT,\n   output logic              done\n);\n\nlogic [WIDTH-1:0] gcd_ab;\nlogic [WIDTH-1:0] gcd_bc;\nlogic             go_abc;\nlogic             done_ab;\nlogic             done_bc;\nlogic             done_ab_latched;\nlogic             done_bc_latched;\n\n// GCD is calculated for AB and BC in parallel. The GCD for two numbers is lower than the numbers themselves in most cases.\n// And calculating GCD for smaller numbers is comparatively faster using the implemented algorithm.\n// Hence in order to reduce GCD computation latency the calculation is broken up in this fashion.\n\ngcd_top\n#( .WIDTH(WIDTH),\n   .SIGNED_EN(SIGNED_EN)\n) gcd_A_B_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (A),\n   .B             (B),\n   .go            (go),\n   .OUT           (gcd_ab),\n   .done          (done_ab)\n);\n\ngcd_top\n#( .WIDTH(WIDTH),\n   .SIGNED_EN(SIGNED_EN)\n) gcd_B_C_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (B),\n   .B             (C),\n   .go            (go),\n   .OUT           (gcd_bc),\n   .done          (done_bc)\n);\n\ngcd_top\n#( .WIDTH(WIDTH),\n   .SIGNED_EN(SIGNED_EN)\n) gcd_ABC_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (gcd_ab),\n   .B             (gcd_bc),\n   .go            (go_abc),\n   .OUT           (OUT),\n   .done          (done)\n);\n\nalways_ff @ (posedge clk) begin\n   if (rst) begin\n      done_ab_latched    <= 0;\n      done_bc_latched    <= 0;\n   end else begin\n      if(done_ab) begin\n         done_ab_latched <= done_ab;\n      end else if (go_abc) begin\n         done_ab_latched <= 0;\n      end\n\n      if(done_bc) begin\n         done_bc_latched <= done_bc;\n      end else if (go_abc) begin\n         done_bc_latched <= 0;\n      end\n   end\nend\n\nassign go_abc = done_ab_latched & done_bc_latched;\n\nendmodule\n\nmodule gcd_top #(\n   parameter WIDTH = 32,              // Parameter to define the bit-width of the input and output data\n   parameter SIGNED_EN = 1\n   )(\n   input                     clk,   // Clock signal\n   input                     rst,   // Active High Synchronous reset signal\n   input  [WIDTH-1:0]        A,     // Input operand A\n   input  [WIDTH-1:0]        B,     // Input operand B\n   input                     go,    // Start signal to begin GCD computation\n   output logic  [WIDTH-1:0] OUT,   // Output for the GCD result\n   output logic              done   // Signal to indicate completion of computation\n);\n\n   // Internal signals to communicate between control path and data path\n   logic equal;                     // Signal indicating A == B\n   logic greater_than;              // Signal indicating A > B\n   logic [1:0] controlpath_state;   // Current state of the control FSM\n\n   // Instantiate the control path module\n   gcd_controlpath gcd_controlpath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .go                (go),                // Connect go signal\n      .equal             (equal),             // Connect equal signal from datapath\n      .greater_than      (greater_than),      // Connect greater_than signal from datapath\n      .controlpath_state (controlpath_state), // Output current state to datapath\n      .done              (done)               // Output done signal\n   );\n\n   // Instantiate the data path module\n   gcd_datapath\n   #( .WIDTH(WIDTH),\n      .SIGNED_EN(SIGNED_EN)\n   ) gcd_datapath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .A                 (A),                 // Connect input A\n      .B                 (B),                 // Connect input B\n      .controlpath_state (controlpath_state), // Connect current state from control path\n      .equal             (equal),             // Output equal signal to control path\n      .greater_than      (greater_than),      // Output greater_than signal to control path\n      .OUT               (OUT)                // Output GCD result\n   );\nendmodule\n\n\n// Datapath module for GCD computation\nmodule gcd_datapath  #(\n   parameter WIDTH = 32,                           // Bit-width of operands\n   parameter SIGNED_EN = 1\n   )(\n   input                     clk,                // Clock signal\n   input                     rst,                // Active High Synchronous reset\n   input  [WIDTH-1:0]        A,                  // Input operand A\n   input  [WIDTH-1:0]        B,                  // Input operand B\n   input  [1:0]              controlpath_state,  // Current state from control path\n   output logic              equal,              // Signal indicating A_ff == B_ff\n   output logic              greater_than,       // Signal indicating A_ff > B_ff\n   output logic  [WIDTH-1:0] OUT                 // Output GCD result\n);\n\n   // Registers to hold intermediate values of A and B\n   logic [WIDTH-1:0] A_ff;\n   logic [WIDTH-1:0] B_ff;\n   logic [WIDTH-1:0] A_abs;\n   logic [WIDTH-1:0] B_abs;\n\n   // State encoding for control signals\n   localparam S0 = 2'd0;    // State 0: Initialization state\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff, subtract B_ff from A_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff, subtract A_ff from B_ff\n\n   always_comb begin\n      A_abs = A[WIDTH-1]? -A : A;\n      B_abs = B[WIDTH-1]? -B : B;\n   end\n\n   // Sequential logic to update registers based on controlpath_state\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         // On reset, initialize registers to zero\n         A_ff <= 'b0;\n         B_ff <= 'b0;\n         OUT  <= 'b0;\n      end else begin\n         case (controlpath_state)\n            S0: begin\n                // In state S0, load input values into registers\n                A_ff  <= SIGNED_EN? A_abs : A;\n                B_ff  <= SIGNED_EN? B_abs : B;\n             end\n            S1: begin\n                // In state S1, computation is done, output the result\n                OUT  <= A_ff;\n             end\n            S2: begin\n                // In state S2, A_ff > B_ff, subtract B_ff from A_ff\n                if (greater_than) begin\n                   if (~|B_ff) begin\n                       B_ff <= A_ff;\n                   end else begin\n                       A_ff <= A_ff - B_ff;\n                   end\n                end\n            end\n            S3: begin\n               // In state S3, B_ff > A_ff, subtract A_ff from B_ff\n               if (!equal & !greater_than) begin\n                  if(~|A_ff) begin\n                     A_ff <= B_ff;\n                  end else begin\n                     B_ff <= B_ff - A_ff;\n                  end\n               end\n            end\n            default: begin\n                A_ff <= 'b0;\n                B_ff <= 'b0;\n                OUT <= 'b0;\n            end\n         endcase\n      end\n   end\n\n   // Generating control response signals for the control path FSM\n   always_comb begin\n      case(controlpath_state)\n         S0: begin\n            // In state S0, compare initial input values A and B\n            if(SIGNED_EN) begin\n               equal        = (A_abs == B_abs)? 1'b1 : 1'b0;\n               greater_than = (A_abs >  B_abs)? 1'b1 : 1'b0;\n            end else begin\n               equal        = (A == B)? 1'b1 : 1'b0;\n               greater_than = (A >  B)? 1'b1 : 1'b0;\n            end\n         end\n         default: begin\n            // In other states, compare the current values in registers A_ff and B_ff\n            equal        = (A_ff == B_ff)? 1'b1 : 1'b0;\n            greater_than = (A_ff >  B_ff)? 1'b1 : 1'b0;\n         end\n      endcase\n   end\nendmodule\n\n// Control path module for GCD computation FSM\nmodule gcd_controlpath (\n   input                    clk,               // Clock signal\n   input                    rst,               // Active High Synchronous reset\n   input                    go,                // Start GCD calculation signal\n   input                    equal,             // From Datapath: A_ff equals B_ff\n   input                    greater_than,      // From Datapath: A_ff is greater than B_ff\n   output logic [1:0]       controlpath_state, // Current state to Datapath\n   output logic             done               // Indicates completion of GCD calculation\n);\n\n   // Internal state registers\n   logic [1:0] curr_state;  // Current state of FSM\n   logic [1:0] next_state;  // Next state of FSM\n\n   // State encoding\n   localparam S0 = 2'd0;    // State 0: Initialization or waiting for 'go' signal\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff\n\n   // State latching logic: Update current state on clock edge\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         curr_state   <= S0;   // On reset, set state to S0\n      end else begin\n         curr_state   <= next_state;   // Transition to next state\n      end\n   end\n\n   // State transition logic: Determine next state based on current state and inputs\n   always_comb begin\n      case(curr_state)\n         S0: begin\n            // State S0: Waiting for 'go' signal\n            if(!go)\n               next_state = S0;         // Remain in S0 until 'go' is asserted\n            else if (equal)\n               next_state = S1;         // If A == B, computation is complete\n            else if (greater_than)\n               next_state = S2;         // If A > B, go to state S2\n            else\n               next_state = S3;         // If B > A, go to state S3\n         end\n         S1: begin\n            // State S1: Computation complete, output the result\n            next_state = S0;           // Return to S0 after completion\n         end\n         S2: begin\n            // State S2: A_ff > B_ff, subtract B_ff from A_ff\n            if(equal)\n               next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n            else if (greater_than)\n               next_state = S2;         // If A_ff > B_ff, stay in S2\n            else\n               next_state = S3;         // If B_ff > A_ff, go to S3\n         end\n         S3: begin\n            // State S3: B_ff > A_ff, subtract A_ff from B_ff\n            if (equal)\n               next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n            else if (greater_than)\n               next_state = S2;         // If A_ff > B_ff, go to S2\n            else\n               next_state = S3;         // If B_ff > A_ff, stay in S3\n         end\n         default: begin\n             next_state = S0;\n         end\n      endcase\n   end\n\n   // Output logic: Generate 'done' signal when computation is complete\n   always_ff @ (posedge clk) begin\n      if(rst) begin\n         done <= 1'b0;               // On reset, 'done' is low\n      end else begin\n         done <= (curr_state == S1); // 'done' is asserted when in state S1\n      end\n   end\n\n   // Assign current state to output for datapath\n   assign controlpath_state = curr_state;\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Simulation didn't run correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage merge didn't run correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    try:\n        with open(\"/code/rundir/coverage.log\") as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage.log file.\")\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    print(\"Parsed Metrics:\")\n    print(metrics)\n\n    # Ensure TARGET environment variable is set\n    target = os.getenv(\"TARGET\")\n    if not target:\n        raise ValueError(\"TARGET environment variable is not set.\")\n    target = float(target)\n\n    # Check coverage for the DUT or specific key\n    dut = \"dut\"  # Replace this with the DUT key you want to check\n    if dut in metrics and \"Overall Average\" in metrics[dut]:\n        assert float(metrics[dut][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        # Log available keys for debugging\n        print(f\"Available keys in metrics: {metrics.keys()}\")\n        assert False, f\"Coverage data for '{dut}' is not available.\""}}}
{"id": "cvdp_copilot_gcd_0033", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `gcd_controlpath` module. The assertions should ensure that the module correctly handles state transitions and accurately tracks the completion of the GCD calculation.\n\n## **RTL Design Overview**  \nThe Greatest Common Divisor (GCD), also known as the Greatest Common Factor (GCF) or Highest Common Factor (HCF), is the largest positive integer that divides two or more integers without leaving a remainder.\n\nThis RTL design consists of the modules `gcd_top`, `gcd_controlpath`, and `gcd_datapath` that compute the GCD of two inputs, A and B, using the Euclidean algorithm. The Euclidean algorithm calculates the GCD by iteratively replacing the larger of two numbers with the difference between the two numbers. This process is repeated, reducing the larger number each time until the two numbers become equal. At this point, the value of either number is the GCD of the original inputs. The module is designed with a finite state machine (FSM) to control the computation and a datapath to perform arithmetic operations. The result of the computation is output as soon as the calculation completes, along with a signal indicating completion.\n\nThe `gcd_controlpath` module is responsible for maintaining the FSM required to perform the GCD calculation using the Euclidean algorithm.\n\n### **1. Key Components of the `gcd_controlpath` Module**       \n- **Inputs**:\n  - `clk`: Clock signal. The design is synchronized to the positive edge of this clock signal.\n  - `rst`: Active high synchronous reset signal.\n  - `go`: Start signal for GCD computation. Active high.\n  - `equal`: Signal from the datapath indicating that `A == B`. Active high.\n  - `greater_than`: Signal from the datapath indicating `A > B`. Active high.\n\n- **Outputs**:\n  - `controlpath_state [1:0]`: Current FSM state sent to the datapath to control its operations.\n  - `done`: Signal indicating that the computation is complete (`A == B`). Active high.\n\n- **FSM States**:\n  - **S0 (IDLE)**: Wait for `go` to be set high. No operation until `go` is received. When `go` is received at S0 state,\n     - Transition to S1: A is equal to B.\n     - Transition to S2: A is greater than B.\n     - Transition to S3: A is less than B.\n  - **S1 (DONE)**: Set `done` to high when `A == B`. Return to `S0` after the output is provided.\n     - Transition to S0.\n  - **S2 (A > B)**: Control the datapath to subtract `B` from `A`.\n     - Transition to S1: A_ff is equal to B_ff.\n     - Stay in S2: A_ff is  greater than B_ff.\n     - Transition to S3: A_ff is  less than B_ff.\n  - **S3 (B > A)**: Control the datapath to subtract `A` from `B`.\n     - Transition to S1: A_ff is equal to B_ff.\n     - Transition in S2: A_ff is  greater than B_ff.\n     - Stay to S3: A_ff is  less than B_ff.\n  - **Default**: Transition to the S0 state without performing any computation.\n  \n### **2. Key Components of the `gcd_datapath` Module**:  \n- **Inputs**:\n  - `clk`: Clock signal. The design should be synchronized to the positive edge of this clock signal.\n  - `rst`: Active high Synchronous reset signal.\n  - `A [WIDTH-1:0]`: input value A (unsigned and non-zero).\n  - `B [WIDTH-1:0]`: input value B (unsigned and non-zero).\n  - `controlpath_state [1:0]`: The current state of the control path FSM.\n\n- **Outputs**:\n  - `OUT [WIDTH-1:0]`: output holding the GCD value (unsigned). The value of `OUT` is updated every time the `done` signal is asserted. \n  - `equal`: Signal indicating that `A == B`. Active high.\n  - `greater_than`: Signal indicating that `A > B`. Active high.\n\n### **3. GCD Top Module (`gcd_top`)**:\n- **Inputs**:\n  - `clk`: Clock signal. The design should be synchronized to the positive edge of this clock signal..\n  - `rst`: Active high synchronous reset signal.\n  - `A [WIDTH-1:0]`: input value A (unsigned and non-zero). \n  - `B [WIDTH-1:0]`: input value B (unsigned and non-zero).\n  - `go`: Start signal to initiate GCD calculation. Active high.\n\n- **Outputs**:\n  - `OUT [WIDTH-1:0]`: output for the calculated GCD (unsigned) from `gcd_datapath`.\n  - `done`: Signal that indicates when the computation is complete from `gcd_controlpath`. \n  \n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Correct FSM behavior:** Ensure the design performs expected FSM state transitions in `gcd_controlpath` as described above.  \n- **Operations after `go`:** Ensure in the `gcd_controlpath` that initial state transitions occur only after `go` is asserted and in the `gcd_top` module, that whenever `go` is asserted, `done` eventually follows.\n- **Correct completion:** Ensure that the `done` signal is asserted at the correct `gcd_controlpath` FSM state.  \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/gcd_top.sv": "module gcd_top #(\n   parameter WIDTH = 4              // Parameter to define the bit-width of the input and output data\n   )(\n   input                     clk,   // Clock signal\n   input                     rst,   // Active High Synchronous reset signal\n   input  [WIDTH-1:0]        A,     // Input operand A\n   input  [WIDTH-1:0]        B,     // Input operand B\n   input                     go,    // Start signal to begin GCD computation\n   output logic  [WIDTH-1:0] OUT,   // Output for the GCD result\n   output logic              done   // Signal to indicate completion of computation\n);\n\n   // Internal signals to communicate between control path and data path\n   logic equal;                     // Signal indicating A == B\n   logic greater_than;              // Signal indicating A > B\n   logic [1:0] controlpath_state;   // Current state of the control FSM\n\n   // Instantiate the control path module\n   gcd_controlpath gcd_controlpath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .go                (go),                // Connect go signal\n      .equal             (equal),             // Connect equal signal from datapath\n      .greater_than      (greater_than),      // Connect greater_than signal from datapath\n      .controlpath_state (controlpath_state), // Output current state to datapath\n      .done              (done)               // Output done signal\n   );\n\n   // Instantiate the data path module\n   gcd_datapath\n   #( .WIDTH(WIDTH)\n   ) gcd_datapath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .A                 (A),                 // Connect input A\n      .B                 (B),                 // Connect input B\n      .controlpath_state (controlpath_state), // Connect current state from control path\n      .equal             (equal),             // Output equal signal to control path\n      .greater_than      (greater_than),      // Output greater_than signal to control path\n      .OUT               (OUT)                // Output GCD result\n   );\nendmodule\n\n\n// Datapath module for GCD computation\nmodule gcd_datapath  #(\n   parameter WIDTH = 4                           // Bit-width of operands\n   )(\n   input                     clk,                // Clock signal\n   input                     rst,                // Active High Synchronous reset\n   input  [WIDTH-1:0]        A,                  // Input operand A\n   input  [WIDTH-1:0]        B,                  // Input operand B\n   input  [1:0]              controlpath_state,  // Current state from control path\n   output logic              equal,              // Signal indicating A_ff == B_ff\n   output logic              greater_than,       // Signal indicating A_ff > B_ff\n   output logic  [WIDTH-1:0] OUT                 // Output GCD result\n);\n\n   // Registers to hold intermediate values of A and B\n   logic [WIDTH-1:0] A_ff;\n   logic [WIDTH-1:0] B_ff;\n\n   // State encoding for control signals\n   localparam S0 = 2'd0;    // State 0: Initialization state\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff, subtract B_ff from A_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff, subtract A_ff from B_ff\n\n   // Sequential logic to update registers based on controlpath_state\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         // On reset, initialize registers to zero\n         A_ff <= 'b0;\n         B_ff <= 'b0;\n         OUT  <= 'b0;\n      end else begin\n         case (controlpath_state)\n            S0: begin\n                // In state S0, load input values into registers\n                A_ff <= A;\n                B_ff <= B;\n             end\n            S1: begin\n                // In state S1, computation is done, output the result\n                OUT  <= A_ff;\n             end\n            S2: begin\n                // In state S2, A_ff > B_ff, subtract B_ff from A_ff\n                if (greater_than)\n                   A_ff <= A_ff - B_ff;\n             end\n            S3: begin\n                // In state S3, B_ff > A_ff, subtract A_ff from B_ff\n                if (!equal & !greater_than)\n                   B_ff <= B_ff - A_ff;\n             end\n            default: begin\n                A_ff <= 'b0;\n                B_ff <= 'b0;\n                OUT <= 'b0;\n            end\n         endcase\n      end\n   end\n\n   // Generating control response signals for the control path FSM\n   always_comb begin\n      case(controlpath_state)\n         S0: begin\n            // In state S0, compare initial input values A and B\n            equal        = (A == B)? 1'b1 : 1'b0;\n            greater_than = (A >  B)? 1'b1 : 1'b0;\n          end\n          default: begin\n            // In other states, compare the current values in registers A_ff and B_ff\n            equal        = (A_ff == B_ff)? 1'b1 : 1'b0;\n            greater_than = (A_ff >  B_ff)? 1'b1 : 1'b0;\n          end\n      endcase\n   end\nendmodule\n\n// Control path module for GCD computation FSM\nmodule gcd_controlpath (\n   input                    clk,               // Clock signal\n   input                    rst,               // Active High Synchronous reset\n   input                    go,                // Start GCD calculation signal\n   input                    equal,             // From Datapath: A_ff equals B_ff\n   input                    greater_than,      // From Datapath: A_ff is greater than B_ff\n   output logic [1:0]       controlpath_state, // Current state to Datapath\n   output logic             done               // Indicates completion of GCD calculation\n);\n\n   // Internal state registers\n   logic [1:0] curr_state;  // Current state of FSM\n   logic [1:0] next_state;  // Next state of FSM\n\n   // State encoding\n   localparam S0 = 2'd0;    // State 0: Initialization or waiting for 'go' signal\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff\n\n   // State latching logic: Update current state on clock edge\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         curr_state   <= S0;   // On reset, set state to S0\n      end else begin\n         curr_state   <= next_state;   // Transition to next state\n      end\n   end\n\n   // State transition logic: Determine next state based on current state and inputs\n   always_comb begin\n      case(curr_state)\n         S0: begin\n             // State S0: Waiting for 'go' signal\n             if(!go)\n                next_state = S0;         // Remain in S0 until 'go' is asserted\n             else if (equal)\n                next_state = S1;         // If A == B, computation is complete\n             else if (greater_than)\n                next_state = S2;         // If A > B, go to state S2\n             else\n                next_state = S3;         // If B > A, go to state S3\n         end\n         S1: begin\n             // State S1: Computation complete, output the result\n             next_state = S0;           // Return to S0 after completion\n         end\n         S2: begin\n             // State S2: A_ff > B_ff, subtract B_ff from A_ff\n             if(equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, stay in S2\n             else\n                next_state = S3;         // If B_ff > A_ff, go to S3\n         end\n         S3: begin\n             // State S3: B_ff > A_ff, subtract A_ff from B_ff\n             if (equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, go to S2\n             else\n                next_state = S3;         // If B_ff > A_ff, stay in S3\n         end\n         default: begin\n             next_state = S0;\n         end\n      endcase\n   end\n\n   // Output logic: Generate 'done' signal when computation is complete\n   always_ff @ (posedge clk) begin\n     if(rst) begin\n        done <= 1'b0;             // On reset, 'done' is low\n     end else begin\n        done <= (curr_state == S1); // 'done' is asserted when in state S1\n     end\n   end\n\n   // Assign current state to output for datapath\n   assign controlpath_state = curr_state;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/gcd_top.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/gcd_top.sv\nTOPLEVEL        = gcd_top\nMODULE          = test_gcd_top\nPYTHONPATH      = /src\nHASH            = 33-rtl-assertion-controlpath-2-input-gcd", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_gcd_top.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nfrom cocotb.regression import TestFactory\nimport random\n\n# Function to calculate GCD in software for comparison\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\n# Coroutine to reset the DUT\nasync def reset_dut(dut):\n    dut.rst.value = 1\n    dut.go.value  = 0\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    assert dut.OUT.value == 0, f\"Reset Test failed OUT Expected 0, got {int(dut.OUT.value)}\"\n    assert dut.done.value == 0, f\"Reset Test failed done Expected 0, got {int(dut.done.value)}\"\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n    assert dut.OUT.value == 0, f\"Reset Test failed OUT Expected 0, got {int(dut.OUT.value)}\"\n    assert dut.done.value == 0, f\"Reset Test failed done Expected 0, got {int(dut.done.value)}\"\n\n# Main GCD test coroutine\n@cocotb.test()\nasync def gcd_test(dut):\n    \"\"\" Test GCD calculation for different combinations of A and B \"\"\"\n    \n    # Start the clock with 10ns period\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    width  = int(dut.WIDTH.value)\n    max = (1 << width) - 1\n    # Reset the DUT\n    await reset_dut(dut)\n    \n    # Define test cases for non-zero, positive numbers\n    test_cases = [\n        (1, 1),    # GCD(1, 1) = 1\n        (4, 2),    # GCD(4, 2) = 2\n        (6, 3),    # GCD(6, 3) = 3\n        (15, 5),   # GCD(15, 5) = 5\n        (8, 4),    # GCD(8, 4) = 4\n        (9, 6),    # GCD(9, 6) = 3\n        (12, 8),   # GCD(12, 8) = 4\n        (14, 7),   # GCD(14, 7) = 7\n        (max, 1),   # (worst case for WIDTH )\n        (max, max)  # (best case for WIDTH )\n    ]\n    \n    # Test all pre-defined test cases\n    for A, B in test_cases:\n        # Apply inputs\n        dut.A.value  = A\n        dut.B.value  = B\n        dut.go.value = 1\n        latency      = 0\n        \n        # Wait for the `done` signal\n        await RisingEdge(dut.clk)\n        # Release go signal\n        dut.go.value = 0\n        await RisingEdge(dut.clk)\n        latency      = latency + 1\n        while (dut.done.value == 0):\n            await RisingEdge(dut.clk)\n            latency      = latency + 1\n        \n        # Compare the result with expected GCD\n        expected_gcd = gcd(A, B)\n        assert dut.OUT.value == expected_gcd, f\"Test failed with A={A}, B={B}. Expected {expected_gcd}, got {int(dut.OUT.value)}\"\n        if((A==2**width-1) & (B==1)):\n            assert latency == 2**width+1,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        elif((A==1) & (B==2**width-1)):\n            assert latency == 2**width+1,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        elif((A==B)):\n            assert latency == 2,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        await RisingEdge(dut.clk)\n        assert dut.done.value == 0, f\"Done should be high for only 1 clk cycle expected 0, got {int(dut.done.value)}\"\n        latency = 0\n    # Reset the DUT\n    await reset_dut(dut)\n        \n# Additional stress test with random values for A and B\n@cocotb.test()\nasync def gcd_stress_test(dut):\n    \"\"\" Stress test GCD calculation with random non-zero, positive values \"\"\"\n    \n    # Start the clock with 10ns period\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    latency      = 0\n    \n    # Reset the DUT\n    await reset_dut(dut)\n    \n    width  = int(dut.WIDTH.value)\n    \n    # Run random test cases\n    for _ in range(100):\n        A = random.randint(1, 2**width-1)  # A is positive number\n        B = random.randint(1, 2**width-1)  # B is positive number\n        latency = 0\n\n        # Apply inputs\n        dut.A.value  = A\n        dut.B.value  = B\n        dut.go.value = 1\n        \n        # Wait for the `done` signal\n        await RisingEdge(dut.clk)\n        # Release go signal\n        dut.go.value = 0\n        while (dut.done.value == 0):\n            await RisingEdge(dut.clk)\n            latency      = latency + 1\n        \n        # Compare the result with expected GCD\n        expected_gcd = gcd(A, B)\n        assert dut.OUT.value == expected_gcd, f\"Test failed with A={A}, B={B}. Expected {expected_gcd}, got {int(dut.OUT.value)}\"\n        if((A==2**width-1) & (B==1)):\n            assert latency == 2**width+1,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        elif((A==1) & (B==2**width-1)):\n            assert latency == 2**width+1,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        elif((A==B)):\n            assert latency == 2,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        \n        await RisingEdge(dut.clk)\n        assert dut.done.value == 0, f\"Done should be high for only 1 clk cycle expected 0, got {int(dut.done.value)}\"\n        latency = 0\n    \n    # Reset the DUT\n    await reset_dut(dut)", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.parametrize(\"WIDTH\", [random.randint(4, 6)])\ndef test_runner(WIDTH):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    parameters = { \"WIDTH\": WIDTH }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# if __name__ == \"__main__\":\n#     test_simulate()"}}}
{"id": "cvdp_copilot_generic_nbit_counter_0013", "categories": ["cid012", "easy"], "input": {"prompt": "Create a `tb_generic_counter` module that serves as the top-level testbench. This module should instantiate and include a `stimulus_generator` module, which must be developed to systematically drive different input conditions to the `generic_counter` module. The `stimulus_generator` should be designed to achieve 100% functional and code coverage by exercising all counting modes implemented in the `generic_counter`. These counting modes include binary up/down counting, modulo-N counting, Johnson counting, Gray code counting, and Ring counting. The counter operates based on an enable signal, a mode signal, and a configurable reference modulo value.\n\n---\n\nFollows the interface description of the RTL module.\n\n## **Inputs** \n \n- **Parameter**:  \n  - `N`: A configurable Parameter Value. The default Value is 8. \n\n- **Control Signals**:  \n  - `mode_in [2:0]`: A 3-bit register selecting the counter mode.  \n  - `enable_in`: A 1-bit register enabling the counter operation.  \n\n- **Clock Signal**:  \n  - `clk_in`: The counter updates its value on the rising edge of this clock signal.  \n\n- **Reset Signal**:  \n  - `rst_in`: A 1-bit asynchronous, active-high reset signal. When asserted HIGH, the counter resets to zero.  \n\n- **Reference Modulo Value**:  \n  - `ref_modulo [N-1:0]`: A configurable N-bit reference value used for modulo-N counting.  \n\n\n## **Outputs**  \n\n- **Registers**:  \n  - `o_count [N-1:0]`: An N-bit output representing the current counter value.  \n\n---\n\n## **Instantiation**  \n\n- **Module Instance**:  \n  - The `generic_counter` module is instantiated as `uut` in the testbench, with its inputs and outputs connected for testing.  \n\n---\n\n## **Input Generation**  \n\n1. **Mode Coverage**:  \n   - The testbench must ensure that all counting modes are exercised:  \n     - `BINARY_UP`: Counts up sequentially.  \n     - `BINARY_DOWN`: Counts down sequentially.  \n     - `MODULO_256`: Resets when `o_count == ref_modulo`.  \n     - `JOHNSON`: Implements Johnson's counter behavior.  \n     - `GRAY`: Converts binary count to Gray code.  \n     - `RING`: Implements a rotating one-hot sequence.  \n\n2. **Enable Behavior**:  \n   - Toggle `enable_in` dynamically and ensure that counting stops when `enable_in = 0`.  \n\n3. **Modulo-N Counting**:  \n   - Provide various `ref_modulo` values to the module.  \n\n4. **Reset Behavior**:  \n   - Test asynchronous reset by asserting `rst_in` during different counter states.  \n   - Ensure that `o_count` resets to zero when `rst_in` is active.  \n\n5. **Edge Cases**:  \n   - There will be a random transition between different counting modes during operation.  \n   - Initialize the RTL `count` register to a random value and run it in different modes.\n\n6. **Timing Requirements**:  \n   - After applying inputs, the testbench waits for a stabilization period of **300 clock cycles** before asserting new values.\n\n7. **Stimulus Generator IO Ports**:  \n\n- **`clk` (input, 1-bit)**: Clock signal synchronizes the stimulus generation process.\n- **`rst` (output, 1-bit)**: Active-high reset signal that initializes the `generic_counter` module.\n- **`mode` (output, 3-bit)**: Specifies the counting mode for the `generic_counter`. Different values correspond to different counting modes such as binary up/down, modulo-N, Johnson, Gray code, and Ring counting.\n- **`enable` (output, 1-bit)**: Enables the `generic_counter` operation when asserted high.\n- **`check_sync` (output, 1-bit)**: Indicates when to check the correctness of the counter output.\n- **`ref_modulo` (output, N-bit)**: Configurable modulo value, primarily used in modulo-N counting mode to define the counting range.\n\n---\n\n## **Module Functionality**  \n\n1. **Asynchronous Reset**:  \n   - When `rst_in` is asserted HIGH, `o_count` is reset to `0`.  \n\n2. **Counting Modes**:  \n   - The counter updates `o_count` based on `mode_in`:  \n     - **Binary Up/Down Counting**: Increments or decrements the counter.  \n     - **Modulo Counting**: Resets `o_count` when reaching `ref_modulo`.  \n     - **Johnson Counter**: Implements shift-and-invert behavior.  \n     - **Gray Code Counter**: Converts binary count to Gray code.  \n     - **Ring Counter**: Circulates a single `1` through the bit positions.  \n\n3. **Enable Control**:  \n   - If `enable_in = 0`, `o_count` remains unchanged.  \n\n---\n\n## **Testbench Features**  \n\n- **Input Scenarios**:  \n  - Cover all possible counter modes.  \n  - Randomize `mode_in`, `enable_in`, and `ref_modulo` to simulate diverse use cases.  \n\n- **Simulation Observations**:  \n  - Use `$monitor` to log counter transitions, mode changes, and reset events for debugging.  ", "context": {}}, "output": {"response": "", "context": {"verif/tb_generic_counter.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = f6bd528da7c299af11aceb77f495e5c4820a2dd2\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite\n", "src/generic_counter.sv": "\r\nmodule generic_counter #(parameter N = 8) (\r\n    input logic clk_in,          // Clock input\r\n    input logic rst_in,          // Active HIGH Reset input\r\n    input logic [2:0] mode_in,   // Mode input (3 bits)\r\n    input logic enable_in,       // Enable input\r\n    input logic [N-1:0] ref_modulo, // Reference modulo value for Modulo-N counter\r\n    output logic [N-1:0] o_count   // Output count (N bits)\r\n);\r\n\r\n    parameter BINARY_UP = 3'b000;\r\n    parameter BINARY_DOWN = 3'b001;\r\n    parameter MODULO_256 = 3'b010;\r\n    parameter JOHNSON = 3'b011;\r\n    parameter GRAY = 3'b100;\r\n    parameter RING = 3'b101;\r\n\r\n    logic [N-1:0] count;\r\n\r\n    always_ff @(posedge clk_in or posedge rst_in) begin\r\n        if (rst_in) begin\r\n            count <= {N{1'b0}};\r\n        end else if (enable_in) begin\r\n            case (mode_in)\r\n                BINARY_UP: begin\r\n                    count <= count + 1;\r\n                end\r\n                \r\n\t\tBINARY_DOWN: begin\r\n                    count <= count - 1;\r\n                end\r\n                \r\n\t\tMODULO_256: begin\r\n                    if (count == ref_modulo) begin\r\n                        count <= {N{1'b0}};\r\n                    end else begin\r\n                        count <= count + 1;\r\n                    end\r\n                end\r\n                \r\n\t\tJOHNSON: begin\r\n                    count <= {~count[0], count[N-1:1]};\r\n                end\r\n                \r\n\t\tGRAY: begin\r\n                    count <= count + 1;\r\n                end\r\n                \r\n\t\tRING: begin\r\n                    if (count == {N{1'b0}}) begin\r\n                        count <= {{(N-1){1'b0}}, 1'b1};\r\n                    end else begin\r\n                        count <= {count[N-2:0], count[N-1]};\r\n                    end\r\n                end\t\t\r\n                \r\n\t\tdefault: begin\r\n                    count <= {N{1'b0}};\r\n                end\r\n            endcase\r\n        end\r\n    end\r\n\r\n    \r\n    assign o_count = (mode_in == GRAY) ? ((count) ^ (count >> 1)) : count;\r\n\r\nendmodule\r\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_gf_multiplier_0045", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the `gf_multiplier` module to ensure its correct functionality during simulation?  The assertions should cover the key aspect of the Galois Field (GF) multiplication operation, ensuring that the output (`result`) remains within valid bounds (4 bits) after the polynomial multiplication and reduction steps.\n\n---\n\n## **Key Assertions**\n\n### **1. Result Within Valid Range**\n- **Condition**:  \n  - `result` should remain within 4 bits (`result < 16`), as we are operating in GF(2<sup>4</sup>).\n- **Assertion**:  \n  - If `result` exceeds `4'b1111`, an error message is displayed indicating that the value is out of bounds.\n\n- **Error Message**:  \n  - The display message includes the simulation time (`$time`) and the actual value of `result`.\n\n---\n\n## **Interface**\n\n### **Inputs**\n\n1. `A [3:0]`  \n   - 4-bit multiplicand in GF(2<sup>4</sup>).\n2. `B [3:0]`  \n   - 4-bit multiplier in GF(2<sup>4</sup>).\n\n### **Output**\n\n1. `result [3:0]`  \n   - 4-bit result after polynomial multiplication and reduction.\n\n---", "context": {"rtl/gf_multiplier.sv": "module gf_multiplier (\n    input [3:0] A,     // Multiplicand\n    input [3:0] B,     // Multiplier\n    output reg [3:0] result // Result\n);\n    reg [3:0] temp_result;\n    reg [4:0] multiplicand;\n    reg [4:0] irreducible_poly = 5'b10011; // Irreducible polynomial x^4 + x + 1\n\n    integer i;\n\n    always @(*) begin\n        temp_result = 4'b0000; // Initialize result to zero\n        multiplicand = {1'b0, A}; // Initialize multiplicand, adding an extra bit to handle overflow\n\n        // Perform multiplication using shift-and-add algorithm\n        for (i = 0; i < 4; i = i + 1) begin\n            if (B[i]) begin\n                temp_result = temp_result ^ multiplicand[3:0]; // XOR the multiplicand with result\n            end\n            multiplicand = multiplicand << 1; // Shift the multiplicand left by 1\n            if (multiplicand[4]) begin\n                multiplicand = multiplicand ^ irreducible_poly; // Polynomial reduction if overflow occurs\n            end\n        end\n\n        result = temp_result; // Output the final result\n    end\nendmodule"}}, "output": {"response": "", "context": {"rtl/gf_multiplier.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/gf_multiplier.sv\nTOPLEVEL        = gf_multiplier\nMODULE          = test_gf_mult\nPYTHONPATH      = /src\nHASH            = 45-assertion-for-4-bit-gf-multiplier\n", "src/test_gf_mult.py": "import cocotb\nfrom cocotb.triggers import Timer\nimport random\n\n# Function to perform GF(2^4) multiplication with polynomial reduction\ndef gf_mult(a, b):\n    irreducible_poly = 0b10011  # x^4 + x + 1 (10011 in binary)\n    result = 0\n\n    print(f\"Calculating GF(2^4) multiplication for A = {a:04b}, B = {b:04b}\")\n    \n    # Perform multiplication using shift-and-add method\n    for i in range(4):  # 4-bit multiplication\n        if (b >> i) & 1:\n            result ^= a << i  # Add shifted multiplicand\n            print(f\"  - Bit {i} of B is 1: result = result XOR (A << {i}) = {result:08b}\")\n\n    # Perform polynomial reduction if the result exceeds 4 bits\n    print(f\"  Before reduction: result = {result:08b}\")\n    for i in range(7, 3, -1):  # Start checking from bit 7 down to bit 4\n        if result & (1 << i):  # If the bit is set\n            result ^= irreducible_poly << (i - 4)  # XOR with irreducible polynomial\n            print(f\"  - Bit {i} of result is 1: result = result XOR (irreducible_poly << {i - 4}) = {result:08b}\")\n\n    final_result = result & 0b1111  # Return the final result (4 bits)\n    print(f\"  Final reduced result: {final_result:04b}\\n\")\n    return final_result\n\n# Test for GF(2^4) multiplier with known vectors\n@cocotb.test()\nasync def gf_multiplier_basic_test(dut):\n    \"\"\"Test the GF multiplier with known test vectors\"\"\"\n    \n    # Test vector: A = 3 (0011), B = 1 (0001)\n    A = 3\n    B = 1\n    expected_result = gf_mult(A, B)\n    dut.A.value = A\n    dut.B.value = B\n    await Timer(1, units='ns')  # Small delay to allow propagation\n\n    actual_result = dut.result.value\n    cocotb.log.info(f\"Basic Test: A = {A}, B = {B}, Expected = {expected_result}, Actual = {actual_result}\")\n    assert actual_result == expected_result, f\"Test failed: {A} * {B} = {actual_result}, expected {expected_result}\"\n\n    # Test vector: A = 3 (0011), B = 7 (0111)\n    A = 3\n    B = 7\n    expected_result = gf_mult(A, B)\n    dut.A.value = A\n    dut.B.value = B\n    await Timer(1, units='ns')\n\n    actual_result = dut.result.value\n    cocotb.log.info(f\"Basic Test: A = {A}, B = {B}, Expected = {expected_result}, Actual = {actual_result}\")\n    assert actual_result == expected_result, f\"Test failed: {A} * {B} = {actual_result}, expected {expected_result}\"\n\n    # Test vector: A = 15 (1111), B = 15 (1111)\n    A = 15\n    B = 15\n    expected_result = gf_mult(A, B)\n    dut.A.value = A\n    dut.B.value = B\n    await Timer(1, units='ns')\n\n    actual_result = dut.result.value\n    cocotb.log.info(f\"Basic Test: A = {A}, B = {B}, Expected = {expected_result}, Actual = {actual_result}\")\n    assert actual_result == expected_result, f\"Test failed: {A} * {B} = {actual_result}, expected {expected_result}\"\n\n@cocotb.test()\nasync def gf_multiplier_random_test(dut):\n    \"\"\"Test the GF multiplier with random values\"\"\"\n    \n    # Perform 20 random tests\n    for i in range(20):\n        A = random.randint(0, 15)  # Random 4-bit value\n        B = random.randint(0, 15)  # Random 4-bit value\n        print(f\"Random Test {i + 1}: A = {A:04b}, B = {B:04b}\")\n        expected_result = gf_mult(A, B)  # Use the GF multiplication logic\n\n        dut.A.value = A\n        dut.B.value = B\n\n        await Timer(1, units='ns')  # Allow propagation delay\n\n        actual_result = dut.result.value\n        cocotb.log.info(f\"Random Test {i + 1}: A = {A}, B = {B}, Expected = {expected_result}, Actual = {actual_result}\")\n        assert actual_result == expected_result, f\"Random test failed: {A} * {B} = {actual_result}, expected {expected_result}\"", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}}
{"id": "cvdp_copilot_gf_multiplier_0047", "categories": ["cid012", "medium"], "input": {"prompt": "Create a testbench to generate stimuli for the `gf_mac` module, which computes a byte-wide Galois Field (2<sup>8</sup>) multiply-accumulate function over two `WIDTH`-bit inputs (`a` and `b`). The module also supports a passthrough mode and provides status signals for validity, readiness, and error indication.\n\n---\n## Description\n\nThe `gf_mac` module processes two input values by breaking them into 8-bit segments and multiplies each corresponding segment in GF(2<sup>8</sup>). The partial products are then XORed together to form an 8-bit accumulation result (`result`). A passthrough mode is included, allowing direct output of `a[7:0]` instead of the GF multiply-accumulate result. The module provides the `valid_result` and `ready` signals to indicate when the output can be sampled, and sets `error_flag` if the specified `WIDTH` is not a multiple of 8.\n\n---\n## Inputs\n\n### **1. Parameters**\n- **`WIDTH`**  \n  - **Type**: Integer parameter  \n  - **Default / Typical**: 32  \n  - **Purpose**: Defines the bit width of inputs `a` and `b`. Must be a multiple of 8 for proper GF(2<sup>8</sup>) segmentation.  \n  - **Impact**: If `WIDTH` is not divisible by 8, the module asserts `error_flag` and forces the result output to `8'b0`.  \n\n### **2. Registers / Signals for Stimulus**\n- **`reset`**  \n  - **Bit Width**: 1  \n  - **Purpose**: Asynchronous reset signal. When asserted, internal registers and outputs are forced to their default state.  \n  - **Usage**: Drives the module to initialize or clear state before applying new inputs.\n\n- **`enable`**  \n  - **Bit Width**: 1  \n  - **Purpose**: Activation signal to start the multiply-accumulate process. When low, the outputs remain at default values.  \n  - **Usage**: Driven high for normal operation or low to hold outputs in an inactive state.\n\n- **`pass_through`**  \n  - **Bit Width**: 1  \n  - **Purpose**: Mode selector. When set, the module outputs `a[7:0]` directly, bypassing the GF multiply-accumulate logic.  \n  - **Usage**: Driven high or low to test both normal GF MAC operation and pass-through behavior.\n\n- **`a [WIDTH-1:0]`**  \n  - **Bit Width**: `WIDTH` (e.g., 32 bits by default)  \n  - **Purpose**: First input operand for the GF MAC calculation or direct source (when `pass_through` is set).  \n  - **Usage**: Driven with a variety of patterns (random, edge, corner cases) to exercise the internal GF segments.\n\n- **`b [WIDTH-1:0]`**  \n  - **Bit Width**: `WIDTH` (e.g., 32 bits by default)  \n  - **Purpose**: Second input operand for the GF MAC calculation, partitioned into 8-bit segments for multiplication.  \n  - **Usage**: Driven alongside `a` to cover different multiply-accumulate scenarios in GF(2<sup>8</sup>).\n\n---\n## Outputs\n\n- **`result [7:0]`**  \n  - **Bit Width**: 8  \n  - **Purpose**: Final 8-bit accumulation of GF(2<sup>8</sup>) partial products or direct pass-through from `a[7:0]` when `pass_through` is set.  \n  - **Usage**: Observed after applying stimulus to determine the outcome of the GF MAC or pass-through operation.\n\n- **`valid_result`**  \n  - **Bit Width**: 1  \n  - **Purpose**: Indicates that `result` is valid when `enable` is asserted and `WIDTH` is a multiple of 8.  \n  - **Usage**: Sampled to confirm that the output is ready and valid in the current cycle.\n\n- **`ready`**  \n  - **Bit Width**: 1  \n  - **Purpose**: Mirrors `valid_result` in this design. Signals the environment that the module has produced the final output.  \n  - **Usage**: Observed to coordinate data flow, especially if additional handshake logic is applied.\n\n- **`error_flag`**  \n  - **Bit Width**: 1  \n  - **Purpose**: Asserts high when `WIDTH` is not divisible by 8. Remains low if `WIDTH` is valid.  \n  - **Usage**: Checked to detect or log configuration errors or unsupported widths during stimulus application.\n\n---\n## Instantiation\n\nA single instance of the `gf_mac` module can be created, supplying `reset`, `enable`, `pass_through`, `a`, and `b` as stimulus inputs and capturing `result`, `valid_result`, `ready`, and `error_flag` as outputs. The parameter `WIDTH` can be set to 32 or other multiples of 8 to explore different valid configurations, or to a non-multiple of 8 to observe the `error_flag` behavior.\n\n---\n## Input Generation and Observations\n\n1. **Deterministic Stimuli**  \n   - **Zero Inputs**: Apply `a=0`, `b=0` with `enable=1`, checking if the module outputs `0x00`.  \n   - **Simple Patterns**: Use known 8-bit segments repeated across `a` and `b` (e.g., `0x00000001`, `0xFFFFFFFF`) to observe repeated partial multiplications.  \n   - **Pass-Through Mode**: Set `pass_through=1` and apply different values to `a` to confirm that `result` matches `a[7:0]`.\n\n2. **Toggle Reset**  \n   - Assert `reset` for a period before releasing it, ensuring the module clears its outputs to default and deasserts `error_flag` unless `WIDTH` is invalid.\n\n3. **Valid and Invalid `WIDTH` Tests**  \n   - Use a `WIDTH` multiple of 8 (e.g., 32) to keep `error_flag` low and observe proper GF MAC operation.  \n   - Optionally modify `WIDTH` to a non-multiple of 8 in a separate simulation run to observe `error_flag` assertion and forced zero output.\n\n4. **Random Stimuli**  \n   - Generate random patterns for `a` and `b` to stress the partial products across the 8-bit segments.  \n   - Randomly switch `enable` and `pass_through` to exercise state transitions while capturing the resultant behavior.\n\n5. **Timing Intervals**  \n   - Change inputs at defined or random time steps (e.g., 5\u201310 time units) to capture the module\u2019s combinational output.  \n   - Log and compare results after each stimulus to observe the correlation with input patterns.\n\n---\n## Module Interface\n\n### **Inputs**\n- **`reset` (1 bit)**: Active-high reset for the internal state.\n- **`enable` (1 bit)**: Activates the GF MAC operation when high.\n- **`pass_through` (1 bit)**: Selects direct pass of `a[7:0]` vs. GF MAC accumulation.\n- **`a [WIDTH-1:0]`**: First operand for the GF(2<sup>8</sup>) accumulate or pass-through data.\n- **`b [WIDTH-1:0]`**: Second operand for the GF(2<sup>8</sup>) accumulate.\n\n### **Outputs**\n- **`result [7:0]`**: 8-bit GF MAC output or direct pass of `a[7:0]`.\n- **`valid_result` (1 bit)**: Indicates a valid `result` when `enable` is high and `WIDTH` is valid.\n- **`ready` (1 bit)**: Mirrors the `valid_result` signal.\n- **`error_flag` (1 bit)**: High if `WIDTH` is invalid (not multiple of 8), otherwise low.\n\n---\n## Module Functionality\n\n- **GF MAC Calculation**  \n  - When `enable` is high and `pass_through` is low, the module slices `a` and `b` into 8-bit segments and multiplies each pair using a GF(2<sup>8</sup>) multiplier. The partial products are XORed to produce `result`.\n\n- **Pass-Through Mode**  \n  - When `pass_through` is high and `enable` is high, the 8-bit portion `a[7:0]` is directly mapped to `result`. \n\n- **Readiness & Validity**  \n  - The signals `valid_result` and `ready` both indicate that the output is finalized and stable under valid conditions (`WIDTH % 8 == 0`).\n\n- **Error Indication**  \n  - The signal `error_flag` is asserted if `WIDTH` is not divisible by 8. In that case, `result` is forced to `8'b0`, and `valid_result` remains low.\n\n---\n## Additional Notes\n\n- **GF Multiplier Usage**: Internally, the module instantiates multiple `gf_multiplier` blocks (one per 8-bit segment of `a` and `b`) to compute partial products.\n- **Coverage of Corner Cases**: Stimuli can include values with alternating bits, large or small decimal representations, and identical inputs for both `a` and `b` to exercise the reduction logic in the GF multipliers.\n- **Scalability**: The parameterizable `WIDTH` allows the environment to explore larger or smaller inputs, provided the requirement (`WIDTH % 8 == 0`) is satisfied.", "context": {}}, "output": {"response": "", "context": {"verif/gf_mac_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = d6607a8bd6315fd792b07574d43b38cdd1cd3bab\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/gf_mac.sv": "`timescale 1ns/1ps\nmodule gf_mac#(parameter WIDTH=32)(\n    input reset,\n    input enable,\n    input pass_through,\n    input [WIDTH-1:0] a,\n    input [WIDTH-1:0] b,\n    output [7:0] result,\n    output valid_result,\n    output ready,\n    output error_flag\n);\n    localparam WIDTH_VALID = (WIDTH % 8 == 0);\n\n    reg [7:0] result_reg;\n    reg [7:0] mux_result;\n\n    assign error_flag = (reset) ? 1'b0 : (!WIDTH_VALID);\n    assign valid_result = (reset) ? 1'b0 : ((enable && WIDTH_VALID) ? 1'b1 : 1'b0);\n    assign ready = (reset) ? 1'b0 : ((enable && WIDTH_VALID) ? 1'b1 : 1'b0);\n    assign result = (reset) ? 8'b0 : mux_result;\n\n    generate\n        if (WIDTH_VALID) begin : gen_valid\n            integer i;\n            reg [7:0] temp_result;\n            wire [7:0] partial_results[(WIDTH/8)-1:0];\n            genvar j;\n            for (j = 0; j < WIDTH/8; j = j + 1) begin: gen_segments\n                gf_multiplier u_gf_multiplier(\n                    .A(a[(j+1)*8-1 : j*8]),\n                    .B(b[(j+1)*8-1 : j*8]),\n                    .result(partial_results[j])\n                );\n            end\n            always @(*) begin\n                temp_result = 8'b0;\n                if (!reset && enable && !pass_through) begin\n                    for (i = 0; i < WIDTH/8; i = i + 1) begin\n                        temp_result = temp_result ^ partial_results[i];\n                    end\n                end\n                result_reg = temp_result;\n            end\n        end\n    endgenerate\n\n    always @(*) begin\n        if (!WIDTH_VALID) begin\n            result_reg = 8'b0;\n        end\n        if (!reset && enable && pass_through && WIDTH_VALID) begin\n            mux_result = a[7:0];\n        end else if (!reset && enable && WIDTH_VALID) begin\n            mux_result = result_reg;\n        end else begin\n            mux_result = 8'b0;\n        end\n    end\nendmodule\n\n\nmodule gf_multiplier(\n    input [7:0] A,\n    input [7:0] B,\n    output reg [7:0] result\n);\n    reg [7:0] temp_result;\n    reg [8:0] multiplicand;\n    localparam [8:0] IRREDUCIBLE_POLY = 9'b100011011;\n    integer i;\n    always @(*) begin\n        temp_result = 8'b0;\n        multiplicand = {1'b0, A};\n        for (i = 0; i < 8; i = i + 1) begin\n            if (B[i]) begin\n                temp_result = temp_result ^ multiplicand[7:0];\n            end\n            multiplicand = multiplicand << 1;\n            if (multiplicand[8]) begin\n                multiplicand = multiplicand ^ IRREDUCIBLE_POLY;\n            end\n        end\n        result = temp_result;\n    end\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    for line in lines[2:]:\n        info = line.split()\n        while len(info) < 3:\n            info.append(\"0%\")\n        inst = re.sub(r'[\\W]', '', info[0])\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'dut' is missing in the coverage log.\")\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))\n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['dut']['Average']}, Target: {target}\""}}}
{"id": "cvdp_copilot_gray_to_binary_0014", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench for the `gray_to_binary` module, which converts an N-bit Gray code input into its N-bit binary equivalent using combinational logic. The testbench must have the instantiation of RTL module and generate stimulus for various test conditions.\n\n### Interface of gray_to_binary RTL Module\n\n**Parameter:**\n  - `WIDTH`: Width of the Gray code(`Default: 4`)\n\n**Inputs:**\n  - `gray_in [WIDTH-1:0]`: The Gray code input that needs to be converted into binary.\n\n**Outputs:**\n  - `binary_out [WIDTH-1:0]`: The corresponding binary output derived from the Gray code input.\n\n## \n### Input Generation and Validation\n\n1. Fixed Test Cases\n    - Test a variety of Gray code inputs, including:\n      - Boundary values (0, `max value`)\n      - Alternating bit patterns (`0101`, `1010`)\n      - Power-of-two values to check conversion correctness.\n    - Example test values:\n      - `0000`, `0001`, `0011`, `0110`, `1111`, `1000`, `1100`, `1010`.\n\n2. Randomized Testing\n    - Generate random Gray code values and compare them against a reference binary conversion function.\n\n3. Edge Cases\n    - Minimum Input (`gray_in = 0`) \u2192 Expected Binary Output: `0000`\n    - Maximum Input (`gray_in = 1111`) \u2192 Expected Binary Output: `1000`\n    - One-bit change transitions:\n      - `0001 \u2192 0000`\n      - `0011 \u2192 0010`\n      - `0111 \u2192 0100`\n    - Ensures that only one bit changes at a time.\n___\n### Instantiation\nInstantiate the RTL module inside the testbench and name the instance as `uut`.\n\n##\n### Module Functionality\n\n1. XOR-Based Conversion Logic\n    - The MSB of `binary_out` is directly assigned from gray_in's MSB.\n    - Each subsequent bit is computed as:\n                `B[i]=B[i+1] XOR G[I]`\n\n2. Test One-Bit Change Property\n    - Ensure that each successive Gray code value only changes one bit when converted back to binary.\n   ", "context": {}}, "output": {"response": "", "context": {"verif/tb_gray_to_binary.sv": ""}}, "harness": {"files": {"docker-compose.yml": "\nservices:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 0eef2298523a980bd1d86b2705da865b3e91f662\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/gray_to_binary.sv": "`timescale 1ns / 1ps\n\nmodule gray_to_binary #(\n    parameter WIDTH = 4\n) (\n    input  logic [WIDTH-1:0] gray_in,    // Gray code input\n    output logic [WIDTH-1:0] binary_out  // Binary output\n);\n\n  always @* begin\n    binary_out[WIDTH-1] = gray_in[WIDTH-1];\n    for (int i = WIDTH - 2; i >= 0; i = i - 1) begin\n      binary_out[i] = binary_out[i+1] ^ gray_in[i];\n    end\n  end\n\nendmodule\n\n", "src/process.py": "import os\r\nimport re\r\nimport subprocess\r\nimport pytest\r\n\r\n# ----------------------------------------\r\n# - Simulate\r\n# ----------------------------------------\r\n\r\n@pytest.mark.usefixtures(scope='session')\r\ndef test_simulate():\r\n\r\n    cmd = \"xrun -coverage all /src/gray_to_binary.sv /code/verif/tb_gray_to_binary.sv -covtest test -seed random -covoverwrite\"\r\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\r\n\r\n# ----------------------------------------\r\n# - Generate Coverage\r\n# ----------------------------------------\r\n\r\n@pytest.mark.usefixtures(scope='test_simulate')\r\ndef test_coverage():\r\n\r\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\r\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\r\n\r\n# ----------------------------------------\r\n# - Report\r\n# ----------------------------------------\r\n\r\n@pytest.mark.usefixtures(scope='test_coverage')\r\ndef test_report():\r\n\r\n    metrics = {}\r\n\r\n    with open(\"/code/rundir/coverage.log\") as f:\r\n        lines = f.readlines()\r\n\r\n    # ----------------------------------------\r\n    # - Evaluate Report\r\n    # ----------------------------------------\r\n\r\n    for line in lines[2:]:\r\n        info = line.split()\r\n\r\n        inst = info [0]\r\n        avg  = info [1]\r\n        cov  = info [2]\r\n\r\n        inst = re.sub(r'[\\W]', '', inst)\r\n\r\n        metrics [inst] = {\r\n            \"Average\" : float(avg[:-1]),\r\n            \"Covered\" : float(cov[:-1])\r\n        }\r\n\r\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_grayscale_image_0019", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the SystemVerilog testbench **`tb_conv3x3`** to include a checker that verifies the correctness of the **`conv3x3`** module. The testbench already comprises stimulus generator to execute multiple test cases of 3x3 convolution. Enhance the testbench by including checker by comparing `convolved_data` against a reference model, flagging mismatches using `$display` and `$error`. Ensure the functionality validation with edge cases (uniform images, single-pixel influence, weighted kernels, reset behavior) and randomized testing for robustness.\n\n---\n\n## Design Specification\n\n- The module **accepts 8-bit pixel values** and **8-bit kernel weights** as inputs and produces a **16-bit convolved output** to accommodate larger sum values.  \n- **Element-wise multiplication** is performed between the image pixels and kernel weights, ensuring accurate convolution computation.  \n- The computed sum is **normalized by dividing by 9**, ensuring proper averaging in the convolution process.  \n- The module is designed for pipelined operation, where computations occur in a combinational block, and the final output is registered on the clock edge.  \n- A proper **reset mechanism initializes the output to zero**, ensuring a known starting state when `rst_n` is asserted low.  \n\n---\n\n### **Interfaces**\n\n#### **Input Signals**  \n\n- **`clk`**: Design work based on posedege of clockSystem clock.  \n- **`rst_n`**: Active-low **asynchronous reset**.  \n- **`image_data0`** to **`image_data8`** (**8-bit each**): Represents a **3x3 image patch**, where:  \n  - `image_data0 [7:0]` \u2192 Top-left pixel  \n  - `image_data1 [7:0]` \u2192 Top-middle pixel  \n  - `image_data2 [7:0]` \u2192 Top-right pixel  \n  - `image_data3 [7:0]` \u2192 Middle-left pixel  \n  - `image_data4 [7:0]` \u2192 Center pixel  \n  - `image_data5 [7:0]` \u2192 Middle-right pixel  \n  - `image_data6 [7:0]` \u2192 Bottom-left pixel  \n  - `image_data7 [7:0]` \u2192 Bottom-middle pixel  \n  - `image_data8 [7:0]` \u2192 Bottom-right pixel  \n\n- **`kernel0`** to **`kernel8`** (**8-bit each**): Represents the **3x3 convolution kernel**, applied to the image patch in the same order. \n  \n#### **Kernel Signals **  \n\n- **`kernel0 [7:0]`** \u2192 Weight for the **top-left** pixel  \n- **`kernel1 [7:0]`** \u2192 Weight for the **top-middle** pixel  \n- **`kernel2 [7:0]`** \u2192 Weight for the **top-right** pixel  \n- **`kernel3 [7:0]`** \u2192 Weight for the **middle-left** pixel  \n- **`kernel4 [7:0]`** \u2192 Weight for the **center** pixel  \n- **`kernel5 [7:0]`** \u2192 Weight for the **middle-right** pixel  \n- **`kernel6 [7:0]`** \u2192 Weight for the **bottom-left** pixel  \n- **`kernel7 [7:0]`** \u2192 Weight for the **bottom-middle** pixel  \n- **`kernel8 [7:0]`** \u2192 Weight for the **bottom-right** pixel  \n\nEach kernel value corresponds to a specific position in the 3x3 convolution operation and determines the weighted sum of the respective image pixels.  \n\n#### **Output Signals**  \n\n- **`convolved_data [15:0]`**: 16-bit output representing the **convolution result** after applying the kernel to the image patch.  \n\n\n---\n\n## **Testbench checker  Specification**\nThe `conv3x3` module processes the convolution using **matrix multiplication**, where:\n[text{convolved\\_data} = \\sum_{i=0}^{8} (\\text{image\\_data}[i] \\times \\text{kernel}[i]) \\div 9]\n\n\n### 1. 3x3 Convolution Operation\nThe module performs a **3x3 convolution** by multiplying each input pixel value with a corresponding kernel weight and summing the results.\n\n### 2. Summation and Normalization\nThe computed **sum of the products** is divided by **9** to normalize the result before outputting it.\n\n### 3. Clocked Output Registering\nThe final **convolved output** is stored in a register and updated **on the rising edge of the clock**, ensuring synchronized data output.\n\n### 4. Reset Behavior\nWhen **reset (`rst_n`) is asserted low**, the convolved output is reset to zero, ensuring a known starting state.\n\nThis checker ensures the design's correctness and robustness by testing various input cases, including edge cases and randomized stress testing.\n\n\n---\n\n### **Checker Test Cases**\nThe testbench validates the following **critical scenarios**:\n\n### **1. Reset Behavior**\n- **Test**: Assert `rst_n = 0` and verify that `convolved_data` is reset to `0`.\n- **Expected Output**: `convolved_data = 0`.\n\n### **2. Basic Convolution Check**\n- **Test**: Input an image of all `9`s and a kernel of all `1`s.\n- **Expected Output**:  \n  - Sum: \\( 9+9+9+9+9+9+9+9+9 = 81 \\)\n  - Division by 9: \\( 81/9 = 9 \\)\n  - **`convolved_data` should be `9`**.\n\n### **3. Edge Case \u2013 Single Nonzero Pixel**\n- **Test**: A single `9` in the last pixel with a kernel containing a `1` in the same location.\n- **Expected Output**:  \n  - Sum: \\( 9 \\times 1 = 9 \\)\n  - Division by 9: \\( 9/9 = 1 \\)\n  - **`convolved_data` should be `1`**.\n\n### **4. Kernel with Different Weights**\n- **Test**: Kernel with varying weight factors (e.g., `1,2,0,0,0,0,0,0,0`).\n- **Expected Output**:  \n  - Ensures correct **weighting in the convolution calculation**.\n\n### **5. Large Values (Max Inputs)**\n- **Test**: `image_data` and `kernel` filled with **255**.\n- **Expected Output**:  \n  - Detects **overflow handling** in `conv3x3`.\n\n### **6. Randomized Testing (600 Iterations)**\n- **Test**: Randomized values for `image_data` and `kernel` for stress testing.\n- **Expected Output**:  \n  - Ensures **robustness** and **numerical accuracy**.\n\n---\n\n### **Testbench Components**\n**1. DUT Instantiation**\n   - Instantiate the `conv3x3` module with the necessary signals.\n   \n**2. Clock Generation**\n   - A **10 ns clock period** (`#5 clk = ~clk;`).\n\n**3. Reference Model**\n   - Implements the **expected convolution operation** for comparison.\n\n**4. Stimulus Application**\n   - A **task-based mechanism** (`apply_stimulus`) for structured input testing.\n\n**5. Output Checking**\n   - The testbench checker  **compares DUT output** with the reference model.\n\n**6. Simulation Control**\n   - Runs all test cases sequentially and prints the results.\n\n---\n\n### *Checker Expected Outputs**\nFor each test case, the testbench:\n1. Verifies **convolution correctness**.\n2. Confirms **reset behavior**.\n3. Checks **overflow and edge cases**.\n4. **Logs mismatches** with detailed error messages.\n5. **Ends the simulation** after all tests.\n\n---\n\n## **Deliverables**\n\n-  Complete SystemVerilog checker testbench code**:\n-  Includes **DUT instantiation, clock, reset logic, and behavioral model**.\n-  Structured test scenarios** validating different operations.\n-  Error messages** if mismatches occur, otherwise a pass message.\n-  Automatic completion of simulation** using `$finish`.\n\n---", "context": {"verif/tb.sv": "module tb_conv3x3;\n\n    // Clock and reset\n    logic clk;\n    logic rst_n;\n\n    // UUT inputs\n    logic [7:0] image_data[8:0];\n    logic [7:0] kernel[8:0];\n\n    // UUT output\n    logic [15:0] convolved_data;\n\n    // Clock generation (10ns period)\n    always #5 clk = ~clk;\n\n    // Instantiate the UUT\n    conv3x3 uut (\n        .clk(clk),\n        .rst_n(rst_n),\n        .image_data0(image_data[0]), .image_data1(image_data[1]), .image_data2(image_data[2]),\n        .image_data3(image_data[3]), .image_data4(image_data[4]), .image_data5(image_data[5]),\n        .image_data6(image_data[6]), .image_data7(image_data[7]), .image_data8(image_data[8]),\n        .kernel0(kernel[0]), .kernel1(kernel[1]), .kernel2(kernel[2]),\n        .kernel3(kernel[3]), .kernel4(kernel[4]), .kernel5(kernel[5]),\n        .kernel6(kernel[6]), .kernel7(kernel[7]), .kernel8(kernel[8]),\n        .convolved_data(convolved_data)\n    );\n\n    // Task to apply test cases\n    task apply_stimulus(input logic [7:0] img [8:0], input logic [7:0] kern [8:0]);\n        begin\n            image_data = img;\n            kernel = kern;\n\n            #10; // Wait for output\n            \n            $display(\"Test Case: Image = %p, Kernel = %p, Output = %d\",\n                     img, kern, convolved_data);\n        end\n    endtask\n\n    // Reset and test sequence\n    initial begin\n        clk = 0;\n        rst_n = 0;\n        $display(\"Starting Testbench...\");\n\n        #10 rst_n = 1;\n        #5  rst_n = 0;\n        #5  rst_n = 1;\n        $display(\"Reset De-asserted\");\n\n        // Apply various test cases\n        apply_stimulus('{0, 0, 0, 0, 0, 0, 0, 0, 0}, '{0, 0, 0, 0, 0, 0, 0, 0, 0});\n        $display(\"Test 1 completed.\");\n        apply_stimulus('{255, 255, 255, 255, 255, 255, 255, 255, 255}, '{255, 255, 255, 255, 255, 255, 255, 255, 255});\n        $display(\"Test 2 completed.\");\n        apply_stimulus('{255, 255, 255, 255, 255, 255, 255, 255, 255}, '{-1, -1, -1, -1, 8, -1, -1, -1, -1});\n        $display(\"Test 3 completed.\");\n        apply_stimulus('{255, 0, 255, 0, 255, 0, 255, 0, 255}, '{255, 0, 255, 0, 255, 0, 255, 0, 255});\n        $display(\"Test 4 completed.\");\n\n        apply_stimulus('{0, 0, 0, 0, 0, 0, 0, 0, 8}, '{0, 0, 0, 0, 1, 0, 0, 0, 0});\n        $display(\"Test 5 completed.\");\n        apply_stimulus('{0, 0, 0, 0, 0, 0, 0, 0, 9}, '{0, 0, 0, 0, 1, 0, 0, 0, 0});\n        $display(\"Test 6 completed.\");\n        apply_stimulus('{0, 0, 0, 0, 0, 0, 0, 0, 17}, '{0, 0, 0, 0, 1, 0, 0, 0, 0});\n        $display(\"Test 7 completed.\");\n\n        image_data[0] = 100; kernel[0] = 100;\n        #5;  \n        rst_n = 0;  \n        #10;\n        rst_n = 1;\n        #20;\n        $display(\"Test 8 completed.\");\n\n        apply_stimulus('{128, 128, 128, 128, 128, 128, 128, 128, 128},\n                       '{128, 128, 128, 128, 128, 128, 128, 128, 128});\n        $display(\"Test 9 completed.\");\n\n        // Randomized Testing (600 iterations)\n        repeat (600) begin\n            logic [7:0] img_data[9];\n            logic [7:0] kern_data[9];\n\n            foreach (img_data[i]) img_data[i] = $urandom_range(0, 255);\n            foreach (kern_data[i]) kern_data[i] = $urandom_range(0, 255);\n\n            apply_stimulus(img_data, kern_data);\n        end\n        $display(\"Randomized testing completed.\");\n\n        $display(\"Testbench Complete\");\n        $finish;\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/conv3x3.sv \nHASH            = 0cba405aaee3050eef8fded715a8027c3966d57b\nNUM_BUGS        = 3\n", "src/conv3x3.sv": "module conv3x3 (\n    input logic          clk,               // Clock signal\n    input logic          rst_n,             // Reset signal, active low\n    input logic  [7:0]   image_data0,       // Individual pixel data inputs (8-bit each)\n    input logic  [7:0]   image_data1,\n    input logic  [7:0]   image_data2,\n    input logic  [7:0]   image_data3,\n    input logic  [7:0]   image_data4,\n    input logic  [7:0]   image_data5,\n    input logic  [7:0]   image_data6,\n    input logic  [7:0]   image_data7,\n    input logic  [7:0]   image_data8,\n    input logic  [7:0]   kernel0,           // Individual kernel inputs (8-bit each)\n    input logic  [7:0]   kernel1,\n    input logic  [7:0]   kernel2,\n    input logic  [7:0]   kernel3,\n    input logic  [7:0]   kernel4,\n    input logic  [7:0]   kernel5,\n    input logic  [7:0]   kernel6,\n    input logic  [7:0]   kernel7,\n    input logic  [7:0]   kernel8,\n    output logic [15:0]  convolved_data     // 16-bit convolved output\n);\n\n    logic [15:0] mult_result [0:8];\n    logic [19:0] sum_result;         // Stores the sum of the products\n    logic [15:0] normalized_result;  // Stores the normalized result\n\n    always_comb begin\n        // Compute element-wise multiplication\n        `ifndef BUG_0\n        mult_result[0] = image_data0 * kernel0;\n        mult_result[1] = image_data1 * kernel1;\n        mult_result[2] = image_data2 * kernel2;\n        mult_result[3] = image_data3 * kernel3;\n        mult_result[4] = image_data4 * kernel4;\n        mult_result[5] = image_data5 * kernel5;\n        mult_result[6] = image_data6 * kernel6;\n        mult_result[7] = image_data7 * kernel7;\n        mult_result[8] = image_data8 * kernel8;\n        `else\n        // BUG: Using XOR instead of multiplication\n        mult_result[0] = image_data0 ^ kernel0;\n        mult_result[1] = image_data1 ^ kernel1;\n        mult_result[2] = image_data2 ^ kernel2;\n        mult_result[3] = image_data3 ^ kernel3;\n        mult_result[4] = image_data4 ^ kernel4;\n        mult_result[5] = image_data5 ^ kernel5;\n        mult_result[6] = image_data6 ^ kernel6;\n        mult_result[7] = image_data7 ^ kernel7;\n        mult_result[8] = image_data8 ^ kernel8;\n        `endif\n\n        // Compute summation of all multiplied values\n        `ifndef BUG_1\n        sum_result = mult_result[0] + mult_result[1] + mult_result[2] +\n                     mult_result[3] + mult_result[4] + mult_result[5] +\n                     mult_result[6] + mult_result[7] + mult_result[8];\n        `else\n        // BUG: Incorrect summation (subtracting some terms)\n        sum_result = mult_result[0] + mult_result[1] - mult_result[2] +\n                     mult_result[3] + mult_result[4] - mult_result[5] +\n                     mult_result[6] + mult_result[7] - mult_result[8];\n        `endif\n    end\n\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            `ifndef BUG_2\n            convolved_data <= 16'd0;\n            normalized_result <= 16'd0;\n            `else\n            // BUG: Incorrect reset value\n            convolved_data <= 16'd255;\n            normalized_result <= 16'd255;\n            `endif\n        end else begin\n            `ifndef BUG_3\n            normalized_result <= sum_result / 9;\n            convolved_data <= normalized_result;\n            `else\n            // BUG: Incorrect normalization divisor (dividing by 8 instead of 9)\n            normalized_result <= sum_result / 8;\n            convolved_data <= normalized_result;\n            `endif\n        end\n    end\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_hamming_code_tx_and_rx_0029", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench that only supplies stimulus to a `hamming_code_tx_for_4bit` module, which encodes 4-bit input data `data_in` into an 8-bit output `data_out` using Hamming code principles for error detection and correction. Hamming code helps generate parity bits, which are combined with the original data to detect and correct single-bit errors.\n\n\n---\n## **Testbench Description**\n\n**Inputs**\n\n- Registers: `data_in` is a 4-bit register that provides binary inputs to the module.\n\n**Outputs**\n\n- Wire: An 8-bit wire, `data_out`, with 4 data bits, 3 parity bits and an extra redundant bit added to pad the output to 8 bits.\n\n---\n\n## **Instantiation**\n\n- Module Instance: The `hamming_code_tx_for_4bit` module should be instantiated as **uut_transmitter**, with the input and output signals connected for testing.\n\n---\n\n## **Input Generation and Validation**\n\n- Input Generation: The testbench must generate pairs of 4-bit binary values for `data_in` to cover all possibilities, including corner cases.\n- Corner cases Input Generation: The testbench must generate pairs of 4-bit binary values from minimum value 0 to maximum 2<sup>4</sup> - 1\n- Stabilization Period: After setting each pair of inputs, the testbench waits 10 time units to ensure the outputs have stabilized before asserting new values.\n\n---\n\n## **RTL Specification:**\n\n1. **Module interface:** \n\n- Input:\n     `data_in[3:0]`: A 4-bit input signal representing the original data to be transmitted.\n- Output:\n     `data_out[7:0]`: An 8-bit output signal representing the encoded data.\n\n\n2. **Module Functionality**:\n\nThe module encodes the data based on the following steps:\n\n1. `data_out[0]`: This bit is fixed to 0 as a redundant bit.\n2. `data_out[1]`, `data_out[2]` `data_out[4]`: Parity bits , calculated using the XOR operation to ensure even parity of specific input bits.\n3. `data_out[3]`, `data_out[5]`, `data_out[6]`, `data_out[7]`: These are assigned `data_in[0]`, `data_in[1]`, `data_in[2]`, `data_in[3]` respectively, preserving the order of the input data.\n   \n3 **Timing and Synchronization:**\n- This design is purely combinational. The output must be immediately updated with a change in the input.", "context": {}}, "output": {"response": "", "context": {"verif/testbench_for_tx.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 7d500602776b97b13e1cc97c3218c229ab1483b4\nTARGET = 91\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html\n", "src/hamming_code_tx_for_4bit.sv": "module hamming_code_tx_for_4bit( \n  input[3:0] data_in,\n  output[7:0] data_out\n);\n  assign data_out[0] = 1'b0;\n  assign data_out[1] = data_in[0] ^ data_in[1] ^ data_in[3]; // 2^0\n  assign data_out[2] = data_in[0] ^ data_in[2] ^ data_in[3]; // 2^1\n  assign data_out[3] = data_in[0];\n  assign data_out[4] = data_in[1] ^ data_in[2] ^ data_in[3]; // 2^2\n  assign data_out[5] = data_in[1];\n  assign data_out[6] = data_in[2];\n  assign data_out[7] = data_in[3];\nendmodule \n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/hamming_code_tx_for_4bit.sv /code/verif/testbench_for_tx.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut_transmitter\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_hamming_code_tx_and_rx_0031", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench to only supply stimulus to a `hamming_code_receiver` module. This module decodes an 8-bit input signal and detects single-bit errors using Hamming code principles. The receiver performs \"even parity checks\" to identify single-bit errors in `data_in` and provides corrected 4-bit data through the output port `data_out[3:0]`.\n\n---\n\n### **RTL Specification**\n\n#### 1. **Module Interface**\n\n**Inputs:**  \n- `data_in[7:0]` \u2013 An 8-bit input signal containing 4 data bits, 3 parity bits, and 1 redundant bit.\n\n**Output:**  \n- `data_out[3:0]` \u2013 A 4-bit output signal containing the corrected data if an error is detected. If no error is detected, the output mirrors the data bits in the input (`data_in`).\n\n#### 2. **Module Functionality**\n\nThe module uses Hamming code principles to detect and correct single-bit errors in the 8-bit input (`data_in`). The organization of bits in the input is as follows:  \n- **Parity Bits:** Placed at positions that are powers of 2 in `data_in`:\n  - `data_in[1]` (2<sup>0</sup> = 1),  \n  - `data_in[2]` (2<sup>1</sup> = 2),  \n  - `data_in[4]` (2<sup>2</sup> = 4).  \n- **Data Bits:** Placed sequentially in positions that are not powers of 2:\n  - `data_in[3]`, `data_in[5]`, `data_in[6]`, and `data_in[7]`.\n\n#### 2.1. **Error Detection and Correction**\n\n- The module calculates three syndrome bits (`c1`, `c2`, `c3`) using XOR operations on specific data and parity bits from `data_in`. These syndrome bits indicate the position of any error within the 7 most significant bits (`data_in[7:1]`).\n- If an error is detected, the incorrect bit is corrected.  \n\n#### 2.2. **Output Assignment**\n\n- After error correction, the module retrieves the 4 data bits from the corrected input and assigns them to the output port `data_out[3:0]`.  \n- The positions of the data bits in the input correspond to:\n  - `data_in[3]`, `data_in[5]`, `data_in[6]`, and `data_in[7]`.\n\n#### 3. **Timing and Synchronization**\n\n- The design is purely combinational, meaning the output is updated immediately after any change in the input.\n\n\n\n---\n\n### **Testbench Requirements**\n\n- **Module Instance:** The `hamming_code_receiver` module should be instantiated as **`uut_receiver`**, with input and output signals connected for testing.\n\n---\n\n### **Input Generation and Validation**\n\n1. **Input Generation:**  \n   - The testbench should generate all possible 4-bit binary values for input data (ranging from the minimum value (0) to the maximum value (2<sup>4</sup> - 1)) and extend it to include encoding bits before supplying the stimulus to the design, ensuring coverage of both typical cases and edge cases.  \n\n3. **Golden Encoder Logic:**  \n   - Inputs provided to the module should follow a specific pattern similar to data generated from a transmitter following hamming code principles. It should also ensure that erroneous input data is supplied with only single-bit errors (as the RTL is capable of correcting only single-bit errors)\n   - The testbench should encode the generated 4-bit data into an 8-bit data (golden encoded data) using Hamming code principles for error detection.  \n   - The encoding process based on Hamming code principles is as follows:  (Assume the 4-bit data generated internally is `data_in` and it is extended to `golden_data_out`)\n     1. **`golden_data_out[0]`**: A redundant bit, fixed at 0.  \n     2. **`golden_data_out[1]`**: Parity bit ensuring even parity (XOR) for the input bits at positions `data_in[0]`, `data_in[1]`, and `data_in[3]`.  \n     3. **`golden_data_out[2]`**: Parity bit ensuring even parity (XOR) for the input bits at positions `data_in[0]`, `data_in[2]`, and `data_in[3]`.  \n     4. **`golden_data_out[4]`**: Parity bit ensuring even parity (XOR) for the input bits at positions `data_in[1]`, `data_in[2]`, and `data_in[3]`.  \n     5. **`golden_data_out[3]`, `golden_data_out[5]`, `golden_data_out[6]`, `golden_data_out[7]`**: These are the data bits `data[0]`, `data[1]`, `data[2]`, and `data[3]` respectively, in the same order.  \n   - To simulate errors, a single bit in the **golden encoded data** must be randomly modified. This modified data should then be assigned to the input of the design under test (**`uut_receiver`**).  \n\n4. **Stabilization Period:**  \n   - After assigning each input value, the testbench must wait for 10 time units to ensure that the outputs have stabilized before asserting new values.  \n\n---", "context": {}}, "output": {"response": "", "context": {"verif/testbench_for_hamming_rx.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 72ca8649c47feda1ef5faa77f8121b7d54429dac\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html\n", "src/hamming_code_receiver.sv": "module hamming_code_receiver (\n  input[7:0] data_in,\n  output [3:0] data_out\n);\n \n  wire c1,c2,c3,error;\n  reg[7:0] correct_data;\n \n \n  assign c3 =  data_in[1] ^ data_in[3] ^ data_in[5] ^ data_in[7];\n  assign c2 =  data_in[2] ^ data_in[3] ^ data_in[6] ^ data_in[7];\n  assign c1 =  data_in[4] ^ data_in[5] ^ data_in[6] ^ data_in[7];\n \n  assign error = ({c3,c2,c1}==3'b000) ? 1'b0 : 1'b1;\n \n  always@(*)\n  begin\n    correct_data = 0;\n    if(error)\n    begin\n      correct_data             = data_in;\n      correct_data[{c1,c2,c3}] = ~correct_data[{c1,c2,c3}];\n    end\n    else\n    begin\n      correct_data             = data_in;\n    end\n  end\n \n assign data_out = {correct_data[7],correct_data[6],correct_data[5],correct_data[3]};\n \nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/hamming_code_receiver.sv /code/verif/testbench_for_hamming_rx.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut_receiver\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_hamming_code_tx_and_rx_0035", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the given testbench, `testbench_for_tx`, for validating the output of a SystemVerilog design `hamming_code_tx_for_4bit` that is responsible for encoding a 4-bit input, designated as `data_in`, into an 8-bit output, identified as `data_out`, utilizing Hamming code methodologies aimed at error detection and correction. The Hamming code mechanism produces parity bits that, when combined with the original data, facilitate the identification and rectification of single-bit errors. The testbench already contains the logic for stimulus generation and it should be modified to add the checker logic that validates the output from this stimulus.\n\n## **Design specification**\n\nThe design is a transmitter module that encodes 4-bit input data (`data_in`) into an 8-bit output (`data_out`) with 3 parity bits and an extra redundant bit added to pad the output 8 bits. \n\nThe parity bits are calculated using XOR operations to ensure \"even parity,\" which guarantees that the number of 1s in specified bit groups is even. They are placed at bit positions corresponding to powers of 2 in the output structure (positions 1, 2, and 4 in this 8-bit layout), allowing for targeted error detection.\n\n### 1. Input/Output Specifications:\n\n1. Input:\n     `data_in[3:0]`: A 4-bit input signal representing the original data to be transmitted.\n2. Output:\n     `data_out[7:0]`: An 8-bit output signal representing the encoded data.\n\n### 2. Behavioral Definition:\n\nThe module should encode the data based on the following steps:\n\n1. `data_out[0]`: This bit is fixed to 0 as a redundant bit.\n2. `data_out[1]`: This is a parity bit, calculated using the XOR operation to ensure even parity of the input bits (`data_in`) at positions 0, 1, and 3 of `data_in`.\n3. `data_out[2]`: Another parity bit, calculated using XOR for even parity, but this time based on input bits (`data_in`) at positions 0, 2, and 3 of `data_in`.\n4. `data_out[4]`: A third parity bit, also using XOR for even parity, calculated based on input bits (`data_in`) at positions 1, 2, and 3 of `data_in`.\n5. `data_out[3]`, `data_out[5]`, `data_out[6]`, `data_out[7]`: These are assigned `data_in[0]`, `data_in[1]`, `data_in[2]`, `data_in[3]` respectively, preserving the order of the input data.\n\n### 3. Timing and Synchronization:\nThis design is purely combinational. The output must be immediately updated with a change in the input.\n\n## **Testbench Description**\n\n**Inputs**\n\n- Registers: The `data_in` is a 4-bit register that delivers binary inputs to the module.\n\n**Outputs**\n\n- Wire: An 8-bit wire, `data_out`, containing 4 data bits, 3 parity bits, and an additional redundant bit to ensure the output is padded to 8 bits.\n\n---\n\n## **Instantiation**\n\n- Module Instance: The `hamming_code_tx_for_4bit` module is instantiated under the name **uut_transmitter**, with appropriate connections established for testing the input and output signals.\n\n## **Input Generation and Validation**\n\n- Input Generation: The testbench must use the given test cases that produce 4-bit binary values for `data_in` to encompass all potential cases, including edge conditions.\n- **Golden Data Generation Task**:  A new task, `generate_golden_data`, should be introduced to formulate the reference data based on the current `data_in`, adhering to Hamming code principles for error detection.  \n- **Stabilization Period:**  \n   - Following the assignment of each `data_in` value and the generation of reference data, the testbench must pause for **10 time units** to guarantee that `data_out` stabilizes prior to the validation process.  \n- **Validation Process**:\n   - The testbench must verify whether the `data_out` from `uut_transmitter` aligns with the reference generated for each testcase.\n   - In the event of a match, a success message should be displayed using `$display`.\n   - If a discrepancy is found, an error message should be displayed through the `$error` system task, and display the mismatch along with the anticipated and received values.\n   - The testbench should also track the total number of passing and failing test cases using separate counters.\n\n- **Simulation Summary**: Upon conclusion of the test, the total number of successful and unsuccessful validations should be displayed.", "context": {"verif/testbench_for_tx.sv": "module testbench_for_tx;\n\n  reg [3:0] data_in;         // Input for the transmitter\n  wire [7:0] data_out;       // Output from the transmitter\n  \n  parameter TEST_CASE = 20;\n\n  // Instantiate the transmitter module\n  hamming_code_tx_for_4bit uut_transmitter (\n    .data_in(data_in),\n    .data_out(data_out)\n  );\n  \ninteger i;\n  initial \n  begin\n    $dumpfile(\"dump.vcd\");\n    $dumpvars(1);\n    \n    // Generate and test multiple sets of corner case data\n    $display(\"-------corner case-------------------\");\n\n    for (i = 0; i < 2**4; i = i + 1) begin\n    \n      // Generate random 4-bit data\n      data_in = i;  // Generates a random number between 0 and 15\n\n      // Display the original data\n      $display(\"FROM TESTBENCH: Original 4-bit data: %b\", data_in);\n\n      // Wait for the transmitter to process the data\n      #10;\n\n      // Print the transmitted 8-bit data\n      $display(\"FROM DESIGN: Transmitted 8-bit data: %b\", data_out);\n  \n    end\n    \n    $display(\"-------------random case----------------------\");\n    // Generate and test multiple sets of random case data\n    for (i = 0; i < TEST_CASE; i = i + 1) begin\n    \n      // Generate random 4-bit data\n      data_in = $random;  // Generates a random number between 0 and 15\n\n      // Display the original data\n      $display(\"FROM TESTBENCH: Original 4-bit data: %b\", data_in);\n\n      // Wait for the transmitter to process the data\n      #10;\n\n      // Print the transmitted 8-bit data\n      $display(\"FROM DESIGN: Transmitted 8-bit data: %b\", data_out);\n  \n    end\n    $display(\"-----------------------------------\");\n\n    $finish; // End the simulation\n  end\n\nendmodule\n"}}, "output": {"response": "", "context": {"verif/testbench_for_tx.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH            = eeb7adeeb35afb73d2d4083d1d6f103356929028\nNUM_BUGS        = 5\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html\n", "src/hamming_code_tx_for_4bit.sv": "module hamming_code_tx_for_4bit( \n  input[3:0] data_in,\n  output[7:0] data_out\n);\n\n`ifndef BUG_0\n    assign data_out[0] = 1'b0;\n`else\n    assign data_out[0] = 1'b1;\n`endif\n\n`ifndef BUG_1\n    assign data_out[1] = data_in[0] ^ data_in[1] ^ data_in[3]; // 2^0\n`else\n    assign data_out[1] = data_in[0] ^ data_in[2] ^ data_in[3]; // 2^0\n`endif\n\n`ifndef BUG_2\n    assign data_out[2] = data_in[0] ^ data_in[2] ^ data_in[3]; // 2^1\n`else\n    assign data_out[2] = data_in[0] ^ data_in[1] ^ data_in[3]; // 2^1\n`endif\n\n`ifndef BUG_3\n    assign data_out[4] = data_in[1] ^ data_in[2] ^ data_in[3]; // 2^2\n`else\n    assign data_out[4] = data_in[1] ^ data_in[0] ^ data_in[3]; // 2^2\n`endif\n\n`ifndef BUG_4\n  assign data_out[3] = data_in[0];\n  assign data_out[5] = data_in[1];\n  assign data_out[6] = data_in[2];\n  assign data_out[7] = data_in[3];\n`else\n  assign data_out[3] = data_in[3];\n  assign data_out[5] = data_in[2];\n  assign data_out[6] = data_in[1];\n  assign data_out[7] = data_in[0];\n`endif\n\nendmodule \n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/hamming_code_tx_for_4bit.sv /code/verif/testbench_for_tx.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_hamming_code_tx_and_rx_0037", "categories": ["cid012", "easy"], "input": {"prompt": "Develop a SystemVerilog testbench named `testbench_for_hamming_rx` to only supply stimuli to and achieve maximum possible coverage for an RTL design named  `hamming_rx` . The module is a **parameterized Hamming code receiver** that takes an encoded input signal (`data_in`), which contains **data bits, parity bits, and a redundant bit**, and detects and corrects **only single-bit errors**. The corrected data is then assigned to `data_out`. Error detection and correction are performed using Hamming code principles, specifically **even parity checks (XOR operations)**.  \n\n---\n### **RTL Specification for `hamming_rx`**\n\n#### Parameterization:\n- **DATA_WIDTH**: Specifies the width of the data input, configurable by the user. The default is 4 and should be greater than 0.\n- **PARITY_BIT**: Specifies the number of parity bits, also configurable by the user. The default is 3.\n  - The **number of parity bits** should be the minimum integer value that satisfies the Hamming code formula:\n    [2<sup>p</sup>  >= (p + m) + 1], where m is the number of data bits and p is the number of parity bits.\n    For example, if `m = 4`:\n    - `p = 0` results in \\(2<sup>0</sup>  >= 0 + 5\\), which is false.\n    - `p = 1` results in \\(2<sup>1</sup>  >= 1 + 5\\), which is false.\n    - `p = 2` results in \\(2<sup>2</sup>  >= 2 + 5\\), which is false.\n    - `p = 3` results in \\(2<sup>3</sup>  >= 3 + 5\\), which is true and the minimum value to satisfy the condition\n- **ENCODED_DATA**: Calculated as the sum of `PARITY_BIT + DATA_WIDTH + 1`, representing the total input width according to the Hamming code formula.\n    - `+1` accounts for the \"no error\" state in the input (`data_in`) by adding a redundant bit as the least significant bit.\n    - For example, if `m = 4` and `p = 3`, then `ENCODED_DATA = 8`.\n- **ENCODED_DATA_BIT**: Calculated as the minimum number of bits required to index `ENCODED_DATA`.\n  - For example, if `m = 4`, `p = 3`, and `ENCODED_DATA = 8`, then `ENCODED_DATA_BIT = 3`.\n\n#### Input/Output Specifications:\n- **Inputs:**\n  - `data_in[ENCODED_DATA-1:0]`: Encoded data containing the redundant bit, original data, and parity bits.\n- **Outputs:**\n  - `data_out[DATA_WIDTH-1:0]`: An output signal containing the corrected data if an error is detected. If no error is detected, this output will mirror the data bits in the Encoded input (`data_in`).\n\n#### Behavioral Definitions:\n   - The number of parity bits is determined based on the configured `PARITY_BIT` parameter.  \n   - Each parity bit is calculated by performing an XOR operation over specific bits in `data_in`.\n   - Individual parity bits are combined into an error detection code, which represents the parity check result.  \n   - Based on the parity check result  \n       - The design locates and inverts the erroneous bit position at the error location.  \n       - Note: The redundant bit at position 0 is not inverted.  \n4. **Output Assignment**:\n      - The data bits are retrieved from the internal **corrected data** and assigned to `data_out` from least significant bit (LSB) to most significant bit (MSB), with the lowest-index bit picked from the corrected data mapped to the LSB of `data_out`, progressing to the MSB. This ensures that `data_out` contains only the **corrected data bits, excluding the parity bits and the redundant bit**. \n\n### **Testbench Description**\n\n#### **Instantiation**\n\n- **Module Instance:** The `hamming_rx` module should be instantiated as **`uut_receiver`**, with parameters, input and output signals connected for testing.\n\n--- \n### **Input Generation and Validation**\n\n1. **Input Generation:**  \n   - The testbench should generate all possible DATA_WIDTH-bit binary values for input data (ranging from the minimum value (0) to the maximum value (2<sup>DATA_WIDTH</sup> - 1)) and extend it to include encoding bits before supplying the stimulus to the design, ensuring coverage of both typical cases and edge cases.  \n\n3. **Golden Encoder Logic:**  \n   - Inputs provided to the module should follow a specific pattern similar to data generated from a transmitter following Hamming code principles. It should also ensure that erroneous input data is supplied with only single-bit errors (as the RTL is capable of correcting only single-bit errors)\n   \n   - The testbench should encode the generated DATA_WIDTH-bit data into an ENCODED_DATA-bit data (golden encoded data). The encoding process based on Hamming code principles is explained in the Hamming code transmitter specification given below.  \n   \n        **Hamming code transmitter function:** This function takes an input `[DATA_WIDTH-1:0] input_data` and generates an encoded output `[ENCODED_DATA-1:0] temp_data`.\n        \n        1. **Step 1**: Clear all internal registers to 0, including an internal PARITY_BIT-width array named `parity` for holding calculated parity bit values.\n        2. **Step 2**: Assign `input_data` to `temp_data`.\n           - Parity bits are placed at `temp_data` positions corresponding to powers of 2. (e.g., indices 2<sup>0</sup> = 1, 2<sup>1</sup> = 2, 2<sup>2</sup> = 4, etc.) and  `temp_data[0]` is a redundant bit which is always set to 1'b0.\n           - The bits of `input_data` are mapped sequentially, starting from the least significant bit (LSB) to the most significant bit (MSB), into the non-parity and non-redundant positions of `temp_data`. The LSB of `input_data` aligns with the lowest-index non-parity and non-redundant position in `temp_data`, and the order of the bits is preserved.\n           - Example:\n             - For `DATA_WIDTH = 4` and `PARITY_BIT = 3`, `ENCODED_DATA` is 8, and `ENCODED_DATA_BIT` is 3:\n             - The `temp_data` assignment is as follows:\n               - `temp_data[0]` - position 000 - assign **1'b0**.\n               - `temp_data[1]` - position 001 - reserve for **parity[0]**.\n               - `temp_data[2]` - position 010 - reserve for **parity[1]**.\n               - `temp_data[3]` - position 011 - assign `input_data[0]`.\n               - `temp_data[4]` - position 100 - reserve for **parity[2]**.\n               - `temp_data[5]` - position 101 - assign `input_data[1]`.\n               - `temp_data[6]` - position 110 - assign `input_data[2]`.\n               - `temp_data[7]` - position 111 - assign `input_data[3]`.\n        3. **Step 3**: Calculate the even parity bits based on the Hamming code principle.\n           - Define **PARITY_BIT** (e.g., for `PARITY_BIT = 3`, calculate `parity[0]`, `parity[1]`, and `parity[2]`).\n           - Each parity bit calculation: For each parity bit `parity[n]` (where n ranges from 0 to PARITY_BIT-1), determine its value by performing an XOR operation on the bits in `temp_data` located at indices where the n<sup>th</sup> bit (counting from the least significant bit) of the binary index is 1. For example:\n             -  `parity[0]` includes all indices where the least significant bit (LSB) of the binary index is 1. (positions 00**1**, 01**1**, 10**1**, and 11**1** in `temp_data`).\n                 - Calculation: `parity[0] = XOR of temp_data[1], temp_data[3], temp_data[5], temp_data[7]`.\n             -   `parity[1]` includes indices where the second bit from the LSB of the binary index is 1, and so forth. (positions 0**1**0, 0**1**1, 1**1**0, and 1**1**1 in `temp_data`).\n                 - Calculation: `parity[1] = XOR of temp_data[2], temp_data[3], temp_data[6], temp_data[7]`.\n        4. **Step 4**: Insert the calculated parity bits into `temp_data` at positions corresponding to powers of 2.\n          \n   - To simulate errors, a single bit in the **golden encoded data** (generated from the transmitter function above) should be randomly modified. This modified data is then assigned to the input `data_in[ENCODED_DATA-1:0]` of the design under test (**`uut_receiver`**).  \n\n4. **Stabilization Period:**  \n   - After assigning each input value, the testbench should wait for at least 10 time units to ensure that the outputs have stabilized before asserting new values.  ", "context": {}}, "output": {"response": "", "context": {"verif/testbench_for_hamming_rx.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 37-tb_for_stimulus_tx\nTARGET = 97\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite\n", "src/hamming_rx.sv": "module hamming_rx \n#(\n  parameter DATA_WIDTH   = 4,\n  parameter PARITY_BIT   = 3,\n  parameter ENCODED_DATA = PARITY_BIT + DATA_WIDTH + 1,\n  parameter ENCODED_DATA_BIT = $clog2(ENCODED_DATA)\n)\n(\n  input  [ENCODED_DATA-1:0] data_in, \n  output reg [DATA_WIDTH-1:0] data_out\n);\n  \n  localparam PARITY = $clog2(PARITY_BIT);\n  \n  reg [PARITY_BIT-1:0] parity;\n  reg [PARITY:0] j;\n  reg [$clog2(DATA_WIDTH)-1:0] count;\n  reg [ENCODED_DATA-1:0] corrected_data;\n\n  reg [ENCODED_DATA_BIT:0] i,k;\n  \n  always @(*) \n  begin\n    parity        = {PARITY_BIT{1'b0}};\n    data_out      = {DATA_WIDTH{1'b0}};\n    i             = {1'b1,{ENCODED_DATA_BIT{1'b1}}};\n    j             = {1'b1,{PARITY{1'b1}}};\n    k             = {1'b1,{ENCODED_DATA_BIT{1'b1}}};\n    count         = 0;\n    corrected_data = data_in;\n\n\n    for (j = 0; j < PARITY_BIT; j = j + 1) \n    begin\n      for (i = 1; i < ENCODED_DATA; i = i + 1) \n      begin\n        if ((i & (1 << j)) != 0) \n        begin\n          parity[j] = parity[j] ^ data_in[i];\n        end\n      end\n    end\n    \n    corrected_data[parity] = (|parity) ? ~corrected_data[parity] : corrected_data[parity];\n\n    for (k = 1; k < ENCODED_DATA; k = k + 1) \n    begin\n      if ((k & (k - 1)) != 0) \n      begin \n        data_out[count] = corrected_data[k];\n        count = count + 1;\n      end\n    end\n  end\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/hamming_rx.sv /code/verif/testbench_for_hamming_rx.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut_receiver\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_hebbian_rule_0020", "categories": ["cid012", "medium"], "input": {"prompt": "Create a SystemVerilog testbench module named `tb_hebb_gates` that instantiates the `hebb_gates` module as the Unit Under Test (UUT). The testbench must include a stimulus generator that systematically drives various input conditions to achieve a minimum of 95% code and functional coverage for the `hebb_gates` module. The `hebb_gates` implements a Moore Finite State Machine (FSM) to train a Hebbian learning model. The module takes signed 4-bit inputs (`a` and `b`), a 2-bit gate selector, and control signals for starting the FSM and resetting the system. It sequentially performs training steps such as weight initialization, target selection, weight/bias updates, and convergence checks using the Hebbian learning rule. The module outputs the updated weights (`w1` and `w2`), bias, and the FSM's current and next state. The system uses a gate selection module to determine the target outputs based on logical gate operations for training.\n\n## Design Specifications:\n- Hebbian rule is a type of unsupervised neural network learning algorithm\n\n## Abstract Algorithm:\n- The hebbian or hebb rule works based on the following algorithm\n\n-  **Step 1**: Initialize all the weights and bias to zero.\n                                  w<sub>I</sub> = 0 for i = 1 to n, n is the number of input vectors\n\n- **Step 2**: For each input training vector and target output pair, do the following:\n\n    - **Step 2a**: Set activation for input units\n                         x<sub>i</sub>=s<sub>i</sub>, x is a register to store the input vector, where x is a register to store the input vector\n\n    -  **Step 2b**: Set activation for output unit\n                            y = t, where t is the target vector and y is the output vector\n\n    -  **Step 2c**: Adjust the weights and bias\n                         w<sub>i</sub>(new) = w<sub>i</sub>(old) + delta_w\n                         bias(new) = bias(old) + delta_b\n                          Where:\n                            delta_w = x<sub>I</sub> * t\n                            delta_b = t\n                   \n## Inputs and Outputs:\n## Inputs:\n- `clk` (1-bit): Posedge Clock signal.\n- `rst` (1-bit): Asynchronous Negedge Reset signal. When asserted LOW , the FSM is initialized to State_0 and iteration counter is initialized to 0.\n- `start `(1-bit): Active HIGH Signal to initiate the FSM.\n- `a`, `b` (4-bit each, [3:0], signed): Bipolar input signals [-1 ,1]. Only -1 and 1 have to be considered as valid inputs\n- `target_select`(2-bit,[1:0]): Selector to specify the target for a given gate.\n- `gate_select` (2-bit,[1:0]): Selector to specify the given gate\n## Outputs:\n- `w1`, `w2` (4-bit each,[3:0], signed): Trained weights for the inputs.\n- `bias` (4-bit, signed,[3:0]): Trained bias value.\n- `present_state`, `next_state` (4-bit each,[3:0]): Current and next states of the Training FSM.\n\n**Instantiation** :\nThe testbench instantiates the `hebb_gates` module as uut and connects the signals between the module and the testbench. Each input and output from the uut is connected to its corresponding signal in the testbench.\n\n## **Input Generation and Validation**:\n**Stimulus**: The test bench should employ multiple tasks to simulate training epochs for different gate selections, each applying a sequence of input stimuli. Each task should correspond to one epoch for a given gate configuration and varies the input combinations of signals' a and `b`, along with control signals `gate_select` and `target_select`.\n\n**Gate 00 (gate_select = 2\u2019b00) Epochs**:\n\n**Test Case 1: First Epoch for Gate 00**:\n- Control: `gate_select` should be set to 00, `target_select` should be set to 00, and `start` should be asserted HIGH.\n- Inputs: A sequence where (a, b) takes on values: (1, 1) \u2192 (1, \u20131) \u2192 (\u20131, 1) \u2192 (\u20131, \u20131).\n\n**Test Case 2: Second Epoch for Gate 00**:\n- Control: `gate_select` should be set to 00, and `target_select` should be set to 01.\n- Inputs: The sequence is modified to start with (\u20131, \u20131) and then vary through (\u20131, 1), (1, \u20131), and (1, 1).\n\n**Test Case 3: Third Epoch for Gate 00**:\n- Control: `gate_select` should be set to 00, `target_select` should be set to 10.\n- Inputs: Similar to previous epochs but with a different ordering of input polarity to test consistency in weight and state transitions.\n\n**Test Case 4: Fourth Epoch for Gate 00**:\n- Control: `gate_select` should be set to 00, `target_select` should be set to 11.\n- Inputs: Another permutation of input values is applied to verify module behavior further.\n\n**Test Case 5: Fifth Epoch for Gate 00 (Invalid Target)**:\n- Control: `gate_select` should be set to 00, `target_select` should be set to an unknown value (2\u2019bxx).\n- Inputs: Standard sequence similar to the first epoch.\n\n**Gate 01 (gate_select = 2\u2019b01), Gate 10 (gate_select = 2\u2019b10), and Gate 11 (gate_select = 2\u2019b11) Epochs**:\n- For each valid gate (01, 10, 11), the testbench defines four epochs with explicitly defined target selections (00, 01, 10, 11) and a fifth epoch using an unknown target (2\u2019bxx).\n- In each epoch, the tasks apply a similar method: a sequence of input combinations is applied to a and b with specific delays (#60, #70, #80, etc.) to mimic realistic timing conditions.\n\n**Invalid Gate Epochs**:\n **Test Case: Invalid Epochs 1\u20135**\n- Control: `gate_select` should be set to an unknown value (2\u2019bxx), with target selections both valid (00\u201311) and completely unknown (2\u2019bxx).\nInputs: A variety of input patterns (including zeros and mixed values) are applied.\n\n## Learning Logic:\n- Weights (w1, w2) and bias are updated incrementally based on the input values and a computed error:\n    delta_w1 = x1 * target\n    delta_w2 = x2 * target\n    delta_b = target \n    w1 = w1 + delta_w1\n    w2 = w2 + delta_w2\n    bias = bias + delta_b\n\n- Target values are determined using a `gate_target` submodule based on `gate_select`:\n  - gate_select = 2'b00: AND gate behavior.\n  - gate_select = 2'b01: OR gate behavior.\n  - gate_select = 2'b10: NAND gate behavior.\n  - gate_select = 2'b11: NOR gate behavior.\n\n## FSM Design:\nThere are 11 states handled by Moore FSM.\n- State_0: Reset state.\n- State_1: Capture inputs.\n- State_2-State_6: Assign targets based on the selected gate.\n- State_7: Compute deltas for weights and bias.\n- State_8: Update weights and bias.\n- State_9: Loop through training iterations.\n- State_10: Return to the initial state.\n\n## Functional Requirements:\n- Weight adjustment must follow the Hebbian learning rule.\n- The FSM must support multiple training iterations for every possible input combination of a two-input logic gate.\n- Outputs (`w1`, `w2`, `bias`) should reflect trained values at the end of the process.", "context": {}}, "output": {"response": "", "context": {"verif/tb_hebb_gates.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 9fbf672af52ebe98412cf75e6fc8214c80787a70\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/hebb_gates.sv": "`timescale 1ns/1ps\nmodule hebb_gates(\n   input  logic               clk,          // Posedge clk\n   input  logic               rst,          // Asynchronous negedge rst\n   input  logic               start,        // To start the FSM\n   input  logic         [1:0] target_select,// To select different targets for a given gate\n   input  logic  signed [3:0] a,            // First Input\n   input  logic  signed [3:0] b,            // Second Input\n   input  logic         [1:0] gate_select,  // To select a given gate\n   output logic  signed [3:0] w1,           // Weight 1 obtained by training\n   output logic  signed [3:0] w2,           // Weight 2 obtained by training\n   output logic  signed [3:0] bias,         // Bias obtained by training\n   output logic       [3:0] present_state,  // Present State of the Training FSM\n   output logic       [3:0] next_state      // Next_State of the Training FSM\n);\n   logic signed [3:0] t1;\n   logic signed [3:0] t2;\n   logic signed [3:0] t3;\n   logic signed [3:0] t4;\n   \n   gate_target dut (\n      .gate_select   (gate_select),\n      .target_select (target_select),\n      .o_1           (t1),\n      .o_2           (t2),\n      .o_3           (t3),\n      .o_4           (t4)\n   );\n   \n   \n   localparam [3:0] State_0  = 4'd0;\n   localparam [3:0] State_1  = 4'd1;\n   localparam [3:0] State_2  = 4'd2;\n   localparam [3:0] State_3  = 4'd3;\n   localparam [3:0] State_4  = 4'd4;\n   localparam [3:0] State_5  = 4'd5;\n   localparam [3:0] State_6  = 4'd6;\n   localparam [3:0] State_7  = 4'd7;\n   localparam [3:0] State_8  = 4'd8;\n   localparam [3:0] State_9  = 4'd9;\n   localparam [3:0] State_10 = 4'd10;\n   \n   \n   logic [2:0]          iteration;\n   logic signed [3:0]   x1;\n   logic signed [3:0]   x2;\n   logic signed [3:0]   delta_w1;\n   logic signed [3:0]   delta_w2;\n   logic signed [3:0]   delta_b;\n   logic signed [3:0]   w1_reg;\n   logic signed [3:0]   w2_reg;\n   logic signed [3:0]   bias_reg;\n   logic signed [1:0]   target;\n   logic                delta_en;\n   logic                sum_en;\n   logic                clr_en;\n   logic                cap_en;\n  \n   \n   always @(*) begin\n      if (cap_en) begin\n         x1 = a;\n         x2 = b;\n      end else begin\n         x1 = x1 + 4'h0;\n         x2 = x2 + 4'h0;\n      end\n   end\n   \n   \n   always @(*) begin\n      if (delta_en) begin\n         delta_w1 = x1 * target;\n         delta_w2 = x2 * target;\n         delta_b  = target;\n      end else begin\n         delta_w1 = delta_w1 + 4'h0;\n         delta_w2 = delta_w2 + 4'h0;\n         delta_b  = delta_b + 4'h0;\n      end\n   end\n   \n   \n   always @(*) begin\n      if (sum_en) begin\n         w1_reg   = w1_reg + delta_w1;\n         w2_reg   = w2_reg + delta_w2;\n         bias_reg = bias_reg + delta_b;\n      end else begin\n         w1_reg   = w1_reg + 4'h0;\n         w2_reg   = w2_reg + 4'h0;\n         bias_reg = bias_reg + 4'h0;\n      end\n   end\n   \n   \n   always @(*) begin\n      if (clr_en) begin\n         w1_reg   = 0;\n         w2_reg   = 0;\n         bias_reg = 0;\n      end else begin\n         w1_reg   = w1_reg + 4'h0;\n         w2_reg   = w2_reg + 4'h0;\n         bias_reg = bias_reg + 4'h0;\n      end\n   end\n   \n   \n   always @(posedge clk or negedge rst) begin\n      if (!rst) begin\n         present_state <= State_0;\n         iteration     <= 0;\n      end else begin\n         present_state <= next_state;\n      end\n   end\n   \n   \n   always @(*) begin\n      next_state = present_state;\n      case (present_state)\n         State_0: begin \n            if (start)\n               next_state = State_1;\n            else\n               next_state = State_0;\n         end\n         State_1: begin \n            next_state = State_2;\n         end\n         State_2: begin \n            if (iteration == 0)\n               next_state = State_3;\n            else if (iteration == 1)\n               next_state = State_4;\n            else if (iteration == 2)\n               next_state = State_5;\n            else \n               next_state = State_6;\n         end\n         State_3: begin \n            next_state = State_7;\n         end\n         State_4: begin \n            next_state = State_7;\n         end\n         State_5: begin \n            next_state = State_7;\n         end\n         State_6: begin \n            next_state = State_7;\n         end\n         State_7: begin\n            next_state = State_8;\n         end\n         State_8: begin\n            next_state = State_9;\n         end\n         State_9: begin\n            if (iteration < 4)\n               next_state = State_1;\n            else\n               next_state = State_10;\n         end\n         State_10: begin\n            next_state = State_0;\n         end\n         default: ;\n      endcase\n   end \n   \n   \n   always @(*) begin    \n      case (present_state)\n         State_0: begin\n            clr_en    = 1;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = 0;\n            target    = target + 4'h0;\n         end \n         State_1: begin\n            clr_en    = 0;\n            cap_en    = 1;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = target + 4'h0;\n         end\n         State_2: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = target + 4'h0;\n         end\n         State_3: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = t1;\n         end\n         State_4: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = t2;\n         end     \n         State_5: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = t3;\n         end  \n         State_6: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = t4;\n         end        \n         State_7: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 1;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = target + 4'h0;\n         end\n         State_8: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 1;\n            iteration = iteration + 1;\n            target    = target + 4'h0;\n         end\n         State_9: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = target + 4'h0;\n         end  \n         State_10: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = target + 4'h0;\n         end\n         default: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = 0;\n            target    = target + 4'h0;\n         end\n      endcase\n   end\n   \n   \n   assign w1   = w1_reg;\n   assign w2   = w2_reg;\n   assign bias = bias_reg;\n   \nendmodule\n\n\n`timescale 1ns/1ps\nmodule gate_target(\n   input  logic        [1:0] gate_select,\n   input  logic        [1:0] target_select,\n   output logic signed [3:0] o_1,\n   output logic signed [3:0] o_2,\n   output logic signed [3:0] o_3,\n   output logic signed [3:0] o_4\n);\n   always @(*) begin\n      case (gate_select)\n         2'b00: begin \n            case (target_select)\n               2'b00: begin\n                  o_1 =  4'b0001; \n                  o_2 = -4'b0001; \n                  o_3 = -4'b0001; \n                  o_4 = -4'b0001; \n               end\n               2'b01: begin\n                  o_1 = -4'b0001;\n                  o_2 = -4'b0001;\n                  o_3 = -4'b0001;\n                  o_4 =  4'b0001;\n               end\n               2'b10: begin\n                  o_1 = -4'b0001;\n                  o_2 =  4'b0001;\n                  o_3 = -4'b0001;\n                  o_4 = -4'b0001;\n               end\n               2'b11: begin\n                  o_1 = -4'b0001;\n                  o_2 = -4'b0001;\n                  o_3 =  4'b0001;\n                  o_4 = -4'b0001;\n               end\n               default: begin\n                  o_1 = 4'b0000; \n                  o_2 = 4'b0000; \n                  o_3 = 4'b0000; \n                  o_4 = 4'b0000; \n               end\n            endcase\n         end\n         2'b01: begin \n            case (target_select)\n               2'b00: begin  \n                  o_1 =  4'b0001; \n                  o_2 =  4'b0001; \n                  o_3 =  4'b0001; \n                  o_4 = -4'b0001; \n               end\n               2'b01: begin  \n                  o_1 =  4'b0001; \n                  o_2 =  4'b0001; \n                  o_3 = -4'b0001; \n                  o_4 =  4'b0001;\n               end\n               2'b10: begin  \n                  o_1 =  4'b0001; \n                  o_2 = -4'b0001; \n                  o_3 =  4'b0001; \n                  o_4 =  4'b0001;\n               end\n               2'b11: begin  \n                  o_1 = -4'b0001; \n                  o_2 =  4'b0001; \n                  o_3 =  4'b0001; \n                  o_4 =  4'b0001;\n               end \n               default: begin\n                  o_1 = 4'b0000; \n                  o_2 = 4'b0000; \n                  o_3 = 4'b0000; \n                  o_4 = 4'b0000; \n               end\n            endcase\n         end                \n         2'b10: begin \n            case (target_select)\n               2'b00: begin\n                  o_1 =  4'b0001; \n                  o_2 =  4'b0001; \n                  o_3 =  4'b0001; \n                  o_4 = -4'b0001; \n               end\n               2'b01: begin\n                  o_1 =  4'b0001;\n                  o_2 =  4'b0001;\n                  o_3 = -4'b0001;\n                  o_4 =  4'b0001;\n               end\n               2'b10: begin\n                  o_1 =  4'b0001;\n                  o_2 = -4'b0001;\n                  o_3 =  4'b0001;\n                  o_4 =  4'b0001;\n               end\n               2'b11: begin\n                  o_1 = -4'b0001;\n                  o_2 =  4'b0001;\n                  o_3 =  4'b0001;\n                  o_4 =  4'b0001;\n               end\n               default: begin\n                  o_1 = 4'b0000; \n                  o_2 = 4'b0000; \n                  o_3 = 4'b0000; \n                  o_4 = 4'b0000; \n               end\n            endcase\n         end\n         2'b11: begin \n            case (target_select)\n               2'b00: begin \n                  o_1 =  4'b0001; \n                  o_2 = -4'b0001; \n                  o_3 = -4'b0001; \n                  o_4 = -4'b0001; \n               end\n               2'b01: begin\n                  o_1 = -4'b0001; \n                  o_2 =  4'b0001; \n                  o_3 = -4'b0001; \n                  o_4 = -4'b0001;\n               end\n               2'b10: begin\n                  o_1 = -4'b0001; \n                  o_2 = -4'b0001; \n                  o_3 =  4'b0001; \n                  o_4 = -4'b0001;\n               end\n               2'b11: begin\n                  o_1 = -4'b0001; \n                  o_2 = -4'b0001; \n                  o_3 = -4'b0001; \n                  o_4 =  4'b0001; \n               end\n               default: begin\n                  o_1 = 4'b0000; \n                  o_2 = 4'b0000; \n                  o_3 = 4'b0000; \n                  o_4 = 4'b0000; \n               end\n            endcase\n         end\n         default: begin\n            o_1 = 4'b0000; \n            o_2 = 4'b0000; \n            o_3 = 4'b0000; \n            o_4 = 4'b0000; \n         end\n      endcase\n   end\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    for line in lines[2:]:\n        info = line.split()\n        while len(info) < 3:\n            info.append(\"0%\")\n        inst = re.sub(r'[\\W]', '', info[0])\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'uut' is missing in the coverage log.\")\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))\n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['uut']['Average']}, Target: {target}\"\n    \n"}}}
{"id": "cvdp_copilot_hebbian_rule_0022", "categories": ["cid014", "medium"], "input": {"prompt": "Can you add concurrent assertions in the RTL design of the `hebb_gates` module to ensure its correct functionality during simulation? The assertions should cover various key aspects of the `hebb_gates` module's operations such as proper reset initialization of the FSM and weight registers, verifying correct state transitions based on the iteration counter and start signal, checking that the arithmetic operations for delta calculations and weight updates are performed only under the appropriate control conditions, and validating that the gate_target submodule outputs match the expected target values based on the `gate_select` input.\n\nThe assertions should fail when any one of the following 10 conditions fails:\n\n**1. reset_initialization**:\n- Ensure that on asynchronous reset, the FSM is set to `State_0` and the iteration counter is reset to `0`.\n\n**2. state0_to_state1**:\n- Ensure that when the FSM is in `State_0` and the start signal is asserted, the next state is correctly set to `State_1`, indicating that the FSM properly initiates the transition from its idle state upon receiving the start signal.\n\n**3. state2_transition**:\n- Check that when the FSM is in `State_2`, the next state is correctly determined by the current value of the iteration counter. Specifically, if the iteration is 0, the next state should be `State_3`; if 1, it should be `State_4`; if 2, then `State_5`; and for any other iteration value, the next state must be `State_6`.\n\n**4. state9_transition** :\n- Ensure that when the FSM is in State_9, the next state is chosen based on the value of the iteration counter. If the iteration is less than 4, the FSM should loop back to `State_1`; otherwise, if the iteration is 4 or higher, it should transition to `State_10`.\n\n**5. clear_signal_state0**:\n- Verify that when the FSM is in `State_0`, the clear enable signal (`clr_en`) is asserted HIGH (set to 1). This ensures that the clearing functionality\u2014typically responsible for resetting or initializing registers\u2014is active in the idle state.\n\n**6. capture_signal_state1**:\n- Check that when the FSM is in State_1, the capture enable signal (`cap_en`) is asserted HIGH. This ensures that the module properly captures the input values at this stage of the FSM operation.\n\n**7. delta_calculation_state7**:\n- Verify that when the FSM is in `State_7` and the delta enable signal (`delta_en`) is ACTIVE HIGH, the module correctly calculates the delta values.\n\n**8. weight_update_state8**:\n- Verify that when the FSM is in `State_8` and the sum enable (`sum_en`) signal is ACTIVE HIGH, the weight registers are updated correctly.\n\n**9. gate_target_00**:\n- Verify that when the `gate_select` input is set to `2'b00`, the outputs from the gate_target submodule (`t1`, `t2`, `t3`, `t4`) match the expected target values. Specifically, `t1` must be `4'd1` while `t2`, `t3`, and `t4` should each be `-4'd1`.\n\n**10. weights_cleared_in_state0**:\n- Ensure that when the FSM is in `State_0`, the weight registers (`w1`, `w2`, and `bias`) are all reset to zero. This verifies that the clear operation is working correctly, guaranteeing proper initialization or reset of the weight values.\n\n## Inputs and Outputs:\n## Inputs:\n- `clk` (1-bit): Posedge Clock signal.\n- `rst` (1-bit): Asynchronous Negedge Reset signal. When ACTIVE LOW , the FSM is initialized to `State_0` and iteration counter `iteration` to 0\n- `start `(1-bit): Active HIGH Signal to initiate the FSM.\n- `a`, `b` (4-bit each, [3:0],signed): Bipolar input signals [-1 ,1]. Only -1 and 1 have to be considered as valid inputs\n- `gate_select` (2-bit,[1:0]): Selector to specify the target for a given gate\n## Outputs:\n- `w1`, `w2` (4-bit each,[3:0], signed): Trained weights for the inputs.\n- `bias` (4-bit, signed,[3:0]): Trained bias value.\n- `present_state`, `next_state` (4-bit each,[3:0]): Current and next states of the Training FSM.", "context": {"rtl/hebb_gates.sv": "module hebb_gates(\n   input  logic               clk,// Posedge clk\n   input  logic               rst,// Asynchronous negedge rst\n   input  logic               start, // To start the FSM\n   input  logic  signed [3:0] a, // First Input\n   input  logic  signed [3:0] b, // Second Input\n   input  logic         [1:0] gate_select, // To provide the targets for a selected gate in order to train\n   output logic  signed [3:0] w1, // Weight 1 obtained by training\n   output logic  signed [3:0] w2, // Weight 2 obtained by training\n   output logic  signed [3:0] bias,// Bias obtained by training\n   output logic [3:0] present_state,// Present State of the Training FSM\n   output logic [3:0] next_state // Next_State of the Training FSM\n   \n);\n   logic signed [3:0] t1;\n   logic signed [3:0] t2;\n   logic signed [3:0] t3;\n   logic signed [3:0] t4;\n   \n   gate_target dut(\n       .gate_select(gate_select),\n       .o_1        (t1),\n       .o_2        (t2),\n       .o_3        (t3),\n       .o_4        (t4)\n   );\n   \n   localparam [3:0] State_0 = 4'd0;\n   localparam [3:0] State_1 = 4'd1;\n   localparam [3:0] State_2 = 4'd2;\n   localparam [3:0] State_3 = 4'd3;\n   localparam [3:0] State_4 = 4'd4;\n   localparam [3:0] State_5 = 4'd5;\n   localparam [3:0] State_6 = 4'd6;\n   localparam [3:0] State_7 = 4'd7;\n   localparam [3:0] State_8 = 4'd8;\n   localparam [3:0] State_9 = 4'd9;\n   localparam [3:0] State_10 = 4'd10;\n   \n   logic [2:0] iteration;\n   logic signed [3:0] x1;\n   logic signed [3:0] x2;\n   logic signed [3:0] delta_w1;\n   logic signed [3:0] delta_w2;\n   logic signed [3:0] delta_b;\n   logic signed [3:0] w1_reg;\n   logic signed [3:0] w2_reg;\n   logic signed [3:0] bias_reg;\n   logic signed [1:0] target;\n   logic delta_en;\n   logic sum_en;\n   logic clr_en;\n   logic cap_en;\n  \n   always_comb begin\n     if(cap_en ) begin\n        x1 = a;\n        x2 = b;\n     end else begin\n        x1 = x1 + 4'h0;\n        x2 = x2 + 4'h0;\n     end\n   \n   end\n   \n   always_comb begin\n     \n     if(delta_en) begin\n       delta_w1 = x1 * target;\n       delta_w2 = x2 * target;\n       delta_b  = target;\n     end else begin\n       delta_w1 = delta_w1 + 4'h0;\n       delta_w2 = delta_w2 + 4'h0;\n       delta_b  = delta_b + 4'h0; \n   end\n   \n  end\n   \n  always_comb begin\n     \n     if(sum_en) begin\n       w1_reg = w1_reg + delta_w1;\n       w2_reg = w2_reg + delta_w2;\n       bias_reg = bias_reg + delta_b;\n     end else begin\n       w1_reg = w1_reg + 4'h0;\n       w2_reg = w2_reg + 4'h0;\n       bias_reg = bias_reg + 4'h0;\n   end\n  end\n   \n   always_comb begin\n     \n     if(clr_en) begin\n       w1_reg = 0;\n       w2_reg = 0;\n       bias_reg = 0;\n     end else begin\n       w1_reg = w1_reg + 4'h0;\n       w2_reg = w2_reg + 4'h0;\n       bias_reg = bias_reg + 4'h0; \n    end\n   end\n   \n   always_ff@(posedge clk or negedge rst) begin\n       if(!rst) begin\n          present_state <= State_0;\n          iteration <= 0;\n        end else\n          present_state <= next_state;\n   end\n\n   \n   always@(*) begin\n        next_state = present_state;\n        \n     case(present_state)\n            State_0  : begin \n                        if(start)\n                           next_state = State_1;\n                        else\n                           next_state = State_0;\n                       end\n            State_1  : begin \n                           next_state = State_2;\n                       end\n            State_2  : begin \n                         if(iteration == 0)\n                           next_state = State_3;\n                       else if(iteration == 1)\n                           next_state = State_4;\n                       else if(iteration == 2)\n                           next_state = State_5;\n                       else \n                           next_state = State_6;\n                       end\n            State_3  : begin \n                         next_state = State_7;\n                       end\n            State_4  : begin \n                         next_state = State_7;\n                       end\n            State_5  : begin \n                         next_state = State_7;\n                       end\n            State_6  : begin \n                         next_state = State_7;\n                       end\n            State_7  : begin\n                         next_state = State_8;\n                       end\n            State_8  : begin\n                         next_state = State_9;\n                       end\n            State_9  : begin\n                        if(iteration < 4)\n                         next_state = State_1;\n                        else\n                         next_state = State_10;\n                       end\n            State_10 : begin\n                         next_state = State_0;\n                       end\n            default : ;\n     endcase\n   end \n   \n   \n   always@(*) begin    \n      case(present_state)\n             State_0  : begin\n                         clr_en = 1;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en   = 0;\n                         iteration = 0;\n                         target = target + 4'h0;\n                        end \n             State_1  : begin\n                         clr_en = 0;\n                         cap_en = 1;\n                         delta_en = 0;\n                         sum_en = 0;  \n                         iteration = iteration + 0;  \n                         target = target + 4'h0;              \n                        end\n             State_2  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0; \n                         iteration = iteration + 0;     \n                         target = target + 4'h0;              \n                        end\n             State_3  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0;\n                         iteration = iteration + 0;\n                         target = t1;\n                        end\n             State_4  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0;\n                         iteration = iteration + 0;\n                         target = t2;\n                        end     \n             State_5  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0;\n                         iteration = iteration + 0;\n                         target = t3;\n                        end  \n             State_6  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0;\n                         iteration = iteration + 0;\n                         target = t4;\n                        end        \n             State_7  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 1;\n                         sum_en = 0;\n                         iteration = iteration + 0;\n                         target = target + 4'h0;\n                        end\n             State_8  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 1;\n                         iteration = iteration + 1;\n                         target = target + 4'h0;\n                        end\n             State_9  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0;\n                         iteration = iteration + 0;\n                         target = target + 4'h0;\n                        end  \n             State_10 : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0;\n                         iteration = iteration + 0;\n                         target = target + 4'h0;\n                        end\n             default  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0;\n                         iteration = 0;\n                         target = target + 4'h0;\n                        end\n       endcase\n   end\n   assign w1 = w1_reg;\n   assign w2 = w2_reg;\n   assign bias = bias_reg;\n   \nendmodule\n\nmodule gate_target(\n   input  logic        [1:0] gate_select,\n   output logic signed [3:0] o_1,\n   output logic signed [3:0] o_2,\n   output logic signed [3:0] o_3,\n   output logic signed [3:0] o_4\n);\n   always@(*) begin\n     case(gate_select)\n          2'b00 : begin \n                    o_1 =  4'b0001; \n                    o_2 = -4'b0001; \n                    o_3 = -4'b0001; \n                    o_4 = -4'b0001; \n                  end\n          2'b01 : begin \n                    o_1 =  4'b0001; \n                    o_2 =  4'b0001; \n                    o_3 =  4'b0001; \n                    o_4 = -4'b0001; \n                  end\n          2'b10 : begin \n                    o_1 =  4'b0001; \n                    o_2 =  4'b0001; \n                    o_3 =  4'b0001; \n                    o_4 = -4'b0001; \n                  end\n          2'b11 : begin \n                    o_1 =  4'b0001; \n                    o_2 = -4'b0001; \n                    o_3 = -4'b0001; \n                    o_4 = -4'b0001; \n                  end\n        default : begin\n                    o_1 =  4'b0000; \n                    o_2 =  4'b0000; \n                    o_3 =  4'b0000; \n                    o_4 =  4'b0000; \n                  end\n        endcase\n   end\nendmodule"}}, "output": {"response": "", "context": {"rtl/hebb_gates.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/hebb_gates.sv\nTOPLEVEL        = hebb_gates\nMODULE          = test_hebb_gates\nPYTHONPATH      = /src\nHASH            = 22-hebbian_rule_tb_assertion_generation\n", "src/test_hebb_gates.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n@cocotb.test()\nasync def test_hebb_gates(dut):\n    \"\"\"Test the hebb_gates module with different gate selections and inputs.\"\"\"\n\n    # Create a 10ns clock\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Reset logic\n    dut.rst.value = 0\n    await Timer(10, units=\"ns\")\n    dut.rst.value = 1\n\n    # Initialize inputs\n    dut.start.value = 0\n    dut.a.value = 0\n    dut.b.value = 0\n    dut.gate_select.value = 0\n\n    await RisingEdge(dut.rst)\n    await Timer(10, units=\"ns\")\n\n    # Helper function for applying stimulus and logging outputs\n    async def apply_stimulus(a, b, gate_select, duration):\n        dut.a.value = a\n        dut.b.value = b\n        dut.gate_select.value = gate_select\n        await Timer(duration, units=\"ns\")\n        cocotb.log.info(\n              f\"gate_select={gate_select}, a={a}, b={b}, \"\n              f\"w1={int(dut.w1.value)}, w2={int(dut.w2.value)}, \"\n              f\"bias={int(dut.bias.value)}, state={bin(int(dut.present_state.value))}\"\n        )\n\n    # Test AND gate targets (gate_select = 2'b00)\n    dut.gate_select.value = 0b00\n    dut.start.value = 1\n    cocotb.log.info(\"Start of AND gate Training\")\n\n    await apply_stimulus(1, 1, 0b00, 60)\n    await apply_stimulus(1, -1, 0b00, 60)\n    await apply_stimulus(-1, 1, 0b00, 60)\n    await apply_stimulus(-1, -1, 0b00, 70)\n\n    cocotb.log.info(\"End of AND gate Training\")\n\n    # Test OR gate targets (gate_select = 2'b01)\n    dut.gate_select.value = 0b01\n    cocotb.log.info(\"Start of OR gate Training\")\n\n    await apply_stimulus(1, 1, 0b01, 70)\n    await apply_stimulus(-1, 1, 0b01, 60)\n    await apply_stimulus(1, -1, 0b01, 60)\n    await apply_stimulus(-1, -1, 0b01, 70)\n\n    cocotb.log.info(\"End of OR gate Training\")\n\n    # Test NAND gate targets (gate_select = 2'b10)\n    dut.gate_select.value = 0b10\n    cocotb.log.info(\"Start of NAND gate Training\")\n\n    await apply_stimulus(-1, -1, 0b10, 70)\n    await apply_stimulus(-1, 1, 0b10, 60)\n    await apply_stimulus(1, -1, 0b10, 60)\n    await apply_stimulus(1, 1, 0b10, 70)\n\n    cocotb.log.info(\"End of NAND gate Training\")\n\n    # Test NOR gate targets (gate_select = 2'b11)\n    dut.gate_select.value = 0b11\n    cocotb.log.info(\"Start of NOR gate Training\")\n\n    await apply_stimulus(-1, -1, 0b11, 70)\n    await apply_stimulus(-1, 1, 0b11, 60)\n    await apply_stimulus(1, -1, 0b11, 60)\n    await apply_stimulus(1, 1, 0b11, 70)\n\n    cocotb.log.info(\"End of NOR gate Training\")\n\n    # Randomized test cases\n    num_random_cases = 10  # Number of random test cases\n    for i in range(num_random_cases):\n        random_gate_select = random.randint(0, 3)  # Randomly select gate (0b00 to 0b11)\n        random_inputs = [(random.choice([-1, 1]), random.choice([-1, 1])) for _ in range(4)]\n\n        dut.gate_select.value = random_gate_select\n        dut.start.value = 1\n        cocotb.log.info(f\"Start of Random Test Case {i+1} for gate_select={bin(random_gate_select)}\")\n\n        for a, b in random_inputs:\n            await apply_stimulus(a, b, random_gate_select, 65)\n        cocotb.log.info(f\"End of Random Test Case {i+1} for gate_select={bin(random_gate_select)}\")\n    # Stop the test\n    dut.start.value = 0\n    cocotb.log.info(\"Test Completed\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_hill_cipher_0012", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench to generate the stimuli for the `hill_cipher` module, which applies a 3\u00d73 key matrix to a 3-letter (15-bit) plaintext vector, computing the ciphertext (also 3 letters, 15 bits) modulo 26.\n\n---\n\n## Description\n\n### Inputs\n\n- **Registers**:\n  - `clk (1 bit)`: Clock signal that drives the internal finite state machine (FSM) and arithmetic logic.\n  - `reset (1 bit)`: Active-high, synchronous reset that clears all registers and returns the module to the `IDLE` state.\n  - `start (1 bit)`: A strobe signal indicating the module should begin computing the ciphertext for the provided `plaintext` and `key`.\n  - `plaintext (15 bits)`: Three letters, each 5 bits, forming the message to encrypt.\n  - `key (45 bits)`: A 3\u00d73 matrix of 9 elements, each 5 bits, used to multiply the plaintext vector in the Hill Cipher algorithm.\n\n### Outputs\n\n- **Wires**:\n  - `ciphertext (15 bits)`: The resulting 3-letter (5 bits per letter) encrypted output.\n  - `done (1 bit)`: Goes high for one cycle when the module finishes encryption, signaling the `ciphertext` is valid.\n\n---\n\n## Input Generation\n\n- **Random Input Generation**:  \n  The testbench provides random 15-bit values for `plaintext` (covering possible 3-letter combinations) and 45-bit values for `key` (covering random 3\u00d73 matrices). These random tests help uncover boundary issues and verify the FSM\u2019s transitions.\n\n- **Directed Patterns**:  \n  The testbench also applies specific edge-case values for `plaintext` and `key`, such as:\n  - `plaintext = 15'h0000` (all zeros).\n  - `key = 45'h0000000000` (all zeros).\n  - Maximal or near-maximal values to ensure the modulo operations function correctly.\n  - Sequences that check if multiple consecutive encryption requests work as intended.\n\n---\n\n## Stabilization Period\n\n- The testbench asserts `start` for **one clock cycle** after setting `plaintext` and `key`.  \n- It then waits until `done` goes high, indicating the FSM has advanced through `COMPUTE`, `COMPUTE_MOD`, and finally `DONE`.  \n- Once `done=1`, the testbench samples `ciphertext` and logs the result.\n\n---\n\n## Instantiation\n\nName the instance of the module as `uut`.\n\n---\n\nFollows the specification for building the RTL of the module, use it as reference for the verification environment too:\n\n### Module Interface\n\n1. **Inputs**:\n   - `clk (1 bit)`\n   - `reset (1 bit)`\n   - `start (1 bit)`\n   - `plaintext [14:0]`\n   - `key [44:0]`\n\n2. **Outputs**:\n   - `ciphertext [14:0]`\n   - `done`\n\n### Module Functionality\n\nInstead of viewing the key as a matrix, consider it as **9 separate 5-bit key elements**, grouped in **3 sets** (each set has 3 elements). The `plaintext` is **3 letters**, each 5 bits. The module computes each output letter as follows:\n\n1. **Multiply & Sum**:  \n   For one of the 3 output letters, the module multiplies each of the 3 plaintext letters (5 bits each) by the corresponding key element in that set. It then adds these 3 products together.\n\n2. **Modulo Operation**:  \n   Because we want each letter to stay in the range `0\u201325` (the alphabet size), the module takes the sum **modulo 26**. This final value (0\u201325) becomes one letter of the encrypted output.\n\n3. **Three Times**:  \n   The module repeats Steps 1 and 2 for each of the **3 sets** of key elements, creating **3 encrypted letters**.  \n\n4. **Finite State Machine**:  \n   - **IDLE**: Waits until `start` is asserted.  \n   - **COMPUTE**: Calculates partial sums (multiply-and-add) for each of the 3 output letters.  \n   - **COMPUTE_MOD**: Finalizes each sum modulo 26, storing the results in internal registers for `ciphertext`.  \n   - **DONE**: Pulses `done=1` for one clock cycle to signal the `ciphertext` is valid, then returns to IDLE.\n\n5. **Reset**:  \n     When `reset` is asserted, the FSM returns to `IDLE`, and internal registers are cleared. The outputs (`ciphertext`, `done`) remain in their initial states (zeros) until the next valid compute cycle. \n\n---", "context": {}}, "output": {"response": "", "context": {"verif/hill_cipher_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n   xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 5c145b95e5e2c6caf039151222ef4630ff5dcaf8\nTARGET          = 90\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/hill_cipher.sv": "`timescale 1ns/1ps\n\nmodule hill_cipher (\n    input logic clk,\n    input logic reset,\n    input logic start,\n    input logic [14:0] plaintext,   // 3 letters, 5 bits each\n    input logic [44:0] key,         // 9 elements, 5 bits each\n    output logic [14:0] ciphertext, // 3 letters, 5 bits each \n    output logic done\n);\n\n    logic [4:0] P0, P1, P2;\n    logic [4:0] K00, K01, K02;\n    logic [4:0] K10, K11, K12;\n    logic [4:0] K20, K21, K22;\n\n    logic [5:0] temp0, temp1, temp2;\n    logic [4:0] C0_reg, C1_reg, C2_reg;\n\n    typedef enum logic [1:0] {\n        IDLE        = 2'b00,\n        COMPUTE     = 2'b01,\n        COMPUTE_MOD = 2'b10,\n        DONE        = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    assign P0 = plaintext[14:10];\n    assign P1 = plaintext[9:5];\n    assign P2 = plaintext[4:0];\n\n    assign K00 = key[44:40];\n    assign K01 = key[39:35];\n    assign K02 = key[34:30];\n    assign K10 = key[29:25];\n    assign K11 = key[24:20];\n    assign K12 = key[19:15];\n    assign K20 = key[14:10];\n    assign K21 = key[9:5];\n    assign K22 = key[4:0];\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    always_comb begin\n        next_state = current_state;\n        done = 1'b0;\n\n        case (current_state)\n            IDLE: begin\n                if (start)\n                    next_state = COMPUTE;\n            end\n            COMPUTE: begin\n                next_state = COMPUTE_MOD;\n            end\n            COMPUTE_MOD: begin\n                next_state = DONE;\n            end\n            DONE: begin\n                done = 1'b1;\n                next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            temp0 <= 12'b0;\n            temp1 <= 12'b0;\n            temp2 <= 12'b0;\n            C0_reg <= 5'b0;\n            C1_reg <= 5'b0;\n            C2_reg <= 5'b0;\n        end\n        else begin\n            case (current_state)\n                COMPUTE: begin\n                    temp0 <= (K00 * P0)%26 + (K01 * P1)%26 + (K02 * P2)%26;\n                    temp1 <= (K10 * P0)%26 + (K11 * P1)%26 + (K12 * P2)%26;\n                    temp2 <= (K20 * P0)%26 + (K21 * P1)%26 + (K22 * P2)%26;\n                end\n                COMPUTE_MOD: begin\n                    C0_reg <= temp0%26;\n                    C1_reg <= temp1%26;\n                    C2_reg <= temp2%26;\n                end\n                default: begin\n                    temp0 <= 12'b0;\n                    temp1 <= 12'b0;\n                    temp2 <= 12'b0;\n                    C0_reg <= 5'b0;\n                    C1_reg <= 5'b0;\n                    C2_reg <= 5'b0;\n                end\n            endcase\n        end\n    end\n\n    assign ciphertext = {C0_reg, C1_reg, C2_reg};\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_hill_cipher_0017", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the SystemVerilog Testbench for the `hill_cipher` module to verify the functionality of the **hill_cipher** design specification.\n\n---\n\n## Design Specification\n\nThe **hill_cipher** module implements the Hill cipher encryption algorithm. It encrypts a 3-letter plaintext by using a 3\u00d73 key matrix. Both the plaintext letters and key elements are represented as 5-bit values (ranging from 0 to 25). All arithmetic operations are performed with modulo 26 to ensure that the results correspond to valid letters.\n\n### I/O Signals\n\n- **Inputs**  \n  - `clk` (1-bit): Clock signal for synchronous operation.  \n  - `reset` (1-bit): Asynchronous reset signal to initialize the design.  \n  - `start` (1-bit): Signal to trigger the encryption process.  \n  - `plaintext` (15-bit): Three concatenated 5-bit values representing the plaintext letters.  \n  - `key` (45-bit): Nine concatenated 5-bit values representing the 3\u00d73 key matrix.\n\n- **Outputs**  \n  - `ciphertext` (15-bit): Three concatenated 5-bit values representing the encrypted text.  \n  - `done` (1-bit): Indicates that the encryption process is complete.\n\n### Summary of Operations\n\n1. **Input Extraction**  \n   - The testbench divides the 15-bit `plaintext` into three separate 5-bit segments.\n   - Similarly, it divides the 45-bit `key` into nine separate 5-bit elements, forming a 3\u00d73 matrix.\n\n2. **Matrix Multiplication and Modular Reduction**  \n   - The module processes each row of the key matrix by multiplying the corresponding key elements with the plaintext segments and then adding those results together.\n   - The total from each row is then reduced to ensure it is within the range of 0 to 25.  \n   - Finally, the three resulting values (one per row) are combined to form the final 15-bit `ciphertext`.\n\n3. **Output Generation**  \n   - Once the encryption process is complete, the module asserts the `done` signal and outputs the computed ciphertext.\n\n---\n\n## Requirements\n\n### Testbench Components\n\n1. **Input Stimuli**  \n   - Provide both directed (fixed) and randomized test vectors for the `plaintext` and `key` inputs.\n\n2. **Output Monitoring**  \n   - Capture and log the DUT\u2019s `ciphertext` and `done` signals for each test case.\n\n3. **Reference Model / Scoreboard**  \n   - Implement a reference function in the testbench that follows the same logical steps as the DUT:\n     - Extract the three 5-bit segments from the plaintext.\n     - Extract the nine 5-bit key elements and arrange them as a 3\u00d73 matrix.\n     - For each row of the key matrix, multiply the key elements with the corresponding plaintext segments, add the results, and then reduce the sum to fall within the range 0\u201325.\n     - Combine the three final values to form the expected 15-bit ciphertext.\n  \n4. **Comparison and Logging**  \n   - For every test vector, compare the expected ciphertext (from the reference model) with the actual ciphertext output by the DUT.\n   - Print detailed information for each test, including:\n     - The applied `plaintext` and `key` values.\n     - The expected ciphertext.\n     - The actual ciphertext.\n     - A pass/fail status.\n\n### Validation Logic\n\n- **Test Execution**  \n  - Use both directed and random test vectors to thoroughly validate the module.\n  \n- **Pass/Fail Reporting**  \n  - Maintain a count of passing and failing tests.\n  - End the simulation with an exit code of **0** if all tests pass, or with a nonzero exit code if any test fails.\n\n### Edge Cases\n\n- **Zero Inputs**: Verify that the module correctly processes inputs when both `plaintext` and `key` are zero.\n- **Maximum Values**: Validate operation when maximum valid values are applied.\n- **Random Patterns**: Ensure robust operation over a wide range of random test vectors.\n\n---\n\n## Test Strategy\n\n- **Directed Tests**  \n  - Use specific test vectors to validate expected behavior.\n- **Random Tests**  \n  - Generate random inputs to explore various scenarios.\n- **Comparison**  \n  - For each test vector, compute the expected output using the reference model and compare it with the DUT\u2019s output.\n- **Logging**  \n  - Print both the expected and actual ciphertext values for every test case.\n\n---\n\n## Expected Output\n\n- **For Each Test Case**:  \n  - A log message displaying:\n    - The input `plaintext` and `key`\n    - The expected ciphertext computed by the reference model\n    - The actual ciphertext from the DUT\n    - A pass or fail status\n\n- **Final Summary**:  \n  - A summary of the total number of tests passed and failed.\n  - The simulation should exit with code **0** if all tests pass, or a nonzero code if any test fails.\n\n---\n\n## Deliverables\n\nProvide a complete SystemVerilog testbench `hill_cipher_tb.sv` that meets the requirements above to verify the **hill_cipher** module.", "context": {"verif/hill_cipher_tb.sv": "`timescale 1ns/1ps\n\nmodule tb_hill_cipher;\n  logic        clk;\n  logic        reset;\n  logic        start;\n  logic [14:0] plaintext;\n  logic [44:0] key;\n  logic [14:0] ciphertext;\n  logic        done;\n\n  // Instantiate the DUT\n  hill_cipher uut (\n    .clk       (clk),\n    .reset     (reset),\n    .start     (start),\n    .plaintext (plaintext),\n    .key       (key),\n    .ciphertext(ciphertext),\n    .done      (done)\n  );\n\n  // Clock generation\n  initial clk = 1'b0;\n  always #5 clk = ~clk;\n\n  // Apply stimuli\n  initial begin\n    $dumpfile(\"hill_cipher_tb.vcd\");\n    $dumpvars(0, tb_hill_cipher);\n\n    // Initialize\n    reset     = 1'b1;\n    start     = 1'b0;\n    plaintext = 15'd0;\n    key       = 45'd0;\n\n    repeat(3) @(posedge clk);\n    reset = 1'b0;\n\n\n    // Task usage\n    do_test(15'h0000, 45'h0000000000); \n    do_test(15'h07e4, 45'h123456789A); \n    do_test(15'h3FFF, 45'h0AAAAAAAAB); \n    do_test(15'h1555, 45'h1FFF000123); \n    do_test(15'h2ABC, 45'h2ABCDE1111); \n\n    for (int i = 6; i <= 10; i++) begin\n      do_test($random, $random);\n    end\n\n    do_test(15'h001F, 45'h0000001F1F); \n    do_test(15'h0BEE, 45'h00BEE12345); \n    do_test(15'h07EF, 45'hFEED0AB123); \n    do_test(15'h1234, 45'h0123456789); \n    do_test(15'h7FFF, 45'h3FFFFABCDF); \n\n    for (int i = 16; i <= 20; i++) begin\n      do_test($random, $random);\n    end\n\n    do_test(15'h0F0F, 45'hF0F0F0F0F0); \n    do_test(15'h1B1B, 45'h1111122222); \n    do_test(15'h3C3C, 45'h3333344444); \n    do_test(15'h2F2F, 45'h55555AAAAB); \n    do_test(15'h5A5A, 45'h77777CCCCD); \n\n    for (int i = 26; i <= 30; i++) begin\n      do_test($random, $random);\n    end\n\n    #50;\n    $finish;\n  end\n\n  task do_test(input [14:0] p, input [44:0] k);\n    begin\n      @(posedge clk);\n      start     = 1'b0;\n      plaintext = p;\n      key       = k;\n      @(posedge clk);\n      start = 1'b1; \n      @(posedge clk);\n      start = 1'b0;\n      wait (done == 1);\n      @(posedge clk);\n      $display(\n        \"[%0t] plaintext=%h, key=%h => ciphertext=%h, done=%b\",\n        $time, p, k, ciphertext, done\n      );\n    end\n  endtask\n\nendmodule"}}, "output": {"response": "", "context": {"verif/hill_cipher_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/hill_cipher.sv\nHASH            = 378a2560829d670ef7d446bbb53794848c9b33bf\nNUM_BUGS        = 8\n", "src/hill_cipher.sv": "`timescale 1ns/1ps\n\nmodule hill_cipher (\n    input logic clk,\n    input logic reset,\n    input logic start,\n    input logic [14:0] plaintext,\n    input logic [44:0] key,\n    output logic [14:0] ciphertext,\n    output logic done\n);\n\n    logic [4:0] P0, P1, P2;\n    logic [4:0] K00, K01, K02;\n    logic [4:0] K10, K11, K12;\n    logic [4:0] K20, K21, K22;\n\n    logic [5:0] temp0, temp1, temp2;\n    logic [4:0] C0_reg, C1_reg, C2_reg;\n\n    typedef enum logic [1:0] {\n        IDLE        = 2'b00,\n        COMPUTE     = 2'b01,\n        COMPUTE_MOD = 2'b10,\n        DONE        = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    assign P0 = plaintext[14:10];\n    assign P1 = plaintext[9:5];\n    assign P2 = plaintext[4:0];\n\n    assign K00 = key[44:40];\n    assign K01 = key[39:35];\n    assign K02 = key[34:30];\n    assign K10 = key[29:25];\n    assign K11 = key[24:20];\n    assign K12 = key[19:15];\n    assign K20 = key[14:10];\n    assign K21 = key[9:5];\n    assign K22 = key[4:0];\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    always_comb begin\n        next_state = current_state;\n        done = 1'b0;\n        case (current_state)\n            IDLE: begin\n                if (start)\n                    next_state = COMPUTE;\n            end\n            COMPUTE: begin\n                next_state = COMPUTE_MOD;\n            end\n            COMPUTE_MOD: begin\n                next_state = DONE;\n            end\n            DONE: begin\n                done = 1'b1;\n                next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            temp0   <= 12'b0;\n            temp1   <= 12'b0;\n            temp2   <= 12'b0;\n            C0_reg  <= 5'b0;\n            C1_reg  <= 5'b0;\n            C2_reg  <= 5'b0;\n        end\n        else begin\n            case (current_state)\n                COMPUTE: begin\n                    `ifdef BUG_6\n                        temp0 <= ((K00 * P0) % 26 + (K01 * P1) % 26 + (K02 * P2) % 26) + 6'd2;\n                        temp1 <= ((K10 * P0) % 26 + (K11 * P1) % 26 + (K12 * P2) % 26) + 6'd2;\n                        temp2 <= ((K20 * P0) % 26 + (K21 * P1) % 26 + (K22 * P2) % 26) + 6'd2;\n                    `elsif BUG_7\n                        temp0 <= ((K00 * P0) % 26 + (K01 * P1) % 26 + (K02 * P2) % 26) - 6'd2;\n                        temp1 <= ((K10 * P0) % 26 + (K11 * P1) % 26 + (K12 * P2) % 26) - 6'd2;\n                        temp2 <= ((K20 * P0) % 26 + (K21 * P1) % 26 + (K22 * P2) % 26) - 6'd2;\n                    `else\n                        temp0 <= (K00 * P0) % 26 + (K01 * P1) % 26 + (K02 * P2) % 26;\n                        temp1 <= (K10 * P0) % 26 + (K11 * P1) % 26 + (K12 * P2) % 26;\n                        temp2 <= (K20 * P0) % 26 + (K21 * P1) % 26 + (K22 * P2) % 26;\n                    `endif\n                end\n                COMPUTE_MOD: begin\n                    `ifdef BUG_0\n                        C0_reg <= ~(temp0 % 26);\n                        C1_reg <= ~(temp1 % 26);\n                        C2_reg <= ~(temp2 % 26);\n                    `elsif BUG_1\n                        C0_reg <= (temp0 % 26) ^ 5'b11111;\n                        C1_reg <= (temp1 % 26) ^ 5'b11111;\n                        C2_reg <= (temp2 % 26) ^ 5'b11111;\n                    `elsif BUG_2\n                        C0_reg <= (temp0 + 1) % 26;\n                        C1_reg <= (temp1 + 1) % 26;\n                        C2_reg <= (temp2 + 1) % 26;\n                    `elsif BUG_3\n                        C0_reg <= temp0 % 25;\n                        C1_reg <= temp1 % 25;\n                        C2_reg <= temp2 % 25;\n                    `elsif BUG_4\n                        C0_reg <= 5'b0;\n                        C1_reg <= 5'b0;\n                        C2_reg <= 5'b0;\n                    `elsif BUG_5\n                        C0_reg <= (temp0 % 26) + 5'd1;\n                        C1_reg <= (temp1 % 26) + 5'd1;\n                        C2_reg <= (temp2 % 26) + 5'd1;\n                    `else\n                        C0_reg <= temp0 % 26;\n                        C1_reg <= temp1 % 26;\n                        C2_reg <= temp2 % 26;\n                    `endif\n                end\n                default: begin\n                    temp0   <= 12'b0;\n                    temp1   <= 12'b0;\n                    temp2   <= 12'b0;\n                    C0_reg  <= 5'b0;\n                    C1_reg  <= 5'b0;\n                    C2_reg  <= 5'b0;\n                end\n            endcase\n        end\n    end\n\n    assign ciphertext = {C0_reg, C1_reg, C2_reg};\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_icache_controller_0004", "categories": ["cid014", "medium"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the `instruction_cache_controller` module based on the design specifications provided? Below are the module details and design requirements for assertion development.\n\n## **Interface**\n\n### **Inputs**\n- **clk**: The clock signal ensures all sequential operations are synchronized and triggers updates on the rising edge.\n- **rst**: The active-high asynchronous reset signal initializes all states and outputs to their default values immediately when asserted.\n- **io_mem_ready**: A 1-bit handshake signal from memory indicating that the memory is ready to accept a request or provide data.\n- **l1b_addr [17:0]**: An 18-bit address input from the L1 cache, where the higher 9 bits represent the tag for validation and the lower 9 bits specify the block offset.\n- **ram256_t0_data [7:0]**: An 8-bit data input from Tag RAM 0, containing tag or validity information for a specific cache line. This input is used to determine whether the requested data is valid and matches the tag of the cache line.\n- **ram256_t1_data [7:0]**: An 8-bit data signal from Tag RAM 1, containing tag or validity information for a different cache line. This input is used to determine whether the requested data is valid and matches the tag of the cache line.\n- **ram512_d0_data [15:0]**: A 16-bit signal from Data RAM 0 representing the lower half of cached block data.\n- **ram512_d1_data [15:0]**: A 16-bit signal from Data RAM 1 providing the upper half of cached block data.\n\n### **Outputs**\n- **io_mem_valid**: A 1-bit signal is asserted HIGH when a valid memory request is issued by the controller to fetch data during a cache miss.\n- **io_mem_addr [16:0]**: A 17-bit signal specifying the external memory address for reading or writing data during memory transactions.\n- **l1b_wait**: A 1-bit signal asserted to notify the L1 cache to pause new requests while the controller resolves a miss or fetches data.\n- **l1b_data [31:0]**: A 32-bit output signal combining data from Data RAM 0 and Data RAM 1, adjusted for unaligned accesses if required.\n- **ram256_t0_we**: A 1-bit write enable signal for Tag RAM 0, activated during cache updates to store new tags or validity bits.\n- **ram256_t0_addr [7:0]**: An 8-bit address output for Tag RAM 0, specifying the location to access or modify a tag or validity bit.\n- **ram256_t1_we**: A 1-bit write enable signal for Tag RAM 1, used to update tags or validity bits in another cache line.\n- **ram256_t1_addr [7:0]**: An 8-bit address output for Tag RAM 1, specifying the address for tag or validity bit access or modification.\n- **ram512_d0_we**: A 1-bit write enable signal for Data RAM 0, used to store the lower half of a cache line during updates.\n- **ram512_d0_addr [8:0]**: A 9-bit address output for Data RAM 0, identifying the memory location for reading or writing the lower half of a cache line.\n- **ram512_d1_we**: A 1-bit write enable signal for Data RAM 1, activated to store the upper half of a cache line.\n- **ram512_d1_addr [8:0]**: A 9-bit address output for Data RAM 1, specifying the location for accessing or modifying the upper half of a cache line.\n\n## Design Specifications\nThe cache controller manages fetching instruction data, ensuring that valid cached data is used whenever possible. If the requested data is not in the cache, it fetches it from memory and updates the cache.\n\n### Cache Hit and Miss Behavior\n- If the requested data is available in the cache, no memory read should occur.\n- If the data is missing, the controller should initiate a memory fetch by asserting a valid memory request signal.\n\n### State Transitions\n- **Idle**: The controller waits for requests. If the requested data is missing, it initiates a memory fetch.\n- **Read Memory Block 0**: Reads the first part of the instruction from memory.\n- **Read Memory Block 1**: Reads the second part of the instruction from memory.\n- **Read Cache**: Ensures the fetched data is valid and updates the cache if necessary.\n\n### Memory Read Operations\n- The memory request signal should only be active when a read operation is required.\n- The memory address must always be within the allowed range.\n- The controller should only transition between read states when the memory signals indicate readiness.\n\n### Write Enable Control\n- The write enable signal should only be active when updating cache memory.\n- Data should only be written to cache during valid read operations.\n\n### L1 Cache Wait Behavior\n- The wait signal should be active when the cache does not have valid data.\n- The wait signal should be cleared once data is available.\n\n## Assertion Requirements\nDevelop SystemVerilog assertions to validate the following behaviors:\n\n### 1. Reset Behavior\n- When the reset signal is high, all internal states and control signals should be properly initialized.\n- The cache controller should return to its idle state, disable write operations, and clear any pending memory requests.\n\n### 2. Memory Address Validation\n- Ensures that whenever a memory operation is initiated, the memory address remains within the valid 17-bit address range. \n- This check happens in the same cycle when a memory request is active, preventing out-of-bounds memory access.\n\n### 3. Data RAM Address Validation\n- Guarantees that when a write operation is enabled, the memory address falls within the expected 9-bit range. \n- This is checked immediately in the same cycle to prevent invalid memory writes.\n\n### 4. Write Enable Timing Validation\n- Enforces that the write enable signal is only active during memory read operations. \n- If it is asserted, the system must be in either the first or second memory read state within the next two cycles. This prevents accidental writes outside the designated states.\n\n### 5. L1 Cache Wait Validation\n- Ensures that if data is missing in the cache, the wait signal must be asserted in the next cycle. \n- This guarantees that the controller correctly signals a waiting state when required.\n\n### 6. State Transition from IDLE\n- Confirms that if the system is idle and the requested data is missing, it must move to the first memory read state. \n- This transition is checked in the same cycle to ensure immediate response to a cache miss.\n\n### 7. State Transition from the First to the Second Memory Read State\n- Ensures that when the system is fetching the first part of memory and memory becomes ready, it must move to the second read state in the next cycle.\n-  This guarantees that the controller fetches data in a structured manner.\n\n### 8. State Transition from the Second Memory Read State to Cache Read\n- Validates that once the second memory read is completed, the controller must transition to the cache read state in the next cycle. \n- This ensures that the fetched data is correctly processed.\n\n### 9. Write Enable Should Be Disabled in IDLE\n- Ensures that no write operations occur while the system is in the idle state. \n- This is checked in the same cycle to prevent unnecessary writes when no memory operation is ongoing.\n\n### 10. Memory Request Signal Should Be Low in IDLE\n- Confirms that when the system is idle, it should not signal a memory operation. \n- This is checked immediately to ensure no unnecessary memory requests.\n\n### 11. L1 Cache Wait Signal in Cache Read State\n- Ensures that if the system is reading from the cache, the wait signal should only be active if the required data is still not available. \n- This is checked in the same cycle to avoid incorrect cache access behavior.\n\n### 12. Memory Request Signal in the Second Memory Read State\n- Enforces that when the system is fetching the second part of memory, the memory request signal must be high. \n- This ensures uninterrupted fetching and is checked in the same cycle.\n\n### 13. Transition from IDLE when Data is Not Ready\n- Ensures that if the system is idle but cache data is missing, it must move to the first memory read state in the next cycle. \n- This guarantees that missing data is fetched without unnecessary delay.\n\n\n## Deliverables\nPlease provide SystemVerilog assertions that:\n- Cover all the validation requirements listed above.\n- Include clear error messages for easier debugging.\n- Follow industry standards for verification efficiency.\n\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.", "context": {"rtl/instruction_cache_controller.sv": "module instruction_cache_controller (\n    input  wire        clk,                // Clock signal\n    input  wire        rst,                // Reset signal\n\n    output reg         io_mem_valid,       // Indicates that memory operation is valid\n    input  wire        io_mem_ready,       // Indicates that memory is ready for the operation\n    output reg  [16:0] io_mem_addr,        // Address for memory operation\n\n    output reg         l1b_wait,           // Indicates if the L1 cache is still waiting for data\n    output wire [31:0] l1b_data,           // Data output from the L1 cache\n    input  wire [17:0] l1b_addr,           // Address of the L1 cache (18-bits)\n\n    // RAM256_T0 (Tag Memory 0)\n    output wire       ram256_t0_we,        // Write enable for the RAM256_T0 (Tag RAM 0)\n    output wire [7:0] ram256_t0_addr,      // Address for the RAM256_T0 (Tag RAM 0)\n    input  wire [7:0] ram256_t0_data,      // Data read from the RAM256_T0 (Tag RAM 0)\n\n    // RAM256_T1 (Tag Memory 1)\n    output wire       ram256_t1_we,        // Write enable for the RAM256_T1 (Tag RAM 1)\n    output wire [7:0] ram256_t1_addr,      // Address for the RAM256_T1 (Tag RAM 1)\n    input  wire [7:0] ram256_t1_data,      // Data read from the RAM256_T1 (Tag RAM 1)\n\n    // RAM512_D0 (Data Memory 0)\n    output wire        ram512_d0_we,       // Write enable for the RAM512_D0 (Data RAM 0)\n    output wire [8:0]  ram512_d0_addr,     // Address for the RAM512_D0 (Data RAM 0)\n    input  wire [15:0] ram512_d0_data,     // Data read from the RAM512_D0 (Data RAM 0)\n\n    // RAM512_D1 (Data Memory 1)\n    output wire        ram512_d1_we,       // Write enable for the RAM512_D1 (Data RAM 1)\n    output wire [8:0]  ram512_d1_addr,     // Address for the RAM512_D1 (Data RAM 1)\n    input  wire [15:0] ram512_d1_data      // Data read from the RAM512_D1 (Data RAM 1)\n);\n    wire [15:0] data_0;\n    wire [15:0] data_1;\n\n    assign l1b_data = l1b_addr[0] ? {data_0, data_1} : {data_1, data_0};\n\n    localparam TAG_BITS = 8;\n    localparam ADR_BITS = 9;\n\n    localparam IDLE      = 3'd0,\n               READMEM0  = 3'd1,\n               READMEM1  = 3'd2,\n               READCACHE = 3'd3;\n\n    reg [2:0] state, next_state;\n    reg [ADR_BITS-1:0] addr_0, addr_1;\n    reg write_enable;\n\n    wire [ADR_BITS-1:0] data_addr_0 = l1b_addr[17:9] + {{8{1'b0}}, l1b_addr[0]};\n    wire [ADR_BITS-1:0] data_addr_1 = l1b_addr[17:9];\n\n    wire valid_0, valid_1;\n    wire [TAG_BITS-1:0] tag_0, tag_1;\n\n    wire data_0_ready = (l1b_addr[17:9] == tag_0) && valid_0;\n    wire data_1_ready = (l1b_addr[17:9] == tag_1) && valid_1;\n\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            write_enable <= 1'b0;\n            addr_0 <= {ADR_BITS{1'b0}};\n            addr_1 <= {ADR_BITS{1'b0}};\n        end else begin\n            if ((state == READMEM0 || state == READMEM1) && io_mem_ready) begin\n                write_enable <= 1'b1;\n            end else begin \n                write_enable <= 1'b0;\n            end\n            state <= next_state;\n            addr_0 <= data_addr_0;\n            addr_1 <= data_addr_1;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        io_mem_valid = 1'b0;\n        io_mem_addr = {17{1'b0}};\n        l1b_wait = 1'b1;\n\n        case (state)\n            IDLE: begin\n                l1b_wait = 1'b0;\n                if (!data_0_ready || !data_1_ready)\n                    next_state = READMEM0;\n            end\n            READMEM0: begin\n                io_mem_addr = {l1b_addr[17:9], data_addr_0[7:0]};\n                io_mem_valid = 1'b1;\n                if (io_mem_ready)\n                    next_state = READMEM1;\n            end\n            READMEM1: begin\n                io_mem_addr = {l1b_addr[17:9], data_addr_1[7:0]};\n                io_mem_valid = 1'b1;\n                if (io_mem_ready)\n                    next_state = READCACHE;\n            end\n            READCACHE: begin\n                l1b_wait = ~(data_0_ready && data_1_ready);\n                if (!data_0_ready)\n                    next_state = READMEM0;\n                else if (!data_1_ready)\n                    next_state = READMEM1;\n                else\n                    next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    assign ram512_d0_we = write_enable;\n    assign ram512_d0_addr = addr_0;\n    assign data_0 = ram512_d0_data;\n\n    assign ram512_d1_we = write_enable;\n    assign ram512_d1_addr = addr_1;\n    assign data_1 = ram512_d1_data;\n\n    tag_controller tag_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .write_enable(write_enable),\n        .write_addr(io_mem_addr[ADR_BITS-1:0]),\n        .data_0_out({valid_0, tag_0}),\n        .read_addr_0(data_addr_0[7:0]),\n        .data_1_out({valid_1, tag_1}),\n        .read_addr_1(data_addr_1[7:0]),\n        .ram_t0_we(ram256_t0_we),\n        .ram_t0_addr(ram256_t0_addr),\n        .ram_t0_data(ram256_t0_data),\n        .ram_t1_we(ram256_t1_we),\n        .ram_t1_addr(ram256_t1_addr),\n        .ram_t1_data(ram256_t1_data)\n    );\n\nendmodule\n\n\nmodule tag_controller (\n   input wire clk,                     // Clock signal\n   input wire rst,                     // Reset signal\n\n   // Port 0: Write operation (W)\n   input wire       write_enable,      // Enable write operation\n   input wire [8:0] write_addr,        // Write address (9 bits)\n\n   // Port 0: Read operation for address 0 (R)\n   output reg [8:0] data_0_out,        // Data output for read operation on address 0 (9 bits)\n   input  wire [7:0] read_addr_0,      // Read address for tag memory 0 (8 bits)\n\n   // Port 1: Read operation for address 1 (R)\n   output reg [8:0] data_1_out,        // Data output for read operation on address 1 (9 bits)\n   input  wire [7:0] read_addr_1,      // Read address for tag memory 1 (8 bits)\n\n   // RAM256_T0 (Tag Memory 0)\n   output reg       ram_t0_we,         // Write enable for the RAM256_T0 (Tag RAM 0)\n   output reg [7:0] ram_t0_addr,       // Address for the RAM256_T0 (Tag RAM 0)\n   input  wire [7:0] ram_t0_data,      // Data read from the RAM256_T0 (Tag RAM 0)\n\n   // RAM256_T1 (Tag Memory 1)\n   output reg       ram_t1_we,         // Write enable for the RAM256_T1 (Tag RAM 1)\n   output reg [7:0] ram_t1_addr,       // Address for the RAM256_T1 (Tag RAM 1)\n   input  wire [7:0] ram_t1_data       // Data read from the RAM256_T1 (Tag RAM 1)\n);\n   reg [511:0] RAM;\n\n   wire [7:0] tag_0_data;\n   wire [7:0] tag_1_data;\n\n   wire [7:0] tag_addr_0 = write_enable ? write_addr[7:0] : read_addr_0;\n   wire [7:0] tag_addr_1 = write_enable ? write_addr[7:0] : read_addr_1;\n\n   always @(posedge clk or posedge rst) begin\n       if (rst) begin\n           RAM <= 0;\n           ram_t0_we <= 1'b0;  \n           ram_t1_we <= 1'b0;  \n           ram_t0_addr <= 8'b0; \n           ram_t1_addr <= 8'b0; \n           data_0_out <= 9'b0;\n           data_1_out <= 9'b0;\n       end else if (write_enable) begin\n           RAM[write_addr[7:0]] <= 1'b1;\n       end\n   end\n\n   assign tag_0_data = ram_t0_data;\n   assign tag_1_data = ram_t1_data;\n\n   always @(*) begin\n       ram_t0_addr = tag_addr_0;\n       ram_t1_addr = tag_addr_1;\n\n       data_0_out = {RAM[read_addr_0], tag_0_data};\n       data_1_out = {RAM[read_addr_1], tag_1_data};\n\n       ram_t0_we = (~write_addr[0]) && write_enable;\n       ram_t1_we = write_addr[0] && write_enable;\n   end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/instruction_cache_controller.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/instruction_cache_controller.sv\nTOPLEVEL        = instruction_cache_controller\nMODULE          = test_instruction_cache_controller\nPYTHONPATH      = /src\nRANDOM_SEED     = 1736275973\nHASH            = c5da356229f42ccf928b6db74d57c9e746468aab", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_instruction_cache_controller.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\nimport harness_library as hrs_lb\n\ndef calculate_expected_data(data_0, data_1, unaligned):\n\n    if unaligned:\n        return (data_0 << 16) | data_1\n    else:\n        return (data_1 << 16) | data_0\n\n\n@cocotb.test()\nasync def test_instruction_cache_controller(dut):\n\n    # Start clock\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Reset initialization\n    await hrs_lb.dut_init(dut)\n    await hrs_lb.reset_dut(dut.rst, duration_ns=25, active=False)\n    await RisingEdge(dut.clk)\n    # Simulate a memory read sequence\n    for _ in range(10):\n        \n        dut.io_mem_ready.value = random.choice([0, 1])\n        dut.l1b_addr.value = random.randint(0, 0x3FFFF)  # Random L1 cache address\n\n        data_0 = random.randint(0, 0xFFFF)\n        data_1 = random.randint(0, 0xFFFF)\n        dut.ram512_d0_data.value = data_0\n        dut.ram512_d1_data.value = data_1\n\n        # Verify output signals\n        unaligned = int(dut.l1b_addr.value) & 0x1\n        expected_data = calculate_expected_data(data_0, data_1, unaligned)\n\n        if dut.l1b_wait.value == 0:\n            assert int(dut.l1b_data.value) == expected_data, (\n                f\"Mismatch in l1b_data. Expected: {expected_data:#010X}, Got: {int(dut.l1b_data.value):#010X}\"\n            )\n        await RisingEdge(dut.clk)\n    # Test corner cases\n    dut._log.info(\"Testing corner cases...\")\n\n    corner_cases = [\n        (0x00000, False),  # Minimum address (aligned)\n        (0x3FFFF, True),   # Maximum address (unaligned)\n        (0x123FE, False),  # Near boundary, aligned\n        (0x123FF, True),   # Near boundary, unaligned\n    ]\n\n    for addr, unaligned in corner_cases:\n        dut.io_mem_ready.value = random.choice([0, 1])\n        dut.l1b_addr.value = addr\n        data_0 = random.randint(0, 0xFFFF)\n        data_1 = random.randint(0, 0xFFFF)\n        dut.ram512_d0_data.value = data_0\n        dut.ram512_d1_data.value = data_1\n\n        # Verify output signals\n        unaligned = dut.l1b_addr.value\n        expected_data = calculate_expected_data(data_0, data_1, unaligned)\n\n        if dut.l1b_wait.value == 0:\n            assert int(dut.l1b_data.value) == expected_data, (\n                f\"Corner Case Mismatch for address {addr:#06X}: Expected {expected_data:#010X}, Got {int(dut.l1b_data.value):#010X}\"\n            )\n        else:\n            dut._log.info(f\"Corner Case Success for address {addr:#06X}: Data is being fetched.\")\n        await RisingEdge(dut.clk)\n\n    # Test random cases\n    dut._log.info(\"Testing random cases...\")\n    for _ in range(20):\n        addr = random.randint(0, 0x3FFFF)\n        unaligned = addr & 0x1\n        data_0 = random.randint(0, 0xFFFF)\n        data_1 = random.randint(0, 0xFFFF)\n\n        dut.l1b_addr.value = addr\n        dut.ram512_d0_data.value = data_0\n        dut.ram512_d1_data.value = data_1\n\n        expected_data = calculate_expected_data(data_0, data_1, unaligned)\n\n        if dut.l1b_wait.value == 0:\n            assert int(dut.l1b_data.value) == expected_data, (\n                f\"Random Case Mismatch for address {addr:#06X}: Expected {expected_data:#010X}, Got {int(dut.l1b_data.value):#010X}\"\n            )\n        else:\n            dut._log.info(f\"Random Case Success for address {addr:#06X}: Data is being fetched.\")\n        await RisingEdge(dut.clk)\n    # End simulation with no errors\n    dut._log.info(\"Test completed successfully.\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_image_rotate_0010", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the given SystemVerilog testbench to add a **checker** to validate the output of an **image rotation module** that rotates an input matrix by **0\u00b0, 90\u00b0, 180\u00b0, or 270\u00b0**. The stimulus is provided, and the new checker implementation should verify that the **DUT (Design Under Test)** correctly transforms the input image according to the expected rotation behavior.\n\n---\n\n## **Design Specifications**\n\n### **1. Parameterization**\n| Parameter     | Description                                       | Default Value         |\n|---------------|---------------------------------------------------|-----------------------|\n| `IN_ROW`      | Number of input image rows                        | `3`                   |\n| `IN_COL`      | Number of input image columns                     | `2`                   |\n| `OUT_ROW`     | Number of output rows (`max(IN_ROW, IN_COL)`)     | `max(IN_ROW, IN_COL)` |\n| `OUT_COL`     | Number of output columns (`max(IN_ROW, IN_COL)`)  | `max(IN_ROW, IN_COL)` |\n| `DATA_WIDTH`  | Bit width of each pixel value                     | `8`                   |\n\n### **2. Functionality**\n- The module **performs a 2D image rotation** of an `IN_ROW \u00d7 IN_COL` image matrix based on the `rotation_angle`.  \n- The design is **fully combinational**, meaning that the output **image_out** is produced **immediately** when `image_in` and `rotation_angle` are applied.  \n- If the **input image is not square**, the module **pads it with zeros** to form a square matrix before rotation.  \n- The input and output images are represented as **flattened 1D arrays**.  \n\n### **3. Rotation Behavior**\n| Rotation Angle (`rotation_angle`) | Transformation                                           |\n|-----------------------------------|----------------------------------------------------------|\n| `00` (Clockwise 90\u00b0)              | **Transpose** the image, then **reverse the rows**       |\n| `01` (Clockwise 180\u00b0)             | **Reverse both rows and columns**                        |\n| `10` (Clockwise 270\u00b0)             | **Transpose** the image, then **reverse the columns**    |\n| `11` (0\u00b0)                         | **Output matches input (Pass-through the padded image)** |\n\n---\n\n## **Image Processing and Transformation**\n\n### **1. Example of Image Matrix Flattening**\n\nSuppose you have Image matrix:\n\n- **Image Matrix (3x2)**:\n\n```text\n| a11  a12 |\n| a21  a22 |\n| a31  a32 |\n```\n\nThe flattened representation of this image matrix will be as follows:\n\n- **Flattened Image Matrix (3x2)**:\n\n```text\nimage matrix = {a32, a31, a22, a21, a12, a11}\n```\n\n### **2. Input Padding for Non-Square Images**\n- If `IN_ROW \u2260 IN_COL`, the module **pads the image with zeros** to create a `max(IN_ROW, IN_COL) \u00d7 max(IN_ROW, IN_COL)` square matrix.  \n- **Example (3\u00d72 image padded to 3\u00d73):** \n\n\n- **Input Image (3x2)**:\n\n```text\n| a11  a12 |\n| a21  a22 |\n| a31  a32 |\n```\n\n- **Padded Image (3x3)**:\n\n```text\n| a11  a12  0|\n| a21  a22  0|\n| a31  a32  0|\n```\n\n---\n\n## **Module Interface**\n\n### **Inputs**\n- `rotation_angle [1:0]` - Defines the rotation:  \n  - `00` \u2192 90\u00b0  \n  - `01` \u2192 180\u00b0  \n  - `10` \u2192 270\u00b0  \n  - `11` \u2192 0\u00b0  \n- `image_in [(IN_ROW*IN_COL*DATA_WIDTH)-1:0]` - Input image matrix.  \n\n### **Outputs**\n- `image_out [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0]` - Rotated image output.  \n\n---\n\n## **Testbench Requirements**\n\n### **1. Instantiation**\n- `image_rotate` is already instantiated as `image_rotate_inst` with input/output connections.  \n\n### **2. Testbench Components**\n\n#### **Parameters**\n- `IN_ROW`, `IN_COL`: Input Image dimensions for rotation.  \n- `OUT_ROW`, `OUT_COL`: Output Image dimensions, determined dynamically.  \n- `DATA_WIDTH`: Bit width per pixel.  \n\n#### **Signals**\n- `rotation_angle`: Defines the angle of rotation (`00`, `01`, `10`, `11`).  \n- `image_in`: Input image matrix, applied to the DUT.  \n- `image_out`: Output image matrix, expected to match rotated input.  \n- `image_out_expected`: Expected rotated output for verification.  \n- `image_out_matched`: Indicates whether `image_out` matches the expected result.  \n\n### **3. Design Under Test (DUT)**\n- The **stimulus generator** is already provided, which applies `image_in` and `rotation_angle` to the DUT.\n- The testbench should focus on writing a checker that verifies correctness.\n\n### **4. Checker Functionality**\n- Implement a **checker logic** that:\n  - Computes the **expected rotated image** using a **reference model**.\n  - Compares DUT output (`image_out`) against the expected result (`image_out_expected`).\n  - Reports errors using `$error` when mismatches occur.\n\n### **5. Test Procedure**\n- Iterate through **multiple test cases**, each with:\n  - A **randomly selected or predefined** input image.  \n  - A **randomly generated rotation angle** using `$urandom_range(3,0)`.  \n  - Computation of the **expected rotated image** using a reference model.  \n  - **Comparison of DUT output** with expected output.  \n  - **Logging results** (pass/fail).\n\n---\n\n## **Expected Deliverables**\n- **SystemVerilog checker** that verifies the `image_rotate` module's output against expected results.\n", "context": {"verif/tb_image_rotate.sv": "module tb_image_rotate ();\n\n  parameter IN_ROW = 3;\n  parameter IN_COL = 2;\n  \n  parameter OUT_ROW     = (IN_ROW > IN_COL) ? IN_ROW : IN_COL;\n  parameter OUT_COL     = (IN_ROW > IN_COL) ? IN_ROW : IN_COL;\n  parameter DATA_WIDTH  = 8                                  ;\n  parameter NUM_SAMPLES = 10                                 ;\n\n  logic [        1:0]                              rotation_angle         ;\n  logic [ IN_ROW-1:0][ IN_COL-1:0][DATA_WIDTH-1:0] image_in               ;\n  logic [OUT_ROW-1:0][OUT_COL-1:0][DATA_WIDTH-1:0] image_out              ;\n\n  image_rotate #(\n    .IN_ROW    (IN_ROW    ),\n    .IN_COL    (IN_COL    ),\n    .DATA_WIDTH(DATA_WIDTH)\n  ) image_rotate_inst (\n    .rotation_angle(rotation_angle),\n    .image_in      (image_in),\n    .image_out     (image_out)\n  );\n\n  initial begin\n    \n    $display(\"Applying Stimulus . . . .\");\n    for (int pattern_id = 0; pattern_id < 5; pattern_id++) begin\n      for (int sample = 0; sample < NUM_SAMPLES; sample++) begin\n        rotation_angle = $urandom_range(3, 0); \n        image_in = gen_task(pattern_id);\n        #10;\n      end\n    end\n\n    $display(\"Stimulus has been applied!\");\n\n    #20;\n    $finish;\n  end\n\n  function automatic logic [(IN_ROW * IN_COL * DATA_WIDTH) - 1:0] gen_task(input int pattern_id);\n    logic [(IN_ROW * IN_COL * DATA_WIDTH) - 1:0] pattern_image;\n    begin\n      for (int i = 0; i < (IN_ROW * IN_COL); i++) begin\n        case (pattern_id)\n          0: pattern_image[i * DATA_WIDTH +: DATA_WIDTH] = $urandom_range((1 << DATA_WIDTH) - 1, 0);\n          1: pattern_image[i * DATA_WIDTH +: DATA_WIDTH] = '0;\n          2: pattern_image[i * DATA_WIDTH +: DATA_WIDTH] = {(DATA_WIDTH){1'b1}};\n          3: pattern_image[i * DATA_WIDTH +: DATA_WIDTH] = (i[0]) ? {(DATA_WIDTH){1'b1}} : '0;\n          4: pattern_image[i * DATA_WIDTH +: DATA_WIDTH] = i % (1 << DATA_WIDTH);\n          default: pattern_image[i * DATA_WIDTH +: DATA_WIDTH] = '0;\n        endcase\n      end\n      return pattern_image;\n    end\n  endfunction\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_image_rotate.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 10-tb-checker-generation-for-image-rotate\nNUM_BUGS        = 3", "src/image_rotate.sv": "module image_rotate #(\n  parameter IN_ROW     = 3                                  , // Number of rows in input matrix\n  parameter IN_COL     = 2                                  , // Number of columns in input matrix\n  parameter OUT_ROW    = (IN_ROW > IN_COL) ? IN_ROW : IN_COL, // Output rows after padding\n  parameter OUT_COL    = (IN_ROW > IN_COL) ? IN_ROW : IN_COL, // Output columns after padding\n  parameter DATA_WIDTH = 8                                    // Bit-width of data\n) (\n  input  logic [                             1:0] rotation_angle, // Rotation angle (00: 90\u00b0, 01: 180\u00b0, 10: 270\u00b0, 11: No Rotation)\n  input  logic [  (IN_ROW*IN_COL*DATA_WIDTH)-1:0] image_in      , // Flattened input image\n  output logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] image_out       // Flattened output image\n);\n\n  logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] padded_image    ; // Padded square image\n  logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] transposed_image; // Transposed square image\n\n  // Step 1: Pad the input image into a square matrix\n  always @(image_in, rotation_angle) begin\n    for (int pad_row = 0; pad_row < OUT_ROW; pad_row++) begin: pad_row_block\n      for (int pad_col = 0; pad_col < OUT_COL; pad_col++) begin: pad_col_block\n        if ((pad_row < IN_ROW) && (pad_col < IN_COL)) begin\n          // Copy input data into padded_image\n          padded_image[((pad_row * OUT_COL) + pad_col) * DATA_WIDTH +: DATA_WIDTH] = image_in[(pad_row * IN_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH];\n        end else begin\n          // Fill remaining positions with zeros\n        `ifndef BUG_0\n          padded_image[(pad_row * OUT_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH] = '0;\n        `else \n          padded_image[(pad_row * OUT_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH] = '1;\n        `endif\n        end\n      end\n    end\n  end\n\n  // Step 2: Transpose the padded image\n  always @* begin\n    for (int trans_row = 0; trans_row < OUT_ROW; trans_row++) begin: trans_row_block\n      for (int trans_col = 0; trans_col < OUT_COL; trans_col++) begin: trans_col_block\n        // Transpose logic: Swap rows and columns\n      `ifndef BUG_1\n        transposed_image[(trans_col * OUT_ROW + trans_row) * DATA_WIDTH +: DATA_WIDTH] = padded_image[(trans_row * OUT_COL + trans_col) * DATA_WIDTH +: DATA_WIDTH];\n      `else     \n        transposed_image[(trans_row * OUT_COL + trans_col) * DATA_WIDTH +: DATA_WIDTH] = padded_image[(trans_row * OUT_COL + trans_col) * DATA_WIDTH +: DATA_WIDTH];\n      `endif\n      end\n    end\n  end\n\n  // Step 3: Apply rotation logic\n  always @* begin\n    for (int rot_row = 0; rot_row < OUT_ROW; rot_row++) begin: rot_row_block\n      for (int rot_col = 0; rot_col < OUT_COL; rot_col++) begin: rot_col_block\n        case (rotation_angle)\n          // 90\u00b0 Clockwise: Transpose + Reverse Rows\n        `ifndef BUG_2\n          2'b00: image_out[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] = transposed_image[(rot_row * OUT_COL + (OUT_COL-1-rot_col)) * DATA_WIDTH +: DATA_WIDTH];\n        `else\n          2'b00: image_out[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] = padded_image[(rot_row * OUT_COL + (OUT_COL-1-rot_col)) * DATA_WIDTH +: DATA_WIDTH];\n        `endif\n\n          // 180\u00b0 Clockwise: Reverse Rows and Columns\n          2'b01: image_out[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] = padded_image[((OUT_ROW-1-rot_row) * OUT_COL + (OUT_COL-1-rot_col)) * DATA_WIDTH +: DATA_WIDTH];\n\n          // 270\u00b0 Clockwise: Transpose + Reverse Columns\n          2'b10: image_out[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] = transposed_image[((OUT_ROW-1-rot_row) * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH];\n\n          // No Rotation (Pass-through)\n          default: image_out[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] = padded_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH];\n        endcase\n      end\n    end\n  end\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_image_stego_0014", "categories": ["cid012", "medium"], "input": {"prompt": "Develop a SystemVerilog module named `tb_image_stego` that generates input stimulus to verify the `image_stego` module. The `image_stego` module embeds bits of data into an image. Each pixel is 8 bits, and up to 4 bits can be embedded according to a `mask` control. The data bits are first XOR-encrypted by an 8-bit key. The purpose of `tb_image_stego` is to thoroughly test all features of the `image_stego` module, achieving complete functional and toggle coverage.\n\n---\n\n## Module Interface\n\n### **Parameters**\n- **`row`** *(default = 2)*  \n  Number of rows in the image.\n\n- **`col`** *(default = 2)*  \n  Number of columns in the image.\n\n- **`EMBED_COUNT_WIDTH`** *(default = 3)*  \n  Width of the `embedded_pixel_count` output.\n\n*(Each pixel is 8 bits, so total bits in `img_in` and `img_out` is `row * col * 8`.)*\n\n---\n\n## Port List\n\n| **Port Name**                                | **Direction** | **Width**                     | **Description**                                                                                                                      |\n|----------------------------------------------|---------------|-------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|\n| `img_in[(row*col*8)-1:0]`                    | **Input**     | `row*col*8` bits              | Contains the original image data, 8 bits per pixel.                                                                                  |\n| `data_in[(row*col*4)-1:0]`                   | **Input**     | `row*col*4` bits              | Data bits to be embedded, allowing up to 4 bits per pixel.                                                                           |\n| `bpp[2:0]`                                   | **Input**     | 3 bits                        | Indicates how many bits per pixel to embed: `000=1`, `001=2`, `010=3`, `011=4`. Other values are invalid and result in no embedding. |\n| `encryption_key[7:0]`                        | **Input**     | 8 bits                        | Key used for XOR encryption of `data_in`.                                                                                            |\n| `mask[(row*col)-1:0]`                        | **Input**     | `row*col` bits                | Pixel-wise mask enabling embedding: `1=embed`, `0=pass-through`.                                                                     |\n| `img_out[(row*col*8)-1:0]`                   | **Output**    | `row*col*8` bits              | Image data after embedding the specified bits into some (or none) of the pixels.                                                     |\n| `error_out`                                  | **Output**    | 1 bit                         | Indicates odd parity in `data_in`.                                                                                                   |\n| `embedded_pixel_count[EMBED_COUNT_WIDTH-1:0]`| **Output**    | `EMBED_COUNT_WIDTH` bits      | Holds the total count of pixels in which data was actually embedded.                                                                 |\n| `embedding_done[1:0]`                        | **Output**    | 2 bits                        | Reflects the embedding status: `00=Idle`, `01=In-progress`, `10=Done`, `11=No-embed`.                                                |\n\n---\n\n## Functional Description\n\n1. **Parity Checking**  \n   - The module calculates the XOR of all bits in `data_in`. If an **odd** number of bits in `data_in` is set to 1, `error_out` is driven high (`1`).  \n   - This ensures the system can detect if the embedded data has non-even parity.\n\n2. **Encryption**  \n   - The bits of `data_in` are split into 8-bit blocks. Each block is XORed with the 8-bit `encryption_key`.  \n   - This process creates an **encrypted** data stream, referred to internally as `data_in_encrypted`.\n\n3. **Embedding**  \n   - The image has `(row * col)` pixels, each indexed by `i` ranging from `0` to `row * col - 1`.  \n   - For each pixel `i`, if `mask[i]` is `1`, the module replaces the **lowest** bits (based on `bpp`) in `img_in[i*8 +: 8]` with bits from `data_in_encrypted`.  \n   - **Incrementing Embedded Pixel Count**:  \n     - Each time a pixel is modified, `embedded_pixel_count` is incremented by `1`.  \n   - **`embedding_done` Transitions**:  \n     - **`2'b01` (In-progress)**: Once embedding starts (i.e., at least one `mask[i] == 1` pixel is encountered).  \n     - **`2'b10` (Done)**: Set when at least one pixel has been embedded successfully.  \n     - **`2'b11` (No-embed)**: If `mask != 0` but no bits actually get embedded (e.g., because `bpp` is invalid).\n\n4. **Idle vs. Non-Idle**  \n   - **Idle**: If `mask == 0`, the module does not modify any pixels, so `img_out` equals `img_in`.  \n   - **Non-Idle**: If `mask != 0`, embedding logic attempts to modify pixels. However, if it results in no modified pixels for some reason (e.g., `bpp` is invalid), `embedding_done` becomes `2'b11`.\n\n---\n\n## Instantiation\n\nUse an instance of `image_stego` named `uut` within the testbench `tb_image_stego`.\n\n---\n\n## Required Stimulus Description\n\nThe objective is to achieve **100% code and toggle coverage** for the `image_stego` module by systematically exercising its functionality. The stimulus should ensure that all key features, edge cases, and status transitions of the design are thoroughly tested to maintain coverage goals.\n\n| **Test Condition**          | **Purpose**                                                                                                                                                                            |\n|-----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **BPP Variations**          | Embedding for `bpp = 000, 001, 010, 011`, ensuring the correct number of bits are replaced in each pixel. Other `bpp` values should result in no embedding to cover the `2'b11` state. |\n| **Mask Patterns**           | Embedding for different mask patterns (e.g., all zeros, all ones, partial patterns).                                                                                                   |\n| **Encryption Keys**         | Ensure the XOR process covers various `encryption_key` values (0x00, 0xFF, random, etc.).                                                                                              |\n| **Parity Checks**           | Provide even and odd `data_in` to check proper assertion of `error_out`.                                                                                                               |\n| **Pixel Count**             | `embedded_pixel_count` increments only for pixels that are actually embedded.                                                                                                          |\n| **Embedding Done States**   | Test `embedding_done` transitions: `00 (Idle)` \u2192 `01 (In-progress)` \u2192 `10 (Done)` or `11 (No-embed)`.                                                                                  |\n| **Randomized Scenarios**    | Randomize `img_in`, `data_in`, `bpp`, `encryption_key`, and `mask` to cover unexpected corner cases.                                                                                   |", "context": {}}, "output": {"response": "", "context": {"verif/image_stego_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 94311fe0c984ef0e3b64652a0c4a45c16b8e389a\nTARGET = 100", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/image_stego.sv": "`timescale 1ns/1ps\nmodule image_stego #(\n  parameter row = 2,\n  parameter col = 2,\n  parameter EMBED_COUNT_WIDTH = 3\n)(\n  input [(row*col*8)-1:0] img_in,\n  input [(row*col*4)-1:0] data_in,\n  input [2:0] bpp,\n  input [7:0] encryption_key,\n  input [(row*col)-1:0] mask,\n  output reg [(row*col*8)-1:0] img_out,\n  output reg error_out,\n  output reg [EMBED_COUNT_WIDTH-1:0] embedded_pixel_count,\n  output reg [1:0] embedding_done\n);\n\ninteger p;\nreg parity;\nalways @(*) begin\n  parity = 0;\n  for (p = 0; p < (row*col*4); p = p + 1) begin\n    parity = parity ^ data_in[p];\n  end\n  error_out = (parity == 1);\nend\n\nreg [(row*col*4)-1:0] data_in_encrypted;\ninteger block;\nalways @(*) begin\n  data_in_encrypted = 0;\n  for (block = 0; block < (row*col*4); block = block + 8) begin\n    data_in_encrypted[block +: 8] = data_in[block +: 8] ^ encryption_key;\n  end\nend\n\ninteger i;\nalways @(*) begin\n  img_out = img_in;\n  embedded_pixel_count = 0;\n  embedding_done = 2'b00;\n  if (mask != 0) begin\n    embedding_done = 2'b01;\n    for (i = 0; i < (row*col); i = i + 1) begin\n      if (mask[i]) begin\n        case (bpp)\n          3'b000: img_out[i*8 +: 8] = {img_in[i*8 + 1 +: 7], data_in_encrypted[i]};\n          3'b001: img_out[i*8 +: 8] = {img_in[i*8 + 2 +: 6], data_in_encrypted[(2*i) +: 2]};\n          3'b010: img_out[i*8 +: 8] = {img_in[i*8 + 3 +: 5], data_in_encrypted[(3*i) +: 3]};\n          3'b011: img_out[i*8 +: 8] = {img_in[i*8 + 4 +: 4], data_in_encrypted[(4*i) +: 4]};\n          default: img_out[i*8 +: 8] = img_in[i*8 +: 8];\n        endcase\n        if (bpp <= 3'b011) begin\n          embedded_pixel_count = embedded_pixel_count + 1;\n        end\n      end\n    end\n    if (embedded_pixel_count > 0) begin\n      embedding_done = 2'b10;\n    end else begin\n      embedding_done = 2'b11;\n    end\n  end\nend\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_ir_receiver_0013", "categories": ["cid014", "medium"], "input": {"prompt": " Create SystemVerilog Assertions to verify the **functional correctness** of the `ir_receiver` module. The properties should ensure that:  \n\n1. **Start Condition Timing**:  The `started` signal is asserted within **25 clock cycles** after `ir_signal_in` goes HIGH and `started` is LOW.  \n\n2. **Decoding Starts Only if Started**:  The module transitions to the `decoding` state only if the `started` signal was previously asserted.  \n\n3. **Frame Has Minimum Bits**:  The module transitions to the `finish` state only after capturing at least **12 bits** in the `decoding` state.  \n\n4. **Output Valid in Finish State**:  The `ir_output_valid` signal is only asserted in the `finish` state.  \n\n5. **Output Valid Not in Frame Space**:  The `ir_output_valid` signal is never asserted in the `frame_space` state.  \n\n6. **Valid Device Address**:  The `ir_device_address_out` signal always has a valid value when `ir_output_valid` is asserted.  \n\nEach assertion must provide a **detailed failure message**, including the current state, input signals, and relevant outputs for debugging purposes.  \n\n---\n\n### RTL Specification  \n\nThe `ir_receiver` module decodes an IR signal into a function code and device address. It operates based on a state machine and validates the input signal to ensure correct decoding.  \n\n#### Module Name: `ir_receiver`\n\n\n#### **Sony IR Frame Structure**  \n| **Phase**         | **Description**                                                              | **Timing**          |\n|-------------------|------------------------------------------------------------------------------|---------------------|\n| **Start Bit**     | The frame begins with a **2.4 ms HIGH pulse**                                | 2.4 ms              |\n| **Data Bits**     | The frame consists of **12 bits**. Each bit is encoded as follows:           |                     |\n|                   | - **0:** A LOW pulse of **0.6 ms** followed by a HIGH pulse of **0.6 ms**.   | 0.6 ms + 0.6 ms     |\n|                   | - **1:** A LOW pulse of **0.6 ms** followed by a HIGH pulse of **1.2 ms**.   | 0.6 ms + 1.2 ms     |\n| **Frame Space**   | The frame ends after completing **45 ms** before the next frame starts.      | 45-2.4-(12 bit) ms  |\n\n#### **States in the State Machine**\n\n1. **IDLE**:\n   - Waits for the start bit. If the start condition is detected, it transitions to the `START` state.\n\n2. **START**:\n   - Validates the **2.4 ms HIGH pulse** to confirm the start bit.\n   - On successful detection, transition to the `DECODING` state; otherwise, transition back to `IDLE` on failure.\n\n3. **DECODING**:\n   - Decodes the 12-bit data by detecting each bit\u2019s HIGH and LOW timing.\n   - Distinguishes between `0` and `1` based on pulse widths. When all 12 bits are decoded, transitions to the `FINISH` state.\n\n4. **FINISH**:\n   - Extract the 12-bit IR Frame from the received IR signal.\n   - Asserts the valid signal and outputs the decoded data. Then transitions to the `FRAME_SPACE` state.\n\n5. **FRAME_SPACE**:\n   - Monitors the 45 ms frame space. If the space duration completes, transition back to `IDLE`.\n\n#### **Decoding Logic**\nThe module must:\n   - Decode a 12-bit frame extracted from `FINISH` state\n   - Extract:\n     - **Function Code**: The lower 7 bits of the frame (`ir_function_code_out`).\n     - **Device Address**: The upper 5 bits of the frame (`ir_device_address_out`).\n   - Output a **valid signal** (`ir_output_valid`) indicating successful decoding.\n\n\n#### **Function decoding Table Commands **\nCommand is the LSB 7-bit Information received in 12-bit frame.\n| **Command (decimal)** | **Function**    | **ir_function_code_out** |\n|-----------------------|-----------------|--------------------------|\n| `0`                   | digit 1         | `7'b000_0001`            |\n| `1`                   | digit 2         | `7'b000_0010`            |\n| `2`                   | digit 3         | `7'b000_0011`            |\n| `3`                   | digit 4         | `7'b000_0100`            |\n| `4`                   | digit 5         | `7'b000_0101`            |\n| `5`                   | digit 6         | `7'b000_0110`            |\n| `6`                   | digit 7         | `7'b000_0111`            |\n| `7`                   | digit 8         | `7'b000_1000`            |\n| `8`                   | digit 9         | `7'b000_1001`            |\n| `9`                   | digit 0         | `7'b000_0000`            |\n| `16`                  | channel +       | `7'b001_1111`            |\n| `17`                  | channel -       | `7'b010_1111`            |\n| `18`                  | volume +        | `7'b011_1111`            |\n| `19`                  | volume -        | `7'b100_1111`            |\n| `20`                  | mute            | `7'b101_1111`            |\n| `21`                  | power           | `7'b110_1111`            |\n| `22`                  | pause           | `7'b111_1111`            |\n\n\n#### **Address Decoding Table**\nAddress is the MSB 5-bit Information received in 12-bit frame.\n| **Address** | **Device**      | **ir_device_address_out** |\n|-------------|-----------------|---------------------------|\n| `0`         | TV              | `5'b00001`                |\n| `1`         | HDMI1           | `5'b00010`                |\n| `2`         | USB             | `5'b00100`                |\n| `3`         | HDMI2           | `5'b01000`                |\n| `4`         | VCR             | `5'b10000`                |\n\n---\n\n#### IO Ports  \n\n| Port Name                   | Direction| Size       | Description                                        |\n|-----------------------------|----------|------------|----------------------------------------------------|\n| `reset_in`                  | Input    | 1 bit      | Asynchronous Active-high reset                     |\n| `clk_in`                    | Input    | 1 bit      | Positive Edge System clock (10 KHz, 100us)         |\n| `ir_signal_in`              | Input    | 1 bit      | Input signal (IR)                                  |\n| `ir_function_code_out[6:0]` | Output   | 7 bits     | Decoded output for different functions             |\n| `ir_device_address_out[4:0]`| Output   | 5 bits     | Decoded device address                             |\n| `ir_output_valid`           | Output   | 1 bit      | Indicates validity of the decoded frame            |\n", "context": {"rtl/ir_receiver.sv": "module ir_receiver (\n    input  logic        reset_in,               // Active HIGH reset\n    input  logic        clk_in,                 // System clock (10 KHz, 100us)\n    input  logic        ir_signal_in,           // Input signal (IR)\n    output logic [6:0]  ir_function_code_out,   // Decoded output for different functions\n    output logic [4:0]  ir_device_address_out,  // \"00001\": TV, \"00010\":HDMI1, \"00100\":USB, \"01000\":HDMI2, \"10000\": VCR\n    output logic        ir_output_valid         // Indicates validity of the decoded frame\n);\n\n    typedef enum logic [2:0] {idle, start, decoding, finish, frame_space} ir_state;\n    ir_state present_state, next_state;\n\n    logic started;\n    logic decoded;\n    logic failed;\n    logic success;\n    logic frame_full;\n    logic ir_frame_valid;\n\n    int cycle_counter;\n    int frame_space_counter;\n    int bit_counter;\n\n    logic [11:0] ir_frame_reg;\n    logic [11:0] ir_frame_out;\n    logic stored;\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in)\n            present_state <= idle;\n        else\n            present_state <= next_state;\n    end\n\n    always_comb begin\n        case (present_state)\n            idle: begin\n                if (ir_signal_in == 1 && started == 0)\n                    next_state = start;\n                else\n                    next_state = idle;\n            end\n            start: begin\n                if (ir_signal_in == 0 && started == 1)\n                    next_state = decoding;\n                else if (failed == 1)\n                    next_state = idle;\n                else\n                    next_state = start;\n            end\n            decoding: begin\n                if (decoded == 1)\n                    next_state = finish;\n                else if (failed == 1)\n                    next_state = idle;\n                else\n                    next_state = decoding;\n            end\n            finish: begin\n                if (success == 1)\n                    next_state = frame_space;\n                else\n                    next_state = finish;\n            end\n            frame_space: begin\n                if (frame_full)\n                    next_state = idle;\n                else\n                    next_state = frame_space;\n            end\n            default: next_state = idle;\n        endcase\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            cycle_counter        <= 0;\n            frame_space_counter  <= 0;\n            bit_counter          <= -1;\n            failed               <= 0;\n            started              <= 0;\n            decoded              <= 0;\n            success              <= 0;\n            stored               <= 0;\n            ir_frame_reg         <= 12'b000000000000;\n            ir_frame_out         <= 12'b000000000000;\n            ir_frame_valid       <= 1'b0;\n            frame_full           <= 1'b0;\n        end\n        else begin\n            case (next_state)\n                idle: begin\n                    cycle_counter        <= 0;\n                    bit_counter          <= -1;\n                    frame_space_counter  <= 0;\n                    failed               <= 0;\n                    started              <= 0;\n                    decoded              <= 0;\n                    success              <= 0;\n                    stored               <= 0;\n                    ir_frame_reg         <= 12'b000000000000;\n                    ir_frame_valid       <= 1'b0;\n                    frame_full           <= 1'b0;\n                end\n                start: begin\n                    if (cycle_counter < 24) begin\n                        cycle_counter <= cycle_counter + 1;\n                        if (cycle_counter < 20 && ir_signal_in == 0)\n                            failed <= 1;\n                    end\n                    else begin\n                        started       <= 1;\n                        cycle_counter <= 0;\n                    end\n                end\n                decoding: begin\n                    if (bit_counter < 12) begin\n                        if (ir_signal_in == 1) begin\n                            stored        <= 0;\n                            cycle_counter <= cycle_counter + 1;\n                        end\n                        else begin\n                            if (stored == 0) begin\n                                if (bit_counter > -1) begin\n                                    if (cycle_counter > 10)\n                                        ir_frame_reg[bit_counter] <= 1;\n                                    else\n                                        ir_frame_reg[bit_counter] <= 0;\n                                end\n                                bit_counter   <= bit_counter + 1;\n                                cycle_counter <= 0;\n                                stored        <= 1;\n                            end\n                        end\n                    end\n                    else begin\n                        decoded <= 1;\n                    end\n                    frame_space_counter <= frame_space_counter + 1;\n                end\n                finish: begin\n                    ir_frame_out         <= ir_frame_reg;\n                    ir_frame_valid       <= 1'b1;\n                    success              <= 1;\n                    frame_space_counter  <= frame_space_counter + 1;\n                end\n                frame_space: begin\n                    success              <= 0;\n                    ir_frame_valid       <= 1'b0;\n                    ir_frame_out         <= 12'b0;\n                    frame_space_counter  <= frame_space_counter + 1;\n                    if (frame_space_counter < 424)\n                        frame_full <= 0;\n                    else\n                        frame_full <= 1;\n                end\n                default: begin\n                    cycle_counter        <= 0;\n                    frame_space_counter  <= 0;\n                    bit_counter          <= -1;\n                    failed               <= 0;\n                    started              <= 0;\n                    decoded              <= 0;\n                    success              <= 0;\n                    stored               <= 0;\n                    ir_frame_reg         <= 12'b000000000000;\n                    ir_frame_out         <= 12'b000000000000;\n                    ir_frame_valid       <= 1'b0;\n                    frame_full           <= 1'b0;\n                end\n            endcase\n        end\n    end\n\n    logic [3:0] device_function_code;\n    logic [4:0] device_address_out;\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            device_function_code <= 4'b0000;\n        end\n        else begin\n            if (ir_frame_reg[6:4] == 3'b000) begin\n                case (ir_frame_reg[3:0])\n                    4'b0000: device_function_code = 4'b0001;\n                    4'b0001: device_function_code = 4'b0010;\n                    4'b0010: device_function_code = 4'b0011;\n                    4'b0011: device_function_code = 4'b0100;\n                    4'b0100: device_function_code = 4'b0101;\n                    4'b0101: device_function_code = 4'b0110;\n                    4'b0110: device_function_code = 4'b0111;\n                    4'b0111: device_function_code = 4'b1000;\n                    4'b1000: device_function_code = 4'b1001;\n                    4'b1001: device_function_code = 4'b0000;\n                    default: device_function_code = 4'b0000;\n                endcase\n            end\n            else begin\n                case (ir_frame_reg[6:0])\n                    7'b0010000: device_function_code = 4'b0001;\n                    7'b0010001: device_function_code = 4'b0010;\n                    7'b0010010: device_function_code = 4'b0011;\n                    7'b0010011: device_function_code = 4'b0100;\n                    7'b0010100: device_function_code = 4'b0101;\n                    7'b0010101: device_function_code = 4'b0110;\n                    7'b0010110: device_function_code = 4'b0111;\n                    default: device_function_code = 4'b0000;\n                endcase\n            end\n        end\n    end\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            device_address_out <= 5'b00000;\n        end\n        else begin\n            case (ir_frame_reg[11:7])\n                5'b00000: device_address_out = 5'b00001;\n                5'b00001: device_address_out = 5'b00010;\n                5'b00010: device_address_out = 5'b00100;\n                5'b00011: device_address_out = 5'b01000;\n                5'b00100: device_address_out = 5'b10000;\n                default: device_address_out = 5'b00000;\n            endcase\n        end\n    end\n\n    assign ir_function_code_out = (ir_frame_valid) ? ((ir_frame_reg[6:4] == 3'b000) ? {3'b000, device_function_code} : {device_function_code[2:0], 4'b1111}) : 'd0;\n    assign ir_device_address_out = (ir_frame_valid) ? device_address_out : 'd0;\n    assign ir_output_valid = ir_frame_valid;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/ir_receiver.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ir_receiver.sv\nTOPLEVEL        = ir_receiver\nMODULE          = test_ir_receiver\nPYTHONPATH      = /src\nHASH            = 8dd946cad612316cfa4b522c370f0dc54b8c1540\n", "src/test_ir_receiver.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n\ndef calculate_reference_value(predefined_seq):\n    \"\"\"Calculate the expected reference value based on the input frame.\"\"\"\n    if predefined_seq & 0x7F < 10:  # For values less than 10\n        if (predefined_seq & 0x7F) == 9:\n            ref_value = ((1 << ((predefined_seq >> 7) & 0x1F)) << 7)\n        else:\n            ref_value = ((1 << ((predefined_seq >> 7) & 0x1F)) << 7) | ((predefined_seq & 0x7F) + 1)\n    elif 16 <= (predefined_seq & 0x7F) < 23:  # For values between 16 and 23\n        test_bits = (predefined_seq & 0x7F) - 15\n        ref_value = ((1 << ((predefined_seq >> 7) & 0x1F)) << 7) | (test_bits << 4) | 0xF\n    else:\n        ref_value = 0  # Default value if conditions are not met\n    return ref_value\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and start the clock.\"\"\"\n    dut.reset_in.value = 1\n    dut.ir_signal_in.value = 1\n\n    # Start the 50 MHz clock (period = 20 ns)\n    clock = Clock(dut.clk_in, 100000, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Wait for reset propagation\n    await Timer(200000, units=\"ns\")\n    dut.reset_in.value = 0\n\nasync def send_ir_signal(dut, predefined_value):\n    \"\"\"Send the IR signal to the DUT.\"\"\"\n    # Start bit: 2.4 ms LOW\n    dut.ir_signal_in.value = 1\n    await Timer(2400000, units=\"ns\")\n\n    for i in range(12):\n        dut.ir_signal_in.value = 0\n        await Timer(600000, units=\"ns\")  # 0.6 ms LOW\n\n        if (predefined_value >> i) & 1:\n            dut.ir_signal_in.value = 1\n            await Timer(1200000, units=\"ns\")  # 1.2 ms HIGH for '1'\n        else:\n            dut.ir_signal_in.value = 1\n            await Timer(600000, units=\"ns\")  # 0.6 ms HIGH for '0'\n\n    # End of transmission: 0.6 ms LOW\n    dut.ir_signal_in.value = 0\n\nasync def run_test_case(dut, address):\n    \"\"\"Run a test case for a specific 5-bit address.\"\"\"\n    await initialize_dut(dut)\n\n    for function in range(10):  # Loop through 7-bit function codes (0 to 16)\n        predefined_value = (address << 7) | function  # Combine address and function\n        reference_value = calculate_reference_value(predefined_value)\n\n        # Send the IR signal\n        await send_ir_signal(dut, predefined_value)\n\n        # Wait for the DUT to process the signal\n        await Timer(100000, units=\"ns\")\n        await Timer(100000, units=\"ns\")\n        await Timer(100000, units=\"ns\")\n\n        received_frame = (int(dut.ir_device_address_out.value) << 7) | int(dut.ir_function_code_out.value)\n\n        dut._log.info(f\"Predefined: {predefined_value:012b}, Expected: {reference_value:012b}, Received: {received_frame:012b}\")\n        assert received_frame == reference_value, (\n            f\"Test Failed: Predefined = {predefined_value:012b}, \"\n            f\"Expected = {reference_value:012b}, Received = {received_frame:012b}\"\n        )\n        await Timer(40000000, units=\"ns\")  # 0.6 ms HIGH for '0'\n\n    for function in range(16, 23):  # Loop through 7-bit function codes (0 to 16)\n        predefined_value = (address << 7) | function  # Combine address and function\n        reference_value = calculate_reference_value(predefined_value)\n\n        # Send the IR signal\n        await send_ir_signal(dut, predefined_value)\n\n        # Wait for the DUT to process the signal\n        await Timer(100000, units=\"ns\")\n        await Timer(100000, units=\"ns\")\n        await Timer(100000, units=\"ns\")\n\n        received_frame = (int(dut.ir_device_address_out.value) << 7) | int(dut.ir_function_code_out.value)\n\n        dut._log.info(f\"Predefined: {predefined_value:012b}, Expected: {reference_value:012b}, Received: {received_frame:012b}\")\n        assert received_frame == reference_value, (\n            f\"Test Failed: Predefined = {predefined_value:012b}, \"\n            f\"Expected = {reference_value:012b}, Received = {received_frame:012b}\"\n        )\n        await Timer(40000000, units=\"ns\")  # 0.6 ms HIGH for '0'\n\n    dut._log.info(f\"Test Case for Address {address:05b} passed successfully.\")\n\n@cocotb.test()\nasync def test_ir_receiver_address_00000(dut):\n    \"\"\"Test Case: Address 5'b00000 with all valid 7-bit function combinations.\"\"\"\n    await run_test_case(dut, address=0b00000)\n\n\n@cocotb.test()\nasync def test_ir_receiver_address_00001(dut):\n    \"\"\"Test Case: Address 5'b00001 with all valid 7-bit function combinations.\"\"\"\n    await run_test_case(dut, address=0b00001)\n\n\n@cocotb.test()\nasync def test_ir_receiver_address_00010(dut):\n    \"\"\"Test Case: Address 5'b00010 with all valid 7-bit function combinations.\"\"\"\n    await run_test_case(dut, address=0b00010)\n\n@cocotb.test()\nasync def test_ir_receiver_address_00011(dut):\n    \"\"\"Test Case: Address 5'b00011 with all valid 7-bit function combinations.\"\"\"\n    await run_test_case(dut, address=0b00011)\n\n\n@cocotb.test()\nasync def test_ir_receiver_address_00100(dut):\n    \"\"\"Test Case: Address 5'b00100 with all valid 7-bit function combinations.\"\"\"\n    await run_test_case(dut, address=0b00100)\n\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_lfsr_0069", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the SystemVerilog testbench `tb_lfsr_8bit` to add the functionality of a checker to test the `lfsr_8bit` module. The testbench provided in the context already includes a stimulus generator for multiple test cases. The purpose of the testbench checker is to verify the functionality of the LFSR 8-bit module against the given design specification.\n___\n\n### **Design Specification**\nThe `lfsr_8bit` module implements an 8-bit Linear Feedback Shift Register (LFSR) with the following features:\n\n**1. Random Bit Generation:**\n\n   - The LFSR generates a pseudo-random sequence based on a Galois LFSR configuration.\n   - Uses a primitive polynomial (x<sup>8</sup>+x<sup>6</sup>+x<sup>5</sup>+x+1)\n\n**2. Configurable Behavior:**\n   - The module supports two feedback operations:\n     - `NOR` (Bias towards `0s`).\n     - `NAND` (Bias towards `1s`).\n   - Supports shift direction control:\n     - `LSB to MSB` (`0`).  \n     - `MSB to LSB` (`1`).\n   - Includes weight control to define the number of bits affected by the feedback logic.\n___\n### Summary of Operations\n**1. LFSR Update:**\n   - The module shifts the LFSR state at every clock cycle.\n   - Feedback bits are `XOR`ed to introduce randomness.\n   - Additional logic is applied based on the `sel`, `dir`, and `weight` signals to control the LFSR output characteristics.\n\n**2. Edge Cases:**\n   - `lfsr_seed = 0` should produce an all-zero output unless influenced by feedback.\n   - `lfsr_seed = 255` should cycle through a known LFSR sequence.\n   - Cases with `weight = 0` (minimal impact) vs. `weight = 7` (maximum impact).\n   - Alternating bit patterns (`8'b10101010`, `8'b01010101`).\n   - Rapid changes in `sel` and `dir` settings.\n   - Mid-operation reset should restore the LFSR to `lfsr_seed`.\n   - Randomized `lfsr_seed` values should be compared with a reference model.\n___\n### Example Computation\n   - For an LFSR initialized with `lfsr_seed = 8'b11001011` and `dir = 0`, `sel = 0`, `weight = 3'b010`:\n    1. Shift operation: `lfsr_out` = `{lfsr_out[0], lfsr_out[7], q1, q2, lfsr_out[4], lfsr_out[3], lfsr_out[2], q3}`\n    2. Expected new output (after logic adjustments): `lfsr_new = 8'b10110101` (example).\n\n___\n### Requirements\n**1. Testbench Components**\n\n  **Input Signals:**\n   - `clock`: Clock signal for synchronous operation, design works on Positive edge of clock.\n   - `reset`: Asynchronous active-low reset signal.\n   - `lfsr_seed` [7:0]: 8-bit initial LFSR state.\n   - `sel`: Selects NAND (1) or NOR (0) feedback logic.\n   - `dir`: Defines shift direction (0: LSB to MSB, 1: MSB to LSB).\n   - `weight` [2:0]: Defines the number of bits affected by feedback.\n \n **Output Validation:**\n   - `lfsr_new` [7:0]: LFSR output from the DUT.\n   - `lfsr_out` [7:0]: Internal LFSR state (for debugging).\n\n**2. Validation Logic**\n   - Implement a reference function (`lfsr_reference`) to compute the expected LFSR output for any given configuration.\n   - The reference function should:\n     - Apply the correct shift and feedback logic based on `sel`, `dir`, and `weight`.\n     - Compare `lfsr_new` from the DUT against the expected output.\n   - Log mismatches and error messages.\n\n**3. Functionality Coverage**\n  - The testbench must exhaustively test:\n    - All shift and feedback configurations (`NOR/NAND`, `LSB/MSB`).\n    - All weight values (`0\u20137`).\n    -  LFSR seed values: `0`, `255`, random values.\n    -  Boundary conditions:\n       - Alternating patterns (`8'b10101010`, `8'b01010101`).\n       - Rapid changes in `sel` and `dir`.\n       - Mid-operation reset verification.\n    - Randomized testing for better coverage.\n\n**4. Verification Strategy**\n   - Apply test vectors with various `lfsr_seed`, `sel`, `dir`, and `weight` values.\n   - Compute the expected LFSR output using the reference function.\n   - Compare expected vs. actual DUT outputs.\n   - Print pass/fail messages for each test case.\n\n**5. Simulation and Logging**\n   - Display pass/fail results for each test.\n   - Log input settings and the corresponding expected vs. actual LFSR outputs.\n   - End simulation after all test cases execute.\n___\n### Expected Output\n  - Pass/Fail messages for each test scenario.\n  - Log of input settings (`lfsr_seed`, `dir`, `sel`, `weight`) and the corresponding expected vs. actual outputs.\n\n___\n### Deliverables\n  - Provide a complete SystemVerilog testbench (`tb_lfsr_8bit.sv`) that meets all the above requirements.", "context": {"verif/tb_lfsr_8bit.sv": "\n`timescale 1ns / 1ps\n\nmodule tb_lfsr_8bit;\n\n  // Inputs\n  reg        clock;\n  reg        reset;\n  reg  [7:0] lfsr_seed;\n  reg        sel;  // Selector for NAND or NOR operation\n  reg        dir;  // Direction control (0: LSB to MSB, 1: MSB to LSB)\n  reg  [2:0] weight;  // Weight control signal\n\n  // Outputs\n  wire [7:0] lfsr_out;\n  wire [7:0] lfsr_new;\n\n  // Instantiate the LFSR DUT (Device Under Test)\n  lfsr_8bit uut (\n      .clock(clock),\n      .reset(reset),\n      .lfsr_seed(lfsr_seed),\n      .sel(sel),\n      .dir(dir),\n      .weight(weight),\n      .lfsr_new(lfsr_new)\n  );\n\n  // Clock generation: 100 MHz clock with 10ns period\n  initial begin\n    clock = 0;\n    forever #5 clock = ~clock;\n  end\n\n  initial begin\n    // Display LFSR output\n    $monitor(\"Time=%0t | lfsr_new =%b | lfsr_seed=%b | sel=%b | dir=%b | weight=%b\", $time,\n             lfsr_new, lfsr_seed, sel, dir, weight);\n\n    // Test case 1\n    $display(\"=== Test: Reset Behavior ===\");\n    test_case(8'hAA, 0, 0, 3'b000);\n    @(posedge clock);\n    reset = 1;\n    @(posedge clock);\n    reset = 0;\n    #10;\n    // Test case 2\n    test_case(8'hAA, 0, 0, 3'b001);\n    @(posedge clock);\n    reset = 1;\n    @(posedge clock);\n    reset = 0;\n    #10;\n    \n    // Test case 3\n    $display(\"=== Test: Toggle Direction ===\");\n    test_case(8'hAA, 0, 0, 3'b010);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 1, 3'b010);\n    run_lfsr(5);\n\n    // Test case 4:\n    $display(\"=== Test: Alternate Seed Values ===\");\n    test_case(8'h00, 0, 0, 3'b001);\n    run_lfsr(5);\n    test_case(8'hFF, 0, 0, 3'b101);\n    run_lfsr(5);\n    // Test case 5:\n    $display(\"=== Test: Randomized Inputs ===\");\n    repeat (10) begin\n      test_case($random, $random % 2, $random % 2, $random % 16);\n      run_lfsr(5);\n    end\n    // Test case 6:\n    $display(\"=== Test: all values ===\");\n    test_case(8'hAA, 0, 0, 3'b000);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 0, 3'b001);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 0, 3'b010);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 0, 3'b011);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 0, 3'b100);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 0, 3'b101);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 0, 3'b110);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 0, 3'b111);\n    run_lfsr(5);\n\n    // Test case 7:\n    test_case(8'hAA, 0, 1, 3'b000);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 1, 3'b001);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 1, 3'b010);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 1, 3'b011);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 1, 3'b100);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 1, 3'b101);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 1, 3'b110);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 1, 3'b111);\n    run_lfsr(5);\n\n    // Test case 8:\n    test_case(8'hAA, 1, 0, 3'b000);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 0, 3'b001);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 0, 3'b010);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 0, 3'b011);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 0, 3'b100);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 0, 3'b101);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 0, 3'b110);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 0, 3'b111);\n    run_lfsr(5);\n\n    // Test case 9:\n    test_case(8'hAA, 1, 1, 3'b000);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 1, 3'b001);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 1, 3'b010);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 1, 3'b011);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 1, 3'b100);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 1, 3'b101);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 1, 3'b110);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 1, 3'b111);\n    run_lfsr(5);\n\n    // Test case 10:\n    $display(\"=== Test: Reset in the Middle of Operation ===\");\n    test_case(8'hAA, 1, 0, 3'b011);\n    run_lfsr(5);\n    reset = 1;  \n    @(posedge clock);\n    reset = 0;\n    run_lfsr(5);\n\n    // Test case 11:\n    $display(\"=== Test: Alternate Seed Values ===\");\n    test_case(8'h00, 0, 0, 3'b001); \n    run_lfsr(5);\n    test_case(8'hFF, 0, 0, 3'b101);  \n    run_lfsr(5);\n    test_case(8'h55, 0, 1, 3'b110);  \n    run_lfsr(5);\n    test_case(8'hAA, 1, 1, 3'b011);  \n    run_lfsr(5);\n\n    // Test case 12:\n    $display(\"=== Test: Randomized Weight Values ===\");\n    repeat (10) begin\n      test_case(8'hA5, 0, 0, $random % 8);\n      run_lfsr(5);\n    end\n\n    // Test case 13:\n    $display(\"=== Test: Switching NAND and NOR ===\");\n    test_case(8'hCC, 0, 0, 3'b100);\n    run_lfsr(5);\n    test_case(8'hCC, 1, 0, 3'b100);\n    run_lfsr(5);\n    test_case(8'hCC, 0, 0, 3'b100);\n    run_lfsr(5);\n\n    // Test case 14:\n    $display(\"=== Test: Minimum and Maximum Weight Values ===\");\n    test_case(8'hFF, 0, 0, 3'b000); \n    run_lfsr(5);\n    test_case(8'hFF, 1, 1, 3'b111);  \n    run_lfsr(5);\n\n    // Test case 15:\n    $display(\"=== Test: Rapid Direction Switching ===\");\n    test_case(8'hA5, 0, 0, 3'b010);\n    run_lfsr(2);\n    test_case(8'hA5, 0, 1, 3'b010);\n    run_lfsr(2);\n    test_case(8'hA5, 1, 0, 3'b010);\n    run_lfsr(2);\n    test_case(8'hA5, 1, 1, 3'b010);\n    run_lfsr(2);\n\n    // Test case 16:\n    $display(\"=== Test: Transition Between Boundaries ===\");\n    test_case(8'hAA, 0, 0, 3'b000);\n    run_lfsr(5);\n    test_case(8'hAA, 0, 0, 3'b001);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 1, 3'b111);\n    run_lfsr(5);\n    test_case(8'hAA, 1, 1, 3'b110);\n    run_lfsr(5);\n\n    // Test case 17:\n    $display(\"=== Test: Switching NAND and NOR ===\");\n    test_case(8'hCC, 0, 0, 3'b100);\n    run_lfsr(5);\n    test_case(8'hCC, 1, 0, 3'b100);\n    run_lfsr(5);\n    test_case(8'hCC, 0, 0, 3'b100);\n    run_lfsr(5);\n\n    $finish;\n  end\n\n  // Task to set up a specific test case\n  task test_case(input [7:0] seed, input sel_val, input dir_val, input [2:0] weight_val);\n    begin\n      reset = 1;\n      lfsr_seed = seed;\n      sel = sel_val;\n      dir = dir_val;\n      weight = weight_val;\n      #10 reset = 0;\n\n      if (!reset) begin\n        // $display(\"Reset is low, output assigned to seed value: %h\", lfsr_seed);\n      end\n      #10 reset = 1;\n    end\n  endtask\n\n  task run_lfsr(input integer num_cycles);\n    begin\n      repeat (num_cycles) @(posedge clock);\n    end\n  endtask\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_lfsr_8bit.sv": ""}}, "harness": {"files": {"docker-compose.yml": "\nservices:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "VERILOG_SOURCES = ./rtl/lfsr_8bit.sv\nHASH            = 2a406405e9d5ffac12bcb7dc701442df96c96ee9\nNUM_BUGS        = 3\n", "src/lfsr_8bit.sv": "`timescale 1ns / 1ps\n\nmodule lfsr_8bit (\n    input logic clock,\n    input logic reset,\n    input logic [7:0] lfsr_seed,\n    input logic sel,  // Selector for NAND or NOR operation (0: NOR for more 0s, 1: NAND for more 1s)\n    input logic dir,  // Direction control (0: LSB to MSB, 1: MSB to LSB)\n    input logic [2:0] weight,  // Weight control signal\n    output logic [7:0] lfsr_new\n);\n\n  // Internal registers\n  logic [7:0] lfsr_out;\n  logic [7:0] output_new;\n\n  // Primitive polynomial for 8-bit LFSR with Galois configuration: x^8 + x^6 + x^5 + x + 1\n\n  assign q1 = lfsr_out[6] ^ lfsr_out[0];\n  assign q2 = lfsr_out[5] ^ lfsr_out[0];\n  assign q3 = lfsr_out[1] ^ lfsr_out[0];\n\n\n  always @(*) begin\n`ifndef BUG_0\n    output_new = lfsr_out;  // Default to no change\n`else\n    output_new = 8'b00000000; // Bug: Always assigning 0\n`endif\n\n    // Apply feedback logic based on the selected direction and NAND/NOR operation\n     if (sel == 0 && dir == 0) begin  // LSB to MSB, NOR\n      case (weight)\n        3'b000: output_new = lfsr_out;  // No change\n        3'b001: output_new = {lfsr_out[7:1], ~(lfsr_out[0] | 1'b1)};\n        3'b010:\n        output_new = {output_new[7:2], ~(lfsr_out[1] | lfsr_out[0]), ~(lfsr_out[1] | lfsr_out[0])};\n        3'b011:\n        output_new = {\n          lfsr_out[7:3],\n          ~(lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        3'b100:\n        output_new = {\n          output_new[7:4],\n          ~(lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        3'b101:\n        output_new = {\n          lfsr_out[7:5],\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        3'b110:\n        output_new = {\n          output_new[7:6],\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2])\n        };\n        3'b111:\n        output_new = {\n          output_new[7],\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n      endcase\n    end else if (sel == 0 && dir == 1) begin  // MSB to LSB, NOR\n      case (weight)\n        3'b000: output_new = lfsr_out;  // No change\n        3'b001: output_new = {~(lfsr_out[7] | 1'b0), lfsr_out[7:1]};\n        3'b010:\n        output_new = {~(lfsr_out[7] | lfsr_out[6]), ~(lfsr_out[7] | lfsr_out[6]), lfsr_out[7:2]};\n        3'b011:\n        output_new = {\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          lfsr_out[7:3]\n        };\n        3'b100:\n        output_new = {\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          lfsr_out[7:4]\n        };\n        3'b101:\n        output_new = {\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          lfsr_out[7:5]\n        };\n        3'b110:\n        output_new = {\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          lfsr_out[7:6]\n        };\n        3'b111:\n        output_new = {\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          lfsr_out[7]\n        };\n      endcase\n    end else if (sel == 1 && dir == 0) begin  // LSB to MSB, NAND\n      case (weight)\n        3'b000: output_new = lfsr_out;  // No change\n        3'b001: output_new = {lfsr_out[7:1], ~(lfsr_out[7])};\n        3'b010:\n        output_new = {lfsr_out[7:2], ~(lfsr_out[7] & lfsr_out[6]), ~(lfsr_out[7] & lfsr_out[6])};\n        3'b011:\n        output_new = {\n          lfsr_out[7:3],\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5])\n\n        };\n        3'b100:\n        output_new = {\n          lfsr_out[7:4],\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4])\n\n        };\n        3'b101:\n        output_new = {\n          lfsr_out[7:5],\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3])\n\n        };\n        3'b110:\n        output_new = {\n          lfsr_out[7:6],\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2])\n\n\n        };\n        3'b111:\n        output_new = {\n          lfsr_out[7],\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1])\n\n        };\n      endcase\n    end else if (sel == 1 && dir == 1) begin  // MSB to LSB, NOR\n      case (weight)\n        3'b000: output_new = lfsr_out;  // No change\n        3'b001: output_new = {~(lfsr_out[7] & 1'b0), lfsr_out[7:1]};\n        3'b010:\n        output_new = {~(lfsr_out[7] & lfsr_out[6]), ~(lfsr_out[7] & lfsr_out[6]), lfsr_out[7:2]};\n        3'b011:\n        output_new = {\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          lfsr_out[7:3]\n        };\n        3'b100:\n        output_new = {\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          lfsr_out[7:4]\n        };\n        3'b101:\n        output_new = {\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          lfsr_out[7:5]\n        };\n        3'b110:\n        output_new = {\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          lfsr_out[7:6]\n        };\n        3'b111:\n        output_new = {\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          lfsr_out[7]\n        };\n      endcase\n    end\n  end\n\n  // Sequential logic to shift and update LFSR output\n  always @(posedge clock or posedge reset) begin\n`ifndef BUG_1\n    if (reset) begin\n      lfsr_out <= lfsr_seed;  // Load seed on reset\n`else\n    if (reset) begin\n      lfsr_out <= 8'b00000000; // Bug: Reset forces all bits to zero instead of using seed\n    end\n`endif\n    end \n    else begin\n`ifndef BUG_2\n      lfsr_out <= {lfsr_out[0], lfsr_out[7], q1, q2, lfsr_out[4], lfsr_out[3], lfsr_out[2], q3};\n      lfsr_new <= output_new;\n`else\n      lfsr_out <= 8'b00000000; // Bug: Incorrect shift pattern\n      lfsr_new <= 8'b00000000; \n`endif\n     \n    end\n  end\n\n  \nendmodule\n", "src/process.py": "import os\r\nimport re\r\nimport subprocess\r\nimport pytest\r\n\r\n# ----------------------------------------\r\n# - Simulate\r\n# ----------------------------------------\r\n\r\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\r\n\r\ndef check_log(filename = \"sim.log\", expected = 0):\r\n\r\n    # ----------------------------------------\r\n    # - Check for errors in the log\r\n    # ----------------------------------------\r\n\r\n    with open(filename) as f:\r\n        lines = f.readlines()\r\n\r\n    errors = []\r\n    for line in lines[3:]:\r\n        errors.append(re.findall(r'*E', line))\r\n\r\n    # ----------------------------------------\r\n    # - Evaluate Report\r\n    # ----------------------------------------\r\n\r\n    assert len(errors) == expected, \"Simulation ended with error.\"\r\n\r\n@pytest.mark.usefixtures(scope='session')\r\ndef test_sanity():\r\n\r\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\r\n    assert(res.returncode == 0), \"Simulation ended with error.\"\r\n\r\n# ----------------------------------------\r\n# - Generate Bug Simulations\r\n# ----------------------------------------\r\n\r\n@pytest.mark.usefixtures(scope='test_sanity')\r\ndef test_errors():\r\n\r\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\r\n\r\n    for i in range(num_bugs):\r\n        bug = f\"-define BUG_{i}=1\"\r\n        cmd = f\"{sim} {bug}\"\r\n\r\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\r\n        assert(res.returncode != 0), \"Simulation ended without error.\""}}}
{"id": "cvdp_copilot_lfsr_0073", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the `lfsr_16bit` module to ensure its correct functionality during simulation? The assertions should validate the correct operation of the LFSR (Linear Feedback Shift Register), ensuring that:\n  - The weight input remains within the valid range (`0 to 15`).\n  - The `lfsr_out` output is not stuck at all 0s (`16'h0000`), which would indicate a failure in the shifting process.\n\n___\n### Key Assertions\n**1. Valid weight Input Range**\n  - Condition:\n    - The weight signal should always remain within the 4-bit valid range (`0000 to 1111`).\n    - If weight is less than `0000` or greater than `1111`, an error message should be displayed.\n\n  - Failure Handling:\n    - If weight is out of range, an error message should be printed to indicate whether the value exceeded the limit or dropped below the minimum range.\n\n##\n**2. LFSR Should Not Be Stuck at 16'h0000**\n  - Condition:\n    - After reset is deasserted (`reset = 0`), `lfsr_out` should not remain at `16'h0000` indefinitely.\n    - This ensures that the LFSR is not stuck in a non-random state and continues to shift correctly.\n\n  - Failure Handling:\n    - If `lfsr_out` remains at `16'h0000`, an error message should be displayed to indicate that the LFSR is not shifting properly.\n___\n### Implementation Requirements\n**1. Placement**\n  - The assertions must be inside the RTL module (`lfsr_16bit`) to validate real-time behavior during simulation.\n\n**2. Immediate Assertions**\n  - Uses `assert()` inside an `always` block to catch errors during execution.\n\n**3. Failure Handling**\n  - If an assertion fails, the simulation should:\n    - Display debugging information (`$display`).\n    - Indicate the incorrect behavior.\n    - Help identify issues related to invalid weight values or LFSR getting stuck.\n\n##\n### Interface\n**PARAMETER**\n  - `WIDTH`: Defines the bit width of the LFSR (`Default: 16`).\n\n**INPUTS**\n  - `clock`: System clock input that synchronizes state transitions, ensuring the LFSR shifts on every rising edge..\n  - `reset`: An active-high signal that initializes `lfsr_out` with `lfsr_seed`, ensuring a known starting state before normal operation..\n  - `lfsr_seed [15:0]`: Initial seed value for the LFSR.\n  - `sel`: Select signal for `NAND` or `NOR` operation (`0: NOR`, `1: NAND`).\n  - `dir`: Direction control (`0: LSB to MSB`, `1: MSB to LSB`).\n  - `weight [3:0]`: Controls the weight applied to feedback logic.\n\n**OUTPUT**\n  - `lfsr_new [15:0]`: Updated LFSR value after each shift cycle.", "context": {"rtl/lfsr_16bit.sv": "`timescale 1ns / 1ps\n\nmodule lfsr_16bit (\n    input clock,\n    input reset,\n    input [15:0] lfsr_seed,\n    input sel,  // Selector for NAND or NOR operation (0: NOR for more 0s, 1: NAND for more 1s)\n    input dir,  // Direction control (0: LSB to MSB, 1: MSB to LSB)\n    input [3:0] weight,  // Weight control signal\n    output reg [15:0] lfsr_new\n\n);\n  wire q1;\n  wire q2;\n  wire q3;\n  reg [15:0] output_new;\n  reg [15:0] lfsr_out;\n\n  assign q1 = lfsr_out[6] ^ lfsr_out[0];\n  assign q2 = lfsr_out[5] ^ lfsr_out[0];\n  assign q3 = lfsr_out[1] ^ lfsr_out[0];\n\n\n  always @* begin\n    output_new = lfsr_out;  // Default to no change\n\n    if (sel == 0 && dir == 0) begin\n      case (weight)\n        4'b0000: output_new = lfsr_out;\n        4'b0001: output_new = {lfsr_out[15:1], ~(lfsr_out[0] | 1'b1)};\n        4'b0010:\n        output_new = {output_new[15:2], ~(lfsr_out[1] | lfsr_out[0]), ~(lfsr_out[1] | lfsr_out[0])};\n        4'b0011:\n        output_new = {\n          lfsr_out[15:3],\n          ~(lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b0100:\n        output_new = {\n          output_new[15:4],\n          ~(lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b0101:\n        output_new = {\n          lfsr_out[15:5],\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b0110:\n        output_new = {\n          output_new[15:6],\n          ~(lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b0111:\n        output_new = {\n          output_new[15:7],\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b1000:\n        output_new = {\n          output_new[15:8],\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b1001:\n        output_new = {\n          output_new[15:9],\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b1010:\n        output_new = {\n          output_new[15:10],\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n\n        };\n        4'b1011:\n        output_new = {\n          output_new[15:11],\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b1100:\n        output_new = {\n          output_new[15:12],\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b1101:\n        output_new = {\n          output_new[15:13],\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b1110:\n        output_new = {\n          output_new[15:14],\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b1111:\n        output_new = {\n          output_new[15],\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n\n        };\n      endcase\n    end else if (sel == 0 && dir == 1) begin\n      case (weight)\n        4'b0000: output_new = lfsr_out;\n        4'b0001: output_new = {~(lfsr_out[15] | 1'b0), lfsr_out[14:0]};\n        4'b0010:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14]), ~(lfsr_out[15] | lfsr_out[14]), lfsr_out[13:0]\n        };\n        4'b0011:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13]),\n\n          lfsr_out[12:0]\n        };\n        4'b0100:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12]),\n          lfsr_out[11:0]\n        };\n        4'b0101:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11]),\n          lfsr_out[10:0]\n        };\n        4'b0110:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10]),\n          lfsr_out[9:0]\n        };\n        4'b0111:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9]),\n          lfsr_out[8:0]\n        };\n        4'b1000:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          lfsr_out[7:0]\n        };\n        4'b1001:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          lfsr_out[6:0]\n        };\n        4'b1010:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          lfsr_out[5:0]\n        };\n        4'b1011:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          lfsr_out[4:0]\n        };\n        4'b1100:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          lfsr_out[3:0]\n        };\n        4'b1101:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          lfsr_out[2:0]\n        };\n        4'b1110:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          lfsr_out[1:0]\n        };\n        4'b1111:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          lfsr_out[0]\n        };\n      endcase\n    end else if (sel == 1 && dir == 0) begin\n      case (weight)\n        4'b0000: output_new = lfsr_out;\n        4'b0001: output_new = {lfsr_out[15:1], ~(lfsr_out[0] & 1'b1)};\n        4'b0010:\n        output_new = {output_new[15:2], ~(lfsr_out[1] & lfsr_out[0]), ~(lfsr_out[1] & lfsr_out[0])};\n        4'b0011:\n        output_new = {\n          lfsr_out[15:3],\n          ~(lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b0100:\n        output_new = {\n          output_new[15:4],\n          ~(lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b0101:\n        output_new = {\n          lfsr_out[15:5],\n          ~(lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b0110:\n        output_new = {\n          output_new[15:6],\n          ~(lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b0111:\n        output_new = {\n          output_new[15:7],\n          ~(lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b1000:\n        output_new = {\n          output_new[15:8],\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b1001:\n        output_new = {\n          output_new[15:9],\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b1010:\n        output_new = {\n          output_new[15:10],\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n\n        };\n        4'b1011:\n        output_new = {\n          output_new[15:11],\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b1100:\n        output_new = {\n          output_new[15:12],\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b1101:\n        output_new = {\n          output_new[15:13],\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b1110:\n        output_new = {\n          output_new[15:14],\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b1111:\n        output_new = {\n          output_new[15],\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n\n        };\n      endcase\n    end else if (sel == 1 && dir == 1) begin\n      case (weight)\n        4'b0000: output_new = lfsr_out;\n        4'b0001: output_new = {~(lfsr_out[15] & 1'b0), lfsr_out[14:0]};\n        4'b0010:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14]), ~(lfsr_out[15] & lfsr_out[14]), lfsr_out[13:0]\n        };\n        4'b0011:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13]),\n\n          lfsr_out[12:0]\n        };\n        4'b0100:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12]),\n          lfsr_out[11:0]\n        };\n        4'b0101:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11]),\n          lfsr_out[10:0]\n        };\n        4'b0110:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10]),\n          lfsr_out[9:0]\n        };\n        4'b0111:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9]),\n          lfsr_out[8:0]\n        };\n        4'b1000:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          lfsr_out[7:0]\n        };\n        4'b1001:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          lfsr_out[6:0]\n        };\n        4'b1010:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          lfsr_out[5:0]\n        };\n        4'b1011:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          lfsr_out[4:0]\n        };\n        4'b1100:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          lfsr_out[3:0]\n        };\n        4'b1101:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          lfsr_out[2:0]\n        };\n        4'b1110:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          lfsr_out[1:0]\n        };\n        4'b1111:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          lfsr_out[0]\n        };\n      endcase\n    end\n  end\n\n  always @(posedge clock or posedge reset) begin\n\n    if (reset) begin\n      lfsr_out <= lfsr_seed;  // Load seed on reset\n      lfsr_new <= lfsr_seed;\n    end else begin\n\n      lfsr_out <= {\n        lfsr_out[0],\n        lfsr_out[15],\n        q1,\n        q2,\n        lfsr_out[12],\n        lfsr_out[11],\n        lfsr_out[10],\n        q3,\n        lfsr_out[8],\n        lfsr_out[7],\n        lfsr_out[6],\n        lfsr_out[5],\n        lfsr_out[4],\n        lfsr_out[3],\n        lfsr_out[2],\n        lfsr_out[1]\n      };\n      lfsr_new <= output_new;\n\n    end\n  end\nendmodule"}}, "output": {"response": "", "context": {"rtl/lfsr_16bit.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/lfsr_16bit.sv\nTOPLEVEL        = lfsr_16bit\nMODULE          = test_lfsr_16bit\nPYTHONPATH      = /src\nHASH            = 73-assertion-generation-for-lfsr-16-bit\n", "src/test_lfsr_16bit.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport random\n\n@cocotb.test()\nasync def test_lfsr(dut):\n    \"\"\"Test LFSR with different seeds, sel, dir, and weight values\"\"\"\n\n    # Start the clock\n    clock = Clock(dut.clock, 10, units=\"ns\")  # Create a clock with 100MHz frequency\n    cocotb.start_soon(clock.start())  # Start the clock\n\n    # Test cases with different configurations of lfsr_seed, sel, dir, and weight\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b0000)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0000)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b0010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0010)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b0011)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0011)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b0101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0101)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b0111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0111)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b1010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1010)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b1101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1101)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b1111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1111)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b0000)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0000)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b0010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0010)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b0011)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0011)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b0101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0101)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b0111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0111)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b1010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1010)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b1101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1101)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b1111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1111)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b0000)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0000)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b0010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0010)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b0011)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0011)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b0101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0101)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b0111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0111)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b1010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1010)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b1101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1101)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b1111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1111)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b0000)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0000)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b0010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0010)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b0011)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0011)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b0101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0101)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b0111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0111)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b1010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1010)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b1101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1101)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b1111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1111)\n\n\n\n    # Additional random test cases\n    random_seed = random.randint(0, 65535)\n    await test_case(dut, seed=random_seed, sel=1, dir=1, weight=0b0110)\n    await run_lfsr(dut, random_seed, 5, weight=0b0110)\n\nasync def test_case(dut, seed, sel, dir, weight):\n    \"\"\"Initialize test case with given seed, sel, dir, and weight\"\"\"\n    dut.reset.value = 1\n    await RisingEdge(dut.clock)\n\n    dut.reset.value = 0  # Assert reset\n    dut.lfsr_seed.value = seed\n    dut.sel.value = sel\n    dut.dir.value = dir\n    dut.weight.value = weight\n\n    # Wait for one clock cycle after reset\n    await RisingEdge(dut.clock)\n    cocotb.log.info(f\"Reset is low, output assigned to seed value: {bin(seed)}\")\n    \n    # Release reset and start running\n    dut.reset.value = 1\n    await RisingEdge(dut.clock)\n    cocotb.log.info(f\"Running Test Case: seed={bin(seed)}, sel={sel}, dir={dir}, weight={bin(weight)}\")\n\nasync def run_lfsr(dut, seed, cycles, weight):\n    \"\"\"Run the LFSR for a given number of clock cycles using custom logic\"\"\"\n    lfsr_out = seed  # Initialize testbench LFSR to seed value\n    lfsr_output = None  # Local variable to hold lfsr_new \n\n    for cycle in range(cycles):\n        await RisingEdge(dut.clock)\n        \n        # Corrected conversion from BinaryValue to int\n        lfsr_output = int(dut.lfsr_new.value)  \n        lfsr_out = get_lfsr_output(lfsr_output, int(dut.lfsr_out.value), weight)\n\n        # Read lfsr_new from DUT for comparison\n        lfsr_new_value = int(dut.lfsr_new.value)  # Corrected conversion\n\n        # Log detailed information for debugging\n        cocotb.log.info(f\"Cycle {cycle+1}: LFSR Out = {format(lfsr_out, '016b')} ({lfsr_out}), \"\n                        f\"LFSR New = {format(lfsr_new_value, '016b')} ({lfsr_new_value})\")\n\n        # Perform assertion only if weight is 0\n        if weight == 0:\n            assert lfsr_new_value == lfsr_out, \\\n                f\"Mismatch at cycle {cycle+1}: Expected {bin(lfsr_out)}, got {bin(lfsr_new_value)}\"\n\n        # Additional range checks\n        assert 0 <= lfsr_out < 65536, f\"lfsr_out out of 16-bit range: {bin(lfsr_out)}\"\n        assert 0 <= lfsr_new_value < 65536, f\"lfsr_new out of 16-bit range: {bin(lfsr_new_value)}\"\n\ndef get_lfsr_output(lfsr_output, lfsr_value, weight):\n    \"\"\"Return the new LFSR output; use hidden conditions when weight is zero\"\"\"\n    if weight == 0:\n        return lfsr_output  \n    else:\n        # Calculate feedback bits q1, q2, q3 based on RTL logic\n        q1 = ((lfsr_value >> 6) & 1) ^ ((lfsr_value >> 0) & 1)\n        q2 = ((lfsr_value >> 5) & 1) ^ ((lfsr_value >> 0) & 1)\n        q3 = ((lfsr_value >> 1) & 1) ^ ((lfsr_value >> 0) & 1)\n        # feed the logic to lfsr out to verify\n        return ((lfsr_value & 1) << 15) | (((lfsr_value >> 15) & 1) << 14) | (((lfsr_value >> 14) & 1) << 13) | (((lfsr_value >> 13) & 1) << 12) | (((lfsr_value >> 12) & 1) << 11) | (((lfsr_value >> 11) & 1) << 10) | (((lfsr_value >> 10) & 1) << 9) | (((lfsr_value >> 9) & 1) << 8) | (((lfsr_value >> 8) & 1) << 7) |  (((lfsr_value >> 7) & 1) << 6) | (q1 << 5) | (q2 << 4) | \\\n               ((lfsr_value >> 4) & 1 << 3) | ((lfsr_value >> 3) & 1 << 2) | ((lfsr_value >> 2) & 1 << 1) | q3\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}}
{"id": "cvdp_copilot_load_store_unit_0016", "categories": ["cid014", "medium"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `load_store_unit ` module. \n\n## **RTL Design Overview**  \n\n#### **Description:**\nThe `load_store_unit` (LSU) handles memory read and write operations, managing both aligned and misaligned accesses. It interfaces with the execution stage, writeback stage, and memory subsystem, ensuring that correct addresses, byte enables, and data are sent for load/store operations. It also manages the timing for data propagation between stages and ensures memory access validity using assertions.\n\n---\n\n#### **Ports:**\n\n##### **Inputs:**\n- **clk**: Clock signal for synchronization.\n- **rst_n**: Active-low reset signal.\n- **ex_if_req_i**: LSU request signal indicating a memory access request.\n- **ex_if_we_i**: Write enable signal (0 for load, 1 for store).\n- **ex_if_type_i**: Data type (byte, halfword, or word).\n- **ex_if_wdata_i**: Data to be written (for store operations).\n- **ex_if_addr_base_i**: Base address for the load/store operation.\n- **ex_if_addr_offset_i**: Offset to be added to the base address for memory access.\n- **ex_if_extend_mode_i**: Sign-extension or zero-extension mode for loads.\n\n##### **Outputs:**\n- **ex_if_ready_o**: Ready signal indicating LSU is ready for a new request.\n- **wb_if_rdata_o**: Data read from memory (for load operations).\n- **wb_if_rvalid_o**: Valid signal for the read data.\n- **dmem_req_o**: Memory request signal to DMEM.\n- **dmem_gnt_i**: Grant signal from DMEM, indicating the request has been accepted.\n- **dmem_req_addr_o**: Address for memory access.\n- **dmem_req_we_o**: Write enable signal to DMEM.\n- **dmem_req_be_o**: Byte enable signal for the memory access.\n- **dmem_req_wdata_o**: Data to be written to DMEM (for store operations).\n- **dmem_rsp_rdata_i**: Data read from DMEM (for load operations).\n- **dmem_rvalid_i**: Valid signal for the data read from DMEM.\n\n---\n\n#### **Internal Signals:**\n- **state**: Current state of the load/store unit, which can be IDLE, ALIGNED, or MISALIGNED states.\n- **next_state**: Next state to transition to based on the current state and input conditions.\n- **two_transactions**: Flag indicating whether the current operation requires two transactions (misaligned access).\n- **addr_0, addr_1**: Addresses for the two memory transactions in case of misalignment.\n- **be_0, be_1**: Byte enable signals for the two transactions in case of misalignment.\n- **wdata_q**: Data to be written to memory.\n- **data_rdata_ext**: Extended read data based on the data type.\n- **wb_rsp_valid**: Validity of the response data for writeback.\n\n---\n\n#### **Module Behavior:**\n\n1. **Address and Byte Enable Calculation:**\n   - The LSU calculates memory addresses and byte enables depending on the data type (byte, halfword, word). \n   - If the address is misaligned, the operation is split into two transactions (requiring `two_transactions`).\n\n2. **State Machine:**\nBelow is the FSM representation to handle all scenarios:\n\n```mermaid\nstateDiagram-v2\n    direction LR\n    [*] --> IDLE: rst_n\n    IDLE --> MISALIGNED_WR: wr and misaligned\n    MISALIGNED_WR --> MISALIGNED_WR_1: granted\n    MISALIGNED_WR_1 --> IDLE: granted\n    IDLE --> MISALIGNED_RD: rd and misaligned\n    MISALIGNED_RD --> MISALIGNED_RD_GNT: granted\n    MISALIGNED_RD_GNT --> MISALIGNED_RD_1: dmem_rvalid_i\n    MISALIGNED_RD_1 --> MISALIGNED_RD_GNT_1: granted\n    MISALIGNED_RD_GNT_1 --> IDLE: dmem_rvalid_i\n    IDLE --> ALIGNED_WR: wr and aligned\n    ALIGNED_WR --> IDLE: granted\n    IDLE --> ALIGNED_RD: rd and aligned\n    ALIGNED_RD --> ALIGNED_RD_GNT: granted\n    ALIGNED_RD_GNT --> IDLE: dmem_rvalid_i\n```\n\n### **FSM State Descriptions**\n1. **IDLE:**\n   - Default state where the LSU waits for a request from the execute stage.\n   - Transitions to either `ALIGNED_WR`, `ALIGNED_RD`, `MISALIGNED_WR`, or `MISALIGNED_RD` based on the type and alignment of the request.\n\n2. **ALIGNED_WR:**\n   - Handles single bus transaction for an aligned store.\n   - Transitions back to `IDLE` after the grant signal.\n\n3. **ALIGNED_RD:**\n   - Handles single bus transaction for an aligned load.\n   - Transitions back to `IDLE` after the data memory response (`dmem_rvalid_i`).\n\n4. **MISALIGNED_WR:**\n   - Initiates the first bus transaction for a misaligned store.\n   - Transitions to `MISALIGNED_WR_1` after the first grant signal.\n\n5. **MISALIGNED_WR_1:**\n   - Completes the second bus transaction for a misaligned store.\n   - Returns to `IDLE` after the second grant signal.\n\n6. **MISALIGNED_RD:**\n   - Initiates the first bus transaction for a misaligned load.\n   - Transitions to `MISALIGNED_RD_GNT` after the first grant signal.\n\n7. **MISALIGNED_RD_GNT:**\n   - Waits for the first data response (`dmem_rvalid_i`) and transitions to `MISALIGNED_RD_1`.\n\n8. **MISALIGNED_RD_1:**\n   - Initiates the second bus transaction for a misaligned load.\n   - Transitions to `MISALIGNED_RD_GNT_1` after the second grant signal.\n\n9. **MISALIGNED_RD_GNT_1:**\n   - Waits for the second data response (`dmem_rvalid_i`) and transitions back to `IDLE`.\n\n\n3. **Request Handling:**\n   - The LSU monitors the `ex_if_req_i` signal to trigger a memory request.\n   - It determines whether the request is aligned or misaligned based on `two_transactions` and prepares the corresponding memory access signals.\n\n4. **Memory Request Generation:**\n   - Based on the request, the LSU asserts `dmem_req_o` and provides the memory address, byte enables, and data to the memory subsystem.\n   \n5. **Response Handling:**\n   - For load operations, data is read from memory (`dmem_rsp_rdata_i`), extended according to the data type, and sent to the writeback stage (`wb_if_rdata_o`).\n   - The module ensures proper timing and validity by controlling `dmem_req_o` and `dmem_rsp_rdata_i` based on the state transitions.\n\n---\n## Assertion Details\n\n### 1. **Invalid State Assertion**\nWrite an assertion to check that the `state` signal is always inside a valid set of states. The valid states include:\n- `IDLE`\n- `MISALIGNED_WR`, `MISALIGNED_WR_1`\n- `MISALIGNED_RD`, `MISALIGNED_RD_GNT`, `MISALIGNED_RD_GNT_1`, `MISALIGNED_RD_1`\n- `ALIGNED_RD_GNT`, `ALIGNED_RD`, `ALIGNED_WR`, `ALIGNED_WB`\n- `MISALIGNED_WB`\n\n---\n\n### 2. **Request When Not Ready Assertion**\nWrite an assertion to ensure that if `ex_if_req_i` is active only if `ex_if_ready_o` also active. This asserts that a request cannot happen if the system isn't ready.\n\n---\n\n### 3. **Aligned Write Assertion**\nWrite an assertion to check that when an aligned write request is directed to the memory, the memory responds with a grant (dmem_gnt_i) within 1 to 6 cycles.\n\n---\n\n### 4. **Aligned Read Assertion**\nWrite an assertion to check that when an aligned read request is directed to the memory, the memory responds with a grant (dmem_gnt_i) within 1 to 6 cycles, followed by the memory returning the data (dmem_rvalid_i) within the next 1 to 6 cycles.\n\n---\n\n### 5. **Misaligned Read Assertion**\nWrite an assertion to check that when a **misaligned read** request is directed, `dmem_req_o` is asserted twice to the memory. The memory should respond with a grant (`dmem_gnt_i`) within 1 to 6 cycles, followed by returning the data (`dmem_rvalid_i`) within the next 1 to 6 cycles. The sequence should occur as follows:\n\n1. `dmem_req_o` is asserted to initiate the first transaction.\n2. Once the memory grants the request, within 1 to 6 cycles, `dmem_req_o` is deasserted, and the module waits for `dmem_rvalid_i` to be asserted within 1 to 6 cycles before initiating the second transaction.\n3. `dmem_req_o` is asserted again to initiate the second transaction.\n4. When the memory grants the request, within 1 to 6 cycles, `dmem_req_o` is deasserted, and the module waits for `dmem_rvalid_i` to be asserted within 1 to 6 cycles, completing the misaligned read operation.\n\n---\n\n### 6. **Misaligned Write Assertion**\nWrite an assertion to check that when a **misaligned write** request is directed, `dmem_req_o` is asserted once to the memory. The memory should respond with a grant (`dmem_gnt_i`) within 1 to 6 cycles, followed by another grant (`dmem_gnt_i`) within the next 1 to 6 cycles. The sequence should occur as follows:\n\n1. `dmem_req_o` is asserted to initiate the first transaction.\n2. Once the memory grants the request, within 1 to 6 cycles, `dmem_req_o` **remains high**, and the module initiates the second transaction (without deasserting `dmem_req_o` in between).\n3. When the memory grants the second request, within 1 to 6 cycles, `dmem_req_o` is deasserted, completing the misaligned write operation.\n \n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/load_store_unit.sv": "module load_store_unit (\n    input  logic                 clk,\n    input  logic                 rst_n,\n\n    // EX stage interface\n    input  logic                 ex_if_req_i,           // LSU request\n    input  logic                 ex_if_we_i,            // Write enable: 0 (load), 1 (store)\n    input  logic     [ 1:0]      ex_if_type_i,          // Data type: 0x2 (word), 0x1 (halfword), 0x0 (byte)\n    input  logic     [31:0]      ex_if_wdata_i,         // Data to write to memory\n    input  logic     [31:0]      ex_if_addr_base_i,     // Base address\n    input  logic     [31:0]      ex_if_addr_offset_i,   // Offset address\n    input  logic                 ex_if_extend_mode_i,\n    output logic                 ex_if_ready_o    ,\n\n    \n    // Writeback stage interface\n    output logic     [31:0]      wb_if_rdata_o,         // Requested data\n    output logic                 wb_if_rvalid_o,        // Requested data valid\n\n    // Data memory (DMEM) interface\n    output logic                 dmem_req_o,\n    input  logic                 dmem_gnt_i,\n    output logic     [31:0]      dmem_req_addr_o,\n    output logic                 dmem_req_we_o,\n    output logic     [ 3:0]      dmem_req_be_o,\n    output logic     [31:0]      dmem_req_wdata_o,\n    input  logic     [31:0]      dmem_rsp_rdata_i,\n    input  logic                 dmem_rvalid_i\n    );\n  \n  typedef enum logic [4:0] {\n        IDLE,    \n        MISALIGNED_WR,\n        MISALIGNED_WR_1,  \n        MISALIGNED_RD ,\n        MISALIGNED_RD_GNT,\n        MISALIGNED_RD_GNT_1, \n        MISALIGNED_RD_1,\n        ALIGNED_RD_GNT,\n        ALIGNED_RD,\n        ALIGNED_WR,\n        ALIGNED_WB,\n        MISALIGNED_WB\n        } state_t;\n  state_t state, next_state ;\n  // Internal signals\n  logic ex_req_fire;\n  logic we_q;\n  logic [31:0] data_addr_int, addr_0, addr_1, word_addr, next_word_addr, addr_0_q, addr_1_q ;\n  logic  two_transactions;\n  logic [3:0] be_0, be_1, be_0_q, be_1_q ;\n\n  \n\n  logic [31:0] wdata_q;\n\n  logic wb_rsp_valid;\n\n  logic [1:0] rdata_offset_q ;\n  logic [31:0] rdata_w_ext , rdata_h_ext, rdata_b_ext, data_rdata_ext, dmem_rsp_data, rdata_0_q, rdata_1_q ;\n  logic [1:0] data_type_q ;\n  logic data_sign_ext_q ;\n\n  always_comb begin\n    data_addr_int = ex_if_addr_base_i + ex_if_addr_offset_i;\n    word_addr = {data_addr_int[31:2], 2'b00} ;\n    next_word_addr = word_addr + 3'b100 ;\n  end\n\n  assign ex_req_fire = ex_if_req_i && ex_if_ready_o ;\n\n  always_comb begin : address_bmem_alignment\n    addr_0 = '0 ;\n    be_0 = 4'b0000;\n    addr_1 = '0 ;\n    be_1 = 4'b0000;\n    two_transactions = 1'b0 ; \n    case (ex_if_type_i)  \n      2'b00: begin  \n          addr_0 = word_addr ;\n          case (data_addr_int[1:0])\n            2'b00:   be_0 = 4'b0001;\n            2'b01:   be_0 = 4'b0010;\n            2'b10:   be_0 = 4'b0100;\n            2'b11:   be_0 = 4'b1000;\n            default: be_0 = 4'b0000;\n          endcase\n      end\n\n      2'b01: begin  \n          case (data_addr_int[1:0])\n            2'b00: begin\n              addr_0 = word_addr ; \n              be_0 = 4'b0011;\n            end\n            2'b01: begin\n              addr_0 = word_addr ;\n              be_0 = 4'b0110;\n            end\n            2'b10: begin\n              addr_0 = word_addr ;\n              be_0 = 4'b1100;\n            end\n            2'b11: begin\n              two_transactions = 1'b1 ; \n              addr_0 = word_addr ;\n              be_0 = 4'b1000;\n              addr_1 = next_word_addr ;\n              be_1 = 4'b0001;\n            end\n          endcase\n      end\n\n      2'b10: begin  \n          case (data_addr_int[1:0])\n            2'b00: begin\n              addr_0 = word_addr ;\n              be_0 = 4'b1111;\n            end   \n            2'b01: begin\n              two_transactions = 1'b1 ;\n              addr_0 = word_addr ;\n              be_0 = 4'b1110;\n              addr_1 = next_word_addr ;\n              be_1 = 4'b0001;\n            end\n            2'b10: begin\n              two_transactions = 1'b1 ;\n              addr_0 = word_addr ;\n              be_0 = 4'b1100;\n\n              addr_1 = next_word_addr ;\n              be_1 = 4'b0011;\n            end\n            2'b11: begin\n              two_transactions = 1'b1 ;\n              addr_0 = word_addr ;\n              be_0 = 4'b1000;\n              addr_1 = next_word_addr ;\n              be_1 = 4'b0111;\n            end\n          endcase\n      end\n      default: begin\n        addr_0 = '0 ;\n        be_0 = 4'b0000;\n        addr_1 = '0 ;\n        be_1 = 4'b0000;\n        two_transactions = 1'b0 ;\n      end\n       \n    endcase\n  end\n\n  always_comb begin : state_transition\n    case(state)\n      IDLE: begin // Note req only checked if idle (ready)\n        if (ex_if_req_i) begin\n          if (ex_if_we_i && two_transactions) begin\n            next_state = MISALIGNED_WR ;\n          end \n          else if (!ex_if_we_i && two_transactions) begin \n            next_state = MISALIGNED_RD ;\n          end \n          else if (ex_if_we_i && !two_transactions)  begin\n            next_state = ALIGNED_WR ;\n          end \n          else next_state = ALIGNED_RD ;\n        end else begin\n          next_state = IDLE ;\n        end\n      end\n      MISALIGNED_WR: begin\n        if (dmem_gnt_i) begin\n          next_state = MISALIGNED_WR_1 ; \n        end else begin\n          next_state = MISALIGNED_WR ;\n        end\n      end\n      MISALIGNED_WR_1: begin\n        if (dmem_gnt_i) begin\n          next_state = IDLE ; \n        end else begin\n          next_state = MISALIGNED_WR_1 ;\n        end\n      end\n      \n      MISALIGNED_RD: begin\n        if (dmem_gnt_i) begin\n          next_state = MISALIGNED_RD_GNT ; \n        end else begin\n          next_state = MISALIGNED_RD ;\n        end\n      end\n\n      MISALIGNED_RD_GNT: begin\n        if (dmem_rvalid_i) begin\n          next_state = MISALIGNED_RD_1 ; \n        end else begin\n          next_state = MISALIGNED_RD_GNT ;\n        end\n      end\n\n      MISALIGNED_RD_1: begin\n        if (dmem_gnt_i) begin\n          next_state = MISALIGNED_RD_GNT_1 ; \n        end else begin\n          next_state = MISALIGNED_RD_1 ;\n        end\n      end\n\n      MISALIGNED_RD_GNT_1: begin\n        if (dmem_rvalid_i) begin\n          next_state = MISALIGNED_WB ; \n        end else begin\n          next_state = MISALIGNED_RD_GNT_1 ;\n        end\n      end\n\n      MISALIGNED_WB: begin\n        next_state = IDLE ;\n      end\n\n      ALIGNED_WR: begin\n        if (dmem_gnt_i) begin\n          next_state = IDLE ; \n        end else begin\n          next_state = ALIGNED_WR ;\n        end\n      end\n      ALIGNED_RD : begin\n        if (dmem_gnt_i) begin\n          next_state = ALIGNED_RD_GNT ; \n        end else begin\n          next_state = ALIGNED_RD ;\n        end\n      end\n      ALIGNED_RD_GNT: begin\n        if (dmem_rvalid_i) begin\n          next_state = ALIGNED_WB ; \n        end else begin\n          next_state = ALIGNED_RD_GNT ;\n        end\n      end\n      \n      ALIGNED_WB: begin\n        next_state = IDLE ;\n      end\n      \n      default: begin\n        next_state = IDLE ;\n      end\n    endcase\n  end\n  always_comb begin : output_logic\n    case(state)\n      IDLE: begin\n        ex_if_ready_o     = 1'b1 ;\n        dmem_req_o        = '0 ;\n        dmem_req_addr_o   = '0 ;\n        dmem_req_we_o     = '0 ;\n        dmem_req_be_o     = '0 ;\n        dmem_req_wdata_o  = '0 ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n      MISALIGNED_WR: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b1 ;\n        dmem_req_addr_o   = addr_0_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_0_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ; \n        wb_rsp_valid      = 1'b0 ;\n      end\n      MISALIGNED_WR_1: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b1 ;\n        dmem_req_addr_o   = addr_1_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_1_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n      \n      MISALIGNED_RD: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b1 ;\n        dmem_req_addr_o   = addr_0_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_0_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n\n      MISALIGNED_RD_GNT: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b0 ;\n        dmem_req_addr_o   = addr_0_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_0_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n\n      MISALIGNED_RD_1: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b1 ;\n        dmem_req_addr_o   = addr_1_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_1_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n\n      MISALIGNED_RD_GNT_1: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b0 ;\n        dmem_req_addr_o   = addr_0_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_0_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n\n      MISALIGNED_WB: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b0 ;\n        dmem_req_addr_o   = '0 ;\n        dmem_req_we_o     = '0 ; \n        dmem_req_be_o     = '0 ; \n        dmem_req_wdata_o  = '0 ;\n        dmem_rsp_data     = rdata_0_q | rdata_1_q ;\n        wb_rsp_valid      = 1'b1 ; \n      end\n      ALIGNED_WR: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b1 ;\n        dmem_req_addr_o   = addr_0_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_0_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n      ALIGNED_RD : begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b1 ;\n        dmem_req_addr_o   = addr_0_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_0_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n      ALIGNED_RD_GNT: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b0 ;\n        dmem_req_addr_o   = addr_0_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_0_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n\n      ALIGNED_WB: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b0 ;\n        dmem_req_addr_o   = '0 ;\n        dmem_req_we_o     = '0 ; \n        dmem_req_be_o     = '0 ; \n        dmem_req_wdata_o  = '0 ;\n        dmem_rsp_data     = rdata_0_q ;\n        wb_rsp_valid      = 1'b1 ;\n      end\n      default: begin\n        ex_if_ready_o     = 1'b1 ;\n        dmem_req_o        = '0 ;\n        dmem_req_addr_o   = '0 ;\n        dmem_req_we_o     = '0 ;\n        dmem_req_be_o     = '0 ;\n        dmem_req_wdata_o  = '0 ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n    endcase\n  end\n  \n  always_ff @( posedge clk or negedge rst_n ) begin : FSM\n    if (!rst_n) begin\n      state <= IDLE;\n    end else begin\n      state <= next_state;\n    end  \n  end\n  \n    \n  always_ff @(posedge clk or negedge rst_n) begin : ex_req_reg\n    if (!rst_n) begin\n      we_q <= '0 ;\n      addr_0_q <= '0 ; \n      be_0_q <= '0 ;\n      addr_1_q <= '0 ;\n      be_1_q <= '0 ;\n      wdata_q <= '0 ;\n      data_type_q <= '0 ;\n      rdata_offset_q <= '0 ;\n      data_sign_ext_q <= '0 ;\n      \n    end else if (ex_req_fire) begin\n      we_q <= ex_if_we_i ;\n      addr_0_q <= addr_0; \n      be_0_q <= be_0;\n      addr_1_q <= addr_1;\n      be_1_q <= be_1;\n      wdata_q <= ex_if_wdata_i ;\n      data_type_q <= ex_if_type_i ;\n      rdata_offset_q <= data_addr_int[1:0] ;\n      data_sign_ext_q <= ex_if_extend_mode_i ;\n    end \n  end\n\nalways_comb begin : w_ext\n    case (rdata_offset_q)\n      2'b00: rdata_w_ext = dmem_rsp_data[31:0];\n      2'b01: rdata_w_ext = {dmem_rsp_data[7:0], dmem_rsp_data[31:8]};\n      2'b10: rdata_w_ext = {dmem_rsp_data[15:0], dmem_rsp_data[31:16]};\n      2'b11: rdata_w_ext = {dmem_rsp_data[23:0], dmem_rsp_data[31:24]};\n      default: rdata_w_ext = dmem_rsp_data ;\n    endcase\n  end\n\n  always_comb begin : h_ext\n    case (rdata_offset_q)\n      2'b00: begin\n        if (data_sign_ext_q) rdata_h_ext ={{16{dmem_rsp_data[15]}}, dmem_rsp_data[15:0]};\n        else rdata_h_ext =  {16'h0000, dmem_rsp_data[15:0]};\n      end\n\n      2'b01: begin\n        if (data_sign_ext_q) rdata_h_ext ={{16{dmem_rsp_data[23]}}, dmem_rsp_data[23:8]};\n        else rdata_h_ext =  {16'h0000, dmem_rsp_data[23:8]};\n      end\n      2'b10: begin\n        if (data_sign_ext_q) rdata_h_ext ={{16{dmem_rsp_data[31]}}, dmem_rsp_data[31:16]};\n        else rdata_h_ext =  {16'h0000, dmem_rsp_data[31:16]};\n      end\n      2'b11: begin\n        if (data_sign_ext_q) rdata_h_ext ={{16{dmem_rsp_data[7]}}, dmem_rsp_data[7:0] , dmem_rsp_data[31:24] };\n        else rdata_h_ext =  {16'h0000, dmem_rsp_data[7:0], dmem_rsp_data[31:24] };\n      end\n      \n      default: begin\n        rdata_h_ext = dmem_rsp_data ;  \n      end\n    endcase  \n  end\n  \n  always_comb begin : b_ext\n    case (rdata_offset_q)\n      2'b00: begin\n        if (data_sign_ext_q) rdata_b_ext  = {{24{dmem_rsp_data[7]}}, dmem_rsp_data[7:0]}; \n        else rdata_b_ext = {24'h00_0000, dmem_rsp_data[7:0]};\n      end\n\n      2'b01: begin\n        if (data_sign_ext_q) rdata_b_ext  = {{24{dmem_rsp_data[15]}}, dmem_rsp_data[15:8]}; \n        else rdata_b_ext = {24'h00_0000, dmem_rsp_data[15:8]};\n      end\n\n      2'b10: begin\n        if (data_sign_ext_q) rdata_b_ext  = {{24{dmem_rsp_data[23]}}, dmem_rsp_data[23:16]}; \n        else rdata_b_ext = {24'h00_0000, dmem_rsp_data[23:16]};\n      end\n\n      2'b11: begin\n        if (data_sign_ext_q) rdata_b_ext  = {{24{dmem_rsp_data[31]}}, dmem_rsp_data[31:24]}; \n        else rdata_b_ext = {24'h00_0000, dmem_rsp_data[31:24]};\n      end\n    endcase  \n  end\n\n  always_comb begin : rdata_ext\n    case (data_type_q)\n      2'b00:        data_rdata_ext = rdata_b_ext ;\n      2'b01:        data_rdata_ext = rdata_h_ext;\n      2'b10:        data_rdata_ext = rdata_w_ext;\n      default:      data_rdata_ext = 32'b0;\n    endcase  \n  end\n\n  always_ff @(posedge clk or negedge rst_n) begin :dmem_reg\n    if (!rst_n) begin\n      rdata_0_q   <= 32'b0;\n      rdata_1_q   <=  32'b0;\n    end else if (dmem_rvalid_i) begin\n      rdata_0_q  <= dmem_rsp_rdata_i;\n      rdata_1_q  <= rdata_0_q;\n    end\n  end\n\n\n  assign wb_if_rdata_o =  data_rdata_ext;\n  assign wb_if_rvalid_o = wb_rsp_valid;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/load_store_unit.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\r\n\r\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/load_store_unit.sv\nTOPLEVEL        = load_store_unit\nMODULE          = test_load_store_unit\nPYTHONPATH      = /src\nHASH            = \"feature/assertions_1\"\n", "src/harness_library.py": "\nimport cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, ReadOnly, NextTimeStep, Timer\nimport random\nimport os\nimport subprocess\nimport re\n#       Test_Vec = (type, wdata, addr_base, addr_off, sign_extend)\n\ndef is_cross_boundary(Test_Vec):\n    type = Test_Vec[0] \n    address = (Test_Vec[2]+ Test_Vec[3])\n    addr_offset= address& 0x3\n    crossing_hw = (type == 0x1) and (addr_offset==3)\n    crossing_w = (type == 0x2) and (addr_offset!=0)\n    if ( crossing_hw or crossing_w ):\n            return True\n    else:\n        return False\n\nasync def check_dmem_req(dut, Test_Vec, we):\n    address = (Test_Vec[2]+ Test_Vec[3])\n    expected_addr = (address//4)*4\n    \n    if (is_cross_boundary(Test_Vec)):\n        for _ in range(2):\n            while int(dut.dmem_req_o.value) != 1:\n                await RisingEdge(dut.clk)\n            \n            await FallingEdge(dut.clk)\n            dut_address = int(dut.dmem_req_addr_o.value)\n            dut_we = int(dut.dmem_req_we_o.value)\n\n            assert dut_address == expected_addr, f\"Dmem address mismatch: Expected:{expected_addr}, Got:{dut_address}\"\n            assert dut_we == we, f\"Dmem we mismatch: Expected: {we}, Got:{dut_we}\"\n            # wait for that transaction to be granted/rvalid rsp\n            if(we):\n                await RisingEdge(dut.dmem_gnt_i)\n            else:\n                await RisingEdge(dut.dmem_rvalid_i)\n            await RisingEdge(dut.clk)\n            \n            expected_addr+=4\n    else:\n        while int(dut.dmem_req_o.value) != 1:\n                await RisingEdge(dut.clk)\n        \n        await FallingEdge(dut.clk)\n        dut_address = int(dut.dmem_req_addr_o.value)\n        dut_we = int(dut.dmem_req_we_o.value)\n\n        assert dut_address == expected_addr, f\"Dmem address mismatch: Expected:{expected_addr}, Got:{dut_address}\"\n        assert dut_we == we, f\"Dmem we mismatch: Expected: {we}, Got:{dut_we}\"\n\n    \n    \n\nasync def check_wb_val(dut, dmem_model, Test_Vec):\n    type, _, addr_base, addr_off, sign_extend = Test_Vec\n    address = (addr_base+ addr_off)\n    aligned_address = (address//4)*4\n    expected_wb = 0 \n    read_val_vec = (aligned_address, 0, 0xF, 0)\n    data0 = dmem_model.read_addr(read_val_vec)\n    read_val_vec = (aligned_address+4, 0, 0xF, 0)\n    data1 = dmem_model.read_addr(read_val_vec)\n    byte_offset = address % 4\n\n    if (is_cross_boundary(Test_Vec)):\n        # Calculate offsets and extract relevant data\n        if type == 1:  # Halfword\n            if byte_offset == 3:\n                extracted_data = ((data0 >> (8 * 3)) & 0xFF) | ((data1 & 0xFF) << 8)\n            else:\n                extracted_data = (data0 >> (8 * byte_offset)) & 0xFFFF\n        elif type == 2:  # Word\n            extracted_data = ((data0 >> (8 * byte_offset)) & 0xFFFFFFFF) | ((data1 & 0xFFFFFFFF) << (32 - 8 * byte_offset))\n\n        # Apply sign or zero extension\n        if sign_extend:\n            sign_bit = 1 << (15 if type == 1 else 31)  # MSB for halfword or word\n            if extracted_data & sign_bit:\n                expected_wb = extracted_data | (~((1 << (16 if type == 1 else 32)) - 1))\n            else:\n                expected_wb = extracted_data\n        else:\n            expected_wb = extracted_data\n        \n        expected_wb = expected_wb & 0xFFFFFFFF\n \n    else: # Aligned case\n        if type == 0:  # Byte\n            extracted_data = (data0 >> (8 * byte_offset)) & 0xFF\n        elif type == 1:  # Halfword\n            extracted_data = (data0 >> (8 * byte_offset)) & 0xFFFF\n        elif type == 2:  # Word\n            extracted_data = data0\n\n        # Apply sign or zero extension\n        if sign_extend:\n            sign_bit = 1 << (7 if type == 0 else 15 if type == 1 else 31) # 0b10000000 , 0b1000000000000000\n            if extracted_data & sign_bit:\n                expected_wb = extracted_data | (~((1 << (8 if type == 0 else 16 if type == 1 else 32)) - 1))\n            else:\n                expected_wb = extracted_data\n        else:\n            expected_wb = extracted_data\n        \n        expected_wb = expected_wb & 0xFFFFFFFF\n        expected_wb = expected_wb & 0xFFFFFFFF\n\n    while int(dut.wb_if_rvalid_o.value) != 1:\n            await RisingEdge(dut.clk)\n        \n    \n    wb_if_rdata_o = int(dut.wb_if_rdata_o.value)\n\n    assert wb_if_rdata_o == expected_wb, f\"WB MISMATCH: Expected:{hex(expected_wb)}, Got:{hex(wb_if_rdata_o)}\"\n    \n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def reset_dut(reset, duration_ns = 10):\n    # Restart Interface\n    reset.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    reset.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    reset.value = 1\n    await Timer(duration_ns, units='ns')\n    reset._log.debug(\"Reset complete\")\n\n\n\nclass DataMemory:\n    def __init__(self):\n        self.mem_array = [0] * (2**8)  # 32-bit memory addresses\n\n    # Value tuple is a tuple (addr, we, be, wdata)\n    def write_addr(self, value):\n        \"\"\"\n        Perform a memory write operation considering the byte enable (BE).\n        \"\"\"\n        addr, we, be, wdata = value\n\n        if we:  # Write enable is asserted\n            current_word = self.mem_array[addr]\n            for byte_index in range(4):\n                if be & (1 << byte_index):  \n                    current_word &= ~(0xFF << (byte_index * 8))\n                    current_word |= (wdata & (0xFF << (byte_index * 8)))\n\n            self.mem_array[addr] = current_word\n\n    def read_addr(self, value):\n        \"\"\"\n        Perform a memory read operation considering the byte enable (BE).\n        \"\"\"\n        addr, _, be, _ = value\n\n        \n        current_word = self.mem_array[addr]\n\n        \n        read_data = 0\n        for byte_index in range(4):\n            if be & (1 << byte_index):  \n                read_data |= (current_word & (0xFF << (byte_index * 8)))\n\n        return read_data\n\nclass ExReqDriver:\n    def __init__(self, dut, name, clk, sb_callback):\n        \"\"\"\n        Initialize the InputDriver.\n        :param dut: The DUT instance.\n        :param name: The name of the bus signals (e.g., 'input_bus').\n        :param clk: Clock signal for synchronization.\n        :param sb_callback: Callback function to handle data/address events.\n        \"\"\"\n        self.dut = dut\n        self.clk = clk\n        self.callback = sb_callback\n        \n        # Initialize bus signals\n        self.bus = {\n            \"req_i\"         : getattr(dut, f\"{name}_req_i\"),\n            \"we_i\"          : getattr(dut, f\"{name}_we_i\"),\n            \"type_i\"        : getattr(dut, f\"{name}_type_i\"),\n            \"wdata_i\"       : getattr(dut, f\"{name}_wdata_i\"),\n            \"addr_base_i\"   : getattr(dut, f\"{name}_addr_base_i\"),\n            \"extend_mode_i\" : getattr(dut, f\"{name}_extend_mode_i\"),              \n            \"addr_offset_i\" : getattr(dut, f\"{name}_addr_offset_i\"),\n            \"ready_o\"       : getattr(dut, f\"{name}_ready_o\"), \n        }\n\n        # Reset bus values\n        self.bus[\"req_i\"].value = 0\n\n    async def write_req(self, value):\n        \"\"\"\n        Send a value over the bus.\n        :param value: A tuple (type, wdata, base_addr, off_addr) to send on the bus.\n        \"\"\"\n        # Random delay before request\n        for _ in range(random.randint(1, 20)):\n            await RisingEdge(self.clk)\n\n        # Wait until ready signal is asserted\n        # PROMPT: \" ex_if_req_i Should only be asserted if the module is ready\"\n        while self.bus[\"ready_o\"].value != 1:\n            await RisingEdge(self.clk)\n\n        # Drive the bus\n        # PROMPT:\n        # The module will register the calculated \n        # address, write data (if applicable), and control signals (e.g., write enable, byte enable) to signal a data memory request.\n        self.bus[\"req_i\"].value = 1\n        self.bus[\"we_i\"].value = 1\n        self.bus[\"type_i\"].value = value[0]\n        self.bus[\"wdata_i\"].value = value[1]\n        self.bus[\"addr_base_i\"].value = value[2]\n        self.bus[\"addr_offset_i\"].value = value[3]\n        self.bus[\"extend_mode_i\"].value = 0 # Doesn't affect write\n\n\n        # Allow ReadOnly phase and trigger the callback\n        await ReadOnly()\n        self.callback(self.dut, int(self.bus[\"type_i\"].value), int(self.bus[\"wdata_i\"].value), int(self.bus[\"addr_base_i\"].value), int(self.bus[\"addr_offset_i\"].value))\n\n        # Hold the enable signal for one clock cycle\n        await RisingEdge(self.clk)\n        self.bus[\"req_i\"].value = 0\n        self.bus[\"we_i\"].value = 0\n\n        \n            \n\n    async def read_req(self, value):\n        \"\"\"\n        Send a value over the bus.\n        :param value: A tuple (type, wdata, base_addr, off_addr) to send on the bus.\n        \"\"\"\n        # Random delay before sending data\n        #PROMPT: \" ex_if_req_i Should only be asserted if the module is ready\"\n        for _ in range(random.randint(1, 20)):\n            await RisingEdge(self.clk)\n\n        # Wait until ready signal is asserted\n        # PROMPT: \" ex_if_req_i Should only be asserted if the module is ready\"\n        while self.bus[\"ready_o\"].value != 1:\n            await RisingEdge(self.clk)\n\n        # Drive the bus\n        # PROMPT:\n        # The module will register the calculated \n        # address, write data (if applicable), and control signals (e.g., write enable, byte enable) to signal a data memory request.\n        self.bus[\"req_i\"].value = 1\n        self.bus[\"we_i\"].value = 0\n        self.bus[\"type_i\"].value = value[0]\n        self.bus[\"wdata_i\"].value = 0\n        self.bus[\"addr_base_i\"].value = value[2]\n        self.bus[\"addr_offset_i\"].value = value[3]\n        self.bus[\"extend_mode_i\"].value = value[4]\n        self.extend = value[4]\n\n\n        # Allow ReadOnly phase and trigger the callback\n        await ReadOnly()\n        self.callback(self.dut, int(self.bus[\"type_i\"].value), int(self.bus[\"wdata_i\"].value), int(self.bus[\"addr_base_i\"].value), int(self.bus[\"addr_offset_i\"].value))\n\n        # Hold the enable signal for one clock cycle\n        await RisingEdge(self.clk)\n        self.bus[\"req_i\"].value = 0\n\n        \n\n\nclass dmemIFDriver:\n    def __init__(self, dut, name, clk, dmem_model):\n        \"\"\"\n        Initialize the InputDriver.\n        :param dut: The DUT instance.\n        :param name: The name of the bus signals (e.g., 'input_bus').\n        :param clk: Clock signal for synchronization.\n        \"\"\"\n        self.dut = dut\n        self.clk = clk\n        # Initialize bus signals\n        self.bus = {\n            \"req_o\"        : getattr(dut, f\"{name}_req_o\"),\n            \"req_addr_o\"   : getattr(dut, f\"{name}_req_addr_o\"),\n            \"req_we_o\"     : getattr(dut, f\"{name}_req_we_o\"),\n            \"req_be_o\"     : getattr(dut, f\"{name}_req_be_o\"),\n            \"req_wdata_o\"  : getattr(dut, f\"{name}_req_wdata_o\"),\n            \"rsp_rdata_i\"  : getattr(dut, f\"{name}_rsp_rdata_i\"),\n            \"rvalid_i\"     : getattr(dut, f\"{name}_rvalid_i\"),\n            \"gnt_i\"        : getattr(dut, f\"{name}_gnt_i\"),    \n        }\n\n        # Reset bus values\n        self.bus[\"rvalid_i\"].value = 0\n        self.bus[\"rsp_rdata_i\"].value = 0\n        self.bus[\"gnt_i\"].value = 0\n        self.dmem_model = dmem_model\n        cocotb.start_soon(self._listening())\n\n\n    async def _listening(self):\n        while True:\n            while self.bus[\"req_o\"].value != 1:\n                await RisingEdge(self.clk)\n            addr = int(self.bus[\"req_addr_o\"].value)\n            we = int(self.bus[\"req_we_o\"].value)\n            be = int(self.bus[\"req_be_o\"].value)\n            wdata = int(self.bus[\"req_wdata_o\"].value)\n            Req_vector = (addr, we, be, wdata)\n            await self._process_req(Req_vector)\n            \n          \n    async def _process_req(self, value):\n        \"\"\"\n        Send a value over the bus.\n        :param value: A tuple (addr, we, be, wdata) to send on the bus.\n        \"\"\"\n        # Wait random time to gnt the request \n        for _ in range(random.randint(1, 5)):\n            await RisingEdge(self.clk)\n        self.bus[\"gnt_i\"].value = 1\n        await RisingEdge(self.clk)\n        self.bus[\"gnt_i\"].value = 0\n        await ReadOnly()\n        if value[1] == 1: #Write req\n            self.dmem_model.write_addr(value)\n        else: #Read req\n           # Read from mem model\n           rdata = self.dmem_model.read_addr(value)\n           for _ in range(random.randint(1, 5)):\n               await RisingEdge(self.clk) \n           self.bus[\"rvalid_i\"].value = 1\n           self.bus[\"rsp_rdata_i\"].value = rdata \n           await RisingEdge(self.clk)\n           self.bus[\"rvalid_i\"].value = 0\n           self.bus[\"rsp_rdata_i\"].value = 0\n           \n    \n#################    ASSERTIONS STUFF        ###############\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"    \n     \n        \n    ", "src/test_load_store_unit.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport time\nimport harness_library as hrs_lb\nfrom harness_library import ExReqDriver, dmemIFDriver, DataMemory\n\n# Place holder for coverage\n\ndef execute_sb_fn(dut,type_i, wdata, addr_base, addr_offset):\n   pass\n   #dut._log.info(f\"Execute unit request -- type:{hex(type_i)}, write_data = {hex(wdata)}, addr: {hex(addr_base + addr_offset)}\")\n\n@cocotb.test()\nasync def test_load_store_unit(dut): \n   # Start clock\n   DUT_CLK = Clock(dut.clk, 10, 'ns')\n   await cocotb.start(DUT_CLK.start())\n   dut.clk._log.info(f\"clk STARTED\")\n\n   await hrs_lb.dut_init(dut)\n\n   # Apply reset \n   await hrs_lb.reset_dut(dut.rst_n, 10)\n\n   for i in range(2):\n      await RisingEdge(dut.clk)\n\n   # Ensure  outputs reset value \n\n   # The Execution Stage Interface is signaled as ready for new requests.\n   assert dut.ex_if_ready_o.value == 1, f\"The Execution Stage Interface should be signaled as ready for new requests (ex_if_ready_o = 0x1): {dut.ex_if_ready_o.value}\"\n   \n   # No requests are sent to data memory.\n   assert dut.dmem_req_o.value == 0, f\"\u064fShould be No requests are sent to data memory (dmem_req_o = 0x0). {dut.dmem_req_o.value}\"\n   \n   # No valid data is provided to the writeback stage.\n   assert dut.wb_if_rvalid_o.value == 0, f\"Should be No valid data  provided to the writeback stage (wb_if_rvalid_o = 0x0). {dut.wb_if_rvalid_o.value}\"\n\n   \n   await FallingEdge(dut.clk)\n   \n   execute_if_driver = ExReqDriver(dut,'ex_if',dut.clk,execute_sb_fn)\n   dmem_model = DataMemory()\n   dmemIFDriver(dut,'dmem', dut.clk, dmem_model)\n\n   for i in range(5000):\n      wdata = random.randint(0, 2**32) # 32 bit word data\n      addr_base = random.randint(0,2**6)\n      addr_off = random.randint(0,2**6) # Limiting address space to 7 bit (MemoryModel representation limit)\n      type = random.randint(0,2) # TYPE: can be 0x0, 0x1, 0x2\n      sign_extend = random.randint(0,1)\n      sign_extend = 1\n      Test_Vec = (type, wdata, addr_base, addr_off, sign_extend)\n      # Drive Write operation\n      await execute_if_driver.write_req(Test_Vec)\n      await hrs_lb.check_dmem_req(dut, Test_Vec, 1)\n      \n      # Read the written value\n      await execute_if_driver.read_req(Test_Vec)\n\n      await hrs_lb.check_dmem_req(dut, Test_Vec, 0)\n      await hrs_lb.check_wb_val(dut, dmem_model, Test_Vec)\n\n\n\n    \n\n\n\n", "src/test_runner.py": "import os\nfrom cocotb.runner import get_runner\nimport harness_library as hrs_lb\n\nimport pytest\nimport random\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    runner = get_runner(\"xcelium\")\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        build_args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\"),\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=False,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n    hrs_lb.coverage_report(\"assertion\")\n    hrs_lb.covt_report_check()\n\ndef test_allocator():\n    runner()\n"}}}
{"id": "cvdp_copilot_manchester_enc_0009", "categories": ["cid012", "easy"], "input": {"prompt": "Complete the given SystemVerilog testbench for the `top_manchester` module. The testbench currently instantiates the UUT and should include stimulus generation logic that dynamically produces a wide range of test scenarios to ensure 100% functional and code coverage. The stimulus generation logic should drive the design under various conditions, including the module functionality below.\n\n---\n\n## Description\n\n### Parameter\n- **`N`**: Input Parameter Value, Default value is 8.\n\n### Inputs\n\n- **`clk_in`**: Clock signal driving the design (positive edge triggered).\n- **`rst_in`**: Asynchronous reset signal (active high) to reset the encoder and decoder.\n- **`enc_valid_in`**: 1-bit Input valid signal for the encoder.\n- **`enc_data_in[N-1:0]`**: N-bit input data for the encoder.\n- **`dec_valid_in`**: 1-bit Input valid signal for the decoder.\n- **`dec_data_in[2*N-1:0]`**: 2N-bit input data for the decoder.\n\n### Outputs\n\n- **`enc_valid_out`**: 1-bit Output valid signal for the encoder.\n- **`enc_data_out[2*N-1:0]`**: 2N-bit Manchester-encoded output data from the encoder.\n- **`dec_valid_out`**: 1-bit Output valid signal for the decoder.\n- **`dec_data_out[N-1:0]`**: N-bit decoded output data from the decoder.\n\n---\n\n## Input Generation\n\n### Input Generation\n\n- **Clock and Reset**:\n  - Generate a clock signal (`clk_in`) with a configurable period.\n  - Apply reset (`rst_in`) at the beginning and during random intervals to test reset behavior.\n\n- **Encoder Inputs**:\n  - Generate diverse patterns for `enc_data_in`, such as:\n    - Incremental data (e.g., 0, 1, 2, ...).\n    - Random data patterns.\n    - Edge cases (e.g., all zeros, all ones, alternating patterns).\n  - Toggle `enc_valid_in` to test valid and invalid input scenarios.\n\n- **Decoder Inputs**:\n  - Generate diverse patterns for `dec_data_in`, such as:\n    - Valid Manchester-encoded data (e.g., 0x5AA5, 0xC33C).\n    - Invalid Manchester-encoded data (e.g., 0xFFFF, 0x0000).\n    - Incremental data (e.g., 0, 1, 2, ...).\n    - Random data patterns.\n  - Toggle `dec_valid_in` to test valid and invalid input scenarios.\n\n## **Instantiation**  \n\n- The instance of the RTL should be named **`uut`**.  \n\n---\n\nFollows the specification for building the RTL of the module, use it as a reference for the verification environment too: \n## Module Functionality\n\n1. **Encoder Functionality**:\n   - The encoder converts N-bit input data (`enc_data_in`) into 2N-bit Manchester-encoded data (`enc_data_out`).\n   - The encoding logic follows the Manchester encoding scheme:\n     - `1` is encoded as `01`.\n     - `0` is encoded as `10`.\n\n2. **Decoder Functionality**:\n   - The decoder converts 2N-bit Manchester-encoded data (`dec_data_in`) into N-bit decoded data (`dec_data_out`).\n   - The decoding logic follows the Manchester decoding scheme:\n     - `01` is decoded as `1`.\n     - `10` is decoded as `0`.\n     - Invalid patterns (e.g., `00` or `11`) are decoded as `0`.\n\n3. **Reset Behavior**:\n   - When `rst_in` is asserted, all outputs (`enc_data_out`, `enc_valid_out`, `dec_data_out`, `dec_valid_out`) are cleared to zero.\n\n---\n\n```verilog\nmodule tb_top_manchester;\n\n    parameter N = 8;  // Width of input and output data\n    parameter CLK_PERIOD = 10;  // Clock period in ns\n\n    // Testbench signals\n    logic clk_in;\n    logic rst_in;\n    logic enc_valid_in;\n    logic [N-1:0] enc_data_in;\n    logic dec_valid_out;\n    logic dec_valid_in;\n    logic [N-1:0] dec_data_out;\n    logic [2*N-1:0] enc_data_out; // 2N-bit Manchester encoded data\n    logic [2*N-1:0] dec_data_in; // 2N-bit Manchester encoded data\n    logic enc_valid_out;          // Encoded data valid signal\n\n    // Instantiate the top module\n    top_manchester #(\n        .N(N)\n    ) uut (\n        .clk_in(clk_in),\n        .rst_in(rst_in),\n        \n        .enc_valid_in(enc_valid_in),\n        .enc_data_in(enc_data_in),\n        .enc_valid_out(enc_valid_out),\n        .enc_data_out(enc_data_out),\n        \n        .dec_valid_in(dec_valid_in),\n        .dec_data_in(dec_data_in),\n        .dec_valid_out(dec_valid_out),\n        .dec_data_out(dec_data_out)\n        \n    );\n\n    // Insert the code here to generate stimulus generation logic\n\nendmodule\n```", "context": {}}, "output": {"response": "", "context": {"verif/tb_top_manchester.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 6287c4b82cca1a6847ec1472e026f940b4ffdb3f\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n", "src/top_manchester.sv": "module top_manchester #(\r\n    parameter N = 8  // Default width of input and output data\r\n) (\r\n    input  logic           clk_in,          // Clock input\r\n    input  logic           rst_in,          // Active high reset input\r\n    \r\n    // Encoder Signals\r\n    input  logic           enc_valid_in,    // Input valid signal\r\n    input  logic [N-1:0]   enc_data_in,     // N-bit input data\r\n    output logic           enc_valid_out,   // Output valid signal\r\n    output logic [2*N-1:0] enc_data_out,    // 2*N-bit encoder output data\r\n    \r\n    // Decoder Signals\r\n    input  logic           dec_valid_in,    // Input valid signal\r\n    input  logic [2*N-1:0] dec_data_in,     // 2*N-bit input data\r\n    output logic           dec_valid_out,   // Output valid signal\r\n    output logic [N-1:0]   dec_data_out     // N-bit output decoded data\r\n);\r\n\r\n    always_ff @(posedge clk_in) begin\r\n        if (rst_in) begin\r\n            enc_data_out  <= '0; \r\n            enc_valid_out <= 1'b0; \r\n        end else if (enc_valid_in) begin\r\n            for (int i = 0; i < N; i++) begin\r\n                if (enc_data_in[i] == 1'b1) begin\r\n                    enc_data_out[2*i]   <= 1'b1;\r\n                    enc_data_out[2*i+1] <= 1'b0;\r\n                end else begin\r\n                    enc_data_out[2*i]   <= 1'b0;\r\n                    enc_data_out[2*i+1] <= 1'b1;\r\n                end\r\n            end\r\n            enc_valid_out <= 1'b1;\r\n        end else begin\r\n            enc_data_out  <= 'd0;\r\n            enc_valid_out <= 1'b0;\r\n        end\r\n    end\r\n\r\n    always_ff @(posedge clk_in) begin\r\n        if (rst_in) begin\r\n            dec_data_out  <= '0; \r\n            dec_valid_out <= 1'b0;\r\n        end else if (dec_valid_in) begin\r\n            for (int i = 0; i < N; i++) begin\r\n                if (dec_data_in[2*i] == 1'b1 && dec_data_in[2*i+1] == 1'b0) begin\r\n                    dec_data_out[i] <= 1'b1;\r\n                end else if (dec_data_in[2*i] == 1'b0 && dec_data_in[2*i+1] == 1'b1) begin\r\n                    dec_data_out[i] <= 1'b0;\r\n                end else begin\r\n                    dec_data_out[i] <= 1'b0;\r\n                end\r\n            end\r\n            dec_valid_out <= 1'b1;\r\n        end else begin\r\n            dec_data_out  <= '0;\r\n            dec_valid_out <= 1'b0;\r\n        end\r\n    end\r\n\r\nendmodule\r\n"}}}
{"id": "cvdp_copilot_matrix_multiplier_0022", "categories": ["cid012", "easy"], "input": {"prompt": "Write a testbench for the `matrix_multiplier` module, which performs matrix multiplication for configurable dimensions. The testbench should focus only on generating stimuli to exercise all key features of the module.\n\n---\n\n## Design Details\n\n### **Parameterization**\n1. **ROW_A**: Number of rows in Matrix A. (Default=4)\n2. **COL_A**: Number of columns in Matrix A. (Default=4)\n3. **ROW_B**: Number of rows in Matrix B. (Default=4)\n4. **COL_B**: Number of columns in Matrix B. (Default=4)\n5. **INPUT_DATA_WIDTH**: Bit-width of the input matrix elements. (Default=8)\n6. **OUTPUT_DATA_WIDTH**: Bit-width of the output matrix elements, calculated as `(INPUT_DATA_WIDTH * 2) + $clog2(COL_A)`.\n\n### **Inputs and Outputs**\n- **Inputs**:\n  - `clk`: Clock signal (positive edge-triggered).\n  - `srst`: Active-high synchronous reset signal.\n  - `valid_in`: Active high signal, indicates that `matrix_a` and `matrix_b` contain valid inputs.\n  - `[(ROW_A*COL_A*INPUT_DATA_WIDTH)-1:0] matrix_a`: Flattened 1D representation of input Matrix A.\n  - `[(ROW_B*COL_B*INPUT_DATA_WIDTH)-1:0] matrix_b`: Flattened 1D representation of input Matrix B.\n- **Outputs**:\n  - `valid_out`: Active high signal, indicates that the output matrix `matrix_c` is valid.\n  - `[(ROW_A*COL_B*OUTPUT_DATA_WIDTH)-1:0] matrix_c`: Flattened 1D representation of the result Matrix C.\n\n### Example of Matrix Flattening:\n\nSuppose you have two input matrices A and B to multiply:\n\n- **Matrix A (2x3)**:\n\n```text\n| a11  a12  a13 |\n| a21  a22  a23 |\n```\n\n- **Matrix B (3x2)**:\n\n```text\n| b11  b12 |\n| b21  b22 |\n| b31  b32 |\n```\n\nThe resulting output matrix from the multiplication of the above matrices would be:\n\n- **Matrix C (2x2)**:\n\n```text\n| c11  c12 |\n| c21  c22 |\n```\n\nThe flattened representation of these matrices will be as follows:\n\n- **Flattened Matrix A (2x3)**:\n\n```text\nmatrix_a = {a23, a22, a21, a13, a12, a11}\n```\n\n- **Flattened Matrix B (3x2)**:\n\n```text\nmatrix_b = {b32, b31, b22, b21, b12, b11}\n```\n\n- **Flattened Matrix C (2x2)**:\n\n```text\nmatrix_c = {c22, c21, c12, c11}\n```\n\n- **Note** : The design enables the processing of a new input set (matrix_a, matrix_b, and valid_in) in every clock cycle while maintaining a latency of $clog2(COL_A) + 2 clock cycles from valid_in to valid_out.\n---\n\n### Testbench Requirements\n\n#### Instantiation\n\n- Instantiate the `matrix_multiplier` module as `matrix_multiplier_inst`, connecting all input and output signals.\n- Support configurable matrix sizes using defines:\n  - **`MATRIX_MULT_2x2`**: Sets `ROW_A = 2`, `COL_A = 2`, `ROW_B = 2`, `COL_B = 2`.\n  - **`MATRIX_MULT_3x3`**: Sets `ROW_A = 3`, `COL_A = 3`, `ROW_B = 3`, `COL_B = 3`.\n  - **`NON_SQUARE_MATRIX_MULT`**: Sets `ROW_A = 2`, `COL_A = 3`, `ROW_B = 3`, `COL_B = 2`.\n  - **`MATRIX_MULT_1x1`**: Sets `ROW_A = 1`, `COL_A = 1`, `ROW_B = 1`, `COL_B = 1`.\n  - **Default Configuration**: If no define is enabled, use `ROW_A = 4`, `COL_A = 4`, `ROW_B = 4`, `COL_B = 4`.\n\n---\n\n### **Stimulus Generation**\n1. **Randomized Inputs**:\n   - Generate random values for `matrix_a` and `matrix_b` based on their respective dimensions (`ROW_A x COL_A` for Matrix A and `ROW_B x COL_B` for Matrix B).\n   - Randomly toggle the `valid_in` signal to mimic varying input availability.\n\n2. **Control Signals**:\n   - Assert `srst` at the start of the simulation to reset the pipeline and output.\n   - Randomly toggle `valid_in` during operation to simulate intermittent valid input availability.\n\n3. **Continuous Stimulus**:\n   - Continuously provide randomized `matrix_a` and `matrix_b` inputs for the duration of the simulation to ensure complete coverage of the RTL.", "context": {}}, "output": {"response": "", "context": {"verif/tb_matrix_multiplier.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 56f99b2422ec76b41bd1663f641a7b97399bc84b\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/matrix_multiplier.sv": "module matrix_multiplier #(\n  parameter ROW_A             = 4                                                   , // Number of rows in matrix A\n  parameter COL_A             = 4                                                   , // Number of columns in matrix A\n  parameter ROW_B             = 4                                                   , // Number of rows in matrix B\n  parameter COL_B             = 4                                                   , // Number of columns in matrix B\n  parameter INPUT_DATA_WIDTH  = 8                                                   , // Bit-width of input data\n  parameter OUTPUT_DATA_WIDTH = (INPUT_DATA_WIDTH * 2) + $clog2(COL_A)                // Bit-width of output data\n) (\n  input  logic                                       clk      , // Clock input\n  input  logic                                       srst     , // Active-high Synchronous reset\n  input  logic                                       valid_in , // Indicates valid input matrices\n  input  logic [ (ROW_A*COL_A*INPUT_DATA_WIDTH)-1:0] matrix_a , // Input matrix A in 1D form\n  input  logic [ (ROW_B*COL_B*INPUT_DATA_WIDTH)-1:0] matrix_b , // Input matrix B in 1D form\n  output logic                                       valid_out, // Indicates valid output matrix\n  output logic [(ROW_A*COL_B*OUTPUT_DATA_WIDTH)-1:0] matrix_c   // Output matrix C in 1D form\n);\n\n\n  localparam MODIFIED_COL_A      = 1<<($clog2(COL_A));\n  localparam HALF_MODIFIED_COL_A = MODIFIED_COL_A/2  ;\n\n  generate\n    logic [                                             $clog2(COL_A):0] valid_out_reg;\n    logic [     (ROW_A*COL_B*MODIFIED_COL_A*(INPUT_DATA_WIDTH * 2))-1:0] mult_stage   ;\n\n    always_ff @(posedge clk)\n      if (srst)\n        {valid_out, valid_out_reg} <= '0;\n      else\n        {valid_out, valid_out_reg} <= {valid_out_reg, valid_in}; \n\n    always_ff @(posedge clk)\n      for (int i = 0 ; i < ROW_A ; i++) begin: mult_row_a_gb\n        for (int j = 0 ; j < COL_B ; j++) begin: mult_col_b_gb\n          for (int k = 0 ; k < MODIFIED_COL_A ; k++) begin: mult_gb\n              if (srst)\n                mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+k)*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)] <= '0; \n              else\n                mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+k)*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)] <=  (k < COL_A) ? matrix_a[((i*COL_A)+k)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH] * matrix_b[((k*COL_B)+j)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH] : '0; \n          end\n        end\n      end\n\n    if (HALF_MODIFIED_COL_A > 0) begin\n      logic [($clog2(COL_A)*ROW_A*COL_B*HALF_MODIFIED_COL_A*OUTPUT_DATA_WIDTH)-1:0] add_stage    ; \n      always_ff @(posedge clk)\n        for (int i = 0 ; i < ROW_A ; i++) begin: accum_row_a_gb\n          for (int j = 0 ; j < COL_B ; j++) begin: accum_col_b_gb\n            for (int k = 0 ; k < HALF_MODIFIED_COL_A ; k++) begin: accum_gb\n              for (int l = 0 ; l < $clog2(COL_A) ; l++) begin: pipe_gb\n                if (l == 0) begin\n                  if (srst)\n                    add_stage[((0*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+k))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0; \n                  else if (valid_out_reg[0])\n                    add_stage[((0*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+k))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+(2*k))*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)] + mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+((2*k)+1))*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)];\n                end\n                else begin\n                  if (srst)\n                    add_stage[((l*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+k))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0; \n                  else if ((HALF_MODIFIED_COL_A > 1) && (k < (HALF_MODIFIED_COL_A/2)))\n                    add_stage[((l*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+k))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= add_stage[(((l-1)*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+(2*k)))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] + add_stage[(((l-1)*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+((2*k)+1)))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH];\n                end\n              end\n            end\n          end\n        end\n\n      always_ff @(posedge clk)\n        for (int i = 0 ; i < ROW_A ; i++) begin: out_row_a_gb\n          for (int j = 0 ; j < COL_B ; j++) begin: out_col_b_gb\n            for (int k = 0 ; k < MODIFIED_COL_A ; k++) begin: out_add_gb\n              if (srst)\n                matrix_c[((i*COL_B)+j)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0;\n              else if (valid_out_reg[$clog2(COL_A)])\n                matrix_c[((i*COL_B)+j)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= add_stage[((($clog2(COL_A)-1)*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+0))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH]; \n            end\n          end\n        end\n    end\n    else begin\n      always_ff @(posedge clk)\n        for (int i = 0 ; i < ROW_A ; i++) begin: out_row_a_gb\n          for (int j = 0 ; j < COL_B ; j++) begin: out_col_b_gb\n            for (int k = 0 ; k < MODIFIED_COL_A ; k++) begin: out_mult_gb\n              if (srst)\n                matrix_c[((i*COL_B)+j)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0;\n              else if (valid_out_reg[$clog2(COL_A)])\n                matrix_c[((i*COL_B)+j)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+0)*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)]; \n            end\n          end\n        end\n    end\n\n  endgenerate\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Simulation didn't run correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage merge didn't run correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    try:\n        with open(\"/code/rundir/coverage.log\") as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage.log file.\")\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    print(\"Parsed Metrics:\")\n    print(metrics)\n\n    # Ensure TARGET environment variable is set\n    target = os.getenv(\"TARGET\")\n    if not target:\n        raise ValueError(\"TARGET environment variable is not set.\")\n    target = float(target)\n\n    # Check coverage for the DUT or specific key\n    dut = \"matrix_multiplier_inst\"  # Replace this with the DUT key you want to check\n    if dut in metrics and \"Overall Average\" in metrics[dut]:\n        assert float(metrics[dut][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        # Log available keys for debugging\n        print(f\"Available keys in metrics: {metrics.keys()}\")\n        assert False, f\"Coverage data for '{dut}' is not available.\""}}}
{"id": "cvdp_copilot_matrix_multiplier_0035", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the given SystemVerilog testbench to add a **checker** to validate the output of a **matrix multiplier module** `matrix_multiplier`, which performs matrix multiplication for configurable dimensions. The **stimulus already is provided** in the given testbench, and the checker should be added to verify that the **DUT (Design Under Test)** correctly computes the output matrix based on matrix multiplication rules.\n\n---\n\n## **Design Details**\n\n### **1. Parameterization**\n- **ROW_A**: Number of rows in Matrix A (default: 2).  \n- **COL_A**: Number of columns in Matrix A (default: 3).  \n- **ROW_B**: Number of rows in Matrix B (default: 3).  \n- **COL_B**: Number of columns in Matrix B (default: 2).  \n- **INPUT_DATA_WIDTH**: Bit-width of the input matrix elements (default: 8).  \n- **OUTPUT_DATA_WIDTH**: Bit-width of the output matrix elements, computed as `(INPUT_DATA_WIDTH * 2) + $clog2(COL_A)`.  \n\n### **2. Functional Behavior**\n1. **Matrix Multiplication**:  \n   - The module computes the output matrix `matrix_c` as `matrix_c = matrix_a * matrix_b`.  \n   - The final result is stored in `matrix_c` as a **flattened 1D array**.\n\n2. **Continuous Input Processing**:  \n   - The design supports **continuous input processing** without waiting for prior computations to complete.  \n   - New values for `matrix_a` and `matrix_b` can be applied **on every cycle** when `valid_in` is asserted.  \n\n3. **Latency**:  \n   - The valid output (`valid_out`) is asserted **after `log2(COL_A) + 2` cycles** from a valid input (`valid_in`).  \n\n4. **Control Signal Behavior**:  \n   - **Reset (`srst`)**: Clears all registers and resets output to zero.  \n   - **Input Valid (`valid_in`)**: Indicates that `matrix_a` and `matrix_b` contain valid input data.  \n   - **Output Valid (`valid_out`)**: Indicates when `matrix_c` contains valid output data.  \n\n---\n\n## **3. Inputs and Outputs**\n- **Inputs**:\n  - `clk`: Clock signal.  \n  - `srst`: Synchronous reset (active high).  \n  - `valid_in`: Active-high signal indicating valid input.  \n  - `matrix_a`: Flattened 1D representation of input Matrix A.  \n  - `matrix_b`: Flattened 1D representation of input Matrix B.  \n\n- **Outputs**:\n  - `valid_out`: Active-high signal indicating valid output.  \n  - `matrix_c`: Flattened 1D representation of the result Matrix C.  \n\n## **4. Example of Matrix Flattening**\n\nSuppose you have two input matrices A and B to multiply:\n\n- **Matrix A (2x3)**:\n\n```text\n| a11  a12  a13 |\n| a21  a22  a23 |\n```\n\n- **Matrix B (3x2)**:\n\n```text\n| b11  b12 |\n| b21  b22 |\n| b31  b32 |\n```\n\nThe resulting output matrix from the multiplication of the above matrices would be:\n\n- **Matrix C (2x2)**:\n\n```text\n| c11  c12 |\n| c21  c22 |\n```\n\nThe flattened representation of these matrices will be as follows:\n\n- **Flattened Matrix A (2x3)**:\n\n```text\nmatrix_a = {a23, a22, a21, a13, a12, a11}\n```\n\n- **Flattened Matrix B (3x2)**:\n\n```text\nmatrix_b = {b32, b31, b22, b21, b12, b11}\n```\n\n- **Flattened Matrix C (2x2)**:\n\n```text\nmatrix_c = {c22, c21, c12, c11}\n```\n\n---\n\n## **Testbench Requirements**\n\n### **1. Instantiation**\n- `matrix_multiplier` is already instantiated as `matrix_multiplier_inst`, with all input and output signals connected.\n\n### **2. Clock Generation**\n- The testbench operates with a **500 MHz clock** (2 ns period). \n\n### **3. Testbench Components**\n\n#### **Parameters**\n- `ROW_A`, `COL_A`, `ROW_B`, `COL_B`: Define matrix dimensions.  \n- `INPUT_DATA_WIDTH`, `OUTPUT_DATA_WIDTH`: Define element sizes.  \n\n#### **Signals**\n- `clk`: Clock signal.  \n- `srst`: Synchronous reset.  \n- `valid_in`: Input valid signal.  \n- `matrix_a`: Input matrix A.  \n- `matrix_b`: Input matrix B.  \n- `valid_out`: Output valid signal.  \n- `matrix_c`: Output matrix C.  \n- `matrix_a_queue`: **Queue** storing input matrices A.  \n- `matrix_b_queue`: **Queue** storing input matrices B.  \n- `matrix_c_queue`: **Queue** storing output matrices C.  \n- `matrix_c_expected`: Expected output matrix for verification.  \n\n---\n\n## **4. Use of Queues and checker functionality**\n- **Queues enable continuous input processing without waiting for prior results.**  \n- This allows **new inputs to be applied every clock cycle**, while previous results are still in computation.  \n- The process works as follows:  \n  1. **When `valid_in` is asserted**, push `matrix_a` and `matrix_b` into `matrix_a_queue` and `matrix_b_queue`.  \n  2. **After `log2(COL_A) + 2` cycles**, when `valid_out` is asserted:  \n     - Pop the corresponding matrices from `matrix_a_queue` and `matrix_b_queue`.  \n     - Compute `matrix_c_expected` using standard matrix multiplication rules.  \n     - Compare `matrix_c_expected` with `matrix_c`.  \n  3. If a mismatch occurs, log an error using `$error`.  \n  4. Continue monitoring until all expected computations have been verified.  \n\n---\n\n## **5. Simulation Control**\n- Use `$display` statements to log test case execution.  \n- Print a message if all cases pass. Otherwise, report errors.  \n\n---\n\n## **Expected Deliverables**\n- **SystemVerilog checker** that uses the given stimulus and includes logic to verify the `matrix_multiplier` module\u2019s output against expected results.  ", "context": {"verif/tb_matrix_multiplier.sv": "module tb_matrix_multiplier ();\n  parameter ROW_A = 2;\n  parameter COL_A = 3;\n  parameter ROW_B = 3;\n  parameter COL_B = 2;\n  parameter INPUT_DATA_WIDTH  = 8                                   ;\n  parameter OUTPUT_DATA_WIDTH = (INPUT_DATA_WIDTH*2) + $clog2(COL_A);\n  parameter NUM_SAMPLES = 1000;\n  parameter FULL_THROUGHPUT = 1;\n\n  logic                                               clk                  = 0;\n  logic                                               srst                    ;\n  logic                                               valid_in                ;\n  logic [ROW_A-1:0][COL_A-1:0][ INPUT_DATA_WIDTH-1:0] matrix_a                ;\n  logic [ROW_B-1:0][COL_B-1:0][ INPUT_DATA_WIDTH-1:0] matrix_b                ;\n  logic                                               valid_out               ;\n  logic [ROW_A-1:0][COL_B-1:0][OUTPUT_DATA_WIDTH-1:0] matrix_c                ;\n  logic                                               give_input           = 0;\n  logic                                               give_input_reg          ;\n  logic [     31:0]                                   valid_in_cnt            ;\n\n  matrix_multiplier #(\n    .ROW_A           (ROW_A           ),\n    .COL_A           (COL_A           ),\n    .ROW_B           (ROW_B           ),\n    .COL_B           (COL_B           ),\n    .INPUT_DATA_WIDTH(INPUT_DATA_WIDTH)\n  ) matrix_multiplier_inst (\n    .clk      (clk      ),\n    .srst     (srst     ),\n    .valid_in (valid_in ),\n    .matrix_a (matrix_a ),\n    .matrix_b (matrix_b ),\n    .valid_out(valid_out),\n    .matrix_c (matrix_c ) \n  );\n\n  always\n    #1 clk = ~clk;\n\n  initial\n  begin\n    give_input = '0;\n    srst = 1'b0;\n    #10;\n    srst = 1'b1;\n    repeat(20) @(posedge clk);\n    srst = 1'b0;\n    repeat(20) @(posedge clk);\n\n    give_input = 1'b1;\n\n    $display(\"Applying Stimulus . . . .\");\n    wait(valid_in_cnt == NUM_SAMPLES)\n    give_input = 1'b0;\n\n    repeat($clog2(COL_A)+2) @(posedge clk);\n\n    $display(\"Stimulus has been applied!\");\n\n    repeat (20)@(posedge clk);\n\n    $finish;\n  end\n\n  always_ff @(posedge clk)\n    if (srst)\n      give_input_reg <= 1'b0;\n    else\n      give_input_reg <= give_input;\n\n  always_ff @(posedge clk)\n    if (srst)\n      valid_in_cnt <= '0;\n    else if (valid_in) begin\n      valid_in_cnt <= valid_in_cnt + 1;\n    end\n\n  always_ff @(posedge clk)\n    if (srst)\n      valid_in <= '0;\n    else if (give_input_reg && (valid_in_cnt != NUM_SAMPLES))\n      valid_in <= FULL_THROUGHPUT ? 1 : $urandom_range(0,1);\n    else\n      valid_in <= '0;\n\n  always_ff @(posedge clk)\n    if (srst)\n      matrix_a <= '0;\n    else if (give_input_reg)\n      matrix_a <= generate_random_matrix_a();\n\n  always_ff @(posedge clk)\n    if (srst)\n      matrix_b <= '0;\n    else if (give_input_reg)\n      matrix_b <= generate_random_matrix_b();\n\n  function automatic logic [(ROW_A * COL_A * INPUT_DATA_WIDTH)-1:0] generate_random_matrix_a();\n    logic [(ROW_A * COL_A * INPUT_DATA_WIDTH)-1:0] random_matrix;\n    begin\n      for (int index = 0; index < ROW_A * COL_A; index++) begin\n        random_matrix[index * INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] = $urandom_range((1 << INPUT_DATA_WIDTH) - 1, 0);\n      end\n      return random_matrix;\n    end\n  endfunction\n\n\n  function automatic logic [(ROW_B * COL_B * INPUT_DATA_WIDTH)-1:0] generate_random_matrix_b();\n    logic [(ROW_B * COL_B * INPUT_DATA_WIDTH)-1:0] random_matrix;\n    begin\n      for (int index = 0; index < ROW_B * COL_B; index++) begin\n        random_matrix[index * INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] = $urandom_range((1 << INPUT_DATA_WIDTH) - 1, 0);\n      end\n      return random_matrix;\n    end\n  endfunction\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_matrix_multiplier.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 35-tb-checker-generation-for-matrix-multiplier\nNUM_BUGS        = 3", "src/matrix_multiplier.sv": "module matrix_multiplier #(\n  parameter ROW_A             = 2                                                   , // Number of rows in matrix A\n  parameter COL_A             = 3                                                   , // Number of columns in matrix A\n  parameter ROW_B             = 3                                                   , // Number of rows in matrix B\n  parameter COL_B             = 2                                                   , // Number of columns in matrix B\n  parameter INPUT_DATA_WIDTH  = 8                                                   , // Bit-width of input data\n  parameter OUTPUT_DATA_WIDTH = (INPUT_DATA_WIDTH * 2) + $clog2(COL_A)                // Bit-width of output data\n) (\n  input  logic                                       clk      , // Clock input\n  input  logic                                       srst     , // Active-high Synchronous reset\n  input  logic                                       valid_in , // Indicates valid input matrices\n  input  logic [ (ROW_A*COL_A*INPUT_DATA_WIDTH)-1:0] matrix_a , // Input matrix A in 1D form\n  input  logic [ (ROW_B*COL_B*INPUT_DATA_WIDTH)-1:0] matrix_b , // Input matrix B in 1D form\n  output logic                                       valid_out, // Indicates valid output matrix\n  output logic [(ROW_A*COL_B*OUTPUT_DATA_WIDTH)-1:0] matrix_c   // Output matrix C in 1D form\n);\n\n\n  localparam MODIFIED_COL_A      = 1<<($clog2(COL_A));\n  localparam HALF_MODIFIED_COL_A = MODIFIED_COL_A/2  ;\n\n  generate\n    logic [                                             $clog2(COL_A):0] valid_out_reg;\n    logic [     (ROW_A*COL_B*MODIFIED_COL_A*(INPUT_DATA_WIDTH * 2))-1:0] mult_stage   ;\n\n    always_ff @(posedge clk)\n      if (srst)\n        {valid_out, valid_out_reg} <= '0;\n      else\n        {valid_out, valid_out_reg} <= {valid_out_reg, valid_in}; \n\n    always_ff @(posedge clk)\n      for (int i = 0 ; i < ROW_A ; i++) begin: mult_row_a_gb\n        for (int j = 0 ; j < COL_B ; j++) begin: mult_col_b_gb\n          for (int k = 0 ; k < MODIFIED_COL_A ; k++) begin: mult_gb\n              if (srst)\n                mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+k)*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)] <= '0; \n              else\n              `ifndef BUG_0\n                mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+k)*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)] <=  (k < COL_A) ? matrix_a[((i*COL_A)+k)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH] * matrix_b[((k*COL_B)+j)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH] : '0; \n              `else\n                mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+k)*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)] <=  (k < COL_A) ? matrix_a[((i*COL_A)+k)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH] * matrix_b[((k*COL_B)+j)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH] : '1; \n              `endif\n          end\n        end\n      end\n\n    if (HALF_MODIFIED_COL_A > 0) begin\n      logic [($clog2(COL_A)*ROW_A*COL_B*HALF_MODIFIED_COL_A*OUTPUT_DATA_WIDTH)-1:0] add_stage    ; \n      always_ff @(posedge clk)\n        for (int i = 0 ; i < ROW_A ; i++) begin: accum_row_a_gb\n          for (int j = 0 ; j < COL_B ; j++) begin: accum_col_b_gb\n            for (int k = 0 ; k < HALF_MODIFIED_COL_A ; k++) begin: accum_gb\n              for (int l = 0 ; l < $clog2(COL_A) ; l++) begin: pipe_gb\n                if (l == 0) begin\n                  if (srst)\n                    add_stage[((0*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+k))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0; \n                `ifndef BUG_1\n                  else if (valid_out_reg[0])\n                `else\n                  else if (valid_out)\n                `endif\n                    add_stage[((0*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+k))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+(2*k))*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)] + mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+((2*k)+1))*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)];\n                end\n                else begin\n                  if (srst)\n                    add_stage[((l*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+k))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0; \n                  else if ((HALF_MODIFIED_COL_A > 1) && (k < (HALF_MODIFIED_COL_A/2)))\n                    add_stage[((l*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+k))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= add_stage[(((l-1)*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+(2*k)))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] + add_stage[(((l-1)*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+((2*k)+1)))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH];\n                end\n              end\n            end\n          end\n        end\n\n      always_ff @(posedge clk)\n        for (int i = 0 ; i < ROW_A ; i++) begin: out_row_a_gb\n          for (int j = 0 ; j < COL_B ; j++) begin: out_col_b_gb\n            for (int k = 0 ; k < MODIFIED_COL_A ; k++) begin: out_add_gb\n              if (srst)\n                matrix_c[((i*COL_B)+j)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0;\n              else if (valid_out_reg[$clog2(COL_A)])\n              `ifndef BUG_2\n                matrix_c[((i*COL_B)+j)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= add_stage[((($clog2(COL_A)-1)*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+0))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH]; \n              `else\n                matrix_c[((i*COL_B))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= add_stage[((($clog2(COL_A)-1)*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+0))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH];\n              `endif\n            end\n          end\n        end\n    end\n    else begin\n      always_ff @(posedge clk)\n        for (int i = 0 ; i < ROW_A ; i++) begin: out_row_a_gb\n          for (int j = 0 ; j < COL_B ; j++) begin: out_col_b_gb\n            for (int k = 0 ; k < MODIFIED_COL_A ; k++) begin: out_mult_gb\n              if (srst)\n                matrix_c[((i*COL_B)+j)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0;\n              else if (valid_out_reg[$clog2(COL_A)])\n              `ifndef BUG_2\n                matrix_c[((i*COL_B)+j)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+0)*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)]; \n              `else\n                matrix_c[((i*COL_B))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+0)*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)];\n              `endif\n            end\n          end\n        end\n    end\n\n  endgenerate\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_mem_allocator_0006", "categories": ["cid014", "medium"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `cvdp_copilot_mem_allocator` module. The assertions should ensure that the module dynamically manages a pool of resources, enabling the acquisition and release of resource slots. The design uses a bitmask (free_slots) to track the availability of resource slots. The module uses the provided cvdp_leading_zero_cnt to track the first available slot (starting from the least significant bit) and provides signals indicating whether the allocator is empty or full.\n\n## **RTL Design Overview**  \n\n### Parameters:\n- `SIZE` (default: 4): Specifies the total number of resource slots managed by the allocator. It must be a positive integer and a multiple of 4.\n-  `ADDRW`: Specifies the bit width of the address required to index all slots. Computed as ceil(log2(SIZE)).\n\n### Inputs:\n   - `clk`: System clock signal. The design is synchronized to the positive edge of this clock\n   - `reset`: Active-high synchronous reset signal.\n   - `acquire_en`: Active-high enable signal for a resource allocation request.\n   - `release_en`: Active-high enable signal for a resource deallocation request.\n   - `release_addr[ADDRW-1:0]`: Address of the slot to be released.\n\n### Outputs:\n   - `acquire_addr[ADDRW-1:0]`: Represents the address of the next available resource slot for allocation. It will be 0 after if the reset is high and index of the least significant free slot after that. The value is invalid (left undefined) when `full` is asserted.\n   - `empty`: High if all slots are free, low otherwise.\n   - `full`: High if no slots are available, low otherwise.\n\n### Behavior\n\n####  `cvdp_leading_zero_cnt` module functionality:\n`cvdp_leading_zero_cnt` module calculates the number of trailing zeros in a given `DATA_WIDTH`-bit input. It computes the total trailing zero count. `all_zeros` is high whenever input data is zero.\n\n#### Reset Behavior\n- On reset, when reset is asserted\n    - All slots are marked as free (free_slots initialized to all 1s).\n    - acquire_addr is set to 0.(indicating first available slot when requested)\n    - empty is set to 1 (all slots are free).\n    - full is set to 0 (slots are not fully occupied).\n\n#### Resource Allocation and Release\n- The first available address, (if all slots are not allocated), is always available on `acquire_addr` output signal. (If all slots are allocated, leave `acquire_addr` undefined)\n- When `acquire_en` is asserted:\n    - The slot specified by `acquire_addr` in `free_slots_n` is cleared **combinationally**.\n- When `release_en` is asserted:\n    - The slot specified by `release_addr` is marked as free in `free_slots_n` **combinationally**.\n- `free_slots_n` is registered on the posedge of `clk` in `free_slots` register **sequentially** to mark the slot as allocated or released.\n- The module **precomputes** the first available slot. Leading zero counter module initialized with correct parameters, **combinationally** updates `free_index` using the updated `free_slots_n`. \n- The `acquire_addr` output is **updated in the next clock cycle**, registering `free_index`, to ensure the address is ready and maintained for the **next acquire request**.\n\n#### Empty and Full Signals\n- `empty` is asserted high when all slots are free. Updated **sequentially** after `release_en` asserted for the last allocated slot.\n- `full` is asserted high when no slots are available for allocation. Updated **sequentially** after an acquire request allocates the last available slot.\n\n### Interface Constraints and Assumptions:\n- The `release_en` signal will only be asserted for addresses that were previously allocated. \n- If the `full` signal is asserted high, indicating no available slots, `acquire_en` will not be asserted.\n\n## Assertion Details\n\n- **Size Alignment:**  \n  Verify that the `SIZE` parameter is a multiple of four.\n\n- **Release Operations:**  \n  - Ensure that a release request does not target an empty slot.\n  - Confirm that after a release request, the `free_slots` array is updated for the given `release_addr`.\n  - Ensure that when `release_en` is asserted, the system is not in an empty state.\n\n- **Acquisition Operations:**  \n  - Verify that when `acquire_en` is asserted, on the following cycle the address stored in `acquire_addr_r` is updated in the `free_slots` array to indicate acquisition.\n  - Ensure that when `acquire_en` is high, the system is not in a full state.\n \n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/cvdp_copilot_mem_allocator.sv": "module cvdp_copilot_mem_allocator #(\n    parameter SIZE  = 4,\n    parameter ADDRW = $clog2(SIZE)\n) (\n    input  wire             clk,\n    input  wire             reset,\n\n    input  wire             acquire_en,    \n    output wire [ADDRW-1:0] acquire_addr,      \n    \n    input  wire             release_en,\n    input  wire [ADDRW-1:0] release_addr,    \n    \n    output wire             empty,\n    output wire             full    \n);\n    reg [SIZE-1:0] free_slots, free_slots_n;\n    reg [ADDRW-1:0] acquire_addr_r;\n    reg empty_r, full_r;    \n    wire [ADDRW-1:0] free_index;\n    wire full_d;\n    \n    /* Leading zero counter instantiation */\n    cvdp_leading_zero_cnt #(\n            .DATA_WIDTH (SIZE),\n            .REVERSE (1)\n        ) free_slots_sel (\n            .data   (free_slots_n),\n            .leading_zeros  (free_index),\n            .all_zeros (full_d)\n        ); \n    \n    always @(*) begin\n        free_slots_n = free_slots;\n        if (release_en) begin\n            free_slots_n[release_addr] = 1;                \n        end\n        if (acquire_en) begin\n            free_slots_n[acquire_addr_r] = 0;\n        end            \n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            acquire_addr_r <= 0;\n            free_slots     <= {SIZE{1'b1}};\n            empty_r        <= 1'b1;\n            full_r         <= 1'b0;            \n        end else begin\n            acquire_addr_r  <= free_index;\n            free_slots      <= free_slots_n;           \n            empty_r         <= (& free_slots_n);\n            full_r          <= full_d;\n        end        \n    end\n        \n    assign acquire_addr = acquire_addr_r;\n    assign empty        = empty_r;\n    assign full         = full_r;\n    \nendmodule\n\nmodule cvdp_leading_zero_cnt #(\n    parameter DATA_WIDTH = 32,\n    parameter REVERSE = 0 \n)(\n    input  [DATA_WIDTH -1:0] data,\n    output  [$clog2(DATA_WIDTH)-1:0] leading_zeros,\n    output all_zeros \n);\n    localparam NIBBLES_NUM = DATA_WIDTH/4 ; \n    reg [NIBBLES_NUM-1 :0] all_zeros_flag ;\n    reg [1:0]  zeros_cnt_per_nibble [NIBBLES_NUM-1 :0]  ;\n\n    genvar i;\n    integer k ;\n    // Assign data/nibble \n    reg [3:0]  data_per_nibble [NIBBLES_NUM-1 :0]  ;\n    generate\n        for (i=0; i < NIBBLES_NUM ; i=i+1) begin\n            always @* begin\n                data_per_nibble[i] = data[(i*4)+3: (i*4)] ;\n            end\n        end\n    endgenerate\n   \n    generate\n        for (i=0; i < NIBBLES_NUM ; i=i+1) begin\n            if (REVERSE) begin\n                always @* begin\n                        zeros_cnt_per_nibble[i] [1] = ~(data_per_nibble[i][1] | data_per_nibble[i][0]); \n                        zeros_cnt_per_nibble[i] [0] = (~data_per_nibble[i][0]) &\n                                                      ((~data_per_nibble[i][2]) | data_per_nibble[i][1]);\n                        all_zeros_flag[i] = (data_per_nibble[i] == 4'b0000);\n                end\n            end else begin\n                always @* begin\n                    zeros_cnt_per_nibble[NIBBLES_NUM-1-i][1] = ~(data_per_nibble[i][3] | data_per_nibble[i][2]); \n                    zeros_cnt_per_nibble[NIBBLES_NUM-1-i][0] = (~data_per_nibble[i][3]) &\n                                     ((~data_per_nibble[i][1]) | data_per_nibble[i][2]);\n                    \n                    all_zeros_flag[NIBBLES_NUM-1-i] = (data_per_nibble[i] == 4'b0000);\n                end\n            end\n        end\n    endgenerate\n\n    \n    \n    reg [$clog2(NIBBLES_NUM)-1:0] index ; \n    reg [1:0]    choosen_nibbles_zeros_count ;\n    reg [ $clog2(NIBBLES_NUM*4)-1:0] zeros_count_result ;\n    wire [NIBBLES_NUM-1:0]         all_zeros_flag_decoded;\n    \n    assign all_zeros_flag_decoded[0] = all_zeros_flag[0] ;\n    genvar j;\n        generate\n            for (j=1; j < NIBBLES_NUM; j=j+1) begin\n                assign all_zeros_flag_decoded[j] = all_zeros_flag_decoded[j-1] & all_zeros_flag[j];\n            end\n        endgenerate\n\n    always@ * begin\n        index = 0 ;\n        for ( k =0 ; k< NIBBLES_NUM ; k =k +1) begin\n            index = index + all_zeros_flag_decoded[k] ;\n        end\n    end\n    \n    always@* begin\n        choosen_nibbles_zeros_count = zeros_cnt_per_nibble[index]  ;  \n        zeros_count_result = choosen_nibbles_zeros_count + (index <<2) ; \n    end\n    \n    assign leading_zeros =  zeros_count_result ;\n    assign all_zeros = (data ==0) ;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/cvdp_copilot_mem_allocator.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nSIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cvdp_copilot_mem_allocator.sv\nTOPLEVEL        = cvdp_copilot_mem_allocator\nMODULE          = test_cvdp_copilot_mem_allocator\nPYTHONPATH      = /src\nHASH            = \"feature/assertions\"\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport os\nimport subprocess\nimport re\n\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def reset_dut(reset, duration_ns = 10):\n    # Restart Interface\n    reset.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    reset.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    reset.value = 0\n    await Timer(duration_ns, units='ns')\n    reset._log.debug(\"Reset complete\")\n\n\n    \n#################    ASSERTIONS STUFF        ###############\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n", "src/test_cvdp_copilot_mem_allocator.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport time\nimport harness_library as hrs_lb\n\n\n\n@cocotb.test()\nasync def test_cvdp_copilot_mem_allocator(dut): \n   # Start clock\n   dut_clock_period = 10 \n   print(f\"Clk period is {dut_clock_period}\")\n   DUT_CLK = Clock(dut.clk, dut_clock_period, 'ns')\n   await cocotb.start(DUT_CLK.start())\n   dut.clk._log.info(f\"clk STARTED\")\n\n   await hrs_lb.dut_init(dut)\n\n   # Apply reset \n   await hrs_lb.reset_dut(dut.reset, dut_clock_period)\n\n   for i in range(2):\n      await RisingEdge(dut.clk)\n\n   # Ensure  outputs reset value \n   assert dut.acquire_addr.value == 0, f\"acquire_addr is not zero after reset: {dut.acquire_addr.value}\"\n   assert dut.empty.value == 1, f\"\u064fempty should be asserted: {dut.empty.value}\"\n   assert dut.full.value == 0, f\"full should be low: {dut.full.value}\"\n\n   # Get parameter values from top module\n   SIZE = int(dut.SIZE.value)\n   #ADDRW = int(dut.ADDRW.value)\n\n   #1. Testing Sequential Full condition: Setting acquire request for SIZE cycles After reset (empty) should result in Full assertion\n   await FallingEdge(dut.clk)\n   dut.acquire_en.value = 1\n   cycles_to_full = 0\n   while (dut.full.value != 1):\n      await RisingEdge(dut.clk)\n      cycles_to_full = cycles_to_full + 1\n      await FallingEdge(dut.clk)\n   dut.acquire_en.value = 0\n   assert cycles_to_full == SIZE, f\"full should be asserted. Asserted after: {cycles_to_full}, Expected: {SIZE}\"\n\n   await hrs_lb.reset_dut(dut.reset, dut_clock_period)  \n\n   #2. Randomly verify Allocation address/Dellocation\n   mask_list = [0 for _ in range(SIZE)]  # Keep track of allocated slots\n   addr_list = []  # Store allocated addresses for potential deallocation\n   allocate_index = 0 # First address available for allocation is 0x0\n   await FallingEdge(dut.clk)\n   \n   actions = [0, 1, 2]  # 0: No action, 1: Allocate, 2: Deallocate\n   \n   weights = [1, 3, 1]  # Higher weight for allocation (1: Allocate) #Tends to be full\n   for i in range(5 * SIZE):\n      dut.acquire_en.value = 0\n      dut.release_en.value = 0\n\n      action = random.choices(actions, weights=weights, k=1)[0]\n      #action = random.randint(0, 2)  # 0: No action, 1: Allocate, 2: Deallocate\n      \n      if action == 0:\n         pass\n\n      elif action == 1:  # Allocate\n         if 0 in mask_list: #Empty slot\n            dut.acquire_en.value = 1\n            mask_list[allocate_index] = 1  \n            addr_list.append(allocate_index)\n            # If not, next cycle full will be examined\n            if 0 in mask_list:\n               allocate_index = mask_list.index(0)         \n         else:\n            assert dut.full.value == 1, f\"Full should be asserted when there are no empty slots\"\n\n      elif action == 2:  # Deallocate\n         if addr_list:  # Only attempt deallocation if there are allocated addresses\n            deallocate_index = random.choice(addr_list)  # Randomly choose an allocated address\n            dut.release_en.value = 1\n            dut.release_addr.value = deallocate_index\n            mask_list[deallocate_index] = 0  # Mark the index as free\n            addr_list.remove(deallocate_index)  # Remove from allocated list\n            allocate_index = mask_list.index(0)\n         else:\n            assert dut.empty.value == 1, f\"Empty should be asserted when there are no thing allocated\"\n\n      await RisingEdge(dut.clk)\n      await FallingEdge(dut.clk)\n      # Assert acquire address in case full is deasserted only.\n      if (dut.full.value != 1):\n         assert int(dut.acquire_addr.value) == allocate_index, f\"acquire_addr mismatch Expected: {allocate_index} , dut_output: {int(dut.acquire_addr.value)} \"\n\n   weights = [1, 1, 3]  # Higher weight for deallocation (2: Deallocate) #Tends to be empty\n   for i in range(5 * SIZE):\n      dut.acquire_en.value = 0\n      dut.release_en.value = 0\n\n      action = random.choices(actions, weights=weights, k=1)[0]\n      #action = random.randint(0, 2)  # 0: No action, 1: Allocate, 2: Deallocate\n      \n      if action == 0:\n         pass\n\n      elif action == 1:  # Allocate\n         if 0 in mask_list: #Empty slot\n            dut.acquire_en.value = 1\n            mask_list[allocate_index] = 1  \n            addr_list.append(allocate_index)\n            # If not, next cycle full will be examined\n            if 0 in mask_list:\n               allocate_index = mask_list.index(0)         \n         else:\n            assert dut.full.value == 1, f\"Full should be asserted when there are no empty slots\"\n\n      elif action == 2:  # Deallocate\n         if addr_list:  # Only attempt deallocation if there are allocated addresses\n            deallocate_index = random.choice(addr_list)  # Randomly choose an allocated address\n            dut.release_en.value = 1\n            dut.release_addr.value = deallocate_index\n            mask_list[deallocate_index] = 0  # Mark the index as free\n            addr_list.remove(deallocate_index)  # Remove from allocated list\n            allocate_index = mask_list.index(0)\n         else:\n            assert dut.empty.value == 1, f\"Empty should be asserted when there are no thing allocated\"\n\n      await RisingEdge(dut.clk)\n      await FallingEdge(dut.clk)\n      # Assert acquire address in case full is deasserted only.\n      if (dut.full.value != 1):\n         assert int(dut.acquire_addr.value) == allocate_index, f\"acquire_addr mismatch Expected: {allocate_index} , dut_output: {int(dut.acquire_addr.value)} \"\n\n\n\n\n", "src/test_runner.py": "import os\n\nfrom cocotb.runner import get_runner\n\nimport harness_library as hrs_lb\nimport pytest\nimport random\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(SIZE):\n    print(\"Inside Runner\")\n    print(SIZE)\n    runner = get_runner(\"xcelium\")\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters={'SIZE': SIZE},\n        build_args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\"),\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=False,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    print(\"Running\")    \n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n    hrs_lb.coverage_report(\"assertion\")\n    hrs_lb.covt_report_check()\n# random test \ntest_param = [(random.randint(1, 32) * 4) for _ in range(5)]\n\n@pytest.mark.parametrize('SIZE', test_param )\ndef test_allocator(SIZE):\n    print(\"Calling Runner\")\n    runner(SIZE)\n"}}}
{"id": "cvdp_copilot_microcode_sequencer_0026", "categories": ["cid014", "medium"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the microcode sequencer (`microcode_sequencer`) to ensure its correct functionality during simulation? The assertions should cover various key aspects of the microcode sequencer's operations such as preventing push operation when the stack is full, ensuring data output is zero when a soft reset from the `instruction_decoder` submodule is asserted LOGIC HIGH, ensuring output carry of program incrementer is zero irrespective of its input carry, etc. These assertions should fail when any one of the following conditions fails:\n\n1. **stack_push_prevent_full** :\n      - Ensures that a push operation of the `lifo_stack` submodule is not attempted when the stack is full.\n2. **reset_data_output_to_zero**:\n      - Verifies that the data output (`d_out`) is reset to 4'b0000 when the reset signal (`rst_w`) from the `instruction_decoder` submodule is asserted LOGIC HIGH.\n3. **carry_out_zero_when_input_zero** :\n      - Checks that the `c_inc_out`  of the `program_counter` submodule is 0 when its `c_inc_in` is 0 or 1.\n4. **output_enable_zero_when_cc_zero** :\n      - Ensures the output enable signal of the  (`out_ce_w`) `result_register` submodule is 0 when the condition code (`cc`) is 0.\n5. **stack_mux_select_for_instr_01110** :\n      - Verifies that `stack_mux_sel_w` of the `stack_pointer` submodule is set to 1 when `ien` is 0 and `instr_in` is `5'b01110`.\n6. **a_mux_select_for_instr_opcodes** :\n      - Validates that `a_mux_sel_w` of `microcode_arithmetic` submodule is set to 2'b10 when `ien` is 0 and` instr_in` matches one of the specified opcodes(`instr_in == 5'b01110` || `instr_in == 5'b01011` || `instr_in == 5'b00001` || `instr_in == 5'b00000`).\n7. **auxiliary_register_mux_select_zero_when_cc_zero**:\n      - Ensures that the `rsel_w` of the `microcode_arithmetic` submodule is 0 when condition code (`cc`) is 0.\n8. **b_mux_select_for_instr_opcodes**:\n      - Verifies that `b_mux_sel_w`  of `microcode_arithmetic` submodule is set to 2'b10 when `ien` is 0 and `instr_in` matches one of the specified opcodes(`instr_in == 5'b00000` || `instr_in == 5'b00010` || `instr_in == 5'b00011`).\n9. **valid_aux_register_chip_enable**:\n     - Ensures that the auxiliary register chip enable (`rce_w`)  of the `microcode_arithmetic` submodule is either 0 or 1.\n10. **valid_stack_write_enable**:\n     - Verifies that the stack write enable signal (`stack_we_w`) of the `lifo_stack` submodule is either 0 or 1.\n\nFollowing should be the interface of the RTL design of the microcode_sequencer module named `microcode_sequencer`.\n## Interface:\n### Inputs:\n- `clk`(1-bit): The positive edge-triggered clock signal required for the sequential components.\n- `c_n_in`(1-bit): Carry-in signal for the ripple carry adder.\n- `c_inc_in`(1-bit): Carry-in for the program counter incrementer.\n- `r_en`(1-bit): ACTIVE LOW auxiliary register enable signal.\n- `cc`(1-bit): ACTIVE LOW condition code input for instruction decoding.\n- `ien`(1-bit): ACTIVE LOW instruction enable signal.\n- `d_in`(4-bit , [3:0]): A 4-bit data input bus.\n- `instr_in`(5-bit, [4:0]): A 5-bit opcode representing the instruction.\n- `oen`(1-bit): ACTIVE LOW output enable for the data output path.\n\n### Outputs:\n- `d_out`(4-bit,[3:0]): A 4-bit address output bus.\n- `c_n_out`(1-bit): Carry-out signal from the ripple carry adder. LOGIC HIGH in this signal indicates the presence of carry.\n- `c_inc_out`(1-bit): Carry-out signal from the program counter incremented. LOGIC HIGH in this signal indicates the presence of carry.\n- `full`(1-bit): ACTIVE HIGH signal indicates if the Last In First Out (LIFO) stack is full.\n- `empty`(1-bit): ACTIVE HIGH signal indicates if the LIFO stack is empty.", "context": {"rtl/microcode_sequencer.sv": "module microcode_sequencer (\n   // Inputs\n   input logic clk, // Input Clock\n   input logic c_n_in,  // Input Carry for Ripple Carry Adder\n   input logic c_inc_in, // Input Carry for Program Counter Incrementer\n   input logic r_en, // Auxiliary Register enable\n   input logic cc, // Condition Code\n   input logic ien, // Instruction Enable\n   input logic [3:0] d_in, // Data Input\n   input logic [4:0] instr_in, // 5-bit Instruction Opcode\n   input logic oen, // Output Enable\n\n   // Outputs\n   output logic [3:0] d_out, // Data Output\n   output logic c_n_out , // Output Carry from Ripple Carry Adder\n   output logic c_inc_out, // Output Carry from Program Counter Incrementer\n   output logic full, // Stack Full Condition\n   output logic empty // Stack Empty Condition\n   \n );\n\n \n logic [3:0] pc_data_w;\n logic stack_reset_w;\n logic [3:0] stack_data_w;\n logic [3:0] fa_out_w;\n logic [3:0] data_out_w;\n  \n logic rsel_w;\n logic rce_w;\n logic [1:0] a_mux_sel_w;\n logic [1:0] b_mux_sel_w;\n logic cen_w;\n logic rst_w;\n logic push_w;\n logic pop_w;\n logic stack_push_w;\n logic stack_pop_w;\n logic pc_mux_sel_w;\n logic stack_mux_sel_w;\n logic stack_we_w;\n logic stack_re_w;\n logic inc_w;\n logic oen_w;\n logic out_en_w;\n \n lifo_stack dut_1 (\n    .clk              (clk),\n    .stack_data_1_in  (d_in),\n    .stack_data_2_in  (pc_data_w),\n    .stack_reset      (rst_w),\n    .stack_push       (stack_push_w),\n    .stack_pop        (stack_pop_w),\n    .stack_mux_sel    (stack_mux_sel_w),\n    .stack_we         (stack_we_w),\n    .stack_re         (stack_re_w),\n    .stack_data_out   (stack_data_w),\n    .full_o           (full),\n    .empty_o          (empty)\n );\n\n program_counter dut_2 (\n    .clk               (clk),\n    .full_adder_data_i (fa_out_w),\n    .pc_c_in           (c_inc_in),\n    .inc               (inc_w),\n    .pc_mux_sel        (pc_mux_sel_w),\n    .pc_out            (pc_data_w),\n    .pc_c_out          (c_inc_out)\n );\n \n microcode_arithmetic dut_3(\n    .clk              (clk),\n    .fa_in            (data_out_w),\n    .d_in             (d_in),\n    .stack_data_in    (stack_data_w),\n    .pc_data_in       (pc_data_w),\n    .reg_en           (r_en),\n    .oen              (oen_w),\n    .rsel             (rsel_w),\n    .rce              (rce_w),\n    .cen              (cen_w),\n    .a_mux_sel        (a_mux_sel_w),\n    .b_mux_sel        (b_mux_sel_w),\n    .arith_cin        (c_n_in),\n    .arith_cout       (c_n_out),\n    .oe               (oen),\n    .d_out            (fa_out_w)\n );\n \n instruction_decoder dut_4 (\n    .instr_in         (instr_in),\n    .cc_in            (cc),\n    .instr_en         (ien),\n    .cen              (cen_w), \n    .rst              (rst_w), \n    .oen              (oen_w), \n    .inc              (inc_w), \n    .rsel             (rsel_w), \n    .rce              (rce_w),  \n    .pc_mux_sel       (pc_mux_sel_w), \n    .a_mux_sel        (a_mux_sel_w), \n    .b_mux_sel        (b_mux_sel_w), \n    .push             (stack_push_w),\n    .pop              (stack_pop_w), \n    .src_sel          (stack_mux_sel_w),\n    .stack_we         (stack_we_w),\n    .stack_re         (stack_re_w),\n    .out_ce           (out_ce_w)\n);\n\n result_register dut_5 (\n   .clk     (clk),\n   .data_in (fa_out_w),\n   .out_ce  (out_ce_w),\n   .data_out(data_out_w)\n );\nassign d_out = fa_out_w;\nendmodule\n \nmodule stack_pointer (\n  input logic clk,\n  input logic rst,\n  input logic push,\n  input logic pop,\n  output logic [4:0] stack_addr,\n  output logic full,\n  output logic empty\n);\nlogic full_r;\nlogic empty_r;\nassign full_r     = (stack_addr == 5'd16);\nassign empty_r    = (stack_addr == 5'd0);\nalways_ff@(posedge clk) begin\n   if(rst)\n     stack_addr <= 5'd0;\n   else if(push && !full_r)\n     stack_addr  <= stack_addr + 5'd1;\n   else if(pop && !empty_r)\n     stack_addr  <= stack_addr - 5'd1;\n   else\n     stack_addr  <= stack_addr + 5'd0;\nend\nassign full       = full_r;\nassign empty      = empty_r;\nendmodule\n\nmodule stack_ram (\n  input logic clk,\n  input logic  [4:0] stack_addr,\n  input logic  [3:0] stack_data_in,\n  input logic  stack_we,\n  input logic  stack_re,\n  output logic [3:0] stack_data_out\n);\n\nlogic [3:0] stack_arr [16:0];\nalways_ff@(posedge clk) begin\n  if(stack_we)\n    stack_arr[stack_addr] <= stack_data_in;\nend\n\nalways_ff @(posedge clk) begin\n    if (stack_re)\n      stack_data_out <= stack_arr[stack_addr];\nend\nendmodule\n\nmodule stack_data_mux (\n  input  logic [3:0] data_in,\n  input  logic [3:0] pc_in,\n  input  logic stack_mux_sel,\n  output logic [3:0] stack_mux_out\n);\nassign stack_mux_out = (stack_mux_sel & data_in) | (~stack_mux_sel & pc_in);\nendmodule\n\nmodule lifo_stack (\n  input  logic clk,\n  input  logic [3:0] stack_data_1_in,\n  input  logic [3:0] stack_data_2_in,\n  input  logic stack_reset,\n  input  logic stack_push,\n  input  logic stack_pop,\n  input  logic stack_mux_sel,\n  input  logic stack_we,\n  input  logic stack_re,\n  output logic [3:0] stack_data_out,\n  output logic full_o,\n  output logic empty_o\n);\n\nlogic [3:0] stack_data_in_w;\nlogic [4:0] stack_addr_w;\n\nstack_data_mux dut_1(\n    .data_in       (stack_data_1_in),\n    .pc_in         (stack_data_2_in),\n    .stack_mux_sel (stack_mux_sel),\n    .stack_mux_out (stack_data_in_w)\n);\n\nstack_pointer dut_2 (\n     .clk        (clk),\n     .rst        (stack_reset),\n     .push       (stack_push),\n     .pop        (stack_pop),\n     .stack_addr (stack_addr_w),\n     .full       (full_o),\n     .empty      (empty_o)\n);\n\nstack_ram dut_3 (\n     .clk            (clk),\n     .stack_addr     (stack_addr_w),\n     .stack_data_in  (stack_data_in_w),\n     .stack_we       (stack_we),\n     .stack_re       (stack_re),\n     .stack_data_out (stack_data_out)\n);\nendmodule\n\nmodule pc_mux (\n    input logic [3:0] full_adder_data,\n    input logic [3:0] pc_data,\n    input logic pc_mux_sel,\n    output logic [3:0] pc_mux_out\n);\nassign pc_mux_out = pc_mux_sel ? full_adder_data : pc_data;\nendmodule\n\nmodule pc_incrementer (\n  input logic pc_c_in,\n  input logic inc,\n  input logic [3:0] pc_data_in,\n  output logic [3:0] pc_inc_out,\n  output logic pc_c_out\n);\nassign {pc_c_out , pc_inc_out} = pc_data_in + (inc ? pc_c_in : 1'b0); \nendmodule\n\nmodule pc_reg (\n input logic clk,\n input logic[3:0] pc_data_in,\n output logic [3:0] pc_data_out\n);\nalways_ff@(posedge clk) begin\n   pc_data_out <= pc_data_in;\nend\nendmodule\n\nmodule program_counter(\n  input logic clk,\n  input logic [3:0] full_adder_data_i,\n  input logic pc_c_in,\n  input logic inc,\n  input logic pc_mux_sel,\n  output logic [3:0] pc_out,\n  output logic pc_c_out\n);\n \n logic [3:0] pc_out_w;\n logic [3:0] pc_mux_out_w;\n logic [3:0] pc_inc_out_w;\n logic pc_c_out_w;\npc_mux dut_1 (\n   .full_adder_data(full_adder_data_i),\n   .pc_data(pc_out_w),\n   .pc_mux_sel(pc_mux_sel),\n   .pc_mux_out(pc_mux_out_w)\n);\n\npc_incrementer dut_2 (\n  .pc_c_in(pc_c_in),\n  .inc(inc),\n  .pc_data_in(pc_mux_out_w),\n  .pc_inc_out(pc_inc_out_w),\n  .pc_c_out(pc_c_out_w)\n);\n\npc_reg dut_3 (\n   .clk(clk),\n   .pc_data_in(pc_inc_out_w),\n   .pc_data_out(pc_out_w)\n);\n\nassign pc_out = pc_out_w;\nassign pc_c_out = pc_c_out_w;\nendmodule\n\nmodule instruction_decoder(\n    input logic [4:0] instr_in,\n    input logic cc_in,\n    input logic instr_en,\n    output logic cen, \n    output logic rst, \n    output logic oen, \n    output logic inc, \n    output logic rsel, \n    output logic rce,  \n    output logic pc_mux_sel, \n    output logic [1:0] a_mux_sel, \n    output logic [1:0] b_mux_sel, \n    output logic push,\n    output logic pop, \n    output logic src_sel,\n    output logic stack_we,\n    output logic stack_re,\n    output logic out_ce\n );\n\n always_comb begin\n    casex({instr_in,cc_in,instr_en})\n       7'bxxxxxx1 : begin\n                      cen        = 1'b1;\n                      rst        = 1'b0;\n                      oen        = 1'b1;\n                      inc        = 1'b0;\n                      rsel       = 1'b0;\n                      rce        = 1'b0;\n                      a_mux_sel  = 2'b10;\n                      b_mux_sel  = 2'b10;\n                      pc_mux_sel = 1'b1;\n                      push       = 1'b0;\n                      pop        = 1'b0;\n                      src_sel    = 1'b0;\n                      stack_we   = 1'b0;\n                      stack_re   = 1'b0;\n                      out_ce     = 1'b0;\n                    end\n      7'b00000x0 : begin \n                      cen        = 1'b1; \n                      rst        = 1'b1; \n                      oen        = 1'b1;  \n                      inc        = 1'b1; \n                      rsel       = 1'b0; \n                      rce        = 1'b1; \n                      a_mux_sel  = 2'b10;  \n                      b_mux_sel  = 2'b10; \n                      pc_mux_sel = 1'b1; \n                      push       = 1'b0;\n                      pop        = 1'b0;\n                      src_sel    = 1'b0; \n                      stack_we   = 1'b0;\n                      stack_re   = 1'b0;\n                      out_ce     = 1'b0;\n                   end\n      7'b00001x0 : begin \n                     cen         = 1'b0; \n                     rst         = 1'b0; \n                     oen         = 1'b1; \n                     inc         = 1'b1; \n                     rsel        = 1'b0; \n                     rce         = 1'b0; \n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00; \n                     pc_mux_sel  = 1'b0; \n                     push        = 1'b0;\n                     pop         = 1'b0;\n                     src_sel     = 1'b0;\n                     stack_we    = 1'b0;\n                     stack_re    = 1'b0;\n                     out_ce      = 1'b0;\n                   end\n      7'b00010x0 : begin \n                     cen         = 1'b0; \n                     rst         = 1'b0; \n                     oen         = 1'b1; \n                     inc         = 1'b1; \n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     a_mux_sel   = 2'b01; \n                     b_mux_sel   = 2'b10; \n                     pc_mux_sel  = 1'b0; \n                     push        = 1'b0;\n                     pop         = 1'b0;\n                     src_sel     = 1'b0;\n                     stack_we    = 1'b0;\n                     stack_re    = 1'b0;\n                     out_ce      = 1'b0;\n                   end\n      7'b00011x0 : begin \n                     cen         = 1'b0; \n                     rst         = 1'b0; \n                     oen         = 1'b1; \n                     inc         = 1'b1; \n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     a_mux_sel   = 2'b00; \n                     b_mux_sel   = 2'b10; \n                     pc_mux_sel  = 1'b0; \n                     push        = 1'b0;\n                     pop         = 1'b0;\n                     src_sel     = 1'b0;\n                     stack_we    = 1'b0;\n                     stack_re    = 1'b0;\n                     out_ce      = 1'b0;\n                  end\n     7'b00100x0 : begin \n                     cen         = 1'b1; \n                     rst         = 1'b0; \n                     oen         = 1'b1; \n                     inc         = 1'b1; \n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     a_mux_sel   = 2'b00; \n                     b_mux_sel   = 2'b11; \n                     pc_mux_sel  = 1'b0;  \n                     push        = 1'b0;\n                     pop         = 1'b0;\n                     src_sel     = 1'b0;\n                     stack_we    = 1'b0;\n                     stack_re    = 1'b0;\n                     out_ce      = 1'b0;\n                  end\n     7'b01011x0 : begin \n                     cen         = 1'b0; \n                     rst         = 1'b0; \n                     oen         = 1'b1; \n                     inc         = 1'b1; \n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00; \n                     pc_mux_sel  = 1'b0; \n                     push        = 1'b1; \n                     pop         = 1'b0; \n                     src_sel     = 1'b0; \n                     stack_we    = 1'b1;\n                     stack_re    = 1'b0;\n                     out_ce      = 1'b0;\n                  end\n     7'b01110x0 : begin \n                     cen         = 1'b0; \n                     rst         = 1'b0; \n                     oen         = 1'b1; \n                     inc         = 1'b0; \n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     a_mux_sel   = 2'b10;\n                     b_mux_sel   = 2'b01; \n                     pc_mux_sel  = 1'b0; \n                     push        = 1'b0; \n                     pop         = 1'b1; \n                     src_sel     = 1'b1; \n                     stack_we    = 1'b0;\n                     stack_re    = 1'b1;\n                     out_ce      = 1'b0;\n                  end\n                      \n      default   : begin\n                     cen         = 1'b1; \n                     rst         = 1'b0; \n                     oen         = 1'b0; \n                     inc         = 1'b0; \n                     rsel        = 1'b0; \n                     rce         = 1'b0; \n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b10; \n                     pc_mux_sel  = 1'b0; \n                     push        = 1'b0; \n                     pop         = 1'b0; \n                     src_sel     = 1'b1; \n                     stack_we    = 1'b0;\n                     stack_re    = 1'b0;\n                     out_ce      = 1'b0;\n                   end \n                    \n      endcase\n  end\nendmodule\n\n\n\nmodule full_adder (\n    input logic [3:0] a_in,\n    input logic [3:0] b_in,\n    input logic cen,\n    input logic c_in,\n    output logic [3:0] y_out,\n    output logic c_out\n    \n);\nassign {c_out,y_out} = a_in + b_in + (cen ? c_in : 1'b0);\nendmodule\n\n\nmodule aux_reg_mux (\n  input logic [3:0] reg1_in, \n  input logic [3:0] reg2_in, \n  input logic rsel,\n  input logic re,\n  output logic [3:0] reg_mux_out\n);\n\nassign reg_mux_out = (~re & rsel) ? reg1_in : reg2_in;\nendmodule\n\nmodule aux_reg (\n    input logic clk,\n    input logic [3:0] reg_in,\n    input logic rce,\n    input logic re,\n    output logic [3:0] reg_out\n);\n always_ff@(posedge clk) begin\n   if(rce | ~re) \n    reg_out <= reg_in;\n end\nendmodule\n\nmodule a_mux (\n  input logic [3:0] register_data,\n  input logic [3:0] data_in,\n  input logic [1:0] a_mux_sel,\n  output logic [3:0] a_mux_out\n);\nalways@(*) begin\n  case(a_mux_sel) \n      2'b00 : a_mux_out = data_in;\n      2'b01 : a_mux_out = register_data;\n      2'b10 : a_mux_out = 4'b0000;\n      default : a_mux_out = 4'b0000;\n  endcase\nend\nendmodule\n\nmodule b_mux (\n  input logic [3:0] register_data,\n  input logic [3:0] stack_data,\n  input logic [3:0] pc_data,\n  input logic [1:0] b_mux_sel,\n  output logic [3:0] b_mux_out\n);\n\nalways@(*) begin\n    case(b_mux_sel)\n      2'b00 : b_mux_out = pc_data;\n      2'b01 : b_mux_out = stack_data;\n      2'b10 : b_mux_out = 4'b0000;\n      2'b11 : b_mux_out = register_data;\n      default : ;\n    endcase\nend\nendmodule\n\nmodule microcode_arithmetic ( \n  input  logic clk,\n  input  logic [3:0] fa_in,\n  input  logic [3:0] d_in,\n  input  logic [3:0] stack_data_in,\n  input  logic [3:0] pc_data_in,\n  input  logic       reg_en,\n  input  logic       oen,\n  input  logic       rsel,\n  input  logic       rce,\n  input  logic       cen,\n  input  logic [1:0] a_mux_sel,\n  input  logic [1:0] b_mux_sel,\n  input  logic       arith_cin,\n  output logic       arith_cout,\n  input  logic       oe,\n  output logic [3:0] d_out\n);\n\nlogic [3:0] fa_out_w;\nlogic [3:0] reg_mux_out_w;\nlogic [3:0] reg_out_w;\nlogic [3:0] a_mux_out_w;\nlogic [3:0] b_mux_out_w;\n\n\naux_reg_mux dut_1 (\n  .reg1_in     (fa_in),\n  .reg2_in     (d_in),\n  .rsel        (rsel),\n  .re          (reg_en),\n  .reg_mux_out (reg_mux_out_w)\n);\n\naux_reg dut_2 (\n    .clk     (clk),\n    .reg_in  (reg_mux_out_w),\n    .rce     (rce),\n    .re      (reg_en),\n    .reg_out (reg_out_w)\n);\n\na_mux dut_3(\n  .register_data(reg_out_w),\n  .data_in      (d_in),\n  .a_mux_sel    (a_mux_sel),\n  .a_mux_out    (a_mux_out_w)\n);\n\nb_mux dut_4(\n  .register_data  (reg_out_w),\n  .stack_data     (stack_data_in),\n  .pc_data        (pc_data_in),\n  .b_mux_sel      (b_mux_sel),\n  .b_mux_out      (b_mux_out_w)\n);\n\nfull_adder dut_5 (\n  .a_in  (a_mux_out_w),\n  .b_in  (b_mux_out_w),\n  .cen   (cen),\n  .c_in  (arith_cin),\n  .y_out (fa_out_w),\n  .c_out (arith_cout)\n);\nassign d_out = oen & ~oe ? fa_out_w : 4'b0000;\nendmodule\n \nmodule result_register (\n  input  logic clk,\n  input  logic [3:0] data_in,\n  input  logic out_ce,\n  output logic [3:0] data_out\n);\nalways_ff@(posedge clk) begin\n   if(out_ce)\n     data_out <= data_in;\n   else\n     data_out <= data_out;\nend\nendmodule    "}}, "output": {"response": "", "context": {"rtl/microcode_sequencer.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/microcode_sequencer.sv\nTOPLEVEL        = microcode_sequencer\nMODULE          = test_microcode_sequencer\nPYTHONPATH      = /src\nHASH            = 26-microcode_sequencer_tb_assertion_generation\n", "src/test_microcode_sequencer.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge , Timer\nimport random\n\n\n@cocotb.test()\nasync def test_microcode_sequencer(dut):\n    \"\"\"Testbench for microcode_sequencer\"\"\"\n\n    # Create a clock with a period of 20 ns (50 MHz)\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Initialize all inputs\n    dut.instr_in.value = 0\n    dut.c_n_in.value = 0\n    dut.c_inc_in.value = 0\n    dut.r_en.value = 0\n    dut.cc.value = 0\n    dut.ien.value = 0\n    dut.d_in.value = 0\n    dut.oen.value = 0\n\n    # Reset DUT\n    dut._log.info(\"Resetting DUT...\")\n    await Timer(3, units=\"ns\")  # Wait for reset to propagate\n    dut._log.info(\"Reset complete.\")\n\n    # Allow signals to settle\n    await Timer(20, units=\"ns\")\n\n    # Utility function to safely read signal values\n    def safe_read(signal):\n        \"\"\"Safely read a signal, handling unknown ('X') values.\"\"\"\n        try:\n            return int(signal.value)\n        except ValueError:\n            dut._log.warning(f\"Signal {signal._name} has an unknown value ('X'). Defaulting to 0.\")\n            return 0\n\n    @cocotb.test()\n    async def test_push_pc_instruction(dut):\n        \"\"\"Testbench for Push PC Instruction\"\"\"\n        dut._log.info(f\"Push_PC_instruction\")\n        # Start a clock with a period of 20 ns\n        cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n        # Initialize inputs\n        dut.instr_in.value = 0\n        dut.c_n_in.value = 0\n        dut.c_inc_in.value = 0\n        dut.r_en.value = 0\n        dut.cc.value = 0\n        dut.ien.value = 0\n        dut.d_in.value = 0\n        dut.oen.value = 0\n\n        # Reset DUT\n        await Timer(9, units=\"ns\")\n\n        # Apply Push PC Instruction inputs\n        dut.instr_in.value = 0b01011\n        dut.c_n_in.value = 0\n        dut.c_inc_in.value = 0\n        dut.r_en.value = 0\n        dut.cc.value = 0\n        dut.ien.value = 0\n        dut.d_in.value = 0\n        dut.oen.value = 0\n\n        # Wait for the DUT to process the inputs\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        \n        # Assertions\n        expected_d_out = 0b01000  # Update based on expected PC value\n        actual_d_out = safe_read(dut.d_out)\n        assert actual_d_out == expected_d_out, f\"Push PC Instruction failed: Expected {expected_d_out}, got {actual_d_out}\"\n\n        dut._log.info(\"Push PC Instruction test passed.\")\n    \n    @cocotb.test()\n    async def test_pop_pc_instruction(dut):\n        \"\"\"Testbench for Pop PC Instruction\"\"\"\n        dut._log.info(f\"Pop_PC_instruction\")\n        # Start a clock with a period of 20 ns\n        cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n        # Initialize inputs\n        dut.instr_in.value = 0\n        dut.c_n_in.value = 0\n        dut.c_inc_in.value = 0\n        dut.r_en.value = 0\n        dut.cc.value = 0\n        dut.ien.value = 0\n        dut.d_in.value = 0\n        dut.oen.value = 0\n\n        # Reset DUT\n        await Timer(15, units=\"ns\")\n\n        # Apply Pop PC Instruction inputs\n        dut.instr_in.value = 0b01110\n        dut.c_n_in.value = 0\n        dut.c_inc_in.value = 0\n        dut.r_en.value = 0\n        dut.cc.value = 0\n        dut.ien.value = 0\n        dut.d_in.value = 0\n        dut.oen.value = 0\n\n        # Wait for the DUT to process the inputs\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        \n        # Assertions\n        expected_d_out = 0b01000  # Update based on expected PC value\n        actual_d_out = safe_read(dut.d_out)\n        assert actual_d_out == expected_d_out, f\"Push PC Instruction failed: Expected {expected_d_out}, got {actual_d_out}\"\n\n        dut._log.info(\"Pop PC Instruction test passed.\")\n\n    # Test Task equivalent\n    async def run_test_case(\n        test_instr,          # Instruction input\n        test_carry_in,       # Carry input\n        test_carry_inc,      # Carry increment input\n        test_reg_en,         # Register enable\n        test_cond_code,      # Condition code\n        test_instr_en,       # Instruction enable\n        test_data_in,        # Data input\n        test_output_en,      # Output enable\n        expected_d_out,      # Expected data output\n        expected_c_n_out,    # Expected carry out (full adder)\n        expected_c_inc_out,  # Expected carry increment out\n        expected_full,       # Expected full condition\n        expected_empty,      # Expected empty condition\n        case_name            # Name of the test case\n    ):\n        # Apply inputs\n        dut.instr_in.value = test_instr\n        dut.c_n_in.value = test_carry_in\n        dut.c_inc_in.value = test_carry_inc\n        dut.r_en.value = test_reg_en\n        dut.cc.value = test_cond_code\n        dut.ien.value = test_instr_en\n        dut.d_in.value = test_data_in\n        dut.oen.value = test_output_en\n\n        # Wait for two clock cycles to allow the DUT to settle\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n\n        # Log inputs, internal signals, and outputs\n        dut._log.info(f\"Running test case: {case_name}\")\n        dut._log.info(f\"Inputs: instr_in = {int(dut.instr_in.value)}, c_n_in = {dut.c_n_in.value}, \"\n                      f\"c_inc_in = {dut.c_inc_in.value}, r_en = {dut.r_en.value}, cc = {dut.cc.value}, \"\n                      f\"ien = {dut.ien.value}, d_in = {int(dut.d_in.value)}, oen = {dut.oen.value}\")\n        dut._log.info(f\"Expected: d_out = {expected_d_out}, c_n_out = {expected_c_n_out}, \"\n                      f\"c_inc_out = {expected_c_inc_out}, full = {expected_full}, empty = {expected_empty}\")\n        dut._log.info(f\"Actual: d_out = {int(dut.d_out.value)}, c_n_out = {dut.c_n_out.value}, \"\n                      f\"c_inc_out = {dut.c_inc_out.value}, full = {dut.full.value}, empty = {dut.empty.value}\")\n\n        # Assertions\n        assert int(dut.d_out.value) == expected_d_out, f\"{case_name} - d_out mismatch\"\n        assert dut.c_n_out.value == expected_c_n_out, f\"{case_name} - c_n_out mismatch\"\n        assert dut.c_inc_out.value == expected_c_inc_out, f\"{case_name} - c_inc_out mismatch\"\n        assert dut.full.value == expected_full, f\"{case_name} - full mismatch\"\n        assert dut.empty.value == expected_empty, f\"{case_name} - empty mismatch\"\n\n    # Run fixed test cases\n    await run_test_case(0b00000, 0, 0, 0, 0, 0, 0b0000, 0, 0b0000, 0, 0, 0, 1, \"Reset Instruction\")\n    await run_test_case(0b00001, 0, 1, 0, 0, 0, 0b0000, 0, 0b0001, 0, 0, 0, 1, \"Fetch PC Instruction 1\")\n    await run_test_case(0b00001, 0, 0, 0, 0, 0, 0b0000, 0, 0b0010, 0, 0, 0, 1, \"Fetch PC Instruction 2\")\n    await run_test_case(0b00010, 0, 1, 0, 0, 0, 0b1010, 0, 0b1010, 0, 0, 0, 1, \"Fetch R Instruction\")\n    await run_test_case(0b00011, 0, 1, 0, 0, 0, 0b1011, 0, 0b1011, 0, 0, 0, 1, \"Fetch D Instruction\")\n    await run_test_case(0b00100, 1, 1, 0, 0, 0, 0b0011, 0, 0b0111, 0, 0, 0, 1, \"Fetch R+D Instruction\")\n    await test_push_pc_instruction(dut)\n    await test_push_pc_instruction(dut) \n    await test_pop_pc_instruction(dut)\n    await test_pop_pc_instruction(dut)\n\n    # List of all directed test cases with their expected values\n    test_cases = [\n        (0b00000, 0, 0, 0, 0, 0, 0b0000, 0, 0b0000, 0, 0, 0, 1, \"Reset Instruction\"),\n        (0b00001, 0, 1, 0, 0, 0, 0b0000, 0, 0b0001, 0, 0, 0, 1, \"Fetch PC Instruction 1\"),\n        (0b00001, 0, 0, 0, 0, 0, 0b0000, 0, 0b0010, 0, 0, 0, 1, \"Fetch PC Instruction 2\"),\n        (0b00010, 0, 1, 0, 0, 0, 0b1010, 0, 0b1010, 0, 0, 0, 1, \"Fetch R Instruction\"),\n        (0b00011, 0, 1, 0, 0, 0, 0b1011, 0, 0b1011, 0, 0, 0, 1, \"Fetch D Instruction\"),\n        (0b00100, 1, 1, 0, 0, 0, 0b0011, 0, 0b0111, 0, 0, 0, 1, \"Fetch R+D Instruction\"),\n        (0b01011, 0, 0, 0, 0, 0, 0b0000, 0, 0b01000, 0, 0, 0, 1, \"Push PC Instruction\"),\n        (0b01110, 0, 0, 0, 0, 0, 0b0000, 0, 0b01000, 0, 0, 0, 1, \"Pop PC Instruction\")\n    ]\n\n    # Always select \"Reset Instruction\" for the randomized test case\n    for i in range(2):  # Run 2 randomized test cases\n        test_case = test_cases[0]  # Always choose the first test case (Reset Instruction)\n        dut._log.info(f\"Running Randomized Test Case {i+1}: {test_case[13]}\")  # Log which test case is being selected\n        await run_test_case(*test_case)\n\n    dut._log.info(\"All test cases, including randomized tests, completed successfully.\")\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_microcode_sequencer_0028", "categories": ["cid012", "medium"], "input": {"prompt": "Complete the given partial System Verilog Testbench `tb_microcode_sequencer`.The testbench must instantiate the `microcode_sequencer` RTL module and provide input stimulus for it, apply various input combinations representing different instructions and conditions such as resetting, fetching instructions, loading data, pushing/popping from the stack, jumping, conditional holds, and program suspensions and edge cases with invalid instructions and test conditional failures rather than building a full testbench. \n\nThe module interface is given below :\n## **Module Interface** :\n### Inputs:\n- `clk`(1-bit): The positive edge-triggered clock signal required for the sequential components.\n- `c_n_in`(1-bit): Carry-in signal for the ripple carry adder.\n- `c_inc_in`(1-bit): Carry-in for the program counter incrementer.\n- `r_en`(1-bit): ACTIVE LOW auxiliary register enable signal.\n- `cc`(1-bit): ACTIVE LOW condition code input for instruction decoding.\n- `ien`(1-bit): ACTIVE LOW instruction enable signal.\n- `d_in`(4-bit , [3:0]): A 4-bit data input bus.\n- `instr_in`(5-bit, [4:0]): A 5-bit opcode representing the instruction.\n- `oen`(1-bit): ACTIVE LOW output enable for the data output path.\n\n### Outputs:\n- `d_out`(4-bit,[3:0]): A 4-bit address output bus.\n- `c_n_out`(1-bit): Carry-out signal from the ripple carry adder. LOGIC HIGH in this signal indicates the presence of carry.\n- `c_inc_out`(1-bit): Carry-out signal from the program counter incremented. LOGIC HIGH in this signal indicates the presence of carry.\n- `full`(1-bit): ACTIVE HIGH signal indicates if the Last In First Out (LIFO) stack is full.\n- `empty`(1-bit): ACTIVE HIGH signal indicates if the LIFO stack is empty.\n- `g_n_out`: Group generate signal from the arithmetic unit.\n- `p_n_out`: Group propagate signal from the arithmetic unit.\n- `g_inc_out`: Group generate signal from the program counter incrementer.\n- `p_inc_out`: Group propagate signal from the program counter incrementer.\n\n## Instantiation :\nThe testbench instantiates the `microcode_sequencer` module as **uut** and connects the signals between the module and the testbench. Each input and output from the **uut** is connected to its corresponding signal in the testbench.\n\n## Input Generation and Validation:\n**Stimulus**: \nSeveral test cases are applied to simulate various operations of the microcode_sequencer. These test cases cover a wide range of scenarios such as different types of instructions (reset, fetch, load, push, pop, jump, etc.), as well as conditional and unconditional instruction executions. For each test case, the relevant outputs (`d_out`, `c_n_out`, `c_inc_out`, `full`, `empty`, `g_n_out`, `p_n_out`, `g_inc_out`, `p_inc_out`) are monitored immediately after the application of inputs to validate the functionality.\n\n**Test Case 1: Instruction Disable** :\n- Description: This test case disables the instruction input (`5'bxxxxx`). With no valid instruction provided, the microcode sequencer should remain idle and output default values, reflecting no operation being performed. The outputs should show that the sequencer is in a non-operational state with the `uut.pc_out_w` value remaining at 0000. \n\n**Test Case 2: Reset Instruction** :\n- The test applies a reset instruction (`5'b00000`), which should clear all registers and reset the state of the sequencer. The outputs should reflect the sequencer being reset, with `d_out`, `c_n_out`, `c_inc_out`, and `uut.pc_out_w` values showing their initial conditions (`0000` for `d_out`, `0000` for `uut.pc_out_w`, and `full` set to `0`, `empty` set to `1`).\n\n**Test Case 3: Fetch PC Instruction** :\n- This test case applies a fetch PC instruction (`5'b00001`), where the program counter (PC) is fetched. The sequencer should output the program counter incremented by 1. In this case, the expected output for uut.pc_out_w is `0001`, with `d_out` reflecting the fetched value.\n\n**Test Case 4: Fetch R Instruction** :\n- The sequencer applies a fetch R instruction (`5'b00010`), which fetches the value from register R. The expected outcome is that the value in `d_out` should be the value of register R (`101` in this case) with `uut.pc_out_w` incrementing accordingly (`0010`).\n\n**Test Case 5: Fetch D Instruction** :\n- This test case applies a fetch D instruction (`5'b00011`). The sequencer fetches the value from the D input(`d_in`), with `d_out` reflecting the value of D (`110`) and `uut.pc_out_w` incrementing as expected (`0011`).\n\n**Test Case 6: Fetch R + D Instruction** :\n- A fetch R + D instruction (`5'b00100`) is applied, where the sequencer fetches and combines data from both the auxiliary register and `d_in`. The expected result is `d_out` showing the combined data (111), and `uut.pc_out_w` reflecting the expected increment (`0100`).\n\n**Test Case 7: Fetch PC + D Instruction** :\n- This test case applies a fetch PC + D instruction (`5'b00101`), which combines the values of the program counter (PC) and the `d_in`. The d_out value should reflect the combination (`1100`), and `uut.pc_out` should increment to `0101`.\n\n**Test Case 8: Fetch PC + R Instruction** :\n- The test applies a fetch PC + R instruction (`5'b00110`), where the sequencer fetches both the program counter (PC) and the Auxiliary register. The expected output for `d_out` should be a combination of the content of the PC and auxiliary register (`1101`), and `pc_out `increments accordingly to `0110`.\n\n**Test Case 9: Fetch PC to R Instruction** :\n- A fetch PC to R instruction (`5'b01000`) is applied, where the program counter (`PC`) is transferred to the auxiliary register. The expected output should show `d_out` reflecting the PC value (`111`), and `pc_out` incrementing as expected (`0111`).\n\n**Test Case 10: Fetch R+D to R Instruction** :\n- This case applies a fetch R + D to R instruction (`5'b01001`), where the data from both the auxiliary register and `d_in` are fetched, added, and transferred to the auxiliary register. The expected output should reflect this combination (`11` for `d_out`), and the program counter should increment (`1000` for `uut.pc_out_w`).\n\n**Test Case 11: Load R Instruction** :\n- A load R instruction (`5'b01010`) is applied, where data from an`d_in` is loaded into the auxiliary register. The output should reflect the `uut.pc_out_w` value (`1001` for `d_out`), and the program counter (`uut.pc_out_w`) should be incremented accordingly (`1001`).\n\n**Test Case 12: Push PC Instruction** :\n- A push PC instruction (`5'b01011`) is tested, where the program counter (`PC`) is pushed onto the stack. The output shows the updated stack (`d_out` as `1010`) and empty flag reflecting the stack status (`0`).\n\n**Test Case 13: Pop PC Instruction** :\n- A pop PC instruction (`5'b01110`) is applied, where the program counter (PC) is popped from the stack. The expected output shows the popped value (`1011`) in d_out and the updated program counter (`uut.pc_out_w` as `1101`).\n\n**Test Case 14: Push D Instruction** :\n- A push D instruction (`5'b01100`) is tested, where data from the `d_in` is pushed onto the stack. The expected output is that `d_out` reflects the pushed value and 1uut.pc_out_w1 should increment appropriately.\n\n**Test Case 15: Pop Stack Instruction** :\n- A pop stack instruction (`5'b01101`) tests the sequencer's ability to pop data from the stack. The expected outputs should show the data being popped correctly (`d_out` reflects the popped value) and the stack's status with empty being checked.\n\n**Test Case 16: HOLD** :\n- A hold instruction (`5'b01111`) is applied to check that the sequencer halts its operation. The expected behavior is that the sequencer should not move to the next instruction and `uut.pc_out_w` stays in the current state.\n\n**Test Case 17: Fail Conditional Instruction** :\n- This test applies an invalid instruction (`5'b1xxxx`) with conditional failure (`cc` = `1`). The sequencer should fail to process the instruction and output appropriate values (`d_out` reflecting updated `uut.pc_out_w` value).\n\n**Test Case 18: Jump R Instruction** :\n- A jump R instruction (`5'b10000`) is applied, where the sequencer performs a jump using the auxiliary register value. The expected output shows a jump action with `d_out` reflecting the jump address.\n\n**Test Case 19: Jump D Instruction** :\n- A jump D instruction (`5'b10001`) tests the sequencer\u2019s ability to jump based on the `d_in` value. The expected outcome is that `d_out` reflects the jump address based on the value of `d_in`.\n\n**Test Case 20: Jump 0 Instruction** :\n- A jump 0 instruction (`5'b10010`) applies a jump to address `0`. The output should reflect this jump, with `uut.pc_out_w` updated to `0000`.\n\n**Test Case 21: Jump R+D Instruction** :\n- A jump R+D instruction (`5'b10011`) applies a jump based on the sum of the auxiliary register and `d_in`. The expected output should reflect the sum.\n\n**Test Case 22: Jump PC+D Instruction** :\n- A jump PC+D instruction (`5'b10100`) applies a jump based on the sum of PC and `d_in`. The expected behavior is that `d_out `reflects the result of PC and `d_in` combined.\n\n**Test Case 23: Jump PC+R Instruction** :\n- A jump PC+R instruction (`5'b10101`) applies a jump based on the sum of PC and auxiliary register. The expected output should reflect this combination in `d_out`.\n\n**Test Case 24: JSB R Instruction** :\n- A JSB R instruction (`5'b10110`) applies a jump to a subroutine based on the auxiliary register. The output should show the subroutine jump address in `d_out`.\n\n**Test Case 25: JSB D Instruction** :\n- A JSB D instruction (`5'b10111`) applies a jump to the subroutine address based on the `d_in`. The sequencer should handle the jump correctly by appropriately updating `d_out`.\n\n**Test Case 26: JSB 0 Instruction** :\n- A JSB 0 instruction (`5'b11000`) applies a jump to a subroutine at address 0. The expected output should reflect the jump to address 0.\n\n**Test Case 27: JSB R+D Instruction** :\n- A JSB R+D instruction (5'b11001) applies a jump to the subroutine address based on the sum of the auxiliary register and `d_in`. The sequencer should perform the jump correctly.\n\n**Test Case 28: JSB PC+D Instruction** : \n - A JSB PC+D instruction (`5'b11010`) applies a jump to the subroutine address based on the sum of PC and `d_in`. The expected outcome should reflect the subroutine jump at `d_out`.\n\n**Test Case 29: Fetch S+D Instruction** :\n- This test applies a fetch S+D instruction (`5'b00111`), where the sequencer fetches and adds values of popped stack value (S) with `d_in`. The expected output should reflect the appropriate address at `d_out`.\n\n**Test Case 30: Return S Instruction** :\n- The return S instruction (`5'b11100`) tests the sequencer\u2019s ability to return from a subroutine. The expected outcome should show the return address at `d_out`.\n\n**Test Case 31: Return S+D Instruction** :\n- The return S+D instruction (`5'b11101`) checks the sequencer\u2019s ability to return from a subroutine with the sum of popped value from the stack and `d_in`. The expected output should be reflected at `d_out`.\n\n**Test Case 32: Conditional Hold** :\n- The conditional hold instruction (`5'b11110`) tests the sequencer\u2019s ability to hold execution based on a condition. The expected outcome should show that the sequencer halts.\n\n**Test Case 33: Program Suspend** :\n- The program suspend instruction (`5'b11111`) checks the sequencer\u2019s ability to suspend its program flow. The expected behavior is that the sequencer stops and no further instructions are executed.\n\n## Module Functionality :\n**Microcode Sequencer Module (microcode_sequencer)** :\nPurpose: This module controls the operation of a microprocessor by sequencing operations based on the instructions it receives. It interacts with other modules (like stack, program counter, arithmetic operations, and instruction decoder) to control the flow of data.\nIt contains the following components :\n\n**LIFO Stack Module (lifo_stack)** :\n**Purpose**: Implements a stack with push and pop functionality, allowing data to be stored and retrieved in a last-in-first-out \norder.\n**Components**:\n- **Stack Pointer**: Tracks the current position in the stack and controls whether the stack is full or empty.\n- **Stack RAM**: Stores the actual stack data.\n- **Stack Data Mux**: Selects which data (either from the program counter or data input) should be pushed onto the stack.\n\n**Program Counter Module (program_counter)** :\n**Purpose**: Handles the program counter (PC), which keeps track of the next instruction to execute. It can increment \nbased on different conditions.\n**Components**:\n- **PC Mux**: Selects the input for the program counter (either from the adder or program counter).\n- **PC Incrementer**: Performs the actual increment of the program counter based on carry and increment signals.\n- **PC Register**: Stores the current value of the program counter.\n\n**Instruction Decoder (instruction_decoder)** :\n**Purpose**: Decodes the incoming instruction (instr_in) and generates control signals for various operations like \nincrement, push, pop, stack operations, etc.\n   \n**Microcode Arithmetic Module (microcode_arithmetic)**\n**Purpose**: Performs arithmetic operations like addition using a carry lookahead adder. It uses data from various inputs \n(program counter, stack, data input) and processes it based on the instruction.\n\n**Components**:\n**Auxiliary Register**: Stores data that can be modified based on the control signals (rsel, rce).\n**MUXes**: Control the selection of data from different sources (registers, stack, program counter) to be used in arithmetic \noperations.\n**Full Adder**: Performs the actual arithmetic operations and generates the result, carry, group, generate, and propagate \nsignals. It is implemented using 4-bit carry-lookahead logic.  \n\n**Partial Test Stimulus Generator Code** :\n```verilog\nmodule tb_microcode_sequencer;\n\n  // Inputs to the DUT\n  logic clk;\n  logic c_n_in;\n  logic c_inc_in;\n  logic r_en;\n  logic cc;\n  logic ien;\n  logic [3:0] d_in;\n  logic [4:0] instr_in;\n  logic oen;\n\n  // Outputs from the DUT\n  logic [3:0] d_out;\n  logic c_n_out;\n  logic c_inc_out;\n  logic full;\n  logic empty;\n  logic g_n_out;\n  logic p_n_out;\n  logic g_inc_out;\n  logic p_inc_out;\n  \n  \n    \n  microcode_sequencer uut (\n    .clk(clk),\n    .c_n_in(c_n_in),\n    .c_inc_in(c_inc_in),\n    .r_en(r_en),\n    .cc(cc),\n    .ien(ien),\n    .d_in(d_in),\n    .instr_in(instr_in),\n    .oen(oen),\n    .d_out(d_out),\n    .c_n_out(c_n_out),\n    .c_inc_out(c_inc_out),\n    .full(full),\n    .empty(empty),\n    .g_n_out(g_n_out),\n    .p_n_out(p_n_out),\n    .g_inc_out(g_inc_out),\n    .p_inc_out(p_inc_out)\n  );\n\n  \n  initial begin\n    clk = 0;\n    forever #10 clk = ~clk;\n  end\n\n  // Task to test specific cases\n  task run_test_case(\n    input logic [4:0] test_instr,          // Instruction input\n    input logic test_carry_in,            // Carry input\n    input logic test_carry_inc,           // Carry increment input\n    input logic test_reg_en,              // Register enable\n    input logic test_cond_code,           // Condition code\n    input logic test_instr_en,            // Instruction enable\n    input logic [3:0] test_data_in,       // Data input\n    input logic test_output_en,           // Output enable\n    input string case_name                // Name of the test case\n  ); \n    begin\n      // Apply inputs\n      instr_in = test_instr;\n      c_n_in = test_carry_in;\n      c_inc_in = test_carry_inc;\n      r_en = test_reg_en;\n      cc = test_cond_code;\n      ien = test_instr_en;\n      d_in = test_data_in;\n      oen = test_output_en;\n\n      #20;  \n      $display(\"Running test case: %s\", case_name);\n      $display(\"time = %0t , Inputs: instr_in = %0b, c_n_in = %b, c_inc_in = %b, r_en = %b, cc = %b, ien = %b, d_in = %0b, oen = %b\",\n               $time,test_instr, test_carry_in, test_carry_inc, test_reg_en, test_cond_code, test_instr_en, test_data_in, test_output_en);\n      $display(\"time = %0t , d_out = %0b, c_n_out = %b, c_inc_out = %b, full = %b, empty = %b, g_n_out = %b, p_n_out = %b, g_inc_out = %b, p_inc_out = %b , pc_out = %b\",\n               $time,d_out, c_n_out, c_inc_out, full, empty, g_n_out, p_n_out, g_inc_out, p_inc_out,uut.pc_data_w);\n               \n      end\n  endtask\n\n  \n  initial begin\n    $dumpfile(\"microcode_sequencer.vcd\");  \n    $dumpvars(0, tb_microcode_sequencer);  \n\n    $display(\"Starting testbench for microcode_sequencer...\");\n\n        \n    run_test_case(5'bxxxxx, 1'b0, 1'b0, 1'b0, 1'b1, 1'b1, 4'bxxxx, 1'b0, \"Instruction Disable\");\n    run_test_case(5'b00000, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 4'bxxxx, 1'b0, \"Reset Instruction\");\n    run_test_case(5'b00001, 1'b0, 1'b1, 1'b0, 1'b0, 1'b0, 4'bxxxx, 1'b0, \"Fetch PC Instruction\");\n    run_test_case(5'b00010, 1'b0, 1'b1, 1'b0, 1'b0, 1'b0, 4'b0101, 1'b0, \"Fetch R Instruction\");\n    run_test_case(5'b00010, 1'b0, 1'b1, 1'b0, 1'b0, 1'b0, 4'b0110, 1'b0, \"Fetch R Instruction\");\n    run_test_case(5'b00011, 1'b0, 1'b1, 1'b0, 1'b0, 1'b0, 4'b0110, 1'b0, \"Fetch D Instruction\");\n    run_test_case(5'b00011, 1'b0, 1'b0, 1'b0, 1'b1, 1'b1, 4'b0110, 1'b0, \"Fetch D Instruction\"); \n    run_test_case(5'b00011, 1'b0, 1'b1, 1'b0, 1'b0, 1'b0, 4'b0111, 1'b0, \"Fetch D Instruction\");\n    // Insert the code for remaining test cases here\n```\n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_microcode_sequencer.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 212f03ed20beb93d25a4509a8d1341b23428fc6e\nTARGET = 90\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/microcode_sequencer.sv": "module microcode_sequencer (\n   // Inputs\n   input logic clk, // Input Clock\n   input logic c_n_in,  // Input Carry for Carry Lookahead Adder\n   input logic c_inc_in, // Input Carry for Carry Lookahead Program Counter Incrementer\n   input logic r_en, // Auxiliary Register enable\n   input logic cc, // Condition Code\n   input logic ien, // Instruction Enable\n   input logic [3:0] d_in, // Data Input\n   input logic [4:0] instr_in, // 5-bit Instruction Opcode\n   input logic oen, // Output Enable\n\n   // Outputs\n   output logic [3:0] d_out, // Data Output\n   output logic c_n_out , // Output Carry from Carry Lookahead Adder\n   output logic c_inc_out, // Output Carry from Program Counter Incrementer\n   output logic full, // Stack Full Condition\n   output logic empty, // Stack Empty Condition\n\n   // Additional Outputs\n   output logic g_n_out, // Group Generate output from  Carry Lookahead adder\n   output logic p_n_out, // Group Propagate output from Carry Lookahead adder\n   output logic g_inc_out, // Group Generate output from Carry Lookahead Program Counter Incrementer\n   output logic p_inc_out  // Group Propagate output from Carry Lookahead Program Counter Incrementer\n );\n\n \n logic [3:0] pc_data_w;\n logic stack_reset_w;\n logic [3:0] stack_data_w;\n logic [3:0] fa_out_w;\n logic [3:0] data_out_w;\n  \n logic rsel_w;\n logic rce_w;\n logic [1:0] a_mux_sel_w;\n logic [1:0] b_mux_sel_w;\n logic cen_w;\n logic rst_w;\n logic stack_push_w;\n logic stack_pop_w;\n logic pc_mux_sel_w;\n logic stack_mux_sel_w;\n logic stack_we_w;\n logic stack_re_w;\n logic inc_w;\n logic oen_w;\n logic out_en_w;\n \n lifo_stack dut_1 (\n    .clk              (clk),\n    .stack_data_1_in  (d_in),\n    .stack_data_2_in  (pc_data_w),\n    .stack_reset      (rst_w),\n    .stack_push       (stack_push_w),\n    .stack_pop        (stack_pop_w),\n    .stack_mux_sel    (stack_mux_sel_w),\n    .stack_we         (stack_we_w),\n    .stack_re         (stack_re_w),\n    .stack_data_out   (stack_data_w),\n    .full_o           (full),\n    .empty_o          (empty)\n );\n\n program_counter dut_2 (\n    .clk               (clk),\n    .full_adder_data_i (fa_out_w),\n    .pc_c_in           (c_inc_in),\n    .inc               (inc_w),\n    .pc_mux_sel        (pc_mux_sel_w),\n    .pc_out            (pc_data_w),\n    .pc_c_out          (c_inc_out),\n    .pc_g_out          (g_inc_out),\n    .pc_p_out          (p_inc_out)\n );\n \n microcode_arithmetic dut_3(\n    .clk              (clk),\n    .fa_in            (data_out_w),\n    .d_in             (d_in),\n    .stack_data_in    (stack_data_w),\n    .pc_data_in       (pc_data_w),\n    .reg_en           (r_en),\n    .oen              (oen_w),\n    .rsel             (rsel_w),\n    .rce              (rce_w),\n    .cen              (cen_w),\n    .a_mux_sel        (a_mux_sel_w),\n    .b_mux_sel        (b_mux_sel_w),\n    .arith_cin        (c_n_in),\n    .arith_cout       (c_n_out),\n    .arith_g_out      (g_n_out),\n    .arith_p_out      (p_n_out),\n    .oe               (oen),\n    .d_out            (fa_out_w)\n );\n \n instruction_decoder dut_4 (\n    .instr_in         (instr_in),\n    .cc_in            (cc),\n    .instr_en         (ien),\n    .cen              (cen_w), \n    .rst              (rst_w), \n    .oen              (oen_w), \n    .inc              (inc_w), \n    .rsel             (rsel_w), \n    .rce              (rce_w),  \n    .pc_mux_sel       (pc_mux_sel_w), \n    .a_mux_sel        (a_mux_sel_w), \n    .b_mux_sel        (b_mux_sel_w), \n    .push             (stack_push_w),\n    .pop              (stack_pop_w), \n    .src_sel          (stack_mux_sel_w),\n    .stack_we         (stack_we_w),\n    .stack_re         (stack_re_w),\n    .out_ce           (out_ce_w)\n);\n\n result_register dut_5 (\n   .clk     (clk),\n   .data_in (fa_out_w),\n   .out_ce  (out_ce_w),\n   .data_out(data_out_w)\n );\nassign d_out = fa_out_w;\nendmodule\n \nmodule stack_pointer (\n  input logic clk,\n  input logic rst,\n  input logic push,\n  input logic pop,\n  output logic [4:0] stack_addr,\n  output logic full,\n  output logic empty\n);\nlogic [4:0] stack_addr_reg;\nlogic full_r;\nlogic empty_r;\nassign full_r     = (stack_addr_reg == 5'b10000);\nassign empty_r    = (stack_addr_reg == 5'b00000);\nalways_ff@(posedge clk) begin\n   if(rst)\n     stack_addr_reg <= 5'b00000;\n   else if(push && !full_r) begin\n     stack_addr_reg <= stack_addr_reg + 5'b00001;\n   end else if(pop && !empty_r) begin\n     stack_addr_reg <= stack_addr_reg - 5'b00001;\n   end \n   \nend\nassign full       = full_r;\nassign empty      = empty_r;\nassign stack_addr = stack_addr_reg; \nendmodule\n\nmodule stack_ram (\n  input logic clk,\n  input logic  [4:0] stack_addr,\n  input logic  [3:0] stack_data_in,\n  input logic  stack_we,\n  input logic  stack_re,\n  output logic [3:0] stack_data_out\n);\n\nlogic [3:0] stack_arr [16:0];\nalways_ff@(posedge clk) begin\n  if(stack_we) begin\n    stack_arr[stack_addr] = stack_data_in;\n  end\nend\n\nassign stack_data_out = stack_re ? stack_arr[stack_addr] : '0; \nendmodule\n\nmodule stack_data_mux (\n  input  logic [3:0] data_in,\n  input  logic [3:0] pc_in,\n  input  logic stack_mux_sel,\n  output logic [3:0] stack_mux_out\n);\nassign stack_mux_out = stack_mux_sel ? data_in : pc_in;\nendmodule\n\nmodule lifo_stack (\n  input  logic clk,\n  input  logic [3:0] stack_data_1_in,\n  input  logic [3:0] stack_data_2_in,\n  input  logic stack_reset,\n  input  logic stack_push,\n  input  logic stack_pop,\n  input  logic stack_mux_sel,\n  input  logic stack_we,\n  input  logic stack_re,\n  output logic [3:0] stack_data_out,\n  output logic full_o,\n  output logic empty_o\n);\n\nlogic [3:0] stack_data_in_w;\nlogic [4:0] stack_addr_w;\n\nstack_data_mux dut_1(\n    .data_in       (stack_data_1_in),\n    .pc_in         (stack_data_2_in),\n    .stack_mux_sel (stack_mux_sel),\n    .stack_mux_out (stack_data_in_w)\n);\n\nstack_pointer dut_2 (\n     .clk        (clk),\n     .rst        (stack_reset),\n     .push       (stack_push),\n     .pop        (stack_pop),\n     .stack_addr (stack_addr_w),\n     .full       (full_o),\n     .empty      (empty_o)\n);\n\nstack_ram dut_3 (\n     .clk            (clk),\n     .stack_addr     (stack_addr_w),\n     .stack_data_in  (stack_data_in_w),\n     .stack_we       (stack_we),\n     .stack_re       (stack_re),\n     .stack_data_out (stack_data_out)\n);\nendmodule\n\nmodule pc_mux (\n    input logic [3:0] full_adder_data,\n    input logic [3:0] pc_data,\n    input logic pc_mux_sel,\n    output logic [3:0] pc_mux_out\n);\nassign pc_mux_out = pc_mux_sel ? pc_data : full_adder_data;\nendmodule\n\n\nmodule pc_incrementer (\n  input  logic pc_c_in,         \n  input  logic inc,             \n  input  logic [3:0] pc_data_in,\n  output logic [3:0] pc_inc_out,\n  output logic pc_c_out,        \n  output logic pc_g_out,        \n  output logic pc_p_out         \n);\n  \n    logic g[3:0];\n    logic p[3:0];\n    logic c[4:0];\n\n    assign g[0]  = 1'b0;\n    assign g[1]  = 1'b0;\n    assign g[2]  = 1'b0;\n    assign g[3]  = 1'b0;\n\n    assign p[0]  = pc_data_in[0] ^ 1'b0; \n    assign p[1]  = pc_data_in[1] ^ 1'b0; \n    assign p[2]  = pc_data_in[2] ^ 1'b0; \n    assign p[3]  = pc_data_in[3] ^ 1'b0; \n    \n    assign c[0]  = pc_c_in;\n    assign c[1]  = (p[0] & c[0]);\n    assign c[2]  = (c[0] & p[0] & p[1]);\n    assign c[3]  = (c[0] & p[0] & p[1] & p[2]);\n    assign c[4]  = (c[0] & p[0] & p[1] & p[2] & p[3]);\n\n    assign pc_inc_out[0]  = inc ? p[0] ^ c[0] : p[0];\n    assign pc_inc_out[1]  = inc ? p[1] ^ c[1] : p[1];\n    assign pc_inc_out[2]  = inc ? p[2] ^ c[2] : p[2];\n    assign pc_inc_out[3]  = inc ? p[3] ^ c[3] : p[3];\n    assign pc_p_out = p[0] & p[1] & p[2] & p[3];\n    assign pc_g_out = 1'b0;\n    assign pc_c_out = c[4];\nendmodule\n\n\nmodule pc_reg (\n input logic clk,\n input logic[3:0] pc_data_in,\n output logic [3:0] pc_data_out\n);\nalways_ff@(posedge clk) begin\n   pc_data_out <= pc_data_in;\n   \nend\nendmodule\n\nmodule program_counter(\n  input logic clk,\n  input logic [3:0] full_adder_data_i,\n  input logic pc_c_in,\n  input logic inc,\n  input logic pc_mux_sel,\n  output logic [3:0] pc_out,\n  output logic pc_c_out,\n  output logic pc_g_out,\n  output logic pc_p_out\n);\n \n logic [3:0] pc_out_w;\n logic [3:0] pc_mux_out_w;\n logic [3:0] pc_inc_out_w;\n logic pc_c_out_w;\n \n \npc_mux dut_1 (\n   .full_adder_data(full_adder_data_i),\n   .pc_data(pc_out_w),\n   .pc_mux_sel(pc_mux_sel),\n   .pc_mux_out(pc_mux_out_w)\n);\n\npc_incrementer dut_2 (\n  .pc_c_in(pc_c_in),\n  .inc(inc),\n  .pc_data_in(pc_mux_out_w),\n  .pc_inc_out(pc_inc_out_w),\n  .pc_c_out(pc_c_out_w),\n  .pc_g_out(pc_g_out),\n  .pc_p_out(pc_p_out)\n);\n\npc_reg dut_3 (\n   .clk(clk),\n   .pc_data_in(pc_inc_out_w),\n   .pc_data_out(pc_out_w)\n);\n\nassign pc_out = pc_out_w;\nassign pc_c_out = pc_c_out_w;\nendmodule\n\nmodule instruction_decoder(\n    input logic [4:0] instr_in,\n    input logic cc_in,\n    input logic instr_en,\n    output logic cen, \n    output logic rst, \n    output logic oen, \n    output logic inc, \n    output logic rsel, \n    output logic rce,  \n    output logic pc_mux_sel, \n    output logic [1:0] a_mux_sel, \n    output logic [1:0] b_mux_sel, \n    output logic push,\n    output logic pop, \n    output logic src_sel,\n    output logic stack_we,\n    output logic stack_re,\n    output logic out_ce\n );\n\n always_comb begin\n    casex({instr_in,cc_in,instr_en})\n       7'bxxxxxx1 : begin  \n                      rst        = 1'b0;\n                      out_ce     = 1'b0;\n                      rsel       = 1'b0;\n                      rce        = 1'b0;\n                      cen        = 1'b0;\n                      stack_re   = 1'b0;\n                      pop        = 1'b0;\n                      a_mux_sel  = 2'b10;\n                      b_mux_sel  = 2'b10;\n                      oen        = 1'b1;\n                      pc_mux_sel = 1'b0;\n                      inc        = 1'b0;\n                      src_sel    = 1'b0;\n                      push       = 1'b0;\n                      stack_we   = 1'b0;\n                   end\n      7'b00000x0 : begin  \n                      rst        = 1'b1;\n                      out_ce     = 1'b0;\n                      rsel       = 1'b0;\n                      rce        = 1'b1; \n                      cen        = 1'b1;  \n                      stack_re   = 1'b0;\n                      pop        = 1'b0;\n                      a_mux_sel  = 2'b10;  \n                      b_mux_sel  = 2'b10;  \n                      oen        = 1'b1;  \n                      pc_mux_sel = 1'b0; \n                      inc        = 1'b1; \n                      src_sel    = 1'b0; \n                      push       = 1'b0;\n                      stack_we   = 1'b0;\n                   end\n      7'b00001x0 : begin  \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                   end\n      7'b00010x0 : begin  \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b01; \n                     b_mux_sel   = 2'b10;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                   end\n      7'b00011x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0;  \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00; \n                     b_mux_sel   = 2'b10;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b00100x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1;  \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00; \n                     b_mux_sel   = 2'b11;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b00101x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00; \n                     b_mux_sel   = 2'b00;  \n                     oen         = 1'b1;  \n                     pc_mux_sel  = 1'b1;  \n                     inc         = 1'b1;  \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b00110x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b01; \n                     b_mux_sel   = 2'b00;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b00111x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b1;\n                     pop         = 1'b1;\n                     a_mux_sel   = 2'b00; \n                     b_mux_sel   = 2'b01;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b01000x0 : begin  \n                     rst         = 1'b0;\n                     out_ce      = 1'b1;\n                     rsel        = 1'b1;\n                     rce         = 1'b0;\n                     cen         = 1'b0; \n                     stack_re    = 1'b0; \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b01001x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b1;\n                     rsel        = 1'b0;\n                     rce         = 1'b1;\n                     cen         = 1'b1; \n                     stack_re    = 1'b0;  \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00; \n                     b_mux_sel   = 2'b11; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0; \n                     stack_we    = 1'b0;\n                  end                    \n     7'b01010x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b1;\n                     rce         = 1'b0;\n                     cen         = 1'b0; \n                     stack_re    = 1'b0;  \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b01011x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0;\n                     rce         = 1'b1;\n                     cen         = 1'b0; \n                     stack_re    = 1'b0;  \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0; \n                     push        = 1'b1; \n                     stack_we    = 1'b1; \n                  end   \n     7'b01100x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0;\n                     rce         = 1'b1;\n                     cen         = 1'b0; \n                     stack_re    = 1'b0; \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b1; \n                     push        = 1'b1; \n                     stack_we    = 1'b1; \n                  end\n     7'b01101x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0;\n                     rce         = 1'b1;\n                     cen         = 1'b0; \n                     stack_re    = 1'b1; \n                     pop         = 1'b1; \n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b01; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0; \n                     push        = 1'b0; \n                     stack_we    = 1'b0; \n                  end    \n    7'b01110x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0;\n                     rce         = 1'b1;\n                     cen         = 1'b0; \n                     stack_re    = 1'b1; \n                     pop         = 1'b1; \n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b01; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0; \n                     push        = 1'b0; \n                     stack_we    = 1'b0; \n                 end    \n    7'b01111x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0;\n                     rce         = 1'b1;\n                     cen         = 1'b0; \n                     stack_re    = 1'b1; \n                     pop         = 1'b1; \n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b0; \n                     src_sel     = 1'b0; \n                     push        = 1'b0; \n                     stack_we    = 1'b0; \n                  end\n     7'b1xxxx10 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                   end \n     7'b1000000 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b01;\n                     b_mux_sel   = 2'b10;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b1000100 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00;\n                     b_mux_sel   = 2'b10;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n    7'b1001000 :  begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10;\n                     b_mux_sel   = 2'b10; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end  \n    7'b1001100 :  begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00;\n                     b_mux_sel   = 2'b11;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;  \n                  end\n    7'b1010000 :  begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00;\n                     b_mux_sel   = 2'b00;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0; \n                  end  \n                   \n    7'b1010100 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b01;\n                     b_mux_sel   = 2'b00;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;  \n                 end                    \n    7'b1011000 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b01;\n                     b_mux_sel   = 2'b10; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b1;\n                     stack_we    = 1'b1;\n                 end\n    7'b1011100 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00;\n                     b_mux_sel   = 2'b10; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b1;\n                     stack_we    = 1'b1; \n                 end\n    7'b1100000 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10;\n                     b_mux_sel   = 2'b10; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b1;\n                     stack_we    = 1'b1; \n                 end\n    7'b1100100 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00;\n                     b_mux_sel   = 2'b11; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b1;\n                     stack_we    = 1'b1;\n                 end\n    7'b1101000 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00;\n                     b_mux_sel   = 2'b00;\n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b1;\n                     stack_we    = 1'b1; \n                 end\n    7'b1101100 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b01;\n                     b_mux_sel   = 2'b00;\n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b1;\n                     stack_we    = 1'b1; \n                end \n   7'b1110000 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b1;\n                     pop         = 1'b1;\n                     a_mux_sel   = 2'b10;\n                     b_mux_sel   = 2'b01;\n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0; \n                end\n   7'b1110100 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b1; \n                     pop         = 1'b1;\n                     a_mux_sel   = 2'b00;\n                     b_mux_sel   = 2'b01;\n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;  \n               end\n  7'b1111000 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0; \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10;\n                     b_mux_sel   = 2'b00;\n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b0; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0; \n               end\n  7'b1111100 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0; \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10;\n                     b_mux_sel   = 2'b00;\n                     oen         = 1'b0; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b0; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                end        \n    default   : begin\n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b0; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0; \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10;\n                     b_mux_sel   = 2'b10;\n                     oen         = 1'b0; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b0; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                   end \n     endcase\n  end\nendmodule\n\n\nmodule full_adder (\n    input  logic [3:0] a_in,\n    input  logic [3:0] b_in,\n    input  logic cen,\n    input  logic c_in,\n    output logic [3:0] y_out,\n    output logic c_out,\n    output logic g_out,\n    output logic p_out\n);\n    \n    logic g[3:0];\n    logic p[3:0];\n    logic c[4:0];\n\n    assign g[0]  = a_in[0] & b_in[0];\n    assign g[1]  = a_in[1] & b_in[1];\n    assign g[2]  = a_in[2] & b_in[2];\n    assign g[3]  = a_in[3] & b_in[3];\n\n    assign p[0]  = a_in[0] ^ b_in[0];\n    assign p[1]  = a_in[1] ^ b_in[1];\n    assign p[2]  = a_in[2] ^ b_in[2];\n    assign p[3]  = a_in[3] ^ b_in[3];\n    \n    assign c[0]  = c_in;\n    assign c[1]  = g[0] | (p[0] & c[0]);\n    assign c[2]  = g[1] | (g[0] & p[1]) | (c[0] & p[0] & p[1]);\n    assign c[3]  = g[2] | (g[1] & p[2]) | (g[0] & p[1] & p[2]) | (c[0] & p[0] & p[1] & p[2]);\n    assign c[4]  = g[3] | (g[2] & p[3]) | (g[1] & p[2] & p[3]) | (g[0] & p[1] & p[2] & p[3]) | (c[0] & p[0] & p[1] & p[2] & p[3]);\n\n    assign y_out[0]  = cen ? p[0] ^ c[0] : p[0];\n    assign y_out[1]  = cen ? p[1] ^ c[1] : p[1];\n    assign y_out[2]  = cen ? p[2] ^ c[2] : p[2];\n    assign y_out[3]  = cen ? p[3] ^ c[3] : p[3];\n    assign p_out = p[0] & p[1] & p[2] & p[3];\n    assign g_out = g[3] | (g[2] & p[3]) | (g[1] & p[3] & p[2]) | (g[0] & p[3] & p[2] & p[1]);\n    assign c_out = c[4];\nendmodule\n\nmodule aux_reg_mux (\n  input logic [3:0] reg1_in, \n  input logic [3:0] reg2_in, \n  input logic rsel,\n  input logic re,\n  output logic [3:0] reg_mux_out\n);\n\nassign reg_mux_out = (~re & rsel) ? reg1_in : reg2_in;\nendmodule\n\nmodule aux_reg (\n    input logic clk,\n    input logic [3:0] reg_in,\n    input logic rce,\n    input logic re,\n    output logic [3:0] reg_out\n);\n always_ff@(posedge clk) begin\n   if(rce | ~re) \n    reg_out <= reg_in;\n end\nendmodule\n\nmodule a_mux (\n  input logic [3:0] register_data,\n  input logic [3:0] data_in,\n  input logic [1:0] a_mux_sel,\n  output logic [3:0] a_mux_out\n);\nalways_comb begin\n  case(a_mux_sel) \n      2'b00 : a_mux_out = data_in;\n      2'b01 : a_mux_out = register_data;\n      2'b10 : a_mux_out = 4'b0000;\n      default : a_mux_out = 4'b0000;\n  endcase\nend\nendmodule\n\nmodule b_mux (\n  input logic [3:0] register_data,\n  input logic [3:0] stack_data,\n  input logic [3:0] pc_data,\n  input logic [1:0] b_mux_sel,\n  output logic [3:0] b_mux_out\n);\n\nalways_comb begin\n    case(b_mux_sel)\n      2'b00 : b_mux_out = pc_data;\n      2'b01 : b_mux_out = stack_data;\n      2'b10 : b_mux_out = 4'b0000;\n      2'b11 : b_mux_out = register_data;\n      default : ;\n    endcase\nend\nendmodule\n\nmodule microcode_arithmetic ( \n  input  logic clk,\n  input  logic [3:0] fa_in,\n  input  logic [3:0] d_in,\n  input  logic [3:0] stack_data_in,\n  input  logic [3:0] pc_data_in,\n  input  logic       reg_en,\n  input  logic       oen,\n  input  logic       rsel,\n  input  logic       rce,\n  input  logic       cen,\n  input  logic [1:0] a_mux_sel,\n  input  logic [1:0] b_mux_sel,\n  input  logic       arith_cin,\n  output logic       arith_cout,\n  output logic       arith_g_out,\n  output logic       arith_p_out,\n  input  logic       oe,\n  output logic [3:0] d_out\n);\n\nlogic [3:0] fa_out_w;\nlogic [3:0] reg_mux_out_w;\nlogic [3:0] reg_out_w;\nlogic [3:0] a_mux_out_w;\nlogic [3:0] b_mux_out_w;\n\n\naux_reg_mux dut_1 (\n  .reg1_in     (fa_in),\n  .reg2_in     (d_in),\n  .rsel        (rsel),\n  .re          (reg_en),\n  .reg_mux_out (reg_mux_out_w)\n);\n\naux_reg dut_2 (\n    .clk     (clk),\n    .reg_in  (reg_mux_out_w),\n    .rce     (rce),\n    .re      (reg_en),\n    .reg_out (reg_out_w)\n);\n\na_mux dut_3(\n  .register_data(reg_out_w),\n  .data_in      (d_in),\n  .a_mux_sel    (a_mux_sel),\n  .a_mux_out    (a_mux_out_w)\n);\n\nb_mux dut_4(\n  .register_data  (reg_out_w),\n  .stack_data     (stack_data_in),\n  .pc_data        (pc_data_in),\n  .b_mux_sel      (b_mux_sel),\n  .b_mux_out      (b_mux_out_w)\n);\n\nfull_adder dut_5 (\n  .a_in  (a_mux_out_w),\n  .b_in  (b_mux_out_w),\n  .cen   (cen),\n  .c_in  (arith_cin),\n  .y_out (fa_out_w),\n  .c_out (arith_cout),\n  .g_out (arith_g_out),\n  .p_out (arith_p_out)\n);\nassign d_out = oen & ~oe ? fa_out_w : 4'bzzzz;\nendmodule\n \nmodule result_register ( \n  input  logic clk,\n  input  logic [3:0] data_in,\n  input  logic out_ce,\n  output logic [3:0] data_out\n);\nalways_latch begin\n   if(out_ce)\n     data_out = data_in;\nend\nendmodule    \n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    for line in lines[2:]:\n        info = line.split()\n        while len(info) < 3:\n            info.append(\"0%\")\n        inst = re.sub(r'[\\W]', '', info[0])\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'dut' is missing in the coverage log.\")\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))\n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['dut']['Average']}, Target: {target}\"\n"}}}
{"id": "cvdp_copilot_montgomery_0006", "categories": ["cid014", "medium"], "input": {"prompt": "Add SytemVerilog Assertions (SVA) for the`montgomery_mult` module designed to use the `montgomery_redc` module to compute modular multiplication of unsigned integers without directly performing division operations. The module calculates the result of the modular multiplication: `result = (a * b) mod N`.  \n\n## **Parameters**\n\n`N`: The modulus used for reduction. \n`R`: A Montgomery parameter, typically chosen as a power of 2.\n`R_INVERSE`: The modular inverse of  R modulo N, satisfying (R* R<sup>-1</sup>) mod N=1\n`NWIDTH`: The bit-width of the numbers involved, computed as  log2(N). \n\n## **Inputs**\n\n`clk`: Clock signal. \n`rst_n`: Active-low Asynchronous reset signal. \n`a`:  First input operand of bit width `NWIDTH`.\n`b`:  Second input operand of bit width `NWIDTH`.\n`valid_in`: Active High control signal indicating valid input data. \n\n## **Outputs**\n\n`result`: Montgomery multiplication result of `a` and `b`, reduced modulo `N`.\n`valid_out`: An active high 1-bit control signal indicating valid output data. \n\n## **Assertions:**\n\n1. Pipeline stability: Ensure the pipeline is stable by checking if the intermediate signals (`valid_in_q`, `valid_in_q1`, `valid_in_q2`, `valid_out_q`) are asserted each after 1 clock cycle. (after an input valid is received)\n\n2. Zero Result: If either `a` or `b` is zero, the `result` must be zero after 4 clock cycles. \n\n3. Modular Multiplication Property - When `valid_in` is set to 1, the result must be equal to `(a * b) mod N` after 4 clock cycles, ensuring correctness.\n\n4. Stability of Valid Signal - Ensure `valid_out` is asserted 4 clock cycles after `valid_in`.\n\n5. Assertions should also be added to check the following conditions related to parameters: Selection of N, R and R_INVERSE should satisfy the following:\n\n    - Radix R, is a number greater than N (R > N).\n    - R is chosen to be a power of 2.\n    - Chosen modulus N is greater than 2 and a coprime with R (R and N must not share any common factors other than 1). We assume N is a prime number so that any choice of R (under the above conditions) is coprime to N.\n    - Let R<sup>-1</sup> be an integer such that:\n        - 0 < R<sup>-1</sup> < N, where R<sup>-1</sup> is the multiplicative inverse in the N-residue system.\n        - The following equation must be satisfied: (R* R<sup>-1</sup>) mod N=1", "context": {"rtl/montgomery_redc.sv": "module montgomery_mult #\n(\n    parameter N = 7,              \n    parameter R = 8,              \n    parameter R_INVERSE = 1,\n    parameter NWIDTH = $clog2(N),\n    parameter TWIDTH = $clog2(N*R)   \n\n    )(\n    input clk ,\n    input rst_n,\n    input  wire [NWIDTH-1:0] a,b, \n    input valid_in,  \n    output wire [NWIDTH-1:0] result ,\n    output valid_out\n);\n    \n    \n    localparam  R_SQUARE  =  (R*R)%N;\n\n    reg [NWIDTH-1:0] a_q,b_q;\n\n    wire [NWIDTH-1:0] a_redc, b_redc , ab_redc;\n    reg [NWIDTH-1:0] a_redc_q, b_redc_q ;\n\n    wire [NWIDTH-1:0] result_d ;\n    reg [NWIDTH-1:0] result_q ;\n\n    reg valid_in_q, valid_in_q1, valid_in_q2 ;\n    reg valid_out_q ;\n    wire [TWIDTH-1:0] ar2 = a_q * R_SQUARE ; \n    wire [TWIDTH-1:0] br2 = b_q * R_SQUARE ; \n\n    wire [TWIDTH-1:0] a_redc_x_b_redc ;\n    reg [TWIDTH-1:0] ab_redc_q ;\n    \n    assign a_redc_x_b_redc = a_redc_q * b_redc_q ;\n    assign result = result_q;\n    assign valid_out = valid_out_q ;\n    always_ff @( posedge clk or negedge rst_n ) begin : valid_out_pipeline\n        if (!rst_n) begin\n            valid_in_q      <=  0 ; \n            valid_in_q1     <=  0 ; \n            valid_in_q2     <=  0 ; \n            valid_out_q     <=  0 ; \n        end else begin\n            valid_in_q      <=  valid_in        ;     \n            valid_in_q1     <=  valid_in_q      ;   \n            valid_in_q2     <=  valid_in_q1     ; \n            valid_out_q     <=  valid_in_q2     ; \n        end \n    end\n\n    always_ff @( posedge clk or negedge rst_n ) begin : input_registers\n        if (!rst_n) begin\n            a_q <= 0 ;\n            b_q <= 0 ;\n        end else begin\n            if(valid_in) begin\n                a_q <= a ;\n                b_q <= b ;\n            end\n        end \n    end\n\n    always_ff @( posedge clk or negedge rst_n ) begin : a_b_reduction_pipeline\n        if (!rst_n) begin\n            a_redc_q <= 0 ;\n            b_redc_q <= 0 ;\n        end else begin\n            a_redc_q <= a_redc ;\n            b_redc_q <= b_redc ;\n        end \n    end\n\n    always_ff @( posedge clk or negedge rst_n ) begin : ab_redc_pipeline\n        if (!rst_n) begin\n            ab_redc_q <= 0 ;\n        end else begin\n            ab_redc_q <= ab_redc; \n        end \n    end\n\n    always_ff @( posedge clk or negedge rst_n ) begin : output_register\n        if (!rst_n) begin\n            result_q <= 0 ;\n        end else begin\n            result_q <= result_d ;\n        end \n    end\n\n    montgomery_redc #\n    (\n        .N (N),\n        .R (R),\n        .R_INVERSE(R_INVERSE)     \n    ) ar2_redc (\n        .T(ar2),    \n        .result(a_redc) \n    );\n    \n    montgomery_redc #\n    (\n        .N (N),\n        .R (R),\n        .R_INVERSE(R_INVERSE)     \n    ) br2_redc (\n        .T(br2),    \n        .result(b_redc) \n    );\n\n    montgomery_redc #\n    (\n        .N (N),\n        .R (R),\n        .R_INVERSE(R_INVERSE)     \n    ) prod_redc (\n        .T(a_redc_x_b_redc),    \n        .result(ab_redc) \n    );\n\n    montgomery_redc #\n    (\n        .N (N),\n        .R (R),\n        .R_INVERSE(R_INVERSE)     \n    ) result_redc (\n        .T(ab_redc_q),    \n        .result(result_d) \n    );\n\nendmodule\n\nmodule montgomery_redc #\n(\n    parameter N = 7,              \n    parameter R = 8,              \n    parameter R_INVERSE = 1,\n    parameter NWIDTH = $clog2(N), \n    parameter TWIDTH = $clog2(N*R)     \n)(\n    input  wire [TWIDTH-1:0] T,    \n    output wire [NWIDTH-1:0] result \n);\n    // Derived parameters\n    localparam RWIDTH = $clog2(R);          \n    localparam TWO_NWIDTH = $clog2(2*N)   ;              \n    localparam [RWIDTH-1:0] N_PRIME = (R * R_INVERSE - 1) / N; \n\n    wire [RWIDTH-1:0] T_mod_R;               \n    wire [2*RWIDTH-1:0] T_mod_R_X_N_PRIME;      \n    wire [RWIDTH-1:0] m;                     \n    wire [TWO_NWIDTH-1:0] t;                      \n\n    assign T_mod_R = T[RWIDTH-1:0];\n\n    assign T_mod_R_X_N_PRIME = T_mod_R * N_PRIME;\n\n    assign m = T_mod_R_X_N_PRIME[RWIDTH-1:0];\n\n    assign t = (T + m * N) >> RWIDTH;\n\n    assign result = (t >= N) ? (t - N) : t;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/montgomery_redc.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/montgomery_redc.sv\nTOPLEVEL        = montgomery_mult\nMODULE          = test_montgomery_mult\nPYTHONPATH      = /src\nHASH            = 6-rtl-assertion-design-montgomery-multiplier", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\ndef redc(T, N, R, N_PRIME):\n    m = ((T%R)*N_PRIME)%R\n    \n    t = (T+ m*N)//R\n    if t>=N:\n        t = t-N\n    else:\n        t = t\n    return t\n\ndef mod_mult(a, b, N):\n    return a*b%N\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build -vcd dumpon\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0", "src/test_montgomery_mult.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport harness_library as hrs_lb\n\n\n@cocotb.test()\nasync def test_montgomery_mult(dut): \n   N = int (dut.N.value)\n   clock_period_ns = 10  # For example, 10ns clock period\n   cocotb.start_soon(Clock(dut.clk, clock_period_ns, units='ns').start())\n   await hrs_lb.dut_init(dut)\n   \n   dut.rst_n.value = 0\n   await Timer(5, units=\"ns\")\n\n   dut.rst_n.value = 1 \n\n   outputs_list = []\n   await RisingEdge(dut.clk)\n   for i in range(50):\n      a = random.randint(0, N-1)\n      b = random.randint(0, N-1)\n      print(\"a: \", a)\n      print(\"b: \", b)\n      print(\"N: \", N)\n      print(\"R: \", dut.R)\n      golden_result = hrs_lb.mod_mult(a,b, N)\n      await FallingEdge(dut.clk)\n      dut.a.value = a\n      dut.b.value = b\n      dut.valid_in.value = 1 \n      await FallingEdge(dut.clk)\n      dut.valid_in.value = 0 \n        \n      latency = 0 \n      while (dut.valid_out.value != 1):\n         await RisingEdge(dut.clk)\n         latency = latency + 1\n       \n      dut_result = int (dut.result.value)\n      assert latency == 4, f\"Valid output should have latency of 2 clk cycles\"\n      assert dut_result == golden_result , f\"Output doesn't match golden output: dut_output {hex(dut_result)}, Expected output {hex(golden_result)}\"\n   \n   for i in range(200):\n      a = random.randint(0, N-1)\n      b = random.randint(0, N-1)\n      golden_result = hrs_lb.mod_mult(a,b, N)\n      outputs_list.append(golden_result)\n      await FallingEdge(dut.clk)\n      dut.a.value = a\n      dut.b.value = b\n      dut.valid_in.value = 1\n      if i>3:\n          expected_result =  outputs_list.pop(0)\n          dut_result = int (dut.result.value) \n          assert dut_result == expected_result, \" Failure!\"\n          ", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nfrom math import gcd\n\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner(WIDTH, N, R, R_INVERSE):\n   \n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            parameter= {'N':N, 'R':R, 'R_INVERSE': R_INVERSE},\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n        hrs_lb.xrun_tb()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\ndef is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef modular_inverse(a, mod):\n    \"\"\"Find the modular inverse of a mod mod.\"\"\"\n    for x in range(1, mod):\n        if (a * x) % mod == 1:\n            return x\n    return None\n\ndef ranomize_test_param():\n    WIDTH = 32\n    while True:\n        N = random.randint(2, 1000)\n        if not is_prime(N):\n            continue\n\n        R = 2**random.randint(2,10)\n        if R <= N:\n            continue\n\n        # Compute R_INVERSE (modular inverse of R mod N)\n        R_INVERSE = modular_inverse(R, N)\n        if R_INVERSE is None:\n            continue\n\n        # Ensure all constraints are satisfied\n        if gcd(R, N) == 1:  # R and N must be coprime (ensured since N is prime)\n            break\n    return(WIDTH, N, R, R_INVERSE)\n\ndef test_redc():\n    for _ in range(5):\n        WIDTH, N, R, R_INVERSE = ranomize_test_param()\n        call_runner(WIDTH, N, R, R_INVERSE)\n"}}}
{"id": "cvdp_copilot_morse_code_0024", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the SystemVerilog testbench `tb_morse_encoder` to add the functionality of checker to test the `morse_encoder` module. The testbench provided in the context already has stimulus generator for many test cases. The purpose of the testbench checker is to verify the functionality of the Morse Encoder against the given design specification.\n\n---\n\n### Design Specification:\n\nA Morse encoder is a digital circuit that converts ASCII characters (A, 0-9) into their corresponding Morse code representation. The Morse encoder module outputs a 6-bit Morse code and its associated length. If the input character is not supported (invalid input), the encoder should output `morse_out` = 6'b000000 and `morse_length` = 4'b0000. The design follows combinational logic.\n\n---\n#### Morse Code Mappings:\n\n| ASCII Input | Character | Morse Code | Morse Output (6 bits) | Length |\n|-------------|-----------|------------|-----------------------|--------|\n| 8'h41       | A         | .-         | 6'b01                 | 2      |\n| 8'h42       | B         | -...       | 6'b1000               | 4      |\n| 8'h43       | C         | -.-.       | 6'b1010               | 4      |\n| 8'h44       | D         | -..        | 6'b100                | 3      |\n| 8'h45       | E         | .          | 6'b1                  | 1      |\n| 8'h46       | F         | ..-.       | 6'b0010               | 4      |\n| 8'h47       | G         | --.        | 6'b110                | 3      |\n| 8'h48       | H         | ....       | 6'b0000               | 4      |\n| 8'h49       | I         | ..         | 6'b00                 | 2      |\n| 8'h4A       | J         | .---       | 6'b0111               | 4      |\n| 8'h4B       | K         | -.-        | 6'b101                | 3      |\n| 8'h4C       | L         | .-..       | 6'b0100               | 4      |\n| 8'h4D       | M         | --         | 6'b11                 | 2      |\n| 8'h4E       | N         | -.         | 6'b10                 | 2      |\n| 8'h4F       | O         | ---        | 6'b111                | 3      |\n| 8'h50       | P         | .--.       | 6'b0110               | 4      |\n| 8'h51       | Q         | --.-       | 6'b1101               | 4      |\n| 8'h52       | R         | .-.        | 6'b010                | 3      |\n| 8'h53       | S         | ...        | 6'b000                | 3      |\n| 8'h54       | T         | -          | 6'b1                  | 1      |\n| 8'h55       | U         | ..-        | 6'b001                | 3      |\n| 8'h56       | V         | ...-       | 6'b0001               | 4      |\n| 8'h57       | W         | .--        | 6'b011                | 3      |\n| 8'h58       | X         | -..-       | 6'b1001               | 4      |\n| 8'h59       | Y         | -.--       | 6'b1011               | 4      |\n| 8'h5A       | Z         | --..       | 6'b1100               | 4      |\n| 8'h30       | 0         | -----      | 6'b11111              | 5      |\n| 8'h31       | 1         | .----      | 6'b01111              | 5      |\n| 8'h32       | 2         | ..---      | 6'b00111              | 5      |\n| 8'h33       | 3         | ...--      | 6'b00011              | 5      |\n| 8'h34       | 4         | ....-      | 6'b00001              | 5      |\n| 8'h35       | 5         | .....      | 6'b00000              | 5      |\n| 8'h36       | 6         | -....      | 6'b10000              | 5      |\n| 8'h37       | 7         | --...      | 6'b11000              | 5      |\n| 8'h38       | 8         | ---..      | 6'b11100              | 5      |\n| 8'h39       | 9         | ----.      | 6'b11110              | 5      |\n---\n\n####  Edge Cases:\n\nInvalid inputs should produce `morse_out` = 6'b000000 and `morse_length` = 4'b0000.\n\n---\n\n### Example Operations:\n\n#### Example 1: Encoding a Valid Input\n\n- Input:` ascii_in` = 8'h41 (A)\n- Expected Output: `morse_out` = 6'b01,` morse_length `= 2\n- Example 2: Encoding an Invalid Input\n- Input: `ascii_in` = 8'h20 (Space, invalid character)\n- Expected Output: `morse_out` = 6'b000000, `morse_length` = 4'b0000\n\n---\n\n### Checker Requirements\n\n- Implement a function to calculate the expected values of `morse_out` and `morse_length` for a given ASCII input (`ascii_in`).\n- Compare the module outputs (`morse_out` and `morse_length`) with the calculated expected values.\n- Log errors if the outputs do not match the expected values.\n- Print success messages for passing test cases.\n- Ensure that the checker operates on all the stimulus generated test cases\n\n\n#### Deliverables\n\n- Provide a modified Verilog testbench implementation that meets the above requirements and verifies the functionality of the `morse_encoder` module.", "context": {"verif/tb.sv": "module tb_morse_encoder;\n\n    reg [7:0] ascii_in;\n    wire [5:0] morse_out;\n    wire [3:0] morse_length;\n\n    morse_encoder uut (\n        .ascii_in(ascii_in),\n        .morse_out(morse_out),\n        .morse_length(morse_length)\n    );\n\n    initial begin\n        $display(\"Running testbench for morse_encoder...\");\n\n        ascii_in = 8'h41; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h42; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h43; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h44; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h45; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h46; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h47; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h48; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h49; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h4A; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h4B; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h4C; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h4D; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h4E; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h4F; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h50; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h51; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h52; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h53; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h54; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h55; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h56; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h57; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h58; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h59; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h5A; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n\n        ascii_in = 8'h30; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h31; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h32; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h33; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h34; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h35; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h36; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h37; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h38; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n        ascii_in = 8'h39; #1;\n        $display(\"Input: %c | Output: %b, %d\", ascii_in, morse_out, morse_length);\n\n        $finish;\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/morse_encoder.sv \nHASH            = 2243deb806a74af062dc5fc514bec98b07f7abdf\nNUM_BUGS        = 3\n", "src/morse_encoder.sv": "module morse_encoder (\n    input wire [7:0] ascii_in,       // ASCII input character\n    output reg [5:0] morse_out,      // Morse code output (6 bits max for each letter or digit)\n    output reg [3:0] morse_length    // Length of the Morse code sequence\n);\n\n    always @(*) begin\n        case (ascii_in)\n            8'h41: begin \n                `ifndef BUG_0\n                morse_out = 6'b01;      morse_length = 2; \n                `else\n                morse_out = 6'b101;      morse_length = 3; \n                `endif\n            end\n            8'h42: begin \n                `ifndef BUG_1\n                morse_out = 6'b1000;     morse_length = 4; \n                `else\n                morse_out = 6'b1111;     morse_length = 4; \n                `endif\n            end\n            8'h43: begin \n                `ifndef BUG_2\n                morse_out = 6'b1010;     morse_length = 4; \n                `else\n                morse_out = 6'b0000;     morse_length = 2; \n                `endif\n            end\n            8'h44: begin morse_out = 6'b100;      morse_length = 3; end \n            8'h45: begin morse_out = 6'b1;        morse_length = 1; end \n            8'h46: begin morse_out = 6'b0010;     morse_length = 4; end \n            8'h47: begin morse_out = 6'b110;      morse_length = 3; end \n            8'h48: begin morse_out = 6'b0000;     morse_length = 4; end \n            8'h49: begin morse_out = 6'b00;       morse_length = 2; end \n            8'h4A: begin morse_out = 6'b0111;     morse_length = 4; end \n            8'h4B: begin morse_out = 6'b101;      morse_length = 3; end \n            8'h4C: begin morse_out = 6'b0100;     morse_length = 4; end \n            8'h4D: begin morse_out = 6'b11;       morse_length = 2; end \n            8'h4E: begin morse_out = 6'b10;       morse_length = 2; end \n            8'h4F: begin morse_out = 6'b111;      morse_length = 3; end \n            8'h50: begin morse_out = 6'b0110;     morse_length = 4; end \n            8'h51: begin morse_out = 6'b1101;     morse_length = 4; end \n            8'h52: begin morse_out = 6'b010;      morse_length = 3; end \n            8'h53: begin morse_out = 6'b000;      morse_length = 3; end \n            8'h54: begin morse_out = 6'b1;        morse_length = 1; end \n            8'h55: begin morse_out = 6'b001;      morse_length = 3; end \n            8'h56: begin morse_out = 6'b0001;     morse_length = 4; end \n            8'h57: begin morse_out = 6'b011;      morse_length = 3; end \n            8'h58: begin morse_out = 6'b1001;     morse_length = 4; end \n            8'h59: begin morse_out = 6'b1011;     morse_length = 4; end \n            8'h5A: begin morse_out = 6'b1100;     morse_length = 4; end \n\n            8'h30: begin morse_out = 6'b11111;    morse_length = 5; end \n            8'h31: begin morse_out = 6'b01111;    morse_length = 5; end \n            8'h32: begin morse_out = 6'b00111;    morse_length = 5; end \n            8'h33: begin morse_out = 6'b00011;    morse_length = 5; end \n            8'h34: begin morse_out = 6'b00001;    morse_length = 5; end \n            8'h35: begin morse_out = 6'b00000;    morse_length = 5; end \n            8'h36: begin morse_out = 6'b10000;    morse_length = 5; end \n            8'h37: begin morse_out = 6'b11000;    morse_length = 5; end \n            8'h38: begin morse_out = 6'b11100;    morse_length = 5; end \n            8'h39: begin morse_out = 6'b11110;    morse_length = 5; end \n\n            default: begin\n                morse_out = 6'b0;                 \n                morse_length = 4'b0;\n            end\n        endcase\n    end\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_morse_code_0027", "categories": ["cid012", "easy"], "input": {"prompt": "Complete the given partial SystemVerilog testbench `morse_encoder_tb`. The testbench must instantiate the `morse_encoder` **RTL** module and provide input stimulus for it, focusing exclusively on generating test vectors rather than building a full testbench.  \n\nThe `morse_encoder` module converts an **8-bit ASCII input** into a **6-bit Morse code output** along with the **length** of the Morse representation.\n\n---\n\n## **Description:**\n### **Inputs**:\n\nRegisters:  \n- `ascii_in` (8-bit, `[7:0]`): ASCII character input supplied to the **DUT**.  \n\n### **Outputs**:\n\nRegisters:  \n- `morse_out` (6-bit, `[5:0]`): Encoded Morse representation received from the **DUT**.  \n- `morse_length` (4-bit, `[3:0]`): Length of the Morse code sequence for the given input character.\n\n---\n\n## **Instantiation:**  \nThe testbench instantiates the `morse_encoder` module as **dut** and connects the signals between the module and the testbench.  \nEach input and output from the **DUT** is connected to its corresponding signal in the testbench.\n\n---\n\n## **Input Generation and Validation:**  \n### **Stimulus Generation:**  \nMultiple test cases are applied to verify Morse encoding for different ASCII characters. The output from the **DUT** is monitored using `$display`.\n\n### **Test Cases:**  \n\n- **Alphabet (Uppercase)**  \n  - `ascii_in = 8'h41;` // 'A'  \n  - `ascii_in = 8'h42;` // 'B'  \n  - `ascii_in = 8'h43;` // 'C'  \n  - `ascii_in = 8'h44;` // 'D'  \n  - `ascii_in = 8'h45;` // 'E'  \n  - `ascii_in = 8'h46;` // 'F'  \n  - `ascii_in = 8'h47;` // 'G'  \n  - `ascii_in = 8'h48;` // 'H'  \n  - `ascii_in = 8'h49;` // 'I'  \n  - `ascii_in = 8'h4A;` // 'J'  \n  - `ascii_in = 8'h4B;` // 'K'  \n  - `ascii_in = 8'h4C;` // 'L'  \n  - `ascii_in = 8'h4D;` // 'M'  \n  - `ascii_in = 8'h4E;` // 'N'  \n  - `ascii_in = 8'h4F;` // 'O'  \n  - `ascii_in = 8'h50;` // 'P'  \n  - `ascii_in = 8'h51;` // 'Q'  \n  - `ascii_in = 8'h52;` // 'R'  \n  - `ascii_in = 8'h53;` // 'S'  \n  - `ascii_in = 8'h54;` // 'T'  \n  - `ascii_in = 8'h55;` // 'U'  \n  - `ascii_in = 8'h56;` // 'V'  \n  - `ascii_in = 8'h57;` // 'W'  \n  - `ascii_in = 8'h58;` // 'X'  \n  - `ascii_in = 8'h59;` // 'Y'  \n  - `ascii_in = 8'h5A;` // 'Z'  \n\n- **Numbers (0-9)**  \n  - `ascii_in = 8'h30;` // '0'  \n  - `ascii_in = 8'h31;` // '1'  \n  - `ascii_in = 8'h32;` // '2'  \n  - `ascii_in = 8'h33;` // '3'  \n  - `ascii_in = 8'h34;` // '4'  \n  - `ascii_in = 8'h35;` // '5'  \n  - `ascii_in = 8'h36;` // '6'  \n  - `ascii_in = 8'h37;` // '7'  \n  - `ascii_in = 8'h38;` // '8'  \n  - `ascii_in = 8'h39;` // '9'  \n\n- **Punctuation and Special Characters**  \n  - `ascii_in = 8'h2E;` // '.'  \n  - `ascii_in = 8'h2C;` // ','  \n  - `ascii_in = 8'h3F;` // '?'  \n  - `ascii_in = 8'h27;` // \"'\"  \n  - `ascii_in = 8'h21;` // '!'  \n  - `ascii_in = 8'h2F;` // '/'  \n  - `ascii_in = 8'h28;` // '('  \n  - `ascii_in = 8'h29;` // ')'  \n  - `ascii_in = 8'h26;` // '&'  \n  - `ascii_in = 8'h3A;` // ':'  \n  - `ascii_in = 8'h3B;` // ';'  \n  - `ascii_in = 8'h3D;` // '='  \n  - `ascii_in = 8'h2B;` // '+'  \n  - `ascii_in = 8'h2D;` // '-'  \n  - `ascii_in = 8'h22;` // '\"'  \n  - `ascii_in = 8'h40;` // '@'  \n\n- **Edge Cases and Invalid Inputs**  \n  - `ascii_in = 8'h00;` // NULL  \n  - `ascii_in = 8'hFF;` // Maximum 8-bit value  \n  - `ascii_in = 8'h7B;` // '{'  \n  - `ascii_in = 8'h7F;` // DEL  \n  - `ascii_in = 8'h5D;` // ']'  \n  - `ascii_in = 8'h5B;` // '['  \n  - `ascii_in = 8'h7A;` // 'z' (Lowercase)  \n  - `ascii_in = 8'h7C;` // '|'  \n\n---\n\n## **Reset Handling:**  \nAt the beginning of the test, an **initial condition** is set to ensure the **DUT** starts in a known state. The testbench then applies each test case sequentially.  \n\n---\n\n```verilog\nmodule morse_encoder_tb;\n\n    reg [7:0] ascii_in;\n    wire [5:0] morse_out; \n    wire [3:0] morse_length;\n\n    morse_encoder dut (\n        .ascii_in(ascii_in),\n        .morse_out(morse_out),\n        .morse_length(morse_length)\n    );\n\n    initial begin\n        $display(\"Starting Testbench...\");\n\n       // Insert code here for Test bench \n\nendmodule\n```\n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 208ecc090e1758e03fab1e8fb9fa33c670aef92d\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/morse_encoder.sv": "module morse_encoder (\n    input wire [7:0] ascii_in,       // ASCII input character\n    output reg [5:0] morse_out,      // Morse code output \n    output reg [3:0] morse_length    // Length of the Morse code sequence\n);\n\n    always @(*) begin\n        case (ascii_in)\n            8'h41: begin morse_out = 6'b000001; morse_length = 2; end  \n            8'h42: begin morse_out = 6'b100000; morse_length = 4; end  \n            8'h43: begin morse_out = 6'b101000; morse_length = 4; end  \n            8'h44: begin morse_out = 6'b010000; morse_length = 3; end  \n            8'h45: begin morse_out = 6'b000001; morse_length = 1; end  \n            8'h46: begin morse_out = 6'b001000; morse_length = 4; end  \n            8'h47: begin morse_out = 6'b110000; morse_length = 3; end  \n            8'h48: begin morse_out = 6'b000000; morse_length = 4; end  \n            8'h49: begin morse_out = 6'b000001; morse_length = 2; end  \n            8'h4A: begin morse_out = 6'b011100; morse_length = 4; end  \n            8'h4B: begin morse_out = 6'b101000; morse_length = 3; end  \n            8'h4C: begin morse_out = 6'b010000; morse_length = 4; end  \n            8'h4D: begin morse_out = 6'b110000; morse_length = 2; end  \n            8'h4E: begin morse_out = 6'b100000; morse_length = 2; end  \n            8'h4F: begin morse_out = 6'b111000; morse_length = 3; end  \n            8'h50: begin morse_out = 6'b011000; morse_length = 4; end  \n            8'h51: begin morse_out = 6'b110100; morse_length = 4; end  \n            8'h52: begin morse_out = 6'b010000; morse_length = 3; end  \n            8'h53: begin morse_out = 6'b000000; morse_length = 3; end  \n            8'h54: begin morse_out = 6'b000001; morse_length = 1; end  \n            8'h55: begin morse_out = 6'b001000; morse_length = 3; end  \n            8'h56: begin morse_out = 6'b000100; morse_length = 4; end  \n            8'h57: begin morse_out = 6'b011000; morse_length = 3; end  \n            8'h58: begin morse_out = 6'b100100; morse_length = 4; end  \n            8'h59: begin morse_out = 6'b101100; morse_length = 4; end  \n            8'h5A: begin morse_out = 6'b110000; morse_length = 4; end  \n            8'h30: begin morse_out = 6'b111111; morse_length = 5; end  \n            8'h31: begin morse_out = 6'b011111; morse_length = 5; end  \n            8'h32: begin morse_out = 6'b001111; morse_length = 5; end  \n            8'h33: begin morse_out = 6'b000111; morse_length = 5; end  \n            8'h34: begin morse_out = 6'b000011; morse_length = 5; end  \n            8'h35: begin morse_out = 6'b000001; morse_length = 5; end  \n            8'h36: begin morse_out = 6'b100000; morse_length = 5; end  \n            8'h37: begin morse_out = 6'b110000; morse_length = 5; end  \n            8'h38: begin morse_out = 6'b111000; morse_length = 5; end  \n            8'h39: begin morse_out = 6'b111100; morse_length = 5; end  \n            8'h2E: begin morse_out = 6'b010101; morse_length = 6; end  \n            8'h2C: begin morse_out = 6'b110011; morse_length = 6; end  \n            8'h3F: begin morse_out = 6'b001100; morse_length = 6; end  \n            8'h27: begin morse_out = 6'b011110; morse_length = 6; end  \n            8'h21: begin morse_out = 6'b101011; morse_length = 6; end  \n            8'h2F: begin morse_out = 6'b100010; morse_length = 5; end  \n            8'h28: begin morse_out = 6'b101100; morse_length = 5; end  \n            8'h29: begin morse_out = 6'b101101; morse_length = 6; end  \n            8'h26: begin morse_out = 6'b010000; morse_length = 5; end  \n            8'h3A: begin morse_out = 6'b111000; morse_length = 6; end  \n            8'h3B: begin morse_out = 6'b101010; morse_length = 6; end  \n            8'h3D: begin morse_out = 6'b100001; morse_length = 5; end  \n            8'h2B: begin morse_out = 6'b010100; morse_length = 5; end  \n            8'h2D: begin morse_out = 6'b100001; morse_length = 6; end  \n            8'h22: begin morse_out = 6'b010010; morse_length = 6; end  \n            8'h40: begin morse_out = 6'b011010; morse_length = 6; end  \n            default: begin\n                morse_out = 6'b000000;                 \n                morse_length = 4'b0000;\n            end\n        endcase\n    end\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_moving_average_0025", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `moving_average` module. The assertions should ensure correct reset behavior, memory operations, address control, and output conditions.  \n\n## **RTL Design Overview**  \nThe `moving_average` module implements an **8-sample moving average filter**. It maintains a sliding window of the last **8 input samples**, computing the moving average by **adding the latest sample and subtracting the oldest sample**.  \n\n### **Key Components of the Module**  \n- **`memory`**: Stores the last 8 input samples.  \n- **`sum`**: Maintains the cumulative sum of the stored values.  \n- **`write_address`**: Tracks the position for writing new data.  \n- **`next_address`**: Points to the next read location (oldest sample).  \n- **`read_data`**: Holds the value of the oldest sample being removed from the sum.  \n- **`clk`**: Clock signal. Design is synchronized to the posedge of this clock.  \n- **`reset`**: Synchronous active-high reset signal.  \n- **`enable`**: Active-high signal. Enables write, read, and sum updates.  \n- **`data_in`**: 12-bit input data sample.  \n- **`data_out`**: 12-bit output representing the computed moving average.  \n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n\n- **Memory Reset Behavior:**  \n  - When `reset` is asserted, all memory locations should be **cleared to `0`** at the next clock cycle.  \n\n- **Write Address Validity:**  \n  - `write_address` should always remain **within the valid range** (`0\u20137`).  \n\n- **Read Data Validity:**  \n  - `read_data` should always be **a previously stored value** from `memory`.  \n\n- **Clock Enable Control:**  \n  - When `enable` is **low**, `sum`, `memory`, `write_address`, and `read_data` should **retain their previous values**.  \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.  ", "context": {"rtl/moving_average.sv": "module moving_average(\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input  wire [11 : 0] data_in,\n    output wire [11 : 0] data_out\n);\n\nreg [11 : 0] memory [7 : 0];\nreg [14 : 0] sum;\nreg [2  : 0] write_address;\nwire [2 : 0] next_address;\nreg [11 : 0] read_data;\n\nassign next_address=write_address + 1'b1;\nassign data_out=sum[14 : 3];\n\n    // write current input to memory\n    integer i;\n    always @(posedge clk ) begin\n        if (reset == 1'b1) begin\n            for (i = 0 ;i < 8 ; i = i + 1 ) begin\n                memory[i]<='h0;\n            end\n        end else begin\n            if(enable==1'b1)begin\n                memory[write_address]<=data_in;\n            end\n        end\n    end\n\n    // read the oldest element written to memory\n    always @(posedge clk ) begin\n        if(reset == 1'b1)begin\n            read_data<='h0;\n        end else begin\n            if(enable==1'b1)begin\n                read_data<=memory[next_address];\n            end\n        end\n    end\n\n    // increase the write address to move onto the next data\n    always @(posedge clk ) begin\n        if(reset == 1'b1)begin\n            write_address<='h0;\n        end else begin\n            if(enable==1'b1)begin\n                write_address<=write_address + 1'b1;\n            end\n        end\n    end\n\n    // calculate sum by adding the latest data to the sum and substracting the oldest data\n    always @(posedge clk ) begin\n        if(reset == 1'b1)begin\n            sum<='h0;\n        end else begin\n            if(enable==1'b1)begin\n                sum<=sum+data_in-read_data;\n            end\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/moving_average.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/moving_average.sv\nTOPLEVEL        = moving_average\nMODULE          = test_moving_average\nPYTHONPATH      = /src\nHASH            = 25-create-the-rtl-for-moving-average", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await RisingEdge(dut.clk)\n    dut.reset.value = 1\n\n    await RisingEdge(dut.clk)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def reset_dut(dut, duration_ns = 10):\n    # Restart Interface\n    dut.reset.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    dut.reset.value = 0\n    await Timer(duration_ns, units='ns')\n    dut.reset._log.debug(\"Reset complete\")\n\nasync def enable_dut(dut):\n    # Restart Interface\n    dut.enable.value = 0\n    await RisingEdge(dut.clk)\n    dut.enable.value = 1\n    await RisingEdge(dut.clk)\n    dut.enable._log.debug(\"enable complete\")\n\n\nasync def calculate_moving_average(data_queue, current_sum, new_data, window):\n    if len(data_queue) < window:\n        data_queue.append(new_data)\n        current_sum += new_data\n    else:\n        oldest_data = data_queue.pop(0)\n        current_sum += new_data - oldest_data\n        data_queue.append(new_data)\n\n    expected_avg = current_sum // window\n    \n    return expected_avg, current_sum\n", "src/test_moving_average.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport random\nimport harness_library as hrs_lb\nimport time\n\n@cocotb.test()\nasync def test_moving_average(dut):\n\n    # Start clock\n    cocotb.start_soon(Clock(dut.clk, 2, units='ns').start())\n    cocotb.log.info(\"[INFO] Clock started.\")\n    width = 12\n    window = 8\n\n    cocotb.log.info(f\"WIDTH = {width}, WINDOW_SIZE = {window}\")\n\n    # Initialize DUT\n    await hrs_lb.dut_init(dut) \n    dut.reset.value = 1\n    # Apply reset and enable\n    await hrs_lb.reset(dut)\n    await hrs_lb.enable_dut(dut)\n\n    # Wait for a couple of cycles to stabilize\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n    # Ensure all outputs are zero\n    assert dut.data_out.value == 0, f\"[ERROR] data_out is not zero after reset: {dut.data_out.value}\"\n\n    current_sum = 0\n    data_queue = []\n    previous_expected_avg = None  # Variable to hold the previous cycle's expected average\n    cycle_num = data_in = random.randint(500, 1000)\n    cycle_off_enable = random.randint(1,int(cycle_num/2))\n    cycle_on_enable  = random.randint(cycle_off_enable+1,int(cycle_num*3/4))\n\n    # Just for DEBUG, set to 1\n    debug = 0\n\n    if debug:\n        cocotb.log.info(cycle_off_enable)\n        cocotb.log.info(cycle_on_enable)\n    # Apply random stimulus and check output\n    for cycle in range(cycle_num):  # Run the test for 20 cycles\n        if cycle == cycle_off_enable:\n            # Disable the DUT after {cycle_off_enable} cycles\n            cocotb.log.info(f'[INFO] Disabling DUT after {cycle_off_enable} cycles')\n            dut.enable.value = 0\n\n        if cycle == cycle_on_enable:\n            # Re-enable the DUT after {cycle_on_enable-cycle_off_enable} cycles\n            cocotb.log.info(f'[INFO] Re-enabling DUT after {cycle_on_enable} cycles')\n            dut.enable.value = 1\n\n        # Generate random data input\n        data_in = random.randint(0, 2**width-1)\n        dut.data_in.value = data_in\n        await RisingEdge(dut.clk)\n\n        if dut.enable.value == 1:\n            # Calculate the expected average using the helper function\n            expected_avg, current_sum = await hrs_lb.calculate_moving_average(data_queue, current_sum, data_in, window)\n\n        # Read the DUT output\n        actual_avg = dut.data_out.value\n\n        # Compare the current DUT output with the previous cycle's expected average\n        if previous_expected_avg is not None:\n            assert actual_avg == previous_expected_avg, \\\n                f\"[ERROR] Mismatch at cycle {cycle}: Expected {previous_expected_avg}, got {actual_avg}\"\n\n            if debug:\n                cocotb.log.info(f\"[DEBUG] Cycle {cycle}/{cycle_num}: DUT average = {actual_avg}\")\n                cocotb.log.info(f\"[DEBUG] Cycle {cycle}/{cycle_num}: Testbench average = {previous_expected_avg}\")\n            \n        # Update the previous expected average only if enable is high\n        if dut.enable.value == 1:\n            previous_expected_avg = expected_avg\n\n\n    await hrs_lb.reset(dut)\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n\n    # Disable the module and finish the test\n    dut.enable.value = 0\n    await RisingEdge(dut.clk)\n    cocotb.log.info(\"[INFO] Test completed successfully.\")", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner():\n    parameters = {}\n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n\n@pytest.mark.parametrize(\"test\", range(3))\ndef test_moving_rndm(test):\n  call_runner()\n\n"}}}
{"id": "cvdp_copilot_moving_average_0027", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the given SystemVerilog testbench to implement a **checker** to validate the output of a `moving_average` module, which computes a sliding window average over incoming **12-bit unsigned data**. The **stimulus is already provided**, and the task is to add a checker that verifies that the **DUT (Design Under Test)** correctly computes the moving average over the last 8 input samples.\n\n---\n\n## **Design Details**\n\n### **1. Functional Behavior**\n1. **Moving Average Computation**:  \n   - The module continuously receives **12-bit input samples** (`data_in`) and maintains a **sliding window** of the last **8 samples** stored in an internal memory.  \n   - The output (`data_out`) is computed as:  \n     ```text\n     data_out = (sum of last 8 samples) / 8\n     ```\n   - On each clock cycle, a new `data_in` value is stored in memory while the oldest value is read and removed from the sum.\n\n2. **Continuous Input Processing**:  \n   - The design supports **continuous data input** without waiting for prior computations to complete.  \n   - New values can be provided **every cycle** when `enable` is high.  \n\n3. **Latency**:  \n   - The output reflects a **valid moving average calculation** after **8 valid input samples**.  \n   - If fewer than 8 samples have been received after reset, the output is the sum of available samples divided by 8.  \n   - **`data_out` updates on the clock cycle immediately following `data_in`, meaning it reflects the moving average of all input samples received up to the previous cycle.**  \n\n4. **Reset Behavior**:  \n   - When `reset` is asserted (active high), the output is cleared to `0`, and the internal buffer is also reset.  \n   - After reset is de-asserted, the moving average calculation starts fresh.  \n\n---\n\n## **2. Inputs and Outputs**\n\n### **Inputs**\n- `clk`: Clock signal (positive edge-triggered).  \n- `reset`: Active-high synchronous reset.  \n- `enable`: Active-high signal that enables data processing.  \n- `data_in`: 12-bit input data sample.  \n\n### **Outputs**\n- `data_out`: 12-bit computed moving average output.  \n\n---\n\n## **3. Testbench Requirements**\n\n### **1. Instantiation**\n- The design `moving_average` is instantiated as `moving_average_inst`, with all input and output signals connected.\n\n### **2. Clock Generation**\n- The DUT operates with a **500 MHz clock** (2 ns period). The testbench should ensure proper synchronization with this clock.\n\n### **3. Testbench Components**\n\n#### **Signals**\n- `clk`: Clock signal.  \n- `reset`: Active-high synchronous reset.  \n- `enable`: Active-high signal that enables data processing.  \n- `enable_reg`: Registered version of `enable`, used for verification.  \n- `data_in`: 12-bit input data sample.  \n- `data_out`: 12-bit DUT output (computed moving average).  \n- `exp_data_out`: Expected output computed from stored input samples.  \n- `start_test`: Signal indicating the start of input generation.  \n- `start_test_reg`: Registered version of `start_test`, used for controlling stimulus.  \n- `accum_data_in`: **Buffer storing the last 8 samples** for computing the expected moving average.  \n\n---\n\n## **4. Use of Buffer in Verification and Checker Functionality**\n- **The testbench maintains a buffer (`accum_data_in`) to store the last 8 samples for computing the expected output.**  \n- The verification process works as follows:  \n  1. **When `enable` is asserted, shift `data_in` into `accum_data_in`**, storing the last 8 samples.  \n  2. **Compute `exp_data_out` as the sum of all values in `accum_data_in`, divided by 8.**  \n  3. **Compare `exp_data_out` with `data_out` from the DUT.**  The checker should continuously verify each computation cycle and ensure that new inputs can be provided without blocking.  \n  4. **If a mismatch occurs, log an error using `$error`.**  \n  5. **Continue monitoring until all expected computations have been verified.**   \n\n---\n\n## **6. Simulation Control**\n- Use `$display` statements to log test case execution.  \n- Print a message if all cases pass. Otherwise, report errors and stop the simulation.  \n\n---\n\n## **Expected Deliverables**\n- **SystemVerilog checker** that uses the existing stimulus and verifies the `moving_average` module\u2019s output against expected results using the new checker logic. ", "context": {"verif/tb.sv": "module tb_moving_average ();\n\n// -------------------------------------------------------------------------\n// Parameter Declarations\n// -------------------------------------------------------------------------\nparameter NUM_INPUTS = 100; // Number of test inputs\nparameter MIN_VALUE = 'd0;  // Minimum input value\nparameter MAX_VALUE = 'd2000; // Maximum input value\n\n\n// -------------------------------------------------------------------------\n// Signal Declarations\n// -------------------------------------------------------------------------\nlogic                  clk = 0;      // Clock signal\nlogic                  reset;        // Active-high reset signal\nlogic                  enable;       // Enable signal\nlogic [11:0]           data_in;      // 12-bit input data\nlogic [11:0]           data_out;     // 12-bit output data\nlogic                  start_test = 0; // Start test signal\nlogic                  start_test_reg; // Register to store start_test signal\n\n// -------------------------------------------------------------------------\n// Module Instantiation\n// -------------------------------------------------------------------------\n\n// Instantiate the moving_average module\nmoving_average moving_average_inst (\n    .clk        (clk     ),\n    .reset      (reset   ),\n    .enable     (enable  ),\n    .data_in    (data_in ),\n    .data_out   (data_out)\n);\n\n// -------------------------------------------------------------------------\n// Clock generation\n// -------------------------------------------------------------------------\n// Toggle clock every 1ns (Clock Period = 2ns)\nalways\n    #1 clk = !clk;\n\n// -------------------------------------------------------------------------\n// Initial block to define testbench stimulus\n// -------------------------------------------------------------------------\n\ninitial \nbegin\n    // Apply synchronous reset\n    reset = 1'b1; // Assert reset\n    repeat(20) @(posedge clk); // Hold reset for 20 clock cycles\n    reset = 1'b0; // De-assert reset\n    repeat(20) @(posedge clk); // Wait additional cycles after reset\n\n    $display (\"Applying stimulus . . .\");\n    repeat(2) @(posedge clk);\n    start_test = 1'b1; // Start generating input values\n    repeat(NUM_INPUTS) @(posedge clk); // Generate NUM_INPUTS test values\n    start_test = 1'b0; // Stop input generation\n\n    repeat(2) @(posedge clk);\n    $display (\"Stimulus has been applied\");\n    // End simulation\n    $finish;\nend\n\n// -------------------------------------------------------------------------\n// Start test register logic\n// -------------------------------------------------------------------------\n// Latch the start_test signal into start_test_reg\nalways_ff @(posedge clk)\n    if (reset)\n        start_test_reg <= 1'b0;\n    else  \n        start_test_reg <= start_test;\n\n// -------------------------------------------------------------------------\n// Input Data Generation\n// -------------------------------------------------------------------------\n// Generate random input data when start_test_reg is high\nalways_ff @(posedge clk)\n    if (reset)\n        data_in <= '0; // Reset input data\n    else if (start_test_reg)\n        data_in <= $urandom_range(MIN_VALUE, MAX_VALUE); // Generate random data\n    else\n        data_in <= '0; // Set data_in to zero when test is not active\n\n// -------------------------------------------------------------------------\n// Enable Signal Generation\n// -------------------------------------------------------------------------\n// Enable signal follows start_test_reg\nalways_ff @(posedge clk)\n    if (reset)\n        enable <= '0; // Reset enable signal\n    else if (start_test_reg)\n        enable <= 1'b1; // Enable processing when start_test_reg is high\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 27-checker-for-moving-average\nNUM_BUGS        = 3", "src/moving_average.sv": "module moving_average(\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input  wire [11 : 0] data_in,\n    output wire [11 : 0] data_out\n);\n\nreg [11 : 0] memory [7 : 0];\nreg [14 : 0] sum;\nreg [2  : 0] write_address;\nwire [2 : 0] next_address;\nreg [11 : 0] read_data;\n\nassign next_address=write_address + 1'b1;\nassign data_out=sum[14 : 3];\n\n    // write current input to memory\n    integer i;\n    always @(posedge clk ) begin\n    `ifndef BUG_0\n        if (reset == 1'b1) begin\n    `else\n        if (reset == 1'b0) begin\n    `endif\n            for (i = 0 ;i < 8 ; i = i + 1 ) begin\n                memory[i]<='h0;\n            end\n        end else begin\n            if(enable==1'b1)begin\n            `ifndef BUG_1\n                memory[write_address]<=data_in;\n            `else\n                memory[next_address]<=data_in;\n            `endif\n            end\n        end\n    end\n\n    // read the oldest element written to memory\n    always @(posedge clk ) begin\n    `ifndef BUG_0\n        if (reset == 1'b1) begin\n    `else\n        if (reset == 1'b0) begin\n    `endif\n            read_data<='h0;\n        end else begin\n            if(enable==1'b1)begin\n                read_data<=memory[next_address];\n            end\n        end\n    end\n\n    // increase the write address to move onto the next data\n    always @(posedge clk ) begin\n    `ifndef BUG_0\n        if (reset == 1'b1) begin\n    `else\n        if (reset == 1'b0) begin\n    `endif\n            write_address<='h0;\n        end else begin\n            if(enable==1'b1)begin\n            `ifndef BUG_2\n                write_address<=write_address + 'd1;\n            `else    \n                write_address<=write_address + 'd3;\n            `endif\n            end\n        end\n    end\n\n    // calculate sum by adding the latest data to the sum and substracting the oldest data\n    always @(posedge clk ) begin\n    `ifndef BUG_0\n        if (reset == 1'b1) begin\n    `else\n        if (reset == 1'b0) begin\n    `endif\n            sum<='h0;\n        end else begin\n            if(enable==1'b1)begin\n                sum<=sum+data_in-read_data;\n            end\n        end\n    end\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_nbit_swizzling_0009", "categories": ["cid012", "easy"], "input": {"prompt": "Write a SystemVerilog testbench for a `nbit_swizzling` module that performs bitwise operations on input data based on a selection signal(`sel`). The testbench should only provide a sequence of test cases to the instantiated RTL module for nbit-swizzling transformations based on the selection signal and ensure proper synchronization of different input signals.\n\n## Description\n**Parameters:**\n\n- `DATA_WIDTH`: Defines the data width of the input and output signals. (default: 16)\n\n**Inputs:**\n\n  - `data_in ([DATA_WIDTH-1:0])`: The input data to be swizzled.\n  - `sel ([1:0])`: Selection signal controlling the swizzling mode.\n\n**Outputs:**\n\n  - `data_out([DATA_WIDTH-1:0])`: The swizzled output data.\n\n## Module Description\n\nThe `nbit_swizzling` module takes an N-bit input (`data_in`) and performs different bit-swizzling transformations based on the selection signal (`sel`).\n\nThe behavior of `nbit_swizzling` is controlled by `sel`:   \n\n- **`sel = 2'b00`**: Complete bitwise reversal of `data_in`.  \n- **`sel = 2'b01`**:  Swap upper and lower halves of `data_in`.  \n- **`sel = 2'b10`**:  Swap quarter sections of `data_in`.  \n- **`sel = 2'b11`**:  Swap eighth sections of `data_in`.  \n- **`Default:`** `data_out` equals to `data_in`.\n\n**Edge Cases:**\n\n- `DATA_WIDTH` must be at least 16 and a multiple of 8.\n- The design(`nbit_swizzling`) must be implemented as combinational logic.\n\n## Testbench Requirements\n\n### Module Instantiation:\n\n- The `nbit_swizzling` module should be instantiated as uut, with all input and output signals properly connected. The testbench must achieve **100% coverage** by covering all input cases.\n\n### Input Stimulus Generation\nThe testbench implements six test cases, each designed to validate a specific functionality:\n\n**Test 1: full_reverse**\n- Repeat 1000 times. Set `sel` = 2'b00.\n- Apply random values of `data_in` value in the range 0 to (2**`DATA_WIDTH`)-1.\n\n**Test 2: half_reverse**\n- Repeat 1000 times. Set `sel` = 2'b01.\n- Apply random values of `data_in` value in the range 0 to (2**`DATA_WIDTH`)-1.\n\n**Test 3: quarter_reverse**\n- Repeat 1000 times. Set `sel` = 2'b10.\n- Apply random values of `data_in` value in the range 0 to (2**`DATA_WIDTH`)-1.\n\n**Test 4: eighth_reverse**\n- Repeat 1000 times. Set `sel` = 2'b11.\n- Apply random values of `data_in` value in the range 0 to (2**`DATA_WIDTH`)-1.\n\n**Test 5: unknown_test**\n- Repeat 1000 times. Randomize `data_in`. Set `sel` = 2'bxx.\n- Validate the module's stability across different input patterns.\n\n**Test 6: random_test**\n- Repeat 1000 times. Randomize `sel` and `data_in`.\n- Validate the module's stability across different input patterns.\n\n**Synchronization**\n- After applying the new randomized inputs(`data_in` and `sel`), wait for **#10ns** before checking the outputs.\n\nCan you implement a SystemVerilog testbench with the above specifications to thoroughly validate all test cases?", "context": {}}, "output": {"response": "", "context": {"verif/nbit_swizzling_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n   xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 2ffe2ca151ffbcff09abe53bb2adc5a6ba0d869a\nTARGET          = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/nbit_swizzling.sv": "module nbit_swizzling #(parameter DATA_WIDTH = 64)(\n    input [DATA_WIDTH-1:0] data_in,                                         // Input data of size DATA_WIDTH \n    input [1:0] sel,                \t                                    //  2-bit selection signal \n    output reg [DATA_WIDTH-1:0] data_out                                    // Output data of size DATA_WIDTH \n);\n\ninteger i; //Loop counter\n\nalways @(*) begin\n    case(sel)\n        2'b00: begin\n            for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH-1-i];                      \n            end\n        end\n        \n        2'b01: begin\n            for (i = 0; i < DATA_WIDTH/2; i = i + 1) begin\n                data_out[i]                = data_in[DATA_WIDTH/2-1-i];     \n                data_out[DATA_WIDTH/2 + i] = data_in[DATA_WIDTH-1-i];       \n            end\n        end\n        \n        2'b10: begin\n            for (i = 0; i < DATA_WIDTH/4; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH/4-1-i]; \t\t            \n                data_out[DATA_WIDTH/4 + i]   = data_in[DATA_WIDTH/2-1-i];  \n                data_out[DATA_WIDTH/2 + i]   = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n        end\n        \n        2'b11: begin\n            for (i = 0; i < DATA_WIDTH/8; i = i + 1) begin\n                data_out[i]                  = data_in[DATA_WIDTH/8-1-i];   \n                data_out[DATA_WIDTH/8 + i]   = data_in[DATA_WIDTH/4-1-i];   \n                data_out[DATA_WIDTH/4 + i]   = data_in[3*DATA_WIDTH/8-1-i]; \n                data_out[3*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[5*DATA_WIDTH/8-1-i]; \n                data_out[5*DATA_WIDTH/8 + i] = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[7*DATA_WIDTH/8-1-i]; \n                data_out[7*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n        end\n\n        default: begin\n            data_out = data_in;\t\t\t\t\t\t                        \n        end\n    endcase\nend\n\nendmodule ", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/nbit_swizzling.sv /code/verif/nbit_swizzling_tb.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_nbit_swizzling_0041", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the SystemVerilog testbench `nbit_swizzling_tb` to integrate the functionality of the checker to test the `nbit_swizzling` module. The testbench provided in the context already has stimulus generator for various test cases. The purpose of the testbench checker is to verify the functionality of the `nbit_swizzling` to ensure proper handling of data swizzling scenarios and confirm that the computed results match the expected outputs as per the design specification.\n\n## Design Specifications\n\nThe behavior of a `nbit_swizzling` operation based on different selection (`sel`) mode\n- **2'b00:** Reverses the `data_in`.\n- **2'b01:** Divides `data_in` into two halves and reverses each halves.\n- **2'b10:** Divides `data_in` into four equal quarters and reverses each quarter.\n- **2'b11:** Divides `data_in` into eight equal segments and reverses each segment.\n\n## Testbench Requirements\n**Parameter:**\n\n- `DATA_WIDTH`: Defines the bit-width of the input and output data. The default value is 16.\n\n **Inputs:**\n- `data_in([DATA_WIDTH-1:0])`: The input data that must be swizzled.\n- `sel([1:0])`: A 2-bit selection signal that determines the swizzling mode.\n\n **Outputs:**\n- `data_out([DATA_WIDTH-1:0])`: The output data after the swizzling operation.\n- `expected_data_out([DATA_WIDTH-1:0])`:  used for the verification to compare the `data_in`.\n\n**Edge Cases:**\n- The `DATA_WIDTH` must be greater than or equal to 16 and multiples of 8.\n- The design must follow combinational logic.\n\n**Example:**\n\n`DATA_WIDTH` = 16\n- **Input:** `data_in([DATA_WIDTH-1:0]) = 16'h2a5c`, `sel([1:0]) = 2'b00`\n- **Expected Output:** `data_out([DATA_WIDTH-1:0]) = 16'h3a54`.\n\n\n## Checker Requirements:\nThe testbench should include a checker to validate the `nbit_swizzling` module by implementing the following:\n- DUT instantiation as `uut`.\n- **Calculate_expected_data_out task:**\n    - Compute the `expected_data_out` based on `sel`:\n       - If `sel = 2'b00`, reverse all bits of `data_in`.\n       - If `sel = 2'b01`, divide the `data_in` into two halves and reverse each half.\n       - If `sel = 2'b10`, divide the `data_in` into four quarters and reverse each quarter.\n       - If `sel = 2'b11`, divide the `data_in` into eight segments and reverse each.\n- **Assertions and Verification:**\n    - **Assert:** `data_out === expected data_out`.\n    - Log results(pass/fail) for each test vector with a detailed message.\n- Ensure that the checker operates on all the stimulus-generated test cases.\n\n## Deliverables\nProvide a modified SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `nbit_swizzling` module.", "context": {"verif/nbit_swizzling_tb.sv": "module nbit_swizzling_tb;\n    // Parameter to define the data width\nparameter DATA_WIDTH = 16;\n\nreg [DATA_WIDTH-1:0] data_in;\t\t    // Input data\nreg [1:0] sel;\t\t\t\t            // Selection signal for different swizzling modes\t\t\t\nwire [DATA_WIDTH-1:0] data_out;\t\t    // Output data after swizzling\n\ninteger i;\t\t\t\t                // Loop variable                           \n\n\n\nnbit_swizzling#(.DATA_WIDTH(DATA_WIDTH)) uut_nbit_sizling (\n    .data_in(data_in),\n    .sel(sel),\n    .data_out(data_out)\n);\n\n\ninitial begin\n    repeat(1000) begin\n      sel = 2'b00;\n      data_in = $urandom_range(DATA_WIDTH,(2**DATA_WIDTH)-1);\n      #10; \n      $display(\"-----------------------------------------------------------------------------------------------------------\");\n      $display(\"%t sel = %h, data_in = %h, data_out = %h, expected_data_out = %h\", $time, sel, data_in, data_out,expected_data_out);\n    end\n    repeat(1000) begin\n      sel = 2'b01;\n      data_in = $urandom_range(DATA_WIDTH,(2**DATA_WIDTH)-1);\n      #10; \n      $display(\"-----------------------------------------------------------------------------------------------------------\");\n      $display(\"%t sel = %h, data_in = %h, data_out = %h\", $time, sel, data_in, data_out);\n    end\n    repeat(1000) begin\n      sel = 2'b10;\n      data_in = $urandom_range(DATA_WIDTH,(2**DATA_WIDTH)-1);\n      #10; \n      $display(\"-----------------------------------------------------------------------------------------------------------\");\n      $display(\"%t sel = %h, data_in = %h, data_out = %h\", $time, sel, data_in, data_out);    \n    end\n    repeat(1000) begin\n      sel = 2'b11;\n      data_in = $urandom_range(DATA_WIDTH,(2**DATA_WIDTH)-1);\n      #10; \n      $display(\"-----------------------------------------------------------------------------------------------------------\");\n      $display(\"%t sel = %h, data_in = %h, data_out = %h\", $time, sel, data_in, data_out);\n    end\nend\n\ninitial begin\n$dumpfile(\"dump.vcd\");\n$dumpvars(0,nbit_swizzling_tb);\nend\n    \nendmodule"}}, "output": {"response": "", "context": {"verif/nbit_swizzling_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/nbit_swizzling.sv\nHASH            = dbe9341f40c5b4e60feaac72df09fa2a25d51fe4\nNUM_BUGS        = 2\n", "src/nbit_swizzling.sv": "module nbit_swizzling #(parameter DATA_WIDTH = 64)(\n    input [DATA_WIDTH-1:0] data_in,                                         // Input data of size DATA_WIDTH \n    input [1:0] sel,                \t                                    //  2-bit selection signal \n    output reg [DATA_WIDTH-1:0] data_out                                    // Output data of size DATA_WIDTH \n);\n\ninteger i; //Loop counter\n\nalways @(*) begin\n    case(sel)\n        2'b00: begin\n        `ifndef BUG_0\n            for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH-1-i];                      \n            end\n        `else\n            for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH-7-i];                      \n            end\n        `endif\n        end\n        \n        2'b01: begin\n        `ifndef BUG_1\n            for (i = 0; i < DATA_WIDTH/2; i = i + 1) begin\n                data_out[i]                = data_in[DATA_WIDTH/2-1-i];     \n                data_out[DATA_WIDTH/2 + i] = data_in[DATA_WIDTH-1-i];       \n            end\n        `else\n            for (i = 0; i < DATA_WIDTH/2; i = i + 1) begin\n                data_out[i]                = data_in[DATA_WIDTH-1-i];     \n                data_out[DATA_WIDTH/2 + i] = data_in[DATA_WIDTH-7-i];       \n            end\n        `endif\n        end\n        \n        2'b10: begin\n            for (i = 0; i < DATA_WIDTH/4; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH/4-1-i]; \t\t            \n                data_out[DATA_WIDTH/4 + i]   = data_in[DATA_WIDTH/2-1-i];  \n                data_out[DATA_WIDTH/2 + i]   = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n        end\n        \n        2'b11: begin\n            for (i = 0; i < DATA_WIDTH/8; i = i + 1) begin\n                data_out[i]                  = data_in[DATA_WIDTH/8-1-i];   \n                data_out[DATA_WIDTH/8 + i]   = data_in[DATA_WIDTH/4-1-i];   \n                data_out[DATA_WIDTH/4 + i]   = data_in[3*DATA_WIDTH/8-1-i]; \n                data_out[3*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[5*DATA_WIDTH/8-1-i]; \n                data_out[5*DATA_WIDTH/8 + i] = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[7*DATA_WIDTH/8-1-i]; \n                data_out[7*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n        end\n\n        default: begin\n            data_out = data_in;\t\t\t\t\t\t                        \n        end\n    endcase\nend\n\nendmodule ", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/nbit_swizzling.sv /code/verif/nbit_swizzling_tb.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_nbit_swizzling_0083", "categories": ["cid014", "medium"], "input": {"prompt": "Can you add SystemVerilog assertions to verify the behavior and correctness of the `nbit_swizzling_top` module. The assertions will ensure functional accuracy, detect errors, and confirm adherence to the expected design specifications.\n## Specifications\n### Interface:\n**Parameters:**\n\n- `DATA_WIDTH`: Width of input data. Default is 16.\n- `CRC_WIDTH`:  Width of CRC output. (Default: DATA_WIDTH/2).\n- `POLY`: CRC polynomial. (Default: 8'b11100110).\n- `CODE_WIDTH (DATA_WIDTH + $clog2(DATA_WIDTH + 1))` : Width of Hamming-encoded data.\n\n**Inputs:**\n\n- `clk(1-bit)`:  Clock signal (active on the rising edge).\n- `rst(1-bit)`:  Active-high reset signal.\n- `data_in([DATA_WIDTH-1:0])`:  Input data.\n- `sel [1:0]`: Selection signal for swizzling.\n- `received ([CODE_WIDTH-1:0])`: Received ECC data.\n\n**Outputs:**\n\n- `data_out([DATA_WIDTH:0])`: Swizzled data with appended parity.\n- `encoded([CODE_WIDTH-1:0])`:  Hamming-encoded data.\n- `crc_out([CRC_WIDTH-1:0]`):  CRC output.\n- `error_detected (1-bit)`:  Indicates ECC error detection.\n- `error_corrected (1-bit)`:  Indicates if an error was corrected.\n- `ecc_data_out([DATA_WIDTH-1:0])`: ECC-corrected output.\n\n## Module Overview\n\nThe `nbit_swizzling_top` module integrates three key components:\n\n- **n-bit Swizzling (`nbit_swizzling`):** Rearranges input data based on a 2-bit selection signal (`sel`).\n- **ECC Generator (`one_bit_ecc`):** Implements Hamming encoding for error detection and correction.\n- **CRC Generator (`crc_generator`):** Computes CRC for error detection using a given polynomial (`POLY`).\n\n## Behavioral Specifications\n\n**1. Swizzling Logic (nbit_swizzling)**\n\n- Rearranges bits based on `sel`:\n    - `2'b00`: Reverse the entire data.\n    - `2'b01`: Reverse two halves separately.\n    - `2'b10`: Reverse four quarters separately.\n    - `2'b11`: Reverse eight segments separately.\n- Appends a parity_bit (^data_in).\n\n**2. ECC (`one_bit_ecc`)**\n\n- Encodes input data into an extended Hamming code (`encoded`).\n- Receives potentially corrupted data (`received`) and calculates syndrome bits.\n- Detects single-bit errors and corrects them.\n- Produces error flags (`error_detected` and `error_corrected`).\n- Outputs the corrected data (`ecc_data_out`).\n\n**3. CRC Computation(`crc_generator`)**\n\n- Computes CRC using the given polynomial (`POLY`).\n- Updates CRC sequentially with each input bit.\n- Outputs the CRC checksum (`crc_out`).\n\n## Assertion Requirements\n**1. ECC Error Correction Assertion:**\n\n- Ensures that when an error is detected (`error_detected == 1`), it is subsequently corrected (`error_corrected == 1`).\n\n**2. ECC Data Correctness Assertion:**\n\n- Ensures that when no errors are present (`encoded == received`), the data output remains unchanged (`data_out == ecc_data_out`).\n\n**3. ECC Error Detection and Correction Check:**\n\n- Ensures that when no errors exist (`encoded == received`), `error_detected` and `error_corrected` is set 0.\n\n**4. Full reverse swizzling logic verification:**\n\n- When `sel == 2'b00`, the entire bit sequence must be reversed, and the parity_bit must be appended at the `data_out([DATA_WIDTH])`.\n\n**5. Swap halves swizzling logic verification:**\n\n- When `sel == 2'b01`, the two halves of `data_in` must be reversed separately, and the parity_bit must be appended at the `data_out([DATA_WIDTH])`.\n\n**6. Swap quarters swizzling logic verification:**\n\n- When `sel == 2'b10`, the four quarters of `data_in` must be reversed separately, and the parity_bit must be appended at the `data_out([DATA_WIDTH])`.\n\n**7. Swap eights swizzling logic verification:**\n\n- When `sel == 2'b11`, the eight segments of `data_in` must be reversed separately, and the parity_bit must be appended at the `data_out([DATA_WIDTH])`.\n\n**8. CRC Reset Check:**\n\n- Ensures that when `rst` = 1, `crc_out` is set to 0.\n\n**9. Data Width Consistency Check:**\n\n- Ensures `data_in` and `crc_out` maintain their expected bit widths.\n---\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.\n\n\n\n", "context": {"rtl/nbit_swizzling.sv": "`timescale 1ns / 1ps\nmodule nbit_swizzling_top #(parameter DATA_WIDTH = 16, \n                            parameter CRC_WIDTH = ((DATA_WIDTH)/2), \n                            parameter POLY = 8'b11100110,\n                            parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1)) (\n    input [DATA_WIDTH-1:0] data_in,                          // Input data\n    input clk,                                               // Clock signal\n    input rst,                                               // Reset signal\n    input  [CODE_WIDTH-1: 0]  received, \n    output  [CRC_WIDTH-1:0] crc_out,                         // CRC output  \n    input   [1:0] sel,                \t                     //  2-bit selection signal \n    output  [DATA_WIDTH:0] data_out,                         // Output data of size DATA_WIDTH \n    output  [CODE_WIDTH-1: 0]  encoded,                      //  Output data with hamming code\n    output error_detected,\n    output error_corrected,\n    output [DATA_WIDTH-1:0] ecc_data_out\n\n  \n ); \n  wire [DATA_WIDTH-1:0] swizzled_data;  \n    \n    nbit_swizzling #(.DATA_WIDTH(DATA_WIDTH)) uut_nbit_swizzling(\n    .data_in(data_in),                                        // Input data of size DATA_WIDTH \n    .sel(sel),                \t                              //  2-bit selection signal \n    .data_out(data_out)                                       // Output data of size DATA_WIDTH \n    );\n    \n    assign swizzled_data = data_out[DATA_WIDTH-1:0];\n\n    one_bit_ecc #(.DATA_WIDTH(DATA_WIDTH),\n                            .CODE_WIDTH(CODE_WIDTH)\n    ) uut_ecc(\n    .data_in(data_in),\n    .encoded(encoded),\n    .received(received),\n    .error_detected(error_detected),\n    .error_corrected(error_corrected),\n    .data_out(ecc_data_out)\n    );\n    \n    crc_generator #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .CRC_WIDTH(CRC_WIDTH),\n        .POLY(POLY)\n    ) crc_gen (\n    .data_in(swizzled_data),\n    .clk(clk),\n    .rst(rst),\n    .crc_out(crc_out)\n    );\n\n       \nendmodule\n\n\nmodule nbit_swizzling #(parameter DATA_WIDTH = 64)(\n    input [DATA_WIDTH-1:0] data_in,                                         // Input data of size DATA_WIDTH \n    input [1:0] sel,                \t                                    //  2-bit selection signal \n    output reg [DATA_WIDTH:0] data_out                                      // Output data of size DATA_WIDTH \n);\n\ninteger i; \nwire parity_bit;                                                            \n\n\nassign parity_bit = ^data_in;\n\nalways @(*) begin\n    case(sel)\n        2'b00: begin\n            for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH-1-i];                      \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        \n        2'b01: begin\n            for (i = 0; i < DATA_WIDTH/2; i = i + 1) begin\n                data_out[i]                = data_in[DATA_WIDTH/2-1-i];     \n                data_out[DATA_WIDTH/2 + i] = data_in[DATA_WIDTH-1-i];       \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        \n        2'b10: begin\n            for (i = 0; i < DATA_WIDTH/4; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH/4-1-i]; \t\t            \n                data_out[DATA_WIDTH/4 + i]   = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        \n        2'b11: begin\n            for (i = 0; i < DATA_WIDTH/8; i = i + 1) begin\n                data_out[i]                  = data_in[DATA_WIDTH/8-1-i];   \n                data_out[DATA_WIDTH/8 + i]   = data_in[DATA_WIDTH/4-1-i];   \n                data_out[DATA_WIDTH/4 + i]   = data_in[3*DATA_WIDTH/8-1-i]; \n                data_out[3*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[5*DATA_WIDTH/8-1-i]; \n                data_out[5*DATA_WIDTH/8 + i] = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[7*DATA_WIDTH/8-1-i]; \n                data_out[7*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        default: begin\n            data_out = data_in;\t\n            data_out[DATA_WIDTH] = parity_bit; \t\t\t\t\t                        \n        end\n    endcase\nend\n\n\nfunction automatic logic [DATA_WIDTH-1:0] reverse_bits(input logic [DATA_WIDTH-1:0] input_bits, int N);\n        logic [DATA_WIDTH-1:0] reversed = '0; // Initialize all bits to 0\n        for (int i = 0; i < N; i = i + 1) begin\n            reversed[i] = input_bits[N-1-i];\n        end\n        return reversed;\n    endfunction\n\n    logic [DATA_WIDTH/2-1:0] first_half, second_half;\n    assign first_half  = data_in[DATA_WIDTH/2-1:0];\n    assign second_half = data_in[DATA_WIDTH-1:DATA_WIDTH/2];\n\n    logic [DATA_WIDTH/4-1:0] q1, q2, q3, q4;\n    assign q1 = data_in[DATA_WIDTH/4-1:0];\n    assign q2 = data_in[DATA_WIDTH/2-1:DATA_WIDTH/4];\n    assign q3 = data_in[3*DATA_WIDTH/4-1:DATA_WIDTH/2];\n    assign q4 = data_in[DATA_WIDTH-1:3*DATA_WIDTH/4];\n\n    logic [DATA_WIDTH/8-1:0] e1, e2, e3, e4, e5, e6, e7, e8;\n    assign e1 = data_in[DATA_WIDTH/8-1:0];\n    assign e2 = data_in[DATA_WIDTH/4-1:DATA_WIDTH/8];\n    assign e3 = data_in[3*DATA_WIDTH/8-1:DATA_WIDTH/4];\n    assign e4 = data_in[DATA_WIDTH/2-1:3*DATA_WIDTH/8];\n    assign e5 = data_in[5*DATA_WIDTH/8-1:DATA_WIDTH/2];\n    assign e6 = data_in[3*DATA_WIDTH/4-1:5*DATA_WIDTH/8];\n    assign e7 = data_in[7*DATA_WIDTH/8-1:3*DATA_WIDTH/4];\n    assign e8 = data_in[DATA_WIDTH-1:7*DATA_WIDTH/8];\n\n    always@(*) begin\n        if (sel == 2'b00) begin\n            logic [DATA_WIDTH-1:0] expected_data; \n            expected_data = reverse_bits(data_in, DATA_WIDTH); \n\n        end\n    end\n\n    always@(*) begin\n        if (sel == 2'b01) begin\n            logic [DATA_WIDTH-1:0] expected_data;\n            expected_data[DATA_WIDTH/2-1:0] = reverse_bits(first_half, DATA_WIDTH/2);\n            expected_data[DATA_WIDTH-1:DATA_WIDTH/2] = reverse_bits(second_half, DATA_WIDTH/2);\n        end\n    end\n\n    always@(*) begin\n        if (sel == 2'b10) begin\n            logic [DATA_WIDTH-1:0] expected_data;\n            expected_data[DATA_WIDTH/4-1:0] = reverse_bits(q1, DATA_WIDTH/4);\n            expected_data[DATA_WIDTH/2-1:DATA_WIDTH/4] = reverse_bits(q2, DATA_WIDTH/4);\n            expected_data[3*DATA_WIDTH/4-1:DATA_WIDTH/2] = reverse_bits(q3, DATA_WIDTH/4);\n            expected_data[DATA_WIDTH-1:3*DATA_WIDTH/4] = reverse_bits(q4, DATA_WIDTH/4);\n        end\n    end\n\n    always@(*) begin\n        if (sel == 2'b11) begin\n            logic [DATA_WIDTH-1:0] expected_data;\n            expected_data[DATA_WIDTH/8-1:0] = reverse_bits(e1, DATA_WIDTH/8);\n            expected_data[DATA_WIDTH/4-1:DATA_WIDTH/8] = reverse_bits(e2, DATA_WIDTH/8);\n            expected_data[3*DATA_WIDTH/8-1:DATA_WIDTH/4] = reverse_bits(e3, DATA_WIDTH/8);\n            expected_data[DATA_WIDTH/2-1:3*DATA_WIDTH/8] = reverse_bits(e4, DATA_WIDTH/8);\n            expected_data[5*DATA_WIDTH/8-1:DATA_WIDTH/2] = reverse_bits(e5, DATA_WIDTH/8);\n            expected_data[3*DATA_WIDTH/4-1:5*DATA_WIDTH/8] = reverse_bits(e6, DATA_WIDTH/8);\n            expected_data[7*DATA_WIDTH/8-1:3*DATA_WIDTH/4] = reverse_bits(e7, DATA_WIDTH/8);\n            expected_data[DATA_WIDTH-1:7*DATA_WIDTH/8] = reverse_bits(e8, DATA_WIDTH/8);\n        end\n    end\n\n\nendmodule \n\n\nmodule crc_generator #(\n    parameter DATA_WIDTH = 8,        // Width of input data\n    parameter CRC_WIDTH = 4,        // Width of CRC output\n    parameter POLY = 4'b1101        // Polynomial for CRC\n) (\n    input [DATA_WIDTH-1:0] data_in, // Input data\n    input clk,                      // Clock signal\n    input rst,                      // Reset signal\n    output reg [CRC_WIDTH-1:0] crc_out // CRC output\n);\n    integer i;                     \n    reg [CRC_WIDTH-1:0] crc_reg;  \n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            crc_out <= 0;           \n        end else begin\n            crc_reg = 0;           \n            for (i = DATA_WIDTH - 1; i >= 0; i = i - 1) begin\n                if (crc_reg[CRC_WIDTH-1] ^ data_in[i]) begin\n                    crc_reg = (crc_reg << 1) ^ POLY; \n                end else begin\n                    crc_reg = crc_reg << 1; \n                end\n            end\n            crc_out <= crc_reg;    \n        end\n    end\n\nendmodule\n\nmodule one_bit_ecc #(\n    parameter DATA_WIDTH = 4,                                  // Width of the data input\n    parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1) // Encoded width\n)(\n    input [DATA_WIDTH-1:0] data_in,                     // Input data\n    output reg [CODE_WIDTH-1:0] encoded,                // Encoded output\n    input [CODE_WIDTH-1:0] received,                    // Received encoded data\n    output reg [DATA_WIDTH-1:0] data_out,               // Corrected output\n    output reg error_detected,                          // Error detected flag\n    output reg error_corrected                          // Error corrected flag\n);\n\n    localparam PARITY_BITS = CODE_WIDTH - DATA_WIDTH;   // Number of parity bits\n\n    reg [PARITY_BITS-1:0] syndrome;                     // Syndrome for error detection\n    reg [CODE_WIDTH-1:0] corrected_data;                // Corrected received data\n\n    integer idx_i, idx_j, idx_k;\n    integer idx_m, idx_n;\n    integer idx_p, idx_q;\n\n    always @(*) begin\n        encoded = 0;\n        idx_k = 0;\n\n        for (idx_i = 0; idx_i < CODE_WIDTH; idx_i = idx_i + 1) begin\n            if ((idx_i + 1) & idx_i) begin\n                encoded[idx_i] = data_in[idx_k];\n                idx_k = idx_k + 1;\n            end\n        end\n\n        for (idx_i = 0; idx_i < PARITY_BITS; idx_i = idx_i + 1) begin\n            encoded[(1 << idx_i) - 1] = 0;\n            for (idx_j = 0; idx_j < CODE_WIDTH; idx_j = idx_j + 1) begin\n                if (((idx_j + 1) & (1 << idx_i)) && ((idx_j + 1) != (1 << idx_i))) begin\n                    encoded[(1 << idx_i) - 1] = encoded[(1 << idx_i) - 1] ^ encoded[idx_j];\n                end\n            end\n        end\n    end\n\n    always @(*) begin\n        syndrome = 0;\n        for (idx_m = 0; idx_m < PARITY_BITS; idx_m = idx_m + 1) begin\n            for (idx_n = 0; idx_n < CODE_WIDTH; idx_n = idx_n + 1) begin\n                if ((idx_n + 1) & (1 << idx_m)) begin\n                    syndrome[idx_m] = syndrome[idx_m] ^ received[idx_n];\n                end\n            end\n        end\n    end\n\n    always @(*) begin\n        error_detected = |syndrome;\n    end\n\n    always @(*) begin\n        corrected_data = received;\n        if (error_detected && syndrome <= CODE_WIDTH) begin\n            corrected_data[syndrome - 1] = ~corrected_data[syndrome - 1];\n        end\n    end\n\n    always @(*) begin\n        data_out = 0;\n        idx_q = 0;\n        for (idx_p = 0; idx_p < CODE_WIDTH; idx_p = idx_p + 1) begin\n            if ((idx_p + 1) & idx_p) begin\n                data_out[idx_q] = corrected_data[idx_p];\n                idx_q = idx_q + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        error_corrected = error_detected; \n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/nbit_swizzling.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/nbit_swizzling.sv\nTOPLEVEL        = nbit_swizzling_top\nMODULE          = test_nbit_swizzling_hamming\nPYTHONPATH      = /src\nHASH            = 9bda4d543cd64295c6b712d36ddec4030fff836b\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n\nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_nbit_swizzling_hamming.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nfrom cocotb.triggers import Timer\n\n\ndef reverse_bits(val, width):\n    result = 0\n    for i in range(width):\n        if (val >> i) & 1:\n            result |= 1 << (width - 1 - i)\n    return result\n\n@cocotb.test()\nasync def sanity_check(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n    print(\"DUT is alive, test passes.\")\n\n@cocotb.test()\nasync def test_ecc_error_correction_flag(dut):\n    \"\"\"\n    Test that whenever error_detected is 1, error_corrected is also 1 (assertion p_error_corrected).\n    \"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Bring the design out of reset\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n    # Put in a known data word\n    test_data = 0xB  # Choose any value in range\n    dut.data_in.value = test_data\n    await RisingEdge(dut.clk)\n\n    # Grab the ECC codeword output\n    codeword = int(dut.encoded.value)\n\n    # Flip one bit in codeword to simulate a single-bit error\n    flip_bit = 0  # LSB for example\n    corrupted_codeword = codeword ^ (1 << flip_bit)\n    dut.received.value = corrupted_codeword   # <-- FIXED\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    # Check: if error_detected, then error_corrected must be set\n    if int(dut.error_detected.value) == 1:\n        assert int(dut.error_corrected.value) == 1, (\n            f\"Assertion failed: error_detected=1 but error_corrected={int(dut.error_corrected.value)}\"\n        )\n    else:\n        # If error not detected, nothing to check for this assertion\n        pass\n\n@cocotb.test()\nasync def test_ecc_data_correct_no_error(dut):\n    \"\"\"\n    Test that when encoded == received, data_out == ecc_data_out (assertion p_data_correct).\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n    width = dut.DATA_WIDTH.value\n\n    for test_data in [0x0, 0x1, 0xF, 0xA5, 0x5A]:\n        dut.data_in.value = test_data\n        await RisingEdge(dut.clk)\n\n        encoded = int(dut.encoded.value)\n        dut.received.value = encoded\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n\n        # Only compare the lower DATA_WIDTH bits (exclude parity)\n        data_only = int(dut.data_out.value) & ((1 << width) - 1)\n        ecc_data = int(dut.ecc_data_out.value)\n\n        assert data_only == ecc_data, (\n            f\"Assertion failed: encoded==received, but data_out({bin(data_only)}) != ecc_data_out({bin(ecc_data)})\"\n        )\n\n@cocotb.test()\nasync def test_ecc_error_flags_clear_when_no_error(dut):\n    \"\"\"\n    Test that when encoded == received, both error_detected and error_corrected are 0 (assertion p_error_correct_check).\n    \"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Apply reset\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n    # Try a few patterns\n    for test_data in [0x0, 0x1, 0x5, 0xA, 0xF]:\n        dut.data_in.value = test_data\n        await RisingEdge(dut.clk)\n\n        encoded = int(dut.encoded.value)\n        dut.received.value = encoded\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n\n        assert int(dut.error_detected.value) == 0, (\n            f\"Assertion failed: error_detected should be 0 when encoded==received for data_in={test_data:#x}\"\n        )\n        assert int(dut.error_corrected.value) == 0, (\n            f\"Assertion failed: error_corrected should be 0 when encoded==received for data_in={test_data:#x}\"\n        )\n\n@cocotb.test()\nasync def test_swizzling_sel_00_assertion_pass(dut):\n    \"\"\"\n    Test the assertion for sel == 00: data_out must be reversed data_in, and data_out[DATA_WIDTH] is parity.\n    \"\"\"\n    # No clock needed for pure combinational, but okay if you have one.\n    width = dut.DATA_WIDTH.value if hasattr(dut, \"DATA_WIDTH\") else 16  # Fallback\n\n    # Try a few values for data_in\n    test_vectors = [0x0, 0x1, 0xA5, 0xFFFF, 0x8001, 0x1234, 0x5555, 0xAAAA]\n    for val in test_vectors:\n        dut.data_in.value = val\n        dut.sel.value = 0b00\n        await Timer(1, units=\"ns\")  # let combinational logic settle\n\n        expected_data = reverse_bits(val, width)\n        expected_parity = bin(val).count(\"1\") % 2\n\n        dout = int(dut.data_out.value)\n        data_bits = dout & ((1 << width) - 1)\n        parity_bit = (dout >> width) & 0x1\n\n        assert data_bits == expected_data, (\n            f\"sel=00: data_out reversed({hex(val)}) = {hex(data_bits)}, expected {hex(expected_data)}\"\n        )\n        assert parity_bit == expected_parity, (\n            f\"sel=00: data_out parity({hex(val)}) = {parity_bit}, expected {expected_parity}\"\n        )\n\n@cocotb.test()\nasync def test_swizzling_sel_01_assertion_pass(dut):\n    \"\"\"\n    Test assertion for sel == 01: data_out lower half is reversed lower half, upper half is reversed upper half, and parity bit is correct.\n    \"\"\"\n    width = dut.DATA_WIDTH.value if hasattr(dut, \"DATA_WIDTH\") else 16\n\n    test_vectors = [0x0, 0x1, 0xA5, 0xFFFF, 0x8001, 0x1234, 0x5555, 0xAAAA]\n    for val in test_vectors:\n        dut.data_in.value = val\n        dut.sel.value = 0b01\n        await Timer(1, units=\"ns\")  # let combinational logic settle\n\n        half_width = width // 2\n        lower_mask = (1 << half_width) - 1\n\n        first_half = val & lower_mask\n        second_half = (val >> half_width) & lower_mask\n\n        reversed_first = reverse_bits(first_half, half_width)\n        reversed_second = reverse_bits(second_half, half_width)\n\n        expected_data = (reversed_second << half_width) | reversed_first\n        expected_parity = bin(val).count(\"1\") % 2\n\n        dout = int(dut.data_out.value)\n        data_bits = dout & ((1 << width) - 1)\n        parity_bit = (dout >> width) & 0x1\n\n        assert data_bits == expected_data, (\n            f\"sel=01: data_out for data_in {hex(val)} = {hex(data_bits)}, expected {hex(expected_data)}\"\n        )\n        assert parity_bit == expected_parity, (\n            f\"sel=01: parity for data_in {hex(val)} = {parity_bit}, expected {expected_parity}\"\n        )\n\n@cocotb.test()\nasync def test_swizzling_sel_10_assertion_pass(dut):\n    \"\"\"\n    Test assertion for sel == 10: data_out is quarter-swizzled and parity is correct.\n    \"\"\"\n    width = dut.DATA_WIDTH.value if hasattr(dut, \"DATA_WIDTH\") else 16\n\n    test_vectors = [0x0, 0x1, 0xA5, 0xFFFF, 0x8001, 0x1234, 0x5555, 0xAAAA]\n    for val in test_vectors:\n        dut.data_in.value = val\n        dut.sel.value = 0b10\n        await Timer(1, units=\"ns\")  # let combinational logic settle\n\n        quarter = width // 4\n        mask = (1 << quarter) - 1\n\n        q1 = val & mask\n        q2 = (val >> quarter) & mask\n        q3 = (val >> (2 * quarter)) & mask\n        q4 = (val >> (3 * quarter)) & mask\n\n        reversed_q1 = reverse_bits(q1, quarter)\n        reversed_q2 = reverse_bits(q2, quarter)\n        reversed_q3 = reverse_bits(q3, quarter)\n        reversed_q4 = reverse_bits(q4, quarter)\n\n        expected_data = (\n            (reversed_q4 << (3 * quarter)) |\n            (reversed_q3 << (2 * quarter)) |\n            (reversed_q2 << (1 * quarter)) |\n            (reversed_q1 << 0)\n        )\n        expected_parity = bin(val).count(\"1\") % 2\n\n        dout = int(dut.data_out.value)\n        data_bits = dout & ((1 << width) - 1)\n        parity_bit = (dout >> width) & 0x1\n\n        assert data_bits == expected_data, (\n            f\"sel=10: data_out for data_in {hex(val)} = {hex(data_bits)}, expected {hex(expected_data)}\"\n        )\n        assert parity_bit == expected_parity, (\n            f\"sel=10: parity for data_in {hex(val)} = {parity_bit}, expected {expected_parity}\"\n        )\n\n@cocotb.test()\nasync def test_swizzling_sel_11_assertion_pass(dut):\n    \"\"\"\n    Test assertion for sel == 11: data_out is octal-swizzled and parity is correct.\n    \"\"\"\n    width = dut.DATA_WIDTH.value if hasattr(dut, \"DATA_WIDTH\") else 16\n    eighth = width // 8\n\n    test_vectors = [0x0, 0x1, 0xA5, 0xFFFF, 0x8001, 0x1234, 0x5555, 0xAAAA]\n    for val in test_vectors:\n        dut.data_in.value = val\n        dut.sel.value = 0b11\n        await Timer(1, units=\"ns\")\n\n        # Extract 8 chunks as per RTL\n        e1 = (val >> 0)             & ((1 << eighth) - 1)\n        e2 = (val >> (1 * eighth))  & ((1 << eighth) - 1)\n        e3 = (val >> (2 * eighth))  & ((1 << eighth) - 1)\n        e4 = (val >> (3 * eighth))  & ((1 << eighth) - 1)\n        e5 = (val >> (4 * eighth))  & ((1 << eighth) - 1)\n        e6 = (val >> (5 * eighth))  & ((1 << eighth) - 1)\n        e7 = (val >> (6 * eighth))  & ((1 << eighth) - 1)\n        e8 = (val >> (7 * eighth))  & ((1 << eighth) - 1)\n\n        expected_data = 0\n        # e1 goes into lowest bits, e8 into MSB\n        expected_data |= reverse_bits(e1, eighth) << (0 * eighth)\n        expected_data |= reverse_bits(e2, eighth) << (1 * eighth)\n        expected_data |= reverse_bits(e3, eighth) << (2 * eighth)\n        expected_data |= reverse_bits(e4, eighth) << (3 * eighth)\n        expected_data |= reverse_bits(e5, eighth) << (4 * eighth)\n        expected_data |= reverse_bits(e6, eighth) << (5 * eighth)\n        expected_data |= reverse_bits(e7, eighth) << (6 * eighth)\n        expected_data |= reverse_bits(e8, eighth) << (7 * eighth)\n\n        expected_parity = bin(val).count(\"1\") % 2\n\n        dout = int(dut.data_out.value)\n        data_bits = dout & ((1 << width) - 1)\n        parity_bit = (dout >> width) & 0x1\n\n        assert data_bits == expected_data, (\n            f\"sel=11: data_out for data_in {hex(val)} = {hex(data_bits)}, expected {hex(expected_data)}\"\n        )\n        assert parity_bit == expected_parity, (\n            f\"sel=11: parity for data_in {hex(val)} = {parity_bit}, expected {expected_parity}\"\n        )\n\n@cocotb.test()\nasync def test_crc_reset_assertion_pass(dut):\n    \"\"\"\n    Test that after asserting rst, crc_out is zero on next clk (reset_crc SVA).\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Give a nonzero crc_out first (by stimulating with some input)\n    dut.rst.value = 0\n    dut.data_in.value = 0xABCD  \n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    # Now assert reset\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n\n    # Check on next clock edge\n    assert int(dut.crc_out.value) == 0, (\n        f\"After reset, crc_out is {int(dut.crc_out.value)}, expected 0\"\n    )\n\n    dut.rst.value = 0\n    dut.data_in.value = 0x1234\n    await RisingEdge(dut.clk)\n\n@cocotb.test()\nasync def test_crc_data_width_assertion_pass(dut):\n    \"\"\"\n    Test that data_in and crc_out always have the correct width (p_data_width assertion).\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Deassert reset after one clock\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n    # Check widths for a few clocks and random data\n    for val in [0, 0x1, 0xAAAA, 0xFFFF]:\n        dut.data_in.value = val\n        await RisingEdge(dut.clk)\n\n        # Check data_in width\n        width_data_in = dut.data_in.value.n_bits\n        expected_data_width = dut.DATA_WIDTH.value if hasattr(dut, \"DATA_WIDTH\") else 16\n\n        # Check crc_out width\n        width_crc_out = dut.crc_out.value.n_bits\n        expected_crc_width = dut.CRC_WIDTH.value if hasattr(dut, \"CRC_WIDTH\") else 8\n\n        assert width_data_in == expected_data_width, (\n            f\"data_in width is {width_data_in}, expected {expected_data_width}\"\n        )\n        assert width_crc_out == expected_crc_width, (\n            f\"crc_out width is {width_crc_out}, expected {expected_crc_width}\"\n        )\n\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    toplevel = os.getenv(\"TOPLEVEL\")\n    target = float(os.getenv(\"TARGET\"))\n\n    if \"Overall Average\" in metrics[toplevel]:\n        assert float(metrics[toplevel][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    elif \"Assertion\" in metrics[toplevel]:\n        assertion_coverage = metrics[toplevel][\"Assertion\"]\n        \n        # Handle the 'n/a' case\n        if assertion_coverage.lower() == \"n/a\":\n            raise AssertionError(\"Coverage report contains 'n/a' for Assertion coverage. Ensure all assertions are exercised in the testbench.\")\n        \n        assert float(assertion_coverage) >= 100.00, \"Didn't achieve the required coverage result.\"\n\n    \nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_password_generator_0013", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the `password_generator` module to ensure its correct functionality during simulation? The assertions should cover key aspects of the password generation process, ensuring that the generated characters are valid and properly packed into the output (`password`).\n\n___\n### Key Assertions\n##\n**1. Password Character Validity**\n  - **Condition:**\n  Each generated password character must be within the valid ASCII printable range:\n    - Lowercase letters (`a-z`): 97\u2013122\n    - Uppercase letters (`A-Z`): 65\u201390\n    - Special characters (`! to /`): 33\u201346\n    - Numeric characters (`0\u20139`): 48\u201357\n\n  - **Assertion:**\n    - Check that each `char_array[i]` falls within one of these valid ASCII ranges.\n\n  - **Error Message:**\n    - The display message should include the simulation time (`$time`), the index of the invalid character, and the actual ASCII value.\n\n**2. Reset Behavior**\n  - Condition:\n    - During reset, all values in `char_array` should be initialized to `0`.\n  - Assertion:\n    - Ensure `char_array[i] == 8'h00` for all positions when reset is high.\n  - Error Message:\n    - If any value is non-zero during reset, the assertion should indicate the failing index and value.\n\n**3. Functionality:**\n  - `Configurable Length`: Generates a password of user-defined length (`WIDTH`).\n  - `Character Categories`: Uses lowercase, uppercase, special, and numeric characters.\n  - `Randomization Logic`: Implements a counter-based algorithm for character variability.\n  - `Efficient Packing`: Stores the password as a single packed output vector.\n  - `Reset Handling`: Clears the password and resets the counter when reset is asserted.\n  - `Ensures Validity`: Ensures all characters fall within printable ASCII range (33\u2013126).\n\n___\n### Interface\n##\n**PARAMETER**\n  - `WIDTH`: Configurable password length defining the number of characters in the generated password(Default 4).\n\n**INPUTS**\n  - `clk`: System clock used to synchronize character generation and password updates on a positive edge of the clock.\n  - `reset`: Active-high Asynchronous reset signal that clears the password and counter.\n\n  \n**OUTPUT**\n  - `password`: Packed 8-bit per character output containing the final generated password, combining sequentially generated characters.", "context": {"rtl/password_generator.sv": "module password_generator #(\n    parameter WIDTH = 4  // Length of the password (default is 4 characters)\n) (\n    input logic clk,\n    input logic reset,\n    output logic [(WIDTH*8)-1:0] password\n);\n\n  logic [7:0] char_array[WIDTH-1:0];\n  logic [7:0] counter;\n  logic [1:0] char_type;\n  int i;\n\n  // Counter Logic\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      counter <= 8'h00;\n    end else begin\n      counter <= counter + 8'h1;\n    end\n  end\n\n  // Character Generation Logic\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      for (i = 0; i < WIDTH; i++) begin\n        char_array[i] <= 8'h00;\n      end\n    end else begin\n      for (i = 0; i < WIDTH; i++) begin\n        char_type = (counter + i) % 4;\n        case (char_type)\n          0: char_array[i] <= ((counter + char_array[(i+1)%WIDTH]) % 26) + 8'd97;  // Lowercase a-z\n          1: char_array[i] <= ((counter + i) % 26) + 8'd65;  // Uppercase A-Z\n          2:\n          char_array[i] <= ((counter + char_array[(i+WIDTH-1)%WIDTH]) % 14) + 8'd33;  // Special chars\n          3: char_array[i] <= ((counter + i) % 10) + 8'd48;  // Numeric 0-9\n        endcase\n      end\n    end\n  end\n\n  // Password Packing Logic\n  always @* begin\n    password = {(WIDTH * 8) {1'b0}};\n    for (i = 0; i < WIDTH; i++) begin\n      password[i*8+:8] = char_array[i];\n    end\n  end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/password_generator.sv": ""}}, "harness": {"files": {".env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/password_generator.sv\nTOPLEVEL        = password_generator\nMODULE          = test_password_generator\nPYTHONPATH      = /src\nHASH            = 13-assertion-for-password-generator\n", "Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/password_generator.sv\nTOPLEVEL        = password_generator\nMODULE          = test_password_generator\nPYTHONPATH      = /src\nHASH            = 13-assertion-for-password-generator\n", "src/test_password_generator.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\n\n\n@cocotb.test()\nasync def test_password_generator(dut):\n\n    WIDTH = 4 \n    print(f\"Detected WIDTH: {WIDTH} (Password length)\")\n\n\n    cocotb.start_soon(clock_gen(dut))\n\n\n    print(f\"Applying reset\")\n    await reset_dut(dut, WIDTH)\n    print(f\"reset completed\")\n\n\n    for _ in range(5): \n        await RisingEdge(dut.clk) \n        await Timer(1, units=\"ns\")  \n\n        password = extract_password(int(dut.password.value), WIDTH)\n        print(f\"Generated Password: {password}\")\n\n     \n        assert validate_password(password), f\"Password validation failed: {password}\"\n\n    await Timer(10, units=\"ns\")\n\n\nasync def reset_dut(dut, width):\n\n    dut.reset.value = 1  \n    await Timer(10, units=\"ns\") \n\n  \n    password = extract_password(int(dut.password.value), width)\n    print(f\"Password during reset: {'0' * width}\")  \n    assert dut.password.value == 0, f\"Password was not cleared during reset, got: {password}\"\n\n    dut.reset.value = 0 \n    await Timer(10, units=\"ns\") \n\n\ndef extract_password(packed_password, width):\n\n    password = \"\"\n    for i in range(width):\n        char_code = (packed_password >> (i * 8)) & 0xFF  \n        password = chr(char_code) + password\n    return password\n\n\ndef validate_password(password):\n\n    has_lowercase = any('a' <= c <= 'z' for c in password)\n    has_uppercase = any('A' <= c <= 'Z' for c in password)\n    has_special = any(33 <= ord(c) <= 46 for c in password)\n    has_numeric = any('0' <= c <= '9' for c in password)\n\n    return has_lowercase and has_uppercase and has_special and has_numeric\n\n\nasync def clock_gen(dut):\n\n    while True:\n        dut.clk.value = 0\n        await Timer(5, units=\"ns\")  \n        dut.clk.value = 1\n        await Timer(5, units=\"ns\") \n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}}
{"id": "cvdp_copilot_perceptron_0016", "categories": ["cid014", "medium"], "input": {"prompt": "Can you add concurrent assertions in the RTL design of the `perceptron_gates` module to ensure its correct functionality during simulation? The assertions should cover various key aspects of the module's operations such as ensuring proper reset initialization of the microcode control unit and weight registers, verifying correct state transitions based on the microcode ROM outputs and iteration counter, checking that the arithmetic operations for calculating `y_in` and updating weights are performed only under the appropriate microcode control conditions, and validating that the gate_target submodule outputs match the expected target values based on the `gate_select` input.\n\nThe assertions should fail when any one of the following 10 conditions fails:\n\n**1. rom_index0_check**:\n- This assertion ensures that when the microcode address is 0, the ROM correctly outputs a microinstruction with `next_addr` set to 1 and `train_action` set to 0.\n\n**2. rom_index1_check**:\n- This assertion verifies that when the microcode address is 1, the ROM provides the correct control signals by setting `next_addr` to 2 and `train_action` to 1.\n\n**3. rom_index2_check**:\n- This assertion confirms that when the microcode address is 2, the ROM outputs a microinstruction with `next_addr` equal to 3 and `train_action` equal to 2, ensuring proper ROM content retrieval.\n\n**4. action1_y_calculation**:\n- This assertion verifies that when train_action is 4'd1, the computed output y is correctly determined by comparing `y_in` with the threshold. Specifically, if `y_in` is greater than the threshold, y should be 1; if `y_in` falls within the range of \u2013threshold to threshold, y should be 0; otherwise, y should be \u20131.\n\n**5. action3_weight_update**:\n- This assertion verifies that during train_action 3, if the actual output y does not match the target, the weight updates and bias updates are computed properly.\n\n**6. action3_no_update** :\n- This assertion ensures that during train_action 3, if the computed output y matches the target, then no weight and bias updates occur (i.e., `wt1_update`, `wt2_update`, and `bias_update` remain zero).\n\n**7. microcode_rom_integrity**:\n- This assertion verifies that every entry of the microcode_rom maintains its expected constant value, ensuring that the ROM contents remain intact throughout the simulation.\n\n**8. address_tracking**:\n- This assertion verifies that the sequential address tracking is correct. It checks that if the current `present_addr `equals `next_addr`, then `microcode_addr` should be updated to the previous cycle's present_addr value, ensuring proper pipelining of the microcode addresses.\n\n**9. train_action5_check** :\n- This assertion verifies that during train_action 5, the design correctly latches the current weight update values into their corresponding previous weight update registers, and it also confirms that the microcode ROM's next address is set to 4'd1.\n\n**10. train_action1_y_in_calc**:\n- This assertion verifies that during `train_action 1`, `y_in`  is computed correctly as the sum of `percep_bias_reg` and the weighted inputs (`x1` multiplied by `percep_wt_1_reg` plus `x2` multiplied by `percep_wt_2_reg`).\n\n## Interface\n## Inputs\n- `clk` (1-bit): Positive edge-triggered clock signal for calculating the microcode ROM address.\n- `rst_n` (1-bit): Asynchronous Negative edge-triggered reset signal. When ACTIVE LOW, `present_addr` is initialized to `4'd0`.\n- `x1`, `x2` (4-bit,[3:0], signed): Perceptron inputs. Can take only Bipolar values [`4'd1`,`-4'd1`]\n- `learning_rate` (1-bit): Learning rate for weight and bias updates.\n- `threshold` (4-bit,[3:0], signed): Threshold value for response calculation.\n- `gate_select` (2-bit,[1:0]): Specifies the gate type for determining target outputs.\n\n## Outputs\n- `percep_w1`, `percep_w2` (4-bit, [3:0], signed): Current weights of the perception. Can take Bipolar Values [`4'd1`,`-4'd1`]\n- `percep_bias` (4-bit,[3:0], signed): Current bias of the perception.Can take Bipolar Values [`4'd1`,`-4'd1`]\n- `present_addr` (4-bit,[3:0]): Current microcode ROM address.\n- `stop` (1-bit): Indicates the end of training.\n- `input_index` (3-bit,[2:0]): Tracks the current target value selected during an iteration. Can take values from 3'd0 to 3'd3.\n- `y_in` (4-bit,[3:0] signed): Computed perception output. Can take Bipolar values [`4'd1`,`-4'd1`]\n- `y` (4-bit, [3:0], signed): Perceptron output after applying the threshold.Can take three different values [`4'd1`,`4'd0`,`-4'd1`]\n- `prev_percep_wt_1`, `prev_percep_wt_2`, `prev_percep_bias` (4-bit, [3:0], signed): Weights and Bias during a previous iteration. Can take Bipolar values [`4'd1`, `-4'd1`]", "context": {"rtl/perceptron_gates.sv": "module perceptron_gates (\n   input  logic clk,// Posedge clock\n   input  logic rst_n,// Negedge reset\n   input  logic signed [3:0] x1, // First Input of the Perceptron\n   input  logic signed [3:0] x2, // Second Input of the Perceptron\n   input  logic learning_rate, // Learning rate (alpha)\n   input  logic signed [3:0] threshold, // Threshold value\n   input  logic [1:0] gate_select, // Gate selection for target values\n   output logic signed [3:0] percep_w1, // Trained Weight 1 \n   output logic signed [3:0] percep_w2, // Trained Weight 2\n   output logic signed [3:0] percep_bias, // Trained Bias\n   output logic [3:0] present_addr, // Current address in microcode ROM\n   output logic stop, // Condition to indicate no learning has occurred(i.e. no weight change between iterations)\n   output logic [2:0] input_index,// Vector to track the selection of target for a given input combination for a gate\n   output logic signed [3:0] y_in, // Calculated Response\n   output logic signed [3:0] y, // Calculated Response obtained by comparing y_in against a threshold value\n   output logic signed [3:0] prev_percep_wt_1,//Value of Weight 1 during a previous iteration\n   output logic signed [3:0] prev_percep_wt_2,//Value of Weight 2 during a previous iteration\n   output logic signed [3:0] prev_percep_bias // Value of Bias during a previous iteration\n);\n\n   logic [15:0] microcode_rom [0:5];\n   logic [3:0]  next_addr;\n   logic [3:0]  train_action;\n   logic [3:0]  microcode_addr;\n   logic [15:0] microinstruction;\n   logic signed [3:0] t1, t2, t3, t4;\n   \n   gate_target dut (\n       .gate_select(gate_select),\n       .o_1(t1),\n       .o_2(t2),\n       .o_3(t3),\n       .o_4(t4)\n   );\n\n   logic signed [3:0] percep_wt_1_reg;\n   logic signed [3:0] percep_wt_2_reg;\n   logic signed [3:0] percep_bias_reg;\n\n   \n   logic signed [3:0] target;\n   logic signed [3:0] prev_wt1_update;\n   logic signed [3:0] prev_wt2_update;\n   logic signed [3:0] prev_bias_update;\n   \n   logic signed [3:0] wt1_update;\n   logic signed [3:0] wt2_update;\n   logic signed [3:0] bias_update;\n   logic [7:0] epoch_counter;\n   \n   assign  prev_percep_wt_1 = prev_wt1_update;\n   assign  prev_percep_wt_2 = prev_wt2_update;\n   assign  prev_percep_bias = prev_bias_update;\n\n   initial begin \n      microcode_rom[0] = 16'b0001_0000_0000_0000; \n      microcode_rom[1] = 16'b0010_0001_0000_0000; \n      microcode_rom[2] = 16'b0011_0010_0000_0000; \n      microcode_rom[3] = 16'b0100_0011_0000_0000; \n      microcode_rom[4] = 16'b0101_0100_0000_0000; \n      microcode_rom[5] = 16'b0000_0101_0000_0000; \n   end  \n   \n   always@(*) begin\n      microinstruction = microcode_rom[microcode_addr];\n      next_addr        = microinstruction[15:12];\n      train_action     = microinstruction[11:8];\n   end\n\n   always_ff @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         present_addr    <= 4'd0;\n         microcode_addr  <= 4'd0;\n         percep_wt_1_reg <= 4'd0;\n         percep_wt_2_reg <= 4'd0;\n         percep_bias_reg <= 4'd0;\n         input_index     <= 2'd0;\n         stop            <= 1'b0;\n      end else begin\n         present_addr    <= next_addr;\n         microcode_addr  <= present_addr;\n      end\n   end\n\n   always_comb begin\n      case (train_action)\n         4'd0:  begin \n                   percep_wt_1_reg = 4'd0;\n                   percep_wt_2_reg = 4'd0;\n                   percep_bias_reg = 4'd0;\n                   stop = 1'b0;\n                   next_addr = next_addr + 4'd0;\n                   y_in = 4'd0;\n                   y    = 4'd0;\n                   prev_wt1_update = 4'd0;\n                   prev_wt2_update = 4'd0;\n                   prev_bias_update = 4'd0;\n                   input_index = 0;\n                   target = 0;\n                   wt1_update = 0;\n                   wt2_update = 0;\n                   bias_update = 0;\n                   epoch_counter = 0;\n                end\n         4'd1 : begin \n                   y_in = percep_bias_reg + (x1 * percep_wt_1_reg) + (x2 * percep_wt_2_reg); \n                   if (y_in > threshold)\n                      y = 4'd1;\n                   else if (y_in >= -threshold && y_in <= threshold)\n                      y = 4'd0;\n                   else\n                      y = -4'd1;\n                \n                   percep_wt_1_reg  = percep_wt_1_reg  + 4'd0;\n                   percep_wt_2_reg  = percep_wt_2_reg  + 4'd0;\n                   percep_bias_reg  = percep_bias_reg  + 4'd0;\n                   prev_wt1_update  = prev_wt1_update  + 4'd0;\n                   prev_wt2_update  = prev_wt2_update  + 4'd0;\n                   prev_bias_update = prev_bias_update + 4'd0;\n                   input_index = input_index + 0;\n                   next_addr = next_addr + 4'd0;\n                   stop = stop + 1'b0;\n                   target = target + 4'd0;\n                   wt1_update = wt1_update + 4'd0 ;\n                   wt2_update = wt2_update + 4'd0 ;\n                   bias_update = bias_update + 4'd0 ;\n                   epoch_counter = epoch_counter + 0;\n                end\n         4'd2 : begin\n                   if(input_index == 0)\n                        target = t1;\n                   else if(input_index == 1)\n                        target = t2;\n                   else if(input_index == 2)\n                        target = t3;\n                   else if(input_index == 3)\n                        target = t4;\n                   else begin\n                        input_index = 0;\n                        target = 0;\n                   end\n                   stop = stop + 1'b0;\n                   input_index = input_index + 0;\n                   next_addr = next_addr + 4'd0;\n                   target = target + 4'd0;\n                   prev_wt1_update  = prev_wt1_update  + 4'd0;\n                   prev_wt2_update  = prev_wt2_update  + 4'd0;\n                   prev_bias_update = prev_bias_update + 4'd0;\n                   \n                   percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                   percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                   percep_bias_reg = percep_bias_reg + 4'd0;\n                   y_in = y_in + 4'd0;\n                   y = y + 4'd0;\n                   wt1_update = wt1_update + 4'd0 ;\n                   wt2_update = wt2_update + 4'd0 ;\n                   bias_update = bias_update + 4'd0 ;\n                   epoch_counter = epoch_counter + 0;\n                end\n         4'd3 : begin\n                   if (y != target) begin\n                        wt1_update = learning_rate * x1 * target ;\n                        wt2_update = learning_rate * x2 * target ;\n                        bias_update = learning_rate * target ; \n                    end else begin\n                        wt1_update = 0 ;\n                        wt2_update = 0 ;\n                        bias_update = 0 ;     \n                    end    \n                    percep_wt_1_reg = percep_wt_1_reg + wt1_update;\n                    percep_wt_2_reg = percep_wt_2_reg + wt2_update;\n                    percep_bias_reg = percep_bias_reg + bias_update;\n                    prev_wt1_update  = prev_wt1_update  + 4'd0;\n                    prev_wt2_update  = prev_wt2_update  + 4'd0;\n                    prev_bias_update = prev_bias_update + 4'd0;\n                    y_in = y_in + 4'd0;\n                    y = y + 4'd0;\n                    stop = stop + 1'b0;\n                    input_index = input_index + 0;\n                    next_addr = next_addr + 4'd0;\n                    target = target + 4'd0;\n                    epoch_counter = epoch_counter + 0;\n                end\n         4'd4 : begin\n                  if ((prev_wt1_update == wt1_update) & (prev_wt2_update == wt2_update) & (input_index == 4'd3)) begin \n                          epoch_counter = 0;\n                          stop = 1'b1; \n                          input_index = 0;\n                          next_addr = 4'd0;\n                          percep_wt_1_reg = 0;\n                          percep_wt_2_reg = 0;\n                          percep_bias_reg = 0;\n                          prev_wt1_update =  0;\n                          prev_wt2_update =  0;\n                          prev_bias_update = 0;\n                          y_in = 0;\n                          y = 0;\n                          target = 0;\n                          wt1_update = 0 ;\n                          wt2_update = 0 ;\n                          bias_update = 0 ;\n                  end else begin\n                          stop = 1'b0; \n                          input_index = input_index + 0;\n                          epoch_counter = epoch_counter + 1;    \n                          next_addr = 4'd5;    \n                          percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                          percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                          percep_bias_reg = percep_bias_reg + 4'd0;\n                          prev_wt1_update = prev_wt1_update + 4'd0;\n                          prev_wt2_update = prev_wt2_update + 4'd0;\n                          prev_bias_update = prev_bias_update + 4'd0;\n                          y_in = y_in + 4'd0;\n                          y = y + 4'd0;\n                          target = target + 4'd0;\n                          wt1_update = wt1_update + 4'd0 ;\n                          wt2_update = wt2_update + 4'd0 ;\n                          bias_update = bias_update + 4'd0 ;\n                  end\n                end\n         4'd5 : begin\n                          percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                          percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                          percep_bias_reg = percep_bias_reg + 4'd0;\n                          prev_wt1_update  = wt1_update;\n                          prev_wt2_update  = wt2_update;\n                          prev_bias_update = bias_update;\n                          next_addr = 4'd1;\n                          input_index = input_index + 1;\n                          stop = stop + 1'b0;\n                          epoch_counter = epoch_counter + 0;\n                          y_in = y_in + 4'd0;\n                          y = y + 4'd0;\n                          target = target + 4'd0;\n                          wt1_update = wt1_update + 4'd0;\n                          wt2_update = wt2_update + 4'd0;\n                          bias_update = bias_update + 4'd0;\n                end   \n      default : begin\n                          next_addr = next_addr + 4'd0;\n                          percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                          percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                          percep_bias_reg = percep_bias_reg + 4'd0;\n                          prev_wt1_update = prev_wt1_update + 4'd0;\n                          prev_wt2_update = prev_wt2_update + 4'd0;\n                          prev_bias_update = prev_bias_update + 4'd0;\n                          stop = stop + 1'b0;\n                          y_in = y_in + 4'd0;\n                          y = y + 4'd0;\n                          input_index = input_index + 0;\n                          target = target + 4'd0;\n                          wt1_update = wt1_update + 4'd0 ;\n                          wt2_update = wt2_update + 4'd0 ;\n                          bias_update = bias_update + 4'd0 ;\n                          epoch_counter = epoch_counter + 0;\n                end\n      endcase\n   end\n   assign percep_w1 = percep_wt_1_reg;\n   assign percep_w2 = percep_wt_2_reg;\n   assign percep_bias = percep_bias_reg;\n\nendmodule\n\nmodule gate_target(\n   input  logic        [1:0] gate_select,\n   output logic signed [3:0] o_1,\n   output logic signed [3:0] o_2,\n   output logic signed [3:0] o_3,\n   output logic signed [3:0] o_4\n);\n   always_comb begin\n     case(gate_select)\n          2'b00 : begin \n                    o_1 =  1; \n                    o_2 = -1; \n                    o_3 = -1; \n                    o_4 = -1; \n                  end\n          2'b01 : begin \n                    o_1 =  1; \n                    o_2 =  1; \n                    o_3 =  1; \n                    o_4 = -1; \n                  end\n          2'b10 : begin \n                    o_1 =  1; \n                    o_2 =  1; \n                    o_3 =  1; \n                    o_4 = -1; \n                  end\n          2'b11 : begin \n                    o_1 =  1; \n                    o_2 = -1; \n                    o_3 = -1; \n                    o_4 = -1; \n                  end\n        default : begin\n                    o_1 =  0; \n                    o_2 =  0; \n                    o_3 =  0; \n                    o_4 =  0; \n                  end\n        endcase\n   end\nendmodule"}}, "output": {"response": "", "context": {"rtl/perceptron_gates.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/perceptron_gates.sv\nTOPLEVEL        = perceptron_gates\nMODULE          = test_perceptron_gates\nPYTHONPATH      = /src\nHASH            = 16-perceptron_tb_assertion_issue\n", "src/test_perceptron_gates.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n@cocotb.test()\nasync def test_perceptron_gates(dut):\n    \"\"\"Testbench for the perceptron_gates module using Cocotb.\"\"\"\n\n    # Create a 10ns clock\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Reset logic\n    dut.rst_n.value = 0\n    await Timer(10, units=\"ns\")\n    dut.rst_n.value = 1\n\n    # Initialize inputs\n    dut.x1.value = 0\n    dut.x2.value = 0\n    dut.learning_rate.value = 1\n    dut.threshold.value = 0\n    dut.gate_select.value = 0\n\n    await RisingEdge(dut.rst_n)\n    await Timer(10, units=\"ns\")\n\n    # Helper function for applying stimulus and logging outputs\n    async def apply_stimulus(x1, x2, gate_select, duration):\n        dut.x1.value = x1\n        dut.x2.value = x2\n        dut.gate_select.value = gate_select\n        await Timer(duration, units=\"ns\")\n        cocotb.log.info(\n            f\"gate_select={gate_select}, x1={x1}, x2={x2}, \"\n            f\"percep_w1={int(dut.percep_w1.value)}, \"\n            f\"percep_w2={int(dut.percep_w2.value)}, \"\n            f\"percep_bias={int(dut.percep_bias.value)}, \"\n            f\"present_addr={bin(int(dut.present_addr.value))}, \"\n            f\"stop={bin(int(dut.stop.value))}, \"\n            f\"input_index={bin(int(dut.input_index.value))}, \"\n            f\"y_in={int(dut.y_in.value)}, \"\n            f\"y={int(dut.y.value)}, \"\n            f\"prev_percep_wt_1={int(dut.prev_percep_wt_1.value)}, \"\n            f\"prev_percep_wt_2={int(dut.prev_percep_wt_2.value)}, \"\n            f\"prev_percep_bias={int(dut.prev_percep_bias.value)}\"\n         )\n\n    # Test AND gate targets (gate_select = 2'b00)\n    dut.gate_select.value = 0b00\n    cocotb.log.info(\"Start of AND gate Training\")\n    await apply_stimulus(1, 1, 0b00, 100)\n    await apply_stimulus(1, -1, 0b00, 80)\n    await apply_stimulus(-1, 1, 0b00, 90)\n    await Timer(25, units=\"ns\")\n    await apply_stimulus(-1, -1, 0b00, 95)\n    await apply_stimulus(1, 1, 0b00, 25)\n    await apply_stimulus(1, -1, 0b00, 30)\n    await apply_stimulus(-1, 1, 0b00, 30)\n    await apply_stimulus(-1, -1, 0b00, 90)\n    await Timer(30, units=\"ns\")\n    cocotb.log.info(\"End of AND gate Training\")\n\n    # Test OR gate targets (gate_select = 2'b01)\n    dut.gate_select.value = 0b01\n    cocotb.log.info(\"Start of OR gate Training\")\n    await apply_stimulus(1, 1, 0b01, 95)\n    await Timer(30, units=\"ns\")\n    await apply_stimulus(-1, 1, 0b01, 65)\n    await apply_stimulus(1, -1, 0b01, 30)\n    await apply_stimulus(-1, -1, 0b01, 60)\n    cocotb.log.info(\"End of OR gate Training\")\n\n    # Test NAND gate targets (gate_select = 2'b10)\n    dut.gate_select.value = 0b10\n    cocotb.log.info(\"Start of NAND gate Training\")\n    await apply_stimulus(-1, -1, 0b10, 115)\n    await Timer(30, units=\"ns\")\n    await apply_stimulus(-1, 1, 0b10, 80)\n    await Timer(30, units=\"ns\")\n    await apply_stimulus(1, -1, 0b10, 65)\n    await Timer(10, units=\"ns\")\n    await apply_stimulus(1, 1, 0b10, 70)\n    cocotb.log.info(\"End of NAND gate Training\")\n\n    # Test NOR gate targets (gate_select = 2'b11)\n    dut.gate_select.value = 0b11\n    cocotb.log.info(\"Start of NOR gate Training\")\n    await apply_stimulus(-1, -1, 0b11, 410)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(-1, 1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(1, -1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(1, 1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(-1, -1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(-1, 1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(1, -1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(1, 1, 0b11, 70)\n    cocotb.log.info(\"End of NOR gate Training\")\n\n    # Randomized test cases\n    num_random_cases = 10  # Number of random test cases\n    for i in range(num_random_cases):\n        random_gate_select = random.randint(0, 3)  # Randomly select gate (0b00 to 0b11)\n        random_inputs = [(random.choice([-1, 1]), random.choice([-1, 1])) for _ in range(4)]\n\n        dut.gate_select.value = random_gate_select\n        cocotb.log.info(f\"Start of Random Test Case {i+1} for gate_select={bin(random_gate_select)}\")\n\n        for x1, x2 in random_inputs:\n            await apply_stimulus(x1, x2, random_gate_select, 100)\n        cocotb.log.info(f\"End of Random Test Case {i+1} for gate_select={bin(random_gate_select)}\")\n\n    # Stop the test\n    cocotb.log.info(\"Test Completed\")\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_perceptron_0018", "categories": ["cid012", "medium"], "input": {"prompt": "Create a SystemVerilog testbench module named `tb_perceptron_gates` that instantiates the `perceptron_gates` module as the Unit Under Test (UUT). The testbench must include a stimulus generator only that systematically drives various input conditions to achieve a minimum of 80% code and functional coverage for the `perceptron_gates` module. The `perceptron_gates` module implements a microcoded controller to train a perceptron model. The module takes signed 4-bit inputs (`x1` and `x2`), a 4-bit threshold, a 1-bit learning rate, and a 2-bit gate selector to determine the target output based on logical gate operations. It uses a microcode ROM to sequentially execute actions like weight initialization, output computation, target selection, weight/bias updates, and convergence checks. The module outputs the updated weights, bias, perceptron response (`y`), and a stop signal when training converges.\n\n## Design Specification:\nThe `perceptron_gates` module handles weight initialization, computation of perceptron outputs, target selection based on input indexes, and weight and bias updates. It features a microcoded approach for defining operational states, ensuring flexibility and reusability for perceptron-based learning tasks.\n\n## Interface\n## Inputs\n- `clk` (1-bit): Positive edge-triggered clock signal for calculating the microcode ROM address.\n- `rst_n` (1-bit): Negative edge-triggered reset signal. When ACTIVE LOW, `present_addr` is initialized to `4'd0`.\n- `x1`, `x2` (4-bit,[3:0], signed): Perceptron inputs. Can take only Bipolar values [`4'd1`,`-4'd1`]\n- `learning_rate` (1-bit): Learning rate for weight and bias updates.\n- `threshold` (4-bit,[3:0], signed): Threshold value for response calculation.\n- `gate_select` (2-bit,[1:0]): Specifies the gate type for determining target outputs.\n\n## Outputs\n- `percep_w1`, `percep_w2` (4-bit, [3:0], signed): Current weights of the perception. Can take Bipolar Values [`4'd1`,`-4'd1`]\n- `percep_bias` (4-bit,[3:0], signed): Current bias of the perception.Can take Bipolar Values [`4'd1`,`-4'd1`]\n- `present_addr` (4-bit,[3:0]): Current microcode ROM address.\n- `stop` (1-bit): Indicates the end of training.\n- `input_index` (3-bit,[2:0]): Tracks the current target value selected during an iteration. Can take values from 3'd0 to 3'd3.\n- `y_in` (4-bit,[3:0] signed): Computed perception output. Can take Bipolar values [`4'd1`,`-4'd1`]\n- `y` (4-bit, [3:0], signed): Perceptron output after applying the threshold.Can take three different values [`4'd1`,`4'd0`,`-4'd1`]\n- `prev_percep_wt_1`, `prev_percep_wt_2`, `prev_percep_bias` (4-bit, [3:0], signed): Weights and Bias during a previous iteration. Can take Bipolar values [`4'd1`, `-4'd1`]\n\n**Instantiation** :\nThe testbench instantiates the `perceptron_gates` module as uut and connects the signals between the module and the testbench. Each input and output from the uut is connected to its corresponding signal in the testbench.\n\n## **Input Generation and Validation**\n**Stimulus**: \n  The testbench continuously drives the clock (`clk`) and applies a reset (`rst_n`). Once out of reset, it goes through two main \u201ctraining sets,\u201d each one iterating over the four possible gate_select values (00, 01, 10, 11). For each `gate_select`, `target_select` is either 0 or 1 depending on whether it is in the \u201cfirst training set\u201d or \u201csecond training set.\u201d Within each gate configuration, multiple input patterns of `x1` and `x2` (both + 1 and - 1) are driven in sequence to stimulate the `perceptron_gates` module.\n\n\n## **1. Gate 00 (gate_select = 2\u2019b00) Training**:\nThe code treats `gate_select` = 2\u2019b00 as an AND-like gate.\n\n**1.Test Case 1 (First Training Set)**:\nControl:\n- `gate_select` = 2\u2019b00\n- `target_select` = 1\u2019b0\n- `rst_n` should be asserted (HIGH), meaning the circuit is active.\n\nInputs:\nThe sequence for '\ud835\udc651','\ud835\udc652' is given by:\n1.  (1, 1)\n2.  (1, \u20131)\n3.  (\u20131, 1)\n4.  (\u20131, \u20131)\n5.  Repeat with similar pairs to check how weights evolve (e.g., cycling through (1, 1), (1, \u20131), (\u20131, 1), (\u20131, \u20131) again with different delays).\n\n**2. Test Case 2 (Second Training Set)** :\nControl:\n- gate_select = 2\u2019b00\n- target_select = 1\u2019b1\n- A reset (rst_n=0) and re-assertion (rst_n=1) should happen right before starting this second training set.\n\nInputs:\n- After the reset, \u2018x1\u2018, and \u2018x2\u2018 should be driven as a series of + 1 and -1 pairs, but in a slightly different order to verify that the perceptron updates (`weights` and `bias`) can handle new input patterns under the new `target_select` value:\n  (\u20131, 1), (1, \u20131), (\u20131, \u20131), (1, 1), etc.\n\n## **2. Gate 01 (gate_select = 2\u2019b01) Training**\nThe code treats `gate_select` = 2\u2019b00 as an `OR-like gate`.\n\n**1. Test Case 1 (First Training Set)**:\nControl:\n- `gate_select` = 2\u2019b01\n- `target_select` = 1\u2019b0\n- `rst_n` should be asserted (HIGH), meaning the circuit is active.\nInputs:\nPatterns of (1, 1), (\u20131, 1), (1, \u20131), (\u20131, \u20131), each separated by delays (#90, #95, etc.).\n\n**2. Test Case 2 (Second Training Set)**:\nControl:\n- `gate_select` = 2\u2019b01\n- `target_select` = 1\u2019b1\nInputs:\nAgain, multiple +1 and -1 combinations should be applied in sequence after a reset, ensuring that the perceptron\u2019s weights adapt to the new target criterion.\n\n## **3. Gate 10 (`gate_select = 2\u2019b10`) Training**\nThe code treats `gate_select` = 2\u2019b00 as a `NAND-like Gate`.\n\n**1.Test Case 1 (First Training Set)**:\nControl:\n- gate_select = 2\u2019b10\n- target_select = 1\u2019b0\nInputs:\nThe testbench should apply (\u20131, \u20131), (\u20131, 1), (1, \u20131), (1, 1), etc., checking that the `perceptron_gates` module updates correctly.\n\n**2. Test Case 2 (Second Training Set)**:\nControl:\n- gate_select = 2\u2019b10\n- target_select = 1\u2019b1\nInputs:\nAfter another reset, the same style of + 1 and -1 inputs should be repeated, but with `target_select` changed to test the  NAND-like behavior.\n\n## **4.Gate 11 (`gate_select = 2\u2019b11`) Training**\nThe code treats `gate_select` = 2\u2019b00 as a `NOR-like Gate`.\n\n**1. Test Case 1 (First Training Set)**:\nControl:\n- `gate_select` = 2\u2019b11\n- `target_select` = 1\u2019b0\nInputs:\nSimilar to the other gates, the code should drive (\u20131, \u20131), (\u20131, 1), (1, \u20131), and (1, 1) in various sequences.\n\n**2. Test Case 2 (Second Training Set)**\nControl:\n- `gate_select` = 2\u2019b11\n- `target_select` = 1\u2019b1\nInputs:\nOnce reset, the same pattern of inputs should be repeated, but with a different `target_select` to test whether the perceptron properly re-learns the new target.\n\n## **Module Functionality**:\n## Submodule Overview\n### 1. Gate Target (`gate_target`)\nGenerates target outputs (`t1`, `t2`, `t3`, `t4`) based on the selected gate type.\n- Inputs: `gate_select` (2-bit,[1:0]).\n- Outputs : `o_1`, `o_2`, `o_3`, `o_4` (4-bit, [3:0],signed).\n- Gates implemented: AND, OR, NAND, and NOR gates.\n   - `gate_select`:\n         - `2'b00` : AND Gate    ; target values : (`4'd1`,`-4'd1`,`-4'd1`,`-4'd1`)\n         - `2'b01` : OR Gate      ; target values : (`4'd1`, `4'd1`, `4'd1`,`-4'd1`)\n         - `2'b10` : NAND Gate ; target values : (`4'd1`, `4'd1`, `4'd1`,`-4'd1`) \n         - `2'b11` : NOR Gate   ;  target values : (`4'd1`, `-4'd1`, `-4'd1`,`-4'd1`) \n         \n### 2. Microcode ROM\n- Defines a sequence of 6 micro-instructions, specifying actions such as weight initialization, output computation, target selection, and weight/bias updates.\n\n## Algorithm Steps for Perceptron Learning\n- Initialization: All weights, biases, and counters are set to zero.\n- Compute Output: Compute `y_in` = `bias` + (`x1` * `w1`) + (`x2` * `w2`) and compare with the threshold to determine `y`.\n- Select Target: Based on `gate_select` and` input_index`, pick the desired target value\n- Update Weights and Bias: Adjust weights and bias  based on the condition (`y` != `target`)\n  -  If the condition is satisfied\n        - `wt1_update` = `learning_rate` * `x1` * `target`\n        - `wt2_update` = `learning_rate` * `x2` * `target`\n        - `bias_update` = `learning_rate` * `target`\n   - If the condition is not satisfied\n        - `wt1_update` = 0\n        - `wt2_update` = 0\n        - `bias_update` = 0\n  - The value of current weights and bias is calculated as follows :\n       - `percep_wt1` = `percep_w1` + `wt1_update`\n       - `percep_wt2` = `percep_wt2` + `wt2_update`\n       - `percep_bias` = `percep_bias` + `bias_update`\n- Check if the `wt1_update`, `wt2_update` , and `bias_update` values are equal to their previous iteration values. If the condition is satisfied, stop the learning. Otherwise assign the `wt1_update`, `wt2_update`, and `bias_update` values to their previous iteration values and continue learning.\n                                                 \n## Control Flow\n### Microcoded Actions\n- Action 0: Initialize weights and bias to zero.\n- Action 1: Compute `y_in` (weighted sum + bias) and `y` (thresholded output).\n- Action 2: Select target value based on `input_index `and `gate type`.\n- Action 3: Update weights and bias if the perceptron output differs from the target.\n- Action 4: Compare current and previous weights and bias to determine convergence.\n- Action 5: Finalize updates and prepare for the next epoch.\n**An epoch is the time taken to train the perceptron for a given combination of four input values**\n\n## Key Features\n- Microcoded Sequencing: Flexible execution of training steps using `microcode ROM`.\n- Dynamic Target Selection: Allows gate-based logic outputs for versatile applications.\n- Sequential Updates: Tracks and applies weight changes across iterations.\n- Convergence Monitoring: Halts training when weights stabilize.", "context": {}}, "output": {"response": "", "context": {"verif/tb_perceptron_gates.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 679b3627e94df8904125beaa1248a22474a8fc42\nTARGET = 80\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/perceptron_gates.sv": "`timescale 1ns/1ps\nmodule perceptron_gates (\n    input  logic clk,// Posedge clock\n    input  logic rst_n,// Negedge reset\n    input  logic signed [3:0] x1, // First Input of the Perceptron\n    input  logic signed [3:0] x2, // Second Input of the Perceptron\n    input  logic learning_rate, // Learning rate (alpha)\n    input  logic signed [3:0] threshold, // Threshold value\n    input  logic [1:0] gate_select, // Gate selection during a specific training\n    input  logic       target_select,// Target Selection for a specific training\n    output logic signed [3:0] percep_w1, // Trained Weight 1 \n    output logic signed [3:0] percep_w2, // Trained Weight 2\n    output logic signed [3:0] percep_bias, // Trained Bias\n    output logic [3:0] present_addr, // Current address in microcode ROM\n    output logic stop, // Condition to indicate no learning has occurred(i.e. no weight change between iterations)\n    output logic [2:0] input_index,// Vector to track the selection of target for a given input combination for a gate\n    output logic signed [3:0] y_in, // Calculated Response\n    output logic signed [3:0] y, // Calculated Response obtained by comparing y_in against a threshold value\n    output logic signed [3:0] prev_percep_wt_1,//Value of Weight 1 during a previous iteration\n    output logic signed [3:0] prev_percep_wt_2,//Value of Weight 2 during a previous iteration\n    output logic signed [3:0] prev_percep_bias // Value of Bias during a previous iteration\n);\n\n    logic [15:0] microcode_rom [0:5];\n    logic [3:0]  next_addr;\n    logic [3:0]  train_action;\n    logic [3:0]  microcode_addr;\n    logic [15:0] microinstruction;\n    logic signed [3:0] t1, t2, t3, t4;\n   \n    gate_target dut (\n        .gate_select(gate_select),\n        .target_select(target_select),\n        .o_1(t1),\n        .o_2(t2),\n        .o_3(t3),\n        .o_4(t4)\n    );\n\n    logic signed [3:0] percep_wt_1_reg;\n    logic signed [3:0] percep_wt_2_reg;\n    logic signed [3:0] percep_bias_reg;\n\n    logic signed [3:0] target;\n    logic signed [3:0] prev_wt1_update;\n    logic signed [3:0] prev_wt2_update;\n    logic signed [3:0] prev_bias_update;\n   \n    logic signed [3:0] wt1_update;\n    logic signed [3:0] wt2_update;\n    logic signed [3:0] bias_update;\n    logic [7:0] epoch_counter;\n   \n    assign prev_percep_wt_1 = prev_wt1_update;\n    assign prev_percep_wt_2 = prev_wt2_update;\n    assign prev_percep_bias = prev_bias_update;\n\n    initial begin \n        microcode_rom[0] = 16'b0001_0000_0000_0000; \n        microcode_rom[1] = 16'b0010_0001_0000_0000; \n        microcode_rom[2] = 16'b0011_0010_0000_0000; \n        microcode_rom[3] = 16'b0100_0011_0000_0000; \n        microcode_rom[4] = 16'b0101_0100_0000_0000; \n        microcode_rom[5] = 16'b0000_0101_0000_0000; \n    end  \n   \n    always @(*) begin\n        microinstruction = microcode_rom[microcode_addr];\n        next_addr        = microinstruction[15:12];\n        train_action     = microinstruction[11:8];\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            present_addr    <= 4'd0;\n            microcode_addr  <= 4'd0;\n            percep_wt_1_reg <= 4'd0;\n            percep_wt_2_reg <= 4'd0;\n            percep_bias_reg <= 4'd0;\n            input_index     <= 2'd0;\n            stop            <= 1'b0;\n        end else begin\n            present_addr    <= next_addr;\n            microcode_addr  <= present_addr;\n        end\n    end\n\n    always @(*) begin\n        case (train_action)\n            4'd0: begin \n                percep_wt_1_reg  = 4'd0;\n                percep_wt_2_reg  = 4'd0;\n                percep_bias_reg  = 4'd0;\n                stop             = 1'b0;\n                next_addr        = next_addr + 4'd0;\n                y_in             = 4'd0;\n                y                = 4'd0;\n                prev_wt1_update  = 4'd0;\n                prev_wt2_update  = 4'd0;\n                prev_bias_update = 4'd0;\n                input_index      = 0;\n                target           = 0;\n                wt1_update       = 0;\n                wt2_update       = 0;\n                bias_update      = 0;\n                epoch_counter    = 0;\n            end\n            4'd1: begin \n                y_in = percep_bias_reg + (x1 * percep_wt_1_reg) + (x2 * percep_wt_2_reg); \n                if (y_in > threshold)\n                    y = 4'd1;\n                else if (y_in >= -threshold && y_in <= threshold)\n                    y = 4'd0;\n                else\n                    y = -4'd1;\n                \n                percep_wt_1_reg  = percep_wt_1_reg  + 4'd0;\n                percep_wt_2_reg  = percep_wt_2_reg  + 4'd0;\n                percep_bias_reg  = percep_bias_reg  + 4'd0;\n                prev_wt1_update  = prev_wt1_update  + 4'd0;\n                prev_wt2_update  = prev_wt2_update  + 4'd0;\n                prev_bias_update = prev_bias_update + 4'd0;\n                input_index      = input_index + 0;\n                next_addr        = next_addr + 4'd0;\n                stop             = stop + 1'b0;\n                target           = target + 4'd0;\n                wt1_update       = wt1_update + 4'd0 ;\n                wt2_update       = wt2_update + 4'd0 ;\n                bias_update      = bias_update + 4'd0 ;\n                epoch_counter    = epoch_counter + 0;\n            end\n            4'd2: begin\n                if (input_index == 0)\n                    target = t1;\n                else if (input_index == 1)\n                    target = t2;\n                else if (input_index == 2)\n                    target = t3;\n                else if (input_index == 3)\n                    target = t4;\n                else begin\n                    input_index = 0;\n                    target      = 0;\n                end\n                stop             = stop + 1'b0;\n                input_index      = input_index + 0;\n                next_addr        = next_addr + 4'd0;\n                target           = target + 4'd0;\n                prev_wt1_update  = prev_wt1_update  + 4'd0;\n                prev_wt2_update  = prev_wt2_update  + 4'd0;\n                prev_bias_update = prev_bias_update + 4'd0;\n                   \n                percep_wt_1_reg  = percep_wt_1_reg + 4'd0;\n                percep_wt_2_reg  = percep_wt_2_reg + 4'd0;\n                percep_bias_reg  = percep_bias_reg + 4'd0;\n                y_in             = y_in + 4'd0;\n                y                = y + 4'd0;\n                wt1_update       = wt1_update + 4'd0 ;\n                wt2_update       = wt2_update + 4'd0 ;\n                bias_update      = bias_update + 4'd0 ;\n                epoch_counter    = epoch_counter + 0;\n            end\n            4'd3: begin\n                if (y != target) begin\n                    wt1_update  = learning_rate * x1 * target ;\n                    wt2_update  = learning_rate * x2 * target ;\n                    bias_update = learning_rate * target ; \n                end else begin\n                    wt1_update  = 0 ;\n                    wt2_update  = 0 ;\n                    bias_update = 0 ;     \n                end    \n                percep_wt_1_reg = percep_wt_1_reg + wt1_update;\n                percep_wt_2_reg = percep_wt_2_reg + wt2_update;\n                percep_bias_reg = percep_bias_reg + bias_update;\n                prev_wt1_update  = prev_wt1_update  + 4'd0;\n                prev_wt2_update  = prev_wt2_update  + 4'd0;\n                prev_bias_update = prev_bias_update + 4'd0;\n                y_in             = y_in + 4'd0;\n                y                = y + 4'd0;\n                stop             = stop + 1'b0;\n                input_index      = input_index + 0;\n                next_addr        = next_addr + 4'd0;\n                target           = target + 4'd0;\n                epoch_counter    = epoch_counter + 0;\n            end\n            4'd4: begin\n                if ((prev_wt1_update == wt1_update) & (prev_wt2_update == wt2_update) & (input_index == 4'd3)) begin \n                    epoch_counter    = 0;\n                    stop            = 1'b1; \n                    input_index     = 0;\n                    next_addr       = 4'd0;\n                    percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                    percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                    percep_bias_reg = percep_bias_reg + 4'd0;\n                    prev_wt1_update = prev_wt1_update + 4'd0;\n                    prev_wt2_update = prev_wt2_update + 4'd0;\n                    prev_bias_update= prev_bias_update + 4'd0;\n                    y_in            = y_in + 4'd0;\n                    y               = y + 4'd0;\n                    target          = target + 4'd0;\n                    wt1_update      = wt1_update + 4'd0 ;\n                    wt2_update      = wt2_update + 4'd0 ;\n                    bias_update     = bias_update + 4'd0 ;\n                end else begin\n                    stop             = 1'b0; \n                    input_index      = input_index + 0;\n                    epoch_counter    = epoch_counter + 1;    \n                    next_addr        = 4'd5;    \n                    percep_wt_1_reg  = percep_wt_1_reg + 4'd0;\n                    percep_wt_2_reg  = percep_wt_2_reg + 4'd0;\n                    percep_bias_reg  = percep_bias_reg + 4'd0;\n                    prev_wt1_update  = prev_wt1_update + 4'd0;\n                    prev_wt2_update  = prev_wt2_update + 4'd0;\n                    prev_bias_update = prev_bias_update + 4'd0;\n                    y_in             = y_in + 4'd0;\n                    y                = y + 4'd0;\n                    target           = target + 4'd0;\n                    wt1_update       = wt1_update + 4'd0 ;\n                    wt2_update       = wt2_update + 4'd0 ;\n                    bias_update      = bias_update + 4'd0 ;\n                end\n            end\n            4'd5: begin\n                percep_wt_1_reg  = percep_wt_1_reg + 4'd0;\n                percep_wt_2_reg  = percep_wt_2_reg + 4'd0;\n                percep_bias_reg  = percep_bias_reg + 4'd0;\n                prev_wt1_update  = wt1_update;\n                prev_wt2_update  = wt2_update;\n                prev_bias_update = bias_update;\n                next_addr        = 4'd1;\n                input_index      = input_index + 1;\n                stop             = stop + 1'b0;\n                epoch_counter    = epoch_counter + 0;\n                y_in             = y_in + 4'd0;\n                y                = y + 4'd0;\n                target           = target + 4'd0;\n                wt1_update       = wt1_update + 4'd0;\n                wt2_update       = wt2_update + 4'd0;\n                bias_update      = bias_update + 4'd0;\n            end   \n            default: begin\n                next_addr         = next_addr + 4'd0;\n                percep_wt_1_reg   = percep_wt_1_reg + 4'd0;\n                percep_wt_2_reg   = percep_wt_2_reg + 4'd0;\n                percep_bias_reg   = percep_bias_reg + 4'd0;\n                prev_wt1_update   = prev_wt1_update + 4'd0;\n                prev_wt2_update   = prev_wt2_update + 4'd0;\n                prev_bias_update  = prev_bias_update + 4'd0;\n                stop              = stop + 1'b0;\n                y_in              = y_in + 4'd0;\n                y                 = y + 4'd0;\n                input_index       = input_index + 0;\n                target            = target + 4'd0;\n                wt1_update        = wt1_update + 4'd0 ;\n                wt2_update        = wt2_update + 4'd0 ;\n                bias_update       = bias_update + 4'd0 ;\n                epoch_counter     = epoch_counter + 0;\n            end\n        endcase\n    end\n\n    assign percep_w1   = percep_wt_1_reg;\n    assign percep_w2   = percep_wt_2_reg;\n    assign percep_bias = percep_bias_reg;\n\nendmodule\n\n`timescale 1ns/1ps\nmodule gate_target(\n    input  logic        [1:0] gate_select,\n    input  logic              target_select,\n    output logic signed [3:0] o_1,\n    output logic signed [3:0] o_2,\n    output logic signed [3:0] o_3,\n    output logic signed [3:0] o_4\n);\n    always @(*) begin\n        case (gate_select)\n            2'b00: begin \n                case (target_select)\n                    1'b0: begin\n                        o_1 =  4'b0001; \n                        o_2 = -4'b0001; \n                        o_3 = -4'b0001; \n                        o_4 = -4'b0001; \n                    end\n                    1'b1: begin\n                        o_1 = -4'b0001;\n                        o_2 = -4'b0001;\n                        o_3 = -4'b0001;\n                        o_4 =  4'b0001;\n                    end\n                    default: begin\n                        o_1 = 4'b0000; \n                        o_2 = 4'b0000; \n                        o_3 = 4'b0000; \n                        o_4 = 4'b0000; \n                    end\n                endcase\n            end\n            2'b01: begin \n                case (target_select)\n                    1'b0: begin  \n                        o_1 =  4'b0001; \n                        o_2 =  4'b0001; \n                        o_3 =  4'b0001; \n                        o_4 = -4'b0001; \n                    end\n                    1'b1: begin  \n                        o_1 =  4'b0001; \n                        o_2 =  4'b0001; \n                        o_3 = -4'b0001; \n                        o_4 =  4'b0001;\n                    end\n                    default: begin\n                        o_1 = 4'b0000; \n                        o_2 = 4'b0000; \n                        o_3 = 4'b0000; \n                        o_4 = 4'b0000; \n                    end\n                endcase\n            end                \n            2'b10: begin \n                case (target_select)\n                    1'b0: begin\n                        o_1 =  4'b0001; \n                        o_2 =  4'b0001; \n                        o_3 =  4'b0001; \n                        o_4 = -4'b0001; \n                    end\n                    1'b1: begin\n                        o_1 =  4'b0001;\n                        o_2 =  4'b0001;\n                        o_3 = -4'b0001;\n                        o_4 =  4'b0001;\n                    end\n                    default: begin\n                        o_1 = 4'b0000; \n                        o_2 = 4'b0000; \n                        o_3 = 4'b0000; \n                        o_4 = 4'b0000; \n                    end\n                endcase\n            end\n            2'b11: begin \n                case (target_select)\n                    1'b0: begin \n                        o_1 =  4'b0001; \n                        o_2 = -4'b0001; \n                        o_3 = -4'b0001; \n                        o_4 = -4'b0001; \n                    end\n                    1'b1: begin\n                        o_1 = -4'b0001; \n                        o_2 =  4'b0001; \n                        o_3 = -4'b0001; \n                        o_4 = -4'b0001;\n                    end\n                    default: begin\n                        o_1 = 4'b0000; \n                        o_2 = 4'b0000; \n                        o_3 = 4'b0000; \n                        o_4 = 4'b0000; \n                    end\n                endcase\n            end\n            default: begin\n                o_1 = 4'b0000; \n                o_2 = 4'b0000; \n                o_3 = 4'b0000; \n                o_4 = 4'b0000; \n            end\n        endcase\n    end\nendmodule\n\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    for line in lines[2:]:\n        info = line.split()\n        while len(info) < 3:\n            info.append(\"0%\")\n        inst = re.sub(r'[\\W]', '', info[0])\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'uut' is missing in the coverage log.\")\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))\n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['uut']['Average']}, Target: {target}\"\n    \n"}}}
{"id": "cvdp_copilot_perceptron_0019", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the SystemVerilog testbench `tb_perceptron_gates` to add the checker functionality to test the `perceptron_gates` module. The testbench provided in the context already has a stimulus generator for many test cases. The purpose of the testbench checker is to verify the functionality of the Perceptron Gates against the given design specification.\n\n## Design Specification:\nThe `perceptron_gates` module handles weight initialization, computation of perceptron outputs, target selection based on input indexes, and weight and bias updates. It features a microcoded approach for defining operational states, ensuring flexibility and reusability for perceptron-based learning tasks.\n\n## Interface\n## Inputs\n- `clk` (1-bit): Positive edge-triggered clock signal for calculating the microcode ROM address.\n- `rst_n` (1-bit): Negative edge-triggered reset signal. When ACTIVE LOW, `present_addr` is initialized to `4'd0`.\n- `x1`, `x2` (4-bit,[3:0], signed): Perceptron inputs. Can take only Bipolar values [`4'd1`,`-4'd1`]\n- `learning_rate` (1-bit): Learning rate for weight and bias updates.\n- `threshold` (4-bit,[3:0], signed): Threshold value for response calculation.\n- `gate_select` (2-bit,[1:0]): Specifies the gate type for determining target outputs.\n\n## Outputs\n- `percep_w1`, `percep_w2` (4-bit, [3:0], signed): Current weights of the perception. Can take Bipolar Values [`4'd1`,`-4'd1`]\n- `percep_bias` (4-bit,[3:0], signed): Current bias of the perception.Can take Bipolar Values [`4'd1`,`-4'd1`]\n- `present_addr` (4-bit,[3:0]): Current microcode ROM address.\n- `stop` (1-bit): Indicates the end of training.\n- `input_index` (3-bit,[2:0]): Tracks the current target value selected during an iteration. Can take values from 3'd0 to 3'd3.\n- `y_in` (4-bit,[3:0] signed): Computed perception output. Can take Bipolar values [`4'd1`,`-4'd1`]\n- `y` (4-bit, [3:0], signed): Perceptron output after applying the threshold.Can take three different values [`4'd1`,`4'd0`,`-4'd1`]\n- `prev_percep_wt_1`, `prev_percep_wt_2`, `prev_percep_bias` (4-bit, [3:0], signed): Weights and Bias during a previous iteration. Can take Bipolar values [`4'd1`, `-4'd1`]\n\n## Submodule Overview\n### 1. Gate Target (`gate_target`)\nGenerates target outputs (`t1`, `t2`, `t3`, `t4`) based on the selected gate type.\n- Inputs: `gate_select` (2-bit,[1:0]).\n- Outputs : `o_1`, `o_2`, `o_3`, `o_4` (4-bit, [3:0],signed).\n- Gates implemented: AND, OR, NAND, and NOR gates.\n   - `gate_select`:\n         - `2'b00` : AND Gate    ; target values : (`4'd1`,`-4'd1`,`-4'd1`,`-4'd1`)\n         - `2'b01` : OR Gate      ; target values : (`4'd1`, `4'd1`, `4'd1`,`-4'd1`)\n         - `2'b10` : NAND Gate ; target values : (`4'd1`, `4'd1`, `4'd1`,`-4'd1`) \n         - `2'b11` : NOR Gate   ;  target values : (`4'd1`, `-4'd1`, `-4'd1`,`-4'd1`) \n         \n### 2. Microcode ROM\n- Defines a sequence of 6 micro-instructions, specifying actions such as weight initialization, output computation, target selection, and weight/bias updates.\n\n## Algorithm Steps for Perceptron Learning\n- Initialization: All weights, biases, and counters are set to zero.\n- Compute Output: Compute `y_in` = `bias` + (`x1` * `w1`) + (`x2` * `w2`) and compare with the threshold to determine `y`.\n- Select Target: Based on `gate_select` and` input_index`, pick the desired target value\n- Update Weights and Bias: Adjust weights and bias  based on the condition (`y` != `target`)\n  -  If the condition is satisfied\n        - `wt1_update` = `learning_rate` * `x1` * `target`\n        - `wt2_update` = `learning_rate` * `x2` * `target`\n        - `bias_update` = `learning_rate` * `target`\n   - If the condition is not satisfied\n        - `wt1_update` = 0\n        - `wt2_update` = 0\n        - `bias_update` = 0\n  - The value of current weights and bias is calculated as follows :\n       - `percep_wt1` = `percep_w1` + `wt1_update`\n       - `percep_wt2` = `percep_wt2` + `wt2_update`\n       - `percep_bias` = `percep_bias` + `bias_update`\n- Check if the `wt1_update`, `wt2_update` , and `bias_update` values are equal to their previous iteration values. If the condition is satisfied, stop the learning. Otherwise assign the `wt1_update`, `wt2_update`, and `bias_update` values to their previous iteration values and continue learning.\n                                                 \n## Control Flow\n### Microcoded Actions\n- Action 0: Initialize weights and bias to zero.\n- Action 1: Compute `y_in` (weighted sum + bias) and `y` (thresholded output).\n- Action 2: Select target value based on `input_index `and `gate type`.\n- Action 3: Update weights and bias if the perceptron output differs from the target.\n- Action 4: Compare current and previous weights and bias to determine convergence.\n- Action 5: Finalize updates and prepare for the next epoch.\n**An epoch is the time taken to train the perceptron for a given combination of four input values**\n\n## Key Features\n- Microcoded Sequencing: Flexible execution of training steps using `microcode ROM`.\n- Dynamic Target Selection: Allows gate-based logic outputs for versatile applications.\n- Sequential Updates: Tracks and applies weight changes across iterations.\n- Convergence Monitoring: Halts training when weights stabilize.\n\n## **Checker Requirements**:\n### **Validation Logic** :\n- The testbench should drive a complete test case by applying specific input signals (such as `x1`, `x2`, `learning_rate`, `threshold`, and `gate_select`) to the DUT and, after a defined delay, should compare the actual outputs (`percep_w1`, `percep_w2`, and `percep_bias`) with their expected values using `check_signal` task.\n- Display results (pass/fail) for each test case. \n- Provide error messages when the actual and expected outputs do not match.\n\n## Deliverables:\nProvide a complete SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `perceptron_gates` module.", "context": {"verif/tb_perceptron_gates.sv": "`timescale 1ns/1ps\n\nmodule tb_perceptron_gates;\n\n    logic clk;\n    logic rst_n;\n\n    logic signed [3:0] x1;\n    logic signed [3:0] x2;\n    logic learning_rate;\n    logic signed [3:0] threshold;\n    logic [1:0] gate_select;\n\n    logic signed [3:0] percep_w1;\n    logic signed [3:0] percep_w2;\n    logic signed [3:0] percep_bias;\n    logic [3:0] present_addr;\n    logic stop;\n    logic [2:0] input_index;\n    logic signed [3:0] y_in;\n    logic signed [3:0] y;\n    logic signed [3:0] prev_percep_wt_1;\n    logic signed [3:0] prev_percep_wt_2;\n    logic signed [3:0] prev_percep_bias;\n\n    perceptron_gates dut (\n        .clk(clk),\n        .rst_n(rst_n),\n        .x1(x1),\n        .x2(x2),\n        .learning_rate(learning_rate),\n        .threshold(threshold),\n        .gate_select(gate_select),\n        .percep_w1(percep_w1),\n        .percep_w2(percep_w2),\n        .percep_bias(percep_bias),\n        .present_addr(present_addr),\n        .stop(stop),\n        .input_index(input_index),\n        .y_in(y_in),\n        .y(y),\n        .prev_percep_wt_1(prev_percep_wt_1),\n        .prev_percep_wt_2(prev_percep_wt_2),\n        .prev_percep_bias(prev_percep_bias)\n    );\n\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    initial begin\n        rst_n = 0;\n        #10 rst_n = 1;\n    end\n\n    initial begin\n        x1 = 0;\n        x2 = 0;\n        learning_rate = 1;\n        threshold = 4'd0;\n        gate_select = 2'b00;\n\n        @(posedge rst_n);\n        #10;\n\n        gate_select = 2'b00;\n\n        x1 = 4'd1; x2 = 4'd1; \n        #85;\n        x1 = 4'd1; x2 = -4'd1;\n        #90;\n        x1 = -4'd1; x2 = 4'd1; \n        #100;\n        x1 = -4'd1; x2 = -4'd1; \n        #100;\n        x1 = 4'd1; x2 = 4'd1;\n        #100;\n        x1 = 4'd1; x2 = -4'd1;\n        #100;\n        x1 = -4'd1; x2 = 4'd1;\n        #100;\n        x1 = -4'd1; x2 = -4'd1; \n        #115;\n       \n        gate_select = 2'b01;\n        x1 = 4'd1; x2 = 4'd1;\n        #90;\n        x1 = -4'd1; x2 = 4'd1;\n        #95;\n        x1 = 4'd1; x2 = -4'd1;\n        #110;\n        x1 = -4'd1; x2 = -4'd1;\n        #100;\n       \n        gate_select = 2'b10;\n        x1 = -4'd1; x2 = -4'd1;\n        #90;\n        x1 = -4'd1; x2 = 4'd1;\n        #110;\n        x1 = 4'd1; x2 = -4'd1;\n        #100;\n        x1 = 4'd1; x2 = 4'd1;\n        #105;\n       \n        gate_select = 2'b11;\n        x1 = -4'd1; x2 = -4'd1;\n        #90;\n        x1 = -4'd1; x2 = 4'd1;\n        #100;\n        x1 = 4'd1; x2 = -4'd1;\n        #105;\n        x1 = 4'd1; x2 = 4'd1;\n        #95;\n        x1 = -4'd1; x2 = -4'd1;\n        #100;\n        x1 = -4'd1; x2 = 4'd1;\n        #100;\n        x1 = 4'd1; x2 = -4'd1;\n        #100;\n        x1 = 4'd1; x2 = 4'd1;\n        #100;\n        $finish;\n    end\n\n    initial begin\n        $monitor($time, \" gate_select=%b, x1=%d, x2=%d, percep_w1=%d, percep_w2=%d, percep_bias=%d, present_addr=%b, stop = %b , input_index = %b,y_in = %b , y = %b , prev_percep_wt_1 = %d,prev_percep_wt_2 = %d , prev_percep_bias = %d\",\n                 gate_select, x1, x2, percep_w1, percep_w2, percep_bias, present_addr, stop, input_index, y_in, y, prev_percep_wt_1, prev_percep_wt_2, prev_percep_bias);\n    end\n\nendmodule\n"}}, "output": {"response": "", "context": {"verif/tb_perceptron_gates.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 1e0ece0273ca38e3ec6ad92515798dcda9facf32\nNUM_BUGS        = 9\n", "src/perceptron_gates.sv": "`timescale 1ns/1ps\nmodule perceptron_gates (\n   input  logic clk,                  // Posedge clock\n   input  logic rst_n,                // Negedge reset\n   input  logic signed [3:0] x1,        // First Input of the Perceptron\n   input  logic signed [3:0] x2,        // Second Input of the Perceptron\n   input  logic learning_rate,          // Learning rate (alpha)\n   input  logic signed [3:0] threshold, // Threshold value\n   input  logic [1:0] gate_select,      // Gate selection for target values\n   output logic signed [3:0] percep_w1, // Trained Weight 1 \n   output logic signed [3:0] percep_w2, // Trained Weight 2\n   output logic signed [3:0] percep_bias, // Trained Bias\n   output logic [3:0] present_addr,     // Current address in microcode ROM\n   output logic stop,                   // Condition to indicate no learning has occurred(i.e. no weight change between iterations)\n   output logic [2:0] input_index,      // Vector to track the selection of target for a given input combination for a gate\n   output logic signed [3:0] y_in,       // Calculated Response\n   output logic signed [3:0] y,          // Calculated Response obtained by comparing y_in against a threshold value\n   output logic signed [3:0] prev_percep_wt_1, // Value of Weight 1 during a previous iteration\n   output logic signed [3:0] prev_percep_wt_2, // Value of Weight 2 during a previous iteration\n   output logic signed [3:0] prev_percep_bias  // Value of Bias during a previous iteration\n);\n\n   logic [15:0] microcode_rom [0:5];\n   logic [3:0]  next_addr;\n   logic [3:0]  train_action;\n   logic [3:0]  microcode_addr;\n   logic [15:0] microinstruction;\n   logic signed [3:0] t1, t2, t3, t4;\n   \n   gate_target dut (\n       .gate_select(gate_select),\n       .o_1(t1),\n       .o_2(t2),\n       .o_3(t3),\n       .o_4(t4)\n   );\n\n   logic signed [3:0] percep_wt_1_reg;\n   logic signed [3:0] percep_wt_2_reg;\n   logic signed [3:0] percep_bias_reg;\n\n   logic signed [3:0] target;\n   logic signed [3:0] prev_wt1_update;\n   logic signed [3:0] prev_wt2_update;\n   logic signed [3:0] prev_bias_update;\n   \n   logic signed [3:0] wt1_update;\n   logic signed [3:0] wt2_update;\n   logic signed [3:0] bias_update;\n   logic [7:0] epoch_counter;\n   \n   `ifdef BUG_0\n      initial begin\n         $display(\"BUG_0 is ACTIVE\");\n      end\n   `else\n      initial begin\n         $display(\"BUG_0 is NOT ACTIVE\");\n      end\n   `endif\n\n   `ifdef BUG_1\n      initial begin\n         $display(\"BUG_1 is ACTIVE\");\n      end\n   `else\n      initial begin\n         $display(\"BUG_1 is NOT ACTIVE\");\n      end\n   `endif\n\n   `ifdef BUG_2\n      initial begin\n         $display(\"BUG_2 is ACTIVE\");\n      end\n   `else\n      initial begin\n         $display(\"BUG_2 is NOT ACTIVE\");\n      end\n   `endif\n\n   `ifdef BUG_3\n      initial begin\n         $display(\"BUG_3 is ACTIVE\");\n      end\n   `else\n      initial begin\n         $display(\"BUG_3 is NOT ACTIVE\");\n      end\n   `endif\n\n   `ifdef BUG_4\n      initial begin\n         $display(\"BUG_4 is ACTIVE\");\n      end\n   `else\n      initial begin\n         $display(\"BUG_4 is NOT ACTIVE\");\n      end\n   `endif\n\n   `ifdef BUG_5\n      initial begin\n         $display(\"BUG_5 is ACTIVE\");\n      end\n   `else\n      initial begin\n         $display(\"BUG_5 is NOT ACTIVE\");\n      end\n   `endif\n\n   `ifdef BUG_6\n      initial begin\n         $display(\"BUG_6 is ACTIVE\");\n      end\n   `else\n      initial begin\n         $display(\"BUG_6 is NOT ACTIVE\");\n      end\n   `endif\n\n   `ifdef BUG_7\n      initial begin\n         $display(\"BUG_7 is ACTIVE\");\n      end\n   `else\n      initial begin\n         $display(\"BUG_7 is NOT ACTIVE\");\n      end\n   `endif\n\n   `ifdef BUG_8\n      initial begin\n         $display(\"BUG_8 is ACTIVE\");\n      end\n   `else\n      initial begin\n         $display(\"BUG_8 is NOT ACTIVE\");\n      end\n   `endif\n   \n   `ifndef BUG_0\n      initial begin \n         microcode_rom[0] = 16'b0001_0000_0000_0000; \n         microcode_rom[1] = 16'b0010_0001_0000_0000; \n         microcode_rom[2] = 16'b0011_0010_0000_0000; \n         microcode_rom[3] = 16'b0100_0011_0000_0000; \n         microcode_rom[4] = 16'b0101_0100_0000_0000; \n         microcode_rom[5] = 16'b0000_0101_0000_0000; \n      end \n   `else\n      initial begin \n         microcode_rom[0] = 16'b0000_0000_0000_0000; \n         microcode_rom[1] = 16'b0000_0000_0000_0000; \n         microcode_rom[2] = 16'b0000_0000_0000_0000; \n         microcode_rom[3] = 16'b0000_0000_0000_0000; \n         microcode_rom[4] = 16'b0000_0000_0000_0000; \n         microcode_rom[5] = 16'b0000_0000_0000_0000; \n      end\n   `endif \n   \n   `ifndef BUG_1 \n      always @(*) begin\n         microinstruction = microcode_rom[microcode_addr];\n         next_addr        = microinstruction[15:12];\n         train_action     = microinstruction[11:8];\n      end\n   `else\n      always @(*) begin\n         microinstruction = microcode_rom[microcode_addr];\n         next_addr        = microinstruction[15:10];\n         train_action     = microinstruction[9:0];\n      end\n   `endif\n   \n   `ifndef BUG_2\n      always @(posedge clk or negedge rst_n) begin\n         if (!rst_n) begin\n            present_addr    <= 4'd0;\n            microcode_addr  <= 4'd0;\n            percep_wt_1_reg <= 4'd0;\n            percep_wt_2_reg <= 4'd0;\n            percep_bias_reg <= 4'd0;\n            input_index     <= 2'd0;\n            stop            <= 1'b0;\n         end else begin\n            present_addr    <= next_addr;\n            microcode_addr  <= present_addr;\n         end\n      end\n   `else\n      always @(posedge clk or negedge rst_n) begin\n         if (!rst_n) begin\n            present_addr    <= 4'd0;\n            microcode_addr  <= 4'd0;\n            percep_wt_1_reg <= 4'd0;\n            percep_wt_2_reg <= 4'd0;\n            percep_bias_reg <= 4'd0;\n            input_index     <= 2'd0;\n            stop            <= 1'b0;\n         end else begin\n            present_addr    <= 4'd0;\n            microcode_addr  <= 4'd0;\n         end\n      end\n   `endif\n   \n   assign prev_percep_wt_1 = prev_wt1_update;\n   assign prev_percep_wt_2 = prev_wt2_update;\n   assign prev_percep_bias = prev_bias_update;\n   \n   always @(*) begin\n      case (train_action)\n         `ifndef BUG_3\n            4'd0:  begin \n                      percep_wt_1_reg = 4'd0;\n                      percep_wt_2_reg = 4'd0;\n                      percep_bias_reg = 4'd0;\n                      stop = 1'b0;\n                      next_addr = next_addr + 4'd0;\n                      y_in = 4'd0;\n                      y    = 4'd0;\n                      prev_wt1_update = 4'd0;\n                      prev_wt2_update = 4'd0;\n                      prev_bias_update = 4'd0;\n                      input_index = 0;\n                      target = 0;\n                      wt1_update = 0;\n                      wt2_update = 0;\n                      bias_update = 0;\n                      epoch_counter = 0;\n                   end\n         `else\n            4'd0:  begin \n                      percep_wt_1_reg = 4'd0;\n                      percep_wt_2_reg = 4'd0;\n                      percep_bias_reg = 4'd0;\n                      stop = 1'b0;\n                      next_addr = 4'd15;\n                      y_in = 4'd0;\n                      y    = 4'd0;\n                      prev_wt1_update = 4'd15;\n                      prev_wt2_update = 4'd15;\n                      prev_bias_update = 4'd15;\n                      input_index = 7;\n                      target = 0;\n                      wt1_update = 15;\n                      wt2_update = 15;\n                      bias_update = 15;\n                      epoch_counter = 0;\n                   end\n         `endif\n         `ifndef BUG_4     \n            4'd1 : begin \n                      y_in = percep_bias_reg + (x1 * percep_wt_1_reg) + (x2 * percep_wt_2_reg); \n                      if (y_in > threshold)\n                         y = 4'd1;\n                      else if (y_in >= -threshold && y_in <= threshold)\n                         y = 4'd0;\n                      else\n                         y = -4'd1;\n                   \n                      percep_wt_1_reg  = percep_wt_1_reg  + 4'd0;\n                      percep_wt_2_reg  = percep_wt_2_reg  + 4'd0;\n                      percep_bias_reg  = percep_bias_reg  + 4'd0;\n                      prev_wt1_update  = prev_wt1_update  + 4'd0;\n                      prev_wt2_update  = prev_wt2_update  + 4'd0;\n                      prev_bias_update = prev_bias_update + 4'd0;\n                      input_index = input_index + 0;\n                      next_addr = next_addr + 4'd0;\n                      stop = stop + 1'b0;\n                      target = target + 4'd0;\n                      wt1_update = wt1_update + 4'd0;\n                      wt2_update = wt2_update + 4'd0;\n                      bias_update = bias_update + 4'd0;\n                      epoch_counter = epoch_counter + 0;\n                   end\n          `else\n                   4'd1 : begin \n                      y_in = percep_bias_reg + (x1 * percep_wt_1_reg) + (x2 * percep_wt_2_reg); \n                      if (y_in > threshold)\n                         y = 4'd0;\n                      else if (y_in >= -threshold && y_in <= threshold)\n                         y = 4'd0;\n                      else\n                         y = 4'd0;\n                   \n                      percep_wt_1_reg  = percep_wt_1_reg  + 4'd0;\n                      percep_wt_2_reg  = percep_wt_2_reg  + 4'd0;\n                      percep_bias_reg  = percep_bias_reg  + 4'd0;\n                      prev_wt1_update  = prev_wt1_update  + 4'd0;\n                      prev_wt2_update  = prev_wt2_update  + 4'd0;\n                      prev_bias_update = prev_bias_update + 4'd0;\n                      input_index = input_index + 0;\n                      next_addr = next_addr + 4'd0;\n                      stop = 0;\n                      target = 0;\n                      wt1_update = 0;\n                      wt2_update = 0;\n                      bias_update = 0;\n                      epoch_counter = 0;\n                   end\n         `endif\n         `ifndef BUG_5\n            4'd2 : begin\n                      if(input_index == 0)\n                           target = t1;\n                      else if(input_index == 1)\n                           target = t2;\n                      else if(input_index == 2)\n                           target = t3;\n                      else if(input_index == 3)\n                           target = t4;\n                      else begin\n                           input_index = 0;\n                           target = 0;\n                      end\n                      stop = stop + 1'b0;\n                      input_index = input_index + 0;\n                      next_addr = next_addr + 4'd0;\n                      target = target + 4'd0;\n                      prev_wt1_update  = prev_wt1_update  + 4'd0;\n                      prev_wt2_update  = prev_wt2_update  + 4'd0;\n                      prev_bias_update = prev_bias_update + 4'd0;\n                      \n                      percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                      percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                      percep_bias_reg = percep_bias_reg + 4'd0;\n                      y_in = y_in + 4'd0;\n                      y = y + 4'd0;\n                      wt1_update = wt1_update + 4'd0;\n                      wt2_update = wt2_update + 4'd0;\n                      bias_update = bias_update + 4'd0;\n                      epoch_counter = epoch_counter + 0;\n                   end\n         `else\n                   4'd2 : begin\n                      if(input_index == 0)\n                           target = t4;\n                      else if(input_index == 1)\n                           target = t4;\n                      else if(input_index == 2)\n                           target = t4;\n                      else if(input_index == 3)\n                           target = t4;\n                      else begin\n                           input_index = 3;\n                           target = t4;\n                      end\n                      stop = stop + 1'b1;\n                      input_index = input_index + 1;\n                      next_addr = next_addr + 4'd1;\n                      target = target + 4'd1;\n                      prev_wt1_update  = prev_wt1_update  + 4'd1;\n                      prev_wt2_update  = prev_wt2_update  + 4'd1;\n                      prev_bias_update = prev_bias_update + 4'd1;\n                      \n                      percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                      percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                      percep_bias_reg = percep_bias_reg + 4'd0;\n                      y_in = y_in + 4'd0;\n                      y = y + 4'd0;\n                      wt1_update = wt1_update + 4'd0;\n                      wt2_update = wt2_update + 4'd0;\n                      bias_update = bias_update + 4'd0;\n                      epoch_counter = epoch_counter + 0;\n                   end\n         `endif\n\n         `ifndef BUG_6\n            4'd3 : begin\n                      if (y != target) begin\n                           wt1_update = learning_rate * x1 * target;\n                           wt2_update = learning_rate * x2 * target;\n                           bias_update = learning_rate * target;\n                      end else begin\n                           wt1_update = 0;\n                           wt2_update = 0;\n                           bias_update = 0;\n                      end    \n                      percep_wt_1_reg = percep_wt_1_reg + wt1_update;\n                      percep_wt_2_reg = percep_wt_2_reg + wt2_update;\n                      percep_bias_reg = percep_bias_reg + bias_update;\n                      prev_wt1_update  = prev_wt1_update  + 4'd0;\n                      prev_wt2_update  = prev_wt2_update  + 4'd0;\n                      prev_bias_update = prev_bias_update + 4'd0;\n                      y_in = y_in + 4'd0;\n                      y = y + 4'd0;\n                      stop = stop + 1'b0;\n                      input_index = input_index + 0;\n                      next_addr = next_addr + 4'd0;\n                      target = target + 4'd0;\n                      epoch_counter = epoch_counter + 0;\n                   end\n         `else\n            4'd3 : begin\n                      if (y != target) begin\n                           wt1_update = 0;\n                           wt2_update = 0;\n                           bias_update = 0;\n                      end else begin\n                           wt1_update = 1;\n                           wt2_update = 1;\n                           bias_update = 1;\n                      end    \n                      percep_wt_1_reg = 4'hF;\n                      percep_wt_2_reg = 4'hF;\n                      percep_bias_reg = 4'hF;\n                      prev_wt1_update  = prev_wt1_update  + 4'd0;\n                      prev_wt2_update  = prev_wt2_update  + 4'd0;\n                      prev_bias_update = prev_bias_update + 4'd0;\n                      y_in = y_in + 4'd0;\n                      y = y + 4'd0;\n                      stop = 1'b1;\n                      input_index = input_index + 0;\n                      next_addr = next_addr + 4'd0;\n                      target = target + 4'd0;\n                      epoch_counter = epoch_counter + 0;\n                   end\n         `endif\n\n         `ifndef BUG_7\n            4'd4 : begin\n                      if ((prev_wt1_update == wt1_update) & (prev_wt2_update == wt2_update) & (input_index == 4'd3)) begin \n                           epoch_counter = 0;\n                           stop = 1'b1; \n                           input_index = 0;\n                           next_addr = 4'd0;\n                           percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                           percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                           percep_bias_reg = percep_bias_reg + 4'd0;\n                           prev_wt1_update = prev_wt1_update + 4'd0;\n                           prev_wt2_update = prev_wt2_update + 4'd0;\n                           prev_bias_update = prev_bias_update + 4'd0;\n                           y_in = y_in + 4'd0;\n                           y = y + 4'd0;\n                           target = target + 4'd0;\n                           wt1_update = wt1_update + 4'd0;\n                           wt2_update = wt2_update + 4'd0;\n                           bias_update = bias_update + 4'd0;\n                      end else begin\n                           stop = 1'b0;\n                           input_index = input_index + 0;\n                           epoch_counter = epoch_counter + 1;\n                           next_addr = 4'd5;\n                           percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                           percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                           percep_bias_reg = percep_bias_reg + 4'd0;\n                           prev_wt1_update = prev_wt1_update + 4'd0;\n                           prev_wt2_update = prev_wt2_update + 4'd0;\n                           prev_bias_update = prev_bias_update + 4'd0;\n                           y_in = y_in + 4'd0;\n                           y = y + 4'd0;\n                           target = target + 4'd0;\n                           wt1_update = wt1_update + 4'd0;\n                           wt2_update = wt2_update + 4'd0;\n                           bias_update = bias_update + 4'd0;\n                      end\n                   end\n         `else\n            4'd4 : begin\n                      if ((prev_wt1_update == wt1_update) & (prev_wt2_update == wt2_update) & (input_index == 4'd3)) begin \n                           epoch_counter = 7;\n                           stop = 1'b0; \n                           input_index = 4;\n                           next_addr = 4'd4;\n                           percep_wt_1_reg = 4'd15;\n                           percep_wt_2_reg = 4'd15;\n                           percep_bias_reg = 4'd15;\n                           prev_wt1_update = 4'd15;\n                           prev_wt2_update = 4'd15;\n                           prev_bias_update = 4'd15;\n                           y_in = y_in + 4'd0;\n                           y = y + 4'd0;\n                           target = target + 4'd0;\n                           wt1_update = wt1_update + 4'd0;\n                           wt2_update = wt2_update + 4'd0;\n                           bias_update = bias_update + 4'd0;\n                      end else begin\n                           stop = 1'b0;\n                           input_index = input_index + 5;\n                           epoch_counter = epoch_counter + 5;\n                           next_addr = 4'd4;\n                           percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                           percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                           percep_bias_reg = percep_bias_reg + 4'd0;\n                           prev_wt1_update = prev_wt1_update + 4'd0;\n                           prev_wt2_update = prev_wt2_update + 4'd0;\n                           prev_bias_update = prev_bias_update + 4'd0;\n                           y_in = y_in + 4'd0;\n                           y = y + 4'd0;\n                           target = target + 4'd0;\n                           wt1_update = wt1_update + 4'd0;\n                           wt2_update = wt2_update + 4'd0;\n                           bias_update = bias_update + 4'd0;\n                      end\n                   end\n         `endif\n         `ifndef BUG_8\n            4'd5 : begin\n                      percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                      percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                      percep_bias_reg = percep_bias_reg + 4'd0;\n                      prev_wt1_update  = wt1_update;\n                      prev_wt2_update  = wt2_update;\n                      prev_bias_update = bias_update;\n                      next_addr = 4'd1;\n                      input_index = input_index + 1;\n                      stop = stop + 1'b0;\n                      epoch_counter = epoch_counter + 0;\n                      y_in = y_in + 4'd0;\n                      y = y + 4'd0;\n                      target = target + 4'd0;\n                      wt1_update = wt1_update + 4'd0;\n                      wt2_update = wt2_update + 4'd0;\n                      bias_update = bias_update + 4'd0;\n                   end   \n         `else\n            4'd5 : begin\n                      percep_wt_1_reg = 4'd15;\n                      percep_wt_2_reg = 4'd15;\n                      percep_bias_reg = 4'd15;\n                      prev_wt1_update  = 4'd15;\n                      prev_wt2_update  = 4'd15;\n                      prev_bias_update = 4'd15;\n                      next_addr = 4'd1;\n                      input_index = input_index + 5;\n                      stop = 1;\n                      epoch_counter = epoch_counter + 6;\n                      y_in = y_in + 4'd4;\n                      y = y + 4'd5;\n                      target = target + 4'd3;\n                      wt1_update = wt1_update + 4'd0;\n                      wt2_update = wt2_update + 4'd0;\n                      bias_update = bias_update + 4'd0;\n                   end   \n         `endif\n         default : begin\n                      next_addr = next_addr + 4'd0;\n                      percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                      percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                      percep_bias_reg = percep_bias_reg + 4'd0;\n                      prev_wt1_update = prev_wt1_update + 4'd0;\n                      prev_wt2_update = prev_wt2_update + 4'd0;\n                      prev_bias_update = prev_bias_update + 4'd0;\n                      stop = stop + 1'b0;\n                      y_in = y_in + 4'd0;\n                      y = y + 4'd0;\n                      input_index = input_index + 0;\n                      target = target + 4'd0;\n                      wt1_update = wt1_update + 4'd0;\n                      wt2_update = wt2_update + 4'd0;\n                      bias_update = bias_update + 4'd0;\n                      epoch_counter = epoch_counter + 0;\n                   end\n      endcase\n   end\n   assign percep_w1 = percep_wt_1_reg;\n   assign percep_w2 = percep_wt_2_reg;\n   assign percep_bias = percep_bias_reg;\n\nendmodule\n\n`timescale 1ns/1ps\nmodule gate_target(\n   input  logic [1:0] gate_select,\n   output logic signed [3:0] o_1,\n   output logic signed [3:0] o_2,\n   output logic signed [3:0] o_3,\n   output logic signed [3:0] o_4\n);\n   always @(*) begin\n      case(gate_select)\n         2'b00 : begin \n                   o_1 =  1; \n                   o_2 = -1; \n                   o_3 = -1; \n                   o_4 = -1; \n                 end\n         2'b01 : begin \n                   o_1 =  1; \n                   o_2 =  1; \n                   o_3 =  1; \n                   o_4 = -1; \n                 end\n         2'b10 : begin \n                   o_1 =  1; \n                   o_2 =  1; \n                   o_3 =  1; \n                   o_4 = -1; \n                 end\n         2'b11 : begin \n                   o_1 =  1; \n                   o_2 = -1; \n                   o_3 = -1; \n                   o_4 = -1; \n                 end\n         default : begin\n                      o_1 =  0; \n                      o_2 =  0; \n                      o_3 =  0; \n                      o_4 =  0; \n                   end\n      endcase\n   end\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n        \n"}}}
{"id": "cvdp_copilot_ping_pong_buffer_0004", "categories": ["cid012", "easy"], "input": {"prompt": "Complete the Ping-Pong Buffer Testbench in SystemVerilog. The testbench must instantiate the `ping_pong_buffer` RTL module and provide input stimulus for it, focusing exclusively on generating test vectors rather than building a full testbench.  \nThe `ping_pong_buffer` module simulates a dual-buffer system that allows concurrent read/write operations while alternating between two buffers.\n\n---\n\n## **Description**:\n### **Inputs** :\n\n- **Registers**:\n  - `clk` (1-bit): Active high Clock signal that toggles every **10 ns** (100 MHz) and is supplied to the **DUT**.\n  - `rst_n` (1-bit): **Active-low** asynchronous reset signal that resets the buffer and control logic of the **DUT**.\n  - `write_enable` (1-bit): Enables writing of data into the buffer.\n  - `read_enable` (1-bit): Enables reading of data from the buffer.\n  - `data_in` (8-bit, `[7:0]`): 8-bit input data that is written into the buffer.\n\n### **Outputs** :\n\n- **Registers**:\n  - `data_out` (8-bit, `[7:0]`): 8-bit output data read from the buffer.\n  - `buffer_full` (1-bit): Indicates whether the buffer is full.\n  - `buffer_empty` (1-bit): Indicates whether the buffer is empty.\n  - `buffer_select` (1-bit): Indicates the currently active buffer.\n\n---\n\n## **Instantiation**:\nThe testbench instantiates the `ping_pong_buffer` module as `dut` and connects the signals between the module and the testbench. Each input and output from the **DUT** is connected to its corresponding signal in the testbench.\n\n---\n\n## **Input Generation and Validation**:\n### **Clock Generation**:  \nThe Active high clock signal `clk` is generated using an `always` block that toggles every **10 ns**.\n\n### **Reset**:  \nThe Asynchronous reset signal `rst_n` is **asserted** at the beginning of the simulation to ensure the **DUT** initializes correctly. After a short period (**150 ns**), the reset is **de-asserted**.\n\n### **Stimulus**:  \nMultiple test cases are applied to simulate various buffer conditions and validate the correct behavior of the **ping-pong buffer**:\n\n- **Test Case 1: Basic Write and Read**\n  - **Write** values sequentially into the buffer.\n  - **Read** them back to verify correct data storage and retrieval.\n\n- **Test Case 2: Buffer Alternation**\n  - Write `DEPTH` elements to trigger **buffer switch**.\n  - Ensure correct alternation between ping and pong buffers.\n\n- **Test Case 3: Writing to Full Buffer**\n  - Fill the buffer.\n  - Attempt an extra write and verify **buffer_full** signal.\n\n- **Test Case 4: Reading from Empty Buffer**\n  - Ensure `buffer_empty` is asserted when reading beyond available data.\n\n- **Test Case 5: Reset Handling**\n  - Apply **reset** during active operations.\n  - Ensure buffer returns to **initial state**.\n\n- **Test Case 6: Edge Case - Minimum Data**\n  - Write and read a **single byte**.\n  - Ensure correct behavior in minimal operation scenarios.\n\n- **Test Case 7: Edge Case - Maximum Data**\n  - Write **DEPTH** elements.\n  - Read all data and verify **buffer alternation**.\n\n---\n\n## **Reset Handling**:\nAfter running the test cases, a **reset is asserted again** to verify that the buffer properly resets and returns to the **initial state**, with `buffer_empty` asserted.\n\n---\n\n```systemverilog\nmodule tb_ping_pong_buffer;\n\n    localparam DEPTH = 256;\n\n    logic clk;\n    logic rst_n;\n    logic write_enable;\n    logic read_enable;\n    logic [7:0] data_in;\n    logic [7:0] data_out;\n    logic buffer_full;\n    logic buffer_empty;\n    logic buffer_select;\n\n    // Instantiate the DUT\n    ping_pong_buffer dut (\n        .clk(clk),\n        .rst_n(rst_n),\n        .write_enable(write_enable),\n        .read_enable(read_enable),\n        .data_in(data_in),\n        .data_out(data_out),\n        .buffer_full(buffer_full),\n        .buffer_empty(buffer_empty),\n        .buffer_select(buffer_select)\n    );\n\n    // Clock generation\n    always #5 clk = ~clk;\n\n    initial begin\n        // Initialize signals\n        clk = 0;\n        rst_n = 0;\n        write_enable = 0;\n        read_enable = 0;\n        data_in = 0;\n\n        $display(\"Applying Reset...\");\n        #10 rst_n = 1;\n\n        $display(\"Testing Basic Write and Read Operations...\");\n        for (int i = 0; i < 10; i++) begin\n            @(posedge clk);\n            write_enable = 1;\n            data_in = i;\n            @(posedge clk);\n            write_enable = 0;\n            @(posedge clk);\n            read_enable = 1;\n            @(posedge clk);\n            read_enable = 0;\n            @(posedge clk);\n        end\n\n        // Insert code here to complete the Testbench\n\nendmodule\n```", "context": {}}, "output": {"response": "", "context": {"verif/tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 7383cb8040a89816460bf534da92ebf67c6a6e21\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/ping_pong_buffer.sv": "module ping_pong_buffer (\n    input logic clk,\n    input logic rst_n,\n    input logic write_enable,\n    input logic read_enable,\n    input logic [7:0] data_in,\n    output logic [7:0] data_out,\n    output logic buffer_full,\n    output logic buffer_empty,\n    output reg buffer_select\n);\n\n    localparam DEPTH = 256; \n    localparam ADDR_WIDTH = 8; \n\n    logic [ADDR_WIDTH-1:0] write_ptr, read_ptr; \n    logic [7:0] data_out0, data_out1; \n\n    // Memory 0\n    dual_port_memory memory0 (\n        .clk(clk),\n        .we(write_enable && !buffer_select && !buffer_full),\n        .write_addr(write_ptr),\n        .din(data_in),\n        .read_addr(read_ptr),\n        .dout(data_out0)\n    );\n\n    // Memory 1\n    dual_port_memory memory1 (\n        .clk(clk),\n        .we(write_enable && buffer_select && !buffer_full),\n        .write_addr(write_ptr),\n        .din(data_in),\n        .read_addr(read_ptr),\n        .dout(data_out1)\n    );\n\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            write_ptr <= 0;\n            read_ptr <= 0;\n            buffer_select <= 0;\n            buffer_full <= 0;\n            buffer_empty <= 1;\n        end else begin\n            // Write operation logic\n            if (write_enable && !buffer_full) begin\n                write_ptr <= (write_ptr + 1) % DEPTH;\n                if (write_ptr == DEPTH - 1) begin\n                    buffer_full <= 1; \n                end\n            end\n\n            if (read_enable && !buffer_empty) begin\n                read_ptr <= (read_ptr + 1) % DEPTH;\n                buffer_empty <= (read_ptr == write_ptr); \n                if (read_ptr == DEPTH - 1) begin\n                    buffer_select <= !buffer_select; \n                end\n            end\n\n            buffer_full <= (write_ptr + 1) % DEPTH == read_ptr;\n            buffer_empty <= read_ptr == write_ptr;\n        end\n    end\n\n    assign data_out = buffer_select ? data_out1 : data_out0;\nendmodule\nmodule dual_port_memory (\n    input logic clk,\n    input logic we,\n    input logic [7:0] write_addr,\n    input logic [7:0] din,\n    input logic [7:0] read_addr,\n    output logic [7:0] dout\n);\n\n    logic [7:0] mem [255:0];\n\n    always_ff @(posedge clk) begin\n        if (we) begin\n            mem[write_addr] <= din; \n        end\n        dout <= mem[read_addr]; \n    end\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        while len(info) < 3:\n            info.append(\"0%\")\n\n        inst = re.sub(r'[\\W]', '', info[0])\n\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n\n    # Check if the required key exists in the metrics\n    if \"dut\" not in metrics:\n        raise KeyError(\"Metrics data for 'dut' is missing in the coverage log.\")\n\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))  \n    assert metrics[\"dut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['dut']['Average']}, Target: {target}\"\n"}}}
{"id": "cvdp_copilot_prim_max_0005", "categories": ["cid012", "medium"], "input": {"prompt": "Create a **testbench** to apply **stimulus** to the `prim_max_find` module. This module implements a **binary tree-based maximum value finder** that determines the highest value from multiple input sources and provides the corresponding index. The testbench must apply a range of test cases to validate correct maximum value selection, index resolution, and handling of various input conditions.\n\n---\n\n### **Inputs:**\n\n- `clk_i`: **Clock signal with a 10ns period.**\n- `rst_ni`: **Active-low reset signal.**\n- `values_i`: **Flattened `NumSrc * Width`-bit wide input containing all values.**\n- `valid_i`: **`NumSrc`-bit wide signal indicating which inputs are valid.**\n\n### **Outputs:**\n\n- `max_value_o`: **`Width`-bit output representing the maximum value among valid inputs.**\n- `max_idx_o`: **`SrcWidth`-bit output indicating the index of the maximum value.**\n- `max_valid_o`: **Indicates whether any valid inputs were provided.**\n\n---\n\n### **Instantiation**\n\nThe testbench must instantiate a single instance of the `prim_max_find` module:\n\n- **Maximum Finder Module (`dut`)**: Instantiated with `NumSrc=8` and `Width=8` to test typical input conditions.\n\n---\n\n### **Testbench Requirements**\n\nThe testbench must apply a **wide range of test patterns** to ensure correct operation under all input conditions:\n\n1. **Clock Generation:**\n   - `clk_i` must toggle every **5 time units**, ensuring a **10 ns clock period**.\n\n2. **Reset Handling:**\n   - `rst_ni` must be **asserted for multiple cycles** before deasserting.\n   - The module must correctly initialize outputs when `rst_ni` is released.\n\n3. **Stimulus Generation Strategy:**\n   - The testbench **must not verify outputs** (only generate inputs).\n   - The following test sequences must be executed:\n     - **All Invalid Inputs**: Assign `valid_i = 0` for all inputs.\n     - **Single Valid Input**: One valid source with all others invalid.\n     - **Multiple Valid Inputs (Distinct Values)**: Various active sources with different values.\n     - **Multiple Valid Inputs (Duplicate Maximums)**: Multiple sources with the same highest value.\n     - **Maximum Value at First and Last Index**: Ensures correct tie-breaking at input boundaries.\n     - **Sequentially Increasing and Decreasing Values**: Tests proper priority handling.\n     - **Alternating Valid Input Patterns**: Exercises irregular valid signal transitions.\n     - **Extended Randomized Testing**: Generates **20 iterations** of randomized valid inputs and values.\n\n4. **Handling Continuous and Edge Cases:**\n   - The testbench must ensure **robust performance** under all valid/invalid input conditions.\n   - **Pipeline behavior** must be properly exercised through random valid signal transitions.\n   - **Valid input bursts and sporadic input toggling** must be tested.\n\n5. **Waveform Generation:**\n   - The testbench must generate a `.vcd` waveform file to allow waveform analysis.\n\n---\n\n### **Coverage and Compliance**\n\n- The testbench must ensure **high coverage** across all possible input combinations.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n\n---\n\n### **Test Plan Overview**\n\nThe testbench must ensure **96%+ input stimulus coverage** by applying:\n\n- **Valid data selection** across different test cases.\n- **Edge case handling** for minimum, maximum, and undefined values.\n- **Randomized input variations** to ensure robustness.\n- **Pipeline behavior verification** to confirm proper propagation of results.\n- **Handling of multiple maximum values** to ensure correct index selection.\n\nThis testbench will provide a **comprehensive input stimulus environment** for `prim_max_find`, ensuring correct operation under various test conditions.\n\n---\n\n### **Note:**\n- The testbench **must only generate stimulus** without verifying outputs.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n- **Ensure the maximum possible input coverage** without adding assertions or comparisons.\n\nCan you implement a **SystemVerilog testbench** with the above stimulus requirements?", "context": {}}, "output": {"response": "", "context": {"verif/prim_max_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 5-tb-stimulus-generation\nTARGET = 96", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/prim_max_find.sv": "module prim_max_find #(\n  parameter int NumSrc = 8,\n  parameter int Width = 8,\n  // Derived parameters\n  localparam int SrcWidth = $clog2(NumSrc),\n  localparam int NumLevels = $clog2(NumSrc),\n  localparam int NumNodes = 2**(NumLevels+1)-1\n) (\n  input                         clk_i,\n  input                         rst_ni,\n  input [Width*NumSrc-1:0]      values_i,    // Flattened Input values\n  input [NumSrc-1:0]            valid_i,     // Input valid bits\n  output wire [Width-1:0]       max_value_o, // Maximum value\n  output wire [SrcWidth-1:0]    max_idx_o,   // Index of the maximum value\n  output wire                   max_valid_o  // Whether any of the inputs is valid\n);\n\n  reg [NumNodes-1:0]                vld_tree [0:NumLevels];\n  reg [SrcWidth-1:0]                 idx_tree [0:NumLevels][NumNodes-1:0];\n  reg [Width-1:0]                    max_tree [0:NumLevels][NumNodes-1:0];\n\n  generate\n    for (genvar level = 0; level <= NumLevels; level++) begin : gen_tree\n      localparam int Base0 = (2**level)-1;\n      localparam int Base1 = (2**(level+1))-1;\n\n      for (genvar offset = 0; offset < 2**level; offset++) begin : gen_level\n        localparam int Pa = Base0 + offset;\n        localparam int C0 = Base1 + 2*offset;\n        localparam int C1 = Base1 + 2*offset + 1;\n\n        if (level == NumLevels) begin : gen_leafs\n          if (offset < NumSrc) begin : gen_assign\n            always @(posedge clk_i or negedge rst_ni) begin\n              if (!rst_ni) begin\n                vld_tree[level][Pa] <= 1'b0;\n                idx_tree[level][Pa] <= '0;\n                max_tree[level][Pa] <= '0;\n              end else begin\n                vld_tree[level][Pa] <= valid_i[offset];\n                idx_tree[level][Pa] <= offset;\n                max_tree[level][Pa] <= values_i[(offset+1)*Width-1 : offset*Width];\n              end\n            end\n          end else begin : gen_tie_off\n            always @(posedge clk_i or negedge rst_ni) begin\n              if (!rst_ni) begin\n                vld_tree[level][Pa] <= 1'b0;\n                idx_tree[level][Pa] <= '0;\n                max_tree[level][Pa] <= '0;\n              end\n            end\n          end\n        end\n\n        else begin : gen_nodes\n          reg sel; \n          always @(posedge clk_i or negedge rst_ni) begin\n            if (!rst_ni) begin\n              vld_tree[level][Pa] <= 1'b0;\n              idx_tree[level][Pa] <= '0;\n              max_tree[level][Pa] <= '0;\n            end else begin\n              sel = (~vld_tree[level+1][C0] & vld_tree[level+1][C1]) |\n                    (vld_tree[level+1][C0] & vld_tree[level+1][C1] & (max_tree[level+1][C1] > max_tree[level+1][C0]));\n\n              vld_tree[level][Pa] <= (sel) ? vld_tree[level+1][C1] : vld_tree[level+1][C0];\n              idx_tree[level][Pa] <= (sel) ? idx_tree[level+1][C1] : idx_tree[level+1][C0];\n              max_tree[level][Pa] <= (sel) ? max_tree[level+1][C1] : max_tree[level+1][C0];\n            end\n          end\n        end\n      end : gen_level\n    end : gen_tree\n  endgenerate\n\n  assign max_valid_o = vld_tree[0][0];\n  assign max_idx_o   = idx_tree[0][0];\n  assign max_value_o = max_tree[0][0];\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert subprocess.run(cmd, shell=True), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert subprocess.run(cmd, shell=True), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # Regular expression to capture the three columns.\n    # It expects:\n    #   - a name field (which may include tree markers)\n    #   - a percentage (or \"n/a\") for overall average\n    #   - a percentage (or \"n/a\") for overall covered\n    regex = re.compile(\n        r'^(?P<name>.*?)\\s+(?P<avg>(?:\\d+\\.\\d+%|n/a))\\s+(?P<cov>(?:\\d+\\.\\d+%|n/a))'\n    )\n\n    # Process each line (skip header/separator lines)\n    for line in lines[2:]:\n        match = regex.match(line)\n        if not match:\n            continue  # Skip lines that do not match our expected format\n\n        inst = match.group(\"name\").strip()\n        # Remove any tree markers (e.g. \"|--\") by splitting on '--'\n        if '--' in inst:\n            inst = inst.split('--')[-1].strip()\n\n        avg_str = match.group(\"avg\")\n        cov_str = match.group(\"cov\")\n\n        # Convert the percentages (remove the '%' if present)\n        avg_val = float(avg_str.rstrip('%')) if avg_str != \"n/a\" else 0.0\n        cov_val = float(cov_str.rstrip('%')) if cov_str != \"n/a\" else 0.0\n\n        metrics[inst] = {\n            \"Average\": avg_val,\n            \"Covered\": cov_val\n        }\n\n    # For DUT, check that the overall average meets the TARGET env variable.\n    required = float(os.getenv(\"TARGET\", \"0\"))\n    assert metrics[\"dut\"][\"Average\"] >= required, \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_restoring_division_0006", "categories": ["cid012", "easy"], "input": {"prompt": "Write a testbench to generate stimulus only for the `restoring_division` module, which performs restoring division on two unsigned positive integer inputs. The module generates the output `quotient`, `remainder`, and `valid` once the computation is completed for the given `dividend` and `divisor` when the `start` signal is asserted.\n\n## **Design Details**\n\n### **Parameterization**\n- **WIDTH**: Specifies the bit-width of the dividend and divisor.\n  - **Default**: 6 bits\n\n### **Functionality**\nThe **restoring_division** module implements division using a shift-subtract approach:\n- The division process must finish within WIDTH clock cycles if WIDTH is a power of 2 (2^n) to ensure all data is processed; otherwise (if WIDTH is not a power of 2), it will take WIDTH+1 clock cycles.\n- The FSM governs the state transitions and ensures proper computation.\n- The division process begins when `start` is asserted and completes when `valid` is high.\n\n## **Signal Behavior**\n\n### Inputs:\n- **`clk`**: 1-bit clock signal, toggles every 5 time units.\n- **`rst`**: Active-low reset signal to initialize the module.\n- **`start`**: Start signal to begin the division process.\n- **`dividend`**: `WIDTH`-bit input representing the dividend.\n- **`divisor`**: `WIDTH`-bit input representing the divisor.\n\n### Outputs:\n- **`quotient`**: `WIDTH`-bit result of the division operation.\n- **`remainder`**: `WIDTH`-bit remainder of the division operation.\n- **`valid`**: 1-bit signal indicating completion of division.\n\n---  \n\n## **Testbench Requirements**\n\n### **Instantiation**\n- **Module Instance**: The **restoring_division** module should be instantiated as `uut`, with all inputs and outputs properly connected.\n\n### **Input Generation and Validation**\n1. **Clock Generation**:  \n   - The testbench must generate a clock signal with a 10 ns period.\n   - The clock should toggle every **5 time units**.\n\n2. **Reset Behavior**:  \n   - The reset signal should be asserted low initially.\n   - After 10 ns, reset should be de-asserted (set high) to allow normal operation.\n\n3. **Division Test Cases**:  \n   - A **task** named `run_test` should be used to apply test cases dynamically.\n   - The testbench should generate **random** values for `dividend` and `divisor`.\n   - The **divisor should never be zero** (handled by ensuring divisor \u2265 1).\n   - The division process should be started by asserting `start` high for one cycle.\n   - The testbench must **wait for `valid`** to be asserted before capturing the results.\n   - The computed **quotient and remainder** should be displayed for debugging.\n\n---", "context": {}}, "output": {"response": "", "context": {"verif/restore_division_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = e6ec70444b3c24b08834396a6d33ac8f5d9ed945\nTARGET = 95", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/restore_division.sv": "`timescale 1ns / 1ps\n\nmodule restoring_division #(parameter WIDTH = 6) (\n    input clk,                          // Clock signal\n    input rst,                          // Reset signal (active low)\n    input start,                        // Start signal to begin the division process\n    input [WIDTH-1:0] dividend,         // Dividend input\n    input [WIDTH-1:0] divisor,          // Divisor input\n    output [WIDTH-1:0] quotient,        // Quotient output\n    output [WIDTH-1:0] remainder,       // Remainder output\n    output reg valid                    // Valid output indicating completion of division\n);\n    //registers width declaration\n    localparam COUNT_WIDTH = $clog2(WIDTH);\n    localparam ACCUMULATOR_WIDTH = 2*WIDTH;\n     // FSM state encoding\n    localparam IDLE  = 1'd0;                                    // Idle state\n    localparam START = 1'd1;                                    // Start state (active division)\n    reg [ACCUMULATOR_WIDTH-1:0] accumulator;                    // Accumulator to store intermediate results\n    reg [ACCUMULATOR_WIDTH-1:0] next_accumulator;               // Next state of the accumulator\n    reg [ACCUMULATOR_WIDTH-1:0] accumulator_temp;               // Temporary register for accumulator shifting\n    reg [ACCUMULATOR_WIDTH-1:0] accumulator_temp1;              // Temporary register for subtraction and concatenation\n    reg next_state, present_state;                              // FSM states for control logic\n    reg [COUNT_WIDTH-1:0] count;                                // Counter for tracking the number of shifts\n    reg [COUNT_WIDTH-1:0] next_count;                           // Next state of the counter\n    reg next_valid;                                             // Next state of the valid signal\n  \n    // Combinational logic block to determine the next state and outputs\n    always @ (*) begin                  \n        case(present_state)\n        IDLE: begin\n            next_count = {COUNT_WIDTH{1'd0}};                    // Reset the counter to 0\n            next_valid = 1'd0;                                   // Clear the valid signal\n\n            if (start) begin\n                next_state = START;                               // Transition to START state\n                next_accumulator = { {WIDTH{1'd0}}, dividend };   // Initialize the accumulator with the dividend\n            end else begin\n                next_state = present_state;                       // Remain in IDLE state\n                next_accumulator = {ACCUMULATOR_WIDTH{1'd0}};     // Keep the accumulator cleared\n            end\n        end\n        START: begin\n            if (next_count == WIDTH) begin             // Check if the division process is complete\n                next_count = {COUNT_WIDTH{1'd0}};      // Reset the counter\n                next_state =  present_state ;          // Transition back to IDLE or present_state state\n                next_valid = 1'd1;                     // Set the valid signal to indicate completion\n            end else begin\n                next_count = count + 1'd1;            // Increment the counter\n                // Perform shift and subtraction operation\n                accumulator_temp = accumulator << 1; // Left shift the accumulator\n                accumulator_temp1 = {accumulator_temp[ACCUMULATOR_WIDTH-1:WIDTH] - divisor, accumulator_temp[WIDTH-1:0]}; // Subtract divisor and concatenate\n                // Update the accumulator based on the subtraction result\n                next_accumulator = accumulator_temp1[ACCUMULATOR_WIDTH-1] ? \n                                   {accumulator_temp[ACCUMULATOR_WIDTH-1:WIDTH], accumulator_temp[WIDTH-1:1], 1'd0} :\n                                   {accumulator_temp1[ACCUMULATOR_WIDTH-1:WIDTH], accumulator_temp[WIDTH-1:1], 1'd1}; \n                next_valid = (&count) ? 1'd1 : 1'd0;         // Set valid signal if all bits have been processed\n                next_state = (valid) ? IDLE : present_state; // Transition to IDLE if done, otherwise stay in START\n            end\n        end\n        endcase\n    end\n    // Sequential logic block to update the current state and outputs on the clock edge or reset\n    always @ (posedge clk or negedge rst) begin\n        if (!rst) begin\n            accumulator   <= {ACCUMULATOR_WIDTH{1'd0}};        // Clear the accumulator on reset\n            valid         <= 1'd0;                             // Clear the valid signal on reset\n            present_state <= IDLE;                             // Set the FSM to IDLE state on reset\n            count         <= {COUNT_WIDTH{1'd0}};              // Reset the counter on reset\n        end else begin\n            accumulator   <= next_accumulator;                 // Update the accumulator\n            valid         <= next_valid;                       // Update the valid signal\n            present_state <= next_state;                       // Update the FSM state\n            count         <= next_count;                       // Update the counter\n        end\n    end\n    // Assign outputs for quotient and remainder based on the accumulator value\n    assign remainder = accumulator[ACCUMULATOR_WIDTH-1:WIDTH]; // Upper half of the accumulator is the remainder\n    assign quotient  = accumulator[WIDTH-1:0];                 // Lower half of the accumulator is the quotient\nendmodule"}}}
{"id": "cvdp_copilot_restoring_division_0034", "categories": ["cid012", "easy"], "input": {"prompt": "Write a testbench to generate stimulus only for the `restoring_division` module, which performs restoring division on two unsigned positive integer inputs. The module produces the `quotient`, `remainder`, and asserts the `valid` signal upon computation completion. Additionally, it sets the `divisor_valid_result` flag to indicate whether the divisor was valid (nonzero) when the `start` signal is asserted with the `dividend` and `divisor` inputs.\n\n---\n\n## **Design Details**\n### **Parameterization**\n- **WIDTH**: Specifies the bit-width of the dividend and divisor.\n  - **Default**: 6\n\n### **Functionality**\nThe **restoring_division** module performs unsigned integer division using a sequential **restoring division algorithm**. The quotient and remainder are computed iteratively over multiple clock cycles.\n\n#### **Division Process and Output Behavior**\n- The computation is **iterative** and progresses bit-by-bit over **WIDTH** clock cycles.\n- The division process must finish within WIDTH clock cycles if WIDTH is a power of 2 (2^n) to ensuring all data is processed; otherwise (if WIDTH is not a power of 2), it will take WIDTH+1 clock cycles.\n- Once the computation is complete, the **valid** signal is asserted high to indicate that the **quotient** and **remainder** outputs are stable and valid.\n- The **divisor_valid_result** signal ensures that valid results are only produced when the divisor is nonzero.\n\n### **Inputs:**  \n- `clk` (1-bit): Clock signal, toggles every 5 time units (**100MHz operation**).  \n- `rst` (1-bit): **Active-low** reset signal to initialize the module.  \n- `start` (1-bit): Start signal to begin the division process.  \n- `dividend` (6-bit): Dividend input value.  \n- `divisor` (6-bit): Divisor input value.  \n\n### **Outputs:**  \n- `quotient` (6-bit): Computed quotient output.  \n- `remainder` (6-bit): Computed remainder output.  \n- `valid` (1-bit): Signal indicating division completion.  \n- `divisor_valid_result` (1-bit): Signal indicating if divisor was valid (not zero).  \n\n---\n\n## **Testbench Requirements**\n### **Instantiation**\n- The **restoring_division** module should be instantiated as **uut** (Unit Under Test), with all input and output signals connected.\n\n### **Input Generation and Validation**\n- **Randomized Inputs**: The testbench must generate multiple test cases, covering:\n  - **Random dividend & random nonzero divisor**\n  - **Dividend = 0** (Edge case)\n  - **Divisor = 0** (Edge case, division by zero)\n  - **Dividend < Divisor** (Ensuring the quotient is 0 and remainder = dividend)\n- **Stabilization Period**: After applying inputs, the testbench must wait until the **valid** signal is asserted before checking outputs.\n\n### **Control Signal Behavior**\n- The **start** signal should be asserted high for **one clock cycle** before being de-asserted.\n- The testbench must ensure that **valid** is asserted only after the computation is complete.\n\n\n---\n\nThis testbench will verify the **correctness, stability, and edge-case behavior** of the **restoring_division** module. It ensures that the division process adheres to the restoring division algorithm and produces accurate results across all test scenarios.", "context": {}}, "output": {"response": "", "context": {"verif/restore_division_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 62c7703bfd6cf99ace3d73bd88ca23fedbb5d3c9\nTARGET = 95", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/restore_division.sv": "`timescale 1ns / 1ps\nmodule restoring_division #(parameter WIDTH = 6) (\n    input        clk,                       // Clock signal\n    input        rst,                       // Reset signal (active low)\n    input        start,                     // Start signal to begin the division process\n    input  [WIDTH-1:0] dividend,            // Dividend input\n    input  [WIDTH-1:0] divisor,             // Divisor input\n    output [WIDTH-1:0] quotient,            // Quotient output\n    output [WIDTH-1:0] remainder,           // Remainder output\n    output reg        valid,                // Valid output indicating completion of division\n    output reg        divisor_valid_result  // Divisor divisor_valid_result signal\n);\n    // Registers width declaration\n    localparam COUNT_WIDTH = $clog2(WIDTH);\n    localparam ACCUMULATOR_WIDTH = 2*WIDTH;\n    // FSM state encoding\n    localparam IDLE  = 1'b0;                                    // Idle state\n    localparam START = 1'b1;                                    // Start state (active division)\n    reg [ACCUMULATOR_WIDTH-1:0] accumulator;                    // Accumulator to store intermediate results\n    reg [ACCUMULATOR_WIDTH-1:0] next_accumulator;               // Next state of the accumulator\n    reg [ACCUMULATOR_WIDTH-1:0] accumulator_temp;               // Temporary register for accumulator shifting\n    reg [ACCUMULATOR_WIDTH-1:0] accumulator_temp1;              // Temporary register for subtraction and concatenation\n    reg                        next_state, present_state;       // FSM states for control logic\n    reg [COUNT_WIDTH-1:0]      count;                           // Counter for tracking the number of shifts\n    reg [COUNT_WIDTH-1:0]      next_count;                      // Next state of the counter\n    reg                        next_valid;                      // Next state of the valid signal\n    reg                        next_divisor_valid_result;       // Divisor next_divisor_valid_result signal\n   \n    // Combinational logic block to determine the next state and outputs\n    always @ (*) begin                  \n        case(present_state)\n            IDLE: begin\n                next_count = {COUNT_WIDTH{1'b0}};                               // Reset the counter to 0\n                next_valid = 1'b0;                                              // Clear the valid signal\n                next_divisor_valid_result  = 1'b1;                              // Clear the divisor_valid_result     \n                if (start) begin\n                    // Special cases\n                    if (divisor == 0) begin                                     // Division by zero case\n                        next_state = IDLE;\n                        next_valid = 1'b1;\n                        next_accumulator = {dividend, {WIDTH{1'b0}}};\n                        next_divisor_valid_result = 1'b0;\n                    end \n                    else if (dividend == 0) begin                               // Dividend is zero case\n                        next_state = IDLE;\n                        next_valid = 1'b1;\n                        next_accumulator = {ACCUMULATOR_WIDTH{1'b0}};           // Both quotient and remainder are zero\n                        next_divisor_valid_result = 1'b1;\n                    end \n                    else if (dividend < divisor) begin                          // Dividend is less than divisor case\n                        next_state = IDLE;\n                        next_valid = 1'b1;\n                        next_accumulator = {dividend, {WIDTH{1'b0}}};           // Quotient is zero, remainder is the dividend\n                        next_divisor_valid_result = 1'b1;\n                    end \n                    else begin                                                  // Valid division process\n                        next_state = START;\n                        next_accumulator = { {WIDTH{1'b0}}, dividend };         // Initialize the accumulator with the dividend\n                    end\n                end \n                else begin\n                    next_state = present_state;                                 // Remain in IDLE state\n                    next_accumulator = {ACCUMULATOR_WIDTH{1'b0}};               // Keep the accumulator cleared\n                end\n            end\n            START: begin\n                if (next_count == WIDTH) begin                                  // Check if the division process is complete\n                    next_count = {COUNT_WIDTH{1'b0}};                           // Reset the counter\n                    next_state = present_state;                                 // Transition back to IDLE or present_state state\n                    next_valid = 1'b1;                                          // Set the valid signal to indicate completion\n                    next_divisor_valid_result = 1'b1;                           // Set the divisor_valid_result signal to indicate completion\n                end else begin\n                    next_count = count + 1'b1;                                  // Increment the counter\n                    accumulator_temp = accumulator << 1;                        // Left shift the accumulator\n                    accumulator_temp1 = {accumulator_temp[ACCUMULATOR_WIDTH-1:WIDTH] - divisor, accumulator_temp[WIDTH-1:0]}; // Subtract divisor and concatenate\n                    // Update the accumulator based on the subtraction result\n                    next_accumulator = accumulator_temp1[ACCUMULATOR_WIDTH-1] ? \n                                       {accumulator_temp[ACCUMULATOR_WIDTH-1:WIDTH], accumulator_temp[WIDTH-1:1], 1'b0} :\n                                       {accumulator_temp1[ACCUMULATOR_WIDTH-1:WIDTH], accumulator_temp[WIDTH-1:1], 1'b1}; \n                    next_valid = (&count) ? 1'b1 : 1'b0;                        // Set valid signal if all bits have been processed\n                    next_state = (valid) ? IDLE : present_state;                // Transition to IDLE if done, otherwise stay in START\n                end\n            end\n        endcase\n    end\n    \n    // Sequential logic block to update the current state and outputs on the clock edge or reset\n    always @ (posedge clk or negedge rst) begin\n        if (!rst) begin\n            accumulator            <= {ACCUMULATOR_WIDTH{1'b0}};                // Clear the accumulator on reset\n            valid                  <= 1'b0;                                     // Clear the valid signal on reset\n            present_state          <= IDLE;                                     // Set the FSM to IDLE state on reset\n            count                  <= {COUNT_WIDTH{1'b0}};                      // Reset the counter on reset \n            divisor_valid_result   <= 1'b0;                                     // Clear the divisor_valid_result signal on reset\n        end else begin\n            accumulator            <= next_accumulator;                         // Update the accumulator\n            valid                  <= next_valid;                               // Update the valid signal\n            present_state          <= next_state;                               // Update the FSM state\n            count                  <= next_count;                               // Update the counter\n            divisor_valid_result   <= next_divisor_valid_result;                // Update the divisor_valid_result signal\n        end\n    end\n    \n    // Assign outputs for quotient and remainder based on the accumulator value\n    assign remainder = accumulator[ACCUMULATOR_WIDTH-1:WIDTH];                  // Upper half of the accumulator is the remainder\n    assign quotient  = accumulator[WIDTH-1:0];                                  // Lower half of the accumulator is the quotient\nendmodule"}}}
{"id": "cvdp_copilot_reverse_bits_0006", "categories": ["cid013", "easy"], "input": {"prompt": "Create a **SystemVerilog testbench checker** with detailed stimulus to test using checker and to validate the Verilog module named `reverse_bits` that reverses the bit order of a 32-bit input.  The testbench should ensure:\n\n- Comprehensive **input stimulus** generation covering all possible cases.\n- **Checker generation** of the reverse_bits output.\n\n---\n## 1. Instantiation\n\nName the instance of the RTL as **dut**.\n\n\n## 2. **RTL Inputs - Outputs and Functional behaviour**\n\n### 2.1 Inputs\n- **`input [31:0] num_in`**  \n  A 32-bit unsigned integer whose bits need to be reversed.\n\n### 2.2 Outputs\n- **`output [31:0] num_out`**  \n  The result of reversing all 32 bits of `num_in`. Bit 0 of `num_in` becomes bit 31 of `num_out`, bit 1 of `num_in` becomes bit 30 of `num_out`, etc.\n\n---\n\n### 2.3. Behavioral Explanation\n- **Reversal Logic**:  \n  If `num_in` is `32'babcdefgh_ijklmnop_qrstuvwx_yzABCDEF` (where each letter represents a single bit), then `num_out` should be `32'bFEDCBAzy_xwvutsrq_ponmlkji_hgfedcba`.\n\n- **Combinational Module**:  \n  The design is purely combinational\u2014no clocks, resets, or sequential logic elements are used.\n\n- **Valid Inputs Only**:  \n  The module is designed to handle valid 32-bit binary inputs (no `x` or `z` states).\n\n---\n\n## 4. Stimulus and checker generation\n\n### 4.1 Stimulus Generation\n1. **Directed (Static) Test Vectors**  \n   - **All Zeroes**: `32'b00000000000000000000000000000000`  \n     - Expected output: `32'b00000000000000000000000000000000`\n   - **All Ones**: `32'b11111111111111111111111111111111`  \n     - Expected output: `32'b11111111111111111111111111111111`\n   - **Single Bit Set (LSB)**: `32'b00000000000000000000000000000001`  \n     - Expected output: `32'b10000000000000000000000000000000`\n   - **Single Bit Set (MSB)**: `32'b10000000000000000000000000000000`  \n     - Expected output: `32'b00000000000000000000000000000001`\n   - **Alternating Pattern**: `32'b10101010101010101010101010101010`  \n     - Expected output: `32'b01010101010101010101010101010101`\n   - **Reverse Alternating Pattern**: `32'b01010101010101010101010101010101`  \n     - Expected output: `32'b10101010101010101010101010101010`\n\n\n## 5. Constraints and Edge Cases\n- **No Clock/Reset**:  \n  The design is purely combinational, so ensure the test bench does not require a clock or reset for correct operation.\n- **Undefined Inputs**:  \n  The test bench will not apply `x` or `z` states to `num_in`.\n\n## 6. Simulation\n- Reset the dut and initialize inputs.\n- Apply the test cases sequentially.\n- Log errors if any discrepancies are found between dut outputs and the model using `$error`.\n\n## 7. Deliverables\nProvide the complete SystemVerilog testbench code with:\n1. dut instantiation.\n2. Implement a behavioral model to replicate the expected functionality.\n3. Test scenarios validating the dut against the expected behavior.\n4. Compare the outputs from the DUT with the model using checkers\n5. Log messages indicating pass/fail status for each test case.\n\n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_reverse_bits.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/reverse_bits.v\nHASH            = 6-tb-checker\nNUM_BUGS        = 2", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.v /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"", "src/reverse_bits.v": "module reverse_bits(\n    input [31:0] num_in,\n    output [31:0] num_out\n);\n    // Using a generate block to reverse the bits\n    genvar i;\n    generate\n        for (i = 0; i < 32; i = i + 1) begin : bit_reverse\n            `ifdef BUG_0\n                assign num_out[31-i] = num_in[31];\n            `elsif BUG_1 \n                assign num_out[31 - i] = num_in[31-i];\n            `else\n                assign num_out[i] = num_in[31 - i];\n            `endif\n        end\n    endgenerate\nendmodule\n"}}}
{"id": "cvdp_copilot_ring_token_0004", "categories": ["cid012", "easy"], "input": {"prompt": "Create a SystemVerilog testbench module named **`tb_token_ring_fsm`** that instantiates the `token_ring_fsm` module as the Unit Under Test (UUT). The testbench must include a **stimulus generator** that systematically drives various input conditions to achieve **100% code and functional coverage** for the `token_ring_fsm`. The `token_ring_fsm` implements a **Finite State Machine (FSM)-based token-passing mechanism** in a four-node ring network, ensuring controlled data transmission between nodes. The stimulus should cover **all state transitions, token passing, data transmission scenarios, and asynchronous reset conditions** while logging outputs for debugging and verification.  \n\n---\n\n## **Description**  \n\n### **Inputs**  \n\n- **Clock Signal**:  \n  - `clk`: Positive edge-triggered clock signal driving the FSM.  \n\n- **Reset Signal**:  \n  - `rst`: Asynchronous active-high reset signal that initializes the FSM.  \n\n- **Data and Control Inputs**:  \n  - `data_in [3:0]`: A 4-bit input representing binary data for transmission by the current node.  \n  - `has_data_to_send`: A 1-bit signal indicating whether the current node has data to send.  \n\n### **Outputs**  \n\n- **Data and Token Outputs**:  \n  - `data_out [3:0]`: A 4-bit output representing the data transmitted by the current node.  \n  - `token_received [3:0]`: A 4-bit one-hot encoded signal indicating which node currently holds the token.  \n  - `token [3:0]`: A 4-bit one-hot encoded signal representing the token being passed to the next node.  \n\n---\n\n## **Input Generation**  \n\n### **State Transitions and Token Passing**  \n\n- Drive the FSM through all four states:  \n  - `NODE0 to NODE1 to NODE2 to NODE3 to NODE0` in a cyclic manner.  \n  - Ensure that `token_received` correctly identifies the node holding the token.  \n\n- Simulate token passing by shifting the `token` signal across nodes and verifying correct cycling.  \n\n### **Data Transmission Stimulus**  \n\n- Generate various patterns for `data_in` and toggle `has_data_to_send` to simulate:  \n  - Nodes transmitting data when they hold the token.  \n  - Nodes idling when `has_data_to_send` is LOW.  \n  - Different data values being sent across nodes.  \n\n### **Edge Case Testing**  \n\n- **Reset Behavior**:  \n  - Apply `rst` at different states to ensure FSM returns to `NODE0`.  \n  - Verify that `token_received` is set to `4'b0001` and `data_out`, `token` are cleared.  \n\n- **Token Handling**:  \n  - Simulate idle conditions where no node is ready to send data.  \n  - Inject forced token values using `force` and `release` commands to verify FSM recovery.  \n\n- **Overlapping Data Transmission**:  \n  - Test scenarios where multiple nodes attempt to send data consecutively.  \n  - Ensure only the node holding the token transmits data.  \n  \n---\n\n## **Instantiation**  \n\n- The instance of the RTL should be named **`uut`**.  \n\n---\n\n## **Module Interface**  \n\n### **Inputs**  \n\n- `clk`: Clock signal.  \n- `rst`: Asynchronous active-high reset signal.  \n- `data_in [3:0]`: Data input for transmission.  \n- `has_data_to_send`: Indicates whether the node has data to send.  \n\n### **Outputs**  \n\n- `data_out [3:0]`: Transmitted data output.  \n- `token_received [3:0]`: Indicates the node currently holding the token.  \n- `token [3:0]`: Indicates the token being passed to the next node.  \n\n---\n\n## **Module Functionality**  \n\n1. **Token Passing Mechanism**:  \n   - The FSM cycles through the four nodes, passing the token sequentially.  \n   - The node with the token is allowed to transmit data if `has_data_to_send` is HIGH.  \n\n2. **Data Transmission**:  \n   - When a node holds the token and `has_data_to_send` is HIGH, `data_out` reflects `data_in`.  \n   - If no node is ready to send, `data_out` remains `4'b0000`.  \n\n3. **Reset Behavior**:  \n   - When `rst` is asserted HIGH, the FSM resets to `NODE0`, `token_received` is set to `4'b0001`, and other outputs are cleared.  \n\n4. **Edge Cases**:  \n   - Idle conditions where no node transmits data.  \n   - Forced invalid states and token values to test FSM recovery.  \n   - Multiple data transmissions in consecutive cycles.  \n\n---\n", "context": {}}, "output": {"response": "", "context": {"verif/tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 464ad3e0d0a1fd65faee6270396c378c7382e372\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/token_ring_fsm.sv": "module token_ring_fsm (\n    input logic clk,              // Clock input\n    input logic rst,              // Reset input\n    input logic [3:0] data_in,    // Data input from node\n    output reg [3:0] data_out,    // Data output to node\n    input logic has_data_to_send, // Signal indicating data is ready to send\n    output reg [3:0] token_received, // Token received status for nodes\n    output reg [3:0] token        // Token status being passed between nodes\n);\n\ntypedef enum logic [1:0] {\n    NODE0 = 2'b00,\n    NODE1 = 2'b01,\n    NODE2 = 2'b10,\n    NODE3 = 2'b11\n} state_t;\n\nstate_t current_state, next_state;\n\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_state <= NODE0;\n        token <= 4'b0001;\n        token_received <= 4'b0001;\n        data_out <= 4'b0000;\n    end else begin\n        case (current_state)\n            NODE0: begin\n                token_received <= 4'b0001;\n                token <= 4'b0010;\n                next_state = NODE1;\n            end\n            NODE1: begin\n                token_received <= 4'b0010;\n                token <= 4'b0100;\n                next_state = NODE2;\n            end\n            NODE2: begin\n                token_received <= 4'b0100;\n                token <= 4'b1000;\n                next_state = NODE3;\n            end\n            NODE3: begin\n                token_received <= 4'b1000;\n                token <= 4'b0001;\n                next_state = NODE0;\n            end\n            default: begin\n                next_state = NODE0;\n            end\n        endcase\n\n        if (token_received[current_state] && has_data_to_send) begin\n            data_out <= data_in;\n        end else begin\n            data_out <= 4'b0000;\n        end\n\n        current_state <= next_state;\n    end\nend\n\nendmodule"}}}
{"id": "cvdp_copilot_ring_token_0009", "categories": ["cid014", "easy"], "input": {"prompt": "Add intermediate assertions to verify that **`token_ring_fsm`** module implements a **token-passing protocol** among four nodes. The FSM ensures that only **one token** is active at a time and rotates sequentially among the nodes in a fixed order. **Assertions have to be created** to verify that the **token-passing mechanism** and **data transmission conditions** operate correctly.\n\n### **Expected Behavior**\nEach assertion should validate the **correct operation of the FSM**, including:\n1. **Token Uniqueness**: Ensure that only **one active token** exists at a time.\n2. **Token Passing Sequence**: Verify that the token follows the expected cyclic sequence `{4'b0001 to 4'b0010 to 4'b0100 to 4'b1000 to 4'b0001}`.\n3. **State Transition Validity**: Validate that the FSM transitions correctly between `NODE0 to NODE1 to NODE2 to NODE3 to NODE0`.\n4. **Data Transmission Rules**: Ensure that `data_out` updates **only** when the **current node holds the token** and `has_data_to_send` is asserted when the clock is Active high.\n\nIn the event of an assertion failure, the error message must include **debugging details** such as the **current state, token value, and `data_out`**.\n\n---\n\n## **RTL Specification**\n\n### **Module Name: `token_ring_fsm`**\nA finite state machine that cycles through four nodes, ensuring only one node holds an active token at a time. Each node can send data only when it has the token.\n\n### **Parameters**\n- **NODES**: Number of nodes in the token ring (default: 4).\n\n### **Ports**\n\n| **Port Name**      | **Direction** | **Size** | **Type** | **Description**                         |\n|--------------------|---------------|----------|----------|-----------------------------------------|\n| `clk`              | Input         | 1 bit    | Signal   | Posedge of Clock signal                 |\n| `rst`              | Input         | 1 bit    | Signal   | Asynchronous reset signal, active high  |\n| `data_in`          | Input         | 4 bits   | Data     | Data input from the node                |\n| `data_out`         | Output        | 4 bits   | Data     | Data output to the next node            |\n| `has_data_to_send` | Input         | 1 bit    | Control  | Indicates if the node has data to send  |\n| `token_received`   | Output        | 4 bits   | Control  | Active token indicator for the nodes    |\n| `token`            | Output        | 4 bits   | Control  | Current token status                    |\n\n---\n\n## **Assertions for `token_ring_fsm`**\n\n1. **Token Uniqueness Assertion**  \n   - Ensures that only **one active token** exists at a time.\n   - Detects multiple active tokens, which would indicate a protocol violation.\n\n2. **Token Passing Sequence Assertion**  \n   - Validates that the **token follows the expected cyclic order** `{4'b0001 to 4'b0010 to 4'b0100 to 4'b1000 to 4'b0001}`.\n   - Detects any invalid token assignments.\n\n3. **State Transition Validity Assertion**  \n   - Ensures that the FSM **only transitions between valid states**:  \n     `{NODE0 to NODE1 to NODE2 to NODE3 to NODE0}`.\n   - Catches unexpected state transitions.\n\n4. **Data Transmission Validity Assertion**  \n   - Ensures that **`data_out` is updated only when**:\n     - The **current node has the token** (`token_received[current_state] == 1`).\n     - `has_data_to_send` is **asserted**.\n   - Detects cases where `data_out` updates incorrectly.\n\n---\n\n## **Assertion Reporting**\nEach assertion must **generate detailed error messages** upon failure, including:\n- **Simulation timestamp (`$time`)**.\n- **Current state (`current_state`)**.\n- **Token value (`token`)**.\n- **Data output (`data_out`)**.\n\nThis will help in **debugging and root cause analysis**.\n\n---\n", "context": {"rtl/token_ring_fsm.sv": "module token_ring_fsm (\n    input logic clk,              // Clock input\n    input logic rst,              // Reset input\n    input logic [3:0] data_in,    // Data input from node\n    output reg [3:0] data_out,    // Data output to node\n    input logic has_data_to_send, // Signal indicating data is ready to send\n    output reg [3:0] token_received, // Token received status for nodes\n    output reg [3:0] token        // Token status being passed between nodes\n);\n\ntypedef enum logic [1:0] {\n    NODE0 = 2'b00,\n    NODE1 = 2'b01,\n    NODE2 = 2'b10,\n    NODE3 = 2'b11\n} state_t;\n\nstate_t current_state, next_state;\n\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_state <= NODE0;\n        token <= 4'b0001;\n        token_received <= 4'b0001;\n        data_out <= 4'b0000;\n    end else begin\n        case (current_state)\n            NODE0: begin\n                token_received <= 4'b0001;\n                token <= 4'b0010;\n                next_state = NODE1;\n            end\n            NODE1: begin\n                token_received <= 4'b0010;\n                token <= 4'b0100;\n                next_state = NODE2;\n            end\n            NODE2: begin\n                token_received <= 4'b0100;\n                token <= 4'b1000;\n                next_state = NODE3;\n            end\n            NODE3: begin\n                token_received <= 4'b1000;\n                token <= 4'b0001;\n                next_state = NODE0;\n            end\n            default: begin\n                next_state = NODE0;\n            end\n        endcase\n\n        if (token_received[current_state] && has_data_to_send) begin\n            data_out <= data_in;\n        end else begin\n            data_out <= 4'b0000;\n        end\n\n        current_state <= next_state;\n    end\nend\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/token_ring_fsm.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/token_ring_fsm.sv\nTOPLEVEL        = token_ring_fsm\nMODULE          = test_token_ring_fsm\nPYTHONPATH      = /src\nHASH            = f5ba72d361d8dce872be6ca138e7d14b8e107dab\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_token_ring_fsm.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n# Clock generation coroutine\nasync def generate_clock(dut, period=10, units='ns'):\n    \"\"\"Generate clock with a period of `period` time units.\"\"\"\n    while True:\n        dut.clk.value = 0\n        await Timer(period // 2, units=units)\n        dut.clk.value = 1\n        await Timer(period // 2, units=units)\n\nasync def reset_dut(dut):\n    \"\"\"Reset DUT and verify initial conditions.\"\"\"\n    dut.rst.value = 1\n    dut.data_in.value = 0\n    dut.has_data_to_send.value = 0\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n    assert dut.token.value == 0b0001, f\"Reset failure: expected token 0001, got {dut.token.value}\"\n    assert dut.token_received.value == 0b0001, f\"Reset failure: expected token_received 0001, got {dut.token_received.value}\"\n    assert int(dut.current_state.value) == 0, f\"Reset failure: expected NODE0, got {int(dut.current_state.value)}\"\n    assert dut.data_out.value == 0, f\"Reset failure: expected data_out 0, got {dut.data_out.value}\"\n\n@cocotb.test()\nasync def test_token_passing(dut):\n    \"\"\"Test FSM token passing and state transitions.\"\"\"\n    cocotb.start_soon(generate_clock(dut))\n    await reset_dut(dut)\n\n    expected_tokens = [0b0010, 0b0100, 0b1000, 0b0001]\n    expected_states = [1, 2, 3, 0]\n\n    for expected_token, expected_state in zip(expected_tokens, expected_states):\n        await RisingEdge(dut.clk)\n        assert dut.token.value == expected_token, f\"Token transition error: expected {bin(expected_token)}, got {bin(dut.token.value)}\"\n        assert int(dut.current_state.value) == expected_state, f\"State transition error: expected {expected_state}, got {int(dut.current_state.value)}\"\n\n@cocotb.test()\nasync def test_data_transmission(dut):\n    \"\"\"Test that data is only transmitted when the node has the token.\"\"\"\n    cocotb.start_soon(generate_clock(dut))\n    await reset_dut(dut)\n\n    for _ in range(10):\n        data = random.randint(0, 15)\n        dut.data_in.value = data\n        dut.has_data_to_send.value = 1\n        await RisingEdge(dut.clk)\n\n        expected_data_out = data if (dut.token_received.value.integer & (1 << int(dut.current_state.value))) else 0\n        assert dut.data_out.value == expected_data_out, f\"Data mismatch: expected {expected_data_out}, got {dut.data_out.value}\"\n\n        dut.has_data_to_send.value = 0\n        await RisingEdge(dut.clk)\n\n@cocotb.test()\nasync def test_boundary_conditions(dut):\n    \"\"\"Check boundary conditions for data_in from 0 to 15.\"\"\"\n    cocotb.start_soon(generate_clock(dut))\n    await reset_dut(dut)\n\n    for data_in_value in range(16):\n        dut.data_in.value = data_in_value\n        dut.has_data_to_send.value = 1\n        await RisingEdge(dut.clk)\n\n        expected_data_out = data_in_value if (dut.token_received.value.integer & (1 << int(dut.current_state.value))) else 0\n        assert dut.data_out.value == expected_data_out, f\"Boundary test failed at data_in={data_in_value}, expected {expected_data_out}, got {dut.data_out.value}\"\n\n        dut.has_data_to_send.value = 0\n        await RisingEdge(dut.clk)\n"}}}
{"id": "cvdp_copilot_rs_232_0004", "categories": ["cid013", "medium"], "input": {"prompt": "Develop a **SystemVerilog testbench** for the **RS232 Transmitter Module** module to validate the transmission capabilities of an RS-232 serial interface, ensuring data integrity and proper timing according to specified baud rates.\n\nRS232 Transmitter Module operates with the following configurable parameters:\n- **CLOCK_FREQ**: The system clock frequency (default: 100MHz).\n- **BAUD_RATE**: The baud rate for transmission (default: 115200).\n- **BAUD_ACC_WIDTH**: The width of the baud rate accumulator (default: 16 bits).\n- **REG_INPUT**: Determines if the input data is registered (default: 1).\n\n### Module Interfaces\n#### Inputs:\n1. **clock**: The main clock signal for the module.\n2. **reset_neg**: Active-low reset signal to initialize or reset the transmitter.\n3. **tx_datain_ready**: Indicates that new data is ready for transmission.\n4. **Present_Processing_Completed**: Signals that the current processing is complete, resetting internal state and registers.\n5. **tx_datain**: 8-bit input data to be transmitted.\n\n#### Outputs:\n1. **tx_transmitter**: The UART serial data output line. It assembles the start bit, 8 data bits, and stop bit into a serial stream.\n2. **tx_transmitter_valid**: An active-high signal that indicates the transmitter is busy (i.e., data is being transmitted).\n\n### Internal Operation\n- **State Machine**: The module implements a state machine with 4-bit states to manage different stages of transmission:\n  - **Idle State**: Awaits `tx_datain_ready` to begin transmission.\n  - **Start State**: Sends the start bit (low level).\n  - **Data States (Bit 0\u20137)**: Sequentially transmits the 8 data bits, one per state.\n  - **Stop State**: Sends the stop bit (high level), signaling the end of transmission.\n\n- **Baud Rate Generator**: A submodule calculates the timing for each bit using the `CLOCK_FREQ` and `BAUD_RATE` parameters. It produces a `baud_pulse` signal to synchronize the transmission process.\n\n### Special Features\n1. **Pause and Resume**: The module can pause transmission if `Present_Processing_Completed` is asserted and resumes without restarting the entire sequence.\n2. **Glitch-Free Output**: Ensures stable and reliable signal transitions for the UART output.\n\n## Requirements\n\n### 1. Testbench Components\n- **Parameters**:\n  - `CLOCK_FREQ`: Clock frequency of the testbench (100 MHz).\n  - `BAUD_RATE`: Baud rate for serial communication (115,200).\n  - `CLOCK_PERIOD`: Clock period calculated from `CLOCK_FREQ`.\n  - `BAUD_PERIOD`: Baud period calculated from `BAUD_RATE`.\n  - `TIMEOUT_CYCLES`: Timeout threshold to prevent infinite loops during transmission tests.\n\n### 2. Signals\n- `clock`: Testbench clock signal.\n- `reset_neg`: Active low reset.\n- `tx_datain_ready`: Signal indicating readiness to receive data.\n- `Present_Processing_Completed`: Signal to indicate processing completion (not used in the initial testing scenario).\n- `tx_datain`: Data input to the transmitter.\n- `tx_transmitter`: Serial data output from the module.\n- `tx_transmitter_valid`: Valid signal indicating data is being transmitted.\n\n### 3. Device Under Test (DUT)\n- **Copilot RS-232 Instantiation**:\n  - Set the `CLOCK_FREQ` and `BAUD_RATE` to control operation.\n  - Connect all relevant control and data signals between the testbench and DUT.\n\n### 4. Testbench Functionality\n- **Clock Generation**:\n  - Generate a continuous clock with a frequency defined by `CLOCK_FREQ`.\n- **Expected Serial Data Calculation**:\n  - Implement a task (`calculate_serial_data`) to generate the expected serial output data including start and stop bits based on input data.\n\n### 5. Test Procedures\n- **Serial Output Checking**:\n  - Simulate data transmission and verify each bit of the serial output over the baud period using a checker task (`check_serial_output`).\n- **Transmission Simulation with Timeout**:\n  - Manage data transmission with a timeout to ensure the test progresses smoothly without hanging, especially when waiting for `tx_transmitter_valid`.\n\n### 6. Output Verification\n- **Verify Serial Transmission**:\n  - For each byte transmitted, ensure the serialized output matches the expected pattern generated by the test reference.\n- **Error Handling**:\n  - Check for mismatches between expected and actual serial outputs and handle timeouts effectively.\n\n### 7. Simulation Control\n- Sequentially transmit multiple bytes (10 in this case) and check each for accuracy.\n- Log results for each transmission attempt and provide a final report on the test outcomes.\n- Utilize procedural blocks and control structures to manage test flow, including loops for multiple tests and conditions to check outputs.\n\n## Expected Output\nThe testbench should:\n1. Execute serial transmission of multiple random bytes.\n2. Validate the correctness of each serial output against expected results.\n3. Log detailed results for each test case, indicating whether the serialized data was transmitted correctly.\n4. Conclude the simulation with a status message indicating the success or failure of all tests.\n\n## Deliverables\nProvide a **complete SystemVerilog testbench** that thoroughly tests and verifies the `copilot_rs_232` module's serial transmission functionality, ensuring data is accurately serialized according to the specified baud rate and format.", "context": {"rtl/copilot_rs_232.sv": "module copilot_rs_232 (\n    clock,\n    reset_neg,\n    tx_datain_ready,\n    Present_Processing_Completed,\n    tx_datain,\n    tx_transmitter,\n    tx_transmitter_valid\n);\n    // Parameters\n    parameter HIGH = 1'b1;\n    parameter LOW = 1'b0;\n    parameter CLOCK_FREQ = 100000000; // 100MHz\n    parameter BAUD_RATE = 115200;     // Default baud rate\n    parameter REG_INPUT = 1;\n    parameter BAUD_ACC_WIDTH = 16;\n\n    // Inputs\n    input reset_neg;\n    input clock;\n    input tx_datain_ready;\n    input Present_Processing_Completed;\n    input [7:0] tx_datain;\n\n    // Outputs\n    output tx_transmitter;\n    output tx_transmitter_valid;\n\n    // Internal signals\n    reg tx_transmitter;\n    wire baud_pulse;\n\n    // Instantiate the Baud Rate Generator\n    baud_rate_generator #(\n        .BAUD_ACC_WIDTH(BAUD_ACC_WIDTH),\n        .CLOCK_FREQ(CLOCK_FREQ),\n        .BAUD_RATE(BAUD_RATE)\n    ) baud_gen (\n        .clock(clock),\n        .reset_neg(reset_neg),\n        .enable(tx_transmitter_valid),\n        .baud_pulse(baud_pulse)\n    );\n\n    // Transmitter State Machine\n    reg [3:0] State;\n    wire tx_Xfer_Ready = (State == 0);\n    assign tx_transmitter_valid = ~tx_Xfer_Ready;\n\n    reg [7:0] tx_data_reg;\n    always @ (posedge clock or negedge reset_neg) begin\n        if (reset_neg == LOW) begin\n            tx_data_reg <= 8'hFF;\n        end else if (Present_Processing_Completed == HIGH) begin\n            tx_data_reg <= 8'hFF;\n        end else if (tx_Xfer_Ready & tx_datain_ready) begin\n            tx_data_reg <= tx_datain;\n        end\n    end\n\n    wire [7:0] Tx_Data_Byte;\n    assign Tx_Data_Byte = REG_INPUT ? tx_data_reg : tx_datain;\n\n    always @ (posedge clock or negedge reset_neg) begin\n        if (reset_neg == LOW) begin\n            State <= 4'b0000;\n        end else if (Present_Processing_Completed == HIGH) begin\n            State <= 4'b0000;\n        end else begin\n            case(State)\n                4'b0000: if (tx_datain_ready) State <= 4'b0100; // Idle\n                4'b0100: if (baud_pulse) State <= 4'b1000;      // Start\n                4'b1000: if (baud_pulse) State <= 4'b1001;      // Bit 0\n                4'b1001: if (baud_pulse) State <= 4'b1010;      // Bit 1\n                4'b1010: if (baud_pulse) State <= 4'b1011;      // Bit 2\n                4'b1011: if (baud_pulse) State <= 4'b1100;      // Bit 3\n                4'b1100: if (baud_pulse) State <= 4'b1101;      // Bit 4\n                4'b1101: if (baud_pulse) State <= 4'b1110;      // Bit 5\n                4'b1110: if (baud_pulse) State <= 4'b1111;      // Bit 6\n                4'b1111: if (baud_pulse) State <= 4'b0010;      // Bit 7\n                4'b0010: if (baud_pulse) State <= 4'b0000;      // Stop\n                default: if (baud_pulse) State <= 4'b0000;\n            endcase\n        end\n    end\n\n    // Output Multiplexer\n    reg MuxBit;\n    always @ (State or Tx_Data_Byte) begin\n        case (State[2:0])\n            3'd0: MuxBit <= Tx_Data_Byte[0];\n            3'd1: MuxBit <= Tx_Data_Byte[1];\n            3'd2: MuxBit <= Tx_Data_Byte[2];\n            3'd3: MuxBit <= Tx_Data_Byte[3];\n            3'd4: MuxBit <= Tx_Data_Byte[4];\n            3'd5: MuxBit <= Tx_Data_Byte[5];\n            3'd6: MuxBit <= Tx_Data_Byte[6];\n            3'd7: MuxBit <= Tx_Data_Byte[7];\n        endcase\n    end\n\n    // Assemble Start, Data, and Stop Bits\n    always @ (posedge clock or negedge reset_neg) begin\n        if (reset_neg == LOW) begin\n            tx_transmitter <= HIGH;\n        end else if (Present_Processing_Completed == HIGH) begin\n            tx_transmitter <= HIGH;\n        end else begin\n            tx_transmitter <= (State < 4) | (State[3] & MuxBit); // Glitch-free output\n        end\n    end\n\nendmodule\n\n// Baud Rate Generator Module\nmodule baud_rate_generator #(\n    parameter CLOCK_FREQ = 100000000, // 100MHz\n    parameter BAUD_RATE = 115200, // Default baud rate\n    parameter BAUD_ACC_WIDTH = 16\n)\n (\n    input clock,\n    input reset_neg,\n    input enable,\n    output reg baud_pulse\n);\n\n\n    // Internal signals\n    wire [BAUD_ACC_WIDTH:0] baud_inc;\n    reg [BAUD_ACC_WIDTH:0] baud_acc;\n\n    // Calculate the baud increment value\n    assign baud_inc = ((BAUD_RATE << (BAUD_ACC_WIDTH - 4)) + (CLOCK_FREQ >> 5)) / (CLOCK_FREQ >> 4);\n\n    // Baud generator logic\n    always @ (posedge clock or negedge reset_neg) begin\n        if (!reset_neg) begin\n            baud_acc <= 0;\n        end else if (enable) begin\n            baud_acc <= baud_acc[BAUD_ACC_WIDTH - 1:0] + baud_inc;\n        end\n    end\n\n    // Generate the baud pulse\n    assign baud_pulse = baud_acc[BAUD_ACC_WIDTH];\n\nendmodule\n"}}, "output": {"response": "", "context": {"verif/tb_copilot_rs_232.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/copilot_rs_232.sv \nHASH            = 4-testbench-checker-for-copilot_rs_232\nNUM_BUGS        = 3", "src/copilot_rs_232.sv": "module copilot_rs_232 (\n    clock,\n    reset_neg,\n    tx_datain_ready,\n    Present_Processing_Completed,\n    tx_datain,\n    tx_transmitter,\n    tx_transmitter_valid\n);\n    // Parameters\n    parameter HIGH = 1'b1;\n    parameter LOW = 1'b0;\n    parameter CLOCK_FREQ = 100000000; // 100MHz\n    parameter BAUD_RATE = 115200;     // Default baud rate\n    parameter REG_INPUT = 1;\n    parameter BAUD_ACC_WIDTH = 16;\n\n    // Inputs\n    input reset_neg;\n    input clock;\n    input tx_datain_ready;\n    input Present_Processing_Completed;\n    input [7:0] tx_datain;\n\n    // Outputs\n    output tx_transmitter;\n    output tx_transmitter_valid;\n\n    // Internal signals\n    reg tx_transmitter;\n    wire baud_pulse;\n\n    // Instantiate the Baud Rate Generator\n    baud_rate_generator #(\n        .BAUD_ACC_WIDTH(BAUD_ACC_WIDTH),\n        .CLOCK_FREQ(CLOCK_FREQ),\n        .BAUD_RATE(BAUD_RATE)\n    ) baud_gen (\n        .clock(clock),\n        .reset_neg(reset_neg),\n        .enable(tx_transmitter_valid),\n        .baud_pulse(baud_pulse)\n    );\n\n    // Transmitter State Machine\n    reg [3:0] State;\n    wire tx_Xfer_Ready = (State == 0);\n    assign tx_transmitter_valid = ~tx_Xfer_Ready;\n\n    reg [7:0] tx_data_reg;\n    always @ (posedge clock or negedge reset_neg) begin\n        if (reset_neg == LOW) begin\n            tx_data_reg <= 8'hFF;\n        end else if (Present_Processing_Completed == HIGH) begin\n            tx_data_reg <= 8'hFF;\n        end else if (tx_Xfer_Ready & tx_datain_ready) begin\n            tx_data_reg <= tx_datain;\n        end\n    end\n\n    wire [7:0] Tx_Data_Byte;\n    assign Tx_Data_Byte = REG_INPUT ? tx_data_reg : tx_datain;\n\n    always @ (posedge clock or negedge reset_neg) begin\n        if (reset_neg == LOW) begin\n            State <= 4'b0000;\n        end else if (Present_Processing_Completed == HIGH) begin\n            State <= 4'b0000;\n        end else begin\n            $display(\"else tx_datain_ready = %b,State = %b, tx_data_reg = %h\", tx_datain_ready,State, tx_data_reg);\n            case(State)\n                4'b0000: if (tx_datain_ready) State <= 4'b0100; // Idle\n                4'b0100: if (baud_pulse) State <= 4'b1000;      // Start\n                4'b1000: if (baud_pulse) State <= 4'b1001;      // Bit 0\n                4'b1001: if (baud_pulse) State <= 4'b1010;      // Bit 1\n                `ifndef BUG_0\n                4'b1010: if (baud_pulse) State <= 4'b1011;      // Bit 2\n                `else \n                4'b1010: if (baud_pulse) State <= 4'b1100;      // Bit 2\n                `endif\n                4'b1011: if (baud_pulse) State <= 4'b1100;      // Bit 3\n                4'b1100: if (baud_pulse) State <= 4'b1101;      // Bit 4\n                4'b1101: if (baud_pulse) State <= 4'b1110;      // Bit 5\n                4'b1110: if (baud_pulse) State <= 4'b1111;      // Bit 6\n                4'b1111: if (baud_pulse) State <= 4'b0010;      // Bit 7\n                4'b0010: if (baud_pulse) State <= 4'b0000;      // Stop\n                default: if (baud_pulse) State <= 4'b0000;\n            endcase\n        end\n    end\n\n    // Output Multiplexer\n    reg MuxBit;\n    always @ (State or Tx_Data_Byte) begin\n        case (State[2:0])\n            3'd0: MuxBit <= Tx_Data_Byte[0];\n            3'd1: MuxBit <= Tx_Data_Byte[1];\n            3'd2: MuxBit <= Tx_Data_Byte[2];\n        `ifndef BUG_1\n            3'd3: MuxBit <= Tx_Data_Byte[3];\n        `else \n            3'd3: MuxBit <= Tx_Data_Byte[2];\n        `endif\n            3'd4: MuxBit <= Tx_Data_Byte[4];\n            3'd5: MuxBit <= Tx_Data_Byte[5];\n            3'd6: MuxBit <= Tx_Data_Byte[6];\n            3'd7: MuxBit <= Tx_Data_Byte[7];\n        endcase\n    end\n\n    // Assemble Start, Data, and Stop Bits\n    always @ (posedge clock or negedge reset_neg) begin\n        if (reset_neg == LOW) begin\n            tx_transmitter <= HIGH;\n        end else if (Present_Processing_Completed == HIGH) begin\n            tx_transmitter <= HIGH;\n        end else begin\n        `ifndef BUG_2\n            tx_transmitter <= (State < 4) | (State[3] & MuxBit); // Glitch-free output\n        `else \n            tx_transmitter <= (State < 4) & (State[3] & MuxBit); // Glitch-free output\n        `endif\n        end\n    end\n\nendmodule\n\n// Baud Rate Generator Module\nmodule baud_rate_generator #(\n    parameter CLOCK_FREQ = 100000000, // 100MHz\n    parameter BAUD_RATE = 115200, // Default baud rate\n    parameter BAUD_ACC_WIDTH = 16\n)\n (\n    input clock,\n    input reset_neg,\n    input enable,\n    output reg baud_pulse\n);\n\n\n    // Internal signals\n    wire [BAUD_ACC_WIDTH:0] baud_inc;\n    reg [BAUD_ACC_WIDTH:0] baud_acc;\n\n    // Calculate the baud increment value\n    assign baud_inc = ((BAUD_RATE << (BAUD_ACC_WIDTH - 4)) + (CLOCK_FREQ >> 5)) / (CLOCK_FREQ >> 4);\n\n    // Baud generator logic\n    always @ (posedge clock or negedge reset_neg) begin\n        if (!reset_neg) begin\n            baud_acc <= 0;\n        end else if (enable) begin\n            baud_acc <= baud_acc[BAUD_ACC_WIDTH - 1:0] + baud_inc;\n        end\n    end\n\n    // Generate the baud pulse\n    assign baud_pulse = baud_acc[BAUD_ACC_WIDTH];\n\nendmodule\n\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun -timescale 1ns/1ps /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_secure_ALU_0006", "categories": ["cid013", "easy"], "input": {"prompt": "Create a **SystemVerilog testbench checker** with detailed stimulus to test using checker and to validate the `alu_seq` module by applying exhaustive test scenarios and verifying the correctness of its **ALU** output. The testbench should ensure:\n\n- Comprehensive **input stimulus** generation covering all possible cases.\n- **Checker Generation** of the ALU output.\n- **Coverage measurement** to confirm all relevant scenarios are tested.\n\n---\n## **Instantiation**\nName the instance of the RTL as `dut`.\n\n## **RTL Parameter Inputs - Outputs and Functional behaviour**\n\n### **Inputs**:\n   - `i_clk` (Clock signal)\n   - `i_rst_b` (Active-low asynchronous reset)\n   - `i_operand_a` (4-bit input operand)\n   - `i_operand_b` (4-bit input operand)\n   - `i_opcode` (3-bit input signal to specify the operation)\n   - `i_key_in` (8-bit input security key)\n\n### **Outputs**:\n   - `o_result` (8-bit result of the operation)\n\n### **Parameter**:\n   - A configurable 8-bit internal security key, `p_key`, with default to 0xAA.\n\n### **Functional Behavior**:\n   - If `i_key_in` matches the internal key, the ALU operations are active and follow the behavior described below:\n     - **Addition** (`i_opcode = 000`): Perform `i_operand_a + i_operand_b`.\n     - **Subtraction** (`i_opcode = 001`): Perform `i_operand_a - i_operand_b`.\n     - **Multiplication** (`i_opcode = 010`): Perform `i_operand_a * i_operand_b`.\n     - **Bitwise AND** (`i_opcode = 011`): Perform `i_operand_a & i_operand_b`.\n     - **Bitwise OR** (`i_opcode = 100`): Perform `i_operand_a | i_operand_b`.\n     - **Bitwise NOT** (`i_opcode = 101`): Negate `i_operand_a` (i.e., `~i_operand_a`).\n     - **Bitwise XOR** (`i_opcode = 110`): Perform `i_operand_a ^ i_operand_b`.\n     - **Bitwise XNOR** (`i_opcode = 111`): Perform `~(i_operand_a ^ i_operand_b)`.\n   - If `i_key_in` does not match the internal key:\n     - The output `o_result` should remain `8'b0`, and no operation is performed.\n\n### **Reset Behavior**:\n   - If `i_rst_b` is low (logic 0), `o_result` should be initialized to `8'b0`.\n---\n## Stimulus and checker generation\n\n1. **Initial Reset**\n   - Drive `i_rst_b = 0` at simulation start.\n   - Randomize `i_operand_a`, `i_operand_b`, `i_opcode`, and `i_key_in`.\n   - Verify `o_result` remains `8'b0`.\n   - De-assert `i_rst_b` (to `1`); confirm output stays `8'b0` until the first valid operation.\n\n2. **Reset During Operation**\n   - With `i_key_in = 0xAA` and a valid opcode (e.g., `000` for addition), assert `i_rst_b = 0`.\n   - Confirm `o_result` goes to `8'b0`.\n   - De-assert `i_rst_b` back to `1`; validate normal ALU operation continues.\n\n3. **Key Mismatch**\n   - Use `i_key_in` values not equal to `0xAA` (e.g., `0x55`, `0xBB`) while cycling through multiple opcodes.\n   - Confirm that `o_result` remains `8'b0` regardless of opcode or operands.\n\n4. **Key Match**\n   - Drive `i_key_in = 0xAA` (matching `p_key`).\n   - Verify each opcode (`000` to `111`) works correctly, using a range of `i_operand_a` and `i_operand_b`:\n     - **Add (000)**: Test operands `0+0`, `15+15`, random pairs.\n     - **Sub (001)**: Test operands `15-0`, `0-15`, `15-15`, random.\n     - **Mul (010)**: Test `0\u00d7anything`, `15\u00d715`, random pairs.\n     - **AND (011)**: Check `0xF & 0xF`, `0x0 & 0x0`, random.\n     - **OR (100)**: Check `0xF | 0xF`, `0x0 | 0x0`, random.\n     - **NOT (101)**: Only `i_operand_a` matters; iterate from `0x0` to `0xF`.\n     - **XOR (110)**: Check `0xF ^ 0xF`, `0x0 ^ 0x0`, random.\n     - **XNOR (111)**: Check complements (`0xF`, `0x0`) and random pairs.\n\n5. **Rapid Opcode Switching**\n   - Change `i_opcode` each clock cycle (with `i_key_in = 0xAA`), and update `i_operand_a`/`i_operand_b` randomly.\n   - Ensure outputs match expected ALU results on each rising clock edge.\n\n6. **Key Toggling**\n   - Alternate `i_key_in` between valid (`0xAA`) and invalid values across different clock cycles.\n   - Confirm output transitions between correct ALU results (when key matches) and `8'b0` (when key mismatches).\n\n## Simulation\n- Reset the dut and initialize inputs.\n- Apply the test cases sequentially.\n- Log errors if any discrepancies are found between dut outputs and the model using `$error`.\n\n## Deliverables\nProvide the complete SystemVerilog testbench code with:\n1. dut instantiation.\n2. Implement a behavioral model to replicate the expected functionality.\n3. Test scenarios validating the dut against the expected behavior.\n4. Compare the outputs from the DUT with the model using checkers\n5. Log messages indicating pass/fail status for each test case.\n---", "context": {}}, "output": {"response": "", "context": {"verif/tb_alu_seq.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/alu_seq.v\nHASH            = 6-tb-checker\nNUM_BUGS        = 5", "src/alu_seq.v": "module alu_seq (\n    input             i_clk,       \n    input             i_rst_b,    \n    input      [3:0]  i_operand_a, \n    input      [3:0]  i_operand_b, \n    input      [2:0]  i_opcode,    \n    input      [7:0]  i_key_in,    \n    output reg [7:0]  o_result     \n);\n    `ifdef BUG_0\n        localparam [7:0] p_key = 8'hBB;\n    `else\n        parameter [7:0] p_key = 8'hAA;\n    `endif\n\n    always @(posedge i_clk or negedge i_rst_b) begin\n        if (!i_rst_b) begin\n            `ifdef BUG_1\n                o_result <= 8'h10;\n            `else\n                o_result <= 8'b0;\n            `endif\n        end \n        else begin\n            `ifdef BUG_2\n                if (i_key_in !== p_key) begin\n                    case (i_opcode)\n                        3'b000: \n                            o_result <= i_operand_a + i_operand_b;\n                        3'b001: \n                            o_result <= i_operand_a - i_operand_b;\n                        3'b010: \n                            o_result <= i_operand_a * i_operand_b;\n                        3'b011: \n                            o_result <= {{4'b0},i_operand_a & i_operand_b};\n                        3'b100: \n                            o_result <= {{4'b0},i_operand_a | i_operand_b};\n                        3'b101: \n                            o_result <= {{4'b0},~i_operand_a};\n                        3'b110: \n                            o_result <= {{4'b0},i_operand_a ^ i_operand_b};\n                        3'b111: \n                            o_result <= {{4'b0},~(i_operand_a ^ i_operand_b)};\n                    endcase\n                end\n                else begin\n                    o_result <= 8'b0;\n                end\n            `elsif BUG_3\n                if (i_key_in == p_key) begin\n                    case (i_opcode)\n                        3'b000: \n                            o_result <= i_operand_a - i_operand_b;\n                        3'b001: \n                            o_result <= i_operand_a + i_operand_b;\n                        3'b010: \n                            o_result <= i_operand_a * i_operand_b;\n                        3'b011: \n                            o_result <= {{4'b0},i_operand_a & i_operand_b};\n                        3'b100: \n                            o_result <= {{4'b0},i_operand_a ^ i_operand_b};\n                        3'b101: \n                            o_result <= {{4'b0},~(i_operand_a^ i_operand_b)};\n                        3'b110: \n                            o_result <= {{4'b0},i_operand_a | i_operand_b};\n                        3'b111: \n                            o_result <= {{4'b0},~i_operand_a};\n                    endcase\n                end\n                else begin\n                    o_result <= 8'b0;\n                end\n            `elsif BUG_4\n                if (i_key_in == p_key) begin\n                    case (i_opcode)\n                        3'b000: \n                            o_result <= i_operand_a + i_operand_b;\n                        3'b001: \n                            o_result <= i_operand_a - i_operand_b;\n                        3'b010: \n                            o_result <= i_operand_a * i_operand_b;\n                        3'b011: \n                            o_result <= {{4'b0},i_operand_a & i_operand_b};\n                        3'b100: \n                            o_result <= {{4'b0},i_operand_a | i_operand_b};\n                        3'b101: \n                            o_result <= {{4'b0},~i_operand_a};\n                        3'b110: \n                            o_result <= {{4'b0},i_operand_a ^ i_operand_b};\n                        3'b111: \n                            o_result <= {{4'b0},~(i_operand_a ^ i_operand_b)};\n                    endcase\n                end\n                else begin\n                    o_result <= 8'h04;\n                end    \n            `else\n                if (i_key_in == p_key) begin\n                    case (i_opcode)\n                        3'b000: \n                            o_result <= i_operand_a + i_operand_b;\n                        3'b001: \n                            o_result <= i_operand_a - i_operand_b;\n                        3'b010: \n                            o_result <= i_operand_a * i_operand_b;\n                        3'b011: \n                            o_result <= {{4'b0},i_operand_a & i_operand_b};\n                        3'b100: \n                            o_result <= {{4'b0},i_operand_a | i_operand_b};\n                        3'b101: \n                            o_result <= {{4'b0},~i_operand_a};\n                        3'b110: \n                            o_result <= {{4'b0},i_operand_a ^ i_operand_b};\n                        3'b111: \n                            o_result <= {{4'b0},~(i_operand_a ^ i_operand_b)};\n                    endcase\n                end\n                else begin\n                    o_result <= 8'b0;\n                end\n            `endif\n        end\n    end\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.v /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\""}}}
{"id": "cvdp_copilot_secure_read_write_bus_0005", "categories": ["cid012", "medium"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `secure_read_write_bus_interface`. It support both read and write operations, with authorization based on a comparison between the input key and an internal parameterized key. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameters, Inputs - Outputs and Functional behavior**\n\n### Functional Requirements\n1. **Read and Write Operations**:\n   - The bus performs read or write actions based on an enable signal.\n   - Access is authorized only if the provided key matches an internal key, with errors flagged otherwise.\n\n### Inputs\n- `i_addr` (`p_addr_width bit`): Specifies the target address for read or write operations.\n- `i_data_in` (`p_data_width` bit): Data to be written during a write operation.\n- `i_key_in` (`8-bit`): Key provided by the initiator for operation authorization.\n- `i_read_write_enable` (`1-bit`): Specifies the requested operation; `1` for read, `0` for write.\n- `i_capture_pulse` (`1-bit`): Qualifies input capture for `i_addr`, `i_data_in`, `i_key_in`, and `i_read_write_enable`.\n- `i_reset_bar` (`1-bit`): Asynchronous, active-low reset to initialize internal states and registers.\n\n### Outputs\n- `o_data_out` (`p_data_width` bit): Data output during a read operation, valid only if the input key matches the internal key.\n- `o_error` (`1-bit`): Asserted if the input key is incorrect and dessert if input key is correct.\n\n### Behavioral Requirements\n\n#### Write Operation\n- If `i_read_write_enable` is **0**, the bus interprets the operation as a write request.\n- At the rising edge of `i_capture_pulse`:\n  - If `i_key_in` matches the internal 8-bit configurable key, `i_data_in` is written to the address specified by `i_addr`.\n  - If `i_key_in` does not match the internal key:\n    - `o_error` is set to **1**.\n    - `o_data_out` is set to **0** (default).\n\n#### Read Operation\n- If `i_read_write_enable` is **1**, the bus interprets the operation as a read request.\n- At the rising edge of `i_capture_pulse`:\n  - If `i_key_in` matches the internal key, data from address `i_addr` is output on `o_data_out`, and `o_error` is **0**.\n  - If `i_key_in` does not match:\n    - `o_error` is set to **1**.\n    - `o_data_out` remains **0**.\n\n### Parameterization Requirements\n- `p_configurable_key`: Internal 8-bit key, default value `8'hAA`.\n- `p_data_width`: Configurable data width, default is **8 bits**.\n- `p_addr_width`: Configurable address width, default is **8 bits**.\n\n### Additional Requirements\n1. **Edge Case Handling**:\n   - `i_reset_bar` reset signal should clear all internal registers and outputs when asserted low.\n   - Ensure that outputs default to `0` upon reset or when unauthorized access occurs.\n2. **Clocking and Timing**:\n   - Operations are gated by the positive edge of `i_capture_pulse` for both read and write actions.\n   - Timing for signal latching and error assertions should align with rising edges of `i_capture_pulse`.\n\n### Assumptions\n  - Assume all the inputs are synchronous to the `i_capture_pulse`\n\n## Test Bench Requirements\n\n### Stimulus Generation\n\n## **1. Reset Behavior**\n- The system should be tested under reset conditions.  \n- Reset is released.\n\n---\n\n## **2. Write Operations**\n### **2.1 Writing Data Under Normal Conditions**\n- A write operation should be performed when the interface is enabled for writing.  \n\n### **2.2 Unauthorized Write Attempt**\n- An attempt should be made to write data while using an incorrect authentication key.  \n\n### **2.3 Writing at the Lower Address Boundary**\n- A write operation should be performed at the smallest possible address in the addressable range.  \n\n### **2.4 Writing at the Upper Address Boundary**\n- A write operation should be performed at the largest possible address in the addressable range.\n\n### **2.5 Randomized Write Operations**\n- Multiple write operations should be performed at various random addresses with different data values.  \n\n---\n\n## **3. Read Operations**\n### **3.1 Reading Data Under Normal Conditions**\n- A read operation is requested, and the correct authentication key is provided.\n\n### **3.2 Unauthorized Read Attempt**\n- A read request should be made using an incorrect authentication key.\n\n### **3.3 Reading from an Uninitialized Memory Location**\n- An attempt should be made to read from an address where no data has been written, ensuring predictable behavior.\n\n### **3.4 Reading at the Lower Address Boundary**\n- A read operation should be performed at the smallest possible address.\n\n### **3.5 Reading at the Upper Address Boundary**\n- A read operation should be performed at the largest possible address in the addressable range to ensure boundary handling.\n\n---\n\n## **4. Error Handling & Corner Cases**\n### **4.1 Switching Between Correct and Incorrect Authentication Keys**\n- The system should be tested by performing multiple read and write operations while alternating between valid and invalid authentication keys.\n\n### **4.2 Writing Without Initiating the Operation**\n- An attempt should be made to write data without properly triggering the operation.\n\n### **4.3 Reading Without Initiating the Operation**\n- A read request should be simulated without properly triggering the operation.\n\n### **4.4 Unauthorized Read Followed by an Authorized Write**\n- An unauthorized read should be performed first, followed by an attempt to write data using the correct authentication key.\n\n### **4.5 Unauthorized Write Followed by an Authorized Read**\n- An unauthorized write should be attempted first, followed by an authorized read to ensure no incorrect data modifications occur.\n\n### **4.6 Rapid Switching Between Read and Write**\n- The interface should be tested with rapid consecutive read and write operations to check for any inconsistencies or race conditions.\n\n---\n\n## **5. Reset and System Initialization**\n### **5.1 System Behavior During Reset**\n- The system should be reset in the middle of operations.\n\n### **5.2 Operations After Reset**\n- Once reset is deactivated, read and write operations resumes.\n\n---\n\n## **6. Stress Testing**\n### **6.1 Consecutive Writes**\n- A series of consecutive write operations should be performed to different addresses.\n\n### **6.2 Consecutive Reads**\n- Multiple read operations should be executed in succession.\n\n### **6.3 Immediate Read After Write**\n- Data should be written to a location, and an immediate read request should be performed at the same address.\n\n### **6.4 Frequent Changes in Authentication Key**\n- Successive read and write operations should be tested while frequently changing the authentication key.\n\n### **6.5 Combining Edge Cases**\n- A complex test scenario should be created by combining multiple conditions, such as alternating between valid and invalid keys, performing reads and writes at boundary addresses, and introducing reset signals.", "context": {}}, "output": {"response": "", "context": {"verif/tb_secure_read_write_bus_interface.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 5-tb-stimulus\nTARGET = 100", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/secure_read_write_bus_interface.v /code/verif/tb_secure_read_write_bus_interface.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/secure_read_write_bus_interface.v": "module secure_read_write_bus_interface #(\n    parameter p_configurable_key = 8'hAA,      // Default key\n    parameter p_data_width       = 8,         // Data width\n    parameter p_addr_width       = 8          // Address width\n)(\n    input  wire [p_addr_width-1:0] i_addr,            // Address input\n    input  wire [p_data_width-1:0] i_data_in,         // Data to write\n    input  wire [7:0]              i_key_in,         // Input key for authentication\n    input  wire                    i_read_write_enable, // 1: Read, 0: Write\n    input  wire                    i_capture_pulse,  // Qualifies input capture\n    input  wire                    i_reset_bar,      // Active-low reset\n    output reg  [p_data_width-1:0] o_data_out,       // Data output during read\n    output reg                     o_error           // Error flag for unauthorized access\n);\n\n    // Internal memory declaration\n    reg [p_data_width-1:0] memory [(2**p_addr_width)-1:0]; // Memory array\n\n    // Internal key comparison logic\n    wire key_match = (i_key_in == p_configurable_key); // Check if keys match\n\n    // Sequential logic: Operates on i_capture_pulse edge or asynchronous reset\n    always @(posedge i_capture_pulse or negedge i_reset_bar) begin\n        if (!i_reset_bar) begin\n            // Reset all outputs and states\n            o_data_out <= {p_data_width{1'b0}};\n            o_error    <= 1'b0;\n        end else begin\n            // Handle Read/Write operations based on enable signal\n            if (key_match) begin\n                o_error <= 1'b0; // Clear error flag if key matches\n                if (i_read_write_enable) begin\n                    // Read operation\n                    o_data_out <= memory[i_addr];\n                end else begin\n                    // Write operation\n                    memory[i_addr] <= i_data_in;\n                    o_data_out     <= {p_data_width{1'b0}}; // Clear output during write\n                end\n            end else begin\n                // Key mismatch: Raise error and clear outputs\n                o_error    <= 1'b1;\n                o_data_out <= {p_data_width{1'b0}};\n            end\n        end\n    end\nendmodule\n"}}}
{"id": "cvdp_copilot_secure_read_write_register_bank_0006", "categories": ["cid012", "medium"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `secure_read_write_register_bank`. It allows read and write operations only after unlocking, which requires specific values written to the first two addresses in sequence.The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameters, Inputs - Outputs and Functional behaviour**\n\n### Parameter\n1.  **p_address_width**: The address width parameter with default value of 8 bits. It will be used to create the addressable space of register bank module.\n2.  **p_data_width**: The data width parameter with default value of 8 bits.\n3. **p_unlock_code_0**: The unlock code to be written at address zero. The default value is 0xAB.\n4. **p_unlock_code_1**: The unlock code to be written at address one. The default value is 0xCD.\n\n\n### Inputs\n1. **i_addr**: `p_addr_width`-bit input. Specifies the target address for read or write operations.\n2. **i_data_in**: `p_data_width`-bit input. Data input to be written to the register bank during a write operation.\n3. **i_read_write_enable**: 1-bit input control signal. Determines the operation type:\n   - `0`: Write operation.\n   - `1`: Read operation.\n4. **i_capture_pulse**: 1-bit capture pulse signal. Triggers the read or write operation on positive edge of this signal. It will act as clock for register bank.\n5.  **i_rst_n**: 1-bit asynchronous active low reset, to reset the unlock state machine\n\n### Outputs\n1. **o_data_out**: `p_data_width`-bit output. Data output bus that reflects the value read from the register bank during a read operation.\n\n### Functional Requirements\n\n#### 1. Write Operation\n   - If **i_read_write_enable** is `0`, the module interprets this as a write operation.\n   - On the **rising edge** of **i_capture_pulse**, the value of **i_data_in** is written to the register at the address specified by **i_addr**.\n   - **o_data_out** should output `0` during write operations as a default state.\n\n#### 2. Read Operation\n   - If **i_read_write_enable** is `1`, the module interprets this as a read operation.\n   - On the **rising edge** of **i_capture_pulse**, **o_data_out** outputs the data stored at the address specified by **i_addr**.\n   - **o_data_out** only reflects the read data during read operations.\n\n### Security Access Requirements\n1. **Unlocking Mechanism**:\n   - **To unlock the register bank**, two sequential operations must be completed:\n     - First, the specific **parameterized unlock code** (matching **p_data_width**) must be written to address `0`.\n     - Then, a specific **parameterized trigger code** must be written to address `1`.\n   - If both conditions are met, the register bank unlocks, enabling access to read and write for all addresses.\n   - If, at any positive edge of i_capture_pulse, values are written to address 0 or 1 does not equal to given parameterized unlock code, the register bank will reset, resulting in lock of register bank. User needs to unlock the register bank once again.\n   - If the unlock sequence is incomplete, access to other addresses will remain restricted as follows:\n     - **Read Operation**: Outputs `0` on **o_data_out**.\n     - **Write Operation**: Prevents writing to any address except `0` and `1`.\n   - When i_rst_n goes low, then this unlocking mechanism resets and user needs to unlock the register bank once again.\n\n2. **Restricted Access Addresses**:\n   - Addresses `0` and `1` are write-only and cannot be read.\n   - Other addresses remain inaccessible for both read and write until the unlock sequence is completed.\n\n### Constraints and Edge Cases\n- Ensure that addresses `0` and `1` cannot be read.\n- Any read or write attempt on other addresses before unlocking should default **o_data_out** to `0` and prevent writing, respectively.\n- The writing of address `0` and address `1` should be concurrent, else register bank should be locked.\n\n## Test Bench Requirements\n\n### Stimulus Generation\n1. **Reset and Initialization:**  \n   - Assert the asynchronous reset signal briefly and then release it.\n\n2. **Locked State \u2013 Write Operation to a General Register:**  \n   - While the module is locked, perform a write operation to a register that is not part of the unlock sequence.\n\n3. **Locked State \u2013 Read Operation from a General Register:**  \n   - In the locked state, perform a read operation from a register outside the unlock sequence.\n\n4. **Locked State \u2013 Read Operation from the Unlock Addresses:**  \n   - While locked, attempt to read from the registers reserved for the unlock sequence.\n\n5. **Successful Unlock Sequence and General Access:**  \n   - Perform the unlock sequence by writing the appropriate unlock code to the first designated address followed by writing the corresponding unlock code to the second designated address, with both operations synchronized to the capture pulse.\n   - Once unlocked, perform a write to a general register and then read from that register.\n\n6. **Unlock Failure \u2013 Incorrect Code in the First Step:**  \n   - Attempt to start the unlock sequence by writing an incorrect code to the first designated address.\n   - Continue by performing the expected operation at the second designated address.\n\n7. **Unlock Failure \u2013 Incorrect Code in the Second Step:**  \n   - Initiate the unlock sequence correctly at the first designated address.\n   - Then write an incorrect code to the second designated address.\n\n8. **Out-of-Sequence Write Aborting Unlock:**  \n   - Begin the unlock sequence by writing the proper code to the first designated address.\n   - Instead of proceeding to the second designated address, write to a different register.\n\n9. **Unlocked State \u2013 Incorrect Write to Unlock Address Causes Relock:**  \n   - After achieving the unlocked state, perform a write operation with an incorrect code to one of the designated unlock addresses.\n   - Perform additional write/read operations on a general register to ensure that access remains restricted.\n\n10. **Unlocked State \u2013 Read Operation from Unlock Addresses:**  \n    - In the unlocked state, attempt to read from the registers used for the unlock sequence.\n\n11. **Boundary Register Operation:**  \n    - Once unlocked, perform a write operation to the highest addressable register in the bank.\n    - Follow this with a read from that boundary register.\n\n12. **Capture Pulse Synchronization:**  \n    - Modify control inputs (such as address selection, data to be written, or operation type) between capture pulses.\n\n13. **Reset During Active Operation:**  \n    - While the module is unlocked, perform a write operation to a general register.\n    - Assert the asynchronous reset during the operation and then de-assert it.\n    - Attempt a read from the previously written register.\n\n14. **Incorrect Unlock Sequence Order:**  \n    - Attempt to initiate the unlock sequence by writing to the second designated address before writing to the first designated address.\n\n15. **Multiple Sequential Unlock Attempts:**  \n    - First, attempt an unlock sequence that intentionally fails by providing an incorrect code in one of the steps.\n    - Then, retry the unlock sequence using the proper codes in the correct order.", "context": {}}, "output": {"response": "", "context": {"verif/tb_secure_read_write_register_bank.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 6-tb-stimulus\nTARGET = 96", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/secure_read_write_register_bank.v /code/verif/tb_secure_read_write_register_bank.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/secure_read_write_register_bank.v": "// -----------------------------------------------------------------------------\n// Module Name: secure_read_write_register_bank\n// Description: \n// This module implements a secure, parameterized register bank with access \n// control. It uses a state machine to enforce an unlocking mechanism for \n// read/write access. Access to the register bank is allowed only after a \n// two-step unlock sequence is completed by writing specific unlock codes to \n// predefined addresses. The register bank operates in a restricted mode until \n// the correct unlock sequence is performed.\n// \n// Key Features:\n// - Parameterized address and data widths\n// - Configurable unlock codes for security\n// - Read and write access controlled by a security FSM\n// - Addresses `0` and `1` are restricted to write-only operations\n// - Reset mechanism to relock the register bank\n// \n// -----------------------------------------------------------------------------\n\nmodule secure_read_write_register_bank #(\n    parameter p_address_width = 8,                // Address width parameter (default 8 bits)\n    parameter p_data_width = 8,                   // Data width parameter (default 8 bits)\n    parameter p_unlock_code_0 = 8'hAB,            // Unlock code for address 0\n    parameter p_unlock_code_1 = 8'hCD             // Unlock code for address 1\n)(\n    input  wire                         i_rst_n,            // Asynchronous active-low reset\n    input  wire [p_address_width-1:0]   i_addr,             // Address input for read/write operations\n    input  wire [p_data_width-1:0]      i_data_in,          // Data input for write operations\n    input  wire                         i_read_write_enable, // Control signal: 1 = Read, 0 = Write\n    input  wire                         i_capture_pulse,    // Capture pulse (acts as clock for the register bank)\n    output reg  [p_data_width-1:0]      o_data_out          // Data output for read operations\n);\n\n    // -------------------------------------------------------------------------\n    // Internal Memory: Register Bank\n    // -------------------------------------------------------------------------\n    // A 2^p_address_width-sized register bank to hold data. Each register is \n    // p_data_width bits wide. This memory is accessed using the `i_addr` signal.\n    reg [p_data_width-1:0] r_register_bank [0:(1<<p_address_width)-1];\n    \n    // -------------------------------------------------------------------------\n    // Unlock State Machine\n    // -------------------------------------------------------------------------\n    // Tracks the state of the unlock mechanism:\n    // - LOCKED: No access to register bank except for write-only access to \n    //   addresses 0 and 1 to attempt unlocking.\n    // - UNLOCK_STEP1: First step of the unlock sequence completed.\n    // - UNLOCKED: Full access granted.\n    reg [1:0] r_unlock_state;  // Unlock FSM state\n\n    // State Encoding\n    localparam p_STATE_LOCKED       = 2'b00; // Locked state (initial state)\n    localparam p_STATE_UNLOCK_STEP1 = 2'b01; // First unlock step complete\n    localparam p_STATE_UNLOCKED     = 2'b11; // Register bank fully unlocked\n\n    // -------------------------------------------------------------------------\n    // Unlock FSM Logic\n    // -------------------------------------------------------------------------\n    // The FSM transitions between LOCKED, UNLOCK_STEP1, and UNLOCKED states \n    // based on the address and data written to the register bank. Incorrect \n    // unlock codes or incorrect sequences reset the FSM back to LOCKED.\n    always @(posedge i_capture_pulse or negedge i_rst_n) begin\n        if (!i_rst_n) begin\n            // Reset the FSM to the locked state on active-low reset\n            r_unlock_state <= p_STATE_LOCKED;\n        end else begin\n            case (r_unlock_state)\n                p_STATE_LOCKED: begin\n                    // Check if the first unlock code is written to address 0\n                    if ((i_addr == 0) && (i_data_in == p_unlock_code_0) && (!i_read_write_enable)) begin\n                        r_unlock_state <= p_STATE_UNLOCK_STEP1; // Move to step 1\n                    end\n                end\n\n                p_STATE_UNLOCK_STEP1: begin\n                    // Check if the second unlock code is written to address 1\n                    if ((i_addr == 1) && (i_data_in == p_unlock_code_1) && (!i_read_write_enable)) begin\n                        r_unlock_state <= p_STATE_UNLOCKED; // Unlock successful\n                    end \n                    // If any other address is tried to be written, reset to LOCKED\n                    else begin\n                        r_unlock_state <= p_STATE_LOCKED;\n                    end\n                end\n\n                p_STATE_UNLOCKED: begin\n                    // If incorrect code is written to address 0 or 1, relock the register bank\n                    if (((i_addr == 1) && (i_data_in != p_unlock_code_1) && (!i_read_write_enable)) ||\n                        ((i_addr == 0) && (i_data_in != p_unlock_code_0) && (!i_read_write_enable))) begin\n                        r_unlock_state <= p_STATE_LOCKED;\n                    end\n                end\n\n                default: begin\n                    r_unlock_state <= p_STATE_LOCKED; // Default to LOCKED\n                end\n            endcase\n        end\n    end\n\n    // -------------------------------------------------------------------------\n    // Read and Write Operations\n    // -------------------------------------------------------------------------\n    always @(posedge i_capture_pulse) begin\n        if (r_unlock_state == p_STATE_UNLOCKED) begin\n            // Unlocked: Full access to the register bank\n            if (i_read_write_enable) begin\n                // Read operation\n                if (i_addr == 0 || i_addr == 1) begin\n                    o_data_out <= 0; // Addresses 0 and 1 are write-only\n                end else begin\n                    o_data_out <= r_register_bank[i_addr]; // Output data at address\n                end\n            end else begin\n                // Write operation\n                r_register_bank[i_addr] <= i_data_in; // Write data to register\n                o_data_out <= 0; // Default output during write\n            end\n        end else begin\n            // Locked: Restricted access\n            if (i_read_write_enable) begin\n                o_data_out <= 0; // Locked state: read outputs 0\n            end else begin\n                // Allow writes only to addresses 0 and 1\n                if (i_addr == 0 || i_addr == 1) begin\n                    r_register_bank[i_addr] <= i_data_in;\n                end\n                o_data_out <= 0; // Default output during write\n            end\n        end\n    end\n\nendmodule\n"}}}
{"id": "cvdp_copilot_secure_variable_timer_0006", "categories": ["cid012", "medium"], "input": {"prompt": "Create a self-checking test bench in SystemVerilog for a Verilog module named `secure_variable_timer`. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameters, Inputs - Outputs and Functional behavior**\n\n| **Port Name**      | **Direction** | **Width** | **Description**                                                              |\n|--------------------|---------------|-----------|------------------------------------------------------------------------------|\n| `i_clk`            | Input         | 1         | Clock signal, rising-edge triggered.                                         |\n| `i_rst_n`          | Input         | 1         | Active-low synchronous reset signal.                                         |\n| `i_data_in`        | Input         | 1         | Serial data input for detecting the start pattern and configuring the delay. |\n| `o_time_left`      | Output        | 4         | 4-bit output showing remaining time during the counting phase.               |\n| `o_processing`     | Output        | 1         | Asserted high when the timer is actively counting.                           |\n| `o_completed`      | Output        | 1         | Asserted high when the timer completes its delay cycle.                      |\n| `i_ack`            | Input         | 1         | Acknowledgment signal from the user to reset the timer after completion.     |\n\n---\n\n### Functional Requirements\n\nThe module operates as a timer with the following behavior:\n\n1. **Start Sequence Detection**:\n   - The timer begins when the serial data input (`i_data_in`) detects the bit sequence `1101` in the incoming stream.\n\n2. **Delay Duration Configuration**:\n   - After detecting the `1101` sequence, the module reads the next 4 bits (most significant bit first) from the `i_data_in` input.\n   - These 4 bits define the delay value (`delay[3:0]`), which determines the timer duration.\n\n3. **Counting Phase**:\n   - The timer counts for exactly ((delay[3:0] + 1) * 1000) clock cycles:\n     - Example: If `delay = 0`, the timer counts for 1000 cycles; if `delay = 5`, the timer counts for 6000 cycles.\n   - During this phase:\n     - The `o_processing` output is asserted high.\n     - The `o_time_left` output decrements as follows:\n       - Starts at `delay` for the first 1000 cycles.\n       - Decrements by 1 every subsequent 1000 cycles until reaching 0.\n\n4. **Completion and Reset**:\n   - Once the counting phase completes:\n     - The `o_completed` signal is asserted high to notify the user.\n     - The module waits for the `i_ack` signal to reset itself and begin searching for the next `1101` sequence.\n\n5. **Idle State**:\n   - When not actively counting:\n     - The `o_time_left` output is a don't-care value.\n     - The module resumes searching the `i_data_in` input for the `1101` sequence.\n\n---\n\n### Design Constraints\n\n- **Clock and Reset**:\n  - On reset, the module enters the idle state, ready to search for the `1101` sequence.\n\n- **Input Handling**:\n  - The `i_data_in` input is ignored during the counting phase.\n  - Only transitions to the configuration phase when the `1101` sequence is detected.\n\n- **Output Behavior**:\n  - The `o_time_left` output is only valid during the counting phase and must correctly represent the remaining time as described.\n\n---\n\n### Implementation Notes\n\n1. **State Machine Design**:\n   - Implement a finite state machine (FSM) to manage the following states:\n     - **Idle**: Search for the `1101` pattern in the `i_data_in` input.\n     - **Configure Delay**: Shift in the next 4 bits to set the delay value (`delay[3:0]`).\n     - **Counting**: Count for \\((\\text{delay[3:0]} + 1) \\times 1000\\) clock cycles.\n     - **Done**: Assert the `o_completed` output and wait for `i_ack` before resetting.\n     \n2. **Counting Logic**:\n   - Use a counter to count the total clock cycles required for the delay.\n   - Maintain a decrementing `o_time_left` output to reflect the remaining time.\n\n---\n## Stimulus generation\n1. **Reset & Idle**\n   - Assert `i_rst_n=0`, then drive high.\n\n2. **No Start Sequence**\n   - Feed random bits avoiding `1101`.\n\n3. **Start Sequence Detection**\n   - Provide `1101` immediately, then incomplete 4-bit delay.\n\n4. **Various Delay Values**\n   - After `1101`, supply 4-bit delays from `0000` to `1111`.\n\n5. **Completion & Acknowledgment**\n   - Feed `1101 + valid_delay`; wait for `o_completed=1`.\n   - Assert `i_ack`; \n\n6. **Overlapping Start Sequence**\n   - Input bit patterns like `11101` or `1101101`.\n\n7. **Spurious Input During Count**\n   - Once counting, feed random `i_data_in`.\n\n8. **Reset Mid-Count**\n   - While counting, assert `i_rst_n=0`.\n   - \n\n9. **Consecutive Timers**\n   - Drive multiple `1101 + 4-bit` sequences back-to-back.", "context": {}}, "output": {"response": "", "context": {"verif/tb_secure_variable_timer.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 6-tb-stimulus\nTARGET = 98", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/secure_variable_timer.v /code/verif/tb_secure_variable_timer.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/secure_variable_timer.v": "module secure_variable_timer (\n    input  wire        i_clk,         // Clock signal (rising-edge triggered)\n    input  wire        i_rst_n,       // Active-low synchronous reset signal\n    input  wire        i_data_in,     // Serial data input\n    output reg  [3:0]  o_time_left,   // 4-bit output showing remaining time (during counting phase)\n    output reg         o_processing,  // Asserted high when the timer is actively counting\n    output reg         o_completed,   // Asserted high when the timer completes its delay\n    input  wire        i_ack          // Acknowledgment signal to reset after completion\n);\n\n    //--------------------------------------------------------------------\n    // 1) State Definitions\n    //--------------------------------------------------------------------\n    localparam  STATE_IDLE       = 2'b00;  // Waiting for 1101 pattern\n    localparam  STATE_DELAY_CFG  = 2'b01;  // Reading 4 bits of delay\n    localparam  STATE_COUNT      = 2'b10;  // Counting phase\n    localparam  STATE_DONE       = 2'b11;   // Timer done, waiting for i_ack\n\n    reg [1:0] current_state;\n    reg [1:0] next_state;\n\n    //--------------------------------------------------------------------\n    // 2) Internal Registers\n    //--------------------------------------------------------------------\n    // Shift register for detecting start pattern (1101)\n    reg [3:0] pattern_shift;\n    // Counter to know how many bits of delay have been read\n    reg [1:0] delay_bit_count;\n    // Temporary shift register for the 4-bit delay value\n    reg [3:0] delay_shift;\n\n\n    // Sub-counter for 1000-cycle chunks\n    // Counts from 0 to 999, then resets\n    reg [9:0] sub_count;\n\n    //--------------------------------------------------------------------\n    // 3) State Machine - Sequential Logic\n    //--------------------------------------------------------------------\n    always @(posedge i_clk or negedge i_rst_n) begin\n        if (!i_rst_n) begin\n            // Synchronous reset (active low)\n            current_state   <= STATE_IDLE;\n            pattern_shift   <= 4'b0;\n            delay_bit_count <= 2'd0;\n            delay_shift     <= 4'b0;\n            sub_count       <= 10'd0;\n            o_time_left     <= 4'b0;\n        end\n        else begin\n            current_state <= next_state;\n\n            case (current_state)\n\n            //--------------------------------------------------------------\n            // STATE_IDLE: Search for the 1101 pattern in i_data_in\n            //--------------------------------------------------------------\n            STATE_IDLE: begin\n                // Shift in the new bit each clock\n                // pattern_shift[3] is the oldest bit, pattern_shift[0] is the newest\n                pattern_shift <= {pattern_shift[2:0], i_data_in};\n\n                // Once we detect the pattern 1101, we\u2019ll move to STATE_DELAY_CFG\n                // (We can check the pattern right after we shift in the new bit.)\n                if (pattern_shift == 4'b1101) begin\n                    // Prepare for delay configuration\n                    delay_bit_count <= 2'd0;\n                    delay_shift     <= 4'b0;\n                end\n            end\n\n            //--------------------------------------------------------------\n            // STATE_DELAY_CFG: Read next 4 bits as the delay\n            //--------------------------------------------------------------\n            STATE_DELAY_CFG: begin\n                // Shift in the next bit from i_data_in\n                delay_shift <= {delay_shift[2:0], i_data_in};\n                delay_bit_count <= delay_bit_count + 1'b1;\n                // Once we have collected 4 bits, latch them as the final delay\n                if (delay_bit_count == 2'd2) begin\n                    o_time_left <= {delay_shift[2:0], i_data_in}; \n                    \n                end\n            end\n\n            //--------------------------------------------------------------\n            // STATE_COUNT: Counting phase\n            //--------------------------------------------------------------\n            STATE_COUNT: begin\n                // Sub-counter increments every clock\n                sub_count <= sub_count + 1'b1;\n                // After 1000 cycles, sub_count resets and o_time_left decrements\n                if (sub_count == 10'd999) begin\n                    sub_count   <= 10'd0;\n                    // Decrement time_left if not already zero\n                    if (o_time_left != 4'd0)\n                        o_time_left <= o_time_left - 1'b1;\n                end\n            end\n\n            //--------------------------------------------------------------\n            // STATE_DONE: Timer complete, o_completed=1, waiting for i_ack\n            //--------------------------------------------------------------\n            STATE_DONE: begin\n                pattern_shift   <= 4'b0;\n                delay_bit_count <= 2'd0;\n                delay_shift     <= 4'b0;\n                // Remain here until i_ack is seen\n                // (No special sequential logic needed here.)\n            end\n\n            endcase\n        end\n    end\n\n    //--------------------------------------------------------------------\n    // 4) State Machine - Combinational Next-State Logic\n    //--------------------------------------------------------------------\n    always @* begin\n\n        case (current_state)\n\n        //--------------------------------------------------------------\n        // STATE_IDLE\n        //--------------------------------------------------------------\n        STATE_IDLE: begin\n            // Remain in IDLE unless we detect '1101' in pattern_shift\n            if (pattern_shift == 4'b1101) begin\n                next_state = STATE_DELAY_CFG;\n                o_completed = 1'b0; \n                o_processing = 1'b0;\n            end\n            else begin\n                next_state = STATE_IDLE;\n                o_completed = 1'b0; \n                o_processing = 1'b0;\n            end\n        end\n\n        //--------------------------------------------------------------\n        // STATE_DELAY_CFG\n        //--------------------------------------------------------------\n        STATE_DELAY_CFG: begin\n            // Wait until we've read 4 bits total (delay_bit_count = 4)\n            if (delay_bit_count == 2'd3) begin\n                // Move to COUNT state\n                next_state = STATE_COUNT;\n                o_processing = 1'b1; // During counting phase, we set o_processing=1\n                o_completed = 1'b0; \n            end\n            else begin\n                next_state = STATE_DELAY_CFG;\n                o_completed = 1'b0; \n                o_processing = 1'b0;\n            end\n        end\n\n        //--------------------------------------------------------------\n        // STATE_COUNT\n        //--------------------------------------------------------------\n        STATE_COUNT: begin\n            \n\n            // We count for (delay_reg + 1) * 1000 cycles\n            // The easiest check: if o_time_left == 0 AND sub_count == 999,\n            // then we have just finished the final chunk of 1000 cycles.\n            if ((o_time_left == 4'd0) && (sub_count == 10'd999)) begin\n                // Counting complete\n                next_state = STATE_DONE;\n                o_completed = 1'b1; // Signal completion\n                o_processing = 1'b0;\n            end\n            else begin\n                next_state = STATE_COUNT;\n                o_processing = 1'b1;\n                o_completed = 1'b0; \n            end\n        end\n\n        //--------------------------------------------------------------\n        // STATE_DONE\n        //--------------------------------------------------------------\n        STATE_DONE: begin\n\n            // Once i_ack is asserted, go back to STATE_IDLE\n            // to look for next 1101 pattern\n            if (i_ack == 1'b1) begin\n                next_state = STATE_IDLE;\n                o_processing = 1'b0;\n                o_completed = 1'b0;\n            end\n            else begin\n                next_state = STATE_DONE;\n                o_completed = 1'b1;\n                o_processing = 1'b0;\n            end\n        end\n\n        endcase\n    end\n\n\n\nendmodule"}}}
{"id": "cvdp_copilot_sequencial_binary_to_one_hot_decoder_0004", "categories": ["cid013", "easy"], "input": {"prompt": "Create a **SystemVerilog testbench checker** with detailed stimulus to test using checker and to validate the `binary_to_one_hot_decoder_sequential` module by applying exhaustive test scenarios and verifying the correctness of its **one-hot encoded** output. The testbench should ensure:\n\n- Comprehensive **input stimulus** generation covering all possible cases.\n- **Checker generation** of the one-hot output.\n\n---\n## **Instantiation**\nName the instance of the RTL as `dut`.\n\n## **RTL Parameter Inputs - Outputs and Functional behaviour**\n\n### Module Parameters  \n1. **`BINARY_WIDTH`**: Specifies the bit width of the binary input `i_binary_in`. This parameter determines the maximum binary value that can be decoded. Default: `BINARY_WIDTH=5`.  \n2. **`OUTPUT_WIDTH`**: Defines the width of the output `o_one_hot_out`, which should have `2^BINARY_WIDTH` bits if fully utilized. However, `OUTPUT_WIDTH` can be set independently to limit the number of one-hot output bits. Default: `OUTPUT_WIDTH=32`.\n\n### Inputs and Outputs  \n- **Inputs**:  \n  - `i_binary_in` (`BINARY_WIDTH` bits) \u2014 Binary input signal.  \n    - Represents a binary-encoded value up to `2^BINARY_WIDTH - 1`.  \n    - Example: For `BINARY_WIDTH = 5`, `i_binary_in` can range from `5'd0` to `5'd31`.  \n    - The input is sampled on the rising edge of `i_clk`.  \n  - `i_clk` (`1-bit`) \u2014 Clock signal (active on the rising edge).  \n  - `i_rstb` (`1-bit`)\u2014 Asynchronous reset signal (active low).\n\n- **Output**:  \n  - `o_one_hot_out` (`OUTPUT_WIDTH` bits) \u2014 One-hot encoded output signal from a sequential register of `OUTPUT_WIDTH` bits to hold state.  \n    - A one-hot encoded output where only the bit at index `i_binary_in` is set to `1`, with all other bits set to `0`.  \n    - Example: If `i_binary_in = 5'd3` and `OUTPUT_WIDTH = 32`, `o_one_hot_out` should output `00000000000000000000000000001000` on the next rising edge of `i_clk`.  \n\n### Behavioral Definition  \n- The module samples the input `i_binary_in` on the rising edge of `i_clk`.  \n- The output `o_one_hot_out` is updated on the same rising edge of `i_clk`.  \n- When `i_rstb` is asserted low, `o_one_hot_out` should asynchronously reset to all zeros.  \n\n### Constraints and Edge Cases  \n1. **Parameter Constraints**:  \n   - Ensure that `BINARY_WIDTH` and `OUTPUT_WIDTH` are set such that `OUTPUT_WIDTH` is large enough to represent all values up to `2^BINARY_WIDTH - 1`.  \n   - Ensure i_binary_in is always less than 2^BINARY_WIDTH, as determined by the BINARY_WIDTH parameter. Inputs violating this constraint are considered invalid.  \n2. **Reset Behavior**: Confirm that when `i_rstb` is asserted low, the output `o_one_hot_out` resets to all zeros.  \n\n\n## Stimulus and checker Generation\n\n1. **Reset Tests**\n   - **Asynchronous Reset**: Drive `i_rstb` low at various clock phases; confirm `o_one_hot_out` is forced to zero.  \n   - **Reset Release**: Deassert `i_rstb` and verify the output updates correctly on the next rising clock edge.\n\n2. **Exhaustive Input Coverage**\n   - **Full Range**: Cycle through all valid binary values (`0` to `2^BINARY_WIDTH - 1`) in sequential and random orders.  \n   - **Transitions**: Immediately switch between extreme values (e.g., `0 \u2194 31`) to check correct output responses.\n\n3. **Edge and Corner Cases**\n   - **Minimum & Maximum Inputs**: Specifically test `0` and `2^BINARY_WIDTH - 1`; confirm correct one-hot bit positions.  \n   - **Mid-Range**: Include representative middle values (e.g., 7, 15, 16) to ensure all bits toggle.\n\n\n## Simulation\n- Reset the dut and initialize inputs.\n- Apply the test cases sequentially.\n- Log errors if any discrepancies are found between dut outputs and the model using `$error`.\n\n## Deliverables\nProvide the complete SystemVerilog testbench code with:\n1. dut instantiation.\n2. Implement a behavioral model to replicate the expected functionality.\n3. Test scenarios validating the dut against the expected behavior.\n4. Compare the outputs from the DUT with the model using checkers\n5. Log messages indicating pass/fail status for each test case.\n---\n\n ", "context": {}}, "output": {"response": "", "context": {"verif/tb_binary_to_one_hot_decoder_sequential.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/binary_to_one_hot_decoder_sequential.v\nHASH            = 4-tb-checker\nNUM_BUGS        = 3", "src/binary_to_one_hot_decoder_sequential.v": "module binary_to_one_hot_decoder_sequential #(\n    parameter BINARY_WIDTH = 5,  // Width of binary input\n    parameter OUTPUT_WIDTH = 32 // Width of one-hot output\n)(\n    input  wire                   i_clk,          // Clock signal\n    input  wire                   i_rstb,         // Asynchronous reset, active low\n    input  wire [BINARY_WIDTH-1:0] i_binary_in,    // Binary input\n    output reg  [OUTPUT_WIDTH-1:0] o_one_hot_out   // One-hot encoded output\n);\n\n    // Internal signal to store the next one-hot value\n    reg [OUTPUT_WIDTH-1:0] one_hot_next;\n\n    // Asynchronous reset logic or one-hot decoding logic\n    always @(posedge i_clk or negedge i_rstb) begin\n        if (!i_rstb) begin\n            `ifdef BUG_0\n                // Asynchronous reset: set output to all zeros\n                o_one_hot_out <= {OUTPUT_WIDTH{1'b1}};\n            `else   \n                o_one_hot_out <= {OUTPUT_WIDTH{1'b0}};\n            `endif\n        end else begin\n            // On the rising edge of the clock, update the one-hot output\n            o_one_hot_out <= one_hot_next;\n        end\n    end\n\n    // Generate the next one-hot value combinationally\n    always @(*) begin\n        // Default: all zeros\n        `ifdef BUG_1\n            one_hot_next = {OUTPUT_WIDTH{1'b1}};\n            // Check if i_binary_in is within valid range\n            if (i_binary_in < OUTPUT_WIDTH) begin\n                // Set the corresponding bit based on i_binary_in\n                one_hot_next[i_binary_in] = 1'b1;\n            end\n        `elsif BUG_2\n            one_hot_next = {OUTPUT_WIDTH{1'b0}};\n            // Check if i_binary_in is within valid range\n            if (i_binary_in < OUTPUT_WIDTH) begin\n                // Set the corresponding bit based on i_binary_in\n                one_hot_next[i_binary_in] = 1'b0;\n            end\n        `else\n            one_hot_next = {OUTPUT_WIDTH{1'b0}};\n            // Check if i_binary_in is within valid range\n            if (i_binary_in < OUTPUT_WIDTH) begin\n                // Set the corresponding bit based on i_binary_in\n                one_hot_next[i_binary_in] = 1'b1;\n            end\n        `endif\n    end\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.v /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\""}}}
{"id": "cvdp_copilot_serial_in_parallel_out_0028", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the SystemVerilog testbench `sipo_top_tb` to integrate the functionality of the checker to test the `sipo_top` module. The testbench provided in the context already has  stimulus generator for various test cases. The purpose of the testbench checker is to verify the functionality of the `sipo_top` to ensure proper handling of data transmission, correct error detection and error correction to confirm that the computed results match the expected outputs as per the design specification.\n\n## Design Specification\nThe `sipo_top` module functions as a Serial-In Parallel-Out (SIPO) shift register with Error Correction Code (ECC) support. It performs the following operations:\n- **SIPO(shift register):**\n    - Continuously shifts data when `shift_en` is active, based on the `SHIFT_DIRECTION`.\n    - `SHIFT_DIRECTION` = 1 (Left shift).\n    - `SHIFT_DIRECTION` = 0 (Right shift).\n    - Generates a `done` signal when the shift operation is complete.\n- **One bit ECC:**\n    - Computes parity bits for ECC based on input data.\n    - Calculates the syndrome to detect errors in `received` encoded data.\n    - Corrects single-bit errors in the `received` encoded data.\n\n## Testbench Requirements\n\n**Parameter:**\n- `DATA_WIDTH:` Width of the data to be shifted and processed. The default value is 16.\n- `SHIFT_DIRECTION:` Determines the shift direction (1 for left, 0 for right). The default value is 1.\n- `CODE_WIDTH:` `DATA_WIDTH` + $clog2(`DATA_WIDTH` + 1). Encoded width of data including parity bits for error correction.\n\n**Inputs:**\n- `clk(1-bit):` Clock signal that runs at a 50:50 duty cycle. Positive edge of the `clk` controls the design.\n- `reset_n(1-bit):` Active HIGH synchronous reset. When HIGH, parallel_out will be zero.\n- `sin(1- bit):` Serial input for the SIPO block.\n- `shift_en:` Enables shifting in the SIPO block.\n- `received([CODE_WIDTH-1:0]):` Received encoded data.\n\n**Outputs:**\n- `data_out([DATA_WIDTH-1:0]):` Corrected data output from the ECC block.\n- `encoded([CODE_WIDTH-1:0]):` Encoded data output from ECC.\n- `error_detected:` Indicates if an error was detected in the received data.\n- `error_corrected:` Indicates if an error was corrected.\n\n**Internal signals for Verification**\n- `sin ([DATA_WIDTH-1:0]):` To randomize the `DATA_WIDTH` input.\n- `expected_parallel_out([DATA_WIDTH-1:0]):` Stores expected output when `SHIFT_DIRECTION` = 0.\n- `expected_parallel_out_1([DATA_WIDTH-1:0]):` Stores expected output when `SHIFT_DIRECTION` = 1.\n- `expected_data_out([DATA_WIDTH-1:0]): ` Stores expected ECC corrected data for validation.\n- `random_bit_position([31:0]):` Randomly selects a bit position for error injection to the `received` encoded data.\n- `expected_corrected_ecc([CODE_WIDTH-1:0]):` ECC word after correction.\n- `expected_error_detected:` Flag to indicate if an error was found.\n- `expected_error_position:` Position of the detected error.\n\n## Checker Requirements\n- DUT instantiation as `uut`\n- **Calculate_expected_out Task:**\n    - Compute the following based on `SHIFT_DIRECTION`\n       - `expected_parallel_out` for `SHIFT_DIRECTION` = 0\n       - `expected_parallel_out_1` for `SHIFT_DIRECTION` = 1\n- **Correct_ecc Task:**\n    - Compute the expected ECC behavior:\n        - `expected_data_out`, `expected_corrected_ecc`, `expected_error_detected`, `expected_error_position`, and `expected_error_position`, based on `received` input.\n- **Shift_serial_data_no_error Task:**\n    - Verify correctness without errors:\n        - When `SHIFT_DIRECTION` = 0 and `done` is HIGH:\n            - **Assert:** `sin` matches `expected_parallel_out`.\n        - When `SHIFT_DIRECTION` = 1 and `done` is HIGH:\n            - **Assert:** `sin` matches `expected_parallel_out`.\n        - **Assert:** `expected_parallel_out == expected_data_out` (ECC corrected)\n        - **Assert:** `encoded == received` (No error detection/correction should occur)\n            - `assert(error_detected == 0)`\n            - `assert(error_corrected == 0)`\n    - Log results (pass/fail) for each test vector.\n- **Shift_serial_data Task:**\n    - Verify correctness with errors (controlled single-bit error injection)\n        - Introduce controlled single-bit errors in `received` encoded data.\n        - When `SHIFT_DIRECTION` = 0 and `done` is HIGH:\n            - **Assert:** `sin` matches `expected_parallel_out`.\n        - When `SHIFT_DIRECTION` = 1 and `done` is HIGH:\n            - **Assert:** `sin` matches `expected_parallel_out`.\n        - **Assert:** `expected_parallel_out == expected_data_out` (ECC corrected)\n        - **Assert:** `encoded != received` (Indicates ECC correction)\n            - assert(`error_detected` = 1) (Error detected).\n            - assert(`error_corrected` = 1) (Single-bit error corrected).\n    - Log results (pass/fail) for each test vector.\n- Ensure that the checker operates on all the stimulus-generated test cases.\n\n## Deliverables\nProvide a modified SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `sipo_top` module.", "context": {"verif/tb_serial_in_parallel_out_8bit.sv": "\n`timescale 1ns/1ps\n\nmodule sipo_top_tb;\n\n    // Parameters\n    parameter DATA_WIDTH = 16;\n    parameter SHIFT_DIRECTION = 0;\n    parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1);\n\n    // Testbench signals\n    reg clk;\n    reg reset_n;\n    reg serial_in;\n    reg shift_en;\n    reg [CODE_WIDTH-1:0] received;\n    wire done;\n    wire [DATA_WIDTH-1:0] data_out;\n    wire [CODE_WIDTH-1:0] encoded;\n    wire error_detected;\n    wire error_corrected;\n\n    integer i;\n    integer random_bit_position;\n    reg [DATA_WIDTH-1:0] sin;\n\n    sipo_top #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .SHIFT_DIRECTION(SHIFT_DIRECTION),\n        .CODE_WIDTH(CODE_WIDTH)\n    ) uut_sipo_top (\n        .clk(clk),\n        .reset_n(reset_n),\n        .serial_in(serial_in),\n        .shift_en(shift_en),\n        .received(received),\n        .done(done),\n        .data_out(data_out),\n        .encoded(encoded),\n        .error_detected(error_detected),\n        .error_corrected(error_corrected)\n    );\n\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    task initialize_signals;\n        begin\n        @(posedge clk);\n            reset_n      <= 1'b0;\n            serial_in    <= 1'b0;\n            shift_en     <= 1'b0;\n            received     <= 1'b0;\n        end\n    endtask\n\n    task reset_dut;\n        begin\n            @(negedge clk);\n            reset_n <= 1'b1;\n        end\n    endtask\n\n    task shift_serial_data_no_error;\n        begin\n        @(posedge clk);\n            shift_en = 1;\n            sin = $urandom_range(DATA_WIDTH,(2**DATA_WIDTH)-1); \n            for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n                serial_in = sin[i];\n                //serial_in = $urandom_range(0, 1); \n                @(posedge clk);\n            end\n            shift_en = 0;\n            wait(uut_sipo_top.done);\n            //calculate_expected_out(sin, expected_parallel_out);\n            @(posedge clk);\n            $display(\"=================================================================================================================\");\n            $display(\"=============================================NORMAL TRANSACTION==================================================\");\n            $display(\"=================================================================================================================\");\n            $display(\"%t sin = %h,expected_parallel_out = %h, parallel_out = %h, SHIFT_DIRECTION = %h\", $time,sin,expected_parallel_out,uut_sipo_top.uut_sipo.parallel_out,SHIFT_DIRECTION);\n            received = encoded;\n            //random_bit_position = {$urandom_range(0,DATA_WIDTH)};\n            //received[random_bit_position] = ~received[random_bit_position];\n            //correct_ecc(received,expected_data_out,expected_corrected_ecc,expected_error_detected,expected_error_position);\n            $display(\"%t ACTUAL:: data_in = %h,encoded_ecc = %h,received_ecc = %h\", $time,uut_sipo_top.uut_onebit_ecc1.data_in,encoded,received);\n            $display(\"%t data_out = %h,error_detected = %b,error_corrected = %b\",$time,data_out,error_detected,error_corrected);\n            @(posedge clk);\n        end\n    endtask\n\n\n\n    \n\n    initial begin\n        initialize_signals();\n        reset_dut();\n        repeat(1000) begin\n            shift_serial_data_no_error();\n            @(posedge clk);\n\n        end\n        #3500;\n        $finish;\n    end\n\n    initial begin\n    $dumpfile(\"sipo_top_tb.vcd\");\n    $dumpvars(0,sipo_top_tb);\n    end\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_serial_in_parallel_out_8bit.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/serial_in_parallel_out_8bit.sv\nHASH            = 34e707fcc89a3069a9aeb2557c4a22308074a318\nNUM_BUGS        = 3", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/serial_in_parallel_out_8bit.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"", "src/serial_in_parallel_out_8bit.sv": "`timescale 1ns/1ps\nmodule sipo_top#(parameter DATA_WIDTH = 16,                                   // Width of the shift register\n                 parameter SHIFT_DIRECTION = 1,                               // Determines Left or right shift\n                 parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1)   // Encoded width\n                 ) (\n   \n   input clk,                                   // Clock input\n   input reset_n,                               // Reset input\n   input serial_in,                             // Serial input to SIPO\n   input shift_en,                              // Shift enable                     \n   input [CODE_WIDTH-1:0] received,             // Received encoded data \n   output done,                                 // Done signal indicating completion of shift\n   output [DATA_WIDTH-1:0] data_out,            // corrected output of ecc block\n   output [CODE_WIDTH-1:0] encoded,             // Encoded output\n   output error_detected,                       // Error detected flag\n   output error_corrected                       // Error corrected  flag\n   \n   );\n\nwire [DATA_WIDTH-1:0] parallel_out;\nwire [DATA_WIDTH-1:0] sipo_out_ecc_in;\n\nserial_in_parallel_out_8bit  #(.WIDTH(DATA_WIDTH), .SHIFT_DIRECTION(SHIFT_DIRECTION)) uut_sipo (\n        .clk           (clk),               // Clock input\n        .reset_n       (reset_n),           // Reset input\n        .sin           (serial_in),         // Serial input to SIPO\n        .shift_en      (shift_en),          // Shift enable for SIPO\n        .done          (done),              // Done signal from SIPO\n        .parallel_out  (parallel_out)       // Parallel output from SIPO\n    );\n \n//assign sipo_out_ecc_in = (done)? parallel_out: {DATA_WIDTH{1'b0}};\n\nonebit_ecc#(.DATA_WIDTH(DATA_WIDTH),.CODE_WIDTH(CODE_WIDTH)) uut_onebit_ecc1 (\n\n    .data_in(parallel_out),\n    .encoded(encoded),\n    .received(received),\n    .data_out(data_out),\n    .error_detected(error_detected),\n    .error_corrected(error_corrected)\n    );\n\nendmodule\n\nmodule serial_in_parallel_out_8bit  #(\n    parameter WIDTH = 64,               // Width of the shift register\n    parameter SHIFT_DIRECTION = 1       // Determines if shifting\n)(\n    input clk,                          // Clock signal\n    input reset_n,                      // Active low reset\n    input sin,                          // Serial input\n    input shift_en,                     // Shift enable signal\n    output reg done,                    // Done signal indicating completion of shift\n    output reg [WIDTH-1:0] parallel_out // Parallel output\n);\n    \n    localparam COUNT_WIDTH = $clog2(WIDTH); // Calculate width for shift_count\n    \n    reg [COUNT_WIDTH:0] shift_count;        // Parameterized counter to track number of shifts\n    \n   \n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin                                   \n            parallel_out     <= {WIDTH{1'b0}};                \n            done             <= 1'b0;                         \n            shift_count      <= {COUNT_WIDTH{1'b0}};          \n        end else begin\n            if (shift_en) begin\n                if (SHIFT_DIRECTION) begin\n                parallel_out    <= {parallel_out[WIDTH-2:0], sin};\n                end \n                else begin\n                `ifndef BUG_0\n                parallel_out    <= {sin, parallel_out[WIDTH-1:1]}; \n                `else\n                parallel_out    <= {sin, parallel_out[WIDTH-4:1]}; \n                `endif\n                end\n                shift_count   <= shift_count + 1;                      \n            end\n            \n            if (shift_count == (WIDTH - 1)) begin\n                done         <= 1'b1;                                 \n                shift_count  <= {COUNT_WIDTH{1'b0}};                  \n            end else begin\n                done         <= 1'b0;                                  \n            end\n        end\n    end \nendmodule\n\n\nmodule onebit_ecc #(\n    parameter DATA_WIDTH = 4,                                  // Width of the data input\n    parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1) // Encoded width\n)(\n    input [DATA_WIDTH-1:0] data_in,                     // Input data\n    output reg [CODE_WIDTH-1:0] encoded,                // Encoded output\n    input [CODE_WIDTH-1:0] received,                    // Received encoded data\n    output reg [DATA_WIDTH-1:0] data_out,               // Corrected output\n    output reg error_detected,                          // Error detected flag\n    output reg error_corrected                          // Error corrected flag\n);\n\n    localparam PARITY_BITS = CODE_WIDTH - DATA_WIDTH;   // Number of parity bits\n\n    reg [PARITY_BITS-1:0] syndrome;                     // Syndrome for error detection\n    reg [CODE_WIDTH-1:0] corrected_data;                // Corrected received data\n\n\n    integer idx_i, idx_j, idx_k;\n    integer idx_m, idx_n;\n    integer idx_p, idx_q;\n\n\n    always @(*) begin\n        encoded = 0;\n        idx_k = 0;\n\n\n        for (idx_i = 0; idx_i < CODE_WIDTH; idx_i = idx_i + 1) begin\n            if ((idx_i + 1) & (idx_i)) begin\n                encoded[idx_i] = data_in[idx_k];\n                idx_k = idx_k + 1;\n            end\n        end\n\n\n        for (idx_i = 0; idx_i < PARITY_BITS; idx_i = idx_i + 1) begin\n            encoded[(1 << idx_i) - 1] = 0; \n            for (idx_j = 0; idx_j < CODE_WIDTH; idx_j = idx_j + 1) begin\n                if (((idx_j + 1) & (1 << idx_i)) && ((idx_j + 1) != (1 << idx_i))) begin\n                    encoded[(1 << idx_i) - 1] = encoded[(1 << idx_i) - 1] ^ encoded[idx_j];\n                end\n            end\n        end\n    end\n\n\n    always @(*) begin\n        syndrome = 0; \n        for (idx_m = 0; idx_m < PARITY_BITS; idx_m = idx_m + 1) begin\n            for (idx_n = 0; idx_n < CODE_WIDTH; idx_n = idx_n + 1) begin\n                if ((idx_n + 1) & (1 << idx_m)) begin\n                    syndrome[idx_m] = syndrome[idx_m] ^ received[idx_n];\n                end\n            end\n        end\n    end\n\n  \n    always @(*) begin\n        `ifndef BUG_2\n            error_detected = |syndrome;\n        `else\n            error_detected = ~|syndrome; \n        `endif\n    end\n\n    \n    always @(*) begin\n        corrected_data = received;\n        if (error_detected) begin\n            corrected_data[syndrome - 1] = ~corrected_data[syndrome - 1]; \n        end\n    end\n\n \n    always @(*) begin\n        idx_q = 0;\n        for (idx_p = 0; idx_p < CODE_WIDTH; idx_p = idx_p + 1) begin\n            if ((idx_p + 1) & (idx_p)) begin\n                data_out[idx_q] = corrected_data[idx_p];\n                idx_q = idx_q + 1;\n            end\n        end\n    end\n\n\n    always @(*) begin\n        `ifndef BUG_1\n            error_corrected = error_detected;\n        `else\n            error_corrected = ~error_detected;\n        `endif\n    end\n\nendmodule"}}}
{"id": "cvdp_copilot_serial_in_parallel_out_0032", "categories": ["cid014", "medium"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the Serial-In Parallel-Out (sipo_top) shift register that integrates a `serial_in_parallel_out_8bit`, `onebit_ecc` and CRC Generator(`crc_generator`) . The module details and design requirements for assertion development are outlined below.\n\n## **Specifications**\n### Interface:\n**Parameter:**\n- `DATA_WIDTH`: Width of the data (default: 16).  \n- `SHIFT_DIRECTION`: Shift direction (`1` = left, `0` = right).  \n- `CODE_WIDTH`: `DATA_WIDTH + $clog2(DATA_WIDTH + 1)`.  \n- `CRC_WIDTH`: Width of the CRC (`DATA_WIDTH/2`).  \n- `POLY`: Polynomial used for CRC computation. Default is 8'b10101010\n\n### **Inputs**\n- `clk` (1-bit): Clock signal that runs at a 50:50 duty cycle. The positive edge of the clk controls the design.  \n- `reset_n` (1-bit): Active LOW asynchronous reset.  \n- `serial_in` (1-bit): Serial input data.  \n- `shift_en` (1-bit): Shift enable signal.  \n- `received ([CODE_WIDTH-1:0])`: Received encoded data.  \n- `received_crc ([CRC_WIDTH-1:0])`: Received CRC value.\n\n### **Outputs**\n- `done` (1-bit): Shift completion signal.  \n- `data_out ([DATA_WIDTH-1:0])`: ECC-corrected data output.  \n- `encoded ([CODE_WIDTH-1:0])`: ECC-encoded data.  \n- `error_detected` (1-bit): Error detection flag.  \n- `error_corrected` (1-bit): Error correction flag.  \n- `crc_out ([CRC_WIDTH-1:0])`: Generated CRC output.  \n- `crc_error` (1-bit): CRC error detected flag.\n\n## **Behavioral Requirements**\n### **1. Serial-In Parallel-Out (`serial_in_parallel_out_8bit`)**\n- Shifts data when `shift_en` is HIGH.  \n- Asserts `done` when `DATA_WIDTH` bits are received.  \n- Shifts **left** if `SHIFT_DIRECTION = 1`, **right** if `SHIFT_DIRECTION = 0`.  \n\n### **2. One-Bit ECC(`onebit_ecc`)**\n- Calculate parity bits during encoding and insert them into the appropriate positions.\n- Extract and output the corrected data.\n- Detects single-bit errors (`error_detected`).  \n- Corrects single-bit errors (`error_corrected`).  \n\n### **3. CRC Generator(`crc_generator`)**\n- Computes CRC using the given polynomial (`POLY`).\n- Updates CRC sequentially with each input bit.\n- Outputs the CRC checksum (crc_out).\n\n## **Assertion Requirements**\nTo validate the design, implement the following SystemVerilog **assertions**:\n\n1. **ECC Error Correction Validity:**  \n   - Ensure that if an error is detected, it gets corrected (`error_corrected=1`).\n\n2. **ECC Data Integrity  Check:**  \n   - Validate that `data_out` correctly reconstructs the original data_in when there is no error.\n\n3. **ECC Error-Free Behavior Check:**  \n   - Ensure that if `received` matches `encoded`, `error_detected` and `error_corrected` remain 0.\n\n4. **Left Shift Verification:**  \n   - Ensure that when shifting is enabled and `SHIFT_DIRECTION=1`, the serial input correctly propagates into `parallel_out.\n\n5. **Reset Behavior Verification:**  \n   - Ensure that when `reset_n=0`, `parallel_out`, `shift_count`, and `done` reset to 0.\n  \n6. **CRC Match Check:**  \n   - Ensure that if `crc_out` matches `received_crc`, `crc_error` is 0.\n\n7. **CRC Mismatch Detection:**  \n   - Verify that when `crc_out` mismatches `received_crc`, `crc_error` is set to 1.\n\n---\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.\n\n\n\n\n", "context": {"rtl/serial_in_parallel_out_8bit.sv": "module sipo_top#(parameter DATA_WIDTH = 16,                                   // Width of the shift register\n                 parameter SHIFT_DIRECTION = 1,                               // Determines Left or right shift\n                 parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1),  // Encoded width\n                 parameter CRC_WIDTH = ((DATA_WIDTH)/2),                      // width of the CRC output\n                 parameter POLY = 8'b10101010                                 // Polynomial for CRC\n                 ) (\n   \n   input clk,                                   // Clock input\n   input reset_n,                               // Reset input\n   input serial_in,                             // Serial input to SIPO\n   input shift_en,                              // Shift enable                     \n   input [CODE_WIDTH-1:0] received,             // Received encoded data \n   input [CRC_WIDTH-1:0] received_crc,          // Received crc data\n   output done,                                 // Done signal indicating completion of shift\n   output [DATA_WIDTH-1:0] data_out,            // corrected output of ecc block\n   output [CODE_WIDTH-1:0] encoded,             // Encoded output\n   output error_detected,                       // Error detected flag\n   output error_corrected,                      // Error corrected  flag\n   output [CRC_WIDTH-1:0] crc_out,              // CRC output\n   output crc_error                             // CRC error detected flag\n   \n   );\n\nwire [DATA_WIDTH-1:0] parallel_out;\nreg [DATA_WIDTH-1:0] crc_in;\n\nserial_in_parallel_out_8bit  #(.WIDTH(DATA_WIDTH),\n       .SHIFT_DIRECTION(SHIFT_DIRECTION)\n       ) uut_sipo (\n        .clk           (clk),               // Clock input\n        .reset_n       (reset_n),           // Reset input\n        .sin           (serial_in),         // Serial input to SIPO\n        .shift_en      (shift_en),          // Shift enable for SIPO\n        .done          (done),              // Done signal from SIPO\n        .parallel_out  (parallel_out)       // Parallel output from SIPO\n    );\n \n\nonebit_ecc#(.DATA_WIDTH(DATA_WIDTH),\n            .CODE_WIDTH(CODE_WIDTH)\n            ) uut_onebit_ecc1 (\n\n    .data_in(parallel_out),\n    .encoded(encoded),\n    .received(received),\n    .data_out(data_out),\n    .error_detected(error_detected),\n    .error_corrected(error_corrected)\n    );\n\nalways @(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n    crc_in <= {DATA_WIDTH{1'b0}};\n    end\n    else begin\n        if(done == 1'b1) begin\n            crc_in <= parallel_out;\n        end\n        else begin\n            crc_in <= {DATA_WIDTH{1'b0}};\n        end\n    end\nend\n\ncrc_generator #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .CRC_WIDTH(CRC_WIDTH),\n        .POLY(POLY)\n    ) crc_gen (\n    .data_in(crc_in),\n    .clk(clk),\n    .rst(!reset_n),\n    .crc_out(crc_out)\n           \n);\n\nassign crc_error = (crc_out == received_crc)?1'b0:1'b1;\n\nendmodule\n\nmodule serial_in_parallel_out_8bit  #(\n    parameter WIDTH = 64,               // Width of the shift register\n    parameter SHIFT_DIRECTION = 1       // Determines if shifting\n)(\n    input clk,                          // Clock signal\n    input reset_n,                      // Active low reset\n    input sin,                          // Serial input\n    input shift_en,                     // Shift enable signal\n    output reg done,                    // Done signal indicating completion of shift\n    output reg [WIDTH-1:0] parallel_out // Parallel output\n);\n    \n    localparam COUNT_WIDTH = $clog2(WIDTH); // Calculate width for shift_count\n    \n    reg [COUNT_WIDTH:0] shift_count;        // Parameterized counter to track number of shifts\n    \n   \n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin                                   \n            parallel_out     <= {WIDTH{1'b0}};                \n            done             <= 1'b0;                         \n            shift_count      <= {COUNT_WIDTH{1'b0}};          \n        end else begin\n            if (shift_en) begin\n                if (SHIFT_DIRECTION) begin\n                    parallel_out    <= {parallel_out[WIDTH-2:0], sin}; \n                end else begin\n                    parallel_out    <= {sin, parallel_out[WIDTH-1:1]}; \n                end\n                shift_count   <= shift_count + 1;                      \n            end\n            \n            if (shift_count == (WIDTH - 1)) begin\n                done         <= 1'b1;                                 \n                shift_count  <= {COUNT_WIDTH{1'b0}};                  \n            end else begin\n                done         <= 1'b0;                                  \n            end\n        end\n    end \n\nendmodule\n\nmodule onebit_ecc #(\n    parameter DATA_WIDTH = 4,                                  // Width of the data input\n    parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1) // Encoded width\n)(\n    input [DATA_WIDTH-1:0] data_in,                     // Input data\n    output reg [CODE_WIDTH-1:0] encoded,                // Encoded output\n    input [CODE_WIDTH-1:0] received,                    // Received encoded data\n    output reg [DATA_WIDTH-1:0] data_out,               // Corrected output\n    output reg error_detected,                          // Error detected flag\n    output reg error_corrected                          // Error corrected flag\n);\n\n    localparam PARITY_BITS = CODE_WIDTH - DATA_WIDTH;   // Number of parity bits\n\n    reg [PARITY_BITS-1:0] syndrome;                     // Syndrome for error detection\n    reg [CODE_WIDTH-1:0] corrected_data;                // Corrected received data\n\n\n    integer idx_i, idx_j, idx_k;\n    integer idx_m, idx_n;\n    integer idx_p, idx_q;\n\n\n    always @(*) begin\n        encoded = 0;\n        idx_k = 0;\n\n\n        for (idx_i = 0; idx_i < CODE_WIDTH; idx_i = idx_i + 1) begin\n            if ((idx_i + 1) & (idx_i)) begin\n                encoded[idx_i] = data_in[idx_k];\n                idx_k = idx_k + 1;\n            end\n        end\n\n\n        for (idx_i = 0; idx_i < PARITY_BITS; idx_i = idx_i + 1) begin\n            encoded[(1 << idx_i) - 1] = 0; \n            for (idx_j = 0; idx_j < CODE_WIDTH; idx_j = idx_j + 1) begin\n                if (((idx_j + 1) & (1 << idx_i)) && ((idx_j + 1) != (1 << idx_i))) begin\n                    encoded[(1 << idx_i) - 1] = encoded[(1 << idx_i) - 1] ^ encoded[idx_j];\n                end\n            end\n        end\n    end\n\n\n    always @(*) begin\n        syndrome = 0; \n        for (idx_m = 0; idx_m < PARITY_BITS; idx_m = idx_m + 1) begin\n            for (idx_n = 0; idx_n < CODE_WIDTH; idx_n = idx_n + 1) begin\n                if ((idx_n + 1) & (1 << idx_m)) begin\n                    syndrome[idx_m] = syndrome[idx_m] ^ received[idx_n];\n                end\n            end\n        end\n    end\n\n  \n    always @(*) begin\n        error_detected = |syndrome; \n    end\n\n    \n    always @(*) begin\n        corrected_data = received;\n        if (error_detected) begin\n            corrected_data[syndrome - 1] = ~corrected_data[syndrome - 1]; \n        end\n    end\n\n \n    always @(*) begin\n        idx_q = 0;\n        for (idx_p = 0; idx_p < CODE_WIDTH; idx_p = idx_p + 1) begin\n            if ((idx_p + 1) & (idx_p)) begin\n                data_out[idx_q] = corrected_data[idx_p];\n                idx_q = idx_q + 1;\n            end\n        end\n    end\n\n\n    always @(*) begin\n        error_corrected = error_detected; \n    end\nendmodule\n\nmodule crc_generator #(\n    parameter DATA_WIDTH = 8,        // Width of input data\n    parameter CRC_WIDTH = 4,        // Width of CRC output\n    parameter POLY = 4'b1101        // Polynomial for CRC\n) (\n    input [DATA_WIDTH-1:0] data_in, // Input data\n    input clk,                      // Clock signal\n    input rst,                      // Reset signal\n    output reg [CRC_WIDTH-1:0] crc_out // CRC output\n);\n    integer i;                     \n    reg [CRC_WIDTH-1:0] crc_reg;  \n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            crc_out <= 0;           \n        end else begin\n            crc_reg = 0;           \n            for (i = DATA_WIDTH - 1; i >= 0; i = i - 1) begin\n                if (crc_reg[CRC_WIDTH-1] ^ data_in[i]) begin\n                    crc_reg = (crc_reg << 1) ^ POLY; \n                end else begin\n                    crc_reg = crc_reg << 1; \n                end\n            end\n            crc_out <= crc_reg;    \n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/serial_in_parallel_out_8bit.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/serial_in_parallel_out_8bit.sv\nTOPLEVEL        = sipo_top\nMODULE          = test_sipo\nPYTHONPATH      = /src\nHASH            = 02c22dc1ac84dead028a8de3f1d20f9a1fcf1056s\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n\nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_sipo.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge,FallingEdge, Timer\nimport harness_library as hrs_lb\nimport random\nimport math\n\n\n@cocotb.test()\nasync def test_sipo(dut):\n    # Randomly select data width and shift direction for this test iteration\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n    SHIFT_DIRECTION = int(dut.SHIFT_DIRECTION.value)\n    CODE_WIDTH = int(dut.CODE_WIDTH.value)\n    CRC_WIDTH = int(dut.CRC_WIDTH.value)\n    POLY = int(dut.POLY.value)\n    \n\n    # Start the clock with a 10ns time period\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n\n    dut.shift_en.value = 0                          # Disable shift initially\n    dut.done.value = 0                              # Initialize the done signal to 0\n    sin_list = []   \n    sin_list_1 = []                  \n    cocotb.log.info(f\" SHIFT_DIRECTION = {SHIFT_DIRECTION}, data_wd = {DATA_WIDTH}\")\n    # Shift data_wd bits into the shift register\n    print(f\"---------------------------------------------------------------------------------------------------------------------------------------------------------\")\n    print(f\"-----------------------------------------------NORMAL OPERATION ----------------------------------------------------------------------------------------\")\n    print(f\"---------------------------------------------------------------------------------------------------------------------------------------------------------\")\n    for i in range(DATA_WIDTH):\n        sin = random.randint(0, 1)                  # Generate a random bit to shift in (0 or 1)\n        dut.shift_en.value = 1                      # Enable the shift and set the serial input bit\n        dut.serial_in.value = sin          \n        sin_list.append(sin)                        # Store the shifted bit for comparison later\n\n        parallel_out = dut.uut_sipo.parallel_out.value       # Capture parallel output\n        parallel_out_1 = int(dut.uut_sipo.parallel_out.value)  \n        # Define the formatter to control the width of different log fields\n    # For example: timestamp (15 characters), logger name (15 characters), log level (8 characters), message (50 characters)\n        #cocotb.logging.Formatter('%(parallel_out)-15s')\n\n        cocotb.log.info(f\" Shifted sin = {sin}, parallel_out = {(parallel_out)} \")\n\n\n        if i == DATA_WIDTH - 1:\n            dut.done.value = 1                      # Indicate completion after last shift\n            cocotb.log.info(f\" done :{dut.done.value}\")\n        else:\n            dut.done.value = 0                      # Done signal is low until the last shift\n            cocotb.log.info(f\" done :{dut.done.value}\")\n\n        await FallingEdge(dut.clk)                   # Wait for clock rising edge \n    #await RisingEdge(dut.clk)\n    #cocotb.log.info(f\" Shifted_sin = invalid, parallel_out = {(parallel_out)} \")\n    \n\n    if i == DATA_WIDTH - 1:\n        dut.done.value = 1\n        cocotb.log.info(f\" done :{dut.done.value}\")\n    else:\n        dut.done.value = 0\n        cocotb.log.info(f\" done :{dut.done.value}\")\n    # Wait for the final clock cycle to allow for the last shift\n    await RisingEdge(dut.clk)\n\n    # Capture the final parallel output\n    parallel_out = dut.uut_sipo.parallel_out.value\n\n    # expected behavior based on shift direction\n    if SHIFT_DIRECTION == 1:\n        # Shift left, capture parallel_out directly\n        expected_output = int(\"\".join(map(str, sin_list)), 2)\n        cocotb.log.info(f\"Shift left mode, Expected output: {expected_output}, Parallel output: {int(parallel_out)}\")\n    else:\n        # Shift right, reverse the bit order of parallel_out\n        original_parallel_out = format(int(parallel_out), f'0{DATA_WIDTH}b')  # Convert to binary string\n        reversed_parallel_out = int(original_parallel_out[::1], 2)  # Reverse the bit order\n        expected_output = int(\"\".join(map(str, sin_list[::-1])), 2)\n        cocotb.log.info(f\" Shift right mode, Expected output: {expected_output}, Reversed parallel output: {reversed_parallel_out}\")\n    \n    # Compare the parallel output with the expected output\n    \n    if SHIFT_DIRECTION == 1:\n        assert int(parallel_out) == expected_output, f\"Test failed: Expected {expected_output}, got {int(parallel_out)}\"\n    else:\n        assert reversed_parallel_out == expected_output, f\"Test failed: Expected {expected_output}, got {reversed_parallel_out}\" \n\n\n    # Final check for done signal - it should be high after the last shift\n    assert dut.done.value == 1, \"Test failed: 'done' signal was not high after the last bit shift.\"\n\n    ecc_encoded = int(dut.encoded.value)\n    dut.received.value = ecc_encoded\n    await RisingEdge(dut.clk)\n    expected_crc = compute_expected_crc(parallel_out_1, DATA_WIDTH, CRC_WIDTH, POLY)\n    dut.received_crc.value = expected_crc\n    cocotb.log.info(f\" parallel_out = {int(parallel_out)}, ecc_encoded = {ecc_encoded}, received_ecc ={int(dut.received.value)}, data_out = {int(dut.data_out.value)}, crc_in = {int(dut.crc_gen.data_in.value)} \")\n    crc_out = int(dut.crc_out.value)\n    await RisingEdge(dut.clk)\n    cocotb.log.info(f\" got_crc_out = {crc_out},received_crc = {int(dut.received_crc.value)},expected_crc = {int(expected_crc)} , crc_error = {int(crc_out != expected_crc) }\")\n    assert expected_crc == crc_out, f\" TEST FAILED:: expected_crc = {expected_crc}, got_crc = {crc_out}\"\n    assert crc_out == dut.received_crc.value, f\" TEST failed::got_crc_out = {crc_out},received_crc = {int(dut.received_crc.value)}\" \n    await RisingEdge(dut.clk)\n    print(f\"---------------------------------------------------------------------------------------------------------------------------------------------------------\")\n    print(f\"--------------------------------------------------------INJECT SINGLE BIT ERROR -------------------------------------------------------------------------\")\n    print(f\"---------------------------------------------------------------------------------------------------------------------------------------------------------\")\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n    cocotb.log.info(f\" SHIFT_DIRECTION = {SHIFT_DIRECTION}, data_wd = {DATA_WIDTH}\")\n    for i in range(DATA_WIDTH):\n        sin = random.randint(0, 1)                  # Generate a random bit to shift in (0 or 1)\n        dut.shift_en.value = 1                      # Enable the shift and set the serial input bit\n        dut.serial_in.value = sin          \n        sin_list_1.append(sin)                        # Store the shifted bit for comparison later\n\n        parallel_out = dut.uut_sipo.parallel_out.value       # Capture parallel output\n\n        # Define the formatter to control the width of different log fields\n    # For example: timestamp (15 characters), logger name (15 characters), log level (8 characters), message (50 characters)\n        #cocotb.logging.Formatter('%(parallel_out)-15s')\n\n        cocotb.log.info(f\" Shifted sin = {sin}, parallel_out = {(parallel_out)} \")\n\n\n        if i == DATA_WIDTH - 1:\n            dut.done.value = 1                      # Indicate completion after last shift\n            cocotb.log.info(f\" done :{dut.done.value}\")\n        else:\n            dut.done.value = 0                      # Done signal is low until the last shift\n            cocotb.log.info(f\" done :{dut.done.value}\")\n\n        await FallingEdge(dut.clk)                   # Wait for clock rising edge \n        parallel_out = dut.uut_sipo.parallel_out.value\n        parallel_out_1 = int(dut.uut_sipo.parallel_out.value)\n\n    if i == DATA_WIDTH - 1:\n        dut.done.value = 1\n        cocotb.log.info(f\" done :{dut.done.value}\")\n    else:\n        dut.done.value = 0\n        cocotb.log.info(f\" done :{dut.done.value}\")\n    # Wait for the final clock cycle to allow for the last shift\n    await RisingEdge(dut.clk)\n\n    # Capture the final parallel output\n    \n\n    # expected behavior based on shift direction\n    if SHIFT_DIRECTION == 1:\n        # Shift left, capture parallel_out directly\n        expected_output = int(\"\".join(map(str, sin_list_1)), 2)\n        cocotb.log.info(f\"Shift left mode, Expected output: {expected_output}, Parallel output: {int(parallel_out)}\")\n    else:\n        # Shift right, reverse the bit order of parallel_out\n        original_parallel_out = format(int(parallel_out), f'0{DATA_WIDTH}b')  # Convert to binary string\n        reversed_parallel_out = int(original_parallel_out[::1], 2)  # Reverse the bit order\n        expected_output = int(\"\".join(map(str, sin_list_1[::-1])), 2)\n        cocotb.log.info(f\" Shift right mode, Expected output: {expected_output}, Reversed parallel output: {reversed_parallel_out}\")\n    \n    # Compare the parallel output with the expected output\n\n    if SHIFT_DIRECTION == 1:\n        assert int(parallel_out) == expected_output, f\"Test failed: Expected {expected_output}, got {int(parallel_out)}\"\n    else:\n        assert reversed_parallel_out == expected_output, f\"Test failed: Expected {expected_output}, got {reversed_parallel_out}\"\n\n\n    # Final check for done signal - it should be high after the last shift\n    assert dut.done.value == 1, \"Test failed: 'done' signal was not high after the last bit shift.\"\n\n    ecc_encoded = int(dut.encoded.value)\n    ecc_encoded_1= (dut.encoded.value)\n    received_ecc = int(dut.encoded.value)\n    error_bit = random.randint(0, DATA_WIDTH + math.ceil(math.log2(DATA_WIDTH)) - 1)\n    received_ecc ^= (1 << error_bit)  # Flip the error bit\n    dut.received.value = received_ecc\n    corrected_data, corrected_ecc, error_detected, error_position = correct_ecc(received_ecc, DATA_WIDTH)\n    \n    await RisingEdge(dut.clk)\n    cocotb.log.info(f\" DUT::parallel_out = {int(parallel_out)}, ecc_encoded = {ecc_encoded_1}, received_ecc ={(dut.received.value)}, data_out = {int(dut.data_out.value)}, error_position from LSB = {error_bit}, error_corrected = {dut.error_corrected.value}, error_detected = {dut.error_detected.value},crc_in = {int(dut.crc_gen.data_in.value)} \")\n    cocotb.log.info(f\" EXPECTED:: corrected_data = {corrected_data}, corrected_ecc = {corrected_ecc}, error_detected = {int(error_detected)}, error_position from LSB = {error_position} \")\n    expected_crc = compute_expected_crc(parallel_out_1, DATA_WIDTH, CRC_WIDTH, POLY)\n    dut.received_crc.value = expected_crc\n    assert ecc_encoded == corrected_ecc, f\" TEST FAILE:: got_ecc_encoded = {ecc_encoded}, expected_corrected_ecc = {corrected_ecc} \"\n    assert error_detected == dut.error_detected.value, f\" expected_error_detected = {error_detected},got_error_detected = {dut.error_detected.value}  \"\n    if error_detected:\n        assert error_position == error_bit, f\"expected_error_detected = {error_position}, got_error_detected = {error_bit}\"\n    await RisingEdge(dut.clk)\n    cocotb.log.info(f\" got_crc_out = {int(dut.crc_out.value)},received_crc = { int(dut.received_crc.value)}, expected_crc = {int(expected_crc)}, crc_error = {int(dut.crc_error.value)} \")\n    assert expected_crc == int(dut.crc_out.value), f\" TEST FAILED:: expected_crc = {expected_crc}, got_crc = {int(dut.crc_out.value)}\"\n    assert dut.crc_out.value == dut.received_crc.value, f\" test failed:: got_crc_out = {int(dut.crc_out.value)},received_crc = { int(dut.received_crc.value)}\"\n    await RisingEdge(dut.clk)\n    print(f\"---------------------------------------------------------------------------------------------------------------------------------------------------------\")\n\ndef correct_ecc(ecc_in, data_wd):\n    parity_bits_count = math.ceil(math.log2(data_wd + 1)) + 1\n    total_bits = data_wd + parity_bits_count\n    ecc_bits = [int(bit) for bit in f\"{ecc_in:0{total_bits}b}\"[::-1]]\n\n    syndrome = 0\n    for i in range(parity_bits_count):\n        parity_pos = 2**i\n        parity_value = 0\n        for j in range(1, total_bits + 1):\n            if j & parity_pos:\n                parity_value ^= ecc_bits[j - 1]\n        syndrome |= (parity_value << i)\n\n    error_detected = syndrome != 0\n    error_position = syndrome - 1 if syndrome > 0 else -1\n\n    if error_detected and 0 <= error_position < len(ecc_bits):\n        ecc_bits[error_position] ^= 1\n\n    corrected_data_bits = [ecc_bits[i - 1] for i in range(1, total_bits + 1) if not (i & (i - 1)) == 0]\n    corrected_data = int(\"\".join(map(str, corrected_data_bits[::-1])), 2)\n    corrected_ecc = int(\"\".join(map(str, ecc_bits[::-1])), 2)\n\n    return corrected_data, corrected_ecc, error_detected, error_position\n\ndef compute_expected_crc(data, data_width, crc_width, poly):\n    crc = 0  # Initialize the CRC register\n    #print(f\" data_in = {data}, data_wd = {data_width}, crc_width = {crc_width}, poly = {poly} \")\n    for i in range(data_width - 1, -1, -1):  # Iterate through the data bits\n        msb = (crc >> (crc_width - 1)) & 1  # Get the MSB of the current CRC\n        data_bit = (data >> i) & 1  # Get the current data bit\n        \n        if msb ^ data_bit:  # If XOR of MSB and data bit is 1\n            crc = ((crc << 1) ^ poly) & ((1 << crc_width) - 1)  # XOR with POLY\n        else:\n            crc = (crc << 1) & ((1 << crc_width) - 1)  # Just shift left\n    \n    return crc  # Return the computed CRC"}}}
{"id": "cvdp_copilot_serial_in_parallel_out_0038", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the SystemVerilog testbench `sipo_top_tb` to integrate the functionality of the checker to test the `sipo_top` module. The testbench provided in the context already has stimulus generator for various test cases. The purpose of the testbench checker is to verify the functionality of the `sipo_top` to ensure proper handling of data transmission, correct error detection and error correction to confirm that the computed results match the expected outputs as per the design specification.\n\n## Design Specification\nThe `sipo_top` module functions as a Serial-In Parallel-Out (SIPO) shift register, Error Correction Code (ECC) and CRC Generation support. It performs the following operations:\n\n- **SIPO(shift register):**\n    - Continuously shifts data when shift_en is active, based on the `SHIFT_DIRECTION`.\n        - `SHIFT_DIRECTION` = 1 (Left shift).\n        - `SHIFT_DIRECTION` = 0 (Right shift).\n    - Generates a `done` signal when the shift operation is complete.\n- **One bit ECC:**\n    - Computes parity bits for ECC based on input data.\n    - Calculates the syndrome to detect errors in received encoded data.\n    - Corrects single-bit errors in the received encoded data.\n- **CRC Generator(`crc_generator`):**\n    - To compute the CRC for `data_in` using a given polynomial (`POLY`).\n## Testbench Requirements\n**Parameters:**\n\n- `DATA_WIDTH:` The width of the data is to be shifted and processed. The default value is 16.\n- `SHIFT_DIRECTION:` Determines the shift direction (1 for left, 0 for right). The default value is 1.\n- `CODE_WIDTH:` `DATA_WIDTH` + $clog2(`DATA_WIDTH` + 1). Encoded width of data including parity bits for error correction.\n- `CRC_WIDTH:` (`DATA_WIDTH`)/2.\n- `POLY:` Default vale is 8'b10101010.\n\n**Inputs:**\n\n- `clk(1-bit):` Clock signal that runs at a 50:50 duty cycle. Positive edge of the `clk` controls the design.\n- `reset_n(1-bit):` Active HIGH synchronous reset. When HIGH, parallel_out will be zero.\n- `serial_in(1- bit):` Serial input for the SIPO block.\n- `shift_en(1-bit):` Enables shifting in the SIPO block.\n- `received([CODE_WIDTH-1:0]):` Received encoded data.\n- `received_crc([CODE_WIDTH-1:0]):` Received the crc data.\n\n\n**Outputs:**\n\n- `data_out([DATA_WIDTH-1:0]):` Corrected data output from the ECC block.\n- `encoded([CODE_WIDTH-1:0]):` Encoded data output from ECC.\n- `done(1-bit):` To indicates the transaction complete.\n- `error_detected(1-bit):` Indicates if an error was detected in the received data.\n- `error_corrected(1-bit):` Indicates if an error was corrected.\n- `crc_out([CRC_WIDTH-1:0]):` CRC output for input data.\n- `crc_error(1-bit):` CRC error.\n\n**Internal signals for Verification:**\n\n- `sin ([DATA_WIDTH-1:0]):` To randomize the DATA_WIDTH input.\n- `expected_parallel_out([DATA_WIDTH-1:0]):` Stores expected output when `SHIFT_DIRECTION` = 0.\n- `expected_parallel_out_1([DATA_WIDTH-1:0]):` Stores expected output when `SHIFT_DIRECTION` = 1.\n- `expected_data_out([DATA_WIDTH-1:0]):`  Stores expected ECC corrected data for validation.\n- `random_bit_position([31:0]):` Randomly selects a bit position for error injection to the received encoded data.\n- `expected_corrected_ecc([CODE_WIDTH-1:0]):` ECC word after correction.\n- `expected_error_detected(1-bit):` Flag to indicate if an error was found.\n- `expected_error_position[31:0]:` Position of the detected error.\n- `expected_crc_out([CRC_WIDTH-1:0]):` Stores the expected_crc_out.\n- `random_bit_position_crc[31:0]:` Randomly selects a bit position for error injection to the received_crc.\n\n## Checker Requirements\n- DUT instantiation as uut.\n- **Calculate_expected_out Task:**\n    - Compute the following based on `SHIFT_DIRECTION`\n       - `expected_parallel_out` for `SHIFT_DIRECTION` = 0\n       - `expected_parallel_out_1` for `SHIFT_DIRECTION` = 1\n- **Correct_ecc Task:**\n    - Compute the expected ECC behavior\n        - `expected_data_out`, `expected_corrected_ecc`, `expected_error_detected`, and `expected_error_position`, based on `received `input.\n- **compute_expected_crc Task:**\n    - Compute the `expected_crc_out` based on  `expected_parallel_out`.\n- **Shift_serial_data_no_error Task:**\n    - Verify correctness without errors\n    - When `SHIFT_DIRECTION` = 0 and `done` is HIGH\n        - **Assert:** `sin` matches `expected_parallel_out`.\n    - When `SHIFT_DIRECTION` = 1 and `done` is HIGH\n        - **Assert:** `sin` matches `expected_parallel_out_1`.\n    - **Assert:** `data_out` == `expected_data_out` (ECC corrected)\n    - **Assert:** `encoded` == `received` (No error detection/correction should occur)\n        - assert(`error_detected` == 0)\n        - assert(`error_corrected` == 0)\n    - If `crc_out` == `received_crc`\n        - assert(`crc_error` == 0).\n    - Log results (pass/fail) for each test vector.\n- **Shift_serial_data Task:**\n    - Verify correctness with errors (controlled single-bit error injection)\n    - Introduce controlled single-bit errors in `received` encoded data in the range of 0 to (`DATA_WIDTH`)-1\n    - Introduce a single bit error in the `received_crc` data in the range of 0 to (`CRC_WIDTH`)- 1\n    - When `SHIFT_DIRECTION` = 0 and done is HIGH\n        - **Assert:** `sin` matches `expected_parallel_out`.\n    - When `SHIFT_DIRECTION` = 1 and done is HIGH\n        - **Assert:** `sin` matches `expected_parallel_out_1`.\n    - **Assert:** `data_out` == `expected_data_out` (ECC corrected)\n    - **Assert:** `encoded` != `received` (Indicates ECC correction)\n        - assert(`error_detected` = 1) (Error detected).\n        - assert(`error_corrected` = 1) (Single-bit error corrected).    \n    - If `crc_out` != `received_crc`\n        - assert(`crc_error` == 1).\n    - Log results (pass/fail) for each test vector.\n- Ensure that the checker operates on all the stimulus-generated test cases.\n## Deliverables\nProvide a modified SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `sipo_top` module.", "context": {"verif/tb_serial_in_parallel_out_8bit.sv": "`timescale 1ns/1ps\n\nmodule sipo_top_tb;\n\n    // Parameters\n    parameter DATA_WIDTH = 16;\n    parameter SHIFT_DIRECTION = 1;\n    parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1);\n    parameter CRC_WIDTH = ((DATA_WIDTH)/2);                       \n    parameter POLY = 8'b10101010;\n\n    // Testbench signals\n    reg clk;\n    reg reset_n;\n    reg serial_in;\n    reg shift_en;\n    reg [CODE_WIDTH-1:0] received;\n    reg [CRC_WIDTH-1:0] received_crc;\n    wire done;\n    wire [DATA_WIDTH-1:0] data_out;\n    wire [CODE_WIDTH-1:0] encoded;\n    wire error_detected;\n    wire error_corrected;\n    wire [CRC_WIDTH-1:0] crc_out;\n    wire crc_error;\n\n    integer i;\n    integer random_bit_position;\n    reg [DATA_WIDTH-1:0] sin;\n\n    sipo_top #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .SHIFT_DIRECTION(SHIFT_DIRECTION),\n        .CODE_WIDTH(CODE_WIDTH)\n    ) dut (\n        .clk(clk),\n        .reset_n(reset_n),\n        .serial_in(serial_in),\n        .shift_en(shift_en),\n        .received(received),\n        .done(done),\n        .data_out(data_out),\n        .encoded(encoded),\n        .error_detected(error_detected),\n        .error_corrected(error_corrected),\n        .crc_out(crc_out),\n        .received_crc(received_crc),\n        .crc_error(crc_error)\n    );\n\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    task initialize_signals;\n        begin\n        @(posedge clk);\n            reset_n      <= 1'b0;\n            serial_in    <= 1'b0;\n            shift_en     <= 1'b0;\n            received     <= 1'b0;\n            received_crc <= {CRC_WIDTH{1'b0}};\n        end\n    endtask\n\n    task reset_dut;\n        begin\n            @(negedge clk);\n            reset_n <= 1'b1;\n        end\n    endtask\n\n    task shift_serial_data;\n        begin\n        @(posedge clk);\n            shift_en = 1;\n            sin = $urandom_range(0,100); \n            for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n                serial_in = sin[i];\n                //serial_in = $urandom_range(0, 1); \n                @(posedge clk);\n            end\n            shift_en = 0;\n            wait(dut.done);\n            @(posedge clk);\n            $display(\"%t shift_en = %b,parallel_out = %h\", $time,shift_en,dut.uut_sipo.parallel_out);\n            received = encoded;\n            random_bit_position = {$urandom_range(0,DATA_WIDTH)};\n            received[random_bit_position] = ~received[random_bit_position];\n            $display(\"%t data_in = %h,encoded_ecc = %h,received_ecc = %h\", $time,dut.uut_onebit_ecc1.data_in,encoded,received);\n            received_crc = expected_crc_out;\n            @(posedge clk);\n            $display(\"%t data_out = %h\",$time,data_out);\n            $display(\"%t got_crc_out = %h,crc_error = %b\",$time,crc_out,crc_error);\n            $display(\"--------------------------------------------------------------------------------------------------------\");\n        end\n    endtask\n\n\n    \n\n    initial begin\n        initialize_signals();\n        reset_dut();\n        repeat(10) begin\n            shift_serial_data();\n            @(posedge clk);\n        end\n        #3500;\n        $finish;\n    end\n\n    initial begin\n    $dumpfile(\"sipo_top_tb.vcd\");\n    $dumpvars(0,sipo_top_tb);\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_serial_in_parallel_out_8bit.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/serial_in_parallel_out_8bit.sv\nHASH            = 4db032326bd9a2792c6dae6bbffd0fd927e9b70f\nNUM_BUGS        = 4", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/serial_in_parallel_out_8bit.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"", "src/serial_in_parallel_out_8bit.sv": "`timescale 1ns/1ps\nmodule sipo_top#(parameter DATA_WIDTH = 16,                                   // Width of the shift register\n                 parameter SHIFT_DIRECTION = 1,                               // Determines Left or right shift\n                 parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1),  // Encoded width\n                 parameter CRC_WIDTH = ((DATA_WIDTH)/2),                      // width of the CRC output\n                 parameter POLY = 8'b10101010                                 // Polynomial for CRC\n                 ) (\n   \n   input clk,                                   // Clock input\n   input reset_n,                               // Reset input\n   input serial_in,                             // Serial input to SIPO\n   input shift_en,                              // Shift enable                     \n   input [CODE_WIDTH-1:0] received,             // Received encoded data \n   input [CRC_WIDTH-1:0] received_crc,          // Received crc data\n   output done,                                 // Done signal indicating completion of shift\n   output [DATA_WIDTH-1:0] data_out,            // corrected output of ecc block\n   output [CODE_WIDTH-1:0] encoded,             // Encoded output\n   output error_detected,                       // Error detected flag\n   output error_corrected,                      // Error corrected  flag\n   output [CRC_WIDTH-1:0] crc_out,              // CRC output\n   output crc_error                             // CRC error detected flag\n   \n   );\n\nwire [DATA_WIDTH-1:0] parallel_out;\nreg [DATA_WIDTH-1:0] crc_in;\n\nserial_in_parallel_out_8bit  #(.WIDTH(DATA_WIDTH),\n       .SHIFT_DIRECTION(SHIFT_DIRECTION)\n       ) uut_sipo (\n        .clk           (clk),               // Clock input\n        .reset_n       (reset_n),           // Reset input\n        .sin           (serial_in),         // Serial input to SIPO\n        .shift_en      (shift_en),          // Shift enable for SIPO\n        .done          (done),              // Done signal from SIPO\n        .parallel_out  (parallel_out)       // Parallel output from SIPO\n    );\n \n\nonebit_ecc#(.DATA_WIDTH(DATA_WIDTH),\n            .CODE_WIDTH(CODE_WIDTH)\n            ) uut_onebit_ecc1 (\n    \n    .data_in(parallel_out),\n    .encoded(encoded),\n    .received(received),\n    .data_out(data_out),\n    .error_detected(error_detected),\n    .error_corrected(error_corrected)\n    );\n\nalways @(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n    crc_in <= {DATA_WIDTH{1'b0}};\n    end\n    else begin\n        if(done == 1'b1) begin\n            crc_in <= parallel_out;\n        end\n        else begin\n            crc_in <= {DATA_WIDTH{1'b0}};\n        end\n    end\nend\n\ncrc_generator #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .CRC_WIDTH(CRC_WIDTH),\n        .POLY(POLY)\n    ) crc_gen (\n    .data_in(crc_in),\n    .clk(clk),\n    .rst(!reset_n),\n    .crc_out(crc_out)\n           \n);\n\n`ifndef BUG_0\n    assign crc_error = (crc_out == received_crc)?1'b0:1'b1;\n`else\n    assign crc_error = (crc_out == received_crc)?1'b1:1'b0;\n`endif\n\nendmodule\n\nmodule serial_in_parallel_out_8bit  #(\n    parameter WIDTH = 64,               // Width of the shift register\n    parameter SHIFT_DIRECTION = 1       // Determines if shifting\n)(\n    input clk,                          // Clock signal\n    input reset_n,                      // Active low reset\n    input sin,                          // Serial input\n    input shift_en,                     // Shift enable signal\n    output reg done,                    // Done signal indicating completion of shift\n    output reg [WIDTH-1:0] parallel_out // Parallel output\n);\n    \n    localparam COUNT_WIDTH = $clog2(WIDTH); // Calculate width for shift_count\n    \n    reg [COUNT_WIDTH:0] shift_count;        // Parameterized counter to track number of shifts\n    \n   \n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin                                   \n            parallel_out     <= {WIDTH{1'b0}};                \n            done             <= 1'b0;                         \n            shift_count      <= {COUNT_WIDTH{1'b0}};          \n        end else begin\n            if (shift_en) begin\n                if (SHIFT_DIRECTION) begin\n                    parallel_out    <= {parallel_out[WIDTH-2:0], sin}; \n                end else begin\n                    parallel_out    <= {sin, parallel_out[WIDTH-1:1]}; \n                end\n                shift_count   <= shift_count + 1;                      \n            end\n            \n            if (shift_count == (WIDTH - 1)) begin\n                done         <= 1'b1;                                 \n                shift_count  <= {COUNT_WIDTH{1'b0}};                  \n            end else begin\n                done         <= 1'b0;                                  \n            end\n        end\n    end \nendmodule\n\n\nmodule onebit_ecc #(\n    parameter DATA_WIDTH = 4,                                  // Width of the data input\n    parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1) // Encoded width\n)(\n    input [DATA_WIDTH-1:0] data_in,                     // Input data\n    output reg [CODE_WIDTH-1:0] encoded,                // Encoded output\n    input [CODE_WIDTH-1:0] received,                    // Received encoded data\n    output reg [DATA_WIDTH-1:0] data_out,               // Corrected output\n    output reg error_detected,                          // Error detected flag\n    output reg error_corrected                          // Error corrected flag\n);\n\n    localparam PARITY_BITS = CODE_WIDTH - DATA_WIDTH;   // Number of parity bits\n\n    reg [PARITY_BITS-1:0] syndrome;                     // Syndrome for error detection\n    reg [CODE_WIDTH-1:0] corrected_data;                // Corrected received data\n\n\n    integer idx_i, idx_j, idx_k;\n    integer idx_m, idx_n;\n    integer idx_p, idx_q;\n\n\n    always @(*) begin\n        encoded = 0;\n        idx_k = 0;\n\n\n        for (idx_i = 0; idx_i < CODE_WIDTH; idx_i = idx_i + 1) begin\n            if ((idx_i + 1) & (idx_i)) begin\n                encoded[idx_i] = data_in[idx_k];\n                idx_k = idx_k + 1;\n            end\n        end\n\n\n        for (idx_i = 0; idx_i < PARITY_BITS; idx_i = idx_i + 1) begin\n            encoded[(1 << idx_i) - 1] = 0; \n            for (idx_j = 0; idx_j < CODE_WIDTH; idx_j = idx_j + 1) begin\n                if (((idx_j + 1) & (1 << idx_i)) && ((idx_j + 1) != (1 << idx_i))) begin\n                    encoded[(1 << idx_i) - 1] = encoded[(1 << idx_i) - 1] ^ encoded[idx_j];\n                end\n            end\n        end\n    end\n\n\n    always @(*) begin\n        syndrome = 0; \n        for (idx_m = 0; idx_m < PARITY_BITS; idx_m = idx_m + 1) begin\n            for (idx_n = 0; idx_n < CODE_WIDTH; idx_n = idx_n + 1) begin\n                if ((idx_n + 1) & (1 << idx_m)) begin\n                    syndrome[idx_m] = syndrome[idx_m] ^ received[idx_n];\n                end\n            end\n        end\n    end\n\n  \n    always @(*) begin\n        `ifndef BUG_2\n            error_detected = |syndrome; \n        `else\n             error_detected = ~|syndrome; \n        `endif\n    end\n\n    \n    always @(*) begin\n        corrected_data = received;\n        if (error_detected) begin\n            `ifndef BUG_3\n                corrected_data[syndrome - 1] = ~corrected_data[syndrome - 1]; \n            `else\n                corrected_data[syndrome - 1] = corrected_data[syndrome - 1];\n            `endif\n        end\n    end\n\n \n    always @(*) begin\n        idx_q = 0;\n        for (idx_p = 0; idx_p < CODE_WIDTH; idx_p = idx_p + 1) begin\n            if ((idx_p + 1) & (idx_p)) begin\n                data_out[idx_q] = corrected_data[idx_p];\n                idx_q = idx_q + 1;\n            end\n        end\n    end\n\n\n    always @(*) begin\n        `ifndef BUG_1\n            error_corrected = error_detected; \n        `else\n            error_corrected = ~error_detected;\n        `endif\n    end\nendmodule\n\nmodule crc_generator #(\n    parameter DATA_WIDTH = 8,        // Width of input data\n    parameter CRC_WIDTH = 4,        // Width of CRC output\n    parameter POLY = 4'b1101        // Polynomial for CRC\n) (\n    input [DATA_WIDTH-1:0] data_in, // Input data\n    input clk,                      // Clock signal\n    input rst,                      // Reset signal\n    output reg [CRC_WIDTH-1:0] crc_out // CRC output\n);\n    integer i;                     \n    reg [CRC_WIDTH-1:0] crc_reg;  \n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            crc_out <= 0;           \n        end else begin\n            crc_reg = 0;           \n            for (i = DATA_WIDTH - 1; i >= 0; i = i - 1) begin\n                if (crc_reg[CRC_WIDTH-1] ^ data_in[i]) begin\n                    crc_reg = (crc_reg << 1) ^ POLY; \n                end else begin\n                    crc_reg = crc_reg << 1;\n                end\n            end\n                crc_out <= crc_reg; \n        end\n    end\n\nendmodule"}}}
{"id": "cvdp_copilot_set_bit_calculator_0005", "categories": ["cid013", "easy"], "input": {"prompt": "Create a **SystemVerilog testbench checker** with detailed stimulus to test using checker and to validate the `SetBitStreamCalculator` module by applying exhaustive test scenarios and verifying the correctness of its **o_set_bit_count** output. The testbench should ensure:\n\n- Comprehensive **input stimulus** generation covering all possible cases.\n- **Checker Generation** of the set bit output.\n- **Coverage measurement** to confirm all relevant scenarios are tested.\n\n---\n## **Instantiation**\nName the instance of the RTL as `dut`.\n\n## **RTL Inputs & Outputs**\n\n### Inputs:\n- i_bit_in (1 bit): The single-bit stream input.\n- i_clk (1 bit): Clock signal for synchronization.\n- i_ready (1 bit): Synchronous signal that enables bit counting when asserted (1).\n- i_rst_n (1 bit): Active-low asynchronous reset signal.\n\n### Outputs:\n- o_set_bit_count (p_max_set_bit_count_width bits): Total count of 1 bits received in the bitstream since the last reset or i_ready assertion. If the count exceeds the maximum value (2^p_max_set_bit_count_width - 1), it saturates.\n\n## RTL Assumptions and Constraints\n1. The bit count updates only when i_ready is high and i_bit_in is sampled on the rising edge of i_clk.\n2. The count halts and retains its value when i_ready deasserts.\n3. The count resets to 0 when:\n   - i_rst_n is asserted low (asynchronous reset).\n   - i_ready asserts again after being deasserted.\n4. It saturates at this maximum value if the count exceeds 2^p_max_set_bit_count_width - 1.\n5. The 1st bit after i_ready goes high will be ignored for set bit calculation.\n\n### Behavioral Definitions\n1. When i_rst_n is low, the o_set_bit_count must asynchronously reset to 0.  \n2. On the positive edge of i_clk, if i_ready is high, o_set_bit_count increments by 1 for each i_bit_in that is 1, up to the saturation limit.  \n3. When i_ready transitions from low to high, the o_set_bit_count resets to 0.  \n\n### Parameters\n- p_max_set_bit_count_width (default = 8): The maximum bit-width of o_set_bit_count. This limits the count value to 2^p_max_set_bit_count_width - 1.\n\n## Stimulus and checker Generation\n\n1. **Power-Up & Reset**\n   - Start with all signals in default/inactive states: `i_bit_in=0, i_ready=0, i_rst_n=1`.\n   - Assert `i_rst_n` low, then deassert it; confirm `o_set_bit_count=0`.\n\n2. **Basic Counting**\n   - Transition `i_ready` from 0\u21921; ignore the first bit after this transition.\n   - Apply a sequence of `i_bit_in` (0s and 1s).\n   - Observe `o_set_bit_count` increments on every rising edge of `i_clk` for `i_bit_in=1`.\n\n3. **Deassert `i_ready` Mid-Count**\n   - While counting, set `i_ready=0`.\n   - Confirm `o_set_bit_count` stops updating.\n   - Reassert `i_ready=1` and verify the count resets to 0 (ignore the first bit again).\n\n4. **Asynchronous Reset During Counting**\n   - With `i_ready=1` and count > 0, drive `i_rst_n=0`.\n   - `o_set_bit_count` must instantly reset to 0.\n   - Deassert reset (`i_rst_n=1`) and ensure normal operation resumes.\n\n5. **Saturation Check**\n   - Use a reduced width (e.g., `p_max_set_bit_count_width=4`).\n   - Send more than 15 consecutive `1`s.\n   - Verify the count stops at 15 and remains saturated.\n\n6. **Repeated On-Off of `i_ready`**\n   - Toggle `i_ready` on/off multiple times in one run.\n   - Each time `i_ready` goes high, the counter resets and ignores the first bit.\n\n7. **Random/Stress Testing**\n   - Randomly toggle `i_bit_in` (0/1) and `i_ready`.\n   - Occasionally assert `i_rst_n` low.\n   - Check for correct count, resets, and saturation across random patterns.\n\n8. **Edge Case: Short & Quick Pulses**\n   - Drive `i_ready=1` for only a clock or two, then quickly back to 0.\n   - Use brief pulses of `i_rst_n` to confirm immediate reset response.\n\n## Simulation\n- Reset the dut and initialize inputs.\n- Apply the test cases sequentially.\n- Log errors if any discrepancies are found between dut outputs and the model using `$error`.\n\n## Deliverables\nProvide the complete SystemVerilog testbench code with:\n1. dut instantiation.\n2. Implement a behavioral model to replicate the expected functionality.\n3. Test scenarios validating the dut against the expected behavior.\n4. Compare the outputs from the DUT with the model using checkers\n5. Log messages indicating pass/fail status for each test case.\n---", "context": {}}, "output": {"response": "", "context": {"verif/tb_SetBitStreamCalculator.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/SetBitStreamCalculator.v\nHASH            = 5-tb-checker\nNUM_BUGS        = 4", "src/SetBitStreamCalculator.v": "module SetBitStreamCalculator #(\n    parameter p_max_set_bit_count_width = 8  // Maximum bit-width of the set bit counter\n)(\n    input  wire                   i_clk,             // Clock signal\n    input  wire                   i_rst_n,           // Active-low asynchronous reset\n    input  wire                   i_ready,           // Ready signal to enable counting\n    input  wire                   i_bit_in,          // Input bit stream\n    output reg  [p_max_set_bit_count_width-1:0] o_set_bit_count // Set bit count output\n);\n    `ifdef BUG_1\n        localparam MAX_COUNT = (1 << p_max_set_bit_count_width);\n    `else\n        localparam MAX_COUNT = (1 << p_max_set_bit_count_width) - 1;\n    `endif\n    reg i_ready_prev; \n\n    always @(posedge i_clk or negedge i_rst_n) begin\n        if (!i_rst_n) begin\n            `ifdef BUG_0\n                o_set_bit_count <= 1;\n                i_ready_prev    <= 1;\n            `else\n                o_set_bit_count <= 0;\n                i_ready_prev    <= 0; \n            `endif\n\n        end else begin\n            i_ready_prev <= i_ready; \n            `ifdef BUG_2\n                if (i_ready) begin\n                    o_set_bit_count <= 0;\n                end else if (i_ready && i_bit_in && (o_set_bit_count < MAX_COUNT)) begin\n                    o_set_bit_count <= o_set_bit_count + 1;\n                end\n            `elsif BUG_3\n                if (!i_ready_prev) begin\n                    o_set_bit_count <= 0;\n                end else if (i_ready && i_bit_in && (o_set_bit_count < MAX_COUNT)) begin\n                    o_set_bit_count <= o_set_bit_count + 1;\n                end\n            `elsif BUG_4\n                if (i_ready && !i_ready_prev) begin\n                    o_set_bit_count <= 0;\n                end else if (i_ready && (o_set_bit_count < MAX_COUNT)) begin\n                    o_set_bit_count <= o_set_bit_count + 1;\n                end\n            `else\n                if (i_ready && !i_ready_prev) begin\n                    o_set_bit_count <= 0;\n                end else if (i_ready && i_bit_in && (o_set_bit_count < MAX_COUNT)) begin\n                    o_set_bit_count <= o_set_bit_count + 1;\n                end\n            `endif\n        end\n    end\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.v /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\""}}}
{"id": "cvdp_copilot_signal_correlator_0017", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the SystemVerilog testbench **`tb_signal_correlator`** to add a checker that verifies the functionality of the **`signal_correlator`** module. The testbench already includes a stimulus generator for multiple test cases. The checker should compare the **`correlation_output`** against the expected correlation result based on the number of matching bits between **`input_signal`** and **`reference_signal`**, ensuring the correctness of the design. Flag any mismatches using `$display` statements.\n\n---\n\n#### Design Specifications:\n- **Inputs**:\n  - `clk`: RTL module operates based on the positive edge of this clock signal.\n  - `reset`: Async posedge Active-high reset signal initializing the outputs to zero.\n  - `input_signal[7:0]`: 8-bit signal to be correlated.\n  - `reference_signal[7:0]`: 8-bit signal used as the reference for correlation.\n  \n- **Output**:\n  - `correlation_output[3:0]`: 4-bit value representing the number of matching bits between `input_signal` and `reference_signal`.\n\n#### Functional Requirements:\n1. On reset, `correlation_output` is initialized to `4'b0000`.\n2. For each clock cycle:\n   - Matching bits between `input_signal` and `reference_signal` are calculated using a bitwise AND operation.\n   - The count of matching bits is assigned to `correlation_output` on the rising edge of the clock.\n\n---\n\n#### Testbench Checker Specification\n\n#### 1. Components\n- **Clock Signal**: Generate a clock signal (`clk`) with a **10 ns period**.\n- **Reset Signal**: Include a reset signal (`reset`) to initialize the module.\n- **Input Signal Drivers**: Provide specific test patterns for `input_signal` and `reference_signal`.\n- **Output Validation**: Monitor and validate the `correlation_output` against expected results.\n\n#### 2. Validation Logic\n- Implement a **checker function** to calculate the expected `correlation_output` for given `input_signal` and `reference_signal`.\n- Compare the module's `correlation_output` with the calculated expected value.\n\n#### 3. Test Scenarios\n- **Basic Functionality**:\n  - Test the correlation between typical input patterns, such as:\n    - `input_signal = 8'b11111111`, `reference_signal = 8'b11111111`\n      - Expected Output: `correlation_output = 4'b1000`\n    - `input_signal = 8'b11110000`, `reference_signal = 8'b11111111`\n      - Expected Output: `correlation_output = 4'b0100`\n\n- **Edge Cases**:\n  - Verify scenarios where no bits match:\n    - `input_signal = 8'b00000000`, `reference_signal = 8'b11111111`\n      - Expected Output: `correlation_output = 4'b0000`\n  - Verify single-bit matches:\n    - `input_signal = 8'b10000000`, `reference_signal = 8'b10000001`\n      - Expected Output: `correlation_output = 4'b0001`\n\n- **Reset Behavior**:\n  - Validate that `correlation_output` initializes to `4'b0000` when `reset` is asserted.\n\n- **Randomized Testing**:\n  - Generate random inputs for `input_signal` and `reference_signal` over multiple clock cycles and validate the output.\n\n#### 4. Verification Tasks\n- Create a **task** to:\n  1. Apply a specific test vector to `input_signal` and `reference_signal`.\n  2. Calculate the expected `correlation_output` using a validation function.\n  3. Compare the actual `correlation_output` with the expected result.\n  4. Log pass/fail results for each test case.\n\n#### 5. Simulation\n- The testbench checker should:\n  1. Apply the input test cases one by one.\n  2. Validate the outputs against the expected results.\n  3. Log a success or failure message for each test case.\n  4. Conclude the simulation after all test cases are verified.\n\n---\n\n#### Expected Output\n1. The checker should:\n   - Log the results for all test cases (pass/fail).\n   - Ensure that `correlation_output` is correct for all specified scenarios.\n   - Conclude the simulation once all test cases are validated.\n2. Example Log Output:\n   ```\n   Starting Simulation\n   Test Passed: Input 11110000, Reference 11111111. Output 4\n   Test Failed: Input 00000000, Reference 11111111. Expected 0, got 1\n   Simulation Complete\n   ```\n\n---\n\n#### Deliverables\nProvide a **Verilog testbench checker** implementation that:\n1. Test all specified scenarios for the `signal_correlator` module.\n2. Includes a validation function to calculate expected outputs.\n3. Logs detailed pass/fail results for all test cases.", "context": {"verif/tb.sv": "module tb_signal_correlator();\n\n    reg clk;\n    reg reset;\n    reg [7:0] input_signal;\n    reg [7:0] reference_signal;\n    wire [3:0] correlation_output;\n\n    // Instantiate the Device Under Test (DUT)\n    signal_correlator uut (\n        .clk(clk),\n        .reset(reset),\n        .input_signal(input_signal),\n        .reference_signal(reference_signal),\n        .correlation_output(correlation_output)\n    );\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk; // Generate a clock with a period of 10 ns\n    end\n\n    // Test stimulus and checkers\n    initial begin\n        // Initialize the VCD dump\n        $dumpfile(\"dump.vcd\");\n        $dumpvars(0, tb_signal_correlator);\n\n        reset = 0;\n        #10;\n\n        // Reset and initialize\n        reset = 1;\n        input_signal = 0;\n        reference_signal = 0;\n        #10; \n\n        reset = 0;\n\n        // Test Case 2: Two bits match\n        input_signal = 8'b11110000;\n        reference_signal = 8'b10101010;\n        #10; \n\n        // Test Case 3: No bits match\n        input_signal = 8'b00000000;\n        reference_signal = 8'b11111111;\n        #10; \n\n\n        // Test Case 4: Alternating bits match\n        input_signal = 8'b01010101;\n        reference_signal = 8'b10101010;\n        #10;\n\n        // Test Case 5: First four bits match\n        input_signal = 8'b11110000;\n        reference_signal = 8'b11111111;\n        #10;\n\n        // Test Case 6: Last four bits match\n        input_signal = 8'b00001111;\n        reference_signal = 8'b11111111;\n        #10;\n\n        // Test Case 7: Only one bit matches\n        input_signal = 8'b10000000;\n        reference_signal = 8'b10000001;\n        #10;\n\n        // Test Case 8: No bits match\n        input_signal = 8'b00000000;\n        reference_signal = 8'b00000000;\n        #10;\n\n        $finish; // End simulation\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/signal_correlator.sv \nHASH            = 6b6295d5eef1a0165d7f749160e1e9f4227a7f67\nNUM_BUGS        = 3\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n", "src/signal_correlator.sv": "module signal_correlator (\n    input clk,\n    input reset,\n    input [7:0] input_signal,\n    input [7:0] reference_signal,\n    output reg [3:0] correlation_output\n);\n\ninteger i;\nreg [3:0] sum;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        `ifndef BUG_0\n        correlation_output <= 0;\n        sum = 0;\n        `else\n        correlation_output <= 4'd15;\n        sum = 4'd15;\n        `endif\n    end else begin\n        sum = 0;\n\n        for (i = 0; i < 8; i = i + 1) begin\n            `ifndef BUG_1\n            sum = sum + (input_signal[i] & reference_signal[i]);\n            `else\n            sum = sum + (input_signal[i] ^ reference_signal[i]);\n            `endif\n        end\n\n        `ifndef BUG_2\n        correlation_output <= sum;\n        `else\n        correlation_output <= sum + 1;\n        `endif\n    end\nend\n\nendmodule\n"}}}
{"id": "cvdp_copilot_signed_adder_0003", "categories": ["cid012", "medium"], "input": {"prompt": "Create a stimulus generating test bench in SystemVerilog for a Verilog module named `signedadder` that add or subtract two signed 2's complement numbers, controlled by input signals and a state machine. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n \n## 1. Instantiation\n\nName the instance of the RTL as dut.\n\n## 2. DESIGN UNDER TEST (DUT)\n\nThe DUT is a **signed 2\u2019s complement adder/subtractor** with a built-in state machine. It can:\n\n- **Add** (`i_mode = 0`) or **Subtract** (`i_mode = 1`) two `DATA_WIDTH`-bit signed operands.  \n- **Detect Overflow** for signed operations.  \n- Operate in a **four-state** machine (IDLE \u2192 LOAD \u2192 COMPUTE \u2192 OUTPUT).  \n- **Parameter**: `DATA_WIDTH` (e.g., 8 bits)  \n\n### High-Level Data Flow\n\n1. **IDLE**: Waits for `i_enable` and `i_start`.  \n2. **LOAD**: Latches `i_operand_a` and `i_operand_b`.  \n3. **COMPUTE**: Performs the requested arithmetic operation.  \n4. **OUTPUT**: Updates the outputs, asserts `o_ready`, then returns to **IDLE**.\n\n---\n\n## 3. INPUT AND OUTPUT EXPLANATION\n\n### Inputs\n\n1. **`i_clk`**  \n   - **Function**: Clock for synchronous logic.  \n   - **Usage**: Triggers all state transitions.\n\n2. **`i_rst_n`** (Active-Low Reset)  \n   - **Function**: Asynchronously resets the design.  \n   - **Usage**: Forces module to **IDLE** state, clears registers, and zeroes outputs.\n\n3. **`i_start`**  \n   - **Function**: Triggers loading of operands when high (if `i_enable` is also asserted).  \n   - **Usage**: Must be pulsed high while in **IDLE** to move the state machine to **LOAD**.\n\n4. **`i_enable`**  \n   - **Function**: Global enable for the module.  \n   - **Usage**: If deasserted, the design will ignore `i_start` and revert or stay in **IDLE**.\n\n5. **`i_mode`**  \n   - **Function**: Selects the arithmetic operation.  \n   - **Usage**:  \n     - `0` \u2192 Addition (`o_resultant_sum = i_operand_a + i_operand_b`)  \n     - `1` \u2192 Subtraction (`o_resultant_sum = i_operand_a - i_operand_b`)\n\n6. **`i_clear`**  \n   - **Function**: Immediately clears outputs and resets the state machine to **IDLE**.  \n   - **Usage**: When high, forces result to 0 and moves to **IDLE**.\n\n7. **`i_operand_a`, `i_operand_b`**  \n   - **Function**: Signed 2\u2019s complement inputs.  \n   - **Usage**: Values to be added or subtracted.\n\n### Outputs\n\n1. **`o_resultant_sum`**  \n   - **Function**: Provides the computed result (in signed 2\u2019s complement).  \n   - **Usage**: Valid only in **OUTPUT** state or once `o_ready` is high.\n\n2. **`o_overflow`**  \n   - **Function**: High if a **signed overflow** is detected.  \n   - **Usage**: Check this after the **COMPUTE** cycle completes.\n\n3. **`o_ready`**  \n   - **Function**: Indicates that `o_resultant_sum` and `o_overflow` are valid.  \n   - **Usage**: High in **OUTPUT** state, then returns low in **IDLE**.\n\n4. **`o_status`** (2 bits)  \n   - **Function**: Encodes the current state of the module.  \n   - **Usage**:\n     - `00`: IDLE  \n     - `01`: LOAD  \n     - `10`: COMPUTE  \n     - `11`: OUTPUT  \n\n---\n\n## 4. BEHAVIOR EXPLANATION\n\n1. **Reset Behavior**  \n   - When `i_rst_n` is deasserted (low), internal registers and outputs are cleared, and the module returns to the **IDLE** state.  \n   - The reset is asynchronous: the design responds immediately to `i_rst_n`.\n\n2. **State Machine Flow**  \n   - **IDLE (00)**: Default/wait state. The design transitions to **LOAD** if `i_enable` and `i_start` are high.  \n   - **LOAD (01)**: Latches `i_operand_a` and `i_operand_b` into internal registers, preparing for computation.  \n   - **COMPUTE (10)**: Performs addition or subtraction based on `i_mode`. Internal overflow logic is used to set `o_overflow`.  \n   - **OUTPUT (11)**: Updates `o_resultant_sum` and `o_overflow`, asserts `o_ready`, and then goes back to **IDLE**.\n\n3. **Overflow Detection**  \n   - Triggered when the sign of the result indicates a signed overflow:  \n     - Both operands positive, result negative.  \n     - Both operands negative, result positive.  \n   - `o_overflow` goes high if either condition is met.\n\n4. **Clear Behavior**  \n   - When `i_clear` is high, the design resets outputs and returns to **IDLE** no matter the current state.\n\n---\n\n## 5. STIMULUS LIST FOR 100% COVERAGE\n\nBelow is an outline of test scenarios and input sequences to exhaustively check each design feature, state, and boundary condition. **No actual code is provided**; only the conceptual approach to drive and observe the design is described.\n\n### A. Reset and Basic State Transition Coverage\n\n1. **Asserting `i_rst_n = 0` During Operation**  \n   - **Objective**: Immediate reset to **IDLE**. \n   - **Process**:  \n     - Start in **IDLE**.  \n     - Assert `i_start` and `i_enable` to move to **LOAD**.  \n     - While in **LOAD** or **COMPUTE**, drive `i_rst_n` low.  \n     - \n2. **Using `i_clear`**  \n   - **Objective**: Immediate clear function at each state.  \n   - **Process**:  \n     - Begin in **IDLE** with `i_enable = 1`.  \n     - Assert `i_start`, capture some operands in **LOAD**.  \n     - Deassert `i_start`, go to **COMPUTE**, then drive `i_clear` high.  \n\n### B. Normal Addition Operations\n\n3. **Simple Positive Addition**  \n   - **Objective**: Correct addition for small positive numbers.  \n   - **Process**:  \n     - `i_operand_a = 5`, `i_operand_b = 10`, `i_mode = 0`, `i_start = 1`, `i_enable = 1`.  \n\n4. **Positive + Negative (No Overflow)**  \n   - **Objective**: Sign handling when operands have opposite signs.  \n   - **Process**:  \n     - `i_operand_a = 15`, `i_operand_b = -5`, `i_mode = 0`.  \n5. **Boundaries with No Overflow**  \n   - **Objective**: Approach boundary without triggering overflow.  \n   - **Process**:  \n     - For an 8-bit example: `i_operand_a = 127`, `i_operand_b = 0`, `i_mode = 0`.  \n\n### C. Overflow in Addition\n\n6. **Positive Overflow**  \n   - **Objective**: Detect overflow when adding two large positive numbers.  \n   - **Process**:  \n     - For 8-bit: `i_operand_a = 127`, `i_operand_b = 1`, `i_mode = 0`.  \n\n7. **Negative Overflow**  \n   - **Objective**: Detect overflow with large negative numbers.  \n   - **Process**:  \n     - For 8-bit: `i_operand_a = -128` (0x80), `i_operand_b = -1`, `i_mode = 0`.  \n\n### D. Subtraction Operations\n\n8. **Basic Positive Subtraction**  \n   - **Objective**: standard subtraction.  \n   - **Process**:  \n     - `i_operand_a = 20`, `i_operand_b = 5`, `i_mode = 1`.  \n\n9. **Negative Result Subtraction**  \n   - **Objective**: Check correct negative outcome.  \n   - **Process**:  \n     - `i_operand_a = 5`, `i_operand_b = 20`, `i_mode = 1`.  \n\n10. **Overflow in Subtraction**  \n    - **Objective**: Trigger overflow from subtracting.  \n    - **Process**:  \n      - For 8-bit: `i_operand_a = 127`, `i_operand_b = -1`, `i_mode = 1`.  \n\n11. **No-Operation Cases**  \n    - **Objective**:  `i_enable = 0`, no transitions occur.  \n    - **Process**:  \n      - Keep `i_enable = 0`, pulse `i_start`.\n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_signedadder.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 3-tb-stimulus\nTARGET = 99", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/signedadder.v /code/verif/tb_signedadder.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/signedadder.v": "module signedadder #(parameter DATA_WIDTH = 8)(\n    input i_clk,\n    input i_rst_n,\n    input i_start,\n    input i_enable,\n    input i_mode,\n    input i_clear,\n    input [DATA_WIDTH-1:0] i_operand_a,\n    input [DATA_WIDTH-1:0] i_operand_b,\n    output reg [DATA_WIDTH-1:0] o_resultant_sum,\n    output reg o_overflow,\n    output reg o_ready,\n    output [1:0] o_status\n);\n\n    // State encoding\n    localparam IDLE    = 2'b00;\n    localparam LOAD    = 2'b01;\n    localparam COMPUTE = 2'b10;\n    localparam OUTPUT  = 2'b11;\n\n    // Internal registers\n    reg [DATA_WIDTH-1:0] reg_operand_a;\n    reg [DATA_WIDTH-1:0] reg_operand_b;\n    reg [1:0] state;\n    reg [DATA_WIDTH-1:0] result;\n    reg signed_overflow;\n\n    assign o_status = state;\n    // Synchronous reset and state transitions\n    always @(posedge i_clk or negedge i_rst_n) begin\n        if (!i_rst_n) begin\n            state <= IDLE;\n            o_resultant_sum <= 0;\n            o_overflow <= 0;\n            o_ready <= 0;\n            reg_operand_a <= 0;\n            reg_operand_b <= 0;\n        end else begin\n            if (i_clear) begin\n                o_resultant_sum <= 0;\n                state <= IDLE;\n            end else begin\n                case (state)\n                    IDLE: begin\n                        o_ready <= 0;\n                        o_overflow <= 0;\n                        if (i_enable && i_start) begin\n                            state <= LOAD;\n                        end\n                    end\n\n                    LOAD: begin\n                        if (i_enable) begin\n                            reg_operand_a <= i_operand_a;\n                            reg_operand_b <= i_operand_b;\n                            state <= COMPUTE;\n                        end else begin\n                            state <= IDLE;\n                        end\n                    end\n\n                    COMPUTE: begin\n                        if (i_enable) begin\n                            if (i_mode == 0) begin\n                                result = reg_operand_a + reg_operand_b;\n                                signed_overflow = \n                                    (~reg_operand_a[DATA_WIDTH-1] & ~reg_operand_b[DATA_WIDTH-1] & result[DATA_WIDTH-1]) | \n                                    (reg_operand_a[DATA_WIDTH-1] & reg_operand_b[DATA_WIDTH-1] & ~result[DATA_WIDTH-1]);\n                            end else begin\n                                result = reg_operand_a - reg_operand_b;\n                                signed_overflow = \n                                    (~reg_operand_a[DATA_WIDTH-1] & reg_operand_b[DATA_WIDTH-1] & result[DATA_WIDTH-1]) | \n                                    (reg_operand_a[DATA_WIDTH-1] & ~reg_operand_b[DATA_WIDTH-1] & ~result[DATA_WIDTH-1]);\n                            end\n                            state <= OUTPUT;\n                        end else begin\n                            state <= IDLE;\n                        end\n                    end\n\n                    OUTPUT: begin\n                        if (i_enable) begin\n                            o_resultant_sum <= result;\n                            o_overflow <= signed_overflow;\n                            o_ready <= 1;\n                            state <= IDLE;\n                        end else begin\n                            state <= IDLE;\n                        end\n                    end\n                endcase\n            end\n        end\n    end\nendmodule\n"}}}
{"id": "cvdp_copilot_simple_spi_0003", "categories": ["cid012", "medium"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `spi_fsm`. The module handles data transmission in a serial format from a 16-bit input vector (`i_data_in`) using an SPI protocol. The design includes proper state transitions, signal handling, and timing synchronization to ensure accurate data transmission. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameters, Inputs - Outputs and Functional behavior**\n\n\n### Inputs\n1. **`i_clk`** (1-bit, Input):  \n   - System clock signal for synchronous operations.  \n\n2. **`i_rst_b`** (1-bit, Input):  \n   - Active-low asynchronous reset. Upon activation, the system must reset all internal states and outputs.  \n\n3. **`i_data_in`** (16-bit, Input):  \n   - Input data vector to be serialized and transmitted through the SPI bus.  \n\n4. **`i_enable`** (1-bit, Input):  \n   - Control signal to enable or disable the block.  \n     - High (`1`): The block operates normally, and data transmission occurs.  \n     - Low (`0`): The block resets to the idle state, disabling transmission.  \n\n5. **`i_fault`** (1-bit, Input):  \n   - Indicates a fault condition. If asserted, the FSM transitions to an error state, halts all activity, and drives outputs to safe defaults.  \n\n6. **`i_clear`** (1-bit, Input):  \n   - Forces the FSM to immediately clear the current transaction, clear counters, and transition to the idle state.  \n\n---\n\n### Outputs\n1. **`o_spi_cs_b`** (1-bit, Output):  \n   - Active-low SPI chip select signal to indicate the start and end of a transmission. Default is logic high when idle.  \n\n2. **`o_spi_clk`** (1-bit, Output):  \n   - SPI clock signal for synchronizing data transfers. The clock signal toggles during transmission. Default is logic low when idle or disabled.  \n\n3. **`o_spi_data`** (1-bit, Output):  \n   - Serialized SPI data output derived from the `i_data_in` input vector. Default is logic low when idle or disabled.  \n\n4. **`o_bits_left`** (5-bit, Output):  \n   - Tracks the number of bits remaining to be transmitted during the SPI session. Default is `0x10` (all bits remaining).  \n\n5. **`o_done`** (1-bit, Output):  \n   - Pulses high for exactly one clock cycle when a transaction is successfully completed or the FSM transitions to an error state.  \n\n6. **`o_fsm_state`** (2-bit, Output):  \n   - Reflects the internal FSM state for external monitoring:  \n     - `00` = Idle  \n     - `01` = Transmit  \n     - `10` = Clock Toggle  \n     - `11` = Error \n\n---\n\n### Behavioral Requirements\n\n1. **FSM States**:  \n   - **Idle** (`00`): Initialize SPI signals (`o_spi_cs_b = 1`, `o_spi_clk = 0`) and wait for `i_enable = 1` to begin transmission.  \n   - **Transmit** (`01`): Activate SPI signals (`o_spi_cs_b = 0`), load the MSB of `i_data_in` into `o_spi_data`, and start shifting the bits out sequentially.  \n   - **Clock Toggle** (`10`): Toggle `o_spi_clk` to latch `o_spi_data` externally, decrement `o_bits_left`, and determine if more bits remain to be transmitted. If all bits are sent, assert `o_done` and transition to Idle.  \n   - **Error** (`11`): Entered upon assertion of `i_fault`. All SPI outputs are driven to safe values (`o_spi_cs_b = 1`, `o_spi_clk = 0`, `o_spi_data = 0`,`o_done`=0,`o_bits_left=10`), and the FSM remains here until cleared or reset.  \n\n2. **Control Signals**:  \n   - **Enable (`i_enable`)**:  \n     - If asserted (`1`): FSM proceeds through normal transmission states (`Transmit` and `Clock Toggle`).  \n     - If deasserted (`0`): FSM immediately transitions to Idle and resets all active outputs.  \n   - **Clear (`i_clear`)**:  \n     - When asserted, FSM immediately transitions to Idle, resetting all counters and outputs regardless of the current state.  \n\n3. **Done Signal (`o_done`)**:  \n   - Asserted (high) for one clock cycle upon successful completion of transmission.\n\n4. **FSM State Output (`o_fsm_state`)**:  \n   - Reflects the current FSM state in real-time for external monitoring.  \n\n## Test Bench Requirements\n\n### Stimulus Generation\n\n**1. Reset and Initialization**\n- Apply the reset is applied.\n\n**2. Normal SPI Transmission**\n- Enable the FSM and provide a valid data input to initiate a transmission. \n- Introduce multiple consecutive transmissions without disabling the FSM to check if data is continuously processed as expected.\n- Attempt to modify the input data while transmission is ongoing to ensure that changes do not interfere with the current operation.\n\n**3. Control Signal Handling**\n- Disable the FSM while a transmission is in progress.\n- Force the FSM to clear its current operation while actively transmitting to confirm that it returns to idle without completing the remaining shifts.\n\n**4. Error Handling**\n- Introduce an error condition during transmission.\n- Attempt to recover from the error by applying a reset-like condition.\n\n**5. Clock and Edge Case Behavior**\n- Make the FSM to properly toggle the SPI clock signal during transmission, synchronizing data shifts.\n- Test the handling of extreme data values, including cases where only a single bit is set.\n- Execute back-to-back transmissions with varying data patterns.", "context": {}}, "output": {"response": "", "context": {"verif/tb_spi_fsm.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 3-tb-stimulus\nTARGET = 94", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/spi_fsm.v /code/verif/tb_spi_fsm.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/spi_fsm.v": "module spi_fsm (\n    input  wire         i_clk,       // System clock\n    input  wire         i_rst_b,     // Active-low async reset\n    input  wire [15:0]  i_data_in,   // Parallel 16-bit data to transmit\n    input  wire         i_enable,    // Enable block\n    input  wire         i_fault,     // Fault indicator\n    input  wire         i_clear,     // Forces FSM to clear/idle\n    \n    output reg          o_spi_cs_b,  // SPI chip select (active-low)\n    output reg          o_spi_clk,   // SPI clock\n    output reg          o_spi_data,  // Serialized SPI data out\n    output reg [4:0]    o_bits_left, // Bits left to transmit\n    output reg          o_done,      // Single-cycle pulse when done or error\n    output reg [1:0]    o_fsm_state  // FSM state for external monitoring\n);\n    \n    //--------------------------------------------------------------------------\n    // Parameter Definitions\n    //--------------------------------------------------------------------------\n    localparam [1:0] ST_IDLE         = 2'b00,  // Idle state\n                     ST_TRANSMIT     = 2'b01,  // Load/shift bits out\n                     ST_CLOCK_TOGGLE = 2'b10,  // Toggle clock & shift data\n                     ST_ERROR        = 2'b11;  // Fault state\n    \n    //--------------------------------------------------------------------------\n    // Internal Signals\n    //--------------------------------------------------------------------------\n    reg [1:0]  curr_state, next_state;\n    reg [15:0] shift_reg;        // Holds data to be shifted out\n    reg [4:0]  next_bits_left;\n    reg        next_done;\n    \n    //--------------------------------------------------------------------------\n    // Synchronous State & Data Registers\n    //--------------------------------------------------------------------------\n    always @(posedge i_clk or negedge i_rst_b) begin\n        if (!i_rst_b) begin\n            curr_state   <= ST_IDLE;\n            shift_reg    <= 16'd0;\n            o_bits_left  <= 5'h10;\n            o_done       <= 1'b0;\n        end\n        else begin\n            // Update FSM state\n            curr_state   <= next_state;\n            \n            // Update shift register (only in states that shift data)\n            if (curr_state == ST_TRANSMIT ) begin\n                shift_reg <= { shift_reg[14:0], 1'b0 }; // shift left\n                o_bits_left <= next_bits_left;\n            end\n            else if ((curr_state==ST_IDLE) && i_enable) begin\n                shift_reg <= i_data_in;\n            end\n            // else if(curr_state == ST_CLOCK_TOGGLE) begin\n                \n            // end\n                        \n            \n            // Update 'done' (one-cycle pulse)\n            o_done      <= next_done;\n        end\n    end\n    \n    //--------------------------------------------------------------------------\n    // Next-State and output Logic (Combinational)\n    //--------------------------------------------------------------------------\n    always @(*) begin\n        \n        if(!i_rst_b) begin\n            o_spi_cs_b     = 1'b1;       // Default de-asserted (active-low)\n            o_spi_clk      = 1'b0;       // Default clock low when idle\n            o_spi_data     = 1'b0;       // Default data low when idle\n            o_fsm_state    = ST_IDLE;\n            next_state     = ST_IDLE;\n            next_bits_left  = 5'h10;\n            next_done       = 1'b0;\n        end\n        else begin\n            // If either clear or !enable is active, force IDLE\n            if (!i_enable) begin\n                o_spi_cs_b     = 1'b1;       // Default de-asserted (active-low)\n                o_spi_clk      = 1'b0;       // Default clock low when idle\n                o_spi_data     = 1'b0;       // Default data low when idle\n                o_fsm_state    = ST_IDLE;\n                next_state      = ST_IDLE;\n                next_bits_left  = 5'h10;     // Reset bits_left to full (16 bits => 0x10; 0x10 can be a placeholder)\n                next_done       = 1'b0;\n            end\n            // If fault is asserted, go to ERROR\n            else if (i_fault) begin\n                o_spi_cs_b     = 1'b1;       // Default de-asserted (active-low)\n                o_spi_clk      = 1'b0;       // Default clock low when idle\n                o_spi_data     = 1'b0;       // Default data low when idle\n                next_state      = ST_ERROR;\n                next_done       = 1'b0;\n                o_fsm_state = ST_ERROR;\n                next_bits_left  = 5'h10;     // Reset bits_left to full (16 bits => 0x10; 0x10 can be a placeholder)\n                // Remain in ERROR until i_clear\n                if (i_clear) begin\n                    next_state     = ST_IDLE;\n                    o_fsm_state    = ST_IDLE; // Reflect the current FSM state\n                        \n                end\n                else begin\n                    next_state     = ST_ERROR;\n                    o_fsm_state = ST_ERROR;\n                end\n            end\n            else begin\n                case (curr_state)\n                    //--------------------------------------------------------------\n                    // IDLE State\n                    //--------------------------------------------------------------\n                    ST_IDLE: begin\n                        o_spi_cs_b     = 1'b1;       // Default de-asserted (active-low)\n                        o_spi_clk      = 1'b0;       // Default clock low when idle\n                        o_spi_data     = 1'b0;       // Default data low when idle\n                        o_fsm_state    = ST_IDLE; // Reflect the current FSM state\n                        if (i_enable && !i_fault && !i_clear) begin\n                            // Move to TRANSMIT to load the shift register\n                            next_state     = ST_TRANSMIT;\n                            next_done      = 1'b0;\n                            next_bits_left = 5'd16;  // 16 bits to send\n                        end\n                        else begin\n                            next_state     = ST_IDLE;\n                            next_bits_left = 5'h10;\n                            next_done      = 1'b0;\n                        end\n                    end\n                    \n                    //--------------------------------------------------------------\n                    // TRANSMIT State\n                    //--------------------------------------------------------------\n                    ST_TRANSMIT: begin\n                        o_spi_cs_b  = 1'b0;\n                        o_spi_clk   = 1'b0;\n                        o_spi_data  = shift_reg[15];\n                        o_fsm_state = ST_TRANSMIT;\n                        // Immediately move to CLOCK_TOGGLE to begin shifting\n                        next_done       = 1'b0;\n                        next_bits_left  = o_bits_left;\n                        next_state      = ST_CLOCK_TOGGLE;\n                        // Decrement bits_left after shifting out\n                        next_bits_left = (o_bits_left == 5'd0)\n                                        ? 5'd0\n                                        : o_bits_left - 5'b1;\n                    end\n                    \n                    //--------------------------------------------------------------\n                    // CLOCK TOGGLE State\n                    //--------------------------------------------------------------\n                    ST_CLOCK_TOGGLE: begin\n                        o_spi_cs_b  = 1'b0;\n                        o_spi_clk   = 1'b1;\n                        o_spi_data  = shift_reg[15];\n                        o_fsm_state = ST_CLOCK_TOGGLE;\n                        \n                        \n                        // If all bits have been shifted out, return to IDLE\n                        // and pulse `o_done` for one clock.\n                        if (o_bits_left == 5'd1) begin\n                            // This was the last bit\n                            next_state = ST_IDLE;\n                            next_done  = 1'b1;\n                        end\n                        else begin\n                            // Go back to TRANSMIT to shift out next bit\n                            next_done       = 1'b0;\n                            next_state      = ST_TRANSMIT;\n                        end\n                    end\n                    \n                    //--------------------------------------------------------------\n                    // ERROR State\n                    //--------------------------------------------------------------\n                    ST_ERROR: begin\n                        // Remain in ERROR until i_clear\n                        o_spi_cs_b  = 1'b1;\n                        o_spi_clk   = 1'b0;\n                        o_spi_data  = 1'b0;\n                        o_fsm_state = ST_ERROR;\n                        next_done       = 1'b0; \n                        next_bits_left  = 5'h10;     // Reset bits_left to full (16 bits => 0x10; 0x10 can be a placeholder)\n                        if (i_clear) begin\n                            next_state     = ST_IDLE;\n                        end\n                        else begin\n                            next_state     = ST_ERROR;\n                        end\n                    end\n                    \n                    default: begin\n                        // Should never happen; default to IDLE\n                        next_state = ST_IDLE;\n                    end\n                endcase\n            end\n        end\n    end\n    \nendmodule\n"}}}
{"id": "cvdp_copilot_single_cycle_arbiter_0004", "categories": ["cid012", "medium"], "input": {"prompt": "Create a **testbench** to apply **stimulus** to the `single_cycle_arbiter` module. This module implements a **fixed-priority, single-cycle arbitration** mechanism that grants exactly one request per cycle based on a priority scheme where **Port 0 has the highest priority** and **Port N-1 has the lowest priority**. The testbench must validate arbitration logic and priority enforcement and ensure proper handling of various request patterns, including edge cases.\n\n---\n\n### **Inputs:**\n\n- `clk`: **Clock signal with a 10ns period.**\n- `reset`: **Active-high reset signal.**\n- `req_i`: **Request signal, `N`-bit wide, where each bit represents a request from a different source.**\n\n### **Outputs:**\n\n- `gnt_o`: **Grant signal, `N`-bit wide, indicating which request has been granted.**\n\n---\n\n### **Instantiation**\n\nThe testbench must instantiate a single instance of the `single_cycle_arbiter` module:\n\n- **Primary Arbiter Module (`uut`)**: Instantiated with `N=8` to test typical request/grant scenarios.\n\n---\n\n### **Testbench Requirements**\n\nThe testbench must apply a **wide range of test patterns** covering various arbitration conditions:\n\n1. **Clock Generation:**\n   - `clk` must toggle every **5 time units**, ensuring a **10 ns clock period**.\n\n2. **Reset Handling:**\n   - `reset` must be **asserted for multiple cycles** before deasserting.\n   - The module must correctly initialize its outputs upon reset.\n\n3. **Stimulus Generation Strategy:**\n   - The testbench **must not verify outputs** (only generate inputs).\n   - The following test sequences must be executed:\n     - **No Requests**: Ensure `gnt_o` remains inactive.\n     - **Single Request Activation**: Apply requests to individual ports one at a time.\n     - **Simultaneous Requests**: Apply multiple requests and observe prioritization.\n     - **Sequential Requests**: Shift requests sequentially over cycles to verify shifting behavior.\n     - **Randomized Testing**: Generate **50 iterations** of randomized request patterns.\n     - **Edge Cases**:\n       - **Simultaneous Multiple-Level Requests**: Activate requests at non-adjacent positions (e.g., `8'b11000110`).\n       - **Even-Indexed Requests Active**: Ensure correct arbitration for `8'b10101010`.\n       - **Odd-Indexed Requests Active**: Ensure correct arbitration for `8'b01010101`.\n       - **Alternating Request Patterns**: Exercise `8'b10011001`.\n       - **Back-to-Back Requests Across Cycles**: Apply requests in consecutive cycles while ensuring arbitration propagates.\n     - **Mid-Run Reset Handling**:\n       - Apply reset **during an ongoing arbitration sequence**.\n       - Apply new requests after reset to verify proper reinitialization.\n\n4. **Handling Continuous and Edge Cases:**\n   - The testbench must ensure arbitration operates **correctly across all request patterns**.\n   - **High-frequency toggling** of requests must be exercised.\n\n5. **Waveform Generation:**\n   - The testbench must generate a `.vcd` waveform file to allow waveform analysis.\n\n---\n\n### **Coverage and Compliance**\n\n- The testbench must ensure **high coverage** across all possible arbitration conditions.\n- The **DUT instance name `uut` must be explicitly used** for instantiation.\n\n---\n\n### **Test Plan Overview**\n\nThe testbench must ensure **96%+ input stimulus coverage** by applying:\n\n- **Request arbitration testing** across different scenarios.\n- **Edge case handling** for alternating and simultaneous requests.\n- **Randomized input variations** to ensure robustness.\n- **Pipeline behavior verification** to confirm proper priority enforcement.\n- **Handling of multiple active requests** to validate correct grant selection.\n\nThis testbench will provide a **comprehensive input stimulus environment** for `single_cycle_arbiter`, ensuring correct operation under various test conditions.\n\n---\n\n### **Note:**\n- The testbench **must only generate stimulus** without verifying outputs.\n- The **DUT instance name `uut` must be explicitly used** for instantiation.\n- **Ensure the maximum possible input coverage** without adding assertions or comparisons.\n\nCan you implement a **SystemVerilog testbench** with the above stimulus requirements?", "context": {}}, "output": {"response": "", "context": {"verif/tb_single_cycle_arbiter.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 4-tb-stimulus-generation\nTARGET = 96", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/single_cycle_arbiter.sv": "module single_cycle_arbiter #(\n  parameter N = 32\n) (\n  input   logic          clk,\n  input   logic          reset,\n  input   logic [N-1:0]  req_i,\n  output  logic [N-1:0]  gnt_o\n);\n\n  // --------------------------------------------------------\n  // Internal wire and regs\n  // --------------------------------------------------------\n  logic [N-1:0] priority_req;\n\n  // --------------------------------------------------------\n  // Arbitration logic\n  // --------------------------------------------------------\n  assign priority_req[0] = 1'b0;\n  if (N > 1) begin : PR_GEN\n    for (genvar i = 0; i < N-1; i++) begin\n      // Port[0] highest priority\n      assign priority_req[i+1] = priority_req[i] | req_i[i];\n    end\n  end\n\n  // -------------------------------------------------------\n  // Output assignments\n  // --------------------------------------------------------\n  assign gnt_o[N-1:0] = req_i[N-1:0] & ~priority_req[N-1:0];\n\nendmodule\n"}}}
{"id": "cvdp_copilot_skid_register_0004", "categories": ["cid012", "medium"], "input": {"prompt": "Create a **testbench** to apply **stimulus** to the `skid_register` module. This module serves as a pipeline register with a skid buffer to handle backpressure. The testbench must simulate various scenarios to verify data flow, handshake mechanisms, and buffer operations.\n\n---\n\n### **Inputs:**\n\n- `clk`: **1-bit clock signal**, toggling every **5 time units** (100MHz operation).\n- `rst`: **Active-high reset signal** to initialize the module.\n- `up_bus`: **8-bit data input from upstream**.\n- `up_val`: **Valid signal from upstream indicating data presence**.\n- `dn_rdy`: **Ready signal from downstream indicating it can accept data**.\n\n### **Outputs:**\n\n- `up_rdy`: **Ready signal from the module for upstream communication**.\n- `dn_bus`: **8-bit data output to the downstream**.\n- `dn_val`: **Valid signal for downstream data**.\n\n---\n\n### **Instantiation**\n\nThe testbench must instantiate a single instance of the `skid_register` module:\n\n- **Skid Register Module (`dut`)**: Instantiated with its default configuration to verify data buffering and pipeline behavior.\n\n---\n\n### **Testbench Requirements**\n\nThe testbench must apply a **wide range of test patterns** covering various operating conditions of the `skid_register` module:\n\n1. **Clock Generation:**\n   - `clk` must toggle every **5 time units**, ensuring a **10 ns clock period**.\n\n2. **Reset Handling:**\n   - `rst` must be **asserted at the beginning** of the simulation for **three cycles**.\n   - The module must correctly initialize internal registers when `rst` is de-asserted.\n\n3. **Stimulus Generation Strategy:**\n   - The testbench **must not verify outputs** (only generate inputs).\n   - The following test sequences must be executed:\n     - **No Backpressure (50 cycles)**: `dn_rdy` asserted while `up_val` and `up_bus` receive random values.\n     - **Full Backpressure (20 cycles)**: `dn_rdy` de-asserted to stall downstream data flow.\n     - **Random Backpressure (100 cycles)**: `dn_rdy` toggles randomly while `up_val` sends variable data.\n     - **Pipeline Flush (20 cycles)**: Ensure buffered data is correctly forwarded when `dn_rdy` remains asserted.\n     - **Multiple Data Transactions**: Apply various input patterns to check how the module buffers and forwards data.\n     - **Randomized Data Sequences**: Generate multiple upstream and downstream handshake variations.\n     - **Continuous Streaming Mode**: Test without stalls to check smooth data flow.\n     - **Pipeline Stall and Restart**: Temporarily hold `dn_rdy` low and later assert it to observe how the module resumes.\n     - **Edge Case Timing Conditions**: Stress test with fast-changing `up_val` and `dn_rdy` transitions.\n\n4. **Handling Continuous and Edge Cases:**\n   - The testbench must ensure a **full range of data transactions** occur correctly.\n   - **Edge cases of data buffering** must be exercised to verify stall and release conditions.\n\n5. **Waveform Generation:**\n   - The testbench must generate a `.vcd` waveform file to allow waveform analysis.\n\n---\n\n### **Coverage and Compliance**\n\n- The testbench must ensure **high coverage** across all pipeline behaviors and backpressure conditions.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n\n---\n\n### **Test Plan Overview**\n\nThe testbench must ensure **comprehensive RTL coverage** by applying:\n\n- **Valid data transfers** under continuous downstream availability.\n- **Stall conditions** when downstream is blocked.\n- **Randomized test scenarios** for data and handshake signals.\n- **Buffer management validation** under varied input sequences.\n- **Reset handling** to verify asynchronous initialization integrity.\n- **High-frequency toggling of control signals** to test robustness.\n- **Back-to-back input bursts and sporadic handshakes** to assess real-world performance.\n\nThis testbench should provide a **comprehensive input stimulus environment** for `skid_register`, ensuring correct operation under various test conditions.\n\n---\n\n### **Note:**\n- The testbench **must only generate stimulus** without verifying outputs.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n- **Ensure the maximum possible input coverage** without adding assertions or comparisons.\n\nCan you implement a **SystemVerilog testbench** with the above stimulus requirements?", "context": {}}, "output": {"response": "", "context": {"verif/tb_skid_register.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 4-test-stimulus-generation-for-skid_register\nTARGET = 98 ", "src/coverage.cmd": "report -metrics overall -out coverage.log\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/skid_register.sv": "module skid_register\n  #(parameter DATA_WIDTH = 32)\n(\n    input  wire                     clk,\n    input  wire                     rst,\n\n    // Upstream (source) side\n    input  wire [DATA_WIDTH-1:0]    up_bus,\n    input  wire                     up_val,\n    output reg                      up_rdy,\n\n    // Downstream (sink) side\n    output reg  [DATA_WIDTH-1:0]    dn_bus,\n    output reg                      dn_val,\n    input  wire                     dn_rdy\n);\n\n    // Internal regs/wires\n    reg  [DATA_WIDTH-1:0]   skid_bus;   // Skid\u2010buffered data\n    reg                     skid_val;   // True if skid_bus holds valid data\n    wire                    dn_active;  // True if we can move data into dn_bus\n    wire                    dn_val_i;   // The \"next\" valid going into dn_val\n    wire [DATA_WIDTH-1:0]   dn_bus_i;   // The \"next\" data going into dn_bus\n\n    // Downstream \"active\" logic\n    assign dn_active = ~dn_val | dn_rdy;\n\n    // Upstream ready logic\n    always @(posedge clk) begin\n        if (rst) begin\n            up_rdy <= 1'b1; \n        end\n        else begin\n            up_rdy <= dn_active;\n        end\n    end\n\n    // Skid\u2010bus and skid\u2010val tracking\n    always @(posedge clk) begin\n        if (rst) begin\n            skid_val <= 1'b0;\n        end \n        else begin\n            skid_val <= dn_val_i & ~dn_active;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            skid_bus <= {DATA_WIDTH{1'b0}};\n        end \n        else if (~dn_active & dn_val_i) begin\n            skid_bus <= dn_bus_i;\n        end\n    end\n\n    // Mux logic: direct or skid\u2010buffered\n    assign dn_bus_i = up_rdy ? up_bus : skid_bus;\n    assign dn_val_i = up_rdy ? up_val : skid_val;\n\n    // Downstream valid/data\n    always @(posedge clk) begin\n        if (rst) begin\n            dn_val <= 1'b0;\n        end\n        else if (dn_active) begin\n            dn_val <= dn_val_i;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dn_bus <= {DATA_WIDTH{1'b0}};\n        end\n        else if (dn_active) begin\n            dn_bus <= dn_bus_i;\n        end\n    end\n\nendmodule\n"}}}
{"id": "cvdp_copilot_sobel_filter_0015", "categories": ["cid012", "easy"], "input": {"prompt": "Write a SystemVerilog testbench for a Sobel filter module named `sobel_filter` that performs edge detection on a stream of pixel data. The Sobel filter calculates the gradient magnitude using a 3x3 pixel window and determines whether the edge strength exceeds a predefined threshold `THRESHOLD`. The testbench should only provide stimuli for the design across various input scenarios, including edge cases, and ensure proper synchronization of different input signals.\n\n#### Inputs:\n- `clk`: Clock signal for synchronization. The design is synchronized to the positive edge of this clock.\n- `rst_n`: Active-low asynchronous reset. Clears internal buffers, counters, and outputs.\n- `pixel_in [7:0]`: 8-bit input pixel data.\n- `valid_in`: An active-high signal that indicates the validity of the `pixel_in` data.\n\n#### Outputs:\n- `edge_out [7:0]`: 8-bit output indicating the presence of an edge (255 for an edge, 0 otherwise).\n- `valid_out`: An active-high signal that indicates when `edge_out` is valid.\n\n### Overview of the Design:\n\nThe Sobel filter detects edges in an image by first computing the gradients in the horizontal (`Gx`) and vertical (`Gy`) directions, then calculating the gradient magnitude (`|Gx| + |Gy|`) and comparing it to a threshold to determine whether a pixel is part of an edge. The `THRESHOLD` is set to a default value of 128, which defines the threshold for edge detection. Pixels with gradient magnitudes greater than this value are classified as edges.  \n\nA 3x3 window of pixels is sent as a continuous stream of inputs through `pixel_in`, and `valid_in` remains high while pixels are supplied. The module uses a 3x3 buffer to store pixel data, ensuring it only outputs valid results (`valid_out` and `edge_out`) once the buffer is fully populated with 9 pixels. Pixels are shifted sequentially to store new incoming pixels. (The input is sent row by row, left to right. Starting from the top row, the traversal proceeds to the bottom row.) The filter performs convolution when the buffer is fully populated and outputs the result. After processing each window, the module clears the buffer and waits for the next set of 9 pixels. The buffer is also cleared when reset is asserted. Assume that the handling of overlapping windows is handled externally, and this design processes each window as a new one (no storing of pixels from the previous window).\n\n---\n\n### Testbench Requirements:\n\n#### Module Instantiation:\n- The Sobel filter module should be instantiated as `dut`, with all input and output signals properly connected. The testbench must cover all possible input scenarios to achieve 100% coverage. \n\n#### Input Stimulus Generation:\n1. **Pixel Stream Generation:**\n   - The testbench should generate a stream of 8-bit pixel values (`pixel_in`) and assert `valid_in` when pixel data is valid.\n   - Include edge cases like:\n     - Uniform pixel values (all zeros, all maximum values).\n     - Pixel gradients (e.g., increasing or decreasing values across the 3x3 window).\n     - Random pixel values to simulate real-world scenarios.\n2. **Synchronization:**\n   - The RTL design maintains a continuous stream of valid pixels by monitoring the assertion of `valid_in`. When `valid_in` remains consistently asserted after a full window is completed, the module resets the count and begins loading a new set of pixels. Therefore, the test case must be designed to reset `valid_in` after loading a 3\u00d73 block of pixels and also to continuously assert `valid_in` for multiple input windows. Additionally, it should be capable of resetting `valid_in` mid-stream to cover all possible scenarios.\n3. Reset Testing:\n- Set the reset (`rst_n`) to clear all internal states (e.g., pixel buffer, counters, outputs) between input windows to create a scenario where the module receives inputs after the reset is de-asserted.", "context": {}}, "output": {"response": "", "context": {"verif/sobel_filter_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 15bb4ff89afa86ec54a214f623981f68bbfe5ac9\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/sobel_filter.sv": "module sobel_filter (\n    input   logic           clk,\n    input   logic           rst_n,\n    input   logic   [7:0]   pixel_in,\n    input   logic           valid_in,\n    output  logic   [7:0]   edge_out,\n    output  logic           valid_out\n);\n \n    logic signed [10:0]  Gx, Gy; \n    logic        [7:0]   pixel_buffer  [8:0]; \n    logic        [3:0]   pixel_count; \n    localparam THRESHOLD = 11'd128;\n    integer i;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        for ( i = 0; i < 9; i = i + 1) begin\n            pixel_buffer[i] <= 8'd0;\n        end\n    end else if (valid_in) begin\n        for ( i = 8; i > 0; i = i - 1) begin\n            pixel_buffer[i] <= pixel_buffer[i-1];\n        end\n        pixel_buffer[0] <= pixel_in;\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n       pixel_count <= 4'd0;\n    end else if (valid_in)begin\n        pixel_count <= pixel_count + 1;\n        if (pixel_count == 4'd9) begin\n          pixel_count <= 4'd0;\n        end\n    end else begin\n       pixel_count <= 0;\n    end    \nend\n\nalways @(*) begin    \n    Gx = 11'sd0;\n    Gy = 11'sd0;\n    edge_out = 8'd0;\n    valid_out = 1'b0;\n    if (pixel_count == 4'd9 ) begin\n        valid_out = 1'b1;\n        Gx = (pixel_buffer[0]) + (-(pixel_buffer[2])) + (pixel_buffer[3] << 1) + (-(pixel_buffer[5] << 1)) + (pixel_buffer[6]) + (-pixel_buffer[8]);        \n        Gy = (pixel_buffer[0]) + ((pixel_buffer[1] << 1)) + (pixel_buffer[2]) + (-pixel_buffer[6]) + (-(pixel_buffer[7] << 1)) + (-pixel_buffer[8]);        \n        edge_out = ((Gx < 0 ? -Gx : Gx) + (Gy < 0 ? -Gy : Gy)) > THRESHOLD ? 8'd255 : 8'd0;\n    end \nend\nendmodule"}}}
{"id": "cvdp_copilot_sobel_filter_0017", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the SystemVerilog testbench for a Sobel filter module named `sobel_filter` to verify edge detection on a stream of pixel data. The Sobel filter design calculates the gradient magnitude using a 3x3 pixel window and determines whether the edge strength exceeds a predefined threshold `THRESHOLD=128`. The testbench should validate the results for the design across various input scenarios, including edge cases, and ensure proper synchronization of different input signals. The stimulus for testing the design is already provided, and based on this given list of test cases, the testbench should be modified to add checkers that thoroughly test the module's capability to perform edge detection on a stream of pixel data\n\n#### Inputs:\n- `clk`: Clock signal for synchronization. The design is synchronized to the positive edge of this clock.\n- `rst_n`: Active-low asynchronous reset. Clears internal buffers, counters, and outputs.\n- `pixel_in [7:0]`: 8-bit input pixel data.\n- `valid_in`: An active-high signal that indicates the validity of the `pixel_in` data.\n\n#### Outputs:\n- `edge_out [7:0]`: 8-bit output indicating the presence of an edge (255 for an edge, 0 otherwise).\n- `valid_out`: An active-high signal that indicates when `edge_out` is valid.\n\n### **1. Overview of the Sobel Filter Algorithm:**\n\nThe Sobel filter detects edges in an image by first computing the gradients in the horizontal (`Gx`) and vertical (`Gy`) directions, then calculating the gradient magnitude (`|Gx| + |Gy|`) and comparing it to a threshold to determine whether a pixel is part of an edge. The `THRESHOLD` is set to a default value of 128 which defines the threshold for edge detection. Pixels with gradient magnitudes greater than this value are classified as edges.  \n\nA 3x3 window of pixels is sent as a continuous stream of inputs through `pixel_in`, and `valid_in` remains high while pixels are supplied. The module uses a 3x3 buffer to store pixel data, ensuring it only outputs valid results once the buffer is fully populated with 9 pixels. Pixels are shifted sequentially to store new incoming pixels. (The input is sent row by row, left to right. Starting from the top row, the traversal proceeds to the bottom row.) The filter performs convolution when the buffer is fully populated and outputs the result. After processing each window, the module clears the buffer and waits for the next set of 9 pixels. Buffer is also cleared when reset is asserted. Assume that the handling of overlapping windows is handled externally, and this design processes each window as a new one (no storing of pixels from the previous window). If `valid_in` is deasserted midstream (before the completion of a full window), the design discards the stored partial window to begin a new calculation at the next `valid_in`.\n\n### **2. Expected Behavior**\nThe Sobel filter module adheres to the following specifications:  \n\n- **Valid Signal Assertion:**  \n   - The `valid_out` signal is asserted (`1`) for 1 clock cycle only when the buffer is fully populated with 9 pixels (9 clock cycles after `valid_in` for the first pixel). During initialization (first 8 clock cycles), `valid_out` remains `0`.  \n\n- **Accurate Gradient Computation:**  \n   - The gradients `Gx` and `Gy` are calculated using the Sobel kernels with proper handling of signed arithmetic. Each pixel in the 3x3 window is multiplied by the kernel coefficient corresponding to its relative position in the Sobel kernel. For example:\n        - The pixel stored in the top-left corner of the buffer is multiplied by -1 (top-left coefficient in the Gx kernel).\n        \nThen the results are added to compute Gx and Gy and obtain the gradient magnitude.\n    \n```\n     Gx Kernel:     Gy Kernel:\n     [-1  0  +1]    [-1  -2  -1]\n     [-2  0  +2]    [ 0   0   0]\n     [-1  0  +1]    [+1  +2  +1]\n```  \n   - The `edge_out` signal should classify pixels as edges (`8'd255`) if the gradient magnitude (`|Gx| + |Gy|`) exceeds the `THRESHOLD`. Otherwise, classify as non-edges (`8'd0`). `edge_out`  and `valid_out` should remain zero until the value from a computation is updated.\n\n---\n\n## Testbench Requirements:\n\n### Module Instantiation:\n- The Sobel filter module is already instantiated as `dut`, with all input and output signals connected for testing.\n\n### Existing Input Stimuli:\n1. **Pixel Stream Generation:**\n   - The existing testbench generates a stream of 8-bit pixel values (`pixel_in`) and asserts `valid_in` when pixel data is valid.\n   - It includes edge cases like:\n     - Uniform pixel values (all zeros, all maximum values).\n     - Pixel gradients (e.g., increasing or decreasing values across the 3x3 window).\n     - Random pixel values to simulate real-world scenarios.\n2. **Synchronization:**\n   - The testbench contains test cases that reset `valid_in` after loading a 3\u00d73 block of pixels and tests that continuously assert `valid_in` for multiple input windows. Additionally, it resets `valid_in` mid-stream to cover all possible scenarios.\n\n3. **Clock and Reset Behavior**:\n   - A continuous clk signal is already generated.\n   - An active-low asynchronous reset (`rst_n`) is set to clear all internal states (e.g., pixel buffer, counters, outputs) at the start and between input windows.\n\n### Output Calculation and Control Signal Validation:\n  -  **Control Signal Valid:** When the buffer is fully populated with 9 pixels (9 clock cycles after `valid_in` for the first pixel), the testbench must validate that the control signal `valid_out` is asserted (`1`) for 1 clock cycle. \n  - **Reference Implementation of `edge_out`:** Reference calculation of the Sobel-based filtering of the complete set of 3*3 pixels must be generated based on the threshold value and the kernel coefficient.\n  - The testbench must validate the outputs of a continuous stream of valid pixels by monitoring the assertion of `valid_in` continuously. When `valid_in` remains consistently asserted after a full window is completed, the consistency of the output value `edge_out` must be checked. \n  - The testbench must validate that no output signal (`valid_out`& `edge_out`) is asserted when the `valid_in` is de-asserted mid-stream (not all 9 pixels are streamed).\n  \n### Latency Validation: \n- The output `edge_out` is valid when the `valid_out` is set to 1. After the  `valid_in` is set, it takes a total of 3*3 ( total number of pixels) clock cycles for the `valid_out` and `edge_out` to be generated. The testbench must include the validation of the latency for the generated output. \n\n### Simulation Control\n- Execute the checkers using procedural blocks, monitoring the process with appropriate delays and synchronization methods.\n- Use $display for logging results and $error for mismatches to facilitate debugging.\n\n### Test Procedure\n\n1. Initialization and Reset: An initial reset to the DUT is already applied before starting the test sequence.\n2. Use the test cases provided, including random values of the pixels, where `valid_in ' is triggered at different points in time as inputs to the design.\n3. Calculate the output value as a reference implementation based on the coefficients in the Gx and Gy kernel and threshold values.\n4. The output `valid_out` and `edge_out` must be checked against the reference implementation\n5. Validate the latency calculated against the expected latency for the generated output.  \n\n### Deliverables\nProvide a **modified SystemVerilog testbench** that effectively verifies the `sobel_filter` module to ensure its correct functionality in filtering a 3*3 set of input pixels using the already provided set of input scenarios. ", "context": {"verif/sobel_filter_tb.sv": "module sobel_filter_tb;\n    logic       clk;\n    logic       rst_n;\n    logic [7:0] pixel_in;\n    logic       valid_in;\n    logic [7:0] edge_out;\n    logic       valid_out;\n\n    logic [71:0] input_array;\n    int i, j;\n\n    sobel_filter dut (\n        .clk       (clk),\n        .rst_n     (rst_n),\n        .pixel_in  (pixel_in),\n        .valid_in  (valid_in),\n        .edge_out  (edge_out),\n        .valid_out (valid_out)\n    );\n\n    always #5 clk = ~clk; \n\n    initial begin\n        clk = 1;\n        rst_n = 0;\n        pixel_in = 8'd0;\n        valid_in = 0;\n\n        $dumpfile(\"test.vcd\"); \n        $dumpvars(0, sobel_filter_tb);    \n\n        @(posedge clk);\n        rst_n = 1; \n        repeat(2) @(posedge clk);\n\n        send_pixels({8'd100, 8'd50,  8'd200, \n                     8'd150, 8'd120, 8'd180, \n                     8'd90,  8'd110, 8'd170});\n\n        send_pixels({8'd10, 8'd255, 8'd10, \n                     8'd10, 8'd255, 8'd10, \n                     8'd10, 8'd255, 8'd10});\n\n        send_pixels({8'd128, 8'd128, 8'd128, \n                     8'd128, 8'd128, 8'd128, \n                     8'd128, 8'd128, 8'd128});\n\n         @(posedge clk);\n        rst_n = 0; \n        valid_in = 0;\n        \n        repeat(2) @(posedge clk);\n\n        rst_n = 1; \n\n        send_pixels({$random, $random, $random, \n                     $random, $random, $random, \n                     $random, $random, $random});\n\n        send_pixels({8'd10, 8'd20,  8'd30, \n                     8'd20, 8'd255, 8'd40, \n                     8'd30, 8'd40,  8'd50});\n      \n\n        send_pixels({8'd0, 8'd255, 8'd255, \n                     8'd0, 8'd0,   8'd255, \n                     8'd0, 8'd0,   8'd0});\n\n        send_pixels({8'd0, 8'd0,   8'd0, \n                     8'd0, 8'd255, 8'd0, \n                     8'd0, 8'd0,   8'd0});\n\n        for (j = 0; j < 10; j++) begin\n            for (i = 0; i < 9; i++) begin\n                input_array[i*8 +: 8] = $urandom_range(0, 2**(8)-1);  \n            end\n\n            send_pixels(input_array);\n\n        end\n\n        repeat(2) @(posedge clk); \n\n        // Stimulate valid_in to 0 in middle of transfer!;\n        for (i = 0; i < 9; i++) begin\n            @(posedge clk);\n            pixel_in = $urandom_range(0, 2**(8)-1); \n            if (i==4) begin \n                valid_in = 0;\n            end else begin\n                valid_in = 1;\n            end\n        end\n        \n        repeat(2) @(posedge clk); \n\n        $finish;\n    end\n\n    task send_pixels(input [71:0] pixels);\n        integer i;\n        for (i = 0; i < 9; i = i + 1) begin\n            @(posedge clk);\n            pixel_in = pixels[8 * (8 - i) +: 8]; \n            valid_in = 1;\n        end\n        @(posedge clk);\n        pixel_in = 0;\n        // Stimulate valid_in is either set to 0 for new set of inputs or set to 1 throughout\n        valid_in = $urandom_range(0, 1);\n    endtask\n\nendmodule"}}, "output": {"response": "", "context": {"verif/sobel_filter_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 17-tb-checker-sobel-filter\nNUM_BUGS        = 3", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n", "src/sobel_filter.sv": "module sobel_filter (\n    input   logic           clk,\n    input   logic           rst_n,\n    input   logic   [7:0]   pixel_in,\n    input   logic           valid_in,\n    output  logic   [7:0]   edge_out,\n    output  logic           valid_out\n);\n \n    logic signed [10:0]  Gx, Gy; \n    logic        [7:0]   pixel_buffer  [8:0]; \n    logic        [3:0]   pixel_count; \n    localparam THRESHOLD = 11'd128;\n    integer i;\n\n\n// Load pixels in the buffer\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        for ( i = 0; i < 9; i = i + 1) begin\n            pixel_buffer[i] <= 8'd0;\n        end\n    end else if (valid_in) begin\n        for ( i = 8; i > 0; i = i - 1) begin\n            pixel_buffer[i] <= pixel_buffer[i-1];\n        end\n        pixel_buffer[0] <= pixel_in;\n    end\nend\n\n// Input is valid only when valid_in is asserted\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n       pixel_count <= 4'd0;\n    end else if (valid_in)begin\n        pixel_count <= pixel_count + 1;\n        if (pixel_count == 4'd9) begin\n          pixel_count <= 4'd0;\n        end\n    end \n    `ifndef BUG_0\n        else begin\n            pixel_count <= 0;\n        end  \n    `else  \n    `endif   \nend\n\n// Calculate Output based on coefficients:\n// Gx Kernel:     Gy Kernel:\n//  [-1  0  +1]    [-1  -2  -1]\n//  [-2  0  +2]    [ 0   0   0]\n//  [-1  0  +1]    [+1  +2  +1]\nalways @(*) begin    \n    Gx = 11'sd0;\n    Gy = 11'sd0;\n    edge_out = 8'd0;\n    valid_out = 1'b0;\n    if (pixel_count == 4'd9 ) begin\n        valid_out = 1'b1;\n        `ifndef BUG_1\n            Gx = (pixel_buffer[0]) + (-(pixel_buffer[2])) + (pixel_buffer[3] << 1) + (-(pixel_buffer[5] << 1)) + (pixel_buffer[6]) + (-pixel_buffer[8]);        \n            Gy = (pixel_buffer[0]) + ((pixel_buffer[1] << 1)) + (pixel_buffer[2]) + (-pixel_buffer[6]) + (-(pixel_buffer[7] << 1)) + (-pixel_buffer[8]);        \n        `else \n            Gx = (pixel_buffer[0]) + ((pixel_buffer[2])) + (pixel_buffer[3] << 1) + ((pixel_buffer[5] << 1)) + (pixel_buffer[6]) + (-pixel_buffer[8]);        \n            Gy = (pixel_buffer[0]) + ((pixel_buffer[1] << 1)) + (pixel_buffer[2]) + (pixel_buffer[6]) + ((pixel_buffer[7] << 1)) + (-pixel_buffer[8]);         \n        `endif  \n        \n        `ifndef BUG_2\n            edge_out = ((Gx < 0 ? -Gx : Gx) + (Gy < 0 ? -Gy : Gy)) > THRESHOLD ? 8'd255 : 8'd0;\n        `else\n            edge_out = (Gx  + Gy) > THRESHOLD ? 8'd255 : 8'd0;\n        `endif  \n\n    end \nend\nendmodule"}}}
{"id": "cvdp_copilot_sorter_0038", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `sorting_engine` module. The assertions should ensure that the module performs sorting correctly with the expected latency.\n\n## **RTL Design Overview**  \n`sorting_engine` receives an array of unsigned integers as input, sorts them using the bubble sort algorithm, and then provides the sorted array as output. The module is driven by a clock, has a reset mechanism, and provides a control signal to indicate when sorting is complete. Sorting arranges the elements of the array in ascending order, such that the smallest element is at index 0 and the largest element is at index N\u22121.\n\nBubble sort is a straightforward sorting algorithm that works by repeatedly comparing adjacent elements in an array and swapping them if they are out of order. Through multiple passes over the array, larger values \"bubble\" up toward the end of the array, while smaller values move toward the beginning. Eventually, after enough passes, the entire array becomes sorted. For this implementation perform (N)*(N-1) passes to sort the array of N elements. \n\n### **Key Components of the Module**       \n\n**Parameters**\n- `N`  (Default is 8, Greater than 0): Number of elements to sort\n- `WIDTH`(Default is 8, Greater than 0): Bit-width of each input element\n\n**Port List**\n| Port Name               | Direction | Width          | Description                                                                                                                                                                                                                                                              |\n|-------------------------|-----------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `clk`                   | input     | 1 bit          | Main clock input. All operations occur on the rising edge of this signal.                                                                                                                                                                                                |\n| `rst`                   | input     | 1 bit          | Active high, asynchronous reset. When asserted, resets the internal state machine and registers to their initial states.                                                                                                                                                 |\n| `start`                 | input     | 1 bit          | Active high, pulse start signal to indicate that the input data is valid and that sorting should begin on the next clock cycle.                                                                                                                                          |\n| `[N*WIDTH-1:0] in_data` | input     | N * WIDTH bits | Input data bus containing the entire unsorted array. Each element has WIDTH bits, and there are N elements.                                                                                                                                                              |\n| `done`                  | output    | 1 bit          | Active high pulse, asserted for 1 clock cycle when the sorting is complete, indicating that `out_data` is now valid and stable. It will be set to 0 in case of a reset.                                                                                                  |\n| `[N*WIDTH-1:0] out_data`| output    | N * WIDTH bits | Output data bus containing the sorted array. This is to be left uninitialized at reset and updated only when sorting a valid input is complete. Valid once `done` is asserted, and maintains previous values until the update from the next sorting operation completes. |\n\nThe state machine has `IDLE`, `SORTING`, and `DONE` states. The FSM transitions from `IDLE` to `SORTING` when the start signal is asserted, cycles through the comparisons and swaps, and eventually moves to `DONE` when sorting is complete.\n\n- **Latency and Timing**: Each comparison and potential swap takes one clock cycle. Bubble sort in hardware will, by default, consume multiple cycles, as it effectively simulates the step-by-step iterative nature of the algorithm. The done signal is asserted only after the last pass is complete. Latency is equal to (N)*(N-1)+2 for an array with `N` elements.\n  \n- **Output**: Once the sorting finishes, the sorted array is presented at the output port. This involves placing the sorted values back onto an output bus.\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Correct sorted output:** The output data `out_data` should contain correctly sorted data after the sorting operation is completed.\n- **Stable output:** Ensure that the output data is stable once the sorting operation is completed until the next sorting operation completes and the result is updated. \n- **Correct latency:** Ensure that the `done` is asserted indicating the sorting operation is completed within the expected latency.  \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // Internal registers to hold the array\n    reg [WIDTH-1:0] array [0:N-1];\n\n    // FSM states\n    localparam IDLE    = 2'd0;\n    localparam SORTING = 2'd1;\n    localparam DONE    = 2'd2;\n\n    reg [1:0]  state, next_state;\n\n    // Variables for bubble sort indexing\n    reg [$clog2(N)-1:0] i;  // Outer loop index\n    reg [$clog2(N)-1:0] j;  // Inner loop index\n\n    // Wires for comparison and swap\n    wire [WIDTH-1:0] val_j;\n    wire [WIDTH-1:0] val_j1;\n\n    assign val_j  = array[j];\n    assign val_j1 = array[j+1];\n\n    // FSM: Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = SORTING;\n            end\n            SORTING: begin\n                // Transition to DONE once all passes are complete\n                if (i == (N-1) && j == (N-2))\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM: Output and counter updates\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            i <= 0;\n            j <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (start) begin\n                        // Load the array from in_data\n                        for (int k = 0; k < N; k = k + 1) begin\n                            array[k] <= in_data[(k+1)*WIDTH-1 -: WIDTH];\n                        end\n                        i <= 0;\n                        j <= 0;\n                    end\n                end\n\n                SORTING: begin\n                    // Perform a single comparison and swap if needed\n                    if (val_j > val_j1) begin\n                        array[j]   <= val_j1;\n                        array[j+1] <= val_j;\n                    end\n\n                    // Update j\n                    if (j == N-2) begin\n                        // One pass completed, increment i\n                        j <= 0;\n                        i <= i + 1;\n                    end else begin\n                        j <= j + 1;\n                    end\n                end\n\n                DONE: begin\n                    // Sorting complete\n                    done <= 1;\n                    // Output the sorted data\n                    for (int m = 0; m < N; m = m + 1) begin\n                        out_data[(m+1)*WIDTH-1 -: WIDTH] <= array[m];\n                    end\n                end\n                default: begin\n                end\n            endcase\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sorting_engine.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sorting_engine.sv\nTOPLEVEL        = sorting_engine\nMODULE          = test_sorting_engine\nPYTHONPATH      = /src\nHASH            = 38-rtl-assertion-bubble-sort", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.parametrize(\"WIDTH\", [random.randint(4, 32)])\n@pytest.mark.parametrize(\"N\", [random.randint(4, 32)])\ndef test_runner(WIDTH,N):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    if N > 2**WIDTH-1:\n        N = 2**WIDTH-1\n    parameters = { \"WIDTH\": WIDTH, \"N\": N }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# if __name__ == \"__main__\":\n#     test_simulate()", "src/test_sorting_engine.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n@cocotb.test()\nasync def test_sorter_dynamic_latency(dut):\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n    clk_period = 10  # ns\n    random.seed(0)  # For reproducibility\n\n    async def clock():\n        while True:\n            dut.clk.value = 0\n            await Timer(clk_period/2, units='ns')\n            dut.clk.value = 1\n            await Timer(clk_period/2, units='ns')\n\n    cocotb.start_soon(clock())\n\n    await reset_dut(dut, 5)\n    dut.start.value = 0\n\n    async def run_test_case(name, input_array):\n        cocotb.log.info(f\"Running Test: {name}\")\n        packed_input = 0\n        for idx, val in enumerate(input_array):\n            packed_input |= (val << (idx * WIDTH))\n        dut.in_data.value = packed_input\n\n        expected_steps = simulate_bubble_sort_steps(input_array, no_early_termination=True) + 2\n\n        await RisingEdge(dut.clk)\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        cycle_count = 0\n        while True:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n            if dut.done.value == 1:\n                break\n\n        out_data_val = int(dut.out_data.value)\n        output_array = [ (out_data_val >> (i * WIDTH)) & ((1 << WIDTH) - 1) for i in range(N)]\n        expected_output = sorted(input_array)\n\n        assert output_array == expected_output, f\"[{name}] Output incorrect. Got: {output_array}, Expected: {expected_output}\"\n        assert cycle_count == expected_steps, f\"[{name}] Latency mismatch. Got {cycle_count}, Expected {expected_steps}\"\n        cocotb.log.info(f\"Input {input_array}.\")\n        cocotb.log.info(f\"Output {output_array}.\")\n        cocotb.log.info(f\"Expected output {expected_output}.\")\n        cocotb.log.info(f\"Test {name} passed.\")\n\n    # Corner Cases\n    if N == 1:\n        await run_test_case(\"Single Element\", [10])\n\n    await run_test_case(\"Already Sorted\", list(range(N)))\n    await run_test_case(\"Reverse Sorted\", list(range(N-1, -1, -1)))\n    await run_test_case(\"All Duplicates\", [5]*N)\n    await run_test_case(\"All Max Values\", [(1 << WIDTH) - 1]*N)\n    await run_test_case(\"All Min Values\", [0]*N)\n    # Mixed min/max pattern\n    await run_test_case(\"Min-Max Alternating\", [0 if i % 2 == 0 else (1 << WIDTH)-1 for i in range(N)])\n\n    # Partial sorted (first half sorted, second half random)\n    half_sorted = list(range(N//2)) + [random.randint(0, (1 << WIDTH)-1) for _ in range(N - N//2)]\n    await run_test_case(\"Half Sorted\", half_sorted)\n\n    # Stress Testing with multiple random arrays\n    # Increase the count for more thorough stress tests\n    stress_test_count = 20\n    for idx in range(stress_test_count):\n        arr = [random.randint(0, (1 << WIDTH)-1) for _ in range(N)]\n        await run_test_case(f\"Random {idx}\", arr)\n\n    cocotb.log.info(\"All tests completed successfully!\")\n\n\ndef simulate_bubble_sort_steps(arr, no_early_termination=False):\n    N = len(arr)\n    # Given the DUT does no early termination, it always does (N-1)*(N-1) steps.\n    # If no_early_termination is True, ignore input and return full passes.\n    if no_early_termination:\n        return (N)*(N-1)\n\n    # If we were to consider early termination logic, it would go here.\n    return (N)*(N-1)\n\n\nasync def reset_dut(dut, duration):\n    dut.rst.value = 1\n    for _ in range(duration):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n"}}}
{"id": "cvdp_copilot_sorter_0042", "categories": ["cid014", "medium"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `sorting_engine` module. The assertions should ensure that the module accurately implements the Insertion sort algorithm.\n\n## **RTL Design Overview**  \n`sorting_engine` receives an array of unsigned integers as input, sorts them using the Insertion sort algorithm, and then provides the sorted array as output. The module is driven by a clock, has a reset mechanism, and provides a control signal to indicate when sorting is complete. Sorting arranges the elements of the array in ascending order, such that the smallest element is at index 0 and the largest element is at index N\u22121.\n\nInsertion sort iterates, consuming one input element each repetition, and grows a sorted output subarray. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted subarray, and inserts it there. It repeats until no input elements remain. Sorting is typically done in-place, by iterating up the array, and growing the sorted subarray behind it. At each array-position, it checks the value there against the largest value in the sorted subarray (which happens to be next to it, in the previous array-position checked). If larger, it leaves the element in place and moves to the next. If smaller, it finds the correct position within the sorted subarray, shifts all the larger values up to make a space, and inserts into that correct position. The resulting array after k iterations has the property where the first k + 1 entries are sorted (\"+1\" because the first entry is skipped).\n\n\n### **Key Components of the Module**       \n\n**Parameters**\n- `N`  (default is 8, greater than 0): Number of elements to sort\n- `WIDTH`(default is 8, greater than 0): Bit-width of each input element\n\n**Port List**\n| Port Name               | Direction | Width          | Description                                                                                                                                                                                                                                                              |\n|-------------------------|-----------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `clk`                   | input     | 1 bit          | Main clock input. All operations occur on the rising edge of this signal.                                                                                                                                                                                                |\n| `rst`                   | input     | 1 bit          | Active high, asynchronous reset. When asserted, resets the internal state machine and registers to their initial states.                                                                                                                                                 |\n| `start`                 | input     | 1 bit          | Active high, pulse start signal to indicate that the input data is valid and that sorting should begin on the next clock cycle.                                                                                                                                          |\n| `in_data`               | input     | N * WIDTH bits | Input data bus containing the entire unsorted array. Each element has WIDTH bits, and there are N elements.                                                                                                                                                              |\n| `done`                  | output    | 1 bit          | Active high pulse, asserted for 1 clock cycle when the sorting is complete, indicating that `out_data` is now valid and stable. It will be set to 0 in case of a reset.                                                                                                  |\n| `out_data`              | output    | N * WIDTH bits | Output data bus containing the sorted array. This is to be left uninitialized at reset and updated only when sorting a valid input is complete. Valid once `done` is asserted, and maintains previous values until the update from the next sorting operation completes. |\n\nThe state machine has `IDLE`, `SORTING`, and `DONE` states. The FSM transitions from `IDLE` to `SORTING` when the start signal is asserted, cycles through the comparisons and swaps, and eventually moves to `DONE` when sorting is complete.\n\n- **Latency and timing**: Latency for every input pair can vary and the latency distribution should be as described below:\n   - 1 clock cycle to set up the start conditions after the `start` is asserted high.\n   - Following will occur for every element in the array:\n      - 1 clock cycle to access the element in the array to be sorted.\n      - Every shift operation (till the correct spot is found for that element) will take 1 clock cycle.\n      - 1 clock cycle to detect iterations for that element is complete.\n      - Inserting the element at the spot found will take 1 clock cycle.\n   - 1 clock cycle to detect that all elements are sorted.\n   - 1 clock cycle to output the sorted array and assert the `done` signal.\n  \n- **Output**: Once the sorting finishes, the sorted array is presented at the output port. This involves placing the sorted values back onto an output bus.\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Final sorted order in `array` at `DONE`:** Once we enter the `DONE` state, we expect the entire internal array (array[0..N-1]) to be sorted in non-decreasing order.\n- **Partial array sorted after each iteration:** In insertion sort, after completing an iteration, the sub-array should be sorted.\n- **No out-of-bounds write on `array[j+1]`:** During `insert_phase` 1 and 2, ensure `j+1` stays within `[0..N-1]`.\n- **If `j < 0`, then transition to phase 2 next cycle:** In insertion sort, once `j` drops below 0, the design should transition to `insert_phase` 2 (where we insert the key) immediately on the next cycle.\n- **Once `i == N`, next state must be `DONE`** in `SORTING`, if `i == N`, we expect the design to move to `DONE` next cycle.\n- **`key` must stay stable during phase 1 shifting and phase 2:** In insertion sort, `key` is loaded in `insert_phase` 0 and should not change while we are shifting elements in `insert_phase` 1 and 2. This ensures we don\u2019t lose the value to be inserted.\n- **`out_data` must remain stable except in `DONE`:**  Ensure that while not in `DONE`, `out_data` never changes.\n- **`i` never decrements:**  `i` only increments. We ensure it does not accidentally go backward or reset to an unexpected value (except via the `rst` condition)\n- **Shift-then-insert mechanism:** Whenever we remain in `insert_phase` 1 (shifting) and `array[j] > key`, we expect the next cycle to see `array[j+1]` updated with `array[j]`. This ensures the shift is indeed happening. \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // Internal array\n    reg [WIDTH-1:0] array [0:N-1];\n\n    // FSM states\n    localparam IDLE    = 2'd0;\n    localparam SORTING = 2'd1;\n    localparam DONE    = 2'd2;\n\n    reg [1:0] state, next_state;\n\n    // Insertion sort variables\n    integer i;\n    integer j;\n    reg [WIDTH-1:0] key;\n\n    // Insertion sort phases for each i\n    // 0: Initialize key and j\n    // 1: Shift elements greater than key\n    // 2: Insert key\n    reg [1:0] insert_phase;\n\n    // FSM: Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = SORTING;\n            end\n            SORTING: begin\n                // Once i reaches N, sorting is done\n                if (i == N)\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM: main logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state         <= IDLE;\n            done          <= 0;\n            i             <= 0;\n            j             <= 0;\n            key           <= 0;\n            insert_phase  <= 0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (start) begin\n                        // Load array from in_data\n                        for (int k = 0; k < N; k = k + 1) begin\n                            array[k] <= in_data[(k+1)*WIDTH-1 -: WIDTH];\n                        end\n                        i <= 1; // Start insertion sort from index 1\n                        j <= 0;\n                        key <= 0;\n                        insert_phase <= 0;\n                    end\n                end\n\n                SORTING: begin\n                    // Perform insertion sort step-by-step\n                    case (insert_phase)\n                        0: begin\n                            // Phase 0: Setup for inserting array[i]\n                            if (i < N) begin\n                                key <= array[i];\n                                j <= i - 1;\n                                insert_phase <= 1;\n                            end\n                            // If i == N, sorting complete, next cycle moves to DONE\n                        end\n\n                        1: begin\n                            // Phase 1: Shift elements to the right until the correct spot is found\n                            if (j >= 0 && array[j] > key) begin\n                                array[j+1] <= array[j];\n                                j <= j - 1;\n                            end else begin\n                                // We found the spot (or j < 0)\n                                insert_phase <= 2;\n                            end\n                        end\n\n                        2: begin\n                            // Phase 2: Insert the key at array[j+1]\n                            array[j+1] <= key;\n                            i <= i + 1;\n                            insert_phase <= 0; \n                        end\n\n                        default: insert_phase <= 0;\n                    endcase\n                end\n\n                DONE: begin\n                    // Sorting complete, output the result\n                    done <= 1;\n                    for (int m = 0; m < N; m = m + 1) begin\n                        out_data[(m+1)*WIDTH-1 -: WIDTH] <= array[m];\n                    end\n                end\n\n                default: begin\n                    // Should not get here\n                end\n            endcase\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sorting_engine.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sorting_engine.sv\nTOPLEVEL        = sorting_engine\nMODULE          = test_sorting_engine\nPYTHONPATH      = /src\nHASH            = 42-rtl-assertion-insertion-sort", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\nvalid_params = []\nvalid_params.append((8,8))\n\n@pytest.mark.parametrize(\"WIDTH, N\", valid_params)\ndef test_runner(WIDTH,N):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    parameters = { \"WIDTH\": WIDTH, \"N\": N }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# if __name__ == \"__main__\":\n#     test_simulate()\n", "src/test_sorting_engine.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport random\n\nasync def reset_dut(dut):\n    dut.rst.value = 1\n    dut.start.value = 0\n    dut.in_data.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\ndef expected_insertion_sort_operations(arr):\n    \"\"\"\n    Compute the expected \"latency\" in terms of operations for an insertion sort on 'arr'.\n    We'll count the number of comparisons made during a standard insertion sort.\n    \"\"\"\n    # Make a copy to avoid modifying the original array\n    data = arr[:]\n    operations = 0\n    for i in range(1, len(data)):\n        operations += 1\n        key = data[i]\n        j = i - 1\n\n        # In insertion sort, for each element, we compare with previous elements until we find the spot.\n        # Count a comparison for each j we test. If we have to move past array[j], that's another comparison.\n        while j >= 0 and data[j] > key:\n            operations += 1  # comparison\n            data[j+1] = data[j]\n            j -= 1\n        # Even when we break out of loop, we've done one more comparison that fails the condition.\n        operations += 1  # comparison to exit the loop\n        data[j+1] = key\n    operations += (len(data) +2)\n    return operations\n\nasync def run_sort_test(dut, input_array, N, WIDTH):\n    \"\"\"\n    Helper function to run a sort test with a given input_array.\n    Returns the number of cycles it took to complete sorting.\n    Also compares actual latency with expected operations count.\n    \"\"\"\n    # Reset the DUT before each test\n    await reset_dut(dut)\n\n    # Pack the input array into a single integer\n    in_val = 0\n    for i, val in enumerate(input_array):\n        in_val |= (val << (i * WIDTH))\n\n    dut._log.info(f\"Testing with input: {input_array}\")\n    dut.in_data.value = in_val\n\n    # Start sorting\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure how many cycles it takes until done\n    cycles = 0\n    while True:\n        #print(\"State = \",dut.state.value)\n        #print(\"insert_phase = \",dut.insert_phase.value)\n        #print(\"i = \",dut.i.value)\n        #print(*dut.array.value)\n        await RisingEdge(dut.clk)\n        cycles += 1\n        if dut.done.value == 1:\n            break\n\n    # Once done is high, read out the sorted result\n    sorted_val = dut.out_data.value\n    output_array = []\n    for i in range(N):\n        chunk = (sorted_val >> (i * WIDTH)) & ((1 << WIDTH) - 1)\n        output_array.append(chunk)\n\n    dut._log.info(f\"Sorted output after {cycles} cycles: {output_array}\")\n\n    # Check correctness\n    expected = sorted(input_array)\n    assert output_array == expected, f\"DUT output {output_array} does not match expected {expected}\"\n    dut._log.info(\"Output is correctly sorted.\")\n\n    # Compute expected operations for a standard insertion sort on input_array\n    exp_ops = expected_insertion_sort_operations(input_array)\n    assert exp_ops == cycles, f\"Expected latency is not equal to actual latency\"\n\n    return cycles\n\n@cocotb.test()\nasync def test_sorting_engine(dut):\n    \"\"\"Test the insertion sort engine with various cases and compare actual latency to expected operations.\"\"\"\n    # Parameters (these should match the DUT)\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    # Start a clock\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Test cases\n    max_val = (1 << WIDTH) - 1\n\n    test_cases = [\n        [i for i in range(N)],  # ascending\n        [N - 1 - i for i in range(N)],  # descending\n        [5] * N,  # all same\n        [0] * N,  # all minimum\n        [max_val] * N,  # all maximum\n        [0, max_val] + [random.randint(0, max_val) for _ in range(N - 2)]  # mixed\n    ]\n\n    # Add multiple random tests\n    for _ in range(5):\n        test_cases.append([random.randint(0, max_val) for _ in range(N)])\n\n    # Run all tests\n    for test_input in test_cases:\n        await run_sort_test(dut, test_input, N, WIDTH)\n\n    dut._log.info(\"All tests completed successfully with latency checks against expected insertion sort operations.\")\n"}}}
{"id": "cvdp_copilot_sorter_0045", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `sorting_engine` module. The assertions should ensure that the module accurately implements the Brick sort algorithm.\n\n## **RTL Design Overview**  \n**Brick Sort** (also known as **Odd-Even Sort**) is a simple comparison-based sorting algorithm that repeatedly alternates between comparing/swapping all \u201codd-even\u201d index pairs and all \u201ceven-odd\u201d index pairs. After each pass of pairwise comparisons, larger elements gradually \u201cbubble\u201d to the right and smaller elements \u201cbubble\u201d to the left, ensuring that enough iterations will fully sort the array. On **even-numbered passes**, the module compares and, if needed, swaps **even-odd** index pairs ((0,1), (2,3)) (compares elements at even-indexed positions with their immediate next neighbors). On **odd-numbered passes**, it compares and, if needed, swaps **odd-even** index pairs ((1,2), (3,4)) (compares elements at odd-indexed positions with their immediate next neighbors). Each pass is processed in multiple clock cycles: each clock cycle steps through the relevant pairs, performing one compare-and-swap per cycle. After finishing \\(N\\) passes, the array is guaranteed to be sorted.\n\n### **Key Components of the Module**       \n\n**Parameters**\n- `N`  (Default is 8, Greater than 0): Number of elements to sort\n- `WIDTH`(Default is 8, Greater than 0): Bit-width of each input element\n\n**Port List**\n| Port Name               | Direction | Width          | Description                                                                                                                                                                                                                                                              |\n|-------------------------|-----------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `clk`                   | input     | 1 bit          | Main clock input. All operations occur on the rising edge of this signal.                                                                                                                                                                                                |\n| `rst`                   | input     | 1 bit          | Active high, asynchronous reset. When asserted, resets the internal state machine and registers to their initial states.                                                                                                                                                 |\n| `start`                 | input     | 1 bit          | Active high, pulse start signal to indicate that the input data is valid and that sorting should begin on the next clock cycle.                                                                                                                                          |\n| `[N*WIDTH-1:0] in_data` | input     | N * WIDTH bits | Input data bus containing the entire unsorted array. Each element has WIDTH bits, and there are N elements.                                                                                                                                                              |\n| `done`                  | output    | 1 bit          | Active high signal, asserted when sorting is complete. `done` remains high until start is deasserted (set to 0), at which point it returns to 0.                                                                                                                         |\n| `[N*WIDTH-1:0] out_data`| output    | N * WIDTH bits | Output data bus containing the sorted array. This is to be left uninitialized at reset and updated only when sorting a valid input is complete. Valid once `done` is asserted, and maintains previous values until the update from the next sorting operation completes. |\n\n- **Output**: Once the sorting finishes, the sorted array is presented at the output port. This involves placing the sorted values back onto an output bus.\n- The brick sort algorithm uses FSM.\n- Assume that all the numbers will be non-negative integers.\n- Assume `N` is an even integer greater than 2.\n---\n\n### Latency Considerations\nTotal latency = (N * (N - 1)) / 2 + 4\nPerforms a single compare-and-swap operation per clock cycle (sequential approach):  \n- 1 clock cycle for moving from `IDLE` state to `LOAD`.\n- **1 clock cycle** to load the data.  \n- Performs **\\(N\\) passes** to completely sort the array.  \n  - Each **even-numbered pass** has N/2 comparisons and swaps.  \n  - Each **odd-numbered pass** has N/2-1 comparisons and swaps.  \n- Each comparison-and-swap takes **1 clock cycle**.\n- **1 clock cycle** to transition to `DONE` state from the `SORT`.\n- **1 clock cycle** to set the output sorted array and assert the `done` signal after sorting is complete.  \n\n**Latency Example:**  \n- \\(N = 4\\), \\(WIDTH = 4\\)  \n- in_data = [0, 1, 2, 3]\n- out_data = [3, 2, 1, 0]  \n- **Latency = 10 clock cycles**  \n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Final sorted order in `array`:** Once we assert the `done` signal, we expect the entire internal array (array[0..N-1]) to be sorted in non-decreasing order.\n- **Sorting latency**: The latency for sorting an input should not exceed the expected latency mentioned above.\n- **'done' pulse assertion**:  The 'done' signal should be asserted as a one-cycle pulse if `start` is low. (It is not held high for multiple cycles unless `start` is also asserted)\n- **No out-of-bounds pair index access**: Confirm the design never attempts to compare-swap an invalid pair index that would exceed N-1.\n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // ----------------------------------------------------------\n    // Internal Parameters and State Encoding\n    // ----------------------------------------------------------\n    localparam IDLE = 2'd0,\n               LOAD = 2'd1,\n               SORT = 2'd2,\n               DONE = 2'd3;\n\n    // ----------------------------------------------------------\n    // Internal Registers\n    // ----------------------------------------------------------\n    reg [1:0]  state, next_state;\n\n    // Store data in a register array for easy swapping\n    reg [WIDTH-1:0] data_array [0:N-1];\n\n    // Pass counter: we will run up to N passes\n    reg [$clog2(N+1)-1:0] pass_cnt;\n\n    // Pair index: on each pass, we compare-swap one pair per clock\n    reg [$clog2(N/2+1)-1:0] pair_idx;\n\n    // We'll compute how many pairs to process in a pass combinationally\n    wire [$clog2(N/2+1)-1:0] pairs_in_this_pass;\n\n    // ----------------------------------------------------------\n    // Combinational Logic for pairs_in_this_pass\n    // ----------------------------------------------------------\n    // For an even N:\n    //   - On even-numbered passes (pass_cnt[0] == 0), we compare (0,1), (2,3), ...\n    //     => that\u2019s N/2 pairs\n    //   - On odd-numbered passes (pass_cnt[0] == 1), we compare (1,2), (3,4), ...\n    //     => that\u2019s (N/2) - 1 pairs\n    //\n    assign pairs_in_this_pass = (pass_cnt[0] == 1'b0) \n                                ? (N/2) \n                                : ( (N/2) > 0 ? (N/2) - 1 : 0 ); // safety check\n\n    // ----------------------------------------------------------\n    // Next-State Logic\n    // ----------------------------------------------------------\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = LOAD;\n            end\n\n            LOAD: begin\n                // After loading input data, go to SORT state\n                next_state = SORT;\n            end\n\n            SORT: begin\n                // Once we've completed N passes, sorting is done\n                if (pass_cnt == N) \n                    next_state = DONE;\n            end\n\n            DONE: begin\n                // Optionally return to IDLE if desired\n                // For a one-shot, we can just stay in DONE unless reset\n                // Here, we return to IDLE if start is deasserted\n                if (!start)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // ----------------------------------------------------------\n    // Sequential State Update\n    // ----------------------------------------------------------\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // ----------------------------------------------------------\n    // Main Control: pass_cnt, pair_idx, and compare-swap\n    // ----------------------------------------------------------\n    integer i;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done      <= 1'b0;\n            pass_cnt  <= 0;\n            pair_idx  <= 0;\n        end\n        else begin\n            case (state)\n\n                //--------------------------------------\n                // IDLE: wait for start, clear signals\n                //--------------------------------------\n                IDLE: begin\n                    done     <= 1'b0;\n                    pass_cnt <= 0;\n                    pair_idx <= 0;\n                end\n\n                //--------------------------------------\n                // LOAD: capture input data into array\n                //--------------------------------------\n                LOAD: begin\n                    // Load all N elements from in_data\n                    for (i = 0; i < N; i = i + 1) begin\n                        data_array[i] <= in_data[i*WIDTH +: WIDTH];\n                    end\n                    // Initialize counters\n                    pass_cnt <= 0;\n                    pair_idx <= 0;\n                end\n\n                //--------------------------------------\n                // SORT: perform Brick Sort passes\n                //--------------------------------------\n                SORT: begin\n                    // Compare-swap the current pair\n                    // Check if we are within the valid pair range\n                    if (pair_idx < pairs_in_this_pass) begin\n                        // Distinguish odd-even pass from even-odd pass\n                        if (pass_cnt[0] == 1'b0) begin\n                            // Odd-even pass => pair = (2*pair_idx, 2*pair_idx+1)\n                            if (data_array[2*pair_idx] > data_array[2*pair_idx+1]) begin\n                                // Swap\n                                {data_array[2*pair_idx], data_array[2*pair_idx+1]} \n                                    <= {data_array[2*pair_idx+1], data_array[2*pair_idx]};\n                            end\n                        end \n                        else begin\n                            // Even-odd pass => pair = (2*pair_idx+1, 2*pair_idx+2)\n                            if ((2*pair_idx+2) < N) begin\n                                if (data_array[2*pair_idx+1] > data_array[2*pair_idx+2]) begin\n                                    // Swap\n                                    {data_array[2*pair_idx+1], data_array[2*pair_idx+2]} \n                                        <= {data_array[2*pair_idx+2], data_array[2*pair_idx+1]};\n                                end\n                            end\n                        end\n                    end\n\n                    // Increment pair_idx or move to next pass\n                    if (pair_idx + 1 == pairs_in_this_pass) begin\n                        // Completed all pairs in this pass -> next pass\n                        pass_cnt <= pass_cnt + 1;\n                        pair_idx <= 0;\n                    end else begin\n                        // Still more pairs to process\n                        pair_idx <= pair_idx + 1;\n                    end\n\n                end // SORT\n\n                //--------------------------------------\n                // DONE: output final data, assert done\n                //--------------------------------------\n                DONE: begin\n                    done <= 1'b1;\n                    // Drive out_data from data_array\n                    for (i = 0; i < N; i = i + 1) begin\n                        out_data[i*WIDTH +: WIDTH] <= data_array[i];\n                    end\n                end\n\n            endcase\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sorting_engine.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sorting_engine.sv\nTOPLEVEL        = sorting_engine\nMODULE          = test_sorting_engine\nPYTHONPATH      = /src\nHASH            = 45-rtl-assertion-brick-sort", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\ntest_space      = [4,8,12,16]\n\n@pytest.mark.parametrize(\"WIDTH\", [random.choice(test_space)])\n@pytest.mark.parametrize(\"N\", [random.choice(test_space)])\ndef test_runner(WIDTH,N):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    parameters = { \"WIDTH\": WIDTH, \"N\": N }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# if __name__ == \"__main__\":\n#     test_simulate()", "src/test_sorting_engine.py": "###############################################################################\n# test_sorting_engine.py\n#\n# Cocotb testbench for the Brick Sort (odd-even sort) RTL module.\n# This version is compatible with older cocotb versions that do not have\n# certain APIs (e.g. cocotb.result.TestSkip, cocotb.utils.get_sim_time).\n###############################################################################\nimport random\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\n\n\n###############################################################################\n# Utility Functions\n###############################################################################\ndef list_to_bus(values, width):\n    \"\"\"\n    Pack a list of integers into a single integer bus.\n\n    values: list of integers\n    width: bit-width of each integer\n    returns: integer with bits concatenated in [values[0], values[1], ...] order\n    \"\"\"\n    total_value = 0\n    for i, val in enumerate(values):\n        total_value |= (val & ((1 << width) - 1)) << (i * width)\n    return total_value\n\ndef bus_to_list(bus_value, width, n):\n    \"\"\"\n    Unpack a single integer bus into a list of integers.\n\n    bus_value: integer representing concatenated data\n    width: bit-width of each element\n    n: number of elements\n    returns: list of integers extracted from bus_value\n    \"\"\"\n    values = []\n    mask = (1 << width) - 1\n    for i in range(n):\n        chunk = (bus_value >> (i * width)) & mask\n        values.append(chunk)\n    return values\n\nasync def apply_reset(dut, cycles=2):\n    \"\"\"\n    Assert and deassert reset for a given number of clock cycles.\n    \"\"\"\n    dut.rst.value = 1\n    dut.start.value = 0\n    dut.in_data.value = 0\n    for _ in range(cycles):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n\n###############################################################################\n# Tests\n###############################################################################\n@cocotb.test()\nasync def test_basic_sort(dut):\n    \"\"\"\n    Test a simple random set of values and verify the DUT's sorting.\n    Also measure latency (in cycles) between start and done.\n    \"\"\"\n    # Parameters from DUT\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    # Generate clock (10 ns period)\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Apply reset\n    await apply_reset(dut)\n\n    # Prepare random input data\n    input_values = [random.randint(0, (1 << WIDTH) - 1) for _ in range(N)]\n    dut.in_data.value = list_to_bus(input_values, WIDTH)\n\n    # Assert start for one clock cycle\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure cycles until done\n    cycle_count = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle_count += 1\n        if dut.done.value == 1:\n            break\n\n    out_data = dut.out_data.value\n    output_values = bus_to_list(out_data, WIDTH, N)\n\n    # Check correctness\n    ref_sorted = sorted(input_values)\n    assert output_values == ref_sorted, (\n        f\"ERROR: DUT output={output_values} expected={ref_sorted}\"\n    )\n    # Latency check (same approach as above)\n    overhead = 4\n    expected_latency = (N * (N - 1)) // 2 + overhead\n    assert cycle_count == expected_latency, (\n        f\"Actual Latency: {cycle_count} Expected latency {expected_latency} for N={N}\"\n    )\n\n    dut._log.info(f\"[BASIC SORT] Input        : {input_values}\")\n    dut._log.info(f\"[BASIC SORT] DUT Output   : {output_values}\")\n    dut._log.info(f\"[BASIC SORT] Reference    : {ref_sorted}\")\n    dut._log.info(f\"[BASIC SORT] Latency(cycles) = {cycle_count}\")\n\n\n@cocotb.test()\nasync def test_already_sorted(dut):\n    \"\"\"\n    Test the engine with an already sorted array (ascending).\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    #await apply_reset(dut)\n\n    # Already sorted input (0,1,2,...,N-1)\n    input_values = list(range(N))\n    dut.in_data.value = list_to_bus(input_values, WIDTH)\n\n    # Start\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Wait for done\n    while True:\n        await RisingEdge(dut.clk)\n        if dut.done.value == 1:\n            break\n\n    out_data = dut.out_data.value\n    output_values = bus_to_list(out_data, WIDTH, N)\n\n    # Verify\n    assert output_values == input_values, (\n        f\"Sorted test failed, got {output_values}, expected {input_values}\"\n    )\n\n\n@cocotb.test()\nasync def test_reverse_sorted(dut):\n    \"\"\"\n    Test with reverse-sorted data to see if it sorts properly.\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    #await apply_reset(dut)\n\n    # Reverse sorted input (N-1,N-2,...,0)\n    input_values = list(range(N - 1, -1, -1))\n    dut.in_data.value = list_to_bus(input_values, WIDTH)\n\n    # Start\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Wait for done\n    while True:\n        await RisingEdge(dut.clk)\n        if dut.done.value == 1:\n            break\n\n    out_data = dut.out_data.value\n    output_values = bus_to_list(out_data, WIDTH, N)\n    ref_sorted = sorted(input_values)\n\n    assert output_values == ref_sorted, (\n        f\"Reverse sorted test failed, got {output_values}, expected {ref_sorted}\"\n    )\n\n@cocotb.test()\nasync def test_all_equal(dut):\n    \"\"\"\n    Test the engine with all elements equal.\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    #await apply_reset(dut)\n\n    # All equal\n    val = random.randint(0, (1 << WIDTH) - 1)\n    input_values = [val] * N\n    dut.in_data.value = list_to_bus(input_values, WIDTH)\n\n    # Start\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Wait for done\n    while True:\n        await RisingEdge(dut.clk)\n        if dut.done.value == 1:\n            break\n\n    out_data = dut.out_data.value\n    output_values = bus_to_list(out_data, WIDTH, N)\n\n    assert output_values == input_values, (\n        f\"All equal test failed, got {output_values}, expected {input_values}\"\n    )\n\n@cocotb.test()\nasync def test_random_cases(dut):\n    \"\"\"\n    Perform multiple random test vectors to gain coverage.\n    Measure and report latency for each.\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    NUM_RANDOM_TESTS = 5\n\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    for test_idx in range(NUM_RANDOM_TESTS):\n        # Reset\n        #await apply_reset(dut)\n\n        # Generate random input\n        input_values = [random.randint(0, (1 << WIDTH) - 1) for _ in range(N)]\n        dut.in_data.value = list_to_bus(input_values, WIDTH)\n\n        # Start\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        # Count cycles until done\n        cycle_count = 0\n        while True:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n            if dut.done.value == 1:\n                break\n\n        out_data = dut.out_data.value\n        output_values = bus_to_list(out_data, WIDTH, N)\n        ref_sorted = sorted(input_values)\n\n        assert output_values == ref_sorted, (\n            f\"[RANDOM {test_idx}] got {output_values}, expected {ref_sorted}\"\n        )\n        \n        # Latency check (same approach as above)\n        overhead = 4\n        expected_latency = (N * (N - 1)) // 2 + overhead\n        assert cycle_count == expected_latency, (\n            f\"[RANDOM {test_idx}] Actual Latency: {cycle_count} Expected latency {expected_latency} for N={N}\"\n        )\n\n        dut._log.info(f\"[RANDOM {test_idx}] Input = {input_values}\")\n        dut._log.info(f\"[RANDOM {test_idx}] Output = {output_values}\")\n        dut._log.info(f\"[RANDOM {test_idx}] Latency (cycles) = {cycle_count}\")\n"}}}
{"id": "cvdp_copilot_sorter_0046", "categories": ["cid014", "medium"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `sorting_engine` module. The assertions should ensure that the module accurately implements the Selection sort algorithm.\n\n## **RTL Design Overview**  \n\n**Selection Sort** is a simple sorting algorithm that repeatedly selects the smallest element from the unsorted portion of an array and places it in its correct position in the sorted portion.\n\n## Algorithm Steps\n\n1. First find the smallest element and swap it with the first element. This way the smallest element is at its correct position.\n2. Then find the smallest among the remaining elements (or the second smallest) and swap it with the second element.\n3. Keep doing this until all elements are moved to the correct positions.\n\n### **Key Components of the Module**       \n\n**Parameters**\n- `N`  (Default is 8, Greater than 0): Number of elements to sort\n- `WIDTH`(Default is 8, Greater than 0): Bit-width of each input element\n\n**Port List**\n| Port Name               | Direction | Width          | Description                                                                                                                                                                                                                                                              |\n|-------------------------|-----------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `clk`                   | input     | 1 bit          | Main clock input. All operations occur on the rising edge of this signal.                                                                                                                                                                                                |\n| `rst`                   | input     | 1 bit          | Active high, asynchronous reset. When asserted, resets the internal state machine and registers to their initial states.                                                                                                                                                 |\n| `start`                 | input     | 1 bit          | Active high, pulse start signal to indicate that the input data is valid and that sorting should begin on the next clock cycle.                                                                                                                                          |\n| `[N*WIDTH-1:0] in_data` | input     | N * WIDTH bits | Input data bus containing the entire unsorted array. Each element has WIDTH bits, and there are N elements.                                                                                                                                                              |\n| `done`                  | output    | 1 bit          | Active high pulse, asserted for 1 clock cycle when the sorting is complete, indicating that `out_data` is now valid and stable. It will be set to 0 in case of a reset.                                                                                                  |\n| `[N*WIDTH-1:0] out_data`| output    | N * WIDTH bits | Output data bus containing the sorted array. This is to be left uninitialized at reset and updated only when sorting a valid input is complete. Valid once `done` is asserted, and maintains previous values until the update from the next sorting operation completes. |\n\n- Assume that all the numbers will be non-negative integers.\n- Assume `N` is an even integer greater than 2.\n---\n\n### Latency Considerations\n\nTotal latency = ((N) * (N - 1)) / 2 + 3*(N-1) + 3\n  \n- **Output**: Once the sorting finishes, the sorted array is presented at the output port. This involves placing the sorted values back onto an output bus.\n\n### FSM Transitions\n- **IDLE:** If `start` is asserted move to the next state `LOAD`.\n- **LOAD:** Move to the next state `FIND` at the next clock cycle.\n- **FIND:**  Move to the next state `CHECK` at the next clock cycle.\n- **CHECK:** Move to the next state `SWAP` if j == N-1.\n- **SWAP:** Move to the next state `NEXT` at the next clock cycle.\n- **NEXT:** Move to the next state `DONE` if i == N-2 else next state is `FIND`.\n- **DONE:** Move to the next state `IDLE` at the next clock cycle.\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Verify all state transitions**\n- **Correct assertion and deassertion of `Done` signal:** \n   - When in the IDLE state, the 'done' signal must remain low.  \n   - The 'done' output must be asserted only when the state machine is in the DONE state.\n   - Whenever 'start' is asserted, the state machine must eventually reach the DONE state\n- **Final sorted order in `array` at `DONE`:** Once we enter the `DONE` state, we expect the entire internal array (array[0..N-1]) to be sorted in non-decreasing order.\n- **Verify correct operation of `SWAP` state:** In the SWAP state, if a swap is needed then the lowest value element from the unsorted array should be found at the lowest available index (first position of the unsorted section) in the next cycle. \n- **Sorting latency:** The latency for sorting an input should not exceed the expected latency mentioned above.\n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,\n    parameter WIDTH = 8\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    typedef enum logic [2:0] {\n        IDLE  = 3'd0,\n        LOAD  = 3'd1,\n        FIND  = 3'd2,\n        CHECK = 3'd3,\n        SWAP  = 3'd4,\n        NEXT  = 3'd5,\n        DONE  = 3'd6\n    } state_t;\n\n    state_t current_state, next_state;\n\n    reg [WIDTH-1:0] data_array [0:N-1];\n\n    reg [$clog2(N)-1:0] i;\n    reg [$clog2(N)-1:0] j;\n    reg [$clog2(N)-1:0] min_idx;\n\n    reg [WIDTH-1:0] min_val;\n    integer idx;\n    integer k;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = current_state;\n        case (current_state)\n            IDLE: begin\n                if (start)\n                    next_state = LOAD;\n            end\n\n            LOAD: begin\n                next_state = FIND;\n            end\n\n            FIND: begin\n                next_state = CHECK;\n            end\n\n            CHECK: begin\n                if (j == N-1)\n                    next_state = SWAP;\n                else\n                    next_state = CHECK;\n            end\n\n            SWAP: begin\n                next_state = NEXT;\n            end\n\n            NEXT: begin\n                if (i == N-2)\n                    next_state = DONE;\n                else\n                    next_state = FIND;\n            end\n\n            DONE: begin\n                next_state = IDLE;\n            end\n\n            default: next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done     <= 1'b0;\n            out_data <= {N*WIDTH{1'b0}};\n        end\n        else begin\n            done <= (current_state == DONE);\n\n            if (current_state == DONE) begin\n                for (idx = 0; idx < N; idx = idx + 1) begin\n                    out_data[idx*WIDTH +: WIDTH] <= data_array[idx];\n                end\n            end\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            for (k = 0; k < N; k = k + 1) begin\n                data_array[k] <= {WIDTH{1'b0}};\n            end\n            i       <= 0;\n            j       <= 0;\n            min_idx <= 0;\n            min_val <= {WIDTH{1'b0}};\n        end\n        else begin\n            case (current_state)\n\n                IDLE: begin\n                end\n\n                LOAD: begin\n                    for (k = 0; k < N; k = k + 1) begin\n                        data_array[k] <= in_data[k*WIDTH +: WIDTH];\n                    end\n                    i       <= 0;\n                    j       <= 0;\n                    min_idx <= 0;\n                    min_val <= {WIDTH{1'b0}};\n                end\n\n                FIND: begin\n                    j          <= i + 1;\n                    min_idx    <= i;\n                    min_val    <= data_array[i];\n                end\n\n                CHECK: begin\n                    if (data_array[j] < min_val) begin\n                        min_val    <= data_array[j];\n                        min_idx    <= j;\n                    end\n\n                    if (j < N-1) begin\n                        j <= j + 1;\n                    end\n                end\n\n                SWAP: begin\n                    if (min_idx != i) begin\n                        data_array[i]        <= data_array[min_idx];\n                        data_array[min_idx]  <= data_array[i];\n                    end\n                end\n\n                NEXT: begin\n                    i <= i + 1;\n                end\n\n                DONE: begin\n                end\n\n                default: begin\n                end\n            endcase\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sorting_engine.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sorting_engine.sv\nTOPLEVEL        = sorting_engine\nMODULE          = test_sorting_engine\nPYTHONPATH      = /src\nHASH            = 46-rtl-assertion-selection-sort", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\nvalid_params = []\nvalid_params.append((8,8))\n\n@pytest.mark.parametrize(\"WIDTH, N\", valid_params)\n\ndef test_runner(WIDTH,N):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    parameters = { \"WIDTH\": WIDTH, \"N\": N }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# if __name__ == \"__main__\":\n#     test_simulate()", "src/test_sorting_engine.py": "# ============================================================\n# test_sorting_engine.py\n#\n# Cocotb testbench for the \"sorting_engine\" module.\n# \n# This testbench demonstrates:\n#   1. Randomized tests\n#   2. Directed corner cases\n#   3. Latency measurements (clock cycles from start to done)\n#   4. Asserting that the latency == expected_latency (for a full selection sort)\n# ============================================================\n\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nimport math\n\n\n# ------------------------------------------------------------------------------\n# Helper function: reset the DUT\n# ------------------------------------------------------------------------------\nasync def reset_dut(dut, cycles=2):\n    \"\"\"Drive reset high for 'cycles' clock cycles, then deassert.\"\"\"\n    dut.rst.value = 1\n    for _ in range(cycles):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)  # Wait one more cycle after deassert\n\n\n# ------------------------------------------------------------------------------\n# Helper function: pack a list of integers into a single bus of width N*WIDTH\n# ------------------------------------------------------------------------------\ndef pack_data(data_list, width):\n    \"\"\"\n    data_list: list of integers\n    width:     number of bits per integer\n    \"\"\"\n    packed = 0\n    for i, val in enumerate(data_list):\n        w = int(width)\n        packed |= (val & ((1 << w) - 1)) << (i * w)\n    return packed\n\n\n# ------------------------------------------------------------------------------\n# Helper function: unpack a single bus of width N*WIDTH into a list of integers\n# ------------------------------------------------------------------------------\ndef unpack_data(packed, n, width):\n    \"\"\"\n    packed: integer that holds N elements\n    n:      number of elements\n    width:  number of bits per element\n    \"\"\"\n    data_list = []\n    w = int(width)\n    mask = (1 << w) - 1\n    for i in range(n):\n        val = (packed >> (i * w)) & mask\n        data_list.append(val)\n    return data_list\n\n\n# ------------------------------------------------------------------------------\n# Compute expected latency for the full selection sort hardware\n# ------------------------------------------------------------------------------\ndef expected_latency(n):\n    \"\"\"\n    Returns the expected total cycle count (from the cycle after 'start' \n    is deasserted to the first cycle 'done' is high).\n    \"\"\"\n    # \n    # Formula: 1 + sum_{i=0..n-2}[ (n-1 - i) + 3 ] + 1\n    # = 1 + (n-1)*n/2 + 3*(n-1) + 1\n    # = (n-1)*n/2 + 3(n-1) + 2\n    #\n    # For integer math in Python:\n    return 1 + ((n - 1) * n // 2 + 3 * (n - 1)) + 1 + 1\n\n\n@cocotb.test()\nasync def test_sorting_engine_random(dut):\n    \"\"\"\n    Test #1: Random data, checking correctness and latency\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    # Start clock\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    \n    await reset_dut(dut)\n\n    # Generate random data\n    random_data = [random.randint(0, (1 << WIDTH) - 1) for _ in range(N)]\n    dut.in_data.value = pack_data(random_data, WIDTH)\n\n    # Start sorting\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure latency in clock cycles\n    cycle_count = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle_count += 1\n        if dut.done.value == 1:\n            break\n\n    # Check sorting correctness\n    out_list = unpack_data(dut.out_data.value, N, WIDTH)\n    sorted_ref = sorted(random_data)\n    assert out_list == sorted_ref, (\n        f\"ERROR: Output not sorted.\\n\"\n        f\"Input   = {random_data}\\n\"\n        f\"Got     = {out_list}\\n\"\n        f\"Expected= {sorted_ref}\"\n    )\n\n    # Check latency == expected\n    exp = expected_latency(N)\n    assert cycle_count == exp, (\n        f\"Latency mismatch for random data:\\n\"\n        f\"Measured: {cycle_count}, Expected: {exp}\"\n    )\n\n    print(f\"[Random Data] PASS: Sorted in {cycle_count} cycles (expected {exp}).\")\n\n\n@cocotb.test()\nasync def test_sorting_engine_already_sorted(dut):\n    \"\"\"\n    Test #2: Already-sorted data\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Already-sorted data\n    if(WIDTH >= math.log(N,2)):\n        sorted_data = list(range(N))\n    else:\n        sorted_data = [random.randint(0, (1 << WIDTH) - 1) for _ in range(N)]\n    dut.in_data.value = pack_data(sorted_data, WIDTH)\n\n    # Start\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure latency\n    cycle_count = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle_count += 1\n        if dut.done.value == 1:\n            break\n\n    out_list = unpack_data(dut.out_data.value, N, WIDTH)\n    assert out_list == sorted(sorted_data), (\n        f\"ERROR: Output not sorted.\\n\"\n        f\"Input   = {sorted_data}\\n\"\n        f\"Got = {out_list}\\n\"\n        f\"Expected = {sorted_data}\"\n    )\n\n    # Check latency\n    exp = expected_latency(N)\n    assert cycle_count == exp, (\n        f\"Latency mismatch for already-sorted data:\\n\"\n        f\"Measured: {cycle_count}, Expected: {exp}\"\n    )\n\n    print(f\"[Already Sorted] PASS: Sorted in {cycle_count} cycles (expected {exp}).\")\n\n\n@cocotb.test()\nasync def test_sorting_engine_reverse_sorted(dut):\n    \"\"\"\n    Test #3: Reverse-sorted data (worst-case scenario)\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Reverse-sorted data\n    if(WIDTH >= math.log(N,2)):\n        rev_data = list(range(N - 1, -1, -1))\n    else:\n        rev_data = [random.randint(0, (1 << WIDTH) - 1) for _ in range(N)]\n    dut.in_data.value = pack_data(rev_data, WIDTH)\n\n    # Start\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure latency\n    cycle_count = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle_count += 1\n        if dut.done.value == 1:\n            break\n\n    out_list = unpack_data(dut.out_data.value, N, WIDTH)\n    assert out_list == sorted(rev_data), (\n        f\"ERROR: Output not sorted.\\n\"\n        f\"Input   = {rev_data}\\n\"\n        f\"Got = {out_list}\\n\"\n        f\"Expected = {sorted(rev_data)}\"\n    )\n\n    # Check latency\n    exp = expected_latency(N)\n    assert cycle_count == exp, (\n        f\"Latency mismatch for reverse-sorted data:\\n\"\n        f\"Measured: {cycle_count}, Expected: {exp}\"\n    )\n\n    print(f\"[Reverse Sorted] PASS: Sorted in {cycle_count} cycles (expected {exp}).\")\n\n\n@cocotb.test()\nasync def test_sorting_engine_all_equal(dut):\n    \"\"\"\n    Test #4: All elements the same\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n\n    # All elements equal\n    val = random.randint(0, (1 << WIDTH) - 1)\n    equal_data = [val for _ in range(N)]\n    dut.in_data.value = pack_data(equal_data, WIDTH)\n\n    # Start\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure latency\n    cycle_count = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle_count += 1\n        if dut.done.value == 1:\n            break\n\n    out_list = unpack_data(dut.out_data.value, N, WIDTH)\n    assert out_list == equal_data, (\n        f\"ERROR: Output not all-equal.\\n\"\n        f\"Input   = {equal_data}\\n\"\n        f\"Got = {out_list}\\n\"\n        f\"Expected = {equal_data}\"\n    )\n\n    # Check latency\n    exp = expected_latency(N)\n    assert cycle_count == exp, (\n        f\"Latency mismatch for all-equal data:\\n\"\n        f\"Measured: {cycle_count}, Expected: {exp}\"\n    )\n\n    print(f\"[All Equal] PASS: Output is unchanged, sorted in {cycle_count} cycles (expected {exp}).\")\n\n\n@cocotb.test()\nasync def test_sorting_engine_single_element(dut):\n    \"\"\"\n    Test #5: Single-element array (if N=1)\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    # If the DUT is not configured for N=1, skip\n    if N != 1:\n        return\n\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Single data\n    single_data = [random.randint(0, (1 << WIDTH) - 1)]\n    dut.in_data.value = pack_data(single_data, WIDTH)\n\n    # Start\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure latency\n    cycle_count = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle_count += 1\n        if dut.done.value == 1:\n            break\n\n    out_list = unpack_data(dut.out_data.value, N, WIDTH)\n    assert out_list == single_data, (\n        f\"ERROR: Single-element array was changed.\\n\"\n        f\"Input   = {single_data}\\n\"\n        f\"Got = {out_list}\\n\"\n        f\"Expected = {single_data}\"\n    )\n\n    # Check latency\n    exp = expected_latency(N)\n    assert cycle_count == exp, (\n        f\"Latency mismatch for single-element data:\\n\"\n        f\"Measured: {cycle_count}, Expected: {exp}\"\n    )\n\n    print(f\"[Single Element] PASS: No change, done in {cycle_count} cycles (expected {exp}).\")\n"}}}
{"id": "cvdp_copilot_sorter_0066", "categories": ["cid014", "medium"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `sorting_engine` module. The assertions should ensure that the module accurately implements the Bitonic sort algorithm.\n\n## **RTL Design Overview**  \n\n**Bitonic Sort** is a comparison-based sorting algorithm particularly suited for hardware (e.g., FPGAs, ASICs) and parallel architectures. It constructs sequences that are \u201cbitonic\u201d.\n- A bitonic sequence is a list of numbers that first increases and then decreases (or vice versa). This means that there exists an index i such that all elements before i are in ascending order, and all elements after i are in descending order.\n\n## Algorithm Steps\n\nBelow is an outline of how bitonic sort proceeds for \\( N = 2^k \\) elements:\n\n1. **Construct Bitonic Subsequences**  \n   - Recursively form smaller sorted subsequences. The algorithm arranges them so that one subsequence is sorted in ascending order and the other in descending order, thereby forming a **bitonic** sequence.\n\n2. **Bitonic Merge**  \n   - Once a sequence is bitonic, it can be fully sorted (in ascending or descending order) by a cascade of compare-and-swap operations that progressively reduce the bitonic sequence length until the entire array is sorted.\n\n3. **Recursive / Iterative Stages**  \n   - If we\u2019re dealing with ( N ) elements, we typically have (log_2(N)) stages of building bitonic sequences and (log_2(N)) stages of merging. In hardware, this often translates to a series of **pipeline** stages, each performing some pattern of compare-swap pairs.\n\n\n### **Key Components of the Module**       \n\n**Parameters**\n- `WIDTH`(Default is 8, Greater than 0): Bit-width of each input element\n\n**Port List**\n| Port Name               | Direction | Width          | Description                                                                                                                                                                                                                                                              |\n|-------------------------|-----------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `clk`                   | input     | 1 bit          | Main clock input. All operations occur on the rising edge of this signal.                                                                                                                                                                                                |\n| `rst`                   | input     | 1 bit          | Active high, asynchronous reset. When asserted, resets the internal state machine and registers to their initial states.                                                                                                                                                 |\n| `start`                 | input     | 1 bit          | Active high, pulse start signal to indicate that the input data is valid and that sorting should begin on the next clock cycle.                                                                                                                                          |\n| `[8*WIDTH-1:0] in_data` | input     | 8 * WIDTH bits | Input data bus containing the entire unsorted array. Each element has WIDTH bits, and there are 8 elements.                                                                                                                                                              |\n| `done`                  | output    | 1 bit          | Active high pulse, asserted for 1 clock cycle when the sorting is complete, indicating that `out_data` is now valid and stable. It will be set to 0 in case of a reset.                                                                                                  |\n| `[8*WIDTH-1:0] out_data`| output    | 8 * WIDTH bits | Output data bus containing the sorted array. This is initialized to 0 at reset and updated only when sorting a valid input is complete. Valid once `done` is asserted, and maintains previous values until the update from the next sorting operation completes.         |\n\n- Assume that all the numbers will be non-negative integers.\n---\n\n### Latency Considerations\n\nTotal latency = 9\n  \n- **Output**: Once the sorting finishes, the sorted array is presented at the output port. This involves placing the sorted values back onto an output bus.\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Bitonic Sequence formation:** Verify a bitonic sequence is formed at the correct step.\n- **Bitonic sequence sorting:** Verify the bitonic sequence is correctly sorted when done is high.\n- **One-cycle done pulse and only after `DONE` state:** The done signal should be high for only one clock cycle and only after `DONE` state.\n- **Sort latency:** Make sure the module latency is correct.\n- **State sequence:** After a 'start' is asserted in `cycle` clock cycle, the state machine must follow this sequence: `cycle`+1: SETUP, `cycle`+2: SORT, and `cycle`+8: DONE.\n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/sorting_engine.sv": "module sorting_engine #(parameter WIDTH = 8)(\n    input                     clk,\n    input                     rst,\n    input                     start,      // Start the sort when start=1\n    input  [8*WIDTH-1:0]      in_data,    // 8 inputs, each WIDTH bits\n    output reg                done,\n    output reg [8*WIDTH-1:0]  out_data    // 8 outputs, sorted in_data ascending order\n);\n\n    //////////////////////////////////////////////////////////////////////////\n    // FSM States\n    //////////////////////////////////////////////////////////////////////////\n    localparam  START = 3'b000,\n                SETUP = 3'b001,\n                SORT  = 3'b010,\n                DONE  = 3'b011;\n\n    reg [2:0] state;   // Current FSM state\n    reg [2:0] step;    // Step counter within the SORT state\n\n    // An 8-element array for local sorting\n    // Each element is WIDTH bits\n    reg [WIDTH-1:0] d [0:7];\n\n    integer i;  // For loops\n\n    //////////////////////////////////////////////////////////////////////////\n    // Synchronous FSM\n    //////////////////////////////////////////////////////////////////////////\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state     <= START;\n            step      <= 3'd0;\n            done      <= 1'b0;\n            out_data  <= {8*WIDTH{1'b0}};\n            // Initialize 'd' array\n            for (i = 0; i < 8; i = i + 1) begin\n                d[i]  <= {WIDTH{1'b0}};\n            end\n        end\n        else begin\n            case (state)\n                //////////////////////////////////////////////////////////////////\n                // START: Wait for start to go high. Then move to SETUP.\n                //////////////////////////////////////////////////////////////////\n                START: begin\n                    done <= 1'b0;\n                    if (start) begin\n                        state <= SETUP;\n                        step  <= 3'd0;\n                    end\n                    else begin\n                        state <= START; // remain\n                    end\n                end\n\n                //////////////////////////////////////////////////////////////////\n                // SETUP: Copy the 8 inputs into d[0..7]. Then go to SORT.\n                //////////////////////////////////////////////////////////////////\n                SETUP: begin\n                    for (i = 0; i < 8; i = i + 1) begin\n                        d[i] <= in_data[(i+1)*WIDTH - 1 -: WIDTH];\n                    end\n                    step  <= 3'd0;\n                    state <= SORT;\n                end\n\n                //////////////////////////////////////////////////////////////////\n                // SORT: Perform the bitonic compare-swap sequence (6 steps).\n                //////////////////////////////////////////////////////////////////\n                SORT: begin\n                    case (step)\n                        // Step 0:\n                        //   (0,1), (2,3), (4,5), (6,7)\n                        3'd0: begin\n                            if (d[0] > d[1]) begin\n                                d[0] <= d[1];\n                                d[1] <= d[0];\n                            end\n                            if (d[2] < d[3]) begin\n                                d[2] <= d[3];\n                                d[3] <= d[2];\n                            end\n                            if (d[4] > d[5]) begin\n                                d[4] <= d[5];\n                                d[5] <= d[4];\n                            end\n                            if (d[6] < d[7]) begin\n                                d[6] <= d[7];\n                                d[7] <= d[6];\n                            end\n                            step <= step + 1'b1;\n                        end\n\n                        // Step 1:\n                        //   (0,2), (1,3), (4,6), (5,7)\n                        3'd1: begin\n                            if (d[0] > d[2]) begin\n                                d[0] <= d[2];\n                                d[2] <= d[0];\n                            end\n                            if (d[1] > d[3]) begin\n                                d[1] <= d[3];\n                                d[3] <= d[1];\n                            end\n                            if (d[4] < d[6]) begin\n                                d[4] <= d[6];\n                                d[6] <= d[4];\n                            end\n                            if (d[5] < d[7]) begin\n                                d[5] <= d[7];\n                                d[7] <= d[5];\n                            end\n                            step <= step + 1'b1;\n                        end\n\n                        // Step 2:\n                        //   (0,1), (2,3), (4,5), (6,7)\n                        3'd2: begin\n                            if (d[0] > d[1]) begin\n                                d[0] <= d[1];\n                                d[1] <= d[0];\n                            end\n                            if (d[2] > d[3]) begin\n                                d[2] <= d[3];\n                                d[3] <= d[2];\n                            end\n                            if (d[4] < d[5]) begin\n                                d[4] <= d[5];\n                                d[5] <= d[4];\n                            end\n                            if (d[6] < d[7]) begin\n                                d[6] <= d[7];\n                                d[7] <= d[6];\n                            end\n                            step <= step + 1'b1;\n                        end\n\n                        // Step 3:\n                        //   (0,4), (1,5), (2,6), (3,7)\n                        //   Ascending for even blocks, descending for odd blocks.\n                        3'd3: begin\n                            // For 8 total, let's assume we want all ascending:\n                            if (d[0] > d[4]) begin\n                                d[0] <= d[4];\n                                d[4] <= d[0];\n                            end\n                            if (d[1] > d[5]) begin\n                                d[1] <= d[5];\n                                d[5] <= d[1];\n                            end\n                            if (d[2] > d[6]) begin\n                                d[2] <= d[6];\n                                d[6] <= d[2];\n                            end\n                            if (d[3] > d[7]) begin\n                                d[3] <= d[7];\n                                d[7] <= d[3];\n                            end\n                            step <= step + 1'b1;\n                        end\n\n                        // Step 4:\n                        //   (0,2), (1,3), (4,6), (5,7)\n                        3'd4: begin\n                            if (d[0] > d[2]) begin\n                                d[0] <= d[2];\n                                d[2] <= d[0];\n                            end\n                            if (d[1] > d[3]) begin\n                                d[1] <= d[3];\n                                d[3] <= d[1];\n                            end\n                            if (d[4] > d[6]) begin\n                                d[4] <= d[6];\n                                d[6] <= d[4];\n                            end\n                            if (d[5] > d[7]) begin\n                                d[5] <= d[7];\n                                d[7] <= d[5];\n                            end\n                            step <= step + 1'b1;\n                        end\n\n                        // Step 5:\n                        //   (0,1), (2,3), (4,5), (6,7)\n                        3'd5: begin\n                            if (d[0] > d[1]) begin\n                                d[0] <= d[1];\n                                d[1] <= d[0];\n                            end\n                            if (d[2] > d[3]) begin\n                                d[2] <= d[3];\n                                d[3] <= d[2];\n                            end\n                            if (d[4] > d[5]) begin\n                                d[4] <= d[5];\n                                d[5] <= d[4];\n                            end\n                            if (d[6] > d[7]) begin\n                                d[6] <= d[7];\n                                d[7] <= d[6];\n                            end\n                            step  <= 3'd0;    // reset step\n                            state <= DONE;    // sorting complete\n                        end\n\n                        // Default\n                        default: begin\n                            step  <= 3'd0;\n                            state <= DONE;\n                        end\n                    endcase\n                end\n\n                //////////////////////////////////////////////////////////////////\n                // DONE: Latch the sorted data to 'out_data', assert done = 1.\n                //       Then go to START.\n                //////////////////////////////////////////////////////////////////\n                DONE: begin\n                    // Write final sorted data out_data\n                    for (i = 0; i < 8; i = i + 1) begin\n                        out_data[i*WIDTH +: WIDTH] <= d[i];\n                    end\n\n                    done   <= 1'b1;\n                    state  <= START;\n                end\n\n                //////////////////////////////////////////////////////////////////\n                // DEFAULT\n                //////////////////////////////////////////////////////////////////\n                default: begin\n                    state <= START;\n                end\n            endcase\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sorting_engine.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sorting_engine.sv\nTOPLEVEL        = sorting_engine\nMODULE          = test_sorting_engine\nPYTHONPATH      = /src\nHASH            = 66-rtl-assertion-bitonic-sort", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.parametrize(\"WIDTH\", [random.randint(1, 32)])\ndef test_runner(WIDTH):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    parameters = { \"WIDTH\": WIDTH }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# if __name__ == \"__main__\":\n#     test_simulate()", "src/test_sorting_engine.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n# A helper function to split the bits from dut.out_data into a list of integers\n# Each element is WIDTH bits, total 8 elements => 8*WIDTH bits.\ndef unpack_output(dut, width=8):\n    out_val = int(dut.out_data.value)\n    elements = []\n    for i in range(8):\n        # Extract bits [(i*width) : (i+1)*width]\n        chunk = (out_val >> (i * width)) & ((1 << width) - 1)\n        elements.append(chunk)\n    return elements\n\n@cocotb.test()\nasync def test_sorting_engine(dut):\n    \"\"\" Test the sorting engine for various corner cases and random data, \n        making sure no input exceeds the DUT's bit-width. \"\"\"\n\n    # Create a clock on dut.clk with a period of 10ns\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Read the parameterized WIDTH from the DUT\n    WIDTH = int(dut.WIDTH.value)\n    N = 8  # Number of elements\n    EXPECTED_LATENCY = 9  # Matches your DUT's expected pipeline latency\n\n    # Compute the maximum representable value for 'WIDTH' bits\n    max_val = (1 << WIDTH) - 1\n\n    # Reset procedure\n    dut.rst.value = 1\n    dut.start.value = 0\n    dut.in_data.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n    # ---------------\n    # Helper function\n    # ---------------\n    async def apply_inputs_and_sort(data_list):\n        \"\"\"\n        Applies 'data_list' (length = 8) to dut.in_data, asserts 'start',\n        measures the clock cycles until 'done', and checks the sorted result.\n        \"\"\"\n        # Convert data_list to a single integer for dut.in_data\n        packed_val = 0\n        for i, val in enumerate(data_list):\n            # Ensure each value is within [0, max_val]\n            # (In practice, data_list is already clamped, \n            #  but this extra \"& max_val\" is harmless and safe.)\n            val_clamped = val & max_val  \n            packed_val |= val_clamped << (i * WIDTH)\n\n        # Drive the input\n        dut.in_data.value = packed_val\n\n        # Assert 'start' for 1 cycle\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        # Count cycles until done\n        cycle_count = 0\n        while True:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n            if dut.done.value == 1:\n                break\n\n        # Check the latency\n        assert cycle_count == EXPECTED_LATENCY, \\\n            f\"ERROR: Observed latency {cycle_count} != expected {EXPECTED_LATENCY}\"\n\n        # Now retrieve the output\n        result = unpack_output(dut, WIDTH)\n\n        # Check if output is sorted in ascending order\n        sorted_data = sorted(data_list)\n        if result != sorted_data:\n            # Sometimes reversing might fix indexing mismatches\n            if list(reversed(result)) == sorted_data:\n                pass  # Possibly your hardware packs the data in reverse order\n            else:\n                raise AssertionError(\n                    f\"ERROR: Output not sorted.\\n\"\n                    f\"Input = {data_list},\\n\"\n                    f\"DUT output = {result},\\n\"\n                    f\"Expected sorted = {sorted_data}.\"\n                )\n        print(f\"Input = {data_list},\\n\"\n              f\"DUT output = {result},\\n\"\n              f\"Expected sorted = {sorted_data}.\")\n\n        # Additional clock if you want to see 'done' high for a cycle\n        await RisingEdge(dut.clk)\n\n    # ---------------\n    #  Test Cases\n    # ---------------\n    # Always clamp data to [0..max_val], in case WIDTH < 3\n\n    # 1) Already-sorted input\n    data_sorted = [min(i, max_val) for i in range(N)]\n    await apply_inputs_and_sort(data_sorted)\n\n    # 2) Reverse-sorted input\n    data_reversed = [min(i, max_val) for i in reversed(range(N))]\n    await apply_inputs_and_sort(data_reversed)\n\n    # 3) All elements are the same\n    #    (If WIDTH = 1, '2' is out of range. So clamp to max_val.)\n    data_all_same = [min(2, max_val)] * N\n    await apply_inputs_and_sort(data_all_same)\n\n    # 4) All zero\n    data_zeros = [0]*N\n    await apply_inputs_and_sort(data_zeros)\n\n    # 5) All maximum for WIDTH bits\n    data_all_max = [max_val]*N\n    await apply_inputs_and_sort(data_all_max)\n\n    # 6) Random test: Repeat multiple times\n    for _ in range(10):\n        data_random = [random.randint(0, max_val) for _ in range(N)]\n        await apply_inputs_and_sort(data_random)\n\n    # 7) Mixed corner test: includes 0, max, random mid-values\n    #    Some values (13,15) might exceed max_val if WIDTH < 4, so clamp them\n    data_mixed_raw = [0, max_val, 1, (max_val // 2), 0, max_val, 13, 15]\n    data_mixed = [min(x, max_val) for x in data_mixed_raw]\n    await apply_inputs_and_sort(data_mixed)\n\n    # If we reach here without any assertion failures, the test passes.\n    cocotb.log.info(\"All test cases PASSED!\")\n"}}}
{"id": "cvdp_copilot_square_root_0008", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `square_root_seq` module. The assertions should ensure correct FSM transitions, root calculation, and termination conditions.  \n\n## **RTL Design Overview**  \nThe `square_root_seq` module implements a **sequential square root calculator** using **subtractive iteration**. It determines the integer square root of an input value by continuously subtracting odd numbers from the input number and counting how many times this can be done before the remainder becomes smaller than the current odd number.\n\n### **Key Components of the Module**  \n- **`state`**: FSM state (`IDLE` or `COMPUTE`).  \n- **`remainder`**: Holds the value being reduced through subtraction.  \n- **`odd`**: Tracks the next odd number to subtract from `remainder`.  \n- **`root`**: Holds the current computed square root value.  \n- **`final_root`**: Stores the final computed square root once the computation completes. `WIDTH/2` bit wide output.\n- **`done`**: Active high signal indicates when the computation is complete.  \n- **`clk`**: Clock signal. Design is synchronized to the posedge of this clock.  \n- **`rst`**: Asynchronous active-high reset signal.  \n- **`start`**: Active-high signal that initiates the computation.  \n- **`num`**: Input number for which the square root is computed. `WIDTH` bit wide input. \n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n\n- **FSM State Transition:**  \n  - The FSM must transition from `IDLE` to `COMPUTE` on the next rising clock edge after `start` is asserted.  \n\n- **Final Root Assignment:**  \n  - When `done` is asserted, `final_root` should **match the computed `root` value** from the previous clock cycle.  \n\n- **Root Increment Behavior:**  \n  - When `remainder >= odd` in `COMPUTE` state, `root` should **increment by 1** at the next clock cycle.  \n\n- **Odd Increment Behavior:**  \n  - When `remainder >= odd` in `COMPUTE` state, `odd` should **increment by 2** at the next clock cycle.  \n\n- **Computation Termination:**  \n  - `done` should be **asserted only when `remainder` is less than `odd`**, signaling the end of the computation.  \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.  ", "context": {"rtl/square_root_seq.sv": "module square_root_seq #(parameter WIDTH = 16) (\n    input clk, rst, start,\n    input wire [WIDTH-1:0] num,\n    output reg done,\n    output reg [WIDTH/2-1:0] final_root\n);\n   localparam IDLE = 1'b0;\n   localparam COMPUTE = 1'b1;\n   \n    reg [WIDTH-1:0] remainder;\n    reg [WIDTH-1:0] odd;\n    reg [WIDTH/2-1:0] root;\n    reg  state;\n    \n    always @(posedge clk or posedge rst) \n    begin\n        if (rst) \n        begin\n          state <= IDLE;\n          remainder <= {WIDTH{1'b0}};\n          odd <= 1; \n          root <= 0;\n          done <= 0;\n          final_root <= 0;\n        end \n        else \n        begin\n            case (state)\n                IDLE: \n                begin\n                    done <= 0;\n                    if (start) \n                    begin\n                        remainder <= num; \n                        odd <= 1; \n                        root <= 0;\n                        state <= COMPUTE; \n                    end\n                end\n                COMPUTE: \n                begin\n                    if (remainder >= odd) \n                    begin\n                        remainder <= remainder - odd; \n                        odd <= odd + 2; \n                        root <= root + 1; \n                    end \n                    else \n                    begin\n                        final_root <= root; \n                        done <= 1; \n                        state <= IDLE; \n                    end\n                end\n                default: \n                begin\n                  state <= IDLE;\n                  remainder <= {WIDTH{1'b0}};\n                  odd <= 1; \n                  root <= 0;\n                  done <= 0;\n                  final_root <= 0; \n                end\n            endcase \n        end\n    end\nendmodule"}}, "output": {"response": "", "context": {"rtl/square_root_seq.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/square_root_seq.sv\nTOPLEVEL        = square_root_seq\nMODULE          = test_square_root_seq\nPYTHONPATH      = /src\nHASH            = 8-rtl-assertion-for-squate-root", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner(WIDTH):\n    parameters = {\n        \"WIDTH\": WIDTH,\n    }\n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n\ndef get_powers_of_two_pairs(iterations):\n    value = 2\n    pairs = []\n    for _ in range(iterations):\n        pairs.append(value)\n        value *= 2\n    return pairs\n\n# Test the function\npairs = get_powers_of_two_pairs(1)\n#print(pairs)\n\n# random test\n@pytest.mark.parametrize(\"WIDTH\",pairs)\ndef test(WIDTH):\n    print(f'Running with: WIDTH = {WIDTH}')\n    call_runner(WIDTH)\n", "src/test_square_root_seq.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nimport math\n\nRANDOM_TESTCASE = 8;\n\nasync def expected_sqrt(value):\n    #Calculate the integer square root.\n    return int(math.isqrt(value))\n\n@cocotb.test()\nasync def test_square_root_seq(dut):\n    width = int(dut.WIDTH.value)\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Define golden latencies for each width and test case\n    golden_latencies = {\n        2:  {'MAX': 2, 'MIN': 1},\n        4:  {'MAX': 4, 'MIN': 1},\n        8:  {'MAX': 16, 'MIN': 1},\n        16: {'MAX': 256, 'MIN': 1},\n        32: {'MAX': 65536, 'MIN': 1}\n    }\n\n    dut.rst.value = 1  # Assert reset\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0  # Deassert reset\n\n    test_cases = [\n        {\"num\": (2**width) - 1, \"description\": \"MAX number\"},\n        {\"num\": 0, \"description\": \"MIN number\"}\n    ]\n\n    for test_case in test_cases:\n        await RisingEdge(dut.clk)\n        num = test_case[\"num\"]\n        dut.num.value = num\n        expected_root = await expected_sqrt(num)\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        # Initialize latency counter\n        latency = 0\n        # Wait for the operation to complete\n        while dut.done.value == 0:\n            await RisingEdge(dut.clk)\n            latency += 1\n\n        final_root = int(dut.final_root.value)\n        assert final_root == expected_root, f\"Test {test_case['description']} FAILED: Input = {num}, Calculated = {final_root}, Expected = {expected_root}\"\n        \n        # Get the expected golden latency for the current test\n        test_key = 'MAX' if num == (2**width) - 1 else 'MIN'\n        expected_latency = golden_latencies[width][test_key]\n\n        # Assert and log if latency mismatch\n        if latency != expected_latency:\n            dut._log.error(f\"Test {test_case['description']} FAILED: Latency mismatch, expected {expected_latency+1}, got {latency+1}\")\n            assert False, f\"Latency mismatch for test {test_case['description']} - expected {expected_latency+1}, got {latency+1}\"\n        else:\n            dut._log.info(f\"Test {test_case['description']} PASSED: Input = {num}, Calculated = {final_root}, Expected = {expected_root}, Latency = {latency+1} cycles\")\n            \n\n@cocotb.test()\nasync def test_square_root_seq(dut):\n    width = int(dut.WIDTH.value)\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Assert and deassert reset\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)  # Wait for a clock edge post reset deassertion\n\n    test_count = 0\n    # Define test cases including edge cases\n    test_values = [random.randint(0, (1 << width) - 1) for _ in range(RANDOM_TESTCASE-1)] + [(1 << width) - 1, 0]\n    #print(bin(test_values))\n    \n    for num in test_values:\n        dut.num.value = num\n        expected_root = await expected_sqrt(num)\n\n        # Initialize the test action\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n        \n        # Initialize latency counter\n        latency = 0\n        # Wait for the operation to complete\n        while dut.done.value == 0:\n            await RisingEdge(dut.clk)\n            latency += 1\n                \n        # Read the result and verify\n        final_root = int(dut.final_root.value)\n        if final_root == expected_root:\n            dut._log.info(f\"Test {test_count} PASSED: Input = {num}, Calculated = {final_root}, Expected = {expected_root}\")\n        else:\n            dut._log.error(f\"Test {test_count} FAILED: Input = {num}, Calculated = {final_root}, Expected = {expected_root}\")\n            assert final_root == expected_root, f\"Assertion failed for test {test_count}\"\n        \n        test_count += 1 \n         \n"}}}
{"id": "cvdp_copilot_sram_fd_0024", "categories": ["cid012", "easy"], "input": {"prompt": "Generate a SystemVerilog testbench named `cvdp_sram_fd_tb` that only generates stimulus, to systematically drive input signals to a **cvdp_sram_fd** module. The stimulus should comprehensively cover all valid read and write operations with constraints as mentioned below. \n\n---\n\n## Module Overview:\nThe **cvdp_sram_fd** module is a full-duplex, dual-port static RAM (SRAM) with independent read and write access on two separate ports (**Port A** and **Port B**). The memory has a configurable data width (`DATA_WIDTH`) and address width (`ADDR_WIDTH`). \n\n**Key Features:**\n- **Dual-port architecture**: Supports concurrent read/write operations on both ports.\n- **Synchronous operation**: Inputs are sampled on the rising edge of `clk`.\n- **Read-First behavior**: If a read and write happens at the same address in the same cycle, the read returns the old data before the write updates it.\n\n--- \n\n### **Parameters:**\n- `DATA_WIDTH (default: 8)`: Width of the data bus.\n- `ADDR_WIDTH (default: 4)`: Width of the address bus.\n- `RAM_DEPTH`: Determines the depth of the memory. It is derived using the `ADDR_WIDTH` parameter to match the full range of unique addresses possible with the given address width.\n\n### **Ports:**\n\n#### 1. Clock and Control Signal Inputs:\n- `clk`: System clock. All input transitions are synchronized to the **rising edge** of `clk`.  \n- `ce`: Chip enable (active high).\n   -  When `ce` is **low**, the memory ignores all inputs and does not perform read or write operations (`a_rdata` and `b_rdata` are set to zero).\n   -  When `ce` is **high**, the memory operates normally.\n\n#### 2. Port A:\n**Inputs:**\n- `a_we`: Write enable (active high).\n- `a_oe`: Read enable (active high).\n- `a_addr [ADDR_WIDTH-1:0]`: Address bus.\n- `a_wdata [DATA_WIDTH-1:0]`: Write data.\n\n**Output:**\n- `a_rdata [DATA_WIDTH-1:0]`: Read data output.\n\n#### 3. Port B:\n**Inputs:**\n- `b_we`: Write enable (active high).\n- `b_oe`: Read enable (active high).\n- `b_addr [ADDR_WIDTH-1:0]`: Address bus.\n- `b_wdata [DATA_WIDTH-1:0]`: Write data.\n\n**Output:**\n- `b_rdata [DATA_WIDTH-1:0]`: Read data output.\n\n\n#### 4.  Memory Array:\n   - The module consist of an internal memory array `mem` with depth `RAM_DEPTH` and width `DATA_WIDTH`.\n\n#### 5. Operational Behavior:\n\n   - **Port A Operations:**\n     - **Write Operation:**\n       - Occurs when `ce` and `a_we` are high.\n       - The data on `a_wdata` is written to the memory location specified by `a_addr`.\n     - **Read Operation:**\n       - Occurs when `ce` is high,  and `a_oe` is high.\n       - The data from the memory location specified by `a_addr` is loaded into `a_rdata`.\n       - `a_rdata` retains its previous value if `a_oe` is low while `ce` is high\n     - **Priority:**\n       - If both `a_we` and `a_oe` are high, the read operation takes precedence, where data previously stored at the address appears on the output while the input data is being stored in memory.\n     - **Timing:**\n       - **Write Latency:** 1 clock cycle.\n       - **Read Latency:** 1 clock cycle.\n\n   - **Port B Operations:**\n     - This port behaves same as Port A. The signals controlling this port are `b_we`, `b_oe`, `b_addr`, `b_wdata` and the output is driven on `b_rdata`.\n\n#### 6. Simultaneous Access Handling:\n   - The memory supports simultaneous operations on both ports, including:\n     - Reads on both ports.\n     - Writes on both ports.\n     - A read on one port and a write on the other.\n   - **Same Address Access:**\n     - **If both ports access the same address:**\n       - Read and write: Follow a \"read-first\" approach which means that if a write and read occur at the same address simultaneously, data previously stored at the address appears on the output while the input data is being stored in memory.\n       - Reads on both ports: Should be supported with both ports providing the same output data.\n       - It is assumed that the write access will not occur for the same address on both ports together. Such a collision is not handled. \n\n#### 7. Assumptions and Constraints:\n   - All inputs are synchronous and are sampled on the rising edge of `clk`.\n   - Input addresses (`a_addr`, `b_addr`) are within the valid range (`0` to `RAM_DEPTH - 1`).\n   - Data inputs (`a_wdata`, `b_wdata`) are valid when write enables (`a_we`, `b_we`) are high.\n   - If neither read nor write is enabled for a port during a clock cycle (with `ce` high), the port maintains its previous output state.\n\n#### 8. Boundary Conditions:\n - `DATA_WIDTH` and `ADDR_WIDTH` must be positive integers greater than zero.\n\n--- \n\n## **Testbench Requirements:**\n\n### **Module Instantiation:**\nThe **cvdp_sram_fd** module should be instantiated as `DUT`, with all input and output signals properly connected. The testbench must cover all possible scenarios to achieve 100% coverage.\n\n\n### **Stimuli Generation for Dual-Port SRAM Testbench:**  \n\n#### 1. Clock and Enable Control:\n- Generate a continuous clock signal with a period of 10 time units.  \n- Toggle `ce` periodically to simulate active/inactive states.  \n\n#### 2. Address and Data Generation:\n- **Address Sequences**  \n  - Use randomized or structured address sequences for `a_addr` and `b_addr`  for read and write operations.  \n\n- **Data Sequences**  \n  - Generate randomized `a_wdata` and `b_wdata` values.  \n  - Drive valid data only when write enable (`a_we`, `b_we`) is high.  \n\n#### 3. Different Scenarios:\n\n- **A.Independent Operations**\n  - **Single Port Write-Read:** Generate stimuli for Port A to write to a given address and read from the same address after the write is complete. Perform the same operation on port B\n\n- **B. Simultaneous Operations**  \n  - **Simultaneous Writes:** \n      - Generate stimuli to simultaneously write and read from the same port and from the same address.  \n      - Generate stimuli to simultaneously write from one port and read from the other at the same address.  \n      - Generate stimuli to simultaneously write from one port and read from the other at different addresses. \n\n- **C. Special Cases**  \n  - **Boundary Testing:** Generate stimuli to write at minimum (`0`) and maximum (`RAM_DEPTH-1`) addresses.  \n  - **Chip Enable Disabled:** Generate stimuli for `ce = 0`.  \n  - **Chip Enabled with no operation:** Generate stimuli for `ce = 1` with no read/write operations on either port. \n\n---\n\n**Expected Output:** \n\nA SystemVerilog testbench that generates varied input stimuli for the **cvdp_sram_fd** module according to the above specifications and allows different corner cases for extended testing scenarios. ", "context": {}}, "output": {"response": "", "context": {"verif/cvdp_sram_fd_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 24-tb-stimulus-sram_fd\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/cvdp_sram_fd.sv": "/**************************************************************************\nFILENAME:    cvdp_sram_fd.sv\nDESCRIPTION: This file contains the RTL for a full-duplex dual-port RAM in SystemVerilog.\nLATENCY:     Write latency = 1 clk cycle\n             Read  latency = 1 clk cycle\n**************************************************************************/\nmodule cvdp_sram_fd #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 4\n)(\n    input                         clk     , // clock input\n    input                         ce      , // chip enable\n    input                         a_we    , // channel A write enable\n    input                         a_oe    , // channel A output enable\n    input        [ADDR_WIDTH-1:0] a_addr  , // channel A address\n    input        [DATA_WIDTH-1:0] a_wdata , // channel A write data\n    output logic [DATA_WIDTH-1:0] a_rdata , // channel A read data out\n    input                         b_we    , // channel B write enable\n    input                         b_oe    , // channel B output enable\n    input        [ADDR_WIDTH-1:0] b_addr  , // channel B address\n    input        [DATA_WIDTH-1:0] b_wdata , // channel B write data\n    output logic [DATA_WIDTH-1:0] b_rdata   // channel B read data out\n);\n    // Setup RAM_DEPTH parameter\n    localparam RAM_DEPTH = 1 << ADDR_WIDTH;\n    // Memory array\n    logic [DATA_WIDTH-1:0] mem [0:RAM_DEPTH-1];\n    // Channel A operations\n    always_ff @(posedge clk) begin\n        if (ce) begin\n            if (a_oe) begin\n                a_rdata     <= mem[a_addr];\n            end\n            if (a_we) begin\n                mem[a_addr] <= a_wdata;\n            end\n        end else begin\n            a_rdata         <= 'b0;\n        end\n    end\n    // Channel B operations\n    always_ff @(posedge clk) begin\n        if (ce) begin\n            if (b_oe) begin\n                b_rdata     <= mem[b_addr];\n            end \n            if (b_we) begin\n                mem[b_addr] <= b_wdata;\n            end\n        end else begin\n            b_rdata         <= 'b0;\n        end\n    end\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/cvdp_sram_fd.sv /code/verif/cvdp_sram_fd_tb.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"DUT\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_sram_fd_0026", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the given testbench to validate the results of a **full-duplex dual-port Static Random Access Memory (SRAM)** design named `cvdp_sram_fd` that allows simultaneous read and write operations on two separate ports (Port A and Port B). The stimulus is already provided and the modification should implement the checker logic that validates the functionality of the design described below.\n\n## Design Details\n1. **Module Name:** `cvdp_sram_fd`\n\n2. **Parameters:**\n   - `DATA_WIDTH` (default value: 8): Defines the width of the data bus.\n   - `ADDR_WIDTH` (default value: 4): Defines the width of the address bus.\n   - **Derived Parameter:**\n     - `RAM_DEPTH`: Determines the depth of the memory. Should be derived using the ADDR_WIDTH parameter to match the full range of unique addresses possible with the given address width.\n\n3. **Ports:**\n\n   - **Clock and Control Signals:**\n     - `input clk`: Clock signal.\n     - `input ce`: Active-high chip enable signal.\n\n   - **Port A Signals:**\n     - `input a_we`: Active-high write enable for Port A.\n     - `input a_oe`: Active-high output (read) enable for Port A.\n     - `input [ADDR_WIDTH-1:0] a_addr`: Address bus for Port A.\n     - `input [DATA_WIDTH-1:0] a_wdata`: Write data bus for Port A.\n     - `output logic [DATA_WIDTH-1:0] a_rdata`: Read data output for Port A.\n\n   - **Port B Signals:**\n     - `input b_we`: Active-high write enable for Port B.\n     - `input b_oe`: Active-high output (read) enable for Port B.\n     - `input [ADDR_WIDTH-1:0] b_addr`: Address bus for Port B.\n     - `input [DATA_WIDTH-1:0] b_wdata`: Write data bus for Port B.\n     - `output logic [DATA_WIDTH-1:0] b_rdata`: Read data output for Port B.\n\n4. **Clock Behavior:**\n   - The module should operate on the **positive edge** of the clock signal `clk`.\n   - There is no reset signal; initial memory contents to be left undefined.\n\n5. **Chip Enable (`ce`):**\n   - When `ce` is **low**, the memory ignores all inputs and does not perform read or write operations (`a_rdata` and `b_rdata` should be set to zero).\n   - When `ce` is **high**, the memory operates normally.\n\n6. **Memory Array:**\n   - Implement an internal memory array `mem` with depth `RAM_DEPTH` and width `DATA_WIDTH`.\n\n7. **Operational Behavior:**\n\n   - **Port A Operations:**\n     - **Write Operation:**\n       - Occurs when `ce` and `a_we` are high.\n       - The data on `a_wdata` is written to the memory location specified by `a_addr`.\n     - **Read Operation:**\n       - Occurs when `ce` is high,  and `a_oe` is high.\n       - The data from the memory location specified by `a_addr` is loaded into `a_rdata`.\n       - `a_rdata` retains its previous value if `a_oe` is low while `ce` is high\n     - **Priority:**\n       - If both `a_we` and `a_oe` are high, the read operation takes precedence, where data previously stored at the address appears on the output while the input data is being stored in memory.\n     - **Timing:**\n       - **Write Latency:** 1 clock cycle.\n       - **Read Latency:** 1 clock cycle.\n\n   - **Port B Operations:**\n     - This port behaves same as Port A. The signals controlling this port are `b_we`, `b_oe`, `b_addr`, `b_wdata` and the output is driven on `b_rdata`.\n\n8. **Simultaneous Access Handling:**\n   - The memory should support simultaneous operations on both ports, including:\n     - Reads on both ports.\n     - Writes on both ports.\n     - A read on one port and a write on the other.\n   - **Same Address Access:**\n     - **If both ports access the same address:**\n       - Read and write: Follow a \"read-first\" approach which means that if a write and read occur at the same address simultaneously, data previously stored at the address appears on the output while the input data is being stored in memory.\n       - Reads on both ports: Should be supported with both ports providing the same output data.\n       - It is assumed that the write access will not occur for the same address on both ports together. Such a collision need not be handled. \n\n9. **Assumptions and Constraints:**\n   - All inputs are synchronous and are sampled on the rising edge of `clk`.\n   - Input addresses (`a_addr`, `b_addr`) are within the valid range (`0` to `RAM_DEPTH - 1`).\n   - Data inputs (`a_wdata`, `b_wdata`) are valid when write enables (`a_we`, `b_we`) are high.\n   - If neither read nor write is enabled for a port during a clock cycle (with `ce` high), the port maintains its previous output state.\n\n10. **Boundary Conditions:**\n    - **Data Width and Address Width:**\n      - `DATA_WIDTH` and `ADDR_WIDTH` must be positive integers greater than zero.\n\n\n## Testbench requirements:\n\n### Instantiation\n\n- Module Instance: The `cvdp_sram_fd` module is instantiated as `DUT`, with the input and output signals connected for testing.\n\n#### 1. Device Under Test (DUT)\n- **cvdp_sram_fd Instantiation**:\n  - cvdp_sram_fd module is already configured with the parameters for data and address widths.\n  - DUT is connected to the testbench signals for clock, control, and data handling.\n\n#### 2. Testbench Functionality\n- **Clock Generation**:\n  - Given testbench generates a continuous clock with a period of 10 ns (100 MHz frequency).\n- **Input Data Initialization and Driving**:\n  - Testbench intializes test data and control signals as input to the DUT.\n  - It sequentially loads data into the DUT and initiates the operation.\n\n#### 3. Test Procedures\n- **Deterministic Test Case**:\n  - Provide the given set of testcases as inputs to the design\n  - Add RTL code to perform checking of the output from the DUT and matching it with the expected output.\n  - Ensure RTL functionality described above (including operations on both ports, and simultaneous access) matches the expected output.\n  - Feed the input data and control signal to the DUT as required by different test cases.\n\n#### 4. Output Verification\n- **Comparison of DUT Output with Expected Result**:\n  - Use `$error` to report test failure if the outputs do not match.\n### 5. Simulation Control\n- Execute the test cases using procedural blocks, monitoring the process with appropriate delays and synchronization methods.\n- Use `$display` to log results and facilitate debugging.\n\n## Deliverables\nProvide a modified **complete SystemVerilog testbench** that effectively tests and verifies the `cvdp_sram_fd` module's functionality for the input data as expected.", "context": {"verif/cvdp_sram_fd_tb.sv": "module cvdp_sram_fd_tb ();\n   \n   localparam DATA_WIDTH = 8;\n   localparam ADDR_WIDTH = 4;\n   localparam RAM_DEPTH  = 1 << ADDR_WIDTH;\n   \n   logic  clk, ce, a_we, b_we, a_oe, b_oe;\n   logic  [DATA_WIDTH-1:0] a_wdata;  // Write data for Port A\n   logic  [DATA_WIDTH-1:0] a_rdata;  // Read data from Port A\n   logic  [ADDR_WIDTH-1:0] a_addr;   // Address for Port A\n   logic  [DATA_WIDTH-1:0] b_wdata;  // Write data for Port B\n   logic  [DATA_WIDTH-1:0] b_rdata;  // Read data from Port B\n   logic  [ADDR_WIDTH-1:0] b_addr;   // Address for Port B\n\n\ncvdp_sram_fd\n   #( .DATA_WIDTH(DATA_WIDTH),\n      .ADDR_WIDTH(ADDR_WIDTH)\n   ) DUT (\n      .clk           (clk),\n      .ce            (ce),\n      .a_we          (a_we),\n      .a_oe          (a_oe),\n      .a_addr        (a_addr),\n      .a_wdata       (a_wdata),\n      .a_rdata       (a_rdata),\n      .b_we          (b_we),\n      .b_oe          (b_oe),\n      .b_addr        (b_addr),\n      .b_wdata       (b_wdata),\n      .b_rdata       (b_rdata)\n   );\n\n   initial begin\n      clk = 0;\n      forever #5 clk = ~clk; \n   end\n   \n   // VCD Dump\n   initial begin\n      $dumpfile(\"cvdp_sram_fd_tb_1.vcd\");\n      $dumpvars(0, cvdp_sram_fd_tb);\n   end\n   \n   initial begin\n      ce     = 0;\n      a_we   = 0;\n      b_we   = 0;\n      a_oe   = 0;\n      b_oe   = 0;\n      a_addr = 0;\n      b_addr = 0;\n      a_wdata= 0;\n      b_wdata= 0;\n\n      repeat(2) @(posedge clk);\n\n      test_undefined_memory_content();\n\n      repeat(3) begin\n         \n         test_ce_low();\n\n         test_port_a_write_read();\n\n         test_port_b_write_read();\n\n         test_port_a_read_first();\n\n         test_simultaneous_ops_different_addresses();\n\n         test_simultaneous_ops_same_address();\n\n         test_no_operation_with_ce_high();\n\n         test_boundary_addresses();\n\n         test_data_retention();\n\n      end\n\n      $display(\"\\nAll tests completed successfully.\");\n      $finish();\n   end\n\n   task test_undefined_memory_content();\n      begin\n         $display(\"\\nTest 0: Verify undefined initial memory content\");\n         @(negedge clk);\n         ce      = 1;\n         a_we    = 0;\n         a_oe    = 1;\n         a_addr  = $random();\n         \n         @(posedge clk);\n         @(posedge clk);\n         \n      end\n   endtask\n\n   task test_ce_low();\n      begin\n         $display(\"\\nTest 1: Verify behavior when ce is low\");\n         @(negedge clk);\n         ce      = 0;\n         a_we    = 1;\n         a_oe    = 1;\n         b_we    = 1;\n         b_oe    = 1;\n         a_addr  = $random();\n         b_addr  = $random();\n         a_wdata = $random();\n         b_wdata = $random();\n         \n         @(posedge clk); \n         @(posedge clk); \n         \n         // Return signals to default\n         a_we = 0; a_oe = 0;\n         b_we = 0; b_oe = 0;\n      end\n   endtask\n\n   task test_port_a_write_read();\n      begin\n         $display(\"\\nTest 2: Write and Read on Port A\");\n         @(negedge clk);\n         ce      = 1;\n         a_we    = 1;\n         a_oe    = 0;\n         a_addr  = $random();\n         a_wdata = $random();\n         \n         @(posedge clk); \n         @(posedge clk); \n  \n         @(negedge clk);\n         a_we    = 0;\n         a_oe    = 1;\n         \n         @(posedge clk); \n         @(posedge clk); \n\n      end\n   endtask\n\n   task test_port_b_write_read();\n      begin\n         $display(\"\\nTest 3: Write and Read on Port B\");\n         @(negedge clk);\n         ce      = 1;\n         b_we    = 1;\n         b_oe    = 0;\n         b_addr  = $random();\n         b_wdata = $random();\n         \n         @(posedge clk); \n         @(posedge clk); \n    \n         @(negedge clk);\n         b_we    = 0;\n         b_oe    = 1;\n         \n         @(posedge clk);\n         @(posedge clk);\n         \n      end\n   endtask\n\n   task test_port_a_read_first();\n      begin\n         $display(\"\\nTest 4: Simultaneous Read and Write on Port A with Read-first priority\");\n         @(negedge clk);\n         ce      = 1;\n         a_we    = 1;\n         a_oe    = 1; \n         a_addr  = $random();\n         a_wdata = $random();\n  \n         @(posedge clk); \n         @(posedge clk);  \n         \n      end\n   endtask\n\n   task test_simultaneous_ops_different_addresses();\n      begin\n         $display(\"\\nTest 5: Simultaneous operations on both ports (different addresses)\");\n         @(negedge clk);\n         ce      = 1;\n         a_we    = 1;\n         a_oe    = 0;\n         b_we    = 0;\n         b_oe    = 1;\n         a_addr  = $random();\n         b_addr  = $random();\n         a_wdata = $random();\n         while(a_addr == b_addr) begin\n\t\t\t   b_addr  = $random();\n         end\n\n         \t \n         @(posedge clk); \n         @(posedge clk); \n\n      end\n   endtask\n\n   task test_simultaneous_ops_same_address();\n      begin\n         $display(\"\\nTest 6: Simultaneous operations on both ports (same address)\");\n         @(negedge clk);\n         ce      = 1;\n         a_we    = 0;\n         a_oe    = 1;\n         b_we    = 1;\n         b_oe    = 0;\n         a_addr  = $random();\n         b_addr  = a_addr;\n         b_wdata = $random();\n \n         @(posedge clk); \n         @(posedge clk); \n\n      end\n   endtask\n\n   task test_no_operation_with_ce_high();\n      begin\n         $display(\"\\nTest 7: Neither read nor write enabled (ce high)\");\n         @(posedge clk); \n         @(posedge clk); \n    \n         @(negedge clk);\n         ce      = 1;\n         a_we    = 0;\n         a_oe    = 0;\n         b_we    = 0;\n         b_oe    = 0;\n         a_addr  = $random();\n         b_addr  = $random();\n         \n         @(posedge clk); \n         @(posedge clk); \n         \n      end\n   endtask\n\n   task test_boundary_addresses();\n      begin\n         $display(\"\\nTest 8: Boundary Address Testing\");\n         @(negedge clk);\n         ce      = 1;\n         a_we    = 1;\n         a_oe    = 0;\n         a_addr  = 0;\n         a_wdata = $random();\n         \n         @(posedge clk);\n         @(posedge clk);\n  \n         @(negedge clk);\n         a_we    = 0;\n         b_we    = 1;\n         b_oe    = 0;\n         b_addr  = RAM_DEPTH - 1;\n         b_wdata = $random();\n         \n         @(posedge clk);\n         @(posedge clk);\n\n      end\n   endtask\n\n   task test_data_retention();\n      begin\n         $display(\"\\nTest 9: Data Retention when ce is high and no operation\");\n         @(negedge clk);\n         ce      = 1;\n         a_we    = 1;\n         a_oe    = 0;\n         a_addr  = $random();\n         a_wdata = $random();\n         \n         @(posedge clk);\n         @(posedge clk);\n         \n         @(negedge clk);\n         a_we    = 0;\n         a_oe    = 0;\n         \n         @(posedge clk); \n         @(posedge clk); \n         \n         @(negedge clk);\n         a_oe    = 1;\n         \n         @(posedge clk); \n         @(posedge clk); \n         \n      end\n   endtask\n\nendmodule"}}, "output": {"response": "", "context": {"verif/cvdp_sram_fd_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 26-tb-checker\nNUM_BUGS        = 4\n", "src/cvdp_sram_fd.sv": "`timescale 1ns/1ps\n/**************************************************************************\nFILENAME:    cvdp_sram_fd.sv\nDESCRIPTION: This file contains the RTL for a full-duplex dual-port RAM in SystemVerilog.\nLATENCY:     Write latency = 1 clk cycle\n             Read  latency = 1 clk cycle\n**************************************************************************/\nmodule cvdp_sram_fd #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 4\n)(\n    input                         clk     , // clock input\n    input                         ce      , // chip enable\n    input                         a_we    , // channel A write enable\n    input                         a_oe    , // channel A output enable\n    input        [ADDR_WIDTH-1:0] a_addr  , // channel A address\n    input        [DATA_WIDTH-1:0] a_wdata , // channel A write data\n    output logic [DATA_WIDTH-1:0] a_rdata , // channel A read data out\n    input                         b_we    , // channel B write enable\n    input                         b_oe    , // channel B output enable\n    input        [ADDR_WIDTH-1:0] b_addr  , // channel B address\n    input        [DATA_WIDTH-1:0] b_wdata , // channel B write data\n    output logic [DATA_WIDTH-1:0] b_rdata   // channel B read data out\n);\n    // Setup RAM_DEPTH parameter\n    localparam RAM_DEPTH = 1 << ADDR_WIDTH;\n    // Memory array\n    logic [DATA_WIDTH-1:0] mem [0:RAM_DEPTH-1];\n    // Channel A operations\n    always_ff @(posedge clk) begin\n        if (ce) begin\n            `ifndef BUG_3\n            if (a_oe) begin\n            `else\n            if (a_we) begin\n            `endif\n                a_rdata     <= mem[a_addr];\n            end\n            `ifndef BUG_3\n            if (a_we) begin\n            `else\n            if (a_oe) begin\n            `endif\n                mem[a_addr] <= a_wdata;\n            end\n        end\n        `ifndef BUG_1\n        else begin\n            a_rdata         <= 'b0;\n        end\n        `endif\n    end\n    // Channel B operations\n    always_ff @(posedge clk) begin\n        if (ce) begin\n            `ifndef BUG_2\n            if (b_oe) begin\n            `else\n            if (b_we) begin\n            `endif\n                b_rdata     <= mem[b_addr];\n            end\n            `ifndef BUG_2\n            if (b_we) begin\n            `else\n            if (b_oe) begin\n            `endif\n                mem[b_addr] <= b_wdata;\n            end\n        end\n        `ifndef BUG_0\n        else begin\n            b_rdata         <= 'b0;\n        end\n        `endif\n    end\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
{"id": "cvdp_copilot_sram_fd_0028", "categories": ["cid014", "medium"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `cvdp_sram_fd` module. The assertions should ensure that the module accurately implements the full duplex SRAM.\n\n## **RTL Design Overview**  \n \nA full-duplex SRAM allows simultaneous read and write operations on two separate ports (Port A and Port B)\n\n### **Key Components of the Module**       \n\n1. **Parameters:**\n   - `DATA_WIDTH` (default value: 8): Defines the width of the data bus.\n   - `ADDR_WIDTH` (default value: 4): Defines the width of the address bus.\n   - **Derived Parameter:**\n     - `RAM_DEPTH`: Determines the depth of the memory. It is derived using the ADDR_WIDTH parameter to match the full range of unique addresses possible with the given address width.\n\n2. **Ports:**\n\n   - **Clock and Control Signals:**\n     - `input clk`: Clock signal.\n     - `input ce`: Active-high chip enable signal.\n\n   - **Port A Signals:**\n     - `input a_we`: Active-high write enable for Port A.\n     - `input a_oe`: Active-high output (read) enable for Port A.\n     - `input [ADDR_WIDTH-1:0] a_addr`: Address bus for Port A.\n     - `input [DATA_WIDTH-1:0] a_wdata`: Write data bus for Port A.\n     - `output logic [DATA_WIDTH-1:0] a_rdata`: Read data output for Port A.\n\n   - **Port B Signals:**\n     - `input b_we`: Active-high write enable for Port B.\n     - `input b_oe`: Active-high output (read) enable for Port B.\n     - `input [ADDR_WIDTH-1:0] b_addr`: Address bus for Port B.\n     - `input [DATA_WIDTH-1:0] b_wdata`: Write data bus for Port B.\n     - `output logic [DATA_WIDTH-1:0] b_rdata`: Read data output for Port B.\n     \n3. **Operational Behavior:**\n\n   - **Port A Operations:**\n     - **Write Operation:**\n       - Occurs when `ce` and `a_we` are high.\n       - The data on `a_wdata` is written to the memory location specified by `a_addr`.\n     - **Read Operation:**\n       - Occurs when `ce` is high,  and `a_oe` is high.\n       - The data from the memory location specified by `a_addr` is loaded into `a_rdata`.\n       - `a_rdata` retains its previous value if `a_oe` is low while `ce` is high\n     - **Priority:**\n       - If both `a_we` and `a_oe` are high, the read operation takes precedence, where data previously stored at the address appears on the output while the input data is being stored in memory.\n     - **Timing:**\n       - **Write Latency:** 1 clock cycle.\n       - **Read Latency:** 1 clock cycle.\n\n   - **Port B Operations:**\n     - This port behaves same as Port A. The signals controlling this port are `b_we`, `b_oe`, `b_addr`, `b_wdata` and the output is driven on `b_rdata`.\n\n4. **Simultaneous Access Handling:**\n   - The memory supports simultaneous operations on both ports, including:\n     - Reads on both ports.\n     - Writes on both ports.\n     - A read on one port and a write on the other.\n   - **Same Address Access:**\n     - **If both ports access the same address:**\n       - Read and write: Follows a \"read-first\" approach which means that if a write and read occur at the same address simultaneously, data previously stored at the address appears on the output while the input data is being stored in memory.\n       - Reads on both ports: Supports with both ports providing the same output data.\n       - It is assumed that the write access will not occur for the same address on both ports together. Such a collision is not handled. \n\n5. **Assumptions and Constraints:**\n   - All inputs are synchronous and are sampled on the rising edge of `clk`.\n   - Input addresses (`a_addr`, `b_addr`) are within the valid range (`0` to `RAM_DEPTH - 1`).\n   - Data inputs (`a_wdata`, `b_wdata`) are valid when write enables (`a_we`, `b_we`) are high.\n   - If neither read nor write is enabled for a port during a clock cycle (with `ce` high), the port maintains its previous output state.\n   \n6. **Boundary Conditions:**\n    - **Data Width and Address Width:**\n      - `DATA_WIDTH` and `ADDR_WIDTH` are positive integers greater than zero.\n   \n---\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Read first behavior and Simultaneous access handling**\n- **Behaviour with chip enable deasserted and the behaviour when chip enable is asserted with no read or write enabled.**\n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/cvdp_sram_fd.sv": "/**************************************************************************\nFILENAME:    cvdp_sram_fd.sv\nDESCRIPTION: This file contains the RTL for a full-duplex dual-port RAM in SystemVerilog.\nLATENCY:     Write latency = 1 clk cycle\n             Read  latency = 1 clk cycle\n**************************************************************************/\nmodule cvdp_sram_fd #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 4\n)(\n    input                         clk     , // clock input\n    input                         ce      , // chip enable\n    input                         a_we    , // channel A write enable\n    input                         a_oe    , // channel A output enable\n    input        [ADDR_WIDTH-1:0] a_addr  , // channel A address\n    input        [DATA_WIDTH-1:0] a_wdata , // channel A write data\n    output logic [DATA_WIDTH-1:0] a_rdata , // channel A read data out\n    input                         b_we    , // channel B write enable\n    input                         b_oe    , // channel B output enable\n    input        [ADDR_WIDTH-1:0] b_addr  , // channel B address\n    input        [DATA_WIDTH-1:0] b_wdata , // channel B write data\n    output logic [DATA_WIDTH-1:0] b_rdata   // channel B read data out\n);\n    // Setup RAM_DEPTH parameter\n    localparam RAM_DEPTH = 1 << ADDR_WIDTH;\n    // Memory array\n    logic [DATA_WIDTH-1:0] mem [0:RAM_DEPTH-1];\n    // Channel A operations\n    always_ff @(posedge clk) begin\n        if (ce) begin\n            if (a_oe) begin\n                a_rdata     <= mem[a_addr];\n            end\n            if (a_we) begin\n                mem[a_addr] <= a_wdata;\n            end\n        end else begin\n            a_rdata         <= 'b0;\n        end\n    end\n    // Channel B operations\n    always_ff @(posedge clk) begin\n        if (ce) begin\n            if (b_oe) begin\n                b_rdata     <= mem[b_addr];\n            end \n            if (b_we) begin\n                mem[b_addr] <= b_wdata;\n            end\n        end else begin\n            b_rdata         <= 'b0;\n        end\n    end\nendmodule"}}, "output": {"response": "", "context": {"rtl/cvdp_sram_fd.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cvdp_sram_fd.sv\nTOPLEVEL        = cvdp_sram_fd\nMODULE          = test_sram_fd\nPYTHONPATH      = /src\nHASH            = 28-rtl-assertion-sram-fd", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.parametrize(\"ADDR_WIDTH\", [2])#,4,8])\n@pytest.mark.parametrize(\"DATA_WIDTH\", [4])#,8,32])\n\ndef test_sram_fd(ADDR_WIDTH,DATA_WIDTH):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    parameters = { \"ADDR_WIDTH\": ADDR_WIDTH, \"DATA_WIDTH\": DATA_WIDTH }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# if __name__ == \"__main__\":\n#     test_simulate()\n", "src/test_sram_fd.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n# Utility function to initialize the SRAM\nasync def init_sram(dut, depth, width, memory):\n    dut.ce.value = 1\n    prev_memory = memory.copy()\n    for addr in range(depth):\n        # Initialize the memory with random values\n        a_wdata = random.randint(0, 2**width - 1)\n\n        # Channel A: write\n        dut.a_addr.value = addr\n        dut.a_we.value = 1\n        dut.a_wdata.value = a_wdata\n        dut.a_oe.value = 0\n\n        # Wait for write latency\n        await RisingEdge(dut.clk)\n\n        # Update memory model after write latency\n        memory[addr] = a_wdata\n\n        # Reset write enables\n        dut.a_we.value = 0\n        dut.b_we.value = 0\n\n        # Update prev_memory for latency modeling\n        prev_memory = memory.copy()\n\n# Function to perform random read/write operations on the SRAM\nasync def random_rw_test(dut, depth, width, memory):\n    prev_memory = memory.copy()\n    for _ in range(100):  # Run 100 random transactions\n        a_addr = random.randint(0, depth - 1)\n        b_addr = random.randint(0, depth - 1)\n        a_we = random.choice([0, 1])\n        b_we = random.choice([0, 1]) if a_addr != b_addr else int(not a_we)\n        a_wdata = random.randint(0, 2**width - 1) if a_we else 0\n        b_wdata = random.randint(0, 2**width - 1) if b_we else 0\n\n        # Ensure CE is high for this test\n        dut.ce.value = 1\n\n        # Set inputs\n        dut.a_addr.value = a_addr\n        dut.b_addr.value = b_addr\n        dut.a_we.value = a_we\n        dut.b_we.value = b_we\n        dut.a_wdata.value = a_wdata\n        dut.b_wdata.value = b_wdata\n        dut.a_oe.value = 1 if not a_we else 0\n        dut.b_oe.value = 1 if not b_we else 0\n\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n\n        # Apply pending writes after write latency\n        if a_we:\n            memory[a_addr] = a_wdata\n        if b_we:\n            memory[b_addr] = b_wdata\n\n        # Read data from previous memory state (before writes)\n        if dut.a_oe.value == 1:\n            expected_data = prev_memory[a_addr]\n            read_data = int(dut.a_rdata.value)\n            dut._log.info(f\"Channel A read from addr {a_addr}: {read_data}\")\n            assert read_data == expected_data, f\"Mismatch on Channel A: expected {expected_data}, got {read_data}\"\n\n        if dut.b_oe.value == 1:\n            expected_data = prev_memory[b_addr]\n            read_data = int(dut.b_rdata.value)\n            dut._log.info(f\"Channel B read from addr {b_addr}: {read_data}\")\n            assert read_data == expected_data, f\"Mismatch on Channel B: expected {expected_data}, got {read_data}\"\n\n        # Update prev_memory after read latency\n        prev_memory = memory.copy()\n\n        # Reset controls\n        dut.a_we.value = 0\n        dut.b_we.value = 0\n        dut.a_oe.value = 0\n        dut.b_oe.value = 0\n\n# Function to check corner cases like address overlap between ports A and B\nasync def corner_case_test(dut, depth, width, memory):\n    dut._log.info(\"Testing corner cases\")\n    prev_memory = memory.copy()\n\n    # Case: Same address, one write (Port A), one read (Port B)\n    same_addr = random.randint(0, depth - 1)\n    a_wdata = random.randint(0, 2**width - 1)\n    b_wdata = random.randint(0, 2**width - 1)\n\n    # First, write to the address from port A\n    dut.a_addr.value = same_addr\n    dut.a_we.value = 1\n    dut.a_wdata.value = a_wdata\n    dut.a_oe.value = 0\n\n    dut.b_addr.value = same_addr\n    dut.b_we.value = 0\n    dut.b_oe.value = 1\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    # Apply pending writes after write latency\n    memory[same_addr] = a_wdata\n\n    # Read data from previous memory state\n    expected_data = prev_memory[same_addr]\n    read_data = int(dut.b_rdata.value)\n    dut._log.info(f\"Channel B read: {read_data} before Channel A wrote at addr {same_addr}\")\n    assert read_data == expected_data, f\"Mismatch on Channel B: expected {expected_data}, got {read_data}\"\n    \n    await RisingEdge(dut.clk)\n    expected_data = memory[same_addr]\n    read_data = int(dut.b_rdata.value)\n    dut._log.info(f\"Channel B read: {read_data} after Channel A wrote at addr {same_addr}\")\n    assert read_data == expected_data, f\"Mismatch on Channel B: expected {expected_data}, got {read_data}\"\n    \n\n    # Update prev_memory\n    prev_memory = memory.copy()\n\n    # Reset controls\n    dut.a_we.value = 0\n    dut.b_oe.value = 0\n\n    await RisingEdge(dut.clk)\n\n    # Now, write to the same address from port B while reading from port A\n    dut.b_addr.value = same_addr\n    dut.b_we.value = 1\n    dut.b_wdata.value = b_wdata\n    dut.b_oe.value = 0\n\n    dut.a_addr.value = same_addr\n    dut.a_we.value = 0\n    dut.a_oe.value = 1\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    # Apply pending writes after write latency\n    memory[same_addr] = b_wdata\n\n    # Read data from previous memory state\n    expected_data = prev_memory[same_addr]\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"Channel A read: {read_data} before Channel B wrote at addr {same_addr}\")\n    assert read_data == expected_data, f\"Mismatch on Channel A: expected {expected_data}, got {read_data}\"\n    \n    await RisingEdge(dut.clk)\n    expected_data = memory[same_addr]\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"Channel A read: {read_data} after Channel B wrote at addr {same_addr}\")\n    assert read_data == expected_data, f\"Mismatch on Channel A: expected {expected_data}, got {read_data}\"\n\n    # Update prev_memory\n    prev_memory = memory.copy()\n\n    # Reset controls\n    dut.b_we.value = 0\n    dut.a_oe.value = 0\n\n# Test the case when CE is low\nasync def test_ce_low(dut, depth, width, memory):\n    dut._log.info(\"Testing with CE low\")\n    prev_memory = memory.copy()\n\n    # Set CE low\n    dut.ce.value = 0\n\n    # Try to write to SRAM\n    addr = random.randint(0, depth - 1)\n    data = random.randint(0, 2**width - 1)\n    dut.a_addr.value = addr\n    dut.a_we.value = 1\n    dut.a_wdata.value = data\n    dut.a_oe.value = 0\n\n    await RisingEdge(dut.clk)\n\n    # Memory should not be updated\n    expected_data = prev_memory[addr]\n\n    # Try to read from SRAM\n    dut.a_we.value = 0\n    dut.a_oe.value = 1\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    dut.a_oe.value = 0\n\n    # Read data should be zero as per specification\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"Read data with CE low: {read_data}\")\n    assert read_data == 0, f\"Expected read_data to be 0 when CE is low, got {read_data}\"\n\n    await RisingEdge(dut.clk)\n    # Set CE high to verify that the write didnt make any changes\n    dut.ce.value = 1\n    dut.a_addr.value = addr\n    dut.a_we.value = 0\n    dut.a_oe.value = 1\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    \n    # Read data should be zero as per specification\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"Read data with CE high: {read_data}\")\n    assert read_data == expected_data, f\"Expected read_data to be {expected_data} when CE is high, got {read_data}\"\n    \n    # Reset controls\n    dut.a_oe.value = 0\n\n# Test the case when a_we and a_oe are low while CE is high\nasync def test_no_we_oe(dut, depth, width, memory):\n    dut._log.info(\"Testing with CE high but WE and OE low\")\n    prev_memory = memory.copy()\n\n    dut.ce.value = 1\n    old_rdata =  dut.a_rdata.value\n    dut.a_we.value = 0\n    dut.a_oe.value = 0\n\n    addr = random.randint(0, depth - 1)\n    data = random.randint(0, 2**width - 1)\n    dut.a_addr.value = addr\n    dut.a_wdata.value = data\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    \n    # To confirm if a_oe 0 and ce 1 performs a read.\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"Read data with CE high but WE and OE low: {read_data}\")\n    assert read_data == old_rdata, f\"Expected read_data to be {old_rdata}, got {read_data}\" \n\n    # Since WE and OE are low, no write or read should occur\n    expected_data = prev_memory[addr]\n\n    # Read from SRAM to confirm memory is unchanged\n    dut.a_oe.value = 1\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"Read data with CE,OE high to check previous write during WE low: {read_data}\")\n    assert read_data == expected_data, f\"Expected read_data to be {expected_data}, got {read_data}\"\n\n    # Update prev_memory\n    prev_memory = memory.copy()\n\n    # Reset controls\n    dut.a_oe.value = 0\n\n# Test the case when both WE and OE are high in a read-first module\nasync def test_we_and_oe_high(dut, depth, width, memory):\n    dut._log.info(\"Testing with both WE and OE high (Read-First behavior)\")\n\n    prev_memory = memory.copy()\n\n    dut.ce.value = 1\n\n    addr = random.randint(0, depth - 1)\n    old_data = prev_memory[addr]\n    new_data = random.randint(0, 2**width - 1)\n\n    # Set both WE and OE high\n    dut.a_addr.value = addr\n    dut.a_we.value = 1\n    dut.a_oe.value = 1\n    dut.a_wdata.value = new_data\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    \n    # Read data should be the old written data (read-first behavior)\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"With both WE and OE high, wrote new data {new_data} to addr {addr}, read old data {read_data}\")\n    assert read_data == old_data, f\"Expected read_data to be {old_data}, got {read_data}\"\n\n    # Perform another read to check whether the write was performed after the read was performed when both WE and OE were high\n    \n    await RisingEdge(dut.clk)\n\n    # Read data should be the old written data (read-first behavior)\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"On second read, read new data {read_data}\")\n    assert read_data == new_data, f\"Expected read_data to be {new_data}, got {read_data}\"\n    \n    # Update prev_memory\n    prev_memory = memory.copy()\n\n    # Reset controls\n    dut.a_we.value = 0\n    dut.a_oe.value = 0\n\n\n# Testbench to run\n@cocotb.test()\nasync def test_sram_full_duplex(dut):\n    depth = 2**int(dut.ADDR_WIDTH.value)\n    width = int(dut.DATA_WIDTH.value)\n\n    # Initialize memory model\n    memory = [0] * depth\n\n    # Clock generation\n    clock = Clock(dut.clk, 10, units=\"ns\")  # 100 MHz clock\n    cocotb.start_soon(clock.start())\n\n    # Reset\n    dut.ce.value = 0\n    dut.a_we.value = 0\n    dut.a_oe.value = 0\n    dut.b_we.value = 0\n    dut.b_oe.value = 0\n    await Timer(100, units=\"ns\")  # Wait for reset\n\n    # Chip enable\n    dut.ce.value = 1\n    await RisingEdge(dut.clk)\n    \n    # Initialization phase\n    await init_sram(dut, depth, width, memory)\n    await RisingEdge(dut.clk)\n\n    # Random read/write test (stress test)\n    await random_rw_test(dut, depth, width, memory)\n    await RisingEdge(dut.clk)\n\n    # Corner case test (overlap, simultaneous operations)\n    await corner_case_test(dut, depth, width, memory)\n    await RisingEdge(dut.clk)\n\n    # Test CE low\n    await test_ce_low(dut, depth, width, memory)\n    await RisingEdge(dut.clk)\n\n    # Test with WE and OE low while CE high\n    await test_no_we_oe(dut, depth, width, memory)\n    await RisingEdge(dut.clk)\n\n    # Test with both WE and OE high (WE has priority)\n    await test_we_and_oe_high(dut, depth, width, memory)\n    await RisingEdge(dut.clk)\n"}}}
{"id": "cvdp_copilot_static_branch_predict_0030", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the System Verilog Testbench `tb_static_branch_predict` to include checkers to verify the functional correctness of the `static_branch_predict` module. The testbench with stimulus generation has been given in the context.\n\n## Design Specification:\nThe `static_branch_predict` module takes in a 32-bit RV32I (RISC V 32-bit base Integer ISA) conditional branch and unconditional jump instructions as input. This module generally exists as part of the Instruction Fetch Stage of a pipelined processor. The branch and jump instruction can be either from the RV32I Instruction Set or from the RV32C Instruction Set. The branch and jump instructions as part of the RV32I Instruction Set are 32-bit in width, whereas those belonging to the RV32C Instruction Set are 16-bit in width. The 16-bit RV32C branch and jump instructions are converted into an equivalent 32-bit RV32I instruction using a specialized circuit called Instruction Decompresser before being applied to this module. For the module to recognize the 32-bit equivalent of the 16-bit branch and jump instructions, the inputs are properly formatted into a 32-bit value and applied. The Instruction Decompresser is not instantiated into the branch predictor module. Based on the instruction's offset in the case of the branch instruction and based on instruction in the case of a jump instruction, the branch predictor outputs two signals (i) a 1-bit signal to indicate whether the branching will occur for a given instruction or not (ii) If branching occurs, to which 32-bit address it has to get branched.\n\n## Key Assumptions and Constraints:\n- Only uncompressed 32-bit instructions are applied as input to this module.\n- The module operates in a purely combinational manner without requiring any state elements such as registers.\n- The Instruction Decompressor is outside the scope of this module, and the equivalent 32-bit uncompressed instruction is \n  given as input.\n\n### Introduction to RISC V:\nRISC-V is a royalty-free open-source instruction set architecture, which anyone can utilize to implement a processor microarchitecture (i.e. processor hardware). The RISC-V ISA consists of three variants of Integer ISA namely RV32I (32-bit instructions to handle 32-bit data), RV64I (32-bit instructions to handle 64-bit data), and RV128I (32-bit instructions to handle 128-bit data). In addition to these, there are 14 extensions. One of the extensions that will be considered in this module is RV32C (16-bit ISA called Compressed RISC-V ISA)\n\n## RV32I Branch and Jump Instructions\nThe RISC-V RV32I instruction set includes both unconditional jump and conditional branch instructions. Below, we describe the encodings and behaviors for these types of instructions.\n### Unconditional Jump Instructions(JAL and JALR)\n`JAL` (Jump and Link instruction):\n    -  Branches to an address obtained by adding the 32-bit program counter (pc) to a sign-extended 20-bit offset encoded in the instruction.\n    -  Returns to resume execution from the address stored in the 32-bit link register (x1 or x5) after completing the branched subroutine. A link register (also called a return address register) is the one that holds the address from where the processor has to resume its execution after returning from a subroutine. \n**Instruction Encoding**:\n\n**|   31 -  imm[20]   |    30:21 - imm[10:1]    |     20 - imm[11]       |       19 : 12 - imm[19:12]      | 11 : 7 - rd   | 6 : 0  - 7'h6F   |**\n\n            \nAssembler syntax for JAL instruction :  jal  rd ,  imm[20:1]\n           \nTarget Address  calculated for this instruction : \n\nrd <--- pc + {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 };\n\nwhere {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 } - 32-bit sign extended offset or immediate. \nHere, `rd` is a 5-bit number to identify the 32-bit destination register; `pc` - 32-bit program counter.\n  \n`JALR` (Jump and Link Register instruction): \n - Branches to an address obtained by adding the 32-bit program counter to a sign-extended 12-bit offset present in a register specified in the instruction.\n\nThe instruction encoding for 32-bit uncompressed JALR instruction \n**Instruction Encoding**:\n \n**|   31 :20 -  imm[11:0]   |    19:15 - rs1   |     14:12 - 000      |      11 : 7 - rd      | 11 : 7 - rd   | 6 : 0  - 7'h67   |**             \n            \nAssembler syntax for JAL instruction:  jalr  rd,  rs1, imm[11:0]  \n\nTarget address calculated for this instruction : \nrd <-pc + {{20{instr[31]}}, instr[31:20]} + rs1\n                           \nwhere \n {{20{instr[31]}}, instr[31:20]} + rs1 - 32-bit sign extended offset or immediate                          \nHere `rd` is the 5-bit number to identify a 32-bit destination register; `rs1` is the 5-bit number to identify the 32-bit source register; `pc` - 32-bit program counter\n                           \n### Conditional Branch Instructions (BXXX) :\n  - Takes in two operands (rs1 and rs2), compares them, and branches based on the comparison result.\n  - The target address is obtained by adding the pc to a sign-extended 12-bit offset encoded in the instruction.\n\n The instruction encoding for the 32-bit uncompressed Branch instruction\n\n**Instruction Encoding**:\n \n**| 31 -  imm[12]|30:25 - imm[10:5]|24:20 - rs2 | 14 : 12 - func3| 11 : 8 -  imm[4:1]|7 - imm[11]| 6 : 0  - 7'h63   |**          \n      \nAssembler syntax for Branch instruction:  bxxx rs1, rs2, offset\n        \nHere `rs1` and `rs2`  are the 5-bit numbers to identify the 32-bit source registers which will be used for comparison\n        \nTarget address calculated for this instruction : \npc + { {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 };\n\nwhere,\n{ {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 } - 32-bit sign extended offset or immediate; `pc` - 32-bit program counter\n\nThe different types of branch instruction :\n- beq       rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b000)\n- bne       rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b001)\n- blt         rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b100)\n- bltu       rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b110)\n- bge       rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b101)\n- bgeu     rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b111)\n                               \n ## RV32C Branch and Jump Instructions :\n The RV32C compressed instructions are 16-bit wide, but before applying them to this module, they are converted to their equivalent 32-bit uncompressed form using an external decompressor circuit. The following sections describe how these instructions are handled.\n \n   \n ### C.J / C.JAL Instructions: \n  - Equivalent to the RV32I JAL instruction, with different function codes.\n    \nThe instruction encoding for the 16-bit compressed jump instruction is given below:\n**Instruction Encoding**:\n**| 15 : 13 - func3 | 12:2- imm[11:1]| 1 : 0 - 01 |**              \n  \nAssembler syntax for C.J  instruction:   c.j offset[11:1]\nAssembler syntax for C.JAL instruction:  c.jal offset [11:1]\n             \n`func3` is a 3-bit code that differentiates between C.J and C.JAL instruction.\nThe 3-bit function code for C.J is 101 and C.JAL is 001.\n  \nIts equivalent 32-bit uncompressed instruction encoding is given by :\n**Instruction Encoding**:\n \n**| 31  -  instr_c[12] | 30 -instr_c[8] | 29 : 28 - instr_c[10:9]| 27 -  instr_c[6]| 26-  instr_c[7]| 25 - instr_c[2] | 24- instr_c[11]|**\n\n**| 23 :  21 -  instr_c[5:3]  | 20 : 12  - {9{instr_c[12]}}| 11 : 8 - 4'b0000 | 7 - ~instr_c[15] | 6 : 0 - 7'h6F   |**              \n   \n   Only C.J and C.JAL instructions are supported by this module.\n   \n   Other Compressed Jump Instructions that RV32C supports are C.JR and C.JALR, but these are not being tested by the module.\n   \n### C.BEQZ / C.BNEZ Instructions:\n\nEquivalent to the RV32I BXXX instructions but check whether the content of the specified register(rs1') is zero or not.\n                                               \nThe instruction encoding for the 16-bit compressed branch instruction is given below:\n**Instruction Encoding**:\n**| 15 : 13 - func3 | 12 : 10 - imm[8:6]    | 9 : 7 - rs1'  | 6 : 3 -  imm[4:1]| 2 -  imm[5]| 1 : 0 - 01  |**\n\n- func3 is a 3-bit code that differentiates between C.BEQZ and C.BNEZ instruction\n- The 3-bit function code for Compressed Branch EQual Zero (C.BEQZ) is 110 and that of Compressed Branch Not \n   Equal Zero (C.BNEZ) is 111\n \n Assembler syntax for C.BEQZ instruction:  c.beqz rs1' , offset[8:1]\n Assembler syntax for C.BNEZ instruction:  c.bnez rs1', offset[8:1]\n          \n Its equivalent 32-bit uncompressed instruction encoding is given by :\n**Instruction Encoding**:\n**| 31 : 28 - {4{instr_c[12]}} | 27 : 26 - instr_c[6:5] | 25 - instr_c[2]| 24 : 20 - 5'b00000 | 19 : 18 - 2'b01 | 17 : 15 - instr_c[9:7] |**\n\n**| 14 :  13 - 2'b00  | 12  - instr_c[13] | 11 : 10 -  instr_c[11:10] | 9 : 8 - instr_c[4:3] | 7 -  instr_c[12]  | 6 : 0 - 7'h63  |**\n\n### Only Supported Instructions\n- The following instructions are supported by this module:\n\n  - Uncompressed Instructions: JAL, JALR, BXXX.\n  - Compressed Instructions: C.J, C.JAL, C.BEQZ, C.BNEZ.\n  - For all other instructions, fetch_valid_i will be 0, indicating that they will not be predicted as taken.\n\n\n \n### Concept of Sign Extension of Immediate(or Offset) in the RISC V Control Transfer Instruction :\n\nSign extension refers to identifying the sign bit of an operand and replicating it at the higher significant positions to increase the operand width to the desired value.\nIllustration :\nSuppose there is 8-bit data, data[7:0], say 8'b0110_1110. Suppose this has to be stored in a 32-bit register rd.\n\n\n| Bit Position : Bit Value    | 7 : 0  | 6 : 1  | 5 : 1  | 4: 0  | 3 : 1  | 2 : 1  | 1 : 1 | 0 : 0 |\n                \nHere the bit at position 7 is called sign-bit; Since it is 0, it indicates that it is a positive value. Hence, will be replicated in the higher 24-bit positions (i.e. from bit position 8 to bit position 31) to form a 32-bit value. This is represented in shorthand as\n                                                      rd <---  {{24{0}} , data_i[7:0]};\n                                                      \n### Static Branch Prediction Algorithm :\n### For Branch Instruction:\n- Immediate Extraction:\n    Extract the immediate value from the branch instruction.\n- Sign Extension:\n    Sign extend the immediate to 32 bits.\n- Prediction Logic and Target Address Calculation:\n   If the sign bit of the immediate is 1, the branch is predicted to be taken.\n   Otherwise, it is predicted as not taken.\n   The 32-bit program counter is added to the sign-extended offset or sign-extended immediate to form the target address\n\n### For Jump Instruction:\n- Immediate Extraction:\n   Extract the immediate value from the jump instruction.\n- Sign Extension:\n  Sign extend the immediate to 32 bits.\n- Prediction Logic and Target Address Calculation:\n   Always predict jumps (JAL, JALR, C.J, C.JAL) as taken.\n   The 32-bit program counter is added to the sign-extended offset or sign-extended immediate to form the target address\n\n## What do the words `taken` and `not-taken` signify in case of branch prediction :\n- Taken: The branch will occur, and execution will continue at the target address.   \n- Not-Taken: The branch will not occur, and execution continues sequentially.\n\n### Interface :\n\n#### Inputs:\n- `fetch_rdata_i` ([31:0], 32-bit): The fetched instruction data from the instruction memory or pipeline.\n- `fetch_pc_i` ([31:0], 32-bit): Program counter (PC) value of the fetched instruction.\n- `fetch_valid_i` (1-bit): Active HIGH Indicates the validity of the fetched instruction.\n\n#### Outputs:\n- `predict_branch_taken_o` (1-bit): Active HIGH indicates whether the branch or jump is predicted as taken.\n- `predict_branch_pc_o` ([31:0], 32-bit): Predicted target address for a taken branch or jump instruction.\n\n### Internal registers and parameters:\n\n#### Localparams :\n -  OPCODE_BRANCH = 7'h63\n -  OPCODE_JAL          = 7'h6F;\n -  OPCODE_JALR       = 7'h67;\n\n#### Immediate:\n- `imm_j_type` ([31:0], 32-bit): Immediate for uncompressed jump (JAL) instructions, sign-extended.\n- `imm_b_type` ([31:0], 32-bit): Immediate for uncompressed branch instructions, sign-extended.\n- `imm_cj_type` ([31:0], 32-bit): Immediate for compressed jump instructions, sign-extended.\n- `imm_cb_type` ([31:0], 32-bit): Immediate for compressed branch instructions, sign-extended.\n- `branch_imm` ([31:0], 32-bit): One of the immediate values: `imm_j_type` or `imm_b_type` or `imm_cj_type` or `imm_cb_type`.\n\n### Signals and Logic :\n#### Control Signals:\n- `instr` ([31:0], 32-bit): Alias for the input `fetch_rdata_i` to simplify the code.\n- `instr_j`, `instr_b`, `instr_cj`, `instr_cb` (1-bit each): Signals to identify specific branch or jump types in compressed and uncompressed formats.\n- `instr_b_taken` (1-bit): Indicates whether an uncompressed or compressed branch offset is negative, implying that the branch is taken.\n\n## Module Functionality: \n#### Combinational Logic\n- `Immediate Extraction`: The immediate branches and jumps are extracted from the instruction, with an appropriate sign extension based on the instruction type.\n- `Instruction Type Decoding`: Decodes whether the instruction is an uncompressed branch (instr_b), uncompressed jump (instr_j), compressed branch (instr_cb), or compressed jump (instr_cj) based on opcode and bit patterns.\n- `Target Address Calculation`: Determines the branch offset and computes the target PC for the predicted branch or jump.\n\n#### Branch Prediction:\n\n-  `Uncompressed Branch/Jump Detection`: Detection of uncompressed instructions (JAL, JALR, BXXX) uses opcode\n   matching to identify the instruction type.\n\n- `Compressed Branch/Jump Detection`: Compressed branch/jump instructions (C.J, C.JAL, C.BEQZ, C.BNEZ) are provided\n  in their 32-bit uncompressed form. This module directly uses opcodes and fields from the uncompressed equivalent\n  to determine the offset and perform the prediction.\n  \n- `Offset-Based Prediction`:Branches are predicted as taken if the offset is negative. This predictions are assigned to \n   the signal `instr_b_taken`.\n\n\n#### Branch or Jump Prediction:\n\n- For jumps (`instr_j`, `instr_cj`), the module always predicts the instruction as taken.\n- For branches, the module uses the `instr_b_taken` signal to decide.\n\n#### Output Prediction Logic:\n\n- `predict_branch_taken_o` is asserted(active-high) if the instruction is predicted to be taken.\n- `predict_branch_pc_o` is calculated by adding `fetch_pc_i` to `branch_imm`, giving the predicted target address.\n\n## **Edge Cases and Stress Testing**:\n- Tests for positive and negative offsets in branch and jump instructions ensure the predictor can handle a wide range of conditions, such as large PC offsets.\n- The compressed instruction tests ensure that the branch predictor correctly handles the compressed instruction set (C-type) in scenarios where the instructions are smaller and use shorter offsets.\n- Verifies the correct handling of invalid fetches, where the `fetch_valid_i` signal is set to 0, ensuring that no predictions are made under invalid conditions.\n\n## **Checker Requirements**:\n### **Validation Logic**:\n- A task named `run_test_case` is implemented to compare the actual output of the static branch predictor (`predict_branch_taken_o` and `predict_branch_pc_o`) against the expected values(`expected_taken`,`expected_pc`).\n- The task checks both the predicted branch taken status and the predicted branch target PC by comparing them with the expected values provided in each test case.\n- If the actual result matches the expected output, a PASS message is displayed; otherwise, an error message with details is printed, and the test is marked as FAIL.\n\n## Deliverables:\nProvide a complete SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `static_branch_predict` module.", "context": {"verif/tb_static_branch_predict.sv": "module tb_static_branch_predict;\n\n  // Parameters and signals for testing\n  logic [31:0] fetch_rdata_i;\n  logic [31:0] fetch_pc_i;\n  logic [31:0] register_addr_i;\n  logic fetch_valid_i;\n  logic predict_branch_taken_o;\n  logic [31:0] predict_branch_pc_o;\n\n  // Instantiate the Device Under Test (DUT)\n  static_branch_predict uut (\n    .fetch_rdata_i(fetch_rdata_i),\n    .fetch_pc_i(fetch_pc_i),\n    .register_addr_i(register_addr_i),\n    .fetch_valid_i(fetch_valid_i),\n    .predict_branch_taken_o(predict_branch_taken_o),\n    .predict_branch_pc_o(predict_branch_pc_o)\n  );\n\n  \n  task run_test_case(\n    input logic [31:0] test_instr,          \n    input logic [31:0] test_pc,             \n    input logic [31:0] test_register_operand,\n    input logic test_valid,                 \n    input logic expected_taken,             \n    input logic [31:0] expected_pc,         \n    input string case_name                  \n  );\n    begin\n      fetch_rdata_i = test_instr;\n      fetch_pc_i = test_pc;\n      fetch_valid_i = test_valid;\n      register_addr_i = test_register_operand;\n      #10;  \n     \n      $display(\"Running test case: %s\", case_name);\n      $display(\"%s - fetch_rdata_i = %0h, fetch_pc_i = %0h, Valid = %b\", case_name, test_instr, test_pc, test_valid);\n      $display(\"%s - Expected taken = %b, Actual taken = %b \", case_name, expected_taken, predict_branch_taken_o);\n      $display(\"%s - Expected PC = %0h, Actual PC = %0h\", case_name, expected_pc, predict_branch_pc_o);\n    end\n  endtask\n\n  \n  initial begin\n    $dumpfile(\"static_branch_predict.vcd\");  \n    $dumpvars(0, tb_static_branch_predict);  \n  end\n\n  \n  initial begin\n    $display(\"Starting testbench for Static Branch Predictor...\");\n    run_test_case(32'h8C218363, 32'h00001000, 32'h00000000,1'b1, \"Branch taken, PC offset negative (B-type),[BEQ]\");\n    run_test_case(32'h6C2183E3, 32'h00001000, 32'h00000000,1'b1, \"Branch taken, PC offset positive (B-type)[BEQ]\");\n    run_test_case(32'h926CF16F, 32'h00001000, 32'h00000000,1'b1, \"Jump taken (J-type) with negative offset[JAL]\"); \n    run_test_case(32'h126CF16F, 32'h00001000, 32'h00000000,1'b1, \"Jump taken (J-type) with positive offset[JAL]\"); \n    run_test_case(32'hF63101E7, 32'h00001000, 32'h00000000,1'b1, \"Jump taken (J-type) with negative offset[JALR]\"); \n    run_test_case(32'h763101E7, 32'h00001000, 32'h00000000,1'b1, \"Jump taken (J-type) with positive offset[JALR]\"); \n    run_test_case(32'h4840006F, 32'h00001000, 32'h00000000,1'b1, \"Compressed Jump taken (J-type) with positive offset[C.J]\"); \n    run_test_case(32'h484000EF, 32'h00001000, 32'h00000000,1'b1, \"Compressed Jump taken (J-type) with positive offset[C.JAL]\"); \n    run_test_case(32'h08040A63, 32'h00001000, 32'h00000000,1'b1, \"Compressed Branch Taken , PC offset positive(B-type)[C.BEQZ]\"); \n    run_test_case(32'h00000001, 32'h00002000, 32'h00000000,1'b0, \"Invalid fetch (not valid)\");\n    run_test_case(32'h00000000, 32'h00002000, 32'h00000000,1'b1, \"No branch or jump\");\n    run_test_case(32'hfe000e63, 32'h00001000, 32'h00000000,1'b1, \"Branch taken, PC offset negative (B-type)[BEQ]\"); \n    #100;  \n    $finish;\n  end\n\nendmodule "}}, "output": {"response": "", "context": {"verif/tb_static_branch_predict.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 752e3af0ab3fbfe66351ba74bb28fc96a919e23e\nNUM_BUGS        = 3\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n        \n", "src/static_branch_predict.sv": "module static_branch_predict (\n  \n  // Instruction from fetch stage\n  input  logic [31:0] fetch_rdata_i,\n  input  logic [31:0] fetch_pc_i,\n  input  logic [31:0] register_addr_i,\n  input  logic        fetch_valid_i,\n\n  // Prediction for supplied instruction\n  output logic        predict_branch_taken_o,\n  output logic [31:0] predict_branch_pc_o\n);\n  logic [31:0] reg_addr;\n  logic [31:0] imm_jal_type;\n  logic [31:0] imm_jalr_type;\n  logic [31:0] imm_b_type;\n  logic [31:0] imm_cj_type;\n  logic [31:0] imm_cb_type;\n\n  logic [31:0] branch_imm;\n\n  logic [31:0] instr;\n\n  logic instr_jal;\n  logic instr_jalr;\n  logic instr_b;\n  logic instr_cj;\n  logic instr_cb;\n\n  logic instr_b_taken;\n  \n    \n  localparam OPCODE_BRANCH = 7'h63;\n  localparam OPCODE_JAL    = 7'h6F;\n  localparam OPCODE_JALR   = 7'h67;\n\n  assign instr = fetch_rdata_i;\n  assign reg_addr = register_addr_i;\n\n  assign imm_jal_type = { {12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 };\n  assign imm_jalr_type = {{20{instr[31]}}, instr[31:20]}+reg_addr;\n  assign imm_b_type = { {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 };\n\n  assign imm_cj_type = { {20{instr[12]}}, instr[12], instr[8], instr[10:9], instr[6], instr[7],\n    instr[2], instr[11], instr[5:3], 1'b0 };\n\n  assign imm_cb_type = { {23{instr[12]}}, instr[12], instr[6:5], instr[2], instr[11:10],\n    instr[4:3], 1'b0};\n\n  assign instr_b    = instr[6:0] == OPCODE_BRANCH;\n  assign instr_jal  = instr[6:0] == OPCODE_JAL;\n  assign instr_jalr = instr[6:0] == OPCODE_JALR;\n\n  assign instr_cb = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b110) | (instr[15:13] == 3'b111));\n  assign instr_cj = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b101) | (instr[15:13] == 3'b001));\n  \n  `ifdef BUG_0\n      initial begin\n        $display(\"BUG_0 is ACTIVE\");\n      end\n    `else\n      initial begin\n       $display(\"BUG_0 is NOT ACTIVE\");\n      end\n     `endif\n\n    `ifdef BUG_1\n      initial begin\n        $display(\"BUG_1 is ACTIVE\");\n      end\n    `else\n      initial begin\n        $display(\"BUG_1 is NOT ACTIVE\");\n      end\n    `endif\n    \n    `ifdef BUG_2\n      initial begin\n        $display(\"BUG_2 is ACTIVE\");\n      end\n    `else\n      initial begin\n        $display(\"BUG_2 is NOT ACTIVE\");\n      end\n    `endif\n\n  `ifndef BUG_0\n  always_comb begin\n    branch_imm = imm_b_type;\n\n    case(1'b1)\n      instr_jal  : branch_imm = imm_jal_type;\n      instr_jalr : branch_imm = imm_jalr_type;\n      instr_b    : branch_imm = imm_b_type;\n      instr_cj   : branch_imm = imm_cj_type;\n      instr_cb   : branch_imm = imm_cb_type;\n      default    : ;\n    endcase\n  end\n  `else\n   always_comb begin\n    branch_imm = imm_b_type;\n\n    case(1'b1)\n      instr_jal  : branch_imm = imm_jalr_type;\n      instr_jalr : branch_imm = imm_jalr_type;\n      instr_b    : branch_imm = imm_b_type;\n      instr_cj   : branch_imm = imm_cj_type;\n      instr_cb   : branch_imm = imm_b_type;\n      default    : ;\n    endcase\n  end\n  `endif\n  \n  assign instr_b_taken = (instr_b & imm_b_type[31]) | (instr_cb & imm_cb_type[31]);\n  \n  `ifndef BUG_1\n  assign predict_branch_taken_o = fetch_valid_i & (instr_jal | instr_jalr | instr_cj | instr_b_taken);\n  `else\n   assign predict_branch_taken_o = fetch_valid_i & (instr_jal & instr_jalr & instr_cj & instr_b_taken);\n  `endif\n  \n  `ifndef BUG_2\n  assign predict_branch_pc_o    = fetch_pc_i + branch_imm;\n  `else\n  assign predict_branch_pc_o    = branch_imm;\n  `endif \nendmodule\n"}}}
{"id": "cvdp_copilot_static_branch_predict_0032", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add assertions in the RTL design of the `static_branch_predict` module to ensure its correct functionality during simulation? The assertions should specifically validate the branch target and branch-taken signals, and they must trigger clear error messages when any violation occurs.\n\nThe assertions should cover the following conditions:\n\n**1. Branch Target (`predict_branch_pc_o`) Validation**:\nAt every clock cycle, after a 10-time unit delay, the predicted branch PC (`predict_branch_pc_o`) must equal the sum of `fetch_pc_i` and the computed branch immediate (`branch_imm`). If this equality is not met, the assertion should trigger an error message displaying the expected value (`i.e.,fetch_pc_i + branch_imm`)  versus the actual  `predict_branch_pc_o` that  does not match.\n\n**2. Branch Taken (`predict_branch_taken_o`) Validation**:\nAt every clock cycle, after 10-time units delay, the branch is taken signal (`predict_branch_taken_o)` must equal the result of the logical AND of `fetch_valid_i` and the logical OR of `instr_jal`, `instr_jalr`, `instr_cj`, `instr_b_taken`. If this condition is violated, the assertion should trigger an error message showing the expected outcome versus the actual `predict_branch_taken_o` does not match.\n\nFollowing should be the interface of the RTL design of the Static Branch Predict module named `static_branch_predict`.\n## Interface:\n### **Inputs**:\n- `clk (1-bit)`: Clock signal for executing the assertions.\n- `fetch_rdata_i (32-bit,[31:0])`: Instruction fetched from the fetch stage.\n- `fetch_pc_i (32-bit,[31:0])`: Program counter corresponding to the fetched instruction.\n- `register_addr_i (32-bit,[31:0])`: Register address or value used for the immediate value for JALR instruction.\n- `fetch_valid_i (1-bit)`: Indicates that the fetch stage has provided a valid instruction.\n\n### **Outputs**:\n- `predict_branch_taken_o (1-bit)`: Indicates whether the branch is predicted to be taken.\n- `predict_branch_pc_o (32-bit,[31:0])`: The calculated branch target PC based on the immediate value for each branch instruction.", "context": {"rtl/static_branch_predict.sv": "module static_branch_predict (\n  input  logic  clk,\n  // Instruction from fetch stage\n  input  logic [31:0] fetch_rdata_i,\n  input  logic [31:0] fetch_pc_i,\n  input  logic [31:0] register_addr_i,\n  input  logic        fetch_valid_i,\n\n  // Prediction for supplied instruction\n  output logic        predict_branch_taken_o,\n  output logic [31:0] predict_branch_pc_o\n);\n  logic [31:0] reg_addr;\n  logic [31:0] imm_jal_type;\n  logic [31:0] imm_jalr_type;\n  logic [31:0] imm_b_type;\n  logic [31:0] imm_cj_type;\n  logic [31:0] imm_cb_type;\n\n  logic [31:0] branch_imm;\n\n  logic [31:0] instr;\n\n  logic instr_jal;\n  logic instr_jalr;\n  logic instr_b;\n  logic instr_cj;\n  logic instr_cb;\n\n  logic instr_b_taken;\n  \n    \n  localparam OPCODE_BRANCH = 7'h63;\n  localparam OPCODE_JAL    = 7'h6F;\n  localparam OPCODE_JALR   = 7'h67;\n\n  assign instr = fetch_rdata_i;\n  assign reg_addr = register_addr_i;\n\n  assign imm_jal_type = { {12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 };\n  assign imm_jalr_type = {{20{instr[31]}}, instr[31:20]}+reg_addr;\n  assign imm_b_type = { {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 };\n\n  assign imm_cj_type = { {20{instr[12]}}, instr[12], instr[8], instr[10:9], instr[6], instr[7],\n    instr[2], instr[11], instr[5:3], 1'b0 };\n\n  assign imm_cb_type = { {23{instr[12]}}, instr[12], instr[6:5], instr[2], instr[11:10],\n    instr[4:3], 1'b0};\n\n  assign instr_b    = instr[6:0] == OPCODE_BRANCH;\n  assign instr_jal  = instr[6:0] == OPCODE_JAL;\n  assign instr_jalr = instr[6:0] == OPCODE_JALR;\n\n  assign instr_cb = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b110) | (instr[15:13] == 3'b111));\n  assign instr_cj = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b101) | (instr[15:13] == 3'b001));\n\n always_comb begin\n    branch_imm = imm_b_type;\n\n    case(1'b1)\n      instr_jal  : branch_imm = imm_jal_type;\n      instr_jalr : branch_imm = imm_jalr_type;\n      instr_b    : branch_imm = imm_b_type;\n      instr_cj   : branch_imm = imm_cj_type;\n      instr_cb   : branch_imm = imm_cb_type;\n      default    : ;\n    endcase\n  end\n  \n  assign instr_b_taken = (instr_b & imm_b_type[31]) | (instr_cb & imm_cb_type[31]);\n  assign predict_branch_taken_o = fetch_valid_i & (instr_jal | instr_jalr | instr_cj | instr_b_taken);\n  assign predict_branch_pc_o    = fetch_pc_i + branch_imm;\n  \nendmodule"}}, "output": {"response": "", "context": {"rtl/static_branch_predict.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/static_branch_predict.sv\nTOPLEVEL        = static_branch_predict\nMODULE          = test_static_branch_predict\nPYTHONPATH      = /src\nHASH            = 32-static_branch_predict_tb_assertion_generation\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_static_branch_predict.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import Timer\nfrom random import randint\n\n# Cocotb testbench for static branch predictor module\n@cocotb.test()\nasync def test_static_branch_predict(dut):\n    \"\"\"Test Static Branch Predictor for different branch and jump scenarios.\"\"\"\n    dut.clk.value = 0\n           \n    # Clock generation\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    # Define the test vectors based on the SystemVerilog run_test_case task\n    test_vectors = [\n        # Format: (test_instr, test_pc, test_register_operand, test_valid, expected_taken, expected_pc, case_name)\n        (0x8C218363, 0x00001000, 0x00000000, 1, 1, 0x000000C6, \"Branch taken, PC offset negative (B-type), [BEQ]\"),\n        (0x6C2183E3, 0x00001000, 0x00000000, 1, 0, 0x00001EC6, \"Branch taken, PC offset positive (B-type), [BEQ]\"),\n        (0x926CF16F, 0x00001000, 0x00000000, 1, 1, 0xFFFD0126, \"Jump taken (J-type) with negative offset, [JAL]\"),\n        (0x126CF16F, 0x00001000, 0x00000000, 1, 1, 0x000D0126, \"Jump taken (J-type) with positive offset, [JAL]\"),\n        (0xF63101E7, 0x00001000, 0x00000000, 1, 1, 0x00000F63, \"Jump taken (JALR) with negative offset, [JALR]\"),\n        (0x763101E7, 0x00001000, 0x00000000, 1, 1, 0x00001763, \"Jump taken (JALR) with positive offset, [JALR]\"),\n        (0x4840006F, 0x00001000, 0x00000000, 1, 1, 0x00001484, \"Compressed Jump taken (J-type) with positive offset, [C.J]\"),\n        (0x484000EF, 0x00001000, 0x00000000, 1, 1, 0x00001484, \"Compressed Jump taken (J-type) with positive offset, [C.JAL]\"),\n        (0x08040A63, 0x00001000, 0x00000000, 1, 0, 0x00001094, \"Compressed Branch Taken, PC offset positive (B-type), [C.BEQZ]\"),\n        (0x00000001, 0x00002000, 0x00000000, 0, 0, 0x00002000, \"Invalid fetch (not valid)\"),\n        (0x00000000, 0x00002000, 0x00000000, 1, 0, 0x00002000, \"No branch or jump\"),\n        (0xFE000E63, 0x00001000, 0x00000000, 1, 1, 0x000007FC, \"Improper Instruction Encoding\"),\n    ]\n\n    # Iterate through the test vectors and apply them to the DUT\n    for (test_instr, test_pc, test_register_operand, test_valid, expected_taken, expected_pc, case_name) in test_vectors:\n        # Apply inputs\n        dut.fetch_rdata_i.value = test_instr\n        dut.fetch_pc_i.value = test_pc\n        dut.register_addr_i.value = test_register_operand\n        dut.fetch_valid_i.value = test_valid\n\n        # Wait for the DUT to process the inputs\n        await Timer(10, units=\"ns\")\n\n        # Capture the outputs\n        actual_taken = dut.predict_branch_taken_o.value\n        actual_pc = dut.predict_branch_pc_o.value\n\n        # Log the test case details\n        dut._log.info(f\"Running test case: {case_name}\")\n        dut._log.info(f\"fetch_rdata_i: {test_instr:08X}, fetch_pc_i: {test_pc:08X}, Register Operand: {test_register_operand:08X}, Valid: {test_valid}\")\n        dut._log.info(f\"Expected Taken: {expected_taken}, Actual Taken: {actual_taken}\")\n        dut._log.info(f\"Expected PC: {expected_pc:08X}, Actual PC: {int(actual_pc):08X}\")  # Fixed the error here\n\n        # Assertions to check if outputs match expectations\n        assert actual_taken == expected_taken, f\"{case_name} - Predict Branch Taken Mismatch: Expected {expected_taken}, Got {actual_taken}\"\n        assert int(actual_pc) == expected_pc, f\"{case_name} - Predict Branch PC Mismatch: Expected {expected_pc:08X}, Got {int(actual_pc):08X}\"\n\n        # Wait for a short time before the next test case\n        await Timer(10, units=\"ns\")\n\n    # Additional random test cases\n    num_random_tests = 10  # Number of random tests to generate\n    for i in range(num_random_tests):\n        # Generate random values for instruction, PC, register operand, and valid signal\n        test_instr = randint(0, 0xFFFFFFFF)\n        test_pc = randint(0, 0xFFFFFFFF)\n        test_register_operand = randint(0, 0xFFFFFFFF)\n        test_valid = randint(0, 1)\n\n        # Apply inputs\n        dut.fetch_rdata_i.value = test_instr\n        dut.fetch_pc_i.value = test_pc\n        dut.register_addr_i.value = test_register_operand\n        dut.fetch_valid_i.value = test_valid\n\n        # Wait for the DUT to process the inputs\n        await Timer(10, units=\"ns\")\n\n        # Capture the outputs\n        actual_taken = dut.predict_branch_taken_o.value\n        actual_pc = dut.predict_branch_pc_o.value\n\n        # Log the random test case details\n        dut._log.info(f\"Random Test Case {i + 1}\")\n        dut._log.info(f\"fetch_rdata_i: {test_instr:08X}, fetch_pc_i: {test_pc:08X}, Register Operand: {test_register_operand:08X}, Valid: {test_valid}\")\n        dut._log.info(f\"Predict Branch Taken: {actual_taken}, Predict Branch PC: {int(actual_pc):08X}\")  # Fixed the error here\n\n        # Randomized cases do not have specific expected values, so only check for consistency of output types and log results\n        assert actual_taken in [0, 1], f\"Random Test Case {i + 1} - Invalid Predict Branch Taken Output: Got {actual_taken}\"\n        assert isinstance(int(actual_pc), int), f\"Random Test Case {i + 1} - Predict Branch PC Output Not Integer: Got {int(actual_pc)}\"\n\n        # Wait for a short time before the next random test case\n        await Timer(10, units=\"ns\")\n\n"}}}
{"id": "cvdp_copilot_static_branch_predict_0035", "categories": ["cid012", "medium"], "input": {"prompt": "Create a SystemVerilog testbench module named `tb_static_branch_predict` that instantiates the `static_branch_predict` module as the Unit Under Test (UUT). The testbench must include a stimulus generator that systematically drives various input conditions to achieve a minimum of 95% code and functional coverage for the `static_branch_predict` module.  The `static_branch_predict` takes a 32-bit branch or jump RISC-V instruction as input and predicts whether that branch will occur based on the conditions indicated in the instruction.\n\n## Design Specification:\nThe `static_branch_predict` module takes in a 32-bit RV32I (RISC V 32-bit base Integer ISA) conditional branch and unconditional jump instructions as input. This module generally exists as part of the Instruction Fetch Stage of a pipelined processor. The branch and jump instruction can be either from the RV32I Instruction Set or from the RV32C Instruction Set. The branch and jump instructions as part of the RV32I Instruction Set are 32-bit in width, whereas those belonging to the RV32C Instruction Set are 16-bit in width. The 16-bit RV32C branch and jump instructions are converted into an equivalent 32-bit RV32I instruction using a specialized circuit called Instruction Decompresser before being applied to this module. For the module to recognize the 32-bit equivalent of the 16-bit branch and jump instructions, the inputs are properly formatted into a 32-bit value and applied. The Instruction Decompresser is not instantiated into the branch predictor module. Based on the instruction's offset in the case of the branch instruction and based on instruction in the case of a jump instruction, the branch predictor outputs two signals (i) a 1-bit signal to indicate whether the branching will occur for a given instruction or not (ii) If branching occurs, to which 32-bit address it has to get branched.\n\n## Key Assumptions and Constraints:\n- Only uncompressed 32-bit instructions are applied as input to this module.\n- The module operates in a purely combinational manner without requiring any state elements such as registers.\n- The Instruction Decompressor is outside the scope of this module, and the equivalent 32-bit uncompressed instruction is \n  given as input.\n\n### Introduction to RISC V:\nRISC-V is a royalty-free open-source instruction set architecture, which anyone can utilize to implement a processor microarchitecture (i.e. processor hardware). The RISC-V ISA consists of three variants of Integer ISA namely RV32I (32-bit instructions to handle 32-bit data), RV64I (32-bit instructions to handle 64-bit data), and RV128I (32-bit instructions to handle 128-bit data). In addition to these, there are 14 extensions. One of the extensions that will be considered in this module is RV32C (16-bit ISA called Compressed RISC-V ISA)\n\n## RV32I Branch and Jump Instructions\nThe RISC-V RV32I instruction set includes both unconditional jump and conditional branch instructions. Below, we describe the encodings and behaviors for these types of instructions.\n### Unconditional Jump Instructions(JAL and JALR)\n`JAL` (Jump and Link instruction):\n    -  Branches to an address obtained by adding the 32-bit program counter (pc) to a sign-extended 20-bit offset encoded in the instruction.\n    -  Returns to resume execution from the address stored in the 32-bit link register (x1 or x5) after completing the branched subroutine. A link register (also called a return address register) is the one that holds the address from where the processor has to resume its execution after returning from a subroutine. \n**Instruction Encoding**:\n\n**|   31 -  imm[20]   |    30:21 - imm[10:1]    |     20 - imm[11]       |       19 : 12 - imm[19:12]      | 11 : 7 - rd   | 6 : 0  - 7'h6F   |**\n\n            \nAssembler syntax for JAL instruction :  jal  rd ,  imm[20:1]\n           \nTarget Address  calculated for this instruction : \n\nrd <--- pc + {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 };\n\nwhere {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 } - 32-bit sign extended offset or immediate. \nHere, `rd` is a 5-bit number to identify the 32-bit destination register; `pc` - 32-bit program counter.\n  \n`JALR` (Jump and Link Register instruction): \n - Branches to an address obtained by adding the 32-bit program counter to a sign-extended 12-bit offset present in a register specified in the instruction.\n\nThe instruction encoding for 32-bit uncompressed JALR instruction \n**Instruction Encoding**:\n \n**|   31 :20 -  imm[11:0]   |    19:15 - rs1   |     14:12 - 000      |      11 : 7 - rd      | 11 : 7 - rd   | 6 : 0  - 7'h67   |**             \n            \nAssembler syntax for JAL instruction:  jalr  rd,  rs1, imm[11:0]  \n\nTarget address calculated for this instruction : \nrd <-pc + {{20{instr[31]}}, instr[31:20]} + rs1\n                           \nwhere \n {{20{instr[31]}}, instr[31:20]} + rs1 - 32-bit sign extended offset or immediate                          \nHere `rd` is the 5-bit number to identify a 32-bit destination register; `rs1` is the 5-bit number to identify the 32-bit source register; `pc` - 32-bit program counter\n                           \n### Conditional Branch Instructions (BXXX) :\n  - Takes in two operands (rs1 and rs2), compares them, and branches based on the comparison result.\n  - The target address is obtained by adding the pc to a sign-extended 12-bit offset encoded in the instruction.\n\n The instruction encoding for the 32-bit uncompressed Branch instruction\n\n**Instruction Encoding**:\n \n**| 31 -  imm[12]|30:25 - imm[10:5]|24:20 - rs2 | 14 : 12 - func3| 11 : 8 -  imm[4:1]|7 - imm[11]| 6 : 0  - 7'h63   |**          \n      \nAssembler syntax for Branch instruction:  bxxx rs1, rs2, offset\n        \nHere `rs1` and `rs2`  are the 5-bit numbers to identify the 32-bit source registers which will be used for comparison\n        \nTarget address calculated for this instruction : \npc + { {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 };\n\nwhere,\n{ {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 } - 32-bit sign extended offset or immediate; `pc` - 32-bit program counter\n\nThe different types of branch instruction :\n- beq       rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b000)\n- bne       rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b001)\n- blt         rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b100)\n- bltu       rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b110)\n- bge       rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b101)\n- bgeu     rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b111)\n                               \n ## RV32C Branch and Jump Instructions :\n The RV32C compressed instructions are 16-bit wide, but before applying them to this module, they are converted to their equivalent 32-bit uncompressed form using an external decompressor circuit. The following sections describe how these instructions are handled.\n \n   \n ### C.J / C.JAL Instructions: \n  - Equivalent to the RV32I JAL instruction, with different function codes.\n    \nThe instruction encoding for the 16-bit compressed jump instruction is given below:\n**Instruction Encoding**:\n**| 15 : 13 - func3 | 12:2- imm[11:1]| 1 : 0 - 01 |**              \n  \nAssembler syntax for C.J  instruction:   c.j offset[11:1]\nAssembler syntax for C.JAL instruction:  c.jal offset [11:1]\n             \n`func3` is a 3-bit code that differentiates between C.J and C.JAL instruction.\nThe 3-bit function code for C.J is 101 and C.JAL is 001.\n  \nIts equivalent 32-bit uncompressed instruction encoding is given by :\n**Instruction Encoding**:\n \n**| 31  -  instr_c[12] | 30 -instr_c[8] | 29 : 28 - instr_c[10:9]| 27 -  instr_c[6]| 26-  instr_c[7]| 25 - instr_c[2] | 24- instr_c[11]|**\n\n**| 23 :  21 -  instr_c[5:3]  | 20 : 12  - {9{instr_c[12]}}| 11 : 8 - 4'b0000 | 7 - ~instr_c[15] | 6 : 0 - 7'h6F   |**              \n   \n   Only C.J and C.JAL instructions are supported by this module.\n   \n   Other Compressed Jump Instructions that RV32C supports are C.JR and C.JALR, but these are not being tested by the module.\n   \n### C.BEQZ / C.BNEZ Instructions:\n\nEquivalent to the RV32I BXXX instructions but check whether the content of the specified register(rs1') is zero or not.\n                                               \nThe instruction encoding for the 16-bit compressed branch instruction is given below:\n**Instruction Encoding**:\n**| 15 : 13 - func3 | 12 : 10 - imm[8:6]    | 9 : 7 - rs1'  | 6 : 3 -  imm[4:1]| 2 -  imm[5]| 1 : 0 - 01  |**\n\n- func3 is a 3-bit code that differentiates between C.BEQZ and C.BNEZ instruction\n- The 3-bit function code for Compressed Branch EQual Zero (C.BEQZ) is 110 and that of Compressed Branch Not \n   Equal Zero (C.BNEZ) is 111\n \n Assembler syntax for C.BEQZ instruction:  c.beqz rs1' , offset[8:1]\n Assembler syntax for C.BNEZ instruction:  c.bnez rs1', offset[8:1]\n          \n Its equivalent 32-bit uncompressed instruction encoding is given by :\n**Instruction Encoding**:\n**| 31 : 28 - {4{instr_c[12]}} | 27 : 26 - instr_c[6:5] | 25 - instr_c[2]| 24 : 20 - 5'b00000 | 19 : 18 - 2'b01 | 17 : 15 - instr_c[9:7] |**\n\n**| 14 :  13 - 2'b00  | 12  - instr_c[13] | 11 : 10 -  instr_c[11:10] | 9 : 8 - instr_c[4:3] | 7 -  instr_c[12]  | 6 : 0 - 7'h63  |**\n\n### Only Supported Instructions\n- The following instructions are supported by this module:\n\n  - Uncompressed Instructions: JAL, JALR, BXXX.\n  - Compressed Instructions: C.J, C.JAL, C.BEQZ, C.BNEZ.\n  - For all other instructions, fetch_valid_i will be 0, indicating that they will not be predicted as taken.\n\n\n \n### Concept of Sign Extension of Immediate(or Offset) in the RISC V Control Transfer Instruction :\n\nSign extension refers to identifying the sign bit of an operand and replicating it at the higher significant positions to increase the operand width to the desired value.\nIllustration :\nSuppose there is 8-bit data, data[7:0], say 8'b0110_1110. Suppose this has to be stored in a 32-bit register rd.\n\n\n| Bit Position : Bit Value    | 7 : 0  | 6 : 1  | 5 : 1  | 4: 0  | 3 : 1  | 2 : 1  | 1 : 1 | 0 : 0 |\n                \nHere the bit at position 7 is called sign-bit; Since it is 0, it indicates that it is a positive value. Hence, will be replicated in the higher 24-bit positions (i.e. from bit position 8 to bit position 31) to form a 32-bit value. This is represented in shorthand as\n                                                      rd <---  {{24{0}} , data_i[7:0]};\n                                                      \n### Static Branch Prediction Algorithm :\n### For Branch Instruction:\n- Immediate Extraction:\n    Extract the immediate value from the branch instruction.\n- Sign Extension:\n    Sign extend the immediate to 32 bits.\n- Prediction Logic and Target Address Calculation:\n   If the sign bit of the immediate is 1, the branch is predicted to be taken.\n   Otherwise, it is predicted as not taken.\n   The 32-bit program counter is added to the sign-extended offset or sign-extended immediate to form the target address\n\n### For Jump Instruction:\n- Immediate Extraction:\n   Extract the immediate value from the jump instruction.\n- Sign Extension:\n  Sign extend the immediate to 32 bits.\n- Prediction Logic and Target Address Calculation:\n   Always predict jumps (JAL, JALR, C.J, C.JAL) as taken.\n   The 32-bit program counter is added to the sign-extended offset or sign-extended immediate to form the target address\n\n## What do the words `taken` and `not-taken` signify in case of branch prediction :\n- Taken: The branch will occur, and execution will continue at the target address.   \n- Not-Taken: The branch will not occur, and execution continues sequentially.\n\n### Interface :\n\n#### Inputs:\n- `fetch_rdata_i` ([31:0], 32-bit): The fetched instruction data from the instruction memory or pipeline.\n- `fetch_pc_i` ([31:0], 32-bit): Program counter (PC) value of the fetched instruction.\n- `fetch_valid_i` (1-bit): Active HIGH Indicates the validity of the fetched instruction.\n\n#### Outputs:\n- `predict_branch_taken_o` (1-bit): Active HIGH indicates whether the branch or jump is predicted as taken.\n- `predict_branch_pc_o` ([31:0], 32-bit): Predicted target address for a taken branch or jump instruction\n\n### Internal registers and parameters:\n\n#### Localparams :\n -  OPCODE_BRANCH = 7'h63\n -  OPCODE_JAL          = 7'h6F;\n -  OPCODE_JALR       = 7'h67;\n\n#### Immediate:\n- `imm_j_type` ([31:0], 32-bit): Immediate for uncompressed jump (JAL) instructions, sign-extended.\n- `imm_b_type` ([31:0], 32-bit): Immediate for uncompressed branch instructions, sign-extended.\n- `imm_cj_type` ([31:0], 32-bit): Immediate for compressed jump instructions, sign-extended.\n- `imm_cb_type` ([31:0], 32-bit): Immediate for compressed branch instructions, sign-extended.\n- `branch_imm` ([31:0], 32-bit): One of the immediate values: `imm_j_type` or `imm_b_type` or `imm_cj_type` or `imm_cb_type`.\n\n### Signals and Logic :\n#### Control Signals:\n- `instr` ([31:0], 32-bit): Alias for the input `fetch_rdata_i` to simplify the code.\n- `instr_j`, `instr_b`, `instr_cj`, `instr_cb` (1-bit each): Signals to identify specific branch or jump types in compressed and uncompressed formats.\n- `instr_b_taken` (1-bit): Indicates whether an uncompressed or compressed branch offset is negative, implying that the branch is taken.\n\n**Instantiation** :\nThe testbench instantiates the `static_branch_predict` module as `uut` and connects the signals between the module and the testbench. Each input and output from the `uut` is connected to its corresponding signal in the testbench.\n\n## **Input Generation and Validation**:\n- Stimulus: Several test cases must be applied to simulate various operations of the static branch predictor. These test cases should cover a range of scenarios, including branch instructions with positive and negative offsets, jump instructions (both JAL and JALR), compressed jump and branch instructions, as well as invalid fetch conditions and non\u2010branch operations. For each case, the relevant signals (`predict_branch_taken_o`, `predict_branch_pc_o`) have to be displayed immediately after the application of inputs (`fetch_rdata_i`, `fetch_pc_i`, `register_addr_i`, `fetch_valid_i`).\n\n- **Test Case 1: Branch taken, PC offset negative (B-type) [BEQ]**\nTest a BEQ instruction with a negative offset, expecting the branch to be taken with the target PC computed accordingly.\n\n- **Test Case 2: Branch taken, PC offset positive (B-type) [BEQ]**\nTest a BEQ instruction with a positive offset, ensuring correct branch prediction and target PC calculation for a forward branch.\n\n- **Test Case 3: Jump taken (J-type) with negative offset [JAL]**\nApply a JAL instruction with a negative offset to validate that the jump is correctly predicted and the computed PC reflects a backward jump.\n\n- **Test Case 4: Jump taken (J-type) with positive offset [JAL]**\nUse a JAL instruction with a positive offset to verify the proper prediction of a forward jump with the correct target PC.\n\n- **Test Case 5: Jump with valid false (JAL)**\nApply a JAL instruction with fetch_valid_i deasserted, ensuring that no branch prediction is produced.\n\n- **Test Case 6: Jump Register (JALR) taken with negative offset (reg = 0) [JALR]**\nTest a JALR instruction with a negative offset using a zero register operand to confirm correct target PC computation.\n\n- **Test Case 7: Jump Register (JALR) taken with positive offset (reg = 0) [JALR]**\nTest a JALR instruction with a positive offset using a zero register operand.\n\n- **Test Case 8: Jump Register (JALR) taken with negative offset (nonzero reg) [JALR]**\nApply a JALR instruction with a negative offset using a nonzero register operand to exercise immediate addition.\n\n- **Test Case 9: Jump Register (JALR) taken with positive offset (nonzero reg) [JALR]**\nApply a JALR instruction with a positive offset using a nonzero register operand to verify proper computation.\n\n- **Test Case 10: Jump Register (JALR) with valid false [JALR]**\nTest a JALR instruction with fetch_valid_i deasserted, ensuring no prediction is produced.\n\n- **Test Case 11: Compressed Jump taken (C.J) with positive offset [C.J]**\nTest a compressed jump instruction with encoding 3'b101 and bit12 = 0, yielding a positive immediate for jump target calculation.\n\n- **Test Case 12: Compressed Jump taken (C.J) with negative offset [C.J]**\nTest a compressed jump instruction with encoding 3'b001 and bit12 = 1, producing a negative immediate for a backward jump.\n\n- **Test Case 13: Compressed Branch not taken (C.BEQZ) with 3'b110 encoding [C.BEQZ]**\nTest a compressed branch instruction with encoding 3'b110 and bit12 = 0, expecting the branch not to be taken.\n\n- **Test Case 14: Compressed Branch taken (C.BEQZ) with 3'b110 encoding [C.BEQZ]**\nTest a compressed branch instruction with encoding 3'b110 and bit12 = 1, expecting the branch to be taken.\n\n- **Test Case 15: Compressed Branch not taken (C.BEQZ) with 3'b111 encoding [C.BEQZ]**\nTest a compressed branch instruction with encoding 3'b111 and bit12 = 0, ensuring the branch is not taken.\n\n- **Test Case 16: Compressed Branch taken (C.BEQZ) with 3'b111 encoding [C.BEQZ]**\nTest a compressed branch instruction with encoding 3'b111 and bit12 = 1, expecting the branch to be taken.\n\n- **Test Case 17: Default non\u2010branch (zero instruction)**\nApply an all\u2011zeros instruction to verify that no branch or jump is predicted.\n\n- **Test Case 18: Default non\u2010branch (random instruction)**\nApply a random non\u2011branch instruction, confirming that the predictor remains inactive.\n\n- **Test Case 19: Default non\u2010branch with valid false**\nApply a non\u2011branch instruction with 1fetch_valid_i1 deasserted, ensuring no prediction occurs.\n\n- **Test Case 20: Default non\u2010branch (all ones)**\nApply an instruction of all ones, verifying default non\u2011branch behavior.\n\n- **Test Case 21: Default non\u2010branch (instruction with lower 2 bits \u2260 01)**\nTest an instruction that does not meet the compressed instruction format, confirming non\u2011branch operation.\n\n- **Test Case 22: Default non\u2010branch (random pattern)**\nApply a random instruction that does not correspond to any branch or jump, ensuring default behavior.\n\n- **Test Case 23: Default non\u2010branch (random pattern with valid false)**\nApply a random non\u2011branch instruction with fetch_valid_i deasserted.\n\n- **Test Case 24: Custom JAL with positive immediate [JAL custom]**\nTest a custom JAL instruction with a positive immediate (with instr[31] = 0) to verify proper immediate generation.\n\n- **Test Case 25: Custom JAL with negative immediate [JAL custom]**\nTest a custom JAL instruction with a negative immediate (with instr[31] = 1).\n\n- **Test Case 26: Custom JALR with positive immediate [JALR custom]**\nTest a custom JALR instruction with a positive immediate (with instr[31] = 0).\n\n- **Test Case 27: Custom JALR with negative immediate [JALR custom]**\nTest a custom JALR instruction with a negative immediate (with instr[31] = 1).\n\n- **Test Case 28: Custom BEQ with positive offset [BEQ custom]**\nTest a custom BEQ instruction with a positive offset (with instr[31] = 0) to verify correct prediction.\n\n- **Test Case 29: Custom BEQ with negative offset [BEQ custom]**\nTest a custom BEQ instruction with a negative offset (with instr[31] = 1).\n\n- **Test Case 30: Custom Compressed Jump with varied immediate [CJ custom]**\nTest a custom compressed jump instruction (CJ) with varied immediate fields (using encoding 3'b101).\n\n- **Test Case 31: Custom Compressed Branch taken [CB custom]**\nTest a custom compressed branch instruction (CB) with encoding 3'b110 and bit12 = 1, expecting the branch to be taken.\n\n- **Test Case 32: Custom Compressed Branch not taken [CB custom]**\nTest a custom compressed branch instruction (CB) with encoding 3'b110 and bit12 = 0, expecting the branch not to be taken.\n\n- **Test Case 33: JALR with large register operand**\nTest a JALR instruction with a large register operand to exercise potential arithmetic overflow in immediate addition.\n\n- **Test Case 34: Default non\u2010branch (pattern with lower 2 bits \u2260 01)**\nApply a default instruction pattern where the lower two bits are not 01, confirming non\u2011branch operation.\n\n- **Test Case 35: JALR with nonzero register and valid false**\nTest a JALR instruction with a nonzero register operand but with fetch_valid_i deasserted, ensuring no prediction is produced.\n\n- **Test Case 36: Default case with non\u2011matching compressed encoding**\nApply an instruction with lower 2 bits equal to 01 and bits [15:13] that do not match any CJ or CB encoding, thereby exercising the default branch in the case statement.\n\n- **Test Case 37: JALR with register operand causing potential overflow**\nTest a JALR instruction with a register operand that may cause arithmetic overflow during the immediate addition.\n\n- **Test Case 38: JALR with positive offset and register causing overflow**\nTest a JALR instruction with a positive offset and a register value that leads to overflow in addition.\n\n- **Test Case 39: Custom JAL with varied immediate fields**\nTest a custom JAL instruction specifically constructed to exercise the full concatenation of the JAL immediate fields.\n\n- **Test Case 40: JALR with negative register operand**\nTest a JALR instruction with a negative (two\u2019s complement) register operand to further verify the immediate addition in JALR.\n\n- **Test Case 41: BEQ with valid false**\nApply a BEQ instruction with fetch_valid_i deasserted to ensure that even a branch instruction is suppressed.\n\n- **Test Case 42: Compressed Branch with valid false**\nApply a compressed branch instruction (CB) with fetch_valid_i deasserted, ensuring no branch prediction is produced.\n\n- **Test Case 43: Default branch (non\u2011matching compressed encoding)**\nTest an instruction with lower 2 bits equal to 01 and bits [15:13] equal to 000\u2014which does not match any CJ or CB encoding\u2014ensuring that the default branch in the case statement is exercised.\n\n- **Test Case 44: JALR with minimal nonzero register operand**\nTest a JALR instruction with a minimal nonzero register operand to confirm proper handling of small register values.\n\n- **Test Case 45: Compressed Jump taken (C.J) with negative offset [C.J]**\nTest a compressed jump instruction with encoding 3'b101 and bit12 = 1, forcing a negative immediate for a backward jump.\n\n- **Test Case 46: Custom Compressed Branch with unique immediate fields**\nTest a custom compressed branch (CB) instruction with unique immediate field settings to exercise additional bit slices in CB decoding.\n\n- **Test Case 47: Custom Compressed Jump with unique immediate fields**\nTest a custom compressed jump (CJ) instruction with unique immediate field values to cover remaining combinational logic in CJ decoding.\n\n- **Test Case 48: Custom Compressed Jump with unique immediate fields (CJ)**\nTest a custom compressed jump (CJ) instruction\u2014crafted from a 16\u2010bit pattern (0x2D6D extended to 32 bits)\u2014that specifically sets the lower 2 bits to 01, bits [15:13] to 001, and forces distinct values in bits [12], [11], [10:9], [8], and the lower nibble.\n\n\n## Module Functionality: \n#### Combinational Logic\n- `Immediate Extraction`: The immediate branches and jumps are extracted from the instruction, with an appropriate sign extension based on the instruction type.\n- `Instruction Type Decoding`: Decodes whether the instruction is an uncompressed branch (instr_b), an uncompressed jump (instr_j), a compressed branch (instr_cb), or a compressed jump (instr_cj) based on opcode and bit patterns.\n- `Target Address Calculation`: Determines the branch offset and computes the target PC for the predicted branch or jump.\n\n#### Branch Prediction:\n\n-  `Uncompressed Branch/Jump Detection`: Detection of uncompressed instructions (JAL, JALR, BXXX) uses opcode\n   matching to identify the instruction type.\n\n- `Compressed Branch/Jump Detection`: Compressed branch/jump instructions (C.J, C.JAL, C.BEQZ, C.BNEZ) are provided\n  in their 32-bit uncompressed form. This module directly uses opcodes and fields from the uncompressed equivalent\n  to determine the offset and perform the prediction.\n  \n- `Offset-Based Prediction ': Branches are predicted as taken if the offset is negative. These predictions are assigned to \n   the signal `instr_b_taken`.\n\n\n#### Branch or Jump Prediction:\n\n- For jumps (`instr_j`, `instr_cj`), the module always predicts the instruction as taken.\n- For branches, the module uses the `instr_b_taken` signal to decide.\n\n#### Output Prediction Logic:\n\n- `predict_branch_taken_o` is asserted(active-high) if the instruction is predicted to be taken.\n- `predict_branch_pc_o` is calculated by adding `fetch_pc_i` to `branch_imm`, giving the predicted target address.", "context": {}}, "output": {"response": "", "context": {"verif/tb_static_branch_predict.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 670d5442d1727a032598e6d80037688df979ac70\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/static_branch_predict.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n        \n        \n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n", "src/static_branch_predict.sv": "module static_branch_predict (\n  \n  // Instruction from fetch stage\n  input  logic [31:0] fetch_rdata_i,\n  input  logic [31:0] fetch_pc_i,\n  input  logic [31:0] register_addr_i,\n  input  logic        fetch_valid_i,\n\n  // Prediction for supplied instruction\n  output logic        predict_branch_taken_o,\n  output logic [31:0] predict_branch_pc_o\n);\n  logic [31:0] reg_addr;\n  logic [31:0] imm_jal_type;\n  logic [31:0] imm_jalr_type;\n  logic [31:0] imm_b_type;\n  logic [31:0] imm_cj_type;\n  logic [31:0] imm_cb_type;\n\n  logic [31:0] branch_imm;\n\n  logic [31:0] instr;\n\n  logic instr_jal;\n  logic instr_jalr;\n  logic instr_b;\n  logic instr_cj;\n  logic instr_cb;\n\n  logic instr_b_taken;\n  \n    \n  localparam OPCODE_BRANCH = 7'h63;\n  localparam OPCODE_JAL    = 7'h6F;\n  localparam OPCODE_JALR   = 7'h67;\n\n  \n  assign instr = fetch_rdata_i;\n  assign reg_addr = register_addr_i;\n\n  assign imm_jal_type = { {12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 };\n  assign imm_jalr_type = {{20{instr[31]}}, instr[31:20]}+reg_addr;\n  assign imm_b_type = { {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 };\n\n  \n  assign imm_cj_type = { {20{instr[12]}}, instr[12], instr[8], instr[10:9], instr[6], instr[7],\n    instr[2], instr[11], instr[5:3], 1'b0 };\n\n  assign imm_cb_type = { {23{instr[12]}}, instr[12], instr[6:5], instr[2], instr[11:10],\n    instr[4:3], 1'b0};\n\n  assign instr_b    = instr[6:0] == OPCODE_BRANCH;\n  assign instr_jal  = instr[6:0] == OPCODE_JAL;\n  assign instr_jalr = instr[6:0] == OPCODE_JALR;\n\n  \n  assign instr_cb = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b110) | (instr[15:13] == 3'b111));\n  assign instr_cj = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b101) | (instr[15:13] == 3'b001));\n\n  always_comb begin\n    branch_imm = imm_b_type;\n\n    case(1'b1)\n      instr_jal  : branch_imm = imm_jal_type;\n      instr_jalr : branch_imm = imm_jalr_type;\n      instr_b    : branch_imm = imm_b_type;\n      instr_cj   : branch_imm = imm_cj_type;\n      instr_cb   : branch_imm = imm_cb_type;\n      default    : ;\n    endcase\n  end\n\n  assign instr_b_taken = (instr_b & imm_b_type[31]) | (instr_cb & imm_cb_type[31]);\n  assign predict_branch_taken_o = fetch_valid_i & (instr_jal | instr_jalr | instr_cj | instr_b_taken);\n  assign predict_branch_pc_o    = fetch_pc_i + branch_imm;\nendmodule\n"}}}
{"id": "cvdp_copilot_swizzler_0023", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the `swizzler` module to ensure its correct functionality during simulation? The assertion should cover key aspects of the swizzler\u2019s operation, such as correct mapping of each input bit (`data_in[i]`) to the proper output bit (`data_out[j]`) based on the `MAPPING` parameter. The assertion should display an error message if any output bit does not match its expected value.\n\n---\n\n## **Key Assertions**\n\n### **1. Correct Bit Mapping**\n- **Condition**:  \n  - For each output bit index `i`, `data_out[i]` must be equal to `data_in[map_idx[i]]` when `map_idx[i]` is within the valid range \\([0, N-1]\\).  \n  - If `map_idx[i]` is out of range, `data_out[i]` should be driven to `0`.\n- **Assertion**:  \n  - Check that `data_out[i]` matches the expected bit from `data_in` based on `map_idx[i]`.  \n  - If there\u2019s a mismatch, display an error message with the expected vs. actual values along with relevant inputs (e.g., `data_in`, `map_idx`).\n\n---\n\n## **Interface**\n\n### **Parameters**\n1. `N` : Configurable width of the data path.  \n2. `MAPPING` : Parameter array specifying the bit mapping from input to output.\n\n### **Inputs**\n\n1. `data_in [N-1:0]` : Input bus to be swizzled.\n2. (Optional) Any other control signals you may wish to include for additional debugging or behavior changes.\n\n### **Outputs**\n\n1. `data_out [N-1:0]` : Output bus that reflects the mapped result.\n\n### **Expected Behavior**  \nIf the assertion fails, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/swizzler.sv": "`timescale 1ns/1ps\nmodule swizzler #(\n    parameter int N = 8,\n    parameter [N*$clog2(N)-1:0] MAPPING = {\n        3'd7, 3'd5, 3'd6, 3'd4, 3'd3, 3'd1, 3'd2, 3'd0\n    }\n)(\n    input  logic [N-1:0] data_in,\n    output logic [N-1:0] data_out\n);\n    localparam int M = $clog2(N);\n    logic [M-1:0] map_idx [N-1:0];\n\n    genvar j;\n    generate\n        for (j = 0; j < N; j++) begin : lane_mapping\n            assign map_idx[j] = MAPPING[j*M +: M];\n        end\n    endgenerate\n\n    always_comb begin\n        for (int i = 0; i < N; i++) begin : lane_mapping\n            if (map_idx[i] >=0 && map_idx[i] < N) begin\n                data_out[i] = data_in[map_idx[i]];\n            end else begin\n                data_out[i] = 1'b0;\n            end\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/swizzler.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/swizzler.sv\nTOPLEVEL        = swizzler\nMODULE          = test_swizzler\nPYTHONPATH      = /src\nHASH            = 23-assertion-generation-for-intial-level-rtl\n", "src/test_runner.py": "import os\nimport re\nimport pytest\nimport subprocess\nfrom cocotb.runner import get_runner\n\n# Read environment variables\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n# Additional parameters\nN_default       = \"8\"\nMAPPING_default = \"{3'd7,3'd5,3'd6,3'd4,3'd3,3'd1,3'd2,3'd0}\"\n\nN_val = os.getenv(\"N\", N_default)\nMAPPING_val = os.getenv(\"MAPPING\", MAPPING_default)\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n\n    # Pass parameters to the HDL build\n    # For Verilog: these become module parameters in your DUT\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        parameters={\n            \"N\":       N_val,\n            \"MAPPING\": MAPPING_val\n        },\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    # Example coverage report command (Mentor/Siemens or Cadence tools vary)\n    cmd = (\n        'imc -load /code/rundir/sim_build/cov_work/scope/test '\n        '-execcmd \"report -metrics assertion -all -aspect sim '\n        '-assertionStatus -overwrite -text -out coverage.log\"'\n    )\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage report generation failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {\n            column[i]: info[i].split('%')[0] for i in range(1, len(column))\n        }\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) \\\n            >= float(os.getenv(\"TARGET\", \"90.0\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \\\n            \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) \\\n            >= float(os.getenv(\"TARGET\", \"90.0\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) \\\n            >= float(os.getenv(\"TARGET\", \"90.0\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n", "src/test_swizzler.py": "import os\nimport random\nimport cocotb\nfrom cocotb.triggers import Timer\n\n@cocotb.test()\nasync def test_swizzler_random(dut):\n   \n    N = int(os.getenv(\"N\", \"8\"))\n   \n    cocotb.log.info(f\"Starting swizzler random test with N={N}\")\n    for cycle in range(16):\n        val = random.randint(0, (1 << N) - 1)\n        dut.data_in.value = val\n        await Timer(10, units=\"ns\")\n        cocotb.log.info(f\"Cycle: {cycle}, data_in={val:0{N}b}, data_out={int(dut.data_out.value):0{N}b}\")\n\n    cocotb.log.info(\"All random cycles completed.\")\n"}}}
{"id": "cvdp_copilot_sync_serial_communication_0009", "categories": ["cid012", "easy"], "input": {"prompt": "Write a SystemVerilog testbench for a `sync_serial_communication_tx_rx` module, which simulates the `tx_block` and `rx_block` modules and performs data transfer operations with a focus on ensuring the proper handling of data values, selection signals(`sel`), and asynchronous resets. The testbench must apply a sequence of test cases to the instantiated RTL module, focusing on data transfer operations.\n\n## Description\n\n**Inputs:**\n\n- `clk`: Clock signal for synchronization. Design works on the posedge of `clk`.\n- `reset_n`: Active-low asynchronous reset signal.\n- `sel [2:0]`:  Controls the data width for the transmitter (TX):\n    - `3'h0:` 0 bits. No transmission happens\n    - `3'h1:` 8 bits. `data_in [7:0]` is the valid data to be transmitted.\n    - `3'h2:` 16 bits. `data_in [15:0]` is the valid data to be transmitted.\n    - `3'h3:` 32 bits. `data_in [31:0]` is the valid data to be transmitted.\n    - `3'h4:` 64 bits. `data_in [63:0]` is the valid data to be transmitted.\n    - Default: 0 bits\n- `data_in [63:0]`: Input data signal.\n\n**Outputs:**\n\n- `data_out [63:0]`: Output data received from the communication module.\n- `done`: Signal indicating transmission completion.\n\n## Module Description\n\nThe `sync_serial_communication_tx_rx` module simulates serial communication behavior with configurable selection modes (`sel`).  \n- **Transmission block(`tx_block`):**\n    - The transmitter(TX) and receiver (RX) operate synchronously, driven by the same clock signal (`clk`) and reset (`reset_n`).\n    - Upon reset (reset_n) became LOW, all internal counters and registers are reset to their initial values.\n    - The transmitter (TX) is responsible for serializing 8, 16, 32, or 64-bit data input based on the `sel` signal and produces serial data.\n    - During data transfer, a gated clock signal serial_clk which operates at the frequency of clk has to be transmitted to the receiver (RX) alongside the serial data. When no data is transmitted, it remains at a fixed logic state of either HIGH or LOW.\n    - The transmitter (TX) generates the serial clock signal serial_clk that is used by both the transmitter (TX) and receiver (RX) for synchronized communication to transmit and receive one bit each during the positive edge of the clock.\n- **Receiver block(`rx_block`):**\n    - Data sampling in the receiver (RX) is valid whenever serial_clk is active.\n    - The `sel` in the RX module receives the same value of sel maintained by the TX module\n    - The receiver (RX) receives the serial data from the transmitter (TX) and reconstructs it into a 64-bit parallel output (`data_out`). \n    - The `data_out` will have the following data based on the `sel` value\n        - If `sel` is 000, `data_out` = 64'h0\n        - If `sel` is 001, `data_out` = {56'h0,data_in[7:0]}\n        - If `sel` is 010, `data_out` = {48'h0,data_in[15:0]}\n        - If `sel` is 011, `data_out` = {32'h0,data_in[31:0]}\n        - If `sel` is 100, `data_out` = data_in[63:0]\n        - default: 64'h0\n    - The `done` signal High indicates the valid output.\n- Reset behavior ensures that the system initializes correctly before starting new data transactions.\n\n## Testbench Requirements\n\n### Module Instantiation:\n\n- The `sync_serial_communication_tx_rx` module should be instantiated as uut, with all input and output signals properly connected. The testbench must achieve **100% coverage** by covering all input cases.\n\n### Input Stimulus Generation\nThe testbench implements task designed to validate a specific functionality:\n\n**drive_data task:**\n- Accepts three integer inputs: sel_mode, range, and data_in_val.\n- Waits for a positive edge of the `clk` signal.\n- Based on sel_mode, assigns different portions of data_in_val to data_in:\n    - If sel_mode == 1, assign the least significant 8 bits ([7:0]).\n    - If sel_mode == 2, assign the least significant 16 bits ([15:0]).\n    - If sel_mode == 3, assign the least significant 32 bits ([31:0]).\n    - If sel_mode == 4, assign the full 64-bit value ([63:0]).\n    - Otherwise, set range_value = 8 and data_in_rand = 64'd0.\n- Assign `data_in` = data_in_val and iterate range times, setting `sel` = sel_mode[2:0] at each iteration, synchronized to `clk`.\n- Wait for the `done` signal to be asserted.\n- Print a message displaying the values of `sel`, `data_in`, `data_out`, and `done`.\n\n**initial block:**\n- Asserts `reset_n` and initializes `data_in` to zero.\n- Calls a reset procedure.\n- Repeats a random test sequence 10,000 times:\n- Randomly selects a sel_value between 1 to 4.\n- Sets range_value and data_in_rand based on sel_value:\n    - **sel_value == 1:** range_value = 8, data_in_rand is a random 7-bit number.\n    - **sel_value == 2:** range_value = 16, data_in_rand is a random 16-bit number.\n    - **sel_value == 3:** range_value = 32, data_in_rand is a random 31-bit number.\n    - **sel_value == 4:** range_value = 64, data_in_rand is a random 64-bit number.\n    - Otherwise, range_value = 8, data_in_rand = 64'd0.\n- Calls the `drive_data` task with the generated values.\n- Calls the reset procedure.\n- After completion, waits **100 ns** and terminates the simulation.\n\nCan you implement a SystemVerilog testbench with the above specifications to thoroughly validate the task?", "context": {}}, "output": {"response": "", "context": {"verif/sync_serial_communication_top.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n   xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = b372e535ca8d53442368e0b4a1243fd3fa001576\nTARGET          = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/sync_serial_communication_top.sv /code/verif/sync_serial_communication_top.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n\n    # Open the coverage log file\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # Iterate through lines, starting from the 3rd line (index 2)\n    for line in lines[2:]:\n        try:\n            # Split the line into components\n            info = line.split()\n\n            # Ensure the line has at least 3 components\n            if len(info) < 3:\n                print(f\"Skipping malformed line: {line.strip()}\")\n                continue\n\n            # Extract and clean the module name\n            inst = re.sub(r'[\\W|]', '', info[0])  # Remove non-alphanumeric and special characters\n            avg = info[1].replace('%', '')       # Remove percentage symbol from average coverage\n            cov = info[2].replace('%', '')       # Remove percentage symbol from covered coverage\n\n            # Convert the average and covered percentages to floats\n            metrics[inst] = {\n                \"Average\": float(avg),\n                \"Covered\": float(cov)\n            }\n\n        except ValueError as e:\n            # Skip malformed lines that cannot be parsed\n            print(f\"Error parsing line: {line.strip()} - {e}\")\n            continue\n\n    # Check the target coverage for the module\n    target = float(os.getenv(\"TARGET\", \"80\"))  # Default target coverage is 90%\n    assert metrics.get(\"uut\", {}).get(\"Average\", 0) >= target, \\\n        f\"Didn't achieve the required coverage result. Expected: {target}, Got: {metrics.get('uut_sync_communication_top', {}).get('Average', 0)}\"", "src/sync_serial_communication_top.sv": "`timescale 1ns / 1ps\nmodule sync_serial_communication_tx_rx(\n    input clk,                     // Clock signal\n    input reset_n,                 // Active low reset signal\n    input [2:0] sel,               // Selection signal for TX block\n    input [63:0] data_in,          // 64-bit data input for TX block\n    output [63:0] data_out,        // 64-bit data output from RX block\n    output done                    // Done signal indicating completion\n);\n\n// Internal signals\nwire tx_out;                       // Serial data output from TX block\nwire tx_done;                      // Done signal from TX block\nwire serial_clk_in;                // Serial clock generated by TX block\n\n// Instantiate the TX block\ntx_block uut_tx_block (\n    .clk(clk),                     // Clock input to TX block\n    .reset_n(reset_n),             // Reset input to TX block\n    .data_in(data_in),             // 64-bit data input to TX block\n    .sel(sel),                     // Selection signal to TX block\n    .serial_out(tx_out),           // Serial data output from TX block\n    .done(tx_done),                // Done signal from TX block\n    .serial_clk(serial_clk_in)     // Serial clock output from TX block\n);\n\n// Instantiate the RX block\nrx_block uut_rx_block (\n    .clk(clk),                     // Clock input to RX block\n    .serial_clk(serial_clk_in),    // Serial clock input to RX block\n    .reset_n(reset_n),             // Reset input to RX block\n    .sel(sel),                     // Selection signal to RX block\n    .data_in(tx_out),              // Serial data input to RX block\n    .data_out(data_out),           // 64-bit data output from RX block\n    .done(done)                    // Done signal from RX block\n);\n\nendmodule\n\n///// tx_block\nmodule tx_block(\n    input clk,               // Clock input\n    input reset_n,           // Active-low reset input\n    input [63:0] data_in,    // 64-bit parallel data input\n    input [2:0] sel,         // Selection input to choose data width\n    output reg serial_out,   // Serial data output\n    output reg done,         // Done signal indicating completion of transmission\n    output serial_clk        // Clock for serial data transmission\n);\n\n// Internal registers\nreg [63:0] data_reg;         // Register to hold the data being transmitted\nreg [6:0] bit_count;         // Counter to track number of bits to transmit\nreg [6:0] reg_count;         // Register for counting bits for serial clock control\nreg [6:0] temp_reg_count;    // Temporary register to track reg_count\n\n// Sequential block for state control and data selection\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        // Reset all values on active-low reset\n        data_reg     <= 64'h0;\t\t\t     \t           // Clear the data register\n        bit_count    <= 7'h0;\t\t\t     \t           // Reset bit count to zero\n        reg_count    <= 7'h0;\t\t             \t       // Reset reg_count to zero\n    end else begin\n        if (done == 1'b1) begin\n\t    // Case block to determine the width of data to transmit based on the 'sel' input\n            case (sel)\n                3'b000: begin\n                    data_reg  <= 64'h0;             \t   // No data selected\n                    bit_count <= 7'd0;                     // No bits to transmit\n                end\n                3'b001: begin\n                    data_reg  <= {56'h0, data_in[7:0]};    // Transmit lowest 8 bits\n                    bit_count <= 7'd7;              \t   // 8 bits to transmit\n                end\n                3'b010: begin\n                    data_reg  <= {48'h0, data_in[15:0]};   // Transmit lowest 16 bits\n                    bit_count <= 7'd15;             \t   // 16 bits to transmit\n                end\n                3'b011: begin\n                    data_reg  <= {32'h0, data_in[31:0]};   // Transmit lowest 32 bits\n                    bit_count <= 7'd31;             \t   // 32 bits to transmit\n                end\n                3'b100: begin\n                    data_reg  <= data_in[63:0];     \t   // Transmit all 64 bits\n                    bit_count <= 7'd63;             \t   // 64 bits to transmit\n                end\n                default: begin\n                    data_reg  <= 64'h0;             \t   // Default case: no data\n                    bit_count <= 7'h0;              \t   // No bits to transmit\n                end\n            endcase\n           \n        end else if (bit_count > 7'h0) begin\n            data_reg   <= data_reg >> 1;                   // Shift the data to the right\n            bit_count  <= bit_count - 1'b1;                // Decrement the bit count\n            \n        end\n        reg_count <= bit_count;                            // Update reg_count for serial clock control\n    end\nend\n\n// Generate serial clock based on reg_count\n//`ifdef SIMULATION\nassign  #1 serial_clk = clk && (temp_reg_count !== 7'd0) ;  // To avoid SImulator issue \n//`else\n//assign  serial_clk = clk && (temp_reg_count !== 7'd0) ;  \n//`endif\n\n// Register to keep track of reg_count and use for clock gating\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n        temp_reg_count <= 7'h0;\t\t\t\t\t           // Reset temporary reg_count\n    end\n    else begin\n        temp_reg_count <= reg_count;\t\t\t           // Update temp_reg_count with current reg_count\n    end\nend\n\n\n// Sequential logic to drive the serial_out signal based on reg_count and bit_count\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n\t   serial_out <= 1'b0;\t\t\t\t                  // Reset serial output\n    end\n    else if(reg_count > 7'h0 || bit_count > 7'h0) begin\n\t   serial_out <= data_reg[0];\t\t\t              // Output the least significant bit of data_reg\n    end\nend\n\n// Set the done signal when transmission is complete (bit_count reaches zero)\nalways@(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n        done <= 1'b0;\t\t\t\t\t                  // Reset done output\n    end \n    else begin\n     if(bit_count == 7'h0) begin\n\t    done <= 1'b1; \t\t\t                          // Set done signal high when transmission is done\n     end\n     else begin \n\t    done <= 1'b0;\t\t\t\t\t                  // Clear done signal during transmission\n     end\nend\nend\n\n\nendmodule\n\n///// rx_block\nmodule rx_block(\n    input wire clk,  \t\t\t    // clock input\n    input wire reset_n,\t\t\t    // Active-low reset\n    input wire data_in,\t\t\t    // Serial input data\t\n    input wire serial_clk,\t\t    // Clock signal for serial data\n    input wire [2:0] sel,           // Selection output to choose data width\n    output reg done,\t\t\t    // Done signal to indicate data reception complete\t\t\n    output reg [63:0] data_out  \t// Parallel output data after serial operation\n\n);\n\n    // Internal registers\n    reg [63:0] data_reg;\t\t    // Register to hold incoming serial data\n    reg [7:0] bit_count;\t\t    // Counter for the number of bits received\t\n    reg [7:0] count;\t\t\t    // General purpose counter to sync with bit_count\n\n\n    // Sequential logic block to capture serial data on the rising edge of serial_clk\n    always @(posedge serial_clk or negedge  reset_n) begin\n        if (!reset_n) begin\t\t    // Reset all registers on reset_n (active low)\n            data_reg <= 64'h0;\t\t// Clear the data register\n            bit_count <= 8'd0;\t\t// Clear the bit counter\n        end else begin\n            if(done == 1'b1) begin                   // If done signal is asserted, reset the bit counter and data register  \n                bit_count <= 8'b0;\n                data_reg <= 64'h0;\n            end\n            else begin\n                 bit_count <= bit_count;\t\t\t // Maintain the bit counter if not done\n            end\n                bit_count <= bit_count + 1'b1;\t     // Increment bit count\n                data_reg[bit_count]<=data_in; \t     // Store the incoming data bit \n           end\n    end  \n    \n    // Sequential logic block to monitor the completion of data reception and update outputs\n    always@(posedge clk or negedge reset_n) begin\n    \tif(!reset_n) begin\t\t\t \t             // Reset all registers on reset_n (active low)\n    \t   count <= 8'd0;\t\t\t\t\t         // Clear the bit counter\n           done <= 1'b0;\t\t\t\t\t         // Deassert done signal\n           data_out <= 64'h0;\t\t\t\t\t     // Clear the output data register\t\t\t\t\t \n        end \n        else if(count >= bit_count && count != 8'd0) begin       // When the count reaches the bit_count, assert done and output the data\n           done <= 1'b1;\t\t\t\t             // Set done to indicate transmission complete\n           case(sel)\n            3'b000:begin\n                data_out <= 64'h0;                   // no bits to transmit\n            end\n            3'b001:begin\n                data_out <= {56'h0,data_reg};        // 8 bits of data_reg \n            end\n            3'b010:begin\n                data_out <= {48'h0,data_reg};        // 16 bits of data_reg\n            end\n            3'b011:begin\n                data_out <= {32'h0,data_reg};        // 32 bits of data_reg\n            end\n            3'b100:begin\n                data_out <= data_reg;                // 64 bits of data_reg\n            end\n            default:begin\n                data_out <= 64'h0;                   // no bits to transmit, default state\n            end\n           endcase\n        end\n        else if(bit_count > 8'd0) begin              // If bits are being received, increment the count and deassert done\n           count <= count+ 1'b1;\t\t\t\t     // Increment count\n           done <= 1'b0;\t\t\t\t\t         // Clear done signal while receiving\n        end\n        else begin  \t\t\t                     // If no bits have been received, reset the count and deassert done\n           count <= 8'd0;\t\t\t\t\t         // Reset count\n           done <= 1'b0;\t\t\t\t\t         // Clear done signal   \n        end \n    end\n\nendmodule"}}}
{"id": "cvdp_copilot_sync_serial_communication_0047", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the SystemVerilog testbench `sync_serial_communication_tb` to integrate the functionality of the checker to test the `sync_serial_communication_tx_rx` module. The testbench provided in the context already has stimulus generator for various test cases. The purpose of the testbench checker is to verify the functionality of the `sync_serial_communication_tx_rx` to ensure proper handling of data transmission and reception scenarios and confirm that the computed results match the expected outputs as per the design specification.\n\n## Design Specification:\n\nThe behavior of a `sync_serial_communication_tx_rx` data transmission happens based on different selection (`sel`) mode. The TX block of the design converts parallel data into a serial format based on the `sel` input and RX block captures incoming serial data and reconstructs it into the specified parallel data based on the `sel` input. The final module captures parallel data and outputs parallel data selected from `data_in` based on `sel` input as described below.\n\n- **3'b000:** Zero-bit data transmission.\n- **3'b001:** 8-bit data transmission.\n- **3'b010:** 16-bit data transmission.\n- **3'b011:** 32-bit data transmission.\n- **3'b100:** 64-bit data transmission.\n\n## Testbench Requirements\n**Input:**\n\n- `data_in([63:0])`: Input data to the transmitter (TX).\n- `clk(1-bit)`: Clock signal that runs at a 50:50 duty cycle. Design works on the Active posedge of clk.\n- `reset_n(1-bit)`: Active LOW asynchronous reset.\n- `sel ([2:0])`: Controls the data width for the transmitter (TX).\n\n**Outputs:**\n\n- `data_out([63:0])`: Output data from the receiver (RX).\n- `done (1-bit)`: A HIGH in this signal for one clock cycle represents the availability of the stable result of the receiver (RX), default value is 1'b0.\n- `parity_error(1-bit)`: Signal indicating the parity error that occurred during the transmission.\n\n**Internal signals:**\n- `expected_data_out([63:0])`: used for the verification to compare the `data_in`.\n\n**Example:**\n\n- `data_in([63:0]) = 64'h2a5c, sel([2:0]) = 3'b010`, for the transmitter (TX).\n- `data_out([63:0]) = 64'h2a5c` from the receiver(RX).\n- `done(1-bit) = 1'b1`.\n- `parity_error(1-bit) = 1'b0`.\n\n## Checker Requirements\n- DUT instantiation as `uut`.\n- **Drive_data Task:**\n    - Compute the `expected_data_out` based on the `sel` and `data_in`. \n    - **Assert:** If `done == 1`, then `data_out == expected_data_out` and verify the  TX block `parity == ^data_in([63:0])`\n    - Log results (pass/fail) for each test vector.\n- After every transaction `reset_n`(Active Low asynchronous reset) should be applied to initialize the internal registers.\n- Ensure that the checker operates on all the stimulus-generated test cases. Complete the simulation once all test cases are verified.\n\n## Deliverables\nProvide a modified SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `sync_serial_communication_tx_rx` module.", "context": {"verif/sync_serial_communication_top.sv": "\n`timescale 1ns / 1ps\n\nmodule sync_serial_communication_tb();\n    // Declaration of registers and wires\n    reg clk;                        // Clock signal\n    reg reset_n;                    // Active-low reset signal\n    reg [2:0] sel;                  // Selection signal\n    reg [63:0] data_in;             // Data input signal\n    wire done;                      // Done signal (output from DUT)\n    wire [63:0] data_out;           // Data output signal\n    wire parity_error;\n\n    integer i;                      // Loop variable for tasks\n\n    integer sel_value;\n    integer range_value;\n    integer data_in_rand;\n\n    sync_serial_communication_tx_rx uut (\n        .clk(clk),\n        .reset_n(reset_n),\n        .sel(sel),\n        .data_in(data_in),\n        .data_out(data_out),\n        .done(done),\n        .parity_error(parity_error)\n    );\n\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    task initialization();\n    begin\n        @(posedge clk);\n        data_in <= 64'd0;           \n        sel     <= 3'b000;         \n    end\n    endtask\n\n    task reset();\n    begin\n        reset_n = 1'b0;              \n        @(posedge clk);\n        initialization();            \n        @(negedge clk);\n        reset_n = 1'b1;              \n    end\n    endtask\n\n    task drive_data(input integer sel_mode, input integer range, input integer data_in_val);\n        integer i;\n        begin\n            @(posedge clk);\n            case (sel_mode)\n                1: begin\n                    data_in = data_in_val[7:0];  \n                end\n                2: begin\n                    data_in = data_in_val[15:0];  \n                end\n                3: begin\n                    data_in = data_in_val[31:0];  \n                end\n                4: begin\n                    data_in = data_in_val[63:0];  \n                end\n                default: begin\n                    range_value = 8;\n                    data_in_rand = 64'd0;\n                end\n            endcase\n            data_in = data_in_val;  \n            for (i = 0; i < range; i = i + 1) begin\n                sel = sel_mode[2:0];     \n                @(posedge clk);\n            end\n            \n            wait(done);\n            @(posedge clk);\n            $display(\"%t DRIVE_DATA:: sel = %h, data_in = %h, data_out = %h, done = %b,parity_error = %b\", $time, sel, data_in, data_out, done,parity_error);\n            $display(\"=====================================================================================================================================\");\n        end\n    endtask\n\n    initial begin\n        reset_n = 1'b0;\n        data_in = 64'd0;\n        reset();\n        repeat(1000) begin  \n            sel_value = $urandom_range(1,4);  \n            case (sel_value)\n                1: begin\n                    range_value = 8;\n                    data_in_rand = $urandom_range(0,127);\n                end\n                2: begin\n                    range_value = 16;\n                    data_in_rand = $urandom_range(0,(2**16)-1);\n                end\n                3: begin\n                    range_value = 32;\n                    data_in_rand = {$urandom_range(0,(2**31)-1)};\n                end\n                4: begin\n                    range_value = 64;\n                    data_in_rand = {$urandom_range(0,(2**64)-1)};\n                end\n                default: begin\n                    range_value = 8;\n                    data_in_rand = 64'd0;\n                end\n            endcase\n            drive_data(sel_value, range_value, data_in_rand);\n            reset();\n        end\n        #100;\n        $finish;\n    end\n\n    initial begin\n        $dumpfile(\"sync_serial_communication_tb.vcd\");\n        $dumpvars(0, sync_serial_communication_tb);\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/sync_serial_communication_top.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/sync_serial_communication_top.sv\nHASH            = 4b6e88408fc90c76baf3b38fefe9ab0cf4b751c1\nNUM_BUGS        = 4\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/sync_serial_communication_top.sv /code/verif/sync_serial_communication_top.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"", "src/sync_serial_communication_top.sv": "`timescale 1ns / 1ps\nmodule sync_serial_communication_tx_rx(\n    input clk,                     // Clock signal\n    input reset_n,                 // Active low reset signal\n    input [2:0] sel,               // Selection signal for TX block\n    input [63:0] data_in,          // 64-bit data input for TX block\n    output [63:0] data_out,        // 64-bit data output from RX block\n    output done,                   // Done signal indicating completion\n    output parity_error            // parity error flag\n);\n\n// Internal signals\nwire tx_out;                       \nwire tx_done;                      \nwire serial_clk_in;  \nwire parity;              \n\n// Instantiate the TX block\ntx_block uut_tx_block (\n    .clk(clk),                     // Clock input to TX block\n    .reset_n(reset_n),             // Reset input to TX block\n    .data_in(data_in),             // 64-bit data input to TX block\n    .sel(sel),                     // Selection signal to TX block\n    .serial_out(tx_out),           // Serial data output from TX block\n    .done(tx_done),                // Done signal from TX block\n    .serial_clk(serial_clk_in),    // Serial clock output from TX block\n    .parity(parity)                // parity bit\n);\n\n// Instantiate the RX block\nrx_block uut_rx_block (\n    .clk(clk),                     // Clock input to RX block\n    .serial_clk(serial_clk_in),    // Serial clock input to RX block\n    .reset_n(reset_n),             // Reset input to RX block\n    .sel(sel),                     // Selection signal to RX block\n    .data_in(tx_out),              // Serial data input to RX block\n    .parity_in(parity),            // received parity bit\n    .data_out(data_out),           // 64-bit data output from RX block\n    .done(done),                   // Done signal from RX block\n    .parity_error(parity_error)    // parity error flag\n    \n);\n\nendmodule\n\n///// tx_block\nmodule tx_block(\n    input clk,               // Clock input\n    input reset_n,           // Active-low reset input\n    input [63:0] data_in,    // 64-bit parallel data input\n    input [2:0] sel,         // Selection input to choose data width\n    output reg serial_out,   // Serial data output\n    output reg done,         // Done signal indicating completion of transmission\n    output serial_clk,       // Clock for serial data transmission\n    output reg parity        // parity bit\n);\n\n// Internal registers\nreg [63:0] data_reg;       \nreg [6:0] bit_count;         \nreg [6:0] reg_count;        \nreg [6:0] temp_reg_count;    \n\n\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        // Reset all values on active-low reset\n        data_reg     <= 64'h0;\t\t\t     \t           \n        bit_count    <= 7'h0;\t\t\t     \t           \n        reg_count    <= 7'h0;\t\n        parity       <= 1'b0;\t             \t       \n    end else begin\n        if (done == 1'b1) begin\n            case (sel)\n                3'b000: begin\n                    data_reg  <= 64'h0;             \t   \n                    bit_count <= 7'd0; \n                    parity    <= 1'b0;                    \n                end\n                3'b001: begin\n                    data_reg  <= {56'h0, data_in[7:0]};  \n                    bit_count <= 7'd7;\n                    parity    <= ^data_in[7:0];              \t   \n                end\n                3'b010: begin\n                    `ifndef BUG_0\n                        data_reg  <= {48'h0, data_in[15:0]};   \n                        bit_count <= 7'd15; \n                        parity    <= ^data_in[15:0];\n                    `else\n                        data_reg  <= {61'h0, data_in[2:0]};   \n                        bit_count <= 7'd15;\n                        parity    <= ~^data_in[15:0];\n                    `endif                 \t   \n                end\n                3'b011: begin\n                    data_reg  <= {32'h0, data_in[31:0]};   \n                    bit_count <= 7'd31; \n                    parity    <= ^data_in[31:0];       \t \n                end\n                3'b100: begin\n                    `ifndef BUG_1\n                        data_reg  <= data_in[63:0];  \n                        bit_count <= 7'd63; \n                        parity    <= ^data_in[63:0];  \n                    `else\n                        data_reg  <= {60'h0,data_in[3:0]};   \n                        bit_count <= 7'd63;\n                        parity    <= ~^data_in[63:0];  \n                    `endif          \t              \t   \n                end\n                default: begin\n                    data_reg  <= 64'h0;             \t   \n                    bit_count <= 7'h0; \n                    parity    <= 1'b0;              \t   \n                end\n            endcase\n           \n        end else if (bit_count > 7'h0) begin\n            data_reg   <= data_reg >> 1;                   \n            bit_count  <= bit_count - 1'b1;                \n            \n        end\n        reg_count <= bit_count;                            \n    end\nend\n\n// Generate serial clock based on reg_count\n//`ifdef SIMULATION\nassign  #1 serial_clk = clk && (temp_reg_count !== 7'd0) ; \n//`else\n//assign  serial_clk = clk && (temp_reg_count !== 7'd0) ;  \n//`endif\n\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n        temp_reg_count <= 7'h0;\t\t\t\t\t           \n    end\n    else begin\n        temp_reg_count <= reg_count;\t\t\t        \n    end\nend\n\n\n\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n\t   serial_out <= 1'b0;\t\t\t\t                \n    end\n    else if(reg_count > 7'h0 || bit_count > 7'h0) begin\n\t   serial_out <= data_reg[0];\t\t\t              \n    end\nend \n\nalways@(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n        done <= 1'b0;\t\t\t\t\t                  \n    end \n    else begin\n     if(bit_count == 7'h0) begin\n\t    done <= 1'b1; \t\t\t                          \n     end\n     else begin \n\t    done <= 1'b0;\t\t\t\t\t                  \n     end\nend\nend\n\n\nendmodule\n\n///// rx_block\nmodule rx_block(\n    input wire clk,  \t\t\t    // clock input\n    input wire reset_n,\t\t\t    // Active-low reset\n    input wire data_in,\t\t\t    // Serial input data\t\n    input wire serial_clk,\t\t    // Clock signal for serial data\n    input wire [2:0] sel,           // Selection output to choose data width\n    input wire parity_in,           // received parity\n    output reg done,\t\t\t    // Done signal to indicate data reception complete\t\t\n    output reg [63:0] data_out,  \t// Parallel output data after serial operation\n    output reg parity_error         // parity_error flag\n\n);\n\n    // Internal registers\n    reg [63:0] data_reg;\t\t    \n    reg [7:0] bit_count;\t\t   \n    reg [7:0] count;\t\t    \n\n    \n    always @(posedge serial_clk or negedge  reset_n) begin\n        if (!reset_n) begin\t\t    \n            data_reg <= 64'h0;\t\t\n            bit_count <= 8'd0;\t\t\n        end else begin\n            if(done == 1'b1) begin                   \n                bit_count <= 8'b0;\n                data_reg <= 64'h0;\n            end\n            else begin\n                 bit_count <= bit_count;\t\t\t\n            end\n                bit_count <= bit_count + 1'b1;\t     \n                data_reg[bit_count]<=data_in; \t     \n           end\n    end  \n    \n    \n    always@(posedge clk or negedge reset_n) begin\n    \tif(!reset_n) begin\t\t\t \t             \n    \t   count <= 8'd0;\t\t\t\t\t         \n           done <= 1'b0;\t\t\t\t\t         \n           data_out <= 64'h0;\t\t\t\t\t     \n           parity_error  <= 1'b0;\t\t\t\t \n        end \n        else if(count >= bit_count && count != 8'd0) begin      \n           done <= 1'b1;\t\t\t\t             \n           case(sel)\n            3'b000:begin\n                data_out <= 64'h0;\n                parity_error <= 1'b0;                   \n            end\n            3'b001:begin\n                if(parity_in == (^data_reg[7:0])) begin\n                    data_out <= {56'h0,data_reg}; \n                    parity_error <= 1'b0;\n                end    \n                else begin\n                    data_out <= {56'h0,data_reg};\n                    parity_error <= 1'b1;\n                end   \n            end\n            3'b010:begin\n                if(parity_in == (^data_reg[15:0])) begin\n                    `ifndef BUG_2\n                        data_out <= {48'h0,data_reg};  \n                        parity_error <= 1'b0;\n                    `else\n                        data_out <= {63'h0,data_reg[0]};  \n                        parity_error <= 1'b1;\n                    `endif\n                end    \n                else begin\n                    data_out <= {48'h0,data_reg};\n                    parity_error <= 1'b1;\n                end       \n            end\n            3'b011:begin\n                if(parity_in == (^data_reg[31:0])) begin\n                    data_out <= {32'h0,data_reg};\n                    parity_error <= 1'b0;\n                end \n                else begin\n                    data_out <= {32'h0,data_reg};\n                    parity_error <= 1'b1;\n                end        \n            end\n            3'b100:begin\n                if(parity_in == (^data_reg)) begin\n                    `ifndef BUG_3\n                        data_out <= data_reg; \n                        parity_error <= 1'b0;\n                    `else\n                        data_out <= {56'h0,data_reg[7:0]}; \n                        parity_error <= 1'b1;\n                    `endif\n                end    \n                else begin\n                    data_out <= data_reg;\n                    parity_error <= 1'b1;\n                end              \n            end\n            default:begin\n                data_out <= 64'h0;    \n                parity_error <= 1'b0;               \n            end\n           endcase\n        end\n        else if(bit_count > 8'd0) begin              \n           count <= count+ 1'b1;\t\t\t\t     \n           done <= 1'b0;\t\t\t\t\t        \n        end\n        else begin  \t\t\t                     \n           count <= 8'd0;\t\t\t\t\t         \n           done <= 1'b0;\t\t\t\t\t           \n        end \n    end\nendmodule"}}}
{"id": "cvdp_copilot_sync_serial_communication_0053", "categories": ["cid014", "medium"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the `sync_serial_communication_tx_rx `module, which integrates a `tx_block`, `rx_block`, `crc_generation`, `crc_detection` and `onebit_ecc`. The module details and design requirements for assertion development are outlined below.\n\n## Specifications\n\n**Interface:**\n\n**Parameters:**\n- `DATA_WIDTH` (default: 16): Width of input and output data.\n- `CODE_WIDTH`:  Encoded width for ECC (`DATA_WIDTH + $clog2(DATA_WIDTH + 1)`)\n- `CRC_WIDTH`: Width of CRC output(`DATA_WIDTH/2`)\n- `POLY`: Polynomial for CRC computation.  Default is 8.\n\n**Inputs:**\n- `clk`: Clock signal that runs at a 50:50 duty cycle. Design works on the Posedge of the clk.\n- `reset_n`: Active LOW asynchronous reset signal.\n- `sel [2:0]`: Selection signal for TX block.\n- `data_in([DATA_WIDTH-1:0])`: Data input for TX block.\n- `received_1([CODE_WIDTH-1:0])`: Received encoded data.\n- `received_2([CODE_WIDTH-1:0])`: Second received encoded data.\n- `enable_crc_error`: Enable bit for CRC error generation.\n\n**Outputs:**\n- `data_out([DATA_WIDTH-1:0])`: Output data from RX block.\n- `done`: Signal indicating completion.\n- `parity_error`: Parity error flag.\n- `encoded_received_TX([CODE_WIDTH-1:0])`: Transmitted ECC-encoded output.\n- `encoded_2([CODE_WIDTH-1:0])`: ECC-encoded output from received data.\n- `crc_out([CRC_WIDTH-1:0])`: CRC output.\n- `error_detected_1`: ECC error detected in transmitter.\n- `error_corrected_1`: ECC error corrected in transmitter.\n- `error_detected_2`: ECC error detected in receiver.\n- `error_corrected_2`: ECC error corrected in receiver.\n- `crc_error_detected`: CRC error detection flag.\n\n## Module Overview\nThe `sync_serial_communication_tx_rx ` module integrates: \n- TX Block (`tx_block`): Serializes data_in, computes a parity bit, and transmits data serially.\n- RX Block (`rx_block`): Receives and deserializes data while checking for parity errors.\n- ECC Generator (`onebit_ecc`): Adds parity bits, detects, and corrects single-bit errors.\n- CRC Generator (`crc_generation`): Computes CRC using POLY for error detection.\n- CRC Detector (`crc_detection`): Verifies received CRC and detects mismatches.\n## Behavioral Specifications\n**1. **Transmisson(`tx_block`)****\nThe `tx_block` serializes the `data_in` based on the `sel` input:\n- `sel == 3'b000`: No transmission, `data_out` remains 0.\n- `sel == 3'b001`: Transmits the 8 least significant bits.\n- `sel == 3'b010`: Transmits the 16 least significant bits.\n- `sel == 3'b011`: Transmits the 32 least significant bits.\n- `sel == 3'b100`: Transmits the entire 64-bit data.\n- A parity bit is computed as the XOR of all transmitted bits (^`data_in`).\n- A done signal is asserted when transmission completes.\n\n**2. **Reception(`rx_block`)****\n- The `rx_block`receives serial data and reconstructs `data_out`.\n- The `parity_error` flag is asserted if the received parity bit does not match the computed parity.\n- The done signal is asserted once deserialization is complete.\n\n**3. **One bit ECC(`onebit_ecc`)****\n- Detects and Corrects single-bit errors (`error_corrected_1`, `error_corrected_2`).\n- The RX block processes the received ECC data and reconstructs the original `data_out`.\n\n**4. **CRC Computation(`crc_generation`)****\n- The CRC generator calculates a cyclic redundancy check (CRC) using the given polynomial (`POLY`).\n- The CRC output (`crc_out`) is used for error detection.\n\n**5. **CRC Detection****\n- The CRC detector verifies whether the received CRC matches the computed CRC.\n- If there is a mismatch, `crc_error_detected` is asserted.\n\n## Assertion Requirements\n\n**1.Validating Parity Bit Positions**\n-  Ensure that parity bits are correctly positioned at power-of-2 indices in data_out.\n\n**2.CRC Detection Without Error**\n- Ensures that when `enable_crc_error` is disabled, the received data must match the original received data.\n\n**3.CRC Detection With Error**\n- Ensures that when `enable_crc_error` is enabled, the received data is set to 1, simulating an error scenario.\n\n**4.No ECC Error Detection When Encoded Data Matches**\n- Ensures that when `encoded_2` is equal to encoded_received_temp, both `error_detected_2` and `error_corrected_2` must remain 0.\n\n**5.ECC Data Integrity Check**\n- Ensures that when the received ECC-encoded data (`encoded_2`) matches the expected encoded data, the ECC-corrected output (`data_out`) must be identical to the original input (`data_in`).\n\n**6.TX Done Signal Correctness**\n- The `done` signal in the TX module must be asserted HIGH when the bit count reaches zero for certain values of `sel` signal, namely `sel = 3b001` ,`sel = 3b010`, `sel = 3b011` and `sel = 3b100`.\n\n**7.RX Data Stability During Reception**\n- Ensures that `data_out` remains unchanged while the reception process is still ongoing (`done == 0`).\n\n**8.No CRC Error Detection When CRC Matches**\n- Ensures that if the computed CRC (`calculated_crc`) matches the received CRC (`received_crc`), the `error_detected` signal must remain 0 (no error).\n\n**9.CRC Error Detection When CRC Mismatch Occurs**\n- Ensures that when `error_detected` is 1, the computed CRC (`calculated_crc`) must not match the received CRC (`received_crc`).\n\n**10.Parity Check**\n- Ensures that when done is HIGH and the parity of `data_in` matches the parity of data_out_rx, the `parity_error` signal must remain LOW.\n\n---\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.", "context": {"rtl/sync_serial_communication_top.sv": "`timescale 1ns / 1ps\nmodule sync_serial_communication_tx_rx#(parameter DATA_WIDTH = 16,\n                                        parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1),\n                                        parameter CRC_WIDTH = ((DATA_WIDTH)/2),\n                                        parameter POLY = 8)(\n    input clk,                                      // Clock signal\n    input reset_n,                                  // Active low reset signal\n    input [2:0] sel,                                // Selection signal for TX block\n    input [DATA_WIDTH-1:0] data_in,                 // 64-bit data input for TX block\n    output [DATA_WIDTH-1:0] data_out,               // 64-bit data output from RX block\n    output done,                                    // Done signal indicating completion\n    output parity_error,                            // parity error flag\n    input [CODE_WIDTH-1:0] received_1,              // Received encoded data\n    input [CODE_WIDTH-1:0] received_2,              // Received encoded data\n    input enable_crc_error,                         // enable bit for crc error  generation \n    output [CODE_WIDTH-1:0] encoded_received_TX,    // Encoded output transmitted_ecc\n    output [CODE_WIDTH-1:0] encoded_2,              // Encoded output of received_ecc\n    output [CRC_WIDTH-1:0] crc_out,                 // crc output\n    output error_detected_1,                        // Error detected flag for ECC transmitter\n    output error_corrected_1,                       // Error corrected flag for ECC transmitter \n    output error_detected_2,                        // Error detected flag for  ECC receiver\n    output error_corrected_2,                        // Error corrected flag for ECC receiver\n    output crc_error_detected                       // Error detected flag for CRC\n);\n\n// Internal signals\nwire tx_out;                       \nwire tx_done;                      \nwire serial_clk_in;  \nwire parity;    \nwire [DATA_WIDTH-1:0] data_out_rx;\nwire [DATA_WIDTH-1:0] data_out1;\nwire [DATA_WIDTH-1:0] data_out2;\nwire [CODE_WIDTH-1:0] encoded_received_temp;\nwire [CODE_WIDTH-1:0] encoded_received_temp2;\nwire [CRC_WIDTH-1:0] crc_out_1;\nreg [CRC_WIDTH-1:0] crc_out_temp;\nreg [DATA_WIDTH-1:0] data_out_rx_temp;\n\n\nonebit_ecc#(.DATA_WIDTH(DATA_WIDTH),.CODE_WIDTH(CODE_WIDTH)) uut_onebit_ecc1 (\n\n    .data_in(data_in),\n    .encoded(encoded_received_TX),\n    .received(encoded_received_temp2),\n    .data_out(data_out1),\n    .error_detected(error_detected_1),\n    .error_corrected(error_corrected_1)\n    );\n\ncrc_generation# (.DATA_WIDTH(DATA_WIDTH),.CRC_WIDTH(CRC_WIDTH),.POLY(POLY)) uut_crc_1 (\n\n    .clk(clk),\n    .rst(!reset_n),\n    .data_in(data_in),\n    .crc_out(crc_out)\n\n);\n\nassign crc_out_1 = crc_out;\n\n// Instantiate the TX block\ntx_block#(.DATA_WIDTH(DATA_WIDTH)) uut_tx_block (\n    .clk(clk),                     // Clock input to TX block\n    .reset_n(reset_n),             // Reset input to TX block\n    .data_in(data_in),             // 64-bit data input to TX block\n    .sel(sel),                     // Selection signal to TX block\n    .serial_out(tx_out),           // Serial data output from TX block\n    .done(tx_done),                // Done signal from TX block\n    .serial_clk(serial_clk_in),    // Serial clock output from TX block\n    .parity(parity)                // parity bit\n);\n\n// Instantiate the RX block\nrx_block#(.DATA_WIDTH(DATA_WIDTH)) uut_rx_block (\n    .clk(clk),                     // Clock input to RX block\n    .serial_clk(serial_clk_in),    // Serial clock input to RX block\n    .reset_n(reset_n),             // Reset input to RX block\n    .sel(sel),                     // Selection signal to RX block\n    .data_in(tx_out),              // Serial data input to RX block\n    .parity_in(parity),            // received parity bit\n    .data_out(data_out_rx),           // 64-bit data output from RX block\n    .done(done),                   // Done signal from RX block\n    .parity_error(parity_error)    // parity error flag\n    \n);\n\nalways@(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n        crc_out_temp    <= 0;\n        data_out_rx_temp <= 0;\n    end\n    else begin\n    if(done == 1) begin\n        if(enable_crc_error == 0) begin\n            crc_out_temp <= crc_out_1;\n            data_out_rx_temp <= data_out_rx;\n        end\n        else begin\n        crc_out_temp <= crc_out_1;\n        data_out_rx_temp <= 1;\n        end\n    end\n    else begin\n        crc_out_temp <= 0;\n        data_out_rx_temp <= 0;\n    end\nend\nend\n\n\nonebit_ecc#(.DATA_WIDTH(DATA_WIDTH),.CODE_WIDTH(CODE_WIDTH)) uut_onebit_ecc2 (\n\n    .data_in(data_out_rx),\n    .encoded(encoded_2),\n    .received(encoded_received_temp),\n    .data_out(data_out),\n    .error_detected(error_detected_2),\n    .error_corrected(error_corrected_2)\n    );\n\ncrc_detection# (.DATA_WIDTH(DATA_WIDTH),.CRC_WIDTH(CRC_WIDTH),.POLY(POLY)) uut_crc_detection (\n\n    .clk(clk),\n    .rst(!reset_n),\n    .data_in(data_out_rx_temp),\n    .received_crc(crc_out_temp),\n    .error_detected(crc_error_detected)\n\n);\n\n\nassign encoded_received_temp = received_2 | encoded_received_temp2;\nassign encoded_received_temp2 = encoded_received_TX;\nendmodule\n\n///// tx_block\nmodule tx_block#(parameter DATA_WIDTH = 8)(\n    input clk,               // Clock input\n    input reset_n,           // Active-low reset input\n    input [DATA_WIDTH-1:0] data_in,    // 64-bit parallel data input\n    input [2:0] sel,         // Selection input to choose data width\n    output reg serial_out,   // Serial data output\n    output reg done,         // Done signal indicating completion of transmission\n    output serial_clk,       // Clock for serial data transmission\n    output reg parity        // parity bit\n);\n\n// Internal registers\nreg [DATA_WIDTH-1:0] data_reg;       \nreg [6:0] bit_count;         \nreg [6:0] reg_count;        \nreg [6:0] temp_reg_count;    \n\n\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        // Reset all values on active-low reset\n        data_reg     <= {DATA_WIDTH{1'b0}};\t\t\t     \t           \n        bit_count    <= 7'h0;\t\t\t     \t           \n        reg_count    <= 7'h0;\t\n        parity       <= 1'b0;\t             \t       \n    end else begin\n        if (done == 1'b1) begin\n            case (sel)\n                3'b000: begin\n                    data_reg  <= 64'h0;             \t   \n                    bit_count <= 7'd0; \n                    parity    <= 1'b0;                    \n                end\n                3'b001: begin\n                    data_reg  <= {56'h0, data_in[7:0] };  \n                    bit_count <= 7'd7;\n                    parity    <= ^data_in[7:0];              \t   \n                end\n                3'b010: begin\n                    if (DATA_WIDTH >= 16) begin\n                        data_reg  <= { {(DATA_WIDTH - 16){1'b0}}, data_in[15:0] }; \n                        bit_count <= 7'd15; \n                        parity    <= ^data_in[15:0];\n                    end             \t   \n                end\n                3'b011: begin\n                    if (DATA_WIDTH >= 32) begin\n                        data_reg  <= { {(DATA_WIDTH - 32){1'b0}}, data_in[31:0] };\n                        bit_count <= 7'd31;  \n                        parity    <= ^data_in[31:0];\n                    end            \t \n                end\n                3'b100: begin\n                    if (DATA_WIDTH >= 64) begin\n                        data_reg  <={data_in[63:0] };   \t   \n                        bit_count <= 7'd63; \n                        parity    <= ^data_in[63:0];\n                    end             \t   \n                end\n                default: begin\n                    data_reg  <= {DATA_WIDTH{1'b0}};             \t   \n                    bit_count <= 7'h0; \n                    parity    <= 1'b0;              \t   \n                end\n            endcase\n           \n        end else if (bit_count > 7'h0) begin\n            data_reg   <= data_reg >> 1;                   \n            bit_count  <= bit_count - 1'b1;                \n            \n        end\n        reg_count <= bit_count;                            \n    end\nend\n\n// Generate serial clock based on reg_count\n//`ifdef SIMULATION\nassign  #1 serial_clk = clk && (temp_reg_count !== 7'd0) ; \n//`else\n//assign  serial_clk = clk && (temp_reg_count !== 7'd0) ;  \n//`endif\n\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n        temp_reg_count <= 7'h0;\t\t\t\t\t           \n    end\n    else begin\n        temp_reg_count <= reg_count;\t\t\t        \n    end\nend\n\n\n\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n\t   serial_out <= 1'b0;\t\t\t\t                \n    end\n    else if(reg_count > 7'h0 || bit_count > 7'h0) begin\n\t   serial_out <= data_reg[0];\t\t\t              \n    end\nend \n\nalways@(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n        done <= 1'b0;\t\t\t\t\t                  \n    end \n    else begin\n     if(bit_count == 7'h0) begin\n\t    done <= 1'b1; \t\t\t                          \n     end\n     else begin \n\t    done <= 1'b0;\t\t\t\t\t                  \n     end\nend\nend\n\n\nendmodule\n\n///// rx_block\nmodule rx_block#(parameter DATA_WIDTH = 8)(\n    input wire clk,  \t\t\t    // clock input\n    input wire reset_n,\t\t\t    // Active-low reset\n    input wire data_in,\t\t\t    // Serial input data\t\n    input wire serial_clk,\t\t    // Clock signal for serial data\n    input wire [2:0] sel,           // Selection output to choose data width\n    input wire parity_in,           // received parity\n    output reg done,\t\t\t    // Done signal to indicate data reception complete\t\t\n    output reg [DATA_WIDTH-1:0] data_out,  \t// Parallel output data after serial operation\n    output reg parity_error         // parity_error flag\n\n);\n\n    // Internal registers\n    reg [DATA_WIDTH-1:0] data_reg;\t\t    \n    reg [7:0] bit_count;\t\t   \n    reg [7:0] count;\t\t    \n\n    \n    always @(posedge serial_clk or negedge  reset_n) begin\n        if (!reset_n) begin\t\t    \n            data_reg <= {DATA_WIDTH{1'b0}};\t\t\n            bit_count <= 8'd0;\t\t\n        end else begin\n            if(done == 1'b1) begin                   \n                bit_count <= 8'b0;\n                data_reg <= {DATA_WIDTH{1'b0}};\n            end\n            else begin\n                 bit_count <= bit_count;\t\t\t\n            end\n                bit_count <= bit_count + 1'b1;\t     \n                data_reg[bit_count]<=data_in; \t     \n           end\n    end  \n    \n    \n    always@(posedge clk or negedge reset_n) begin\n    \tif(!reset_n) begin\t\t\t \t             \n    \t   count <= 8'd0;\t\t\t\t\t         \n           done <= 1'b0;\t\t\t\t\t         \n           data_out <= {DATA_WIDTH{1'b0}};\t\t\t\t\t     \n           parity_error  <= 1'b0;\t\t\t\t \n        end \n        else if(count >= bit_count && count != 8'd0) begin      \n           done <= 1'b1;\t\t\t\t             \n           case(sel)\n            3'b000:begin\n                data_out <= {DATA_WIDTH{1'b0}};\t\n                parity_error <= 1'b0;                   \n            end\n            3'b001:begin\n                if(parity_in == (^data_reg[7:0])) begin\n                    data_out <= {56'h0, data_reg[7:0]};\n                    parity_error <= 1'b0;\n                end    \n                else begin\n                    data_out <= {56'h0, data_reg[7:0]};\n                    parity_error <= 1'b1;\n                end   \n            end\n            3'b010:begin\n                if (DATA_WIDTH >= 16) begin\n                    if(parity_in == (^data_reg[15:0])) begin\n                        data_out <= {48'h0, data_reg[15:0]};    \n                        parity_error <= 1'b0;\n                    end    \n                    else begin\n                        data_out <= {48'h0, data_reg[15:0]}; \n                        parity_error <= 1'b1;\n                    end\n                end       \n            end\n            3'b011:begin\n                if (DATA_WIDTH >= 32) begin\n                    if(parity_in == (^data_reg[31:0])) begin\n                        data_out <= {32'h0, data_reg[31:0]};  \n                        parity_error <= 1'b0;\n                    end    \n                    else begin\n                        data_out <= {32'h0, data_reg[31:0]};  \n                        parity_error <= 1'b1;\n                    end\n                end        \n            end\n            3'b100:begin\n                if (DATA_WIDTH >= 64) begin\n                    if(parity_in == (^data_reg[63:0])) begin\n                        data_out <= {data_reg[63:0]};   \n                        parity_error <= 1'b0;\n                    end    \n                    else begin\n                        data_out <= {data_reg[63:0]}; \n                        parity_error <= 1'b1;\n                    end \n                end             \n            end\n            default:begin\n                data_out <= {DATA_WIDTH{1'b0}};    \n                parity_error <= 1'b0;               \n            end\n           endcase\n        end\n        else if(bit_count > 8'd0) begin              \n           count <= count+ 1'b1;\t\t\t\t     \n           done <= 1'b0;\t\t\t\t\t        \n        end\n        else begin  \t\t\t                     \n           count <= 8'd0;\t\t\t\t\t         \n           done <= 1'b0;\t\t\t\t\t           \n        end \n    end\nendmodule\n\nmodule onebit_ecc #(\n    parameter DATA_WIDTH = 4,                                  // Width of the data input\n    parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1) // Encoded width\n)(\n    input [DATA_WIDTH-1:0] data_in,                     // Input data\n    output reg [CODE_WIDTH-1:0] encoded,                // Encoded output\n    input [CODE_WIDTH-1:0] received,                    // Received encoded data\n    output reg [DATA_WIDTH-1:0] data_out,               // Corrected output\n    output reg error_detected,                          // Error detected flag\n    output reg error_corrected                          // Error corrected flag\n);\n\n    localparam PARITY_BITS = CODE_WIDTH - DATA_WIDTH;   // Number of parity bits\n\n    reg [PARITY_BITS-1:0] syndrome;                     // Syndrome for error detection\n    reg [CODE_WIDTH-1:0] corrected_data;                // Corrected received data\n\n\n    integer idx_i, idx_j, idx_k;\n    integer idx_m, idx_n;\n    integer idx_p, idx_q;\n\n\n    always @(*) begin\n        encoded = 0;\n        idx_k = 0;\n\n\n        for (idx_i = 0; idx_i < CODE_WIDTH; idx_i = idx_i + 1) begin\n            if ((idx_i + 1) & (idx_i)) begin\n                encoded[idx_i] = data_in[idx_k];\n                idx_k = idx_k + 1;\n            end\n        end\n\n\n        for (idx_i = 0; idx_i < PARITY_BITS; idx_i = idx_i + 1) begin\n            encoded[(1 << idx_i) - 1] = 0; \n            for (idx_j = 0; idx_j < CODE_WIDTH; idx_j = idx_j + 1) begin\n                if (((idx_j + 1) & (1 << idx_i)) && ((idx_j + 1) != (1 << idx_i))) begin\n                    encoded[(1 << idx_i) - 1] = encoded[(1 << idx_i) - 1] ^ encoded[idx_j];\n                end\n            end\n        end\n    end\n\n\n    always @(*) begin\n        syndrome = 0; \n        for (idx_m = 0; idx_m < PARITY_BITS; idx_m = idx_m + 1) begin\n            for (idx_n = 0; idx_n < CODE_WIDTH; idx_n = idx_n + 1) begin\n                if ((idx_n + 1) & (1 << idx_m)) begin\n                    syndrome[idx_m] = syndrome[idx_m] ^ received[idx_n];\n                end\n            end\n        end\n    end\n\n  \n    always @(*) begin\n        error_detected = |syndrome; \n    end\n\n    \n    always @(*) begin\n        corrected_data = received;\n        if (error_detected) begin\n            corrected_data[syndrome - 1] = ~corrected_data[syndrome - 1]; \n        end\n    end\n\n \n    always @(*) begin\n        idx_q = 0;\n        for (idx_p = 0; idx_p < CODE_WIDTH; idx_p = idx_p + 1) begin\n            if ((idx_p + 1) & (idx_p)) begin\n                data_out[idx_q] = corrected_data[idx_p];\n                idx_q = idx_q + 1;\n            end\n        end\n    end\n\n\n    always @(*) begin\n        error_corrected = error_detected; \n    end\n\nendmodule\n\nmodule crc_generation #(\n    parameter DATA_WIDTH = 8,       // Width of input data\n    parameter CRC_WIDTH = 4,        // Width of CRC output\n    parameter POLY = 4'b1101        // Polynomial for CRC\n) (\n    input [DATA_WIDTH-1:0] data_in, // Input data\n    input clk,                      // Clock signal\n    input rst,                      // Reset signal\n    output reg [CRC_WIDTH-1:0] crc_out // CRC output\n);\n    integer i;                      // Loop variable\n    reg [CRC_WIDTH-1:0] crc_reg;    // Internal CRC register\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            crc_out <= 0;           \n        end else begin\n            crc_reg = 0;            \n            for (i = DATA_WIDTH - 1; i >= 0; i = i - 1) begin\n                if (crc_reg[CRC_WIDTH-1] ^ data_in[i]) begin\n                    crc_reg = (crc_reg << 1) ^ POLY; \n                end else begin\n                    crc_reg = crc_reg << 1; \n                end\n            end\n            crc_out <= crc_reg;     \n        end\n    end\n\nendmodule\n\nmodule crc_detection #(\n    parameter DATA_WIDTH = 8,           // Width of input data\n    parameter CRC_WIDTH = 4,            // Width of CRC\n    parameter POLY = 4'b1101            // Polynomial for CRC\n) (\n    input [DATA_WIDTH-1:0] data_in,     // Input data\n    input [CRC_WIDTH-1:0] received_crc, // Received CRC\n    input clk,                          // Clock signal\n    input rst,                          // Reset signal\n    output error_detected           // High if error detected\n);\n\n    wire [CRC_WIDTH-1:0] calculated_crc; \n\n    crc_generation #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .CRC_WIDTH(CRC_WIDTH),\n        .POLY(POLY)\n    ) crc_gen (\n        .data_in(data_in),\n        .clk(clk),\n        .rst(rst),\n        .crc_out(calculated_crc)\n    );\n\n    assign error_detected =  ((calculated_crc != received_crc) && (calculated_crc != 0 && received_crc != 0 ))? 1:0;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sync_serial_communication_top.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sync_serial_communication_top.sv\nTOPLEVEL        = sync_serial_communication_tx_rx\nMODULE          = test_sync_serial_communication\nPYTHONPATH      = /src\nHASH            = c7f1092b8185259c988eabf846e05bd3340e9f51\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n\nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    toplevel = os.getenv(\"TOPLEVEL\")\n    target = float(os.getenv(\"TARGET\"))\n\n    if toplevel in metrics:\n        if \"Overall Average\" in metrics[toplevel]:\n            if metrics[toplevel][\"Overall Average\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n\n        elif \"Assertion\" in metrics[toplevel]:\n            if metrics[toplevel][\"Assertion\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Assertion\"]) >= 100.00, \"Didn't achieve the required coverage result.\"\n\n        elif \"Toggle\" in metrics[toplevel]:\n            if metrics[toplevel][\"Toggle\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Toggle\"]) >= target, \"Didn't achieve the required coverage result.\"\n\n        elif \"Block\" in metrics[toplevel]:\n            if metrics[toplevel][\"Block\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Block\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n        \nif __name__ == \"__main__\":\n    test_simulate()", "src/test_sync_serial_communication.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge,FallingEdge,Timer\nimport harness_library as hrs_lb\nimport random\n\n\n\n\n# Main test for sync_communication top module\n@cocotb.test()\nasync def test_sync_communication(dut):\n    data_wd = int(dut.DATA_WIDTH.value)                                    # Get the data width from the DUT (Device Under Test)\n    crc_width = int(dut.CRC_WIDTH.value)\n    poly = int(dut.POLY.value)\n    # Start the clock with a 10ns time period\n\n    if data_wd == 8:\n        range_value = 8\n        data_in = random.randint(0, 127)\n        sel = 1\n    elif data_wd == 16:\n        range_value = 16\n        data_in = random.randint(0,4196)\n        sel = 2\n    elif data_wd == 32:\n        range_value = 32\n        data_in = random.randint(0,18192)\n        sel = 3\n    elif data_wd == 64:\n        range_value = 64\n        data_in = random.randint(0,154097)\n        sel = 4\n\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n\n    # Ensure all control signals are low initially before starting the test\n    dut.sel.value = 0\n    dut.data_in.value = 0\n    dut.received_1.value = 0\n    dut.received_2.value = 0\n    dut.enable_crc_error.value = 0\n\n    # Main test loop to validate both PISO and SIPO functionality\n    for _ in range(1):\n        await drive_byte(dut,sel,range_value,data_in,data_wd,crc_width,poly)\n        await FallingEdge(dut.clk)\n        await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n        await RisingEdge(dut.clk)\n        await drive_rx_error(dut,sel,range_value,data_in,data_wd,crc_width,poly)\n        await FallingEdge(dut.clk)\n        await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n        await RisingEdge(dut.clk)\n\n    #await inject_parity_error(dut)\n\n\nasync def drive_byte(dut,sel,range_value,data_in,data_wd,crc_width,poly):\n    dut.enable_crc_error.value = 0\n    dut._log.info(f\" DRIVE TRANSACTION NORMAL MODE\")\n    await RisingEdge(dut.clk)\n    dut.data_in.value = data_in  # Assign a random byte (0-127)\n    dut.sel.value  = sel\n    await RisingEdge(dut.clk)\n    data_in_bits = f'{data_in:0{range_value}b}'\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}\")\n    await RisingEdge(dut.clk)\n    encoded_1 = int(dut.encoded_received_TX.value)\n    dut.received_1.value = encoded_1\n    \n    await RisingEdge(dut.clk)\n    #dut.enable_crc_error.value = 0\n    error_corrected_1 = int(dut.error_corrected_1.value)\n    error_detected_1 = int(dut.error_detected_1.value)\n    if error_detected_1:\n            assert error_corrected_1, \"Error detected but not corrected!\"\n    dut._log.info(f\" ecc_hamming_TX = {encoded_1}\")\n    #dut._log.info(f\" data_out1 = {int(dut.uut_onebit_ecc1.data_out.value)}\")\n    await RisingEdge(dut.clk)\n    crc_out = int(dut.crc_out.value)\n    for i in range(range_value):\n        dut.sel.value  = sel\n        await RisingEdge(dut.clk)  \n    await RisingEdge(dut.done)\n    #await RisingEdge(dut.clk) \n    #dut._log.info(f\"  data_out_rx = {int(dut.data_out_rx.value)} \")\n    \n    encoded_2 = int(dut.encoded_received_TX.value)\n    dut.received_2.value = encoded_2\n    \n    \n    await RisingEdge(dut.clk)\n    \n    \n    error_corrected_2 = int(dut.error_corrected_2.value)\n    error_detected_2 = int(dut.error_detected_2.value)\n    await FallingEdge(dut.clk)\n    data_out_rx = int(dut.data_out_rx_temp.value)\n    expected_crc = compute_expected_crc(data_out_rx, data_wd, crc_width, poly)\n    #dut._log.info(f\" CHECK:: crc_out = {crc_out}, expected_crc = {expected_crc}, crc_error_detected = {dut.crc_error_detected.value}\")\n    if error_detected_2:\n            assert error_corrected_2, \"Error detected but not corrected!\"\n    dut._log.info(f\" AFTER RX RECIVED DATA FROM TX\")\n\n    dut._log.info(f\" ecc_hamming_RX = {encoded_2}, ecc_hamming_received_TX = {int(dut.received_2.value)} \")\n    \n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}, data_out = {int(dut.data_out.value)}, done = {dut.done.value}\")\n    \n    \n    expected_data_out = dut.data_in.value\n    assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, expected_data_out = {int(expected_data_out)}, data_out = {int(dut.data_out.value)}\")\n    dut._log.info(f\" enable_crc_error = {dut.enable_crc_error.value} \")\n    dut._log.info(f\" actual_crc_out = {crc_out}, expected_crc = {expected_crc}, actual_crc_error_detected = {dut.crc_error_detected.value}, expected_crc_error_detected = {int(crc_out != expected_crc)}\")\n    assert crc_out == expected_crc, f\" TEST FAILED actual_crc_out = {crc_out}, expected_crc = {expected_crc}\"\n    if crc_out != expected_crc:\n         assert dut.crc_error_detected.value ==1, f\"EST FAILED actual_crc_out = {crc_out}, expected_crc = {expected_crc}\"\n    #await RisingEdge(dut.clk)\n    \n    #assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    data_out = int(dut.data_out.value)\n    data_out_bits = f'{data_out:0{range_value}b}'\n    got_parity = {data_out_bits.count('1') % 2}\n    expected_parity = {data_in_bits.count('1') % 2}\n    #await RisingEdge(dut.clk)\n    \n\n    '''\n    if expected_parity == got_parity:\n        assert dut.parity_error.value == 0, f\"Test passed: Got {dut.parity_error.value}\"\n    else:\n        assert dut.parity_error.value == 1, f\"Test failed: Got {dut.parity_error.value}\" '''\n    \n    \n    dut._log.info(f\" ---------------------------------------------------------------------------------------------------------------------------\")\n    \nasync def drive_tx_error(dut,sel,range_value,data_in,data_wd):\n    \"\"\"Drive a byte of data to the DUT\"\"\"\n    \n    dut._log.info(f\" INJECT ERROR AT BEFORE TX START\")\n    await RisingEdge(dut.clk)\n    dut.data_in.value = data_in  # Assign a random byte (0-127)\n    dut.sel.value  = sel\n    await RisingEdge(dut.clk)\n    data_in_bits = f'{data_in:0{range_value}b}'\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}\")\n    await RisingEdge(dut.clk)\n    encoded_1 = int(dut.encoded_received_TX.value)\n    dut.received_1.value = encoded_1\n    received_1 = int(dut.received_1.value)\n    random_bit_position = random.randint(0, data_wd - 1)\n    received_1 ^= (1 << random_bit_position) \n    dut.received_1.value  = received_1\n    await RisingEdge(dut.clk)\n    error_corrected_1 = int(dut.error_corrected_1.value)\n    error_detected_1 = int(dut.error_detected_1.value)\n    if error_detected_1:\n            assert error_corrected_1, \"Error detected but not corrected!\"\n    dut._log.info(f\" encoded_1 = {encoded_1}, received_1 = {int(dut.received_1.value)}, error_corrected_1 = {error_corrected_1} , error_detected_1 = {error_detected_1}\")\n    dut._log.info(f\" data_out1 = {int(dut.uut_onebit_ecc1.data_out.value)}\")\n    await RisingEdge(dut.clk)\n    for i in range(range_value):\n        dut.sel.value  = sel\n        await RisingEdge(dut.clk)  \n    await RisingEdge(dut.done)\n    dut._log.info(f\"  data_out_rx = {int(dut.data_out_rx.value)} \")\n    encoded_2 = int(dut.encoded_2.value)\n    dut.received_2.value = encoded_2\n    await RisingEdge(dut.clk)\n    error_corrected_2 = int(dut.error_corrected_2.value)\n    error_detected_2 = int(dut.error_detected_2.value)\n    if error_detected_2:\n        assert error_corrected_2, \"Error detected but not corrected!\"\n    dut._log.info(f\" encoded_2 = {encoded_2}, received_2 = {int(dut.received_2.value)} , error_corrected_2 = {error_corrected_2} , error_detected_2 = {error_detected_2}\")\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}, data_out = {int(dut.data_out.value)}, done = {dut.done.value}\")\n\n    expected_data_out = dut.data_in.value\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, expected_data_out = {int(expected_data_out)}, data_out = {int(dut.data_out.value)}\")\n\n    assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    data_out = int(dut.data_out.value)\n    data_out_bits = f'{data_out:0{range_value}b}'\n    got_parity = {data_out_bits.count('1') % 2}\n    expected_parity = {data_in_bits.count('1') % 2}\n    dut._log.info(f\"  expected_parity = {data_in_bits.count('1') % 2}, got_parity = {data_out_bits.count('1') % 2} parity_error = {dut.parity_error.value}\")\n    '''\n    if expected_parity == got_parity:\n        assert dut.parity_error.value == 0, f\"Test passed: Got {dut.parity_error.value}\"\n    else:\n        assert dut.parity_error.value == 1, f\"Test failed: Got {dut.parity_error.value}\" '''\n    dut._log.info(f\" ---------------------------------------------------------------------------------------------------------------------------\")\n    \n\nasync def drive_rx_error(dut,sel,range_value,data_in,data_wd,crc_width,poly):\n    \"\"\"Drive a byte of data to the DUT\"\"\"\n    dut._log.info(f\" INJECT ERROR AT RX\")\n    \n    await RisingEdge(dut.clk)\n    \n    dut.data_in.value = data_in  # Assign a random byte (0-127)\n    dut.sel.value  = sel\n    await RisingEdge(dut.clk)\n    data_in_bits = f'{data_in:0{range_value}b}'\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}\")\n    await RisingEdge(dut.clk)\n    encoded_1 = int(dut.encoded_received_TX.value)\n    dut.received_1.value = encoded_1\n    await RisingEdge(dut.clk)\n    error_corrected_1 = int(dut.error_corrected_1.value)\n    error_detected_1 = int(dut.error_detected_1.value)\n    if error_detected_1:\n            assert error_corrected_1, \"Error detected but not corrected!\"\n    dut._log.info(f\" ecc_hamming_TX = {encoded_1}\")\n    #dut._log.info(f\" data_out1 = {int(dut.uut_onebit_ecc1.data_out.value)}\")\n    await RisingEdge(dut.clk)\n    dut.enable_crc_error.value = 1\n    for i in range(range_value):\n        dut.sel.value  = sel\n        await RisingEdge(dut.clk)   \n    await RisingEdge(dut.done)\n    await FallingEdge(dut.clk) \n    #dut._log.info(f\"  data_out_rx = {int(dut.data_out_rx.value)} \")\n    calculated_crc = int(dut.crc_out.value)\n    encoded_2 = int(dut.encoded_received_TX.value)\n    #dut.received_crc.value = calculated_crc\n    \n    #await RisingEdge(dut.clk)\n    dut.received_2.value = encoded_2\n    received_2 = int(dut.received_2.value)\n    random_bit_position = random.randint(0, data_wd - 1)\n    received_2 ^= (1 << random_bit_position) \n    dut.received_2.value  = received_2\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}, data_out = {int(dut.data_out.value)}, done = {dut.done.value}\")\n    await FallingEdge(dut.clk)\n    data_out_rx_temp = int(dut.data_out_rx_temp.value)\n    dut._log.info(f\" enable_crc_error = {dut.enable_crc_error.value} \")\n    expected_crc = compute_expected_crc(data_out_rx_temp, data_wd, crc_width, poly)\n    await FallingEdge(dut.clk)\n    crc_error_detected = int(dut.crc_error_detected.value)\n    #dut._log.info(f\" check::calculated_crc = {calculated_crc}, expected_crc = {expected_crc}, crc_error_detected = {dut.crc_error_detected.value}\")\n    error_corrected_2 = int(dut.error_corrected_2.value)\n    error_detected_2 = int(dut.error_detected_2.value)\n    if error_detected_2:\n        assert error_corrected_2, \"Error detected but not corrected!\"\n    dut._log.info(f\" AFTER RX RECIVED DATA FROM TX\")\n    dut._log.info(f\" ecc_hamming_RX = {int(encoded_2)}, ecc_hamming_received_TX = {int(dut.received_2.value)}\")\n    dut._log.info(f\" actual_crc = {calculated_crc}, expected_crc = {expected_crc}, actual_crc_error_detected = {crc_error_detected},expected_crc_error_detected = {int(calculated_crc != expected_crc )}\")\n    if calculated_crc == poly:\n        assert calculated_crc == expected_crc, f\"Test failed: calculated_crc =  {calculated_crc}, expected_crc {expected_crc}\"\n        assert crc_error_detected == 0, f\"Test failed: crc_error_detected =  {crc_error_detected}\"\n    elif calculated_crc == 0:\n        assert calculated_crc != expected_crc, f\"Test failed: calculated_crc =  {calculated_crc}, expected_crc {expected_crc}\"\n        assert crc_error_detected == 0, f\"Test failed: crc_error_detected =  {crc_error_detected}\"\n    else:\n        assert calculated_crc != expected_crc, f\"Test failed: calculated_crc =  {calculated_crc}, expected_crc {expected_crc}\"\n        assert crc_error_detected == 1, f\"Test failed: crc_error_detected =  {crc_error_detected}\"\n         \n    expected_data_out = dut.data_in.value\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, expected_data_out = {int(expected_data_out)}, data_out = {int(dut.data_out.value)}\")\n\n    assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    data_out = int(dut.data_out.value)\n    data_out_bits = f'{data_out:0{range_value}b}'\n    got_parity = {data_out_bits.count('1') % 2}\n    expected_parity = {data_in_bits.count('1') % 2}\n    '''\n    if expected_parity == got_parity:\n        assert dut.parity_error.value == 0, f\"Test passed: Got {dut.parity_error.value}\"\n    else:\n        assert dut.parity_error.value == 1, f\"Test failed: Got {dut.parity_error.value}\" '''\n\n    dut._log.info(f\" ---------------------------------------------------------------------------------------------------------------------------\")\n\nasync def inject_parity_error(dut):\n    \"\"\"Simulate injecting a parity error into the communication process.\"\"\"\n    # Initialize DUT signals\n    data_in = random.randint(0, 127)  # Generate random byte data\n    range_value = 8  # Assuming 8 bits for a byte\n    sel = 1          # Corresponding to the byte-level selection\n    corrupted_parity = 0\n\n    dut.sel.value = 0\n    dut.data_in.value = 0\n\n    # Reset the DUT\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n\n    # Drive the byte of data\n    dut.data_in.value = data_in\n    data_in_bits = f\"{data_in:08b}\"\n\n    for _ in range(range_value):\n        dut.sel.value = sel\n        await RisingEdge(dut.clk)\n\n    # Wait for the TX block to signal it's done\n    await RisingEdge(dut.done)\n    \n    # Force corrupt the parity bit (simulate bit flip)\n    #corrupted_parity = not dut.uut_tx_block.parity.value  # Invert the correct parity value\n    if dut.parity.value == 1:\n        corrupted_parity = 0\n    else:\n        corrupted_parity = 1\n\n    dut._log.info(f\"Original parity: {int(dut.parity.value)}, Injecting corrupted parity: {int(corrupted_parity)}\")\n    dut.parity.value = corrupted_parity\n\n    # Wait for RX block to process the corrupted data\n    await RisingEdge(dut.done)\n\n    # Validate the output\n    dut._log.info(f\"SEL: {int(dut.sel.value)}, Data In: {int(dut.data_in.value)}, \"\n                  f\"Data Out: {int(dut.data_out.value)}, Done: {int(dut.done.value)}, \"\n                  f\"Parity Error: {int(dut.parity_error.value)}\")\n\n    # Expecting a parity error\n    assert dut.parity_error.value == 1, f\"Parity error not detected! Parity Error: {int(dut.parity_error.value)}\"\n    dut._log.info(\"Parity error successfully injected and detected.\")\n\ndef compute_expected_crc(data, data_width, crc_width, poly):\n    crc = 0  # Initialize the CRC register\n    #print(f\" data_in = {data}, data_wd = {data_width}, crc_width = {crc_width}, poly = {poly} \")\n    for i in range(data_width - 1, -1, -1):  # Iterate through the data bits\n        msb = (crc >> (crc_width - 1)) & 1  # Get the MSB of the current CRC\n        data_bit = (data >> i) & 1  # Get the current data bit\n        \n        if msb ^ data_bit:  # If XOR of MSB and data bit is 1\n            crc = ((crc << 1) ^ poly) & ((1 << crc_width) - 1)  # XOR with POLY\n        else:\n            crc = (crc << 1) & ((1 << crc_width) - 1)  # Just shift left\n    \n    return crc  # Return the computed CRC\n"}}}
{"id": "cvdp_copilot_sync_serial_communication_0056", "categories": ["cid014", "medium"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the `sync_serial_communication_tx_rx `module, which integrates a `tx_block`, `rx_block`, and `onebit_ecc`. The module details and design requirements for assertion development are outlined below.\n\n## Specifications  \n\n**Interface:**\n\n**Parameters:** \n- `DATA_WIDTH` (default: 8): Width of input and output data.  \n- `CODE_WIDTH`: Encoded width for ECC (`DATA_WIDTH + $clog2(DATA_WIDTH + 1)`).  \n\n**Inputs:** \n- `clk`: Clock signal with a 50:50 duty cycle, active on the rising edge.  \n- `reset_n`: Active-low asynchronous reset signal.  \n- `sel [2:0]`: Selection signal for TX block.  \n- `data_in([DATA_WIDTH-1:0])`: Data input for TX block.  \n- `received_1([CODE_WIDTH-1:0])`: Received encoded data.  \n- `received_2([CODE_WIDTH-1:0])`: Second received encoded data.  \n\n**Outputs:**  \n- `data_out([DATA_WIDTH-1:0])`: Output data from RX block.  \n- `done`: Signal indicating completion.  \n- `parity_error`: Parity error flag.  \n- `encoded_received_TX([CODE_WIDTH-1:0])`: Transmitted ECC-encoded output.  \n- `encoded_2([CODE_WIDTH-1:0])`: ECC-encoded output from received data.  \n- `error_detected_1`: ECC error detected in transmitter.  \n- `error_corrected_1`: ECC error corrected in transmitter.  \n- `error_detected_2`: ECC error detected in receiver.  \n- `error_corrected_2`: ECC error corrected in receiver. \n\n## Module Overview\nThe `sync_serial_communication_tx_rx ` module integrates: \n- TX Block (`tx_block`): Serializes data_in, computes a parity bit, and transmits data serially.\n- RX Block (`rx_block`): Receives and deserializes data while checking for parity errors.\n- ECC Generator (`onebit_ecc`): Adds parity bits, detects, and corrects single-bit errors.\n\n## Behavioral Specifications\n**1. **Transmisson(`tx_block`)****\nThe `tx_block` serializes the `data_in` based on the `sel` input:\n- `sel == 3'b000`: No transmission, `data_out` remains 0.\n- `sel == 3'b001`: Transmits the 8 least significant bits.\n- `sel == 3'b010`: Transmits the 16 least significant bits.\n- `sel == 3'b011`: Transmits the 32 least significant bits.\n- `sel == 3'b100`: Transmits the entire 64-bit data.\n- A parity bit is computed as the XOR of all transmitted bits (^`data_in`).\n- A done signal is asserted when transmission completes.\n\n**2. **Reception(`rx_block`)****\n- The `rx_block`receives serial data and reconstructs `data_out`.\n- The `parity_error` flag is asserted if the received parity bit does not match the computed parity.\n- The done signal is asserted once deserialization is complete.\n\n**3. **One bit ECC(`onebit_ecc`)****\n- Detects and Corrects single-bit errors (`error_corrected_1`, `error_corrected_2`).\n- The RX block processes the received ECC data and reconstructs the original `data_out`.\n\n## Assertion Requirements\n\n**1.No ECC Error Detection When Encoded Data Matches**\n\n- Ensures that if `encoded_2` matches `encoded_received_temp`, both `error_detected_2` and `error_corrected_2` must remain LOW\n\n**2.ECC Data Integrity Check**\n\n- Ensures that when `encoded_2` is equal to `encoded_received_temp`, the ECC-corrected output (`data_out`) must be identical to the original input (`data_in`).\n\n **3.Parity Check**\n\n- Ensures that when `done` is HIGH and the parity of `data_in` matches the parity of `data_out`, the `parity_error` signal must remain LOW.\n\n**4.TX Done Signal Correctness**\n- The `done` signal in the TX module must be asserted HIGH when the bit count reaches zero for certain values of `sel` signal, namely `sel = 3b001` ,`sel = 3b010`, `sel = 3b011` and `sel = 3b100`.\n\n**5.RX Data Stability During Reception**\n- Ensures that `data_out` remains unchanged while the reception process is still ongoing when `done ` is LOW.\n\n---\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.", "context": {"rtl/sync_serial_communication_top.sv": "`timescale 1ns / 1ps\nmodule sync_serial_communication_tx_rx#(parameter DATA_WIDTH = 8,\n                                        parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1))(\n    input clk,                                  // Clock signal\n    input reset_n,                              // Active low reset signal\n    input [2:0] sel,                            // Selection signal for TX block\n    input [DATA_WIDTH-1:0] data_in,             // 64-bit data input for TX block\n    output [DATA_WIDTH-1:0] data_out,           // 64-bit data output from RX block\n    output done,                                // Done signal indicating completion\n    output parity_error,                        // parity error flag\n    input [CODE_WIDTH-1:0] received_1,\n    input [CODE_WIDTH-1:0] received_2,\n    output [CODE_WIDTH-1:0] encoded_received_TX,\n    output [CODE_WIDTH-1:0] encoded_2,\n    output error_detected_1,\n    output error_corrected_1,\n    output error_detected_2,\n    output error_corrected_2\n);\n\n// Internal signals\nwire tx_out;                       \nwire tx_done;                      \nwire serial_clk_in;  \nwire parity;    \nwire [DATA_WIDTH-1:0] data_out_rx;\nwire [DATA_WIDTH-1:0] data_out1;\nwire [DATA_WIDTH-1:0] data_out2;\nwire [CODE_WIDTH-1:0] encoded_received_temp;\nwire [CODE_WIDTH-1:0] encoded_received_temp2;\n\nonebit_ecc#(.DATA_WIDTH(DATA_WIDTH),.CODE_WIDTH(CODE_WIDTH)) uut_onebit_ecc1 (\n\n    .data_in(data_in),\n    .encoded(encoded_received_TX),\n    .received(encoded_received_temp2),\n    .data_out(data_out1),\n    .error_detected(error_detected_1),\n    .error_corrected(error_corrected_1)\n    );\n\n// Instantiate the TX block\ntx_block#(.DATA_WIDTH(DATA_WIDTH)) uut_tx_block (\n    .clk(clk),                     // Clock input to TX block\n    .reset_n(reset_n),             // Reset input to TX block\n    .data_in(data_in),             // 64-bit data input to TX block\n    .sel(sel),                     // Selection signal to TX block\n    .serial_out(tx_out),           // Serial data output from TX block\n    .done(tx_done),                // Done signal from TX block\n    .serial_clk(serial_clk_in),    // Serial clock output from TX block\n    .parity(parity)                // parity bit\n);\n\n// Instantiate the RX block\nrx_block#(.DATA_WIDTH(DATA_WIDTH)) uut_rx_block (\n    .clk(clk),                     // Clock input to RX block\n    .serial_clk(serial_clk_in),    // Serial clock input to RX block\n    .reset_n(reset_n),             // Reset input to RX block\n    .sel(sel),                     // Selection signal to RX block\n    .data_in(tx_out),              // Serial data input to RX block\n    .parity_in(parity),            // received parity bit\n    .data_out(data_out_rx),           // 64-bit data output from RX block\n    .done(done),                   // Done signal from RX block\n    .parity_error(parity_error)    // parity error flag\n    \n);\n\nonebit_ecc#(.DATA_WIDTH(DATA_WIDTH),.CODE_WIDTH(CODE_WIDTH)) uut_onebit_ecc2 (\n\n    .data_in(data_out_rx),\n    .encoded(encoded_2),\n    .received(encoded_received_temp),\n    .data_out(data_out),\n    .error_detected(error_detected_2),\n    .error_corrected(error_corrected_2)\n    );\n\nassign encoded_received_temp = received_2 | encoded_received_temp2;\nassign encoded_received_temp2 = encoded_received_TX;\nendmodule\n\n///// tx_block\nmodule tx_block#(parameter DATA_WIDTH = 8)(\n    input clk,               // Clock input\n    input reset_n,           // Active-low reset input\n    input [DATA_WIDTH-1:0] data_in,    // 64-bit parallel data input\n    input [2:0] sel,         // Selection input to choose data width\n    output reg serial_out,   // Serial data output\n    output reg done,         // Done signal indicating completion of transmission\n    output serial_clk,       // Clock for serial data transmission\n    output reg parity        // parity bit\n);\n\n// Internal registers\nreg [DATA_WIDTH-1:0] data_reg;       \nreg [6:0] bit_count;         \nreg [6:0] reg_count;        \nreg [6:0] temp_reg_count;    \n\n\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        // Reset all values on active-low reset\n        data_reg     <= {DATA_WIDTH{1'b0}};\t\t\t     \t           \n        bit_count    <= 7'h0;\t\t\t     \t           \n        reg_count    <= 7'h0;\t\n        parity       <= 1'b0;\t             \t       \n    end else begin\n        if (done == 1'b1) begin\n            case (sel)\n                3'b000: begin\n                    data_reg  <= 64'h0;             \t   \n                    bit_count <= 7'd0; \n                    parity    <= 1'b0;                    \n                end\n                3'b001: begin\n                    data_reg  <= {56'h0, data_in[7:0] };  \n                    bit_count <= 7'd7;\n                    parity    <= ^data_in[7:0];              \t   \n                end\n                3'b010: begin\n                    if (DATA_WIDTH >= 16) begin\n                        data_reg  <= { {(DATA_WIDTH - 16){1'b0}}, data_in[15:0] }; \n                        bit_count <= 7'd15; \n                        parity    <= ^data_in[15:0];\n                    end             \t   \n                end\n                3'b011: begin\n                    if (DATA_WIDTH >= 32) begin\n                        data_reg  <= { {(DATA_WIDTH - 32){1'b0}}, data_in[31:0] };\n                        bit_count <= 7'd31;  \n                        parity    <= ^data_in[31:0];\n                    end            \t \n                end\n                3'b100: begin\n                    if (DATA_WIDTH >= 64) begin\n                        data_reg  <={data_in[63:0] };   \t   \n                        bit_count <= 7'd63; \n                        parity    <= ^data_in[63:0];\n                    end             \t   \n                end\n                default: begin\n                    data_reg  <= {DATA_WIDTH{1'b0}};             \t   \n                    bit_count <= 7'h0; \n                    parity    <= 1'b0;              \t   \n                end\n            endcase\n           \n        end else if (bit_count > 7'h0) begin\n            data_reg   <= data_reg >> 1;                   \n            bit_count  <= bit_count - 1'b1;                \n            \n        end\n        reg_count <= bit_count;                            \n    end\nend\n\n// Generate serial clock based on reg_count\n//`ifdef SIMULATION\nassign  #1 serial_clk = clk && (temp_reg_count !== 7'd0) ; \n//`else\n//assign  serial_clk = clk && (temp_reg_count !== 7'd0) ;  \n//`endif\n\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n        temp_reg_count <= 7'h0;\t\t\t\t\t           \n    end\n    else begin\n        temp_reg_count <= reg_count;\t\t\t        \n    end\nend\n\n\n\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n\t   serial_out <= 1'b0;\t\t\t\t                \n    end\n    else if(reg_count > 7'h0 || bit_count > 7'h0) begin\n\t   serial_out <= data_reg[0];\t\t\t              \n    end\nend \n\nalways@(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n        done <= 1'b0;\t\t\t\t\t                  \n    end \n    else begin\n     if(bit_count == 7'h0) begin\n\t    done <= 1'b1; \t\t\t                          \n     end\n     else begin \n\t    done <= 1'b0;\t\t\t\t\t                  \n     end\nend\nend\n\n\nendmodule\n\n///// rx_block\nmodule rx_block#(parameter DATA_WIDTH = 8)(\n    input wire clk,  \t\t\t    // clock input\n    input wire reset_n,\t\t\t    // Active-low reset\n    input wire data_in,\t\t\t    // Serial input data\t\n    input wire serial_clk,\t\t    // Clock signal for serial data\n    input wire [2:0] sel,           // Selection output to choose data width\n    input wire parity_in,           // received parity\n    output reg done,\t\t\t    // Done signal to indicate data reception complete\t\t\n    output reg [DATA_WIDTH-1:0] data_out,  \t// Parallel output data after serial operation\n    output reg parity_error         // parity_error flag\n\n);\n\n    // Internal registers\n    reg [DATA_WIDTH-1:0] data_reg;\t\t    \n    reg [7:0] bit_count;\t\t   \n    reg [7:0] count;\t\t    \n\n    \n    always @(posedge serial_clk or negedge  reset_n) begin\n        if (!reset_n) begin\t\t    \n            data_reg <= {DATA_WIDTH{1'b0}};\t\t\n            bit_count <= 8'd0;\t\t\n        end else begin\n            if(done == 1'b1) begin                   \n                bit_count <= 8'b0;\n                data_reg <= {DATA_WIDTH{1'b0}};\n            end\n            else begin\n                 bit_count <= bit_count;\t\t\t\n            end\n                bit_count <= bit_count + 1'b1;\t     \n                data_reg[bit_count]<=data_in; \t     \n           end\n    end  \n    \n    \n    always@(posedge clk or negedge reset_n) begin\n    \tif(!reset_n) begin\t\t\t \t             \n    \t   count <= 8'd0;\t\t\t\t\t         \n           done <= 1'b0;\t\t\t\t\t         \n           data_out <= {DATA_WIDTH{1'b0}};\t\t\t\t\t     \n           parity_error  <= 1'b0;\t\t\t\t \n        end \n        else if(count >= bit_count && count != 8'd0) begin      \n           done <= 1'b1;\t\t\t\t             \n           case(sel)\n            3'b000:begin\n                data_out <= {DATA_WIDTH{1'b0}};\t\n                parity_error <= 1'b0;                   \n            end\n            3'b001:begin\n                if(parity_in == (^data_reg[7:0])) begin\n                    data_out <= {56'h0, data_reg[7:0]};\n                    parity_error <= 1'b0;\n                end    \n                else begin\n                    data_out <= {56'h0, data_reg[7:0]};\n                    parity_error <= 1'b1;\n                end   \n            end\n            3'b010:begin\n                if (DATA_WIDTH >= 16) begin\n                    if(parity_in == (^data_reg[15:0])) begin\n                        data_out <= {48'h0, data_reg[15:0]};    \n                        parity_error <= 1'b0;\n                    end    \n                    else begin\n                        data_out <= {48'h0, data_reg[15:0]}; \n                        parity_error <= 1'b1;\n                    end\n                end       \n            end\n            3'b011:begin\n                if (DATA_WIDTH >= 32) begin\n                    if(parity_in == (^data_reg[31:0])) begin\n                        data_out <= {32'h0, data_reg[31:0]};  \n                        parity_error <= 1'b0;\n                    end    \n                    else begin\n                        data_out <= {32'h0, data_reg[31:0]};  \n                        parity_error <= 1'b1;\n                    end\n                end        \n            end\n            3'b100:begin\n                if (DATA_WIDTH >= 64) begin\n                    if(parity_in == (^data_reg[63:0])) begin\n                        data_out <= {data_reg[63:0]};   \n                        parity_error <= 1'b0;\n                    end    \n                    else begin\n                        data_out <= {data_reg[63:0]}; \n                        parity_error <= 1'b1;\n                    end \n                end             \n            end\n            default:begin\n                data_out <= {DATA_WIDTH{1'b0}};    \n                parity_error <= 1'b0;               \n            end\n           endcase\n        end\n        else if(bit_count > 8'd0) begin              \n           count <= count+ 1'b1;\t\t\t\t     \n           done <= 1'b0;\t\t\t\t\t        \n        end\n        else begin  \t\t\t                     \n           count <= 8'd0;\t\t\t\t\t         \n           done <= 1'b0;\t\t\t\t\t           \n        end \n    end\nendmodule\n\nmodule onebit_ecc #(\n    parameter DATA_WIDTH = 4,                                  // Width of the data input\n    parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1) // Encoded width\n)(\n    input [DATA_WIDTH-1:0] data_in,                     // Input data\n    output reg [CODE_WIDTH-1:0] encoded,                // Encoded output\n    input [CODE_WIDTH-1:0] received,                    // Received encoded data\n    output reg [DATA_WIDTH-1:0] data_out,               // Corrected output\n    output reg error_detected,                          // Error detected flag\n    output reg error_corrected                          // Error corrected flag\n);\n\n    localparam PARITY_BITS = CODE_WIDTH - DATA_WIDTH;   // Number of parity bits\n\n    reg [PARITY_BITS-1:0] syndrome;                     // Syndrome for error detection\n    reg [CODE_WIDTH-1:0] corrected_data;                // Corrected received data\n\n\n    integer idx_i, idx_j, idx_k;\n    integer idx_m, idx_n;\n    integer idx_p, idx_q;\n\n\n    always @(*) begin\n        encoded = 0;\n        idx_k = 0;\n\n\n        for (idx_i = 0; idx_i < CODE_WIDTH; idx_i = idx_i + 1) begin\n            if ((idx_i + 1) & (idx_i)) begin\n                encoded[idx_i] = data_in[idx_k];\n                idx_k = idx_k + 1;\n            end\n        end\n\n\n        for (idx_i = 0; idx_i < PARITY_BITS; idx_i = idx_i + 1) begin\n            encoded[(1 << idx_i) - 1] = 0; \n            for (idx_j = 0; idx_j < CODE_WIDTH; idx_j = idx_j + 1) begin\n                if (((idx_j + 1) & (1 << idx_i)) && ((idx_j + 1) != (1 << idx_i))) begin\n                    encoded[(1 << idx_i) - 1] = encoded[(1 << idx_i) - 1] ^ encoded[idx_j];\n                end\n            end\n        end\n    end\n\n\n    always @(*) begin\n        syndrome = 0; \n        for (idx_m = 0; idx_m < PARITY_BITS; idx_m = idx_m + 1) begin\n            for (idx_n = 0; idx_n < CODE_WIDTH; idx_n = idx_n + 1) begin\n                if ((idx_n + 1) & (1 << idx_m)) begin\n                    syndrome[idx_m] = syndrome[idx_m] ^ received[idx_n];\n                end\n            end\n        end\n    end\n\n  \n    always @(*) begin\n        error_detected = |syndrome; \n    end\n\n    \n    always @(*) begin\n        corrected_data = received;\n        if (error_detected) begin\n            corrected_data[syndrome - 1] = ~corrected_data[syndrome - 1]; \n        end\n    end\n\n \n    always @(*) begin\n        idx_q = 0;\n        for (idx_p = 0; idx_p < CODE_WIDTH; idx_p = idx_p + 1) begin\n            if ((idx_p + 1) & (idx_p)) begin\n                data_out[idx_q] = corrected_data[idx_p];\n                idx_q = idx_q + 1;\n            end\n        end\n    end\n\n\n    always @(*) begin\n        error_corrected = error_detected; \n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sync_serial_communication_top.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sync_serial_communication_top.sv\nTOPLEVEL        = sync_serial_communication_tx_rx\nMODULE          = test_sync_serial_communication\nPYTHONPATH      = /src\nHASH            = 18886fab7078f9c484b5ffe7e8d0fc93f0cb3bbc", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n\nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    toplevel = os.getenv(\"TOPLEVEL\")\n    target = float(os.getenv(\"TARGET\"))\n\n    if toplevel in metrics:\n        if \"Overall Average\" in metrics[toplevel]:\n            if metrics[toplevel][\"Overall Average\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n\n        elif \"Assertion\" in metrics[toplevel]:\n            if metrics[toplevel][\"Assertion\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Assertion\"]) >= 100.00, \"Didn't achieve the required coverage result.\"\n\n        elif \"Toggle\" in metrics[toplevel]:\n            if metrics[toplevel][\"Toggle\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Toggle\"]) >= target, \"Didn't achieve the required coverage result.\"\n\n        elif \"Block\" in metrics[toplevel]:\n            if metrics[toplevel][\"Block\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Block\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n        \nif __name__ == \"__main__\":\n    test_simulate()", "src/test_sync_serial_communication.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge,FallingEdge,Timer\nimport harness_library as hrs_lb\nimport random\n\n\n\n\n# Main test for sync_communication top module\n@cocotb.test()\nasync def test_sync_communication(dut):\n    data_wd = int(dut.DATA_WIDTH.value)                                    # Get the data width from the DUT (Device Under Test)\n    # Start the clock with a 10ns time period\n\n    if data_wd == 8:\n        range_value = 8\n        data_in = random.randint(0, 127)\n        sel = 1\n    elif data_wd == 16:\n        range_value = 16\n        data_in = random.randint(0,4196)\n        sel = 2\n    elif data_wd == 32:\n        range_value = 32\n        data_in = random.randint(0,18192)\n        sel = 3\n    elif data_wd == 64:\n        range_value = 64\n        data_in = random.randint(0,154097)\n        sel = 4\n\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n\n    # Ensure all control signals are low initially before starting the test\n    dut.sel.value = 0\n    dut.data_in.value = 0\n    dut.received_1.value = 0\n    dut.received_2.value = 0\n\n    # Main test loop to validate both PISO and SIPO functionality\n    for _ in range(sel):\n        await drive_byte(dut,sel,range_value,data_in)\n        await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n        await RisingEdge(dut.clk)\n        await drive_rx_error(dut,sel,range_value,data_in,data_wd)\n        await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n        await RisingEdge(dut.clk)\n\n    #await inject_parity_error(dut)\n\n\nasync def drive_byte(dut,sel,range_value,data_in):\n    \"\"\"Drive a byte of data to the DUT\"\"\"\n    dut._log.info(f\" DRIVE TRANSACTION NORMAL MODE\")\n    await RisingEdge(dut.clk)\n    dut.data_in.value = data_in  # Assign a random byte (0-127)\n    dut.sel.value  = sel\n    await RisingEdge(dut.clk)\n    data_in_bits = f'{data_in:0{range_value}b}'\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}\")\n    await RisingEdge(dut.clk)\n    encoded_1 = int(dut.encoded_received_TX.value)\n    dut.received_1.value = encoded_1\n    await RisingEdge(dut.clk)\n    error_corrected_1 = int(dut.error_corrected_1.value)\n    error_detected_1 = int(dut.error_detected_1.value)\n    if error_detected_1:\n            assert error_corrected_1, \"Error detected but not corrected!\"\n    dut._log.info(f\" ecc_hamming_TX = {encoded_1}\")\n    #dut._log.info(f\" data_out1 = {int(dut.uut_onebit_ecc1.data_out.value)}\")\n    await RisingEdge(dut.clk)\n    for i in range(range_value):\n        dut.sel.value  = sel\n        await RisingEdge(dut.clk)  \n    await RisingEdge(dut.done)\n    #await RisingEdge(dut.clk) \n    #dut._log.info(f\"  data_out_rx = {int(dut.data_out_rx.value)} \")\n    encoded_2 = int(dut.encoded_received_TX.value)\n    dut.received_2.value = encoded_2\n    await RisingEdge(dut.clk)\n    error_corrected_2 = int(dut.error_corrected_2.value)\n    error_detected_2 = int(dut.error_detected_2.value)\n    if error_detected_2:\n            assert error_corrected_2, \"Error detected but not corrected!\"\n    dut._log.info(f\" AFTER RX RECIVED DATA FROM TX\")\n\n    dut._log.info(f\" ecc_hamming_RX = {encoded_2}, ecc_hamming_received_TX = {int(dut.received_2.value)} \")\n    \n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}, data_out = {int(dut.data_out.value)}, done = {dut.done.value}\")\n\n    expected_data_out = dut.data_in.value\n    assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, expected_data_out = {int(expected_data_out)}, data_out = {int(dut.data_out.value)}\")\n\n    #assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    data_out = int(dut.data_out.value)\n    data_out_bits = f'{data_out:0{range_value}b}'\n    got_parity = {data_out_bits.count('1') % 2}\n    expected_parity = {data_in_bits.count('1') % 2}\n    \n    '''\n    if expected_parity == got_parity:\n        assert dut.parity_error.value == 0, f\"Test passed: Got {dut.parity_error.value}\"\n    else:\n        assert dut.parity_error.value == 1, f\"Test failed: Got {dut.parity_error.value}\" '''\n    \n    \n    dut._log.info(f\" ---------------------------------------------------------------------------------------------------------------------------\")\n    \nasync def drive_tx_error(dut,sel,range_value,data_in,data_wd):\n    \"\"\"Drive a byte of data to the DUT\"\"\"\n    dut._log.info(f\" INJECT ERROR AT BEFORE TX START\")\n    await RisingEdge(dut.clk)\n    dut.data_in.value = data_in  # Assign a random byte (0-127)\n    dut.sel.value  = sel\n    await RisingEdge(dut.clk)\n    data_in_bits = f'{data_in:0{range_value}b}'\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}\")\n    await RisingEdge(dut.clk)\n    encoded_1 = int(dut.encoded_received_TX.value)\n    dut.received_1.value = encoded_1\n    received_1 = int(dut.received_1.value)\n    random_bit_position = random.randint(0, data_wd - 1)\n    received_1 ^= (1 << random_bit_position) \n    dut.received_1.value  = received_1\n    await RisingEdge(dut.clk)\n    error_corrected_1 = int(dut.error_corrected_1.value)\n    error_detected_1 = int(dut.error_detected_1.value)\n    if error_detected_1:\n            assert error_corrected_1, \"Error detected but not corrected!\"\n    dut._log.info(f\" encoded_1 = {encoded_1}, received_1 = {int(dut.received_1.value)}, error_corrected_1 = {error_corrected_1} , error_detected_1 = {error_detected_1}\")\n    dut._log.info(f\" data_out1 = {int(dut.uut_onebit_ecc1.data_out.value)}\")\n    await RisingEdge(dut.clk)\n    for i in range(range_value):\n        dut.sel.value  = sel\n        await RisingEdge(dut.clk)  \n    await RisingEdge(dut.done)\n    dut._log.info(f\"  data_out_rx = {int(dut.data_out_rx.value)} \")\n    encoded_2 = int(dut.encoded_2.value)\n    dut.received_2.value = encoded_2\n    await RisingEdge(dut.clk)\n    error_corrected_2 = int(dut.error_corrected_2.value)\n    error_detected_2 = int(dut.error_detected_2.value)\n    if error_detected_2:\n        assert error_corrected_2, \"Error detected but not corrected!\"\n    dut._log.info(f\" encoded_2 = {encoded_2}, received_2 = {int(dut.received_2.value)} , error_corrected_2 = {error_corrected_2} , error_detected_2 = {error_detected_2}\")\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}, data_out = {int(dut.data_out.value)}, done = {dut.done.value}\")\n\n    expected_data_out = dut.data_in.value\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, expected_data_out = {int(expected_data_out)}, data_out = {int(dut.data_out.value)}\")\n\n    assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    data_out = int(dut.data_out.value)\n    data_out_bits = f'{data_out:0{range_value}b}'\n    got_parity = {data_out_bits.count('1') % 2}\n    expected_parity = {data_in_bits.count('1') % 2}\n    dut._log.info(f\"  expected_parity = {data_in_bits.count('1') % 2}, got_parity = {data_out_bits.count('1') % 2} parity_error = {dut.parity_error.value}\")\n    '''\n    if expected_parity == got_parity:\n        assert dut.parity_error.value == 0, f\"Test passed: Got {dut.parity_error.value}\"\n    else:\n        assert dut.parity_error.value == 1, f\"Test failed: Got {dut.parity_error.value}\" '''\n    dut._log.info(f\" ---------------------------------------------------------------------------------------------------------------------------\")\n    \n\nasync def drive_rx_error(dut,sel,range_value,data_in,data_wd):\n    \"\"\"Drive a byte of data to the DUT\"\"\"\n    dut._log.info(f\" INJECT ERROR AT RX\")\n    await RisingEdge(dut.clk)\n    dut.data_in.value = data_in  # Assign a random byte (0-127)\n    dut.sel.value  = sel\n    await RisingEdge(dut.clk)\n    data_in_bits = f'{data_in:0{range_value}b}'\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}\")\n    await RisingEdge(dut.clk)\n    encoded_1 = int(dut.encoded_received_TX.value)\n    dut.received_1.value = encoded_1\n    await RisingEdge(dut.clk)\n    error_corrected_1 = int(dut.error_corrected_1.value)\n    error_detected_1 = int(dut.error_detected_1.value)\n    if error_detected_1:\n            assert error_corrected_1, \"Error detected but not corrected!\"\n    dut._log.info(f\" ecc_hamming_TX = {encoded_1}\")\n    #dut._log.info(f\" data_out1 = {int(dut.uut_onebit_ecc1.data_out.value)}\")\n    await RisingEdge(dut.clk)\n    for i in range(range_value):\n        dut.sel.value  = sel\n        await RisingEdge(dut.clk)   \n    await RisingEdge(dut.done)\n    #await RisingEdge(dut.clk) \n    #dut._log.info(f\"  data_out_rx = {int(dut.data_out_rx.value)} \")\n    encoded_2 = int(dut.encoded_received_TX.value)\n    #await RisingEdge(dut.clk)\n    dut.received_2.value = encoded_2\n    received_2 = int(dut.received_2.value)\n    random_bit_position = random.randint(0, data_wd - 1)\n    received_2 ^= (1 << random_bit_position) \n    dut.received_2.value  = received_2\n    await FallingEdge(dut.clk)\n    error_corrected_2 = int(dut.error_corrected_2.value)\n    error_detected_2 = int(dut.error_detected_2.value)\n    if error_detected_2:\n        assert error_corrected_2, \"Error detected but not corrected!\"\n    dut._log.info(f\" AFTER RX RECIVED DATA FROM TX\")\n    dut._log.info(f\" ecc_hamming_RX = {int(encoded_2)}, ecc_hamming_received_TX = {int(dut.received_2.value)}\")\n    \n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}, data_out = {int(dut.data_out.value)}, done = {dut.done.value}\")\n\n    expected_data_out = dut.data_in.value\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, expected_data_out = {int(expected_data_out)}, data_out = {int(dut.data_out.value)}\")\n\n    assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    data_out = int(dut.data_out.value)\n    data_out_bits = f'{data_out:0{range_value}b}'\n    got_parity = {data_out_bits.count('1') % 2}\n    expected_parity = {data_in_bits.count('1') % 2}\n    '''\n    if expected_parity == got_parity:\n        assert dut.parity_error.value == 0, f\"Test passed: Got {dut.parity_error.value}\"\n    else:\n        assert dut.parity_error.value == 1, f\"Test failed: Got {dut.parity_error.value}\" '''\n\n    dut._log.info(f\" ---------------------------------------------------------------------------------------------------------------------------\")\n\n\nasync def inject_parity_error(dut):\n    \"\"\"Simulate injecting a parity error into the communication process.\"\"\"\n    # Initialize DUT signals\n    data_in = random.randint(0, 127)  # Generate random byte data\n    range_value = 8  # Assuming 8 bits for a byte\n    sel = 1          # Corresponding to the byte-level selection\n    corrupted_parity = 0\n\n    dut.sel.value = 0\n    dut.data_in.value = 0\n\n    # Reset the DUT\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n\n    # Drive the byte of data\n    dut.data_in.value = data_in\n    data_in_bits = f\"{data_in:08b}\"\n\n    for _ in range(range_value):\n        dut.sel.value = sel\n        await RisingEdge(dut.clk)\n\n    # Wait for the TX block to signal it's done\n    await RisingEdge(dut.done)\n    \n    # Force corrupt the parity bit (simulate bit flip)\n    #corrupted_parity = not dut.uut_tx_block.parity.value  # Invert the correct parity value\n    if dut.parity.value == 1:\n        corrupted_parity = 0\n    else:\n        corrupted_parity = 1\n\n    dut._log.info(f\"Original parity: {int(dut.parity.value)}, Injecting corrupted parity: {int(corrupted_parity)}\")\n    dut.parity.value = corrupted_parity\n\n    # Wait for RX block to process the corrupted data\n    await RisingEdge(dut.done)\n\n    # Validate the output\n    dut._log.info(f\"SEL: {int(dut.sel.value)}, Data In: {int(dut.data_in.value)}, \"\n                  f\"Data Out: {int(dut.data_out.value)}, Done: {int(dut.done.value)}, \"\n                  f\"Parity Error: {int(dut.parity_error.value)}\")\n\n    # Expecting a parity error\n    assert dut.parity_error.value == 1, f\"Parity error not detected! Parity Error: {int(dut.parity_error.value)}\"\n    dut._log.info(\"Parity error successfully injected and detected.\")\n"}}}
{"id": "cvdp_copilot_sync_serial_communication_0059", "categories": ["cid013", "medium"], "input": {"prompt": "Modify the SystemVerilog testbench `sync_serial_communication_tb` to integrate the functionality of the checker to test the `sync_serial_communication_tx_rx` module. The testbench provided in the context already has stimulus generator for various test cases. The purpose of the testbench checker is to verify the functionality of the` sync_serial_communication_tx_rx` to ensure proper handling of data transmission and reception scenarios and confirm that the computed results match the expected outputs as per the design specification.\n\n## Design Specification\nThe behavior of `sync_serial_communication_tx_rx` data transmission happens based on different selection (`sel`) mode. The TX block of the design converts parallel data into a serial format based on the `sel` input and RX block captures incoming serial data and reconstructs it into the specified parallel data based on the `sel` input. Computes parity for transmitted data. Checks parity upon reception. The final module captures parallel data and outputs parallel data selected from `data_in` based on `sel` input as described below.\n\n- **3'b000:** Zero-bit data transmission.\n- **3'b001:** 8-bit data transmission.\n- **3'b010:** 16-bit data transmission.\n- **3'b011:** 32-bit data transmission.\n- **3'b100:** 64-bit data transmission.\n\n## Testbench Requirements\n\n**Inputs:**\n\n- `clk (1-bit)`: Clock signal with a 50:50 duty cycle (rising edge active).\n- `reset_n (1-bit)`: Active-Low synchronous reset. \n- `sel (3-bit)`: Determines the data size for transmission.\n- `data_in ([63:0])`: Input data for transmission.\n\n**Outputs:**\n\n- `done (1-bit)`: Indicates completion of data transmission.\n- `data_out ([63:0])`: Received data output.\n- `parity_error (1-bit)`: Indicates if a parity error was detected.\n\n**Internal Signals for Verification:**\n\n- `expected_data_out ([63:0])`: Stores the expected output after transmission.\n- `expected_parity (1-bit)`: Stores the expected parity of transmitted data.\n\n## Checker Requirements\n\n- DUT Instantiation as uut.\n- **Task drive_byte:**\n    - Computes `expected_data_out` and `expected_parity` based on the selected mode (`sel=3'b001`).\n        - `expected_data_out = data_in[7:0]` (Extracts least significant 8 bits).\n        - `expected_parity = ^data_in[7:0]` (Computes even parity using XOR).\n    - **Assert:** ((`data_out` == `expected_data_out`)&& (`expected_parity` == ^`data_out`))\n    - Log results(pass/fail) for each test vector with a detailed message.\n- **Task drive_half_word:**\n    - computes `expected_data_out` and `expected_parity` based on the selected mode (`sel=3'b010`).\n        - `expected_data_out = data_in[15:0]` (Extracts least significant 16 bits).\n        - `expected_parity = ^data_in[15:0]` (Computes even parity).\n    - **Assert:** ((`data_out` == `expected_data_out`)&& (`expected_parity` == ^`data_out`))\n    - Log results(pass/fail) for each test vector with a detailed message.\n- **Task drive_word:**\n    - computes `expected_data_out` and `expected_parity` based on the selected mode (`sel=3'b011`).\n        - `expected_data_out = data_in[31:0]` (Extracts least significant 32 bits).\n        - `expected_parity = ^data_in[31:0]` (Computes even parity).\n    - **Assert:** ((`data_out` == `expected_data_out`)&& (`expected_parity` == ^`data_out`))\n    - Log results(pass/fail) for each test vector with a detailed message.\n- **Task double_word:**\n    - computes `expected_data_out` and `expected_parity` based on the selected mode (`sel=3'b011`).\n        - `expected_data_out = data_in[63:0]` (Extracts full 64-bit data).\n        - `expected_parity = ^data_in[63:0]` (Computes even parity).\n    - **Assert:** ((`data_out` == `expected_data_out`)&& (`expected_parity` == ^`data_out`))\n    - Log results(pass/fail) for each test vector with a detailed message.\n\n## Deliverables\nProvide a modified SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the ` sync_serial_communication_tx_rx` module.", "context": {"verif/sync_serial_communication_top.sv": "module sync_serial_communication_tb();\n\nreg clk;                    // Clock signal\nreg reset_n;                // Active-low reset signal\nreg [2:0] sel;              // Selection signal\nreg [63:0] data_in;         // Data input signal\nwire done;                  // Done signal (output from DUT)\nwire [63:0] data_out;       // Data output signal\nwire parity_error;\ninteger i;                  // Loop variable for tasks\n\n\nsync_serial_communication_tx_rx uut(\n    .clk(clk),\n    .reset_n(reset_n),\n    .sel(sel),\n    .data_in(data_in),\n    .data_out(data_out),\n    .done(done),\n    .parity_error(parity_error)\n);\n\n\ninitial begin\n    clk = 0;\n    forever #5 clk = ~clk;\nend\n\n\ninitial begin\n    reset_n = 0;                        \t\t             \n    @(posedge clk);\n    @(posedge clk);\n    initialization();                   \t\t             \n    @(negedge clk);\n    reset_n = 1;                        \t\t             \n    @(posedge clk);\n    repeat(30) begin\n        drive_byte();                                        \n        reset();                        \n        drive_half_word();                                   \n        reset();\n        drive_word();                   \n        reset();                    \n        double_word();                                       \n        reset();\n        \n    end\n    #100;    \t\t\t\t\t\t                         \n    $finish();                                               \nend\n\ntask initialization();\nbegin\n    @(posedge clk);\n    if (!reset_n) begin\n        data_in <= 64'd0;                \t\t             \n        sel     <= 3'b000;               \t\t             \n    end\nend\nendtask\n\n\ntask drive_byte();\nbegin\n    @(posedge clk);\n    data_in = $urandom_range(0,(2**8)-1);\t\n    for (i = 0; i <= 7; i = i + 1) begin\n        sel <= 3'b001;                   \t\t          \n        @(posedge clk);\n    end\n    wait(done);\n    $display(\"-----------------------------------------------------------------------------------------------------------------------------------\");\n    $display(\"%t DRIVE_BYTE:: sel = %h, data_in = %h, data_out = %h, done = %b,parity_error = %b\", $time,sel,data_in,data_out,done,parity_error);\nend\nendtask\n\n\ntask drive_half_word();\nbegin\n    @(posedge clk);\n    data_in = $urandom_range(0,(2**16)-1);           \t\t                        \n    for (i = 0; i <= 15; i = i + 1) begin\n        @(posedge clk);\n        sel <= 3'b010;                   \t\t            \n    end\n    wait(done);\n    $display(\"----------------------------------------------------------------------------------------------------------------------------------\");\n    $display(\"%t DRIVE_HALF_WORD:: sel = %h, data_in = %h, data_out = %h, done = %b,parity_error = %b\", $time,sel,data_in,data_out,done,parity_error);\nend\nendtask\n\n\ntask drive_word();\nbegin\n    @(posedge clk);\n    data_in = $urandom_range(0,(2**31)-1);             \t\t        \n    for (i = 0; i <= 31; i = i + 1) begin\n        @(posedge clk);\n        sel <= 3'b011;                  \t\t            \n    end\n    wait(done);\n    $display(\"-------------------------------------------------------------------------------------------------\");\n    $display(\"%t DRIVE_WORD:: sel = %h, data_in = %h, data_out = %h, done = %b,parity_error = %b\", $time,sel,data_in,data_out,done,parity_error);\nend\nendtask\n\n\ntask double_word();\nbegin\n    @(posedge clk);\n    data_in = $urandom_range(0,(2**64)-1);            \t\t        \n    for (i = 0; i <= 63; i = i + 1) begin\n        @(posedge clk);\n        sel <= 3'b100;                  \t                \n    end\n    wait(done);\n    $display(\"-------------------------------------------------------------------------------------------------\");\n    $display(\"%t DRIVE_DOUBLE_WORD:: sel = %h, data_in = %h, data_out = %h, done = %b,parity_error = %b\", $time,sel,data_in,data_out,done,parity_error);\nend\nendtask\n\ntask reset;\n    @(posedge clk);\n    reset_n = 1'b0;                                      \n    @(posedge clk);\n    initialization();                                    \n    @(negedge clk);\n    reset_n = 1'b1;                                      \nendtask\n\ninitial begin\n$dumpfile(\"dump.vcd\");\n$dumpvars(0,sync_serial_communication_tb);\nend\nendmodule"}}, "output": {"response": "", "context": {"verif/sync_serial_communication_top.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/sync_serial_communication_top.sv\nHASH            = 1af35036f58c466c02b39bfa7649e90be9ae17a5\nNUM_BUGS        = 4\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/sync_serial_communication_top.sv /code/verif/sync_serial_communication_top.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"", "src/sync_serial_communication_top.sv": "`timescale 1ns / 1ps\nmodule sync_serial_communication_tx_rx(\n    input clk,                     // Clock signal\n    input reset_n,                 // Active low reset signal\n    input [2:0] sel,               // Selection signal for TX block\n    input [63:0] data_in,          // 64-bit data input for TX block\n    output [63:0] data_out,        // 64-bit data output from RX block\n    output done,                   // Done signal indicating completion\n    output parity_error            // parity error flag\n);\n\n// Internal signals\nwire tx_out;                       \nwire tx_done;                      \nwire serial_clk_in;  \nwire parity;              \n\n// Instantiate the TX block\ntx_block uut_tx_block (\n    .clk(clk),                     // Clock input to TX block\n    .reset_n(reset_n),             // Reset input to TX block\n    .data_in(data_in),             // 64-bit data input to TX block\n    .sel(sel),                     // Selection signal to TX block\n    .serial_out(tx_out),           // Serial data output from TX block\n    .done(tx_done),                // Done signal from TX block\n    .serial_clk(serial_clk_in),    // Serial clock output from TX block\n    .parity(parity)                // parity bit\n);\n\n// Instantiate the RX block\nrx_block uut_rx_block (\n    .clk(clk),                     // Clock input to RX block\n    .serial_clk(serial_clk_in),    // Serial clock input to RX block\n    .reset_n(reset_n),             // Reset input to RX block\n    .sel(sel),                     // Selection signal to RX block\n    .data_in(tx_out),              // Serial data input to RX block\n    .parity_in(parity),            // received parity bit\n    .data_out(data_out),           // 64-bit data output from RX block\n    .done(done),                   // Done signal from RX block\n    .parity_error(parity_error)    // parity error flag\n    \n);\n\nendmodule\n\n///// tx_block\nmodule tx_block(\n    input clk,               // Clock input\n    input reset_n,           // Active-low reset input\n    input [63:0] data_in,    // 64-bit parallel data input\n    input [2:0] sel,         // Selection input to choose data width\n    output reg serial_out,   // Serial data output\n    output reg done,         // Done signal indicating completion of transmission\n    output serial_clk,       // Clock for serial data transmission\n    output reg parity        // parity bit\n);\n\n// Internal registers\nreg [63:0] data_reg;       \nreg [6:0] bit_count;         \nreg [6:0] reg_count;        \nreg [6:0] temp_reg_count;    \n\n\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        // Reset all values on active-low reset\n        data_reg     <= 64'h0;\t\t\t     \t           \n        bit_count    <= 7'h0;\t\t\t     \t           \n        reg_count    <= 7'h0;\t\n        parity       <= 1'b0;\t             \t       \n    end else begin\n        if (done == 1'b1) begin\n            case (sel)\n                3'b000: begin\n                    data_reg  <= 64'h0;             \t   \n                    bit_count <= 7'd0; \n                    parity    <= 1'b0;                    \n                end\n                3'b001: begin\n                    `ifndef BUG_0\n                        data_reg  <= {56'h0, data_in[7:0]};\n                    `else\n                        data_reg  <= {63'h0, data_in[0]};\n                     `endif\n                    bit_count <= 7'd7;\n                    parity    <= ^data_in[7:0];         \t   \n                end\n                3'b010: begin\n                    `ifndef BUG_1\n                        data_reg  <= {48'h0, data_in[15:0]};  \n                    `else\n                        data_reg  <= {63'h0, data_in[0]}; \n                    `endif\n                    bit_count <= 7'd15; \n                    parity    <= ^data_in[15:0];                 \t   \n                end\n                3'b011: begin\n                    `ifndef BUG_2\n                    data_reg  <= {32'h0, data_in[31:0]};  \n                    `else\n                     data_reg  <= {56'h0, data_in[7:0]}; \n                     `endif\n                    bit_count <= 7'd31;  \n                    parity    <= ^data_in[31:0];             \t \n                end\n                3'b100: begin\n                    `ifndef BUG_3\n                        data_reg  <= data_in[63:0]; \n                    `else\n                        data_reg  <= {48'h0, data_in[15:0]}; \n                    `endif\n                    bit_count <= 7'd63; \n                    parity    <= ^data_in[63:0];               \t   \n                end\n                default: begin\n                    data_reg  <= 64'h0;             \t   \n                    bit_count <= 7'h0; \n                    parity    <= 1'b0;              \t   \n                end\n            endcase\n           \n        end else if (bit_count > 7'h0) begin\n            data_reg   <= data_reg >> 1;                   \n            bit_count  <= bit_count - 1'b1;                \n            \n        end\n        reg_count <= bit_count;                            \n    end\nend\n\n// Generate serial clock based on reg_count\n//`ifdef SIMULATION\nassign  #1 serial_clk = clk && (temp_reg_count !== 7'd0) ; \n//`else\n//assign  serial_clk = clk && (temp_reg_count !== 7'd0) ;  \n//`endif\n\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n        temp_reg_count <= 7'h0;\t\t\t\t\t           \n    end\n    else begin\n        temp_reg_count <= reg_count;\t\t\t        \n    end\nend\n\n\n\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n\t   serial_out <= 1'b0;\t\t\t\t                \n    end\n    else if(reg_count > 7'h0 || bit_count > 7'h0) begin\n\t   serial_out <= data_reg[0];\t\t\t              \n    end\nend \n\nalways@(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n        done <= 1'b0;\t\t\t\t\t                  \n    end \n    else begin\n     if(bit_count == 7'h0) begin\n\t    done <= 1'b1; \t\t\t                          \n     end\n     else begin \n\t    done <= 1'b0;\t\t\t\t\t                  \n     end\nend\nend\n\n\nendmodule\n\n///// rx_block\nmodule rx_block(\n    input wire clk,  \t\t\t    // clock input\n    input wire reset_n,\t\t\t    // Active-low reset\n    input wire data_in,\t\t\t    // Serial input data\t\n    input wire serial_clk,\t\t    // Clock signal for serial data\n    input wire [2:0] sel,           // Selection output to choose data width\n    input wire parity_in,           // received parity\n    output reg done,\t\t\t    // Done signal to indicate data reception complete\t\t\n    output reg [63:0] data_out,  \t// Parallel output data after serial operation\n    output reg parity_error         // parity_error flag\n\n);\n\n    // Internal registers\n    reg [63:0] data_reg;\t\t    \n    reg [7:0] bit_count;\t\t   \n    reg [7:0] count;\t\t    \n\n    \n    always @(posedge serial_clk or negedge  reset_n) begin\n        if (!reset_n) begin\t\t    \n            data_reg <= 64'h0;\t\t\n            bit_count <= 8'd0;\t\t\n        end else begin\n            if(done == 1'b1) begin                   \n                bit_count <= 8'b0;\n                data_reg <= 64'h0;\n            end\n            else begin\n                 bit_count <= bit_count;\t\t\t\n            end\n                bit_count <= bit_count + 1'b1;\t     \n                data_reg[bit_count]<=data_in; \t     \n           end\n    end  \n    \n    \n    always@(posedge clk or negedge reset_n) begin\n    \tif(!reset_n) begin\t\t\t \t             \n    \t   count <= 8'd0;\t\t\t\t\t         \n           done <= 1'b0;\t\t\t\t\t         \n           data_out <= 64'h0;\t\t\t\t\t     \n           parity_error  <= 1'b0;\t\t\t\t \n        end \n        else if(count >= bit_count && count != 8'd0) begin      \n           done <= 1'b1;\t\t\t\t             \n           case(sel)\n            3'b000:begin\n                data_out <= 64'h0;\n                parity_error <= 1'b0;                   \n            end\n            3'b001:begin\n                if(parity_in == (^data_reg[7:0])) begin\n                    data_out <= {56'h0,data_reg}; \n                    parity_error <= 1'b0;\n                end    \n                else begin\n                    data_out <= {56'h0,data_reg};\n                    parity_error <= 1'b1;\n                end   \n            end\n            3'b010:begin\n                if(parity_in == (^data_reg[15:0])) begin\n                    data_out <= {48'h0,data_reg};  \n                    parity_error <= 1'b0;\n                end    \n                else begin\n                    data_out <= {48'h0,data_reg};\n                    parity_error <= 1'b1;\n                end       \n            end\n            3'b011:begin\n                if(parity_in == (^data_reg[31:0])) begin\n                    data_out <= {32'h0,data_reg}; \n                    parity_error <= 1'b0;\n                end    \n                else begin\n                    data_out <= {32'h0,data_reg};\n                    parity_error <= 1'b1;\n                end        \n            end\n            3'b100:begin\n                if(parity_in == (^data_reg)) begin\n                    data_out <= data_reg; \n                    parity_error <= 1'b0;\n                end    \n                else begin\n                    data_out <= data_reg;\n                    parity_error <= 1'b1;\n                end              \n            end\n            default:begin\n                data_out <= 64'h0;    \n                parity_error <= 1'b0;               \n            end\n           endcase\n        end\n        else if(bit_count > 8'd0) begin              \n           count <= count+ 1'b1;\t\t\t\t     \n           done <= 1'b0;\t\t\t\t\t        \n        end\n        else begin  \t\t\t                     \n           count <= 8'd0;\t\t\t\t\t         \n           done <= 1'b0;\t\t\t\t\t           \n        end \n    end\nendmodule"}}}
{"id": "cvdp_copilot_tensor_compute_unit_0004", "categories": ["cid013", "medium"], "input": {"prompt": "Develop a **SystemVerilog testbench** for the `tensor_compute_unit` module to validate its functionality in performing matrix multiplication and other tensor operations according to specified parameters.\n\nThe tensor compute unit can perform tensor instructions such as matrix multiplication, elementwise operations, and tensor-scalar addition on two unsigned input arrays (in this context: tensors). The module must implement all tensor instructions based on the systolic array concept. A systolic array is a hardware architecture with interconnected processing elements (PEs) that synchronously compute and pass data to other PEs in a pipeline-like manner, ideal for tensor operations. Input tensors must be of dimension 2 and are stored and accessed as flat arrays. Both the dimensions of these input tensors are expected to be of the same size. Input to the tensor compute unit are the two tensors (`input_tensor1`, `input_tensor2`), scalar value (`scalar`), and instruction type (`op_type`). The module is driven by a clock(`clk`), has an asynchronous active high reset mechanism(`reset`) to reset all outputs to zero, and provides active high control signals (1 clock cycle in duration) to indicate when sorting should start (`enable`) and when it is completed (`done`). Any change in the inputs (`input_tensor1`and `input_tensor2`) in the middle of the operation must not be considered and the earlier value of the inputs must be retained. \n\n#### Parameterization:\n\n- SIZE: The total number of elements along one dimension of a square matrix, where the number of rows equals the number of columns.\n- INPUT_DATA_WIDTH: Bit-width of input tensor elements.\n- OUTPUT_DATA_WIDTH: Derived parameter for output data width, to accommodate output without overflow\n\n#### op_type [1:0]: Specifies the operation type:\n\n- 00: Matrix multiplication.\n- 01: Element-wise addition.\n- 10: Element-wise multiplication.\n- 11: Scalar addition on both input tensors\n\nThe output (`output_tensor`) is an unsigned tensor computed as a flat array. The total clock cycle for a single operation to be computed successfully is SIZE + 4. The 4 additional clock cycles in the expected latency (SIZE + 4) are split as follows: After the `start` is set to 1, it takes 1 clock cycle to move to the `IN_OPERATION` state. In the `IN_OPERATION` state, 1 additional clock cycle is required to store the inputs in a proper format in the systolic array. The remaining 2 additional clock cycles contribute to the different operations requiring different ways of collecting the result from the PE array and thus require intermediate storage of those results. \n\nThe design consists of 3 modules:\n1. Top module: tensor_compute_unit: Instantiates the pe_array based on the input and output \n2. systolic_array: This is the main module that instantiates the PEs to create an array-like structure. It implements an FSM to schedule and access the input, assigning it to the PE array, and accordingly collecting and assigning the output based on the op_type\n3. processing_element: This is the basic unit responsible for performing scalar computation of the input tensor value based on the op_type. \n\n### Instructions to complete the given code:\nComplete the logic for the processing element instantiation, processing_element module, and the insertion of inputs to the PE array as well as the logic to store intermediate and final results during the IN_OPERATION state. Define all the required signals necessary to complete the logic for the above-mentioned implementation. \n\n- **Complete the processing element instantiation**\n  The systolic array is structured as a grid of size (SIZE x SIZE) where each element in that array is a PE. Each PE receives two inputs from two different tensors: one tensor is fed across the columns, and the other across the rows. All PEs in the same row of the systolic array share the same row input, while all PEs in the same column share the same column input.\n\n- **Complete the  processing_element module**\n  Each processing element takes two input values from two tensors. Depending on the op_type, the PE either adds or multiplies the inputs. The PE performs a MAC operation for matrix multiplication, starting with an accumulator value of 0, which updates with the previous value in subsequent clock cycles. \n\n- **Complete the IN_OPERATION FSM state**\n  In the IN_OPERATION FSM state, the two input tensors are inserted into the systolic array in a specific manner based on the type of operation. The implementation must divide the tensors to form row and column arrays to be then inserted as the row and column of the systolic array consisting of PE arranged in a grid of size (SIZE x SIZE). Additionally, in the same state, the output from the PE array must be assigned to the intermediate result based on the `op_type`. For matrix multiplication, the output is collected from all PEs. Only the output from the diagonal PEs is stored in the intermediate result for elementwise and scalar operations. The result from the PE elements is stored in the intermediate result in row-major format. Row-major format stores a multi-dimensional array in memory with all elements of each row placed consecutively whereas column-major stores all elements of each column placed consecutively. If the results of all elements of the input tensors are computed, then collect the intermediate results in the final output (`output_tensor`) and set the done signal to mark that the computation for given input tensors has been completed. \n\n### Explanation for each tensor operation\n\n1.  The matrix multiplication operation assumes that `input_tensor1` is accessed in a row-major whereas `input_tensor2` is accessed in a column-major format. Each PE is mapped to the computation of an output element in matrix multiplication. \nFor example, for 2*2 matrix, \n\n- **PE1 Computation**\n\n   - _1st Clock Cycle:_ \n     ```math\n          \\text{PE1} = a_{00} \\times b_{00}\n      ```\n   - _2nd Clock Cycle:_ \n     ```math\n       \\text{PE1} = a_{00} \\times b_{00} + a_{01} \\times b_{10}\n      ```\n   - _Final Output_: \n     ```math\n       \\text{output}[0] = a_{00} \\times b_{00} + a_{01} \\times b_{10} + a_{02} \\times b_{20}\n      ```\n\n- **PE2 Computation**\n   - _1st Clock Cycle:_ \n    ```math\n       \\text{PE2} = a_{00} \\times b_{01}\n    ```\n   -  _2nd Clock Cycle:_  \n    ```math\n        \\text{PE2} = a_{00} \\times b_{01} + a_{01} \\times b_{11}\n     ```\n   - _Final Output_: \n     ```math\n         \\text{output}[1] = a_{00} \\times b_{01} + a_{01} \\times b_{11} + a_{02} \\times b_{21}\n      ```\n\n2. For elementwise addition and multiplication it is assumed that the `input_tensor1`, `input_tensor2` \n are accessed as row major. The input in each PE for every clock cycle remains the same. However, the output is collected only from the diagonal PE elements. \nFor example for a 2*2 matrix: \n\n- **All PE Computation**\n\n  - _1st Clock Cycle:_ \n    ```math\n      \\text{PE1} = a_{00} \\times b_{00} \n    ```\n     ```math\n       \\text{PE2} = a_{00} \\times b_{10} \n     ```\n     ```math\n       \\text{PE3} = a_{10} \\times b_{00} \n      ```\n      ```math\n      \\text{PE4} = a_{10} \\times b_{10}\n       ```\n      ```math\n        \\text{output}[0] = a_{00} \\times b_{00}   (PE1)\n      ```\n      ```math\n        \\text{output}[1] = a_{10} \\times b_{10}   (PE4)\n       ```\n   - _2nd Clock Cycle:_ \n       ```math\n         \\text{PE1} = a_{01} \\times b_{01} \n       ```\n       ```math\n           \\text{PE2} = a_{01} \\times b_{11} \n       ```\n       ```math\n         \\text{PE3} = a_{11} \\times b_{01} \n       ```\n       ```math\n       \\text{PE4} = a_{11} \\times b_{11}\n       ```\n       ```math\n          \\text{output}[2] = a_{01} \\times b_{01}   (PE1)\n       ```\n        ```math\n        \\text{output}[3] = a_{11} \\times b_{11}   (PE4)\n        ```\n\n## Requirements\n\n### 1. Testbench Components\n- **Parameters**:\n  - `SIZE`: Defines the dimension of the matrix (e.g., 3x3).\n  - `INPUT_DATA_WIDTH`: Bit-width of each element in the input tensors.\n  - `OUTPUT_DATA_WIDTH`: Bit-width of each element in the output tensor, calculated based on input width and matrix size.\n  - `CLOCK_PERIOD`: Clock period corresponding to a 100 MHz clock frequency.\n\n### 2. Signals\n- `clk`: Clock signal.\n- `reset`: Synchronous reset signal.\n- `enable`: Control signal to start operations within the DUT.\n- `input_tensor1`, `input_tensor2`: Input tensors for operations.\n- `scalar`: Scalar value for operations requiring a scalar (not used in initial tests).\n- `op_type`: Operation type selector (e.g., matrix multiplication).\n- `output_tensor`: Resultant tensor from operations.\n- `done`: Signal indicating completion of the operation.\n\n### 3. Device Under Test (DUT)\n- **Tensor Compute Unit Instantiation**:\n  - Configure the module with parameters like tensor size and data widths.\n  - Connect all relevant inputs and outputs between the testbench and the DUT.\n\n### 4. Testbench Functionality\n- **Clock Generation**:\n  - Generate a continuous clock with a defined period.\n- **Expected Output Calculation**:\n  - Implement tasks to compute expected results based on matrix operations.\n  \n### 5. Test Procedures\n- **Matrix Multiplication Test**:\n  - Simulate matrix multiplication with random input tensors.\n  - Validate the output tensor against expected results calculated by a reference model.\n\n### 6. Output Verification\n- **Verify Matrix Multiplication**:\n  - Sequentially compare each element of the computed output tensor against the expected results.\n  - Log mismatches and assert errors if the output does not match the expected values.\n\n### 7. Simulation Control\n- Sequentially execute multiple test cases, managing simulation events such as reset, enable signal assertion, and waiting for the `done` signal.\n- Utilize loops and conditional checks to manage dynamic tensor data generation and result validation.\n\n## Expected Output\nThe testbench should:\n1. Accurately simulate tensor operations specified by `op_type`.\n2. Validate each computed result against a pre-calculated expected tensor.\n3. Log detailed results for each test case, highlighting any discrepancies.\n4. Conclude the simulation with an overall assessment indicating the success or failure of all tests.\n\n## Deliverables\nProvide a **complete SystemVerilog testbench** that effectively tests and verifies the `tensor_compute_unit` module's functionality, ensuring its reliability in tensor computations, particularly matrix multiplication, according to the defined operational parameters.", "context": {"rtl/tensor_compute_unit.sv": "module tensor_compute_unit #(\n    parameter SIZE = 3,\n    parameter INPUT_DATA_WIDTH  = 8,             // Bit-width of input data\n    parameter OUTPUT_DATA_WIDTH = (INPUT_DATA_WIDTH * 2) + $clog2(SIZE)    // Bit-width of output data\n)(\n    input clk,\n    input reset,\n    input enable, // Enable signal for different operation\n    input  logic [SIZE*SIZE*INPUT_DATA_WIDTH-1:0] input_tensor1, // Input tensor 1 (flat buffer)\n    input  logic [SIZE*SIZE*INPUT_DATA_WIDTH-1:0] input_tensor2, // Input tensor 2 (flat buffer)\n    output logic [SIZE*SIZE*OUTPUT_DATA_WIDTH-1:0] output_tensor, // Computed output tensor\n    input  logic [INPUT_DATA_WIDTH-1:0]  scalar,      // Scalar value\n    input  logic [1:0]   op_type,     // Operation type: 00=Matrix Mul, 01=Elementwise Add, 10=Elementwise Multiplication, 11=Scalar addition\n    output logic done\n);\n\n    // PE Array instantiation\n    systolic_array #(.SIZE(SIZE), .INPUT_DATA_WIDTH(INPUT_DATA_WIDTH), .OUTPUT_DATA_WIDTH(OUTPUT_DATA_WIDTH))\n        pe_array_inst (\n            .clk(clk),\n            .reset(reset),\n            .input_tensor1(input_tensor1),\n            .input_tensor2(input_tensor2),\n            .output_tensor(output_tensor),\n            .op_type(op_type),\n            .scalar(scalar),\n            .enable(enable),\n            .done(done)\n    );\n\nendmodule\n\nmodule processing_element #(\n    parameter SIZE = 3,\n    parameter INPUT_DATA_WIDTH  = 8,             // Bit-width of input data\n    parameter OUTPUT_DATA_WIDTH = (INPUT_DATA_WIDTH * 2) + $clog2(SIZE)    // Bit-width of output data\n) (\n    input clk,\n    input reset,\n    input  logic [INPUT_DATA_WIDTH-1:0]  a_input,     // Row input tensor\n    input  logic [INPUT_DATA_WIDTH-1:0]  b_input,     // Column input tensor\n    input  logic [INPUT_DATA_WIDTH-1:0]  scalar,      // Scalar value\n    input  logic [1:0]   op_type,     // Operation type: 00=Matrix Mul, 01=Elementwise Add, 10=Elementwise Multiplication, 11=Scalar addition\n    input                enable,      // Enable signal for MAC operation\n    output logic [OUTPUT_DATA_WIDTH-1:0]  result       // Result output\n);\n\n    reg [OUTPUT_DATA_WIDTH-1:0] acc;                  // Accumulator for MAC operation\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            acc    <= 0;\n        end\n        else begin\n            if (enable) begin\n                case (op_type)\n                    2'b00: acc <= acc + (a_input * b_input); // MAC for matrix multiplication\n                    2'b01: acc <= a_input + b_input;     // Elementwise addition\n                    2'b10: acc <= a_input * b_input;     // Elementwise multiplication\n                    2'b11: acc <= a_input + scalar;      // Scalar-tensor addition\n                endcase\n            end else begin\n                acc <= 0;\n            end\n        end\n    end\n\n    assign result = acc; \n\nendmodule\n\n\n\nmodule systolic_array #(\n    parameter SIZE = 3,\n    parameter INPUT_DATA_WIDTH  = 8,             // Bit-width of input data\n    parameter OUTPUT_DATA_WIDTH = (INPUT_DATA_WIDTH * 2) + $clog2(SIZE)    // Bit-width of output data\n)(\n    input clk,\n    input reset,\n    input enable,\n    input  logic  [SIZE*SIZE*INPUT_DATA_WIDTH-1:0] input_tensor1, \n    input  logic  [SIZE*SIZE*INPUT_DATA_WIDTH-1:0] input_tensor2, \n    input  logic  [INPUT_DATA_WIDTH-1:0] scalar,\n    input  logic  [1:0]              op_type,\n    output logic  [SIZE*SIZE*OUTPUT_DATA_WIDTH-1:0] output_tensor,\n    output logic done\n);\n\n    // FSM states\n    typedef enum logic {\n        IDLE = 1'b0,\n        IN_OPERATION = 1'b1\n    } state_t;\n\n    state_t current_state;\n\n    // Registers for operation management\n    logic [SIZE*SIZE*INPUT_DATA_WIDTH-1:0] tensor1;       // copy of input1\n    logic [SIZE*SIZE*INPUT_DATA_WIDTH-1:0] tensor2;       // copy of input2\n    logic [SIZE*INPUT_DATA_WIDTH-1:0] row_input;\n    logic [SIZE*INPUT_DATA_WIDTH-1:0]  col_input;\n    logic [SIZE*SIZE*OUTPUT_DATA_WIDTH-1:0] pe_result;\n    logic [1:0] op;   \n    logic [SIZE*SIZE*OUTPUT_DATA_WIDTH-1:0] intermediate_result; // only used for elementwise operations\n\n\n    logic computation_done;\n    int   count       = 0;\n    int count_delay = 0;\n    logic en_pe;\n    int i,j;  \n\n    // FSM: Next State Logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state    <= IDLE;\n            count            <= 0;\n            computation_done <= 0;\n            done <= 0;\n            for (j = 0; j < SIZE*SIZE; j = j + 1) begin\n                output_tensor[j*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= 0; \n                intermediate_result[j*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= 0;\n            end  \n        end else begin\n            case (current_state)\n                IDLE: begin        // if enable, then start the computataion \n                    done <= 0;     // Reset the done back to 0 (pulse of one clock cycle)\n                    count <= 0;\n                    count_delay <= 0;\n                    if (enable) begin\n                        for (i = 0; i < SIZE*SIZE; i = i + 1) begin\n                            tensor1[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= input_tensor1[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH];\n                            tensor2[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= input_tensor2[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH];\n                            output_tensor[j*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= 0; \n                            intermediate_result[j*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= 0;\n                        end\n                        op <= op_type;\n                        current_state <= IN_OPERATION;\n\n                    end else\n                        current_state <= IDLE;\n                end\n            \n                // Update the intermediate result for elementwise operation if all elements have not processed\n                // Store the final result when computation_done is set\n                IN_OPERATION: begin  \n                    if (computation_done) begin\n                        for (i = 0; i < SIZE; i = i + 1) begin\n                            for (j = 0; j < SIZE; j = j + 1) begin\n                                output_tensor[(i*SIZE + j)*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= intermediate_result[(i*SIZE + j)*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH];\n                            end\n                        end\n                        computation_done <= 0; // Set the computation_done to  0\n                        current_state <= IDLE;    // Return to idle after collecting results\n                        done <= 1;\n                                     \n                    end else begin \n                        // Collect the result in a intermediate signal in a specific format based on operation type\n                        for (i = 0; i < SIZE; i = i + 1) begin\n                            for (j = 0; j < SIZE; j = j + 1) begin\n                                if (op == 2'b00) begin   // Matrix Multiplication\n                                   intermediate_result[(i*SIZE + j)*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= pe_result[(i*SIZE + j)*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH];\n                                end\n                                else if (op == 2'b01 || op == 2'b10 || op == 2'b11) begin //Elementwise operations              \n                                    if (i==j) begin\n                                        intermediate_result[(i*SIZE + (count_delay-1))*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= pe_result[(i*SIZE + j)*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH];                               \n                                    end\n                                end\n                                else begin\n                                        intermediate_result[(i*SIZE + j)*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= 0;\n                                end\n                            end\n                        end\n                        current_state <= IN_OPERATION;\n                    end\n                end\n\n            endcase\n        end\n    end  \n\n    // Provide input to the PE Array as  separate Row and Col input and signal if computation is completed\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            for (i = 0; i < SIZE; i = i + 1) begin\n                row_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= 0; \n            end\n            for (j = 0; j < SIZE; j = j + 1) begin\n                col_input[j*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= 0; \n            end   \n        end\n        // During IN_OPERATION state, Insert each element from the input tensor into each Processing element\n        else begin\n            if ((current_state == IN_OPERATION) & (count_delay < SIZE) & (!(computation_done))) begin\n                case (op)\n                    2'b00: begin // Matrix Multiplication\n                        // Matrix Multiplication\n                        if (count < SIZE) begin\n                            for (i = 0; i < SIZE; i = i + 1) begin\n                                row_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= tensor1[(i*SIZE+count)*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH];  \n                                col_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= tensor2[(i+SIZE*count)*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH]; \n                            end\n                            en_pe <= 1;\n                            count <= count + 1;\n                        end else begin\n                            for (i = 0; i < SIZE; i = i + 1) begin\n                                row_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= 0;\n                                col_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= 0;\n                            end\n                            count <= 0;\n                        end \n                    end\n\n                    2'b01, 2'b10, 2'b11: begin // Elementwise Add/ROWultiply\n                        if (count < SIZE) begin\n                            for (i = 0; i < SIZE; i = i + 1) begin\n                                row_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= tensor1[(i*SIZE + count)*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH]; \n                                col_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= tensor2[(i*SIZE + count)*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH]; \n                            end\n                            en_pe <= 1;\n                            count <= count + 1;\n                           \n                        end else begin\n                            for (i = 0; i < SIZE; i = i + 1) begin\n                                row_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= 0;\n                                col_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= 0;\n                            end\n                            count <= 0;\n                        end \n                    end\n                endcase\n            end else begin\n                if (count_delay == SIZE) begin\n                    computation_done <= 1;\n                    en_pe <= 0;\n                end\n            end\n\n            count_delay <= count;  \n\n        end \n    end\n\n    // Instantiate PEs in a grid of SIZE x SIZE \n    genvar gi, gj;\n    \n    generate\n        for (gi = 0; gi < SIZE; gi = gi + 1) begin : PE_ROW\n            for (gj = 0; gj < SIZE; gj = gj + 1) begin : PE_COL\n                \n                processing_element #(.SIZE(SIZE), .INPUT_DATA_WIDTH(INPUT_DATA_WIDTH), .OUTPUT_DATA_WIDTH(OUTPUT_DATA_WIDTH))\n                pe_inst (\n                    .clk(clk),\n                    .reset(reset),\n                    .a_input(row_input[gi*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH]),\n                    .b_input(col_input[gj*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH]),\n                    .op_type(op),\n                    .enable(en_pe),\n                    .scalar(scalar),\n                    .result(pe_result[(gi*SIZE + gj)*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH])\n                );\n            end\n        end\n    endgenerate\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_tensor_compute_unit.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "VERILOG_SOURCES = ./rtl/tensor_compute_unit.sv \nHASH            = 4-testbench-with-checker-for-tensor-compute-module\nNUM_BUGS        = 4", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun -timescale 1ns/1ps /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n", "src/tensor_compute_unit.sv": "module tensor_compute_unit #(\n    parameter SIZE = 3,\n    parameter INPUT_DATA_WIDTH  = 8,             // Bit-width of input data\n    parameter OUTPUT_DATA_WIDTH = (INPUT_DATA_WIDTH * 2) + $clog2(SIZE)    // Bit-width of output data\n)(\n    input clk,\n    input reset,\n    input enable, // Enable signal for different operation\n    input  logic [SIZE*SIZE*INPUT_DATA_WIDTH-1:0] input_tensor1, // Input tensor 1 (flat buffer)\n    input  logic [SIZE*SIZE*INPUT_DATA_WIDTH-1:0] input_tensor2, // Input tensor 2 (flat buffer)\n    output logic [SIZE*SIZE*OUTPUT_DATA_WIDTH-1:0] output_tensor, // Computed output tensor\n    input  logic [INPUT_DATA_WIDTH-1:0]  scalar,      // Scalar value\n    input  logic [1:0]   op_type,     // Operation type: 00=Matrix Mul, 01=Elementwise Add, 10=Elementwise Multiplication, 11=Scalar addition\n    output logic done\n);\n\n    // PE Array instantiation\n    systolic_array #(.SIZE(SIZE), .INPUT_DATA_WIDTH(INPUT_DATA_WIDTH), .OUTPUT_DATA_WIDTH(OUTPUT_DATA_WIDTH))\n        pe_array_inst (\n            .clk(clk),\n            .reset(reset),\n            .input_tensor1(input_tensor1),\n            .input_tensor2(input_tensor2),\n            .output_tensor(output_tensor),\n            .op_type(op_type),\n            .scalar(scalar),\n            .enable(enable),\n            .done(done)\n    );\n\nendmodule\n\nmodule processing_element #(\n    parameter SIZE = 3,\n    parameter INPUT_DATA_WIDTH  = 8,             // Bit-width of input data\n    parameter OUTPUT_DATA_WIDTH = (INPUT_DATA_WIDTH * 2) + $clog2(SIZE)    // Bit-width of output data\n) (\n    input clk,\n    input reset,\n    input  logic [INPUT_DATA_WIDTH-1:0]  a_input,     // Row input tensor\n    input  logic [INPUT_DATA_WIDTH-1:0]  b_input,     // Column input tensor\n    input  logic [INPUT_DATA_WIDTH-1:0]  scalar,      // Scalar value\n    input  logic [1:0]   op_type,     // Operation type: 00=Matrix Mul, 01=Elementwise Add, 10=Elementwise Multiplication, 11=Scalar addition\n    input                enable,      // Enable signal for MAC operation\n    output logic [OUTPUT_DATA_WIDTH-1:0]  result       // Result output\n);\n\n    reg [OUTPUT_DATA_WIDTH-1:0] acc;                  // Accumulator for MAC operation\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            acc    <= 0;\n        end\n        else begin\n            if (enable) begin\n                case (op_type)\n                    `ifndef BUG_0\n\n                    2'b00: acc <= acc + (a_input * b_input); // MAC for matrix multiplication\n                    `else \n                    2'b00: acc <= acc - (a_input * b_input); // MAC for matrix multiplication\n\n                    `endif\n\n                    `ifndef BUG_1\n                        2'b01: acc <= a_input + b_input;     // Elementwise addition\n                    `else \n                        2'b01: acc <= a_input - b_input;     // Elementwise addition\n                    `endif\n                    `ifndef BUG_2\n\n                    2'b10: acc <= a_input * b_input;     // Elementwise multiplication\n                    `else \n                    2'b10: acc <= a_input + b_input;     // Elementwise multiplication\n\n                    `endif\n\n                    `ifndef BUG_3\n\n                    2'b11: acc <= a_input + scalar;      // Scalar-tensor addition\n                    `else \n                    2'b11: acc <= a_input - scalar;      // Scalar-tensor addition\n\n                    `endif\n\n                endcase\n            end else begin\n                acc <= 0;\n            end\n        end\n    end\n\n    assign result = acc; \n\nendmodule\n\n\n\nmodule systolic_array #(\n    parameter SIZE = 3,\n    parameter INPUT_DATA_WIDTH  = 8,             // Bit-width of input data\n    parameter OUTPUT_DATA_WIDTH = (INPUT_DATA_WIDTH * 2) + $clog2(SIZE)    // Bit-width of output data\n)(\n    input clk,\n    input reset,\n    input enable,\n    input  logic  [SIZE*SIZE*INPUT_DATA_WIDTH-1:0] input_tensor1, \n    input  logic  [SIZE*SIZE*INPUT_DATA_WIDTH-1:0] input_tensor2, \n    input  logic  [INPUT_DATA_WIDTH-1:0] scalar,\n    input  logic  [1:0]              op_type,\n    output logic  [SIZE*SIZE*OUTPUT_DATA_WIDTH-1:0] output_tensor,\n    output logic done\n);\n\n    // FSM states\n    typedef enum logic {\n        IDLE = 1'b0,\n        IN_OPERATION = 1'b1\n    } state_t;\n\n    state_t current_state;\n\n    // Registers for operation management\n    logic [SIZE*SIZE*INPUT_DATA_WIDTH-1:0] tensor1;       // copy of input1\n    logic [SIZE*SIZE*INPUT_DATA_WIDTH-1:0] tensor2;       // copy of input2\n    logic [SIZE*INPUT_DATA_WIDTH-1:0] row_input;\n    logic [SIZE*INPUT_DATA_WIDTH-1:0]  col_input;\n    logic [SIZE*SIZE*OUTPUT_DATA_WIDTH-1:0] pe_result;\n    logic [1:0] op;   \n    logic [SIZE*SIZE*OUTPUT_DATA_WIDTH-1:0] intermediate_result; // only used for elementwise operations\n\n\n    logic computation_done;\n    int   count       = 0;\n    int count_delay = 0;\n    logic en_pe;\n    int i,j;  \n\n    // FSM: Next State Logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state    <= IDLE;\n            count            <= 0;\n            computation_done <= 0;\n            done <= 0;\n            for (j = 0; j < SIZE*SIZE; j = j + 1) begin\n                output_tensor[j*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= 0; \n                intermediate_result[j*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= 0;\n            end  \n        end else begin\n            case (current_state)\n                IDLE: begin        // if enable, then start the computataion \n                    done <= 0;     // Reset the done back to 0 (pulse of one clock cycle)\n                    count <= 0;\n                    count_delay <= 0;\n                    if (enable) begin\n                        for (i = 0; i < SIZE*SIZE; i = i + 1) begin\n                            tensor1[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= input_tensor1[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH];\n                            tensor2[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= input_tensor2[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH];\n                            output_tensor[j*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= 0; \n                            intermediate_result[j*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= 0;\n                        end\n                        op <= op_type;\n                        current_state <= IN_OPERATION;\n\n                    end else\n                        current_state <= IDLE;\n                end\n            \n                // Update the intermediate result for elementwise operation if all elements have not processed\n                // Store the final result when computation_done is set\n                IN_OPERATION: begin  \n                    if (computation_done) begin\n                        for (i = 0; i < SIZE; i = i + 1) begin\n                            for (j = 0; j < SIZE; j = j + 1) begin\n                                output_tensor[(i*SIZE + j)*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= intermediate_result[(i*SIZE + j)*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH];\n                            end\n                        end\n                        computation_done <= 0; // Set the computation_done to  0\n                        current_state <= IDLE;    // Return to idle after collecting results\n                        done <= 1;\n                                     \n                    end else begin \n                        // Collect the result in a intermediate signal in a specific format based on operation type\n                        for (i = 0; i < SIZE; i = i + 1) begin\n                            for (j = 0; j < SIZE; j = j + 1) begin\n                                if (op == 2'b00) begin   // Matrix Multiplication\n                                   intermediate_result[(i*SIZE + j)*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= pe_result[(i*SIZE + j)*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH];\n                                end\n                                else if (op == 2'b01 || op == 2'b10 || op == 2'b11) begin //Elementwise operations              \n                                    if (i==j) begin\n                                        intermediate_result[(i*SIZE + (count_delay-1))*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= pe_result[(i*SIZE + j)*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH];                               \n                                    end\n                                end\n                                else begin\n                                        intermediate_result[(i*SIZE + j)*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH] <= 0;\n                                end\n                            end\n                        end\n                        current_state <= IN_OPERATION;\n                    end\n                end\n\n            endcase\n        end\n    end  \n\n    // Provide input to the PE Array as  separate Row and Col input and signal if computation is completed\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            for (i = 0; i < SIZE; i = i + 1) begin\n                row_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= 0; \n            end\n            for (j = 0; j < SIZE; j = j + 1) begin\n                col_input[j*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= 0; \n            end   \n        end\n        // During IN_OPERATION state, Insert each element from the input tensor into each Processing element\n        else begin\n            if ((current_state == IN_OPERATION) & (count_delay < SIZE) & (!(computation_done))) begin\n                case (op)\n                    2'b00: begin // Matrix Multiplication\n                        // Matrix Multiplication\n                        if (count < SIZE) begin\n                            for (i = 0; i < SIZE; i = i + 1) begin\n                                row_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= tensor1[(i*SIZE+count)*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH];  \n                                col_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= tensor2[(i+SIZE*count)*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH]; \n                            end\n                            en_pe <= 1;\n                            count <= count + 1;\n                        end else begin\n                            for (i = 0; i < SIZE; i = i + 1) begin\n                                row_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= 0;\n                                col_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= 0;\n                            end\n                            count <= 0;\n                        end \n                    end\n\n                    2'b01, 2'b10, 2'b11: begin // Elementwise Add/ROWultiply\n                        if (count < SIZE) begin\n                            for (i = 0; i < SIZE; i = i + 1) begin\n                                row_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= tensor1[(i*SIZE + count)*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH]; \n                                col_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= tensor2[(i*SIZE + count)*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH]; \n                            end\n                            en_pe <= 1;\n                            count <= count + 1;\n                           \n                        end else begin\n                            for (i = 0; i < SIZE; i = i + 1) begin\n                                row_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= 0;\n                                col_input[i*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH] <= 0;\n                            end\n                            count <= 0;\n                        end \n                    end\n                endcase\n            end else begin\n                if (count_delay == SIZE) begin\n                    computation_done <= 1;\n                    en_pe <= 0;\n                end\n            end\n\n            count_delay <= count;  \n\n        end \n    end\n\n    // Instantiate PEs in a grid of SIZE x SIZE \n    genvar gi, gj;\n    \n    generate\n        for (gi = 0; gi < SIZE; gi = gi + 1) begin : PE_ROW\n            for (gj = 0; gj < SIZE; gj = gj + 1) begin : PE_COL\n                \n                processing_element #(.SIZE(SIZE), .INPUT_DATA_WIDTH(INPUT_DATA_WIDTH), .OUTPUT_DATA_WIDTH(OUTPUT_DATA_WIDTH))\n                pe_inst (\n                    .clk(clk),\n                    .reset(reset),\n                    .a_input(row_input[gi*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH]),\n                    .b_input(col_input[gj*INPUT_DATA_WIDTH +: INPUT_DATA_WIDTH]),\n                    .op_type(op),\n                    .enable(en_pe),\n                    .scalar(scalar),\n                    .result(pe_result[(gi*SIZE + gj)*OUTPUT_DATA_WIDTH +: OUTPUT_DATA_WIDTH])\n                );\n            end\n        end\n    endgenerate\n\nendmodule\n"}}}
{"id": "cvdp_copilot_thermostat_0003", "categories": ["cid012", "medium"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `thermostat`. It automatically switches between heating and cooling based on temperature feedback. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameter Inputs - Outputs and Functional behaviour**\n\n### Inputs\n\n1. **6-bit**: `i_temp_feedback[5:0]`  \n   Each bit represents a distinct temperature condition :\n   - `i_temp_feedback[5]` : `i_full_cold`  (1 = too cold)  \n   - `i_temp_feedback[4]` : `i_medium_cold` (1 = medium cold)  \n   - `i_temp_feedback[3]` : `i_low_cold`   (1 = low cold)  \n   - `i_temp_feedback[2]` : `i_low_hot`    (1 = low hot)  \n   - `i_temp_feedback[1]` : `i_medium_hot` (1 = medium hot)  \n   - `i_temp_feedback[0]` : `i_full_hot`   (1 = too hot)  \n\n2. **1-bit**: `i_fan_on`  \n   - User control to turn the fan on manually (`1` = fan on, `0` = fan off).\n\n3. **1-bit**: `i_enable`  \n   - Enables or disables the thermostat.  \n   - When `i_enable = 0`, all thermostat outputs must be forced to `0` regardless of temperature feedback.\n\n4. **1-bit**: `i_fault`  \n   - Signals a fault/error condition.  \n   - When `i_fault = 1`, all outputs must be forced to `0` (overridden), ignoring normal FSM logic.\n\n5. **1-bit**: `i_clr`  \n   - Clears the error state set by `i_fault`. Upon assertion, the thermostat should return to `AMBIENT`.\n6. **Clock/Reset**  \n   - `i_clk`: Clock for sequential logic.\n   - `i_rst`: Asynchronous active-low reset.\n---\n\n### Outputs\n\n1. **Heating Control (1-bit each)**  \n   - `o_heater_full`  \n   - `o_heater_medium`  \n   - `o_heater_low`  \n\n2. **Cooling Control (1-bit each)**  \n   - `o_aircon_full`  \n   - `o_aircon_medium`  \n   - `o_aircon_low`  \n\n3. **Fan Control (1-bit)**  \n   - `o_fan`  \n\n4. **FSM Output State (3-bit)**  \n   - `o_state[2:0]`: Indicates the current FSM state among the seven valid states:\n     - `3'b000` = `HEAT_LOW`\n     - `3'b001` = `HEAT_MED`\n     - `3'b010` = `HEAT_FULL`\n     - `3'b011` = `AMBIENT`\n     - `3'b100` = `COOL_LOW`\n     - `3'b101` = `COOL_MED`\n     - `3'b110` = `COOL_FULL`\n\n---\n\n### Reset/Idle Behavior\n\n- **Asynchronous Reset (`i_rst` active low)**  \n  - When `i_rst` is asserted (`0`), force the FSM to `AMBIENT` and all outputs to `0`.\n- **Idle/Default State**  \n  - `AMBIENT` state when no heating or cooling is required.  \n  - When `i_clr` is asserted (to clear a fault), the FSM should go back to `AMBIENT` on the next rising clock edge if `i_rst` is not active.\n\n---\n### Fault Handling\n\n- If `i_fault = 1`, **all outputs** (`o_heater_full`, `o_heater_medium`, `o_heater_low`, `o_aircon_full` , `o_aircon_medium`, `o_aircon_low`, `o_fan`) must be forced to `0`, overriding any state-based or feedback logic.\n- Once a fault is signaled, the thermostat remains forced off until `i_clr` is asserted to clear the fault.  \n  - After clearing the fault (`i_clr = 1`), the controller returns to `AMBIENT` state on the next rising clock edge.\n\n---\n\n### Enable Control\n\n- If `i_enable = 0`, the thermostat is turned off.  \n  - Force **all outputs** to `0` (similar to a disable override).  \n  - Internally, the FSM move to `AMBIENT`.\n\n---\n\n## FSM State Transition Logic\n\nOn each rising edge of `i_clk` (while `i_rst = 1` and no fault override), the FSM evaluates the temperature feedback bits to determine the next state:\n\n1. **Cold Conditions** (highest priority first)\n   - If `i_full_cold = 1`: transition to `HEAT_FULL`.  \n   - Else if `i_medium_cold = 1`: transition to `HEAT_MED`.  \n   - Else if `i_low_cold = 1`: transition to `HEAT_LOW`.\n\n2. **Hot Conditions** (highest priority first)\n   - If `i_full_hot = 1`: transition to `COOL_FULL`.  \n   - Else if `i_medium_hot = 1`: transition to `COOL_MED`.  \n   - Else if `i_low_hot = 1`: transition to `COOL_LOW`.\n\n3. **Ambient Condition**\n   - If none of the cold/hot feedback bits are asserted, transition to `AMBIENT`.\n\n> **Note**: The bits `i_full_cold`, `i_medium_cold`, `i_low_cold` are mutually exclusive with `i_full_hot`, `i_medium_hot`, `i_low_hot`, meaning they will never be asserted at the same time.\n\n---\n\n## Output Logic\n\nThe output will be synchronous to `i_clk`, and should get asynchronously reset.\nGiven the current FSM state **(unless overridden by `i_fault` or disabled by `i_enable`)**:\n\n- **Heating States**  \n  - `HEAT_FULL`  \n    - `o_heater_full = 1`, all other heater/cooler outputs = 0  \n  - `HEAT_MED`  \n    - `o_heater_medium = 1`, all other heater/cooler outputs = 0  \n  - `HEAT_LOW`  \n    - `o_heater_low = 1`, all other heater/cooler outputs = 0  \n\n- **Cooling States**  \n  - `COOL_FULL`  \n    - `o_aircon_full = 1`, all other heater/cooler outputs = 0  \n  - `COOL_MED`  \n    - `o_aircon_medium = 1`, all other heater/cooler outputs = 0  \n  - `COOL_LOW`  \n    - `o_aircon_low = 1`, all other heater/cooler outputs = 0  \n\n- **AMBIENT**  \n  - All heater/aircon outputs = 0  \n\n- **Fan Control** (`o_fan`)  \n  - `o_fan = 1` if any heater or air conditioner output is active in the current state **OR** if `i_fan_on = 1`.  \n  - Otherwise, `o_fan = 0`.\n\n---\n\n## Overriding Conditions Summary\n\n1. **Reset (`i_rst = 0`)**  \n   - Highest-priority override: sets FSM to `AMBIENT`, outputs = 0 immediately (asynchronous).  \n\n2. **Fault (`i_fault = 1`)**  \n   - Next-highest priority: overrides *all outputs* to 0, regardless of state or temperature feedback.\n\n3. **Disable (`i_enable = 0`)**  \n   - Next priority: thermostat outputs forced off (0). The FSM logic may remain in its current state internally, but no heat/cool/fan outputs are driven.\n\n4. **Normal Operation**  \n   - When `i_rst=1`, `i_fault=0`, and `i_enable=1`, the FSM outputs follow the state-based transitions and normal fan logic.\n\n5. **Clearing Fault (`i_clr = 1`)**  \n   - On the next rising clock edge, if `i_fault` is deasserted, the FSM moves to `AMBIENT` and resumes normal functionality.\n   - \n## 4. Test Bench Requirements\n\n### 4.1 Stimulus Generation\n\n1. **Asynchronous Reset Scenario**  \n   - Initiate a reset condition while the system is active.\n\n2. **Idle Operation Scenario**  \n   - Set up a condition where no temperature deviation is detected, the thermostat is enabled, there is no fault, and manual fan control is inactive. \n\n3. **Extreme Cold Condition**  \n   - Simulate a situation where the temperature feedback indicates a severe cold condition. \n\n4. **Moderate Cold Condition**  \n   - Create a scenario where the environment is moderately cold. \n5. **Mild Cold Condition**  \n   - Emulate a condition with only a slight drop in temperature. \n\n6. **Extreme Hot Condition**  \n   - Simulate a severe hot condition using temperature feedback. \n\n7. **Moderate Hot Condition**  \n   - Establish a scenario where the temperature feedback indicates moderate heat. \n\n8. **Mild Hot Condition**  \n   - Create a condition where there is only a slight increase in temperature. \n9. **Conflicting Temperature Conditions**  \n   - Provide simultaneous indications of severe cold and severe heat to test the system\u2019s ability to prioritize among conflicting temperature conditions.\n\n10. **Transition from Active Control to Ambient**  \n    - First, simulate a temperature deviation that leads to active heating or cooling. Then remove the deviation so that the system naturally transitions back to an ambient (idle) state.\n\n11. **Manual Fan Activation in Ambient Environment**  \n    - In an ambient condition with no heating or cooling demand, manually activate the fan control. \n\n12. **Disable Thermostat Operation**  \n    - Under conditions that would normally trigger heating or cooling, disable the thermostat functionality. \n\n13. **Fault Condition Enforcement**  \n    - Introduce a fault during normal operation with active temperature deviation. \n\n14. **Fault Clearance and Recovery**  \n    - After inducing a fault condition, simulate the process of clearing the fault. \n\n15. **Systematic Branch Testing:**\n  - **For Each FSM State:**\n    - Drive the thermostat naturally from AMBIENT into each of its 7 states (AMBIENT, HEAT_FULL, COOL_FULL, HEAT_MED, COOL_MED, HEAT_LOW, COOL_LOW) using specific temperature feedback vectors.\n  - **Within Each State:**\n    - Apply 7 distinct temperature feedback patterns that correspond to each branch in the state's nested decision logic (full cold, full hot, medium cold, medium hot, low cold, low hot, and default).\n  - **Reset Between Tests:**\n    - Return to AMBIENT between branch tests to ensure each condition is applied from a known starting point.\n\n\n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_thermostat.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 3-tb-stimulus\nTARGET = 100", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/thermostat.v /code/verif/tb_thermostat.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/thermostat.v": "module thermostat (\n    input wire [5:0] i_temp_feedback, // Temperature feedback bits\n    input wire i_fan_on,             // Manual fan control\n    input wire i_enable,             // Enable thermostat\n    input wire i_fault,              // Fault signal\n    input wire i_clr,                // Clear fault signal\n    input wire i_clk,                // Clock input\n    input wire i_rst,                // Asynchronous reset (active-low)\n\n    output reg o_heater_full,\n    output reg o_heater_medium,\n    output reg o_heater_low,\n    output reg o_aircon_full,\n    output reg o_aircon_medium,\n    output reg o_aircon_low,\n    output reg o_fan,\n    output reg [2:0] o_state         // FSM state output\n);\n\n// State encoding\nlocalparam [2:0] HEAT_LOW  = 3'b000,\n                 HEAT_MED  = 3'b001,\n                 HEAT_FULL = 3'b010,\n                 AMBIENT   = 3'b011,\n                 COOL_LOW  = 3'b100,\n                 COOL_MED  = 3'b101,\n                 COOL_FULL = 3'b110;\n\n// Internal signals\nreg [2:0] current_state, next_state; // FSM state registers\nreg heater_full, heater_medium, heater_low;\nreg aircon_full, aircon_medium, aircon_low;\nreg fan;\nalways @(*) begin\n    o_state = current_state;\nend\n// Sequential logic for state transitions and registered outputs\nalways @(posedge i_clk or negedge i_rst) begin\n    if (!i_rst) begin\n        // Asynchronous reset\n        current_state <= AMBIENT;\n        o_heater_full <= 0;\n        o_heater_medium <= 0;\n        o_heater_low <= 0;\n        o_aircon_full <= 0;\n        o_aircon_medium <= 0;\n        o_aircon_low <= 0;\n        o_fan <= 0;\n    end else begin\n        // Normal state transition\n        current_state <= next_state;\n        // Update registered outputs\n        o_heater_full <= heater_full;\n        o_heater_medium <= heater_medium;\n        o_heater_low <= heater_low;\n        o_aircon_full <= aircon_full;\n        o_aircon_medium <= aircon_medium;\n        o_aircon_low <= aircon_low;\n        o_fan <= fan || i_fan_on;\n    end\nend\n\n// Combinational logic for next state and intermediate outputs\nalways @(*) begin\n    if (!i_enable || i_fault) begin\n        // Handle fault or disable\n        next_state = AMBIENT;\n        heater_full = 0;\n        heater_medium = 0;\n        heater_low = 0;\n        aircon_full = 0;\n        aircon_medium = 0;\n        aircon_low = 0;\n        fan = 0;\n    end else begin\n        case (current_state)\n            // Heating states\n            HEAT_LOW: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 1;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            HEAT_MED: begin\n                heater_full = 0;\n                heater_medium = 1;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            HEAT_FULL: begin\n                heater_full = 1;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            // Cooling states\n            COOL_LOW: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 1;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            COOL_MED: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 1;\n                aircon_low = 0;\n                fan = 1;\n                aircon_medium = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            COOL_FULL: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 1;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            // Ambient state\n            AMBIENT: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 0;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            default: next_state = AMBIENT; // Safety fallback\n        endcase\n    end\nend\n\nendmodule\n"}}}
{"id": "cvdp_copilot_traffic_light_controller_0007", "categories": ["cid012", "medium"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `traffic_controller_fsm`. Based on sensor inputs and timing signals, the FSM manages the traffic lights for both a main road and a side road. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameter Inputs - Outputs and Functional behaviour**\n\n---\n### Inputs and Outputs\n\n| Signal                       | Direction | Bit Width | Active Level | Description                                                                             |\n|------------------------------|-----------|-----------|--------------|-----------------------------------------------------------------------------------------|\n| **`i_clk`**                  | Input     | 1         | \u2014            | System clock signal, with FSM transitions occurring on the rising edge.                 |\n| **`i_rst_b`**                | Input     | 1         | Active-low   | Asynchronous reset signal. When asserted (`0`), FSM resets to its initial state.        |\n| **`i_vehicle_sensor_input`** | Input     | 1         | Active-high  | Detects vehicle presence on the side road. High (`1`) when a vehicle is detected.       |\n| **`i_short_timer`**          | Input     | 1         | Active-high  | Indicates the expiration of the short timer. High (`1`) when the short timer expires.   |\n| **`i_long_timer`**           | Input     | 1         | Active-high  | Indicates the expiration of the long timer. High (`1`) when the long timer expires.     |\n| **`o_short_trigger`**        | Output    | 1         | Active-high  | Initiates the short timer. Set to high (`1`) to start the short timer.                  |\n| **`o_long_trigger`**         | Output    | 1         | Active-high  | Initiates the long timer. Set to high (`1`) to start the long timer.                    |\n| **`o_main[2:0]`**            | Output    | 3         | \u2014            | Controls main road traffic lights: Red (`3'b100`), Yellow (`3'b010`), Green (`3'b001`). |\n| **`o_side[2:0]`**            | Output    | 3         | \u2014            | Controls side road traffic lights: Red (`3'b100`), Yellow (`3'b010`), Green (`3'b001`). |\n\n### FSM Output Table\n\n| State | Description                           | `o_main`          | `o_side`          | `o_short_trigger` | `o_long_trigger` |\n|-------|---------------------------------------|-------------------|-------------------|-------------------|------------------|\n| **S1** | Main road green, side road red       | `3'b001` (Green)  | `3'b100` (Red)    | 0                 | 1                |\n| **S2** | Main road yellow, side road red      | `3'b010` (Yellow) | `3'b100` (Red)    | 1                 | 0                |\n| **S3** | Main road red, side road green       | `3'b100` (Red)    | `3'b001` (Green)  | 0                 | 1                |\n| **S4** | Main road red, side road yellow      | `3'b100` (Red)    | `3'b010` (Yellow) | 1                 | 0                |\n\n### FSM Transition Logic\n- **S1 \u2192 S2**: Transition when a vehicle is detected (`i_vehicle_sensor_input = 1`) and the long timer expires (`i_long_timer = 1`).\n- **S2 \u2192 S3**: Transition upon short timer expiration (`i_short_timer = 1`).\n- **S3 \u2192 S4**: Transition when either vehicle is detected (`i_vehicle_sensor_input = 1`) or the long timer expires (`i_long_timer = 1`).\n- **S4 \u2192 S1**: Transition upon short timer expiration (`i_short_timer = 1`).\n\n### Requirements\n1. **Reset Behavior**: When the reset signal is active (`i_rst_b = 0`), the FSM should reset to **State S1** with the following initial values:\n   - **`o_main`** set to `3'b000` (main road lights off).\n   - **`o_side`** set to `3'b000` (side road lights off).\n   - **`o_long_trigger`** set to `1'b0` (long timer trigger reset).\n   - **`o_short_trigger`** set to `1'b0` (short timer trigger reset).\n2. **Clocked Transitions**: The FSM should transition between states on the rising edge of the clock (`i_clk`).\n3. **Synchronized Outputs**: Ensure the traffic light outputs (`o_main` and `o_side`) and the timer triggers (`o_long_trigger`, `o_short_trigger`) are properly synchronized with state transitions.\n\n\n## 4. Test Bench Requirements\n\n### 4.1 Stimulus Generation\n1. **Reset and Initialization Stimulus**  \n   1.1. Assert the asynchronous reset by driving the active-low reset signal to its active state for several clock cycles while keeping all other inputs inactive.  \n   1.2. Deassert the reset by returning the active-low reset signal to its inactive state and wait one clock cycle for system initialization.\n\n2. **Stimulus for the State with Main Road Green and Side Road Red (S1)**  \n   2.1. **No Transition Conditions:**  \n   \u2003\u20032.1.1. Apply stimulus with the sensor input inactive and the long timer signal inactive for several clock cycles.  \n   \u2003\u20032.1.2. Apply stimulus with the sensor input active and the long timer signal inactive for several clock cycles.  \n   \u2003\u20032.1.3. Apply stimulus with the sensor input inactive and the long timer signal active for several clock cycles.  \n   2.2. **Transition Condition:**  \n   \u2003\u20032.2.1. Apply stimulus with both the sensor input and the long timer signal active for one clock cycle.\n\n3. **Stimulus for the State with Main Road Yellow and Side Road Red (S2)**  \n   3.1. **No Transition Condition:**  \n   \u2003\u20033.1.1. Maintain the short timer signal inactive for several clock cycles.  \n   3.2. **Transition Condition:**  \n   \u2003\u20033.2.1. Provide a one-clock-cycle pulse on the short timer signal.\n\n4. **Stimulus for the State with Main Road Red and Side Road Green (S3)**  \n   4.1. **No Transition Condition:**  \n   \u2003\u20034.1.1. Apply stimulus with the sensor input active and the long timer signal inactive for several clock cycles.  \n   4.2. **Transition Conditions:**  \n   \u2003\u20034.2.1. Transition Branch A: Apply stimulus with the sensor input inactive (with the long timer signal inactive) for one clock cycle.  \n   \u2003\u20034.2.2. Transition Branch B: Alternatively, apply stimulus with the sensor input active and the long timer signal active for one clock cycle.\n\n5. **Stimulus for the State with Main Road Red and Side Road Yellow (S4)**  \n   5.1. **No Transition Condition:**  \n   \u2003\u20035.1.1. Maintain the short timer signal inactive for several clock cycles.  \n   5.2. **Transition Condition:**  \n   \u2003\u20035.2.1. Provide a one-clock-cycle pulse on the short timer signal.\n\n6. **Clock and Synchronization Stimulus**  \n   6.1. Generate a continuous clock signal.  \n   6.2. Ensure that any changes to the input signals are applied between clock edges so that state transitions occur on the rising edge of the clock.\n\n7. **Timer Pulse Width Stimulus**  \n   7.1. Apply one-clock-cycle pulses to the short timer and long timer signals to simulate timer expiration events.  \n   7.2. In separate scenarios, hold the short timer and long timer signals active for multiple clock cycles.\n\n8. **Comprehensive Sequence Stimulus**  \n   8.1. Start with the reset sequence as described in section 1.  \n   8.2. Progress through the full state cycle by sequentially applying stimulus to:  \n   \u2003\u20038.2.1. The state with main road green and side road red (S1), including both no transition and transition conditions.  \n   \u2003\u20038.2.2. The state with main road yellow and side road red (S2), including both no transition and transition conditions.  \n   \u2003\u20038.2.3. The state with main road red and side road green (S3), including both no transition and transition conditions using both branches.  \n   \u2003\u20038.2.4. The state with main road red and side road yellow (S4), including both no transition and transition conditions.", "context": {}}, "output": {"response": "", "context": {"verif/tb_traffic_controller_fsm.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 7-tb-stimulus\nTARGET = 97", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/traffic_light_controller.sv /code/verif/tb_traffic_controller_fsm.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/traffic_light_controller.sv": "module traffic_controller_fsm ( \n    input i_clk,                     // System clock input\n    input i_rst_b,                   // Active-low reset signal\n    input i_vehicle_sensor_input,     // High when a vehicle is present on the side road\n    input i_short_timer,              // High when the short timer expires\n    input i_long_timer,               // High when the long timer expires\n    output reg o_short_trigger,       // Trigger for the short timer (active high)\n    output reg o_long_trigger,        // Trigger for the long timer (active high)\n    output reg [2:0] o_main,          // Main road traffic lights (3-bit: Red, Yellow, Green)\n    output reg [2:0] o_side           // Side road traffic lights (3-bit: Red, Yellow, Green)\n);\n    \nlocalparam p_state_S1 = 2'd0 ;       \nlocalparam p_state_S2 = 2'd1 ;       \nlocalparam p_state_S3 = 2'd2 ;       \nlocalparam p_state_S4 = 2'd3 ;       \n\nreg [1:0]   r_state;                 \nreg [1:0]   r_next_state;            \n\n//-----------------------------------------------------------------------------\n// Next State Logic\n//-----------------------------------------------------------------------------\nalways @(*) begin\n    if (!i_rst_b) begin              \n        r_next_state = p_state_S1;   \n    end else begin\n        case (r_state)\n        p_state_S1: begin\n            if (i_vehicle_sensor_input & i_long_timer) begin\n                r_next_state = p_state_S2;  \n            end else begin\n                r_next_state = p_state_S1;  \n            end\n        end\n        p_state_S2: begin\n            if (i_short_timer) begin\n                r_next_state = p_state_S3;  \n            end else begin\n                r_next_state = p_state_S2;  \n            end\n        end\n        p_state_S3: begin\n            if ((!i_vehicle_sensor_input) | i_long_timer) begin\n                r_next_state = p_state_S4;  \n            end else begin\n                r_next_state = p_state_S3;  \n            end\n        end\n        p_state_S4: begin\n            if (i_short_timer) begin\n                r_next_state = p_state_S1;  \n            end else begin\n                r_next_state = p_state_S4;  \n            end\n        end\n        endcase\n    end\nend\n\nalways @(posedge i_clk or negedge i_rst_b) begin\n    if (!i_rst_b) begin                  \n        r_state <= p_state_S1;           \n    end else begin\n        r_state <= r_next_state;         \n    end\nend\n\n\nalways @(posedge i_clk or negedge i_rst_b) begin\n    if (!i_rst_b) begin                   \n        o_main <= 3'd0;                  \n        o_side <= 3'd0;                  \n        o_long_trigger <= 1'b0;          \n        o_short_trigger <= 1'b0;         \n    end else begin\n        case (r_state)\n        p_state_S1: begin\n            o_main <= 3'b001;            \n            o_side <= 3'b100;            \n            o_long_trigger <= 1'b1;      \n            o_short_trigger <= 1'b0;     \n        end\n        p_state_S2: begin\n            o_main <= 3'b010;             \n            o_side <= 3'b100;             \n            o_long_trigger <= 1'b0;       \n            o_short_trigger <= 1'b1;     \n        end\n        p_state_S3: begin\n            o_main <= 3'b100;            \n            o_side <= 3'b001;            \n            o_long_trigger <= 1'b1;      \n            o_short_trigger <= 1'b0;     \n        end\n        p_state_S4: begin\n            o_main <= 3'b100;             \n            o_side <= 3'b010;             \n            o_long_trigger <= 1'b0;       \n            o_short_trigger <= 1'b1;     \n        end\n        endcase\n    end\nend\n\nendmodule\n"}}}
{"id": "cvdp_copilot_ttc_lite_0013", "categories": ["cid014", "medium"], "input": {"prompt": "Create SystemVerilog Assertions to verify the correct behavior of the `ttc_counter_lite` module, ensuring all key registers and operations function as expected.\n\nThe properties should validate that the counter, match value, reload value, control flags, and interrupt mechanism behave correctly under all conditions. Assertions must be created to verify that after a reset, write, or increment operation, the assigned values do not interfere with the correct functioning of the module. The timer must correctly update, trigger interrupts, and respond to AXI transactions.\n\n## **Expected Behavior**\nEach assertion should validate the respective behavior of the timer registers, interrupt signals, and AXI read/write operations. In the event of a failure, the error message must include relevant details such as the counter value, match flag status, and control register settings for debugging purposes.\n\n## **RTL Specification**\nThe `ttc_counter_lite` module implements a simple timer with configurable match and reload values, supporting an interval mode and an interrupt mechanism. It uses an AXI-compatible interface for control and status updates.\n\n### **Module Name:** `ttc_counter_lite`\n\n### **Ports**\n| **Port Name**  | **Direction** | **Size**  | **Description**                     |\n|----------------|---------------|-----------|-------------------------------------|\n| `clk`          | Input         | 1 bit     | Clock signal                        |\n| `reset`        | Input         | 1 bit     | Asynchronous reset, active high     |\n| `axi_addr`     | Input         | 4 bits    | AXI address for register read/write |\n| `axi_wdata`    | Input         | 32 bits   | AXI write data                      |\n| `axi_write_en` | Input         | 1 bit     | AXI write enable                    |\n| `axi_read_en`  | Input         | 1 bit     | AXI read enable                     |\n| `axi_rdata`    | Output        | 32 bits   | AXI read data                       |\n| `interrupt`    | Output        | 1 bit     | Interrupt signal                    |\n\n### **Registers and Functionality**\n- **`count`** (16-bit): Increments every clock cycle when enabled.\n- **`match_value`** (16-bit): Defines the counter match condition.\n- **`reload_value`** (16-bit): Reload value for interval mode.\n- **`enable`** (1-bit): Enables or disables the counter.\n- **`interval_mode`** (1-bit): Enables interval-based reset.\n- **`interrupt_enable`** (1-bit): Enables interrupt generation.\n- **`match_flag`** (1-bit): Indicates whether the counter has matched `match_value`.\n- **Interrupt** is set when `match_flag` is asserted and `interrupt_enable` is high.\n\n### **Assertions to Cover**\n- **Reset Behavior:** Ensure all registers are reset to zero.\n- **Counter Functionality:** Ensure the counter increments correctly and reloads in interval mode.\n- **AXI Register Writes:** Ensure register values update correctly when written via AXI.\n- **Match and Interrupt Behavior:** Please make sure the match flag and interrupt signal as expected.\n- **AXI Read Consistency:** Ensure reads return the correct values.\n\n---\n", "context": {"rtl/ttc_counter_lite.sv": "module ttc_counter_lite (\n    input wire          clk,                // Clock signal\n    input wire          reset,              // Reset signal\n    input wire [3:0]    axi_addr,           // AXI address for read/write\n    input wire [31:0]   axi_wdata,          // AXI write data\n    input wire          axi_write_en,       // AXI write enable\n    input wire          axi_read_en,        // AXI read enable\n    output reg [31:0]   axi_rdata,          // AXI read data\n    output reg          interrupt           // Interrupt signal\n);\n\n    // Timer registers\n    reg [15:0] count;                       // Counter register\n    reg [15:0] match_value;                 // Match value for interval mode\n    reg [15:0] reload_value;                // Reload value in interval mode\n    reg        enable;                      // Timer enable flag\n    reg        interval_mode;               // Interval mode enable flag\n    reg        interrupt_enable;            // Interrupt enable flag\n\n    // Address map\n    localparam ADDR_COUNT        = 4'b0000; // Counter register (read only)\n    localparam ADDR_MATCH_VALUE  = 4'b0001; // Match value register\n    localparam ADDR_RELOAD_VALUE = 4'b0010; // Reload value register\n    localparam ADDR_CONTROL      = 4'b0011; // Control register\n    localparam ADDR_STATUS       = 4'b0100; // Status register\n\n    // Interrupt flag\n    reg match_flag;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 16'b0; \n        end else if (enable) begin\n            if (interval_mode && match_flag) begin\n                count <= reload_value; \n            end \n            else if (count == match_value) begin\n                count <= count; \n            end else begin\n                count <= count + 16'b1; \n            end\n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            match_flag <= 1'b0; \n        end else begin\n            match_flag <= (count == match_value); \n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            interrupt <= 1'b0; \n        end else if (match_flag && interrupt_enable) begin\n            interrupt <= 1'b1; \n        end else if (axi_write_en && axi_addr == ADDR_STATUS) begin\n            interrupt <= 1'b0; \n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            match_value      <= 16'b0; \n            reload_value     <= 16'b0; \n            enable           <= 1'b0; \n            interval_mode    <= 1'b0; \n            interrupt_enable <= 1'b0; \n        end else if (axi_write_en) begin\n            case (axi_addr)\n                ADDR_MATCH_VALUE:  match_value      <= axi_wdata[15:0]; \n                ADDR_RELOAD_VALUE: reload_value     <= axi_wdata[15:0]; \n                ADDR_CONTROL: begin\n                    enable           <= axi_wdata[0]; \n                    interval_mode    <= axi_wdata[1]; \n                    interrupt_enable <= axi_wdata[2]; \n                end\n                default: ; \n            endcase\n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            axi_rdata <= 32'b0; \n        end else if (axi_read_en) begin\n            case (axi_addr)\n                ADDR_COUNT:        axi_rdata <= {16'b0, count};       \n                ADDR_MATCH_VALUE:  axi_rdata <= {16'b0, match_value}; \n                ADDR_RELOAD_VALUE: axi_rdata <= {16'b0, reload_value}; \n                ADDR_CONTROL:      axi_rdata <= {29'b0, interrupt_enable, interval_mode, enable}; \n                ADDR_STATUS:       axi_rdata <= {31'b0, interrupt};   \n                default:           axi_rdata <= 32'b0;               \n            endcase\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/ttc_counter_lite.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 80\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ttc_counter_lite.sv\nTOPLEVEL        = ttc_counter_lite\nMODULE          = test_ttc_counter_lite\nPYTHONPATH      = /src\nHASH            = 9a63cbc79c9d371f3e89f355abe9824ec5315585\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 2, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_ttc_counter_lite.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_ttc_counter_lite(dut):\n    \"\"\"\n    Cocotb-based testbench for the ttc_counter_lite module.\n    \"\"\"\n    # Generate clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Initialize the DUT signals (e.g., reset all values to default 0)\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT\n    dut.reset.value = 1\n    await Timer(20, units=\"ns\")\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\n    # Helper function to write to AXI\n    async def axi_write(addr, data):\n        dut.axi_addr.value = addr\n        dut.axi_wdata.value = data\n        dut.axi_write_en.value = 1\n        await RisingEdge(dut.clk)\n        dut.axi_write_en.value = 0\n        await RisingEdge(dut.clk)\n\n    # Helper function to read from AXI\n    async def axi_read(addr):\n        dut.axi_addr.value = addr\n        dut.axi_read_en.value = 1\n        await RisingEdge(dut.clk)\n        dut.axi_read_en.value = 0\n        await RisingEdge(dut.clk)\n        read_value = int(dut.axi_rdata.value)\n        print(f\"[READ] Address: {addr}, Data: {read_value}\")\n        return read_value\n\n    # Write match value\n    await axi_write(0x1, 0x14)  # Set match value to 20\n    assert int(dut.match_value.value) == 0x14, \"[ERROR] Match value not set correctly\"\n    dut._log.info(f\"[CHECK] Match value correctly set: {int(dut.match_value.value)}\")\n\n    # Write reload value\n    await axi_write(0x2, 0xA)  # Set reload value to 10\n    assert int(dut.reload_value.value) == 0xA, \"[ERROR] Reload value not set correctly\"\n    dut._log.info(f\"[CHECK] Reload value correctly set: {int(dut.reload_value.value)}\")\n\n    # Configure control register\n    await axi_write(0x3, 0x7)  # Enable = 1, Interval mode = 1, Interrupt enable = 1\n    assert dut.enable.value == 1, \"[ERROR] Control register enable not set\"\n    assert dut.interval_mode.value == 1, \"[ERROR] Interval mode not set\"\n    assert dut.interrupt_enable.value == 1, \"[ERROR] Interrupt enable not set\"\n    dut._log.info(f\"[CHECK] Control register configured correctly: Enable={dut.enable.value}, Interval Mode={dut.interval_mode.value}, Interrupt Enable={dut.interrupt_enable.value}\")\n\n    # Observe counting\n    await Timer(200, units=\"ns\")\n    count = int(dut.count.value)\n    reload_value = int(dut.reload_value.value)\n    match_value = int(dut.match_value.value)\n    assert reload_value <= count <= match_value, f\"[ERROR] Counter value {count} is out of range [{reload_value}, {match_value}]\"\n    dut._log.info(f\"[CHECK] Counter is running within range: {count}, Reload Value: {reload_value}, Match Value: {match_value}\")\n\n    # Read counter value\n    count_val = await axi_read(0x0)  # Read counter value\n    assert count_val == int(dut.count.value), f\"[ERROR] Counter value mismatch: read {count_val}, expected {int(dut.count.value)}\"\n    dut._log.info(f\"[INFO] Counter value read: {count_val}\")\n\n    # Wait for interrupt\n    await Timer(50, units=\"ns\")\n    assert dut.interrupt.value == 1, \"[ERROR] Interrupt not asserted\"\n    dut._log.info(f\"[CHECK] Interrupt asserted at match: {dut.interrupt.value}\")\n    # Check interrupt status\n    interrupt_status = await axi_read(0x4)\n    assert interrupt_status == dut.interrupt.value, \"[ERROR] Interrupt status mismatch\"\n    dut._log.info(\"[CHECK] Interrupt status matches expected value\")\n\n    # Clear interrupt\n    await axi_write(0x4, 0x0)  # Clear interrupt\n    assert dut.interrupt.value == 0, \"[ERROR] Interrupt not cleared\"\n    dut._log.info(f\"[CHECK] Interrupt cleared successfully: {dut.interrupt.value}\")\n\n    dut._log.info(\"[INFO] Simulation completed\")\n\n"}}}
{"id": "cvdp_copilot_ttc_lite_0016", "categories": ["cid014", "medium"], "input": {"prompt": "Create SystemVerilog Assertions to verify the functional correctness of the `ttc_counter_lite` module. The properties should ensure that:\n\n- **Interval Mode Reset:**  \n   When `enable` and `interval_mode` are asserted, and `count` reaches `match_value`, the counter must reset to `reload_value` on the next clock cycle.\n\n- **Match Value Write:**  \n   When an AXI write occurs to the `ADDR_MATCH_VALUE` register, the `match_value` register should correctly update to `axi_wdata[15:0]`.\n\n- **Reload Value Write:**  \n   When an AXI write occurs to the `ADDR_RELOAD_VALUE` register, the `reload_value` register should correctly update to `axi_wdata[15:0]`.\n\n- **Control Register Write:**  \n   When an AXI write occurs to the `ADDR_CONTROL` register, the control signals (`enable`, `interval_mode`, `interrupt_enable`, `interrupt_clear`) should correctly update according to `axi_wdata[3:0]`.\n\n- **Counter Range Check:**  \n   When the timer is enabled, `count` should always remain within the range `[reload_value, match_value]` to ensure it does not overflow or underflow unexpectedly.\n\n- **Interrupt Assertion:**  \n   When `count` reaches `match_value` and `interrupt_enable` is set, `interrupt` should assert on the next clock cycle.\n\n- **Fault Flag Handling:**  \n   If an AXI write is attempted to an invalid address (`axi_addr > ADDR_STATUS`), the `fault_flag` must be set to `1'b1`.\n\nEach assertion must provide a detailed failure message, including the expected and actual values of the counter, relevant control signals, and AXI transactions for debugging purposes.\n\n---\n\n## Design Specifications\n\nThe `ttc_counter_lite` module is a lightweight timer/counter with configurable match and reload values. It supports AXI-based configuration and status monitoring. The module operates in both one-shot and interval mode, generating an interrupt when the counter reaches the match value.\n\n**Module Name**:\n`ttc_counter_lite`\n\n### Inputs:\n1. **`clk`** (1 bit): Clock signal for synchronous operation.\n2. **`reset`** (1 bit): Active-high reset signal to initialize the timer.\n3. **`axi_addr`** (4 bits): Address bus for AXI-Lite read/write operations.\n4. **`axi_wdata`** (32 bits): Data bus for AXI-Lite write operations.\n5. **`axi_write_en`** (1 bit): Write enable signal for AXI-Lite writes.\n6. **`axi_read_en`** (1 bit): Read enable signal for AXI-Lite reads.\n\n### Outputs:\n1. **`axi_rdata`** (32 bits): Data bus for AXI-Lite read operations.\n2. **`interrupt`** (1 bit): Interrupt signal, asserted when the counter matches the configured match value.\n3. **`fault_flag`** Signal indicating invalid AXI operations, such as unsupported address accesses.\n4. **`debug_flag[15:0]`** Debug output exposing internal states for real-time monitoring.\n\n---", "context": {"rtl/ttc_counter_lite.sv": "\nmodule ttc_counter_lite (\n    input wire          clk,                // Clock signal\n    input wire          reset,              // Reset signal\n    input wire [3:0]    axi_addr,           // AXI address for read/write\n    input wire [31:0]   axi_wdata,          // AXI write data\n    input wire          axi_write_en,       // AXI write enable\n    input wire          axi_read_en,        // AXI read enable\n    output reg [31:0]   axi_rdata,          // AXI read data\n    output reg          interrupt,          // Interrupt signal\n    output reg          fault_flag,         // Fault flag for invalid operations\n    output reg [15:0]   debug_flag          // Debug flag for internal monitoring\n);\n\n    // Timer registers\n    reg [15:0] count;                       // Counter register\n    reg [15:0] match_value;                 // Match value for interval mode\n    reg [15:0] reload_value;                // Reload value in interval mode\n    reg        enable;                      // Timer enable flag\n    reg        interval_mode;               // Interval mode enable flag\n    reg        interrupt_enable;            // Interrupt enable flag\n    reg        interrupt_clear;             // Interrupt clear signal\n\n    // Address map\n    localparam ADDR_COUNT        = 4'b0000; // Counter register (read only)\n    localparam ADDR_MATCH_VALUE  = 4'b0001; // Match value register\n    localparam ADDR_RELOAD_VALUE = 4'b0010; // Reload value register\n    localparam ADDR_CONTROL      = 4'b0011; // Control register\n    localparam ADDR_STATUS       = 4'b0100; // Status register\n\n    wire match_flag = (count == match_value);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 16'b0; \n        end else if (enable) begin\n            if (interval_mode && match_flag) begin\n                count <= reload_value; \n            end \n            else if (count == match_value) begin\n                count <= count; \n            end else begin\n                count <= count + 16'b1; \n            end\n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            interrupt <= 1'b0;\n        end else if (match_flag && interrupt_enable) begin\n            interrupt <= 1'b1; \n        end else if (interrupt_clear) begin\n            interrupt <= 1'b0; \n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            match_value      <= 16'd50;  \n            reload_value     <= 16'd10;  \n            enable           <= 1'b0; \n            interval_mode    <= 1'b0; \n            interrupt_enable <= 1'b0; \n            interrupt_clear  <= 1'b0; \n            fault_flag       <= 1'b0;   \n        end else if (axi_write_en) begin\n            case (axi_addr)\n                ADDR_MATCH_VALUE:  match_value      <= axi_wdata[15:0];\n                ADDR_RELOAD_VALUE: reload_value     <= axi_wdata[15:0];\n                ADDR_CONTROL: begin\n                    enable           <= axi_wdata[0];\n                    interval_mode    <= axi_wdata[1];\n                    interrupt_enable <= axi_wdata[2];\n                    interrupt_clear  <= axi_wdata[3];\n                end\n                default: fault_flag <= 1'b1; \n            endcase\n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            axi_rdata <= 32'b0;\n        end else if (axi_read_en) begin\n            case (axi_addr)\n                ADDR_COUNT:        axi_rdata <= {16'b0, count}; \n                ADDR_MATCH_VALUE:  axi_rdata <= {16'b0, match_value}; \n                ADDR_RELOAD_VALUE: axi_rdata <= {16'b0, reload_value}; \n                ADDR_CONTROL:      axi_rdata <= {28'b0, interrupt_clear, interrupt_enable, interval_mode, enable};\n                ADDR_STATUS:       axi_rdata <= {30'b0, fault_flag, interrupt}; \n                default:           axi_rdata <= 32'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            debug_flag <= 16'b0; \n        end else begin\n            debug_flag <= {enable, interval_mode, interrupt_enable, interrupt_clear, match_flag, count[10:0]};\n        end\n    end\n\nendmodule\n"}}, "output": {"response": "", "context": {"rtl/ttc_counter_lite.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 80\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ttc_counter_lite.sv\nTOPLEVEL        = ttc_counter_lite\nMODULE          = test_ttc_counter_lite\nPYTHONPATH      = /src\nHASH            = 5d5c075e46d7e91cbc38c65f6940119bfe5bb1e1\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 2, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_ttc_counter_lite.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport harness_library as hrs_lb\n\n# Constants for address map\nADDR_MATCH_VALUE = 0x1\nADDR_RELOAD_VALUE = 0x2\nADDR_CONTROL = 0x3\nADDR_STATUS = 0x4\n\n@cocotb.test()\nasync def test_ttc_counter_lite(dut):\n    \n    # Generate a clock signal for the DUT (10 ns period, 100 MHz frequency)\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Initialize the DUT signals using a helper library (reset all signals to defaults)\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT to ensure a clean start\n    dut.reset.value = 1\n    await Timer(20, units=\"ns\")  # Wait for the reset pulse\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)  # Wait for the next clock edge\n    dut._log.info(\"[INFO] Reset completed and deasserted\")\n\n    # Helper function to write data to a register\n    async def write_register(dut, addr, data):\n       \n        dut.axi_addr.value = addr  # Set the address\n        dut.axi_wdata.value = data  # Set the write data\n        dut.axi_write_en.value = 1  # Enable the write\n        await RisingEdge(dut.clk)  # Wait for one clock cycle\n        dut.axi_write_en.value = 0  # Disable the write\n        await RisingEdge(dut.clk)  # Wait for the next clock edge\n\n    # Helper function to read data from a register\n    async def read_register(dut, addr):\n       \n        dut.axi_addr.value = addr  # Set the address\n        dut.axi_read_en.value = 1  # Enable the read\n        await RisingEdge(dut.clk)  # Wait for one clock cycle\n        dut.axi_read_en.value = 0  # Disable the read\n        await RisingEdge(dut.clk)  # Wait for the next clock edge\n        return dut.axi_rdata.value.integer  # Return the read data as an integer\n\n    # Test: Write match value to the register and verify it\n    await write_register(dut, ADDR_MATCH_VALUE, 0x14)  # Set match_value = 20\n    match_value = await read_register(dut, ADDR_MATCH_VALUE)\n    assert match_value == 0x14, f\"[ERROR] Match value mismatch: {match_value}\"\n    dut._log.info(f\"[CHECK] Match value correctly set to {match_value}\")\n\n    # Test: Write reload value to the register and verify it\n    await write_register(dut, ADDR_RELOAD_VALUE, 0x0A)  # Set reload_value = 10\n    reload_value = await read_register(dut, ADDR_RELOAD_VALUE)\n    assert reload_value == 0x0A, f\"[ERROR] Reload value mismatch: {reload_value}\"\n    dut._log.info(f\"[CHECK] Reload value correctly set to {reload_value}\")\n\n    # Test: Configure control register and verify the settings\n    await write_register(dut, ADDR_CONTROL, 0x7)  # Enable=1, Interval_Mode=1, Interrupt_Enable=1\n    control_value = await read_register(dut, ADDR_CONTROL)\n    assert control_value == 0x7, f\"[ERROR] Control register mismatch: {control_value}\"\n    dut._log.info(f\"[CHECK] Control register configured: Enable={dut.enable.value}, Interval Mode={dut.interval_mode.value}, Interrupt Enable={dut.interrupt_enable.value}\")\n    dut._log.info(\"[CHECK] Control register correctly configured\")\n\n    # Wait and verify counter operation (observe counting within range)\n    await Timer(200, units=\"ns\")  # Allow the counter to run for 200 ns\n    count = int(dut.count.value)  # Read the current counter value\n    reload_value = int(dut.reload_value.value)  # Reload value\n    match_value = int(dut.match_value.value)  # Match value\n    assert reload_value <= count <= match_value, f\"[ERROR] Counter value {count} is out of range [{reload_value}, {match_value}]\"\n    dut._log.info(f\"[CHECK] Counter is running within range: {count}, Reload Value: {reload_value}, Match Value: {match_value}\")\n\n    # Wait and verify interrupt generation when counter matches the match value\n    await Timer(100, units=\"ns\")  # Wait for an interrupt to be generated\n    interrupt_status = await read_register(dut, ADDR_STATUS)\n    assert interrupt_status & 0x1, \"[ERROR] Interrupt not asserted\"\n    dut._log.info(f\"[CHECK] Interrupt asserted at match: {dut.interrupt.value}\")\n    dut._log.info(\"[CHECK] Interrupt correctly asserted at match\")\n\n    # Test: Clear the interrupt and verify it is deasserted\n    await write_register(dut, ADDR_CONTROL, 0x8)  # Set interrupt_clear\n    interrupt_status = await read_register(dut, ADDR_STATUS)\n    assert not (interrupt_status & 0x1), \"[ERROR] Interrupt not cleared\"\n    dut._log.info(f\"[CHECK] Interrupt cleared successfully: {dut.interrupt.value}\")\n    dut._log.info(\"[CHECK] Interrupt cleared successfully\")\n\n    # Test: Write to an invalid address and verify fault flag\n    await write_register(dut, 0xF, 0x1234)  # Write to invalid address\n    fault_status = await read_register(dut, ADDR_STATUS)\n    assert fault_status & 0x2, \"[ERROR] Fault flag not asserted for invalid address\"\n    dut._log.info(f\"[CHECK] Fault flag correctly asserted for invalid address: {dut.fault_flag.value}\")\n\n    # Test: Verify the debug flag for correctness\n    debug_flag = dut.debug_flag.value.integer\n    expected_debug = ((int(dut.enable.value) << 15) |\n                    (int(dut.interval_mode.value) << 14) |\n                    (int(dut.interrupt_enable.value) << 13) |\n                    (int(dut.interrupt_clear.value) << 12) |\n                    (int(dut.match_flag.value) << 11) |\n                    (int(dut.count.value) & 0x7FF))\n    assert debug_flag == expected_debug, f\"[ERROR] Debug flag mismatch: {debug_flag} != {expected_debug}\"\n    dut._log.info(f\"[CHECK] Debug Flag: debug_flag = {int(dut.debug_flag.value)}, expected_debug = {expected_debug}\")\n    dut._log.info(\"[CHECK] Debug flag is functioning correctly\")\n\n    # Final message indicating simulation success\n    dut._log.info(\"[INFO] Simulation finished successfully.\")\n"}}}
{"id": "cvdp_copilot_uart_0013", "categories": ["cid014", "medium"], "input": {"prompt": "\nCan you generate SystemVerilog assertions to validate the behavior and specifications of the `UART`  . The module details and design requirements for assertion development are outlined below.\n\n---\n\n## **Specifications**\n\n### **Interface:**  \n\n**Parameter:**\n\n- `DATA_WIDTH` : Determines the bit width of transmitted and received data. Default is 8.\n- `BAUD_RATE` : Specifies the baud rate for communication. Default is 4800.\n- `CLK_FREQ` : Clock frequency used for UART operations. Default: 50 MHz.\n\n**Inputs:**\n\n- `clk`: 50 MHz system clock. The positive edge of the `clk` controls the design.\n- `reset`: Active HIGH Asynchronous reset signal.\n- `tx_start`: Signal to start data transmission.\n- `tx_data([DATA_WIDTH-1:0])`: Data to be transmitted.\n- `rx`: Received serial data.\n\n**Outputs:**\n\n- `tx`: Transmitted serial data.\n- `tx_ready`: Indicates when the transmitter is ready to accept new data.\n- `rx_data([DATA_WIDTH-1:0])`: Received data output.\n- `rx_ready`: Reception complete flag.\n- `rx_bit_count([3:0])`: Monitor bit counting in reception.\n\n## **Behavioral Requirements** \n\n- **`Transmission`:** If `tx_start` is HIGH then Load `tx_data` into shift register with the formatted frame `start bit`, `tx_data`, `parity` and `stop` bits. Shift out LSB-first at baud rate. TX(`tx`) completes when all bits are sent, setting `tx_ready` is HIGH.\n- **`Reception`:** If `rx` is LOW detected then  Start reception, shift bits into `rx_shift_reg` at baud rate. After receiving `DATA_WIDTH` bits, check parity and stop bit. If valid, `rx_ready` should be HIGH and `rx_data` updates.\n- **`Baud Timing`:**  If `tx_div_counter` and `rx_div_counter` regulate transmission and sampling. `rx_bit_count` tracks received bits.\n\n---\n\n## **Assertion Requirements** \n\n**1. Reset Behavior Verification**\n - Ensures that upon reset `(reset = 1)`:\n - `tx` is set to 1 (idle).\n - `tx_ready = 1` (transmitter ready).\n - `tx_busy = 0`, `rx_ready = 0`, `rx_busy = 0` (UART idle state).\n\n**2. TX Ready & Busy Check**\n- When `tx_ready` is asserted, the transmitter must not be engaged in an ongoing transmission when `tx_busy` has LOW.\n\n**3. RX Start Bit Detection**\n- The UART receiver `rx_busy` should be enabled when a falling edge is detected on `rx` (i.e., rx is LOW while rx_busy is also LOW) and If this condition is met, `rx_busy` must be set HIGH in the next clock cycle for the start of data reception.\n\n**4. RX Data Integrity Check and RX Parity Validation**\n- Ensures that when `rx_ready` is HIGH, `rx_data` correctly shifted into `rx_shift_reg` confirming proper data reception on the receiver side. Also, verifies that the computed parity of `rx_shift_reg` matches the received parity bit, ensuring error detection.\n\n **5. RX Baud Rate Timing Check**\n- Ensures `rx_div_counter` resets correctly at zero and does not exceed BAUD_DIV - 1, maintaining correct bit sampling.\n\n**6. RX Bit Counting Check**\n- Ensures `rx_bit_count_internal` holds its previous value unless a new bit is received during RX operation.\n\n---\n\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.\n\n", "context": {"rtl/UART_RTL.sv": "module UART_RTL#(\n    parameter int DATA_WIDTH = 8,\n    parameter int BAUD_RATE = 4800,\n    parameter int CLK_FREQ = 50000000 // Clock frequency in Hz\n) (\n    input  logic clk,         // Common clock (50 MHz) for both TX and RX\n    input  logic reset,       // Asynchronous reset\n    input  logic tx_start,    // Start transmission\n    input  logic [DATA_WIDTH-1:0] tx_data, // Data to be transmitted\n    output logic tx,          // Transmitted serial data\n    output logic tx_ready,    // Transmitter ready to accept new data\n    input  logic rx,          // Received serial data\n    output logic [DATA_WIDTH-1:0] rx_data, // Data received\n    output logic rx_ready,    // Reception complete flag\n    output logic [3:0] rx_bit_count // To monitor bit counting\n);\n\n    // Calculate baud rate divisor for the transmitter and receiver\n    localparam int BAUD_DIV = CLK_FREQ / BAUD_RATE;\n\n    // Transmitter signals\n    logic [DATA_WIDTH+3:0] tx_shift_reg;\n    logic [15:0] tx_bit_count;\n    logic [15:0] tx_div_counter;\n    logic tx_busy;\n    logic tx_parity;\n\n    // Receiver signals\n    logic [DATA_WIDTH+2:0] rx_shift_reg;\n    logic [3:0] rx_bit_count_internal;\n    logic [15:0] rx_div_counter;\n    logic rx_busy;\n    logic rx_parity;\n    logic [2:0] rx_sample_count; // Counter to determine the middle of a bit\n\n    assign rx_bit_count = rx_bit_count_internal;\n\n    // TX FSM (using clk)\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            tx <= 1'b1;\n            tx_ready <= 1'b1;\n            tx_busy <= 1'b0;\n            tx_div_counter <= 0;\n            tx_bit_count <= 0;\n            tx_parity <= 1'b0; // Initialize parity bit\n        end else begin\n            if (tx_start && tx_ready) begin\n                // Calculate parity bit for even parity\n                tx_parity <= ^tx_data; // XOR all bits in tx_data for even parity\n                // Load data into the shift register with start, parity, and stop bits\n                tx_shift_reg <= {2'b11, tx_parity, tx_data, 1'b0}; // Stop bits, parity, data, start\n                tx_bit_count <= 0;\n                tx_div_counter <= BAUD_DIV - 1;\n                tx_busy <= 1;\n                tx_ready <= 1'b0;\n            end\n\n            if (tx_busy) begin\n                if (tx_div_counter == 0) begin\n                    tx_div_counter <= BAUD_DIV - 1;\n                    if (tx_bit_count < DATA_WIDTH + 3) begin\n                        tx <= tx_shift_reg[0];\n                        tx_shift_reg <= tx_shift_reg >> 1;\n                        tx_bit_count <= tx_bit_count + 1;\n                    end else begin\n                        tx_busy <= 1'b0;\n                        tx_ready <= 1'b1;\n                    end\n                end else begin\n                    tx_div_counter <= tx_div_counter - 1;\n                end\n            end\n        end\n    end\n\n      // RX FSM (using clk)\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            rx_shift_reg <= 0;\n            rx_bit_count_internal <= 0;\n            rx_div_counter <= 0;\n            rx_busy <= 1'b0;\n            rx_data <= 0;\n            rx_ready <= 1'b0;\n            rx_sample_count <= 0;\n        end else begin\n            if (!rx_busy && (rx == 1'b0)) begin // Detect start bit\n                rx_busy <= 1'b1;\n                rx_div_counter <= BAUD_DIV / 2; // Wait to sample in the middle of the start bit\n                rx_bit_count_internal <= 0;\n                rx_sample_count <= 0;\n                rx_ready <= 1'b0; // Clear ready flag\n            end\n\n            if (rx_busy) begin\n                if (rx_div_counter == 0) begin\n                    rx_div_counter <= BAUD_DIV - 1; // Use the same baud divisor for both TX and RX\n\n                    if (rx_bit_count_internal == 0) begin\n                        rx_bit_count_internal <= 1; // Move to the next bit (skip the start bit)\n                    end else if (rx_bit_count_internal <= DATA_WIDTH) begin\n                        rx_shift_reg <= {rx, rx_shift_reg[DATA_WIDTH+1:1]}; // Shift in the received bit\n                        rx_bit_count_internal <= rx_bit_count_internal + 1;\n                    end else if (rx_bit_count_internal == DATA_WIDTH + 1) begin\n                        // Parity bit check (not used in this example, but reserved for future)\n                        rx_parity <= rx; \n                        rx_bit_count_internal <= rx_bit_count_internal + 1;\n                    end else if (rx_bit_count_internal == DATA_WIDTH + 2) begin\n                        // Stop bit check\n                        if (rx == 1'b1) begin // Ensure stop bit is 1\n                            rx_data <= rx_shift_reg[DATA_WIDTH+2:2]; // Load the received data\n                            rx_ready <= 1'b1; // Indicate data reception is complete\n                        end\n                        rx_busy <= 1'b0; // Frame is done\n                    end\n                end else begin\n                    rx_div_counter <= rx_div_counter - 1;\n                end\n            end else begin\n                rx_ready <= 1'b0; // Clear ready flag once data is read\n            end\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/UART_RTL.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nWAVE            = True\nVERILOG_SOURCES = /code/rtl/UART_RTL.sv\nTOPLEVEL        = UART_RTL\nMODULE          = test_uart\nPYTHONPATH      = /src\nHASH            = d15322b3eef7b3e964186bd7b00975b918edffe5", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_uart.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import Timer\n\nasync def fn(dut, reg):\n    \"\"\"UART Transmission and Reception logic.\"\"\"\n    \n    # Register to store RX bits during transmission\n    rx_data_reg = []\n\n    # Start the clock (50 MHz -> 20ns period)\n    cocotb.start_soon(Clock(dut.clk, 20, units='ns').start())\n\n    # Reset the DUT\n    dut.reset.value = 1\n    dut.tx_start.value = 0\n    dut.tx_data.value = 0\n    dut.rx.value = 1  # Set rx to idle state (high)\n    await Timer(100, units='ns')\n    dut.reset.value = 0\n    await Timer(100, units='ns')  \n    \n    # Ensure TX is initially ready\n    assert dut.tx_ready.value == 1, \"TX should be ready initially\"\n\n    # Wait for some cycles before starting transmission\n    await Timer(10, units=\"ns\")\n\n    # Get BAUD_RATE from DUT\n    BAUD_RATE = int(dut.BAUD_RATE.value)\n    \n    # Calculate baud period in nanoseconds\n    baud_period = int(1e9 / BAUD_RATE)  # Baud period in ns\n    dut._log.info(f\"Calculated baud period: {baud_period} ns\")\n\n    # Transmit start bit (0)\n    dut.tx.value = 0  # Start bit (Low)\n    dut.rx.value = 0  # Immediately mirror TX to RX for start bit\n    #rx_data_reg.append(dut.rx.value.to_unsigned())  # Store start bit in rx_data_reg\n    rx_data_reg.append(int(dut.rx.value))\n    await Timer(baud_period, units='ns')  # Wait for the full baud period\n    dut._log.info(f\"TX start bit transmitted: {dut.tx.value}, RX: {dut.rx.value}\")\n\n    # Transmit 8 data bits\n    for bit in reg:\n        dut.tx.value = bit  # Send each bit of the data\n        await Timer(1, units='ns')  # Ensure RX is updated after TX\n        dut.rx.value = dut.tx.value  # Immediately mirror TX to RX\n        #rx_data_reg.append(dut.rx.value.to_unsigned())  # Store RX bits in rx_data_reg\n        rx_data_reg.append(int(dut.rx.value))\n        #dut._log.info(f\"TX bit: {bit}, RX bit: {dut.rx.value.to_unsigned()}\")\n        dut._log.info(f\"TX bit: {bit}, RX bit: {dut.rx.value}\")\n        await Timer(baud_period - 1, units='ns')  # Wait full baud period\n\n    # Calculate even parity (XOR all data bits)\n    parity_bit = 0\n    for bit in reg:\n        parity_bit ^= bit  # XOR operation to calculate even parity\n\n    # Transmit parity bit\n    dut.tx.value = parity_bit\n    await Timer(1, units='ns')  # Ensure RX is updated after TX\n    dut.rx.value = parity_bit  # Mirror TX parity to RX\n    #rx_data_reg.append(dut.rx.value.to_unsigned())  # Store parity bit in rx_data_reg\n    rx_data_reg.append(int(dut.rx.value))\n    dut._log.info(f\"TX parity bit: {parity_bit}\")\n    await Timer(baud_period - 1, units='ns')  # Wait full baud period\n\n    # Transmit stop bit (1)\n    dut.tx.value = 1\n    await Timer(1, units='ns')  # Ensure RX is updated after TX\n    dut.rx.value = dut.tx.value  # Mirror TX stop bit to RX\n    #rx_data_reg.append(dut.rx.value.to_unsigned())  # Store stop bit in rx_data_reg\n    rx_data_reg.append(int(dut.rx.value))\n    dut._log.info(\"TX stop bit transmitted.\")\n    await Timer(baud_period - 1, units='ns')  # Wait full baud period\n\n    dut._log.info(\"UART transmission complete.\")\n\n    # Receiver logic\n    dut._log.info(\"UART Reception started:\")\n\n    # Now print the RX values received from TX\n    for i, rx_bit in enumerate(rx_data_reg):\n        dut._log.info(f\"RX bit {i}: {rx_bit}\")\n\n    # Receiver logic: Use rx_data_reg for receiver processing \n    received_data = rx_data_reg[2:10]  # Exclude parity and stop bit from data\n\n    # Verify received data matches transmitted data\n    transmitted_data = reg\n    assert received_data == transmitted_data, f\"Received data {received_data} does not match transmitted data {transmitted_data}\"\n\n    # Check parity\n    received_parity = rx_data_reg[-2]  # Second-to-last bit is parity bit\n    stop_bit = rx_data_reg[-1]  # Last bit is stop bit\n    expected_parity = 0\n    for bit in transmitted_data:\n        expected_parity ^= bit  # XOR for even parity\n\n   \n    dut._log.info(\"UART Received data matches with Transmitted data.\")\n\n@cocotb.test()\nasync def test_1(dut):\n    \"\"\"Test Case 1: Data = [0,0,0,0,1,1,1,1]\"\"\"\n    reg = [0, 0, 0, 0, 1, 1, 1, 1]\n    await fn(dut, reg)\n\n@cocotb.test()\nasync def test_2(dut):\n    \"\"\"Test Case 2: Data = [1,1,0,0,1,1,0,0]\"\"\"\n    reg = [1, 1, 0, 0, 1, 1, 0, 0]\n    await fn(dut, reg)\n\n@cocotb.test()\nasync def test_3(dut):\n    \"\"\"Test Case 3: Data = [0,0,1,1,0,1,0,0]\"\"\"\n    reg = [0, 0, 1, 1, 0, 1, 0, 0]\n    await fn(dut, reg)"}}}
{"id": "cvdp_copilot_vending_machine_0006", "categories": ["cid012", "medium"], "input": {"prompt": "Complete the given partial SystemVerilog testbench `serial_line_code_converter_tb`. The testbench must instantiate the `serial_line_code_converter` RTL module and provide input stimulus for various testcases. This testbench simulates a vending machine that processes item selection, coin insertion, item dispensing, change return, and purchase cancellation. \n## Description\nThe vending machine operates using a finite state machine (FSM) with distinct states to ensure a structured transaction flow. It begins in the IDLE state, awaiting item selection before allowing coin insertion. The machine validates inserted coins, dispenses the item upon sufficient payment, and returns change if necessary. Errors trigger the RETURN_MONEY state, ensuring incorrect transactions are handled properly, and a reset clears all internal states, preparing the machine for a new transaction.\n\n## **Interface**\n\n### **Inputs**\n- **clk:** Clock signal for timing and synchronizing state transitions, operating on the rising edge.\n- **rst:** Asynchronous, active-high reset signal that resets all internal states, outputs, and accumulated values, returning the machine to the `IDLE` state.\n- **item_button(1-bit):** Signal indicating that the user has pressed the button to initiate item selection (active high). This acts as a toggle signal and should only register on the rising edge.\n- **item_selected (3-bits, [2:0]):** This input represents the item chosen by the user, with valid values corresponding to the four available items (valid values: `3'b001` to `3'b100`).\n- **coin_input(4-bits, [3:0]):** This input represents the value of the coin inserted, with valid values of 1, 2, 5, or 10 units.\n- **cancel (1-bit):** Signal allowing the user to cancel the current transaction before the item is dispensed (active high).\n\n### **Outputs**\n- **dispense_item(1-bit):** Indicates that the selected item is ready for dispensing after the required amount is met. Active high for one clock cycle when the item is being dispensed.\n- **return_change(1-bit):** Signal that excess coins are being returned as change. Active high for one clock cycle when change is being returned.\n- **item_price(5-bits,[4:0]):** Output displaying the price of the currently selected item.\n- **change_amount(5-bits,[4:0]):** Output representing the amount of change to be returned if excess coins were inserted.\n- **dispense_item_id(3-bits,[2:0]):** Output indicating the ID of the item being dispensed.\n- **error(1-bit):** Indicates that an invalid operation has occurred, such as inserting coins without selecting an item or entering invalid coin values. Active high for one clock cycle during an error condition.\n- **return_money(1-bit):** Indicates that all inserted money should be returned due to cancellation or an error. Active high for one clock cycle when returning money.\n\n## Instantiation\n\nThe testbench instantiates the `vending_machine` module as `uut` (unit under test) and connects the signals accordingly.\n\n### Input Generation and Validation\n\n#### Clock Generation\nThe `clk` signal should toggle every 5 time units, simulating a 100MHz clock.\n\n#### Reset Handling\nThe `rst` signal should be high at the beginning of the simulation for at least three clock cycles. \n\n### Test Scenarios\n\nThe testbench should generate multiple real-world scenarios involving purchases, cancellations, and error handling.\n\n#### 1. System Initialization\n-  Generate a clock signal and assert the reset signal for multiple cycles to initialize the system in a defined state.e.\n\n#### 2. Selecting an Item\n-  Assert and de-assert the selection button within a clock cycle while setting the selected item ID.\n\n#### 3. Inserting Coins\n- A value representing the coin input is assigned, and after a clock cycle, it is reset to zero.\n\n#### 4. Cancelling a Purchase\n - The cancel button is asserted and de-asserted within one clock cycle.\n\n#### 5. Purchasing an Item with Exact Coins\n- Select an item 1 and insert the exact required amount (5) in a single step.\n\n#### 6. Purchasing an Item with Multiple Coin Insertions\n- Select item 2 and insert a partial amount (5), followed by the remaining balance (5) in subsequent cycles.\n\n#### 7. Purchasing an Item with Extra Coins and Getting Change\n- Select item 2 and insert more than the required amount and ensure a change is computed.\n\n#### 8. Cancelling a Purchase After Inserting Some Coins\n- Select an item, insert partial coins, then assert cancel.\n\n#### 9. Cancelling Immediately After Selecting an Item\n- Select an item and immediately trigger cancellation.\n\n#### 10. Purchasing an Expensive Item with Multiple Small Coin Insertions\n- Insert small denominations over multiple steps to accumulate the required price.\n\n#### 11. Inserting Coins Without Selecting an Item\n- Insert money without item selection.\n\n#### 12. Resetting the System After Inserting Coins or Selecting an Item\n- Initiate a transaction, assert reset, and verify system restart.\n\n#### 13. Rapid Successive Coin Insertions\n- Insert multiple small denominations in quick succession.\n\n#### 14. Rapid Coin Insertion Handling\n - The same coin value is inserted multiple times in quick succession.\n\n#### 15. Selecting an Invalid Item ID\n - A non-existent item ID is chosen.\n\n#### 16. Returning Money When No Item Is Selected\n- Insert money and verify refund without selection.\n\n#### 17. Transition from Dispensing an Item to Returning Change\n- Overpay and verify that dispensing occurs before change return.\n\n#### 18. Transition from Returning Change Back to Idle\n-  Complete a purchase with a change return and verify system readiness.\n\n#### 19. Cancelling After Pressing the Item Selection Button\n- Select an item and cancel before inserting money.\n\n### Final Steps\n\n- **Simulation End**: After all tests, wait for a few cycles and call `$finish`.\n- **Waveform Dump**: Generate a VCD file for offline analysis.\n\n### Partial Test Stimulus Generator Code:\n\n```verilog\nmodule vending_machine_tb;\n\n    reg clk;                    // Clock signal\n    reg rst;                    // Reset signal\n    reg item_button;            // Signal for item selection button press\n    reg [2:0] item_selected;    // Input to select one of 4 items\n    reg [3:0] coin_input;       // Coin input\n    reg cancel;                 // Cancel button signal\n\n    wire dispense_item;         // Signal to dispense item\n    wire return_change;         // Signal to return change\n    wire error;                 // Error signal if any invalid operation occurs\n    wire return_money;          // Signal to return all money if operation is cancelled\n    wire [4:0] item_price;      // Price of the selected item\n    wire [4:0] change_amount;   // Amount of change to return\n    wire [2:0] dispense_item_id;// ID of item being dispensed\n\n    // Instantiate the vending machine module\n    vending_machine uut (\n        .clk(clk),\n        .rst(rst),\n        .item_button(item_button),\n        .item_selected(item_selected),\n        .coin_input(coin_input),\n        .dispense_item(dispense_item),\n        .return_change(return_change),\n        .item_price(item_price),\n        .change_amount(change_amount),\n        .dispense_item_id(dispense_item_id),\n        .error(error),\n        .cancel(cancel),\n        .return_money(return_money)\n    );\n\n    // Clock generator: Clock signal toggles every 5 time units\n    always #5 clk = ~clk;\n\n    // Task to initialize the testbench (reset and initial conditions)\n    task initialize;\n    begin\n        clk = 0;\n        rst = 1;              \n        item_button = 0;\n        item_selected = 3'b000;\n        coin_input = 0;\n        cancel = 0;\n        @(posedge clk) rst = 0;          \n    end\n    endtask\n\n    // Task to select an item\n    task select_item(input [2:0] item);\n    begin\n        @(posedge clk)\n        item_button = 1;     \n        @(posedge clk) item_button = 0;\n        item_selected = item;\n        @(posedge clk);\n    end\n    endtask\n\n    // Insert the code for the remaining test stimulus here\n\nendmodule\n\n\n```", "context": {}}, "output": {"response": "", "context": {"verif/vending_machine_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro \n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 76091a14c1d5d7926f0b7a471c78b7f9cf8ad22b\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        while len(info) < 3:\n            info.append(\"0%\")\n\n        inst = re.sub(r'[\\W]', '', info[0])\n\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'uut' is missing in the coverage log.\")\n\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))  \n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['uut']['Average']}, Target: {target}\"", "src/vending_machine.sv": "module vending_machine(\n    input clk,                          // Clock signal\n    input rst,                          // Reset signal\n    input item_button,                  // Signal for item selection button press (active high, rising edge)\n    input [2:0] item_selected,          // 3-bit input to select item (valid: 3'b001 to 3'b100)\n    input [3:0] coin_input,             // 4-bit coin input to represent value of coin inserted (1, 2, 5, or 10)\n    input cancel,                       // Cancel button signal (active high, rising edge)\n    output reg dispense_item,           // Signal to dispense item (active high for one cycle)\n    output reg return_change,           // Signal to return change (active high for one cycle)\n    output reg [4:0] item_price,        // Price of the selected item\n    output reg [4:0] change_amount,     // Amount of change to return\n    output reg [2:0] dispense_item_id,  // ID of item being dispensed\n    output reg error,                   // Error signal if any invalid operation occurs (active high for one cycle)\n    output reg return_money             // Signal to return all money if operation is cancelled or invalid (active high for one cycle)\n);\n\n    // Item Prices (Assume we have 4 items with prices: 5, 10, 15, 20 units)\n    localparam ITEM_1_PRICE = 5'd5;\n    localparam ITEM_2_PRICE = 5'd10;\n    localparam ITEM_3_PRICE = 5'd15;\n    localparam ITEM_4_PRICE = 5'd20;\n\n    // Item IDs or Names\n    localparam NO_ITEM = 3'b000;\n    localparam ITEM_1_ID = 3'b001; // Item 1\n    localparam ITEM_2_ID = 3'b010; // Item 2\n    localparam ITEM_3_ID = 3'b011; // Item 3\n    localparam ITEM_4_ID = 3'b100; // Item 4\n\n    // Internal registers\n    reg [4:0] coins_accumulated;   // Tracks accumulated coins\n    reg [4:0] amount;\n\n    // Define state enum\n    typedef enum logic [3:0] {\n        IDLE                = 4'd0,     // Idle state\n        ITEM_SELECTION      = 4'd1,     // Waiting for item selection\n        PAYMENT_VALIDATION  = 4'd2,     // Validating coin input\n        DISPENSING_ITEM     = 4'd3,     // Dispensing the item\n        RETURN_CHANGE       = 4'd4,     // Returning change\n        RETURN_MONEY        = 4'd5      // Returning all money\n    } state_t;\n\n    state_t current_state, next_state;         // Current and next states of the vending machine\n    reg [4:0] next_coins_accumulated;\n    reg       next_return_change;\n    reg [4:0] next_item_price;\n    reg [4:0] next_change_amount;\n    reg       next_error;\n    reg [2:0] next_dispense_item_id;\n    reg       next_return_money;\n    reg       next_dispense_item;\n    reg [4:0] next_amount;\n\n    // State Machine logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all outputs and internal registers\n            coins_accumulated <= 5'd0;\n            return_change     <= 1'b0;\n            item_price        <= 5'd0;\n            change_amount     <= 5'd0;\n            error             <= 1'b0;\n            dispense_item_id  <= 3'd0;\n            return_money      <= 1'b0;\n            dispense_item     <= 1'b0;\n            current_state     <= IDLE;\n        end else begin\n            current_state       <= next_state;\n            coins_accumulated   <= next_coins_accumulated;\n            item_price          <= next_item_price;\n            change_amount       <= next_change_amount;\n            error               <= next_error;\n            dispense_item_id    <= next_dispense_item_id;\n            return_money        <= next_return_money;\n            dispense_item       <= next_dispense_item;\n            return_change       <= next_return_change;\n            amount              <= next_amount;\n\n        end\n        \n    end\n\n    // Next state logic (combinatorial)\n    always @ (*) begin\n        next_state = current_state;\n        next_coins_accumulated = coins_accumulated;\n        next_item_price        = item_price;\n        next_change_amount     = change_amount;\n        next_error             = error;\n        next_dispense_item_id  = dispense_item_id;\n        next_return_money      = return_money;\n        next_dispense_item     = dispense_item;\n        next_return_change     = return_change;\n        next_amount            = amount;\n        case (current_state)\n            // IDLE State\n            IDLE: begin\n                if (item_button) begin\n                    next_return_money  = 1'b0;\n                    next_return_change = 1'b0; \n                    next_change_amount = 5'd0;\n                    next_coins_accumulated = 5'd0; \n                    next_error   = 1'b0;\n                    next_amount = 5'd0;\n                    next_dispense_item_id = 3'd0;\n                    next_state = ITEM_SELECTION;\n                end else if (coin_input > 0) begin\n                    next_return_change = 1'b0; \n                    next_coins_accumulated =  coin_input;\n                    next_error   = 1'b1;\n                    next_amount = 5'd0;;    \n                    next_dispense_item_id  = 3'd0;\n                    next_state = RETURN_MONEY;\n                end else begin\n                    next_return_money  = 1'b0;\n                    next_return_change = 1'b0; \n                    next_change_amount = 5'd0;\n                    next_error   = 1'b0;\n                    next_amount = 5'd0;\n                    next_dispense_item_id  = 3'd0;\n                end\n            end\n\n            // ITEM_SELECTION State\n            ITEM_SELECTION: begin\n                if (cancel) begin\n                    next_error   = 1'b1;\n                    next_state = RETURN_MONEY;\n                end else if (item_selected >= 3'b000 ) begin\n                    case (item_selected)\n                        3'b001: next_item_price = ITEM_1_PRICE;\n                        3'b010: next_item_price = ITEM_2_PRICE;\n                        3'b011: next_item_price = ITEM_3_PRICE;\n                        3'b100: next_item_price = ITEM_4_PRICE;\n                        default: next_item_price = NO_ITEM;\n                    endcase\n                    next_state = PAYMENT_VALIDATION;\n                end\n            end\n\n            // PAYMENT_VALIDATION State\n            PAYMENT_VALIDATION: begin\n                if (cancel) begin\n                    next_error   = 1'b1;\n                    next_state = RETURN_MONEY;\n                end else if ( item_selected == 3'b000 ) begin\n                    next_error = 1'b1;\n                    next_coins_accumulated = coins_accumulated + coin_input;\n                    next_state = RETURN_MONEY;\n                end else if ( item_price == NO_ITEM ) begin\n                    next_error = 1'b1;\n                    next_coins_accumulated = coins_accumulated + coin_input;\n                    next_state = RETURN_MONEY;\n                end else if (error) begin\n                    next_state = IDLE; \n                end else if (coins_accumulated >= item_price) begin\n                    next_state = DISPENSING_ITEM;\n                    next_dispense_item   = 1'b1;\n                end else if (coin_input > 0) begin\n                    // Validate the coin input (only 1, 2, 5, or 10 is accepted)\n                    if (coin_input == 4'd1 || coin_input == 4'd2 || coin_input == 4'd5 || coin_input == 4'd10) begin\n                        next_coins_accumulated = coins_accumulated + coin_input; \n                        next_state = PAYMENT_VALIDATION;  \n                    end else begin  \n                        next_amount =  coins_accumulated + coin_input;  \n                        next_error = 1'b1; \n                        next_return_money = 1'b1; \n                        next_change_amount = next_amount;\n                        next_state = IDLE;      \n                    end\n                end\n            end\n\n            // DISPENSING_ITEM State\n            DISPENSING_ITEM: begin\n                next_dispense_item = 1'b0;\n                case (item_selected)\n                    3'b001: next_dispense_item_id = ITEM_1_ID;\n                    3'b010: next_dispense_item_id = ITEM_2_ID;\n                    3'b011: next_dispense_item_id = ITEM_3_ID;\n                    3'b100: next_dispense_item_id = ITEM_4_ID;\n                    default: next_dispense_item_id = NO_ITEM;\n                endcase\n\n                if (coins_accumulated > item_price) begin\n                    next_state = RETURN_CHANGE;\n                    next_amount = coins_accumulated - item_price;\n                end else begin\n                    next_coins_accumulated = 5'd0;\n                    next_state = IDLE;\n                end\n                next_coins_accumulated = 5'd0;\n            end\n\n            // RETURN_CHANGE State\n            RETURN_CHANGE: begin\n                next_return_change = 1'b1;\n                next_change_amount = amount;\n                next_error   = 1'b0;\n                next_dispense_item_id  = 3'b000;\n                next_coins_accumulated = 5'b0;\n                next_state = IDLE;\n            end\n\n            // RETURN_MONEY State\n            RETURN_MONEY: begin\n                if (coins_accumulated == 0) begin\n                    next_return_money  = 1'b0;\n                end else if (coins_accumulated > 0) begin\n                    next_return_money  = 1'b1;\n                    next_change_amount = coins_accumulated;\n                end\n                next_error   = 1'b0;\n                next_state = IDLE;\n            end\n\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule\n\n"}}}
{"id": "cvdp_copilot_vending_machine_0009", "categories": ["cid014", "medium"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the vending_machine module based on the design specifications provided? Below are the module details and design requirements for assertion development.\n\n## **Interface**\n\n### **Inputs**\n- **clk:** Clock signal for timing and synchronizing state transitions, operating on the rising edge.\n- **rst:** Asynchronous, active-high reset signal that resets all internal states, outputs, and accumulated values, returning the machine to the `IDLE` state.\n- **item_button(1-bit):** Signal indicating that the user has pressed the button to initiate item selection (active high). This acts as a toggle signal and should only register on the rising edge.\n- **item_selected (3-bits,[2:0]):** This input represents the item chosen by the user, with valid values corresponding to the four available items (valid values: `3'b001` to `3'b100`).\n- **coin_input(4-bits,[3:0]):** This input represents the value of the coin inserted, with valid values of 1, 2, 5, or 10 units.\n- **cancel(1-bit):** Signal allowing the user to cancel the current transaction before the item is dispensed (active high).\n\n### **Outputs**\n- **dispense_item(1-bit):** Indicates that the selected item is ready for dispensing after the required amount is met. Active high for one clock cycle when the item is being dispensed.\n- **return_change(1-bit):** Signal that excess coins are being returned as change. Active high for one clock cycle when change is being returned.\n- **item_price(5-bits,[4:0]):** Output displaying the price of the currently selected item.\n- **change_amount(5-bits,[4:0]):** Output representing the amount of change to be returned if excess coins were inserted.\n- **dispense_item_id(3-bits,[2:0]):** Output indicating the ID of the item being dispensed.\n- **error(1-bit):** Indicates that an invalid operation has occurred, such as inserting coins without selecting an item or entering invalid coin values. Active high for one clock cycle during an error condition.\n- **return_money(1-bit):** Indicates that all inserted money should be returned due to cancellation or an error. Active high for one clock cycle when returning money.\n\n# Design Specifications\n\nThe vending machine operates in multiple states, handling item selection, coin validation, and dispensing items accordingly.\n\n## Item Selection and Payment Validation:\n- The user selects an item using `item_button` and `item_selected`.\n- The machine validates whether a selected item is valid (3'b001 to 3'b100).\n- The total amount of inserted coins is accumulated.\n- If the accumulated coins meet or exceed the item's price, the machine transitions to the dispensing state.\n- If an invalid item is selected (3'b000), the machine triggers an error and returns all money.\n- Only valid coin values (1, 2, 5, 10) are accepted. Invalid coin values should trigger an error and return all inserted money.\n\n## Dispensing Items and Change Handling:\n- The machine dispenses an item when sufficient payment is received.\n- If the inserted money exceeds the item price, the excess amount is returned as change.\n- The machine resets to IDLE after completing the transaction.\n\n## Error Handling and Cancellation:\n- Pressing the cancel button at any stage should result in an error and return all inserted money.\n- Any invalid operation should trigger an error and reset the system to IDLE.\n\n# Assertion Requirements\n\nDevelop a set of SystemVerilog assertions to validate the following behaviors:\n\n## 1. Reset Behavior:\nThis assertion ensures that when the reset signal (`rst`) is asserted, the vending machine initializes correctly. \n\n- On the rising edge of `clk`, if `rst` is high, the following conditions must be met:\n  1. `current_state` must be set to IDLE.\n  2. `coins_accumulated` must be cleared.\n  3. `return_money` must be de-asserted.\n\n## 2. Dispense the Correct Item Assertion:\n- Ensures that the dispensed item ID matches the selected item.\n- The assertion is checked one cycle (`##1`) after entering `DISPENSING_ITEM` state.\n- Disabled when `rst` is high.\n\n## 3. Dispense Only When Enough Money is Inserted:\n- Ensures that the vending machine only dispenses an item if enough money has been inserted.\n- If the state is `DISPENSING_ITEM`, then `coins_accumulated` must be at least equal to `item_price`.\n- Disabled when `rst` is high.\n\n## 4. Transition to IDLE After an Error:\n- Ensures that after an error, the vending machine must transition to the IDLE state in the next cycle (`##1`).\n- Disabled when `rst` is high.\n\n## 5. Cancel Should Trigger Error:\n- Ensures that pressing the cancel button results in an error signal being asserted in the next cycle.\n- Disabled when `rst` is high.\n\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.", "context": {"rtl/vending_machine.sv": "module vending_machine(\n    input clk,                          // Clock signal\n    input rst,                          // Reset signal\n    input item_button,                  // Signal for item selection button press (active high, rising edge)\n    input [2:0] item_selected,          // 3-bit input to select item (valid: 3'b001 to 3'b100)\n    input [3:0] coin_input,             // 4-bit coin input to represent value of coin inserted (1, 2, 5, or 10)\n    input cancel,                       // Cancel button signal (active high, rising edge)\n    output reg dispense_item,           // Signal to dispense item (active high for one cycle)\n    output reg return_change,           // Signal to return change (active high for one cycle)\n    output reg [4:0] item_price,        // Price of the selected item\n    output reg [4:0] change_amount,     // Amount of change to return\n    output reg [2:0] dispense_item_id,  // ID of item being dispensed\n    output reg error,                   // Error signal if any invalid operation occurs (active high for one cycle)\n    output reg return_money             // Signal to return all money if operation is cancelled or invalid (active high for one cycle)\n);\n\n    // Item Prices (Assume we have 4 items with prices: 5, 10, 15, 20 units)\n    localparam ITEM_1_PRICE = 5'd5;\n    localparam ITEM_2_PRICE = 5'd10;\n    localparam ITEM_3_PRICE = 5'd15;\n    localparam ITEM_4_PRICE = 5'd20;\n\n    // Item IDs or Names\n    localparam NO_ITEM = 3'b000;\n    localparam ITEM_1_ID = 3'b001; // Item 1\n    localparam ITEM_2_ID = 3'b010; // Item 2\n    localparam ITEM_3_ID = 3'b011; // Item 3\n    localparam ITEM_4_ID = 3'b100; // Item 4\n\n    // Internal registers\n    reg [4:0] coins_accumulated;   // Tracks accumulated coins\n    reg [4:0] amount;\n\n    // Define state enum\n    typedef enum logic [3:0] {\n        IDLE                = 4'd0,     // Idle state\n        ITEM_SELECTION      = 4'd1,     // Waiting for item selection\n        PAYMENT_VALIDATION  = 4'd2,     // Validating coin input\n        DISPENSING_ITEM     = 4'd3,     // Dispensing the item\n        RETURN_CHANGE       = 4'd4,     // Returning change\n        RETURN_MONEY        = 4'd5      // Returning all money\n    } state_t;\n\n    state_t current_state, next_state;         // Current and next states of the vending machine\n    reg [4:0] next_coins_accumulated;\n    reg       next_return_change;\n    reg [4:0] next_item_price;\n    reg [4:0] next_change_amount;\n    reg       next_error;\n    reg [2:0] next_dispense_item_id;\n    reg       next_return_money;\n    reg       next_dispense_item;\n    reg [4:0] next_amount;\n\n    // State Machine logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all outputs and internal registers\n            coins_accumulated <= 5'd0;\n            return_change     <= 1'b0;\n            item_price        <= 5'd0;\n            change_amount     <= 5'd0;\n            error             <= 1'b0;\n            dispense_item_id  <= 3'd0;\n            return_money      <= 1'b0;\n            dispense_item     <= 1'b0;\n            current_state     <= IDLE;\n        end else begin\n            current_state       <= next_state;\n            coins_accumulated   <= next_coins_accumulated;\n            item_price          <= next_item_price;\n            change_amount       <= next_change_amount;\n            error               <= next_error;\n            dispense_item_id    <= next_dispense_item_id;\n            return_money        <= next_return_money;\n            dispense_item       <= next_dispense_item;\n            return_change       <= next_return_change;\n            amount              <= next_amount;\n\n        end\n        \n    end\n\n    // Next state logic (combinatorial)\n    always @ (*) begin\n        next_state = current_state;\n        next_coins_accumulated = coins_accumulated;\n        next_item_price        = item_price;\n        next_change_amount     = change_amount;\n        next_error             = error;\n        next_dispense_item_id  = dispense_item_id;\n        next_return_money      = return_money;\n        next_dispense_item     = dispense_item;\n        next_return_change     = return_change;\n        next_amount            = amount;\n        case (current_state)\n            // IDLE State\n            IDLE: begin\n                if (item_button) begin\n                    next_return_money  = 1'b0;\n                    next_return_change = 1'b0; \n                    next_change_amount = 5'd0;\n                    next_coins_accumulated = 5'd0; \n                    next_error   = 1'b0;\n                    next_amount = 5'd0;\n                    next_dispense_item_id = 3'd0;\n                    next_state = ITEM_SELECTION;\n                end else if (coin_input > 0) begin\n                    next_return_change = 1'b0; \n                    next_coins_accumulated =  coin_input;\n                    next_error   = 1'b1;\n                    next_amount = 5'd0;;    \n                    next_dispense_item_id  = 3'd0;\n                    next_state = RETURN_MONEY;\n                end else begin\n                    next_return_money  = 1'b0;\n                    next_return_change = 1'b0; \n                    next_change_amount = 5'd0;\n                    next_error   = 1'b0;\n                    next_amount = 5'd0;\n                    next_dispense_item_id  = 3'd0;\n                end\n            end\n\n            // ITEM_SELECTION State\n            ITEM_SELECTION: begin\n                if (cancel) begin\n                    next_error   = 1'b1;\n                    next_state = RETURN_MONEY;\n                end else if (item_selected >= 3'b000 ) begin\n                    case (item_selected)\n                        3'b001: next_item_price = ITEM_1_PRICE;\n                        3'b010: next_item_price = ITEM_2_PRICE;\n                        3'b011: next_item_price = ITEM_3_PRICE;\n                        3'b100: next_item_price = ITEM_4_PRICE;\n                        default: next_item_price = NO_ITEM;\n                    endcase\n                    next_state = PAYMENT_VALIDATION;\n                end\n            end\n\n            // PAYMENT_VALIDATION State\n            PAYMENT_VALIDATION: begin\n                if (cancel) begin\n                    next_error   = 1'b1;\n                    next_state = RETURN_MONEY;\n                end else if ( item_selected == 3'b000 ) begin\n                    next_error = 1'b1;\n                    next_coins_accumulated = coins_accumulated + coin_input;\n                    next_state = RETURN_MONEY;\n                end else if ( item_price == NO_ITEM ) begin\n                    next_error = 1'b1;\n                    next_coins_accumulated = coins_accumulated + coin_input;\n                    next_state = RETURN_MONEY;\n                end else if (error) begin\n                    next_state = IDLE; \n                end else if (coins_accumulated >= item_price) begin\n                    next_state = DISPENSING_ITEM;\n                    next_dispense_item   = 1'b1;\n                end else if (coin_input > 0) begin\n                    // Validate the coin input (only 1, 2, 5, or 10 is accepted)\n                    if (coin_input == 4'd1 || coin_input == 4'd2 || coin_input == 4'd5 || coin_input == 4'd10) begin\n                        next_coins_accumulated = coins_accumulated + coin_input; \n                        next_state = PAYMENT_VALIDATION;  \n                    end else begin  \n                        next_amount =  coins_accumulated + coin_input;  \n                        next_error = 1'b1; \n                        next_return_money = 1'b1; \n                        next_change_amount = next_amount;\n                        next_state = IDLE;      \n                    end\n                end\n            end\n\n            // DISPENSING_ITEM State\n            DISPENSING_ITEM: begin\n                next_dispense_item = 1'b0;\n                case (item_selected)\n                    3'b001: next_dispense_item_id = ITEM_1_ID;\n                    3'b010: next_dispense_item_id = ITEM_2_ID;\n                    3'b011: next_dispense_item_id = ITEM_3_ID;\n                    3'b100: next_dispense_item_id = ITEM_4_ID;\n                    default: next_dispense_item_id = NO_ITEM;\n                endcase\n\n                if (coins_accumulated > item_price) begin\n                    next_state = RETURN_CHANGE;\n                    next_amount = coins_accumulated - item_price;\n                end else begin\n                    next_coins_accumulated = 5'd0;\n                    next_state = IDLE;\n                end\n                next_coins_accumulated = 5'd0;\n            end\n\n            // RETURN_CHANGE State\n            RETURN_CHANGE: begin\n                next_return_change = 1'b1;\n                next_change_amount = amount;\n                next_error   = 1'b0;\n                next_dispense_item_id  = 3'b000;\n                next_coins_accumulated = 5'b0;\n                next_state = IDLE;\n            end\n\n            // RETURN_MONEY State\n            RETURN_MONEY: begin\n                if (coins_accumulated == 0) begin\n                    next_return_money  = 1'b0;\n                end else if (coins_accumulated > 0) begin\n                    next_return_money  = 1'b1;\n                    next_change_amount = coins_accumulated;\n                end\n                next_error   = 1'b0;\n                next_state = IDLE;\n            end\n\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule\n"}}, "output": {"response": "", "context": {"rtl/vending_machine.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/vending_machine.sv\nTOPLEVEL        = vending_machine\nMODULE          = test_vending_machine\nPYTHONPATH      = /src\nHASH            = d5e3c9ad9b92dd8712ea6229b5f2bb6ac4ffa4ab\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_vending_machine.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ReadOnly , Timer\n\nimport harness_library as hrs_lb\nimport random\n\n# Task to select item\nasync def select_item(dut, item):\n    await RisingEdge(dut.clk)\n    dut.item_button.value = 1   \n    await RisingEdge(dut.clk)\n    dut.item_selected.value = item\n    dut.item_button.value = 0\n    await RisingEdge(dut.clk)\n\n# Task to insert coins\nasync def insert_coins(dut, amount):\n    dut.coin_input.value = amount\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk)\n\n# Task to simulate cancel button press\nasync def cancel_purchase(dut):\n    dut.cancel.value = 1\n    await RisingEdge(dut.clk)\n    dut.cancel.value = 0\n\n# Task to check if the item is dispensed and no errors occurred\nasync def check_dispense(dut, expected_item_id):\n    await RisingEdge(dut.clk)\n    assert dut.dispense_item.value == 1, f\"Expected item to be dispensed!\"\n    await RisingEdge(dut.clk)\n    assert dut.dispense_item_id.value == expected_item_id, f\"Dispensed item ID mismatch, got {dut.dispense_item_id.value}, expected {expected_item_id}\"\n    assert dut.error.value == 0, f\"Error signal should not be high!\"\n    assert dut.return_change.value == 0, \"Change should not be returned change in this clock cycle\"\n    print(f\"Dispense_item_id  - {int(dut.dispense_item_id.value)} , Error - {int(dut.error.value)} \")\n\n# Task to check if the correct change is returned\nasync def check_change(dut, expected_change): \n    if expected_change > 0:\n        await RisingEdge(dut.clk)\n        assert dut.return_change.value == 1, \"Change should be returned\"\n        print(f\"expected_chang amount - {int(expected_change)}\")\n        print(f\"Return change amount - {int(dut.change_amount.value)}\")\n        assert dut.change_amount.value == expected_change, f\"Expected change {expected_change}, but got {dut.change_amount.value}\"\n    else:\n        assert dut.return_change.value == 0, \"No change should be returned\"\n    await RisingEdge(dut.clk)\n    assert dut.return_change.value == 0, \"Change should not be returned after one cycle\"\n    assert dut.change_amount.value == 0, f\"Expected change {0}, but got {dut.change_amount.value}\"\n\n# Task to randomly buy an item with random coins and validate results\nasync def random_purchase(dut):\n    item_id = random.randint(1, 4)\n    item_prices = {1: 5, 2: 10, 3: 15, 4: 20}\n    expected_price = item_prices[item_id]\n    dut._log.info(f\"Randomly selecting item {item_id}, expected price: {expected_price}\")\n\n    await select_item(dut, item_id)\n\n    # Randomly insert coins until we meet or exceed the price\n    total_inserted = 0\n    while total_inserted < expected_price:\n        coin = random.choice([1, 2, 5, 10])  \n        await insert_coins(dut, coin)\n        total_inserted += coin\n        dut._log.info(f\"Inserted coin: {coin}, total so far: {total_inserted}\")\n\n    await check_dispense(dut, item_id)\n    expected_change = total_inserted - expected_price   \n\n    await check_change(dut, expected_change)\n    await Timer(50, units='ns')\n\n# Task to randomly cancel a purchase\nasync def random_cancel_purchase(dut):\n    item_prices = {1: 5, 2: 10, 3: 15, 4: 20}\n    item_id = random.randint(1, 4)\n    expected_price = item_prices[item_id]\n\n    dut._log.info(f\"Randomly selecting item {item_id} with price {expected_price} and canceling the operation\")\n    await select_item(dut, item_id)\n    dut.coin_input.value = 1\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 2\n    await RisingEdge(dut.clk) \n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk)\n    await cancel_purchase(dut)\n    await RisingEdge(dut.clk)\n    assert dut.error.value == 1, \"Error should be high for cancellation\"\n    await RisingEdge(dut.clk)\n    assert dut.return_money.value == 1, \"Expected money to be returned after cancellation\"\n    assert dut.error.value == 0, \"Error should not be high for cancellation after clock\"\n    await RisingEdge(dut.clk)\n    assert dut.return_money.value == 0, \"when cancle Expected money not be returned after clock\"\n    await Timer(50, units='ns')\n\n# Task to simulate invalid item selection\nasync def invalid_item_selection(dut):\n    invalid_item_id = random.choice([0,5])\n    dut._log.info(f\"Selecting invalid item ID: {invalid_item_id}\")\n    await select_item(dut, invalid_item_id)\n    dut.coin_input.value = 2\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk)\n    assert dut.error.value == 1, \"Error should be high for invalid item selection\"\n    assert dut.dispense_item.value == 0, \"No item should be dispensed\"\n    await insert_coins(dut, 0)\n    assert dut.error.value == 0, \"Error should not be high for invalid item selection after clock\" \n    await Timer(50, units='ns')\n\n# Task to simulate multiple purchases without resetting the machine\nasync def multiple_purchases_without_reset(dut):\n    for _ in range(3):  \n        await random_purchase(dut)\n        await RisingEdge(dut.clk) \n    await Timer(50, units='ns')\n\n# Task to simulate random coin validation\nasync def random_coin_validation(dut):\n    coin = random.choice([1,2,5,10]) \n    dut._log.info(f\"Inserting random coin value: {coin}\")\n\n    await select_item(dut, random.randint(1, 4)) \n    await insert_coins(dut, coin)\n    if coin == 7:\n        assert dut.error.value == 1, \"Expected error for invalid coin input\"\n    else:\n        assert dut.error.value == 0, \"Unexpected error for valid coin input\"\n    await insert_coins(dut, 0)\n    await Timer(50, units='ns')\n\nasync def reset_during_transaction(dut):\n    await select_item(dut, 3)\n    await insert_coins(dut, 5)\n    await insert_coins(dut, 0)\n    dut._log.info(\"Resetting the machine during the transaction.\")\n    dut.rst.value = 1\n    dut.item_selected.value = 0\n    await Timer(30, units='ns')\n\n    assert dut.dispense_item.value == 0, \"No item should be dispensed after reset\"\n    assert dut.return_money.value == 0, \"No money should be returned after reset\"\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n    dut._log.info(\"reset_during_transaction: Machine successfully reset during transaction.\")\n    await Timer(50, units='ns')\n\n# Task to simulate inserting coins without selecting an item\nasync def insert_coins_without_selecting_item(dut):\n    cocotb.log.info(\"Simulating coin insertion without selecting an item\")\n    await RisingEdge(dut.clk)\n    dut.item_button.value = 1   \n    dut.item_selected.value = 0\n    await RisingEdge(dut.clk)\n    dut.item_button.value = 0\n    await RisingEdge(dut.clk)\n    await insert_coins(dut, 10)\n\n    assert dut.error.value == 1, \"Error should be raised when inserting coins without selecting an item\"\n    await RisingEdge(dut.clk)  \n    assert dut.error.value == 0, \"Error should  not be raised when inserting coins without selecting an item after a clock\"\n    assert dut.return_money.value == 1, \"Money should be returned when no item is selected\"\n    await insert_coins(dut, 0)\n    await RisingEdge(dut.clk)\n\n\n    assert dut.dispense_item.value == 0, \"No item should be dispensed without item selection\"\n    assert dut.return_money.value == 0, \"Money should not be returned when no item is selected after a clock\"\n    cocotb.log.info(\"Simulating coin insertion without selecting an item: Coins returned when no item is selected.\")\n    await Timer(50, units='ns')\n\n# Task to cancel after selecting an item\nasync def cancel_after_selecting_item(dut):\n    item_id = 2\n    await select_item(dut, item_id)\n    dut._log.info(f\"Selected item {item_id}\")\n\n    dut.cancel.value = 1\n    await RisingEdge(dut.clk)\n    dut.cancel.value = 0\n    await RisingEdge(dut.clk)\n    assert dut.error.value == 1, \"Expected error signal to be set after cancellation\"\n    await RisingEdge(dut.clk)\n\n    await RisingEdge(dut.clk)\n    assert dut.error.value == 0, \"Expected error signal not be set in cancellation after a clock  \"\n    await Timer(50, units='ns')   \n\n\n# Task to insert coins without selecting an item\nasync def insert_coins_without_item_button(dut):\n    coin = 5\n    await RisingEdge(dut.clk) \n    dut.item_selected.value = 0\n    await RisingEdge(dut.clk) \n    dut.coin_input.value = coin\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk) \n    assert dut.error.value == 1, \"Expected error signal to be set when coins are inserted without item selection\"\n    dut._log.info(f\"Inserted coin: {coin} without selecting an item\")\n    await RisingEdge(dut.clk)   \n    assert dut.return_money.value == 1, \"Expected return_money signal to be high when no item selected\"\n    assert dut.error.value == 0, \"Expected error signal not be set when coins are inserted without item selection after a clock\"\n    dut._log.info(\"Coins returned successfully when inserted without item selection.\")\n    await RisingEdge(dut.clk) \n    assert dut.return_money.value == 0, \"Expected return_money signal not be high when no item selected after a clock\"\n    await Timer(50, units='ns')\n\n# Task to insert an invalid coin during payment validation\nasync def insert_invalid_coin_during_payment_validation(dut):\n    item_id = 1\n    await select_item(dut, item_id)\n    dut._log.info(f\"Selected item {item_id}\")\n    await insert_coins(dut, 1)\n    dut.coin_input.value = 3\n    await RisingEdge(dut.clk)   \n    dut.coin_input.value = 0 \n    await RisingEdge(dut.clk) \n    assert dut.return_money.value == 1, \"Expected return_money signal to be high after inserting invalid coin\"\n    assert dut.error.value == 1, \"Expected error signal to be set after inserting invalid coin\"\n    dut._log.info(\"Invalid coin insertion handled successfully.\")\n    await RisingEdge(dut.clk) \n\n    assert dut.return_money.value == 0, \"Expected return_money signal not be high after inserting invalid coin after a clock\"\n    assert dut.error.value == 0, \"Expected error signal not be set after inserting invalid coin after a clock\"\n    await Timer(50, units='ns') \n\n\n@cocotb.test()\nasync def test_vending_machine(dut):\n\n    print(\"start of vending machine\")\n\n    # Start the clock with a 10ns time period (100 MHz clock)\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.rst, duration_ns=25, active=False)\n\n    await RisingEdge(dut.clk) \n\n    await random_purchase(dut)\n\n    await random_cancel_purchase(dut)\n\n    await invalid_item_selection(dut)\n\n    await multiple_purchases_without_reset(dut)\n\n    await random_coin_validation(dut)\n\n    await reset_during_transaction(dut)\n\n    await random_purchase(dut)\n\n    await insert_coins_without_selecting_item(dut)\n\n    await cancel_after_selecting_item(dut)\n\n    await insert_coins_without_item_button(dut)\n\n    await insert_invalid_coin_during_payment_validation(dut)\n"}}}
{"id": "cvdp_copilot_wb2ahb_0004", "categories": ["cid012", "medium"], "input": {"prompt": "Write a System Verilog testbench to generate stimulus for a `wishbone_to_ahb_bridge_tb` module, which is responsible for bridging transactions between a Wishbone master and an AHB slave. \n\n## **Design Specification**\nThe `wishbone_to_ahb_bridge` module serves as a bridge between the Wishbone bus and the AMBA AHB bus, facilitating data transfers between a Wishbone master and an AHB slave. The bridge is responsible for handling address alignment, transfer size selection, and acknowledgment signaling, ensuring compatibility between the two protocols.\n\n### **Functionality**\n- The bridge takes Wishbone signals (`cyc_i`, `stb_i`, `we_i`, `sel_i`, `addr_i`, `data_i`) as inputs and converts them into AHB-compatible signals (`haddr`, `hwrite`, `hsize`, `htrans`, `hwdata`).\n- The bridge properly aligns **Wishbone byte enables (`sel_i`)** to the corresponding **AHB address and data phase transactions**.\n- Acknowledgment (`ack_o`) is generated when the **AHB slave is ready (`hready`)**, ensuring correct transaction completion.\n- Supports **single transfers** with **variable transfer sizes** (`byte`, `half-word`, `word`).\n- Includes **address holding logic** to maintain proper transactions in case of stalled AHB responses.\n\n---\n\n### Inputs\n- **Wishbone Ports (from WB Master):**\n  - `clk_i`: Clock signal for Wishbone operations.\n  - `rst_i`: Active-low reset signal to initialize the bridge.\n  - `cyc_i`: Indicates a valid Wishbone transaction cycle.\n  - `stb_i`: Strobe signal for valid data on the Wishbone interface.\n  - `sel_i[3:0]`: Byte enables to select which bytes are active.\n  - `we_i`: Write enable signal.\n  - `addr_i[31:0]`: Address for the Wishbone transaction.\n  - `data_i[31:0]`: Write data from the Wishbone master.\n- **AHB Ports (from AHB Slave):**\n  - `hclk`: Clock signal for AHB operations.\n  - `hreset_n`: Active-low reset signal for the AHB interface.\n  - `hrdata[31:0]`: Read data from the AHB slave.\n  - `hresp[1:0]`: AHB response signal.\n  - `hready`: Indicates when the AHB slave is ready.\n\n### Outputs\n- **Wishbone Outputs:**\n  - `data_o[31:0]`: Read data back to the Wishbone master.\n  - `ack_o`: Acknowledge signal for Wishbone operations.\n- **AHB Outputs:**\n  - `htrans[1:0]`: AHB transaction type.\n  - `hsize[2:0]`: Size of the AHB transfer.\n  - `hburst[2:0]`: Burst type (always single in this design).\n  - `hwrite`: Write enable signal for AHB transactions.\n  - `haddr[31:0]`: Address for the AHB transaction.\n  - `hwdata[31:0]`: Write data to the AHB slave.\n\n---\n\n## **Testbench Requirements**\n### **Instantiation**\n- The `wishbone_to_ahb_bridge` module must be instantiated as **DUT (Device Under Test)**.\n- All input and output signals should be properly connected for functional verification.\n\n### **Test Scenarios**\n#### **Clock and Reset Generation**\n- Generate two separate clocks:\n  - `clk_i` for the Wishbone interface.\n  - `hclk` for the AHB interface.\n- Implement an asynchronous reset (`rst_i` for Wishbone, `hreset_n` for AHB) at the start of the test.\n\n#### **Wishbone Transactions**\n##### **Write Transactions**\n- Perform multiple write operations using different addresses, data values, and byte enable (`sel_i`) configurations.\n- Validate the correct Wishbone to AHB conversion by checking:\n  - Address alignment\n  - Transfer size selection (`hsize`)\n  - Data transfer correctness (`hwdata`)\n  - Acknowledgment (`ack_o`)\n- Include test cases for:\n  - Byte writes (`sel_i = 4'b0001, 4'b0010, 4'b0100, 4'b1000`)\n  - Half-word writes (`sel_i = 4'b0011, 4'b1100`)\n  - Word writes (`sel_i = 4'b1111`)\n\n##### **Read Transactions**\n- Perform read operations using different addresses.\n- Ensure correct data retrieval from the AHB slave (`hrdata` \u2192 `data_o`).\n- Verify acknowledgment timing.\n\n#### **Address Alignment and Endianness Handling**\n- Check how the bridge modifies Wishbone addresses to match AHB alignment rules.\n- Ensure that byte and half-word transfers properly align data in `hwdata` and `data_o`.\n\n#### **AHB Protocol Compliance**\n- Validate the AHB transaction type (`htrans`) for different Wishbone operations:\n  - Idle (2'b00)\n  - Non-sequential (2'b10)\n  - Sequential (2'b11) \u2013 if burst support is added in the future\n- Verify proper operation of:\n  - AHB Ready Handling (`hready`):\n    - Ensure bridge correctly waits for `hready` before transferring data.\n  - AHB Response Handling (`hresp`):\n    - Include test cases where the AHB slave returns an error response (`hresp = 2'b01`).\n    - Check whether the bridge correctly stalls and recovers from such conditions.\n\n#### **Error and Recovery Handling**\n- AHB Error (`hresp = 2'b01`)\n  - Ensure the bridge correctly halts and resets the transaction.\n- AHB Busy Handling (`hready = 0`)\n  - Verify that the bridge waits and resumes when `hready` becomes `1`.\n\n---", "context": {}}, "output": {"response": "", "context": {"verif/wishbone_to_ahb_bridge_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n      ", "src/.env": "HASH   = 79a49dacf494628b34940c5fff404004e443b3af\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    ", "src/wishbone_to_ahb_bridge.sv": "`timescale 1ns / 1ps\n\nmodule wishbone_to_ahb_bridge\n  // Wishbone ports from WB master\n (\n  input  clk_i,             // Clock input for Wishbone\n  input  rst_i,             // Reset input for Wishbone\n  input  cyc_i,             // Cycle signal from Wishbone master\n  input  stb_i,             // Strobe signal from Wishbone master\n  input  [3:0] sel_i,       // Byte enable signals from Wishbone master\n  input  we_i,              // Write enable signal from Wishbone master\n  input  [31:0] addr_i,     // Address signal from Wishbone master\n  input  [31:0] data_i,     // Data signal from Wishbone master\n  output reg [31:0] data_o, // Data output to Wishbone master\n  output ack_o,             // Acknowledgment signal to Wishbone master\n\n  // AHB ports to AHB slave\n  input  hclk,              // Clock input for AHB\n  input  hreset_n,          // Reset input for AHB (active low)\n  input  [31:0] hrdata,     // Data input from AHB slave\n  input [1:0] hresp,        // Response signal from AHB slave\n  input hready,             // Ready signal from AHB slave\n  output [1:0] htrans,      // Transfer type signal for AHB\n  output [2:0] hsize,       // Transfer size signal for AHB\n  output [2:0] hburst,      // Burst type signal for AHB (always SINGLE)\n  output hwrite,            // Write signal for AHB\n  output [31:0] haddr,      // Address signal for AHB\n  output reg [31:0] hwdata  // Data output to AHB slave\n);\n\n// Internal signals\nreg ahb_prev_addr_hold;  // Holds the address phase state\nreg ahb_data_phase;      // Indicates data phase\nreg [1:0] trans;         // Transfer type (Idle, Non-sequential, etc.)\nreg [2:0] size;          // Transfer size (Byte, Half-word, Word)\nreg [31:0] addr_hold;    // Holds the address during wait states\nreg [1:0] trans_hold;    // Holds transfer type during wait states\nreg [2:0] size_hold;     // Holds transfer size during wait states\nreg write_hold;          // Holds write signal during wait states\nreg [31:0] wb_adr_fixed; // Fixed Wishbone address after alignment\n\n// Fix up the Wishbone address\n// Aligns the Wishbone address based on byte enables (sel_i)\nalways @(*) begin\n  wb_adr_fixed[31:2] = addr_i[31:2]; \n\n  case (sel_i)\n    4'b0001: wb_adr_fixed[1:0] = 2'b00; \n    4'b0010: wb_adr_fixed[1:0] = 2'b01;\n    4'b0100: wb_adr_fixed[1:0] = 2'b10;\n    4'b1000: wb_adr_fixed[1:0] = 2'b11;\n    4'b0011: wb_adr_fixed[1:0] = 2'b00; \n    4'b1100: wb_adr_fixed[1:0] = 2'b10;\n    4'b1111: wb_adr_fixed[1:0] = 2'b00; \n    default: wb_adr_fixed[1:0] = addr_i[1:0]; \n  endcase\nend\n\nalways @(posedge hclk or negedge hreset_n) begin\n  if (!hreset_n)\n    ahb_prev_addr_hold <= 0;\n  else if (!ahb_data_phase & stb_i & cyc_i & !hready)\n    ahb_prev_addr_hold <= 1; \n  else\n    ahb_prev_addr_hold <= 0; \nend\n\nassign haddr  = ahb_prev_addr_hold ? addr_hold : wb_adr_fixed;\nassign htrans = ahb_prev_addr_hold ? trans_hold : trans;\nassign hsize  = ahb_prev_addr_hold ? size_hold : size;\nassign hwrite = ahb_prev_addr_hold ? write_hold : we_i;\nassign ack_o = ahb_data_phase ? hready : 0; \n\nassign hburst = 3'b000; // Fixed burst type (SINGLE)\n\nalways @(*) begin\n  case (sel_i)\n    4'b0001, 4'b0010, 4'b0100, 4'b1000: begin \n      hwdata = { data_i[7:0], data_i[15:8], data_i[23:16], data_i[31:24] };\n      data_o = { hrdata[7:0], hrdata[15:8], hrdata[23:16], hrdata[31:24] };\n    end\n    4'b0011, 4'b1100: begin \n      hwdata = { data_i[15:0], data_i[31:16] };\n      data_o = { hrdata[15:0], hrdata[31:16] };\n    end\n    default: begin \n      hwdata = data_i;\n      data_o = hrdata;\n    end\n  endcase\nend\n\nalways @(posedge hclk or negedge hreset_n) begin\n  if (!hreset_n)\n    ahb_data_phase <= 0;\n  else if (ahb_data_phase & hready)\n    ahb_data_phase <= 0; \n  else if (!ahb_data_phase & cyc_i & stb_i & hready)\n    ahb_data_phase <= 1; \nend\n\nalways @(posedge hclk or negedge hreset_n) begin\n  if (!hreset_n) begin\n    addr_hold  <= 0;\n    trans_hold <= 0;\n    size_hold  <= 0;\n    write_hold <= 0;\n  end else if (!ahb_prev_addr_hold) begin\n    addr_hold  <= wb_adr_fixed;\n    trans_hold <= trans;\n    size_hold  <= size;\n    write_hold <= we_i;\n  end\nend\n\nalways @(*) begin\n  if (ahb_data_phase)\n    trans = 2'b00; \n  else if (cyc_i) begin\n    if (stb_i)\n      trans = 2'b10; \n    else\n      trans = 2'b01; \n  end else\n    trans = 2'b00; \nend\n\nalways @(*) begin\n  case (sel_i)\n    4'b0001, 4'b0010, 4'b0100, 4'b1000: size = 3'b000; \n    4'b0011, 4'b1100: size = 3'b001; \n    4'b1111: size = 3'b010; \n    default: size = 3'b010; \n  endcase\nend\n\nendmodule"}}}
{"id": "cvdp_copilot_wb2ahb_0005", "categories": ["cid014", "medium"], "input": {"prompt": "Create SystemVerilog Assertions (SVA) to verify the correctness of **Wishbone to AHB bridge transactions**. The properties should ensure that Wishbone transactions are correctly translated into AHB transactions and that the interface remains stable and functional under all conditions. Assertions must be created to verify that the bridge operates as expected across different transfer types, alignment scenarios, and handshake signals.\n\n## **Expected Behavior**\nEach assertion should validate the correctness of data transfer, handshake signals, and address alignment. In case of failure, the error message must include relevant details such as address, data, control signals, and handshake status for debugging purposes.\n\n## **RTL Specification**\nThe **Wishbone to AHB Bridge** module converts Wishbone bus transactions into AHB-compliant transactions. It supports single transfers, address alignment, and optional endianness conversion.\n\n### Inputs\n- **Wishbone Ports (from WB Master):**\n  - `clk_i`: Clock signal for Wishbone operations.\n  - `rst_i`: Active-low reset signal to initialize the bridge.\n  - `cyc_i`: Indicates a valid Wishbone transaction cycle.\n  - `stb_i`: Strobe signal for valid data on the Wishbone interface.\n  - `sel_i[3:0]`: Byte enables to select which bytes are active.\n  - `we_i`: Write enable signal.\n  - `addr_i[31:0]`: Address for the Wishbone transaction.\n  - `data_i[31:0]`: Write data from the Wishbone master.\n- **AHB Ports (from AHB Slave):**\n  - `hclk`: Clock signal for AHB operations.\n  - `hreset_n`: Active-low reset signal for the AHB interface.\n  - `hrdata[31:0]`: Read data from the AHB slave.\n  - `hresp[1:0]`: AHB response signal.\n  - `hready`: Indicates when the AHB slave is ready.\n\n### Outputs\n- **Wishbone Outputs:**\n  - `data_o[31:0]`: Read data back to the Wishbone master.\n  - `ack_o`: Acknowledge signal for Wishbone operations.\n- **AHB Outputs:**\n  - `htrans[1:0]`: AHB transaction type.\n  - `hsize[2:0]`: Size of the AHB transfer.\n  - `hburst[2:0]`: Burst type (always single in this design).\n  - `hwrite`: Write enable signal for AHB transactions.\n  - `haddr[31:0]`: Address for the AHB transaction.\n  - `hwdata[31:0]`: Write data to the AHB slave.\n\n---\n\n## **Assertions to be Verified**\nThe following properties should be verified using **SystemVerilog Assertions**:\n\n1. **Write Operation Verification:**  \n\n  - Ensure that when Wishbone requests a write (`cyc_i && stb_i && we_i`), the AHB `hwrite` signal is correctly asserted.\n\n   \n2. **Address Alignment Verification:**  \n\n  - Check that the translated Wishbone address (`wb_adr_fixed`) is properly aligned and matches the AHB address (`haddr`).\n\n3. **Read Operation Verification:**  \n\n  - Ensure that a valid Wishbone read (`cyc_i && stb_i && !we_i`) results in `data_o` receiving the correct `hrdata`.\n\n4. **Data Phase Verification:**  \n\n  - Ensure that once the AHB transaction enters the **data phase**, the `hready` signal is asserted.\n\n5. **AHB Transfer Type Validation:**  \n\n  - Ensure that when a Wishbone transaction is active, the corresponding AHB `htrans` signal is **not IDLE (`2'b00`)**.\n\n6. **Acknowledgment Verification:**  \n\n  - Ensure that every Wishbone transaction (`cyc_i && stb_i`) results in an acknowledgment (`ack_o`).\n\n7. **AHB Response Validation:**  \n\n  - Ensure that AHB does not return an **error response (`hresp != 2'b01`)**.\n\nEach assertion should include a **failure message** with key debugging information in case of assertion failure.", "context": {"rtl/wishbone_to_ahb_bridge.sv": "`timescale 1ns / 1ps\n\nmodule wishbone_to_ahb_bridge\n  // Wishbone ports from WB master\n (\n  input  clk_i,             // Clock input for Wishbone\n  input  rst_i,             // Reset input for Wishbone\n  input  cyc_i,             // Cycle signal from Wishbone master\n  input  stb_i,             // Strobe signal from Wishbone master\n  input  [3:0] sel_i,       // Byte enable signals from Wishbone master\n  input  we_i,              // Write enable signal from Wishbone master\n  input  [31:0] addr_i,     // Address signal from Wishbone master\n  input  [31:0] data_i,     // Data signal from Wishbone master\n  output reg [31:0] data_o, // Data output to Wishbone master\n  output ack_o,             // Acknowledgment signal to Wishbone master\n\n  // AHB ports to AHB slave\n  input  hclk,              // Clock input for AHB\n  input  hreset_n,          // Reset input for AHB (active low)\n  input  [31:0] hrdata,     // Data input from AHB slave\n  input [1:0] hresp,        // Response signal from AHB slave\n  input hready,             // Ready signal from AHB slave\n  output [1:0] htrans,      // Transfer type signal for AHB\n  output [2:0] hsize,       // Transfer size signal for AHB\n  output [2:0] hburst,      // Burst type signal for AHB (always SINGLE)\n  output hwrite,            // Write signal for AHB\n  output [31:0] haddr,      // Address signal for AHB\n  output reg [31:0] hwdata  // Data output to AHB slave\n);\n\n// Internal signals\nreg ahb_prev_addr_hold;  // Holds the address phase state\nreg ahb_data_phase;      // Indicates data phase\nreg [1:0] trans;         // Transfer type (Idle, Non-sequential, etc.)\nreg [2:0] size;          // Transfer size (Byte, Half-word, Word)\nreg [31:0] addr_hold;    // Holds the address during wait states\nreg [1:0] trans_hold;    // Holds transfer type during wait states\nreg [2:0] size_hold;     // Holds transfer size during wait states\nreg write_hold;          // Holds write signal during wait states\nreg [31:0] wb_adr_fixed; // Fixed Wishbone address after alignment\n\n// Fix up the Wishbone address\n// Aligns the Wishbone address based on byte enables (sel_i)\nalways @(*) begin\n  wb_adr_fixed[31:2] = addr_i[31:2]; \n\n  case (sel_i)\n    4'b0001: wb_adr_fixed[1:0] = 2'b00; \n    4'b0010: wb_adr_fixed[1:0] = 2'b01;\n    4'b0100: wb_adr_fixed[1:0] = 2'b10;\n    4'b1000: wb_adr_fixed[1:0] = 2'b11;\n    4'b0011: wb_adr_fixed[1:0] = 2'b00; \n    4'b1100: wb_adr_fixed[1:0] = 2'b10;\n    4'b1111: wb_adr_fixed[1:0] = 2'b00; \n    default: wb_adr_fixed[1:0] = addr_i[1:0]; \n  endcase\nend\n\nalways @(posedge hclk or negedge hreset_n) begin\n  if (!hreset_n)\n    ahb_prev_addr_hold <= 0;\n  else if (!ahb_data_phase & stb_i & cyc_i & !hready)\n    ahb_prev_addr_hold <= 1; \n  else\n    ahb_prev_addr_hold <= 0; \nend\n\nassign haddr  = ahb_prev_addr_hold ? addr_hold : wb_adr_fixed;\nassign htrans = ahb_prev_addr_hold ? trans_hold : trans;\nassign hsize  = ahb_prev_addr_hold ? size_hold : size;\nassign hwrite = ahb_prev_addr_hold ? write_hold : we_i;\nassign ack_o = ahb_data_phase ? hready : 0; \n\nassign hburst = 3'b000; // Fixed burst type (SINGLE)\n\nalways @(*) begin\n  case (sel_i)\n    4'b0001, 4'b0010, 4'b0100, 4'b1000: begin \n      hwdata = { data_i[7:0], data_i[15:8], data_i[23:16], data_i[31:24] };\n      data_o = { hrdata[7:0], hrdata[15:8], hrdata[23:16], hrdata[31:24] };\n    end\n    4'b0011, 4'b1100: begin \n      hwdata = { data_i[15:0], data_i[31:16] };\n      data_o = { hrdata[15:0], hrdata[31:16] };\n    end\n    default: begin \n      hwdata = data_i;\n      data_o = hrdata;\n    end\n  endcase\nend\n\nalways @(posedge hclk or negedge hreset_n) begin\n  if (!hreset_n)\n    ahb_data_phase <= 0;\n  else if (ahb_data_phase & hready)\n    ahb_data_phase <= 0; \n  else if (!ahb_data_phase & cyc_i & stb_i & hready)\n    ahb_data_phase <= 1; \nend\n\nalways @(posedge hclk or negedge hreset_n) begin\n  if (!hreset_n) begin\n    addr_hold  <= 0;\n    trans_hold <= 0;\n    size_hold  <= 0;\n    write_hold <= 0;\n  end else if (!ahb_prev_addr_hold) begin\n    addr_hold  <= wb_adr_fixed;\n    trans_hold <= trans;\n    size_hold  <= size;\n    write_hold <= we_i;\n  end\nend\n\nalways @(*) begin\n  if (ahb_data_phase)\n    trans = 2'b00; \n  else if (cyc_i) begin\n    if (stb_i)\n      trans = 2'b10; \n    else\n      trans = 2'b01; \n  end else\n    trans = 2'b00; \nend\n\nalways @(*) begin\n  case (sel_i)\n    4'b0001, 4'b0010, 4'b0100, 4'b1000: size = 3'b000; \n    4'b0011, 4'b1100: size = 3'b001; \n    4'b1111: size = 3'b010; \n    default: size = 3'b010; \n  endcase\nend\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/wishbone_to_ahb_bridge.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 80\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/wishbone_to_ahb_bridge.sv\nTOPLEVEL        = wishbone_to_ahb_bridge\nMODULE          = test_wishbone_to_ahb_bridge\nPYTHONPATH      = /src\nHASH            = f6dc856cdfaa180c18ddbd0c84acbf3ee1aaa41b\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 2, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n            ", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_wishbone_to_ahb_bridge.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nimport harness_library as hrs_lb\n@cocotb.test()\nasync def test_wishbone_to_ahb_bridge(dut):\n    \"\"\"Testbench for Wishbone-to-AHB Bridge\"\"\"\n\n    # Clock generation\n    cocotb.start_soon(Clock(dut.clk_i, 10, units=\"ns\").start())\n    cocotb.start_soon(Clock(dut.hclk, 10, units=\"ns\").start())\n\n    # Initialize inputs\n    dut.rst_i.value = 1\n    dut.cyc_i.value = 0\n    dut.stb_i.value = 0\n    dut.sel_i.value = 0b1111\n    dut.we_i.value = 0\n    dut.addr_i.value = 0\n    dut.data_i.value = 0\n    dut.hreset_n.value = 0\n    dut.hrdata.value = 0\n    dut.hresp.value = 0b00\n    dut.hready.value = 1\n\n    # Reset pulse\n    await Timer(20, units=\"ns\")\n    dut.rst_i.value = 0\n    dut.hreset_n.value = 1\n    await Timer(20, units=\"ns\")\n    dut.rst_i.value = 1\n\n    # Test 1: Write operation\n    await RisingEdge(dut.clk_i)\n    dut.cyc_i.value = 1\n    dut.stb_i.value = 1\n    dut.we_i.value = 1\n    dut.addr_i.value = 0x10000000\n    dut.data_i.value = 0xDEADBEEF\n\n    await RisingEdge(dut.hclk)\n    dut.hready.value = 0  # Simulate wait state\n    await RisingEdge(dut.hclk)\n    dut.hready.value = 1  # Simulate transfer completion\n\n    # Check AHB outputs for write\n    assert dut.hwrite.value == 1, f\"ERROR: hwrite should be 1, got {dut.hwrite.value}\"\n    assert dut.haddr.value == 0x10000000, f\"ERROR: haddr should be 0x10000000, got {hex(dut.haddr.value)}\"\n    assert dut.hwdata.value == 0xDEADBEEF, f\"ERROR: hwdata should be 0xDEADBEEF, got {hex(dut.hwdata.value)}\"\n    dut._log.info(f\"[CHECK] AHB outputs for write correctly set: dut.hwdata.value = {int(dut.hwdata.value)}, dut.hwrite.value = {int(dut.hwrite.value)}, dut.haddr.value = {int(dut.haddr.value)}\")\n\n    cocotb.log.info(\"PASS: Write operation successful\")\n\n    await RisingEdge(dut.clk_i)\n    dut.stb_i.value = 0\n    dut.cyc_i.value = 0\n\n    # Test 2: Read operation\n    await RisingEdge(dut.clk_i)\n    dut.cyc_i.value = 1\n    dut.stb_i.value = 1\n    dut.we_i.value = 0\n    dut.addr_i.value = 0x20000000\n    dut.hrdata.value = 0xCAFEBABE  # AHB slave data\n\n    await RisingEdge(dut.hclk)\n    dut.hready.value = 0  # Simulate wait state\n    await RisingEdge(dut.hclk)\n    dut.hready.value = 1  # Simulate transfer completion\n\n    # Check Wishbone outputs for read\n    assert dut.data_o.value == 0xCAFEBABE, f\"ERROR: data_o should be 0xCAFEBABE, got {hex(dut.data_o.value)}\"\n    dut._log.info(f\"[CHECK] Wishbone outputs for read correctly set: dut.data_o.value = {int(dut.data_o.value)}\")\n\n    cocotb.log.info(\"PASS: Read operation successful\")\n\n    await RisingEdge(dut.clk_i)\n    dut.stb_i.value = 0\n    dut.cyc_i.value = 0\n\n    cocotb.log.info(\"Test complete\")\n"}}}
{"id": "cvdp_copilot_word_change_detector_0012", "categories": ["cid012", "medium"], "input": {"prompt": "\nComplete the Given Partial System Verilog Testbench `tb_Word_Change_Pulse`.  The testbench must instantiate the `Word_Change_Pulse` RTL module and provide input stimulus to validate its behavior. This module detects word changes and pattern matches in a DATA_WIDTH-bit data stream based on a specified mask and pattern.\n\n## Description\n\n**Parameters:**\n- `DATA_WIDTH`: Specifies the bit width of the input data word `data_in`. Default is 8. It must be a positive integer greater than or equal to 1.\n\n**Inputs:**\n- `clk`: Clock signal for synchronizing operations. The design is synchronized to the positive edge of this clock.\n- `reset`:Active-high asynchronous reset signal to initialize the module.\n- `data_in [DATA_WIDTH-1:0]`: Input data word whose changes are to be detected.\n- `mask [DATA_WIDTH-1:0]`: Mask signal to enable/disable change detection per bit (1 = detect changes, 0 = ignore changes)\n- `match_pattern [DATA_WIDTH-1:0]`: Pattern to compare against the (masked) input data word.\n- `enable`: Active-high signal, which enables the module\u2019s operation.\n- `latch_pattern`: When high, latches the current match_pattern into an internal register.\n\n**Outputs:**\n- `word_change_pulse`: Output signal that pulses high one clock cycle after any bit in data_in changes.\n- `pattern_match_pulse`: Pulses high to indicate the masked input data word matches the latched pattern.\n- `latched_pattern [DATA_WIDTH-1:0]`: Register that holds the latched pattern for comparison\n\n## Module Functionality\nThe Word_Change_Pulse module should perform the following:\n- **Pattern Latching**: When latch_pattern is asserted, match_pattern should be stored in latched_pattern.\n- **Word Change Detection**: The word_change_pulse should be asserted if any masked bit in data_in differs from data_in_prev.\n- **Pattern Match Detection**: The pattern_match_pulse should be asserted if the masked bits of data_in match latched_pattern.\n- **Enable Control**: If enable = 0, pulses should not be generated.\n- **Reset Behavior**: Upon assertion of reset, all outputs should be initialized to zero.\n\n## Instantiation\nThe testbench should instantiate the Word_Change_Pulse module as `uut` and connect the signals accordingly.\n\n## Input Generation \n\n### Clock Generation\nThe clk signal should toggle every 5 time units, resulting in a 100MHz operation.\n\n### Reset Handling\nThe reset signal should be asserted at the beginning of the simulation for three cycles. It should then be de-asserted, ensuring the DUT starts in a known state.\n\n### Stimulus \nSeveral test cases are applied to simulate different operations of the Word_Change_Pulse module. These cases cover a range of scenarios, including detecting word changes, pattern matching, masking behavior, enable-based operations, and edge cases.\n\n### Test Phases\nThe testbench should consist of multiple test phases, each targeting different behaviors of the module:\n\n#### Phase 1: Default Pattern Latching\nLatch a pattern of all zeros (00000000).  \n\n#### Phase 2: Word Change Pulse Tests\n- All bits transition from 0 \u2192 1.\n- All bits transition from 1 \u2192 0.\n- Single-bit flips (LSB, MSB).\n- Alternating bit patterns.\n- No changes in data_in (pulse should not be triggered).\n\n#### Phase 3: Pattern Match Pulse Tests\nLatch a specific pattern. \nApply data_in values that:\n- Match the pattern with the full mask.\n- Mismatch with full mask.\n- Partial match with partial mask.\n\n#### Phase 4: Masking Behavior\n- **Full Mask**: mask = 8'b11111111\n- **No Mask**: mask = 8'b00000000 (should suppress pulses).\n- **Random Mask Values**: Generate correct selective comparison.\n\n#### Phase 5: Enable Control\nRun tests with enable = 0 to ensure no pulses are generated.\n\n#### Phase 6: Generate Word Change and Pattern Match Pulses with Masking\n- No Change Scenario.\n- Single-Bit Transitions.\n-  Multiple-Bit Transitions.\n- Fully Masked Changes.\n- Pattern Match Case Without Changes.\n- Partial Mask and Upper Bits Transition.\n\n#### Phase 7: Stress Testing\n- Apply randomized data sequences over 100 cycles.\n- Introduce delays and glitches.\n\n### Final Steps \n- Waveform Dump: Generate a VCD file (Word_Change_Pulse.vcd) for visualization.\n\n### Partial Test Stimulus Generator Code :\n\n\n```verilog\nmodule tb_Word_Change_Pulse;\n\n    // Parameters\n    parameter DATA_WIDTH = 8;\n\n    // Testbench Signals\n    reg clk;\n    reg reset;\n    reg enable;\n    reg latch_pattern;\n    reg [DATA_WIDTH-1:0] data_in;\n    reg [DATA_WIDTH-1:0] mask;\n    reg [DATA_WIDTH-1:0] match_pattern;\n    reg [DATA_WIDTH-1:0] data_in_prev;\n    wire word_change_pulse;\n    wire pattern_match_pulse;\n    wire [DATA_WIDTH-1:0] latched_pattern;\n\n\n    // Instantiate the DUT\n    Word_Change_Pulse #(\n        .DATA_WIDTH(DATA_WIDTH)\n    ) dut (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .latch_pattern(latch_pattern),\n        .data_in(data_in),\n        .mask(mask),\n        .match_pattern(match_pattern),\n        .word_change_pulse(word_change_pulse),\n        .pattern_match_pulse(pattern_match_pulse),\n        .latched_pattern(latched_pattern)\n    );\n\n    // Clock Generation\n    initial clk = 0;\n    always #5 clk = ~clk;\n\n    task run_test(\n        input [DATA_WIDTH-1:0] test_data,\n        input [DATA_WIDTH-1:0] test_mask,\n        input [DATA_WIDTH-1:0] test_pattern,\n        input string testcase_name,\n        input reg test_enabled\n    );\n        begin\n            @(posedge clk);\n            data_in = test_data;\n            mask = test_mask;\n            match_pattern = test_pattern;\n            enable = test_enabled;\n            @(posedge clk);\n            $display(\"%s: data_in=%b, mask=%b, enable=%b -> word change pulse=%b\", \n                         testcase_name, test_data, test_mask, enable, word_change_pulse);\n        end\n    endtask\n\n    // Insert the code for the remaining test stimulus here\n\nendmodule\n```", "context": {}}, "output": {"response": "", "context": {"verif/tb_WordChangePulseGenerator.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro \n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = cd333cb68f0c2cced622013cbe0e25f802d5e693\nTARGET = 90\n", "src/Word_Change_Pulse.sv": "// Word_Change_Pulse Module with Maskable Input, Pattern Matching, and Advanced Features\nmodule Word_Change_Pulse #(\n    parameter DATA_WIDTH = 8 // Default word width\n) (\n    input  wire                  clk,               // Clock signal for synchronizing operations\n    input  wire                  reset,             // Reset signal to initialize the module\n    input  wire [DATA_WIDTH-1:0] data_in,           // Input data, width defined by parameter DATA_WIDTH\n    input  wire [DATA_WIDTH-1:0] mask,              // Mask signal to enable/disable change detection for each bit\n    input  wire [DATA_WIDTH-1:0] match_pattern,     // Pattern to match for generating the pulse\n    input  wire                  enable,            // Enable signal to allow module operation\n    input  wire                  latch_pattern,     // Signal to latch the match pattern\n    output reg                   word_change_pulse, // Output signal indicating a change in any bit of data_in\n    output reg                   pattern_match_pulse, // Output signal indicating a match with the pattern\n    output reg [DATA_WIDTH-1:0]  latched_pattern    // Latched pattern for comparison\n);\n\n    wire [DATA_WIDTH-1:0] change_pulses;\n\n    reg [DATA_WIDTH-1:0] masked_data_in;\n    reg [DATA_WIDTH-1:0] masked_change_pulses;\n    reg                  match_detected;\n\n    genvar i;\n    generate\n        for (i = 0; i < DATA_WIDTH; i = i + 1) begin : change_detectors\n            Bit_Change_Detector u_single_bit_change_detector (\n                .clk          (clk),\n                .reset        (reset),\n                .bit_in       (data_in[i]),\n                .change_pulse (change_pulses[i])\n            );\n        end\n    endgenerate\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            masked_data_in <= {DATA_WIDTH{1'b0}};\n            masked_change_pulses <= {DATA_WIDTH{1'b0}};\n            word_change_pulse <= 1'b0;\n            match_detected <= 1'b0;\n            pattern_match_pulse <= 1'b0;\n            latched_pattern <= {DATA_WIDTH{1'b0}};\n        end else if (enable) begin\n            if (latch_pattern) begin\n                latched_pattern <= match_pattern;\n            end\n            if (match_detected) begin\n            pattern_match_pulse <= 1'b1;\n            end else begin \n            pattern_match_pulse <= 1'b0;\n            end\n            masked_data_in <= data_in & mask;\n            masked_change_pulses <= change_pulses & mask;\n            word_change_pulse <= |masked_change_pulses;\n            match_detected <= (masked_data_in == (latched_pattern & mask));\n        end else begin\n            masked_data_in <= {DATA_WIDTH{1'b0}};\n            masked_change_pulses <= {DATA_WIDTH{1'b0}};\n            word_change_pulse <= 1'b0;\n            match_detected <= 1'b0;\n            pattern_match_pulse <= 1'b0;\n            latched_pattern <= {DATA_WIDTH{1'b0}};\n        end\n    end\n\nendmodule\n\n// Bit_Change_Detector Module\nmodule Bit_Change_Detector (\n    input  wire clk,         // Clock signal\n    input  wire reset,       // Reset signal to initialize the module\n    input  wire bit_in,      // Single bit input to detect changes\n    output reg  change_pulse // Pulse signal indicating a change in the input bit\n);\n\n    reg bit_in_d;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            bit_in_d <= 1'b0;\n            change_pulse <= 1'b0;\n        end else begin\n            bit_in_d <= bit_in; \n        end\n    end\n\n    always @(*) begin\n        change_pulse = (bit_in != bit_in_d); \n    end\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        while len(info) < 3:\n            info.append(\"0%\")\n\n        inst = re.sub(r'[\\W]', '', info[0])\n\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'uut' is missing in the coverage log.\")\n\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))  \n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['uut']['Average']}, Target: {target}\"\n"}}}
{"id": "cvdp_copilot_word_change_detector_0015", "categories": ["cid014", "easy"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the `Word_Change_Pulse` module based on the design specifications provided? Below are the module details and design requirements for assertion development.\n\n## Interface\n\n**Parameters:**\n- `DATA_WIDTH`: Specifies the bit width of the input data word `data_in`. Default is 8. It must be a positive integer greater than or equal to 1.\n\n**Inputs:**\n- `clk`: Clock signal for synchronizing operations. The design is synchronized to the positive edge of this clock.\n- `reset`:Active-high asynchronous reset signal to initialize the module.\n- `data_in [DATA_WIDTH-1:0]`: Input data word whose changes are to be detected.\n- `mask [DATA_WIDTH-1:0]`: Mask signal to enable/disable change detection per bit (1 = detect changes, 0 = ignore changes)\n- `match_pattern [DATA_WIDTH-1:0]`: Pattern to compare against the (masked) input data word.\n- `enable (1-bit)`: Active-high signal, which enables the module\u2019s operation.\n- `latch_pattern (1-bit) `: When high, latches the current match_pattern into an internal register.\n\n**Outputs:**\n- `word_change_pulse (1-bit)`: Output signal that pulses high one clock cycle after any bit in data_in changes.\n- `pattern_match_pulse (1-bit)`: Pulses high to indicate the masked input data word matches the latched pattern.\n- `latched_pattern [DATA_WIDTH-1:0]`: Register that holds the latched pattern for comparison\n\n# Design Specifications\n\nThe `Word_Change_Pulse` module monitors each bit of the input data word by using multiple Bit_Change_Detector instances, one for each bit. Each Bit_Change_Detector watches for changes in its respective bit and signals when a change occurs. The module applies a mask to determine which bits should be actively monitored for changes. When any of the masked bits change, the word_change_pulse is triggered to indicate that a change has been detected. Additionally, the module can latch a specific pattern when the latch_pattern signal is high, and it continuously compares the masked input data against this latched pattern. If the masked input matches the latched pattern, a pattern_match_pulse is generated. The entire operation is controlled by an enable signal, allowing the monitoring functionality to be turned on or off as needed. The module also includes a reset mechanism to initialize or clear all internal states and outputs.\n\n# Assertion Requirements\n\nDevelop a set of SystemVerilog assertions to validate the following behaviors:\n\n## 1. Word Change Pulse Assertion\n- Ensures that `word_change_pulse` is triggered whenever there is a change in the `data_in` signal while the module is active.\n- The change detection is applied only to the bits that are enabled by the mask.\n- When a valid bit transition occurs, the assertion checks whether the `word_change_pulse` is generated within one clock cycle.\n\n## 2. Pattern Match Assertion\n- `pattern_match_pulse` is correctly generated when the `data_in` signal matches the latched pattern, considering only the bits enabled by the mask.\n- The assertion ensures that when the masked `data_in` equals the masked `latched_pattern`, the `pattern_match_pulse` is asserted within one clock cycle.\n\n## 3. No Pulse When Disabled\n- Ensures that no pulses are generated when the module is disabled.\n- It checks that both `word_change_pulse` and `pattern_match_pulse` remain de-asserted when the module is not active.\n\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry best practices for concise and effective verification.", "context": {"rtl/Word_Change_Pulse.sv": "// Word_Change_Pulse Module with Maskable Input, Pattern Matching, and Advanced Features\nmodule Word_Change_Pulse #(\n    parameter DATA_WIDTH = 8 // Default word width\n) (\n    input  wire                  clk,               // Clock signal for synchronizing operations\n    input  wire                  reset,             // Reset signal to initialize the module\n    input  wire [DATA_WIDTH-1:0] data_in,           // Input data, width defined by parameter DATA_WIDTH\n    input  wire [DATA_WIDTH-1:0] mask,              // Mask signal to enable/disable change detection for each bit\n    input  wire [DATA_WIDTH-1:0] match_pattern,     // Pattern to match for generating the pulse\n    input  wire                  enable,            // Enable signal to allow module operation\n    input  wire                  latch_pattern,     // Signal to latch the match pattern\n    output reg                   word_change_pulse, // Output signal indicating a change in any bit of data_in\n    output reg                   pattern_match_pulse, // Output signal indicating a match with the pattern\n    output reg [DATA_WIDTH-1:0]  latched_pattern    // Latched pattern for comparison\n);\n\n    wire [DATA_WIDTH-1:0] change_pulses;\n\n    reg [DATA_WIDTH-1:0] masked_data_in;\n    reg [DATA_WIDTH-1:0] masked_change_pulses;\n    reg                  match_detected;\n\n    genvar i;\n    generate\n        for (i = 0; i < DATA_WIDTH; i = i + 1) begin : change_detectors\n            Bit_Change_Detector u_single_bit_change_detector (\n                .clk          (clk),\n                .reset        (reset),\n                .bit_in       (data_in[i]),\n                .change_pulse (change_pulses[i])\n            );\n        end\n    endgenerate\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            masked_data_in <= {DATA_WIDTH{1'b0}};\n            masked_change_pulses <= {DATA_WIDTH{1'b0}};\n            word_change_pulse <= 1'b0;\n            match_detected <= 1'b0;\n            pattern_match_pulse <= 1'b0;\n            latched_pattern <= {DATA_WIDTH{1'b0}};\n        end else if (enable) begin\n            if (latch_pattern) begin\n                latched_pattern <= match_pattern;\n            end\n            if (match_detected) begin\n            pattern_match_pulse <= 1'b1;\n            end else begin \n            pattern_match_pulse <= 1'b0;\n            end\n            masked_data_in <= data_in & mask;\n            masked_change_pulses <= change_pulses & mask;\n            word_change_pulse <= |masked_change_pulses;\n            match_detected <= (masked_data_in == (latched_pattern & mask));\n        end else begin\n            masked_data_in <= {DATA_WIDTH{1'b0}};\n            masked_change_pulses <= {DATA_WIDTH{1'b0}};\n            word_change_pulse <= 1'b0;\n            match_detected <= 1'b0;\n            pattern_match_pulse <= 1'b0;\n            latched_pattern <= {DATA_WIDTH{1'b0}};\n        end\n    end\n\nendmodule\n\n// Bit_Change_Detector Module\nmodule Bit_Change_Detector (\n    input  wire clk,         // Clock signal\n    input  wire reset,       // Reset signal to initialize the module\n    input  wire bit_in,      // Single bit input to detect changes\n    output reg  change_pulse // Pulse signal indicating a change in the input bit\n);\n\n    reg bit_in_d;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            bit_in_d <= 1'b0;\n            change_pulse <= 1'b0;\n        end else begin\n            bit_in_d <= bit_in; \n        end\n    end\n\n    always @(*) begin\n        change_pulse = (bit_in != bit_in_d); \n    end\nendmodule"}}, "output": {"response": "", "context": {"rtl/Word_Change_Pulse.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/Word_Change_Pulse.sv\nTOPLEVEL        = Word_Change_Pulse\nMODULE          = test_Word_Change_Pulse\nPYTHONPATH      = /src\nRANDOM_SEED     = 1739797288\nHASH            = f2b3692399d6fb9d67877f517bea10249f8bac99", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_Word_Change_Pulse.py": "import cocotb \nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nimport random\n\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_Word_Change_Pulse(dut):\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    await hrs_lb.dut_init(dut)\n    await RisingEdge(dut.clk)\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.reset, duration_ns=25, active=False)\n    await RisingEdge(dut.clk)\n    # Reset all inputs\n    dut.data_in.value = 0\n    dut.mask.value = (1 << DATA_WIDTH) - 1\n    dut.match_pattern.value = 0\n    dut.enable.value = 1\n    dut.latch_pattern.value = 0\n\n    for _ in range(2):\n        await RisingEdge(dut.clk)    \n\n    # Generate an initial rising edge for synchronization\n    await RisingEdge(dut.clk)\n\n    # Ensure word_change_pulse starts low\n    assert dut.word_change_pulse.value == 0, \"Initial word_change_pulse is not 0\"\n\n    # Run tests\n    await random_changes_test(dut, DATA_WIDTH, num_tests=10)\n    await RisingEdge(dut.clk)\n    await test_no_change(dut, DATA_WIDTH)\n    await RisingEdge(dut.clk)\n    await test_single_bit_change(dut, DATA_WIDTH)\n    await RisingEdge(dut.clk)\n    await test_multiple_bits_change(dut, DATA_WIDTH)\n    await RisingEdge(dut.clk)\n    await test_back_to_back_changes(dut, DATA_WIDTH)\n    await RisingEdge(dut.clk)\n    await test_pattern_matching(dut, DATA_WIDTH)\n    await RisingEdge(dut.clk)\n    await test_enable_functionality(dut, DATA_WIDTH)\n    await RisingEdge(dut.clk)\n\n\n    # Log success\n    dut._log.info(\"All tests passed!\")\n\n\nasync def test_pattern_matching(dut, data_width):\n    \"\"\"Test pattern matching functionality with random mask and data_in.\"\"\"\n    # Reset the DUT\n    dut.reset.value = 1\n    await RisingEdge(dut.clk)\n    dut.reset.value = 0    \n\n    # Set a random match pattern and latch it\n    match_pattern = random.randint(0, (1 << data_width) - 1)\n    dut.match_pattern.value = match_pattern\n    dut.latch_pattern.value = 1\n    await RisingEdge(dut.clk)  # Latch the pattern\n    latched_pattern = int(dut.latched_pattern.value)\n    await RisingEdge(dut.clk)\n    # Track previous match status\n    previous_match = 0\n\n    \n\nasync def test_mask_functionality(dut, data_width):\n    \"\"\"Test masking functionality for change detection and pattern matching.\"\"\"\n     # Reset the DUT\n    dut.reset.value = 1\n    await RisingEdge(dut.clk)\n    dut.reset.value = 0  \n    mask = random.randint(0, (1 << data_width) - 1)\n    dut.mask.value = mask\n\n    prev_data = 0\n    used_data = set()\n\n    for _ in range(5):\n        while True:\n            random_data = random.randint(0, (1 << data_width) - 1)\n            if random_data not in used_data:\n                break\n        used_data.add(random_data)\n        dut.data_in.value = random_data\n\n        masked_data = random_data & int(dut.mask.value)\n        previous_masked_data = prev_data & int(dut.mask.value)\n        change_detected = masked_data != previous_masked_data\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        await FallingEdge(dut.clk)\n        assert int(dut.word_change_pulse.value) == change_detected, (\n            f\"word_change_pulse incorrect for masked data_in {masked_data:#0{data_width+2}b}.\"\n        )\n\n        prev_data = random_data\n\n\n\nasync def test_enable_functionality(dut, data_width):\n    \"\"\"Test enable signal functionality.\"\"\"\n     # Reset the DUT\n    dut.reset.value = 1\n    await RisingEdge(dut.clk)\n    dut.reset.value = 0  \n    dut.enable.value = 0\n\n    for _ in range(5):\n        random_data = random.randint(0, (1 << data_width) - 1)\n        dut.data_in.value = random_data\n        await RisingEdge(dut.clk)\n        await FallingEdge(dut.clk)\n        assert dut.word_change_pulse.value == 0, (\n            \"word_change_pulse should remain low when enable is deasserted.\"\n        )\n        assert dut.pattern_match_pulse.value == 0, (\n            \"pattern_match_pulse should remain low when enable is deasserted.\"\n        )\n\n\nasync def random_changes_test(dut, data_width, num_tests=10):\n    prev_data = 0\n    for _ in range(num_tests):\n        random_data = random.randint(0, (1 << data_width) - 1)\n        dut.data_in.value = random_data\n        await RisingEdge(dut.clk)  \n\n        expected_pulse = 1 if random_data != prev_data else 0\n        await RisingEdge(dut.clk)\n        await FallingEdge(dut.clk)\n        assert dut.word_change_pulse.value == expected_pulse, (\n            f\"word_change_pulse incorrect for data_in change from {prev_data:#0{data_width+2}b} \"\n            f\"to {random_data:#0{data_width+2}b}, expected {expected_pulse}.\"\n        )\n\n        prev_data = random_data\n        await RisingEdge(dut.clk)\n\n\nasync def test_no_change(dut, data_width):\n    random_value = random.randint(0, (1 << data_width) - 1)\n    dut.data_in.value = random_value\n    for _ in range(2):\n        await RisingEdge(dut.clk)  \n\n    for _ in range(5):\n        dut.data_in.value = random_value\n        await RisingEdge(dut.clk)  \n        await FallingEdge(dut.clk)\n        assert dut.word_change_pulse.value == 0, (\n            \"word_change_pulse should remain low when data_in does not change\"\n        )\n\n\nasync def test_single_bit_change(dut, data_width):\n    initial_value = random.randint(0, (1 << data_width) - 1)\n    dut.data_in.value = initial_value\n    await RisingEdge(dut.clk)\n\n    for i in range(data_width):\n        new_value = initial_value ^ (1 << i)\n        dut.data_in.value = new_value\n        expected_pulse = 1 if initial_value != new_value else 0\n        await RisingEdge(dut.clk)  \n        await RisingEdge(dut.clk)\n        await FallingEdge(dut.clk)\n        assert dut.word_change_pulse.value == expected_pulse, (\n            f\"word_change_pulse should be {expected_pulse} when bit {i} changes from {initial_value:#0{data_width+2}b} \"\n            f\"to {new_value:#0{data_width+2}b}.\"\n        )\n        initial_value = new_value\n        await RisingEdge(dut.clk)\n\n\nasync def test_multiple_bits_change(dut, data_width):\n    initial_value = random.randint(0, (1 << data_width) - 1)\n    dut.data_in.value = initial_value\n    await RisingEdge(dut.clk)\n\n    for _ in range(5):\n        new_value = random.randint(0, (1 << data_width) - 1)\n        dut.data_in.value = new_value\n        bitwise_change_detected = initial_value != new_value\n        expected_pulse = 1 if bitwise_change_detected else 0\n        await RisingEdge(dut.clk)  \n        await RisingEdge(dut.clk)\n        await FallingEdge(dut.clk)\n        assert dut.word_change_pulse.value == expected_pulse, (\n            f\"word_change_pulse incorrect for data_in change from {initial_value:#0{data_width+2}b} \"\n            f\"to {new_value:#0{data_width+2}b}, expected {expected_pulse}.\"\n        )\n        initial_value = new_value\n        await RisingEdge(dut.clk) \n\n\nasync def test_back_to_back_changes(dut, data_width):\n    num_iterations = 10\n\n    prev_value = random.randint(0, (1 << data_width) - 1)\n    dut.data_in.value = prev_value\n    await RisingEdge(dut.clk)\n\n    for _ in range(num_iterations):\n        while True:\n            new_value = random.randint(0, (1 << data_width) - 1)\n            if new_value != prev_value:\n                break\n\n        dut.data_in.value = new_value\n        await RisingEdge(dut.clk)\n\n        value1 = prev_value\n        prev_value = new_value\n        await RisingEdge(dut.clk)\n        await FallingEdge(dut.clk)\n\n        expected_pulse = 1 if value1 != prev_value else 0\n        word_change_pulse_val = dut.word_change_pulse.value\n\n        assert word_change_pulse_val == expected_pulse, (\n            f\"word_change_pulse incorrect for change from {value1:#0{data_width+2}b} \"\n            f\"to {prev_value:#0{data_width+2}b}, expected {expected_pulse}.\"\n        )\n\n    dut._log.info(\"All assertions passed successfully for data width {data_width}.\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_word_reducer_0012", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench named `tb_Bit_Difference_Counter` using SystemVerilog to generate stimulus for the `Bit_Difference_Counter` module, which calculates the hamming distance (bitwise difference) between two inputs of equal bit width. The testbench should apply edge-case scenarios and random input patterns to thoroughly exercise the module. The testbench should only contain stimulus generator.\n\n## Module: `Bit_Difference_Counter`\n\n### Parameters:\n- **BIT_WIDTH**: Defines the width of the input vectors, with a default value of 3. This parameter must be a positive integer greater than or equal to 1.\n- **COUNT_WIDTH**: The expression calculates $clog2(BIT_WIDTH + 1), which is the width required to represent the maximum possible number of differing bits.\n### Inputs\n1. **`[BIT_WIDTH-1:0] input_A`**:  A binary input signal.\n2. **`[BIT_WIDTH-1:0] input_B`**:  A binary input signal of the same width as `input_A`.\n\n### Output\n1. **`[COUNT_WIDTH-1:0] bit_difference_count`**: The output indicates the Hamming distance between `input_A` and `input_B`. The Hamming distance is the number of differing bits between the two inputs.\n\n## Testbench Design\n\n### Instantiation\nThe `Bit_Difference_Counter` module is instantiated as `dut`, with the following connections:\n- **Inputs**: `input_A` and `input_B`\n- **Output**: `bit_difference_count`\n\n## Input Generation \n\n### Edge Case Testing\n1. **All Zero Inputs**:  Generate a test case where both inputs are composed entirely of zeros (0).\n2. **All One Inputs**:  Generate a test case where both inputs are composed entirely of ones (1).\n3. **Completely Different Inputs**:  Generate a test case where one input is all zeros and the other is all ones.\n4. **Single Bit Differences**:  For each bit position in the input, generate test cases where the inputs differ by only that single bit.\n\n### Randomized Testing\n- Randomly generates 100 test cases for `input_A` and `input_B`, covering various combinations of differing bits.\n", "context": {}}, "output": {"response": "", "context": {"verif/Data_Reduction_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro \n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 788fbf7f1c84e1f87b2ee2554fce9da07d1987fd\nTARGET = 100\n", "src/Data_Reduction.sv": "`timescale 1ns / 1ps\n\nmodule Bit_Difference_Counter\n#(\n    parameter BIT_WIDTH    = 3,                          // Defines the width of the input vectors.\n    localparam COUNT_WIDTH = $clog2(BIT_WIDTH + 1)       // Calculates the width required to represent the count of differing bits.\n)\n(\n    input  wire [BIT_WIDTH-1:0] input_A,                // First input vector.\n    input  wire [BIT_WIDTH-1:0] input_B,                // Second input vector.\n    output reg  [COUNT_WIDTH-1:0] bit_difference_count  // Count of differing bits (Hamming distance).\n);\n\n    wire [BIT_WIDTH-1:0] different_bits;\n    integer idx;\n\n    // Instantiate the Data_Reduction module to compute bitwise XOR between input_A and input_B.\n    Data_Reduction\n    #(\n        .REDUCTION_OP (3'b010), // XOR operation\n        .DATA_WIDTH  (BIT_WIDTH),\n        .DATA_COUNT  (2)\n    )\n    compare_bits\n    (\n        .data_in      ({input_A, input_B}),\n        .reduced_data_out   (different_bits)\n    );\n\n    // Count set bits in different_bits to compute Hamming distance\n    always @(*) begin\n        bit_difference_count = 0;\n        for (idx = 0; idx < BIT_WIDTH; idx = idx + 1) begin\n            bit_difference_count = bit_difference_count + different_bits[idx];\n        end\n    end\n\nendmodule\n\nmodule Data_Reduction\n#(\n    parameter [2:0] REDUCTION_OP = 3'b000, // Default operation: AND\n    parameter DATA_WIDTH         = 4,      // Width of each data element\n    parameter DATA_COUNT         = 4,      // Number of data elements\n    localparam TOTAL_INPUT_WIDTH = DATA_WIDTH * DATA_COUNT\n)\n(\n    input  wire [TOTAL_INPUT_WIDTH-1:0] data_in,\n    output reg  [DATA_WIDTH-1:0]        reduced_data_out\n);\n\n    generate\n        genvar bit_index;\n\n        for (bit_index = 0; bit_index < DATA_WIDTH; bit_index = bit_index + 1) begin : bit_processing\n            wire [DATA_COUNT-1:0] extracted_bits;\n\n            genvar data_index;\n            for (data_index = 0; data_index < DATA_COUNT; data_index = data_index + 1) begin : bit_extraction\n                assign extracted_bits[data_index] = data_in[(data_index * DATA_WIDTH) + bit_index];\n            end\n\n            Bitwise_Reduction\n            #(\n                .REDUCTION_OP (REDUCTION_OP),\n                .BIT_COUNT    (DATA_COUNT)\n            )\n            reducer_instance\n            (\n                .input_bits  (extracted_bits),\n                .reduced_bit (reduced_data_out[bit_index])\n            );\n        end\n    endgenerate\n\nendmodule\n\n\nmodule Bitwise_Reduction\n#(\n    parameter [2:0] REDUCTION_OP = 3'b000, // Default operation: AND\n    parameter BIT_COUNT          = 4       // Number of bits to reduce\n)\n(\n    input  wire [BIT_COUNT-1:0] input_bits,\n    output reg                  reduced_bit\n);\n\n    // Reduction Operation Codes\n    localparam [2:0] AND_OP  = 3'b000;\n    localparam [2:0] OR_OP   = 3'b001;\n    localparam [2:0] XOR_OP  = 3'b010;\n    localparam [2:0] NAND_OP = 3'b011;\n    localparam [2:0] NOR_OP  = 3'b100;\n    localparam [2:0] XNOR_OP = 3'b101;\n\n    int i;\n    reg temp_result; \n\n    always @(*) begin\n        temp_result = input_bits[0];\n\n        for (i = 1; i < BIT_COUNT; i = i + 1) begin\n            case (REDUCTION_OP)\n                AND_OP, NAND_OP  : temp_result = temp_result & input_bits[i];\n                OR_OP,  NOR_OP   : temp_result = temp_result | input_bits[i];\n                XOR_OP, XNOR_OP  : temp_result = temp_result ^ input_bits[i];\n                default          : temp_result = temp_result & input_bits[i];\n            endcase\n        end\n\n        case (REDUCTION_OP)\n            NAND_OP : reduced_bit = ~temp_result;\n            NOR_OP  : reduced_bit = ~temp_result;\n            XNOR_OP : reduced_bit = ~temp_result;\n            default : reduced_bit = temp_result;\n        endcase\n    end\nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/Data_Reduction.sv /code/verif/Data_Reduction_tb.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        while len(info) < 3:\n            info.append(\"0%\")\n\n        inst = re.sub(r'[\\W]', '', info[0])\n\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n\n    # Check if the required key exists in the metrics\n    if \"dut\" not in metrics:\n        raise KeyError(\"Metrics data for 'dut' is missing in the coverage log.\")\n\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))  \n    assert metrics[\"dut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['dut']['Average']}, Target: {target}\"\n"}}}
{"id": "cvdp_copilot_write_buffer_merge_0014", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `write_buffer_merge` module. The assertions should ensure that the module correctly handles write operations, maintains address stability, and asserts output signals appropriately.  \n\n## **RTL Design Overview**  \nThe `write_buffer_merge` module is responsible for **buffering and merging write operations** before sending them to memory. It collects multiple small write transactions and outputs a larger, merged write. \n\n### **Key Components of the Module**  \n- **`write_count`**: Tracks the number of write operations stored in the buffer.  \n- **`base_addr`**: Stores the starting address for the merged transaction.  \n- **`merged_data`**: Holds the accumulated write data before output.  \n- **`write_complete`**: Signals when the buffer is full and ready to send data.  \n- **`wr_en_out`**: Indicates that a merged write is available.  \n- **`wr_en_in`**: Indicates that valid input data is available.  \n- **`wr_addr_in` & `wr_data_in`**: Input address and data for the merged write.  \n- **`wr_addr_out` & `wr_data_out`**: Output address and data for the merged write.  \n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Write Counter Bounds:** `write_count` should **never exceed** `BUFFER_DEPTH - 1`.  \n- **Base Address Stability:** `base_addr` should **only update** when `write_count == 0` and `wr_en_in == 1`.  \n- **Write Completion Signal:** `write_complete` should **assert correctly** when `write_count == BUFFER_DEPTH - 1` and `wr_en_in` is active.  \n- **Write Enable Output Behavior:** `wr_en_out` should **assert only when** `write_complete` is asserted.  \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.\n", "context": {"rtl/write_buffer_merge.sv": "module write_buffer_merge #(\n  parameter INPUT_DATA_WIDTH  = 32,                                     // Width of input data\n  parameter INPUT_ADDR_WIDTH  = 16,                                     // Width of input address\n  parameter BUFFER_DEPTH      = 8,                                      // Depth of the write buffer\n  parameter OUTPUT_DATA_WIDTH = INPUT_DATA_WIDTH * BUFFER_DEPTH,        // Width of merged output data\n  parameter OUTPUT_ADDR_WIDTH = INPUT_ADDR_WIDTH - $clog2(BUFFER_DEPTH) // Width of merged output address\n) (\n  input  logic                         clk,          // Clock signal. Design is synchronized to posedge of this.\n  input  logic                         srst,         // Synchronous reset (active high)\n  input  logic                         wr_en_in,     // Active high Write enable input\n  input  logic [INPUT_ADDR_WIDTH-1:0]  wr_addr_in,   // Write address input\n  input  logic [INPUT_DATA_WIDTH-1:0]  wr_data_in,   // Write data input\n  output logic                         wr_en_out,    // Active high Write enable output\n  output logic [OUTPUT_ADDR_WIDTH-1:0] wr_addr_out,  // Write address output\n  output logic [OUTPUT_DATA_WIDTH-1:0] wr_data_out   // Write data output\n);\n\n  logic [$clog2(BUFFER_DEPTH)-1:0]      write_count;\n  logic [OUTPUT_ADDR_WIDTH-1:0]         base_addr;\n  logic [OUTPUT_DATA_WIDTH-1:0]         merged_data;\n  logic                                 write_complete;\n\n  always_ff @(posedge clk) begin\n    if (srst) \n      write_count <= '0;\n    else if (wr_en_in)\n      write_count <= write_count + 1;\n  end\n\n  always_ff @(posedge clk) begin\n    if (srst)\n      base_addr <= '0;\n    else if ((write_count == 0) && wr_en_in)\n      base_addr <= wr_addr_in[INPUT_ADDR_WIDTH-1:$clog2(BUFFER_DEPTH)];\n  end\n\n  always_ff @(posedge clk) begin\n    if (srst)\n      merged_data <= '0;\n    else if (wr_en_in)\n      merged_data <= {wr_data_in, merged_data[OUTPUT_DATA_WIDTH-1:INPUT_DATA_WIDTH]};\n  end\n\n  always_ff @(posedge clk) begin\n    if (srst)\n      write_complete <= 1'b0;\n    else if ((write_count == (BUFFER_DEPTH - 1)) && wr_en_in)\n      write_complete <= 1'b1;\n    else\n      write_complete <= 1'b0;\n  end\n\n  always_ff @(posedge clk) begin\n    if (srst)\n      wr_en_out <= 1'b0;\n    else\n      wr_en_out <= write_complete;\n  end\n\n  always_ff @(posedge clk) begin\n    if (srst)\n      wr_addr_out <= '0;\n    else if (write_complete)\n      wr_addr_out <= base_addr;\n  end\n\n  always_ff @(posedge clk) begin\n    if (srst)\n      wr_data_out <= '0;\n    else if (write_complete)\n      wr_data_out <= merged_data;\n  end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/write_buffer_merge.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/write_buffer_merge.sv\nTOPLEVEL        = write_buffer_merge\nMODULE          = test_write_buffer_merge\nPYTHONPATH      = /src\nHASH            = 14-rtl-assertion-generation-for-write-buffer-merge", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner(INPUT_DATA_WIDTH: int=32, INPUT_ADDR_WIDTH: int=16, BUFFER_DEPTH: int=8):\n    parameters = {\n        \"INPUT_DATA_WIDTH\": INPUT_DATA_WIDTH,\n        \"INPUT_ADDR_WIDTH\": INPUT_ADDR_WIDTH,\n        \"BUFFER_DEPTH\": BUFFER_DEPTH,\n    }\n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# ---------------------------------------------------------------------------\n# Random Parameterized Write Buffer Merge Tests\n# ---------------------------------------------------------------------------\n# Generate random parameters for the write_buffer_merge testbench and run the test multiple times.\n@pytest.mark.parametrize(\"random_test\", range(3))\ndef test_random_write_buffer_merge(random_test):\n  # Generate random parameters\n  INPUT_DATA_WIDTH = random.randint(8, 32)  # Random input data width (8 to 32 bits)\n  INPUT_ADDR_WIDTH = random.randint(8, 32)  # Random input address width (8 to 32 bits)\n  BUFFER_DEPTH = 2**(math.ceil(math.log2(random.randint(2, 8))))\n\n  # Run the test with the generated parameters\n  call_runner(INPUT_DATA_WIDTH=INPUT_DATA_WIDTH, INPUT_ADDR_WIDTH=INPUT_ADDR_WIDTH, BUFFER_DEPTH=BUFFER_DEPTH)\n", "src/test_write_buffer_merge.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport harness_library as hrs_lb\nimport math\n\n# ----------------------------------------\n# - Write Buffer Merge Test\n# ----------------------------------------\n\nasync def reset_dut(dut, duration_ns=10):\n  \"\"\"\n    Reset the DUT by setting the synchronous reset signal high for a specified duration\n    and then setting it low again.\n\n    During reset, ensure that the DUT's outputs are zero.\n\n    Args:\n        dut: The Design Under Test (DUT).\n        duration_ns: The time duration in nanoseconds for which the reset signal will be held high.\n    \"\"\"\n  dut.srst.value = 1  # Set reset to active high\n  await Timer(duration_ns, units=\"ns\")  # Wait for the specified duration\n\n  # Ensure all outputs are zero\n  assert dut.wr_en_out.value == 0, f\"[ERROR] wr_en_out is not zero after reset: {dut.wr_en_out.value}\"\n  assert dut.wr_addr_out.value == 0, f\"[ERROR] wr_addr_out is not zero after reset: {dut.wr_addr_out.value}\"\n  assert dut.wr_data_out.value == 0, f\"[ERROR] wr_data_out is not zero after reset: {dut.wr_data_out.value}\"\n\n  dut.srst.value = 0  # Deactivate reset (set it low)\n  await Timer(duration_ns, units='ns')  # Wait for the reset to stabilize\n  dut.srst._log.debug(\"Reset complete\")\n\n\n@cocotb.test()\nasync def verify_write_buffer_merge(dut):\n  \"\"\"\n  Verify the write buffer merge functionality.\n  This test checks for the following:\n  - Proper buffering and merging of input data.\n  - Correct output address and data generation.\n  - Proper signaling of `wr_en_out` when the buffer is full.\n  - Handling of resets.\n\n  The test dynamically generates random inputs, tracks expected outputs, \n  and verifies the DUT outputs against expected results.\n  \"\"\"\n\n  # Start the clock with a 2ns period\n  cocotb.start_soon(Clock(dut.clk, 2, units='ns').start())\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles to stabilize\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve parameters from the DUT\n  input_data_width = int(dut.INPUT_DATA_WIDTH.value)\n  input_addr_width = int(dut.INPUT_ADDR_WIDTH.value)\n  buffer_depth = int(dut.BUFFER_DEPTH.value)\n  output_data_width = int(dut.OUTPUT_DATA_WIDTH.value)\n  output_addr_width = int(dut.OUTPUT_ADDR_WIDTH.value)\n\n  # Number of outputs and inputs based on buffer depth\n  num_outputs = random.randint(1, 16) \n  num_inputs = num_outputs*buffer_depth\n  continuous_input = random.randint(0, 1)\n\n\n  # Print paramerters for debugging\n  print(f\"INPUT_DATA_WIDTH: {input_data_width}\")\n  print(f\"INPUT_ADDR_WIDTH: {input_addr_width}\")\n  print(f\"BUFFER_DEPTH: {buffer_depth}\")\n  print(f\"NUM_OUTPUTS: {num_outputs}\")\n  \n  # Initialize variables for tracking inputs and outputs\n  i = 0\n  data_in_queue = []\n  addr_in_queue = []\n\n  data_out_queue = []\n  addr_out_queue = []\n  num_outputs_from_dut = 0\n\n  prev_wr_data_out = 0\n  prev_wr_addr_out = 0\n  out_latency = 0\n\n  # Dynamically generate and apply inputs\n  while i < num_inputs:\n    # Generate random inputs\n    if continuous_input == 1:\n      wr_en_in = 1\n    else:\n      wr_en_in = random.randint(0, 1)\n    wr_data_in = random.randint(0, (1<<input_data_width)-1)\n    if (wr_en_in == 1):\n      if ((i%buffer_depth) == 0):\n        # Generate aligned addresses based on buffer depth\n        wr_addr_in = buffer_depth*((random.randint(0, ((1<<input_addr_width)-1)))//buffer_depth)\n      else:\n        wr_addr_in = wr_addr_in + 1\n\n      # Assign the values to DUT inputs\n      dut.wr_en_in.value = wr_en_in\n      dut.wr_data_in.value = wr_data_in\n      dut.wr_addr_in.value = wr_addr_in\n\n      # Store the input for later verification\n      i+=1\n      data_in_queue.append(wr_data_in)\n      if ((i%buffer_depth) == 0):\n        addr_in_queue.append(wr_addr_in)\n\n    await RisingEdge(dut.clk)\n\n    # Capture DUT outputs\n    wr_en_out = int(dut.wr_en_out.value)\n    wr_data_out = int(dut.wr_data_out.value)\n    wr_addr_out = int(dut.wr_addr_out.value)\n    if (wr_en_out == 1):\n      data_out_queue.append(wr_data_out)\n      addr_out_queue.append(wr_addr_out)\n      num_outputs_from_dut+=1\n    else:\n      assert wr_addr_out == prev_wr_addr_out, f\"[ERROR] Output Address Changed when Write Enable Out is Low Prev={prev_wr_addr_out}, Current={wr_addr_out}\"\n      assert wr_data_out == prev_wr_data_out, f\"[ERROR] Output Data Changed when Write Enable Out is Low Prev={prev_wr_data_out}, Current={wr_data_out}\"\n\n    prev_wr_data_out = wr_data_out\n    prev_wr_addr_out = wr_addr_out\n\n    if (wr_en_out == 1):\n      if (buffer_depth == 1):\n        assert out_latency == 1, f\"[ERROR] Output Latency Mismatch Expected=1, Current={out_latency}\"\n      else:\n        assert out_latency == 2, f\"[ERROR] Output Latency Mismatch Expected=2, Current={out_latency}\"\n      out_latency = 0\n\n    if (wr_en_in & (((i-1)%buffer_depth) == (buffer_depth-1))):\n      out_latency = 1\n    elif (out_latency >= 1):\n      out_latency += 1\n\n    # Set wr_en_in low\n    dut.wr_en_in.value = 0\n\n  print(f\"All inputs have been generated!\")\n\n  await RisingEdge(dut.clk)\n  # Wait for remaining outputs from the DUT\n  while num_outputs_from_dut < num_outputs:\n    wr_en_out = int(dut.wr_en_out.value)\n    wr_data_out = int(dut.wr_data_out.value)\n    wr_addr_out = int(dut.wr_addr_out.value)\n    if (wr_en_out == 1):\n      data_out_queue.append(wr_data_out)\n      addr_out_queue.append(wr_addr_out)\n      num_outputs_from_dut+=1\n    await RisingEdge(dut.clk)\n\n  print(f\"All outputs have been received!\")\n\n  # Verify outputs against expected values\n  for i in range(num_outputs):\n    expected_data = 0\n    expected_addr = addr_in_queue.pop(0) >> math.ceil(math.log2(buffer_depth));\n    for j in range(buffer_depth):\n      expected_data |= (data_in_queue.pop(0) << (j * input_data_width))\n\n    rtl_addr = addr_out_queue.pop(0)\n    rtl_data = data_out_queue.pop(0)\n\n\n    # Verify address output\n    assert rtl_addr == expected_addr, f\"[ERROR] Output {i+1}: Address mismatch! Expected={expected_addr}, Got={rtl_addr}\"\n\n    # Verify data output\n    assert rtl_data == expected_data, f\"[ERROR] Output {i+1}: Data mismatch! Expected={expected_data}, Got={rtl_data}\"\n\n    print(f\"Output {i+1} Matched\")\n\n  # Wait for 2 cycles\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for 2 cycles\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n"}}}
{"id": "cvdp_copilot_write_through_data_direct_mapped_cache_0001", "categories": ["cid012", "medium"], "input": {"prompt": "Complete the given partial System Verilog Testbench `tb_ddm_cache`.The testbench must instantiate the `ddm_cache` RTL module and provide input stimulus for it, focusing exclusively on generating comprehensive test vectors rather than building a full testbench. The data cache handles read and write operations from the CPU, along with memory access operations. The module supports both cached memory accesses and uncached I/O port accesses.\n\n## Module Interface\n## 1. Inputs:\n\n- `clk(1-bit)`: Clock signal. The module operates on the rising edge of `clk`. It synchronizes the operations within the cache logic.\n\n- `rst_n(1-bit)`: 1-bit asynchronous, active-low reset signal. This is triggered on a negedge (falling edge) of the reset signal. When rst_n is asserted (`rst_n` = 0), all the cache locations are invalidated\n\n- `cpu_addr (32-bit,[31:0])`: A 32-bit input representing the memory address issued by the CPU for a read or write operation. This address is used by the cache to determine if a cache hit or miss occurs.\n\n- `cpu_dout (32-bit,[31:0])`: A 32-bit input that carries data emitted by the CPU when writing to memory.\n\n- `cpu_strobe(1-bit)`: A ACTIVE HIGH signal indicating that the CPU wants to perform a read or write operation.\n\n- `cpu_rw:(1-bit)` A control signal indicating the type of operation to be performed by the CPU. cpu_rw = 1 represents a memory write operation, while cpu_rw = 0 represents a memory read operation.\n\n- `uncached(1-bit)`: A control signal where uncached = 1 indicates that the operation is accessing an uncached I/O port (instead of memory). When uncached = 0, a regular memory operation is performed.\n\n- `mem_dout(32-bit, [31:0])`: A 32-bit input that carries data from memory. This data is provided to the cache when there is a cache miss and is forwarded to the CPU if it is a read operation.\n\n- `mem_ready(1-bit)`: A signal indicating that memory is ready with the data to be provided to the cache\n\n## 2. Outputs:\n\n- `cpu_din (32-bit, [31:0])`: A 32-bit output that carries data to the CPU during a read operation. This can either be data from the cache or from memory in the event of a cache miss.\n\n- `mem_din(32-bit, [31:0])`: A 32-bit output carrying data from the CPU to memory when via cache during a write operation\n\n- `cpu_ready(1-bit)`: A signal indication from the cache that data is ready for the CPU to be read.\n\n- `mem_strobe(1-bit)`: A signal that indicates that the memory is going to be accessed by the cache for a read or write operation\n\n- `mem_rw`: The read/write control signal for memory. It reflects the cpu_rw signal, indicating whether the operation is a read (0) or write (1) to memory.\n\n- `mem_addr(32-bit ,[31:0])`: A 32-bit output representing the memory address sent to the memory during the read/write operation from the cache.\n\n- `cache_hit(1-bit)` - A ACTIVE HIGH signal indicating memory location is available in Cache.\n\n- `cache_miss(1-bit)` - A ACTIVE HIGH signal indicating memory location is not available in Cache.\n\n- `d_data_out(32-bit,[31:0])` - Data at a particular index(location) of the cache.\n\n\n## Instantiation :\nThe testbench instantiates the `ddm_cache` module as dut and connects the signals between the module and the testbench. Each input and output from the DUT is connected to its corresponding signal in the testbench.\n\n## Input Generation and Validation:\n\n- Clock Generation: The clock signal `clk` is generated using an always block that toggles the clock every 5 time units.\n\n- Reset: The reset signal `rst_n` is asserted at the beginning of the simulation to ensure the cache is initialized in a known state. After a short period (10 time units), the reset is deasserted.\n\n- Stimulus: Several test cases are applied to simulate various operations of the cache. These test cases cover a range of scenarios such as cache misses, cache writes, and uncached accesses. For each case, the relevant signals (address, data, control signals) are set, followed by a brief wait period to allow the DUT to respond.\n\n  - Test Case 1: A cache read miss occurs when the CPU accesses address 0x00000000. The memory provides data (0x11111111), and the CPU reads this data from memory after the cache miss.\n\n  - Test Case 2: A cache write occurs when the CPU accesses address 0x00000004 and writes data (0xAABBCCDD) into the cache.\n\n  - Test Case 3: A cache read hit occurs when the CPU accesses address 0x00000000. The cache provides the previously cached data (0x11111111) without needing to access memory.\n\n  - Test Case 4: A cache write and read after reset occur when the CPU writes to address 0x00000010 and then reads the data back from the cache after a reset.\n\n  - Test Case 5: An edge case occurs when the CPU writes to address 0x00000014 with two different values (0xDEADBEEF and 0xFACEFEED), followed by a read operation. The cache should return the most recent value (0xFACEFEED).\n\n   - Test Case 6: A cache miss and cache write with different memory delays occur when the CPU performs a write operation at address 0x00000018 while memory readiness (`mem_ready`) changes. The cache should handle these delays properly.\n\n   - Test Case 7: An uncached IO port access occurs when the CPU writes to IO port address 0xF0000000. This access bypasses the cache and directly interacts with the IO port.\n\n   - Test Case 8: Cache read and write operations with randomized addresses occur when the CPU performs random read and write operations. The cache should handle these operations correctly.\n\n   - Test Case 9: A cache invalidation occurs when the CPU writes data (0xDEADBEAF) to address 0x00000020, and then performs a read, resulting in a cache miss. The cache fetches new data (0xBBBBBBBB) from memory.\n\n   - Test Case 10: Boundary address tests occur when the CPU accesses the first (0x00000000) and last (0xFFFFFFFC) cacheable addresses. These boundary cases are tested to ensure correct cache handling at the limits of the address space.\n   \n   - Test Case 11: Multiple cache misses and hits in sequence occur when the CPU performs operations at sequential addresses (0x00000024, 0x00000028). The cache should handle the misses and hits correctly.\n\n   - Test Case 12: A memory read with a cache miss and delayed memory readiness occurs when the CPU reads from address 0x00000050. The memory is initially not ready (`mem_ready` = 0), causing a delay before the CPU can read the data after the cache miss. The memory readiness flag is toggled to allow the read after a short delay.\n\n## Module Functionality:\n- Asynchronous Reset: When `rst_n` is asserted (`rst_n = 0`), all cache locations are invalidated This ensures the cache is reset to a known state.\n\n- Cache Operation: On each rising edge of clk, the cache processes the incoming requests from the CPU:\n\n   - Cache Read: If the CPU issues a read request and the address is present in the cache (`cache hit`), the corresponding data is returned to the CPU without accessing memory.\n\n  - Cache Miss: If the CPU accesses a memory address that is not cached (`cache miss`), the cache issues a memory read request to the memory. Once the data is retrieved from memory, it is stored in the cache for future accesses.\n\n - Cache Write: If the CPU writes data, the cache writes the data into the cache entry corresponding to the address. If the operation is not cached (i.e., `uncached = 1`), the data is written directly to memory instead of the cache.\n\n - Cache Management: Each cache entry has a valid bit, a tag, and data. The tag is used to determine whether a cache entry matches the requested address, and the valid bit indicates whether the entry contains valid data. When a write operation occurs, the corresponding cache entry is updated with the new tag and data.\n\n - Memory Read/Write: If a cache miss occurs, the module performs a memory read operation (if `cpu_rw = 0`), waits for the memory to become ready (`mem_ready`), and then forwards the data to the CPU. Similarly, for write operations (`cpu_rw = 1`), the data is written to memory after it is cached.\n\n - Cache Write Signal: The cache write signal (`cache_write`) is asserted when a write operation occurs, either because the CPU is performing a write or because the cache is updating its contents after a cache miss.\n\n**Partial Test Stimulus Generator Code :**\n``` verilog\nmodule tb_ddm_cache;\n\n  logic clk;\n  logic rst_n;\n  logic [31:0] cpu_addr;\n  logic [31:0] cpu_dout;\n  logic cpu_strobe;\n  logic cpu_rw;\n  logic uncached;\n  logic [31:0] mem_dout;\n  logic mem_ready;\n  logic [31:0] cpu_din;\n  logic [31:0] mem_din;\n  logic cpu_ready;\n  logic mem_strobe;\n  logic mem_rw;\n  logic [31:0] mem_addr;\n  logic cache_hit;\n  logic cache_miss;\n  logic [31:0] d_data_dout;\n\n  ddm_cache dut (\n    .clk(clk),\n    .rst_n(rst_n),\n    .cpu_addr(cpu_addr),\n    .cpu_dout(cpu_dout),\n    .cpu_strobe(cpu_strobe),\n    .cpu_rw(cpu_rw),\n    .uncached(uncached),\n    .mem_dout(mem_dout),\n    .mem_ready(mem_ready),\n    .cpu_din(cpu_din),\n    .mem_din(mem_din),\n    .cpu_ready(cpu_ready),\n    .mem_strobe(mem_strobe),\n    .mem_rw(mem_rw),\n    .mem_addr(mem_addr),\n    .cache_hit(cache_hit),\n    .cache_miss(cache_miss),\n    .d_data_dout(d_data_dout)\n  );\n\n  always begin\n    #5 clk = ~clk;\n  end\n\n  \n  initial begin\n    clk = 0;\n    rst_n = 0;\n    cpu_addr = 32'h00000000;\n    cpu_dout = 32'h12345678;\n    cpu_strobe = 0;\n    cpu_rw = 0;\n    uncached = 0;\n    mem_dout = 32'h00000000;\n    mem_ready = 1;\n\n    #10 rst_n = 1;\n    #10;\n\n    $display(\"Test case 1: Cache Read Miss (CPU address 0x00000000)\");\n    cpu_addr = 32'h00000000;\n    cpu_dout = 32'h12345678;\n    cpu_strobe = 1;\n    cpu_rw = 0;\n    uncached = 0;\n    mem_dout = 32'h11111111;\n    #10;\n    cpu_strobe = 0;\n    #50;\n    \n    $display(\"Test case 2: Cache Write (CPU address 0x00000004)\");\n    cpu_addr = 32'h00000004;\n    cpu_dout = 32'hAABBCCDD;\n    cpu_strobe = 1;\n    cpu_rw = 1;\n    uncached = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;\n    \n    $display(\"Test case 3: Cache Read Hit (CPU address 0x00000000, should hit cached data)\");\n    cpu_addr = 32'h00000000;\n    cpu_strobe = 1;\n    cpu_rw = 0;\n    uncached = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;\n        \n    // Insert the code for the remaining test cases here\n   ```", "context": {}}, "output": {"response": "", "context": {"verif/tb_ddm_cache.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 8964898c83fa98eb898b95bbe0d73de7203c7e67\nTARGET = 85\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/ddm_cache.sv": "module ddm_cache (\n  input  logic        clk,           // Posedge clock\n  input  logic        rst_n,         // Asynchronous Negedge reset\n  input  logic [31:0] cpu_addr,      // Memory address emitted by the CPU\n  input  logic [31:0] cpu_dout,      // Data emitted by CPU\n  input  logic        cpu_strobe,    // CPU status signal to Cache to indicate it is going to perform a read or write operation\n  input  logic        cpu_rw,        // cpu_rw == 1, Memory Write Operation ; cpu_rw == 0 , Memory Read Operation\n  input  logic        uncached,      // uncached == 1 , IO port is accessed ; uncached == 0, Memory is accessed\n  input  logic [31:0] mem_dout,      // Data emitted by memory\n  input  logic        mem_ready,     // Memory is ready with the read data\n  output logic [31:0] cpu_din,       // CPU Data coming from Memory through Cache\n  output logic [31:0] mem_din,       // Memory Data coming from CPU through Cache\n  output logic        cpu_ready,     // Cache is ready with data to be provided to CPU\n  output logic        mem_strobe,    // Cache Status signal to Memory to indicate it is going to perform a read or write operation\n  output logic        mem_rw,        // mem_rw == 1, Memory Write Operation ; mem_rw == 0 , Memory Read Operation\n  output logic [31:0] mem_addr,      // Memory address to be accessed, emitted by the Cache\n  output logic        cache_hit,     // Indicates a memory location is available in the cache\n  output logic        cache_miss,    // Indicates a memory location is not available in the cache\n  output logic [31:0] d_data_dout     // Data at a cache index\n);\n\n  logic         d_valid [0:63];\n  logic [23:0]  d_tags  [0:63];\n  logic [31:0]  d_data  [0:63];\n  \n  logic [23:0] tag;\n  logic [5:0]  index;\n  \n  logic [31:0] cache_din;   \n  logic        cache_write; \n  logic [23:0] d_tag_out;\n  logic  valid;\n  \n  integer i;\n  \n  assign tag   = cpu_addr[31:8];\n  assign index = cpu_addr[7:2]; \n  assign cache_write = ~uncached & (cpu_rw | cache_miss & mem_ready); \n  \n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        for (i = 0; i < 64; i = i + 1) begin\n            d_valid[i] <= 0;\n        end\n    end else if (cache_write) begin\n            d_valid[index] <= 1;\n    end\n  end\n\n  assign cache_din = cpu_rw ? cpu_dout : mem_dout;\n  always_ff@(posedge clk) begin\n       if(cache_write) begin\n         d_tags [index] <= tag;\n         d_data [index] <= cache_din;\n      end else begin\n         d_tags [index] <= d_tags[index] + 32'd0;\n         d_data [index] <= d_data[index] + 32'd0;\n       end\n  end  \n  \n  assign valid          = d_valid[index];\n  assign d_tag_out      = d_tags [index];\n  assign cache_dout     = d_data [index];\n  assign cache_hit      = cpu_strobe & valid & (d_tag_out == tag);\n  assign cache_miss     = cpu_strobe & (!valid | (d_tag_out != tag));\n  assign mem_din        = cpu_dout;\n  assign mem_addr       = cpu_addr;\n  assign mem_rw         = cpu_rw;\n  assign mem_strobe     = cpu_strobe | cache_miss;\n  assign cpu_ready      = ~cpu_rw & cache_hit | (cache_miss | cpu_rw) & mem_ready;\n  assign cpu_din        = cache_hit ? cache_dout : mem_dout;\n  assign d_data_out     = cache_dout;\nendmodule  \n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n        \n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_write_through_data_direct_mapped_cache_0004", "categories": ["cid013", "easy"], "input": {"prompt": "Modify the SystemVerilog testbench `tb_ddm_cache` to integrate the checker functionality to test the `ddm_cache` module. The testbench provided in the context already has a stimulus generator for many test cases. The purpose of the testbench checker is to verify the functionality of the Direct Data Mapped Cache against the given design specification.\n\n## **Design Specification**:\nThe `ddm_cache` module implements a direct-mapped cache for CPU and memory operations. It supports cache reads and writes, uncached accesses, and memory read delays.\n\nThe `ddm_cache` module has the following interface:\n\n## Interface:\n###  Inputs:\n\n- `clk(1-bit)`: Clock signal. The module operates on the rising edge of `clk`. It synchronizes the operations within the cache logic.\n\n- `rst_n(1-bit)`: 1-bit asynchronous, active-low reset signal. This is triggered on a negedge (falling edge) of the reset signal. When rst_n is asserted (`rst_n` = 0), all the cache locations are invalidated\n\n- `cpu_addr (32-bit,[31:0])`: A 32-bit input representing the memory address issued by the CPU for a read or write operation. This address is used by the cache to determine if a cache hit or miss occurs.\n\n- `cpu_dout (32-bit,[31:0])`: A 32-bit input that carries data emitted by the CPU when writing to memory.\n\n- `cpu_strobe(1-bit)`: A ACTIVE HIGH signal indicating that the CPU wants to perform a read or write operation.\n\n- `cpu_rw:(1-bit)` A control signal indicating the type of operation to be performed by the CPU. cpu_rw = 1 represents a memory write operation, while cpu_rw = 0 represents a memory read operation.\n\n- `uncached(1-bit)`: A control signal where uncached = 1 indicates that the operation is accessing an uncached I/O port (instead of memory). When uncached = 0, a regular memory operation is performed.\n\n- `mem_dout(32-bit, [31:0])`: A 32-bit input that carries data from memory. This data is provided to the cache when there is a cache miss and is forwarded to the CPU if it is a read operation.\n\n- `mem_ready(1-bit)`: A signal indicating that memory is ready with the data to be provided to the cache\n\n### Outputs:\n\n- `cpu_din (32-bit, [31:0])`: A 32-bit output that carries data to the CPU during a read operation. This can either be data from the cache or from memory in the event of a cache miss.\n\n- `mem_din(32-bit, [31:0])`: A 32-bit output carrying data from the CPU to memory when via cache during a write operation\n\n- `cpu_ready(1-bit)`: A signal indication from the cache that data is ready for the CPU to be read.\n\n- `mem_strobe(1-bit)`: A signal that indicates that the memory is going to be accessed by the cache for a read or write operation\n\n- `mem_rw`: The read/write control signal for memory. It reflects the cpu_rw signal, indicating whether the operation is a read (0) or write (1) to memory.\n\n- `mem_addr(32-bit ,[31:0])`: A 32-bit output representing the memory address sent to the memory during the read/write operation from the cache.\n\n- `cache_hit(1-bit)` - A ACTIVE HIGH signal indicating memory location is available in Cache.\n\n- `cache_miss(1-bit)` - A ACTIVE HIGH signal indicating memory location is not available in Cache.\n\n- `d_data_out(32-bit,[31:0])` - Data at a particular index(location) of the cache.\n\n## Module Functionality:\n- Asynchronous Reset: When `rst_n` is asserted (`rst_n = 0`), all cache locations are invalidated .This ensures the cache is reset to a known state.\n\n- Cache Operation: On each rising edge of `clk`, the cache processes the incoming requests from the CPU:\n\n- Cache Read: If the CPU issues a read request and the address is present in the cache (`cache hit`), the corresponding data is returned to the CPU without accessing memory.\n\n- Cache Miss: If the CPU accesses a memory address that is not cached (`cache miss`), the cache issues a memory read request to the memory. Once the data is retrieved from memory, it is stored in the cache for future accesses.\n\n- Cache Write: If the CPU writes data, the cache writes the data into the cache entry corresponding to the address. If the operation is not cached (i.e., `uncached = 1`), the data is written directly to memory instead of the cache.\n\n- Cache Management: Each cache entry has a valid bit, a tag, and data. The tag is used to determine whether a cache entry matches the requested address, and the valid bit indicates whether the entry contains valid data. When a write operation occurs, the corresponding cache entry is updated with the new tag and data.\n\n- Memory Read/Write: If a cache miss occurs, the module performs a memory read operation (if `cpu_rw = 0`), waits for the memory to become ready (`mem_ready`), and then forwards the data to the CPU. Similarly, for write operations (`cpu_rw = 1`), the data is written to memory after it is cached.\n\n- Cache Write Signal: The cache write signal (`cache_write`) is asserted when a write operation occurs, either because the CPU is performing a write or because the cache is updating its contents after a cache miss.\n\n## **Edge Cases and Stress Testing** :\n- Handle edge cases such as boundary address tests, memory delays, multiple write operations followed by reads, and cache invalidation scenarios.\n- Stress test the cache with random address access and data input patterns.\n\n## **Checker Requirements**:\n\n**1. **Validation Logic****\n    - Implement tasks that compare the actual output against expected results. \n    - Each task performs the required comparison after a delay of 10-time units once invoked.\n    - Display results (pass/fail) for each test case. Provide success messages when expected and actual outputs match, and error messages when they don't.\n    - End the simulation after all test cases are completed.\n    \n **Validation Checkers** :\n\n -  `check_cache_read_miss`\n      Verifies that the correct data is fetched from memory during a cache read miss.\n      Checking operation : (`cpu_din == mem_dout`)\n\n -  `check_cache_write`\n     Ensures that the data is correctly written to the cache during a write operation.\n     Checking operation : (`d_data_dout == cpu_dout`)\n\n-  `check_cache_read_hit`\n    Confirm that the data read from the cache matches the expected value during a cache read hit.\n    Checking operation : (`cpu_din == d_data_dout`)\n\n-  `check_cache_write_after_reset`\n    Check if the data is correctly written to the cache after a reset.\n    Checking operation : (`d_data_dout == cpu_dout`)\n\n-  `check_multiple_writes_read`\n    Validates that the correct data is read from the cache after multiple write operations to the same address\n    Checking operation :  (`d_data_dout == cpu_dout`)\n \n-  `check_cache_miss_with_delays`\n    Verifies that the correct data is fetched from memory after a cache miss and a delay in memory readiness\n    Checking operation : (`cpu_din == mem_dout`)\n\n-  `check_uncached_io_access`\n    Ensures that uncached accesses are properly handled and data passes directly to the memory.\n    Checking operations : (`uncached == 1`) , (`mem_din == cpu_dout`)\n\n-  `check_random_access`\n    Ensures the data read from the random address does not match with data written to a random address\n    Checking operation : (`d_data_dout != cpu_dout`)\n\n-  `check_cache_invalidation`\n    Ensures that data is correctly fetched from memory after a cache invalidation.\n    Checking operation : (`cpu_din == mem_dout`)\n\n-  `check_boundary_address`\n    Validates correct data handling when accessing boundary addresses in memory.\n    Checking operation : (`d_data_dout == cpu_dout`) \n    Lower Boundary Address Used: `32'h00000000`\n    Upper Boundary Address Used: `32'hFFFFFFFC`\n\n-  `check_multiple_cache_hits_misses`\n    Verifies that multiple cache hits and misses are correctly handled in sequence.\n    Checking operations : (`cache_hit` && `cpu_din == d_data_dout`), (`!cache_hit` && `cpu_din == mem_dout`)\n     \n-  `check_cache_miss_and_delayed_memory_ready`\n    Check if the correct data is fetched after a cache miss and a delayed memory ready signal.\n    Checking operation : `cpu_din == mem_dout`\n\n## Deliverables:\nProvide a complete SystemVerilog testbench implementation that meets the above requirements and verifies the functionality of the `ddm_cache` module.", "context": {"verif/tb_ddm_cache.sv": "module tb_ddm_cache;\n\n  logic clk;\n  logic rst_n;\n  logic [31:0] cpu_addr;\n  logic [31:0] cpu_dout;\n  logic cpu_strobe;\n  logic cpu_rw;\n  logic uncached;\n  logic [31:0] mem_dout;\n  logic mem_ready;\n  logic [31:0] cpu_din;\n  logic [31:0] mem_din;\n  logic cpu_ready;\n  logic mem_strobe;\n  logic mem_rw;\n  logic [31:0] mem_addr;\n  logic cache_hit;\n  logic cache_miss;\n  logic [31:0] d_data_dout;\n\n  ddm_cache dut (\n    .clk(clk),\n    .rst_n(rst_n),\n    .cpu_addr(cpu_addr),\n    .cpu_dout(cpu_dout),\n    .cpu_strobe(cpu_strobe),\n    .cpu_rw(cpu_rw),\n    .uncached(uncached),\n    .mem_dout(mem_dout),\n    .mem_ready(mem_ready),\n    .cpu_din(cpu_din),\n    .mem_din(mem_din),\n    .cpu_ready(cpu_ready),\n    .mem_strobe(mem_strobe),\n    .mem_rw(mem_rw),\n    .mem_addr(mem_addr),\n    .cache_hit(cache_hit),\n    .cache_miss(cache_miss),\n    .d_data_dout(d_data_dout)\n  );\n\n  always begin\n    #5 clk = ~clk;\n  end\n\n  \n  initial begin\n    clk = 0;\n    rst_n = 0;\n    cpu_addr = 32'h00000000;\n    cpu_dout = 32'h12345678;\n    cpu_strobe = 0;\n    cpu_rw = 0;\n    uncached = 0;\n    mem_dout = 32'h00000000;\n    mem_ready = 1;\n\n    #10 rst_n = 1;\n    #10;\n\n    $display(\"Test case 1: Cache Read Miss (CPU address 0x00000000)\");\n    cpu_addr = 32'h00000000;\n    cpu_dout = 32'h12345678;\n    cpu_strobe = 1;\n    cpu_rw = 0;\n    uncached = 0;\n    mem_dout = 32'h11111111;\n    #10;\n    cpu_strobe = 0;\n    #50;\n    \n    $display(\"Test case 2: Cache Write (CPU address 0x00000004)\");\n    cpu_addr = 32'h00000004;\n    cpu_dout = 32'hAABBCCDD;\n    cpu_strobe = 1;\n    cpu_rw = 1;\n    uncached = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;\n    \n    $display(\"Test case 3: Cache Read Hit (CPU address 0x00000000, should hit cached data)\");\n    cpu_addr = 32'h00000000;\n    cpu_strobe = 1;\n    cpu_rw = 0;\n    uncached = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;\n        \n    $display(\"Test case 4: Cache Write and Read After Reset\");\n    rst_n = 0;\n    #10;\n    rst_n = 1;\n    #10;\n    cpu_addr = 32'h00000010;\n    cpu_dout = 32'hA1A2A3A4;\n    cpu_strobe = 1;\n    cpu_rw = 1;\n    uncached = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;  \n    #10;\n    cpu_addr = 32'h00000010;\n    cpu_strobe = 1;\n    cpu_rw = 0;\n    #10;\n    cpu_strobe = 0;\n        \n    $display(\"Test case 5: Edge case - Read after multiple writes\");\n    cpu_addr = 32'h00000014;\n    cpu_dout = 32'hDEADBEEF;\n    cpu_strobe = 1;\n    cpu_rw = 1; \n    uncached = 0; \n    #10;\n    cpu_rw = 0;\n    cpu_strobe = 0;\n    #10;  \n    \n    cpu_addr = 32'h00000014;\n    cpu_dout = 32'hFACEFEED;\n    cpu_strobe = 1;\n    cpu_rw = 1; \n    #10;\n    cpu_rw = 0;\n    cpu_strobe = 0;\n    #10;  \n    \n    cpu_strobe = 1;\n    cpu_rw = 0;  \n    #10;\n    cpu_strobe = 0;\n    \n        \n    $display(\"Test case 6: Cache Miss and Cache Write with Different Memory Delays\");\n    mem_ready = 0;  \n    cpu_addr = 32'h00000018;\n    cpu_dout = 32'h11223344; \n    cpu_strobe = 1;\n    cpu_rw = 1;   \n    uncached = 0; \n    #10;  \n    cpu_strobe = 0; \n    mem_ready = 1;  \n    #10;  \n    cpu_addr = 32'h00000018; \n    cpu_strobe = 1;\n    cpu_rw = 0;   \n    #10;\n    cpu_strobe = 0;\n\n    $display(\"Test case 7: Uncached IO Port Access\");\n    cpu_addr = 32'hF0000000;\n    cpu_dout = 32'hA5A5A5A5;\n    cpu_strobe = 1;\n    cpu_rw = 1;\n    uncached = 1;\n    #10;\n    cpu_strobe = 0;\n    #10;\n    \n    $display(\"Test case 8: Cache Read and Write with Randomized Addresses\");\n    cpu_addr = $random;\n    cpu_dout = $random;\n    cpu_strobe = 1;\n    cpu_rw = 1;\n    uncached = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;\n        \n    cpu_addr = $random;\n    cpu_dout = $random;\n    cpu_strobe = 1;\n    cpu_rw = 0;\n    uncached = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;\n        \n    $display(\"Test case 9: Cache Invalidations - Read Miss after Cache Invalidation\");\n    cpu_addr = 32'h00000020;\n    cpu_dout = 32'hDEADBEAF;\n    cpu_strobe = 1;\n    cpu_rw = 1;\n    uncached = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;\n\n    cpu_addr = 32'h00000020;\n    cpu_strobe = 1;\n    cpu_rw = 0;\n    mem_dout = 32'hBBBBBBBB;\n    #10;\n    cpu_strobe = 0;\n    #10;\n    \n    $display(\"Test case 10: Boundary Address Tests\");\n    cpu_addr = 32'h00000000;\n    cpu_strobe = 1;\n    cpu_rw = 1;\n    uncached = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;\n\n    cpu_addr = 32'hFFFFFFFC;\n    cpu_dout = 32'h22222222;\n    cpu_strobe = 1;\n    cpu_rw = 1;\n    uncached = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;\n        \n    $display(\"Test case 11: Test Multiple Cache Misses and Hits in Sequence\");\n    cpu_addr = 32'h00000024;\n    cpu_dout = 32'h77777777;\n    cpu_strobe = 1;\n    cpu_rw = 1;\n    uncached = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;\n    \n    cpu_addr = 32'h00000028;\n    cpu_dout = 32'h88888888;\n    cpu_strobe = 1;\n    cpu_rw = 1;\n    uncached = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;\n    cpu_addr = 32'h00000024;\n    cpu_strobe = 1;\n    cpu_rw = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;\n    cpu_addr = 32'h00000028;\n    cpu_strobe = 1;\n    cpu_rw = 0;\n    #10;\n    cpu_strobe = 0;\n    \n    $display(\"Test case 12: Memory Read with Cache Miss and Delayed Memory Ready\");\n    cpu_addr = 32'h00000050;\n    cpu_dout = 32'hAABBCCDD;\n    cpu_strobe = 1;\n    cpu_rw = 0;  \n    uncached = 0;\n    mem_dout = 32'h55555555;\n    mem_ready = 0;  \n    #10;\n    cpu_strobe = 0;\n    mem_ready = 1;  \n    cpu_strobe = 1; \n    #10;\n    cpu_strobe = 0;\n    \n    $finish;\n  end\n\n  \n  initial begin\n    $monitor(\"Time: %0t, clk: %b, rst_n: %b, cpu_addr: %h, cpu_data_out: %h, cpu_strobe: %b, cpu_rw: %b, uncached: %b, mem_dout: %h, mem_ready: %b, cpu_din: %h, mem_din: %h, cpu_ready: %b, mem_strobe: %b, mem_rw: %b, mem_addr: %h, cache_hit: %b , cache_miss: %b,d_data_dout : %b\", \n             $time, clk, rst_n, cpu_addr, cpu_dout, cpu_strobe, cpu_rw, uncached, mem_dout, mem_ready, cpu_din, mem_din, cpu_ready, mem_strobe, mem_rw, mem_addr, cache_hit, cache_miss,d_data_dout);\n  end\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_ddm_cache.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 97976eb4549d5846636bd1ef838a6ec1ac35da02\nNUM_BUGS        = 2\n", "src/ddm_cache.sv": "module ddm_cache (\n  input  logic        clk,           // Posedge clock\n  input  logic        rst_n,         // Asynchronous Negedge reset\n  input  logic [31:0] cpu_addr,      // Memory address emitted by the CPU\n  input  logic [31:0] cpu_dout,      // Data emitted by CPU\n  input  logic        cpu_strobe,    // CPU status signal to Cache to indicate it is going to perform a read or write operation\n  input  logic        cpu_rw,        // cpu_rw == 1, Memory Write Operation ; cpu_rw == 0 , Memory Read Operation\n  input  logic        uncached,      // uncached == 1 , IO port is accessed ; uncached == 0, Memory is accessed\n  input  logic [31:0] mem_dout,      // Data emitted by memory\n  input  logic        mem_ready,     // Memory is ready with the read data\n  output logic [31:0] cpu_din,       // CPU Data coming from Memory through Cache\n  output logic [31:0] mem_din,       // Memory Data coming from CPU through Cache\n  output logic        cpu_ready,     // Cache is ready with data to be provided to CPU\n  output logic        mem_strobe,    // Cache Status signal to Memory to indicate it is going to perform a read or write operation\n  output logic        mem_rw,        // mem_rw == 1, Memory Write Operation ; mem_rw == 0 , Memory Read Operation\n  output logic [31:0] mem_addr,      // Memory address to be accessed, emitted by the Cache\n  output logic        cache_hit,     // Indicates a memory location is available in the cache\n  output logic        cache_miss,    // Indicates a memory location is not available in the cache\n  output logic [31:0] d_data_dout     // Data at a cache index\n);\n\n  logic         d_valid [0:63];\n  logic [23:0]  d_tags  [0:63];\n  logic [31:0]  d_data  [0:63];\n  \n  logic [23:0] tag;\n  logic [5:0]  index;\n  \n  logic [31:0] cache_din;   \n  logic        cache_write; \n  logic [23:0] d_tag_out;\n  logic        valid;\n  logic [31:0] cache_dout;\n  \n  integer i;\n  \n  assign tag   = cpu_addr[31:8];\n  assign index = cpu_addr[7:2]; \n  assign cache_write = ~uncached & (cpu_rw | cache_miss & mem_ready); \n\n  `ifdef BUG_0\n    initial begin\n      $display(\"BUG_0 is ACTIVE: Cache validity is incorrectly marked as invalid during writes.\");\n    end\n  `else\n    initial begin\n      $display(\"BUG_0 is NOT ACTIVE: Cache validity is correctly marked as valid during writes.\");\n    end\n  `endif\n\n  `ifdef BUG_1\n    initial begin\n      $display(\"BUG_1 is ACTIVE: Incorrect cache hit/miss detection (uses ~valid instead of valid).\");\n    end\n  `else\n    initial begin\n      $display(\"BUG_1 is NOT ACTIVE: Correct cache hit/miss detection.\");\n    end\n  `endif\n  \n  `ifndef BUG_0\n    always_ff @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n          for (i = 0; i < 64; i = i + 1) begin\n              d_valid[i] <= 0;\n          end\n      end else if (cache_write) begin\n          d_valid[index] <= 1;  \n      end\n    end\n    \n  `else\n    always_ff @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n          for (i = 0; i < 64; i = i + 1) begin\n              d_valid[i] <= 0;\n          end\n      end else if (cache_write) begin\n          d_valid[index] <= 0;  \n      end\n    end\n  `endif\n\n  assign cache_din = cpu_rw ? cpu_dout : mem_dout;\n  always_ff@(posedge clk) begin\n       if(cache_write) begin\n            d_tags [index] <= tag;\n            d_data [index] <= cache_din;\n       end else begin\n             d_tags [index] <= d_tags[index] + 32'd0;\n             d_data [index] <= d_data[index] + 32'd0;\n       end\n  end  \n  \n  assign valid          = d_valid[index];\n  assign d_tag_out      = d_tags [index];\n  assign cache_dout     = d_data [index];\n  \n  `ifndef BUG_1\n    assign cache_hit      = cpu_strobe & valid & (d_tag_out == tag);\n    assign cache_miss     = cpu_strobe & (!valid | (d_tag_out != tag)); \n    \n  `else\n    assign cache_hit      = cpu_strobe & ~valid & (d_tag_out == tag);  \n    assign cache_miss     = cpu_strobe & (valid | (d_tag_out != tag)); \n  `endif\n  \n  assign mem_din        = cpu_dout;\n  assign mem_addr       = cpu_addr;\n  assign mem_rw         = cpu_rw;\n  assign mem_strobe     = cpu_strobe | cache_miss;\n  assign cpu_ready      = ~cpu_rw & cache_hit | (cache_miss | cpu_rw) & mem_ready; \n  assign cpu_din        = cache_hit ? cache_dout : mem_dout;\n  assign d_data_dout    = cache_dout;\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\nsim = f\"xrun /src/*.sv /code/verif/*.sv -seed random\"\n\ndef check_log(filename = \"sim.log\", expected = 0):\n\n    # ----------------------------------------\n    # - Check for errors in the log\n    # ----------------------------------------\n\n    with open(filename) as f:\n        lines = f.readlines()\n\n    errors = []\n    for line in lines[3:]:\n        errors.append(re.findall(r'*E', line))\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    assert len(errors) == expected, \"Simulation ended with error.\"\n\n@pytest.mark.usefixtures(scope='session')\ndef test_sanity():\n\n    res = subprocess.run(f\"{sim} -l /code/rundir/sanity.log\", shell=True)\n    assert(res.returncode == 0), \"Simulation ended with error.\"\n\n# ----------------------------------------\n# - Generate Bug Simulations\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_sanity')\ndef test_errors():\n\n    num_bugs = int(os.getenv(\"NUM_BUGS\"))\n\n    for i in range(num_bugs):\n        bug = f\"-define BUG_{i}=1\"\n        cmd = f\"{sim} {bug}\"\n\n        res = subprocess.run(f\"{cmd} -l /code/rundir/bug_{i}.log\", shell=True)\n        assert(res.returncode != 0), \"Simulation ended without error.\"\n"}}}
