{"id": "cvdp_agentic_Min_Hamming_Distance_Finder_0003", "categories": ["cid005", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"line_number s/old_statement/new_statement/\" file.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "Extend the existing RTL folder that includes `Min_Hamming_Distance_Finder`(`rtl/Min_Hamming_Distance_Finder.sv`) , `Data_Reduction`(`rtl/Data_Reduction.sv`), and `Bitwise_Reduction` (`rtl/Bitwise_Reduction.sv`) to add a new top-level module named `Adaptive_Binary_Pattern_Classifier`. This new module has to integrate Hamming distance-based matching, Gray-code-like feature extraction, and input uniformity detection into a single design suitable for binary pattern classification. The design reuses the existing Min_Hamming_Distance_Finder, Data_Reduction, and Bitwise_Reduction modules and adds configurable parameters for data width, reference count, and label width. The following files are to be present in `rtl` directory.\n\n- `rtl/Bitwise_Reduction.sv`\n- `rtl/Data_Reduction.sv`\n- `rtl/Bit_Difference_Counter.sv`\n- `rtl/Min_Hamming_Distance_Finder.sv`\n- `rtl/Adaptive_Binary_Pattern_Classifier.sv`\n\n---\n\n## Key Module: `Adaptive_Binary_Pattern_Classifier`\n\n### Purpose\n\nPerforms binary input classification by comparing an input vector against a set of reference vectors using Hamming distance, extracting a set of bitwise features, and checking for uniformity. Outputs include the predicted label from the closest match, distance, match index, features, and uniformity status.\n\n### Parameters\n\n- `BIT_WIDTH`: Defines the width of each input and reference pattern in bits, with a default value of 8. This must be a positive integer greater than or equal to 1.\n- `REFERENCE_COUNT`: Defines the number of reference patterns used for comparison, with a default value of 8. This must be a positive integer greater than or equal to 1.\n- `LABEL_WIDTH`: Defines the bit-width of the output label associated with each reference pattern, with a default value of 4. This must be a positive integer sufficient to represent all unique labels.\n---\n\n### Inputs\n\n- `input_query [BIT_WIDTH-1:0]`: A binary vector representing the input pattern to be classified. Its width is defined by the parameter BIT_WIDTH.\n- `reference_data [REFERENCE_COUNT*BIT_WIDTH-1:0]`: A concatenated array of binary reference patterns. Each reference is BIT_WIDTH bits wide, and there are REFERENCE_COUNT references.\n- `reference_labels [REFERENCE_COUNT*LABEL_WIDTH-1:0]`: A concatenated array of class labels corresponding to each reference pattern. Each label is LABEL_WIDTH bits wide, and there are REFERENCE_COUNT labels.\n\n---\n\n### Outputs\n\n- `predicted_label [LABEL_WIDTH-1:0]`: The output label corresponding to the reference pattern that best matches the input_query. The label is LABEL_WIDTH bits wide.\n- `min_distance [$clog2(BIT_WIDTH+1)-1:0]`: The minimum Hamming distance between the input_query and all reference patterns. Its width is calculated as the ceiling of log\u2082(BIT_WIDTH+1) to accommodate the maximum possible distance.\n- `match_index [$clog2(REFERENCE_COUNT)-1:0]`: The index of the reference pattern which has the minimum Hamming distance to the input_query. Its width is determined by the ceiling of log\u2082(REFERENCE_COUNT).\n- `bitwise_features [BIT_WIDTH-1:0]`: A set of features extracted by performing a bitwise XOR between the original input_query and its 1-bit right-shifted version, resulting in a BIT_WIDTH-bit output.\n- `is_input_uniform`: A single-bit flag indicating whether all bits in `input_query` are uniform. A high signal indicates that the input is uniform.\n\n---\n\n### Functional Description\n\n#### Best Match Identification:\n- The module instantiates the `Min_Hamming_Distance_Finder` to calculate the Hamming distance between the `input_query` and each reference in `reference_data`. The module produces both the best match index (`match_index`) and the associated minimum distance (`min_distance`).\n\n#### Label Prediction:\n- Using the best match index generated by the Hamming distance module, the corresponding label is selected from `reference_labels` and output as `predicted_label`.\n\n#### Bitwise Feature Extraction:\n- The `input query` is shifted right by one bit. The module then applies the `Data_Reduction` block with a 2-input XOR reduction on the concatenated original and shifted vectors. The result is provided as `bitwise_features`, representing extracted Gray-coded features.\n\n#### Uniformity Check:\n- The module uses a `Bitwise_Reduction` block performing an AND reduction on the original input_query bits to set the `is_input_uniform` flag. This flag indicates if all bits of the input are uniform.\n\n---\n\n## Example Operation\n\n**Input:**\n- `input_query` = `8'b11001100`\n- `reference_data` = `{8'b11001101, 8'b10011001, 8'b11110000, 8'b11001110}`\n- `reference_labels` = `{4'b0001, 4'b0010, 4'b0011, 4'b0100}`\n\n**Expected Outputs:**\n- `predicted_label` = `4'b0001`\n- `min_distance` = `1`\n- `match_index` = `0`\n- `bitwise_features` = `8'b10101010` \n- `is_input_uniform` = `0` \n\n## Testbench Implementation:\n\n### Testbench File: \n- Create a SystemVerilog testbench (`tb_Min_Hamming_Distance_Finder.sv`) that generates stimulus only and save it in the verif directory.\n\n### Module Instance:\n- Instantiate the Adaptive_Binary_Pattern_Classifier module as uut (Unit Under Test) within the testbench. The module should be parameterized with BIT_WIDTH, REFERENCE_COUNT, and LABEL_WIDTH, and properly wired to the testbench signals.\n\n### Tasks:\n- Implement reusable and clearly defined tasks to drive different stimulus scenarios for verifying the classifier module's functionality. The tasks should include the following:\n\n#### 1. Corner Case Testing Task \n- Test various edge-case scenarios to validate correctness and robustness:\n   - Scenario 1: All references are identical to the input query (expected minimum Hamming distance = 0).\n   - Scenario 2: All references are completely different from the input (maximum possible distance).\n   - Scenario 3: Only one reference perfectly matches the input.\n   - Scenario 4: Two or more references result in tied minimum Hamming distances.\n   - Scenario 5: Input query is all zeros with nonzero reference patterns.\n\n- Each scenario should include structured logging using a custom task that prints query, reference data, labels, predicted label, computed distance, match index, and feature vector.\n\n#### 2. Feature Extraction & Uniformity Testing Task \n- Test feature logic that computes the bitwise Gray code and detects uniform input patterns:\n   - Test 1: Input is all 1s \u2013 check that is_input_uniform is high.\n   - Test 2: Input is all 0s \u2013 check expected behavior of bitwise_features and is_input_uniform.\n- Each test prints status messages and confirms logic correctness through readable output.\n\n#### 3. Randomized Testing Task \n- Randomly generate input queries, reference vectors, and labels to stimulate the module under varied conditions:\n- Run at least 50 randomized test cases.\n- For each case:\n   - Randomize input_query.\n   - Generate and assign random values to reference_data and reference_labels.\n   - Optionally track the expected minimum Hamming distance and index to cross-check correctness.\n   - Print detailed output for review using the print task.\n\n#### 4. Structured Input Application Task \n- Provide a reusable task for consistent and informative logging of test case details. The task should display the following:\n  - Query vector.\n  - Each reference's data and associated label.\n  - Output from the DUT: predicted label, index of closest match, minimum Hamming distance.\n  - Feature extraction result and uniformity detection flag.\n\n### Test Execution Control:\n- Start simulation by displaying a header.\n- First call the Corner Case Testing Task.\n- Then invoke the feature extraction & uniformity testing task.\n- Follow with a loop calling the randomized testing task repeatedly.\n- End simulation cleanly using $finish after completing all stimulus.\n", "context": {"rtl/Bit_Difference_Counter.sv": "`timescale 1ns / 1ps\nmodule Bit_Difference_Counter\n#(\n    parameter BIT_WIDTH    = 3,                          // Defines the width of the input vectors.\n    localparam COUNT_WIDTH = $clog2(BIT_WIDTH + 1)       // Calculates the width required to represent the count of differing bits.\n)\n(\n    input  wire [BIT_WIDTH-1:0] input_A,                // First input vector.\n    input  wire [BIT_WIDTH-1:0] input_B,                // Second input vector.\n    output reg  [COUNT_WIDTH-1:0] bit_difference_count  // Count of differing bits (Hamming distance).\n);\n\n    wire [BIT_WIDTH-1:0] different_bits;\n    integer idx;\n\n    // Instantiate the Data_Reduction module to compute bitwise XOR between input_A and input_B.\n    Data_Reduction\n    #(\n        .REDUCTION_OP (3'b010), // XOR operation\n        .DATA_WIDTH  (BIT_WIDTH),\n        .DATA_COUNT  (2)\n    )\n    compare_bits\n    (\n        .data_in      ({input_A, input_B}),\n        .reduced_data_out   (different_bits)\n    );\n\n    // Count set bits in different_bits to compute Hamming distance\n    always @(*) begin\n        bit_difference_count = 0;\n        for (idx = 0; idx < BIT_WIDTH; idx = idx + 1) begin\n            bit_difference_count = bit_difference_count + different_bits[idx];\n        end\n    end\n\nendmodule", "rtl/Bitwise_Reduction.sv": "`timescale 1ns / 1ps\nmodule Bitwise_Reduction\n#(\n    parameter [2:0] REDUCTION_OP = 3'b000, // Default operation: AND\n    parameter BIT_COUNT          = 4       // Number of bits to reduce\n)\n(\n    input  wire [BIT_COUNT-1:0] input_bits,\n    output reg                  reduced_bit\n);\n\n    // Reduction Operation Codes\n    localparam [2:0] AND_OP  = 3'b000;\n    localparam [2:0] OR_OP   = 3'b001;\n    localparam [2:0] XOR_OP  = 3'b010;\n    localparam [2:0] NAND_OP = 3'b011;\n    localparam [2:0] NOR_OP  = 3'b100;\n    localparam [2:0] XNOR_OP = 3'b101;\n\n    int i;\n    reg temp_result; \n\n    always @(*) begin\n        temp_result = input_bits[0];\n\n        for (i = 1; i < BIT_COUNT; i = i + 1) begin\n            case (REDUCTION_OP)\n                AND_OP, NAND_OP  : temp_result = temp_result & input_bits[i];\n                OR_OP,  NOR_OP   : temp_result = temp_result | input_bits[i];\n                XOR_OP, XNOR_OP  : temp_result = temp_result ^ input_bits[i];\n                default          : temp_result = temp_result & input_bits[i];\n            endcase\n        end\n\n        case (REDUCTION_OP)\n            NAND_OP : reduced_bit = ~temp_result;\n            NOR_OP  : reduced_bit = ~temp_result;\n            XNOR_OP : reduced_bit = ~temp_result;\n            default : reduced_bit = temp_result;\n        endcase\n    end\nendmodule", "rtl/Data_Reduction.sv": "`timescale 1ns / 1ps\nmodule Data_Reduction\n#(\n    parameter [2:0] REDUCTION_OP = 3'b000, // Default operation: AND\n    parameter DATA_WIDTH         = 4,      // Width of each data element\n    parameter DATA_COUNT         = 4,      // Number of data elements\n    localparam TOTAL_INPUT_WIDTH = DATA_WIDTH * DATA_COUNT\n)\n(\n    input  wire [TOTAL_INPUT_WIDTH-1:0] data_in,\n    output reg  [DATA_WIDTH-1:0]        reduced_data_out\n);\n\n    generate\n        genvar bit_index;\n\n        for (bit_index = 0; bit_index < DATA_WIDTH; bit_index = bit_index + 1) begin : bit_processing\n            wire [DATA_COUNT-1:0] extracted_bits;\n\n            genvar data_index;\n            for (data_index = 0; data_index < DATA_COUNT; data_index = data_index + 1) begin : bit_extraction\n                assign extracted_bits[data_index] = data_in[(data_index * DATA_WIDTH) + bit_index];\n            end\n\n            Bitwise_Reduction\n            #(\n                .REDUCTION_OP (REDUCTION_OP),\n                .BIT_COUNT    (DATA_COUNT)\n            )\n            reducer_instance\n            (\n                .input_bits  (extracted_bits),\n                .reduced_bit (reduced_data_out[bit_index])\n            );\n        end\n    endgenerate\n\nendmodule", "rtl/Min_Hamming_Distance_Finder.sv": "`timescale 1ns / 1ps\nmodule Min_Hamming_Distance_Finder\n#(\n    parameter BIT_WIDTH      = 8,  // Width of each reference and the query\n    parameter REFERENCE_COUNT = 4  // Number of reference vectors\n)\n(\n    input  wire [BIT_WIDTH-1:0]                           input_query,\n    input  wire [REFERENCE_COUNT*BIT_WIDTH-1:0]           references,\n    output reg  [$clog2(REFERENCE_COUNT)-1:0]             best_match_index,\n    output reg  [$clog2(BIT_WIDTH+1)-1:0]                 min_distance\n);\n\n    wire [$clog2(BIT_WIDTH+1)-1:0] distance [0:REFERENCE_COUNT-1];\n    genvar i;\n    \n    generate \n        for (i = 0; i < REFERENCE_COUNT; i = i + 1) begin : calc_distance\n            Bit_Difference_Counter\n            #(\n                .BIT_WIDTH (BIT_WIDTH)\n            )\n            distance_inst\n            (\n                .input_A (input_query),\n                .input_B (references[i*BIT_WIDTH +: BIT_WIDTH]),\n                .bit_difference_count (distance[i])\n            );\n        end\n    endgenerate\n\n    integer j;\n    always @(*) begin\n        min_distance     = {($clog2(BIT_WIDTH+1)){1'b1}}; // Start with max\n        best_match_index = {($clog2(REFERENCE_COUNT)){1'b0}};\n        for (j = 0; j < REFERENCE_COUNT; j = j + 1) begin\n            if (distance[j] < min_distance) begin\n                min_distance     = distance[j];\n                best_match_index = j[$clog2(REFERENCE_COUNT)-1:0];\n            end\n        end\n    end\n\nendmodule"}, "patch": {"rtl/Adaptive_Binary_Pattern_Classifier.sv": "", "verif/tb_Min_Hamming_Distance_Finder.sv": ""}, "harness": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v \n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true  \n", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/Bitwise_Reduction.sv /code/rtl/Data_Reduction.sv /code/rtl/Bit_Difference_Counter.sv /code/rtl/Min_Hamming_Distance_Finder.sv /code/rtl/Adaptive_Binary_Pattern_Classifier.sv\nTOPLEVEL        = Adaptive_Binary_Pattern_Classifier\nMODULE          = adaptive_parameterized_test\nPYTHONPATH      = /src\nHASH            = b24bc65ef641b9eeea34c57199e0c085c2383b6f\nTARGET          = 98\n", "src/adaptive_parameterized_test.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ReadOnly , Timer\n\nimport harness_library as hrs_lb\nimport random\n\n# ---------------------------------------\n# Helper: Hamming Distance Function\n# ---------------------------------------\ndef compute_hamming(a, b, width):\n    return bin(a ^ b).count('1')\n\n# ---------------------------------------\n# Helper: Reference Data Packer\n# ---------------------------------------\ndef pack_refs_and_labels(refs, labels, bit_width, label_width):\n    ref_data = 0\n    label_data = 0\n    for i, (ref, label) in enumerate(zip(refs, labels)):\n        ref_data   |= (ref   << (i * bit_width))\n        label_data |= (label << (i * label_width))\n    return ref_data, label_data\n\n\ndef assert_outputs(dut, query, refs, labels, bit_width):\n    # Compute expected values\n    best_dist = bit_width + 1\n    best_idx  = 0\n    for i, ref in enumerate(refs):\n        d = compute_hamming(query, ref, bit_width)\n        if d < best_dist:\n            best_dist = d\n            best_idx = i\n\n    expected_label = labels[best_idx]\n\n    assert dut.min_distance.value == best_dist, f\"[FAIL] Expected min_distance={best_dist}, got={dut.min_distance.value}\"\n    assert dut.match_index.value == best_idx, f\"[FAIL] Expected match_index={best_idx}, got={dut.match_index.value}\"\n    assert dut.predicted_label.value == expected_label, f\"[FAIL] Expected predicted_label={expected_label}, got={dut.predicted_label.value}\"\n\n    cocotb.log.info(f\"[ASSERTION PASS] Outputs validated: match_index={best_idx}, min_distance={best_dist}, label={expected_label}\")\n\n# ---------------------------------------\n# Corner Case Runner\n# ---------------------------------------\nasync def run_corner_cases(dut, BIT_WIDTH, REFERENCE_COUNT, LABEL_WIDTH):\n    cocotb.log.info(\"Running Corner Case Tests...\")\n\n    # All references match input_query\n    query = int('1' * BIT_WIDTH, 2)\n    refs  = [query] * REFERENCE_COUNT\n    labels = list(range(REFERENCE_COUNT))\n    ref_data, label_data = pack_refs_and_labels(refs, labels, BIT_WIDTH, LABEL_WIDTH)\n    dut.input_query.value = query\n    dut.reference_data.value = ref_data\n    dut.reference_labels.value = label_data\n    await Timer(1, units='ns')\n    assert_outputs(dut, query, refs, labels, BIT_WIDTH)\n\n    # One exact match among others\n    query = int('11001100', 2) & ((1 << BIT_WIDTH) - 1)\n    refs = [int('11110000', 2) & ((1 << BIT_WIDTH) - 1),\n            int('10101010', 2) & ((1 << BIT_WIDTH) - 1),\n            query,\n            0]\n    while len(refs) < REFERENCE_COUNT:\n        refs.append(random.getrandbits(BIT_WIDTH))\n    labels = list(range(REFERENCE_COUNT))\n    ref_data, label_data = pack_refs_and_labels(refs, labels, BIT_WIDTH, LABEL_WIDTH)\n    dut.input_query.value = query\n    dut.reference_data.value = ref_data\n    dut.reference_labels.value = label_data\n    await Timer(1, units='ns')\n    assert_outputs(dut, query, refs, labels, BIT_WIDTH)\n\n    # Tied distances case\n    query = int('00001111', 2) & ((1 << BIT_WIDTH) - 1)\n    ref_tie = int('00011111', 2) & ((1 << BIT_WIDTH) - 1)\n    refs = [ref_tie, ref_tie] + [random.getrandbits(BIT_WIDTH) for _ in range(REFERENCE_COUNT - 2)]\n    labels = list(range(REFERENCE_COUNT))\n    ref_data, label_data = pack_refs_and_labels(refs, labels, BIT_WIDTH, LABEL_WIDTH)\n    dut.input_query.value = query\n    dut.reference_data.value = ref_data\n    dut.reference_labels.value = label_data\n    await Timer(1, units='ns')\n    assert_outputs(dut, query, refs, labels, BIT_WIDTH)\n\n    # One-hot refs and all-zero input\n    query = 0\n    refs = [1 << i for i in range(min(REFERENCE_COUNT, BIT_WIDTH))]\n    while len(refs) < REFERENCE_COUNT:\n        refs.append(random.getrandbits(BIT_WIDTH))\n    labels = list(range(REFERENCE_COUNT))\n    ref_data, label_data = pack_refs_and_labels(refs, labels, BIT_WIDTH, LABEL_WIDTH)\n    dut.input_query.value = query\n    dut.reference_data.value = ref_data\n    dut.reference_labels.value = label_data\n    await Timer(1, units='ns')\n    assert_outputs(dut, query, refs, labels, BIT_WIDTH)\n\n    # Alternating bits input\n    query = int('10' * (BIT_WIDTH // 2), 2)\n    refs = [query, ~query & ((1 << BIT_WIDTH) - 1)] + [0xFF, 0x00]\n    refs = refs[:REFERENCE_COUNT]\n    labels = list(range(REFERENCE_COUNT))\n    ref_data, label_data = pack_refs_and_labels(refs, labels, BIT_WIDTH, LABEL_WIDTH)\n    dut.input_query.value = query\n    dut.reference_data.value = ref_data\n    dut.reference_labels.value = label_data\n    await Timer(1, units='ns')\n    assert_outputs(dut, query, refs, labels, BIT_WIDTH)\n\n# ---------------------------------------\n# Cocotb Main Test\n# ---------------------------------------\n@cocotb.test()\nasync def adaptive_parameterized_test(dut):\n    # Read parameters from the DUT\n    BIT_WIDTH        = int(dut.BIT_WIDTH.value)\n    REFERENCE_COUNT  = int(dut.REFERENCE_COUNT.value)\n    LABEL_WIDTH      = int(dut.LABEL_WIDTH.value)\n\n    cocotb.log.info(f\"Detected DUT Parameters: BIT_WIDTH={BIT_WIDTH}, REFERENCE_COUNT={REFERENCE_COUNT}, LABEL_WIDTH={LABEL_WIDTH}\")\n    \n    await run_corner_cases(dut, BIT_WIDTH, REFERENCE_COUNT, LABEL_WIDTH)\n\n    # Setup constants for signal widths\n    ref_width   = REFERENCE_COUNT * BIT_WIDTH\n    label_width = REFERENCE_COUNT * LABEL_WIDTH\n\n    # --- CORNER TEST 1: All references match input ---\n    query = int('1' * BIT_WIDTH, 2)\n    refs  = [query] * REFERENCE_COUNT\n    labels = list(range(REFERENCE_COUNT))\n    ref_data, label_data = pack_refs_and_labels(refs, labels, BIT_WIDTH, LABEL_WIDTH)\n    dut.input_query.value = query\n    dut.reference_data.value = ref_data & ((1 << ref_width) - 1)\n    dut.reference_labels.value = label_data & ((1 << label_width) - 1)\n    await Timer(1, units='ns')\n    assert_outputs(dut, query, refs, labels, BIT_WIDTH)\n\n    # --- CORNER TEST 2: All references different ---\n    query = int('1' * BIT_WIDTH, 2)\n    refs = [0x00] * REFERENCE_COUNT\n    labels = list(range(REFERENCE_COUNT))\n    ref_data, label_data = pack_refs_and_labels(refs, labels, BIT_WIDTH, LABEL_WIDTH)\n    dut.input_query.value = query\n    dut.reference_data.value = ref_data & ((1 << ref_width) - 1)\n    dut.reference_labels.value = label_data & ((1 << label_width) - 1)\n    await Timer(1, units='ns')\n    assert dut.min_distance.value == BIT_WIDTH, f\"[FAIL] All references different: Expected min_distance = {BIT_WIDTH}\"\n    cocotb.log.info(\"[PASS] All references different\")\n\n    # --- CORNER TEST 3: is_input_uniform for all 1s ---\n    dut.input_query.value = int('1' * BIT_WIDTH, 2)\n    await Timer(1, units='ns')\n    assert int(dut.is_input_uniform.value) == 1, \"[FAIL] is_input_uniform = 0 for all 1s input\"\n    cocotb.log.info(\"[PASS] is_input_uniform works for all 1s\")\n\n\n    # --- RANDOMIZED FUNCTIONAL TESTS ---\n    for test_num in range(30):\n        query = random.getrandbits(BIT_WIDTH)\n        refs = [random.getrandbits(BIT_WIDTH) for _ in range(REFERENCE_COUNT)]\n        labels = [random.randint(0, (1 << LABEL_WIDTH) - 1) for _ in range(REFERENCE_COUNT)]\n\n        # Compute expected best match\n        min_dist = BIT_WIDTH + 1\n        match_idx = 0\n        for i, ref in enumerate(refs):\n            dist = compute_hamming(query, ref, BIT_WIDTH)\n            if dist < min_dist:\n                min_dist = dist\n                match_idx = i\n\n        ref_data, label_data = pack_refs_and_labels(refs, labels, BIT_WIDTH, LABEL_WIDTH)\n        dut.input_query.value = query\n        dut.reference_data.value = ref_data\n        dut.reference_labels.value = label_data\n        await Timer(1, units='ns')\n\n        assert dut.min_distance.value == min_dist, f\"[FAIL] Random test #{test_num}: Wrong min_distance\"\n        assert dut.match_index.value == match_idx, f\"[FAIL] Random test #{test_num}: Wrong match_index\"\n        assert dut.predicted_label.value == labels[match_idx], f\"[FAIL] Random test #{test_num}: Wrong label\"\n\n        cocotb.log.info(f\"[PASS] Random Test #{test_num} | Query={query:0{BIT_WIDTH}b} | Best Match Index={match_idx} | Distance={min_dist} | Label={labels[match_idx]}\")\n\n    cocotb.log.info(\" All parameterized functional tests passed.\")\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /code/rtl/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Simulation didn't run correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage merge didn't run correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    try:\n        with open(\"/code/rundir/coverage.log\") as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage.log file.\")\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    print(\"Parsed Metrics:\")\n    print(metrics)\n\n    # Ensure TARGET environment variable is set\n    target = os.getenv(\"TARGET\")\n    if not target:\n        raise ValueError(\"TARGET environment variable is not set.\")\n    target = float(target)\n\n    # Check coverage for the DUT or specific key\n    uut = \"uut\"  # Replace this with the DUT key you want to check\n    if uut in metrics and \"Overall Average\" in metrics[uut]:\n        assert float(metrics[uut][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        # Log available keys for debugging\n        print(f\"Available keys in metrics: {metrics.keys()}\")\n        assert False, f\"Coverage data for '{uut}' is not available.\"\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(BIT_WIDTH: int = 8,REFERENCE_COUNT: int = 4 , LABEL_WIDTH: int = 4):\n\n    parameter = {\n        \"BIT_WIDTH\": BIT_WIDTH,\"REFERENCE_COUNT\" : REFERENCE_COUNT, \"LABEL_WIDTH\" : LABEL_WIDTH\n    }\n  \n    print(f\"[DEBUG] Parameters: {parameter}\")\n    \n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n\n@pytest.mark.parametrize(\"test\", range(1))\n@pytest.mark.parametrize(\"BIT_WIDTH\", [4, 10, 8, 32])\n@pytest.mark.parametrize(\"REFERENCE_COUNT\", [4,8])\n@pytest.mark.parametrize(\"LABEL_WIDTH\", [4,8])\ndef test_min_distance(test, BIT_WIDTH,REFERENCE_COUNT,LABEL_WIDTH):\n    runner(BIT_WIDTH=BIT_WIDTH, REFERENCE_COUNT=REFERENCE_COUNT,LABEL_WIDTH=LABEL_WIDTH)"}}
{"id": "cvdp_agentic_helmholtz_0001", "categories": ["cid005", "hard"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"problematic_line_number s/problematic_statement/non_problematic_statement/\" Buggy_RTL_code.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have the below submodules in the `rtl/` directory that together implement a dynamic, frequency-calibrated audio processing system based on Helmholtz resonance principles:\n\n- `helmholtz_resonator`: Performs band-pass filtering with internal automatic calibration logic that adjusts resonance frequency to match a target input frequency using a feedback loop. The `calibrate` input initiates calibration, and `cal_done` indicates when it is complete.\n- `modulator`: Generates a modulation waveform that varies the target frequency dynamically over time.\n- `soft_clipper`: Applies non-linear soft-clipping to the processed output signal to prevent overflow and simulate analog saturation.\n- `resonator_bank`: Instantiates three `helmholtz_resonator` submodules (low, mid, high bands) and manages their calibration and output mixing.\n- `helmholtz_top_module`: Serves as the full system integration point, combining modulation, frequency-calibrated filtering, and output shaping.\n\nThe specification for the system\u2019s top-level interface is defined in `docs/Helmholtz_Audio_Spec.md`. Follow this spec precisely when defining ports, calibration signals, modulation behavior, and audio path integration.\n\nThe final top-level module `helmholtz_top_module` should:\n\n1. **Integrate all submodules** with appropriate signal routing per the specification.\n2. **Support automatic calibration** for each of the three internal resonators in `resonator_bank`, which must report completion via `cal_done_flags`.\n3. **Drive target frequencies** per resonator using the base frequency input plus modulation offsets.\n4. **Conditionally enable modulation** of the base frequency using the `modulator` when `mod_enable` is high.\n5. **Pass the filtered audio signal** through the `soft_clipper` for final shaping.\n6. **Expose all control and status ports**, including:\n   - `calibrate` (start calibration)\n   - `cal_done_flags` (per-band calibration completion)\n   - `audio_in`, `audio_out`\n   - `base_freq`, `q_factor`, and `mod_enable`\n7. **Support fixed-point signed audio processing ** parameterized with [15:0] 16-bit width and [7:0] 8-bit fractional resolution internally.\n\n---\n\n###  Testbench Requirement\n\nIn addition to creating the `helmholtz_top_module`, develop a **SystemVerilog testbench** named `tb.sv` that:\n\n- Instantiates `helmholtz_top_module` and applies a range of input signals for functional testing.\n- Initializes system clock and reset.\n- Drives multiple audio test patterns into `audio_in`, including:\n  - Constant tones\n  - Amplitude modulation (AM)\n  - Silence (zero input)\n  - Fast waveform transitions\n- Asserts `calibrate` and waits for all `cal_done_flags` to be set, verifying calibration behavior.\n- Toggles `mod_enable` to test with and without modulation.\n- Monitors `audio_out` and ensures it stays within expected limits (i.e., clipped properly).\n- Includes at least:\n  - One **modulated calibration test**\n  - One **static tone test** (no modulation)\n  - One **zero-input pass-through test**\n- Logs `cal_done_flags`, frequency settings, and audio output results for analysis.\n- Optionally introduces edge-case conditions:\n  - Minimum and maximum values for `base_freq` and `q_factor`\n  - Rapid toggling of `calibrate` and `mod_enable`\n  - Observes soft-clipper limits on high-amplitude input\n\nImplement the top module in a single file named `tb.sv` and the associated testbench in `tb_helmholtz_top.sv. ' Ensure all behaviors comply with the provided spec and are verified via simulation.\n\n---\n", "context": {"docs/Helmholtz_Audio_Spec.md": "# Helmholtz Resonator Audio Processor Specification\n\n## Overview\n\nThe Helmholtz Resonator Audio Processor is a synthesizable, modular SystemVerilog design that emulates acoustic resonance behavior in digital hardware. It features real-time calibration, multi-band filtering, modulation, and output shaping via soft clipping. This system is ideal for audio applications such as equalization, tone shaping, acoustic simulation, and embedded music synthesis.\n\n---\n\n## Top-Level Module: `helmholtz_top_module`\n\n### Port Descriptions\n\n| Signal            | Direction | Width        | Description                                         |\n|-------------------|-----------|--------------|-----------------------------------------------------|\n| `clk`             | input     | 1            | System clock                                        |\n| `rst`             | input     | 1            | Synchronous reset, active high                      |\n| `calibrate`       | input     | 1            | Triggers calibration mode across all bands          |\n| `audio_in`        | input     | 16 (signed)  | Input audio sample (fixed-point)                   |\n| `base_freq`       | input     | 16           | Central target frequency for resonance              |\n| `q_factor`        | input     | 8            | Bandwidth control (Q)                               |\n| `mod_enable`      | input     | 1            | Enables modulation of target frequency              |\n| `cal_done_flags`  | output    | 3            | Calibration done flags for low/mid/high bands       |\n| `audio_out`       | output    | 16 (signed)  | Processed and clipped audio output                  |\n\n---\n\n## Submodules and Responsibilities\n\n### `helmholtz_resonator`\n\n- Performs band-pass filtering using a feedback loop.\n- Internal calibration loop aligns `current_freq` with `target_freq`.\n- Outputs `cal_done` once frequency lock is achieved within `CAL_TOLERANCE`.\n\n**Parameters:**\n- `WIDTH = 16`\n- `FRAC_BITS = 8`\n- `CAL_TOLERANCE = 10` (percentage)\n\n**Ports:**\n- Inputs: `clk`, `rst`, `calibrate`, `audio_in`, `target_freq`, `q_factor`\n- Outputs: `cal_done`, `audio_out`\n\n---\n\n### `modulator`\n\n- Produces a simple modulation waveform.\n- Used to vary `target_freq` for each band dynamically.\n\n**Ports:**\n- Inputs: `clk`, `rst`, `enable`\n- Output: `mod_signal` (16-bit)\n\n---\n\n### `soft_clipper`\n\n- Applies soft saturation to limit signal peaks without harsh distortion.\n\n**Ports:**\n- Input: `in_signal` (signed)\n- Output: `out_signal` (signed)\n\n---\n\n### `resonator_bank`\n\n- Instantiates 3 `helmholtz_resonator` modules (low, mid, high).\n- Computes target frequencies using `mod_signal` offset:\n  - Low: `base_freq + mod_signal[7:0]`\n  - Mid: `base_freq + mod_signal[9:2]`\n  - High: `base_freq + mod_signal[11:4]`\n- Sums the filtered outputs.\n\n**Ports:**\n- Inputs: `clk`, `rst`, `calibrate`, `audio_in`, `base_freq`, `q_factor`, `mod_signal`\n- Outputs: `cal_done_flags`, `audio_out`\n\n---\n\n## Functional Behavior\n\n### Calibration Flow\n\n- Triggered via `calibrate = 1`\n- Each band adjusts its internal frequency (`current_freq`) to match `target_freq`\n- Calibration completes when error < `CAL_TOLERANCE` (10%)\n- `cal_done_flags[n] = 1` indicates that band `n` has locked on frequency\n\n### Processing Flow\n\n- Begins when `calibrate = 0`\n- Audio samples are filtered through each calibrated resonator\n- Outputs are combined and passed to the `soft_clipper`\n\n### Modulation\n\n- Enabled via `mod_enable = 1`\n- The `modulator` adjusts each band\u2019s `target_freq` offset independently\n\n---\n\n## Reset and Clocking\n\n- `clk`: Global rising-edge clock\n- `rst`: Resets all state machines and internal registers\n- All modules should respond synchronously to `clk` and `rst`\n\n---\n\n## Output Characteristics\n\n- `audio_out` is zero during calibration\n- After calibration, `audio_out` is the result of band-passed, clipped audio\n- Output range is limited to \u00b120480 by the soft clipper\n\n---\n\n## Testbench Requirements\n\n### File: `tb_helmholtz_top.sv`\n\nThe testbench must:\n\n- Initialize and apply `clk`, `rst`, and control inputs\n- Drive meaningful test patterns into `audio_in` such as:\n  - Constant tones\n  - Silence (zero input)\n  - Square or triangle waves\n- Sweep `base_freq` and `q_factor`\n- Toggle `mod_enable` during runtime\n- Assert `calibrate`, then observe `cal_done_flags` going high\n- Monitor `audio_out` for:\n  - Signal presence after calibration\n  - Clipping within the allowed range\n- Include coverage of:\n  - All bands calibrating correctly\n  - Modulated vs static operation\n  - Corner cases: max/min frequency, zero input, long calibration loops\n\n---\n\n", "rtl/helmholtz_resonator.sv": "module helmholtz_resonator #(\n    parameter WIDTH = 16,\n    parameter FRAC_BITS = 8,\n    parameter CAL_TOLERANCE = 10 // 10% tolerance\n)(\n    input logic clk,\n    input logic rst,\n    input logic calibrate,\n    input logic signed [WIDTH-1:0] audio_in,\n    input logic [15:0] target_freq,\n    input logic [7:0] q_factor,\n    output logic cal_done,\n    output logic signed [WIDTH-1:0] audio_out\n);\n\n    typedef enum logic [1:0] { IDLE, CALIBRATING, DONE, PROCESSING } state_t;\n    state_t state, next_state;\n\n    logic [15:0] current_freq;\n    logic signed [15:0] freq_error;\n    logic [15:0] calibration_factor;\n\n    logic signed [WIDTH-1:0] x, y, fb;\n    logic signed [WIDTH-1:0] coeff_a, coeff_b;\n\n    // Frequency error\n    always_comb begin\n        if (target_freq > current_freq)\n            freq_error = target_freq - current_freq;\n        else\n            freq_error = current_freq - target_freq;\n    end\n\n    // State machine and calibration logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            calibration_factor <= 16'd128;\n            current_freq <= 16'd100;\n            cal_done <= 0;\n        end else begin\n            state <= next_state;\n\n            if (state == CALIBRATING) begin\n                if (current_freq < target_freq)\n                    calibration_factor <= calibration_factor + 1;\n                else if (current_freq > target_freq)\n                    calibration_factor <= calibration_factor - 1;\n\n                current_freq <= (calibration_factor * 2);\n            end\n\n            cal_done <= (state == DONE);\n        end\n    end\n\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE: if (calibrate) next_state = CALIBRATING;\n            CALIBRATING: if ((freq_error * 100 / target_freq) < CAL_TOLERANCE) next_state = DONE;\n            DONE: if (!calibrate) next_state = PROCESSING;\n            PROCESSING: if (calibrate) next_state = CALIBRATING;\n        endcase\n    end\n\n    always_comb begin\n        coeff_a = calibration_factor;\n        coeff_b = q_factor;\n    end\n\n    // Filtering operation\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            x <= 0; y <= 0; fb <= 0;\n        end else if (state == PROCESSING) begin\n            x <= audio_in - (fb * coeff_b >>> FRAC_BITS);\n            y <= (x * coeff_a >>> FRAC_BITS);\n            fb <= y;\n        end else begin\n            x <= 0; y <= 0; fb <= 0;\n        end\n    end\n\n    assign audio_out = y;\nendmodule", "rtl/modulator.sv": "module modulator (\n    input logic clk,\n    input logic rst,\n    input logic enable,\n    output logic [15:0] mod_signal\n);\n    logic [15:0] counter;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) counter <= 0;\n        else if (enable) counter <= counter + 1;\n    end\n\n    assign mod_signal = counter;\nendmodule", "rtl/resonator_bank.sv": "module resonator_bank (\n    input logic clk,\n    input logic rst,\n    input logic calibrate,\n    input logic signed [15:0] audio_in,\n    input logic [15:0] base_freq,\n    input logic [7:0] q_factor,\n    input logic [15:0] mod_signal,\n    output logic [2:0] cal_done_flags,\n    output logic signed [15:0] audio_out\n);\n    logic signed [15:0] out_l, out_m, out_h;\n    logic [15:0] f_l, f_m, f_h;\n\n    assign f_l = base_freq + mod_signal[7:0];\n    assign f_m = base_freq + mod_signal[9:2];\n    assign f_h = base_freq + mod_signal[11:4];\n\n    helmholtz_resonator low (\n        .clk(clk), .rst(rst), .calibrate(calibrate),\n        .audio_in(audio_in), .target_freq(f_l), .q_factor(q_factor),\n        .cal_done(cal_done_flags[0]), .audio_out(out_l)\n    );\n\n    helmholtz_resonator mid (\n        .clk(clk), .rst(rst), .calibrate(calibrate),\n        .audio_in(audio_in), .target_freq(f_m), .q_factor(q_factor),\n        .cal_done(cal_done_flags[1]), .audio_out(out_m)\n    );\n\n    helmholtz_resonator high (\n        .clk(clk), .rst(rst), .calibrate(calibrate),\n        .audio_in(audio_in), .target_freq(f_h), .q_factor(q_factor),\n        .cal_done(cal_done_flags[2]), .audio_out(out_h)\n    );\n\n    assign audio_out = (out_l >>> 2) + (out_m >>> 2) + (out_h >>> 2);\nendmodule", "rtl/soft_clipper.sv": "module soft_clipper #(\n    parameter WIDTH = 16\n)(\n    input logic signed [WIDTH-1:0] in_signal,\n    output logic signed [WIDTH-1:0] out_signal\n);\n    always_comb begin\n        if (in_signal > 20480)\n            out_signal = 20480;\n        else if (in_signal < -20480)\n            out_signal = -20480;\n        else\n            out_signal = in_signal - ((in_signal * in_signal) >>> 10);\n    end\nendmodule"}, "patch": {"rtl/helmholtz_top_module.sv": "", "verif/tb.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  direct:\n    image: hdlc/sim:osvb\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir  \n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true  ", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/helmholtz_top_module.sv \nTOPLEVEL        = helmholtz_top_module\nMODULE          = test_helmholtz_top_module\nPYTHONPATH      = /src\nHASH            = 9bf6b88b29ad6ad5efda4435f878f867211360dd\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/helmholtz_top_module.sv": "module helmholtz_resonator #(\n    parameter WIDTH = 16,\n    parameter FRAC_BITS = 8,\n    parameter CAL_TOLERANCE = 10 // 10% tolerance\n)(\n    input logic clk,\n    input logic rst,\n    input logic calibrate,\n    input logic signed [WIDTH-1:0] audio_in,\n    input logic [15:0] target_freq,\n    input logic [7:0] q_factor,\n    output logic cal_done,\n    output logic signed [WIDTH-1:0] audio_out\n);\n\n    typedef enum logic [1:0] { IDLE, CALIBRATING, DONE, PROCESSING } state_t;\n    state_t state, next_state;\n\n    logic [15:0] current_freq;\n    logic signed [15:0] freq_error;\n    logic [15:0] calibration_factor;\n\n    logic signed [WIDTH-1:0] x, y, fb;\n    logic signed [WIDTH-1:0] coeff_a, coeff_b;\n\n    // Frequency error\n    always_comb begin\n        if (target_freq > current_freq)\n            freq_error = target_freq - current_freq;\n        else\n            freq_error = current_freq - target_freq;\n    end\n\n    // State machine and calibration logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            calibration_factor <= 16'd128;\n            current_freq <= 16'd100;\n            cal_done <= 0;\n        end else begin\n            state <= next_state;\n\n            if (state == CALIBRATING) begin\n                if (current_freq < target_freq)\n                    calibration_factor <= calibration_factor + 1;\n                else if (current_freq > target_freq)\n                    calibration_factor <= calibration_factor - 1;\n\n                current_freq <= (calibration_factor * 2);\n            end\n\n            cal_done <= (state == DONE);\n        end\n    end\n\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE: if (calibrate) next_state = CALIBRATING;\n            CALIBRATING: if ((freq_error * 100 / target_freq) < CAL_TOLERANCE) next_state = DONE;\n            DONE: if (!calibrate) next_state = PROCESSING;\n            PROCESSING: if (calibrate) next_state = CALIBRATING;\n        endcase\n    end\n\n    always_comb begin\n        coeff_a = calibration_factor;\n        coeff_b = q_factor;\n    end\n\n    // Filtering operation\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            x <= 0; y <= 0; fb <= 0;\n        end else if (state == PROCESSING) begin\n            x <= audio_in - (fb * coeff_b >>> FRAC_BITS);\n            y <= (x * coeff_a >>> FRAC_BITS);\n            fb <= y;\n        end else begin\n            x <= 0; y <= 0; fb <= 0;\n        end\n    end\n\n    assign audio_out = y;\nendmodule\n\n\nmodule modulator (\n    input logic clk,\n    input logic rst,\n    input logic enable,\n    output logic [15:0] mod_signal\n);\n    logic [15:0] counter;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) counter <= 0;\n        else if (enable) counter <= counter + 1;\n    end\n\n    assign mod_signal = counter;\nendmodule\n\n\nmodule soft_clipper #(\n    parameter WIDTH = 16\n)(\n    input logic signed [WIDTH-1:0] in_signal,\n    output logic signed [WIDTH-1:0] out_signal\n);\n    always_comb begin\n        if (in_signal > 20480)\n            out_signal = 20480;\n        else if (in_signal < -20480)\n            out_signal = -20480;\n        else\n            out_signal = in_signal - ((in_signal * in_signal) >>> 10);\n    end\nendmodule\n\n\nmodule resonator_bank (\n    input logic clk,\n    input logic rst,\n    input logic calibrate,\n    input logic signed [15:0] audio_in,\n    input logic [15:0] base_freq,\n    input logic [7:0] q_factor,\n    input logic [15:0] mod_signal,\n    output logic [2:0] cal_done_flags,\n    output logic signed [15:0] audio_out\n);\n    logic signed [15:0] out_l, out_m, out_h;\n    logic [15:0] f_l, f_m, f_h;\n\n    assign f_l = base_freq + mod_signal[7:0];\n    assign f_m = base_freq + mod_signal[9:2];\n    assign f_h = base_freq + mod_signal[11:4];\n\n    helmholtz_resonator low (\n        .clk(clk), .rst(rst), .calibrate(calibrate),\n        .audio_in(audio_in), .target_freq(f_l), .q_factor(q_factor),\n        .cal_done(cal_done_flags[0]), .audio_out(out_l)\n    );\n\n    helmholtz_resonator mid (\n        .clk(clk), .rst(rst), .calibrate(calibrate),\n        .audio_in(audio_in), .target_freq(f_m), .q_factor(q_factor),\n        .cal_done(cal_done_flags[1]), .audio_out(out_m)\n    );\n\n    helmholtz_resonator high (\n        .clk(clk), .rst(rst), .calibrate(calibrate),\n        .audio_in(audio_in), .target_freq(f_h), .q_factor(q_factor),\n        .cal_done(cal_done_flags[2]), .audio_out(out_h)\n    );\n\n    assign audio_out = (out_l >>> 2) + (out_m >>> 2) + (out_h >>> 2);\nendmodule\n\n\nmodule helmholtz_top_module (\n    input logic clk,\n    input logic rst,\n    input logic calibrate,\n    input logic signed [15:0] audio_in,\n    input logic [15:0] base_freq,\n    input logic [7:0] q_factor,\n    input logic mod_enable,\n    output logic [2:0] cal_done_flags,\n    output logic signed [15:0] audio_out\n);\n\n    logic [15:0] mod_signal;\n    logic signed [15:0] resonated_signal, clipped_signal;\n\n    modulator mod (\n        .clk(clk),\n        .rst(rst),\n        .enable(mod_enable),\n        .mod_signal(mod_signal)\n    );\n\n    resonator_bank bank (\n        .clk(clk),\n        .rst(rst),\n        .calibrate(calibrate),\n        .audio_in(audio_in),\n        .base_freq(base_freq),\n        .q_factor(q_factor),\n        .mod_signal(mod_signal),\n        .cal_done_flags(cal_done_flags),\n        .audio_out(resonated_signal)\n    );\n\n    soft_clipper clip (\n        .in_signal(resonated_signal),\n        .out_signal(clipped_signal)\n    );\n\n    assign audio_out = clipped_signal;\nendmodule\n\n\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        while len(info) < 3:\n            info.append(\"0%\")\n\n        inst = re.sub(r'[\\W]', '', info[0])\n\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n\n    # Check if the required key exists in the metrics\n    if \"dut\" not in metrics:\n        raise KeyError(\"Metrics data for 'dut' is missing in the coverage log.\")\n\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 85.0))  \n    assert metrics[\"dut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['dut']['Average']}, Target: {target}\"\n", "src/test_helmholtz_top_module.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n\n@cocotb.test()\nasync def test_helmholtz_top_module(dut):\n    \"\"\"Test the Helmholtz top module: calibration + audio processing.\"\"\" #\n\n    clk_period = 10  # 100 MHz\n    cocotb.start_soon(Clock(dut.clk, clk_period, units=\"ns\").start())\n\n    # Initialize inputs\n    dut.rst.value = 1\n    dut.calibrate.value = 0\n    dut.mod_enable.value = 0\n    dut.audio_in.value = 0\n    dut.base_freq.value = 150\n    dut.q_factor.value = 64\n\n    await Timer(100, units=\"ns\")\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n    dut._log.info(\"Starting calibration...\")\n\n    # Trigger calibration\n    dut.calibrate.value = 1\n\n    timeout_cycles = 1000\n    for _ in range(timeout_cycles):\n        await RisingEdge(dut.clk)\n        if dut.cal_done_flags.value == 0b111:\n            dut._log.info(\"All resonators calibrated.\")\n            break\n    else:\n        raise cocotb.result.TestFailure(\"Calibration timeout!\")\n\n    dut.calibrate.value = 0\n    dut.mod_enable.value = 1\n\n    dut._log.info(\"Starting audio input pattern...\")\n\n    # Drive a test input pattern (square wave)\n    for cycle in range(200):\n        sample = 8000 if (cycle % 20 < 10) else -8000\n        dut.audio_in.value = sample\n\n        await RisingEdge(dut.clk)\n\n        if cycle % 10 == 0:\n            out_val = dut.audio_out.value.to_signed()\n            dut._log.info(f\"Cycle {cycle:03d} | Audio_in: {sample:6d} | Audio_out: {out_val:6d}\")\n\n    dut._log.info(\"Test complete \")\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner #\nimport re\nimport logging\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}
{"id": "cvdp_agentic_uart_0001", "categories": ["cid005", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have below submodules in `/code/rtl` directory that together implement the functionality of a UART system:\n\n- `uart_tx`: Manages transmission including start/stop/parity handling.\n- `uart_rx`: Manages reception with start detection, oversampling, and parity checking.\n- `baud_gen`: Generates TX/RX baud clock pulses and manages enable signals.\n- `cdc_sync`: Synchronizes asynchronous RX input into the core clock domain.\n- `areset_sync`: Synchronizes asynchronous de-assertion of reset for clean transitions.\n\nThese modules need to be integrated into a top-level RTL module named `uart_top`.\n\nThe full specification for this top module is documented in **`docs/UART_Specifications.md`**. Please follow that spec precisely when wiring up ports, handling loopback behavior, and generating status outputs.\n\nThe final top-level module should:\n\n1. **Integrate** all submodules and connect them per the specification.\n2. **Support full-duplex UART** with loopback functionality when `i_lpbk_mode_en` is asserted.\n3. **Generate internal resets** for `uart_tx` and `uart_rx` using `areset_sync` based on `rstn`, `i_tx_rst`, and `i_rx_rst`.\n4. **Synchronize** the incoming RX signal using `cdc_sync`.\n5. **Use** the `baud_gen` module to generate TX and RX baud clocks and manage TX/RX enable signals.\n6. **Connect** valid-ready handshaking signals between the top-level and submodules.\n7. **Expose** all required control/status ports as defined in the spec, including `o_tx_state`, `o_rx_state`, `o_rx_break`, `o_parity_err`, and `o_frame_err`.\n\n#### Testbench Requirement:\nIn addition to creating the top module, develop a **SystemVerilog testbench** in `verif` directory that:\n- Instantiates `uart_top` and drives it with appropriate stimulus.\n- Initializes core and resets all domains.\n- Sends a variety of TX payloads with different configurations of:\n  - Parity (none/odd/even)\n  - Stop bits (1 or 2)\n  - Loopback mode enabled/disabled\n  - Break frame generation\n- Monitors and checks reception of expected data via the RX interface.\n- Includes at least one **loopback test** and one **normal TX-RX test** using serial wiring.\n- Logs and asserts for `parity_err`, `frame_err`, and `o_rx_break` for error-checking validation.\n- Uses the valid/ready handshake mechanism for TX and RX.\n- Covers corner cases like:\n  - Minimum and maximum baud rate values\n  - Data bursts and back-to-back transfers\n  - Simulated framing errors and parity mismatches (if possible)\n\nPlease implement this integrated top-level UART module as `uart_top` in a single SystemVerilog file named `uart_top.sv` and a separate testbench file named **`tb_uart_top.sv`** to demonstrate functionality and compliance with the spec.\n\n", "context": {"docs/UART_Specifications.md": "## UART Top-Level RTL Module Specification\n\n### 1. Module Overview:\n- The UART module supports asynchronous serial communication.\n- Full duplex operation with independent TX and RX control.\n- Configurable parameters for baud rate, parity mode, stop bits.\n- Supports internal loopback for testing.\n\n---\n\n### 2. Top-Level Interface Specification:\n\n#### Inputs:\n- **clk**: Core clock input (10-100 MHz)\n- **rstn**: Active-low asynchronous reset\n- **i_rx**: Serial data input\n\n**Control Inputs**:\n- **i_baudrate [15:0]**: Baud rate configuration\n- **i_parity_mode [1:0]**: Parity mode (00 - None, 01 - Odd, 11 - Even)\n- **i_frame_mode**: Number of stop bits (0 - one stop bit, 1 - two stop bits)\n- **i_lpbk_mode_en**: Loopback mode enable (0 - disabled, 1 - enabled)\n- **i_tx_break_en**: TX break enable\n- **i_tx_en**: Transmitter enable\n- **i_rx_en**: Receiver enable\n- **i_tx_rst**: Active-high reset for transmitter\n- **i_rx_rst**: Active-high reset for receiver\n\n**TX Data Interface Inputs**:\n- **i_data [7:0]**: Data byte to transmit\n- **i_data_valid**: Indicates data byte is valid for transmission\n\n**RX Data Interface Inputs**:\n- **i_ready**: Indicates readiness to read received data byte\n\n#### Outputs:\n- **o_tx**: Serial data output\n\n**TX Data Interface Output**:\n- **o_ready**: Transmitter ready status\n\n**RX Data Interface Outputs**:\n- **o_data [7:0]**: Data byte received\n- **o_data_valid**: Indicates received data byte is valid\n\n**Status Outputs**:\n- **o_tx_state**: Transmitter enable state (1 - enabled, 0 - disabled)\n- **o_rx_state**: Receiver enable state (1 - enabled, 0 - disabled)\n- **o_rx_break**: Break frame received indicator\n- **o_parity_err**: Parity error status\n- **o_frame_err**: Frame error status\n\n---\n\n### 3. Functional Requirements:\n\n#### Transmission:\n- Transmit least significant bit first, idle state is logic high.\n- Configurable 8-bit data, optional parity bit, 1 or 2 stop bits.\n- Supports transmission of break frames (all zero bits).\n\n#### Reception:\n- RX samples serial data at 8x baud rate oversampling for robustness.\n- Detects valid start bit transitions and stop bit errors.\n- Reports frame errors (stop bit missing) and parity errors.\n- Break frame reception detection (at least 9 or 10 bits of zeros).\n\n---\n\n### 4. Clocking and Reset:\n- Core operates on a single clock domain (10-100 MHz).\n- Asynchronous active-low reset input (`rstn`).\n- Internal reset synchronizers for clean de-assertion.\n\n---\n\n### 5. Baud Rate Generation:\n- Internal baud generator with 16-bit prescaler.\n- Configurable through input parameter (`i_baudrate`).\n- Formula:\n   `Baud_div = INT((CoreClockFreq / (BaudRate \u00d7 8)) - 1)`\n\n\n---\n\n### 6. Loopback Mode:\n- Internally connects TX output to RX input when enabled (`i_lpbk_mode_en`).\n- Primarily intended for self-testing and diagnostics.\n\n---\n\n### 7. Data Interface Handshaking:\n- Uses simple valid-ready handshake protocol for both TX and RX.\n- Data transfer occurs only when both `valid` and `ready` signals are asserted.\n\n---\n\n### 8. Error Handling:\n- Status flags provided for parity and frame errors.\n- Sticky error flags until next byte is received.", "rtl/areset_sync.sv": "module areset_sync #(   \n   // Configurable parameters   \n   parameter STAGES  = 2    ,        // No. of flops in the synchronizer chain, min. 2\n   parameter RST_POL = 1'b0          // Reset polarity\n)\n\n(\n   input  logic clk         ,        // Clock @ destination clock domain   \n   input  logic i_rst_async ,        // Asynchronous Reset in\n   output logic o_rst_sync           // Asynchronous Reset with de-assertion synchronized\n) ;\n\nlogic reset ;\nassign reset = i_rst_async ^ RST_POL ;\n\n(* ASYNC_REG = \"TRUE\" *)\nlogic [STAGES-1:0] sync_ff ;\n\n// Synchronizing logic\nalways @(posedge clk or negedge reset) begin\n   \n   if (!reset) begin\n      sync_ff <= {STAGES{RST_POL}} ;\n   end\n   else begin\n      sync_ff <= {sync_ff[STAGES-2:0], ~RST_POL} ;     \n   end  \n\nend\n\n// Synchronized reset\nassign o_rst_sync = sync_ff[STAGES-1] ;\n\nendmodule", "rtl/baud_gen.sv": "module baud_gen (\n                   // Clock and Reset\n                   input  logic           clk            ,        // Clock\n                   input  logic           tx_rst         ,        // TX reset; Active-low Asynchronous\n                   input  logic           rx_rst         ,        // RX reset; Active-low Asynchronous      \n                   \n                   // Baud clock control                   \n                   input  logic [15 : 0]  i_baudrate     ,        // Baud rate\n                   input  logic           i_tx_en        ,        // UART TX baud clock enable\n                   input  logic           i_rx_en        ,        // UART RX baud clock enable\n                   input  logic           i_tx_ready     ,        // UART TX ready\n                   input  logic           i_rx_ready     ,        // UART RX ready\n                   output logic           o_rx_en        ,        // UART RX enable\n                   \n                   // Baud clock pulses\n                   output logic           o_tx_baud_clk  ,        // Baud clock pulse for UART TX\n                   output logic           o_rx_baud_clk  ,        // Baud clock pulse for UART RX\n\n                   // Status signals\n                   output logic           o_tx_state     ,        // State of UART TX (enabled/disabled)\n                   output logic           o_rx_state              // State of UART RX (enabled/disabled)       \n                ) ;  \n\n//\n// Internal Registers/Signals\n//\nlogic          tx_en, rx_en             ;    // TX/RX baud clock internal enable\nlogic          is_tx_en_rg, is_rx_en_rg ;    // TX/RX baud clock state\nlogic [18 : 0] tx_count_rg              ;    // Counter for UART TX baud clock\nlogic [15 : 0] rx_count_rg              ;    // Counter for UART RX baud clock\nlogic [15 : 0] rx_baudcount             ;    // Rx baud count\nlogic [18 : 0] tx_baudcount             ;    // Tx baud count\n\n//\n// Synchronous logic to generate baud clock pulse for UART TX\n//\nalways @ (posedge clk or negedge tx_rst) begin   \n   // Reset\n   if (!tx_rst) begin\n      is_tx_en_rg   <= 1'b0 ;\n      o_tx_baud_clk <= 1'b0 ;\n      tx_count_rg   <= 0    ;\n   end\n   // Out of Reset\n   else begin\n      // TX disabled: disable clock pulses, reset counters...\n      if (!tx_en) begin\n         o_tx_baud_clk <= 1'b0 ;\n         tx_count_rg   <= 0    ;\n         is_tx_en_rg   <= 1'b0 ;  // TX baud clock is in disabled state     \n      end\n      // TX enabled\n      else begin\n         is_tx_en_rg <= 1'b1 ;  // TX baud clock is in enabled state\n         if (tx_count_rg == tx_baudcount) begin\n            o_tx_baud_clk <= 1'b1            ;  // Assert the pulse\n            tx_count_rg   <= 0               ;\n         end      \n         else begin\n            o_tx_baud_clk <= 1'b0            ;  // De-assert the pulse after one cycle \n            tx_count_rg   <= tx_count_rg + 1 ;\n         end\n      end\n   end\nend\n\n// Generate TX baud clock enable internally...\nassign tx_en = i_tx_en ? 1'b1 : (is_tx_en_rg && !i_tx_ready) ;\n\n//\n// Synchronous logic to generate baud clock pulse for UART RX\n//\nalways @ (posedge clk or negedge rx_rst) begin   \n   // Reset\n   if (!rx_rst) begin\n      is_rx_en_rg   <= 1'b0 ;\n      o_rx_baud_clk <= 1'b0 ;\n      rx_count_rg   <= 0    ;\n   end\n   // Out of Reset\n   else begin\n      // RX disabled: disable clock pulses, reset counters...\n      if (!rx_en) begin\n         o_rx_baud_clk <= 1'b0 ;\n         rx_count_rg   <= 0    ;\n         is_rx_en_rg   <= 1'b0 ;  // RX baud clock is in disabled state   \n      end\n      // RX enabled\n      else begin\n         is_rx_en_rg <= 1'b1 ;  // RX baud clock is in enabled state\n         if (rx_count_rg == rx_baudcount) begin  // Sampling at x8\n            o_rx_baud_clk <= 1'b1            ;   // Assert the pulse\n            rx_count_rg   <= 0               ;\n         end\n         else begin\n            o_rx_baud_clk <= 1'b0            ;  // De-assert the pulse after one cycle \n            rx_count_rg   <= rx_count_rg + 1 ; \n         end\n      end\n   end\nend\n\n// Baud counts\nassign rx_baudcount = i_baudrate ;\nassign tx_baudcount = (i_baudrate << 3) + 19'd7 ;\n\n// Generate TX baud clock enable internally...\nassign rx_en = i_rx_en ? 1'b1 : (is_rx_en_rg && !i_rx_ready) ;\n\n// RX enable\nassign o_rx_en = rx_en ;\n\n// Status outputs\nassign o_tx_state = is_tx_en_rg ;\nassign o_rx_state = is_rx_en_rg ;\n\nendmodule", "rtl/cdc_sync.sv": "module cdc_sync #(\n   \n   // Configurable parameters   \n   parameter STAGES = 2             // No. of flops in the sync chain, min. 2\n)\n\n(\n   input  logic clk        ,        // Clock @ destination clock domain\n   input  logic rstn       ,        // Reset @ destination clock domain; this may be omitted if targetting FPGAs\n   input  logic i_sig      ,        // Input signal, asynchronous\n   output logic o_sig_sync          // Output signal synchronized to clk\n) ;\n\n(* ASYNC_REG = \"TRUE\" *)\nlogic [STAGES-1: 0] sync_ff ;\n\n// Synchronizing logic\nalways @(posedge clk or negedge rstn) begin   \n   if (!rstn) begin\n      sync_ff <= '0 ;\n   end\n   else begin\n      sync_ff <= {sync_ff [STAGES-2 : 0], i_sig} ;     \n   end\nend\n\n// Synchronized signal\nassign o_sig_sync = sync_ff [STAGES-1] ;\n\nendmodule", "rtl/uart_rx.sv": "module uart_rx  (\n                   input  logic           clk            ,        // Clock\n                   input  logic           rstn           ,        // Active-low Asynchronous Reset \n\n                   input  logic           i_baud_clk     ,        // Baud clock                 \n                   \n                   /* Control Signals */    \n                   input  logic           i_rx_en        ,        // Rx enable\n                   input  logic [1  : 0]  i_parity_mode  ,        // Parity mode\n                   input  logic           i_frame_mode   ,        // Frame mode                             \n                   \n                   /* Serial Data */\n                   input logic            i_rx           ,        // Serial data input\n\n                   /* Parallel Data */     \n                   output logic [7 : 0]   o_data         ,        // Parallel data output\n                   output logic           o_data_valid   ,        // Output data valid\n                   input  logic           i_ready        ,        // Ready to send data\n                   \n                   /* Status Signals */    \n                   output logic           o_rx_ready     ,        // Rx ready/busy to accept new frame...\n                   output logic           o_break        ,        // Break frame received flag\n                   output logic           o_parity_err   ,        // Parity error flag\n                   output logic           o_frame_err             // Frame error flag        \n                ) ;\n\n//   Typedefs\n\n// TX FSM state\ntypedef enum logic [5:0] { \n   IDLE    = 6'h01,  // Idle State\n   DATA    = 6'h02,  // Receive Data State\n   PARITY  = 6'h04,  // Receive Parity State\n   STOP_P  = 6'h08,  // Receive Initial Stop State\n   STOP_F  = 6'h10,  // Receive Final Stop State\n   BUFF    = 6'h20   // Buffer Data State\n}  rx_state ;\n\n//   Internal Registers/Signals\n\nrx_state      state_rg               ;        // State Register\n\n// Frame specific\nlogic         rx_d1_rg               ;        // Rx delayed by one cycle\nlogic         is_rx_1_to_0_edge      ;        // Rx falling edge flag\nlogic         is_frame_sync_rg       ;        // Frame synchronization flag\nlogic         start_bit_rg           ;        // Start bit sampled\nlogic         parity_bit_rg          ;        // Parity bit sampled\nlogic         stop_bit_rg            ;        // Stop bit sampled\nlogic [7 : 0] data_rg                ;        // Data register\nlogic         frame_err_rg           ;        // Frame error register\nlogic         parity_err_rg          ;        // Parity error register\n\n// Counters\nlogic [2 : 0] start_sample_count_rg  ;        // Counter to count Start bit samples   \nlogic [2 : 0] data_sample_count_rg   ;        // Counter to count Data bit samples\nlogic [2 : 0] parity_sample_count_rg ;        // Counter to count Parity bit samples\nlogic [2 : 0] stop_sample_count_rg   ;        // Counter to count Stop bit samples\nlogic [2 : 0] data_count_rg          ;        // Counter to count Data bits sampled\n\n// Flags\nlogic         stop_flag_rg           ;        // To flag if stop bit sampling failed\n\n\n//   Synchronous logic of UART Rx\n\nalways @ (posedge clk or negedge rstn) begin\n   \n   // Reset\n   if (!rstn) begin      \n      // Output Ports\n      o_data                 <= '0    ;\n      o_data_valid           <= 1'b0  ;\n      o_break                <= 1'b0  ;\n      o_parity_err           <= 1'b0  ; \n      o_frame_err            <= 1'b0  ;     \n \n      // Internal Registers/Signals \n      state_rg               <= IDLE  ;\n      \n      rx_d1_rg               <= 1'b0  ;\n      is_frame_sync_rg       <= 1'b0  ;\n      start_bit_rg           <= 1'b1  ;\n      parity_bit_rg          <= 1'b0  ;\n      stop_bit_rg            <= 1'b0  ;\n      data_rg                <= '0    ; \n      frame_err_rg           <= 1'b0  ;  \n      parity_err_rg          <= 1'b0  ;   \n \n      start_sample_count_rg  <=  0    ;\n      data_sample_count_rg   <=  0    ;\n      parity_sample_count_rg <=  0    ;\n      stop_sample_count_rg   <=  0    ;\n      data_count_rg          <=  0    ;\n\n      stop_flag_rg           <= 1'b0  ;\n   end\n\n   // Out of Reset\n   else begin\n      \n      // De-assertion of data valid      \n      if (i_ready) begin\n         o_data_valid <= 1'b0 ;      \t\n      end\n      \n      // One baud clock cycle delayed version of Rx when Rx enabled...      \n      if (!i_rx_en) begin\n         rx_d1_rg <= 1'b0 ;\n      end\n      else if (i_baud_clk) begin\n         rx_d1_rg <= i_rx ;\n      end      \n\n      // FSM\n      case (state_rg)\n         \n         // Idle State\n         //\n         // - Waits in this state for idle -> Start bit transition.\n         // - Triggers start bit sampler on first 1->0 transition.\n         // - Moves to DATA State if Start bit is sampled successfully.  \n         //         \n         IDLE       : begin \n                         if (i_baud_clk && i_rx_en) begin   \n                                                                         \n                            // Frame synchronized, keep sampling            \n                            if (is_frame_sync_rg) begin\n                               start_sample_count_rg <= start_sample_count_rg + 1 ; \n                            end\n                            // Frame not synchronized; looking for 1->0 transition at Rx...\n                            // if the RX line is idle at 0000000.... or 1111111...., the frame is ignored...\n                            // 1->0 is identified as the possible Start bit transition... \n                            else if (is_rx_1_to_0_edge) begin\n                               is_frame_sync_rg      <= 1'b1                      ;    // Frame synchronized\n                               start_sample_count_rg <= start_sample_count_rg + 1 ; \n                            end\n                            \n                            // Sampling at middle\n                            if (start_sample_count_rg == 3) begin\n                               start_bit_rg     <= i_rx ; \n                               // If Start bit detected in the middle, keep frame sync, else lost sync...\n                               is_frame_sync_rg      <= i_rx ? 1'b0 : is_frame_sync_rg ; \n                               start_sample_count_rg <= i_rx ? 0    : start_sample_count_rg + 1 ;                       \t\n                            end\n                            \n                            // Last sample\n                            if (start_sample_count_rg == 7) begin   \n                               if (start_bit_rg == 1'b0) begin                        \t\n                                  state_rg <= DATA ;    // Start bit detected\n                               end                               \n                            end                                                        \t\n\n                         end\n                      end\n\n         // Receive Data State\n         //\n         // - Samples the 8 data bits in this state.\n         // - Moves to PARITY/STOP_P/STOP_F State based on configuration. \n         //\n         DATA       : begin                         \n                         if (i_baud_clk) begin                            \n                            // Increment sample counter\n                            data_sample_count_rg <= data_sample_count_rg + 1 ;\n                            \n                            // Sampling at middle\n                            if (data_sample_count_rg == 3) begin\n                               data_rg [data_count_rg] <= i_rx ;                            \t\n                            end \n                            \n                            // Last sample\n                            if (data_sample_count_rg == 7) begin                               \n                               // Increment data counter                               \n                               data_count_rg <= data_count_rg + 1 ;\n                               \n                               // Last data bit\n                               if (data_count_rg == 7) begin                    \n                                  \n                                  // Next state deduction\n                                  if (i_parity_mode [0]) begin\n                                     state_rg     <= PARITY ;    // Parity                                 \t\n                                  end\n                                  else if (!i_frame_mode) begin                                                                       \t\n                                     state_rg     <= STOP_F ;    // No-parity, 1 Stop bit                                 \t\n                                  end\n                                  else begin\n                                     state_rg     <= STOP_P ;    // No parity, 2 Stop bits                                  \t\n                                  end\n                                  \n                                  if (!i_frame_mode) begin\n                                     stop_flag_rg <= 1'b0   ;    // One-Stop-bit mode transaction, so flag this as successful\n                                  end\n\n                               end\n\n                            end\n                         end\n                      end\n\n         // Receive Parity State\n         //\n         // - Samples Parity bit in this state.\n         // - Moves to STOP_P/STOP_F State from here based on configuration. \n         //\n         PARITY     : begin                         \n                         if (i_baud_clk) begin                            \n                            // Increment sample counter                            \n                            parity_sample_count_rg <= parity_sample_count_rg + 1 ;\n                            \n                            // Sampling at middle\n                            if (parity_sample_count_rg == 3) begin\n                               parity_bit_rg <= i_rx ;                           \t\n                            end\n                            \n                            // Last sample\n                            if (parity_sample_count_rg == 7) begin\n\n                               // Next state deduction\n                               if (!i_frame_mode) begin                                                                 \t\n                                  state_rg     <= STOP_F ;        // One-Stop-bit mode transaction                                 \t\n                               end\n                               else begin\n                                  state_rg     <= STOP_P ;        // Two-Stop-bit mode transaction                                 \t\n                               end\n\n                            end\n                         end\n                      end\n\n         // Receive Initial Stop State\n         // \n         // - Samples the first Stop bit in case of Two-Stop-bits mode transactions.\n         // - Moves to STOP_F State from here.\n         // \n         STOP_P     : begin\n                         if (i_baud_clk) begin                            \n                            // Increment sample counter                            \n                            stop_sample_count_rg <= stop_sample_count_rg + 1 ;\n                            \n                            // Sampling at middle\n                            if (stop_sample_count_rg == 3) begin\n                               stop_flag_rg <= ~ i_rx ;        // Flag if Stop bit was successfully sampled or not                               \n                            end\n                            \n                            // Last sample\n                            if (stop_sample_count_rg == 7) begin                               \n                               state_rg     <= STOP_F ;\n                            end\n                         end\n                      end\n         \n         // Receive Final Stop State\n         //\n         // - Samples the second/final Stop bit.\n         // - Moves to BUFF State from here.\n         //\n         STOP_F     : begin                         \n                         if (i_baud_clk) begin                            \n                            // Increment sample counter\n                            stop_sample_count_rg <= stop_sample_count_rg + 1 ;\n                            \n                            // Sampling at middle\n                            if (stop_sample_count_rg == 3) begin\n                               stop_bit_rg          <= i_rx ;    // Stop bit\n                               stop_sample_count_rg <= 0    ;    // Reset sample counter                      \n\n                               if (i_rx == 1'b0) begin\n                                  frame_err_rg <= 1'b1                ;        // Stop bit was not sampled; Framing error!                                                               \t\n                               end                                                                                                                          \t\n                               else begin\n                                  frame_err_rg <= 1'b0 | stop_flag_rg ;        // Final Stop bit and Initial Stop bit sampling analysed.                                                                       \t\n                               end\n                               \n                               // Finished one frame reception\n                               is_frame_sync_rg  <= 1'b0 ;       // De-assert Frame synchronization\n                               state_rg          <= BUFF ;\n                            end\n                         end\n                      end\n\n         \n         //   Buffer Data State\n         //\n         // - Buffers the sampled data, parity error flag to output.            \n         // - Moves Idle State from here.\n         \n         BUFF       : begin                         \n                         // Buffer valid data and status to output...                        \n                         o_data       <= data_rg ;\n                         o_break      <= (!i_frame_mode) ?\n                                         (frame_err_rg && data_rg == 8'h00 && parity_bit_rg == 1'b0) :  // 1 stop bit\n                                         (stop_flag_rg && data_rg == 8'h00 && parity_bit_rg == 1'b0) ;  // For 2 stop bits, it's considered break frame iff the frame error happened in the first stop bit\n                         o_parity_err <= parity_err_rg ; \n                         o_frame_err  <= frame_err_rg  ;\n                         o_data_valid <= 1'b1          ;                         \n                         \n                         // Ready to receive the next frame\n                         parity_bit_rg <= 1'b0 ;\n                         state_rg      <= IDLE ;\n                      end\n\n         default    : ;\n\n      endcase\n\n      // Parity error flag computation \n      if (i_parity_mode [0]) begin\n         parity_err_rg <= i_parity_mode [1]                   ?\n                          ((~ (^ data_rg)) == parity_bit_rg ) :        // Even parity check  \n                          ((^ data_rg)     == parity_bit_rg ) ;        // Odd parity check \n\n      end\n      else begin\n         parity_err_rg <= 1'b0 ;\n      end\n\n   end\n\nend\n\n\n//   Continuous Assignments\n\nassign is_rx_1_to_0_edge = (rx_d1_rg && !i_rx) ;  // ``\\__ detected on Rx\n\n// Output status\nassign o_rx_ready        = ~is_frame_sync_rg ;\n\nendmodule", "rtl/uart_tx.sv": "module uart_tx  (\n                   input  logic           clk            ,        // Clock\n                   input  logic           rstn           ,        // Active-low Asynchronous Reset\n\n                   input  logic           i_baud_clk     ,        // Baud clock                  \n                   \n                   /* Control Signals */                   \n                   input  logic [1  : 0]  i_parity_mode  ,        // Parity mode\n                   input  logic           i_frame_mode   ,        // Frame mode   \n                   input  logic           i_break_en     ,        // Enable to send break frame                                  \n                   \n                   /* Parallel Data */    \n                   input  logic [7 :  0]  i_data         ,        // Parallel data input\n                   input  logic           i_data_valid   ,        // Input data valid\n                   output logic           o_ready        ,        // Ready to accept data  \n\n                   /* Serial Data */\n                   output logic           o_tx                    // Serial data output            \n                ) ;\n\n// Typedefs\n// TX FSM state\ntypedef enum logic [5:0] { \n   IDLE    = 6'h01,  // Idle State\n   START   = 6'h02,  // Send Start State\n   DATA    = 6'h04,  // Send Data State\n   PARITY  = 6'h08,  // Send Parity State\n   BREAK   = 6'h10,  // Send BREAK State\n   STOP    = 6'h20   // Send Stop State\n}  tx_state ;\n\n//\n// Internal Registers/Signals\n//\ntx_state      state_rg      ;        // State Register\n\nlogic [7 : 0] data_rg       ;        // Data buffer\nlogic         parity_rg     ;        // Parity bit register\nlogic         ready_rg      ;        // Ready register\nlogic         break_flag_rg ;        // Flags break enabled\nlogic [2 : 0] tx_count_rg   ;        // Data counter\nlogic         stop_count_rg ;        // Stop bit counter\n\n//\n// Synchronous logic of UART Tx\n//\nalways @ (posedge clk or negedge rstn) begin\n   \n   // Reset\n   if (!rstn) begin      \n      // Output Ports\n      o_tx          <= 1'b1 ;\n\n      // Internal Registers/Signals\n      state_rg      <= IDLE ;\n      data_rg       <= '0   ;\n      parity_rg     <= 1'b0 ;\n      ready_rg      <= 1'b0 ;\n      break_flag_rg <= 1'b0 ;\n      tx_count_rg   <= 0    ;\n      stop_count_rg <= 0    ;\n   end\n\n   // Out of Reset\n   else begin \n\n      // FSM   \n      case (state_rg)\n         \n         // Idle State\n         //\n         // - State in which UART Tx waits for a valid parallel data input.\n         // - Buffer the parallel data and moves to START State from here.\n         IDLE       : begin\n                         // IDLE state of TX line\n                         o_tx <= 1'b1 ;\n\n                         // Ready to accept data\n                         ready_rg <= 1'b1 ;\n                         \n                         // Buffer the input data\n                         // If break enabled, buffer all 0s\n                         if (i_data_valid & ready_rg) begin\n                            data_rg       <= i_break_en ? 8'h00 : i_data ;\n                            break_flag_rg <= i_break_en ;\n                            ready_rg      <= 1'b0   ;\n                            state_rg      <= START  ;\n                         end\n                      end\n\n         // Send Start State\n         //\n         // - State in which Start bit is sent.\n         // - Moves to DATA State from here.\n         START      : begin                         \n                         if (i_baud_clk) begin                         \n                            o_tx     <= 1'b0 ;\n                            state_rg <= DATA ;\n                         end\n                      end\n         \n         // Send Data State\n         // \n         // - State in which data bits are sent serially.\n         // - Moves to PARITY/BREAK/STOP State from here based on parity mode/break configuration.\n         DATA       : begin\n                         if (i_baud_clk) begin                            \n                            // Increment data counter                            \n                            tx_count_rg <= tx_count_rg + 1 ;\n                            \n                            // Last data bit\n                            if (tx_count_rg == 7) begin \n\n                               // Reset data counter\n                               tx_count_rg <= 0      ;        \n                               \n                               // Parity enabled or not                               \n                               if (i_parity_mode [0]) begin\n                                  state_rg <= PARITY ;        // Proceed to send parity bit\n                               end\n                               else begin\n                                  state_rg <= tx_state'(break_flag_rg ? BREAK : STOP);  // Proceed to send STOP bit iff no break enabled                               \n                               end\n\n                            end\n\n                            // Serial data output\n                            o_tx <= data_rg [tx_count_rg] ; \n                         end \n                      end \n         \n         // Send Parity State\n         //\n         // - State in which parity bit is sent.\n         // - Moves to BREAK/STOP State from here.\n         PARITY     : begin                         \n                         if (i_baud_clk) begin\n                            o_tx     <= break_flag_rg ? 1'b0 : parity_rg ;  // Should send 0 always if break is enabled\n                             state_rg <= tx_state'(break_flag_rg ? BREAK : STOP);  // Proceed to send STOP bit iff no break enabled                            \n                         end\n                      end\n\n         // Send BREAK State\n         //\n         // - State in which break bit is sent.\n         // - Sends 0 at the place of stop bit, which should trigger a frame error at the receiver end.\n         // - Moves to STOP State from here to send Stop bit, so that the receiver can re-sync to the next frame.\n         BREAK      : begin                         \n                         if (i_baud_clk) begin                         \n                            o_tx     <= 1'b0 ;\n                            state_rg <= STOP ;\n                         end\n                      end\n\n         // Send Stop State\n         //\n         // - State in which Stop bit is sent.\n         // - No. of Stop bits sent depend on frame mode configuration.\n         // - Moves to IDLE State from here.\n         STOP       : begin                         \n                         if (i_baud_clk) begin\n                            // Increment Stop bit counter                         \n                            stop_count_rg <= stop_count_rg + 1 ; \n\n                            // Last Stop bit\n                            if (stop_count_rg == i_frame_mode) begin\n                               stop_count_rg <= 0    ;\n                               state_rg      <= IDLE ;                           \n                            end   \n\n                            // Stop bit   \n                            o_tx <= 1'b1 ;\n                         end\n                      end\n\n         default    : ;\n\n      endcase\n      \n      // Parity bit computation\n      parity_rg <= i_parity_mode [1]  ?        // Parity mode\n                   (^ data_rg   )     :        // Even parity bit  \n                   (~ (^ data_rg))    ;        // Odd parity bit\n\n   end\n\nend\n\n// Continuous Assignments\nassign o_ready = ready_rg ;\n\nendmodule"}, "patch": {"rtl/uart_top.sv": "", "verif/tb_uart_top.sv": ""}, "harness": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\nRUN pip3 install cocotb_bus\nFROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir  \n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py\n    \n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n      \n  sanity:\n    image: __OSS_SIM_IMAGE__\n    working_dir: /code/rundir/\n    command: >\n      sh -c \"echo 'Compiling...'\n            iverilog -g2012 /code/rtl/*.sv /code/verif/*.sv\n            echo 'Executing...'\n            vvp a.out\"\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/uart_tx.sv /code/rtl/uart_rx.sv /code/rtl/cdc_sync.sv /code/rtl/baud_gen.sv /code/rtl/areset_sync.sv /code/rtl/uart_top.sv \nTOPLEVEL        = uart_top\nMODULE          = test_uart_top\nPYTHONPATH      = /src\nHASH            = b433c920efa2e3dacf92f2ccb7e456276f8ec675\nTARGET          = 53", "src/areset_sync.sv": "module areset_sync #(   \n   // Configurable parameters   \n   parameter STAGES  = 2    ,        // No. of flops in the synchronizer chain, min. 2\n   parameter RST_POL = 1'b0          // Reset polarity\n)\n\n(\n   input  logic clk         ,        // Clock @ destination clock domain   \n   input  logic i_rst_async ,        // Asynchronous Reset in\n   output logic o_rst_sync           // Asynchronous Reset with de-assertion synchronized\n) ;\n\nlogic reset ;\nassign reset = i_rst_async ^ RST_POL ;\n\n(* ASYNC_REG = \"TRUE\" *)\nlogic [STAGES-1:0] sync_ff ;\n\n// Synchronizing logic\nalways @(posedge clk or negedge reset) begin\n   \n   if (!reset) begin\n      sync_ff <= {STAGES{RST_POL}} ;\n   end\n   else begin\n      sync_ff <= {sync_ff[STAGES-2:0], ~RST_POL} ;     \n   end  \n\nend\n\n// Synchronized reset\nassign o_rst_sync = sync_ff[STAGES-1] ;\n\nendmodule", "src/baud_gen.sv": "module baud_gen (\n                   // Clock and Reset\n                   input  logic           clk            ,        // Clock\n                   input  logic           tx_rst         ,        // TX reset; Active-low Asynchronous\n                   input  logic           rx_rst         ,        // RX reset; Active-low Asynchronous      \n                   \n                   // Baud clock control                   \n                   input  logic [15 : 0]  i_baudrate     ,        // Baud rate\n                   input  logic           i_tx_en        ,        // UART TX baud clock enable\n                   input  logic           i_rx_en        ,        // UART RX baud clock enable\n                   input  logic           i_tx_ready     ,        // UART TX ready\n                   input  logic           i_rx_ready     ,        // UART RX ready\n                   output logic           o_rx_en        ,        // UART RX enable\n                   \n                   // Baud clock pulses\n                   output logic           o_tx_baud_clk  ,        // Baud clock pulse for UART TX\n                   output logic           o_rx_baud_clk  ,        // Baud clock pulse for UART RX\n\n                   // Status signals\n                   output logic           o_tx_state     ,        // State of UART TX (enabled/disabled)\n                   output logic           o_rx_state              // State of UART RX (enabled/disabled)       \n                ) ;  \n\n//\n// Internal Registers/Signals\n//\nlogic          tx_en, rx_en             ;    // TX/RX baud clock internal enable\nlogic          is_tx_en_rg, is_rx_en_rg ;    // TX/RX baud clock state\nlogic [18 : 0] tx_count_rg              ;    // Counter for UART TX baud clock\nlogic [15 : 0] rx_count_rg              ;    // Counter for UART RX baud clock\nlogic [15 : 0] rx_baudcount             ;    // Rx baud count\nlogic [18 : 0] tx_baudcount             ;    // Tx baud count\n\n//\n// Synchronous logic to generate baud clock pulse for UART TX\n//\nalways @ (posedge clk or negedge tx_rst) begin   \n   // Reset\n   if (!tx_rst) begin\n      is_tx_en_rg   <= 1'b0 ;\n      o_tx_baud_clk <= 1'b0 ;\n      tx_count_rg   <= 0    ;\n   end\n   // Out of Reset\n   else begin\n      // TX disabled: disable clock pulses, reset counters...\n      if (!tx_en) begin\n         o_tx_baud_clk <= 1'b0 ;\n         tx_count_rg   <= 0    ;\n         is_tx_en_rg   <= 1'b0 ;  // TX baud clock is in disabled state     \n      end\n      // TX enabled\n      else begin\n         is_tx_en_rg <= 1'b1 ;  // TX baud clock is in enabled state\n         if (tx_count_rg == tx_baudcount) begin\n            o_tx_baud_clk <= 1'b1            ;  // Assert the pulse\n            tx_count_rg   <= 0               ;\n         end      \n         else begin\n            o_tx_baud_clk <= 1'b0            ;  // De-assert the pulse after one cycle \n            tx_count_rg   <= tx_count_rg + 1 ;\n         end\n      end\n   end\nend\n\n// Generate TX baud clock enable internally...\nassign tx_en = i_tx_en ? 1'b1 : (is_tx_en_rg && !i_tx_ready) ;\n\n//\n// Synchronous logic to generate baud clock pulse for UART RX\n//\nalways @ (posedge clk or negedge rx_rst) begin   \n   // Reset\n   if (!rx_rst) begin\n      is_rx_en_rg   <= 1'b0 ;\n      o_rx_baud_clk <= 1'b0 ;\n      rx_count_rg   <= 0    ;\n   end\n   // Out of Reset\n   else begin\n      // RX disabled: disable clock pulses, reset counters...\n      if (!rx_en) begin\n         o_rx_baud_clk <= 1'b0 ;\n         rx_count_rg   <= 0    ;\n         is_rx_en_rg   <= 1'b0 ;  // RX baud clock is in disabled state   \n      end\n      // RX enabled\n      else begin\n         is_rx_en_rg <= 1'b1 ;  // RX baud clock is in enabled state\n         if (rx_count_rg == rx_baudcount) begin  // Sampling at x8\n            o_rx_baud_clk <= 1'b1            ;   // Assert the pulse\n            rx_count_rg   <= 0               ;\n         end\n         else begin\n            o_rx_baud_clk <= 1'b0            ;  // De-assert the pulse after one cycle \n            rx_count_rg   <= rx_count_rg + 1 ; \n         end\n      end\n   end\nend\n\n// Baud counts\nassign rx_baudcount = i_baudrate ;\nassign tx_baudcount = (i_baudrate << 3) + 19'd7 ;\n\n// Generate TX baud clock enable internally...\nassign rx_en = i_rx_en ? 1'b1 : (is_rx_en_rg && !i_rx_ready) ;\n\n// RX enable\nassign o_rx_en = rx_en ;\n\n// Status outputs\nassign o_tx_state = is_tx_en_rg ;\nassign o_rx_state = is_rx_en_rg ;\n\nendmodule\n", "src/cdc_sync.sv": "module cdc_sync #(\n   \n   // Configurable parameters   \n   parameter STAGES = 2             // No. of flops in the sync chain, min. 2\n)\n\n(\n   input  logic clk        ,        // Clock @ destination clock domain\n   input  logic rstn       ,        // Reset @ destination clock domain; this may be omitted if targetting FPGAs\n   input  logic i_sig      ,        // Input signal, asynchronous\n   output logic o_sig_sync          // Output signal synchronized to clk\n) ;\n\n(* ASYNC_REG = \"TRUE\" *)\nlogic [STAGES-1: 0] sync_ff ;\n\n// Synchronizing logic\nalways @(posedge clk or negedge rstn) begin   \n   if (!rstn) begin\n      sync_ff <= '0 ;\n   end\n   else begin\n      sync_ff <= {sync_ff [STAGES-2 : 0], i_sig} ;     \n   end\nend\n\n// Synchronized signal\nassign o_sig_sync = sync_ff [STAGES-1] ;\n\nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # Search for line starting with '|--uart_top'\n    for line in lines:\n        if re.match(r'\\|\\-\\-uart_top\\s+', line):\n            # Extract the Overall Average percentage\n            match = re.search(r'\\|\\-\\-uart_top\\s+([0-9.]+)%\\s+([0-9.]+%)', line)\n            if match:\n                avg = float(match.group(1))  # Overall Average\n                cov = float(match.group(2).replace('%', ''))  # Overall Covered\n                metrics[\"uart_top\"] = {\n                    \"Average\": avg,\n                    \"Covered\": cov\n                }\n            break  # Found the line, break the loop\n\n    assert \"uart_top\" in metrics, \"uart_top coverage data not found.\"\n    assert metrics[\"uart_top\"][\"Average\"] >= float(os.getenv(\"TARGET\", \"50\")), \"Didn't achieve the required coverage result.\"\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom cocotb_tools.runner import get_runner\nimport pytest\nimport pickle\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\n@pytest.mark.tb\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\n#if __name__ == \"__main__\":\n#    test_runner()", "src/test_uart_top.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, First\n\nCLK_PERIOD       = 100      # ns\nRST_CYCLES       = 15\nRST_PULSE_LEN    = CLK_PERIOD * RST_CYCLES\nSYS_CLK          = 1e9 / CLK_PERIOD   # Hz\nBAUDRATE         = 115200\n\nNO_PARITY        = 0b00\nS_S              = 0  # (1 Start bit, 1 Stop bit)\nTX_EN            = 1\nRX_EN            = 1\nUART_PACKETS     = 256\n\n@cocotb.test()\nasync def uart_test(dut):\n    dut._log.info(\"UART test with external loopback.\")\n\n    # Start clock (100 ns period)\n    clock = Clock(dut.clk, CLK_PERIOD, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Start the external loopback process\n    cocotb.start_soon(external_loopback(dut))\n\n    # Initialize/reset signals\n    dut.rstn.value           = 0\n    dut.i_tx_rst.value       = 0\n    dut.i_rx_rst.value       = 0\n    dut.i_baudrate.value     = 0\n    dut.i_parity_mode.value  = 0\n    dut.i_frame_mode.value   = 0\n    dut.i_lpbk_mode_en.value = 0\n    dut.i_tx_break_en.value  = 0\n    dut.i_tx_en.value        = 0\n    dut.i_rx_en.value        = 0\n    dut.i_data.value         = 0\n    dut.i_data_valid.value   = 0\n    dut.i_ready.value        = 0\n\n    await Timer(1500, \"ns\")\n    dut.rstn.value = 1\n    await Timer(1500, \"ns\")\n\n    uart_init(dut)\n\n    # Initialize counters and data values\n    tx_data         = 0\n    rx_data_exp     = 0\n    tx_break_en     = False\n    tx_packet_count = 0\n    rx_packet_count = 0\n\n    # Main test loop: Send up to 256 packets and wait for received data.\n    while True:\n        await RisingEdge(dut.clk)\n\n        if int(dut.o_ready.value) == 1 and tx_packet_count < UART_PACKETS:\n            if tx_break_en:\n                tx_break_en = False\n                await uart_send_byte(dut, tx_data, en_break=False)\n                dut._log.info(f\"Sent data     = {tx_data}\")\n                tx_packet_count += 1\n                tx_data = (tx_data + 1) % 256\n            else:\n                if tx_data != 0 and (tx_data % 8 == 0):\n                    tx_break_en = True\n                    await uart_send_byte(dut, tx_data, en_break=True)\n                    # Removed: dut._log.info(f\"Sent BREAK on data = {tx_data}\")\n                else:\n                    await uart_send_byte(dut, tx_data, en_break=False)\n                    dut._log.info(f\"Sent data     = {tx_data}\")\n                    tx_packet_count += 1\n                    tx_data = (tx_data + 1) % 256\n\n        if int(dut.o_data_valid.value) == 1:\n            rx_byte, p_err, f_err, rx_break = await uart_receive_byte(dut)\n            dut._log.info(f\"Received data = {rx_byte}\")\n\n            # Compare the received byte to the expected value\n            if rx_break:\n                # Removed break print\n                pass\n            else:\n                if rx_byte == rx_data_exp:\n                    dut._log.info(\"Data status   = SUCCESS\")\n                else:\n                    # Removed fail print; still raise error.\n                    raise AssertionError(\"UART packet reception failed.\")\n\n            rx_data_exp = (rx_data_exp + 1) % 256\n            rx_packet_count += 1\n\n            # Always log SUCCESS for parity and frame status.\n            dut._log.info(\"Parity status = SUCCESS\")\n            dut._log.info(\"Frame status  = SUCCESS\")\n            dut._log.info(\"\")\n\n            if rx_packet_count >= 256:\n                dut._log.info(\"UART Test Report\")\n                dut._log.info(\"----------------\")\n                dut._log.info(f\"Sent     : {tx_packet_count} packets\")\n                dut._log.info(f\"Received : {rx_packet_count} packets\")\n                dut._log.info(\"No errors in UART packet reception, test passed !!!\")\n                return\n        else:\n            # Wait for either a clock edge or a timeout (1 \u00b5s)\n            event = await First(RisingEdge(dut.clk), Timer(1000000, \"ns\"))\n            if isinstance(event, Timer):\n                dut._log.error(\"Timeout waiting for received data\")\n                raise AssertionError(\"Test timed out waiting for next packet\")\n\n#--------------------------------------------------------------------------\n# Helper tasks and functions\n#--------------------------------------------------------------------------\n\nasync def external_loopback(dut):\n    \"\"\"Continuously drive the receiver input from the transmitter output.\"\"\"\n    while True:\n        await RisingEdge(dut.clk)\n        dut.i_rx.value = dut.o_tx.value\n\ndef uart_init(dut):\n    \"\"\"Initialize UART parameters.\"\"\"\n    # Example calculation for baud divider (adjust as needed)\n    calc_baud_div = int((1e9 / 100 / BAUDRATE) / 8.0 - 1)\n    dut.i_baudrate.value     = calc_baud_div\n    dut.i_parity_mode.value  = 0  # NO_PARITY\n    dut.i_frame_mode.value   = 0  # 1 Start bit, 1 Stop bit\n    dut.i_tx_en.value        = 1\n    dut.i_rx_en.value        = 1\n    dut.i_lpbk_mode_en.value = 0\n\n    dut._log.info(\"UART initialized with:\")\n    dut._log.info(\"--------------------------------------------\")\n    dut._log.info(\"Baud rate   : 115200 bps\")\n    dut._log.info(\"Parity mode : NO_PARITY\")\n    dut._log.info(\"Frame mode  : 1 Start bit, 1 Stop bit\")\n    dut._log.info(\"TX enabled  : YES\")\n    dut._log.info(\"RX enabled  : YES\")\n    dut._log.info(\"\")\n\nasync def uart_send_byte(dut, data_byte, en_break):\n    \"\"\"Send one UART frame (optionally as a break frame).\"\"\"\n    await RisingEdge(dut.clk)\n    dut.i_data.value        = data_byte\n    dut.i_tx_break_en.value = en_break\n    dut.i_data_valid.value  = 1\n    await RisingEdge(dut.clk)\n    dut.i_data_valid.value  = 0\n    await RisingEdge(dut.clk)\n    dut.i_tx_break_en.value = 0\n\nasync def uart_receive_byte(dut):\n    \"\"\"Receive one UART frame and return a tuple: (data, parity_err, frame_err, rx_break).\"\"\"\n    await RisingEdge(dut.clk)\n    dut.i_ready.value = 1\n    await RisingEdge(dut.clk)\n    dut.i_ready.value = 0\n    await Timer(1, \"ns\")  # Allow outputs to settle\n    rx_byte  = int(dut.o_data.value)\n    p_status = bool(dut.o_parity_err.value)\n    f_status = bool(dut.o_frame_err.value)\n    rx_break = bool(dut.o_rx_break.value)\n    return rx_byte, p_status, f_status, rx_break\n", "src/uart_rx.sv": "module uart_rx  (\n                   input  logic           clk            ,        // Clock\n                   input  logic           rstn           ,        // Active-low Asynchronous Reset \n\n                   input  logic           i_baud_clk     ,        // Baud clock                 \n                   \n                   /* Control Signals */    \n                   input  logic           i_rx_en        ,        // Rx enable\n                   input  logic [1  : 0]  i_parity_mode  ,        // Parity mode\n                   input  logic           i_frame_mode   ,        // Frame mode                             \n                   \n                   /* Serial Data */\n                   input logic            i_rx           ,        // Serial data input\n\n                   /* Parallel Data */     \n                   output logic [7 : 0]   o_data         ,        // Parallel data output\n                   output logic           o_data_valid   ,        // Output data valid\n                   input  logic           i_ready        ,        // Ready to send data\n                   \n                   /* Status Signals */    \n                   output logic           o_rx_ready     ,        // Rx ready/busy to accept new frame...\n                   output logic           o_break        ,        // Break frame received flag\n                   output logic           o_parity_err   ,        // Parity error flag\n                   output logic           o_frame_err             // Frame error flag        \n                ) ;\n\n//   Typedefs\n\n// TX FSM state\ntypedef enum logic [5:0] { \n   IDLE    = 6'h01,  // Idle State\n   DATA    = 6'h02,  // Receive Data State\n   PARITY  = 6'h04,  // Receive Parity State\n   STOP_P  = 6'h08,  // Receive Initial Stop State\n   STOP_F  = 6'h10,  // Receive Final Stop State\n   BUFF    = 6'h20   // Buffer Data State\n}  rx_state ;\n\n//   Internal Registers/Signals\n\nrx_state      state_rg               ;        // State Register\n\n// Frame specific\nlogic         rx_d1_rg               ;        // Rx delayed by one cycle\nlogic         is_rx_1_to_0_edge      ;        // Rx falling edge flag\nlogic         is_frame_sync_rg       ;        // Frame synchronization flag\nlogic         start_bit_rg           ;        // Start bit sampled\nlogic         parity_bit_rg          ;        // Parity bit sampled\nlogic         stop_bit_rg            ;        // Stop bit sampled\nlogic [7 : 0] data_rg                ;        // Data register\nlogic         frame_err_rg           ;        // Frame error register\nlogic         parity_err_rg          ;        // Parity error register\n\n// Counters\nlogic [2 : 0] start_sample_count_rg  ;        // Counter to count Start bit samples   \nlogic [2 : 0] data_sample_count_rg   ;        // Counter to count Data bit samples\nlogic [2 : 0] parity_sample_count_rg ;        // Counter to count Parity bit samples\nlogic [2 : 0] stop_sample_count_rg   ;        // Counter to count Stop bit samples\nlogic [2 : 0] data_count_rg          ;        // Counter to count Data bits sampled\n\n// Flags\nlogic         stop_flag_rg           ;        // To flag if stop bit sampling failed\n\n\n//   Synchronous logic of UART Rx\n\nalways @ (posedge clk or negedge rstn) begin\n   \n   // Reset\n   if (!rstn) begin      \n      // Output Ports\n      o_data                 <= '0    ;\n      o_data_valid           <= 1'b0  ;\n      o_break                <= 1'b0  ;\n      o_parity_err           <= 1'b0  ; \n      o_frame_err            <= 1'b0  ;     \n \n      // Internal Registers/Signals \n      state_rg               <= IDLE  ;\n      \n      rx_d1_rg               <= 1'b0  ;\n      is_frame_sync_rg       <= 1'b0  ;\n      start_bit_rg           <= 1'b1  ;\n      parity_bit_rg          <= 1'b0  ;\n      stop_bit_rg            <= 1'b0  ;\n      data_rg                <= '0    ; \n      frame_err_rg           <= 1'b0  ;  \n      parity_err_rg          <= 1'b0  ;   \n \n      start_sample_count_rg  <=  0    ;\n      data_sample_count_rg   <=  0    ;\n      parity_sample_count_rg <=  0    ;\n      stop_sample_count_rg   <=  0    ;\n      data_count_rg          <=  0    ;\n\n      stop_flag_rg           <= 1'b0  ;\n   end\n\n   // Out of Reset\n   else begin\n      \n      // De-assertion of data valid      \n      if (i_ready) begin\n         o_data_valid <= 1'b0 ;      \t\n      end\n      \n      // One baud clock cycle delayed version of Rx when Rx enabled...      \n      if (!i_rx_en) begin\n         rx_d1_rg <= 1'b0 ;\n      end\n      else if (i_baud_clk) begin\n         rx_d1_rg <= i_rx ;\n      end      \n\n      // FSM\n      case (state_rg)\n         \n         // Idle State\n         //\n         // - Waits in this state for idle -> Start bit transition.\n         // - Triggers start bit sampler on first 1->0 transition.\n         // - Moves to DATA State if Start bit is sampled successfully.  \n         //         \n         IDLE       : begin \n                         if (i_baud_clk && i_rx_en) begin   \n                                                                         \n                            // Frame synchronized, keep sampling            \n                            if (is_frame_sync_rg) begin\n                               start_sample_count_rg <= start_sample_count_rg + 1 ; \n                            end\n                            // Frame not synchronized; looking for 1->0 transition at Rx...\n                            // if the RX line is idle at 0000000.... or 1111111...., the frame is ignored...\n                            // 1->0 is identified as the possible Start bit transition... \n                            else if (is_rx_1_to_0_edge) begin\n                               is_frame_sync_rg      <= 1'b1                      ;    // Frame synchronized\n                               start_sample_count_rg <= start_sample_count_rg + 1 ; \n                            end\n                            \n                            // Sampling at middle\n                            if (start_sample_count_rg == 3) begin\n                               start_bit_rg     <= i_rx ; \n                               // If Start bit detected in the middle, keep frame sync, else lost sync...\n                               is_frame_sync_rg      <= i_rx ? 1'b0 : is_frame_sync_rg ; \n                               start_sample_count_rg <= i_rx ? 0    : start_sample_count_rg + 1 ;                       \t\n                            end\n                            \n                            // Last sample\n                            if (start_sample_count_rg == 7) begin   \n                               if (start_bit_rg == 1'b0) begin                        \t\n                                  state_rg <= DATA ;    // Start bit detected\n                               end                               \n                            end                                                        \t\n\n                         end\n                      end\n\n         // Receive Data State\n         //\n         // - Samples the 8 data bits in this state.\n         // - Moves to PARITY/STOP_P/STOP_F State based on configuration. \n         //\n         DATA       : begin                         \n                         if (i_baud_clk) begin                            \n                            // Increment sample counter\n                            data_sample_count_rg <= data_sample_count_rg + 1 ;\n                            \n                            // Sampling at middle\n                            if (data_sample_count_rg == 3) begin\n                               data_rg [data_count_rg] <= i_rx ;                            \t\n                            end \n                            \n                            // Last sample\n                            if (data_sample_count_rg == 7) begin                               \n                               // Increment data counter                               \n                               data_count_rg <= data_count_rg + 1 ;\n                               \n                               // Last data bit\n                               if (data_count_rg == 7) begin                    \n                                  \n                                  // Next state deduction\n                                  if (i_parity_mode [0]) begin\n                                     state_rg     <= PARITY ;    // Parity                                 \t\n                                  end\n                                  else if (!i_frame_mode) begin                                                                       \t\n                                     state_rg     <= STOP_F ;    // No-parity, 1 Stop bit                                 \t\n                                  end\n                                  else begin\n                                     state_rg     <= STOP_P ;    // No parity, 2 Stop bits                                  \t\n                                  end\n                                  \n                                  if (!i_frame_mode) begin\n                                     stop_flag_rg <= 1'b0   ;    // One-Stop-bit mode transaction, so flag this as successful\n                                  end\n\n                               end\n\n                            end\n                         end\n                      end\n\n         // Receive Parity State\n         //\n         // - Samples Parity bit in this state.\n         // - Moves to STOP_P/STOP_F State from here based on configuration. \n         //\n         PARITY     : begin                         \n                         if (i_baud_clk) begin                            \n                            // Increment sample counter                            \n                            parity_sample_count_rg <= parity_sample_count_rg + 1 ;\n                            \n                            // Sampling at middle\n                            if (parity_sample_count_rg == 3) begin\n                               parity_bit_rg <= i_rx ;                           \t\n                            end\n                            \n                            // Last sample\n                            if (parity_sample_count_rg == 7) begin\n\n                               // Next state deduction\n                               if (!i_frame_mode) begin                                                                 \t\n                                  state_rg     <= STOP_F ;        // One-Stop-bit mode transaction                                 \t\n                               end\n                               else begin\n                                  state_rg     <= STOP_P ;        // Two-Stop-bit mode transaction                                 \t\n                               end\n\n                            end\n                         end\n                      end\n\n         // Receive Initial Stop State\n         // \n         // - Samples the first Stop bit in case of Two-Stop-bits mode transactions.\n         // - Moves to STOP_F State from here.\n         // \n         STOP_P     : begin\n                         if (i_baud_clk) begin                            \n                            // Increment sample counter                            \n                            stop_sample_count_rg <= stop_sample_count_rg + 1 ;\n                            \n                            // Sampling at middle\n                            if (stop_sample_count_rg == 3) begin\n                               stop_flag_rg <= ~ i_rx ;        // Flag if Stop bit was successfully sampled or not                               \n                            end\n                            \n                            // Last sample\n                            if (stop_sample_count_rg == 7) begin                               \n                               state_rg     <= STOP_F ;\n                            end\n                         end\n                      end\n         \n         // Receive Final Stop State\n         //\n         // - Samples the second/final Stop bit.\n         // - Moves to BUFF State from here.\n         //\n         STOP_F     : begin                         \n                         if (i_baud_clk) begin                            \n                            // Increment sample counter\n                            stop_sample_count_rg <= stop_sample_count_rg + 1 ;\n                            \n                            // Sampling at middle\n                            if (stop_sample_count_rg == 3) begin\n                               stop_bit_rg          <= i_rx ;    // Stop bit\n                               stop_sample_count_rg <= 0    ;    // Reset sample counter                      \n\n                               if (i_rx == 1'b0) begin\n                                  frame_err_rg <= 1'b1                ;        // Stop bit was not sampled; Framing error!                                                               \t\n                               end                                                                                                                          \t\n                               else begin\n                                  frame_err_rg <= 1'b0 | stop_flag_rg ;        // Final Stop bit and Initial Stop bit sampling analysed.                                                                       \t\n                               end\n                               \n                               // Finished one frame reception\n                               is_frame_sync_rg  <= 1'b0 ;       // De-assert Frame synchronization\n                               state_rg          <= BUFF ;\n                            end\n                         end\n                      end\n\n         \n         //   Buffer Data State\n         //\n         // - Buffers the sampled data, parity error flag to output.            \n         // - Moves Idle State from here.\n         \n         BUFF       : begin                         \n                         // Buffer valid data and status to output...                        \n                         o_data       <= data_rg ;\n                         o_break      <= (!i_frame_mode) ?\n                                         (frame_err_rg && data_rg == 8'h00 && parity_bit_rg == 1'b0) :  // 1 stop bit\n                                         (stop_flag_rg && data_rg == 8'h00 && parity_bit_rg == 1'b0) ;  // For 2 stop bits, it's considered break frame iff the frame error happened in the first stop bit\n                         o_parity_err <= parity_err_rg ; \n                         o_frame_err  <= frame_err_rg  ;\n                         o_data_valid <= 1'b1          ;                         \n                         \n                         // Ready to receive the next frame\n                         parity_bit_rg <= 1'b0 ;\n                         state_rg      <= IDLE ;\n                      end\n\n         default    : ;\n\n      endcase\n\n      // Parity error flag computation \n      if (i_parity_mode[0]) begin\n      parity_err_rg <= i_parity_mode[1]\n                        ? ((^data_rg)     != parity_bit_rg)  // even parity check\n                        : ((~(^data_rg))  != parity_bit_rg); // odd parity check\n      end else begin\n      parity_err_rg <= 1'b0;\n      end\n\n   end\n\nend\n\n\n//   Continuous Assignments\n\nassign is_rx_1_to_0_edge = (rx_d1_rg && !i_rx) ;  // ``\\__ detected on Rx\n\n// Output status\nassign o_rx_ready        = ~is_frame_sync_rg ;\n\nendmodule\n", "src/uart_top.sv": "module uart_top (\n                   /* Clock and Reset */\n                   input  logic         clk            ,        // Clock\n                   input  logic         rstn           ,        // Active-low Asynchronous Reset   \n\n                   /* Serial Interface */\n                   output logic         o_tx           ,        // Serial data out, TX\n                   input  logic         i_rx           ,        // Serial data in, RX              \n                   \n                   /* Control Signals */    \n                   input  logic [15:0]  i_baudrate     ,        // Baud rate\n                   input  logic [1:0]   i_parity_mode  ,        // Parity mode\n                   input  logic         i_frame_mode   ,        // Frame mode \n                   input  logic         i_lpbk_mode_en ,        // Loopback mode enable\n                   input  logic         i_tx_break_en  ,        // Enable to send break frame on TX\n                   input  logic         i_tx_en        ,        // UART TX (Transmitter) enable\n                   input  logic         i_rx_en        ,        // UART RX (Receiver) enable \n                   input  logic         i_tx_rst       ,        // UART TX reset\n                   input  logic         i_rx_rst       ,        // UART RX reset                \n                   \n                   /* UART TX Data Interface */    \n                   input  logic [7:0]   i_data         ,        // Parallel data input\n                   input  logic         i_data_valid   ,        // Input data valid\n                   output logic         o_ready        ,        // Ready signal from UART TX \n                   \n                   /* UART RX Data Interface */ \n                   output logic [7:0]   o_data         ,        // Parallel data output\n                   output logic         o_data_valid   ,        // Output data valid\n                   input  logic         i_ready        ,        // Ready signal to UART RX\n                   \n                   /* Status Signals */   \n                   output logic         o_tx_state     ,        // State of UART TX (enabled/disabled)\n                   output logic         o_rx_state     ,        // State of UART RX (enabled/disabled)\n                   output logic         o_rx_break     ,        // Flags break frame received on RX\n                   output logic         o_parity_err   ,        // Parity error flag\n                   output logic         o_frame_err             // Frame error flag                                            \n);\n\n\n//   Internal Registers/Signals\n\n// Connection between Baud Generator & UART TX \nlogic tx_baud_clk ;        // Baud clock pulse from Baud Generator to UART TX\nlogic tx_ready    ;        // TX ready\n\n// Connection between Baud Generator & UART RX \nlogic rx_baud_clk ;        // Baud clock pulse from Baud Generator to UART RX\nlogic rx_ready    ;        // RX ready\nlogic rx_en       ;        // RX enable\n\n// Other signals\nlogic tx          ;        // TX data to Serial I/F\nlogic rx          ;        // RX data from Serial I/F or loopback\nlogic irx_sync    ;        // Serial data input synchronized to the core-clock domain\nlogic tx_rst_sync ;        // Synchronized reset to TX\nlogic rx_rst_sync ;        // Synchronized reset to RX\n\n\n//   Sub-modules Instantations\n\n// Baud Generator\nbaud_gen inst_baud_gen    (\n                        .clk           ( clk  )                  ,\n                        .tx_rst        ( tx_rst_sync )           ,\n                        .rx_rst        ( rx_rst_sync )           ,\n         \n                        .i_baudrate    ( i_baudrate  )           ,\n                        .i_tx_en       ( i_tx_en     )           ,\n                        .i_rx_en       ( i_rx_en     )           ,    \n                        .i_tx_ready    ( tx_ready    )           ,    \n                        .i_rx_ready    ( rx_ready    )           , \n                        .o_rx_en       ( rx_en       )           ,  \n         \n                        .o_tx_baud_clk ( tx_baud_clk )           ,\n                        .o_rx_baud_clk ( rx_baud_clk )           ,\n\n                        .o_tx_state    ( o_tx_state )            ,\n                        .o_rx_state    ( o_rx_state )\n                     ) ;\n\n// UART TX   \nuart_tx inst_uart_tx      (\n                        .clk           ( clk            )        ,\n                        .rstn          ( tx_rst_sync    )        , \n        \n                        .i_baud_clk    ( tx_baud_clk    )        ,\n\n                        .i_parity_mode ( i_parity_mode  )        ,\n                        .i_frame_mode  ( i_frame_mode   )        ,\n                        .i_break_en    ( i_tx_break_en  )        ,\n\n                        .i_data        ( i_data         )        ,\n                        .i_data_valid  ( i_data_valid   )        ,\n                        .o_ready       ( tx_ready       )        ,\n\n                        .o_tx          ( tx             )     \n                     ) ;\n\n// UART RX   \nuart_rx inst_uart_rx      (\n                        .clk           ( clk            )        ,\n                        .rstn          ( rx_rst_sync    )        , \n        \n                        .i_baud_clk    ( rx_baud_clk    )        ,\n                        \n                        .i_rx_en       ( rx_en          )        ,\n                        .i_parity_mode ( i_parity_mode  )        ,\n                        .i_frame_mode  ( i_frame_mode   )        ,\n                        \n                        .i_rx          ( irx_sync       )        ,\n\n                        .o_data        ( o_data         )        ,\n                        .o_data_valid  ( o_data_valid   )        ,\n                        .i_ready       ( i_ready        )        ,\n                        \n                        .o_rx_ready    ( rx_ready       )        ,\n                        .o_break       ( o_rx_break     )        ,\n                        .o_parity_err  ( o_parity_err   )        ,\n                        .o_frame_err   ( o_frame_err    )   \n                     ) ;\n\n// RX serial data synchronizer for CDC\ncdc_sync inst_rx_sync     (\n                        .clk         ( clk      ) ,\n                        .rstn        ( rstn     ) ,\n                        .i_sig       ( rx       ) ,\n                        .o_sig_sync  ( irx_sync )\n                     ) ;\n\n// Reset synchronizer for TX\nareset_sync inst_tx_rst_sync (\n                         .clk         (clk)              ,\n                         .i_rst_async (~i_tx_rst & rstn) ,\n                         .o_rst_sync  (tx_rst_sync)\n\n                      ) ;\n\n// Reset synchronizer for RX\nareset_sync inst_rx_rst_sync (\n                         .clk         (clk)              ,\n                         .i_rst_async (~i_rx_rst & rstn) ,\n                         .o_rst_sync  (rx_rst_sync)\n\n                      ) ;\n\n// Loopback is expected to be switched after disabling TX and RX to avoid glitches/broken frames...\nassign rx = i_lpbk_mode_en?  tx : i_rx ;\n\n// Outputs\nassign o_tx    = tx       ;\nassign o_ready = tx_ready ;\n\nendmodule", "src/uart_tx.sv": "module uart_tx  (\n                   input  logic           clk            ,        // Clock\n                   input  logic           rstn           ,        // Active-low Asynchronous Reset\n\n                   input  logic           i_baud_clk     ,        // Baud clock                  \n                   \n                   /* Control Signals */                   \n                   input  logic [1  : 0]  i_parity_mode  ,        // Parity mode\n                   input  logic           i_frame_mode   ,        // Frame mode   \n                   input  logic           i_break_en     ,        // Enable to send break frame                                  \n                   \n                   /* Parallel Data */    \n                   input  logic [7 :  0]  i_data         ,        // Parallel data input\n                   input  logic           i_data_valid   ,        // Input data valid\n                   output logic           o_ready        ,        // Ready to accept data  \n\n                   /* Serial Data */\n                   output logic           o_tx                    // Serial data output            \n                ) ;\n\n// Typedefs\n// TX FSM state\ntypedef enum logic [5:0] { \n   IDLE    = 6'h01,  // Idle State\n   START   = 6'h02,  // Send Start State\n   DATA    = 6'h04,  // Send Data State\n   PARITY  = 6'h08,  // Send Parity State\n   BREAK   = 6'h10,  // Send BREAK State\n   STOP    = 6'h20   // Send Stop State\n}  tx_state ;\n\n//\n// Internal Registers/Signals\n//\ntx_state      state_rg      ;        // State Register\n\nlogic [7 : 0] data_rg       ;        // Data buffer\nlogic         parity_rg     ;        // Parity bit register\nlogic         ready_rg      ;        // Ready register\nlogic         break_flag_rg ;        // Flags break enabled\nlogic [2 : 0] tx_count_rg   ;        // Data counter\nlogic         stop_count_rg ;        // Stop bit counter\n\n//\n// Synchronous logic of UART Tx\n//\nalways @ (posedge clk or negedge rstn) begin\n   \n   // Reset\n   if (!rstn) begin      \n      // Output Ports\n      o_tx          <= 1'b1 ;\n\n      // Internal Registers/Signals\n      state_rg      <= IDLE ;\n      data_rg       <= '0   ;\n      parity_rg     <= 1'b0 ;\n      ready_rg      <= 1'b0 ;\n      break_flag_rg <= 1'b0 ;\n      tx_count_rg   <= 0    ;\n      stop_count_rg <= 0    ;\n   end\n\n   // Out of Reset\n   else begin \n\n      // FSM   \n      case (state_rg)\n         \n         // Idle State\n         //\n         // - State in which UART Tx waits for a valid parallel data input.\n         // - Buffer the parallel data and moves to START State from here.\n         IDLE       : begin\n                         // IDLE state of TX line\n                         o_tx <= 1'b1 ;\n\n                         // Ready to accept data\n                         ready_rg <= 1'b1 ;\n                         \n                         // Buffer the input data\n                         // If break enabled, buffer all 0s\n                         if (i_data_valid & ready_rg) begin\n                            data_rg       <= i_break_en ? 8'h00 : i_data ;\n                            break_flag_rg <= i_break_en ;\n                            ready_rg      <= 1'b0   ;\n                            state_rg      <= START  ;\n                         end\n                      end\n\n         // Send Start State\n         //\n         // - State in which Start bit is sent.\n         // - Moves to DATA State from here.\n         START      : begin                         \n                         if (i_baud_clk) begin                         \n                            o_tx     <= 1'b0 ;\n                            state_rg <= DATA ;\n                         end\n                      end\n         \n         // Send Data State\n         // \n         // - State in which data bits are sent serially.\n         // - Moves to PARITY/BREAK/STOP State from here based on parity mode/break configuration.\n         DATA       : begin\n                         if (i_baud_clk) begin                            \n                            // Increment data counter                            \n                            tx_count_rg <= tx_count_rg + 1 ;\n                            \n                            // Last data bit\n                            if (tx_count_rg == 7) begin \n\n                               // Reset data counter\n                               tx_count_rg <= 0      ;        \n                               \n                               // Parity enabled or not                               \n                               if (i_parity_mode [0]) begin\n                                  state_rg <= PARITY ;        // Proceed to send parity bit\n                               end\n                               else begin\n                                  state_rg <= tx_state'(break_flag_rg ? BREAK : STOP);  // Proceed to send STOP bit iff no break enabled                               \n                               end\n\n                            end\n\n                            // Serial data output\n                            o_tx <= data_rg [tx_count_rg] ; \n                         end \n                      end \n         \n         // Send Parity State\n         //\n         // - State in which parity bit is sent.\n         // - Moves to BREAK/STOP State from here.\n         PARITY     : begin                         \n                         if (i_baud_clk) begin\n                            o_tx     <= break_flag_rg ? 1'b0 : parity_rg ;  // Should send 0 always if break is enabled\n                             state_rg <= tx_state'(break_flag_rg ? BREAK : STOP);  // Proceed to send STOP bit iff no break enabled                            \n                         end\n                      end\n\n         // Send BREAK State\n         //\n         // - State in which break bit is sent.\n         // - Sends 0 at the place of stop bit, which should trigger a frame error at the receiver end.\n         // - Moves to STOP State from here to send Stop bit, so that the receiver can re-sync to the next frame.\n         BREAK      : begin                         \n                         if (i_baud_clk) begin                         \n                            o_tx     <= 1'b0 ;\n                            state_rg <= STOP ;\n                         end\n                      end\n\n         // Send Stop State\n         //\n         // - State in which Stop bit is sent.\n         // - No. of Stop bits sent depend on frame mode configuration.\n         // - Moves to IDLE State from here.\n         STOP       : begin                         \n                         if (i_baud_clk) begin\n                            // Increment Stop bit counter                         \n                            stop_count_rg <= stop_count_rg + 1 ; \n\n                            // Last Stop bit\n                            if (stop_count_rg == i_frame_mode) begin\n                               stop_count_rg <= 0    ;\n                               state_rg      <= IDLE ;                           \n                            end   \n\n                            // Stop bit   \n                            o_tx <= 1'b1 ;\n                         end\n                      end\n\n         default    : ;\n\n      endcase\n      \n      // Parity bit computation\n      parity_rg <= i_parity_mode [1]  ?        // Parity mode\n                   (^ data_rg   )     :        // Even parity bit  \n                   (~ (^ data_rg))    ;        // Odd parity bit\n\n   end\n\nend\n\n// Continuous Assignments\nassign o_ready = ready_rg ;\n\nendmodule\n"}}
