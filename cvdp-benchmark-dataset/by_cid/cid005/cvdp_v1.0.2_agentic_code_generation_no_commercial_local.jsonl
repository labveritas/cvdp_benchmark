{"id": "cvdp_agentic_64b66b_codec_0001", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I need to implement a **64b/66b top-level codec module** that integrates a **data encoder (`encoder_data_64b66b`), a control encoder (`encoder_control_64b66b`), and a combined data/control decoder (`decoder_data_control_64b66b`)**. The top-level module should be created at **`/code/rtl/top_64b66b_codec.sv`** and must manage the full encode-decode flow for 64b/66b encoding, supporting data, and control paths.\n\nThe encoder must select between data and control encoding based on the `enc_control_in` value and produce a 66-bit encoded output (`enc_data_out`). The decoder must process incoming 66-bit data and output 64-bit decoded data, associated control signals, and any sync or decoding errors.\n\nThe RTL source files are located as follows:\n- `/code/rtl/encoder_data_64b66b.sv`\n- `/code/rtl/encoder_control_64b66b.sv`\n- `/code/rtl/decoder_data_control_64b66b.sv`\n\nThe documentation, located under the`/code/docs/specification.md` directory, provides design requirements and behavior specifications. \n\nThis integrated module should operate with **minimal latency and full protocol compliance**, as defined in the provided documentation.\n", "context": {"docs/specification.md": "# **64b/66b Codec Specification Document**\n\n## **1. Overview**\nThe 64b/66b encoding scheme is a line coding technique defined by the IEEE 802.3 standard for high-speed serial communication (e.g., 10GbE, PCIe). It addresses two primary transmission challenges:\n- **Clock recovery**: Ensuring frequent transitions to maintain synchronization.\n- **DC balance**: Avoiding long sequences of identical bits that might skew signal integrity.\n\nThe encoder maps 64-bit data along with optional control indicators into a 66-bit encoded format. The decoder reconstructs the original 64-bit data and control information, detecting synchronization and format errors.\n\n## **2. Module Hierarchy**\n```\ntop_64b66b_codec (Top-level)\n\u251c\u2500\u2500 encoder_data_64b66b (Data path encoder)\n\u251c\u2500\u2500 encoder_control_64b66b (Control path encoder)\n\u2514\u2500\u2500 decoder_data_control_64b66b (Data and control path decoder)\n```\n\n## **3. Top-Level Module**\n\n### **3.1 top_64b66b_codec**\nThe system integrator instantiates and connects all submodules. Routes signals based on control inputs and handles data flow between encoder/decoder paths.\n\n#### **I/O Port List**\n| Port                  | Direction | Width | Description                      |\n|-----------------------|-----------|-------|----------------------------------|\n| `clk_in`              | input     | 1     | System clock (rising-edge)       |\n| `rst_in`              | input     | 1     | Active-high synchronous reset    |\n| `enc_data_in`         | input     | 64    | Data input for encoding          |\n| `enc_control_in`      | input     | 8     | Control input for encoding       |\n| `enc_data_out`        | output    | 66    | Encoded output                   |\n| `dec_data_valid_in`   | input     | 1     | Decoder input valid signal       |\n| `dec_data_in`         | input     | 66    | Encoded input for decoding       |\n| `dec_data_out`        | output    | 64    | Decoded data output              |\n| `dec_control_out`     | output    | 8     | Decoded control output           |\n| `dec_sync_error`      | output    | 1     | Sync header error flag           |\n| `dec_error_out`       | output    | 1     | Comprehensive error indicator    |\n\n## **4. Submodules**\n\n### **4.1 encoder_data_64b66b**\nHandles pure data path encoding with \"01\" sync headers.\n\n#### **Key Features**\n- Processes 64-bit data words\n- Generates 2'b01 sync header\n- Zero-latency data pass-through\n- No type field insertion\n\n#### **I/O Port List**\n| Port                  | Direction | Width | Description                      |\n|-----------------------|-----------|-------|----------------------------------|\n| `clk_in`              | input     | 1     | System clock                     |\n| `rst_in`              | input     | 1     | Active-high reset                |\n| `encoder_data_in`     | input     | 64    | Input data word                  |\n| `encoder_control_in`  | input     | 8     | Control mask                     |\n| `encoder_data_out`    | output    | 66    | Encoded output (01 + data)       |\n\n### **4.2 encoder_control_64b66b**\nEncodes control sequences based on both the control flags and matching data patterns.\n\n- Adds sync header `10`\n- Appends an **8-bit type field** to classify the control pattern\n- Encodes remaining 56 bits based on predefined mappings\n- Detects and encodes special sequences such as:\n  - Idle sequences\n  - Start/End of packet delimiters\n  - Custom application codes\n\nControl encoding ensures:\n- Consistent mapping for control events\n- Valid type field generation\n- Zero padding or data substitution to enforce format\n\n#### **I/O Port List**\n| Port                  | Direction | Width | Description                      |\n|-----------------------|-----------|-------|----------------------------------|\n| `clk_in`              | input     | 1     | System clock                     |\n| `rst_in`              | input     | 1     | Active-high reset                |\n| `encoder_data_in`     | input     | 64    | Input data/control word          |\n| `encoder_control_in`  | input     | 8     | Control mask                     |\n| `encoder_data_out`    | output    | 66    | Encoded output (10 + type + data)|\n\n#### **Design Specification**\nThe encoder_control_64b66b converts 64-bit data words and 8-bit control words into 66-bit encoded output with three operational modes:\n\n1. **Control-Only Mode**:  \n   - Activated when `encoder_control_in` = 8'hFF\n   - Sync word set to 2'b10\n   - Full control character replacement\n\n2. **Mixed Mode**:  \n   - Activated for 0 < `encoder_control_in` < 8'hFF\n   - Sync word set to 2'b10\n   - Combines data bytes and control characters\n\n#### **Control Character Encoding**\n| Control Character | Hex Value | Encoded Value | Usage                |\n|-------------------|-----------|---------------|----------------------|\n| Idle (/I/)        | 0x07      | 7'h00         | Link synchronization |\n| Start (/S/)       | 0xFB      | 4'b0000       | Packet delineation   |\n| Terminate (/T/)   | 0xFD      | 4'b0000       | End-of-packet        |\n| Error (/E/)       | 0xFE      | 7'h1E         | Error propagation    |\n| Ordered Set (/Q/) | 0x9C      | 4'b1111       | Configuration        |\n\n\n#### **Valid Control Input Combinations with Type Field Lookup Table**\n\n| **Data Input [63:0]**            | **Control Input**| **Output [65:64]**| **Output [63:56]**| **Output [55:0]**                       |\n|----------------------------------|------------------|-------------------|-------------------|-----------------------------------------|\n| `I7, I6, I5, I4, I3, I2, I1, I0` | `8'b11111111`    | `2'b10`           | `0x1e`            | `C7, C6, C5, C4, C3, C2, C1, C0`        |\n| `E7, E6, E5, E4, E3, E2, E1, E0` | `8'b11111111`    | `2'b10`           | `0x1e`            | `C7, C6, C5, C4, C3, C2, C1, C0`        |\n| `D7, D6, D5, S4, I3, I2, I1, I0` | `8'b00011111`    | `2'b10`           | `0x33`            | `D7, D6, D5, 4'b0000, C3, C2, C1, C0`   |\n| `D7, D6, D5, D4, D3, D2, D1, S0` | `8'b00000001`    | `2'b10`           | `0x78`            | `D7, D6, D5, D4, D3, D2, D1, D0`        |\n| `I7, I6, I5, I4, I3, I2, I1, T0` | `8'b11111110`    | `2'b10`           | `0x87`            | `C7, C6, C5, C4, C3, C2, C1, 7'b0000000`|\n| `I7, I6, I5, I4, I3, I2, T1, D0` | `8'b11111110`    | `2'b10`           | `0x99`            | `C7, C6, C5, C4, C3, C2, 6'b000000, D0` |\n| `I7, I6, I5, I4, I3, T2, D1, D0` | `8'b11111100`    | `2'b10`           | `0xaa`            | `C7, C6, C5, C4, C3, 5'b00000, D1, D0`  |\n| `I7, I6, I5, I4, T3, D2, D1, D0` | `8'b11111000`    | `2'b10`           | `0xb4`            | `C7, C6, C5, C4, 4'b0000, D2, D1, D0`   |\n| `I7, I6, I5, T4, D3, D2, D1, D0` | `8'b11110000`    | `2'b10`           | `0xcc`            | `C7, C6, C5, 3'b000, D3, D2, D1, D0`    |\n| `I7, I6, T5, D4, D3, D2, D1, D0` | `8'b11100000`    | `2'b10`           | `0xd2`            | `C7, C6, 2'b00, D4, D3, D2, D1, D0`     |\n| `I7, T6, D5, D4, D3, D2, D1, D0` | `8'b11000000`    | `2'b10`           | `0xe1`            | `C7, 1'b0, D5, D4, D3, D2, D1, D0`      |\n| `T7, D6, D5, D4, D3, D2, D1, D0` | `8'b10000000`    | `2'b10`           | `0xff`            | `D6, D5, D4, D3, D2, D1, D0`            |\n| `D7, D6, D5, Q4, I3, I2, I1, I0` | `8'b00011111`    | `2'b10`           | `0x2d`            | `D7, D6, D5, 4'b1111, C3, C2, C1, C0`   |\n| `I7, I6, I5, I4, D3, D2, D1, Q0` | `8'b11110001`    | `2'b10`           | `0x4b`            | `C7, C6, C5, C4, D3, D2, D1, 4'b1111`   |\n| `D7, D6, D5, Q4, D3, D2, D1, Q0` | `8'b00010001`    | `2'b10`           | `0x55`            | `D7, D6, D5, 8'b11111111, D3, D2, D1`   |\n| `D7, D6, D5, S4, D3, D2, D1, Q0` | `8'b00010001`    | `2'b10`           | `0x66`            | `D7, D6, D5, 8'b00001111, D3, D2, D1`   |\n\n### **4.3 decoder_data_control_64b66b**\nCombined decoder handling both data and control paths. The decoder handles the full 66-bit word and interprets it based on the sync header.\n\n- **Sync header `01`**: Interpreted as raw data\n- **Sync header `10`**: Parsed using the type field to reconstruct original data and control meaning\n\n#### Functionality:\n- Extracts and checks sync headers\n- Maps type fields back to original control flags\n- Reconstructs data based on encoding format\n- Detects invalid sync headers and unknown control types\n- Performs data validation for encoded formats\n\n#### Error Detection:\n- **Sync Error**: Raised for invalid sync headers (neither `01` nor `10`)\n- **Format Error**: Raised if control types do not match expected format\n\n#### **I/O Port List**\n| Port                      | Direction | Width | Description                      |\n|---------------------------|-----------|-------|----------------------------------|\n| `clk_in`                  | input     | 1     | System clock                     |\n| `rst_in`                  | input     | 1     | Active-high reset                |\n| `decoder_data_valid_in`   | input     | 1     | Input data valid                 |\n| `decoder_data_in`         | input     | 66    | Encoded input                    |\n| `decoder_data_out`        | output    | 64    | Decoded data                     |\n| `decoder_control_out`     | output    | 8     | Decoded control mask             |\n| `sync_error`              | output    | 1     | Header error flag                |\n| `decoder_error_out`       | output    | 1     | Composite error indicator        |\n\n\n#### **Control Character Mapping**\n\n| Character | Hex | Usage                     |\n|-----------|-----|---------------------------|\n| /I/       | 0x07| Idle sequence             |\n| /S/       | 0xFB| Start of packet           |\n| /T/       | 0xFD| End of packet             |\n| /E/       | 0xFE| Error indication          |\n| /Q/       | 0x9C| Ordered set               |\n\n#### **Decoding Table**\n| **Type Field** | **decoder_control_out**  | **decoder_data_out**              |\n|----------------|--------------------------|-----------------------------------|\n| `0x1E`         | `8'b11111111`            | `{E7, E6, E5, E4, E3, E2, E1, E0}`|\n| `0x33`         | `8'b00011111`            | `{D6, D5, D4, S4, I3, I2, I1, I0}`|\n| `0x78`         | `8'b00000001`            | `{D6, D5, D4, D3, D2, D1, D0, S0}`|\n| `0x87`         | `8'b11111110`            | `{I7, I6, I5, I4, I3, I2, I1, T0}`|\n| `0x99`         | `8'b11111110`            | `{I7, I6, I5, I4, I3, I2, T1, D0}`|\n| `0xAA`         | `8'b11111100`            | `{I7, I6, I5, I4, I3, T2, D1, D0}`|\n| `0xB4`         | `8'b11111000`            | `{I7, I6, I5, I4, T3, D2, D1, D0}`|\n| `0xCC`         | `8'b11110000`            | `{I7, I6, I5, T4, D3, D2, D1, D0}`|\n| `0xD2`         | `8'b11100000`            | `{I7, I6, T5, D4, D3, D2, D1, D0}`|\n| `0xE1`         | `8'b11000000`            | `{I7, T6, D5, D4, D3, D2, D1, D0}`|\n| `0xFF`         | `8'b10000000`            | `{T7, D6, D5, D4, D3, D2, D1, D0}`|\n| `0x2D`         | `8'b00011111`            | `{D6, D5, D4, Q4, I3, I2, I1, I0}`|\n| `0x4B`         | `8'b11110001`            | `{I7, I6, I5, I4, D2, D1, D0, Q0}`|\n| `0x55`         | `8'b00010001`            | `{D6, D5, D4, Q4, D2, D1, D0, Q0}`|\n| `0x66`         | `8'b00010001`            | `{D6, D5, D4, S4, D2, D1, D0, Q0}`|\n\n- **Explanation**:\n     - `Dx`: Represents data bits from the input.\n     - `Ix`: Represents idle control characters (`/I/`).\n     - `Sx`: Represents start-of-frame control characters (`/S/`).\n     - `Tx`: Represents end-of-frame control characters (`/T/`).\n     - `Ex`: Represents error control characters (`/E/`).\n     - `Qx`: Represents ordered-set control characters (`/Q/`).\n\n#### **Error Signal Implementation**:\n   - The module generates two error signals:\n     1. **`sync_error`**:\n        - Asserted HIGH when the sync header is invalid (neither `2'b01` nor `2'b10`).\n        - This indicates a synchronization error, meaning the input data is not properly aligned or formatted.\n     2. **`decoder_error_out`**:\n        - Asserted HIGH when either:\n          - The type field is invalid (not in the predefined list of valid type fields).\n          - The control data (`data_in`) does not match the expected pattern for the given type field.\n        - This indicates a decoding error, meaning the input data cannot be properly decoded.\n        - The `decoder_error_out` signal is generated by combining the above two conditions.\n\n## **5. Latency**\n| Module                  | Latency |\n|-------------------------|---------|\n| encoder_data_64b66b     | 1 cycle |\n| encoder_control_64b66b  | 1 cycle |\n| decoder_data_control_64b66b | 1 cycle |\n\n## **6. Operational Notes**\n1. **Clock Domain**:\n   - All modules synchronous to clk_in\n   - No cross-clock domain handling\n\n2. **Reset Behavior**:\n   - Clears all registers\n   - Outputs forced to zero\n   - Error flags cleared\n\n3. **Performance Tradeoffs**:\n   - Fixed 1-cycle latency\n   - Balanced pipeline design\n   - Critical path optimization", "rtl/decoder_data_control_64b66b.sv": "module decoder_data_control_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic         decoder_data_valid_in, // Input data valid signal\n    input  logic [65:0]  decoder_data_in,     // 66-bit encoded input\n    output logic [63:0]  decoder_data_out,    // Decoded 64-bit data output\n    output logic [7:0]   decoder_control_out, // Decoded 8-bit control output\n    output logic         sync_error,          // Sync error flag\n    output logic         decoder_error_out    // Type field error flag\n);\n\n    logic [1:0] sync_header;\n    logic [7:0] type_field;\n    logic [63:0] data_in;\n    logic type_field_valid;\n    logic decoder_wrong_ctrl_received;\n    logic decoder_wrong_type_field;\n\n    assign sync_header = decoder_data_in[65:64];\n    assign type_field = decoder_data_in[63:56];\n    assign data_in = decoder_data_in[55:0];\n\n    always_comb begin\n        type_field_valid = 1'b0;\n        if (sync_header == 2'b10) begin\n            case (type_field)\n                8'h1E, 8'h33, 8'h78, 8'h87, 8'h99, 8'hAA, 8'hB4, \n                8'hCC, 8'hD2, 8'hE1, 8'hFF, 8'h2D, 8'h4B, 8'h55, 8'h66: \n                    type_field_valid = 1'b1;\n                default: type_field_valid = 1'b0;\n            endcase\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_control_out <= 8'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            if (sync_header == 2'b10) begin\n                case (type_field)\n                    8'h1E: decoder_control_out <= 8'b11111111;\n                    8'h33: decoder_control_out <= 8'b00011111;\n                    8'h78: decoder_control_out <= 8'b00000001;\n                    8'h87: decoder_control_out <= 8'b11111110;\n                    8'h99: decoder_control_out <= 8'b11111110;\n                    8'hAA: decoder_control_out <= 8'b11111100;\n                    8'hB4: decoder_control_out <= 8'b11111000;\n                    8'hCC: decoder_control_out <= 8'b11110000;\n                    8'hD2: decoder_control_out <= 8'b11100000;\n                    8'hE1: decoder_control_out <= 8'b11000000;\n                    8'hFF: decoder_control_out <= 8'b10000000;\n                    8'h2D: decoder_control_out <= 8'b00011111;\n                    8'h4B: decoder_control_out <= 8'b11110001;\n                    8'h55: decoder_control_out <= 8'b00010001;\n                    8'h66: decoder_control_out <= 8'b00010001;\n                    default: decoder_control_out <= 8'b0;\n                endcase\n            end\n            else begin\n                decoder_control_out <= 8'b0;\n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_data_out <= 64'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            case (sync_header)\n                2'b01: begin\n                    decoder_data_out <= decoder_data_in[63:0];\n                end\n                2'b10: begin\n                    case (type_field)\n                        8'h1E: if (data_in[55:0] == {8{7'h1E}}) decoder_data_out <= {8{8'hFE}};\n                               else decoder_data_out <= {8{8'h07}};\n                        8'h33: decoder_data_out <= {data_in[55:32], 8'hFB, {4{8'h07}}};\n                        8'h78: decoder_data_out <= {data_in[55:0], 8'hFB};\n                        8'h87: decoder_data_out <= {{7{8'h07}},8'hFD};\n                        8'h99: decoder_data_out <= {{6{8'h07}}, 8'hFD, data_in[7:0]};\n                        8'hAA: decoder_data_out <= {{5{8'h07}}, 8'hFD, data_in[15:0]};\n                        8'hB4: decoder_data_out <= {{4{8'h07}}, 8'hFD, data_in[23:0]};\n                        8'hCC: decoder_data_out <= {{3{8'h07}}, 8'hFD, data_in[31:0]};\n                        8'hD2: decoder_data_out <= {{2{8'h07}}, 8'hFD, data_in[39:0]};\n                        8'hE1: decoder_data_out <= {8'h07, 8'hFD, data_in[47:0]};\n                        8'hFF: decoder_data_out <= {8'hFD, data_in[55:0]};\n                        8'h2D: decoder_data_out <= {data_in[55:32], 8'h9C, {4{8'h07}}};\n                        8'h4B: decoder_data_out <= {{4{8'h07}}, data_in[28:5], 8'h9C};\n                        8'h55: decoder_data_out <= {data_in[55:32], 8'h9C, data_in[23:0], 8'h9C};\n                        8'h66: decoder_data_out <= {data_in[55:32], 8'hFB, data_in[23:0], 8'h9C};\n                        default: decoder_data_out <= 64'b0;\n                    endcase\n                end\n                default: decoder_data_out <= 64'b0;\n            endcase\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_error <= 1'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            sync_error <= (sync_header != 2'b01 && sync_header != 2'b10);\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_wrong_type_field <= 1'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            if (sync_header == 2'b10) begin\n                decoder_wrong_type_field <= ~type_field_valid;\n            end\n            else begin\n                decoder_wrong_type_field <= 1'b0;\n            end\n        end\n    end\n    \n    assign decoder_error_out = decoder_wrong_ctrl_received || decoder_wrong_type_field;\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_wrong_ctrl_received <= 1'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            if (sync_header == 2'b10) begin\n                case (type_field)\n                    8'h1E: if ((data_in[55:0] == {8{7'h1E}}) || (data_in[55:0] == {8{7'h00}})) decoder_wrong_ctrl_received <= 1'b0;\n                           else decoder_wrong_ctrl_received <= 1'b1;\n                    8'h33: if (data_in [31:0] != 32'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h87: if (data_in [55:0] != 56'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h99: if (data_in [55:8] != 48'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hAA: if (data_in [55:16] != 40'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hB4: if (data_in [55:24] != 32'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hCC: if (data_in [55:32] != 24'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hD2: if (data_in [55:40] != 16'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hE1: if (data_in [55:48] != 8'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h2D: if (data_in [31:0] != 32'hF0000000) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h4B: if (data_in[55:28] != {4{7'h00}} && data_in[3:0] != 4'b1111) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;              \n                    8'h55: if (data_in[31:24] != 8'hFF) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0; \n                    8'h66: if (data_in[31:24] != 8'h0F) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0; \n                    default: decoder_wrong_ctrl_received <= 1'b0; \n                endcase\n            end\n            else begin\n                decoder_wrong_ctrl_received <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "rtl/encoder_control_64b66b.sv": "module encoder_control_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic [63:0]  encoder_data_in,     // 64-bit data input\n    input  logic [7:0]   encoder_control_in,  // 8-bit control input\n    output logic [65:0]  encoder_data_out     // 66-bit encoded output\n);\n\n\n    function [7:0] get_output(input [63:0] data_in, input [7:0] control_input);\n        case (control_input)\n            8'b11111111: begin\n                if (data_in == 64'h0707070707070707) get_output = 8'h1e;\n                else if (data_in == 64'hFEFEFEFEFEFEFEFE) get_output = 8'h1e;\n                else if (data_in == 64'h07070707070707FD) get_output = 8'h87;\n                else get_output = 8'b0;\n            end\n            8'b00011111: begin\n                if (data_in[39:0] == 40'hFB07070707) get_output = 8'h33;\n                else if (data_in[39:0] == 40'h9C07070707) get_output = 8'h2d;\n                else get_output = 8'b0;\n            end\n            8'b00000001: begin\n                if (data_in[7:0] == 8'hFB) get_output = 8'h78;\n                else get_output = 8'b0;\n            end\n            8'b11111110: begin\n                if (data_in[63:8] == 56'h070707070707FD) get_output = 8'h99;\n                else get_output = 8'b0;\n            end\n            8'b11111100: begin\n                if (data_in[63:16] == 48'h0707070707FD) get_output = 8'haa;\n                else get_output = 8'b0;\n            end\n            8'b11111000: begin\n                if (data_in[63:24] == 40'h07070707FD) get_output = 8'hb4;\n                else get_output = 8'b0;\n            end\n            8'b11110000: begin\n                if (data_in[63:32] == 32'h070707FD) get_output = 8'hcc;\n                else get_output = 8'b0;\n            end\n            8'b11100000: begin\n                if (data_in[63:40] == 24'h0707FD) get_output = 8'hd2;\n                else get_output = 8'b0;\n            end\n            8'b11000000: begin\n                if (data_in[63:48] == 16'h07FD) get_output = 8'he1;\n                else get_output = 8'b0;\n            end\n            8'b10000000: begin\n                if (data_in[63:56] == 8'hFD) get_output = 8'hff;\n                else get_output = 8'b0;\n            end\n            8'b11110001: begin\n                if ({data_in[63:32], data_in[7:0]} == 40'h070707079C) get_output = 8'h4b;\n                else get_output = 8'b0;\n            end\n            8'b00010001: begin\n                if ({data_in[39:32], data_in[7:0]} == 16'h9C9C) get_output = 8'h55;\n                else if ({data_in[39:32], data_in[7:0]} == 16'hFB9C) get_output = 8'h66;\n                else get_output = 8'b0;\n            end\n            default: get_output = 8'b0;\n        endcase\n    endfunction\n\n    logic [1:0] sync_ctrl_word;\n    logic [7:0] type_field;\n    logic [55:0] encoded_ctrl_words;\n\n    always @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_ctrl_words <= 56'b0;\n            sync_ctrl_word <= 2'b00;\n            type_field <= 8'b0;\n        end else begin\n            sync_ctrl_word <= 2'b10;\n            type_field <= get_output(encoder_data_in, encoder_control_in);\n\n            case (encoder_control_in)\n                8'b11111111: begin\n                    if (encoder_data_in == 64'h0707070707070707) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else if (encoder_data_in == 64'hFEFEFEFEFEFEFEFE) encoded_ctrl_words <= {7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E};\n                    else if (encoder_data_in == 64'h07070707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00011111: begin\n                    if (encoder_data_in[39:0] == 40'hFB07070707) encoded_ctrl_words <= {encoder_data_in[63:40], 4'h0, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else if (encoder_data_in[39:0] == 40'h9C07070707) encoded_ctrl_words <= {encoder_data_in[63:40], 4'hF, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00000001: begin\n                    if (encoder_data_in[7:0] == 8'hFB) encoded_ctrl_words <= {encoder_data_in[63:8]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111110: begin\n                    if (encoder_data_in[63:8] == 56'h070707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 6'b000000, encoder_data_in[7:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111100: begin\n                    if (encoder_data_in[63:16] == 48'h0707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 5'b00000, encoder_data_in[15:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111000: begin\n                    if (encoder_data_in[63:24] == 40'h07070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 4'b0000, encoder_data_in[23:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11110000: begin\n                    if (encoder_data_in[63:32] == 32'h070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 3'b000, encoder_data_in[31:0]};\n                    else encoded_ctrl_words <= 56'hFFFFFFF;\n                end\n                8'b11100000: begin\n                    if (encoder_data_in[63:40] == 24'h0707FD) encoded_ctrl_words <= {7'h00, 7'h00, 2'b00, encoder_data_in[39:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11000000: begin\n                    if (encoder_data_in[63:48] == 16'h07FD) encoded_ctrl_words <= {7'h00, 1'b0, encoder_data_in[47:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b10000000: begin\n                    if (encoder_data_in[63:56] == 8'hFD) encoded_ctrl_words <= encoder_data_in[55:0];\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11110001: begin\n                    if ({encoder_data_in[63:32], encoder_data_in[7:0]} == 40'h070707079C) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, encoder_data_in[31:8], 4'b1111};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00010001: begin\n                    if ({encoder_data_in[39:32], encoder_data_in[7:0]} == 16'h9C9C) encoded_ctrl_words <= {encoder_data_in[63:40], 8'hFF, encoder_data_in[31:8]};\n                    else if ({encoder_data_in[39:32], encoder_data_in[7:0]} == 16'hFB9C) encoded_ctrl_words <= {encoder_data_in[63:40], 8'h0F, encoder_data_in[31:8]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                default: encoded_ctrl_words <= 56'h0000000;\n            endcase\n        end\n    end\n\n    assign encoder_data_out = {sync_ctrl_word, type_field, encoded_ctrl_words};\n\nendmodule", "rtl/encoder_data_64b66b.sv": "module encoder_data_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic [63:0]  encoder_data_in,     // 64-bit data input\n    input  logic [7:0]   encoder_control_in,  // 8-bit control input\n    output logic [65:0]  encoder_data_out     // 66-bit encoded output\n);\n\n    logic [1:0] sync_word;     \n    logic [63:0] encoded_data; \n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_word <= 2'b00;            \n        end \n        else begin\n            if (encoder_control_in == 8'b00000000) begin\n                sync_word <= 2'b01;         \n            end \n            else begin\n                sync_word <= 2'b10;         \n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_data <= 64'b0;         \n        end \n        else begin\n            if (encoder_control_in == 8'b00000000) begin\n                encoded_data <= encoder_data_in; \n            end\n            else begin\n                encoded_data <= 64'b0; \n            end\n        end\n    end\n\n    assign encoder_data_out = {sync_word, encoded_data};\n\nendmodule"}, "patch": {"rtl/top_64b66b_codec.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v -s\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/top_64b66b_codec.sv /code/rtl/encoder_data_64b66b.sv /code/rtl/encoder_control_64b66b.sv /code/rtl/decoder_data_control_64b66b.sv\nTOPLEVEL        = top_64b66b_codec\nMODULE          = test_top_64b66b_codec\nPYTHONPATH      = /src\nHASH            = 5ae28b08977dcf54c572c129fd28f61a708ef1ff\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n# Runner to execute tests\ndef test_runner():\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\nif __name__ == \"__main__\":\n    test_runner()\n", "src/test_top_64b66b_codec.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n# Helper function to initialize DUT inputs\nasync def dut_initialization(dut):\n    \"\"\" Initialize all inputs for DUT \"\"\"\n    dut.rst_in.value = 1\n    dut.dec_data_valid_in.value = 0\n    dut.dec_data_in.value = 0\n    dut.enc_data_in.value = 0\n    dut.enc_control_in.value = 0\n    await RisingEdge(dut.clk_in)  # Wait for one clock cycle\n    await RisingEdge(dut.clk_in)  # Wait for one clock cycle\n    await RisingEdge(dut.clk_in)  # Wait for one clock cycle\n\n# Helper function to check the output with debug logging\nasync def check_output_encoder(dut, expected_sync, expected_data):\n    await RisingEdge(dut.clk_in)\n    actual_output = dut.enc_data_out.value.integer\n    expected_output = (expected_sync << 64) | expected_data\n\n    # Log the actual and expected outputs\n    dut._log.info(f\"Checking output:\\n\"\n                  f\"  Actual enc_data_out: {hex(actual_output)}\\n\"\n                  f\"  Expected enc_data_out: {hex(expected_output)}\\n\")\n\n    assert actual_output == expected_output, \\\n        f\"Test failed: enc_data_out={hex(actual_output)} (expected {hex(expected_output)})\"\n\n\n# Helper function to check the output with debug logging\nasync def check_output_decoder(dut, expected_data, expected_dec_sync_error, expected_control_out=0, expected_dec_error_out=0):\n    \"\"\"Check DUT output against expected values\"\"\"\n    await RisingEdge(dut.clk_in)  # Wait for the output latency of 1 cycle\n    actual_data_out = dut.dec_data_out.value.integer\n    actual_dec_sync_error = dut.dec_sync_error.value.integer\n    actual_control_out = dut.dec_control_out.value.integer\n    actual_dec_error_out = dut.dec_error_out.value.integer\n    dec_data_in = dut.dec_data_in.value.integer\n\n    # Log the actual and expected outputs\n    dut._log.info(f\"Checking output - Input: {hex(dec_data_in)},  Actual dec_data_out: {hex(actual_data_out)}, Expected dec_data_out: {hex(expected_data)}\\n\"\n                  f\"  Actual dec_sync_error: {actual_dec_sync_error}, Expected dec_sync_error: {expected_dec_sync_error}\\n\"\n                  f\"  Actual dec_control_out: {hex(actual_control_out)}, Expected dec_control_out: {hex(expected_control_out)}\\n\"\n                  f\"  Actual dec_error_out: {actual_dec_error_out}, Expected dec_error_out: {expected_dec_error_out}\\n\")\n\n    # Always check dec_sync_error and dec_error_out\n    assert actual_dec_sync_error == expected_dec_sync_error, \\\n        f\"Sync error mismatch: dec_sync_error={actual_dec_sync_error} (expected {expected_dec_sync_error})\"\n    assert actual_dec_error_out == expected_dec_error_out, \\\n        f\"Decoder error mismatch: dec_error_out={actual_dec_error_out} (expected {expected_dec_error_out})\"\n\n    # Check data and control output only if both dec_sync_error and dec_error_out are 0\n    if expected_dec_sync_error == 0 and expected_dec_error_out == 0:\n        assert actual_data_out == expected_data, \\\n            f\"Data mismatch: dec_data_out={hex(actual_data_out)} (expected {hex(expected_data)})\"\n        assert actual_control_out == expected_control_out, \\\n            f\"Control output mismatch: dec_control_out={hex(actual_control_out)} (expected {hex(expected_control_out)})\"\n\n@cocotb.test()\nasync def top_reset_test(dut):\n    \"\"\" Test the reset behavior of the decoder \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    \n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    # Log the output after reset\n    dut._log.info(f\"Reset Test:\\n  dec_data_out: {hex(dut.dec_data_out.value.integer)}\\n  Expected: 0\")\n\n    # Check that output is zero after reset\n    assert dut.dec_data_out.value == 0, \"Reset test failed: dec_data_out should be zero after reset\"\n    assert dut.dec_sync_error.value == 0, \"Reset test failed: dec_sync_error should be zero after reset\"\n     # Check that output is zero after reset\n    assert dut.enc_data_out.value.integer == 0, \"Reset test failed: enc_data_out should be zero after reset\"\n\n@cocotb.test()\nasync def encoder_fixed_pattern_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.enc_data_in.value = 0xA5A5A5A5A5A5A5A5\n    dut.enc_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  enc_data_in: {hex(dut.enc_data_in.value.integer)}\\n\"\n                  f\"  enc_control_in: {bin(dut.enc_control_in.value.integer)}\")\n\n    # Apply test and check output\n    await check_output_encoder(dut, expected_sync=0b01, expected_data=0xA5A5A5A5A5A5A5A5)\n\n@cocotb.test()\nasync def encoder_control_encoding_test(dut):\n    \"\"\" Test encoding when control characters are in the last four octets \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    \n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    # Set test inputs\n    dut.enc_data_in.value = 0xFFFFFFFFFFFFFFFF\n    dut.enc_control_in.value = 0x0F  # Control in last four octets\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for control encoding test\n    dut._log.info(f\"Control Encoding Test:\\n\"\n                  f\"  enc_data_in: {hex(dut.enc_data_in.value.integer)}\\n\"\n                  f\"  enc_control_in: {bin(dut.enc_control_in.value.integer)}\")\n\n    # Apply test and check output\n    await check_output_encoder(dut, expected_sync=0b10, expected_data=0x0000000000000000)  # Expected data output is zero\n\n@cocotb.test()\nasync def encoder_mixed_data_control_test(dut):\n    \"\"\" Test encoding when control characters are mixed in the data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Set test inputs\n    dut.enc_data_in.value = 0x123456789ABCDEF0\n    dut.enc_control_in.value = 0x81  # Control in first and last octets\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for mixed data and control test\n    dut._log.info(f\"Mixed Data and Control Test:\\n\"\n                  f\"  enc_data_in: {hex(dut.enc_data_in.value.integer)}\\n\"\n                  f\"  enc_control_in: {bin(dut.enc_control_in.value.integer)}\")\n\n    # Apply test and check output\n    await RisingEdge(dut.clk_in)\n    await check_output_encoder(dut, expected_sync=0b10, expected_data=0x0000000000000000)  # Expected data output is zero\n\n@cocotb.test()\nasync def encoder_all_control_symbols_test(dut):\n    \"\"\" Test encoding when all characters are control \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Set test inputs\n    dut.enc_data_in.value = 0xA5A5A5A5A5A5A5A5\n    dut.enc_control_in.value = 0xFF  # All control\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for all control symbols test\n    dut._log.info(f\"All Control Symbols Test:\\n\"\n                  f\"  enc_data_in: {hex(dut.enc_data_in.value.integer)}\\n\"\n                  f\"  enc_control_in: {bin(dut.enc_control_in.value.integer)}\")\n\n    # Apply test and check output\n    await check_output_encoder(dut, expected_sync=0b10, expected_data=0x0000000000000000)  # Expected data output is zero\n\n@cocotb.test()\nasync def encoder_random_data_control_test(dut):\n    \"\"\" Test encoding with random data and control inputs \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    \n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    for i in range(500):  # Run 5 random tests\n        # Generate random data and control inputs\n        random_data = random.getrandbits(64)\n        random_control = 0\n\n        dut.enc_data_in.value = random_data\n        dut.enc_control_in.value = random_control\n\n        # Determine expected sync word and data based on control input\n        expected_sync = 0b01 if random_control == 0 else 0b10\n        expected_data = random_data if random_control == 0 else 0x0000000000000000\n\n        await RisingEdge(dut.clk_in)\n        # Log inputs for each random test\n        dut._log.info(f\"Random Test {i+1}:\\n\"\n                      f\"  enc_data_in: {hex(dut.enc_data_in.value.integer)}\\n\"\n                      f\"  enc_control_in: {bin(dut.enc_control_in.value.integer)}\")\n\n        await check_output_encoder(dut, expected_sync=expected_sync, expected_data=expected_data)\n\n        await Timer(10, units=\"ns\")  # Wait for next random test\n\n    dut._log.info(\"Randomized tests completed successfully\")\n\n@cocotb.test()\nasync def encoder_random_data_only_test(dut):\n    \"\"\" Test encoding with random data and control inputs \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    \n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    dut.enc_control_in.value = 0  # All data\n    await RisingEdge(dut.clk_in)\n\n    for i in range(50):  # Run 5 random tests\n        # Generate random data\n        random_data = random.getrandbits(64)\n        dut.enc_data_in.value = random_data\n\n        # Determine expected sync word and data\n        expected_sync = 0b01\n        expected_data = random_data\n\n        await RisingEdge(dut.clk_in)\n        # Log inputs for each random test\n        dut._log.info(f\"Random Test {i+1}:\\n\"\n                      f\"  enc_data_in: {hex(dut.enc_data_in.value.integer)}\\n\"\n                      f\"  enc_control_in: {bin(dut.enc_control_in.value.integer)}\")\n\n        await check_output_encoder(dut, expected_sync=expected_sync, expected_data=expected_data)\n\n        await Timer(10, units=\"ns\")  # Wait for next random test\n\n    dut._log.info(\"Randomized tests completed successfully\")\n\n@cocotb.test()\nasync def encoder_test_all_control_combinations(dut):\n    \"\"\"Cocotb test for 64b/66b encoder with full test cases and expected outputs\"\"\"\n\n    # Start the clock\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Test cases with expected values\n    test_cases = [\n        (0x0707070707070707, 0b11111111, 0x21e00000000000000),\n        (0x070707070707FDAE, 0b11111110, 0x299000000000000ae),\n        (0x0707070707FDA5A5, 0b11111100, 0x2aa0000000000a5a5),\n        (0x07070707FDFEED55, 0b11111000, 0x2b400000000feed55),\n        (0x070707FD99887766, 0b11110000, 0x2cc00000099887766),\n        (0x0707FDAABBCCDDEE, 0b11100000, 0x2d20000aabbccddee),\n        (0x07FDAAAAAA555555, 0b11000000, 0x2e100aaaaaa555555),\n        (0xFD773388229911AA, 0b10000000, 0x2ff773388229911aa),\n        (0xDDCCBBFB07070707, 0b00011111, 0x233ddccbb00000000),\n        (0x0707079C0707079C, 0b00010001, 0x255070707ff070707),\n        (0x3456789ABCDEF0FB, 0b00000001, 0x2783456789abcdef0),\n        (0x777777FBDEEDDE9C, 0b00010001, 0x2667777770fdeedde),\n        (0x07070707ABCDEF9C, 0b11110001, 0x24b0000000abcdeff),\n        (0xAAAAAA9C07070707, 0b00011111, 0x22daaaaaaf0000000),\n        (0xFEFEFEFEFEFEFEFE, 0b11111111, 0x21e3c78f1e3c78f1e),\n        (0x07070707070707FD, 0b11111111, 0x28700000000000000),\n    ]\n\n    # Apply test cases and compare DUT output with expected values\n    for idx, (data_in, control_in, expected_output) in enumerate(test_cases):\n        # Apply inputs\n        await RisingEdge(dut.clk_in)\n        dut.enc_data_in.value = data_in\n        dut.enc_control_in.value = control_in\n\n        # Wait for a clock cycle\n        await RisingEdge(dut.clk_in)\n        await RisingEdge(dut.clk_in)\n\n        # Get DUT output\n        dut_output = int(dut.enc_data_out.value)\n\n        # Compare DUT output with expected output\n        assert dut_output == expected_output, (\n            f\"Test case {idx+1} failed: \"\n            f\"Data: {hex(data_in)}, Control: {bin(control_in)}, \"\n            f\"Expected: {hex(expected_output)}, Got: {hex(dut_output)}\"\n        )\n\n        dut._log.info(\n            f\"Test Case {idx + 1}:\\n\"\n            f\"  enc_data_in: {hex(data_in)}\\n\"\n            f\"  enc_control_in: {bin(control_in)}\\n\"\n            f\"  enc_data_out (DUT): {hex(dut_output)}\\n\"\n            f\"  Expected: {hex(expected_output)}\"\n        )\n\n@cocotb.test()\nasync def encoder_test_all_octets_control(dut):\n    \"\"\"Cocotb test for 64b/66b encoder with full test cases and expected outputs\"\"\"\n\n    # Start the clock\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Test cases with expected values\n    test_cases = [\n        (0x0707070707070707, 0b11111111, 0x21e00000000000000),\n        (0xFEFEFEFEFEFEFEFE, 0b11111111, 0x21e3c78f1e3c78f1e),\n        (0x07070707070707FD, 0b11111111, 0x28700000000000000),\n    ]\n\n    # Apply test cases and compare DUT output with expected values\n    for idx, (data_in, control_in, expected_output) in enumerate(test_cases):\n        # Apply inputs\n        await RisingEdge(dut.clk_in)\n        dut.enc_data_in.value = data_in\n        dut.enc_control_in.value = control_in\n\n        # Wait for a clock cycle\n        await RisingEdge(dut.clk_in)\n        await RisingEdge(dut.clk_in)\n\n        # Get DUT output\n        dut_output = int(dut.enc_data_out.value)\n\n        # Compare DUT output with expected output\n        assert dut_output == expected_output, (\n            f\"Test case {idx+1} failed: \"\n            f\"Data: {hex(data_in)}, Control: {bin(control_in)}, \"\n            f\"Expected: {hex(expected_output)}, Got: {hex(dut_output)}\"\n        )\n\n        dut._log.info(\n            f\"Test Case {idx + 1}:\\n\"\n            f\"  enc_data_in: {hex(data_in)}\\n\"\n            f\"  enc_control_in: {bin(control_in)}\\n\"\n            f\"  enc_data_out (DUT): {hex(dut_output)}\\n\"\n            f\"  Expected: {hex(expected_output)}\"\n        )\n\n@cocotb.test()\nasync def encoder_test_mixed_data_control_octets(dut):\n    \"\"\"Cocotb test for 64b/66b encoder with full test cases and expected outputs\"\"\"\n\n    # Start the clock\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Test cases with expected values\n    test_cases = [\n        (0x070707070707FDAE, 0b11111110, 0x299000000000000ae),\n        (0x0707070707FDA5A5, 0b11111100, 0x2aa0000000000a5a5),\n        (0x07070707FDFEED55, 0b11111000, 0x2b400000000feed55),\n        (0x070707FD99887766, 0b11110000, 0x2cc00000099887766),\n        (0x0707FDAABBCCDDEE, 0b11100000, 0x2d20000aabbccddee),\n        (0x07FDAAAAAA555555, 0b11000000, 0x2e100aaaaaa555555),\n        (0xFD773388229911AA, 0b10000000, 0x2ff773388229911aa),\n        (0xDDCCBBFB07070707, 0b00011111, 0x233ddccbb00000000),\n        (0x0707079C0707079C, 0b00010001, 0x255070707ff070707),\n        (0x3456789ABCDEF0FB, 0b00000001, 0x2783456789abcdef0),\n        (0x777777FBDEEDDE9C, 0b00010001, 0x2667777770fdeedde),\n        (0x07070707ABCDEF9C, 0b11110001, 0x24b0000000abcdeff),\n        (0xAAAAAA9C07070707, 0b00011111, 0x22daaaaaaf0000000),\n    ]\n\n\n    # Apply test cases and compare DUT output with expected values\n    for idx, (data_in, control_in, expected_output) in enumerate(test_cases):\n        # Apply inputs\n        await RisingEdge(dut.clk_in)\n        dut.enc_data_in.value = data_in\n        dut.enc_control_in.value = control_in\n\n        # Wait for a clock cycle\n        await RisingEdge(dut.clk_in)\n        await RisingEdge(dut.clk_in)\n\n        # Get DUT output\n        dut_output = int(dut.enc_data_out.value)\n\n        # Compare DUT output with expected output\n        assert dut_output == expected_output, (\n            f\"Test case {idx+1} failed: \"\n            f\"Data: {hex(data_in)}, Control: {bin(control_in)}, \"\n            f\"Expected: {hex(expected_output)}, Got: {hex(dut_output)}\"\n        )\n\n        dut._log.info(\n            f\"Test Case {idx + 1}:\\n\"\n            f\"  enc_data_in: {hex(data_in)}\\n\"\n            f\"  enc_control_in: {bin(control_in)}\\n\"\n            f\"  enc_data_out (DUT): {hex(dut_output)}\\n\"\n            f\"  Expected: {hex(expected_output)}\"\n        )\n    dut._log.info(\"All test cases passed!\")\n\n\n@cocotb.test()\nasync def decoder_random_any_sync_header_data_test(dut):\n    \"\"\" Test decoding with random sync headers and data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    await RisingEdge(dut.clk_in)\n\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    for i in range(5):  # Run 5 random tests\n        random_sync_header = random.choice([0b01, 0b00, 0b11])\n        random_data = random.getrandbits(64)\n\n        dut.dec_data_in.value = (random_sync_header << 64) | random_data\n        dut.dec_data_valid_in.value = 1\n\n        expected_data = random_data if random_sync_header == 0b01 else 0x0000000000000000\n        expected_dec_sync_error = 0 if random_sync_header == 0b01 else 1\n\n        # Apply test and check output\n        await Timer(5, units=\"ns\")  # Wait before next random test\n        await RisingEdge(dut.clk_in)\n        dut.dec_data_valid_in.value = 0\n        dut._log.info(f\"Random Test {i+1}:\\n\"\n                      f\"  dec_data_in: {hex(dut.dec_data_in.value.integer)}\")\n        await check_output_decoder(dut, expected_data=expected_data, expected_dec_sync_error=expected_dec_sync_error)\n\n@cocotb.test()\nasync def decoder_random_valid_data_test(dut):\n    \"\"\" Test decoding with random sync headers and data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    await RisingEdge(dut.clk_in)\n\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    for i in range(5):  # Run 5 random tests\n        random_sync_header = random.choice([0b01])\n        random_data = random.getrandbits(64)\n\n        dut.dec_data_in.value = (random_sync_header << 64) | random_data\n        dut.dec_data_valid_in.value = 1\n\n        expected_data = random_data if random_sync_header == 0b01 else 0x0000000000000000\n        expected_dec_sync_error = 0 if random_sync_header == 0b01 else 1\n\n        # Apply test and check output\n        await Timer(5, units=\"ns\")  # Wait before next random test\n        await RisingEdge(dut.clk_in)\n        dut.dec_data_valid_in.value = 0\n        dut._log.info(f\"Random Test {i+1}:\\n\"\n                      f\"  dec_data_in: {hex(dut.dec_data_in.value.integer)}\")\n        await check_output_decoder(dut, expected_data=expected_data, expected_dec_sync_error=expected_dec_sync_error)\n\n@cocotb.test()\nasync def decoder_control_only_test(dut):\n    \"\"\" Test decoding for control-only mode \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    await RisingEdge(dut.clk_in)\n\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Control-only mode test cases\n    test_cases = [\n        (0b10, 0x1E, 0x3C78F1E3C78F1E, 0xFEFEFEFEFEFEFEFE, 0, 0),  # All control characters\n        (0b10, 0x1E, 0x00000000000000, 0x0707070707070707, 0, 0),  # All control characters\n        (0b00, 0x1E, 0x00000000000000, 0x0707070707070707, 1, 0),  # All control characters\n        (0b10, 0x11, 0x3C78F1E3C78F1E, 0xFEFEFEFEFEFEFEFE, 0, 1),  # All control characters\n    ]\n\n    for sync_header, type_field, data_in, expected_data, expected_dec_sync_error, expected_dec_error_out in test_cases:\n        dut.dec_data_in.value = (sync_header << 64) | (type_field << 56) | data_in\n        dut.dec_data_valid_in.value = 1\n\n        await Timer(5, units=\"ns\")\n        await RisingEdge(dut.clk_in)\n        dut.dec_data_valid_in.value = 0\n        dut._log.info(f\"Control-Only Test:\\n\"\n                      f\"  dec_data_in: {hex(dut.dec_data_in.value.integer)}\")\n        await check_output_decoder(dut, expected_data=expected_data, expected_dec_sync_error=expected_dec_sync_error,\n                           expected_control_out=0xFF, expected_dec_error_out=expected_dec_error_out)\n\n@cocotb.test()\nasync def decoder_mixed_mode_test(dut):\n    \"\"\" Test decoding for mixed mode \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    await RisingEdge(dut.clk_in)\n\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Mixed mode test cases\n    test_cases = [\n        # Format: (sync_header, type_field, data_in, expected_data, expected_control_out, expected_dec_sync_error, expected_dec_error_out)\n        (0b10, 0x33, 0xDDCCBB00000000, 0xDDCCBBFB07070707, 0x1F, 0, 0),  # Mixed mode example\n        (0b10, 0x78, 0x3456789ABCDEF0, 0x3456789ABCDEF0FB, 0x01, 0, 0),  # Mixed mode example\n        (0b10, 0x87, 0x00000000000000, 0x07070707070707FD, 0xFE, 0, 0),  # Mixed mode example\n        (0b10, 0x99, 0x000000000000AE, 0x070707070707FDAE, 0xFE, 0, 0),  # Mixed mode example\n        (0b10, 0xAA, 0x0000000000A5A5, 0x0707070707FDA5A5, 0xFC, 0, 0),  # Mixed mode example\n        (0b10, 0xB4, 0x00000000FEED55, 0x07070707FDFEED55, 0xF8, 0, 0),  # Mixed mode example\n        (0b10, 0xCC, 0x00000099887766, 0x070707FD99887766, 0xF0, 0, 0),  # Mixed mode example\n        (0b10, 0xD2, 0x00001234567890, 0x0707FD1234567890, 0xE0, 0, 0),  # Mixed mode example\n        (0b10, 0xE1, 0x00FFEEDDCCBBAA, 0x07FDFFEEDDCCBBAA, 0xC0, 0, 0),  # Mixed mode example\n        (0b10, 0xFF, 0x773388229911AA, 0xFD773388229911AA, 0x80, 0, 0),  # Mixed mode example\n        (0b10, 0x55, 0x070707FF070707, 0x0707079C0707079C, 0x11, 0, 0),  # Mixed mode example\n        (0b10, 0x66, 0x7777770FDEEDDE, 0x777777FBDEEDDE9C, 0x11, 0, 0),  # Mixed mode example\n        (0b10, 0x4B, 0x0000000ABCDEFF, 0x0707070755E6F79C, 0xF1, 0, 0),  # Mixed mode example\n        (0b10, 0x2D, 0xAAAAAAF0000000, 0xAAAAAA9C07070707, 0x1F, 0, 0),  # Mixed mode example\n    ]\n\n    for sync_header, type_field, data_in, expected_data, expected_control_out, expected_dec_sync_error, expected_dec_error_out in test_cases:\n        # Set inputs\n        dut.dec_data_in.value = (sync_header << 64) | (type_field << 56) | data_in\n        dut.dec_data_valid_in.value = 1\n\n        # Wait for the output to stabilize\n        await Timer(5, units=\"ns\")\n        await RisingEdge(dut.clk_in)\n\n        # Check outputs\n        await check_output_decoder(dut, expected_data=expected_data, expected_dec_sync_error=expected_dec_sync_error,\n                           expected_control_out=expected_control_out, expected_dec_error_out=expected_dec_error_out)\n\n        # Deassert valid signal\n        dut.dec_data_valid_in.value = 0\n        await RisingEdge(dut.clk_in)\n\n\n@cocotb.test()\nasync def decoder_control_mixed_mode_dec_sync_error_test(dut):\n    \"\"\" Test decoding for mixed mode \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    await RisingEdge(dut.clk_in)\n\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Mixed mode test cases\n    test_cases = [\n        # Format: (sync_header, type_field, data_in, expected_data, expected_control_out, expected_dec_sync_error, expected_dec_error_out)\n        (0b11, 0x33, 0xDDCCBB00000000, 0x0000000000000000, 0x00, 1, 0),  # Mixed mode example\n        (0b00, 0x78, 0x3456789ABCDEF0, 0x0000000000000000, 0x00, 1, 0),  # Mixed mode example\n        (0b11, 0x87, 0x00000000000000, 0x0000000000000000, 0x00, 1, 0),  # Mixed mode example\n        (0b00, 0x99, 0x000000000000AE, 0x0000000000000000, 0x00, 1, 0),  # Mixed mode example\n    ]\n\n    for sync_header, type_field, data_in, expected_data, expected_control_out, expected_dec_sync_error, expected_dec_error_out in test_cases:\n        # Set inputs\n        dut.dec_data_in.value = (sync_header << 64) | (type_field << 56) | data_in\n        dut.dec_data_valid_in.value = 1\n\n        # Wait for the output to stabilize\n        await Timer(5, units=\"ns\")\n        await RisingEdge(dut.clk_in)\n\n\n        # Check outputs\n        await check_output_decoder(dut, expected_data=expected_data, expected_dec_sync_error=expected_dec_sync_error,\n                           expected_control_out=expected_control_out, expected_dec_error_out=expected_dec_error_out)\n\n        # Deassert valid signal\n        dut.dec_data_valid_in.value = 0\n        await RisingEdge(dut.clk_in)\n\n\n@cocotb.test()\nasync def decoder_control_mixed_mode_decoder_error_test(dut):\n    \"\"\" Test decoding for mixed mode \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    await RisingEdge(dut.clk_in)\n\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Mixed mode test cases\n    test_cases = [\n        # Format: (sync_header, type_field, data_in, expected_data, expected_control_out, expected_dec_sync_error, expected_dec_error_out)\n        (0b10, 0x13, 0xDDCCBB00000000, 0x0000000000000000, 0x00, 0, 1),  # Mixed mode example\n        (0b10, 0x18, 0x3456789ABCDEF0, 0x0000000000000000, 0x00, 0, 1),  # Mixed mode example\n        (0b10, 0x27, 0x00000000000000, 0x0000000000000000, 0x00, 0, 1),  # Mixed mode example\n        (0b10, 0x79, 0x000000000000AE, 0x0000000000000000, 0x00, 0, 1),  # Mixed mode example\n        (0b10, 0x0A, 0x0000000000A5A5, 0x0000000000000000, 0x00, 0, 1),  # Mixed mode example\n        (0b10, 0xD4, 0x00000000FEED55, 0x0000000000000000, 0x00, 0, 1),  # Mixed mode example\n        (0b10, 0x0C, 0x00000099887766, 0x0000000000000000, 0x00, 0, 1),  # Mixed mode example\n        (0b10, 0x22, 0x00001234567890, 0x0000000000000000, 0x00, 0, 1),  # Mixed mode example\n    ]\n\n    for sync_header, type_field, data_in, expected_data, expected_control_out, expected_dec_sync_error, expected_dec_error_out in test_cases:\n        # Set inputs\n        dut.dec_data_in.value = (sync_header << 64) | (type_field << 56) | data_in\n        dut.dec_data_valid_in.value = 1\n\n        # Wait for the output to stabilize\n        await Timer(5, units=\"ns\")\n        await RisingEdge(dut.clk_in)\n\n\n        # Check outputs\n        await check_output_decoder(dut, expected_data=expected_data, expected_dec_sync_error=expected_dec_sync_error,\n                           expected_control_out=expected_control_out, expected_dec_error_out=expected_dec_error_out)\n\n        # Deassert valid signal\n        dut.dec_data_valid_in.value = 0\n        await RisingEdge(dut.clk_in)\n\n\n", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v -s'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_AES_encryption_decryption_0018", "categories": ["cid005", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"line_number s/old_statement/new_statement/\" file.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "Update `aes_enc_top` and `aes_dec_top` RTLs so that the CTR block cipher mode changes how it concatenates the IV with the counter. The first 16 bits should be the 16 MSB of the counter, the next 96 should be the bits [111:16] from the IV and the next 16 bits should be the 16 LSB from the counter. As an example:\n\n- `IV = 128'h00112233445566778899aabbccddeeff` and `counter = 32'h55443322`, the combination of them (used in the input of the encryption module in both `aes_dec_top` and `aes_enc_top`) should be `enc_in = 128'h55442233445566778899aabbccdd3322`.\n\nAlso, create a new module that instantiates both `aes_enc_top` and `aes_dec_top` modules and uses them to perform encryption or decryption depending on the `i_encrypt` control signal. This module should add support for four different padding modes used in block ciphers. The testbench to validate this functionality is provided in the `verif` directory, and no other changes, besides those described above, are required in any other RTL. This new module is described below:\n\n### Specifications\n\n- **Module Name**: `padding_top` (defined in `rtl/padding_top.sv`)\n- **Parameters**:\n    - `NBW_KEY`: Bit width of the encryption/decryption key.\n        - Default: 256.\n        - Related interface signals: `i_key`.\n    - `NBW_DATA`: Bit width of the input and output data blocks.\n        - Default: 128.\n        - Related interface signals: `i_data`, `o_data`, `i_iv`.\n    - `NBW_MODE`: Bit width for cipher mode selection.\n        - Default: 3.\n        - Related interface signals: `i_mode`.\n    - `NBW_CNTR`: Bit width of the counter (used in CTR mode).\n        - Default: 32.\n    - `NBW_PADD`: Bit width to represent padding length.\n        - Default: 4.\n        - Related interface signals: `i_padding_bytes`.\n    - `NBW_PMOD`: Bit width to represent padding mode.\n        - Default: 2.\n        - Related interface signals: `i_padding_mode`.\n    - `W3C_BYTE`: Byte used for W3C padding.\n        - Default: 8'hAF.\n\n### Interface signals\n\n- **Clock** (`clk`): Synchronizes operation on the rising edge.\n- **Asynchronous Reset** (`rst_async_n`): Active low. Resets internal registers including the padding mode.\n- **Encryption Mode** (`i_encrypt`): When high, the encryption path is selected; otherwise, the decryption path is selected. It should remain at the desired value while configuring the IV, mode and resetting the counter, until the operation is done.\n- **Padding Mode Update** (`i_update_padding_mode`): When high, updates the internal padding mode register with `i_padding_mode`.\n- **Padding Mode Selection** (`[NBW_PMOD-1:0] i_padding_mode`): Selects the padding logic to apply.\n- **Padding Byte Count** (`[NBW_PADD-1:0] i_padding_bytes`): Indicates how many bytes of the input should be padded.\n- **Reset Counter** (`i_reset_counter`): Reset signal for CTR mode. It resets the internal counter.\n- **IV Update** (`i_update_iv`): When high, updates internal IV register with `i_iv`.\n- **IV Data** (`[NBW_DATA-1:0] i_iv`): Input initialization vector.\n- **Mode Update** (`i_update_mode`): When high, updates the internal cipher mode register with `i_mode`.\n- **Mode** (`[NBW_MODE-1:0] i_mode`): Indicates which cipher mode to use (e.g., ECB, CBC, etc.).\n- **Key Update** (`i_update_key`): When high and `i_start` is asserted, updates the key.\n- **Key** (`[NBW_KEY-1:0] i_key`): Encryption/decryption key.\n- **Start Operation** (`i_start`): Triggers encryption or decryption depending on `i_encrypt`.\n- **Input Data** (`[NBW_DATA-1:0] i_data`): The plaintext or ciphertext block to be processed.\n- **Done** (`o_done`): Indicates operation completion.\n- **Output Data** (`[NBW_DATA-1:0] o_data`): The processed (encrypted or decrypted) data block.\n\n### Internal Behavior\n\n- The internal padding mode register is updated sequentially when `i_update_padding_mode` is high. It is cleared asynchronously when `rst_async_n` is low.\n- The padding logic is combinational and modifies the least significant bytes of the input data block according to the selected padding mode.\n- No padding is done when `i_padding_bytes == 0`, regardless of the selected padding mode.\n- Given that the **Input Data** `i_data` is a fixed size (16 bytes), the padding is done by replacing the least significant bytes, instead of adding them (assuming that those bytes marked for padding are invalid in the input data).\n- Since the **Padding Byte Count** is at most 15, the 16th byte of the **Input Data** will never be padded. The **Padding Byte Count** is limited to 15 given that for the 16th byte to be padded, the padding byte count should be 16 (which, again, is not allowed), and no data would be encrypted/decrypted, only the padding.\n- The `aes_enc_top` used only when `i_encrypt == 1`.\n- The `aes_dec_top` used only when `i_encrypt == 0`.\n- Control signals like `i_update_iv`, `i_update_mode`, `i_update_key`, `i_reset_counter`, and `i_start` are gated so only the selected AES module receives them.\n\n### Supported Padding Modes\n\n- **PKCS#7** (`PKCS = 2'b00`):\n    - Each padding byte is filled with the number of padding bytes.\n    - Example: If 2 bytes are padded, both are `8'h02`.\n\n- **One-And-Zeroes** (`ONEANDZEROES = 2'b01`):\n    - First padding byte(most significant) is `8'h80`, remaining padded bytes are `8'h00`.\n\n- **ANSI X9.23** (`ANSIX923 = 2'b10`):\n    - All padding bytes are `8'h00`, except the last one(least significant), which contains the number of padded bytes.\n\n- **W3C** (`W3C = 2'b11`):\n    - All padding bytes are filled with the `W3C_BYTE` parameter (default is `8'hAF`), except the last one which contains the number of padded bytes.\n", "context": {"rtl/aes_dec_top.sv": "module aes_dec_top #(\n    parameter NBW_KEY  = 'd256,\n    parameter NBW_DATA = 'd128,\n    parameter NBW_MODE = 'd3,\n    parameter NBW_CNTR = 'd32\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_reset_counter,\n    input  logic                i_update_iv,\n    input  logic [NBW_DATA-1:0] i_iv,\n    input  logic                i_update_mode,\n    input  logic [NBW_MODE-1:0] i_mode,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    input  logic                i_start,\n    input  logic [NBW_DATA-1:0] i_ciphertext,\n    output logic                o_done,\n    output logic [NBW_DATA-1:0] o_plaintext\n);\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_MODE-1:0] mode_ff;\nlogic [NBW_DATA-1:0] ciphertext_ff;\nlogic [NBW_DATA-1:0] iv_ff;\nlogic [NBW_DATA-1:0] iv_nx;\nlogic [NBW_DATA-1:0] plaintext;\nlogic [NBW_DATA-1:0] dec_in;\nlogic [NBW_DATA-1:0] dec_out;\nlogic                update_key_ff;\nlogic                start_dec_ff;\nlogic                start_enc_ff;\nlogic                dec_done;\nlogic [NBW_KEY-1:0]  key_ff;\nlogic [NBW_CNTR-1:0] counter_ff;\nlogic                dec_sel;\nlogic [NBW_DATA-1:0] enc_out;\nlogic                enc_done;\n\n// Possible operation modes\nlocalparam ECB  = 3'd0;\nlocalparam CBC  = 3'd1;\nlocalparam PCBC = 3'd2;\nlocalparam CFB  = 3'd3;\nlocalparam OFB  = 3'd4;\nlocalparam CTR  = 3'd5;\n\n// Operation modes logic\nalways_comb begin\n    case(mode_ff)\n        ECB: begin\n            dec_in    = ciphertext_ff;\n            iv_nx     = iv_ff;\n            plaintext = dec_out;\n            dec_sel   = 1'b1;\n        end\n        CBC: begin\n            dec_in    = ciphertext_ff;\n            iv_nx     = ciphertext_ff;\n            plaintext = dec_out ^ iv_ff;\n            dec_sel   = 1'b1;\n        end\n        PCBC: begin\n            dec_in    = ciphertext_ff;\n            iv_nx     = ciphertext_ff ^ dec_out ^ iv_ff;\n            plaintext = dec_out ^ iv_ff;\n            dec_sel   = 1'b1;\n        end\n        CFB: begin\n            dec_in    = iv_ff;\n            iv_nx     = ciphertext_ff;\n            plaintext = ciphertext_ff ^ enc_out;\n            dec_sel   = 1'b0;\n        end\n        OFB: begin\n            dec_in    = iv_ff;\n            iv_nx     = enc_out;\n            plaintext = ciphertext_ff ^ enc_out;\n            dec_sel   = 1'b0;\n        end\n        CTR: begin\n            dec_in    = {iv_ff[NBW_DATA-1:NBW_CNTR], counter_ff};\n            iv_nx     = iv_ff;\n            plaintext = ciphertext_ff ^ enc_out;\n            dec_sel   = 1'b0;\n        end\n        default: begin\n            dec_in    = ciphertext_ff;\n            iv_nx     = iv_ff;\n            plaintext = dec_out;\n            dec_sel   = 1'b1;\n        end\n    endcase\nend\n\nalways_ff @ (posedge clk) begin : data_regs\n    if(i_start & o_done) begin\n        ciphertext_ff <= i_ciphertext;\n    end\nend\n\nalways_ff @ (posedge clk or negedge rst_async_n) begin : reset_regs\n    if(!rst_async_n) begin\n        iv_ff        <= 128'd0;\n        mode_ff      <= 3'd0;\n        o_done       <= 1'b1;\n        o_plaintext  <= 128'd0;\n        counter_ff   <= 0;\n        start_enc_ff <= 1'b0;\n        start_dec_ff <= 1'b0;\n    end else begin\n        if(i_update_iv) begin\n            iv_ff <= i_iv;\n        end else begin\n            if(dec_done | enc_done) begin\n                iv_ff <= iv_nx;\n            end\n        end\n\n        if(i_update_mode) begin\n            mode_ff <= i_mode;\n        end\n\n        if(dec_done | enc_done) begin\n            o_done <= 1'b1;\n        end else begin\n            if(i_start & o_done) begin\n                o_done <= 1'b0;\n            end\n        end\n\n        if(dec_done | enc_done) begin\n            o_plaintext <= plaintext;\n        end\n\n        if(i_reset_counter) begin\n            counter_ff <= 0;\n        end else if((dec_done | enc_done) & mode_ff == CTR) begin\n            counter_ff <= counter_ff + 1'b1;\n        end\n\n        start_enc_ff  <= (i_start & o_done & (~dec_sel));\n        start_dec_ff  <= (i_start & o_done & dec_sel);\n        update_key_ff <= (i_start & i_update_key & o_done);\n        if(i_start & i_update_key & o_done) begin\n            key_ff <= i_key;\n        end\n    end\nend\n\naes_decrypt #(\n    .NBW_KEY (NBW_KEY ),\n    .NBW_DATA(NBW_DATA)\n) uu_aes256_decrypt (\n    .clk         (clk          ),\n    .rst_async_n (rst_async_n  ),\n    .i_update_key(update_key_ff),\n    .i_key       (key_ff       ),\n    .i_start     (start_dec_ff ),\n    .i_data      (dec_in       ),\n    .o_done      (dec_done     ),\n    .o_data      (dec_out      )\n);\n\naes_encrypt #(\n    .NBW_KEY (NBW_KEY ),\n    .NBW_DATA(NBW_DATA)\n) uu_aes_encrypt (\n    .clk         (clk          ),\n    .rst_async_n (rst_async_n  ),\n    .i_update_key(update_key_ff),\n    .i_key       (key_ff       ),\n    .i_start     (start_enc_ff ),\n    .i_data      (dec_in       ),\n    .o_data      (enc_out      ),\n    .o_done      (enc_done     )\n);\n\nendmodule : aes_dec_top", "rtl/aes_decrypt.sv": "module aes_decrypt #(\n    parameter NBW_KEY  = 'd256,\n    parameter NBW_DATA = 'd128\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    input  logic                i_start,\n    input  logic [NBW_DATA-1:0] i_data,\n    output logic                o_done,\n    output logic [NBW_DATA-1:0] o_data\n);\n\n// ----------------------------------------\n// - Internal Parameters\n// ----------------------------------------\nlocalparam NBW_BYTE   = 'd8;\nlocalparam NBW_EX_KEY = 'd1920;\nlocalparam NBW_STEP   = NBW_KEY/2;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_BYTE-1:0]   current_data_nx[4][4];\nlogic [NBW_BYTE-1:0]   current_data_ff[4][4];\nlogic [NBW_BYTE-1:0]   AddRoundKey[4][4];\nlogic [NBW_BYTE-1:0]   SubBytes[4][4];\nlogic [NBW_BYTE-1:0]   ShiftRows[4][4];\nlogic [NBW_BYTE-1:0]   xtimes02[4][4];\nlogic [NBW_BYTE-1:0]   xtimes04[4][4];\nlogic [NBW_BYTE-1:0]   xtimes08[4][4];\nlogic [NBW_BYTE-1:0]   xtimes09[4][4];\nlogic [NBW_BYTE-1:0]   xtimes0b[4][4];\nlogic [NBW_BYTE-1:0]   xtimes0d[4][4];\nlogic [NBW_BYTE-1:0]   xtimes0e[4][4];\nlogic [NBW_BYTE-1:0]   MixColumns[4][4];\nlogic [3:0]            round_ff;\nlogic                  key_done;\nlogic                  key_idle;\nlogic [NBW_EX_KEY-1:0] expanded_key;\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nalways_ff @ (posedge clk or negedge rst_async_n) begin\n    if(!rst_async_n) begin\n        o_done <= 1'b0;\n    end else begin\n        o_done <= (round_ff == 4'd15);\n    end\nend\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : out_row\n        for(genvar j = 0; j < 4; j++) begin : out_col\n            assign o_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] = current_data_ff[i][j];\n        end\n    end\nendgenerate\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : inv_cypher_regs\n    if(!rst_async_n) begin\n        round_ff <= 4'd0;\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= 8'd0;\n            end\n        end\n    end else begin\n        if(i_start) begin\n            if(i_update_key) begin\n                round_ff <= 4'd0;\n            end else begin\n                round_ff <= 4'd1;\n            end\n        end else if((round_ff > 4'd0 && round_ff < 4'd15) || key_done) begin\n            round_ff <= round_ff + 1'b1;\n        end else begin\n            round_ff <= 4'd0;\n        end\n\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= current_data_nx[i][j];\n            end\n        end\n    end\nend\n\nalways_comb begin : next_data\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(i_start) begin\n                current_data_nx[i][j] = i_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n            end else begin\n                if(round_ff != 0) begin\n                    if(round_ff != 15) begin\n                        current_data_nx[i][j] = SubBytes[i][j];\n                    end else begin\n                        current_data_nx[i][j] = AddRoundKey[i][j];\n                    end\n                end else begin\n                    current_data_nx[i][j] = current_data_ff[i][j];\n                end\n            end\n        end\n    end\nend\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : row\n        for(genvar j = 0; j < 4; j++) begin : col\n            inv_sbox uu_inv_sbox0 (\n                .i_data(ShiftRows[i][j]),\n                .o_data(SubBytes[i][j])\n            );\n        end\n    end\nendgenerate\n\nalways_comb begin : decypher_logic\n    // Add Round Key logic\n    for(int i = 0; i < 4; i++) begin : row_key\n        for(int j = 0; j < 4; j++) begin : col_key\n            if(round_ff > 4'd0) begin\n                AddRoundKey[i][j] = current_data_ff[i][j] ^ expanded_key[NBW_EX_KEY-(15-round_ff)*NBW_STEP-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n            end else begin\n                AddRoundKey[i][j] = 0;\n            end\n        end\n    end\n\n    // Mix Columns logic\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(AddRoundKey[i][j][NBW_BYTE-1]) begin\n                xtimes02[i][j] = {AddRoundKey[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                if(AddRoundKey[i][j][NBW_BYTE-2]) begin\n                    xtimes04[i][j] = {xtimes02[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    if(AddRoundKey[i][j][NBW_BYTE-3]) begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    end else begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0};\n                    end\n                end else begin\n                    xtimes04[i][j] = {xtimes02[i][j][NBW_BYTE-2:0], 1'b0};\n                    if(AddRoundKey[i][j][NBW_BYTE-3]) begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    end else begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0};\n                    end\n                end\n            end else begin\n                xtimes02[i][j] = {AddRoundKey[i][j][NBW_BYTE-2:0], 1'b0};\n                if(AddRoundKey[i][j][NBW_BYTE-2]) begin\n                    xtimes04[i][j] = {xtimes02[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    if(AddRoundKey[i][j][NBW_BYTE-3]) begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    end else begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0};\n                    end\n                end else begin\n                    xtimes04[i][j] = {xtimes02[i][j][NBW_BYTE-2:0], 1'b0};\n                    if(AddRoundKey[i][j][NBW_BYTE-3]) begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                    end else begin\n                        xtimes08[i][j] = {xtimes04[i][j][NBW_BYTE-2:0], 1'b0};\n                    end\n                end\n            end\n\n            xtimes0e[i][j] = xtimes08[i][j] ^ xtimes04[i][j] ^ xtimes02[i][j];\n            xtimes0b[i][j] = xtimes08[i][j] ^ xtimes02[i][j] ^ AddRoundKey[i][j];\n            xtimes0d[i][j] = xtimes08[i][j] ^ xtimes04[i][j] ^ AddRoundKey[i][j];\n            xtimes09[i][j] = xtimes08[i][j] ^ AddRoundKey[i][j];\n        end\n    end\n\n    for(int i = 0; i < 4; i++) begin\n        MixColumns[0][i] = xtimes0e[0][i] ^ xtimes0b[1][i] ^ xtimes0d[2][i] ^ xtimes09[3][i];\n        MixColumns[1][i] = xtimes0e[1][i] ^ xtimes0b[2][i] ^ xtimes0d[3][i] ^ xtimes09[0][i];\n        MixColumns[2][i] = xtimes0e[2][i] ^ xtimes0b[3][i] ^ xtimes0d[0][i] ^ xtimes09[1][i];\n        MixColumns[3][i] = xtimes0e[3][i] ^ xtimes0b[0][i] ^ xtimes0d[1][i] ^ xtimes09[2][i];\n    end\n\n    // Shift Rows logic\n    if(round_ff == 4'd1) begin\n        // Line 0: No shift\n        ShiftRows[0][0] = AddRoundKey[0][0];\n        ShiftRows[0][1] = AddRoundKey[0][1];\n        ShiftRows[0][2] = AddRoundKey[0][2];\n        ShiftRows[0][3] = AddRoundKey[0][3];\n\n        // Line 1: Shift 1 right\n        ShiftRows[1][0] = AddRoundKey[1][3];\n        ShiftRows[1][1] = AddRoundKey[1][0];\n        ShiftRows[1][2] = AddRoundKey[1][1];\n        ShiftRows[1][3] = AddRoundKey[1][2];\n\n        // Line 2: Shift 2 right\n        ShiftRows[2][0] = AddRoundKey[2][2];\n        ShiftRows[2][1] = AddRoundKey[2][3];\n        ShiftRows[2][2] = AddRoundKey[2][0];\n        ShiftRows[2][3] = AddRoundKey[2][1];\n\n        // Line 3: Shift 3 right\n        ShiftRows[3][0] = AddRoundKey[3][1];\n        ShiftRows[3][1] = AddRoundKey[3][2];\n        ShiftRows[3][2] = AddRoundKey[3][3];\n        ShiftRows[3][3] = AddRoundKey[3][0];\n    end else begin\n        // Line 0: No shift\n        ShiftRows[0][0] = MixColumns[0][0];\n        ShiftRows[0][1] = MixColumns[0][1];\n        ShiftRows[0][2] = MixColumns[0][2];\n        ShiftRows[0][3] = MixColumns[0][3];\n\n        // Line 1: Shift 1 right\n        ShiftRows[1][0] = MixColumns[1][3];\n        ShiftRows[1][1] = MixColumns[1][0];\n        ShiftRows[1][2] = MixColumns[1][1];\n        ShiftRows[1][3] = MixColumns[1][2];\n\n        // Line 2: Shift 2 right\n        ShiftRows[2][0] = MixColumns[2][2];\n        ShiftRows[2][1] = MixColumns[2][3];\n        ShiftRows[2][2] = MixColumns[2][0];\n        ShiftRows[2][3] = MixColumns[2][1];\n\n        // Line 3: Shift 3 right\n        ShiftRows[3][0] = MixColumns[3][1];\n        ShiftRows[3][1] = MixColumns[3][2];\n        ShiftRows[3][2] = MixColumns[3][3];\n        ShiftRows[3][3] = MixColumns[3][0];\n    end\n\nend\n\naes_ke uu_aes_ke (\n    .clk           (clk                   ),\n    .rst_async_n   (rst_async_n           ),\n    .i_start       (i_start & i_update_key),\n    .i_key         (i_key                 ),\n    .o_idle        (key_idle              ),\n    .o_done        (key_done              ),\n    .o_expanded_key(expanded_key          )\n);\n\nendmodule : aes_decrypt", "rtl/aes_enc_top.sv": "module aes_enc_top #(\n    parameter NBW_KEY  = 'd256,\n    parameter NBW_DATA = 'd128,\n    parameter NBW_MODE = 'd3,\n    parameter NBW_CNTR = 'd32\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_reset_counter,\n    input  logic                i_update_iv,\n    input  logic [NBW_DATA-1:0] i_iv,\n    input  logic                i_update_mode,\n    input  logic [NBW_MODE-1:0] i_mode,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    input  logic                i_start,\n    input  logic [NBW_DATA-1:0] i_plaintext,\n    output logic                o_done,\n    output logic [NBW_DATA-1:0] o_ciphertext\n);\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_MODE-1:0] mode_ff;\nlogic [NBW_DATA-1:0] plaintext_ff;\nlogic [NBW_DATA-1:0] iv_ff;\nlogic [NBW_DATA-1:0] iv_nx;\nlogic [NBW_DATA-1:0] ciphertext;\nlogic [NBW_DATA-1:0] enc_in;\nlogic [NBW_DATA-1:0] enc_out;\nlogic                update_key_ff;\nlogic                start_ff;\nlogic                enc_done;\nlogic [NBW_KEY-1:0]  key_ff;\nlogic [NBW_CNTR-1:0] counter_ff;\n\n// Possible operation modes\nlocalparam ECB  = 3'd0;\nlocalparam CBC  = 3'd1;\nlocalparam PCBC = 3'd2;\nlocalparam CFB  = 3'd3;\nlocalparam OFB  = 3'd4;\nlocalparam CTR  = 3'd5;\n\n// Operation modes logic\nalways_comb begin\n    case(mode_ff)\n        ECB: begin\n            enc_in     = plaintext_ff;\n            iv_nx      = iv_ff;\n            ciphertext = enc_out;\n        end\n        CBC: begin\n            enc_in     = plaintext_ff ^ iv_ff;\n            iv_nx      = enc_out;\n            ciphertext = enc_out;\n        end\n        PCBC: begin\n            enc_in     = plaintext_ff ^ iv_ff;\n            iv_nx      = plaintext_ff ^ enc_out;\n            ciphertext = enc_out;\n        end\n        CFB: begin\n            enc_in     = iv_ff;\n            iv_nx      = plaintext_ff ^ enc_out;\n            ciphertext = plaintext_ff ^ enc_out;\n        end\n        OFB: begin\n            enc_in     = iv_ff;\n            iv_nx      = enc_out;\n            ciphertext = plaintext_ff ^ enc_out;\n        end\n        CTR: begin\n            enc_in     = {iv_ff[NBW_DATA-1:NBW_CNTR], counter_ff};\n            iv_nx      = iv_ff;\n            ciphertext = plaintext_ff ^ enc_out;\n        end\n        default: begin\n            enc_in     = plaintext_ff;\n            iv_nx      = iv_ff;\n            ciphertext = enc_out;\n        end\n    endcase\nend\n\n// Registers\nalways_ff @ (posedge clk) begin : data_regs\n    if(i_start & o_done) begin\n        plaintext_ff <= i_plaintext;\n    end\nend\n\nalways_ff @ (posedge clk or negedge rst_async_n) begin : reset_regs\n    if(!rst_async_n) begin\n        iv_ff        <= 128'd0;\n        mode_ff      <= 3'd0;\n        o_done       <= 1'b1;\n        o_ciphertext <= 128'd0;\n        counter_ff   <= 0;\n    end else begin\n        if(i_update_iv) begin\n            iv_ff <= i_iv;\n        end else begin\n            if(enc_done) begin\n                iv_ff <= iv_nx;\n            end\n        end\n\n        if(i_update_mode) begin\n            mode_ff <= i_mode;\n        end\n\n        if(enc_done) begin\n            o_done <= 1'b1;\n        end else begin\n            if(i_start & o_done) begin\n                o_done <= 1'b0;\n            end\n        end\n\n        if(enc_done) begin\n            o_ciphertext <= ciphertext;\n        end\n\n        if(i_reset_counter) begin\n            counter_ff <= 0;\n        end else if(enc_done & mode_ff == CTR) begin\n            counter_ff <= counter_ff + 1'b1;\n        end\n\n        start_ff <= (i_start & o_done);\n        update_key_ff <= (i_start & i_update_key & o_done);\n        if(i_start & i_update_key & o_done) begin\n            key_ff <= i_key;\n        end\n    end\nend\n\n// Encryption module instantiation\naes_encrypt #(\n    .NBW_KEY (NBW_KEY ),\n    .NBW_DATA(NBW_DATA)\n) uu_aes_encrypt (\n    .clk         (clk          ),\n    .rst_async_n (rst_async_n  ),\n    .i_update_key(update_key_ff),\n    .i_key       (key_ff       ),\n    .i_start     (start_ff     ),\n    .i_data      (enc_in       ),\n    .o_done      (enc_done     ),\n    .o_data      (enc_out      )\n);\n\nendmodule : aes_enc_top", "rtl/aes_encrypt.sv": "module aes_encrypt #(\n    parameter NBW_KEY  = 'd256,\n    parameter NBW_DATA = 'd128\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    input  logic                i_start,\n    input  logic [NBW_DATA-1:0] i_data,\n    output logic                o_done,\n    output logic [NBW_DATA-1:0] o_data\n);\n\n// ----------------------------------------\n// - Internal Parameters\n// ----------------------------------------\nlocalparam NBW_BYTE   = 'd8;\nlocalparam STEPS      = 'd14;\nlocalparam NBW_WORD   = 'd32;\nlocalparam NBW_EX_KEY = 'd1920;\nlocalparam NBW_STEP   = NBW_KEY/2;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_BYTE-1:0]   Rcon   [STEPS/2];\nlogic [NBW_KEY-1:0]    valid_key;\nlogic [NBW_STEP-1:0]   step_key[STEPS];\nlogic [NBW_EX_KEY-1:0] expanded_key_nx;\nlogic [NBW_EX_KEY-1:0] expanded_key_ff;\nlogic [NBW_BYTE-1:0]   current_data_nx[4][4];\nlogic [NBW_BYTE-1:0]   current_data_ff[4][4];\nlogic [NBW_BYTE-1:0]   SubBytes[4][4];\nlogic [NBW_BYTE-1:0]   ShiftRows[4][4];\nlogic [NBW_BYTE-1:0]   xtimes02[4][4];\nlogic [NBW_BYTE-1:0]   xtimes03[4][4];\nlogic [NBW_BYTE-1:0]   MixColumns[4][4];\nlogic [3:0] round_ff;\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nalways_ff @ (posedge clk or negedge rst_async_n) begin : done_assignment\n    if(!rst_async_n) begin\n        o_done <= 1'b0;\n    end else begin\n        o_done <= (round_ff == 4'd14);\n    end\nend\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : out_row\n        for(genvar j = 0; j < 4; j++) begin : out_col\n            assign o_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] = current_data_ff[i][j];\n        end\n    end\nendgenerate\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : cypher_regs\n    if(!rst_async_n) begin\n        round_ff <= 4'd0;\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= 8'd0;\n            end\n        end\n    end else begin\n        if(i_start || (round_ff > 4'd0 && round_ff < 4'd14)) begin\n            round_ff <= round_ff + 1'b1;\n        end else begin\n            round_ff <= 4'd0;\n        end\n\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= current_data_nx[i][j];\n            end\n        end\n    end\nend\n\nalways_comb begin : next_data\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(i_start) begin\n                if(i_update_key) begin\n                    current_data_nx[i][j] = i_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] ^ i_key[NBW_KEY-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                end else begin\n                    current_data_nx[i][j] = i_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] ^ expanded_key_ff[NBW_EX_KEY-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                end\n            end else begin\n                if(round_ff != 4'd0) begin\n                    if(round_ff != 4'd14) begin\n                        current_data_nx[i][j] = MixColumns[i][j] ^ expanded_key_ff[NBW_EX_KEY-round_ff*NBW_STEP-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                    end else begin\n                        current_data_nx[i][j] = ShiftRows[i][j] ^ expanded_key_ff[NBW_EX_KEY-round_ff*NBW_STEP-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                    end\n                end else begin\n                    current_data_nx[i][j] = current_data_ff[i][j];\n                end\n            end\n        end\n    end\nend\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : row\n        for(genvar j = 0; j < 4; j++) begin : col\n            sbox uu_sbox0 (\n                .i_data(current_data_ff[i][j]),\n                .o_data(SubBytes[i][j])\n            );\n        end\n    end\nendgenerate\n\nalways_comb begin : cypher_logic\n    // Shift Rows logic\n    // Line 0: No shift\n    ShiftRows[0][0] = SubBytes[0][0];\n    ShiftRows[0][1] = SubBytes[0][1];\n    ShiftRows[0][2] = SubBytes[0][2];\n    ShiftRows[0][3] = SubBytes[0][3];\n\n    // Line 1: Shift 1 left\n    ShiftRows[1][0] = SubBytes[1][1];\n    ShiftRows[1][1] = SubBytes[1][2];\n    ShiftRows[1][2] = SubBytes[1][3];\n    ShiftRows[1][3] = SubBytes[1][0];\n\n    // Line 2: Shift 2 left\n    ShiftRows[2][0] = SubBytes[2][2];\n    ShiftRows[2][1] = SubBytes[2][3];\n    ShiftRows[2][2] = SubBytes[2][0];\n    ShiftRows[2][3] = SubBytes[2][1];\n\n    // Line 3: Shift 3 left\n    ShiftRows[3][0] = SubBytes[3][3];\n    ShiftRows[3][1] = SubBytes[3][0];\n    ShiftRows[3][2] = SubBytes[3][1];\n    ShiftRows[3][3] = SubBytes[3][2];\n\n    // Mix Columns logic\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(ShiftRows[i][j][NBW_BYTE-1]) begin\n                xtimes02[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                xtimes03[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B ^ ShiftRows[i][j];\n            end else begin\n                xtimes02[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0};\n                xtimes03[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0} ^ ShiftRows[i][j];\n            end\n        end\n    end\n\n    for(int i = 0; i < 4; i++) begin\n        MixColumns[0][i] = xtimes02[0][i] ^ xtimes03[1][i] ^ ShiftRows[2][i] ^ ShiftRows[3][i];\n        MixColumns[1][i] = xtimes02[1][i] ^ xtimes03[2][i] ^ ShiftRows[3][i] ^ ShiftRows[0][i];\n        MixColumns[2][i] = xtimes02[2][i] ^ xtimes03[3][i] ^ ShiftRows[0][i] ^ ShiftRows[1][i];\n        MixColumns[3][i] = xtimes02[3][i] ^ xtimes03[0][i] ^ ShiftRows[1][i] ^ ShiftRows[2][i];\n    end\nend\n\n// ****************************************\n// - Key Expansion logic\n// ****************************************\n\n// ----------------------------------------\n// - Registers\n// ----------------------------------------\nalways_ff @(posedge clk or negedge rst_async_n) begin : reset_regs\n    if(~rst_async_n) begin\n        expanded_key_ff <= {NBW_EX_KEY{1'b0}};\n    end else begin\n        expanded_key_ff <= expanded_key_nx;\n    end\nend\n\n\n// ----------------------------------------\n// - Operation logic\n// ----------------------------------------\nassign Rcon[0] = 8'h01;\nassign Rcon[1] = 8'h02;\nassign Rcon[2] = 8'h04;\nassign Rcon[3] = 8'h08;\nassign Rcon[4] = 8'h10;\nassign Rcon[5] = 8'h20;\nassign Rcon[6] = 8'h40;\n\ngenerate\n    for(genvar i = 0; i < STEPS; i++) begin : steps\n        if(i%2 == 0) begin\n            logic [NBW_WORD-1:0] RotWord;\n            logic [NBW_WORD-1:0] SubWord;\n            logic [NBW_WORD-1:0] RconXor;\n\n            sbox uu_sbox0 (\n                .i_data(RotWord[NBW_WORD-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox1 (\n                .i_data(RotWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox2 (\n                .i_data(RotWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox3 (\n                .i_data(RotWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            always_comb begin : main_operation\n                RotWord = {expanded_key_ff[NBW_EX_KEY-NBW_KEY-i*NBW_STEP+NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)], expanded_key_ff[NBW_EX_KEY-NBW_KEY-i*NBW_STEP+NBW_WORD-1-:NBW_BYTE]};\n                RconXor = {SubWord[NBW_WORD-1-:NBW_BYTE]^Rcon[i/2], SubWord[NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)]};\n\n                step_key[i][NBW_STEP-1-:NBW_WORD]            = expanded_key_ff[NBW_EX_KEY-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ RconXor;\n                step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD]   = expanded_key_ff[NBW_EX_KEY-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-1-:NBW_WORD];\n                step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD];\n                step_key[i][NBW_STEP-3*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD];\n            end\n        end else begin\n            logic [NBW_WORD-1:0] SubWord;\n\n            sbox uu_sbox0 (\n                .i_data(expanded_key_ff[NBW_EX_KEY-NBW_KEY+NBW_WORD-i*NBW_STEP-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox1 (\n                .i_data(expanded_key_ff[NBW_EX_KEY-NBW_KEY+NBW_WORD-i*NBW_STEP-NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox2 (\n                .i_data(expanded_key_ff[NBW_EX_KEY-NBW_KEY+NBW_WORD-i*NBW_STEP-2*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox3 (\n                .i_data(expanded_key_ff[NBW_EX_KEY-NBW_KEY+NBW_WORD-i*NBW_STEP-3*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            always_comb begin : main_operation\n                step_key[i][NBW_STEP-1-:NBW_WORD]            = expanded_key_ff[NBW_EX_KEY-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ SubWord;\n                step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD]   = expanded_key_ff[NBW_EX_KEY-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-1-:NBW_WORD];\n                step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD];\n                step_key[i][NBW_STEP-3*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD];\n            end\n        end\n    end\nendgenerate\n\nassign expanded_key_nx = {valid_key   , step_key[0 ], step_key[1 ], step_key[2 ],\n                          step_key[3 ], step_key[4 ], step_key[5 ], step_key[6 ],\n                          step_key[7 ], step_key[8 ], step_key[9 ], step_key[10],\n                          step_key[11], step_key[12]};\n\nalways_comb begin : input_data\n    if (i_update_key) begin\n        valid_key = i_key;\n    end else begin\n        valid_key = expanded_key_ff[NBW_EX_KEY-1-:NBW_KEY];\n    end\nend\n\nendmodule : aes_encrypt", "rtl/aes_ke.sv": "module aes_ke #(\n    parameter NBW_KEY = 'd256,\n    parameter NBW_OUT = 'd1920\n) (\n    input  logic               clk,\n    input  logic               rst_async_n,\n    input  logic               i_start,\n    input  logic [NBW_KEY-1:0] i_key,\n    output logic               o_idle,\n    output logic               o_done,\n    output logic [NBW_OUT-1:0] o_expanded_key\n);\n\n// ----------------------------------------\n// - Internal Parameters\n// ----------------------------------------\nlocalparam NBW_BYTE = 'd8;\nlocalparam STEPS    = 'd14;\nlocalparam NBW_WORD = 'd32;\nlocalparam NBW_STEP = NBW_KEY/2;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_BYTE-1:0]   Rcon   [STEPS/2];\nlogic [NBW_KEY-1:0]    valid_key;\nlogic [NBW_STEP-1:0] step_key[STEPS];\nlogic [NBW_OUT-1:0] expanded_key_nx;\nlogic [NBW_OUT-1:0] expanded_key_ff;\nlogic [STEPS:0] key_exp_steps_ff;\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nassign o_done = key_exp_steps_ff[STEPS];\nassign o_idle = ~(|key_exp_steps_ff);\nassign o_expanded_key = expanded_key_ff;\n\n// ----------------------------------------\n// - Registers\n// ----------------------------------------\nalways_ff @(posedge clk or negedge rst_async_n) begin : done_regs\n    if(!rst_async_n) begin\n        key_exp_steps_ff <= 0;\n    end else begin\n        key_exp_steps_ff <= {key_exp_steps_ff[STEPS-1:0], i_start};\n    end\nend\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : key_regs\n    if(~rst_async_n) begin\n        expanded_key_ff <= {NBW_OUT{1'b0}};\n    end else begin\n        expanded_key_ff <= expanded_key_nx;\n    end\nend\n\n\n// ----------------------------------------\n// - Operation logic\n// ----------------------------------------\nassign Rcon[0] = 8'h01;\nassign Rcon[1] = 8'h02;\nassign Rcon[2] = 8'h04;\nassign Rcon[3] = 8'h08;\nassign Rcon[4] = 8'h10;\nassign Rcon[5] = 8'h20;\nassign Rcon[6] = 8'h40;\n\ngenerate\n    for(genvar i = 0; i < STEPS; i++) begin : steps\n        if(i%2 == 0) begin\n            logic [NBW_WORD-1:0] RotWord;\n            logic [NBW_WORD-1:0] SubWord;\n            logic [NBW_WORD-1:0] RconXor;\n\n            sbox uu_sbox0 (\n                .i_data(RotWord[NBW_WORD-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox1 (\n                .i_data(RotWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox2 (\n                .i_data(RotWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox3 (\n                .i_data(RotWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            always_comb begin : main_operation\n                RotWord = {expanded_key_ff[NBW_OUT-NBW_KEY-i*NBW_STEP+NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)], expanded_key_ff[NBW_OUT-NBW_KEY-i*NBW_STEP+NBW_WORD-1-:NBW_BYTE]};\n                RconXor = {SubWord[NBW_WORD-1-:NBW_BYTE]^Rcon[i/2], SubWord[NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)]};\n\n                step_key[i][NBW_STEP-1-:NBW_WORD]            = expanded_key_ff[NBW_OUT-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ RconXor;\n                step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD]   = expanded_key_ff[NBW_OUT-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-1-:NBW_WORD];\n                step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_OUT-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD];\n                step_key[i][NBW_STEP-3*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_OUT-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD];\n            end\n        end else begin\n            logic [NBW_WORD-1:0] SubWord;\n\n            sbox uu_sbox0 (\n                .i_data(expanded_key_ff[NBW_OUT-NBW_KEY+NBW_WORD-i*NBW_STEP-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox1 (\n                .i_data(expanded_key_ff[NBW_OUT-NBW_KEY+NBW_WORD-i*NBW_STEP-NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox2 (\n                .i_data(expanded_key_ff[NBW_OUT-NBW_KEY+NBW_WORD-i*NBW_STEP-2*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox3 (\n                .i_data(expanded_key_ff[NBW_OUT-NBW_KEY+NBW_WORD-i*NBW_STEP-3*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            always_comb begin : main_operation\n                step_key[i][NBW_STEP-1-:NBW_WORD]            = expanded_key_ff[NBW_OUT-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ SubWord;\n                step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD]   = expanded_key_ff[NBW_OUT-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-1-:NBW_WORD];\n                step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_OUT-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD];\n                step_key[i][NBW_STEP-3*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_OUT-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD];\n            end\n        end\n    end\nendgenerate\n\nassign expanded_key_nx = {valid_key   , step_key[0 ], step_key[1 ], step_key[2 ],\n                          step_key[3 ], step_key[4 ], step_key[5 ], step_key[6 ],\n                          step_key[7 ], step_key[8 ], step_key[9 ], step_key[10],\n                          step_key[11], step_key[12]};\n\nalways_comb begin : input_data\n    if (i_start) begin\n        valid_key = i_key;\n    end else begin\n        valid_key = expanded_key_ff[NBW_OUT-1-:NBW_KEY];\n    end\nend\n\nendmodule : aes_ke", "rtl/inv_sbox.sv": "module inv_sbox (\n    input  logic [7:0] i_data,\n    output logic [7:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        8'h00: o_data = 8'h52;\n        8'h01: o_data = 8'h09;\n        8'h02: o_data = 8'h6a;\n        8'h03: o_data = 8'hd5;\n        8'h04: o_data = 8'h30;\n        8'h05: o_data = 8'h36;\n        8'h06: o_data = 8'ha5;\n        8'h07: o_data = 8'h38;\n        8'h08: o_data = 8'hbf;\n        8'h09: o_data = 8'h40;\n        8'h0a: o_data = 8'ha3;\n        8'h0b: o_data = 8'h9e;\n        8'h0c: o_data = 8'h81;\n        8'h0d: o_data = 8'hf3;\n        8'h0e: o_data = 8'hd7;\n        8'h0f: o_data = 8'hfb;\n        8'h10: o_data = 8'h7c;\n        8'h11: o_data = 8'he3;\n        8'h12: o_data = 8'h39;\n        8'h13: o_data = 8'h82;\n        8'h14: o_data = 8'h9b;\n        8'h15: o_data = 8'h2f;\n        8'h16: o_data = 8'hff;\n        8'h17: o_data = 8'h87;\n        8'h18: o_data = 8'h34;\n        8'h19: o_data = 8'h8e;\n        8'h1a: o_data = 8'h43;\n        8'h1b: o_data = 8'h44;\n        8'h1c: o_data = 8'hc4;\n        8'h1d: o_data = 8'hde;\n        8'h1e: o_data = 8'he9;\n        8'h1f: o_data = 8'hcb;\n        8'h20: o_data = 8'h54;\n        8'h21: o_data = 8'h7b;\n        8'h22: o_data = 8'h94;\n        8'h23: o_data = 8'h32;\n        8'h24: o_data = 8'ha6;\n        8'h25: o_data = 8'hc2;\n        8'h26: o_data = 8'h23;\n        8'h27: o_data = 8'h3d;\n        8'h28: o_data = 8'hee;\n        8'h29: o_data = 8'h4c;\n        8'h2a: o_data = 8'h95;\n        8'h2b: o_data = 8'h0b;\n        8'h2c: o_data = 8'h42;\n        8'h2d: o_data = 8'hfa;\n        8'h2e: o_data = 8'hc3;\n        8'h2f: o_data = 8'h4e;\n        8'h30: o_data = 8'h08;\n        8'h31: o_data = 8'h2e;\n        8'h32: o_data = 8'ha1;\n        8'h33: o_data = 8'h66;\n        8'h34: o_data = 8'h28;\n        8'h35: o_data = 8'hd9;\n        8'h36: o_data = 8'h24;\n        8'h37: o_data = 8'hb2;\n        8'h38: o_data = 8'h76;\n        8'h39: o_data = 8'h5b;\n        8'h3a: o_data = 8'ha2;\n        8'h3b: o_data = 8'h49;\n        8'h3c: o_data = 8'h6d;\n        8'h3d: o_data = 8'h8b;\n        8'h3e: o_data = 8'hd1;\n        8'h3f: o_data = 8'h25;\n        8'h40: o_data = 8'h72;\n        8'h41: o_data = 8'hf8;\n        8'h42: o_data = 8'hf6;\n        8'h43: o_data = 8'h64;\n        8'h44: o_data = 8'h86;\n        8'h45: o_data = 8'h68;\n        8'h46: o_data = 8'h98;\n        8'h47: o_data = 8'h16;\n        8'h48: o_data = 8'hd4;\n        8'h49: o_data = 8'ha4;\n        8'h4a: o_data = 8'h5c;\n        8'h4b: o_data = 8'hcc;\n        8'h4c: o_data = 8'h5d;\n        8'h4d: o_data = 8'h65;\n        8'h4e: o_data = 8'hb6;\n        8'h4f: o_data = 8'h92;\n        8'h50: o_data = 8'h6c;\n        8'h51: o_data = 8'h70;\n        8'h52: o_data = 8'h48;\n        8'h53: o_data = 8'h50;\n        8'h54: o_data = 8'hfd;\n        8'h55: o_data = 8'hed;\n        8'h56: o_data = 8'hb9;\n        8'h57: o_data = 8'hda;\n        8'h58: o_data = 8'h5e;\n        8'h59: o_data = 8'h15;\n        8'h5a: o_data = 8'h46;\n        8'h5b: o_data = 8'h57;\n        8'h5c: o_data = 8'ha7;\n        8'h5d: o_data = 8'h8d;\n        8'h5e: o_data = 8'h9d;\n        8'h5f: o_data = 8'h84;\n        8'h60: o_data = 8'h90;\n        8'h61: o_data = 8'hd8;\n        8'h62: o_data = 8'hab;\n        8'h63: o_data = 8'h00;\n        8'h64: o_data = 8'h8c;\n        8'h65: o_data = 8'hbc;\n        8'h66: o_data = 8'hd3;\n        8'h67: o_data = 8'h0a;\n        8'h68: o_data = 8'hf7;\n        8'h69: o_data = 8'he4;\n        8'h6a: o_data = 8'h58;\n        8'h6b: o_data = 8'h05;\n        8'h6c: o_data = 8'hb8;\n        8'h6d: o_data = 8'hb3;\n        8'h6e: o_data = 8'h45;\n        8'h6f: o_data = 8'h06;\n        8'h70: o_data = 8'hd0;\n        8'h71: o_data = 8'h2c;\n        8'h72: o_data = 8'h1e;\n        8'h73: o_data = 8'h8f;\n        8'h74: o_data = 8'hca;\n        8'h75: o_data = 8'h3f;\n        8'h76: o_data = 8'h0f;\n        8'h77: o_data = 8'h02;\n        8'h78: o_data = 8'hc1;\n        8'h79: o_data = 8'haf;\n        8'h7a: o_data = 8'hbd;\n        8'h7b: o_data = 8'h03;\n        8'h7c: o_data = 8'h01;\n        8'h7d: o_data = 8'h13;\n        8'h7e: o_data = 8'h8a;\n        8'h7f: o_data = 8'h6b;\n        8'h80: o_data = 8'h3a;\n        8'h81: o_data = 8'h91;\n        8'h82: o_data = 8'h11;\n        8'h83: o_data = 8'h41;\n        8'h84: o_data = 8'h4f;\n        8'h85: o_data = 8'h67;\n        8'h86: o_data = 8'hdc;\n        8'h87: o_data = 8'hea;\n        8'h88: o_data = 8'h97;\n        8'h89: o_data = 8'hf2;\n        8'h8a: o_data = 8'hcf;\n        8'h8b: o_data = 8'hce;\n        8'h8c: o_data = 8'hf0;\n        8'h8d: o_data = 8'hb4;\n        8'h8e: o_data = 8'he6;\n        8'h8f: o_data = 8'h73;\n        8'h90: o_data = 8'h96;\n        8'h91: o_data = 8'hac;\n        8'h92: o_data = 8'h74;\n        8'h93: o_data = 8'h22;\n        8'h94: o_data = 8'he7;\n        8'h95: o_data = 8'had;\n        8'h96: o_data = 8'h35;\n        8'h97: o_data = 8'h85;\n        8'h98: o_data = 8'he2;\n        8'h99: o_data = 8'hf9;\n        8'h9a: o_data = 8'h37;\n        8'h9b: o_data = 8'he8;\n        8'h9c: o_data = 8'h1c;\n        8'h9d: o_data = 8'h75;\n        8'h9e: o_data = 8'hdf;\n        8'h9f: o_data = 8'h6e;\n        8'ha0: o_data = 8'h47;\n        8'ha1: o_data = 8'hf1;\n        8'ha2: o_data = 8'h1a;\n        8'ha3: o_data = 8'h71;\n        8'ha4: o_data = 8'h1d;\n        8'ha5: o_data = 8'h29;\n        8'ha6: o_data = 8'hc5;\n        8'ha7: o_data = 8'h89;\n        8'ha8: o_data = 8'h6f;\n        8'ha9: o_data = 8'hb7;\n        8'haa: o_data = 8'h62;\n        8'hab: o_data = 8'h0e;\n        8'hac: o_data = 8'haa;\n        8'had: o_data = 8'h18;\n        8'hae: o_data = 8'hbe;\n        8'haf: o_data = 8'h1b;\n        8'hb0: o_data = 8'hfc;\n        8'hb1: o_data = 8'h56;\n        8'hb2: o_data = 8'h3e;\n        8'hb3: o_data = 8'h4b;\n        8'hb4: o_data = 8'hc6;\n        8'hb5: o_data = 8'hd2;\n        8'hb6: o_data = 8'h79;\n        8'hb7: o_data = 8'h20;\n        8'hb8: o_data = 8'h9a;\n        8'hb9: o_data = 8'hdb;\n        8'hba: o_data = 8'hc0;\n        8'hbb: o_data = 8'hfe;\n        8'hbc: o_data = 8'h78;\n        8'hbd: o_data = 8'hcd;\n        8'hbe: o_data = 8'h5a;\n        8'hbf: o_data = 8'hf4;\n        8'hc0: o_data = 8'h1f;\n        8'hc1: o_data = 8'hdd;\n        8'hc2: o_data = 8'ha8;\n        8'hc3: o_data = 8'h33;\n        8'hc4: o_data = 8'h88;\n        8'hc5: o_data = 8'h07;\n        8'hc6: o_data = 8'hc7;\n        8'hc7: o_data = 8'h31;\n        8'hc8: o_data = 8'hb1;\n        8'hc9: o_data = 8'h12;\n        8'hca: o_data = 8'h10;\n        8'hcb: o_data = 8'h59;\n        8'hcc: o_data = 8'h27;\n        8'hcd: o_data = 8'h80;\n        8'hce: o_data = 8'hec;\n        8'hcf: o_data = 8'h5f;\n        8'hd0: o_data = 8'h60;\n        8'hd1: o_data = 8'h51;\n        8'hd2: o_data = 8'h7f;\n        8'hd3: o_data = 8'ha9;\n        8'hd4: o_data = 8'h19;\n        8'hd5: o_data = 8'hb5;\n        8'hd6: o_data = 8'h4a;\n        8'hd7: o_data = 8'h0d;\n        8'hd8: o_data = 8'h2d;\n        8'hd9: o_data = 8'he5;\n        8'hda: o_data = 8'h7a;\n        8'hdb: o_data = 8'h9f;\n        8'hdc: o_data = 8'h93;\n        8'hdd: o_data = 8'hc9;\n        8'hde: o_data = 8'h9c;\n        8'hdf: o_data = 8'hef;\n        8'he0: o_data = 8'ha0;\n        8'he1: o_data = 8'he0;\n        8'he2: o_data = 8'h3b;\n        8'he3: o_data = 8'h4d;\n        8'he4: o_data = 8'hae;\n        8'he5: o_data = 8'h2a;\n        8'he6: o_data = 8'hf5;\n        8'he7: o_data = 8'hb0;\n        8'he8: o_data = 8'hc8;\n        8'he9: o_data = 8'heb;\n        8'hea: o_data = 8'hbb;\n        8'heb: o_data = 8'h3c;\n        8'hec: o_data = 8'h83;\n        8'hed: o_data = 8'h53;\n        8'hee: o_data = 8'h99;\n        8'hef: o_data = 8'h61;\n        8'hf0: o_data = 8'h17;\n        8'hf1: o_data = 8'h2b;\n        8'hf2: o_data = 8'h04;\n        8'hf3: o_data = 8'h7e;\n        8'hf4: o_data = 8'hba;\n        8'hf5: o_data = 8'h77;\n        8'hf6: o_data = 8'hd6;\n        8'hf7: o_data = 8'h26;\n        8'hf8: o_data = 8'he1;\n        8'hf9: o_data = 8'h69;\n        8'hfa: o_data = 8'h14;\n        8'hfb: o_data = 8'h63;\n        8'hfc: o_data = 8'h55;\n        8'hfd: o_data = 8'h21;\n        8'hfe: o_data = 8'h0c;\n        8'hff: o_data = 8'h7d;\n        default: o_data = 8'h00;\n    endcase\nend\n\nendmodule : inv_sbox", "rtl/sbox.sv": "module sbox (\n    input  logic [7:0] i_data,\n    output logic [7:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        8'h00: o_data = 8'h63;\n        8'h01: o_data = 8'h7C;\n        8'h02: o_data = 8'h77;\n        8'h03: o_data = 8'h7B;\n        8'h04: o_data = 8'hF2;\n        8'h05: o_data = 8'h6B;\n        8'h06: o_data = 8'h6F;\n        8'h07: o_data = 8'hC5;\n        8'h08: o_data = 8'h30;\n        8'h09: o_data = 8'h01;\n        8'h0A: o_data = 8'h67;\n        8'h0B: o_data = 8'h2B;\n        8'h0C: o_data = 8'hFE;\n        8'h0D: o_data = 8'hD7;\n        8'h0E: o_data = 8'hAB;\n        8'h0F: o_data = 8'h76;\n        8'h10: o_data = 8'hCA;\n        8'h11: o_data = 8'h82;\n        8'h12: o_data = 8'hC9;\n        8'h13: o_data = 8'h7D;\n        8'h14: o_data = 8'hFA;\n        8'h15: o_data = 8'h59;\n        8'h16: o_data = 8'h47;\n        8'h17: o_data = 8'hF0;\n        8'h18: o_data = 8'hAD;\n        8'h19: o_data = 8'hD4;\n        8'h1A: o_data = 8'hA2;\n        8'h1B: o_data = 8'hAF;\n        8'h1C: o_data = 8'h9C;\n        8'h1D: o_data = 8'hA4;\n        8'h1E: o_data = 8'h72;\n        8'h1F: o_data = 8'hC0;\n        8'h20: o_data = 8'hB7;\n        8'h21: o_data = 8'hFD;\n        8'h22: o_data = 8'h93;\n        8'h23: o_data = 8'h26;\n        8'h24: o_data = 8'h36;\n        8'h25: o_data = 8'h3F;\n        8'h26: o_data = 8'hF7;\n        8'h27: o_data = 8'hCC;\n        8'h28: o_data = 8'h34;\n        8'h29: o_data = 8'hA5;\n        8'h2A: o_data = 8'hE5;\n        8'h2B: o_data = 8'hF1;\n        8'h2C: o_data = 8'h71;\n        8'h2D: o_data = 8'hD8;\n        8'h2E: o_data = 8'h31;\n        8'h2F: o_data = 8'h15;\n        8'h30: o_data = 8'h04;\n        8'h31: o_data = 8'hC7;\n        8'h32: o_data = 8'h23;\n        8'h33: o_data = 8'hC3;\n        8'h34: o_data = 8'h18;\n        8'h35: o_data = 8'h96;\n        8'h36: o_data = 8'h05;\n        8'h37: o_data = 8'h9A;\n        8'h38: o_data = 8'h07;\n        8'h39: o_data = 8'h12;\n        8'h3A: o_data = 8'h80;\n        8'h3B: o_data = 8'hE2;\n        8'h3C: o_data = 8'hEB;\n        8'h3D: o_data = 8'h27;\n        8'h3E: o_data = 8'hB2;\n        8'h3F: o_data = 8'h75;\n        8'h40: o_data = 8'h09;\n        8'h41: o_data = 8'h83;\n        8'h42: o_data = 8'h2C;\n        8'h43: o_data = 8'h1A;\n        8'h44: o_data = 8'h1B;\n        8'h45: o_data = 8'h6E;\n        8'h46: o_data = 8'h5A;\n        8'h47: o_data = 8'hA0;\n        8'h48: o_data = 8'h52;\n        8'h49: o_data = 8'h3B;\n        8'h4A: o_data = 8'hD6;\n        8'h4B: o_data = 8'hB3;\n        8'h4C: o_data = 8'h29;\n        8'h4D: o_data = 8'hE3;\n        8'h4E: o_data = 8'h2F;\n        8'h4F: o_data = 8'h84;\n        8'h50: o_data = 8'h53;\n        8'h51: o_data = 8'hD1;\n        8'h52: o_data = 8'h00;\n        8'h53: o_data = 8'hED;\n        8'h54: o_data = 8'h20;\n        8'h55: o_data = 8'hFC;\n        8'h56: o_data = 8'hB1;\n        8'h57: o_data = 8'h5B;\n        8'h58: o_data = 8'h6A;\n        8'h59: o_data = 8'hCB;\n        8'h5A: o_data = 8'hBE;\n        8'h5B: o_data = 8'h39;\n        8'h5C: o_data = 8'h4A;\n        8'h5D: o_data = 8'h4C;\n        8'h5E: o_data = 8'h58;\n        8'h5F: o_data = 8'hCF;\n        8'h60: o_data = 8'hD0;\n        8'h61: o_data = 8'hEF;\n        8'h62: o_data = 8'hAA;\n        8'h63: o_data = 8'hFB;\n        8'h64: o_data = 8'h43;\n        8'h65: o_data = 8'h4D;\n        8'h66: o_data = 8'h33;\n        8'h67: o_data = 8'h85;\n        8'h68: o_data = 8'h45;\n        8'h69: o_data = 8'hF9;\n        8'h6A: o_data = 8'h02;\n        8'h6B: o_data = 8'h7F;\n        8'h6C: o_data = 8'h50;\n        8'h6D: o_data = 8'h3C;\n        8'h6E: o_data = 8'h9F;\n        8'h6F: o_data = 8'hA8;\n        8'h70: o_data = 8'h51;\n        8'h71: o_data = 8'hA3;\n        8'h72: o_data = 8'h40;\n        8'h73: o_data = 8'h8F;\n        8'h74: o_data = 8'h92;\n        8'h75: o_data = 8'h9D;\n        8'h76: o_data = 8'h38;\n        8'h77: o_data = 8'hF5;\n        8'h78: o_data = 8'hBC;\n        8'h79: o_data = 8'hB6;\n        8'h7A: o_data = 8'hDA;\n        8'h7B: o_data = 8'h21;\n        8'h7C: o_data = 8'h10;\n        8'h7D: o_data = 8'hFF;\n        8'h7E: o_data = 8'hF3;\n        8'h7F: o_data = 8'hD2;\n        8'h80: o_data = 8'hCD;\n        8'h81: o_data = 8'h0C;\n        8'h82: o_data = 8'h13;\n        8'h83: o_data = 8'hEC;\n        8'h84: o_data = 8'h5F;\n        8'h85: o_data = 8'h97;\n        8'h86: o_data = 8'h44;\n        8'h87: o_data = 8'h17;\n        8'h88: o_data = 8'hC4;\n        8'h89: o_data = 8'hA7;\n        8'h8A: o_data = 8'h7E;\n        8'h8B: o_data = 8'h3D;\n        8'h8C: o_data = 8'h64;\n        8'h8D: o_data = 8'h5D;\n        8'h8E: o_data = 8'h19;\n        8'h8F: o_data = 8'h73;\n        8'h90: o_data = 8'h60;\n        8'h91: o_data = 8'h81;\n        8'h92: o_data = 8'h4F;\n        8'h93: o_data = 8'hDC;\n        8'h94: o_data = 8'h22;\n        8'h95: o_data = 8'h2A;\n        8'h96: o_data = 8'h90;\n        8'h97: o_data = 8'h88;\n        8'h98: o_data = 8'h46;\n        8'h99: o_data = 8'hEE;\n        8'h9A: o_data = 8'hB8;\n        8'h9B: o_data = 8'h14;\n        8'h9C: o_data = 8'hDE;\n        8'h9D: o_data = 8'h5E;\n        8'h9E: o_data = 8'h0B;\n        8'h9F: o_data = 8'hDB;\n        8'hA0: o_data = 8'hE0;\n        8'hA1: o_data = 8'h32;\n        8'hA2: o_data = 8'h3A;\n        8'hA3: o_data = 8'h0A;\n        8'hA4: o_data = 8'h49;\n        8'hA5: o_data = 8'h06;\n        8'hA6: o_data = 8'h24;\n        8'hA7: o_data = 8'h5C;\n        8'hA8: o_data = 8'hC2;\n        8'hA9: o_data = 8'hD3;\n        8'hAA: o_data = 8'hAC;\n        8'hAB: o_data = 8'h62;\n        8'hAC: o_data = 8'h91;\n        8'hAD: o_data = 8'h95;\n        8'hAE: o_data = 8'hE4;\n        8'hAF: o_data = 8'h79;\n        8'hB0: o_data = 8'hE7;\n        8'hB1: o_data = 8'hC8;\n        8'hB2: o_data = 8'h37;\n        8'hB3: o_data = 8'h6D;\n        8'hB4: o_data = 8'h8D;\n        8'hB5: o_data = 8'hD5;\n        8'hB6: o_data = 8'h4E;\n        8'hB7: o_data = 8'hA9;\n        8'hB8: o_data = 8'h6C;\n        8'hB9: o_data = 8'h56;\n        8'hBA: o_data = 8'hF4;\n        8'hBB: o_data = 8'hEA;\n        8'hBC: o_data = 8'h65;\n        8'hBD: o_data = 8'h7A;\n        8'hBE: o_data = 8'hAE;\n        8'hBF: o_data = 8'h08;\n        8'hC0: o_data = 8'hBA;\n        8'hC1: o_data = 8'h78;\n        8'hC2: o_data = 8'h25;\n        8'hC3: o_data = 8'h2E;\n        8'hC4: o_data = 8'h1C;\n        8'hC5: o_data = 8'hA6;\n        8'hC6: o_data = 8'hB4;\n        8'hC7: o_data = 8'hC6;\n        8'hC8: o_data = 8'hE8;\n        8'hC9: o_data = 8'hDD;\n        8'hCA: o_data = 8'h74;\n        8'hCB: o_data = 8'h1F;\n        8'hCC: o_data = 8'h4B;\n        8'hCD: o_data = 8'hBD;\n        8'hCE: o_data = 8'h8B;\n        8'hCF: o_data = 8'h8A;\n        8'hD0: o_data = 8'h70;\n        8'hD1: o_data = 8'h3E;\n        8'hD2: o_data = 8'hB5;\n        8'hD3: o_data = 8'h66;\n        8'hD4: o_data = 8'h48;\n        8'hD5: o_data = 8'h03;\n        8'hD6: o_data = 8'hF6;\n        8'hD7: o_data = 8'h0E;\n        8'hD8: o_data = 8'h61;\n        8'hD9: o_data = 8'h35;\n        8'hDA: o_data = 8'h57;\n        8'hDB: o_data = 8'hB9;\n        8'hDC: o_data = 8'h86;\n        8'hDD: o_data = 8'hC1;\n        8'hDE: o_data = 8'h1D;\n        8'hDF: o_data = 8'h9E;\n        8'hE0: o_data = 8'hE1;\n        8'hE1: o_data = 8'hF8;\n        8'hE2: o_data = 8'h98;\n        8'hE3: o_data = 8'h11;\n        8'hE4: o_data = 8'h69;\n        8'hE5: o_data = 8'hD9;\n        8'hE6: o_data = 8'h8E;\n        8'hE7: o_data = 8'h94;\n        8'hE8: o_data = 8'h9B;\n        8'hE9: o_data = 8'h1E;\n        8'hEA: o_data = 8'h87;\n        8'hEB: o_data = 8'hE9;\n        8'hEC: o_data = 8'hCE;\n        8'hED: o_data = 8'h55;\n        8'hEE: o_data = 8'h28;\n        8'hEF: o_data = 8'hDF;\n        8'hF0: o_data = 8'h8C;\n        8'hF1: o_data = 8'hA1;\n        8'hF2: o_data = 8'h89;\n        8'hF3: o_data = 8'h0D;\n        8'hF4: o_data = 8'hBF;\n        8'hF5: o_data = 8'hE6;\n        8'hF6: o_data = 8'h42;\n        8'hF7: o_data = 8'h68;\n        8'hF8: o_data = 8'h41;\n        8'hF9: o_data = 8'h99;\n        8'hFA: o_data = 8'h2D;\n        8'hFB: o_data = 8'h0F;\n        8'hFC: o_data = 8'hB0;\n        8'hFD: o_data = 8'h54;\n        8'hFE: o_data = 8'hBB;\n        8'hFF: o_data = 8'h16;\n        default: o_data = 8'h00;\n    endcase\nend\n\nendmodule : sbox", "verif/tb_padding_top.sv": "module tb_padding_top;\n\n// Interface parameters\nlocalparam NBW_KEY  = 'd256;\nlocalparam NBW_DATA = 'd128;\nlocalparam NBW_MODE = 'd3;\nlocalparam NBW_CNTR = 'd32;\nlocalparam NBW_PADD = 'd4;\nlocalparam NBW_PMOD = 'd2;\nlocalparam W3C_BYTE = 8'hAF;\n\n// Possible operation modes\nlocalparam ECB  = 3'd0;\nlocalparam CBC  = 3'd1;\nlocalparam PCBC = 3'd2;\nlocalparam CFB  = 3'd3;\nlocalparam OFB  = 3'd4;\nlocalparam CTR  = 3'd5;\n\n// Interface signals\nlogic                clk;\nlogic                rst_async_n;\nlogic                i_encrypt;\nlogic                i_update_padding_mode;\nlogic [NBW_PMOD-1:0] i_padding_mode;\nlogic [NBW_PADD-1:0] i_padding_bytes;\nlogic                i_reset_counter;\nlogic                i_update_iv;\nlogic [NBW_DATA-1:0] i_iv;\nlogic                i_update_mode;\nlogic [NBW_MODE-1:0] i_mode;\nlogic                i_update_key;\nlogic [NBW_KEY-1:0]  i_key;\nlogic                i_start;\nlogic [NBW_DATA-1:0] i_data;\nlogic                o_done;\nlogic [NBW_DATA-1:0] o_data;\n\n// Module instantiation\npadding_top #(\n    .NBW_KEY (NBW_KEY ),\n    .NBW_DATA(NBW_DATA),\n    .NBW_MODE(NBW_MODE),\n    .NBW_CNTR(NBW_CNTR),\n    .NBW_PADD(NBW_PADD),\n    .NBW_PMOD(NBW_PMOD),\n    .W3C_BYTE(W3C_BYTE)\n) uu_padding_top (\n    .clk                  (clk                  ),\n    .rst_async_n          (rst_async_n          ),\n    .i_encrypt            (i_encrypt            ),\n    .i_update_padding_mode(i_update_padding_mode),\n    .i_padding_mode       (i_padding_mode       ),\n    .i_padding_bytes      (i_padding_bytes      ),\n    .i_reset_counter      (i_reset_counter      ),\n    .i_update_iv          (i_update_iv          ),\n    .i_iv                 (i_iv                 ),\n    .i_update_mode        (i_update_mode        ),\n    .i_mode               (i_mode               ),\n    .i_update_key         (i_update_key         ),\n    .i_key                (i_key                ),\n    .i_start              (i_start              ),\n    .i_data               (i_data               ),\n    .o_done               (o_done               ),\n    .o_data               (o_data               )\n);\n\ninitial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0,tb_padding_top);\nend\n\ntask Compare (logic [NBW_DATA-1:0] compare_value);\n    if(o_data == compare_value) begin\n        $display(\"PASS\");\n    end else begin\n        $display(\"\\nFAIL:\");\n        $display(\" - Expected output: %h\", compare_value);\n        $display(\" - Observed output: %h\", o_data);\n    end\nendtask\n\ntask DriveInputs(logic update_key, logic [NBW_PADD-1:0] padding_bytes, logic [NBW_DATA-1:0] expected_output);\n    @(negedge clk);\n    i_key           = 256'h000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f;\n    i_data          = 128'h00112233445566778899aabbccddeeff;\n    i_reset_counter = 0;\n    i_iv            = 0;\n    i_update_iv     = 0;\n    i_update_mode   = 0;\n    i_mode          = 0;\n    i_update_key    = update_key;\n    i_start         = 1;\n\n    i_padding_bytes = padding_bytes;\n\n    @(negedge clk);\n    i_start = 0;\n    i_update_key = 0;\n    i_key = 0;\n    i_data = 0;\n    i_padding_bytes = 0;\n\n    @(posedge o_done);\n    @(negedge clk);\n\n    Compare(expected_output);\nendtask\n\nalways #5 clk = ~clk;\n\ninitial begin\n    clk = 0;\n    i_update_padding_mode = 0;\n    i_start = 0;\n    i_update_iv = 0;\n    i_update_key = 0;\n    i_update_mode = 0;\n    i_reset_counter = 0;\n    rst_async_n = 1;\n    #1;\n    rst_async_n = 0;\n    #2;\n    rst_async_n = 1;\n    @(negedge clk);\n\n    // Udpate mode to CTR\n    i_update_mode = 1;\n    i_mode        = CTR;\n    // Add a \"random\" IV\n    i_update_iv   = 1;\n    i_iv          = 128'hffffffff_00000000_00000000_ffffffff;\n    // Set to encrypt\n    i_encrypt = 1;\n    $display(\"\\n================\");\n    $display(\"=   Encrypt    =\");\n    $display(\"================\");\n\n    // Set padding mode to PKCS\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b00;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"=     PKCS     =\");\n    $display(\"================\");\n    \n    // Try all paddings for the PKCS mode\n    DriveInputs(1'b1, 4'h0, 128'hf1fa832efe2cceee4f06eda80718af1b);\n    DriveInputs(1'b0, 4'h1, 128'h9c9a150012f05c1db68aa6de49bc56f0);\n    DriveInputs(1'b0, 4'h2, 128'h7736fbfaeb7a413495e65b8a70779392);\n    DriveInputs(1'b0, 4'h3, 128'h85f263da7dea8bcc3883f2c312bccabb);\n    DriveInputs(1'b0, 4'h4, 128'h2c84695b539826d43818daddb1359610);\n    DriveInputs(1'b0, 4'h5, 128'h74b38b042a70078444e45c6cd62fe09f);\n    DriveInputs(1'b0, 4'h6, 128'h049d2c451606113d5c597fd47ed2ddc7);\n    DriveInputs(1'b0, 4'h7, 128'h58d05e0c92b12118eaf2ca738d2c7f06);\n    DriveInputs(1'b0, 4'h8, 128'h4e1d3f0d7dd4b629e291de8eb7520781);\n    DriveInputs(1'b0, 4'h9, 128'h7a3b7f71319b895fadc2c8cadbf3f511);\n    DriveInputs(1'b0, 4'ha, 128'h283873c17d3fac7e9057748dc5a0dc9a);\n    DriveInputs(1'b0, 4'hb, 128'hf1d4ec0c04533fb438681a866d6ceba2);\n    DriveInputs(1'b0, 4'hc, 128'h9e6a83f1871445ba974d9ea24deb2497);\n    DriveInputs(1'b0, 4'hd, 128'h3786b6f975e68cf93eb043f73b0930ec);\n    DriveInputs(1'b0, 4'he, 128'h7e9d6b0ad94e7cccda9b35c383f7639e);\n    DriveInputs(1'b0, 4'hf, 128'h9f6e010a5e695b284e5a8c4d8e8de1c5);\n\n    // Reset the counter\n    i_reset_counter = 1;\n\n    // Set padding mode to OneAndZeroes\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b01;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"= OneAndZeroes =\");\n    $display(\"================\");\n    \n    // Try all paddings for the OneAndZeroes mode\n    DriveInputs(1'b0, 4'h0, 128'hf1fa832efe2cceee4f06eda80718af1b);\n    DriveInputs(1'b0, 4'h1, 128'h9c9a150012f05c1db68aa6de49bc5671);\n    DriveInputs(1'b0, 4'h2, 128'h7736fbfaeb7a413495e65b8a70771190);\n    DriveInputs(1'b0, 4'h3, 128'h85f263da7dea8bcc3883f2c3123fc9b8);\n    DriveInputs(1'b0, 4'h4, 128'h2c84695b539826d43818dadd35319214);\n    DriveInputs(1'b0, 4'h5, 128'h74b38b042a70078444e45ce9d32ae59a);\n    DriveInputs(1'b0, 4'h6, 128'h049d2c451606113d5c59f9d278d4dbc1);\n    DriveInputs(1'b0, 4'h7, 128'h58d05e0c92b12118ea75cd748a2b7801);\n    DriveInputs(1'b0, 4'h8, 128'h4e1d3f0d7dd4b6296a99d686bf5a0f89);\n    DriveInputs(1'b0, 4'h9, 128'h7a3b7f71319b89d6a4cbc1c3d2fafc18);\n    DriveInputs(1'b0, 4'ha, 128'h283873c17d3f26749a5d7e87cfaad690);\n    DriveInputs(1'b0, 4'hb, 128'hf1d4ec0c04d834bf3363118d6667e0a9);\n    DriveInputs(1'b0, 4'hc, 128'h9e6a83f10b1849b69b4192ae41e7289b);\n    DriveInputs(1'b0, 4'hd, 128'h3786b67478eb81f433bd4efa36043de1);\n    DriveInputs(1'b0, 4'he, 128'h7e9de504d74072c2d4953bcd8df96d90);\n    DriveInputs(1'b0, 4'hf, 128'h9fe10e0551665427415583428182eeca);\n\n    // Reset the counter\n    i_reset_counter = 1;\n\n    // Set padding mode to ANSIX923\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b10;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"=   ANSIX923   =\");\n    $display(\"================\");\n    \n    // Try all paddings for the ANSIX923 mode\n    DriveInputs(1'b0, 4'h0, 128'hf1fa832efe2cceee4f06eda80718af1b);\n    DriveInputs(1'b0, 4'h1, 128'h9c9a150012f05c1db68aa6de49bc56f0);\n    DriveInputs(1'b0, 4'h2, 128'h7736fbfaeb7a413495e65b8a70779192);\n    DriveInputs(1'b0, 4'h3, 128'h85f263da7dea8bcc3883f2c312bfc9bb);\n    DriveInputs(1'b0, 4'h4, 128'h2c84695b539826d43818daddb5319210);\n    DriveInputs(1'b0, 4'h5, 128'h74b38b042a70078444e45c69d32ae59f);\n    DriveInputs(1'b0, 4'h6, 128'h049d2c451606113d5c5979d278d4dbc7);\n    DriveInputs(1'b0, 4'h7, 128'h58d05e0c92b12118eaf5cd748a2b7806);\n    DriveInputs(1'b0, 4'h8, 128'h4e1d3f0d7dd4b629ea99d686bf5a0f81);\n    DriveInputs(1'b0, 4'h9, 128'h7a3b7f71319b8956a4cbc1c3d2fafc11);\n    DriveInputs(1'b0, 4'ha, 128'h283873c17d3fa6749a5d7e87cfaad69a);\n    DriveInputs(1'b0, 4'hb, 128'hf1d4ec0c045834bf3363118d6667e0a2);\n    DriveInputs(1'b0, 4'hc, 128'h9e6a83f18b1849b69b4192ae41e72897);\n    DriveInputs(1'b0, 4'hd, 128'h3786b6f478eb81f433bd4efa36043dec);\n    DriveInputs(1'b0, 4'he, 128'h7e9d6504d74072c2d4953bcd8df96d9e);\n    DriveInputs(1'b0, 4'hf, 128'h9f610e0551665427415583428182eec5);\n\n    // Reset the counter\n    i_reset_counter = 1;\n\n    // Set padding mode to W3C\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b11;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"=     W3C      =\");\n    $display(\"================\");\n    \n    // Try all paddings for the W3C mode\n    DriveInputs(1'b0, 4'h0, 128'hf1fa832efe2cceee4f06eda80718af1b);\n    DriveInputs(1'b0, 4'h1, 128'h9c9a150012f05c1db68aa6de49bc56f0);\n    DriveInputs(1'b0, 4'h2, 128'h7736fbfaeb7a413495e65b8a70773e92);\n    DriveInputs(1'b0, 4'h3, 128'h85f263da7dea8bcc3883f2c3121066bb);\n    DriveInputs(1'b0, 4'h4, 128'h2c84695b539826d43818dadd1a9e3d10);\n    DriveInputs(1'b0, 4'h5, 128'h74b38b042a70078444e45cc67c854a9f);\n    DriveInputs(1'b0, 4'h6, 128'h049d2c451606113d5c59d67dd77b74c7);\n    DriveInputs(1'b0, 4'h7, 128'h58d05e0c92b12118ea5a62db2584d706);\n    DriveInputs(1'b0, 4'h8, 128'h4e1d3f0d7dd4b6294536792910f5a081);\n    DriveInputs(1'b0, 4'h9, 128'h7a3b7f71319b89f90b646e6c7d555311);\n    DriveInputs(1'b0, 4'ha, 128'h283873c17d3f09db35f2d1286005799a);\n    DriveInputs(1'b0, 4'hb, 128'hf1d4ec0c04f79b109cccbe22c9c84fa2);\n    DriveInputs(1'b0, 4'hc, 128'h9e6a83f124b7e61934ee3d01ee488797);\n    DriveInputs(1'b0, 4'hd, 128'h3786b65bd7442e5b9c12e15599ab92ec);\n    DriveInputs(1'b0, 4'he, 128'h7e9dcaab78efdd6d7b3a94622256c29e);\n    DriveInputs(1'b0, 4'hf, 128'h9fcea1aafec9fb88eefa2ced2e2d41c5);\n\n    // Set to decrypt\n    i_encrypt = 0;\n\n    $display(\"\\n================\");\n    $display(\"=   Decrypt    =\");\n    $display(\"================\");\n\n    // Set padding mode to PKCS\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b00;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"=     PKCS     =\");\n    $display(\"================\");\n    \n    // Try all paddings for the PKCS mode\n    DriveInputs(1'b1, 4'h0, 128'heab487e68ec92db4ac288a24757b0262);\n    DriveInputs(1'b0, 4'h1, 128'hf64d8192e294917701d3d70da384c8e0);\n    DriveInputs(1'b0, 4'h2, 128'h6ef961d86bfde1b7d9d37020f206f105);\n    DriveInputs(1'b0, 4'h3, 128'hb22dc55b0054fd0ad709cec19d083750);\n    DriveInputs(1'b0, 4'h4, 128'h95e72e8457f2a58a96b41bbccb6e0660);\n    DriveInputs(1'b0, 4'h5, 128'hdd67798259aa234a12d3b764459bfef2);\n    DriveInputs(1'b0, 4'h6, 128'hb98acf0a984284ae96b8bd07cc810ae4);\n    DriveInputs(1'b0, 4'h7, 128'h8265365ce045f9789243ce7b53188570);\n    DriveInputs(1'b0, 4'h8, 128'hee14dc243cab56a63ee686058db3a46d);\n    DriveInputs(1'b0, 4'h9, 128'h1e32eebda4b7878a8a36cb04c11b1983);\n    DriveInputs(1'b0, 4'ha, 128'h0b4dcae2cd918bafbb8bf32f8b05a9e0);\n    DriveInputs(1'b0, 4'hb, 128'hc4067f695b84b0c36c8b2a2ac39347ef);\n    DriveInputs(1'b0, 4'hc, 128'hf8d01782c0031d7555f230f917508c93);\n    DriveInputs(1'b0, 4'hd, 128'ha8a93b08d5b93ae809b78365a31dd1a8);\n    DriveInputs(1'b0, 4'he, 128'hac0cebdf2fae979c490695b48a33d1d5);\n    DriveInputs(1'b0, 4'hf, 128'h22619dbea37c0527210568174c69f3ad);\n\n    // Reset the counter\n    i_reset_counter = 1;\n\n    // Set padding mode to OneAndZeroes\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b01;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"= OneAndZeroes =\");\n    $display(\"================\");\n    \n    // Try all paddings for the OneAndZeroes mode\n    DriveInputs(1'b0, 4'h0, 128'heab487e68ec92db4ac288a24757b0262);\n    DriveInputs(1'b0, 4'h1, 128'hc54a83e25ca56799a14ffd4bcaf3d1f5);\n    DriveInputs(1'b0, 4'h2, 128'h9f52e86b3dd2996b4ca0cc97d58b71d6);\n    DriveInputs(1'b0, 4'h3, 128'h2b66be0bf9e98b1cec49147b99b088e0);\n    DriveInputs(1'b0, 4'h4, 128'h577530ee4c2a45cb8a5e97d879468047);\n    DriveInputs(1'b0, 4'h5, 128'ha77b9e5ffc79e5e930495192f3242255);\n    DriveInputs(1'b0, 4'h6, 128'ha3a023dfdd23fc0410b7694c1b679046);\n    DriveInputs(1'b0, 4'h7, 128'h88f9321e73e273599a4d07874bd666a1);\n    DriveInputs(1'b0, 4'h8, 128'h74c452ff371e6849d6ed5d5335505e45);\n    DriveInputs(1'b0, 4'h9, 128'h0d169882051c4787e25a44b9f0628fd6);\n    DriveInputs(1'b0, 4'ha, 128'hae93a046915f6a4b08868fc5613dff94);\n    DriveInputs(1'b0, 4'hb, 128'hbc554067455fa678d3303a28f0a19cfa);\n    DriveInputs(1'b0, 4'hc, 128'hb7fb754b48f60052e0b10d2f8b32275c);\n    DriveInputs(1'b0, 4'hd, 128'h3f3aa4a7f7aa8342e474a34c5abe3f1a);\n    DriveInputs(1'b0, 4'he, 128'h5694bc221034dfc53b5ac47ee17fc98c);\n    DriveInputs(1'b0, 4'hf, 128'h4e6821cc1b5bc620050e2a6a40a605f6);\n\n    // Reset the counter\n    i_reset_counter = 1;\n\n    // Set padding mode to ANSIX923\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b10;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"=   ANSIX923   =\");\n    $display(\"================\");\n    \n    // Try all paddings for the ANSIX923 mode\n    DriveInputs(1'b0, 4'h0, 128'heab487e68ec92db4ac288a24757b0262);\n    DriveInputs(1'b0, 4'h1, 128'hf64d8192e294917701d3d70da384c8e0);\n    DriveInputs(1'b0, 4'h2, 128'h1fd077ebf6416f3c40bbed158ab717bc);\n    DriveInputs(1'b0, 4'h3, 128'h8479c1c2b5e323f09a8c6d24a123e877);\n    DriveInputs(1'b0, 4'h4, 128'h95dd5b8ea8eb4102cf0c3c7b3355b074);\n    DriveInputs(1'b0, 4'h5, 128'h853d05d712ab8e1122aef182fc9a6d0b);\n    DriveInputs(1'b0, 4'h6, 128'h5e3e77097905251a05af46092bddc94d);\n    DriveInputs(1'b0, 4'h7, 128'h6ac5d4bb95a0bb686f6fa70527030e62);\n    DriveInputs(1'b0, 4'h8, 128'h05474c6d864611bff5152b02bae22577);\n    DriveInputs(1'b0, 4'h9, 128'h1405a02698df01f1ea7c6df42ca32884);\n    DriveInputs(1'b0, 4'ha, 128'h6e088002346334f80f2f129a1d547aaa);\n    DriveInputs(1'b0, 4'hb, 128'h0a980602ad8dad88d6b00c713abea53b);\n    DriveInputs(1'b0, 4'hc, 128'hcd0c9deab70fd5328970a76fa0d1dc48);\n    DriveInputs(1'b0, 4'hd, 128'h9a25537211c82a59b7bdf9a1fbac1f98);\n    DriveInputs(1'b0, 4'he, 128'h195b50b81173a575df5ee29817936c81);\n    DriveInputs(1'b0, 4'hf, 128'h342e5b8715bbb0cc481365f92724c1ed);\n\n    // Reset the counter\n    i_reset_counter = 1;\n\n    // Set padding mode to W3C\n    i_update_padding_mode = 1;\n    i_padding_mode = 2'b11;\n    @(negedge clk);\n\n    $display(\"\\n================\");\n    $display(\"=     W3C      =\");\n    $display(\"================\");\n    \n    // Try all paddings for the W3C mode\n    DriveInputs(1'b0, 4'h0, 128'heab487e68ec92db4ac288a24757b0262);\n    DriveInputs(1'b0, 4'h1, 128'hf64d8192e294917701d3d70da384c8e0);\n    DriveInputs(1'b0, 4'h2, 128'he1b1ea612690eb1620ed797170814e60);\n    DriveInputs(1'b0, 4'h3, 128'h98b896945ce882123e56e787f95857af);\n    DriveInputs(1'b0, 4'h4, 128'h1c4874b8899b6a08c8d6ba8a7c56af36);\n    DriveInputs(1'b0, 4'h5, 128'hdd573152aa7456e418848171a5a36917);\n    DriveInputs(1'b0, 4'h6, 128'h437a94424a9234574e880ded69169a89);\n    DriveInputs(1'b0, 4'h7, 128'h5ee7b24ddcd74217e700cfc4804d1d4f);\n    DriveInputs(1'b0, 4'h8, 128'hf97a9831c2690f65f60bfef87a095127);\n    DriveInputs(1'b0, 4'h9, 128'h7e00f194cdf6e8cea0673e04b679f596);\n    DriveInputs(1'b0, 4'ha, 128'h464bb36d1646eccb390c2697dbe980f4);\n    DriveInputs(1'b0, 4'hb, 128'h2f7eb1363120ab53ff3682cb37ca006b);\n    DriveInputs(1'b0, 4'hc, 128'h77e987e8bdb2a56cd90481a1f2232f4b);\n    DriveInputs(1'b0, 4'hd, 128'h70b8b2de66377852c1fa6090ffa5199a);\n    DriveInputs(1'b0, 4'he, 128'h9fcb5342ceeda9eb119a749e828953ac);\n    DriveInputs(1'b0, 4'hf, 128'h70063b648ddd4ec7ae5bfa7baae10919);\n\n    $finish();\nend\n\nendmodule"}, "patch": {"rtl/aes_dec_top.sv": "", "rtl/aes_enc_top.sv": "", "rtl/padding_top.sv": ""}, "harness": {"docker-compose.yml": "services:\n  test_padding:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache\n\n  test_decrypt:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env_decrypt\n    command     : pytest /src/test_runner_dec_top.py -s -v -o cache_dir=/rundir/harness/.cache\n\n  test_encrypt:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env_encrypt\n    command     : pytest /src/test_runner_enc_top.py -s -v -o cache_dir=/rundir/harness/.cache", "src/.env": "VERILOG_SOURCES = /code/rtl/padding_top.sv /code/rtl/aes_dec_top.sv /code/rtl/aes_decrypt.sv /code/rtl/sbox.sv /code/rtl/aes_ke.sv /code/rtl/inv_sbox.sv /code/rtl/aes_encrypt.sv /code/rtl/aes_enc_top.sv\nTOPLEVEL        = padding_top\nMODULE          = test_padding_top\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 18-create-aes-padding\nWAVE            = true", "src/.env_decrypt": "VERILOG_SOURCES = /code/rtl/aes_dec_top.sv /code/rtl/aes_decrypt.sv /code/rtl/sbox.sv /code/rtl/aes_ke.sv /code/rtl/inv_sbox.sv /code/rtl/aes_encrypt.sv\nTOPLEVEL        = aes_dec_top\nMODULE          = test_aes_dec_top\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 18-create-aes-padding\nWAVE            = true", "src/.env_encrypt": "VERILOG_SOURCES = /code/rtl/aes_enc_top.sv /code/rtl/aes_encrypt.sv /code/rtl/sbox.sv\nTOPLEVEL        = aes_enc_top\nMODULE          = test_aes_enc_top\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 18-create-aes-padding\nWAVE            = true", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom collections import deque\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\ndef PKCS(data, padding):\n    # Convert int to 16-byte array\n    data_bytes = data.to_bytes(16, byteorder='big')\n\n    # Trim the last `padding` bytes\n    trimmed = data_bytes[:16 - padding]\n\n    # Add padding bytes\n    pad_byte = padding.to_bytes(1, byteorder='big')\n    padded_bytes = trimmed + pad_byte * padding\n\n    # Convert back to integer\n    return int.from_bytes(padded_bytes, byteorder='big')\n\ndef OneAndZeroes(data, padding):\n    data_bytes = data.to_bytes(16, byteorder='big')\n\n    if padding == 0:\n        # No padding needed\n        padded_bytes = data_bytes\n    else:\n        trimmed = data_bytes[:16 - padding]\n        padded_bytes = trimmed + b'\\x80' + b'\\x00' * (padding - 1)\n\n    return int.from_bytes(padded_bytes, byteorder='big')\n\ndef ANSIX923(data, padding):\n    data_bytes = data.to_bytes(16, byteorder='big')\n\n    if padding == 0:\n        padded_bytes = data_bytes\n    else:\n        trimmed = data_bytes[:16 - padding]\n        pad_value = padding.to_bytes(1, byteorder='big')\n        padded_bytes = trimmed + b'\\x00' * (padding - 1) + pad_value\n\n    return int.from_bytes(padded_bytes, byteorder='big')\n\ndef W3C(data, padding, filler_byte=0xAF):\n    data_bytes = data.to_bytes(16, byteorder='big')\n\n    if padding == 0:\n        # No padding needed\n        padded_bytes = data_bytes\n    else:\n        trimmed = data_bytes[:16 - padding]\n        fill = bytes([filler_byte] * (padding - 1)) + bytes([padding])\n        padded_bytes = trimmed + fill\n\n    return int.from_bytes(padded_bytes, byteorder='big')\n\nclass aes_decrypt:\n    RCON = [\n        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36\n    ]\n    \n    SBOX = [\n        # S-box table used in AES\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n    \n    def __init__(self):\n        self.expanded_key = 0\n        self.data_out = 0\n        self.iv = 0\n        self.counter = 0\n        self.inv_s_box = [0] * 256\n        for i, val in enumerate(self.SBOX):\n            self.inv_s_box[val] = i\n    \n    def reset(self):\n        self.expanded_key = 0\n        self.data_out = 0\n        self.iv = 0\n        self.counter = 0\n    \n    def update_key(self, key):\n        key_bytes = key.to_bytes(32, 'big')  # Convert 256-bit key to bytes\n        self.expanded_key = self.expand_key(key_bytes)\n    \n    def expand_key(self, key):\n        words = [list(key[i:i+4]) for i in range(0, 32, 4)]\n        \n        for i in range(8, 60):\n            temp = words[i - 1]\n            \n            if i % 8 == 0:\n                temp = self.sub_word(self.rot_word(temp))\n                temp[0] ^= self.RCON[i // 8 - 1]\n            elif i % 8 == 4:\n                temp = self.sub_word(temp)\n            \n            words.append([words[i - 8][j] ^ temp[j] for j in range(4)])\n        \n        expanded_key_bytes = b''.join(bytes(word) for word in words)\n        return int.from_bytes(expanded_key_bytes, 'big')\n    \n    def sub_word(self, word):\n        return [self.SBOX[b] for b in word]\n    \n    def rot_word(self, word):\n        return word[1:] + word[:1]\n    \n    def gmul(self, a, b):\n        p = 0\n        for _ in range(8):\n            if b & 1:\n                p ^= a\n            hi = a & 0x80\n            a = (a << 1) & 0xFF\n            if hi:\n                a ^= 0x1b\n            b >>= 1\n        return p\n\n    def sub_bytes(self, state):\n        for i in range(16):\n            state[i] = self.SBOX[state[i]]\n\n    def shift_rows(self, state):\n        state[1], state[5], state[9], state[13] = state[5], state[9], state[13], state[1]\n        state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]\n        state[3], state[7], state[11], state[15] = state[15], state[3], state[7], state[11]\n\n    def mix_columns(self, s):\n        for i in range(4):\n            a = s[i*4:(i+1)*4]\n            s[i*4+0] = self.gmul(a[0],2)^self.gmul(a[1],3)^a[2]^a[3]\n            s[i*4+1] = a[0]^self.gmul(a[1],2)^self.gmul(a[2],3)^a[3]\n            s[i*4+2] = a[0]^a[1]^self.gmul(a[2],2)^self.gmul(a[3],3)\n            s[i*4+3] = self.gmul(a[0],3)^a[1]^a[2]^self.gmul(a[3],2)\n\n    def add_round_key(self, state, round_key_words):\n        for col in range(4):\n            word = round_key_words[col]\n            for row in range(4):\n                state[col * 4 + row] ^= (word >> (24 - 8 * row)) & 0xFF\n\n    def get_round_keys(self):\n        expanded_bytes = self.expanded_key.to_bytes(240, 'big')\n        round_keys = []\n        for i in range(0, 240, 16):  # Each round key is 16 bytes (4 words)\n            words = [int.from_bytes(expanded_bytes[i + j*4 : i + (j+1)*4], 'big') for j in range(4)]\n            round_keys.append(words)\n        return round_keys\n\n    def encrypt(self, data):\n        state = [(data >> (8 * (15 - i))) & 0xFF for i in range(16)]\n        round_keys = self.get_round_keys()\n        \n        self.add_round_key(state, round_keys[0])\n\n        for rnd in range(1, 14):\n            self.sub_bytes(state)\n            self.shift_rows(state)\n            self.mix_columns(state)\n            self.add_round_key(state, round_keys[rnd])\n\n        self.sub_bytes(state)\n        self.shift_rows(state)\n        self.add_round_key(state, round_keys[14])\n\n        self.data_out = 0\n        for b in state:\n            self.data_out = (self.data_out << 8) | b\n        \n    def inv_sub_bytes(self, state):\n        for i in range(16):\n            state[i] = self.inv_s_box[state[i]]\n\n    def inv_shift_rows(self, state):\n        state[1], state[5], state[9], state[13] = state[13], state[1], state[5], state[9]\n        state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]\n        state[3], state[7], state[11], state[15] = state[7], state[11], state[15], state[3]\n\n    def inv_mix_columns(self, s):\n        for i in range(4):\n            a = s[i*4:(i+1)*4]\n            s[i*4+0] = self.gmul(a[0],14)^self.gmul(a[1],11)^self.gmul(a[2],13)^self.gmul(a[3],9)\n            s[i*4+1] = self.gmul(a[0],9)^self.gmul(a[1],14)^self.gmul(a[2],11)^self.gmul(a[3],13)\n            s[i*4+2] = self.gmul(a[0],13)^self.gmul(a[1],9)^self.gmul(a[2],14)^self.gmul(a[3],11)\n            s[i*4+3] = self.gmul(a[0],11)^self.gmul(a[1],13)^self.gmul(a[2],9)^self.gmul(a[3],14)\n    \n    def decrypt(self, data):\n        state = [(data >> (8 * (15 - i))) & 0xFF for i in range(16)]\n        round_keys = self.get_round_keys()\n\n        self.add_round_key(state, round_keys[14])\n\n        for rnd in range(13, 0, -1):\n            self.inv_shift_rows(state)\n            self.inv_sub_bytes(state)\n            self.add_round_key(state, round_keys[rnd])\n            self.inv_mix_columns(state)\n\n        self.inv_shift_rows(state)\n        self.inv_sub_bytes(state)\n        self.add_round_key(state, round_keys[0])\n\n        self.data_out = 0\n        for b in state:\n            self.data_out = (self.data_out << 8) | b\n    \n    def MODE(self, data, mode):\n        if mode == 0:\n            self.ECB(data)\n        elif mode == 1:\n            self.CBC(data)\n        elif mode == 2:\n            self.PCBC(data)\n        elif mode == 3:\n            self.CFB(data)\n        elif mode == 4:\n            self.OFB(data)\n        else:\n            self.CTR(data)\n\n    def ECB(self, data):\n        self.decrypt(data)\n    \n    def CBC(self, data):\n        self.decrypt(data)\n        self.data_out = self.data_out ^ self.iv\n        self.iv = data\n    \n    def PCBC(self, data):\n        self.decrypt(data)\n        self.data_out = self.data_out ^ self.iv\n        self.iv = data ^ self.data_out\n    \n    def CFB(self, data):\n        self.encrypt(self.iv)\n        self.data_out = self.data_out ^ data\n        self.iv = data\n    \n    def OFB(self, data):\n        self.encrypt(self.iv)\n        self.iv = self.data_out\n        self.data_out = self.data_out ^ data\n    \n    def CTR(self, data):\n        enc_in = (self.iv & 0x0000FFFFFFFFFFFFFFFFFFFFFFFF0000) + (self.counter & 0x0000FFFF) + ((self.counter & 0xFFFF0000) << 96)\n        self.encrypt(enc_in)\n        if self.counter < 2**32 - 1:\n            self.counter = self.counter + 1\n        else:\n            self.counter = 0\n        \n        self.data_out = self.data_out ^ data\n\nclass aes_encrypt:\n    RCON = [\n        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36\n    ]\n    \n    SBOX = [\n        # S-box table used in AES\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n    \n    def __init__(self):\n        self.expanded_key = 0\n        self.data_out = 0\n        self.iv = 0\n        self.counter = 0\n    \n    def reset(self):\n        self.expanded_key = 0\n        self.data_out = 0\n        self.iv = 0\n        self.counter = 0\n    \n    def update_key(self, key):\n        key_bytes = key.to_bytes(32, 'big')  # Convert 256-bit key to bytes\n        self.expanded_key = self.expand_key(key_bytes)\n    \n    def expand_key(self, key):\n        words = [list(key[i:i+4]) for i in range(0, 32, 4)]\n        \n        for i in range(8, 60):\n            temp = words[i - 1]\n            \n            if i % 8 == 0:\n                temp = self.sub_word(self.rot_word(temp))\n                temp[0] ^= self.RCON[i // 8 - 1]\n            elif i % 8 == 4:\n                temp = self.sub_word(temp)\n            \n            words.append([words[i - 8][j] ^ temp[j] for j in range(4)])\n        \n        expanded_key_bytes = b''.join(bytes(word) for word in words)\n        return int.from_bytes(expanded_key_bytes, 'big')\n    \n    def sub_word(self, word):\n        return [self.SBOX[b] for b in word]\n    \n    def rot_word(self, word):\n        return word[1:] + word[:1]\n    \n    def gmul(self, a, b):\n        p = 0\n        for _ in range(8):\n            if b & 1:\n                p ^= a\n            hi = a & 0x80\n            a = (a << 1) & 0xFF\n            if hi:\n                a ^= 0x1b\n            b >>= 1\n        return p\n\n    def sub_bytes(self, state):\n        for i in range(16):\n            state[i] = self.SBOX[state[i]]\n\n    def shift_rows(self, state):\n        state[1], state[5], state[9], state[13] = state[5], state[9], state[13], state[1]\n        state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]\n        state[3], state[7], state[11], state[15] = state[15], state[3], state[7], state[11]\n\n    def mix_columns(self, s):\n        for i in range(4):\n            a = s[i*4:(i+1)*4]\n            s[i*4+0] = self.gmul(a[0],2)^self.gmul(a[1],3)^a[2]^a[3]\n            s[i*4+1] = a[0]^self.gmul(a[1],2)^self.gmul(a[2],3)^a[3]\n            s[i*4+2] = a[0]^a[1]^self.gmul(a[2],2)^self.gmul(a[3],3)\n            s[i*4+3] = self.gmul(a[0],3)^a[1]^a[2]^self.gmul(a[3],2)\n\n    def add_round_key(self, state, round_key_words):\n        for col in range(4):\n            word = round_key_words[col]\n            for row in range(4):\n                state[col * 4 + row] ^= (word >> (24 - 8 * row)) & 0xFF\n\n    def get_round_keys(self):\n        expanded_bytes = self.expanded_key.to_bytes(240, 'big')\n        round_keys = []\n        for i in range(0, 240, 16):  # Each round key is 16 bytes (4 words)\n            words = [int.from_bytes(expanded_bytes[i + j*4 : i + (j+1)*4], 'big') for j in range(4)]\n            round_keys.append(words)\n        return round_keys\n\n    def encrypt(self, data):\n        state = [(data >> (8 * (15 - i))) & 0xFF for i in range(16)]\n        round_keys = self.get_round_keys()\n        \n        self.add_round_key(state, round_keys[0])\n\n        for rnd in range(1, 14):\n            self.sub_bytes(state)\n            self.shift_rows(state)\n            self.mix_columns(state)\n            self.add_round_key(state, round_keys[rnd])\n\n        self.sub_bytes(state)\n        self.shift_rows(state)\n        self.add_round_key(state, round_keys[14])\n\n        self.data_out = 0\n        for b in state:\n            self.data_out = (self.data_out << 8) | b\n    \n    def MODE(self, data, mode):\n        if mode == 0:\n            self.ECB(data)\n        elif mode == 1:\n            self.CBC(data)\n        elif mode == 2:\n            self.PCBC(data)\n        elif mode == 3:\n            self.CFB(data)\n        elif mode == 4:\n            self.OFB(data)\n        else:\n            self.CTR(data)\n    \n    def ECB(self, data):\n        self.encrypt(data)\n    \n    def CBC(self, data):\n        enc_in = data ^ self.iv\n        self.encrypt(enc_in)\n        self.iv = self.data_out\n    \n    def PCBC(self, data):\n        enc_in = data ^ self.iv\n        self.encrypt(enc_in)\n        self.iv = data ^ self.data_out\n    \n    def CFB(self, data):\n        self.encrypt(self.iv)\n        self.iv = self.data_out ^ data\n        self.data_out = self.iv\n    \n    def OFB(self, data):\n        self.encrypt(self.iv)\n        self.iv = self.data_out\n        self.data_out = self.data_out ^ data\n    \n    def CTR(self, data):\n        enc_in = (self.iv & 0x0000FFFFFFFFFFFFFFFFFFFFFFFF0000) + (self.counter & 0x0000FFFF) + ((self.counter & 0xFFFF0000) << 96)\n        self.encrypt(enc_in)\n        if self.counter < 2**32 - 1:\n            self.counter = self.counter + 1\n        else:\n            self.counter = 0\n        \n        self.data_out = self.data_out ^ data\n", "src/test_aes_dec_top.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_plaintext.value.integer\n\n    model_data = model.data_out\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_plaintext  = {hex(dut_data)} \\nMODEL o_plaintext  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_plaintext does not match model o_plaintext: {hex(dut_data)} != {hex(model_data)}\"\n\ndef set_inputs(dut, reset_counter, update_iv, update_mode, update_key, mode, iv, ciphertext, key, start):\n    dut.i_reset_counter.value = reset_counter\n    dut.i_update_iv.value     = update_iv\n    dut.i_update_mode.value   = update_mode\n    dut.i_update_key.value    = update_key\n    dut.i_mode.value          = mode\n    dut.i_iv.value            = iv\n    dut.i_ciphertext.value    = ciphertext\n    dut.i_key.value           = key\n    dut.i_start.value         = start\n\n@cocotb.test()\nasync def test_aes_dec_top(dut):\n    \"\"\"Test the aes_dec_top module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    model = hrs_lb.aes_decrypt()\n\n    resets = 2\n    runs = 2\n    mode_runs = 200\n\n    data_min = 0\n    data_max = 2**128 - 1\n\n    key_min = 0\n    key_max = 2**256 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value  = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n        # After reset o_done must be 1\n        dut_done = dut.o_done.value\n        assert dut_done == 1,  f\"[ERROR] After reset, DUT o_done must be 1. The harness received o_done = {dut_done}\"\n\n        for j in range(runs):\n            print(f'\\n------ Reset {i}, run {j} ------')\n\n            print(\"ECB mode\")\n            mode       = 0\n            iv         = random.randint(data_min, data_max)\n            ciphertext = random.randint(data_min, data_max)\n            key        = random.randint(key_min , key_max )\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, ciphertext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, ciphertext, 0, 1)\n                \n                model.ECB(ciphertext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CBC mode\")\n            mode       = 1\n            iv         = random.randint(data_min, data_max)\n            ciphertext = random.randint(data_min, data_max)\n            key        = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, ciphertext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, ciphertext, 0, 1)\n                \n                model.CBC(ciphertext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"PCBC mode\")\n            mode       = 2\n            iv         = random.randint(data_min, data_max)\n            ciphertext = random.randint(data_min, data_max)\n            key        = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, ciphertext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, ciphertext, 0, 1)\n                \n                model.PCBC(ciphertext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CFB mode\")\n            mode       = 3\n            iv         = random.randint(data_min, data_max)\n            ciphertext = random.randint(data_min, data_max)\n            key        = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, ciphertext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, ciphertext, 0, 1)\n                \n                model.CFB(ciphertext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n\n            print(\"OFB mode\")\n            mode       = 4\n            iv         = random.randint(data_min, data_max)\n            ciphertext = random.randint(data_min, data_max)\n            key        = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, ciphertext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, ciphertext, 0, 1)\n                \n                model.OFB(ciphertext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CTR mode\")\n            mode       = 5\n            iv         = random.randint(data_min, data_max)\n            ciphertext = random.randint(data_min, data_max)\n            key        = random.randint(key_min , key_max )\n            \n            model.iv      = iv\n            model.counter = 0\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, ciphertext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, ciphertext, 0, 1)\n                \n                model.CTR(ciphertext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            ", "src/test_aes_enc_top.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_ciphertext.value.integer\n\n    model_data = model.data_out\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_ciphertext  = {hex(dut_data)} \\nMODEL o_ciphertext  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_ciphertext does not match model o_ciphertext: {hex(dut_data)} != {hex(model_data)}\"\n\ndef set_inputs(dut, reset_counter, update_iv, update_mode, update_key, mode, iv, plaintext, key, start):\n    dut.i_reset_counter.value = reset_counter\n    dut.i_update_iv.value     = update_iv\n    dut.i_update_mode.value   = update_mode\n    dut.i_update_key.value    = update_key\n    dut.i_mode.value          = mode\n    dut.i_iv.value            = iv\n    dut.i_plaintext.value     = plaintext\n    dut.i_key.value           = key\n    dut.i_start.value         = start\n\n@cocotb.test()\nasync def test_aes_enc_top(dut):\n    \"\"\"Test the aes_enc_top module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    model = hrs_lb.aes_encrypt()\n\n    resets = 2\n    runs = 2\n    mode_runs = 200\n\n    data_min = 0\n    data_max = 2**128 - 1\n\n    key_min = 0\n    key_max = 2**256 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value  = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n        # After reset o_done must be 1\n        dut_done = dut.o_done.value\n        assert dut_done == 1,  f\"[ERROR] After reset, DUT o_done must be 1. The harness received o_done = {dut_done}\"\n\n        for j in range(runs):\n            print(f'\\n------ Reset {i}, run {j} ------')\n\n            print(\"ECB mode\")\n            mode      = 0\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.ECB(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CBC mode\")\n            mode      = 1\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.CBC(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"PCBC mode\")\n            mode      = 2\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.PCBC(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CFB mode\")\n            mode      = 3\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.CFB(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n\n            print(\"OFB mode\")\n            mode      = 4\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.OFB(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CTR mode\")\n            mode      = 5\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv      = iv\n            model.counter = 0\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.CTR(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            ", "src/test_padding_top.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_data.value.integer\n\n    model_data = model.data_out\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\ndef set_inputs(dut, reset_counter, update_iv, update_mode, update_key, mode, iv, data, key, start, encrypt, update_padding, padding_mode, padding_bytes):\n    dut.i_reset_counter.value       = reset_counter\n    dut.i_update_iv.value           = update_iv\n    dut.i_update_mode.value         = update_mode\n    dut.i_update_key.value          = update_key\n    dut.i_mode.value                = mode\n    dut.i_iv.value                  = iv\n    dut.i_data.value                = data\n    dut.i_key.value                 = key\n    dut.i_start.value               = start\n    dut.i_encrypt.value             = encrypt\n    dut.i_update_padding_mode.value = update_padding\n    dut.i_padding_mode.value        = padding_mode\n    dut.i_padding_bytes.value       = padding_bytes\n\n@cocotb.test()\nasync def test_padding_top(dut):\n    \"\"\"Test the padding_top module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    W3C_BYTE = dut.W3C_BYTE.value.integer\n\n    model_enc = hrs_lb.aes_encrypt()\n    model_dec = hrs_lb.aes_decrypt()\n\n    resets = 2\n    runs = 2\n    mode_runs = 200\n\n    data_min = 0\n    data_max = 2**128 - 1\n\n    key_min = 0\n    key_max = 2**256 - 1\n\n    padd_min = 0\n    padd_max = 15\n\n    mode_min = 0\n    mode_max = 5\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value  = 1\n        await RisingEdge(dut.clk)\n\n        model_enc.reset()\n        model_dec.reset()\n\n        compare_values(dut, model_enc)\n        compare_values(dut, model_dec)\n        # After reset o_done must be 1\n        dut_done = dut.o_done.value\n        assert dut_done == 1,  f\"[ERROR] After reset, DUT o_done must be 1. The harness received o_done = {dut_done}\"\n\n        for j in range(runs):\n            print(f'\\n------ Reset {i}, run {j} ------')\n\n            print(\"Padding PKCS\")\n            encrypt = random.randint(0,1)\n            padding = random.randint(padd_min, padd_max)\n            mode    = random.randint(mode_min, mode_max)\n            iv      = random.randint(data_min, data_max)\n            data    = random.randint(data_min, data_max)\n            key     = random.randint(key_min , key_max )\n\n            # Set Counter, IV, mode and padding mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0, encrypt, 1, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            model_enc.counter = 0\n            model_dec.counter = 0\n            model_enc.iv      = iv\n            model_dec.iv      = iv\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, data, key, 1, encrypt, 0, 0, padding)\n                    model_enc.update_key(key)\n                    model_dec.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, data, 0, 1, encrypt, 0, 0, padding)\n                \n                model_enc.MODE(hrs_lb.PKCS(data, padding), mode)\n                model_dec.MODE(hrs_lb.PKCS(data, padding), mode)\n\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                if encrypt == 1:\n                    compare_values(dut, model_enc)\n                else:\n                    compare_values(dut, model_dec)\n\n\n            print(\"Padding OneAndZeroes\")\n            encrypt = random.randint(0,1)\n            padding = random.randint(padd_min, padd_max)\n            mode    = random.randint(mode_min, mode_max)\n            iv      = random.randint(data_min, data_max)\n            data    = random.randint(data_min, data_max)\n            key     = random.randint(key_min , key_max )\n\n            # Set Counter, IV, mode and padding mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0, encrypt, 1, 1, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            model_enc.counter = 0\n            model_dec.counter = 0\n            model_enc.iv      = iv\n            model_dec.iv      = iv\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, data, key, 1, encrypt, 0, 0, padding)\n                    model_enc.update_key(key)\n                    model_dec.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, data, 0, 1, encrypt, 0, 0, padding)\n                \n                model_enc.MODE(hrs_lb.OneAndZeroes(data, padding), mode)\n                model_dec.MODE(hrs_lb.OneAndZeroes(data, padding), mode)\n\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                if encrypt == 1:\n                    compare_values(dut, model_enc)\n                else:\n                    compare_values(dut, model_dec)\n            \n\n            print(\"Padding ANSIX923\")\n            encrypt = random.randint(0,1)\n            padding = random.randint(padd_min, padd_max)\n            mode    = random.randint(mode_min, mode_max)\n            iv      = random.randint(data_min, data_max)\n            data    = random.randint(data_min, data_max)\n            key     = random.randint(key_min , key_max )\n\n            # Set Counter, IV, mode and padding mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0, encrypt, 1, 2, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            model_enc.counter = 0\n            model_dec.counter = 0\n            model_enc.iv      = iv\n            model_dec.iv      = iv\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, data, key, 1, encrypt, 0, 0, padding)\n                    model_enc.update_key(key)\n                    model_dec.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, data, 0, 1, encrypt, 0, 0, padding)\n                \n                model_enc.MODE(hrs_lb.ANSIX923(data, padding), mode)\n                model_dec.MODE(hrs_lb.ANSIX923(data, padding), mode)\n\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                if encrypt == 1:\n                    compare_values(dut, model_enc)\n                else:\n                    compare_values(dut, model_dec)\n\n            print(\"Padding W3C\")\n            encrypt = random.randint(0,1)\n            padding = random.randint(padd_min, padd_max)\n            mode    = random.randint(mode_min, mode_max)\n            iv      = random.randint(data_min, data_max)\n            data    = random.randint(data_min, data_max)\n            key     = random.randint(key_min , key_max )\n\n            # Set Counter, IV, mode and padding mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0, encrypt, 1, 3, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            model_enc.counter = 0\n            model_dec.counter = 0\n            model_enc.iv      = iv\n            model_dec.iv      = iv\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, data, key, 1, encrypt, 0, 0, padding)\n                    model_enc.update_key(key)\n                    model_dec.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, data, 0, 1, encrypt, 0, 0, padding)\n\n                model_enc.MODE(hrs_lb.W3C(data, padding, W3C_BYTE), mode)\n                model_dec.MODE(hrs_lb.W3C(data, padding, W3C_BYTE), mode)\n\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0, encrypt, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                if encrypt == 1:\n                    compare_values(dut, model_enc)\n                else:\n                    compare_values(dut, model_dec)", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()", "src/test_runner_dec_top.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()", "src/test_runner_enc_top.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_DES_0005", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"line_number s/old_statement/new_statement/\" file.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "Integrate the `des_enc` and `des_dec` modules to perform the Triple Data Encryption Standard (TDES) encryption. This new module must allow burst operation, where in multiple cycles in a row the valid signal can be asserted with a new data and a new key. No changes are required in any of the RTLs provided. A testbench for this module is available at `verif/tb_3des_enc.sv`.\n\n---\n\n## Specifications\n\n- **Module Name**: `des3_enc`\n\n- **File Name**: `des3_enc.sv` (to be added in `rtl` directory)\n\n- **Parameters**:\n    - `NBW_DATA`: Bit width of the input and output data blocks.\n        - Default: 64.\n        - Related interface signals: `i_data`, `o_data`.\n    - `NBW_KEY`: Bit width of the key.\n        - Default: 192.\n        - Related interface signal: `i_key`.  \n        - The 192-bit key is interpreted as three concatenated 64-bit DES keys (K1, K2, K3) used for Triple DES encryption, where `K1 = i_key[1:64]`, K2 = `i_key[65:128]`, and `K3 = i_key[129:192]`.\n\n- **Functionality**: Implements 3DES encryption in EDE (Encrypt-Decrypt-Encrypt) mode using three 64-bit keys (K1, K2, K3). The input plaintext is encrypted with K1, decrypted with K2, and encrypted again with K3.\n\n- **Latency**: The block's latency, from when `i_valid` is read until `o_valid` is asserted, is **48 cycles**, where each DES stage takes 16 cycles and the process is fully pipelined.\n\n---\n\n## Interface Signals\n\n  | Signal              | Direction | Width            | Description                                                                                                              |\n  |---------------------|-----------|------------------|---------------------------------------------------------------------------------------------------------------------     |\n  | `clk`               | Input     | 1                | Drives the sequential logic on the rising edge.                                                                          |\n  | `rst_async_n`       | Input     | 1                | Active-low asynchronous reset; clears all internal registers and state.                                                  |\n  | `i_valid`           | Input     | 1                | Active high. Indicates that `i_data` and `i_key` are valid and ready to be processed.                                    |\n  | `i_data`            | Input     | [1:NBW_DATA]     | 64-bit plaintext input block (MSB-first).                                                                                |\n  | `i_key`             | Input     | [1:NBW_KEY]      | 192-bit 3DES key, treated as three concatenated 64-bit keys: `{K1, K2, K3}`.                                             |\n  | `o_valid`           | Output    | 1                | Asserted high when `o_data` contains valid encrypted data. It is asserted for as many cycles as `i_valid` is asserted.   |\n  | `o_data`            | Output    | [1:NBW_DATA]     | 64-bit ciphertext output block (MSB-first).                                                                              |\n\n", "context": {"rtl/S1.sv": "module S1(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd14;\n        6'b0_0001_0 : o_data = 4'd4;\n        6'b0_0010_0 : o_data = 4'd13;\n        6'b0_0011_0 : o_data = 4'd1;\n        6'b0_0100_0 : o_data = 4'd2;\n        6'b0_0101_0 : o_data = 4'd15;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd8;\n        6'b0_1000_0 : o_data = 4'd3;\n        6'b0_1001_0 : o_data = 4'd10;\n        6'b0_1010_0 : o_data = 4'd6;\n        6'b0_1011_0 : o_data = 4'd12;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd9;\n        6'b0_1110_0 : o_data = 4'd0;\n        6'b0_1111_0 : o_data = 4'd7;\n        6'b0_0000_1 : o_data = 4'd0;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd7;\n        6'b0_0011_1 : o_data = 4'd4;\n        6'b0_0100_1 : o_data = 4'd14;\n        6'b0_0101_1 : o_data = 4'd2;\n        6'b0_0110_1 : o_data = 4'd13;\n        6'b0_0111_1 : o_data = 4'd1;\n        6'b0_1000_1 : o_data = 4'd10;\n        6'b0_1001_1 : o_data = 4'd6;\n        6'b0_1010_1 : o_data = 4'd12;\n        6'b0_1011_1 : o_data = 4'd11;\n        6'b0_1100_1 : o_data = 4'd9;\n        6'b0_1101_1 : o_data = 4'd5;\n        6'b0_1110_1 : o_data = 4'd3;\n        6'b0_1111_1 : o_data = 4'd8;\n        6'b1_0000_0 : o_data = 4'd4;\n        6'b1_0001_0 : o_data = 4'd1;\n        6'b1_0010_0 : o_data = 4'd14;\n        6'b1_0011_0 : o_data = 4'd8;\n        6'b1_0100_0 : o_data = 4'd13;\n        6'b1_0101_0 : o_data = 4'd6;\n        6'b1_0110_0 : o_data = 4'd2;\n        6'b1_0111_0 : o_data = 4'd11;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd12;\n        6'b1_1010_0 : o_data = 4'd9;\n        6'b1_1011_0 : o_data = 4'd7;\n        6'b1_1100_0 : o_data = 4'd3;\n        6'b1_1101_0 : o_data = 4'd10;\n        6'b1_1110_0 : o_data = 4'd5;\n        6'b1_1111_0 : o_data = 4'd0;\n        6'b1_0000_1 : o_data = 4'd15;\n        6'b1_0001_1 : o_data = 4'd12;\n        6'b1_0010_1 : o_data = 4'd8;\n        6'b1_0011_1 : o_data = 4'd2;\n        6'b1_0100_1 : o_data = 4'd4;\n        6'b1_0101_1 : o_data = 4'd9;\n        6'b1_0110_1 : o_data = 4'd1;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd5;\n        6'b1_1001_1 : o_data = 4'd11;\n        6'b1_1010_1 : o_data = 4'd3;\n        6'b1_1011_1 : o_data = 4'd14;\n        6'b1_1100_1 : o_data = 4'd10;\n        6'b1_1101_1 : o_data = 4'd0;\n        6'b1_1110_1 : o_data = 4'd6;\n        6'b1_1111_1 : o_data = 4'd13;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S1", "rtl/S2.sv": "module S2(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd15;\n        6'b0_0001_0 : o_data = 4'd1;\n        6'b0_0010_0 : o_data = 4'd8;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd11;\n        6'b0_0110_0 : o_data = 4'd3;\n        6'b0_0111_0 : o_data = 4'd4;\n        6'b0_1000_0 : o_data = 4'd9;\n        6'b0_1001_0 : o_data = 4'd7;\n        6'b0_1010_0 : o_data = 4'd2;\n        6'b0_1011_0 : o_data = 4'd13;\n        6'b0_1100_0 : o_data = 4'd12;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd5;\n        6'b0_1111_0 : o_data = 4'd10;\n        6'b0_0000_1 : o_data = 4'd3;\n        6'b0_0001_1 : o_data = 4'd13;\n        6'b0_0010_1 : o_data = 4'd4;\n        6'b0_0011_1 : o_data = 4'd7;\n        6'b0_0100_1 : o_data = 4'd15;\n        6'b0_0101_1 : o_data = 4'd2;\n        6'b0_0110_1 : o_data = 4'd8;\n        6'b0_0111_1 : o_data = 4'd14;\n        6'b0_1000_1 : o_data = 4'd12;\n        6'b0_1001_1 : o_data = 4'd0;\n        6'b0_1010_1 : o_data = 4'd1;\n        6'b0_1011_1 : o_data = 4'd10;\n        6'b0_1100_1 : o_data = 4'd6;\n        6'b0_1101_1 : o_data = 4'd9;\n        6'b0_1110_1 : o_data = 4'd11;\n        6'b0_1111_1 : o_data = 4'd5;\n        6'b1_0000_0 : o_data = 4'd0;\n        6'b1_0001_0 : o_data = 4'd14;\n        6'b1_0010_0 : o_data = 4'd7;\n        6'b1_0011_0 : o_data = 4'd11;\n        6'b1_0100_0 : o_data = 4'd10;\n        6'b1_0101_0 : o_data = 4'd4;\n        6'b1_0110_0 : o_data = 4'd13;\n        6'b1_0111_0 : o_data = 4'd1;\n        6'b1_1000_0 : o_data = 4'd5;\n        6'b1_1001_0 : o_data = 4'd8;\n        6'b1_1010_0 : o_data = 4'd12;\n        6'b1_1011_0 : o_data = 4'd6;\n        6'b1_1100_0 : o_data = 4'd9;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd2;\n        6'b1_1111_0 : o_data = 4'd15;\n        6'b1_0000_1 : o_data = 4'd13;\n        6'b1_0001_1 : o_data = 4'd8;\n        6'b1_0010_1 : o_data = 4'd10;\n        6'b1_0011_1 : o_data = 4'd1;\n        6'b1_0100_1 : o_data = 4'd3;\n        6'b1_0101_1 : o_data = 4'd15;\n        6'b1_0110_1 : o_data = 4'd4;\n        6'b1_0111_1 : o_data = 4'd2;\n        6'b1_1000_1 : o_data = 4'd11;\n        6'b1_1001_1 : o_data = 4'd6;\n        6'b1_1010_1 : o_data = 4'd7;\n        6'b1_1011_1 : o_data = 4'd12;\n        6'b1_1100_1 : o_data = 4'd0;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd14;\n        6'b1_1111_1 : o_data = 4'd9;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S2", "rtl/S3.sv": "module S3(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd10;\n        6'b0_0001_0 : o_data = 4'd0;\n        6'b0_0010_0 : o_data = 4'd9;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd3;\n        6'b0_0110_0 : o_data = 4'd15;\n        6'b0_0111_0 : o_data = 4'd5;\n        6'b0_1000_0 : o_data = 4'd1;\n        6'b0_1001_0 : o_data = 4'd13;\n        6'b0_1010_0 : o_data = 4'd12;\n        6'b0_1011_0 : o_data = 4'd7;\n        6'b0_1100_0 : o_data = 4'd11;\n        6'b0_1101_0 : o_data = 4'd4;\n        6'b0_1110_0 : o_data = 4'd2;\n        6'b0_1111_0 : o_data = 4'd8;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd7;\n        6'b0_0010_1 : o_data = 4'd0;\n        6'b0_0011_1 : o_data = 4'd9;\n        6'b0_0100_1 : o_data = 4'd3;\n        6'b0_0101_1 : o_data = 4'd4;\n        6'b0_0110_1 : o_data = 4'd6;\n        6'b0_0111_1 : o_data = 4'd10;\n        6'b0_1000_1 : o_data = 4'd2;\n        6'b0_1001_1 : o_data = 4'd8;\n        6'b0_1010_1 : o_data = 4'd5;\n        6'b0_1011_1 : o_data = 4'd14;\n        6'b0_1100_1 : o_data = 4'd12;\n        6'b0_1101_1 : o_data = 4'd11;\n        6'b0_1110_1 : o_data = 4'd15;\n        6'b0_1111_1 : o_data = 4'd1;\n        6'b1_0000_0 : o_data = 4'd13;\n        6'b1_0001_0 : o_data = 4'd6;\n        6'b1_0010_0 : o_data = 4'd4;\n        6'b1_0011_0 : o_data = 4'd9;\n        6'b1_0100_0 : o_data = 4'd8;\n        6'b1_0101_0 : o_data = 4'd15;\n        6'b1_0110_0 : o_data = 4'd3;\n        6'b1_0111_0 : o_data = 4'd0;\n        6'b1_1000_0 : o_data = 4'd11;\n        6'b1_1001_0 : o_data = 4'd1;\n        6'b1_1010_0 : o_data = 4'd2;\n        6'b1_1011_0 : o_data = 4'd12;\n        6'b1_1100_0 : o_data = 4'd5;\n        6'b1_1101_0 : o_data = 4'd10;\n        6'b1_1110_0 : o_data = 4'd14;\n        6'b1_1111_0 : o_data = 4'd7;\n        6'b1_0000_1 : o_data = 4'd1;\n        6'b1_0001_1 : o_data = 4'd10;\n        6'b1_0010_1 : o_data = 4'd13;\n        6'b1_0011_1 : o_data = 4'd0;\n        6'b1_0100_1 : o_data = 4'd6;\n        6'b1_0101_1 : o_data = 4'd9;\n        6'b1_0110_1 : o_data = 4'd8;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd4;\n        6'b1_1001_1 : o_data = 4'd15;\n        6'b1_1010_1 : o_data = 4'd14;\n        6'b1_1011_1 : o_data = 4'd3;\n        6'b1_1100_1 : o_data = 4'd11;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd2;\n        6'b1_1111_1 : o_data = 4'd12;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S3", "rtl/S4.sv": "module S4(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd7;\n        6'b0_0001_0 : o_data = 4'd13;\n        6'b0_0010_0 : o_data = 4'd14;\n        6'b0_0011_0 : o_data = 4'd3;\n        6'b0_0100_0 : o_data = 4'd0;\n        6'b0_0101_0 : o_data = 4'd6;\n        6'b0_0110_0 : o_data = 4'd9;\n        6'b0_0111_0 : o_data = 4'd10;\n        6'b0_1000_0 : o_data = 4'd1;\n        6'b0_1001_0 : o_data = 4'd2;\n        6'b0_1010_0 : o_data = 4'd8;\n        6'b0_1011_0 : o_data = 4'd5;\n        6'b0_1100_0 : o_data = 4'd11;\n        6'b0_1101_0 : o_data = 4'd12;\n        6'b0_1110_0 : o_data = 4'd4;\n        6'b0_1111_0 : o_data = 4'd15;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd8;\n        6'b0_0010_1 : o_data = 4'd11;\n        6'b0_0011_1 : o_data = 4'd5;\n        6'b0_0100_1 : o_data = 4'd6;\n        6'b0_0101_1 : o_data = 4'd15;\n        6'b0_0110_1 : o_data = 4'd0;\n        6'b0_0111_1 : o_data = 4'd3;\n        6'b0_1000_1 : o_data = 4'd4;\n        6'b0_1001_1 : o_data = 4'd7;\n        6'b0_1010_1 : o_data = 4'd2;\n        6'b0_1011_1 : o_data = 4'd12;\n        6'b0_1100_1 : o_data = 4'd1;\n        6'b0_1101_1 : o_data = 4'd10;\n        6'b0_1110_1 : o_data = 4'd14;\n        6'b0_1111_1 : o_data = 4'd9;\n        6'b1_0000_0 : o_data = 4'd10;\n        6'b1_0001_0 : o_data = 4'd6;\n        6'b1_0010_0 : o_data = 4'd9;\n        6'b1_0011_0 : o_data = 4'd0;\n        6'b1_0100_0 : o_data = 4'd12;\n        6'b1_0101_0 : o_data = 4'd11;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd13;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd1;\n        6'b1_1010_0 : o_data = 4'd3;\n        6'b1_1011_0 : o_data = 4'd14;\n        6'b1_1100_0 : o_data = 4'd5;\n        6'b1_1101_0 : o_data = 4'd2;\n        6'b1_1110_0 : o_data = 4'd8;\n        6'b1_1111_0 : o_data = 4'd4;\n        6'b1_0000_1 : o_data = 4'd3;\n        6'b1_0001_1 : o_data = 4'd15;\n        6'b1_0010_1 : o_data = 4'd0;\n        6'b1_0011_1 : o_data = 4'd6;\n        6'b1_0100_1 : o_data = 4'd10;\n        6'b1_0101_1 : o_data = 4'd1;\n        6'b1_0110_1 : o_data = 4'd13;\n        6'b1_0111_1 : o_data = 4'd8;\n        6'b1_1000_1 : o_data = 4'd9;\n        6'b1_1001_1 : o_data = 4'd4;\n        6'b1_1010_1 : o_data = 4'd5;\n        6'b1_1011_1 : o_data = 4'd11;\n        6'b1_1100_1 : o_data = 4'd12;\n        6'b1_1101_1 : o_data = 4'd7;\n        6'b1_1110_1 : o_data = 4'd2;\n        6'b1_1111_1 : o_data = 4'd14;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S4", "rtl/S5.sv": "module S5(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd2;\n        6'b0_0001_0 : o_data = 4'd12;\n        6'b0_0010_0 : o_data = 4'd4;\n        6'b0_0011_0 : o_data = 4'd1;\n        6'b0_0100_0 : o_data = 4'd7;\n        6'b0_0101_0 : o_data = 4'd10;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd6;\n        6'b0_1000_0 : o_data = 4'd8;\n        6'b0_1001_0 : o_data = 4'd5;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd15;\n        6'b0_1100_0 : o_data = 4'd13;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd14;\n        6'b0_1111_0 : o_data = 4'd9;\n        6'b0_0000_1 : o_data = 4'd14;\n        6'b0_0001_1 : o_data = 4'd11;\n        6'b0_0010_1 : o_data = 4'd2;\n        6'b0_0011_1 : o_data = 4'd12;\n        6'b0_0100_1 : o_data = 4'd4;\n        6'b0_0101_1 : o_data = 4'd7;\n        6'b0_0110_1 : o_data = 4'd13;\n        6'b0_0111_1 : o_data = 4'd1;\n        6'b0_1000_1 : o_data = 4'd5;\n        6'b0_1001_1 : o_data = 4'd0;\n        6'b0_1010_1 : o_data = 4'd15;\n        6'b0_1011_1 : o_data = 4'd10;\n        6'b0_1100_1 : o_data = 4'd3;\n        6'b0_1101_1 : o_data = 4'd9;\n        6'b0_1110_1 : o_data = 4'd8;\n        6'b0_1111_1 : o_data = 4'd6;\n        6'b1_0000_0 : o_data = 4'd4;\n        6'b1_0001_0 : o_data = 4'd2;\n        6'b1_0010_0 : o_data = 4'd1;\n        6'b1_0011_0 : o_data = 4'd11;\n        6'b1_0100_0 : o_data = 4'd10;\n        6'b1_0101_0 : o_data = 4'd13;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd8;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd9;\n        6'b1_1010_0 : o_data = 4'd12;\n        6'b1_1011_0 : o_data = 4'd5;\n        6'b1_1100_0 : o_data = 4'd6;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd0;\n        6'b1_1111_0 : o_data = 4'd14;\n        6'b1_0000_1 : o_data = 4'd11;\n        6'b1_0001_1 : o_data = 4'd8;\n        6'b1_0010_1 : o_data = 4'd12;\n        6'b1_0011_1 : o_data = 4'd7;\n        6'b1_0100_1 : o_data = 4'd1;\n        6'b1_0101_1 : o_data = 4'd14;\n        6'b1_0110_1 : o_data = 4'd2;\n        6'b1_0111_1 : o_data = 4'd13;\n        6'b1_1000_1 : o_data = 4'd6;\n        6'b1_1001_1 : o_data = 4'd15;\n        6'b1_1010_1 : o_data = 4'd0;\n        6'b1_1011_1 : o_data = 4'd9;\n        6'b1_1100_1 : o_data = 4'd10;\n        6'b1_1101_1 : o_data = 4'd4;\n        6'b1_1110_1 : o_data = 4'd5;\n        6'b1_1111_1 : o_data = 4'd3;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S5", "rtl/S6.sv": "module S6(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd12;\n        6'b0_0001_0 : o_data = 4'd1;\n        6'b0_0010_0 : o_data = 4'd10;\n        6'b0_0011_0 : o_data = 4'd15;\n        6'b0_0100_0 : o_data = 4'd9;\n        6'b0_0101_0 : o_data = 4'd2;\n        6'b0_0110_0 : o_data = 4'd6;\n        6'b0_0111_0 : o_data = 4'd8;\n        6'b0_1000_0 : o_data = 4'd0;\n        6'b0_1001_0 : o_data = 4'd13;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd4;\n        6'b0_1100_0 : o_data = 4'd14;\n        6'b0_1101_0 : o_data = 4'd7;\n        6'b0_1110_0 : o_data = 4'd5;\n        6'b0_1111_0 : o_data = 4'd11;\n        6'b0_0000_1 : o_data = 4'd10;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd4;\n        6'b0_0011_1 : o_data = 4'd2;\n        6'b0_0100_1 : o_data = 4'd7;\n        6'b0_0101_1 : o_data = 4'd12;\n        6'b0_0110_1 : o_data = 4'd9;\n        6'b0_0111_1 : o_data = 4'd5;\n        6'b0_1000_1 : o_data = 4'd6;\n        6'b0_1001_1 : o_data = 4'd1;\n        6'b0_1010_1 : o_data = 4'd13;\n        6'b0_1011_1 : o_data = 4'd14;\n        6'b0_1100_1 : o_data = 4'd0;\n        6'b0_1101_1 : o_data = 4'd11;\n        6'b0_1110_1 : o_data = 4'd3;\n        6'b0_1111_1 : o_data = 4'd8;\n        6'b1_0000_0 : o_data = 4'd9;\n        6'b1_0001_0 : o_data = 4'd14;\n        6'b1_0010_0 : o_data = 4'd15;\n        6'b1_0011_0 : o_data = 4'd5;\n        6'b1_0100_0 : o_data = 4'd2;\n        6'b1_0101_0 : o_data = 4'd8;\n        6'b1_0110_0 : o_data = 4'd12;\n        6'b1_0111_0 : o_data = 4'd3;\n        6'b1_1000_0 : o_data = 4'd7;\n        6'b1_1001_0 : o_data = 4'd0;\n        6'b1_1010_0 : o_data = 4'd4;\n        6'b1_1011_0 : o_data = 4'd10;\n        6'b1_1100_0 : o_data = 4'd1;\n        6'b1_1101_0 : o_data = 4'd13;\n        6'b1_1110_0 : o_data = 4'd11;\n        6'b1_1111_0 : o_data = 4'd6;\n        6'b1_0000_1 : o_data = 4'd4;\n        6'b1_0001_1 : o_data = 4'd3;\n        6'b1_0010_1 : o_data = 4'd2;\n        6'b1_0011_1 : o_data = 4'd12;\n        6'b1_0100_1 : o_data = 4'd9;\n        6'b1_0101_1 : o_data = 4'd5;\n        6'b1_0110_1 : o_data = 4'd15;\n        6'b1_0111_1 : o_data = 4'd10;\n        6'b1_1000_1 : o_data = 4'd11;\n        6'b1_1001_1 : o_data = 4'd14;\n        6'b1_1010_1 : o_data = 4'd1;\n        6'b1_1011_1 : o_data = 4'd7;\n        6'b1_1100_1 : o_data = 4'd6;\n        6'b1_1101_1 : o_data = 4'd0;\n        6'b1_1110_1 : o_data = 4'd8;\n        6'b1_1111_1 : o_data = 4'd13;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S6", "rtl/S7.sv": "module S7(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd4;\n        6'b0_0001_0 : o_data = 4'd11;\n        6'b0_0010_0 : o_data = 4'd2;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd15;\n        6'b0_0101_0 : o_data = 4'd0;\n        6'b0_0110_0 : o_data = 4'd8;\n        6'b0_0111_0 : o_data = 4'd13;\n        6'b0_1000_0 : o_data = 4'd3;\n        6'b0_1001_0 : o_data = 4'd12;\n        6'b0_1010_0 : o_data = 4'd9;\n        6'b0_1011_0 : o_data = 4'd7;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd10;\n        6'b0_1110_0 : o_data = 4'd6;\n        6'b0_1111_0 : o_data = 4'd1;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd0;\n        6'b0_0010_1 : o_data = 4'd11;\n        6'b0_0011_1 : o_data = 4'd7;\n        6'b0_0100_1 : o_data = 4'd4;\n        6'b0_0101_1 : o_data = 4'd9;\n        6'b0_0110_1 : o_data = 4'd1;\n        6'b0_0111_1 : o_data = 4'd10;\n        6'b0_1000_1 : o_data = 4'd14;\n        6'b0_1001_1 : o_data = 4'd3;\n        6'b0_1010_1 : o_data = 4'd5;\n        6'b0_1011_1 : o_data = 4'd12;\n        6'b0_1100_1 : o_data = 4'd2;\n        6'b0_1101_1 : o_data = 4'd15;\n        6'b0_1110_1 : o_data = 4'd8;\n        6'b0_1111_1 : o_data = 4'd6;\n        6'b1_0000_0 : o_data = 4'd1;\n        6'b1_0001_0 : o_data = 4'd4;\n        6'b1_0010_0 : o_data = 4'd11;\n        6'b1_0011_0 : o_data = 4'd13;\n        6'b1_0100_0 : o_data = 4'd12;\n        6'b1_0101_0 : o_data = 4'd3;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd14;\n        6'b1_1000_0 : o_data = 4'd10;\n        6'b1_1001_0 : o_data = 4'd15;\n        6'b1_1010_0 : o_data = 4'd6;\n        6'b1_1011_0 : o_data = 4'd8;\n        6'b1_1100_0 : o_data = 4'd0;\n        6'b1_1101_0 : o_data = 4'd5;\n        6'b1_1110_0 : o_data = 4'd9;\n        6'b1_1111_0 : o_data = 4'd2;\n        6'b1_0000_1 : o_data = 4'd6;\n        6'b1_0001_1 : o_data = 4'd11;\n        6'b1_0010_1 : o_data = 4'd13;\n        6'b1_0011_1 : o_data = 4'd8;\n        6'b1_0100_1 : o_data = 4'd1;\n        6'b1_0101_1 : o_data = 4'd4;\n        6'b1_0110_1 : o_data = 4'd10;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd9;\n        6'b1_1001_1 : o_data = 4'd5;\n        6'b1_1010_1 : o_data = 4'd0;\n        6'b1_1011_1 : o_data = 4'd15;\n        6'b1_1100_1 : o_data = 4'd14;\n        6'b1_1101_1 : o_data = 4'd2;\n        6'b1_1110_1 : o_data = 4'd3;\n        6'b1_1111_1 : o_data = 4'd12;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S7", "rtl/S8.sv": "module S8(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd13;\n        6'b0_0001_0 : o_data = 4'd2;\n        6'b0_0010_0 : o_data = 4'd8;\n        6'b0_0011_0 : o_data = 4'd4;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd15;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd1;\n        6'b0_1000_0 : o_data = 4'd10;\n        6'b0_1001_0 : o_data = 4'd9;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd14;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd12;\n        6'b0_1111_0 : o_data = 4'd7;\n        6'b0_0000_1 : o_data = 4'd1;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd13;\n        6'b0_0011_1 : o_data = 4'd8;\n        6'b0_0100_1 : o_data = 4'd10;\n        6'b0_0101_1 : o_data = 4'd3;\n        6'b0_0110_1 : o_data = 4'd7;\n        6'b0_0111_1 : o_data = 4'd4;\n        6'b0_1000_1 : o_data = 4'd12;\n        6'b0_1001_1 : o_data = 4'd5;\n        6'b0_1010_1 : o_data = 4'd6;\n        6'b0_1011_1 : o_data = 4'd11;\n        6'b0_1100_1 : o_data = 4'd0;\n        6'b0_1101_1 : o_data = 4'd14;\n        6'b0_1110_1 : o_data = 4'd9;\n        6'b0_1111_1 : o_data = 4'd2;\n        6'b1_0000_0 : o_data = 4'd7;\n        6'b1_0001_0 : o_data = 4'd11;\n        6'b1_0010_0 : o_data = 4'd4;\n        6'b1_0011_0 : o_data = 4'd1;\n        6'b1_0100_0 : o_data = 4'd9;\n        6'b1_0101_0 : o_data = 4'd12;\n        6'b1_0110_0 : o_data = 4'd14;\n        6'b1_0111_0 : o_data = 4'd2;\n        6'b1_1000_0 : o_data = 4'd0;\n        6'b1_1001_0 : o_data = 4'd6;\n        6'b1_1010_0 : o_data = 4'd10;\n        6'b1_1011_0 : o_data = 4'd13;\n        6'b1_1100_0 : o_data = 4'd15;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd5;\n        6'b1_1111_0 : o_data = 4'd8;\n        6'b1_0000_1 : o_data = 4'd2;\n        6'b1_0001_1 : o_data = 4'd1;\n        6'b1_0010_1 : o_data = 4'd14;\n        6'b1_0011_1 : o_data = 4'd7;\n        6'b1_0100_1 : o_data = 4'd4;\n        6'b1_0101_1 : o_data = 4'd10;\n        6'b1_0110_1 : o_data = 4'd8;\n        6'b1_0111_1 : o_data = 4'd13;\n        6'b1_1000_1 : o_data = 4'd15;\n        6'b1_1001_1 : o_data = 4'd12;\n        6'b1_1010_1 : o_data = 4'd9;\n        6'b1_1011_1 : o_data = 4'd0;\n        6'b1_1100_1 : o_data = 4'd3;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd6;\n        6'b1_1111_1 : o_data = 4'd11;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S8", "rtl/des_dec.sv": "module des_dec #(\n    parameter NBW_DATA = 'd64,\n    parameter NBW_KEY  = 'd64\n) (\n    input  logic              clk,\n    input  logic              rst_async_n,\n    input  logic              i_valid,\n    input  logic [1:NBW_DATA] i_data,\n    input  logic [1:NBW_KEY]  i_key,\n    output logic              o_valid,\n    output logic [1:NBW_DATA] o_data\n);\n\nlocalparam ROUNDS = 'd16;\nlocalparam EXPANDED_BLOCK = 'd48;\nlocalparam USED_KEY = 'd56;\n\nlogic [1:(NBW_DATA/2)] L16;\nlogic [1:(NBW_DATA/2)] R16;\nlogic [1:(NBW_DATA/2)] L_ff [0:ROUNDS-1];\nlogic [1:(NBW_DATA/2)] R_ff [0:ROUNDS-1];\nlogic [1:(USED_KEY/2)] C16;\nlogic [1:(USED_KEY/2)] D16;\nlogic [1:(USED_KEY/2)] C_ff [0:ROUNDS-1];\nlogic [1:(USED_KEY/2)] D_ff [0:ROUNDS-1];\nlogic [1:NBW_DATA]     last_perm;\nlogic [ROUNDS-1:0]     valid_ff;\n\nalways_ff @ (posedge clk or negedge rst_async_n) begin\n    if(!rst_async_n) begin\n        valid_ff <= 0;\n    end else begin\n        valid_ff <= {valid_ff[ROUNDS-2:0], i_valid};\n    end\nend\n\nassign o_valid = valid_ff[ROUNDS-1];\n\nassign R16 = {i_data[58], i_data[50], i_data[42], i_data[34], i_data[26], i_data[18], i_data[10], i_data[2],\n              i_data[60], i_data[52], i_data[44], i_data[36], i_data[28], i_data[20], i_data[12], i_data[4],\n              i_data[62], i_data[54], i_data[46], i_data[38], i_data[30], i_data[22], i_data[14], i_data[6],\n              i_data[64], i_data[56], i_data[48], i_data[40], i_data[32], i_data[24], i_data[16], i_data[8]};\n\nassign L16 = {i_data[57], i_data[49], i_data[41], i_data[33], i_data[25], i_data[17], i_data[ 9], i_data[1],\n              i_data[59], i_data[51], i_data[43], i_data[35], i_data[27], i_data[19], i_data[11], i_data[3],\n              i_data[61], i_data[53], i_data[45], i_data[37], i_data[29], i_data[21], i_data[13], i_data[5],\n              i_data[63], i_data[55], i_data[47], i_data[39], i_data[31], i_data[23], i_data[15], i_data[7]};\n\nassign C16 = {i_key[57], i_key[49], i_key[41], i_key[33], i_key[25], i_key[17], i_key[ 9],\n              i_key[ 1], i_key[58], i_key[50], i_key[42], i_key[34], i_key[26], i_key[18],\n              i_key[10], i_key[ 2], i_key[59], i_key[51], i_key[43], i_key[35], i_key[27],\n              i_key[19], i_key[11], i_key[ 3], i_key[60], i_key[52], i_key[44], i_key[36]};\n\nassign D16 = {i_key[63], i_key[55], i_key[47], i_key[39], i_key[31], i_key[23], i_key[15],\n              i_key[ 7], i_key[62], i_key[54], i_key[46], i_key[38], i_key[30], i_key[22],\n              i_key[14], i_key[ 6], i_key[61], i_key[53], i_key[45], i_key[37], i_key[29],\n              i_key[21], i_key[13], i_key[ 5], i_key[28], i_key[20], i_key[12], i_key[ 4]};\n\ngenerate\n    for (genvar i = ROUNDS-1; i >= 0; i--) begin : rounds\n        logic [1:EXPANDED_BLOCK] round_key;\n        logic [1:(USED_KEY/2)]   C_nx;\n        logic [1:(USED_KEY/2)]   D_nx;\n        logic [1:USED_KEY]       perm_ch;\n        logic [1:(NBW_DATA/2)]   L_nx;\n        logic [1:EXPANDED_BLOCK] L_expanded;\n        logic [1:6]              Primitive_input  [1:8];\n        logic [1:4]              Primitive_output [1:8];\n        logic [1:(NBW_DATA/2)]   perm_in;\n\n        if(i == 15) begin\n            assign perm_ch = {C16, D16};\n        end else begin\n            assign perm_ch = {C_ff[i+1], D_ff[i+1]};\n        end\n        assign round_key = {perm_ch[14], perm_ch[17], perm_ch[11], perm_ch[24], perm_ch[ 1], perm_ch[ 5],\n                            perm_ch[ 3], perm_ch[28], perm_ch[15], perm_ch[ 6], perm_ch[21], perm_ch[10],\n                            perm_ch[23], perm_ch[19], perm_ch[12], perm_ch[ 4], perm_ch[26], perm_ch[ 8],\n                            perm_ch[16], perm_ch[ 7], perm_ch[27], perm_ch[20], perm_ch[13], perm_ch[ 2],\n                            perm_ch[41], perm_ch[52], perm_ch[31], perm_ch[37], perm_ch[47], perm_ch[55],\n                            perm_ch[30], perm_ch[40], perm_ch[51], perm_ch[45], perm_ch[33], perm_ch[48],\n                            perm_ch[44], perm_ch[49], perm_ch[39], perm_ch[56], perm_ch[34], perm_ch[53],\n                            perm_ch[46], perm_ch[42], perm_ch[50], perm_ch[36], perm_ch[29], perm_ch[32]};\n\n        if(i == 0 || i == 1 || i == 8 || i == 15) begin\n            if(i == 15) begin\n                assign C_nx = {C16[(USED_KEY/2)], C16[1:(USED_KEY/2)-1]};\n                assign D_nx = {D16[(USED_KEY/2)], D16[1:(USED_KEY/2)-1]};\n            end else begin\n                assign C_nx = {C_ff[i+1][(USED_KEY/2)], C_ff[i+1][1:(USED_KEY/2)-1]};\n                assign D_nx = {D_ff[i+1][(USED_KEY/2)], D_ff[i+1][1:(USED_KEY/2)-1]};\n            end\n        end else begin\n            assign C_nx = {C_ff[i+1][(USED_KEY/2)-1+:2], C_ff[i+1][1:(USED_KEY/2)-2]};\n            assign D_nx = {D_ff[i+1][(USED_KEY/2)-1+:2], D_ff[i+1][1:(USED_KEY/2)-2]};\n        end\n\n        assign Primitive_input[1] = L_expanded[ 1:6 ] ^ round_key[ 1:6 ];\n        assign Primitive_input[2] = L_expanded[ 7:12] ^ round_key[ 7:12];\n        assign Primitive_input[3] = L_expanded[13:18] ^ round_key[13:18];\n        assign Primitive_input[4] = L_expanded[19:24] ^ round_key[19:24];\n        assign Primitive_input[5] = L_expanded[25:30] ^ round_key[25:30];\n        assign Primitive_input[6] = L_expanded[31:36] ^ round_key[31:36];\n        assign Primitive_input[7] = L_expanded[37:42] ^ round_key[37:42];\n        assign Primitive_input[8] = L_expanded[43:48] ^ round_key[43:48];\n\n        S1 uu_S1 (\n            .i_data(Primitive_input [1]),\n            .o_data(Primitive_output[1])\n        );\n\n        S2 uu_S2 (\n            .i_data(Primitive_input [2]),\n            .o_data(Primitive_output[2])\n        );\n\n        S3 uu_S3 (\n            .i_data(Primitive_input [3]),\n            .o_data(Primitive_output[3])\n        );\n\n        S4 uu_S4 (\n            .i_data(Primitive_input [4]),\n            .o_data(Primitive_output[4])\n        );\n\n        S5 uu_S5 (\n            .i_data(Primitive_input [5]),\n            .o_data(Primitive_output[5])\n        );\n\n        S6 uu_S6 (\n            .i_data(Primitive_input [6]),\n            .o_data(Primitive_output[6])\n        );\n\n        S7 uu_S7 (\n            .i_data(Primitive_input [7]),\n            .o_data(Primitive_output[7])\n        );\n\n        S8 uu_S8 (\n            .i_data(Primitive_input [8]),\n            .o_data(Primitive_output[8])\n        );\n\n        assign perm_in = {Primitive_output[1], Primitive_output[2], Primitive_output[3], Primitive_output[4],\n                          Primitive_output[5], Primitive_output[6], Primitive_output[7], Primitive_output[8]};\n\n        assign L_nx = {perm_in[16], perm_in[ 7], perm_in[20], perm_in[21],\n                       perm_in[29], perm_in[12], perm_in[28], perm_in[17],\n                       perm_in[ 1], perm_in[15], perm_in[23], perm_in[26],\n                       perm_in[ 5], perm_in[18], perm_in[31], perm_in[10],\n                       perm_in[ 2], perm_in[ 8], perm_in[24], perm_in[14],\n                       perm_in[32], perm_in[27], perm_in[ 3], perm_in[ 9],\n                       perm_in[19], perm_in[13], perm_in[30], perm_in[ 6],\n                       perm_in[22], perm_in[11], perm_in[ 4], perm_in[25]};\n\n        if(i == 15) begin\n            assign L_expanded = {L16[32], L16[ 1], L16[ 2], L16[ 3], L16[ 4], L16[ 5],\n                                 L16[ 4], L16[ 5], L16[ 6], L16[ 7], L16[ 8], L16[ 9],\n                                 L16[ 8], L16[ 9], L16[10], L16[11], L16[12], L16[13],\n                                 L16[12], L16[13], L16[14], L16[15], L16[16], L16[17],\n                                 L16[16], L16[17], L16[18], L16[19], L16[20], L16[21],\n                                 L16[20], L16[21], L16[22], L16[23], L16[24], L16[25],\n                                 L16[24], L16[25], L16[26], L16[27], L16[28], L16[29],\n                                 L16[28], L16[29], L16[30], L16[31], L16[32], L16[ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    if(i_valid) begin\n                        L_ff[i] <= L_nx ^ R16;\n                        R_ff[i] <= L16;\n                        C_ff[i] <= C_nx;\n                        D_ff[i] <= D_nx;\n                    end\n                end\n            end\n        end else begin\n            assign L_expanded = {L_ff[i+1][32], L_ff[i+1][ 1], L_ff[i+1][ 2], L_ff[i+1][ 3], L_ff[i+1][ 4], L_ff[i+1][ 5],\n                                 L_ff[i+1][ 4], L_ff[i+1][ 5], L_ff[i+1][ 6], L_ff[i+1][ 7], L_ff[i+1][ 8], L_ff[i+1][ 9],\n                                 L_ff[i+1][ 8], L_ff[i+1][ 9], L_ff[i+1][10], L_ff[i+1][11], L_ff[i+1][12], L_ff[i+1][13],\n                                 L_ff[i+1][12], L_ff[i+1][13], L_ff[i+1][14], L_ff[i+1][15], L_ff[i+1][16], L_ff[i+1][17],\n                                 L_ff[i+1][16], L_ff[i+1][17], L_ff[i+1][18], L_ff[i+1][19], L_ff[i+1][20], L_ff[i+1][21],\n                                 L_ff[i+1][20], L_ff[i+1][21], L_ff[i+1][22], L_ff[i+1][23], L_ff[i+1][24], L_ff[i+1][25],\n                                 L_ff[i+1][24], L_ff[i+1][25], L_ff[i+1][26], L_ff[i+1][27], L_ff[i+1][28], L_ff[i+1][29],\n                                 L_ff[i+1][28], L_ff[i+1][29], L_ff[i+1][30], L_ff[i+1][31], L_ff[i+1][32], L_ff[i+1][ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    L_ff[i] <= L_nx ^ R_ff[i+1];\n                    R_ff[i] <= L_ff[i+1];\n                    C_ff[i] <= C_nx;\n                    D_ff[i] <= D_nx;\n                end\n            end\n        end\n    end\nendgenerate\n\nassign last_perm = {L_ff[0], R_ff[0]};\n\nassign o_data = {last_perm[40], last_perm[8], last_perm[48], last_perm[16], last_perm[56], last_perm[24], last_perm[64], last_perm[32],\n                 last_perm[39], last_perm[7], last_perm[47], last_perm[15], last_perm[55], last_perm[23], last_perm[63], last_perm[31],\n                 last_perm[38], last_perm[6], last_perm[46], last_perm[14], last_perm[54], last_perm[22], last_perm[62], last_perm[30],\n                 last_perm[37], last_perm[5], last_perm[45], last_perm[13], last_perm[53], last_perm[21], last_perm[61], last_perm[29],\n                 last_perm[36], last_perm[4], last_perm[44], last_perm[12], last_perm[52], last_perm[20], last_perm[60], last_perm[28],\n                 last_perm[35], last_perm[3], last_perm[43], last_perm[11], last_perm[51], last_perm[19], last_perm[59], last_perm[27],\n                 last_perm[34], last_perm[2], last_perm[42], last_perm[10], last_perm[50], last_perm[18], last_perm[58], last_perm[26],\n                 last_perm[33], last_perm[1], last_perm[41], last_perm[ 9], last_perm[49], last_perm[17], last_perm[57], last_perm[25]};\n\nendmodule : des_dec", "rtl/des_enc.sv": "module des_enc #(\n    parameter NBW_DATA = 'd64,\n    parameter NBW_KEY  = 'd64\n) (\n    input  logic              clk,\n    input  logic              rst_async_n,\n    input  logic              i_valid,\n    input  logic [1:NBW_DATA] i_data,\n    input  logic [1:NBW_KEY]  i_key,\n    output logic              o_valid,\n    output logic [1:NBW_DATA] o_data\n);\n\nlocalparam ROUNDS = 'd16;\nlocalparam EXPANDED_BLOCK = 'd48;\nlocalparam USED_KEY = 'd56;\n\nlogic [1:NBW_DATA]     IP;\nlogic [1:(NBW_DATA/2)] L0;\nlogic [1:(NBW_DATA/2)] R0;\nlogic [1:(NBW_DATA/2)] L_ff [1:ROUNDS];\nlogic [1:(NBW_DATA/2)] R_ff [1:ROUNDS];\nlogic [1:(USED_KEY/2)] C0;\nlogic [1:(USED_KEY/2)] D0;\nlogic [1:(USED_KEY/2)] C_ff [1:ROUNDS];\nlogic [1:(USED_KEY/2)] D_ff [1:ROUNDS];\nlogic [1:NBW_DATA]     last_perm;\nlogic [ROUNDS-1:0]     valid_ff;\n\nalways_ff @ (posedge clk or negedge rst_async_n) begin\n    if(!rst_async_n) begin\n        valid_ff <= 0;\n    end else begin\n        valid_ff <= {valid_ff[ROUNDS-2:0], i_valid};\n    end\nend\n\nassign o_valid = valid_ff[ROUNDS-1];\n\nassign IP = {i_data[58], i_data[50], i_data[42], i_data[34], i_data[26], i_data[18], i_data[10], i_data[2],\n             i_data[60], i_data[52], i_data[44], i_data[36], i_data[28], i_data[20], i_data[12], i_data[4],\n             i_data[62], i_data[54], i_data[46], i_data[38], i_data[30], i_data[22], i_data[14], i_data[6],\n             i_data[64], i_data[56], i_data[48], i_data[40], i_data[32], i_data[24], i_data[16], i_data[8],\n             i_data[57], i_data[49], i_data[41], i_data[33], i_data[25], i_data[17], i_data[ 9], i_data[1],\n             i_data[59], i_data[51], i_data[43], i_data[35], i_data[27], i_data[19], i_data[11], i_data[3],\n             i_data[61], i_data[53], i_data[45], i_data[37], i_data[29], i_data[21], i_data[13], i_data[5],\n             i_data[63], i_data[55], i_data[47], i_data[39], i_data[31], i_data[23], i_data[15], i_data[7]};\n\nassign L0 = IP[1:NBW_DATA/2];\nassign R0 = IP[(NBW_DATA/2)+1:NBW_DATA];\n\nassign C0 = {i_key[57], i_key[49], i_key[41], i_key[33], i_key[25], i_key[17], i_key[ 9],\n             i_key[ 1], i_key[58], i_key[50], i_key[42], i_key[34], i_key[26], i_key[18],\n             i_key[10], i_key[ 2], i_key[59], i_key[51], i_key[43], i_key[35], i_key[27],\n             i_key[19], i_key[11], i_key[ 3], i_key[60], i_key[52], i_key[44], i_key[36]};\n\nassign D0 = {i_key[63], i_key[55], i_key[47], i_key[39], i_key[31], i_key[23], i_key[15],\n             i_key[ 7], i_key[62], i_key[54], i_key[46], i_key[38], i_key[30], i_key[22],\n             i_key[14], i_key[ 6], i_key[61], i_key[53], i_key[45], i_key[37], i_key[29],\n             i_key[21], i_key[13], i_key[ 5], i_key[28], i_key[20], i_key[12], i_key[ 4]};\n\ngenerate\n    for (genvar i = 1; i <= ROUNDS; i++) begin : rounds\n        logic [1:EXPANDED_BLOCK] round_key;\n        logic [1:(USED_KEY/2)]    C_nx;\n        logic [1:(USED_KEY/2)]    D_nx;\n        logic [1:USED_KEY]        perm_ch;\n        logic [1:(NBW_DATA/2)] R_nx;\n        logic [1:EXPANDED_BLOCK] R_expanded;\n        logic [1:6] Primitive_input  [1:8];\n        logic [1:4] Primitive_output [1:8];\n        logic [1:(NBW_DATA/2)] perm_in;\n\n        assign perm_ch = {C_nx, D_nx};\n        assign round_key = {perm_ch[14], perm_ch[17], perm_ch[11], perm_ch[24], perm_ch[ 1], perm_ch[ 5],\n                            perm_ch[ 3], perm_ch[28], perm_ch[15], perm_ch[ 6], perm_ch[21], perm_ch[10],\n                            perm_ch[23], perm_ch[19], perm_ch[12], perm_ch[ 4], perm_ch[26], perm_ch[ 8],\n                            perm_ch[16], perm_ch[ 7], perm_ch[27], perm_ch[20], perm_ch[13], perm_ch[ 2],\n                            perm_ch[41], perm_ch[52], perm_ch[31], perm_ch[37], perm_ch[47], perm_ch[55],\n                            perm_ch[30], perm_ch[40], perm_ch[51], perm_ch[45], perm_ch[33], perm_ch[48],\n                            perm_ch[44], perm_ch[49], perm_ch[39], perm_ch[56], perm_ch[34], perm_ch[53],\n                            perm_ch[46], perm_ch[42], perm_ch[50], perm_ch[36], perm_ch[29], perm_ch[32]};\n\n        if(i == 1 || i == 2 || i == 9 || i == 16) begin\n            if(i == 1) begin\n                assign C_nx = {C0[2:(USED_KEY/2)], C0[1]};\n                assign D_nx = {D0[2:(USED_KEY/2)], D0[1]};\n            end else begin\n                assign C_nx = {C_ff[i-1][2:(USED_KEY/2)], C_ff[i-1][1]};\n                assign D_nx = {D_ff[i-1][2:(USED_KEY/2)], D_ff[i-1][1]};\n            end\n        end else begin\n            assign C_nx = {C_ff[i-1][3:(USED_KEY/2)], C_ff[i-1][1:2]};\n            assign D_nx = {D_ff[i-1][3:(USED_KEY/2)], D_ff[i-1][1:2]};\n        end\n\n        assign Primitive_input[1] = R_expanded[ 1:6 ] ^ round_key[ 1:6 ];\n        assign Primitive_input[2] = R_expanded[ 7:12] ^ round_key[ 7:12];\n        assign Primitive_input[3] = R_expanded[13:18] ^ round_key[13:18];\n        assign Primitive_input[4] = R_expanded[19:24] ^ round_key[19:24];\n        assign Primitive_input[5] = R_expanded[25:30] ^ round_key[25:30];\n        assign Primitive_input[6] = R_expanded[31:36] ^ round_key[31:36];\n        assign Primitive_input[7] = R_expanded[37:42] ^ round_key[37:42];\n        assign Primitive_input[8] = R_expanded[43:48] ^ round_key[43:48];\n\n        S1 uu_S1 (\n            .i_data(Primitive_input [1]),\n            .o_data(Primitive_output[1])\n        );\n\n        S2 uu_S2 (\n            .i_data(Primitive_input [2]),\n            .o_data(Primitive_output[2])\n        );\n\n        S3 uu_S3 (\n            .i_data(Primitive_input [3]),\n            .o_data(Primitive_output[3])\n        );\n\n        S4 uu_S4 (\n            .i_data(Primitive_input [4]),\n            .o_data(Primitive_output[4])\n        );\n\n        S5 uu_S5 (\n            .i_data(Primitive_input [5]),\n            .o_data(Primitive_output[5])\n        );\n\n        S6 uu_S6 (\n            .i_data(Primitive_input [6]),\n            .o_data(Primitive_output[6])\n        );\n\n        S7 uu_S7 (\n            .i_data(Primitive_input [7]),\n            .o_data(Primitive_output[7])\n        );\n\n        S8 uu_S8 (\n            .i_data(Primitive_input [8]),\n            .o_data(Primitive_output[8])\n        );\n\n        assign perm_in = {Primitive_output[1], Primitive_output[2], Primitive_output[3], Primitive_output[4],\n                          Primitive_output[5], Primitive_output[6], Primitive_output[7], Primitive_output[8]};\n\n        assign R_nx = {perm_in[16], perm_in[ 7], perm_in[20], perm_in[21],\n                       perm_in[29], perm_in[12], perm_in[28], perm_in[17],\n                       perm_in[ 1], perm_in[15], perm_in[23], perm_in[26],\n                       perm_in[ 5], perm_in[18], perm_in[31], perm_in[10],\n                       perm_in[ 2], perm_in[ 8], perm_in[24], perm_in[14],\n                       perm_in[32], perm_in[27], perm_in[ 3], perm_in[ 9],\n                       perm_in[19], perm_in[13], perm_in[30], perm_in[ 6],\n                       perm_in[22], perm_in[11], perm_in[ 4], perm_in[25]};\n\n        if(i == 1) begin\n            assign R_expanded = {R0[32], R0[ 1], R0[ 2], R0[ 3], R0[ 4], R0[ 5],\n                                 R0[ 4], R0[ 5], R0[ 6], R0[ 7], R0[ 8], R0[ 9],\n                                 R0[ 8], R0[ 9], R0[10], R0[11], R0[12], R0[13],\n                                 R0[12], R0[13], R0[14], R0[15], R0[16], R0[17],\n                                 R0[16], R0[17], R0[18], R0[19], R0[20], R0[21],\n                                 R0[20], R0[21], R0[22], R0[23], R0[24], R0[25],\n                                 R0[24], R0[25], R0[26], R0[27], R0[28], R0[29],\n                                 R0[28], R0[29], R0[30], R0[31], R0[32], R0[ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    if(i_valid) begin\n                        L_ff[i] <= R0;\n                        R_ff[i] <= R_nx ^ L0;\n                        C_ff[i] <= C_nx;\n                        D_ff[i] <= D_nx;\n                    end\n                end\n            end\n        end else begin\n            assign R_expanded = {R_ff[i-1][32], R_ff[i-1][ 1], R_ff[i-1][ 2], R_ff[i-1][ 3], R_ff[i-1][ 4], R_ff[i-1][ 5],\n                                 R_ff[i-1][ 4], R_ff[i-1][ 5], R_ff[i-1][ 6], R_ff[i-1][ 7], R_ff[i-1][ 8], R_ff[i-1][ 9],\n                                 R_ff[i-1][ 8], R_ff[i-1][ 9], R_ff[i-1][10], R_ff[i-1][11], R_ff[i-1][12], R_ff[i-1][13],\n                                 R_ff[i-1][12], R_ff[i-1][13], R_ff[i-1][14], R_ff[i-1][15], R_ff[i-1][16], R_ff[i-1][17],\n                                 R_ff[i-1][16], R_ff[i-1][17], R_ff[i-1][18], R_ff[i-1][19], R_ff[i-1][20], R_ff[i-1][21],\n                                 R_ff[i-1][20], R_ff[i-1][21], R_ff[i-1][22], R_ff[i-1][23], R_ff[i-1][24], R_ff[i-1][25],\n                                 R_ff[i-1][24], R_ff[i-1][25], R_ff[i-1][26], R_ff[i-1][27], R_ff[i-1][28], R_ff[i-1][29],\n                                 R_ff[i-1][28], R_ff[i-1][29], R_ff[i-1][30], R_ff[i-1][31], R_ff[i-1][32], R_ff[i-1][ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    L_ff[i] <= R_ff[i-1];\n                    R_ff[i] <= R_nx ^ L_ff[i-1];\n                    C_ff[i] <= C_nx;\n                    D_ff[i] <= D_nx;\n                end\n            end\n        end\n    end\nendgenerate\n\nassign last_perm = {R_ff[ROUNDS], L_ff[ROUNDS]};\n\nassign o_data = {last_perm[40], last_perm[8], last_perm[48], last_perm[16], last_perm[56], last_perm[24], last_perm[64], last_perm[32],\n                 last_perm[39], last_perm[7], last_perm[47], last_perm[15], last_perm[55], last_perm[23], last_perm[63], last_perm[31],\n                 last_perm[38], last_perm[6], last_perm[46], last_perm[14], last_perm[54], last_perm[22], last_perm[62], last_perm[30],\n                 last_perm[37], last_perm[5], last_perm[45], last_perm[13], last_perm[53], last_perm[21], last_perm[61], last_perm[29],\n                 last_perm[36], last_perm[4], last_perm[44], last_perm[12], last_perm[52], last_perm[20], last_perm[60], last_perm[28],\n                 last_perm[35], last_perm[3], last_perm[43], last_perm[11], last_perm[51], last_perm[19], last_perm[59], last_perm[27],\n                 last_perm[34], last_perm[2], last_perm[42], last_perm[10], last_perm[50], last_perm[18], last_perm[58], last_perm[26],\n                 last_perm[33], last_perm[1], last_perm[41], last_perm[ 9], last_perm[49], last_perm[17], last_perm[57], last_perm[25]};\n\nendmodule : des_enc", "verif/tb_3des_enc.sv": "module tb;\n\nparameter NBW_DATA = 'd64;\nparameter NBW_KEY  = 'd192;\n\nlogic                clk;\nlogic                rst_async_n;\nlogic                i_valid;\nlogic [1:NBW_DATA] i_data;\nlogic [1:NBW_KEY ] i_key;\nlogic                o_valid;\nlogic [1:NBW_DATA] o_data;\n\ndes3_enc #(\n    .NBW_DATA(NBW_DATA),\n    .NBW_KEY (NBW_KEY )\n) uu_des3_enc (\n    .clk        (clk        ),\n    .rst_async_n(rst_async_n),\n    .i_valid    (i_valid    ),\n    .i_data     (i_data     ),\n    .i_key      (i_key      ),\n    .o_valid    (o_valid    ),\n    .o_data     (o_data     )\n);\n\ninitial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0,tb);\nend\n\nalways #5 clk = ~clk;\n\ntask Single_test(logic [1:NBW_KEY] key, logic [1:NBW_DATA] data, logic [1:NBW_DATA] expected);\n    i_key   = key;\n    i_data  = data;\n    i_valid = 1;\n\n    @(negedge clk);\n    i_valid = 0;\n\n    @(posedge o_valid);\n    @(negedge clk);\n    if(o_data != expected) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", expected, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\nendtask\n\ntask Burst_test();\n    i_key   = 192'hB1FECAFEBEBAB1FEABCDABCDABCDABCD8765432187654321;\n    i_data  = 64'h4321432143214321;\n    i_valid = 1;\n\n    @(negedge clk);\n    i_data  = 64'h123456789ABCDEF0;\n\n    @(negedge clk);\n    i_data  = 64'h1234123412341234;\n    i_key   = 192'hABCDABCDABCDABCD8765432187654321B1FECAFEBEBAB1FE;\n\n    @(negedge clk);\n    i_valid = 0;\n\n    @(posedge o_valid);\n    @(negedge clk);\n    if(o_data != 64'h2749c9efcaed543a) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", 64'h2749c9efcaed543a, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\n\n    @(negedge clk);\n    if(o_valid != 1) begin\n        $display(\"FAIL! o_valid should be asserted here.\");\n    end\n    if(o_data != 64'h984d23ecef8df5fd) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", 64'h984d23ecef8df5fd, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\n\n    @(negedge clk);\n    if(o_valid != 1) begin\n        $display(\"FAIL! o_valid should be asserted here.\");\n    end\n    if(o_data != 64'h972161012599c927) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", 64'h972161012599c927, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\n    \nendtask\n\ninitial begin\n    clk = 0;\n    i_valid = 0;\n    rst_async_n = 1;\n    #1;\n    rst_async_n = 0;\n    #2;\n    rst_async_n = 1;\n    @(negedge clk);\n\n    $display(\"\\nSingle Tests\");\n    Single_test(192'h0123456789abcdeffedcba9876543210abcdef9876543210, 64'h0123456789ABCDEF, 64'ha4688b153da3f95b);\n    Single_test(192'h0123456789abcdeffedcba9876543210abcdef9876543210, 64'hFEDCBA9876543210, 64'h7b9325d305515107);\n    Single_test(192'hBEBACAFE12345678B1FECAFE876543219898898974744747, 64'hFEDCBA9876543210, 64'h71f4eedd55b0f964);\n    Single_test(192'hBEBACAFE12345678B1FECAFE876543219898898974744747, 64'hB1FECAFEBEBAB1FE, 64'h2038ea8568d3f771);\n\n    $display(\"\\nBurst Test\");\n    Burst_test();\n\n    @(negedge clk);\n    @(negedge clk);\n\n    $finish();\nend\n\nendmodule"}, "patch": {"rtl/des3_enc.sv": ""}, "harness": {"docker-compose.yml": "services:\n  sanity:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache\n", "src/.env": "VERILOG_SOURCES = /code/rtl/des3_enc.sv /code/rtl/des_dec.sv /code/rtl/des_enc.sv /code/rtl/S1.sv /code/rtl/S2.sv /code/rtl/S3.sv /code/rtl/S4.sv /code/rtl/S5.sv /code/rtl/S6.sv /code/rtl/S7.sv /code/rtl/S8.sv\nTOPLEVEL        = des3_enc\nMODULE          = test_des3_enc\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 5-create-des3-enc\nWAVE            = true", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom collections import deque\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nclass des:\n    def __init__(self):\n        self.reset()\n\n    def reset(self):\n        self.data_out = 0\n        self.enc_out = 0\n        self.dec_out = 0\n        self.fifo = []\n\n    def permute(self, block, table, n):\n        result = 0\n        for i in range(len(table)):\n            bit = (block >> (n - table[i])) & 1\n            result |= (bit << (len(table) - 1 - i))\n        return result\n\n    def left_rotate(self, val, n):\n        return ((val << n) & 0x0FFFFFFF) | (val >> (28 - n))\n\n    def sbox(self, box, val):\n        row = ((val >> 5) & 1) * 2 + (val & 1)\n        col = (val >> 1) & 0xF\n        return box[row][col]\n\n    def f(self, R, subkey):\n        E = [32,1,2,3,4,5,4,5,6,7,8,9,\n             8,9,10,11,12,13,12,13,14,15,16,17,\n             16,17,18,19,20,21,20,21,22,23,24,25,\n             24,25,26,27,28,29,28,29,30,31,32,1]\n\n        P = [16,7,20,21,29,12,28,17,\n             1,15,23,26,5,18,31,10,\n             2,8,24,14,32,27,3,9,\n             19,13,30,6,22,11,4,25]\n\n        SBOXES = self.sboxes\n\n        expanded = self.permute(R << 32, E, 64)\n        xored = expanded ^ subkey\n\n        output = 0\n        for i in range(8):\n            chunk = (xored >> (42 - i*6)) & 0x3F\n            sbox_val = self.sbox(SBOXES[i], chunk)\n            output = (output << 4) | sbox_val\n\n        return self.permute(output << 32, P, 64)\n\n    def generate_subkeys(self, key):\n        PC1 = [57,49,41,33,25,17,9,\n               1,58,50,42,34,26,18,\n               10,2,59,51,43,35,27,\n               19,11,3,60,52,44,36,\n               63,55,47,39,31,23,15,\n               7,62,54,46,38,30,22,\n               14,6,61,53,45,37,29,\n               21,13,5,28,20,12,4]\n\n        PC2 = [14,17,11,24,1,5,\n               3,28,15,6,21,10,\n               23,19,12,4,26,8,\n               16,7,27,20,13,2,\n               41,52,31,37,47,55,\n               30,40,51,45,33,48,\n               44,49,39,56,34,53,\n               46,42,50,36,29,32]\n\n        rotations = [1, 1, 2, 2, 2, 2, 2, 2,\n                     1, 2, 2, 2, 2, 2, 2, 1]\n\n        key56 = self.permute(key, PC1, 64)\n        C = (key56 >> 28) & 0xFFFFFFF\n        D = key56 & 0xFFFFFFF\n\n        subkeys = []\n        for rot in rotations:\n            C = self.left_rotate(C, rot)\n            D = self.left_rotate(D, rot)\n            CD = (C << 28) | D\n            subkey = self.permute(CD, PC2, 56)\n            subkeys.append(subkey)\n        return subkeys\n    \n    def decrypt(self, data, key):\n        IP = [58,50,42,34,26,18,10,2,\n              60,52,44,36,28,20,12,4,\n              62,54,46,38,30,22,14,6,\n              64,56,48,40,32,24,16,8,\n              57,49,41,33,25,17,9,1,\n              59,51,43,35,27,19,11,3,\n              61,53,45,37,29,21,13,5,\n              63,55,47,39,31,23,15,7]\n\n        FP = [40,8,48,16,56,24,64,32,\n              39,7,47,15,55,23,63,31,\n              38,6,46,14,54,22,62,30,\n              37,5,45,13,53,21,61,29,\n              36,4,44,12,52,20,60,28,\n              35,3,43,11,51,19,59,27,\n              34,2,42,10,50,18,58,26,\n              33,1,41,9,49,17,57,25]\n\n        block = self.permute(data, IP, 64)\n        L = (block >> 32) & 0xFFFFFFFF\n        R = block & 0xFFFFFFFF\n\n        subkeys = self.generate_subkeys(key)[::-1]  # Reverse subkeys for decryption\n\n        for i in range(16):\n            temp = R\n            R = L ^ self.f(R, subkeys[i])\n            L = temp\n\n        pre_output = (R << 32) | L\n        self.dec_out = self.permute(pre_output, FP, 64)\n\n    def encrypt(self, data, key):\n        IP = [58,50,42,34,26,18,10,2,\n              60,52,44,36,28,20,12,4,\n              62,54,46,38,30,22,14,6,\n              64,56,48,40,32,24,16,8,\n              57,49,41,33,25,17,9,1,\n              59,51,43,35,27,19,11,3,\n              61,53,45,37,29,21,13,5,\n              63,55,47,39,31,23,15,7]\n\n        FP = [40,8,48,16,56,24,64,32,\n              39,7,47,15,55,23,63,31,\n              38,6,46,14,54,22,62,30,\n              37,5,45,13,53,21,61,29,\n              36,4,44,12,52,20,60,28,\n              35,3,43,11,51,19,59,27,\n              34,2,42,10,50,18,58,26,\n              33,1,41,9,49,17,57,25]\n\n        block = self.permute(data, IP, 64)\n        L = (block >> 32) & 0xFFFFFFFF\n        R = block & 0xFFFFFFFF\n\n        subkeys = self.generate_subkeys(key)\n\n        for i in range(16):\n            temp = R\n            R = L ^ self.f(R, subkeys[i])\n            L = temp\n\n        pre_output = (R << 32) | L\n        self.enc_out = self.permute(pre_output, FP, 64)\n    \n    def des3_enc(self, data, key):\n        K1 = (key & 0xFFFFFFFFFFFFFFFF00000000000000000000000000000000) >> 128\n        K2 = (key & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64\n        K3 = key & 0x00000000000000000000000000000000FFFFFFFFFFFFFFFF\n        self.encrypt(data, K1)\n        self.decrypt(self.enc_out, K2)\n        self.encrypt(self.dec_out, K3)\n\n        self.fifo.append(self.enc_out)\n    \n    def read_data(self):\n        if self.fifo:\n            return self.fifo.pop(0)\n        return 0\n\n    # Full DES S-box definitions\n    sboxes = [\n        [\n            [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n            [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n            [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n            [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13]\n        ],\n        [\n            [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10],\n            [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5],\n            [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15],\n            [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9]\n        ],\n        [\n            [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8],\n            [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1],\n            [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7],\n            [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12]\n        ],\n        [\n            [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15],\n            [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9],\n            [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4],\n            [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14]\n        ],\n        [\n            [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9],\n            [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6],\n            [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14],\n            [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3]\n        ],\n        [\n            [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11],\n            [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8],\n            [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6],\n            [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13]\n        ],\n        [\n            [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1],\n            [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6],\n            [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2],\n            [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12]\n        ],\n        [\n            [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7],\n            [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2],\n            [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8],\n            [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]\n        ]\n    ]", "src/test_des3_enc.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, FallingEdge\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data   = dut.o_data.value.integer\n    model_data = model.read_data()\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\n@cocotb.test()\nasync def test_des3_enc(dut):\n    \"\"\"Test the des3_enc module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n\n    model = hrs_lb.des()\n\n    resets = 4\n    runs = 1000\n\n    data_min = 0\n    data_max = 2**64 - 1\n\n    key_min  = 0\n    key_max  = 2**192 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_valid.value     = 0\n        dut.i_data.value      = 0\n        dut.i_key.value       = 0\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        # Latency check\n        key   = random.randint(key_min , key_max )\n        data  = random.randint(data_min, data_max)\n        valid = 1\n\n        await FallingEdge(dut.clk)\n        dut.i_data.value  = data\n        dut.i_key.value   = key\n        dut.i_valid.value = valid\n\n        model.des3_enc(data, key)\n        await FallingEdge(dut.clk)\n        latency_counter = 1\n        dut.i_valid.value = 0\n\n        while dut.o_valid.value == 0:\n            latency_counter = latency_counter + 1\n            await FallingEdge(dut.clk)\n        \n        assert latency_counter == 48, f\"[ERROR] DUT latency must be 48 clock cycles\"\n        \n        compare_values(dut, model)\n\n        for j in range(runs):\n            if (j+1)%500 == 0:\n                print(f'\\n------ Reset {i}, run {j+1} ------')\n\n            key   = random.randint(key_min , key_max )\n            data  = random.randint(data_min, data_max)\n            valid = random.randint(0,1)\n\n            await FallingEdge(dut.clk)\n\n            dut.i_data.value  = data\n            dut.i_key.value   = key\n            dut.i_valid.value = valid\n            if valid:\n                model.des3_enc(data, key)\n\n            if dut.o_valid.value == 1:\n                compare_values(dut, model)\n", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_DES_0007", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"line_number s/old_statement/new_statement/\" file.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "Integrate the `des_enc` and `des_dec` modules to perform the Triple Data Encryption Standard (TDES) decryption. This new module must not allow burst operations; instead, it must perform start/done controlled operations, where whenever a start occurs, the done signal must be de-asserted, and any data, key, or start signals are ignored until the done signal is asserted again. A testbench for this new module is available at `verif/tb_3des_dec.sv`.\n\nAlso, update the `des_enc` and `des_dec` so that the `o_valid` signal from their interface and all logic related to them are removed, and `i_valid` input signal is renamed to `i_start`.\n\n---\n\n## Specifications\n\n- **Module Name**: `des3_dec`\n\n- **File Name**: `des3_dec.sv` (to be added in `rtl` directory)\n\n- **Parameters**:\n    - `NBW_DATA`: Bit width of the input and output data blocks.\n        - Default: 64.\n        - Related interface signals: `i_data`, `o_data`.\n    - `NBW_KEY`: Bit width of the key.\n        - Default: 192.\n        - Related interface signal: `i_key`.  \n        - The 192-bit key is interpreted as three concatenated 64-bit DES keys (K1, K2, K3) used for Triple DES decryption, where `K1 = i_key[1:64]`, K2 = `i_key[65:128]`, and `K3 = i_key[129:192]`.\n\n- **Functionality**: Implements 3DES decryption in DED (Decrypt-Encrypt-Decrypt) mode using three 64-bit keys (K3, K2, K1). The input ciphertext is decrypted with K3, encrypted with K2, and decrypted again with K1.\n\n- **Latency**: The block's latency, from when `i_start` is read until `o_done` is asserted, is **48 cycles**, where each DES stage takes 16 cycles.\n\n---\n\n## Interface Signals\n\n  | Signal              | Direction | Width            | Description                                                                                                                           |\n  |---------------------|-----------|------------------|---------------------------------------------------------------------------------------------------------------------------------------|\n  | `clk`               | Input     | 1                | Drives the sequential logic on the rising edge.                                                                                       |\n  | `rst_async_n`       | Input     | 1                | Active-low asynchronous reset; clears all internal registers and state.                                                               |\n  | `i_start`           | Input     | 1                | Active high. Indicates that `i_data` and `i_key` are valid and ready to be processed.                                                 |\n  | `i_data`            | Input     | [1:NBW_DATA]     | 64-bit ciphertext input block (MSB-first).                                                                                            |\n  | `i_key`             | Input     | [1:NBW_KEY]      | 192-bit 3DES key, treated as three concatenated 64-bit keys: `{K1, K2, K3}`.                                                          |\n  | `o_done`            | Output    | 1                | Asserted high when `o_data` contains valid encrypted data. It remains asserted until a new `i_start` signal is received.              |\n  | `o_data`            | Output    | [1:NBW_DATA]     | 64-bit plaintext output block (MSB-first). After the decryption is calculated, it must remain stable until a next decryption is done. |\n", "context": {"rtl/S1.sv": "module S1(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd14;\n        6'b0_0001_0 : o_data = 4'd4;\n        6'b0_0010_0 : o_data = 4'd13;\n        6'b0_0011_0 : o_data = 4'd1;\n        6'b0_0100_0 : o_data = 4'd2;\n        6'b0_0101_0 : o_data = 4'd15;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd8;\n        6'b0_1000_0 : o_data = 4'd3;\n        6'b0_1001_0 : o_data = 4'd10;\n        6'b0_1010_0 : o_data = 4'd6;\n        6'b0_1011_0 : o_data = 4'd12;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd9;\n        6'b0_1110_0 : o_data = 4'd0;\n        6'b0_1111_0 : o_data = 4'd7;\n        6'b0_0000_1 : o_data = 4'd0;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd7;\n        6'b0_0011_1 : o_data = 4'd4;\n        6'b0_0100_1 : o_data = 4'd14;\n        6'b0_0101_1 : o_data = 4'd2;\n        6'b0_0110_1 : o_data = 4'd13;\n        6'b0_0111_1 : o_data = 4'd1;\n        6'b0_1000_1 : o_data = 4'd10;\n        6'b0_1001_1 : o_data = 4'd6;\n        6'b0_1010_1 : o_data = 4'd12;\n        6'b0_1011_1 : o_data = 4'd11;\n        6'b0_1100_1 : o_data = 4'd9;\n        6'b0_1101_1 : o_data = 4'd5;\n        6'b0_1110_1 : o_data = 4'd3;\n        6'b0_1111_1 : o_data = 4'd8;\n        6'b1_0000_0 : o_data = 4'd4;\n        6'b1_0001_0 : o_data = 4'd1;\n        6'b1_0010_0 : o_data = 4'd14;\n        6'b1_0011_0 : o_data = 4'd8;\n        6'b1_0100_0 : o_data = 4'd13;\n        6'b1_0101_0 : o_data = 4'd6;\n        6'b1_0110_0 : o_data = 4'd2;\n        6'b1_0111_0 : o_data = 4'd11;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd12;\n        6'b1_1010_0 : o_data = 4'd9;\n        6'b1_1011_0 : o_data = 4'd7;\n        6'b1_1100_0 : o_data = 4'd3;\n        6'b1_1101_0 : o_data = 4'd10;\n        6'b1_1110_0 : o_data = 4'd5;\n        6'b1_1111_0 : o_data = 4'd0;\n        6'b1_0000_1 : o_data = 4'd15;\n        6'b1_0001_1 : o_data = 4'd12;\n        6'b1_0010_1 : o_data = 4'd8;\n        6'b1_0011_1 : o_data = 4'd2;\n        6'b1_0100_1 : o_data = 4'd4;\n        6'b1_0101_1 : o_data = 4'd9;\n        6'b1_0110_1 : o_data = 4'd1;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd5;\n        6'b1_1001_1 : o_data = 4'd11;\n        6'b1_1010_1 : o_data = 4'd3;\n        6'b1_1011_1 : o_data = 4'd14;\n        6'b1_1100_1 : o_data = 4'd10;\n        6'b1_1101_1 : o_data = 4'd0;\n        6'b1_1110_1 : o_data = 4'd6;\n        6'b1_1111_1 : o_data = 4'd13;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S1", "rtl/S2.sv": "module S2(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd15;\n        6'b0_0001_0 : o_data = 4'd1;\n        6'b0_0010_0 : o_data = 4'd8;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd11;\n        6'b0_0110_0 : o_data = 4'd3;\n        6'b0_0111_0 : o_data = 4'd4;\n        6'b0_1000_0 : o_data = 4'd9;\n        6'b0_1001_0 : o_data = 4'd7;\n        6'b0_1010_0 : o_data = 4'd2;\n        6'b0_1011_0 : o_data = 4'd13;\n        6'b0_1100_0 : o_data = 4'd12;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd5;\n        6'b0_1111_0 : o_data = 4'd10;\n        6'b0_0000_1 : o_data = 4'd3;\n        6'b0_0001_1 : o_data = 4'd13;\n        6'b0_0010_1 : o_data = 4'd4;\n        6'b0_0011_1 : o_data = 4'd7;\n        6'b0_0100_1 : o_data = 4'd15;\n        6'b0_0101_1 : o_data = 4'd2;\n        6'b0_0110_1 : o_data = 4'd8;\n        6'b0_0111_1 : o_data = 4'd14;\n        6'b0_1000_1 : o_data = 4'd12;\n        6'b0_1001_1 : o_data = 4'd0;\n        6'b0_1010_1 : o_data = 4'd1;\n        6'b0_1011_1 : o_data = 4'd10;\n        6'b0_1100_1 : o_data = 4'd6;\n        6'b0_1101_1 : o_data = 4'd9;\n        6'b0_1110_1 : o_data = 4'd11;\n        6'b0_1111_1 : o_data = 4'd5;\n        6'b1_0000_0 : o_data = 4'd0;\n        6'b1_0001_0 : o_data = 4'd14;\n        6'b1_0010_0 : o_data = 4'd7;\n        6'b1_0011_0 : o_data = 4'd11;\n        6'b1_0100_0 : o_data = 4'd10;\n        6'b1_0101_0 : o_data = 4'd4;\n        6'b1_0110_0 : o_data = 4'd13;\n        6'b1_0111_0 : o_data = 4'd1;\n        6'b1_1000_0 : o_data = 4'd5;\n        6'b1_1001_0 : o_data = 4'd8;\n        6'b1_1010_0 : o_data = 4'd12;\n        6'b1_1011_0 : o_data = 4'd6;\n        6'b1_1100_0 : o_data = 4'd9;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd2;\n        6'b1_1111_0 : o_data = 4'd15;\n        6'b1_0000_1 : o_data = 4'd13;\n        6'b1_0001_1 : o_data = 4'd8;\n        6'b1_0010_1 : o_data = 4'd10;\n        6'b1_0011_1 : o_data = 4'd1;\n        6'b1_0100_1 : o_data = 4'd3;\n        6'b1_0101_1 : o_data = 4'd15;\n        6'b1_0110_1 : o_data = 4'd4;\n        6'b1_0111_1 : o_data = 4'd2;\n        6'b1_1000_1 : o_data = 4'd11;\n        6'b1_1001_1 : o_data = 4'd6;\n        6'b1_1010_1 : o_data = 4'd7;\n        6'b1_1011_1 : o_data = 4'd12;\n        6'b1_1100_1 : o_data = 4'd0;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd14;\n        6'b1_1111_1 : o_data = 4'd9;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S2", "rtl/S3.sv": "module S3(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd10;\n        6'b0_0001_0 : o_data = 4'd0;\n        6'b0_0010_0 : o_data = 4'd9;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd3;\n        6'b0_0110_0 : o_data = 4'd15;\n        6'b0_0111_0 : o_data = 4'd5;\n        6'b0_1000_0 : o_data = 4'd1;\n        6'b0_1001_0 : o_data = 4'd13;\n        6'b0_1010_0 : o_data = 4'd12;\n        6'b0_1011_0 : o_data = 4'd7;\n        6'b0_1100_0 : o_data = 4'd11;\n        6'b0_1101_0 : o_data = 4'd4;\n        6'b0_1110_0 : o_data = 4'd2;\n        6'b0_1111_0 : o_data = 4'd8;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd7;\n        6'b0_0010_1 : o_data = 4'd0;\n        6'b0_0011_1 : o_data = 4'd9;\n        6'b0_0100_1 : o_data = 4'd3;\n        6'b0_0101_1 : o_data = 4'd4;\n        6'b0_0110_1 : o_data = 4'd6;\n        6'b0_0111_1 : o_data = 4'd10;\n        6'b0_1000_1 : o_data = 4'd2;\n        6'b0_1001_1 : o_data = 4'd8;\n        6'b0_1010_1 : o_data = 4'd5;\n        6'b0_1011_1 : o_data = 4'd14;\n        6'b0_1100_1 : o_data = 4'd12;\n        6'b0_1101_1 : o_data = 4'd11;\n        6'b0_1110_1 : o_data = 4'd15;\n        6'b0_1111_1 : o_data = 4'd1;\n        6'b1_0000_0 : o_data = 4'd13;\n        6'b1_0001_0 : o_data = 4'd6;\n        6'b1_0010_0 : o_data = 4'd4;\n        6'b1_0011_0 : o_data = 4'd9;\n        6'b1_0100_0 : o_data = 4'd8;\n        6'b1_0101_0 : o_data = 4'd15;\n        6'b1_0110_0 : o_data = 4'd3;\n        6'b1_0111_0 : o_data = 4'd0;\n        6'b1_1000_0 : o_data = 4'd11;\n        6'b1_1001_0 : o_data = 4'd1;\n        6'b1_1010_0 : o_data = 4'd2;\n        6'b1_1011_0 : o_data = 4'd12;\n        6'b1_1100_0 : o_data = 4'd5;\n        6'b1_1101_0 : o_data = 4'd10;\n        6'b1_1110_0 : o_data = 4'd14;\n        6'b1_1111_0 : o_data = 4'd7;\n        6'b1_0000_1 : o_data = 4'd1;\n        6'b1_0001_1 : o_data = 4'd10;\n        6'b1_0010_1 : o_data = 4'd13;\n        6'b1_0011_1 : o_data = 4'd0;\n        6'b1_0100_1 : o_data = 4'd6;\n        6'b1_0101_1 : o_data = 4'd9;\n        6'b1_0110_1 : o_data = 4'd8;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd4;\n        6'b1_1001_1 : o_data = 4'd15;\n        6'b1_1010_1 : o_data = 4'd14;\n        6'b1_1011_1 : o_data = 4'd3;\n        6'b1_1100_1 : o_data = 4'd11;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd2;\n        6'b1_1111_1 : o_data = 4'd12;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S3", "rtl/S4.sv": "module S4(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd7;\n        6'b0_0001_0 : o_data = 4'd13;\n        6'b0_0010_0 : o_data = 4'd14;\n        6'b0_0011_0 : o_data = 4'd3;\n        6'b0_0100_0 : o_data = 4'd0;\n        6'b0_0101_0 : o_data = 4'd6;\n        6'b0_0110_0 : o_data = 4'd9;\n        6'b0_0111_0 : o_data = 4'd10;\n        6'b0_1000_0 : o_data = 4'd1;\n        6'b0_1001_0 : o_data = 4'd2;\n        6'b0_1010_0 : o_data = 4'd8;\n        6'b0_1011_0 : o_data = 4'd5;\n        6'b0_1100_0 : o_data = 4'd11;\n        6'b0_1101_0 : o_data = 4'd12;\n        6'b0_1110_0 : o_data = 4'd4;\n        6'b0_1111_0 : o_data = 4'd15;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd8;\n        6'b0_0010_1 : o_data = 4'd11;\n        6'b0_0011_1 : o_data = 4'd5;\n        6'b0_0100_1 : o_data = 4'd6;\n        6'b0_0101_1 : o_data = 4'd15;\n        6'b0_0110_1 : o_data = 4'd0;\n        6'b0_0111_1 : o_data = 4'd3;\n        6'b0_1000_1 : o_data = 4'd4;\n        6'b0_1001_1 : o_data = 4'd7;\n        6'b0_1010_1 : o_data = 4'd2;\n        6'b0_1011_1 : o_data = 4'd12;\n        6'b0_1100_1 : o_data = 4'd1;\n        6'b0_1101_1 : o_data = 4'd10;\n        6'b0_1110_1 : o_data = 4'd14;\n        6'b0_1111_1 : o_data = 4'd9;\n        6'b1_0000_0 : o_data = 4'd10;\n        6'b1_0001_0 : o_data = 4'd6;\n        6'b1_0010_0 : o_data = 4'd9;\n        6'b1_0011_0 : o_data = 4'd0;\n        6'b1_0100_0 : o_data = 4'd12;\n        6'b1_0101_0 : o_data = 4'd11;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd13;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd1;\n        6'b1_1010_0 : o_data = 4'd3;\n        6'b1_1011_0 : o_data = 4'd14;\n        6'b1_1100_0 : o_data = 4'd5;\n        6'b1_1101_0 : o_data = 4'd2;\n        6'b1_1110_0 : o_data = 4'd8;\n        6'b1_1111_0 : o_data = 4'd4;\n        6'b1_0000_1 : o_data = 4'd3;\n        6'b1_0001_1 : o_data = 4'd15;\n        6'b1_0010_1 : o_data = 4'd0;\n        6'b1_0011_1 : o_data = 4'd6;\n        6'b1_0100_1 : o_data = 4'd10;\n        6'b1_0101_1 : o_data = 4'd1;\n        6'b1_0110_1 : o_data = 4'd13;\n        6'b1_0111_1 : o_data = 4'd8;\n        6'b1_1000_1 : o_data = 4'd9;\n        6'b1_1001_1 : o_data = 4'd4;\n        6'b1_1010_1 : o_data = 4'd5;\n        6'b1_1011_1 : o_data = 4'd11;\n        6'b1_1100_1 : o_data = 4'd12;\n        6'b1_1101_1 : o_data = 4'd7;\n        6'b1_1110_1 : o_data = 4'd2;\n        6'b1_1111_1 : o_data = 4'd14;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S4", "rtl/S5.sv": "module S5(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd2;\n        6'b0_0001_0 : o_data = 4'd12;\n        6'b0_0010_0 : o_data = 4'd4;\n        6'b0_0011_0 : o_data = 4'd1;\n        6'b0_0100_0 : o_data = 4'd7;\n        6'b0_0101_0 : o_data = 4'd10;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd6;\n        6'b0_1000_0 : o_data = 4'd8;\n        6'b0_1001_0 : o_data = 4'd5;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd15;\n        6'b0_1100_0 : o_data = 4'd13;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd14;\n        6'b0_1111_0 : o_data = 4'd9;\n        6'b0_0000_1 : o_data = 4'd14;\n        6'b0_0001_1 : o_data = 4'd11;\n        6'b0_0010_1 : o_data = 4'd2;\n        6'b0_0011_1 : o_data = 4'd12;\n        6'b0_0100_1 : o_data = 4'd4;\n        6'b0_0101_1 : o_data = 4'd7;\n        6'b0_0110_1 : o_data = 4'd13;\n        6'b0_0111_1 : o_data = 4'd1;\n        6'b0_1000_1 : o_data = 4'd5;\n        6'b0_1001_1 : o_data = 4'd0;\n        6'b0_1010_1 : o_data = 4'd15;\n        6'b0_1011_1 : o_data = 4'd10;\n        6'b0_1100_1 : o_data = 4'd3;\n        6'b0_1101_1 : o_data = 4'd9;\n        6'b0_1110_1 : o_data = 4'd8;\n        6'b0_1111_1 : o_data = 4'd6;\n        6'b1_0000_0 : o_data = 4'd4;\n        6'b1_0001_0 : o_data = 4'd2;\n        6'b1_0010_0 : o_data = 4'd1;\n        6'b1_0011_0 : o_data = 4'd11;\n        6'b1_0100_0 : o_data = 4'd10;\n        6'b1_0101_0 : o_data = 4'd13;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd8;\n        6'b1_1000_0 : o_data = 4'd15;\n        6'b1_1001_0 : o_data = 4'd9;\n        6'b1_1010_0 : o_data = 4'd12;\n        6'b1_1011_0 : o_data = 4'd5;\n        6'b1_1100_0 : o_data = 4'd6;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd0;\n        6'b1_1111_0 : o_data = 4'd14;\n        6'b1_0000_1 : o_data = 4'd11;\n        6'b1_0001_1 : o_data = 4'd8;\n        6'b1_0010_1 : o_data = 4'd12;\n        6'b1_0011_1 : o_data = 4'd7;\n        6'b1_0100_1 : o_data = 4'd1;\n        6'b1_0101_1 : o_data = 4'd14;\n        6'b1_0110_1 : o_data = 4'd2;\n        6'b1_0111_1 : o_data = 4'd13;\n        6'b1_1000_1 : o_data = 4'd6;\n        6'b1_1001_1 : o_data = 4'd15;\n        6'b1_1010_1 : o_data = 4'd0;\n        6'b1_1011_1 : o_data = 4'd9;\n        6'b1_1100_1 : o_data = 4'd10;\n        6'b1_1101_1 : o_data = 4'd4;\n        6'b1_1110_1 : o_data = 4'd5;\n        6'b1_1111_1 : o_data = 4'd3;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S5", "rtl/S6.sv": "module S6(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd12;\n        6'b0_0001_0 : o_data = 4'd1;\n        6'b0_0010_0 : o_data = 4'd10;\n        6'b0_0011_0 : o_data = 4'd15;\n        6'b0_0100_0 : o_data = 4'd9;\n        6'b0_0101_0 : o_data = 4'd2;\n        6'b0_0110_0 : o_data = 4'd6;\n        6'b0_0111_0 : o_data = 4'd8;\n        6'b0_1000_0 : o_data = 4'd0;\n        6'b0_1001_0 : o_data = 4'd13;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd4;\n        6'b0_1100_0 : o_data = 4'd14;\n        6'b0_1101_0 : o_data = 4'd7;\n        6'b0_1110_0 : o_data = 4'd5;\n        6'b0_1111_0 : o_data = 4'd11;\n        6'b0_0000_1 : o_data = 4'd10;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd4;\n        6'b0_0011_1 : o_data = 4'd2;\n        6'b0_0100_1 : o_data = 4'd7;\n        6'b0_0101_1 : o_data = 4'd12;\n        6'b0_0110_1 : o_data = 4'd9;\n        6'b0_0111_1 : o_data = 4'd5;\n        6'b0_1000_1 : o_data = 4'd6;\n        6'b0_1001_1 : o_data = 4'd1;\n        6'b0_1010_1 : o_data = 4'd13;\n        6'b0_1011_1 : o_data = 4'd14;\n        6'b0_1100_1 : o_data = 4'd0;\n        6'b0_1101_1 : o_data = 4'd11;\n        6'b0_1110_1 : o_data = 4'd3;\n        6'b0_1111_1 : o_data = 4'd8;\n        6'b1_0000_0 : o_data = 4'd9;\n        6'b1_0001_0 : o_data = 4'd14;\n        6'b1_0010_0 : o_data = 4'd15;\n        6'b1_0011_0 : o_data = 4'd5;\n        6'b1_0100_0 : o_data = 4'd2;\n        6'b1_0101_0 : o_data = 4'd8;\n        6'b1_0110_0 : o_data = 4'd12;\n        6'b1_0111_0 : o_data = 4'd3;\n        6'b1_1000_0 : o_data = 4'd7;\n        6'b1_1001_0 : o_data = 4'd0;\n        6'b1_1010_0 : o_data = 4'd4;\n        6'b1_1011_0 : o_data = 4'd10;\n        6'b1_1100_0 : o_data = 4'd1;\n        6'b1_1101_0 : o_data = 4'd13;\n        6'b1_1110_0 : o_data = 4'd11;\n        6'b1_1111_0 : o_data = 4'd6;\n        6'b1_0000_1 : o_data = 4'd4;\n        6'b1_0001_1 : o_data = 4'd3;\n        6'b1_0010_1 : o_data = 4'd2;\n        6'b1_0011_1 : o_data = 4'd12;\n        6'b1_0100_1 : o_data = 4'd9;\n        6'b1_0101_1 : o_data = 4'd5;\n        6'b1_0110_1 : o_data = 4'd15;\n        6'b1_0111_1 : o_data = 4'd10;\n        6'b1_1000_1 : o_data = 4'd11;\n        6'b1_1001_1 : o_data = 4'd14;\n        6'b1_1010_1 : o_data = 4'd1;\n        6'b1_1011_1 : o_data = 4'd7;\n        6'b1_1100_1 : o_data = 4'd6;\n        6'b1_1101_1 : o_data = 4'd0;\n        6'b1_1110_1 : o_data = 4'd8;\n        6'b1_1111_1 : o_data = 4'd13;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S6", "rtl/S7.sv": "module S7(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd4;\n        6'b0_0001_0 : o_data = 4'd11;\n        6'b0_0010_0 : o_data = 4'd2;\n        6'b0_0011_0 : o_data = 4'd14;\n        6'b0_0100_0 : o_data = 4'd15;\n        6'b0_0101_0 : o_data = 4'd0;\n        6'b0_0110_0 : o_data = 4'd8;\n        6'b0_0111_0 : o_data = 4'd13;\n        6'b0_1000_0 : o_data = 4'd3;\n        6'b0_1001_0 : o_data = 4'd12;\n        6'b0_1010_0 : o_data = 4'd9;\n        6'b0_1011_0 : o_data = 4'd7;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd10;\n        6'b0_1110_0 : o_data = 4'd6;\n        6'b0_1111_0 : o_data = 4'd1;\n        6'b0_0000_1 : o_data = 4'd13;\n        6'b0_0001_1 : o_data = 4'd0;\n        6'b0_0010_1 : o_data = 4'd11;\n        6'b0_0011_1 : o_data = 4'd7;\n        6'b0_0100_1 : o_data = 4'd4;\n        6'b0_0101_1 : o_data = 4'd9;\n        6'b0_0110_1 : o_data = 4'd1;\n        6'b0_0111_1 : o_data = 4'd10;\n        6'b0_1000_1 : o_data = 4'd14;\n        6'b0_1001_1 : o_data = 4'd3;\n        6'b0_1010_1 : o_data = 4'd5;\n        6'b0_1011_1 : o_data = 4'd12;\n        6'b0_1100_1 : o_data = 4'd2;\n        6'b0_1101_1 : o_data = 4'd15;\n        6'b0_1110_1 : o_data = 4'd8;\n        6'b0_1111_1 : o_data = 4'd6;\n        6'b1_0000_0 : o_data = 4'd1;\n        6'b1_0001_0 : o_data = 4'd4;\n        6'b1_0010_0 : o_data = 4'd11;\n        6'b1_0011_0 : o_data = 4'd13;\n        6'b1_0100_0 : o_data = 4'd12;\n        6'b1_0101_0 : o_data = 4'd3;\n        6'b1_0110_0 : o_data = 4'd7;\n        6'b1_0111_0 : o_data = 4'd14;\n        6'b1_1000_0 : o_data = 4'd10;\n        6'b1_1001_0 : o_data = 4'd15;\n        6'b1_1010_0 : o_data = 4'd6;\n        6'b1_1011_0 : o_data = 4'd8;\n        6'b1_1100_0 : o_data = 4'd0;\n        6'b1_1101_0 : o_data = 4'd5;\n        6'b1_1110_0 : o_data = 4'd9;\n        6'b1_1111_0 : o_data = 4'd2;\n        6'b1_0000_1 : o_data = 4'd6;\n        6'b1_0001_1 : o_data = 4'd11;\n        6'b1_0010_1 : o_data = 4'd13;\n        6'b1_0011_1 : o_data = 4'd8;\n        6'b1_0100_1 : o_data = 4'd1;\n        6'b1_0101_1 : o_data = 4'd4;\n        6'b1_0110_1 : o_data = 4'd10;\n        6'b1_0111_1 : o_data = 4'd7;\n        6'b1_1000_1 : o_data = 4'd9;\n        6'b1_1001_1 : o_data = 4'd5;\n        6'b1_1010_1 : o_data = 4'd0;\n        6'b1_1011_1 : o_data = 4'd15;\n        6'b1_1100_1 : o_data = 4'd14;\n        6'b1_1101_1 : o_data = 4'd2;\n        6'b1_1110_1 : o_data = 4'd3;\n        6'b1_1111_1 : o_data = 4'd12;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S7", "rtl/S8.sv": "module S8(\n    input  logic [5:0] i_data,\n    output logic [3:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        6'b0_0000_0 : o_data = 4'd13;\n        6'b0_0001_0 : o_data = 4'd2;\n        6'b0_0010_0 : o_data = 4'd8;\n        6'b0_0011_0 : o_data = 4'd4;\n        6'b0_0100_0 : o_data = 4'd6;\n        6'b0_0101_0 : o_data = 4'd15;\n        6'b0_0110_0 : o_data = 4'd11;\n        6'b0_0111_0 : o_data = 4'd1;\n        6'b0_1000_0 : o_data = 4'd10;\n        6'b0_1001_0 : o_data = 4'd9;\n        6'b0_1010_0 : o_data = 4'd3;\n        6'b0_1011_0 : o_data = 4'd14;\n        6'b0_1100_0 : o_data = 4'd5;\n        6'b0_1101_0 : o_data = 4'd0;\n        6'b0_1110_0 : o_data = 4'd12;\n        6'b0_1111_0 : o_data = 4'd7;\n        6'b0_0000_1 : o_data = 4'd1;\n        6'b0_0001_1 : o_data = 4'd15;\n        6'b0_0010_1 : o_data = 4'd13;\n        6'b0_0011_1 : o_data = 4'd8;\n        6'b0_0100_1 : o_data = 4'd10;\n        6'b0_0101_1 : o_data = 4'd3;\n        6'b0_0110_1 : o_data = 4'd7;\n        6'b0_0111_1 : o_data = 4'd4;\n        6'b0_1000_1 : o_data = 4'd12;\n        6'b0_1001_1 : o_data = 4'd5;\n        6'b0_1010_1 : o_data = 4'd6;\n        6'b0_1011_1 : o_data = 4'd11;\n        6'b0_1100_1 : o_data = 4'd0;\n        6'b0_1101_1 : o_data = 4'd14;\n        6'b0_1110_1 : o_data = 4'd9;\n        6'b0_1111_1 : o_data = 4'd2;\n        6'b1_0000_0 : o_data = 4'd7;\n        6'b1_0001_0 : o_data = 4'd11;\n        6'b1_0010_0 : o_data = 4'd4;\n        6'b1_0011_0 : o_data = 4'd1;\n        6'b1_0100_0 : o_data = 4'd9;\n        6'b1_0101_0 : o_data = 4'd12;\n        6'b1_0110_0 : o_data = 4'd14;\n        6'b1_0111_0 : o_data = 4'd2;\n        6'b1_1000_0 : o_data = 4'd0;\n        6'b1_1001_0 : o_data = 4'd6;\n        6'b1_1010_0 : o_data = 4'd10;\n        6'b1_1011_0 : o_data = 4'd13;\n        6'b1_1100_0 : o_data = 4'd15;\n        6'b1_1101_0 : o_data = 4'd3;\n        6'b1_1110_0 : o_data = 4'd5;\n        6'b1_1111_0 : o_data = 4'd8;\n        6'b1_0000_1 : o_data = 4'd2;\n        6'b1_0001_1 : o_data = 4'd1;\n        6'b1_0010_1 : o_data = 4'd14;\n        6'b1_0011_1 : o_data = 4'd7;\n        6'b1_0100_1 : o_data = 4'd4;\n        6'b1_0101_1 : o_data = 4'd10;\n        6'b1_0110_1 : o_data = 4'd8;\n        6'b1_0111_1 : o_data = 4'd13;\n        6'b1_1000_1 : o_data = 4'd15;\n        6'b1_1001_1 : o_data = 4'd12;\n        6'b1_1010_1 : o_data = 4'd9;\n        6'b1_1011_1 : o_data = 4'd0;\n        6'b1_1100_1 : o_data = 4'd3;\n        6'b1_1101_1 : o_data = 4'd5;\n        6'b1_1110_1 : o_data = 4'd6;\n        6'b1_1111_1 : o_data = 4'd11;\n        default: o_data = 4'd0;\n    endcase\nend\n\nendmodule : S8", "rtl/des_dec.sv": "module des_dec #(\n    parameter NBW_DATA = 'd64,\n    parameter NBW_KEY  = 'd64\n) (\n    input  logic              clk,\n    input  logic              rst_async_n,\n    input  logic              i_valid,\n    input  logic [1:NBW_DATA] i_data,\n    input  logic [1:NBW_KEY]  i_key,\n    output logic              o_valid,\n    output logic [1:NBW_DATA] o_data\n);\n\nlocalparam ROUNDS = 'd16;\nlocalparam EXPANDED_BLOCK = 'd48;\nlocalparam USED_KEY = 'd56;\n\nlogic [1:(NBW_DATA/2)] L16;\nlogic [1:(NBW_DATA/2)] R16;\nlogic [1:(NBW_DATA/2)] L_ff [0:ROUNDS-1];\nlogic [1:(NBW_DATA/2)] R_ff [0:ROUNDS-1];\nlogic [1:(USED_KEY/2)] C16;\nlogic [1:(USED_KEY/2)] D16;\nlogic [1:(USED_KEY/2)] C_ff [0:ROUNDS-1];\nlogic [1:(USED_KEY/2)] D_ff [0:ROUNDS-1];\nlogic [1:NBW_DATA]     last_perm;\nlogic [ROUNDS-1:0]     valid_ff;\n\nalways_ff @ (posedge clk or negedge rst_async_n) begin\n    if(!rst_async_n) begin\n        valid_ff <= 0;\n    end else begin\n        valid_ff <= {valid_ff[ROUNDS-2:0], i_valid};\n    end\nend\n\nassign o_valid = valid_ff[ROUNDS-1];\n\nassign R16 = {i_data[58], i_data[50], i_data[42], i_data[34], i_data[26], i_data[18], i_data[10], i_data[2],\n              i_data[60], i_data[52], i_data[44], i_data[36], i_data[28], i_data[20], i_data[12], i_data[4],\n              i_data[62], i_data[54], i_data[46], i_data[38], i_data[30], i_data[22], i_data[14], i_data[6],\n              i_data[64], i_data[56], i_data[48], i_data[40], i_data[32], i_data[24], i_data[16], i_data[8]};\n\nassign L16 = {i_data[57], i_data[49], i_data[41], i_data[33], i_data[25], i_data[17], i_data[ 9], i_data[1],\n              i_data[59], i_data[51], i_data[43], i_data[35], i_data[27], i_data[19], i_data[11], i_data[3],\n              i_data[61], i_data[53], i_data[45], i_data[37], i_data[29], i_data[21], i_data[13], i_data[5],\n              i_data[63], i_data[55], i_data[47], i_data[39], i_data[31], i_data[23], i_data[15], i_data[7]};\n\nassign C16 = {i_key[57], i_key[49], i_key[41], i_key[33], i_key[25], i_key[17], i_key[ 9],\n              i_key[ 1], i_key[58], i_key[50], i_key[42], i_key[34], i_key[26], i_key[18],\n              i_key[10], i_key[ 2], i_key[59], i_key[51], i_key[43], i_key[35], i_key[27],\n              i_key[19], i_key[11], i_key[ 3], i_key[60], i_key[52], i_key[44], i_key[36]};\n\nassign D16 = {i_key[63], i_key[55], i_key[47], i_key[39], i_key[31], i_key[23], i_key[15],\n              i_key[ 7], i_key[62], i_key[54], i_key[46], i_key[38], i_key[30], i_key[22],\n              i_key[14], i_key[ 6], i_key[61], i_key[53], i_key[45], i_key[37], i_key[29],\n              i_key[21], i_key[13], i_key[ 5], i_key[28], i_key[20], i_key[12], i_key[ 4]};\n\ngenerate\n    for (genvar i = ROUNDS-1; i >= 0; i--) begin : rounds\n        logic [1:EXPANDED_BLOCK] round_key;\n        logic [1:(USED_KEY/2)]   C_nx;\n        logic [1:(USED_KEY/2)]   D_nx;\n        logic [1:USED_KEY]       perm_ch;\n        logic [1:(NBW_DATA/2)]   L_nx;\n        logic [1:EXPANDED_BLOCK] L_expanded;\n        logic [1:6]              Primitive_input  [1:8];\n        logic [1:4]              Primitive_output [1:8];\n        logic [1:(NBW_DATA/2)]   perm_in;\n\n        if(i == 15) begin\n            assign perm_ch = {C16, D16};\n        end else begin\n            assign perm_ch = {C_ff[i+1], D_ff[i+1]};\n        end\n        assign round_key = {perm_ch[14], perm_ch[17], perm_ch[11], perm_ch[24], perm_ch[ 1], perm_ch[ 5],\n                            perm_ch[ 3], perm_ch[28], perm_ch[15], perm_ch[ 6], perm_ch[21], perm_ch[10],\n                            perm_ch[23], perm_ch[19], perm_ch[12], perm_ch[ 4], perm_ch[26], perm_ch[ 8],\n                            perm_ch[16], perm_ch[ 7], perm_ch[27], perm_ch[20], perm_ch[13], perm_ch[ 2],\n                            perm_ch[41], perm_ch[52], perm_ch[31], perm_ch[37], perm_ch[47], perm_ch[55],\n                            perm_ch[30], perm_ch[40], perm_ch[51], perm_ch[45], perm_ch[33], perm_ch[48],\n                            perm_ch[44], perm_ch[49], perm_ch[39], perm_ch[56], perm_ch[34], perm_ch[53],\n                            perm_ch[46], perm_ch[42], perm_ch[50], perm_ch[36], perm_ch[29], perm_ch[32]};\n\n        if(i == 0 || i == 1 || i == 8 || i == 15) begin\n            if(i == 15) begin\n                assign C_nx = {C16[(USED_KEY/2)], C16[1:(USED_KEY/2)-1]};\n                assign D_nx = {D16[(USED_KEY/2)], D16[1:(USED_KEY/2)-1]};\n            end else begin\n                assign C_nx = {C_ff[i+1][(USED_KEY/2)], C_ff[i+1][1:(USED_KEY/2)-1]};\n                assign D_nx = {D_ff[i+1][(USED_KEY/2)], D_ff[i+1][1:(USED_KEY/2)-1]};\n            end\n        end else begin\n            assign C_nx = {C_ff[i+1][(USED_KEY/2)-1+:2], C_ff[i+1][1:(USED_KEY/2)-2]};\n            assign D_nx = {D_ff[i+1][(USED_KEY/2)-1+:2], D_ff[i+1][1:(USED_KEY/2)-2]};\n        end\n\n        assign Primitive_input[1] = L_expanded[ 1:6 ] ^ round_key[ 1:6 ];\n        assign Primitive_input[2] = L_expanded[ 7:12] ^ round_key[ 7:12];\n        assign Primitive_input[3] = L_expanded[13:18] ^ round_key[13:18];\n        assign Primitive_input[4] = L_expanded[19:24] ^ round_key[19:24];\n        assign Primitive_input[5] = L_expanded[25:30] ^ round_key[25:30];\n        assign Primitive_input[6] = L_expanded[31:36] ^ round_key[31:36];\n        assign Primitive_input[7] = L_expanded[37:42] ^ round_key[37:42];\n        assign Primitive_input[8] = L_expanded[43:48] ^ round_key[43:48];\n\n        S1 uu_S1 (\n            .i_data(Primitive_input [1]),\n            .o_data(Primitive_output[1])\n        );\n\n        S2 uu_S2 (\n            .i_data(Primitive_input [2]),\n            .o_data(Primitive_output[2])\n        );\n\n        S3 uu_S3 (\n            .i_data(Primitive_input [3]),\n            .o_data(Primitive_output[3])\n        );\n\n        S4 uu_S4 (\n            .i_data(Primitive_input [4]),\n            .o_data(Primitive_output[4])\n        );\n\n        S5 uu_S5 (\n            .i_data(Primitive_input [5]),\n            .o_data(Primitive_output[5])\n        );\n\n        S6 uu_S6 (\n            .i_data(Primitive_input [6]),\n            .o_data(Primitive_output[6])\n        );\n\n        S7 uu_S7 (\n            .i_data(Primitive_input [7]),\n            .o_data(Primitive_output[7])\n        );\n\n        S8 uu_S8 (\n            .i_data(Primitive_input [8]),\n            .o_data(Primitive_output[8])\n        );\n\n        assign perm_in = {Primitive_output[1], Primitive_output[2], Primitive_output[3], Primitive_output[4],\n                          Primitive_output[5], Primitive_output[6], Primitive_output[7], Primitive_output[8]};\n\n        assign L_nx = {perm_in[16], perm_in[ 7], perm_in[20], perm_in[21],\n                       perm_in[29], perm_in[12], perm_in[28], perm_in[17],\n                       perm_in[ 1], perm_in[15], perm_in[23], perm_in[26],\n                       perm_in[ 5], perm_in[18], perm_in[31], perm_in[10],\n                       perm_in[ 2], perm_in[ 8], perm_in[24], perm_in[14],\n                       perm_in[32], perm_in[27], perm_in[ 3], perm_in[ 9],\n                       perm_in[19], perm_in[13], perm_in[30], perm_in[ 6],\n                       perm_in[22], perm_in[11], perm_in[ 4], perm_in[25]};\n\n        if(i == 15) begin\n            assign L_expanded = {L16[32], L16[ 1], L16[ 2], L16[ 3], L16[ 4], L16[ 5],\n                                 L16[ 4], L16[ 5], L16[ 6], L16[ 7], L16[ 8], L16[ 9],\n                                 L16[ 8], L16[ 9], L16[10], L16[11], L16[12], L16[13],\n                                 L16[12], L16[13], L16[14], L16[15], L16[16], L16[17],\n                                 L16[16], L16[17], L16[18], L16[19], L16[20], L16[21],\n                                 L16[20], L16[21], L16[22], L16[23], L16[24], L16[25],\n                                 L16[24], L16[25], L16[26], L16[27], L16[28], L16[29],\n                                 L16[28], L16[29], L16[30], L16[31], L16[32], L16[ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    if(i_valid) begin\n                        L_ff[i] <= L_nx ^ R16;\n                        R_ff[i] <= L16;\n                        C_ff[i] <= C_nx;\n                        D_ff[i] <= D_nx;\n                    end\n                end\n            end\n        end else begin\n            assign L_expanded = {L_ff[i+1][32], L_ff[i+1][ 1], L_ff[i+1][ 2], L_ff[i+1][ 3], L_ff[i+1][ 4], L_ff[i+1][ 5],\n                                 L_ff[i+1][ 4], L_ff[i+1][ 5], L_ff[i+1][ 6], L_ff[i+1][ 7], L_ff[i+1][ 8], L_ff[i+1][ 9],\n                                 L_ff[i+1][ 8], L_ff[i+1][ 9], L_ff[i+1][10], L_ff[i+1][11], L_ff[i+1][12], L_ff[i+1][13],\n                                 L_ff[i+1][12], L_ff[i+1][13], L_ff[i+1][14], L_ff[i+1][15], L_ff[i+1][16], L_ff[i+1][17],\n                                 L_ff[i+1][16], L_ff[i+1][17], L_ff[i+1][18], L_ff[i+1][19], L_ff[i+1][20], L_ff[i+1][21],\n                                 L_ff[i+1][20], L_ff[i+1][21], L_ff[i+1][22], L_ff[i+1][23], L_ff[i+1][24], L_ff[i+1][25],\n                                 L_ff[i+1][24], L_ff[i+1][25], L_ff[i+1][26], L_ff[i+1][27], L_ff[i+1][28], L_ff[i+1][29],\n                                 L_ff[i+1][28], L_ff[i+1][29], L_ff[i+1][30], L_ff[i+1][31], L_ff[i+1][32], L_ff[i+1][ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    L_ff[i] <= L_nx ^ R_ff[i+1];\n                    R_ff[i] <= L_ff[i+1];\n                    C_ff[i] <= C_nx;\n                    D_ff[i] <= D_nx;\n                end\n            end\n        end\n    end\nendgenerate\n\nassign last_perm = {L_ff[0], R_ff[0]};\n\nassign o_data = {last_perm[40], last_perm[8], last_perm[48], last_perm[16], last_perm[56], last_perm[24], last_perm[64], last_perm[32],\n                 last_perm[39], last_perm[7], last_perm[47], last_perm[15], last_perm[55], last_perm[23], last_perm[63], last_perm[31],\n                 last_perm[38], last_perm[6], last_perm[46], last_perm[14], last_perm[54], last_perm[22], last_perm[62], last_perm[30],\n                 last_perm[37], last_perm[5], last_perm[45], last_perm[13], last_perm[53], last_perm[21], last_perm[61], last_perm[29],\n                 last_perm[36], last_perm[4], last_perm[44], last_perm[12], last_perm[52], last_perm[20], last_perm[60], last_perm[28],\n                 last_perm[35], last_perm[3], last_perm[43], last_perm[11], last_perm[51], last_perm[19], last_perm[59], last_perm[27],\n                 last_perm[34], last_perm[2], last_perm[42], last_perm[10], last_perm[50], last_perm[18], last_perm[58], last_perm[26],\n                 last_perm[33], last_perm[1], last_perm[41], last_perm[ 9], last_perm[49], last_perm[17], last_perm[57], last_perm[25]};\n\nendmodule : des_dec", "rtl/des_enc.sv": "module des_enc #(\n    parameter NBW_DATA = 'd64,\n    parameter NBW_KEY  = 'd64\n) (\n    input  logic              clk,\n    input  logic              rst_async_n,\n    input  logic              i_valid,\n    input  logic [1:NBW_DATA] i_data,\n    input  logic [1:NBW_KEY]  i_key,\n    output logic              o_valid,\n    output logic [1:NBW_DATA] o_data\n);\n\nlocalparam ROUNDS = 'd16;\nlocalparam EXPANDED_BLOCK = 'd48;\nlocalparam USED_KEY = 'd56;\n\nlogic [1:NBW_DATA]     IP;\nlogic [1:(NBW_DATA/2)] L0;\nlogic [1:(NBW_DATA/2)] R0;\nlogic [1:(NBW_DATA/2)] L_ff [1:ROUNDS];\nlogic [1:(NBW_DATA/2)] R_ff [1:ROUNDS];\nlogic [1:(USED_KEY/2)] C0;\nlogic [1:(USED_KEY/2)] D0;\nlogic [1:(USED_KEY/2)] C_ff [1:ROUNDS];\nlogic [1:(USED_KEY/2)] D_ff [1:ROUNDS];\nlogic [1:NBW_DATA]     last_perm;\nlogic [ROUNDS-1:0]     valid_ff;\n\nalways_ff @ (posedge clk or negedge rst_async_n) begin\n    if(!rst_async_n) begin\n        valid_ff <= 0;\n    end else begin\n        valid_ff <= {valid_ff[ROUNDS-2:0], i_valid};\n    end\nend\n\nassign o_valid = valid_ff[ROUNDS-1];\n\nassign IP = {i_data[58], i_data[50], i_data[42], i_data[34], i_data[26], i_data[18], i_data[10], i_data[2],\n             i_data[60], i_data[52], i_data[44], i_data[36], i_data[28], i_data[20], i_data[12], i_data[4],\n             i_data[62], i_data[54], i_data[46], i_data[38], i_data[30], i_data[22], i_data[14], i_data[6],\n             i_data[64], i_data[56], i_data[48], i_data[40], i_data[32], i_data[24], i_data[16], i_data[8],\n             i_data[57], i_data[49], i_data[41], i_data[33], i_data[25], i_data[17], i_data[ 9], i_data[1],\n             i_data[59], i_data[51], i_data[43], i_data[35], i_data[27], i_data[19], i_data[11], i_data[3],\n             i_data[61], i_data[53], i_data[45], i_data[37], i_data[29], i_data[21], i_data[13], i_data[5],\n             i_data[63], i_data[55], i_data[47], i_data[39], i_data[31], i_data[23], i_data[15], i_data[7]};\n\nassign L0 = IP[1:NBW_DATA/2];\nassign R0 = IP[(NBW_DATA/2)+1:NBW_DATA];\n\nassign C0 = {i_key[57], i_key[49], i_key[41], i_key[33], i_key[25], i_key[17], i_key[ 9],\n             i_key[ 1], i_key[58], i_key[50], i_key[42], i_key[34], i_key[26], i_key[18],\n             i_key[10], i_key[ 2], i_key[59], i_key[51], i_key[43], i_key[35], i_key[27],\n             i_key[19], i_key[11], i_key[ 3], i_key[60], i_key[52], i_key[44], i_key[36]};\n\nassign D0 = {i_key[63], i_key[55], i_key[47], i_key[39], i_key[31], i_key[23], i_key[15],\n             i_key[ 7], i_key[62], i_key[54], i_key[46], i_key[38], i_key[30], i_key[22],\n             i_key[14], i_key[ 6], i_key[61], i_key[53], i_key[45], i_key[37], i_key[29],\n             i_key[21], i_key[13], i_key[ 5], i_key[28], i_key[20], i_key[12], i_key[ 4]};\n\ngenerate\n    for (genvar i = 1; i <= ROUNDS; i++) begin : rounds\n        logic [1:EXPANDED_BLOCK] round_key;\n        logic [1:(USED_KEY/2)]    C_nx;\n        logic [1:(USED_KEY/2)]    D_nx;\n        logic [1:USED_KEY]        perm_ch;\n        logic [1:(NBW_DATA/2)] R_nx;\n        logic [1:EXPANDED_BLOCK] R_expanded;\n        logic [1:6] Primitive_input  [1:8];\n        logic [1:4] Primitive_output [1:8];\n        logic [1:(NBW_DATA/2)] perm_in;\n\n        assign perm_ch = {C_nx, D_nx};\n        assign round_key = {perm_ch[14], perm_ch[17], perm_ch[11], perm_ch[24], perm_ch[ 1], perm_ch[ 5],\n                            perm_ch[ 3], perm_ch[28], perm_ch[15], perm_ch[ 6], perm_ch[21], perm_ch[10],\n                            perm_ch[23], perm_ch[19], perm_ch[12], perm_ch[ 4], perm_ch[26], perm_ch[ 8],\n                            perm_ch[16], perm_ch[ 7], perm_ch[27], perm_ch[20], perm_ch[13], perm_ch[ 2],\n                            perm_ch[41], perm_ch[52], perm_ch[31], perm_ch[37], perm_ch[47], perm_ch[55],\n                            perm_ch[30], perm_ch[40], perm_ch[51], perm_ch[45], perm_ch[33], perm_ch[48],\n                            perm_ch[44], perm_ch[49], perm_ch[39], perm_ch[56], perm_ch[34], perm_ch[53],\n                            perm_ch[46], perm_ch[42], perm_ch[50], perm_ch[36], perm_ch[29], perm_ch[32]};\n\n        if(i == 1 || i == 2 || i == 9 || i == 16) begin\n            if(i == 1) begin\n                assign C_nx = {C0[2:(USED_KEY/2)], C0[1]};\n                assign D_nx = {D0[2:(USED_KEY/2)], D0[1]};\n            end else begin\n                assign C_nx = {C_ff[i-1][2:(USED_KEY/2)], C_ff[i-1][1]};\n                assign D_nx = {D_ff[i-1][2:(USED_KEY/2)], D_ff[i-1][1]};\n            end\n        end else begin\n            assign C_nx = {C_ff[i-1][3:(USED_KEY/2)], C_ff[i-1][1:2]};\n            assign D_nx = {D_ff[i-1][3:(USED_KEY/2)], D_ff[i-1][1:2]};\n        end\n\n        assign Primitive_input[1] = R_expanded[ 1:6 ] ^ round_key[ 1:6 ];\n        assign Primitive_input[2] = R_expanded[ 7:12] ^ round_key[ 7:12];\n        assign Primitive_input[3] = R_expanded[13:18] ^ round_key[13:18];\n        assign Primitive_input[4] = R_expanded[19:24] ^ round_key[19:24];\n        assign Primitive_input[5] = R_expanded[25:30] ^ round_key[25:30];\n        assign Primitive_input[6] = R_expanded[31:36] ^ round_key[31:36];\n        assign Primitive_input[7] = R_expanded[37:42] ^ round_key[37:42];\n        assign Primitive_input[8] = R_expanded[43:48] ^ round_key[43:48];\n\n        S1 uu_S1 (\n            .i_data(Primitive_input [1]),\n            .o_data(Primitive_output[1])\n        );\n\n        S2 uu_S2 (\n            .i_data(Primitive_input [2]),\n            .o_data(Primitive_output[2])\n        );\n\n        S3 uu_S3 (\n            .i_data(Primitive_input [3]),\n            .o_data(Primitive_output[3])\n        );\n\n        S4 uu_S4 (\n            .i_data(Primitive_input [4]),\n            .o_data(Primitive_output[4])\n        );\n\n        S5 uu_S5 (\n            .i_data(Primitive_input [5]),\n            .o_data(Primitive_output[5])\n        );\n\n        S6 uu_S6 (\n            .i_data(Primitive_input [6]),\n            .o_data(Primitive_output[6])\n        );\n\n        S7 uu_S7 (\n            .i_data(Primitive_input [7]),\n            .o_data(Primitive_output[7])\n        );\n\n        S8 uu_S8 (\n            .i_data(Primitive_input [8]),\n            .o_data(Primitive_output[8])\n        );\n\n        assign perm_in = {Primitive_output[1], Primitive_output[2], Primitive_output[3], Primitive_output[4],\n                          Primitive_output[5], Primitive_output[6], Primitive_output[7], Primitive_output[8]};\n\n        assign R_nx = {perm_in[16], perm_in[ 7], perm_in[20], perm_in[21],\n                       perm_in[29], perm_in[12], perm_in[28], perm_in[17],\n                       perm_in[ 1], perm_in[15], perm_in[23], perm_in[26],\n                       perm_in[ 5], perm_in[18], perm_in[31], perm_in[10],\n                       perm_in[ 2], perm_in[ 8], perm_in[24], perm_in[14],\n                       perm_in[32], perm_in[27], perm_in[ 3], perm_in[ 9],\n                       perm_in[19], perm_in[13], perm_in[30], perm_in[ 6],\n                       perm_in[22], perm_in[11], perm_in[ 4], perm_in[25]};\n\n        if(i == 1) begin\n            assign R_expanded = {R0[32], R0[ 1], R0[ 2], R0[ 3], R0[ 4], R0[ 5],\n                                 R0[ 4], R0[ 5], R0[ 6], R0[ 7], R0[ 8], R0[ 9],\n                                 R0[ 8], R0[ 9], R0[10], R0[11], R0[12], R0[13],\n                                 R0[12], R0[13], R0[14], R0[15], R0[16], R0[17],\n                                 R0[16], R0[17], R0[18], R0[19], R0[20], R0[21],\n                                 R0[20], R0[21], R0[22], R0[23], R0[24], R0[25],\n                                 R0[24], R0[25], R0[26], R0[27], R0[28], R0[29],\n                                 R0[28], R0[29], R0[30], R0[31], R0[32], R0[ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    if(i_valid) begin\n                        L_ff[i] <= R0;\n                        R_ff[i] <= R_nx ^ L0;\n                        C_ff[i] <= C_nx;\n                        D_ff[i] <= D_nx;\n                    end\n                end\n            end\n        end else begin\n            assign R_expanded = {R_ff[i-1][32], R_ff[i-1][ 1], R_ff[i-1][ 2], R_ff[i-1][ 3], R_ff[i-1][ 4], R_ff[i-1][ 5],\n                                 R_ff[i-1][ 4], R_ff[i-1][ 5], R_ff[i-1][ 6], R_ff[i-1][ 7], R_ff[i-1][ 8], R_ff[i-1][ 9],\n                                 R_ff[i-1][ 8], R_ff[i-1][ 9], R_ff[i-1][10], R_ff[i-1][11], R_ff[i-1][12], R_ff[i-1][13],\n                                 R_ff[i-1][12], R_ff[i-1][13], R_ff[i-1][14], R_ff[i-1][15], R_ff[i-1][16], R_ff[i-1][17],\n                                 R_ff[i-1][16], R_ff[i-1][17], R_ff[i-1][18], R_ff[i-1][19], R_ff[i-1][20], R_ff[i-1][21],\n                                 R_ff[i-1][20], R_ff[i-1][21], R_ff[i-1][22], R_ff[i-1][23], R_ff[i-1][24], R_ff[i-1][25],\n                                 R_ff[i-1][24], R_ff[i-1][25], R_ff[i-1][26], R_ff[i-1][27], R_ff[i-1][28], R_ff[i-1][29],\n                                 R_ff[i-1][28], R_ff[i-1][29], R_ff[i-1][30], R_ff[i-1][31], R_ff[i-1][32], R_ff[i-1][ 1]};\n\n            always_ff @ (posedge clk or negedge rst_async_n) begin\n                if(!rst_async_n) begin\n                    L_ff[i] <= 0;\n                    R_ff[i] <= 0;\n                    C_ff[i] <= 0;\n                    D_ff[i] <= 0;\n                end else begin\n                    L_ff[i] <= R_ff[i-1];\n                    R_ff[i] <= R_nx ^ L_ff[i-1];\n                    C_ff[i] <= C_nx;\n                    D_ff[i] <= D_nx;\n                end\n            end\n        end\n    end\nendgenerate\n\nassign last_perm = {R_ff[ROUNDS], L_ff[ROUNDS]};\n\nassign o_data = {last_perm[40], last_perm[8], last_perm[48], last_perm[16], last_perm[56], last_perm[24], last_perm[64], last_perm[32],\n                 last_perm[39], last_perm[7], last_perm[47], last_perm[15], last_perm[55], last_perm[23], last_perm[63], last_perm[31],\n                 last_perm[38], last_perm[6], last_perm[46], last_perm[14], last_perm[54], last_perm[22], last_perm[62], last_perm[30],\n                 last_perm[37], last_perm[5], last_perm[45], last_perm[13], last_perm[53], last_perm[21], last_perm[61], last_perm[29],\n                 last_perm[36], last_perm[4], last_perm[44], last_perm[12], last_perm[52], last_perm[20], last_perm[60], last_perm[28],\n                 last_perm[35], last_perm[3], last_perm[43], last_perm[11], last_perm[51], last_perm[19], last_perm[59], last_perm[27],\n                 last_perm[34], last_perm[2], last_perm[42], last_perm[10], last_perm[50], last_perm[18], last_perm[58], last_perm[26],\n                 last_perm[33], last_perm[1], last_perm[41], last_perm[ 9], last_perm[49], last_perm[17], last_perm[57], last_perm[25]};\n\nendmodule : des_enc", "verif/tb_3des_dec.sv": "module tb;\n\nparameter NBW_DATA = 'd64;\nparameter NBW_KEY  = 'd192;\n\nlogic              clk;\nlogic              rst_async_n;\nlogic              i_start;\nlogic [1:NBW_DATA] i_data;\nlogic [1:NBW_KEY ] i_key;\nlogic              o_done;\nlogic [1:NBW_DATA] o_data;\n\ndes3_dec #(\n    .NBW_DATA(NBW_DATA),\n    .NBW_KEY (NBW_KEY )\n) uu_des3_dec (\n    .clk        (clk        ),\n    .rst_async_n(rst_async_n),\n    .i_start    (i_start    ),\n    .i_data     (i_data     ),\n    .i_key      (i_key      ),\n    .o_done     (o_done     ),\n    .o_data     (o_data     )\n);\n\ninitial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0,tb);\nend\n\nalways #5 clk = ~clk;\n\ntask Single_test(logic [1:NBW_KEY] key, logic [1:NBW_DATA] data, logic [1:NBW_DATA] expected);\n    i_key   = key;\n    i_data  = data;\n    i_start = 1;\n\n    @(negedge clk);\n    i_start = 0;\n\n    @(posedge o_done);\n    @(negedge clk);\n    if(o_data != expected) begin\n        $display(\"FAIL!\");\n        $display(\"Expected %h, got %h\", expected, o_data);\n    end else begin\n        $display(\"PASS!\");\n    end\nendtask\n\ntask Burst_test();\n    i_key   = 192'hB1FECAFEBEBAB1FEABCDABCDABCDABCD8765432187654321;\n    i_data  = 64'h4321432143214321;\n    i_start = 1;\n\n    @(negedge clk); // This next i_data must be ignored by the RTL\n    i_data  = 64'h123456789ABCDEF0;\n\n    @(negedge clk); // This next i_data and i_key must be ignored by the RTL\n    i_data  = 64'h1234123412341234;\n    i_key   = 192'hABCDABCDABCDABCD8765432187654321B1FECAFEBEBAB1FE;\n\n    @(negedge clk);\n    i_start = 0;\n\n    @(posedge o_done);\n    \n    // The ignored data/key can not change the output data, nor the o_done\n    for(int i = 0; i < 3; i++) begin // Using 3 to test the data output for the first value, and validating that the changes in i_data and i_key while the RTL is not done won't affect o_data\n        @(negedge clk);\n        if(o_done != 1) begin\n            $display(\"FAIL! o_done should be asserted here.\");\n        end\n        \n        if(o_data != 64'h32966b20b88edf53) begin\n            $display(\"FAIL!\");\n            $display(\"Expected %h, got %h\", 64'h32966b20b88edf53, o_data);\n        end else begin\n            $display(\"PASS!\");\n        end\n    end\n    \nendtask\n\ninitial begin\n    clk = 0;\n    i_start = 0;\n    rst_async_n = 1;\n    #1;\n    rst_async_n = 0;\n    #2;\n    rst_async_n = 1;\n    @(negedge clk);\n\n    $display(\"\\nSingle Tests\");\n    Single_test(192'h0123456789abcdeffedcba9876543210abcdef9876543210, 64'h0123456789ABCDEF, 64'h29d92f40554ab5dc);\n    Single_test(192'h0123456789abcdeffedcba9876543210abcdef9876543210, 64'hFEDCBA9876543210, 64'hf27a8ffec7e6be1e);\n    Single_test(192'hBEBACAFE12345678B1FECAFE876543219898898974744747, 64'hFEDCBA9876543210, 64'h64ff5c5ace7f03ba);\n    Single_test(192'hBEBACAFE12345678B1FECAFE876543219898898974744747, 64'hB1FECAFEBEBAB1FE, 64'hc78f7a5f19428db8);\n\n    $display(\"\\nBurst Test\");\n    Burst_test();\n\n    @(negedge clk);\n    @(negedge clk);\n\n    $finish();\nend\n\nendmodule"}, "patch": {"rtl/des3_dec.sv": "", "rtl/des_dec.sv": "", "rtl/des_enc.sv": ""}, "harness": {"docker-compose.yml": "services:\n  sanity:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache\n\n  des_enc:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env_des_enc\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache\n  \n  des_dec:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env_des_dec\n    command     : pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache", "src/.env": "VERILOG_SOURCES = /code/rtl/des3_dec.sv /code/rtl/des_dec.sv /code/rtl/des_enc.sv /code/rtl/S1.sv /code/rtl/S2.sv /code/rtl/S3.sv /code/rtl/S4.sv /code/rtl/S5.sv /code/rtl/S6.sv /code/rtl/S7.sv /code/rtl/S8.sv\nTOPLEVEL        = des3_dec\nMODULE          = test_des3_dec\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 7-create-des3-dec\nWAVE            = true", "src/.env_des_dec": "VERILOG_SOURCES = /code/rtl/des_dec.sv /code/rtl/S1.sv /code/rtl/S2.sv /code/rtl/S3.sv /code/rtl/S4.sv /code/rtl/S5.sv /code/rtl/S6.sv /code/rtl/S7.sv /code/rtl/S8.sv\nTOPLEVEL        = des_dec\nMODULE          = test_des_dec\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 7-create-des3-dec\nWAVE            = true", "src/.env_des_enc": "VERILOG_SOURCES = /code/rtl/des_enc.sv /code/rtl/S1.sv /code/rtl/S2.sv /code/rtl/S3.sv /code/rtl/S4.sv /code/rtl/S5.sv /code/rtl/S6.sv /code/rtl/S7.sv /code/rtl/S8.sv\nTOPLEVEL        = des_enc\nMODULE          = test_des_enc\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 7-create-des3-dec\nWAVE            = true", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom collections import deque\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nclass des:\n    def __init__(self):\n        self.reset()\n\n    def reset(self):\n        self.data_out = 0\n        self.enc_out = 0\n        self.dec_out = 0\n        self.fifo = []\n\n    def permute(self, block, table, n):\n        result = 0\n        for i in range(len(table)):\n            bit = (block >> (n - table[i])) & 1\n            result |= (bit << (len(table) - 1 - i))\n        return result\n\n    def left_rotate(self, val, n):\n        return ((val << n) & 0x0FFFFFFF) | (val >> (28 - n))\n\n    def sbox(self, box, val):\n        row = ((val >> 5) & 1) * 2 + (val & 1)\n        col = (val >> 1) & 0xF\n        return box[row][col]\n\n    def f(self, R, subkey):\n        E = [32,1,2,3,4,5,4,5,6,7,8,9,\n             8,9,10,11,12,13,12,13,14,15,16,17,\n             16,17,18,19,20,21,20,21,22,23,24,25,\n             24,25,26,27,28,29,28,29,30,31,32,1]\n\n        P = [16,7,20,21,29,12,28,17,\n             1,15,23,26,5,18,31,10,\n             2,8,24,14,32,27,3,9,\n             19,13,30,6,22,11,4,25]\n\n        SBOXES = self.sboxes\n\n        expanded = self.permute(R << 32, E, 64)\n        xored = expanded ^ subkey\n\n        output = 0\n        for i in range(8):\n            chunk = (xored >> (42 - i*6)) & 0x3F\n            sbox_val = self.sbox(SBOXES[i], chunk)\n            output = (output << 4) | sbox_val\n\n        return self.permute(output << 32, P, 64)\n\n    def generate_subkeys(self, key):\n        PC1 = [57,49,41,33,25,17,9,\n               1,58,50,42,34,26,18,\n               10,2,59,51,43,35,27,\n               19,11,3,60,52,44,36,\n               63,55,47,39,31,23,15,\n               7,62,54,46,38,30,22,\n               14,6,61,53,45,37,29,\n               21,13,5,28,20,12,4]\n\n        PC2 = [14,17,11,24,1,5,\n               3,28,15,6,21,10,\n               23,19,12,4,26,8,\n               16,7,27,20,13,2,\n               41,52,31,37,47,55,\n               30,40,51,45,33,48,\n               44,49,39,56,34,53,\n               46,42,50,36,29,32]\n\n        rotations = [1, 1, 2, 2, 2, 2, 2, 2,\n                     1, 2, 2, 2, 2, 2, 2, 1]\n\n        key56 = self.permute(key, PC1, 64)\n        C = (key56 >> 28) & 0xFFFFFFF\n        D = key56 & 0xFFFFFFF\n\n        subkeys = []\n        for rot in rotations:\n            C = self.left_rotate(C, rot)\n            D = self.left_rotate(D, rot)\n            CD = (C << 28) | D\n            subkey = self.permute(CD, PC2, 56)\n            subkeys.append(subkey)\n        return subkeys\n    \n    def decrypt(self, data, key):\n        IP = [58,50,42,34,26,18,10,2,\n              60,52,44,36,28,20,12,4,\n              62,54,46,38,30,22,14,6,\n              64,56,48,40,32,24,16,8,\n              57,49,41,33,25,17,9,1,\n              59,51,43,35,27,19,11,3,\n              61,53,45,37,29,21,13,5,\n              63,55,47,39,31,23,15,7]\n\n        FP = [40,8,48,16,56,24,64,32,\n              39,7,47,15,55,23,63,31,\n              38,6,46,14,54,22,62,30,\n              37,5,45,13,53,21,61,29,\n              36,4,44,12,52,20,60,28,\n              35,3,43,11,51,19,59,27,\n              34,2,42,10,50,18,58,26,\n              33,1,41,9,49,17,57,25]\n\n        block = self.permute(data, IP, 64)\n        L = (block >> 32) & 0xFFFFFFFF\n        R = block & 0xFFFFFFFF\n\n        subkeys = self.generate_subkeys(key)[::-1]  # Reverse subkeys for decryption\n\n        for i in range(16):\n            temp = R\n            R = L ^ self.f(R, subkeys[i])\n            L = temp\n\n        pre_output = (R << 32) | L\n        self.dec_out = self.permute(pre_output, FP, 64)\n\n    def encrypt(self, data, key):\n        IP = [58,50,42,34,26,18,10,2,\n              60,52,44,36,28,20,12,4,\n              62,54,46,38,30,22,14,6,\n              64,56,48,40,32,24,16,8,\n              57,49,41,33,25,17,9,1,\n              59,51,43,35,27,19,11,3,\n              61,53,45,37,29,21,13,5,\n              63,55,47,39,31,23,15,7]\n\n        FP = [40,8,48,16,56,24,64,32,\n              39,7,47,15,55,23,63,31,\n              38,6,46,14,54,22,62,30,\n              37,5,45,13,53,21,61,29,\n              36,4,44,12,52,20,60,28,\n              35,3,43,11,51,19,59,27,\n              34,2,42,10,50,18,58,26,\n              33,1,41,9,49,17,57,25]\n\n        block = self.permute(data, IP, 64)\n        L = (block >> 32) & 0xFFFFFFFF\n        R = block & 0xFFFFFFFF\n\n        subkeys = self.generate_subkeys(key)\n\n        for i in range(16):\n            temp = R\n            R = L ^ self.f(R, subkeys[i])\n            L = temp\n\n        pre_output = (R << 32) | L\n        self.enc_out = self.permute(pre_output, FP, 64)\n    \n    def des3_enc(self, data, key):\n        K1 = (key & 0xFFFFFFFFFFFFFFFF00000000000000000000000000000000) >> 128\n        K2 = (key & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64\n        K3 = key & 0x00000000000000000000000000000000FFFFFFFFFFFFFFFF\n        self.encrypt(data, K1)\n        self.decrypt(self.enc_out, K2)\n        self.encrypt(self.dec_out, K3)\n\n        self.fifo.append(self.enc_out)\n    \n    def des3_dec(self, data, key):\n        K1 = (key & 0xFFFFFFFFFFFFFFFF00000000000000000000000000000000) >> 128\n        K2 = (key & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64\n        K3 =  key & 0x00000000000000000000000000000000FFFFFFFFFFFFFFFF\n        self.decrypt(data, K3)\n        self.encrypt(self.dec_out, K2)\n        self.decrypt(self.enc_out, K1)\n\n        self.fifo.append(self.dec_out)\n    \n    def read_data(self):\n        if self.fifo:\n            return self.fifo.pop(0)\n        return 0\n\n    # Full DES S-box definitions\n    sboxes = [\n        [\n            [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n            [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n            [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n            [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13]\n        ],\n        [\n            [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10],\n            [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5],\n            [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15],\n            [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9]\n        ],\n        [\n            [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8],\n            [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1],\n            [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7],\n            [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12]\n        ],\n        [\n            [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15],\n            [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9],\n            [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4],\n            [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14]\n        ],\n        [\n            [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9],\n            [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6],\n            [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14],\n            [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3]\n        ],\n        [\n            [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11],\n            [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8],\n            [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6],\n            [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13]\n        ],\n        [\n            [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1],\n            [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6],\n            [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2],\n            [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12]\n        ],\n        [\n            [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7],\n            [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2],\n            [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8],\n            [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]\n        ]\n    ]", "src/test_des3_dec.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, FallingEdge\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data   = dut.o_data.value.integer\n    model_data = model.read_data()\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\n@cocotb.test()\nasync def test_des3_dec(dut):\n    \"\"\"Test the des3_dec module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    model = hrs_lb.des()\n\n    resets = 2\n    runs = 300\n\n    data_min = 0\n    data_max = 2**64 - 1\n\n    key_min  = 0\n    key_max  = 2**192 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_start.value     = 0\n        dut.i_data.value      = 0\n        dut.i_key.value       = 0\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        # Latency check\n        key   = random.randint(key_min , key_max )\n        data  = random.randint(data_min, data_max)\n        start = 1\n\n        await FallingEdge(dut.clk)\n        dut.i_data.value  = data\n        dut.i_key.value   = key\n        dut.i_start.value = start\n\n        model.des3_dec(data, key)\n        await FallingEdge(dut.clk)\n        latency_counter = 1\n        dut.i_start.value = 0\n\n        while dut.o_done.value == 0:\n            latency_counter = latency_counter + 1\n            await FallingEdge(dut.clk)\n        \n        assert latency_counter == 48, f\"[ERROR] DUT latency must be 48 clock cycles\"\n        \n        compare_values(dut, model)\n\n        done_tests = random.randint(1, 50)\n        for j in range(done_tests):\n            previous_data = dut.o_data.value\n            await FallingEdge(dut.clk)\n            assert dut.o_done.value == 1, \"[ERROR] DUT o_done should be 1 when not processing data\"\n            assert dut.o_data.value == previous_data, \"[ERROR] DUT o_data must not be changed when not processing data\"\n            \n\n        for j in range(runs):\n            if (j+1)%100 == 0:\n                print(f'\\n------ Reset {i}, run {j+1} ------')\n\n            key   = random.randint(key_min , key_max )\n            data  = random.randint(data_min, data_max)\n            start = 1\n\n            await FallingEdge(dut.clk)\n\n            dut.i_data.value  = data\n            dut.i_key.value   = key\n            dut.i_start.value = start\n            \n            model.des3_dec(data, key)\n\n            await FallingEdge(dut.clk)\n\n            dut.i_data.value  = 0\n            dut.i_key.value   = 0\n            dut.i_start.value = 0\n\n            while dut.o_done.value == 0:\n                await FallingEdge(dut.clk)\n            \n            compare_values(dut, model)\n", "src/test_des_dec.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, FallingEdge\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data   = dut.o_data.value.integer\n    model_data = model.dec_out\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\n@cocotb.test()\nasync def test_des_dec(dut):\n    \"\"\"Test the des_dec module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n\n    model = hrs_lb.des()\n\n    resets = 4\n    runs = 1000\n\n    data_min = 0\n    data_max = 2**64 - 1\n\n    key_min  = 0\n    key_max  = 2**64 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_start.value     = 0\n        dut.i_data.value      = 0\n        dut.i_key.value       = 0\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        # Latency check\n        key   = random.randint(key_min , key_max )\n        data  = random.randint(data_min, data_max)\n\n        await FallingEdge(dut.clk)\n        dut.i_data.value  = data\n        dut.i_key.value   = key\n        dut.i_start.value = 1\n\n        model.decrypt(data, key)\n        await FallingEdge(dut.clk)\n        latency_counter = 1\n        dut.i_start.value = 0\n\n        while model.dec_out != dut.o_data.value.integer:\n            latency_counter = latency_counter + 1\n            await FallingEdge(dut.clk)\n            if latency_counter > 16:\n                assert latency_counter == 16, f\"[ERROR] DUT latency must be 16 clock cycles\"\n        \n        assert latency_counter == 16, f\"[ERROR] DUT latency must be 16 clock cycles\"\n        \n        compare_values(dut, model)\n\n        for j in range(runs):\n            if (j+1)%500 == 0:\n                print(f'\\n------ Reset {i}, run {j+1} ------')\n\n            key   = random.randint(key_min , key_max )\n            data  = random.randint(data_min, data_max)\n\n            dut.i_data.value  = data\n            dut.i_key.value   = key\n            dut.i_start.value = 1\n            model.decrypt(data, key)\n            await FallingEdge(dut.clk)\n            dut.i_start.value = 0\n\n            latency_counter = 1\n\n            while latency_counter < 16:\n                await FallingEdge(dut.clk)\n                latency_counter = latency_counter + 1\n\n            compare_values(dut, model)\n", "src/test_des_enc.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, FallingEdge\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data   = dut.o_data.value.integer\n    model_data = model.enc_out\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\n@cocotb.test()\nasync def test_des_enc(dut):\n    \"\"\"Test the des_enc module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n\n    model = hrs_lb.des()\n\n    resets = 4\n    runs = 1000\n\n    data_min = 0\n    data_max = 2**64 - 1\n\n    key_min  = 0\n    key_max  = 2**64 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_start.value     = 0\n        dut.i_data.value      = 0\n        dut.i_key.value       = 0\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        # Latency check\n        key   = random.randint(key_min , key_max )\n        data  = random.randint(data_min, data_max)\n\n        await FallingEdge(dut.clk)\n        dut.i_data.value  = data\n        dut.i_key.value   = key\n        dut.i_start.value = 1\n\n        model.encrypt(data, key)\n        await FallingEdge(dut.clk)\n        latency_counter = 1\n        dut.i_start.value = 0\n\n        while model.enc_out != dut.o_data.value.integer:\n            latency_counter = latency_counter + 1\n            await FallingEdge(dut.clk)\n            if latency_counter > 16:\n                assert latency_counter == 16, f\"[ERROR] DUT latency must be 16 clock cycles\"\n        \n        assert latency_counter == 16, f\"[ERROR] DUT latency must be 16 clock cycles\"\n        \n        compare_values(dut, model)\n\n        for j in range(runs):\n            if (j+1)%500 == 0:\n                print(f'\\n------ Reset {i}, run {j+1} ------')\n\n            key   = random.randint(key_min , key_max )\n            data  = random.randint(data_min, data_max)\n\n            dut.i_data.value  = data\n            dut.i_key.value   = key\n            dut.i_start.value = 1\n            model.encrypt(data, key)\n            await FallingEdge(dut.clk)\n            dut.i_start.value = 0\n\n            latency_counter = 1\n\n            while latency_counter < 16:\n                await FallingEdge(dut.clk)\n                latency_counter = latency_counter + 1\n\n            compare_values(dut, model)\n", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    runner()", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest /src/test_runner.py -s -v -o cache_dir=/rundir/harness/.cache'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_Min_Hamming_Distance_Finder_0001", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Design a `Min_Hamming_Distance_Finder` module in SystemVerilog. Refer to the specification provided in `docs/min_hamming_distance_finder_spec.md` to design the RTL. The specification describes a parameterized module that computes the minimum Hamming distance between a query vector and a set of reference vectors. The module accepts one input query and a configurable number of reference vectors and outputs the index of the reference vector with the smallest Hamming distance, along with the corresponding distance value.\n\n## Design Considerations\n\n- The design should be hierarchical, with the **Min_Hamming_Distance_Finder** module as the top-level and the following submodules:\n  - **Bit_Difference_Counter**: Calculates the Hamming distance between two vectors.\n  - **Data_Reduction**: Performs bitwise reduction (e.g., XOR) on paired bits from two vectors.\n  - **Bitwise_Reduction**: Handles the actual logic operation specified (XOR in this case).\n- The design should be parameterized using **BIT_WIDTH** and **REFERENCE_COUNT** to allow flexibility in vector width and number of references.\n- The code should be well-documented with clear comments explaining the functionality of each major block and how the minimum distance and best match index are computed.\n- The design should follow best practices in **SystemVerilog** coding, ensuring readability, modularity, and maintainability.\n", "context": {"docs/min_hamming_distance_finder_spec.md": "The **Min_Hamming_Distance_Finder** module computes the minimum Hamming distance between an input query vector and a set of reference vectors, outputting the index of the reference vector with the smallest Hamming distance and the corresponding minimum distance.\n\n## Parameterization\n\n- **BIT_WIDTH** : Defines the number of bits used for both the query vector and each reference vector. This parameter must be set to a positive integer value indicating the width of the vectors.Default value of 8 \n- **REFERENCE_COUNT** : Specifies how many reference vectors will be compared to the query. This must be a positive integer greater than zero, representing the total number of vectors stored or used within the design.Default value of 4 \n\n## Interfaces\n\n### Data Inputs\n\n- **input_query [BIT_WIDTH-1:0]**: Input vector to be compared.\n- **references [REFERENCE_COUNT*BIT_WIDTH-1:0]**: Concatenated reference vectors against which the query is compared.\n\n### Data Outputs\n\n- **best_match_index [$clog2(REFERENCE_COUNT)-1:0]**: Index of the reference vector with the smallest Hamming distance to the query.\n- **min_distance [$clog2(BIT_WIDTH+1)-1:0]**: The minimum Hamming distance found among all reference vectors.\n\n## Detailed Functionality\n\n### Distance Calculation\n\n- The module instantiates multiple instances of the **Bit_Difference_Counter**, one for each reference vector.\n\n- Each **Bit_Difference_Counter** calculates the Hamming distance between `input_query` and its respective reference vector.\n\n### Minimum Distance Determination\n\n- After computing distances, the module iteratively evaluates each distance to find the smallest one.\n\n- The **best_match_index** is updated whenever a smaller distance is encountered.\n\n- The **min_distance** is updated to reflect the smallest Hamming distance identified.\n\n## Submodules Explanation\n\n### 1. Bit_Difference_Counter\n\n- Computes the Hamming distance between two input vectors (`input_A` and `input_B`).\n- Uses the **Data_Reduction** submodule with an XOR operation to identify differing bits.\n- Counts the differing bits to produce the Hamming distance.\n\n### 2. Data_Reduction\n\n- Performs bitwise reduction operations across multiple data inputs.\n- Configurable for various reduction operations (AND, OR, XOR, NAND, NOR, XNOR).\n- Utilized by **Bit_Difference_Counter** for computing bitwise differences.\n\n### 3. Bitwise_Reduction\n\n- Executes the actual reduction logic defined by the operation parameter.\n- Supports common bitwise reduction operations and their complements.\n- Serves as a core computational element within **Data_Reduction**.\n\n## Example Usage\n\n### Valid Input Example\n\n- input_query = 8'b10101010\n- references = {8'b10101011, 8'b11110000, 8'b00001111, 8'b10101001}\n- The module calculates the Hamming distances:\n    - To ref[0]: Distance = 1\n    - To ref[1]: Distance = 4\n    - To ref[2]: Distance = 4\n    - To ref[3]: Distance = 2\n\n- The module outputs:\n  - best_match_index = 0 (the first smallest distance encountered)\n  - min_distance = 1\n\n## Summary\n\n- **Functionality**: Determines the reference vector closest to a query by Hamming distance.\n- **Distance Calculation**: Parallel instantiation of difference counters ensures efficient distance computation.\n- **Minimum Selection**: Sequential comparison logic finds the minimum distance and its index.\n- **Hierarchical Design**: Composed of reusable submodules (**Bit_Difference_Counter**, **Data_Reduction**, and **Bitwise_Reduction**), enhancing modularity and maintainability.", "rtl/Bit_Difference_Counter.sv": "module Bit_Difference_Counter\n#(\n    parameter BIT_WIDTH    = 3,                          // Defines the width of the input vectors.\n    localparam COUNT_WIDTH = $clog2(BIT_WIDTH + 1)       // Calculates the width required to represent the count of differing bits.\n)\n(\n    input  wire [BIT_WIDTH-1:0] input_A,                // First input vector.\n    input  wire [BIT_WIDTH-1:0] input_B,                // Second input vector.\n    output reg  [COUNT_WIDTH-1:0] bit_difference_count  // Count of differing bits (Hamming distance).\n);\n\n    wire [BIT_WIDTH-1:0] different_bits;\n    integer idx;\n\n    // Instantiate the Data_Reduction module to compute bitwise XOR between input_A and input_B.\n    Data_Reduction\n    #(\n        .REDUCTION_OP (3'b010), // XOR operation\n        .DATA_WIDTH  (BIT_WIDTH),\n        .DATA_COUNT  (2)\n    )\n    compare_bits\n    (\n        .data_in      ({input_A, input_B}),\n        .reduced_data_out   (different_bits)\n    );\n\n    // Count set bits in different_bits to compute Hamming distance\n    always @(*) begin\n        bit_difference_count = 0;\n        for (idx = 0; idx < BIT_WIDTH; idx = idx + 1) begin\n            bit_difference_count = bit_difference_count + different_bits[idx];\n        end\n    end\n\nendmodule", "rtl/Bitwise_Reduction.sv": "module Bitwise_Reduction\n#(\n    parameter [2:0] REDUCTION_OP = 3'b000, // Default operation: AND\n    parameter BIT_COUNT          = 4       // Number of bits to reduce\n)\n(\n    input  wire [BIT_COUNT-1:0] input_bits,\n    output reg                  reduced_bit\n);\n\n    // Reduction Operation Codes\n    localparam [2:0] AND_OP  = 3'b000;\n    localparam [2:0] OR_OP   = 3'b001;\n    localparam [2:0] XOR_OP  = 3'b010;\n    localparam [2:0] NAND_OP = 3'b011;\n    localparam [2:0] NOR_OP  = 3'b100;\n    localparam [2:0] XNOR_OP = 3'b101;\n\n    int i;\n    reg temp_result; \n\n    always @(*) begin\n        temp_result = input_bits[0];\n\n        for (i = 1; i < BIT_COUNT; i = i + 1) begin\n            case (REDUCTION_OP)\n                AND_OP, NAND_OP  : temp_result = temp_result & input_bits[i];\n                OR_OP,  NOR_OP   : temp_result = temp_result | input_bits[i];\n                XOR_OP, XNOR_OP  : temp_result = temp_result ^ input_bits[i];\n                default          : temp_result = temp_result & input_bits[i];\n            endcase\n        end\n\n        case (REDUCTION_OP)\n            NAND_OP : reduced_bit = ~temp_result;\n            NOR_OP  : reduced_bit = ~temp_result;\n            XNOR_OP : reduced_bit = ~temp_result;\n            default : reduced_bit = temp_result;\n        endcase\n    end\nendmodule", "rtl/Data_Reduction.sv": "module Data_Reduction\n#(\n    parameter [2:0] REDUCTION_OP = 3'b000, // Default operation: AND\n    parameter DATA_WIDTH         = 4,      // Width of each data element\n    parameter DATA_COUNT         = 4,      // Number of data elements\n    localparam TOTAL_INPUT_WIDTH = DATA_WIDTH * DATA_COUNT\n)\n(\n    input  wire [TOTAL_INPUT_WIDTH-1:0] data_in,\n    output reg  [DATA_WIDTH-1:0]        reduced_data_out\n);\n\n    generate\n        genvar bit_index;\n\n        for (bit_index = 0; bit_index < DATA_WIDTH; bit_index = bit_index + 1) begin : bit_processing\n            wire [DATA_COUNT-1:0] extracted_bits;\n\n            genvar data_index;\n            for (data_index = 0; data_index < DATA_COUNT; data_index = data_index + 1) begin : bit_extraction\n                assign extracted_bits[data_index] = data_in[(data_index * DATA_WIDTH) + bit_index];\n            end\n\n            Bitwise_Reduction\n            #(\n                .REDUCTION_OP (REDUCTION_OP),\n                .BIT_COUNT    (DATA_COUNT)\n            )\n            reducer_instance\n            (\n                .input_bits  (extracted_bits),\n                .reduced_bit (reduced_data_out[bit_index])\n            );\n        end\n    endgenerate\n\nendmodule", "verif/tb_Min_Hamming_Distance_Finder.sv": "`timescale 1ns / 1ps\n\nmodule tb_Min_Hamming_Distance_Finder;\n\n    // Parameters for the testbench\n    parameter BIT_WIDTH = 8;\n    parameter REFERENCE_COUNT = 4;\n\n    // Testbench signals\n    reg  [BIT_WIDTH-1:0]                      input_query;\n    reg  [REFERENCE_COUNT*BIT_WIDTH-1:0]      references;\n    wire [$clog2(REFERENCE_COUNT)-1:0]        best_match_index;\n    wire [$clog2(BIT_WIDTH+1)-1:0]            min_distance;\n\n    // Instantiate the DUT\n    Min_Hamming_Distance_Finder #(\n        .BIT_WIDTH(BIT_WIDTH),\n        .REFERENCE_COUNT(REFERENCE_COUNT)\n    ) dut (\n        .input_query(input_query),\n        .references(references),\n        .best_match_index(best_match_index),\n        .min_distance(min_distance)\n    );\n\n    // Function to compute Hamming distance (popcount) between two vectors\n    function [$clog2(BIT_WIDTH+1)-1:0] compute_expected_difference;\n        input [BIT_WIDTH-1:0] data_A;\n        input [BIT_WIDTH-1:0] data_B;\n        integer i;\n        reg [BIT_WIDTH-1:0] xor_result;\n        reg [$clog2(BIT_WIDTH+1)-1:0] pop_count;\n        begin\n            xor_result = data_A ^ data_B;\n            pop_count = 0;\n            for (i = 0; i < BIT_WIDTH; i = i + 1) begin\n                pop_count = pop_count + xor_result[i];\n            end\n            compute_expected_difference = pop_count;\n        end\n    endfunction\n\n    // Task to compute expected best match index and minimum Hamming distance\n    task compute_expected_results(\n        input  [BIT_WIDTH-1:0] query,\n        input  [REFERENCE_COUNT*BIT_WIDTH-1:0] refs,\n        output integer expected_index,\n        output integer expected_distance\n    );\n        integer i;\n        integer curr_distance;\n        reg [BIT_WIDTH-1:0] ref_vector;\n        begin\n            expected_distance = BIT_WIDTH + 1; // initialize with a max value\n            expected_index = 0;\n            for (i = 0; i < REFERENCE_COUNT; i = i + 1) begin\n                // Extract the i-th reference vector using part-select\n                ref_vector = refs[i*BIT_WIDTH +: BIT_WIDTH];\n                curr_distance = compute_expected_difference(query, ref_vector);\n                if (curr_distance < expected_distance) begin\n                    expected_distance = curr_distance;\n                    expected_index = i;\n                end\n            end\n        end\n    endtask\n\n    // Coverage tracking\n    integer total_tests = 0;\n    integer passed_tests = 0;\n    integer failed_tests = 0;\n\n    // Task to validate the output of the Min_Hamming_Distance_Finder\n    task validate_output(\n        input [BIT_WIDTH-1:0] test_query,\n        input [REFERENCE_COUNT*BIT_WIDTH-1:0] test_references,\n        input string testcase_name\n    );\n        integer exp_index, exp_distance;\n        begin\n            input_query = test_query;\n            references  = test_references;\n            #10; // Wait for combinational logic to settle\n\n            total_tests += 1;\n            compute_expected_results(test_query, test_references, exp_index, exp_distance);\n\n            if ((best_match_index === exp_index) && (min_distance === exp_distance)) begin\n                passed_tests += 1;\n                $display(\"[PASS] %s: Query=%b, Refs=%b -> Expected: index=%0d, dist=%0d; Got: index=%0d, dist=%0d\",\n                         testcase_name, test_query, test_references, exp_index, exp_distance, best_match_index, min_distance);\n            end else begin\n                failed_tests += 1;\n                $error(\"[FAIL] %s: Query=%b, Refs=%b -> Expected: index=%0d, dist=%0d; Got: index=%0d, dist=%0d\",\n                         testcase_name, test_query, test_references, exp_index, exp_distance, best_match_index, min_distance);\n            end\n        end\n    endtask\n\n    // Task for testing specific edge cases\n    task test_edge_cases;\n        reg [BIT_WIDTH-1:0] ref_vector;\n        reg [REFERENCE_COUNT*BIT_WIDTH-1:0] refs_temp;\n        integer i;\n        begin\n            $display(\"Starting Edge Case Testing...\");\n\n            // Case 1: All references equal to input_query (zero distance)\n            ref_vector = 8'b10101010;\n            for (i = 0; i < REFERENCE_COUNT; i = i + 1) begin\n                refs_temp[i*BIT_WIDTH +: BIT_WIDTH] = ref_vector;\n            end\n            validate_output(ref_vector, refs_temp, \"All references equal to query\");\n\n            // Case 2: One reference is an exact match and others are completely different.\n            input_query = 8'b11110000;\n            // Set reference 0 to be completely different, reference 1 slightly different, reference 2 exact match, reference 3 different.\n            refs_temp = {8'b00000000, 8'b11100000, 8'b11110000, 8'b10101010};\n            validate_output(input_query, refs_temp, \"Exact match among others\");\n\n            // Case 3: Test when the first reference is the closest\n            input_query = 8'b01010101;\n            refs_temp = {8'b01010100, 8'b10101010, 8'b11110000, 8'b00001111};\n            validate_output(input_query, refs_temp, \"First reference is closest\");\n        end\n    endtask\n\n    // Task for testing random inputs\n    task test_random_inputs;\n        integer i;\n        reg [BIT_WIDTH-1:0] random_query;\n        reg [REFERENCE_COUNT*BIT_WIDTH-1:0] random_refs;\n        begin\n            $display(\"Starting Randomized Testing...\");\n            for (i = 0; i < 100; i = i + 1) begin\n                random_query = $urandom;\n                random_refs  = $urandom;\n                validate_output(random_query, random_refs, $sformatf(\"Random Test %0d\", i+1));\n            end\n        end\n    endtask\n\n    // Task to print the summary\n    task print_summary;\n        begin\n            $display(\"=================================================\");\n            $display(\"Test Summary:\");\n            $display(\"Total Tests Run: %0d\", total_tests);\n            $display(\"Tests Passed   : %0d\", passed_tests);\n            $display(\"Tests Failed   : %0d\", failed_tests);\n            $display(\"=================================================\");\n            if (failed_tests > 0)\n                $error(\"Some tests failed. Check the logs for details.\");\n            else\n                $display(\"All tests passed successfully!\");\n        end\n    endtask\n\n    initial begin\n        $display(\"Starting testbench for Min_Hamming_Distance_Finder...\");\n        test_edge_cases();\n        test_random_inputs();\n        print_summary();\n        $finish;\n    end\n\nendmodule"}, "patch": {"rtl/Min_Hamming_Distance_Finder.sv": ""}, "harness": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v ", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/Bitwise_Reduction.sv /code/rtl/Data_Reduction.sv /code/rtl/Bit_Difference_Counter.sv /code/rtl/Min_Hamming_Distance_Finder.sv\nTOPLEVEL        = Min_Hamming_Distance_Finder\nMODULE          = test_Min_Hamming_Distance_Finder\nPYTHONPATH      = /src\nHASH            = 72e8fda2670a73561b09194e3e81a01420fcb1e0\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_Min_Hamming_Distance_Finder.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ReadOnly , Timer\n\nimport harness_library as hrs_lb\nimport random\n\ndef compute_expected_difference(data_A, data_B, bit_width):\n    xor_result = data_A ^ data_B\n    return bin(xor_result).count(\"1\")\n\ndef compute_expected_results(query, refs, bit_width, ref_count):\n\n    expected_distance = bit_width + 1  # Initialize with a large value\n    expected_index = 0\n    for i in range(ref_count):\n        # Extract the i-th reference vector using bit-masking and shifting\n        ref_vector = (refs >> (i * bit_width)) & ((1 << bit_width) - 1)\n        curr_distance = compute_expected_difference(query, ref_vector, bit_width)\n        if curr_distance < expected_distance:\n            expected_distance = curr_distance\n            expected_index = i\n    return expected_index, expected_distance\n\n@cocotb.test()\nasync def test_Min_Hamming_Distance_Finder(dut):\n    \"\"\"\n    Test edge-case scenarios for the Min_Hamming_Distance_Finder module.\n    \"\"\"\n    # Retrieve parameters from DUT\n    BIT_WIDTH = int(dut.BIT_WIDTH.value)\n    # For REFERENCE_COUNT, if it is not exposed as a signal, set it here manually.\n    REFERENCE_COUNT = int(dut.REFERENCE_COUNT.value)\n\n    dut._log.info(f\"Testing Min_Hamming_Distance_Finder with BIT_WIDTH={BIT_WIDTH} and REFERENCE_COUNT={REFERENCE_COUNT}\")\n\n    # --- Case 1: All references equal to input_query (zero distance) ---\n    test_query = random.randint(0, (1 << BIT_WIDTH) - 1)\n    refs_temp = 0\n    # Build concatenated references so that every reference equals test_query.\n    for i in range(REFERENCE_COUNT):\n        refs_temp |= (test_query << (i * BIT_WIDTH))\n    dut.input_query.value = test_query\n    dut.references.value = refs_temp\n    await Timer(10, units=\"ns\")\n    exp_index, exp_distance = compute_expected_results(test_query, refs_temp, BIT_WIDTH, REFERENCE_COUNT)\n    observed_index = int(dut.best_match_index.value)\n    observed_distance = int(dut.min_distance.value)\n    assert observed_index == exp_index, (\n        f\"Edge Case 1: Expected best_match_index {exp_index}, got {observed_index}.\"\n    )\n    assert observed_distance == exp_distance, (\n        f\"Edge Case 1: Expected min_distance {exp_distance}, got {observed_distance}.\"\n    )\n    dut._log.info(f\"Edge Case 1 passed: Query={test_query:0{BIT_WIDTH}b}, Refs={refs_temp:0{REFERENCE_COUNT * BIT_WIDTH}b} -> \"\n                  f\"Expected index={exp_index}, dist={exp_distance}; Got index={observed_index}, dist={observed_distance}.\")\n\n    # --- Case 2: One reference is an exact match and others are different ---\n    test_query = random.randint(0, (1 << BIT_WIDTH) - 1)\n    # Let's define references:\n    # Reference 0: Completely different (invert test_query)\n    ref0 = ((1 << BIT_WIDTH) - 1) ^ test_query\n    # Reference 1: Random value\n    ref1 = random.randint(0, (1 << BIT_WIDTH) - 1)\n    # Reference 2: Exact match\n    ref2 = test_query\n    # Reference 3: Random value\n    ref3 = random.randint(0, (1 << BIT_WIDTH) - 1)\n    refs_temp = ref0 | (ref1 << BIT_WIDTH) | (ref2 << (2 * BIT_WIDTH)) | (ref3 << (3 * BIT_WIDTH))\n    dut.input_query.value = test_query\n    dut.references.value = refs_temp\n    await Timer(10, units=\"ns\")\n    exp_index, exp_distance = compute_expected_results(test_query, refs_temp, BIT_WIDTH, REFERENCE_COUNT)\n    observed_index = int(dut.best_match_index.value)\n    observed_distance = int(dut.min_distance.value)\n    assert observed_index == exp_index, (\n        f\"Edge Case 2: Expected best_match_index {exp_index}, got {observed_index}.\"\n    )\n    assert observed_distance == exp_distance, (\n        f\"Edge Case 2: Expected min_distance {exp_distance}, got {observed_distance}.\"\n    )\n    dut._log.info(f\"Edge Case 2 passed: Query={test_query:0{BIT_WIDTH}b}, Refs={refs_temp:0{REFERENCE_COUNT * BIT_WIDTH}b} -> \"\n                  f\"Expected index={exp_index}, dist={exp_distance}; Got index={observed_index}, dist={observed_distance}.\")\n\n\n    await Timer(50, units=\"ns\")\n    \n    dut._log.info(f\"Starting Randomized Testing for Min_Hamming_Distance_Finder with BIT_WIDTH={BIT_WIDTH} and REFERENCE_COUNT={REFERENCE_COUNT}\")\n\n    for i in range(20):\n        test_query = random.randint(0, (1 << BIT_WIDTH) - 1)\n        refs_temp = random.getrandbits(REFERENCE_COUNT * BIT_WIDTH)\n        dut.input_query.value = test_query\n        dut.references.value = refs_temp\n        await Timer(10, units=\"ns\")\n        exp_index, exp_distance = compute_expected_results(test_query, refs_temp, BIT_WIDTH, REFERENCE_COUNT)\n        observed_index = int(dut.best_match_index.value)\n        observed_distance = int(dut.min_distance.value)\n\n        assert observed_index == exp_index, (\n            f\"Random Test {i+1}: Expected best_match_index {exp_index}, got {observed_index}.\"\n        )\n        assert observed_distance == exp_distance, (\n            f\"Random Test {i+1}: Expected min_distance {exp_distance}, got {observed_distance}.\"\n        )\n        dut._log.info(f\"Random Test {i+1} passed: Query={test_query:0{BIT_WIDTH}b}, \"\n                      f\"Refs={refs_temp:0{REFERENCE_COUNT * BIT_WIDTH}b}, \"\n                      f\"Expected index={exp_index}, dist={exp_distance}; Got index={observed_index}, dist={observed_distance}.\")\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(BIT_WIDTH: int = 8,REFERENCE_COUNT: int =4 ):\n\n    parameter = {\n        \"BIT_WIDTH\": BIT_WIDTH,\"REFERENCE_COUNT\" : REFERENCE_COUNT,\n    }\n  \n    print(f\"[DEBUG] Parameters: {parameter}\")\n    \n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n\n@pytest.mark.parametrize(\"test\", range(1))\n@pytest.mark.parametrize(\"BIT_WIDTH\", [4, 10, 3, 20])\n@pytest.mark.parametrize(\"REFERENCE_COUNT\", [4,8])\ndef test_min_distance(test, BIT_WIDTH,REFERENCE_COUNT):\n    runner(BIT_WIDTH=BIT_WIDTH, REFERENCE_COUNT=REFERENCE_COUNT)", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR=''\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_async_fifo_compute_ram_application_0006", "categories": ["cid005", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"problematic_line_number s/problematic_statement/non_problematic_statement/\" Buggy_RTL_code.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have multiple modules with below functionalities.\n#### 1. `read_to_write_pointer_sync`\nSynchronizes the Gray-coded read pointer from the read clock domain to the write clock domain.\n\n#### 2. `write_to_read_pointer_sync`\nSynchronizes the Gray-coded write pointer from the write clock domain to the read clock domain.\n\n#### 3. `wptr_full`\nHandles the write pointer logic, updates the pointer upon valid writes, and detects FIFO full condition.\n\n#### 4. `fifo_memory`\nDual-port RAM used to store the FIFO data. Supports simultaneous write and read using separate clocks.\n\n#### 5. `rptr_empty`\nHandles the read pointer logic, updates the pointer upon valid reads, and detects FIFO empty condition.\n\nRefer to the specification provided in `docs/fifo.md` and ensure you understand its content. I want you to integrate all these modules to create a top level module named `async_fifo`.\n", "context": {"docs/fifo.md": "# Asynchronous FIFO Specification\n\n## 1. Overview\n\nThe **async_fifo** design is a parameterizable asynchronous FIFO module. It uses separate clock domains for writing and reading, providing safe data transfer between two clock domains. The design employs dual-port memory and Gray-coded pointers for reliable synchronization.\n\n### Key Features\n1. Configurable data width and FIFO depth (determined by address width).\n2. Separate write and read clocks.\n3. Synchronization logic for pointers between clock domains.\n4. Full and empty flags to indicate FIFO status.\n5. Dual-port memory for simultaneous read and write.\n\n## 2. Top-Level Module: `async_fifo`\n\n### 2.1 Parameters\n\n- **p_data_width** (default = 32)\n  - Defines the width of data being transferred in/out of the FIFO.\n- **p_addr_width** (default = 16)\n  - Defines the width of the address pointers for the FIFO.\n  - The FIFO depth will be \\(2^{\\text{p\\_addr\\_width}}\\).\n\n### 2.2 Ports\n\n| **Port Name**       | **Direction** | **Width**                   | **Description**                                                         |\n|---------------------|---------------|-----------------------------|-------------------------------------------------------------------------|\n| `i_wr_clk`          | Input         | 1 bit                       | Write clock domain.                                                     |\n| `i_wr_rst_n`        | Input         | 1 bit                       | Active-low reset signal for the write clock domain.                     |\n| `i_wr_en`           | Input         | 1 bit                       | Write enable signal. When high and FIFO not full, data is written.      |\n| `i_wr_data`         | Input         | `p_data_width` bits         | Write data to be stored in the FIFO.                                    |\n| `o_fifo_full`       | Output        | 1 bit                       | High when FIFO is full and cannot accept more data.                     |\n| `i_rd_clk`          | Input         | 1 bit                       | Read clock domain.                                                      |\n| `i_rd_rst_n`        | Input         | 1 bit                       | Active-low reset signal for the read clock domain.                      |\n| `i_rd_en`           | Input         | 1 bit                       | Read enable signal. When high and FIFO not empty, data is read out.     |\n| `o_rd_data`         | Output        | `p_data_width` bits         | Read data from the FIFO.                                                |\n| `o_fifo_empty`      | Output        | 1 bit                       | High when FIFO is empty and no data is available to read.               |\n\n### 2.3 Internal Signals\n- `w_wr_bin_addr` & `w_rd_bin_addr`\n  - Binary write and read address buses.\n- `w_wr_grey_addr` & `w_rd_grey_addr`\n  - Gray-coded write and read address buses.\n- `w_rd_ptr_sync` & `w_wr_ptr_sync`\n  - Synchronized read pointer in the write domain and synchronized write pointer in the read domain, respectively.\n\n### 2.4 Submodule Instantiations\n\n#### 1. `read_to_write_pointer_sync`\nSynchronizes the Gray-coded read pointer from the read clock domain to the write clock domain.\n\n#### 2. `write_to_read_pointer_sync`\nSynchronizes the Gray-coded write pointer from the write clock domain to the read clock domain.\n\n#### 3. `wptr_full`\nHandles the write pointer logic, updates the pointer upon valid writes, and detects FIFO full condition.\n\n#### 4. `fifo_memory`\nDual-port RAM used to store the FIFO data. Supports simultaneous write and read using separate clocks.\n\n#### 5. `rptr_empty`\nHandles the read pointer logic, updates the pointer upon valid reads, and detects FIFO empty condition.\n\n## 3. Submodules\n\nThis section describes each submodule in detail.\n\n---\n\n### 3.1 `fifo_memory`\n\n#### 3.1.1 Parameters\n\n- **p_data_width** (default = 32)  \n  Width of each data word stored in the memory.\n- **p_addr_width** (default = 16)  \n  Width of the memory address ports. The depth of the memory is \\(2^{\\text{p\\_addr\\_width}}\\).\n\n#### 3.1.2 Ports\n\n| **Port Name** | **Direction** | **Width**           | **Description**                                               |\n|---------------|---------------|---------------------|---------------------------------------------------------------|\n| `i_wr_clk`    | Input         | 1 bit               | Write clock.                                                  |\n| `i_wr_clk_en` | Input         | 1 bit               | Write clock enable; when high, a write operation may occur.   |\n| `i_wr_addr`   | Input         | `p_addr_width` bits | Address in memory where data will be written.                 |\n| `i_wr_data`   | Input         | `p_data_width` bits | Data to be stored in the memory.                              |\n| `i_wr_full`   | Input         | 1 bit               | FIFO full indicator (used to block writes when FIFO is full). |\n| `i_rd_clk`    | Input         | 1 bit               | Read clock.                                                   |\n| `i_rd_clk_en` | Input         | 1 bit               | Read clock enable; when high, a read operation may occur.     |\n| `i_rd_addr`   | Input         | `p_addr_width` bits | Address in memory from where data will be read.               |\n| `o_rd_data`   | Output        | `p_data_width` bits | Output data read from the memory.                             |\n\n### 3.2 `read_to_write_pointer_sync`\n\n#### 3.2.1 Parameters\n\n- **p_addr_width** (default = 16)  \n  Defines the address width (not counting the extra MSB bit used for indexing).\n\n#### 3.2.2 Ports\n\n| **Port Name**     | **Direction** | **Width**             | **Description**                                                                   |\n|-------------------|---------------|-----------------------|-----------------------------------------------------------------------------------|\n| `i_wr_clk`        | Input         | 1 bit                 | Write clock domain.                                                               |\n| `i_wr_rst_n`      | Input         | 1 bit                 | Active-low reset for the write clock domain.                                      |\n| `i_rd_grey_addr`  | Input         | `p_addr_width+1` bits | Gray-coded read pointer from the read clock domain.                               |\n| `o_rd_ptr_sync`   | Output (reg)  | `p_addr_width+1` bits | Synchronized read pointer in the write clock domain (two-stage synchronization).  |\n  \n---\n\n### 3.3 `write_to_read_pointer_sync`\n\n#### 3.3.1 Parameters\n\n- **p_addr_width** (default = 16)\n\n#### 3.3.2 Ports\n\n| **Port Name**     | **Direction** | **Width**             | **Description**                                                                 |\n|-------------------|---------------|-----------------------|---------------------------------------------------------------------------------|\n| `i_rd_clk`        | Input         | 1 bit                 | Read clock domain.                                                              |\n| `i_rd_rst_n`      | Input         | 1 bit                 | Active-low reset for the read clock domain.                                     |\n| `i_wr_grey_addr`  | Input         | `p_addr_width+1` bits | Gray-coded write pointer from the write clock domain.                           |\n| `o_wr_ptr_sync`   | Output (reg)  | `p_addr_width+1` bits | Synchronized write pointer in the read clock domain (two-stage synchronization).|\n\n### 3.4 `wptr_full`\n\n#### 3.4.1 Parameters\n\n- **p_addr_width** (default = 16)\n\n#### 3.4.2 Ports\n\n| **Port Name**     | **Direction** | **Width**             | **Description**                                                     |\n|-------------------|---------------|-----------------------|---------------------------------------------------------------------|\n| `i_wr_clk`        | Input         | 1 bit                 | Write clock.                                                        |\n| `i_wr_rst_n`      | Input         | 1 bit                 | Active-low reset for the write clock domain.                        |\n| `i_wr_en`         | Input         | 1 bit                 | Write enable signal.                                                |\n| `i_rd_ptr_sync`   | Input         | `p_addr_width+1` bits | Synchronized read pointer from the read clock domain (Gray-coded).  |\n| `o_fifo_full`     | Output (reg)  | 1 bit                 | Indicates when the FIFO is full.                                    |\n| `o_wr_bin_addr`   | Output (wire) | `p_addr_width` bits   | Binary write address used for indexing the memory.                  |\n| `o_wr_grey_addr`  | Output (reg)  | `p_addr_width+1` bits | Gray-coded write pointer.                                           |\n\n---\n\n### 3.5 `rptr_empty`\n\n#### 3.5.1 Parameters\n\n- **p_addr_width** (default = 16)\n\n#### 3.5.2 Ports\n\n| **Port Name**     | **Direction** | **Width**             | **Description**                                                       |\n|-------------------|---------------|-----------------------|-----------------------------------------------------------------------|\n| `i_rd_clk`        | Input         | 1 bit                 | Read clock domain.                                                    |\n| `i_rd_rst_n`      | Input         | 1 bit                 | Active-low reset for the read clock domain.                           |\n| `i_rd_en`         | Input         | 1 bit                 | Read enable signal.                                                   |\n| `i_wr_ptr_sync`   | Input         | `p_addr_width+1` bits | Synchronized write pointer from the write clock domain (Gray-coded).  |\n| `o_fifo_empty`    | Output (reg)  | 1 bit                 | Indicates when the FIFO is empty.                                     |\n| `o_rd_bin_addr`   | Output (wire) | `p_addr_width` bits   | Binary read address used for indexing the memory.                     |\n| `o_rd_grey_addr`  | Output (reg)  | `p_addr_width+1` bits | Gray-coded read pointer.                                              |\n", "rtl/fifo_memory.sv": "module fifo_memory\n    #(\n        parameter p_data_width = 32,    // Memory data word width\n        parameter p_addr_width = 16     // Number of memory address bits\n    ) (\n        input  wire                i_wr_clk,       // Write clock\n        input  wire                i_wr_clk_en,    // Write clock enable\n        input  wire [p_addr_width-1:0] i_wr_addr,    // Write address\n        input  wire [p_data_width-1:0] i_wr_data,    // Write data\n        input  wire                i_wr_full,      // Write full flag\n        input  wire                i_rd_clk,       // Read clock\n        input  wire                i_rd_clk_en,    // Read clock enable\n        input  wire [p_addr_width-1:0] i_rd_addr,    // Read address\n        output wire [p_data_width-1:0] o_rd_data     // Read data output\n    );\n\n    // Calculate the depth of the memory based on the address size\n    localparam p_depth = 1 << p_addr_width;\n\n    // Define the memory array with depth p_depth and data width p_data_width\n    reg [p_data_width-1:0] r_memory [0:p_depth-1];\n    reg [p_data_width-1:0] r_rd_data;  // Register to hold read data\n\n    // Write operation\n    always @(posedge i_wr_clk) begin\n        if (i_wr_clk_en && !i_wr_full)          // If write is enabled and FIFO is not full\n            r_memory[i_wr_addr] <= i_wr_data;   // Write data to memory at specified address\n    end\n\n    // Read operation\n    always @(posedge i_rd_clk) begin\n        if (i_rd_clk_en)                        // If read is enabled\n            r_rd_data <= r_memory[i_rd_addr];   // Read data from memory at specified address\n    end\n\n    // Assign the read data register to the output\n    assign o_rd_data = r_rd_data;\n\nendmodule", "rtl/read_to_write_pointer_sync.sv": "module read_to_write_pointer_sync \n    #(\n        parameter p_addr_width = 16  // Parameter to define the address width of the FIFO\n    )(\n        input  wire              i_wr_clk,           // Write clock\n        input  wire              i_wr_rst_n,         // Write reset (active low)\n        input  wire [p_addr_width:0] i_rd_grey_addr, // Gray-coded read address from the read clock domain\n        output reg  [p_addr_width:0] o_rd_ptr_sync   // Synchronized read pointer in the write clock domain\n    );\n\n    // Internal register to hold the intermediate synchronized read pointer\n    reg [p_addr_width:0] r_rd_ptr_ff;\n\n    // Always block for synchronizing the read pointer to the write clock domain\n    always @(posedge i_wr_clk or negedge i_wr_rst_n) \n    begin\n        if (!i_wr_rst_n) begin\n            // If reset is asserted (active low), reset the synchronized pointers to 0\n            o_rd_ptr_sync <= {p_addr_width+1{1'b0}};\n            r_rd_ptr_ff <= {p_addr_width+1{1'b0}};\n        end else begin\n            // If reset is not asserted, synchronize the read pointer to the write clock domain\n            r_rd_ptr_ff <= i_rd_grey_addr;  // First stage of synchronization\n            o_rd_ptr_sync <= r_rd_ptr_ff;   // Second stage of synchronization\n        end\n    end\n\nendmodule", "rtl/rptr_empty.sv": "module rptr_empty \n    #(\n        parameter p_addr_width = 16  // Parameter to define the address width of the FIFO\n    )(\n        input  wire                i_rd_clk,         // Read clock\n        input  wire                i_rd_rst_n,       // Read reset (active low)\n        input  wire                i_rd_en,          // Read enable signal\n        input  wire [p_addr_width  :0] i_wr_ptr_sync, // Synchronized write pointer from the write clock domain\n        output reg                 o_fifo_empty,     // Output flag indicating if the FIFO is empty\n        output wire [p_addr_width-1:0] o_rd_bin_addr, // Output binary read address\n        output reg  [p_addr_width  :0] o_rd_grey_addr // Output Gray-coded read address\n    );\n\n    // Internal registers and wires\n    reg  [p_addr_width:0] r_rd_bin_addr_pointer; // Register to store the current binary read address\n    wire [p_addr_width:0] w_rd_next_grey_addr_pointer; // Wire for the next Gray-coded read address\n    wire [p_addr_width:0] w_rd_next_bin_addr_pointer; // Wire for the next binary read address\n    wire                  w_rd_empty;             // Wire indicating if the FIFO is empty\n\n    //-------------------\n    // GRAYSTYLE2 pointer\n    //-------------------\n    always @(posedge i_rd_clk or negedge i_rd_rst_n) \n    begin\n        if (!i_rd_rst_n) begin\n            // Reset the read address pointers to 0 on reset\n            r_rd_bin_addr_pointer <= {p_addr_width+1{1'b0}};\n            o_rd_grey_addr <= {p_addr_width+1{1'b0}};\n        end else begin\n            // Update the read address pointers on each clock edge\n            r_rd_bin_addr_pointer <= w_rd_next_bin_addr_pointer;\n            o_rd_grey_addr <= w_rd_next_grey_addr_pointer;\n        end\n    end\n    \n    // Memory read-address pointer (binary addressing for memory access)\n    assign o_rd_bin_addr = r_rd_bin_addr_pointer[p_addr_width-1:0];\n\n    // Calculate the next binary read address, increment only if read enable is active and FIFO is not empty\n    assign w_rd_next_bin_addr_pointer = r_rd_bin_addr_pointer + (i_rd_en & ~o_fifo_empty);\n\n    // Convert the next binary read address to Gray code\n    assign w_rd_next_grey_addr_pointer = (w_rd_next_bin_addr_pointer >> 1) ^ w_rd_next_bin_addr_pointer;\n\n    //---------------------------------------------------------------\n    // FIFO is empty when the next Gray-coded read address matches the synchronized write pointer or on reset\n    //---------------------------------------------------------------\n    assign w_rd_empty = (w_rd_next_grey_addr_pointer == i_wr_ptr_sync);\n\n    // Always block for updating the FIFO empty flag\n    always @(posedge i_rd_clk or negedge i_rd_rst_n) begin\n        if (!i_rd_rst_n) begin\n            // Reset the FIFO empty flag to 1 on reset\n            o_fifo_empty <= 1'b1;\n        end else begin\n            // Update the FIFO empty flag based on the calculated empty condition\n            o_fifo_empty <= w_rd_empty;\n        end\n    end\n\nendmodule", "rtl/wptr_full.sv": "module wptr_full \n    #(\n        parameter p_addr_width = 16  // Parameter to define the address width of the FIFO\n    )(\n        input  wire                     i_wr_clk,         // Write clock\n        input  wire                     i_wr_rst_n,       // Write reset (active low)\n        input  wire                     i_wr_en,          // Write enable signal\n        input  wire [p_addr_width  :0]  i_rd_ptr_sync,    // Synchronized read pointer from the read clock domain\n        output reg                      o_fifo_full,      // Output flag indicating if the FIFO is full\n        output wire [p_addr_width-1:0]  o_wr_bin_addr,    // Output binary write address\n        output reg  [p_addr_width  :0]  o_wr_grey_addr    // Output Gray-coded write address\n    );\n\n    // Internal registers and wires\n    reg  [p_addr_width:0] r_wr_bin_addr_pointer;  // Register to store the current binary write address\n    wire [p_addr_width:0] w_wr_next_bin_addr_pointer; // Wire for the next binary write address\n    wire [p_addr_width:0] w_wr_next_grey_addr_pointer; // Wire for the next Gray-coded write address\n    wire                  w_wr_full;             // Wire indicating if the FIFO is full\n\n    // Always block for updating the write address pointers\n    // GRAYSTYLE2 pointer update mechanism\n    always @(posedge i_wr_clk or negedge i_wr_rst_n) begin\n        if (!i_wr_rst_n) begin\n            // Reset the write address pointers to 0 on reset\n            r_wr_bin_addr_pointer <= {p_addr_width{1'b0}};\n            o_wr_grey_addr <= {p_addr_width{1'b0}};\n        end else begin\n            // Update the write address pointers on each clock edge\n            r_wr_bin_addr_pointer <= w_wr_next_bin_addr_pointer;\n            o_wr_grey_addr <= w_wr_next_grey_addr_pointer;\n        end\n    end\n\n    // Assign the binary write address for addressing the memory\n    assign o_wr_bin_addr = r_wr_bin_addr_pointer[p_addr_width-1:0];\n\n    // Calculate the next binary write address, only increment if write enable is active and FIFO is not full\n    assign w_wr_next_bin_addr_pointer  = r_wr_bin_addr_pointer + (i_wr_en & ~o_fifo_full);\n\n    // Convert the next binary write address to Gray code\n    assign w_wr_next_grey_addr_pointer = (w_wr_next_bin_addr_pointer >> 1) ^ w_wr_next_bin_addr_pointer;\n\n    // Check if the FIFO is full by comparing the next Gray-coded write address with the synchronized read pointer\n    // FIFO is full if the next write address matches the read pointer with the MSB inverted\n    assign w_wr_full = (w_wr_next_grey_addr_pointer == {~i_rd_ptr_sync[p_addr_width:p_addr_width-1], i_rd_ptr_sync[p_addr_width-2:0]});\n\n    // Always block for updating the FIFO full flag\n    always @(posedge i_wr_clk or negedge i_wr_rst_n) begin\n        if (!i_wr_rst_n) begin\n            // Reset the FIFO full flag to 0 on reset\n            o_fifo_full <= 1'b0;\n        end else begin\n            // Update the FIFO full flag based on the calculated full condition\n            o_fifo_full <= w_wr_full;\n        end\n    end\n\nendmodule", "rtl/write_to_read_pointer_sync.sv": "module write_to_read_pointer_sync \n    #(\n        parameter p_addr_width = 16  // Parameter to define the address width of the FIFO\n    )(\n        input  wire              i_rd_clk,         // Read clock\n        input  wire              i_rd_rst_n,       // Read reset (active low)\n        input  wire [p_addr_width:0] i_wr_grey_addr, // Input Gray-coded write address\n        output reg  [p_addr_width:0] o_wr_ptr_sync // Output synchronized write pointer\n        \n    );\n\n    // Internal register to hold the intermediate synchronized write pointer\n    reg [p_addr_width:0] r_wr_ptr_ff;\n\n    // Always block for synchronizing the write pointer to the read clock domain\n    always @(posedge i_rd_clk or negedge i_rd_rst_n) \n    begin\n        if (!i_rd_rst_n) begin\n            // If reset is asserted (active low), reset the synchronized pointers to 0\n            o_wr_ptr_sync <= {p_addr_width+1{1'b0}};\n            r_wr_ptr_ff <= {p_addr_width+1{1'b0}};\n        end else begin\n            // If reset is not asserted, synchronize the write pointer to the read clock domain\n            r_wr_ptr_ff <= i_wr_grey_addr;  // First stage of synchronization\n            o_wr_ptr_sync <= r_wr_ptr_ff;   // Second stage of synchronization\n        end\n    end\n\nendmodule"}, "patch": {"rtl/async_fifo.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/async_fifo.sv /code/rtl/read_to_write_pointer_sync.sv /code/rtl/write_to_read_pointer_sync.sv /code/rtl/wptr_full.sv /code/rtl/fifo_memory.sv /code/rtl/rptr_empty.sv\nTOPLEVEL        = async_fifo \nMODULE          = test_async_fifo\nPYTHONPATH      = /src\nHASH            = 6-rtl-integration", "src/test_async_fifo.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\n\nimport random\n\n################################################################################\n# Utility / Setup\n################################################################################\n\nasync def reset_wr_domain(dut, cycles=5):\n    \"\"\"\n    Reset the write domain of the DUT.\n    The reset is active low, so set it to 0, wait a few clock cycles, then set it to 1.\n    \"\"\"\n    dut.i_wr_rst_n.value = 0\n    # Wait for a few rising edges on the write clock\n    for i in range(cycles):\n        await RisingEdge(dut.i_wr_clk)\n    dut.i_wr_rst_n.value = 1\n    # Wait one more cycle to let DUT stabilize\n    await RisingEdge(dut.i_wr_clk)\n\n\nasync def reset_rd_domain(dut, cycles=5):\n    \"\"\"\n    Reset the read domain of the DUT.\n    The reset is active low, so set it to 0, wait a few clock cycles, then set it to 1.\n    \"\"\"\n    dut.i_rd_rst_n.value = 0\n    # Wait for a few rising edges on the read clock\n    for i in range(cycles):\n        await RisingEdge(dut.i_rd_clk)\n    dut.i_rd_rst_n.value = 1\n    # Wait one more cycle to let DUT stabilize\n    await RisingEdge(dut.i_rd_clk)\n\nasync def reset_dut(dut):\n    \"\"\"Reset the DUT (Device Under Test)\"\"\"\n    # Set all input signals to their default values\n    dut.i_wr_clk.value = 0\n    dut.i_wr_rst_n.value = 0\n    dut.i_wr_en.value = 0\n    dut.i_wr_data.value = 0\n    dut.i_rd_clk.value = 0\n    dut.i_rd_rst_n.value = 0\n    dut.i_rd_en.value = 0\n\n    # Wait for a clock cycle before releasing the reset\n    await FallingEdge(dut.i_rd_clk)\n    dut.i_rd_rst_n.value = 1\n    await FallingEdge(dut.i_wr_clk)\n    dut.i_wr_rst_n.value = 1\n    await RisingEdge(dut.i_wr_clk)\n\n\n@cocotb.test()\nasync def test_async_fifo(dut):\n    \"\"\"\n    Top-level test that drives the asynchronous FIFO with multiple scenarios\n    to exercise read/write domain resets, empties, full conditions, etc.\n    \"\"\"\n\n    ############################################################################\n    # 1. Create asynchronous clocks for write and read domains\n    ############################################################################\n    # For example, write clock = 10ns period, read clock = 17ns period\n    cocotb.start_soon(Clock(dut.i_wr_clk, 10, units='ns').start())\n    cocotb.start_soon(Clock(dut.i_rd_clk, 17, units='ns').start())\n\n    ############################################################################\n    # 2. Reset both domains\n    ############################################################################\n    # Initially drive control signals to default\n    await reset_dut(dut)\n\n    # Short wait after reset\n    await Timer(1, units=\"ns\")\n\n    ############################################################################\n    # 3. Test #1: Basic Reset & Empty Test\n    ############################################################################\n    dut._log.info(\"=== TEST #1: Basic Reset & Empty Test ===\")\n\n    # Confirm FIFO is empty after reset\n    assert dut.o_fifo_empty.value == 1, \"FIFO should be empty after reset\"\n    assert dut.o_fifo_full.value == 0,  \"FIFO should not be full after reset\"\n\n    # Attempt to read from empty FIFO\n    dut.i_rd_en.value = 1\n    for i in range(3):\n        await RisingEdge(dut.i_rd_clk)\n    dut.i_rd_en.value = 0\n\n    # FIFO should remain empty\n    assert dut.o_fifo_empty.value == 1, \"FIFO unexpectedly became non-empty\"\n\n    await Timer(1, units=\"ns\")\n\n    ############################################################################\n    # 4. Test #2: Single Write & Read\n    ############################################################################\n    dut._log.info(\"=== TEST #2: Single Write & Read ===\")\n\n    test_data = 0xABCD1234\n\n    # Write a single data word\n    dut.i_wr_data.value = test_data\n    dut.i_wr_en.value   = 1\n    for i in range(2):\n        await RisingEdge(dut.i_wr_clk)\n    dut.i_wr_en.value   = 0\n\n    # Wait a bit for pointer synchronization\n    await Timer(100, units=\"ns\")\n\n    # Now read it back\n    dut.i_rd_en.value = 1\n    for i in range(2):\n        await RisingEdge(dut.i_rd_clk)\n    dut.i_rd_en.value = 0\n\n    # Check read data\n    read_value = dut.o_rd_data.value.integer\n    dut._log.info(f\"Read value = 0x{read_value:08X}\")\n    assert read_value == test_data, f\"Data mismatch! Got: 0x{read_value:08X}, Expected: 0x{test_data:08X}\"\n\n    # FIFO should be empty again\n    await RisingEdge(dut.i_rd_clk)\n    assert dut.o_fifo_empty.value == 1, \"FIFO should be empty after single read\"\n\n    await Timer(2, units=\"ns\")\n\n    ############################################################################\n    # 5. Test #3: Fill and Drain (Full \u2192 Empty)\n    ############################################################################\n    dut._log.info(\"=== TEST #3: Fill and Drain (Full -> Empty) ===\")\n\n    write_count = 0\n    read_count  = 0\n    scoreboard  = []\n\n    # Start writing data until FIFO is full\n    await FallingEdge(dut.i_wr_clk)\n    dut.i_wr_en.value = 1\n    while True:\n        dut.i_wr_data.value = write_count\n        await RisingEdge(dut.i_wr_clk)\n        if dut.o_fifo_full.value == 1:\n            # FIFO is full, stop writing\n            dut.i_wr_en.value = 0\n            dut._log.info(f\"FIFO is FULL after writing {write_count+1} words.\")\n            break\n        else:\n            scoreboard.append(write_count)\n            write_count += 1\n\n    # Now read until empty\n    await FallingEdge(dut.i_rd_clk)\n    dut.i_rd_en.value = 1\n    await FallingEdge(dut.i_rd_clk)\n    while True:\n        await RisingEdge(dut.i_rd_clk)\n        if dut.o_fifo_empty.value == 1:\n            dut.i_rd_en.value = 0\n            dut._log.info(f\"FIFO is EMPTY after reading {read_count} words.\")\n            break\n        expected_data = scoreboard[read_count]\n        read_val      = dut.o_rd_data.value\n        assert read_val == expected_data, f\"Mismatch on read! Expected={expected_data}, Got={read_val}\"\n        read_count += 1\n\n    await Timer(2, units=\"ns\")\n\n\n\n    ############################################################################\n    # 6. Test #4: Partial Writes, Then Partial Reads\n    ############################################################################\n    dut._log.info(\"=== TEST #5: Partial Writes, Then Partial Reads ===\")\n\n    # Re-apply reset to start fresh\n    await reset_dut(dut)\n\n    # Step 5a: Write some portion (less than full)\n    scoreboard = []\n    write_limit = 50  # Arbitrary for partial test\n    await FallingEdge(dut.i_wr_clk)\n    dut.i_wr_en.value = 1\n\n    for i in range(write_limit):\n        dut.i_wr_data.value = i\n        await RisingEdge(dut.i_wr_clk)\n        scoreboard.append(i)\n        if dut.o_fifo_full.value == 1:\n            dut._log.info(\"Reached FIFO full while attempting partial fill.\")\n            break\n    dut.i_wr_en.value = 0\n\n    # Check we are not empty\n    assert dut.o_fifo_empty.value == 0, \"FIFO unexpectedly empty after partial write\"\n\n    # Step 5b: Read only half\n    read_amount = write_limit // 2\n    await FallingEdge(dut.i_rd_clk)\n    dut.i_rd_en.value = 1\n    await FallingEdge(dut.i_rd_clk)\n    read_count = 0\n    for i in range(read_amount):\n        await RisingEdge(dut.i_rd_clk)\n        if dut.o_fifo_empty.value == 1:\n            dut._log.warning(\"FIFO went empty earlier than expected.\")\n            break\n        got_data = dut.o_rd_data.value.integer\n        exp_data = scoreboard[read_count]\n        assert got_data == exp_data, f\"Mismatch partial read. Got={got_data}, Exp={exp_data}\"\n        read_count += 1\n\n    dut.i_rd_en.value = 0\n\n    # Ensure we haven't fully emptied unless we read everything\n    if read_count < len(scoreboard):\n        assert dut.o_fifo_empty.value == 0, \"FIFO went empty too soon.\"\n\n    dut._log.info(\"Partial write/read scenario completed.\")\n\n    ############################################################################\n    # 7. Test #5: Mid-Operation Resets\n    ############################################################################\n    dut._log.info(\"=== TEST #6: Mid-Operation Resets ===\")\n\n    # Start writing some data\n    scoreboard_wr = []\n    scoreboard_rd = []\n    await FallingEdge(dut.i_wr_clk)\n    dut.i_wr_en.value = 1\n\n    for i in range(10):\n        dut.i_wr_data.value = i\n        scoreboard_wr.append(i)\n        await RisingEdge(dut.i_wr_clk)\n\n    # Assert reset in the write domain mid-operation\n    dut._log.info(\"Asserting write domain reset mid-operation...\")\n    dut.i_wr_en.value = 0\n    dut.i_wr_rst_n.value = 0\n    for i in range(3):\n        await RisingEdge(dut.i_wr_clk)\n    dut.i_wr_rst_n.value = 1\n    await RisingEdge(dut.i_wr_clk)\n    dut.i_wr_en.value = 0\n\n    # After write-domain reset, FIFO should not appear empty from the write perspective\n    assert dut.o_fifo_empty.value == 0, \"FIFO empty after write-domain reset\"\n\n    # Write more data so the read side has something\n    for i in range(5):\n        dut.i_wr_data.value = 100 + i\n        dut.i_wr_en.value = 1\n        await RisingEdge(dut.i_wr_clk)\n    dut.i_wr_en.value = 0\n\n    # Now read a couple words\n    await FallingEdge(dut.i_rd_clk)\n    dut.i_rd_en.value = 1\n    await FallingEdge(dut.i_rd_clk)\n    for i in range(2):\n        await RisingEdge(dut.i_rd_clk)\n\n    # Reset read domain mid-operation\n    dut._log.info(\"Asserting read domain reset mid-operation...\")\n    dut.i_rd_rst_n.value = 0\n    dut.i_rd_en.value = 0\n    for i in range(3):\n        await RisingEdge(dut.i_rd_clk)\n    dut.i_rd_rst_n.value = 1\n    await RisingEdge(dut.i_rd_clk)\n\n    # After read-domain reset, FIFO should appear empty from read perspective\n    assert dut.o_fifo_empty.value == 1, \"FIFO not empty after read-domain reset\"\n    dut.i_rd_en.value = 0\n\n    dut._log.info(\"Mid-operation resets scenario completed.\")\n\n    ############################################################################\n    # End\n    ############################################################################\n    dut._log.info(\"=== All done. All test scenarios completed successfully! ===\")\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR=''\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_binary_search_tree_algorithms_0014", "categories": ["cid005", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt, and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "You are provided with three SystemVerilog modules in the rtl/ directory. You need to integrate these three modules into a top-level module called `bst_operations`,  which should support the operations described further in the specification in the docs/bst_operations.md. \n\n1. `search_binary_search_tree` \u2014 performs key search in a binary search tree (BST)  \n2. `delete_node_binary_search_tree` \u2014 deletes a node with the given key from the BST  \n3. `binary_search_tree_sort_construct` \u2014 performs both BST construction and  sorting  via in-order traversal \n\n---\n\n### Required Modifications\n\n1. The module `binary_search_tree_sort_construct` currently combines **BST construction** and **sorting** into one module.  \n   Create **two separate functional modules** using `binary_search_tree_sort_construct` as the reference to be able to provide a BST input to the `search_binary_search_tree` and `delete_node_binary_search_tree` modules and optionally sort after the operations. While creating modules for separating the operations, add necessary input/output ports to the new submodules to propagate data between modules. (Only top module consistency needs to be retained as per the spec).\n   - `bst_tree_construct`: builds the BST\n   - `binary_search_tree_sort`: performs in-order traversal to output sorted keys\n\n2. You must **connect these new modules** inside `bst_operations` along with  `search_binary_search_tree` and  `delete_node_binary_search_tree`\n\n3. No additional latency other than that for handling completion flags must be added in between operations. \n\n---\n\n### Key Handling Consistency\n\nThere is an inconsistency in how **invalid keys** are handled across the modules. The original `binary_search_tree_sort_construct`  module uses `0` to indicate **invalid keys**. In contrast, both `search_binary_search_tree` and `delete_node_binary_search_tree` use **all 1s** (`{DATA_WIDTH{1'b1}}`) to represent invalid key values\n\n- Ensure that all modules within `bst_operations` use **consistent invalid key and pointer representations**  \n- Recommended:\n  - `INVALID Key = {DATA_WIDTH{1'b1}}`\n  - `INVALID Pointer = {($clog2(ARRAY_SIZE)+1){1'b1}}`\n\n---\n\n###  Top-Level Interface\n\nThe `bst_operations` module must:\n- Accept input data as a flattened array (`data_in`)\n- Accept a key (`operation_key`) and operation selector (`operation`)\n- Output the updated BST structure and, optionally, sorted keys\n- Output flags to indicate operation completion and validity\n---\n", "context": {"rtl/delete_node_binary_search_tree.sv": "module delete_node_binary_search_tree #(\n    parameter DATA_WIDTH = 16,         // Width of the data (of a single element)\n    parameter ARRAY_SIZE = 5          // Maximum number of elements in the BST\n) (\n\n    input clk,                                  // Clock signal\n    input reset,                                // Reset signal\n    input reg start,                            // Start signal to initiate the search\n    input reg [DATA_WIDTH-1:0] delete_key,      // Key to delete in the BST\n    input reg [$clog2(ARRAY_SIZE):0] root,      // Root node of the BST\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys, // Node keys in the BST\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child,           // Left child pointers\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child,           // Right child pointers\n    output reg [ARRAY_SIZE*DATA_WIDTH-1:0] modified_keys,                    // Node keys in the BST\n    output reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] modified_left_child,  // Left child pointers\n    output reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] modified_right_child, // Right child pointers\n    output reg complete_deletion,         // Signal indicating search completion\n    output reg delete_invalid            // Signal indicating invalid search\n);\n                                                                                                                                       \n    // Parameters for FSM states\n    parameter S_IDLE = 3'b000,                   // Idle state\n              S_INIT = 3'b001,                   // Initialization state\n              S_SEARCH_LEFT = 3'b010,            // Search in left subtree\n              S_SEARCH_RIGHT = 3'b011,           // Search in both left and right subtrees\n              S_DELETE = 3'b100,                 // Delete a node\n              S_DELETE_COMPLETE = 3'b101,        // Complete deletion\n              S_FIND_INORDER_SUCCESSOR = 3'b110; // State to find inorder successor\n\n   \n    // Registers to store the current FSM state\n    reg [2:0] delete_state;\n\n    // Variables to manage traversal\n    reg found;                                 // Indicates if the key is found\n\n    // Stacks for managing traversal of left and right subtrees\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_stack;  // Stack for left subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_stack; // Stack for right subtree traversal\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_left;         // Stack pointer for left subtree\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_right;        // Stack pointer for right subtree\n\n    // Pointers for the current nodes in left and right subtrees\n    reg [$clog2(ARRAY_SIZE):0] current_left_node;  // Current node in the left subtree\n    reg [$clog2(ARRAY_SIZE):0] current_right_node; // Current node in the right subtree\n    reg [$clog2(ARRAY_SIZE):0] current_node;       // Current node\n\n    // Integer for loop iterations\n    integer i, j;\n    reg [$clog2(ARRAY_SIZE):0] null_node;\n\n    // Registers for inorder successor search\n    reg [$clog2(ARRAY_SIZE):0] min_node;       // Inorder successor node\n\n    // The INVALID pointer value used in comparisons.\n    localparam [($clog2(ARRAY_SIZE)+1)-1:0] INVALID = {($clog2(ARRAY_SIZE)+1){1'b1}};\n    localparam [DATA_WIDTH-1:0] INVALID_KEY = {DATA_WIDTH{1'b1}};\n\n     // FSM for inorder successor search\n    reg inorder_search_active;                 // Flag to activate inorder successor search\n\n    // Always block triggered on the rising edge of the clock or reset signal\n    always @(posedge clk or posedge reset) begin\n         reg [$clog2(ARRAY_SIZE):0] lchild, rchild;\n        if (reset) begin\n            // Reset all states and variables\n            delete_state <= S_IDLE;  // Set state to IDLE\n            found <= 0;              // Reset found flag\n            complete_deletion <= 0;     // Reset complete_deletion signal\n            sp_left <= 0;            // Reset left stack pointer\n            sp_right <= 0;           // Reset right stack pointer\n            delete_invalid <= 0;     // Set invalid_key to 0\n            inorder_search_active <= 0;           \n            // Clear the stacks\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                modified_left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                modified_right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                modified_keys[i*DATA_WIDTH +: DATA_WIDTH] <= INVALID_KEY;\n            end\n\n        end else begin\n            // Main FSM logic\n            case (delete_state)\n                S_IDLE: begin\n                    // Reset intermediate variables\n                     for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                        left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        modified_left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        modified_right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        modified_keys[i*DATA_WIDTH +: DATA_WIDTH] <= INVALID_KEY;\n                    end\n                    complete_deletion <= 0;\n                    delete_invalid <= 0;\n                    inorder_search_active <= 0;\n                    if (start) begin\n                        // Start the search\n                        sp_left <= 0;\n                        sp_right <= 0;\n                        found <= 0;\n                        delete_state <= S_INIT; // Move to INIT state\n                    end\n                end\n\n                S_INIT: begin\n                    if (root != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        // Compare the delete key with the root key\n                        if (delete_key == keys[root*DATA_WIDTH +: DATA_WIDTH]) begin\n                            found <= 1;\n                            current_node <= 0;\n                            delete_state <= S_DELETE; // Move to complete search state\n                        end else if (keys[0*DATA_WIDTH +: DATA_WIDTH] > delete_key) begin // Else if the first key in the keys array is greater than the delete key\n                            delete_state <= S_SEARCH_LEFT;\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];    // Set current left node pointer from the root's left child\n                        end else begin\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];    // Set current left node pointer from the root's left child\n                            current_right_node <= right_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];  // Set current right node pointer from the root's right child\n                            delete_state <= S_SEARCH_RIGHT; // Search in both left and right subtrees\n                        end\n                    end else begin\n                        delete_invalid <= 1;\n                        complete_deletion <= 0;\n                        delete_state <= S_IDLE;\n                    end\n                end\n\n                S_SEARCH_LEFT: begin\n                    // Traverse the left subtree\n                    if (current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin                // If left traversal is not finished and the current left node is valid\n                        left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;  // Push the current left node index onto the left stack\n                        sp_left <= sp_left + 1;\n                        current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];  // Move to the left child of the current node\n                        if (delete_key == keys[current_left_node*DATA_WIDTH +: DATA_WIDTH]) begin    // If the key at the retrieved node matches the search key\n                            found <= 1;\n                            current_node <= current_left_node;  \n                            delete_state <= S_DELETE; // Move to complete search state\n                        end\n                    end else if (sp_left > 0) begin\n                        sp_left <= sp_left - 1;\n                        current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];   // Move to the right child of the popped node for further traversal\n                    end else begin\n                        if (found == 1) begin\n                            delete_state <= S_DELETE; // Move to complete search state\n                        end else begin\n                            delete_invalid <= 1;\n                            complete_deletion <= 0;\n                            delete_state <= S_IDLE;\n                        end\n                    end\n                end\n\n                S_SEARCH_RIGHT: begin\n                    if (current_right_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        right_stack[sp_right*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_right_node;\n                        sp_right <= sp_right + 1;\n                        current_right_node <= left_child[current_right_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; // Move to left child of the current right node\n                        if (delete_key == keys[current_right_node*DATA_WIDTH +: DATA_WIDTH]) begin\n                            current_node <= current_right_node;\n                            found <= 1;\n                            delete_state <= S_DELETE;  \n                        end\n                    end else if (sp_right > 0) begin\n                        sp_right <= sp_right - 1;\n                        current_right_node <= right_child[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; // Move to right child of the popped node\n                    end else begin\n                        if (found == 1) begin\n                            delete_state <= S_DELETE; // Move to complete search state\n                        end else begin\n                            delete_invalid <= 1;\n                            complete_deletion <= 0;\n                            delete_state <= S_IDLE;\n                        end\n                    end\n                end\n\n                S_DELETE: begin\n                    // First, load the left and right child indices of the node.\n                    modified_keys <= keys;     //if not copied here then will give buggy output with only valid values with the moddified tree without the original tree values\n                    modified_left_child <= left_child;\n                    modified_right_child <= right_child;\n\n                    rchild = right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    lchild = left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n\n                    if (left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == INVALID\n                                    && right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] != INVALID) begin\n                        // Node has only right child\n                        // Replace the current node's key and pointers with those of its right child.\n                        modified_keys[current_node*DATA_WIDTH +: DATA_WIDTH] <= keys[rchild*DATA_WIDTH +: DATA_WIDTH];\n                        modified_left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= left_child[rchild*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        modified_right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= right_child[rchild*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        null_node <= rchild;\n                        delete_state <= S_DELETE_COMPLETE;\n                    end\n                    else if (right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == INVALID\n                                && left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] != INVALID) begin\n                        // Node has only left child.\n                        modified_keys[current_node*DATA_WIDTH +: DATA_WIDTH] <= keys[lchild*DATA_WIDTH +: DATA_WIDTH];\n                        modified_left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= left_child[lchild*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        modified_right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= right_child[lchild*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        null_node <= lchild;\n                        delete_state <= S_DELETE_COMPLETE;\n                    end\n                    else if (right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == INVALID    //Will give bug 'x' is both condition set to != INVAALID\n                                && left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == INVALID) begin\n                        // Node has no right or left child\n                        null_node <= current_node;\n                        delete_state <= S_DELETE_COMPLETE;\n                    end\n                    else begin\n                        // Node has two children.\n                        // Start finding the inorder successor.\n                        min_node <= rchild;\n                        inorder_search_active <= 1;\n                        delete_state <= S_FIND_INORDER_SUCCESSOR;\n                        \n                    end\n                end\n\n                S_FIND_INORDER_SUCCESSOR: begin\n                    if (inorder_search_active) begin\n                        if (left_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] != INVALID) begin\n                            min_node <= left_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; // Move to the left child\n                        end else begin\n                            // Copy the inorder successor's key into the current node.\n                            modified_keys[current_node*DATA_WIDTH +: DATA_WIDTH] <= keys[min_node*DATA_WIDTH +: DATA_WIDTH];\n\n                            // Delete the inorder successor by replacing it with its right child.\n                            if (right_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]!= INVALID) begin\n                                modified_keys[min_node*DATA_WIDTH +: DATA_WIDTH] <= keys[right_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH];\n                                modified_right_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= right_child[right_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                modified_left_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= left_child[right_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                null_node <= right_child[min_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else begin\n                                null_node <= min_node;\n                            end\n\n                            delete_state <= S_DELETE_COMPLETE;\n                            inorder_search_active <= 0;\n                        end\n                    end\n\n                end\n\n                S_DELETE_COMPLETE:begin\n                    modified_keys[null_node*DATA_WIDTH +: DATA_WIDTH] <= INVALID_KEY;\n                    modified_left_child[null_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= INVALID;\n                    modified_right_child[null_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= INVALID;\n \n                    for (j=0; j < ARRAY_SIZE; j++) begin\n                        if (modified_left_child[j*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == null_node) begin  //Buggy output if instead of modified child the original child is checked\n                            modified_left_child[j*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= INVALID;\n                        end\n                        if (modified_right_child[j*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == null_node) begin\n                            modified_right_child[j*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= INVALID;\n                        end\n                    end\n                    delete_state <= S_IDLE;\n                    complete_deletion <= 1;\n                end\n\n                default: begin\n                    delete_state <= S_IDLE; // Default to IDLE state\n                end\n            endcase\n        end\n    end\n\nendmodule", "docs/bst_operations.md": "## Specification\n\nA **Binary Search Tree (BST)** is a hierarchical data structure where:\n\n- Each node contains a key.\n- The left child contains keys less than the parent.\n- The right child contains keys greater than the parent.\n\n### Overview\n\nThe `bst_operations` module implements **core Binary Search Tree (BST) operations** in hardware. It supports:\n\n- **Search**\n- **Delete**\n- **Optional sorting** of the BST post-operation\n\nThe module constructs a BST from an input array, performs the requested operation (`search` or `delete`), and outputs the resulting BST (and optionally its sorted version).\n\n---\n\n### Module Interface\n\n#### Inputs\n\n| Name                  | Width                                    | Description                                                             |\n|-----------------------|------------------------------------------|-------------------------------------------------------------------------|\n| `clk`                 | 1 bit                                    | Clock signal. The design is synchronized to the positive edge of this   |\n| `reset`               | 1 bit                                    | Asynchronous active high reset                                          |\n| `start`               | 1 bit                                    | Active high start signal to begin operation                             |\n| `operation_key`       | `DATA_WIDTH`                             | Key to search or delete                                                 |\n| `data_in`             | `ARRAY_SIZE \u00d7 DATA_WIDTH`                | Flattened input array of node values                                    |\n| `operation`           | 1 bit                                    | `0`: Search, `1`: Delete                                                |\n| `sort_after_operation`| 1 bit                                    | `1`: Sort BST after operation, `0`: Skip sorting                        |\n\n---\n\n#### Outputs\n\n| Name                  | Width                                                | Description                                                                                                                  |\n|-----------------------|------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------|\n| `key_position`        | `clog2(ARRAY_SIZE)+1`                                | Index of `operation_key` if found during search. For other operations, it is asserted as INVALID.                            |\n| `complete_operation`  | 1 bit                                                | High when operation is successfully completed                                                                                |\n| `operation_invalid`   | 1 bit                                                | High if the operation was invalid (e.g., key not found)                                                                      |\n| `out_sorted_data`     | `(ARRAY_SIZE \u00d7 DATA_WIDTH)`                          | Sorted BST output (if `sort_after_operation = 1`)                                                                            |\n| `out_keys`            | `(ARRAY_SIZE \u00d7 DATA_WIDTH)`                          | Updated node keys after operation                                                                                            |\n| `out_left_child`      | `(ARRAY_SIZE \u00d7 (clog2(ARRAY_SIZE)+1))`               | Updated left child indices                                                                                                   |\n| `out_right_child`     | `(ARRAY_SIZE \u00d7 (clog2(ARRAY_SIZE)+1))`               | Updated right child indices                                                                                                  |\n\n---\n\n#### Parameters:\n- DATA_WIDTH (default 16): Width of a single element, greater than 0.\n- ARRAY_SIZE (default 5): Number of elements in the array, will be greater than 0 \n\n### Internal Components\n\n#### Tree Construction\n\n- `bst_tree_construct` constructs the BST from the input `data_in`. No duplicate keys are allowed. \n- Outputs keys, left and right child arrays, and root node.\n- Signals the top module `bst_operations` on completion of tree construction.\n- If the structure is invalid (any of the data in the input array is invalid), a control signal to flag that the operation is invalid is raised. This terminates all the ations and asserts the `operation_invalid` to 1. \n\n---\n\n#### Search Operation\n\n- Triggered when `operation == 0` and `start` is asserted.\n- Uses `search_binary_search_tree` module.\n- If `sort_after_operation == 1`, then sorting logic is also invoked.\n- If the key is not found, `operation_invalid` is raised.\n\n---\n\n#### Delete Operation\n\n- Triggered when `operation == 1`.\n- Uses `delete_node_binary_search_tree`.\n- Updates BST and optionally triggers sort if `sort_after_operation` is high.\n- Handles cases where a node has:\n  - No child\n  - One child\n  - Two children (uses in-order successor)\n\n---\n\n#### BST Sorting\n\n- `binary_search_tree_sort` traverses the BST in order.\n- Generates `out_sorted_data`.\n- If sorting is disabled, `out_sorted_data` is filled with `INVALID_KEY`.\n\n---\n\n### Handling Invalid Keys & Pointers\n\n| Signal              | Value                        | Purpose                                                                                                          |\n|---------------------|------------------------------|------------------------------------------------------------------------------------------------------------------|\n| `INVALID Key`       | All 1s in `DATA_WIDTH`       | Represents unused or removed keys                                                                                |\n| `INVALID Pointer`   | All 1s in child pointer width| Represents NULL pointer in left/right child arrays                                                               |\n| `operation_invalid` | 1                            | Raised when operation (search and delete) is not complete, BST structure is invalid, or when sorting is invalid  |\n| `out_sorted_data`   | All 1s if invalid            | Filled with `INVALID_KEY` if sorting was skipped                                                                 |\n\n### Successful Completion of Operation\n\nThe `bst_operations` module asserts the `complete_operation` signal only after all required processes are finished\u2014specifically, the selected operation (search or delete)  if enabled, the sorting operation (`sort_after_operation` = 1). Since each submodule (search, delete, and sort) asserts its respective done signal for only one clock e, these signals must be latched internally to ensure accurate detection and confirmation of successful completion across multiple cycles.\n\n### Latency Analysis\n\nThe total latency from asserting `start` to the `complete_operation` signal being set to `1` depends on the selected operation (**search** or **delete**) and whether sorting nabled using `sort_after_operation`.\n\nIt includes the cumulative clock cycles for:\n- Constructing the BST,\n- Performing the specified operation,\n- Optional sorting of the resulting BST.\n\nEach internal module asserts its respective done signal for 1 clock cycle, which is latched and used by the top-level module to trigger subsequent stages.\n\nWhen sorting is **enabled**, the design requires:\n- 1 additional clock cycle each for: construction complete, operation complete, and sort complete  \n- **Total overhead = 3 clock cycles**\n\nWhen sorting is **not enabled**, the design still incurs:\n- 1 clock cycle each for construction complete and operation complete  \n- +1 additional cycle to latch the `done` or `invalid` signal from the operation module  \n- **Total overhead = 3 clock cycles**\n\nThis ensures control signal synchronization and consistent behavior regardless of sorting.", "rtl/binary_search_tree_sort_construct.sv": "module binary_search_tree_sort_construct #(\n    parameter DATA_WIDTH = 16,\n    parameter ARRAY_SIZE = 5\n) (\n    input clk,\n    input reset,\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in, // Input data to be sorted\n    input start,\n    output reg [ARRAY_SIZE*DATA_WIDTH-1:0] sorted_out, // Sorted output\n    output reg done\n);\n\n    // Parameters for top-level FSM states\n    parameter IDLE = 2'b00, BUILD_TREE = 2'b01, SORT_TREE = 2'b10;\n\n    // Parameters for nested FSM states (Build Tree)\n    parameter INIT = 2'b00, INSERT = 2'b01, TRAVERSE = 2'b10, COMPLETE = 2'b11;\n\n    // Parameters for nested FSM states (Sort Tree)\n    parameter S_INIT = 2'b00, S_TRAVERSE_LEFT = 2'b01, S_PROCESS_NODE = 2'b10, S_TRAVERSE_RIGHT = 2'b11;\n\n    // Registers for FSM states\n    reg [1:0] top_state, build_state, sort_state;\n\n    // BST representation\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in_copy;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] temp_out;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys; // Array to store node keys\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child; // Left child pointers\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child; // Right child pointers\n    reg [$clog2(ARRAY_SIZE):0] root; // Root node pointer\n    reg [$clog2(ARRAY_SIZE):0] next_free_node; // Pointer to the next free node\n\n    // Stack for in-order traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] stack; // Stack for traversal\n    reg [$clog2(ARRAY_SIZE):0] sp; // Stack pointer\n\n    // Working registers\n    reg [$clog2(ARRAY_SIZE):0] current_node; // Current node being processed\n    reg [$clog2(ARRAY_SIZE):0] input_index; // Index for input data\n    reg [$clog2(ARRAY_SIZE):0] output_index; // Index for output data\n    reg [DATA_WIDTH-1:0] temp_data; // Temporary data register\n\n    // Initialize all variables\n    integer i;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all states and variables\n            top_state <= IDLE;\n            build_state <= INIT;\n            sort_state <= S_INIT;\n            root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Null pointer\n            next_free_node <= 0;\n            sp <= 0;\n            input_index <= 0;\n            output_index <= 0;\n            done <= 0;\n\n            // Clear tree arrays\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                temp_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n            end\n\n        end else begin\n            case (top_state)\n                IDLE: begin\n                    done <= 0;\n                    input_index <= 0;\n                    output_index <= 0; \n                    root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; ; // Null pointer\n                    next_free_node <= 0;\n                    sp <= 0;\n                    for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                        keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                        right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        temp_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                    end\n                    if (start) begin\n                        // Load input data into input array\n                        top_state <= BUILD_TREE;\n                        build_state <= INIT;\n                        data_in_copy <= data_in;\n                    end\n                end\n                BUILD_TREE: begin\n                    case (build_state)\n                        INIT: begin\n                            if (input_index < ARRAY_SIZE) begin\n                                temp_data <= data_in_copy[input_index*DATA_WIDTH +: DATA_WIDTH]; \n                                input_index <= input_index + 1;\n                                build_state <= INSERT;\n                            end else begin\n                                build_state <= COMPLETE;\n                            end\n                        end\n\n                        INSERT: begin\n                            if (root == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                // Tree is empty, insert at root\n                                root <= next_free_node;\n                                keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                next_free_node <= next_free_node + 1; \n                                build_state <= INIT;\n                            end else begin\n                                // Traverse the tree to find the correct position\n                                current_node <= root; \n                                build_state <= TRAVERSE;\n                            end\n                        end\n                        \n                        TRAVERSE: begin      \n                            if ((temp_data < keys[current_node*DATA_WIDTH +: DATA_WIDTH])) begin\n                                if (left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                    left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                                    keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                    next_free_node <= next_free_node + 1;\n                                    build_state <= INIT;\n                                end else begin\n                                    current_node <= left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                                end\n                            end else begin\n                                if (right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                    right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                                    keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data; \n                                    next_free_node <= next_free_node + 1;\n                                    build_state <= INIT;\n                                end else begin\n                                    current_node <= right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                                end\n                            end\n                        end\n                        COMPLETE: begin\n                            // Tree construction complete\n                            top_state <= SORT_TREE;\n                            sort_state <= S_INIT;\n                        end\n                    endcase\n                end\n\n                SORT_TREE: begin\n                    case (sort_state)\n                        S_INIT: begin\n                            \n                            if (root != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                current_node <= root; // Start from the root node\n                                sp <= 0;\n                                sort_state <= S_TRAVERSE_LEFT;\n                            end\n                        end\n\n                        S_TRAVERSE_LEFT: begin\n                            if (current_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                stack[sp*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_node;\n                                sp <= sp + 1;\n                                current_node <= left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else begin\n                                sort_state <= S_PROCESS_NODE;\n                            end\n                        end\n\n                        S_PROCESS_NODE: begin\n                            if (sp > 0) begin\n                                sp <= sp - 1;\n                                current_node <= stack[(sp-1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                output_index <= output_index + 1; \n                                temp_out[output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[stack[($unsigned(sp)-1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]; // Output the key\n                                sort_state <= S_TRAVERSE_RIGHT;\n                            end else begin\n                                done <= 1; // All nodes processed\n                                sort_state <= S_INIT;\n                                top_state <= IDLE;\n                                sorted_out <= temp_out;\n                            end\n                        end\n\n                        S_TRAVERSE_RIGHT: begin\n                            current_node <= right_child[current_node*($clog2(ARRAY_SIZE)+1) +:($clog2(ARRAY_SIZE)+1)];\n                            sort_state <= S_TRAVERSE_LEFT;\n                        end\n                    endcase    \n                end\n\n                default: begin\n                    top_state <= IDLE; // Default behavior for top-level FSM\n                end\n            endcase\n        end\n    end\nendmodule", "rtl/search_binary_search_tree.sv": "module search_binary_search_tree #(\n    parameter DATA_WIDTH = 16,         // Width of the data (of a single element)\n    parameter ARRAY_SIZE = 5          // Maximum number of elements in the BST\n) (\n\n    input clk,                         // Clock signal\n    input reset,                       // Reset signal\n    input reg start,                   // Start signal to initiate the search\n    input reg [DATA_WIDTH-1:0] search_key, // Key to search in the BST\n    input reg [$clog2(ARRAY_SIZE):0] root, // Root node of the BST\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys, // Node keys in the BST\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child, // Left child pointers\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child, // Right child pointers\n    output reg [$clog2(ARRAY_SIZE):0] key_position, // Position of the found key\n    output reg complete_found,         // Signal indicating search completion\n    output reg search_invalid          // Signal indicating invalid search\n);\n                                                                                                                                        \n    // Parameters for FSM states\n    parameter S_IDLE = 3'b000,                 // Idle state\n              S_INIT = 3'b001,                 // Initialization state\n              S_SEARCH_LEFT = 3'b010,          // Search in left subtree\n              S_SEARCH_LEFT_RIGHT = 3'b011,    // Search in both left and right subtrees\n              S_COMPLETE_SEARCH = 3'b100;      // Search completion state\n   \n    // Registers to store the current FSM state\n    reg [2:0] search_state;\n\n    // Variables to manage traversal\n    reg [$clog2(ARRAY_SIZE):0] position;       // Position of the current node\n    reg found;                                 // Indicates if the key is found\n\n    reg left_done, right_done;                 // Flags to indicate completion of left and right subtree traversals\n\n    // Stacks for managing traversal of left and right subtrees\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_stack;  // Stack for left subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_stack; // Stack for right subtree traversal\n    reg [$clog2(ARRAY_SIZE):0] sp_left;         // Stack pointer for left subtree\n    reg [$clog2(ARRAY_SIZE):0] sp_right;        // Stack pointer for right subtree\n\n    // Pointers for the current nodes in left and right subtrees\n    reg [$clog2(ARRAY_SIZE):0] current_left_node;  // Current node in the left subtree\n    reg [$clog2(ARRAY_SIZE):0] current_right_node; // Current node in the right subtree\n\n    // Output indices for traversal\n    reg [$clog2(ARRAY_SIZE):0] left_output_index;  // Output index for left subtree\n    reg [$clog2(ARRAY_SIZE):0] right_output_index; // Output index for right subtree\n\n    // Integer for loop iterations\n    integer i;\n\n    // Always block triggered on the rising edge of the clock or reset signal\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all states and variables\n            search_state <= S_IDLE;  // Set state to IDLE\n            found <= 0;              // Reset found flag\n            position <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Invalid position\n            complete_found <= 0;     // Reset complete_found signal\n            key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Invalid key position\n            left_output_index <= 0;  // Reset left output index\n            right_output_index <= 0; // Reset right output index\n            sp_left <= 0;            // Reset left stack pointer\n            sp_right <= 0;           // Reset right stack pointer\n            left_done <= 0;          // Reset left_done flag\n            right_done <= 0;         // Reset right_done flag\n            search_state <= S_IDLE;  // Set state to IDLE\n            search_invalid <= 0;        // Set invalid_key to 0\n            \n            // Clear the stacks\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n            end\n\n        end else begin\n            // Main FSM logic\n            case (search_state)\n                S_IDLE: begin\n                    // Reset intermediate variables\n                    for (i = 0; i < ARRAY_SIZE+1; i = i + 1) begin\n                        left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                    end\n                    complete_found <= 0;\n                    search_invalid <= 0;\n\n                    if (start) begin\n                        // Start the search\n                        left_output_index <= 0;\n                        right_output_index <= 0;\n                        sp_left <= 0;\n                        sp_right <= 0;\n                        left_done <= 0;\n                        right_done <= 0;\n                        found <= 0;\n                        position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        search_state <= S_INIT; // Move to INIT state\n                    end\n                end\n\n                S_INIT: begin\n                    if (root != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        // Compare the search key with the root key\n                        if (search_key == keys[root*DATA_WIDTH +: DATA_WIDTH]) begin\n                            found <= 1;\n                            if (left_child[0*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                position <= 0;\n                                search_state <= S_COMPLETE_SEARCH; // Move to complete search state\n                            end else begin\n                                search_state <= S_SEARCH_LEFT; // Search in the left subtree\n                                current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end\n                        end else if (keys[0*DATA_WIDTH +: DATA_WIDTH] > search_key) begin\n                            search_state <= S_SEARCH_LEFT;\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else begin\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            current_right_node <= right_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            search_state <= S_SEARCH_LEFT_RIGHT; // Search in both left and right subtrees\n                        end\n                    end else begin\n                        search_state <= S_COMPLETE_SEARCH; // Root is null\n                    end\n                end\n\n                S_SEARCH_LEFT: begin\n                    // Traverse the left subtree\n                    if (!left_done && current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                        sp_left <= sp_left + 1;\n                        current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done && sp_left > 0) begin\n                        sp_left <= sp_left - 1;\n                        current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        if (search_key == keys[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]) begin\n                            found <= 1;\n                            position <= left_output_index;   \n                            search_state <= S_COMPLETE_SEARCH; // Move to complete search state\n                        end\n                        left_output_index <= left_output_index + 1;\n                        current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done) begin\n                        if (found == 1) begin\n                            position <= left_output_index;\n                        end \n                        left_done <= 1;\n                        search_state <= S_COMPLETE_SEARCH;\n                    end\n                end\n\n                S_SEARCH_LEFT_RIGHT: begin\n                    // Traverse both left and right subtrees\n                    if (!left_done && current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                        sp_left <= sp_left + 1;\n                        current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done && sp_left > 0) begin\n                        sp_left <= sp_left - 1;\n                        current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        left_output_index <= left_output_index + 1;\n                        current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done) begin\n                        left_done <= 1;\n                    end\n\n                    if (!found) begin\n                        if (!right_done && current_right_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                            right_stack[sp_right*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_right_node;\n                            sp_right <= sp_right + 1;\n                            current_right_node <= left_child[current_right_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else if (!right_done && sp_right > 0) begin\n                            sp_right <= sp_right - 1;\n                            current_right_node <= right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            if (found != 1) begin\n                                if (search_key == keys[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]) begin\n                                    found <= 1;\n                                end\n                            end\n                            right_output_index <= right_output_index + 1;\n                            current_right_node <= right_child[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else if (!right_done) begin\n                            right_done <= 1;\n                        end\n\n                    end else if (left_done) begin\n                        position <= left_output_index + right_output_index;\n                        search_state <= S_COMPLETE_SEARCH;  \n                    end\n\n                    if (right_done && left_done && !found) begin\n                        search_state <= S_COMPLETE_SEARCH;\n                    end\n                end\n\n                S_COMPLETE_SEARCH: begin\n                    // Complete the search\n                    if (!found) begin\n                        complete_found <= 0;\n                        key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        search_invalid <= 1;\n                    end else begin\n                        complete_found  <= 1;\n                        key_position <= position;\n                        search_invalid <= 0;\n                    end\n                    search_state <= S_IDLE; // Return to IDLE state\n                end\n\n                default: begin\n                    search_state <= S_IDLE; // Default to IDLE state\n                end\n            endcase\n        end\n    end\n\nendmodule"}, "patch": {"rtl/binary_search_tree_sort.sv": "", "rtl/bst_operations.sv": "", "rtl/bst_tree_construct.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -vs", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/bst_operations.sv /code/rtl/binary_search_tree_sort.sv   /code/rtl/bst_tree_construct.sv  /code/rtl/search_binary_search_tree.sv /code/rtl/delete_node_binary_search_tree.sv\nTOPLEVEL        = bst_operations\nMODULE          = test_bst_operations\nPYTHONPATH      = /src\nHASH            = 14-bst-operations-initial-wo-insert\n", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nimport math\n\n# Reference model\ndef search_reference_model(search_key, keys):\n    \"\"\"Sort the keys and find the position of the search key.\"\"\"\n    sorted_keys = sorted(keys)\n    if search_key in sorted_keys:\n        return sorted_keys.index(search_key)\n    else:\n        return -1\n\ndef compute_invalid_key(data_width):\n    \"\"\"\n    The invalid key is all ones in data_width bits, i.e., (2^data_width) - 1.\n    Example: if data_width=6, invalid_key=63.\n    \"\"\"\n    return (1 << data_width) - 1\n\ndef compute_invalid_pointer(array_size):\n    \"\"\"\n    The invalid pointer for the left_child/right_child arrays.\n    = 2^(ceil(log2(array_size)) + 1) - 1\n\n    For example, if array_size=5 => ceil(log2(5))=3 => pointer=2^(3+1)-1=15.\n    \"\"\"\n    if array_size <= 1:\n        # degenerate case\n        return 0\n    exp = math.ceil(math.log2(array_size))\n    return (1 << (exp + 1)) - 1\n\ndef find_node_and_parent(keys, left_child, right_child, root_index,\n                         pointer_invalid, target_key):\n    \"\"\"\n    Find the node that has key == target_key in the BST, along with its parent.\n    Returns (node_index, parent_index) or (None, None) if not found.\n\n    'root_index' is the index of the BST root (often 0 if valid).\n    'pointer_invalid' indicates an invalid pointer (no child).\n    \"\"\"\n    parent_idx = None\n    current_idx = root_index\n    \n    while current_idx != pointer_invalid:\n        current_key = keys[current_idx]\n        if current_key == target_key:\n            return (current_idx, parent_idx)\n        elif target_key < current_key:\n            parent_idx = current_idx\n            current_idx = left_child[current_idx]\n        else:\n            parent_idx = current_idx\n            current_idx = right_child[current_idx]\n    \n    return (None, None)  # not found\n\ndef find_leftmost_index(keys, left_child, right_child, start_index, pointer_invalid):\n    \"\"\"\n    Find the index of the leftmost node in the subtree rooted at 'start_index'.\n    i.e. 'inorder successor' if 'start_index' is the root of a right subtree.\n    \"\"\"\n    current = start_index\n    while left_child[current] != pointer_invalid:\n        current = left_child[current]\n    return current\n\ndef replace_parent_pointer(parent_idx, child_idx, new_idx,\n                           left_child, right_child):\n    \"\"\"\n    Helper to redirect parent_idx\u2019s pointer (left or right) that was referencing child_idx\n    to now reference new_idx instead.\n    This is used to \u201cbypass\u201d or remove the child_idx from the tree structure.\n    \"\"\"\n    if parent_idx is None:\n        # No parent => the deleted node was the root.\n        # We'll return special info so the caller knows how to fix the root\n        return None, new_idx\n    \n    # If the parent's left pointer was the child_idx, update that\n    if left_child[parent_idx] == child_idx:\n        left_child[parent_idx] = new_idx\n    # Else if the parent's right pointer was the child_idx, update that\n    elif right_child[parent_idx] == child_idx:\n        right_child[parent_idx] = new_idx\n    \n    return parent_idx, None  # No change to root; no new root\n\ndef delete_node_with_zero_or_one_child(node_idx, parent_idx,\n                                       keys, left_child, right_child,\n                                       pointer_invalid, key_invalid):\n    \"\"\"\n    Handle the case where node_idx has 0 or 1 child.\n    Returns (new_root_idx) if node_idx was the root and we replaced it,\n    or None if the root is unchanged.\n    \"\"\"\n    left_idx = left_child[node_idx]\n    right_idx = right_child[node_idx]\n    \n    # Determine the single child (or none)\n    if left_idx == pointer_invalid and right_idx == pointer_invalid:\n        # No children (leaf)\n        new_idx = pointer_invalid\n    elif left_idx != pointer_invalid and right_idx == pointer_invalid:\n        # Only left child\n        new_idx = left_idx\n    elif left_idx == pointer_invalid and right_idx != pointer_invalid:\n        # Only right child\n        new_idx = right_idx\n    else:\n        # This function should not be called if there are 2 children\n        return None  # logic error if we get here\n    \n    # Replace parent's pointer from node_idx -> new_idx\n    p, new_root = replace_parent_pointer(parent_idx, node_idx, new_idx,\n                                         left_child, right_child)\n    # Invalidate this node\n    keys[node_idx] = key_invalid\n    left_child[node_idx] = pointer_invalid\n    right_child[node_idx] = pointer_invalid\n    \n    # If new_root is not None, that means the old node_idx was the root\n    return new_root\n\ndef _delete_bst_key_inplace(keys, left_child, right_child, delete_key, data_width=6):\n    \"\"\"\n    Internal helper that modifies the lists IN-PLACE. \n    Standard BST deletion algorithm:\n\n      1. Find the node containing 'delete_key'.\n      2. If not found => done.\n      3. If found, apply BST deletion logic:\n         - If node has 0 or 1 child => bypass it.\n         - If node has 2 children => find the inorder successor from the right subtree,\n           copy that key into the node, and then remove the successor using the\n           0-or-1 child rule.\n\n    This is the same logic as before, but it is *internal*, so we can do it in place\n    after copying in the user-facing function.\n    \"\"\"\n    n = len(keys)\n    if n == 0:\n        return  # Nothing to delete\n\n    key_invalid = compute_invalid_key(data_width)       # e.g. 63\n    pointer_invalid = compute_invalid_pointer(n)        # e.g. 15 for array_size=5\n\n    # Assume the BST root is index=0 if valid\n    root_index = 0\n    if keys[root_index] == key_invalid:\n        # Tree is effectively empty\n        return\n\n    # 1) Find the node to delete (node_idx) and its parent (parent_idx)\n    node_idx, parent_idx = find_node_and_parent(keys, left_child, right_child,\n                                                root_index, pointer_invalid, delete_key)\n    if node_idx is None:\n        return  # Key not found, do nothing\n\n    left_idx = left_child[node_idx]\n    right_idx = right_child[node_idx]\n    has_left = (left_idx != pointer_invalid)\n    has_right = (right_idx != pointer_invalid)\n\n    # 2) If node has 0 or 1 child => remove or bypass it\n    # -------------------- CASE 2: ONLY LEFT CHILD -----------------------\n    if has_left and not has_right:\n        # Copy the left child's data into node_idx\n        keys[node_idx]       = keys[left_idx]\n        left_child[node_idx] = left_child[left_idx]\n        right_child[node_idx]= right_child[left_idx]\n        \n        # Now invalidate the old child's index\n        keys[left_idx]          = key_invalid\n        left_child[left_idx]    = pointer_invalid\n        right_child[left_idx]   = pointer_invalid\n\n    elif not has_left and has_right:\n        # Copy the right child's data into node_idx\n        keys[node_idx]       = keys[right_idx]\n        left_child[node_idx] = left_child[right_idx]\n        right_child[node_idx]= right_child[right_idx]\n        \n        # Now invalidate the old child's index\n        keys[right_idx]          = key_invalid\n        left_child[right_idx]    = pointer_invalid\n        right_child[right_idx]   = pointer_invalid\n       \n    elif not has_left and not has_right:\n        new_root = delete_node_with_zero_or_one_child(node_idx, parent_idx,\n                                                      keys, left_child, right_child,\n                                                      pointer_invalid, key_invalid)\n        if new_root is not None:\n            # If we actually replaced the root with a child or invalid,\n            # just note that in case you want to track the new root. \n            pass\n    else:\n        # 3) Node has 2 children => find inorder successor in right subtree\n        successor_idx = find_leftmost_index(keys, left_child, right_child,\n                                            right_idx, pointer_invalid)\n        successor_key = keys[successor_idx]\n\n        # Overwrite the current node's key with the successor's key\n        keys[node_idx] = successor_key\n\n        # Now remove the successor node. The successor is guaranteed to have <=1 child.\n        # We still need to find the successor's parent for that operation:\n\n        if successor_idx == right_idx and left_child[successor_idx] == pointer_invalid:\n            # The successor is the immediate right child, with no left child\n            # => its parent is node_idx\n            succ_parent = node_idx\n        else:\n            # Otherwise, find the successor's parent by searching in the right subtree\n            # from node_idx:\n            current = right_idx\n            prev = node_idx\n            while current != successor_idx:\n                prev = current\n                if keys[successor_idx] < keys[current]:\n                    current = left_child[current]\n                else:\n                    current = right_child[current]\n            succ_parent = prev\n\n        delete_node_with_zero_or_one_child(successor_idx, succ_parent,\n                                           keys, left_child, right_child,\n                                           pointer_invalid, key_invalid)\n\ndef delete_bst_key(\n    keys, left_child, right_child, delete_key, data_width=6\n):\n    \"\"\"\n    *USER-FACING FUNCTION* that behaves like call-by-value in other languages:\n      - Makes copies of the input arrays.\n      - Performs the BST deletion on those copies.\n      - Returns the new copies (modified).\n    \n    The original arrays remain untouched.\n    \"\"\"\n    # Copy the arrays locally (shallow copy is enough for lists of ints)\n    new_keys = list(keys)\n    new_left_child = list(left_child)\n    new_right_child = list(right_child)\n\n    # Perform the in-place BST deletion on these copies\n    _delete_bst_key_inplace(new_keys, new_left_child, new_right_child,\n                            delete_key, data_width)\n\n    # Return the modified copies\n    return new_keys, new_left_child, new_right_child\n\n\n", "src/test_bst_operations.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nimport harness_library as hrs_lb\nimport math\n\n\n@cocotb.test()\nasync def test_bst_operations(dut):\n    ARRAY_SIZE = int(dut.ARRAY_SIZE.value)\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n\n    clk_period = 10  # ns\n    random.seed(0)  # For reproducibility\n\n    cocotb.start_soon(clock(dut, clk_period))\n\n    await reset_dut(dut, 5)\n    dut.start.value = 0\n\n    build_tree_latency = (((ARRAY_SIZE - 1) * ARRAY_SIZE)/2 + 2 * ARRAY_SIZE + 2)\n    sort_latency = (4 * ARRAY_SIZE + 3)\n    invalid = 0\n\n    # Test Case 2: Non-empty BST\n    if (ARRAY_SIZE == 10 and DATA_WIDTH == 16):\n        keys = arr = [58514, 50092, 48887, 48080, 5485, 5967, 19599, 23938, 34328, 42874]\n        right_child = [31, 31, 31, 31, 5, 6, 7, 8, 9, 31]\n        left_child = [1, 2, 3, 4, 31, 31, 31, 31, 31, 31]\n        run = 0\n        expected_latency_smallest_delete = 8 \n        expected_latency_largest_delete = 4 \n        expected_latency_smallest_search =  8 \n        expected_latency_largest_search = (ARRAY_SIZE - 1) * 2 + 2  + 2\n    elif (ARRAY_SIZE == 15 and DATA_WIDTH == 6):\n        run = 1\n        keys =  arr = [9, 14, 15, 17, 19, 21, 30, 32, 35, 40, 46, 47, 48, 49, 50]\n        left_child = [31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31]\n        right_child = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 31]\n        expected_latency_smallest_delete = 4\n        expected_latency_largest_delete =  ((ARRAY_SIZE - 1) * 2 + 3)      \n        expected_latency_smallest_search = 3\n        expected_latency_largest_search = (ARRAY_SIZE - 1) * 2 + 2 + 2\n    elif (ARRAY_SIZE == 15 and DATA_WIDTH == 32):\n        run = 1\n        keys =  arr =  [200706183, 259064287, 811616460, 956305578, 987713153, 1057458493, 1425113391, 1512400858, 2157180141, 2322902151, 2683058769, 2918411874, 2982472603, 3530595430, 3599316877]\n        keys =  arr = sorted(keys, reverse=True)\n        right_child = [31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31]\n        left_child = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 31]\n        expected_latency_smallest_delete = (ARRAY_SIZE - 1) + 4\n        expected_latency_largest_delete = 4\n        expected_latency_smallest_search = (ARRAY_SIZE - 1) + 2 + 2\n        expected_latency_largest_search = (ARRAY_SIZE - 1) * 2 + 2 + 2\n    elif (ARRAY_SIZE == 5 and DATA_WIDTH == 6):\n        keys =  arr = [1, 20, 0, 61, 5]\n        left_child = [2,4,15,15,15]\n        right_child = [1,3,15,15,15]\n        run = 0\n        expected_latency_smallest_delete = 5 \n        expected_latency_largest_delete = (ARRAY_SIZE - 1) + 3 + 2\n        expected_latency_smallest_search = 5 \n        expected_latency_largest_search = (ARRAY_SIZE - 1)*2 + 2 \n    elif (ARRAY_SIZE == 6 and DATA_WIDTH == 6):\n        keys = arr = [2, 20, 63, 61, 5, 1]\n        left_child = [5,4,15,15,15, 15]\n        right_child = [1,3,15,15,15, 15]\n        run = 0\n        invalid = 1\n        expected_latency_smallest_delete = 5 \n        expected_latency_largest_delete = (ARRAY_SIZE - 1) + 3 + 2\n        expected_latency_smallest_search = 5 \n        expected_latency_largest_search = (ARRAY_SIZE - 1)*2 + 2 \n\n    if (invalid != 1):\n\n        packed_keys = 0\n        for i, val in enumerate(arr):\n            packed_keys |= (val << (i * DATA_WIDTH))\n\n        dut.data_in.value = packed_keys\n        sort_after_operation = random.randint(0, 1)\n        key_random = random.randint(0, 2)\n        if key_random == 0:\n            operation_key = sorted(arr)[0]  # Smallest key\n            expected_latency = 4 + expected_latency_smallest_search + build_tree_latency + sort_after_operation * sort_latency\n            check_latency = 1\n            label = \"SEARCH (smallest key)\"\n        elif key_random == 1:\n            operation_key = sorted(arr)[ARRAY_SIZE-1]  # largest key\n            expected_latency =  4 + expected_latency_largest_search + build_tree_latency + sort_after_operation * sort_latency\n            check_latency = 1\n            label = \"SEARCH (largest key)\"\n        else:\n            index = random.randint(1, ARRAY_SIZE-2)\n            operation_key = sorted(arr)[index]  # random key\n            check_latency = 0\n            label = \"SEARCH (random key)\"\n\n        expected_position = hrs_lb.search_reference_model(operation_key, keys)\n\n        # === Test: Search ===\n        await run_operation(\n            dut,\n            operation_key=operation_key,\n            operation=0b0,  # Search\n            sort_after_operation=sort_after_operation,\n            label=label, \n            keys=keys, left_child=left_child, right_child=right_child, \n            check_latency=check_latency*run, expected_latency=expected_latency, \n            ARRAY_SIZE=ARRAY_SIZE, DATA_WIDTH=DATA_WIDTH,\n            key_position = expected_position, operation_invalid = 0  \n        )\n\n        sort_after_operation = random.randint(0, 1)\n        key_random = random.randint(0, 2)\n        if key_random == 0:\n            operation_key = sorted(arr)[0]  # Smallest key\n            expected_latency = expected_latency_smallest_delete + build_tree_latency + sort_after_operation * sort_latency + 4 * (sort_after_operation != 1)\n            check_latency = 1\n            label = \"DELETE (smallest key)\"\n        elif key_random == 1:\n            operation_key = sorted(arr)[ARRAY_SIZE-1]  # largest key\n            expected_latency = expected_latency_largest_delete + build_tree_latency + sort_after_operation * sort_latency + 4 * (sort_after_operation != 1)\n            check_latency = 1\n            label = \"DELETE (largest key)\"\n        else:\n            index = random.randint(1, ARRAY_SIZE-2)\n            operation_key = sorted(arr)[index]  # random key\n            check_latency = 0\n            label = \"DELETE (Random key)\"\n\n        key_bst, left_child_bst, right_child_bst = hrs_lb.delete_bst_key(keys, left_child, right_child, operation_key, DATA_WIDTH)\n\n        print('key', key_bst)\n        print('left_child', left_child_bst)\n        print('right_child', right_child_bst)\n\n        # === Test: Delete ===\n        await run_operation(\n            dut,\n            operation_key=operation_key,\n            operation=0b1,  # Delete\n            sort_after_operation=sort_after_operation,\n            label=label, \n            keys=key_bst, left_child=left_child_bst, right_child=right_child_bst, \n            check_latency=check_latency*run, expected_latency=expected_latency, ARRAY_SIZE=ARRAY_SIZE, DATA_WIDTH=DATA_WIDTH,\n            key_position = expected_position, operation_invalid = 0     \n        )\n    else:\n        left_child = []\n        right_child = []\n        keys = []\n        for i in range(ARRAY_SIZE):\n            left_child.append(2**(math.ceil(math.log2(ARRAY_SIZE)) + 1)-1)\n            right_child.append(2**(math.ceil(math.log2(ARRAY_SIZE)) + 1)-1)\n            keys.append(2**(DATA_WIDTH)-1)\n\n        expected_position = 2**(math.ceil(math.log2(ARRAY_SIZE)) + 1)-1\n        dut.start.value = 1\n        sort_after_operation = random.randint(0, 1)\n        operation_key = sorted(arr)[0]  # Smallest key\n        expected_latency = expected_latency_smallest_delete + build_tree_latency + sort_after_operation * sort_latency\n        check_latency = 1\n        label = \"DELETE (smallest key)\"\n        await run_operation(\n            dut,\n            operation_key=operation_key,\n            operation=0b1,  # Delete\n            sort_after_operation=sort_after_operation,\n            label=label, \n            keys=keys, left_child=left_child, right_child=right_child, \n            check_latency=1, expected_latency=2, ARRAY_SIZE=ARRAY_SIZE, DATA_WIDTH=DATA_WIDTH,\n            key_position = expected_position, operation_invalid = 1     \n        )\n    \n\nasync def reset_dut(dut, duration):\n    dut.reset.value = 1\n    for _ in range(duration):\n        await RisingEdge(dut.clk)\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\nasync def clock(dut, clk_period):\n        while True:\n            dut.clk.value = 0\n            await Timer(clk_period/2, units='ns')\n            dut.clk.value = 1\n            await Timer(clk_period/2, units='ns')\n\n\nasync def run_operation(dut, operation_key, operation, sort_after_operation, label, \n                        keys, left_child, right_child,  check_latency, expected_latency, ARRAY_SIZE, DATA_WIDTH,\n                        key_position, operation_invalid = 0 ):\n\n\n    dut.operation_key.value = operation_key\n    dut.operation.value = operation\n    dut.sort_after_operation.value = sort_after_operation\n\n    await RisingEdge(dut.clk)\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    cycle = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle += 1\n        if (dut.complete_operation.value == 1 or dut.operation_invalid.value == 1):\n            break\n\n    if (dut.operation_invalid.value == 1):\n        cocotb.log.warning(f\"[{label}] Operation invalid\")\n    else:\n        cocotb.log.info(f\"[{label}] Operation complete in {cycle} cycles\")\n        cocotb.log.info(f\"[{label}] out_keys: {dut.out_keys.value}\")\n        cocotb.log.info(f\"[{label}] out_sorted_data: {dut.out_sorted_data.value}\")\n\n\n    if (operation_invalid != 1):\n        if (sort_after_operation == 1):\n            out_data_val = int(dut.out_sorted_data.value)\n            print('output data', out_data_val)\n            output_array = [ (out_data_val >> (i * DATA_WIDTH)) & ((1 << DATA_WIDTH) - 1) for i in range(ARRAY_SIZE)]\n            expected_sorted_out = sorted(keys)\n            assert output_array == expected_sorted_out, f\"[Output incorrect. Got: {output_array}, Expected: {expected_sorted_out}]\"\n    \n    output_keys = [ (int(dut.out_keys.value) >> (i * DATA_WIDTH)) & ((1 << DATA_WIDTH) - 1) for i in range(ARRAY_SIZE)]\n    output_left_child = [ (int(dut.out_left_child.value) >> (i *  (math.ceil(math.log2(ARRAY_SIZE)) + 1) )) & ((1 <<  (math.ceil(math.log2(ARRAY_SIZE)) + 1)) - 1) for i in range(ARRAY_SIZE)]\n    output_right_child = [ (int(dut.out_right_child.value) >> (i *  (math.ceil(math.log2(ARRAY_SIZE)) + 1))) & ((1 <<  (math.ceil(math.log2(ARRAY_SIZE)) + 1)) - 1) for i in range(ARRAY_SIZE)]\n\n    assert ((keys == output_keys)), \\\n                f\"Failed: Key {output_keys} should be modified as {keys}.\"\n    assert ((left_child == output_left_child)), \\\n            f\"Failed: Key {output_left_child} should be modified as  {left_child}.\"\n    assert ((right_child == output_right_child)), \\\n            f\"Failed: Key {output_right_child} should be modified as {right_child}.\"\n    \n    assert (dut.operation_invalid.value == operation_invalid) , \"Failed: delete_invalid  set, but delete_key present\"\n    \n    if (operation == 0):\n         assert dut.key_position.value.integer == key_position, \\\n            f\"Failed: Smallest key {dut.search_key.value} should be at position {key_position}.\"\n\n    if (check_latency):\n        cocotb.log.debug(f\"Total Latency : {cycle}, expected : {expected_latency}\")\n        assert expected_latency == cycle, f\"Latency incorrect. Got: {cycle}, Expected: {expected_latency}\"\n", "src/test_runner.py": "import os\nimport random\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\n# Gather environment variables for simulation settings\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n# Define a runner function that takes the WIDTH parameter\ndef runner(DATA_WIDTH, ARRAY_SIZE):\n    # Get the simulator runner for the specified simulator (e.g., icarus)\n    runner = get_runner(sim)\n    \n    # Build the simulation environment with the randomized WIDTH parameter\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters={'DATA_WIDTH': DATA_WIDTH, 'ARRAY_SIZE' : ARRAY_SIZE},\n        always=True,               # Build even if files have not changed\n        clean=True,                # Clean previous builds\n        waves=True,\n        verbose=False,\n        timescale=(\"1ns\", \"1ns\"),  # Set timescale\n        log_file=\"sim.log\"         # Log the output of the simulation\n    )\n    \n    # Run the test module\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n# Parametrize test for different WIDTH and SIGNED_EN\n@pytest.mark.parametrize(\"DATA_WIDTH, ARRAY_SIZE\", [(6, 5), (6,6), (16,10), (6,15), (32,15)]) \n#@pytest.mark.parametrize(\"DATA_WIDTH, ARRAY_SIZE\", [(6, 5)]) \ndef test_bst(DATA_WIDTH, ARRAY_SIZE):\n    # Log the randomized WIDTH\n    print(f'Running with: DATA_WIDTH = {DATA_WIDTH}, ARRAY_SIZE = {ARRAY_SIZE}')\n\n    # Call the runner function with the randomized WIDTH\n    runner(DATA_WIDTH,ARRAY_SIZE)", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -vs'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_digital_stopwatch_0001", "categories": ["cid005", "easy"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Design a `digital stopwatch` module in SystemVerilog. Refer to the specification provided in `docs/digital_stopwatch_spec.md` to design the RTL. The specification details a parameterizable stopwatch that maintains seconds, minutes, and a single-bit hour indicator, along with a start/stop control. The design should be hierarchical, with dig_stopwatch_top as the top-level module and \ndig_stopwatch implementing the core stopwatch logic. It must include:\n\n- A clock divider that generates a 1 Hz pulse from a parameterized input clock (default 50 MHz).\n- Separate counters for seconds (0\u201359) and minutes (0\u201359).\n- A single-bit hour signal that is asserted upon rolling over 59 minutes.\n- Output signals to indicate pulses when second, minute, or hour counters change.\n- A beep mechanism that activates on each hour pulse and deactivates on the next second pulse.\n\nThe code should be well-documented with clear comments explaining the functionality of each major block. Follow best practices in SystemVerilog coding to ensure readability, reusability, and maintainability.\n", "context": {}, "patch": {"rtl/dig_stopwatch.sv": "", "rtl/dig_stopwatch_top.sv": "", "verif/dig_stopwatch_tb.sv": ""}, "harness": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v ", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/dig_stopwatch.sv /code/rtl/dig_stopwatch_top.sv\nTOPLEVEL        = dig_stopwatch_top\nMODULE          = test_dig_stopwatch\nPYTHONPATH      = /src\nHASH            = 2c6f45825f1b20574a6e9c9985c2767e293a10eb\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_dig_stopwatch.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\nimport harness_library as hrs_lb\n\ndef get_counter_max(dut):\n    # Calculate COUNTER_MAX based on the clock frequency (assumes one second = CLK_FREQ cycles)\n    clk_freq = int(dut.CLK_FREQ.value)\n    return clk_freq - 1\n\nasync def wait_for_seconds(dut, num_seconds):\n    \"\"\"Wait for a specified number of seconds by counting clock cycles.\"\"\"\n    counter_max = get_counter_max(dut)\n    for _ in range(num_seconds):\n        # Wait for one second: (counter_max + 1) clock cycles.\n        for _ in range(counter_max + 1):\n            await RisingEdge(dut.clk)\n        print(f\"Current Time - Hours: {int(dut.hour.value)}, Minutes: {int(dut.minutes.value)}, Seconds: {int(dut.seconds.value)}\")\n\nasync def check_rollover_conditions(dut, num_seconds):\n\n    counter_max = get_counter_max(dut)\n    for _ in range(num_seconds):\n        # Capture the current outputs before waiting\n        prev_sec   = int(dut.seconds.value)\n        prev_min   = int(dut.minutes.value)\n        prev_hour  = int(dut.hour.value)\n        prev_s_pulse = int(dut.second_pulse.value)\n        prev_m_pulse = int(dut.minute_pulse.value)\n        prev_h_pulse = int(dut.hour_pulse.value)\n\n        # Wait for one second (using clock cycles)\n        for _ in range(counter_max + 1):\n            await RisingEdge(dut.clk)\n        curr_sec  = int(dut.seconds.value)\n        curr_min  = int(dut.minutes.value)\n        curr_hour = int(dut.hour.value)\n        curr_s_pulse = int(dut.second_pulse.value)\n        curr_m_pulse = int(dut.minute_pulse.value)\n        curr_h_pulse = int(dut.hour_pulse.value)\n\n        print(f\"Rollover Current Time - Hour: {curr_hour}, Minutes: {curr_min}, Seconds: {curr_sec}\")\n\n        # Check if the stopwatch is saturated (max time reached: 1:00:00).\n        if prev_hour == 1 and prev_min == 0 and prev_sec == 0:\n            # In saturation, the counters remain unchanged.\n            assert curr_sec == prev_sec, f\"Error: Saturated seconds changed (expected {prev_sec}, got {curr_sec}).\"\n            assert curr_min == prev_min, f\"Error: Saturated minutes changed (expected {prev_min}, got {curr_min}).\"\n            assert curr_hour == prev_hour, f\"Error: Saturated hour changed (expected {prev_hour}, got {curr_hour}).\"\n        # Otherwise, if a rollover is expected:\n        elif prev_sec == 59:\n            # Seconds should reset to 0.\n            assert curr_sec == 0, f\"Error: Seconds did not reset to 0 after reaching 59 (prev_sec={prev_sec}, curr_sec={curr_sec}).\"\n            # Check the second_pulse was asserted.\n            assert curr_s_pulse == 1 or prev_s_pulse == 1, \"Error: second_pulse not asserted at seconds rollover.\"\n            # Now check the minutes.\n            if prev_min < 59:\n                expected_min = prev_min + 1\n                assert curr_min == expected_min, f\"Error: Minutes did not increment after seconds rollover (expected {expected_min}, got {curr_min}).\"\n                assert curr_m_pulse == 1 or prev_m_pulse == 1, \"Error: minute_pulse not asserted when minutes incremented.\"\n                # Hour remains the same.\n                assert curr_hour == prev_hour, f\"Error: Hour changed unexpectedly (expected {prev_hour}, got {curr_hour}).\"\n            else:\n                # When minutes are 59, rollover both seconds and minutes.\n                assert curr_min == 0, f\"Error: Minutes did not reset to 0 after reaching 59 (got {curr_min}).\"\n                # For hours, assume a 1-bit hour counter that saturates at 1.\n                expected_hour = 1  # or (prev_hour + 1) % 2 if wrapping is expected.\n                assert curr_hour == expected_hour, f\"Error: Hour did not increment correctly after minutes rollover (expected {expected_hour}, got {curr_hour}).\"\n                assert curr_h_pulse == 1 or prev_h_pulse == 1, \"Error: hour_pulse not asserted at hour rollover.\"\n                assert int(dut.beep.value) == 0, \"Error: Beep did not clear after the subsequent second pulse.\"\n        else:\n            # Otherwise, seconds should increment by one.\n            expected_sec = prev_sec + 1\n            # In case the increment would cause saturation, check if the design has already frozen.\n            if prev_hour == 1 and prev_min == 0 and prev_sec == 0:\n                # Already handled above.\n                pass\n            else:\n                assert curr_sec == expected_sec, f\"Error: Seconds did not increment as expected (expected {expected_sec}, got {curr_sec}).\"\n                # Pulse should be asserted for the second increment.\n                assert curr_s_pulse == 1 or prev_s_pulse == 1, \"Error: second_pulse not asserted when seconds incremented.\"\n\nasync def check_pause_and_resume(dut):\n    \"\"\"Test that the stopwatch pauses and resumes correctly.\"\"\"\n    dut.start_stop.value = 1\n    await wait_for_seconds(dut, 10)\n    \n    # Pause the stopwatch\n    dut.start_stop.value = 0\n    await RisingEdge(dut.clk)\n    \n    paused_seconds = int(dut.seconds.value)\n    # Let several clock cycles pass while paused.\n    for _ in range(20):\n        await RisingEdge(dut.clk)\n    \n    # Verify the stopwatch remains paused.\n    await RisingEdge(dut.clk)\n    assert int(dut.seconds.value) == paused_seconds, \"Error: Stopwatch did not pause correctly.\"\n\n    # Resume the stopwatch and check that it continues counting.\n    dut.start_stop.value = 1\n    await wait_for_seconds(dut, 20)\n    expected_sec = paused_seconds + 20\n    assert int(dut.seconds.value) == expected_sec, f\"Error: Stopwatch did not resume correctly (expected seconds {expected_sec}, got {int(dut.seconds.value)}).\"\n\nasync def pause_at_random_second(dut):\n    dut.start_stop.value = 1\n    tb_counter = 0  \n    clk_freq = int(dut.CLK_FREQ.value)\n    counter_max = clk_freq - 1 \n\n    # Generate a random number of clock cycles to count before pausing.\n    random_pause_duration = random.randint(1, counter_max - 1)\n\n    # Run until reaching the random_pause_duration.\n    for _ in range(random_pause_duration):\n        await RisingEdge(dut.clk)\n        tb_counter += 1\n\n    # Pause the stopwatch.\n    dut.start_stop.value = 0\n    await RisingEdge(dut.clk)\n    paused_seconds = int(dut.seconds.value)\n\n    # Ensure the stopwatch remains paused.\n    for _ in range(100):\n        await RisingEdge(dut.clk)\n        assert int(dut.seconds.value) == paused_seconds, \"Error: Stopwatch did not remain paused as expected.\"\n\n    # Resume the stopwatch and complete the remainder of the second.\n    await RisingEdge(dut.clk)\n    dut.start_stop.value = 1\n\n    remaining_ticks = counter_max - tb_counter  \n    for _ in range(remaining_ticks + 1):\n         await RisingEdge(dut.clk)\n\n    # Verify that the seconds counter has advanced.\n    await RisingEdge(dut.clk)\n    assert int(dut.seconds.value) == paused_seconds + 1, f\"Stopwatch did not resume correctly from paused second. Expected: {paused_seconds + 1}, Got: {int(dut.seconds.value)}\"\n\nasync def pause_at_random_minute(dut):\n    dut.start_stop.value = 1\n    await wait_for_seconds(dut, 50)\n\n    # Pause the stopwatch.\n    dut.start_stop.value = 0\n    await RisingEdge(dut.clk)\n    paused_minutes = int(dut.minutes.value)\n\n    # Ensure the stopwatch remains paused.\n    for _ in range(3600):\n        await RisingEdge(dut.clk)\n        assert int(dut.minutes.value) == paused_minutes, \"Error: Stopwatch did not remain paused as expected.\"\n\n    # Resume the stopwatch and wait for 10 seconds.\n    dut.start_stop.value = 1\n    await wait_for_seconds(dut, 10)\n\n    await RisingEdge(dut.clk)\n    expected_minutes = paused_minutes + 1 if paused_minutes < 59 else 0\n    assert int(dut.minutes.value) == expected_minutes, f\"Stopwatch did not resume correctly from paused minute. Expected: {expected_minutes}, Got: {int(dut.minutes.value)}\"\n\n@cocotb.test()\nasync def test_dig_stopwatch(dut):\n    clk_freq = int(dut.CLK_FREQ.value)\n    PERIOD = int(1_000_000_000 / clk_freq)  # Calculate clock period in ns.\n    cocotb.start_soon(Clock(dut.clk, PERIOD // 2, units='ns').start())\n    \n    await hrs_lb.dut_init(dut)\n    await hrs_lb.reset_dut(dut.reset, duration_ns=PERIOD, active=False)\n\n    # Verify initial time values.\n    assert int(dut.seconds.value) == 0, f\"Initial seconds is not 0! Got: {dut.seconds.value}\"\n    assert int(dut.minutes.value) == 0, f\"Initial minutes is not 0! Got: {dut.minutes.value}\"\n    assert int(dut.hour.value)   == 0, f\"Initial hours is not 0! Got: {dut.hour.value}\"\n\n    await RisingEdge(dut.clk)\n\n    # Start the stopwatch.\n    dut.start_stop.value = 1\n    await RisingEdge(dut.clk)\n\n    initial_seconds = int(dut.seconds.value)\n    await wait_for_seconds(dut, 10)\n    # Expect seconds to have advanced by 10.\n    assert int(dut.seconds.value) == initial_seconds + 10, f\"Seconds did not increment correctly. Current seconds: {dut.seconds.value}\"\n\n    # Stop the stopwatch.\n    dut.start_stop.value = 0\n    await RisingEdge(dut.clk)\n    stopped_seconds = int(dut.seconds.value)\n    await RisingEdge(dut.clk)\n    assert int(dut.seconds.value) == stopped_seconds, \"Stopwatch did not stop as expected.\"\n\n    # Restart the stopwatch.\n    dut.start_stop.value = 1\n    await RisingEdge(dut.clk)\n\n    await check_pause_and_resume(dut)\n    await check_rollover_conditions(dut, 3600)  # Testing rollovers for 1 hour.\n    \n    dut.start_stop.value = 0\n\n    # Reset and check that time values go back to zero.\n    dut.reset.value = 1\n    await RisingEdge(dut.clk)\n    assert int(dut.seconds.value) == 0, f\"Reset failed for seconds! Got: {dut.seconds.value}\"\n    assert int(dut.minutes.value) == 0, f\"Reset failed for minutes! Got: {dut.minutes.value}\"\n    assert int(dut.hour.value)   == 0, f\"Reset failed for hours! Got: {dut.hour.value}\"\n    await RisingEdge(dut.clk)\n\n    dut.reset.value = 0\n    await pause_at_random_second(dut)\n    await RisingEdge(dut.clk)\n\n    dut.reset.value = 1\n    await RisingEdge(dut.clk)\n    dut.reset.value = 0\n\n    await pause_at_random_minute(dut)\n    await RisingEdge(dut.clk)\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(CLK_FREQ: int = 200):\n    parameter = {\"CLK_FREQ\": CLK_FREQ}\n    print(f\"[DEBUG] Parameters: {parameter}\")     \n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n\n@pytest.mark.parametrize(\"test\", range(1))\n@pytest.mark.parametrize(\"CLK_FREQ\", [3,50,100,200])\ndef test_dig_stop(CLK_FREQ, test):\n    runner(CLK_FREQ=CLK_FREQ)\n    \n", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR=''\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_dynamic_equalizer_0008", "categories": ["cid005", "hard"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Edit files** by using:\n    - `sed -i 's/old_text/new_text/g' <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of:\n  - Thought (thinking process of the step you're going to take\n  - Action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - Observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format:\n  - Thought (the summary of what you did and some introduction of the patch file itself)\n  - Patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "There is a SystemVerilog `dynamic_equalizer` module in the `rtl/` directory. The module and its internal modules are designed for the MCMA (Multimodulus Constant Modulus Algorithm) algorithm. Refer to the specification files located in the `docs/` directory and integrate the `dynamic_equalizer` with two `awgn` modules, one for the real data and other for the imaginary data, inside of a top module `equalizer_top`. These files contain the definition of the dynamic equalizer\u2019s structure, the specifications of its internal modules, and a description of common algorithms used for error calculation. The top module `equalizer_top` should be defined in `rtl/equalizer_top.sv`, and the internal `awgn` should be in `rtl/awgn.sv`.\n", "context": {"docs/algorithms.md": "### **1. LMS (Least Mean Squares) Algorithm**\n\nThe **LMS algorithm** is a widely used adaptive filtering technique that adjusts filter coefficients to minimize the **mean squared error** between the filter's output and a desired signal.\n\n#### How it works:\n- At each iteration, the filter output is calculated as the dot product of the input vector and filter coefficients.\n- The **error** is computed as:\n  \\[\n  e(n) = d(n) - y(n)\n  \\]\n  where `d(n)` is the desired signal and `y(n)` is the filter output.\n- The filter coefficients are updated as:\n  \\[\n  w(n+1) = w(n) + \\mu \\cdot e(n) \\cdot x(n)\n  \\]\n  where:\n  - `w(n)` is the coefficient vector\n  - `x(n)` is the input vector\n  - `\u03bc` is the step size (learning rate)\n\nLMS is **simple, stable, and converges slowly** depending on `\u03bc`.\n\n---\n\n### **2. CMA (Constant Modulus Algorithm)**\n\n**CMA** is a **blind equalization** algorithm \u2014 it does **not require a training signal**. It assumes that the transmitted signal has a **constant modulus** (magnitude), such as in QPSK or PSK systems.\n\n#### How it works:\n- The algorithm minimizes the cost function:\n  \\[\n  J(n) = \\left(|y(n)|^2 - R\\right)^2\n  \\]\n  where `R` is a constant related to the signal\u2019s expected modulus.\n- The error used to update the coefficients is:\n  \\[\n  e(n) = y(n) \\cdot \\left(|y(n)|^2 - R\\right)\n  \\]\n- The weights are updated as:\n  \\[\n  w(n+1) = w(n) - \\mu \\cdot e(n) \\cdot x^*(n)\n  \\]\n\nCMA is useful for **equalizing signals blindly**, but can suffer from **phase ambiguity**.\n\n---\n\n### **3. MCMA (Multimodulus CMA)**\n\n**MCMA** is an extension of CMA tailored for **higher-order QAM constellations** (e.g., 16-QAM), where symbols do **not all have the same modulus**.\n\n#### How it works:\n- It separately controls the **real** and **imaginary** parts:\n  \\[\n  e_{\\text{real}} = y_{\\text{real}} \\cdot (|y_{\\text{real}}|^2 - R_{\\text{real}})\n  \\]\n  \\[\n  e_{\\text{imag}} = y_{\\text{imag}} \\cdot (|y_{\\text{imag}}|^2 - R_{\\text{imag}})\n  \\]\n- The total error is combined, and the weights are updated:\n  \\[\n  w(n+1) = w(n) - \\mu \\cdot (e_{\\text{real}} + j \\cdot e_{\\text{imag}}) \\cdot x^*(n)\n  \\]\n\nMCMA improves convergence and performance on **non-constant modulus signals**, such as QAM.\n\n---\n\n### **4. RDE (Radius Directed Equalizer)**\n\n**RDE** is another blind equalization method, similar to CMA, but instead of pushing all symbols to a constant modulus, it tries to force them onto a **circle with radius `R`** \u2014 typically better suited for circular constellations.\n\n#### How it works:\n- It minimizes:\n  \\[\n  J(n) = \\left(|y(n)| - R\\right)^2\n  \\]\n- The gradient (error) is:\n  \\[\n  e(n) = \\left(1 - \\frac{R}{|y(n)|}\\right) \\cdot y(n)\n  \\]\n- Update rule:\n  \\[\n  w(n+1) = w(n) - \\mu \\cdot e(n) \\cdot x^*(n)\n  \\]\n\nRDE provides better convergence in some cases and can be more robust for **radial symmetry constellations**.", "docs/awgn_spec.md": "# AWGN Specification\n\n## Overview\nThe `awgn` module selects Additive White Gaussian Noise (AWGN) values to simulate the effect of random noise on a signal \u2014 specifically, noise that follows a Gaussian (normal) distribution and has constant power across all frequencies (white noise).\n\nThe noise values are stored in a lookup table (LUT), then the selected AWGN value is multiplied by a scale factor, truncated, and added to the original input signal.\n\n## Interface\n\n### Signals Table\n| Signal        | In/Out | Width | Description                          |\n|---------------|--------|-------|--------------------------------------|\n| noise_index   | Input  | 4     | Index for pseudo-random noise        |\n| signal_in     | Input  | 16    | Input signal (Q2.13)                 |\n| noise_scale   | Input  | 16    | Noise gain scaling factor (Q2.13)    |\n| signal_out    | Output | 16    | Output signal (Q2.13)                |\n\n### Parameters Table\n| Parameter   | Value | Description                   |\n|-------------|-------|-------------------------------|\n| DATA_WIDTH  | 16    | Bit width of the data         |\n| LUT_SIZE    | 16    | Size of LUT with AWGN data    |", "docs/coeff_update_spec.md": "# Coefficients Update Specification\n\n## Overview\nThe `coeff_update` module computes the next coefficients of the filter based on the selected algorithm, using the corresponding update rule described in the `algorithms.md` file. The central tap of the real coefficients must be initialized to 1 in fixed-point notation, while all other coefficients must be initialized to 0.\n\nSince division is very costly in hardware, the value of the learning rate parameter is used to apply bitwise shifts to the signal, effectively dividing it by two for each shift.\n\n## Interface\n\n### Signals Table\n| Signal        | In/Out | Width | Parallelism | Description                                |\n|---------------|--------|-------|-------------|--------------------------------------------|\n| clk           | Input  | 1     | 1           | System clock                               |\n| rst_n         | Input  | 1     | 1           | Asynchronous active-low reset              |\n| valid_sample  | Input  | 1     | 1           | Enable processing when is a valid sample   |\n| data_real     | Input  | 16    | 7           | Real part of the input signals             |\n| data_imag     | Input  | 16    | 7           | Imaginary part of the input signals        |\n| error_real    | Input  | 16    | 1           | Real part of the error signal              |\n| error_imag    | Input  | 16    | 1           | Imaginary part of the error signal         |\n| coeff_real    | Output | 16    | 7           | Real part of the coefficients signals      |\n| coeff_imag    | Output | 16    | 7           | Imaginary part of the coefficients signals |\n\n### Parameters Table\n| Parameter   | Value | Description                   |\n|-------------|-------|-------------------------------|\n| TAP_NUM     | 7     | Number of taps of the filters |\n| DATA_WIDTH  | 16    | Bit width of the data         |\n| COEFF_WIDTH | 16    | Bit width of the coefficients |\n| MU          | 15    | Learning rate                 |", "docs/equalizer_spec.md": "# Dynamic Equalizer Specification\n\n## Overview\nA dynamic equalizer is designed to adaptively compensate for channel impairments such as inter-symbol interference (ISI) and signal distortion in real-time digital communication systems. It employs adaptive filtering techniques, such as Least Mean Squares (LMS) and Constant Modulus Algorithm(CMA), to continuously adjust its internal tap coefficients based on the error between the received signal and a reference signal. This allows the equalizer to dynamically \"learn\" and correct channel effects without prior knowledge of the distortion profile. The architecture typically includes a shift register for sample history, multipliers for tap-weighted inputs, an accumulator for the filter output, and logic for error calculation and coefficient updates. Over time, the equalizer converges such that its output closely matches the desired signal, improving signal fidelity and reducing bit error rates in high-speed data links.\n\nThe equation used to calculate the output of the dynamic equalizer for complex baseband signals is as follows:\n\n\\[\n\\hat{y}[n] = \\sum_{k=0}^{L-1} w_k[n] \\cdot x[n-k]\n\\]\n\n- \\( \\hat{y}[n] \\) = Equalizer output at time \\( n \\)  \n- \\( w_k[n] \\) = Complex-valued filter tap coefficient at time \\( n \\)  \n- \\( x[n-k] \\) = Complex input sample (includes I and Q)\n\nThe equalizer includes a 2-samples-per-symbol (2 SPS) to 1-sample-per-symbol (1 SPS) conversion feature. It processes one sample and ignores the next, effectively reducing the sampling rate by half.\n\nThe equalizer has two internal modules: `error_calc`, which computes the error based on the selected algorithm, and `coeff_update`, which calculates the filter coefficients to be used in the next cycle.\n\nThe `desired_real` and `desired_imag` signals are only used when the LMS algorithm is selected, as the other algorithms do not require the desired signal data as input.\n\n## Interface\n\n### Signals Table\n| Signal        | In/Out | Width | Description                          |\n|---------------|--------|-------|--------------------------------------|\n| clk           | Input  | 1     | System clock                         |\n| rst_n         | Input  | 1     | Asynchronous active-low reset        |\n| data_in_real  | Input  | 16    | Real part of the input signal        |\n| data_in_imag  | Input  | 16    | Imaginary part of the input signal   |\n| data_out_real | Output | 16    | Real part of the output signal       |\n| data_out_imag | Output | 16    | Imaginary part of the output signal  |\n\n### Parameters Table\n| Parameter   | Value | Description                   |\n|-------------|-------|-------------------------------|\n| TAP_NUM     | 7     | Number of taps of the filters |\n| DATA_WIDTH  | 16    | Bit width of the data         |\n| COEFF_WIDTH | 16    | Bit width of the coefficients |\n| MU          | 15    | Learning rate                 |", "docs/equalizer_top_spec.md": "# Equalizer Top Specification\n\n## Overview\nThe `equalizer_top` module instantiates the `awgn` blocks to add noise to the input data signals and connects the resulting noisy signals to the `dynamic_equalizer` module.\n\n## Interface\n\n### Signals Table\n| Signal        | In/Out | Width | Description                          |\n|---------------|--------|-------|--------------------------------------|\n| clk           | Input  | 1     | System clock                         |\n| rst_n         | Input  | 1     | Asynchronous active-low reset        |\n| noise_index   | Input  | 4     | Index for pseudo-random noise        |\n| noise_scale   | Input  | 16    | Noise gain scaling factor (Q2.13)    |\n| data_in_real  | Input  | 16    | Real part of the input signal        |\n| data_in_imag  | Input  | 16    | Imaginary part of the input signal   |\n| data_out_real | Output | 16    | Real part of the output signal       |\n| data_out_imag | Output | 16    | Imaginary part of the output signal  |\n\n### Parameters Table\n| Parameter   | Value | Description                   |\n|-------------|-------|-------------------------------|\n| TAP_NUM     | 7     | Number of taps of the filters |\n| DATA_WIDTH  | 16    | Bit width of the data         |\n| COEFF_WIDTH | 16    | Bit width of the coefficients |\n| MU          | 15    | Learning rate                 |\n| LUT_SIZE    | 16    | Size of LUT with AWGN data    |", "docs/error_calc_spec.md": "# Error Calculation Specification\n\n## Overview\nThe `error_calc` module computes the error based on the selected algorithm, using the corresponding equation described in the `algorithms.md` file.\n\nThe `desired_real` and `desired_imag` signals are only used when the LMS algorithm is selected, as the other algorithms do not require the desired signal data as input. For the other algorithms, since they are intended for QPSK, the reference signal R is set to 1.\n\n## Interface\n\n### Signals Table\n| Signal        | In/Out | Width | Description                          |\n|---------------|--------|-------|--------------------------------------|\n| data_real     | Input  | 16    | Real part of the input signal        |\n| data_imag     | Input  | 16    | Imaginary part of the input signal   |\n| error_real    | Output | 16    | Real part of the error signal        |\n| error_imag    | Output | 16    | Imaginary part of the error signal   |\n\n### Parameters Table\n| Parameter   | Value | Description                   |\n|-------------|-------|-------------------------------|\n| DATA_WIDTH  | 16    | Bit width of the data         |", "rtl/coeff_update.sv": "module coeff_update #(\n    parameter TAP_NUM     = 7,\n    parameter DATA_WIDTH  = 16,\n    parameter COEFF_WIDTH = 16,\n    parameter MU          = 15  // Learning rate = 2^(-15)\n)(\n    input  logic                          clk,\n    input  logic                          rst_n,\n    input  logic signed [DATA_WIDTH-1:0]  data_real [TAP_NUM-1:0],\n    input  logic signed [DATA_WIDTH-1:0]  data_imag [TAP_NUM-1:0],\n    input  logic signed [DATA_WIDTH-1:0]  error_real,\n    input  logic signed [DATA_WIDTH-1:0]  error_imag,\n    output logic signed [COEFF_WIDTH-1:0] coeff_real [TAP_NUM-1:0],\n    output logic signed [COEFF_WIDTH-1:0] coeff_imag [TAP_NUM-1:0]\n);\n    // Internal signals\n    logic signed [DATA_WIDTH+COEFF_WIDTH:0] coeff_real_aux [TAP_NUM-1:0];\n    logic signed [DATA_WIDTH+COEFF_WIDTH:0] coeff_imag_aux [TAP_NUM-1:0];\n    logic signed [DATA_WIDTH+COEFF_WIDTH:0] coeff_real_rnd [TAP_NUM-1:0];\n    logic signed [DATA_WIDTH+COEFF_WIDTH:0] coeff_imag_rnd [TAP_NUM-1:0];\n    logic signed [COEFF_WIDTH-1:0] coeff_real_acc [TAP_NUM-1:0];\n    logic signed [COEFF_WIDTH-1:0] coeff_imag_acc [TAP_NUM-1:0];\n    // Update of LMS coefficients\n    always_comb begin\n        for (int i = 0; i < TAP_NUM; ++i) begin\n            coeff_real_aux[i] = (error_real * data_real[i] + error_imag * data_imag[i]);\n            coeff_real_rnd[i] = coeff_real_aux[i] <<< 4;\n            coeff_real_acc[i] = coeff_real_rnd[i][DATA_WIDTH+COEFF_WIDTH -: DATA_WIDTH] >>> MU;\n            coeff_imag_aux[i] = (error_imag * data_real[i] - error_real * data_imag[i]);\n            coeff_imag_rnd[i] = coeff_imag_aux[i] <<< 4;\n            coeff_imag_acc[i] = coeff_imag_rnd[i][DATA_WIDTH+COEFF_WIDTH -: DATA_WIDTH] >>> MU;\n        end\n    end\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            for (int i = 0; i < TAP_NUM; i++) begin\n                if ((i == (TAP_NUM-1)/2)) begin\n                    coeff_real[i] <= 16'h2000; // Initialize central tap to 1 in signed Q2.13\n                    coeff_imag[i] <= 16'h0000;\n                end else begin\n                    coeff_real[i] <= '0;\n                    coeff_imag[i] <= '0;\n                end\n            end\n        end else begin\n            for (int i = 0; i < TAP_NUM; i++) begin\n                coeff_real[i] <= coeff_real[i] - coeff_real_acc[i];\n                coeff_imag[i] <= coeff_imag[i] - coeff_imag_acc[i];\n            end\n        end\n    end\nendmodule", "rtl/dynamic_equalizer.sv": "module dynamic_equalizer #(\n    parameter TAP_NUM     = 7,\n    parameter DATA_WIDTH  = 16,\n    parameter COEFF_WIDTH = 16,\n    parameter MU          = 15  // Learning rate = 2^(-15)\n)(\n    input  logic                         clk,\n    input  logic                         rst_n,\n    input  logic signed [DATA_WIDTH-1:0] data_in_real,\n    input  logic signed [DATA_WIDTH-1:0] data_in_imag,\n    output logic signed [DATA_WIDTH-1:0] data_out_real,\n    output logic signed [DATA_WIDTH-1:0] data_out_imag\n);\n\n    // Input storage (shift register)\n    logic signed [DATA_WIDTH-1:0] shift_real [TAP_NUM-1:0];\n    logic signed [DATA_WIDTH-1:0] shift_imag [TAP_NUM-1:0];\n\n    // Coefficients signals\n    logic signed [COEFF_WIDTH-1:0] coeff_real [TAP_NUM-1:0];\n    logic signed [COEFF_WIDTH-1:0] coeff_imag [TAP_NUM-1:0];\n\n    // Sa\u00edda tempor\u00e1ria\n    logic signed [DATA_WIDTH+COEFF_WIDTH:0] acc_real_rnd;\n    logic signed [DATA_WIDTH+COEFF_WIDTH:0] acc_imag_rnd;\n    logic signed [DATA_WIDTH+COEFF_WIDTH:0] acc_real;\n    logic signed [DATA_WIDTH+COEFF_WIDTH:0] acc_imag;\n\n    // Error\n    logic signed [DATA_WIDTH-1:0] error_real;\n    logic signed [DATA_WIDTH-1:0] error_imag;\n \n    // Shift register\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            for (int i = 0; i < TAP_NUM; i++) begin\n                shift_real[i] <= '0;\n                shift_imag[i] <= '0;\n            end\n        end else begin\n            for (int i = TAP_NUM-1; i > 0; i--) begin\n                shift_real[i] <= shift_real[i-1];\n                shift_imag[i] <= shift_imag[i-1];\n            end\n            shift_real[0] <= data_in_real;\n            shift_imag[0] <= data_in_imag;\n        end\n    end\n\n    // Complex sum FIR\n    always_comb begin\n        acc_real = 0;\n        acc_imag = 0;\n        for (int i = 0; i < TAP_NUM; i++) begin\n            acc_real += (shift_real[i] * coeff_real[i]) - (shift_imag[i] * coeff_imag[i]);\n            acc_imag += (shift_real[i] * coeff_imag[i]) + (shift_imag[i] * coeff_real[i]);\n        end\n    end\n\n    // Round the result\n    assign acc_real_rnd = acc_real <<< 4;\n    assign acc_imag_rnd = acc_imag <<< 4;\n\n    assign data_out_real = acc_real_rnd[DATA_WIDTH+COEFF_WIDTH -: DATA_WIDTH];\n    assign data_out_imag = acc_imag_rnd[DATA_WIDTH+COEFF_WIDTH -: DATA_WIDTH];\n\n    // Error calculation\n    error_calc #(\n        .DATA_WIDTH (DATA_WIDTH)\n    ) uu_error_calc (\n        .data_real    (data_out_real),\n        .data_imag    (data_out_imag),\n        .error_real   (error_real   ),\n        .error_imag   (error_imag   )\n    );\n\n    // Update of coefficients\n    coeff_update #(\n        .TAP_NUM     (TAP_NUM    ),\n        .DATA_WIDTH  (DATA_WIDTH ),\n        .COEFF_WIDTH (COEFF_WIDTH),\n        .MU          (MU         )\n    ) uu_coeff_update (\n        .clk        (clk       ),\n        .rst_n      (rst_n     ),\n        .data_real  (shift_real),\n        .data_imag  (shift_imag),\n        .error_real (error_real),\n        .error_imag (error_imag),\n        .coeff_real (coeff_real),\n        .coeff_imag (coeff_imag)\n    );\nendmodule", "rtl/error_calc.sv": "module error_calc #(\n    parameter DATA_WIDTH = 16\n)(\n    input  logic signed [DATA_WIDTH-1:0] data_real,\n    input  logic signed [DATA_WIDTH-1:0] data_imag,\n    input  logic signed [DATA_WIDTH-1:0] desired_real,\n    input  logic signed [DATA_WIDTH-1:0] desired_imag,\n    output logic signed [DATA_WIDTH-1:0] error_real,\n    output logic signed [DATA_WIDTH-1:0] error_imag\n);\n    // Local parameters\n    localparam DATA_SQ    = DATA_WIDTH * 2;\n    localparam DATA_RAD   = DATA_SQ + 1;\n    localparam ERROR_FULL = DATA_WIDTH + DATA_RAD;\n\n    // Internal signals\n    logic signed [DATA_SQ-1:0] data_real_sq;\n    logic signed [DATA_SQ-1:0] data_imag_sq;\n\n    logic signed [DATA_RAD-1:0] data_real_rad;\n    logic signed [DATA_RAD-1:0] data_imag_rad;\n\n    logic signed [ERROR_FULL-1:0] error_real_full;\n    logic signed [ERROR_FULL-1:0] error_imag_full;\n\n    logic signed [ERROR_FULL-1:0] error_real_rnd;\n    logic signed [ERROR_FULL-1:0] error_imag_rnd;\n\n    // Error calculation using MCMA (Multimodulus Constant Modulus Algorithm) algorithm\n    always_comb begin\n        data_real_sq    = data_real * data_real;\n        data_real_rad   = data_real_sq - 32'h04000000;\n        error_real_full = data_real_rad * data_real;\n        error_real_rnd  = error_real_full <<< 6;\n\n        data_imag_sq    = data_imag * data_imag;\n        data_imag_rad   = data_imag_sq - 32'h04000000;\n        error_imag_full = data_imag_rad * data_imag;\n        error_imag_rnd  = error_imag_full <<< 6;\n\n        error_real = error_real_rnd[(ERROR_FULL - 1) -: DATA_WIDTH];\n        error_imag = error_imag_rnd[(ERROR_FULL - 1) -: DATA_WIDTH];\n    end\n\nendmodule"}, "patch": {"rtl/awgn.sv": "", "rtl/equalizer_top.sv": ""}, "harness": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/equalizer_top.sv /code/rtl/awgn.sv /code/rtl/dynamic_equalizer.sv /code/rtl/error_calc.sv /code/rtl/coeff_update.sv\nTOPLEVEL        = equalizer_top\nMODULE          = test_equalizer_top_harness\nPYTHONPATH      = /src\nHASH            = 8-cid005---rtl-component-integration", "src/test_equalizer_top_harness.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nfrom cocotb.clock import Clock\nimport logging\nimport random\n\nDATA_WIDTH = 16\nFRAC_BITS = 13\nSHIFT_LUT = 4\n\n# Copy of RTL LUT in decimal\nNOISE_LUT = [\n    2048,  -1024,   128,  -3072,\n    1024,  -2048,  3072,   -128,\n       0,    512,  -512,    256,\n    -256,    768,  -768,      0\n]\n\ndef fixed_point_mult(a, b, shift=FRAC_BITS):\n    \"\"\"Multiplies two Q2.13 values \u200b\u200band returns Q2.13 with adjustment\"\"\"\n    return (a * b) >> shift\n\ndef fixed_point_shift(val, left_shift):\n    \"\"\"Apply a left shift to simulate << in SV\"\"\"\n    return val << left_shift\n\ndef check_condition(condition, fail_msg, pass_msg, test_failures):\n    \"\"\"Helper function to log test results\"\"\"\n    if not condition:\n        logging.getLogger().error(fail_msg)\n        test_failures.append(fail_msg)\n    else:\n        logging.getLogger().info(pass_msg)\n\n@cocotb.test()\nasync def test_awgn_real_component(dut):\n    \"\"\"Check that AWGN adds the correct noise to data_in_real\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Check that AWGN adds the correct noise to data_in_real\")\n\n    # Start clock\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Reset\n    dut.rst_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    dut.rst_n.value = 1\n\n    dut.rst_n.value = 0\n    dut.data_in_real.value = 0\n    dut.data_in_imag.value = 0\n    dut.noise_index.value = 0\n    dut.noise_scale.value = 2048  # 0.25 in Q2.13\n\n    # Initialize list to collect failures\n    test_failures = []\n\n    for _ in range(20):\n        await RisingEdge(dut.clk)\n\n        # Stimulus\n        signal_in = random.choice([8192, -8192])  # \u00b11.0 in Q2.13\n        noise_idx = random.randint(0, 15)\n        noise_val = NOISE_LUT[noise_idx]\n\n        # Apply signals\n        dut.data_in_real.value = signal_in\n        dut.data_in_imag.value = signal_in\n        dut.noise_index.value = noise_idx\n\n        await Timer(1, units=\"ns\")  # Wait logic update\n\n        # Expected noise calculation\n        noise_scaled = int(noise_val * 0.25)\n        noise_scaled_q213 = noise_scaled\n        expected = (signal_in + noise_scaled_q213)\n\n        # Reading the result\n        out_real = dut.uu_awgn_real.signal_out.value.signed_integer\n\n        # Check Data Output Imaginary\n        check_condition(\n            out_real == expected,\n            f\"FAIL: Data Output mismatch. Expected: {expected}, \"\n            f\"Got: {out_real}\",\n            f\"PASS: Data Output value: {out_real}\",\n            test_failures\n        )\n\n    # Report failures if any\n    if test_failures:\n        failure_message = \"\\n\".join(test_failures)\n        logger.error(f\"Test AWGN real component completed with failures:\\n{failure_message}\")\n        assert False, f\"Some test cases failed. Check the log for details:\\n{failure_message}\"\n    else:\n        logger.info(\"Test AWGN real component completed successfully\")\n\n@cocotb.test()\nasync def test_awgn_imag_component(dut):\n    \"\"\"Check that AWGN adds the correct noise to data_in_imag\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Check that AWGN adds the correct noise to data_in_imag\")\n\n    # Start clock\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Reset\n    dut.rst_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    dut.rst_n.value = 1\n\n    dut.rst_n.value = 0\n    dut.data_in_real.value = 0\n    dut.data_in_imag.value = 0\n    dut.noise_index.value = 0\n    dut.noise_scale.value = 2048  # 0.25 in Q2.13\n\n    # Initialize list to collect failures\n    test_failures = []\n\n    for _ in range(20):\n        await RisingEdge(dut.clk)\n\n        # Stimulus\n        signal_in = random.choice([8192, -8192])  # \u00b11.0 in Q2.13\n        noise_idx = random.randint(0, 15)\n        noise_val = NOISE_LUT[noise_idx]\n\n        # Apply signals\n        dut.data_in_real.value = signal_in\n        dut.data_in_imag.value = signal_in\n        dut.noise_index.value = noise_idx\n\n        await Timer(1, units=\"ns\")  # Wait logic update\n\n        # Expected noise calculation\n        noise_scaled = int(noise_val * 0.25)\n        noise_scaled_q213 = noise_scaled\n        expected = (signal_in + noise_scaled_q213)\n\n        # Reading the result\n        out_imag = dut.uu_awgn_imag.signal_out.value.signed_integer\n\n        # Check Data Output Imaginary\n        check_condition(\n            out_imag == expected,\n            f\"FAIL: Data Output mismatch. Expected: {expected}, \"\n            f\"Got: {out_imag}\",\n            f\"PASS: Data Output value: {out_imag}\",\n            test_failures\n        )\n\n    # Report failures if any\n    if test_failures:\n        failure_message = \"\\n\".join(test_failures)\n        logger.error(f\"Test AWGN imaginary component completed with failures:\\n{failure_message}\")\n        assert False, f\"Some test cases failed. Check the log for details:\\n{failure_message}\"\n    else:\n        logger.info(\"Test AWGN imaginary component completed successfully\")\n\n@cocotb.test()\nasync def test_equalizer_learns_identity(dut):\n    \"\"\"Test if output equals input after 3 cycles when input == desired\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Test if output equals input after 3 cycles when input == desired\")\n\n    # Start clock\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Reset\n    dut.rst_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    dut.rst_n.value = 1\n\n    # History buffer\n    in_history_real = []\n    in_history_imag = []\n\n    for i in range(20):\n        # AWGN config\n        dut.noise_index.value = 8\n        dut.noise_scale.value = 0\n\n        # Random input: 8192 or -8192\n        value_real = random.choice([8192, -8192])\n        value_imag = random.choice([8192, -8192])\n        \n        # Apply to input\n        dut.data_in_real.value = value_real\n        dut.data_in_imag.value = value_imag\n\n        # Store input for comparison later\n        in_history_real.append(value_real)\n        in_history_imag.append(value_imag)\n        \n        # Initialize list to collect failures\n        test_failures = []\n\n        # After 3 cycles, expect output = input (since input == desired)\n        if i >= 5:\n            expected_real = in_history_real[i - 5]\n            expected_imag = in_history_imag[i - 5]\n            out_real = dut.data_out_real.value.signed_integer\n            out_imag = dut.data_out_imag.value.signed_integer\n\n            # Check Data Output Real\n            check_condition(\n                out_real == expected_real,\n                f\"FAIL: Data Output Real mismatch. Expected: {expected_real}, \"\n                f\"Got: {out_real}\",\n                f\"PASS: Data Output Real value: {out_real}\",\n                test_failures\n            )\n\n            # Check Data Output Imaginary\n            check_condition(\n                out_imag == expected_imag,\n                f\"FAIL: Data Output Imaginary mismatch. Expected: {expected_imag}, \"\n                f\"Got: {out_imag}\",\n                f\"PASS: Data Output Imaginary value: {out_imag}\",\n                test_failures\n            )\n            \n        await RisingEdge(dut.clk)\n\n    # Report failures if any\n    if test_failures:\n        failure_message = \"\\n\".join(test_failures)\n        logger.error(f\"Test identity completed with failures:\\n{failure_message}\")\n        assert False, f\"Some test cases failed. Check the log for details:\\n{failure_message}\"\n    else:\n        logger.info(\"Test identity completed successfully\")\n\n@cocotb.test()\nasync def test_equalizer_data_quadrant(dut):\n    \"\"\"Test if output data quadrant is the desired\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Test if output data quadrant is the desired\")\n\n    # Start clock\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Reset\n    dut.rst_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    dut.rst_n.value = 1\n\n    # History buffer\n    in_history_real = []\n    in_history_imag = []\n\n    for i in range(20):\n        # AWGN config\n        dut.noise_index.value = random.randint(0, 15)\n        dut.noise_scale.value = 2048 # Equivalent to 0.25 in Q2.13\n\n        # Random input with error\n        value_real = random.choice([8390, 8192, 7800, -8390, -8192, -7800])\n        value_imag = random.choice([8390, 8192, 7800, -8390, -8192, -7800])\n        \n        # Apply to input\n        dut.data_in_real.value = value_real\n        dut.data_in_imag.value = value_imag\n\n        # Store input for comparison later\n        in_history_real.append(value_real)\n        in_history_imag.append(value_imag)\n        \n        # Initialize list to collect failures\n        test_failures = []\n\n        # After 3 cycles, expect output = input (since input == desired)\n        if i >= 5:\n            expected_real = in_history_real[i - 5]\n            expected_imag = in_history_imag[i - 5]\n            out_real = dut.data_out_real.value.signed_integer\n            out_imag = dut.data_out_imag.value.signed_integer\n\n            # Check Data Output Real\n            check_condition(\n                (out_real > 0) == (expected_real > 0),\n                f\"FAIL: Data Output Real Quadrant mismatch. Expected: {(expected_real > 0)}, \"\n                f\"Got: {(out_real > 0)}\",\n                f\"PASS: Data Output Real Quadrant value: {(out_real > 0)}\",\n                test_failures\n            )\n\n            # Check Data Output Imaginary\n            check_condition(\n                (out_imag > 0) == (expected_imag > 0),\n                f\"FAIL: Data Output Imaginary Quadrant mismatch. Expected: {(expected_imag > 0)}, \"\n                f\"Got: {(out_imag > 0)}\",\n                f\"PASS: Data Output Imaginary Quadrant value: {(out_imag > 0)}\",\n                test_failures\n            )\n            \n        await RisingEdge(dut.clk)\n\n    # Report failures if any\n    if test_failures:\n        failure_message = \"\\n\".join(test_failures)\n        logger.error(f\"Test quadrant completed with failures:\\n{failure_message}\")\n        assert False, f\"Some test cases failed. Check the log for details:\\n{failure_message}\"\n    else:\n        logger.info(\"Test quadrant completed successfully\")\n", "src/test_runner.py": "# test_runner.py\n\nimport os\nfrom cocotb.runner import get_runner\nimport pytest\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Fetch environment variables\nverilog_sources = os.getenv(\"VERILOG_SOURCES\", \"\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\", \"verilog\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\ndef runner(TAP_NUM, DATA_WIDTH, COEFF_WIDTH, MU, LUT_SIZE):\n    # Initialize the simulator runner\n    runner = get_runner(sim)\n\n    # Build the simulation with the specified TAP_NUM, DATA_WIDTH, COEFF_WIDTH, and MU parameters\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters={\n            \"TAP_NUM\": TAP_NUM,\n            \"DATA_WIDTH\": DATA_WIDTH,\n            \"COEFF_WIDTH\": COEFF_WIDTH,\n            \"MU\": MU,\n            \"LUT_SIZE\": LUT_SIZE},\n        # Simulator Arguments\n        always=True,\n        clean=True,\n        waves=True,        # Disable waveform generation for faster runs\n        verbose=True,      # Set to True for detailed simulator logs\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=f\"sim_{toplevel}.log\"\n    )\n\n    # Run the simulation\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n    logger.info(f\"Completed simulation with TAP_NUM, DATA_WIDTH, COEFF_WIDTH, MU, and LUT_SIZE = {TAP_NUM, DATA_WIDTH, COEFF_WIDTH, MU, LUT_SIZE}\")\n\n@pytest.mark.parametrize(\"TAP_NUM, DATA_WIDTH, COEFF_WIDTH, MU, LUT_SIZE\", [(7, 16, 16, 15, 16)])\ndef test_cvdp_agentic_dynamic_equalizer(TAP_NUM, DATA_WIDTH, COEFF_WIDTH, MU, LUT_SIZE):\n    try:\n        runner(TAP_NUM, DATA_WIDTH, COEFF_WIDTH, MU, LUT_SIZE)\n    except Exception as e:\n        logger.error(f\"Simulation failed for TAP_NUM, DATA_WIDTH, COEFF_WIDTH, MU, LUT_SIZE = {TAP_NUM, DATA_WIDTH, COEFF_WIDTH, MU, LUT_SIZE}: {e}\")\n        # Using assert False to report failure without halting other tests\n        assert False, f\"Simulation failed for TAP_NUM, DATA_WIDTH, COEFF_WIDTH, MU, LUT_SIZE = {TAP_NUM, DATA_WIDTH, COEFF_WIDTH, MU, LUT_SIZE}: {e}\"", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_event_storing_0001", "categories": ["cid005", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"line_number s/old_statement/new_statement/\" file.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)", "prompt": "The `event_storage` module in rtl directory synchronously stores events from the input `i_event` in a register bank. Each `i_event` input has an equivalent register. If the interface signal `i_en_overflow` is asserted, the register bank may wrap around when it reaches its maximum value, and an event occurs. If not asserted, the data stored in the register bank must be saturated.\n\nThe signals `i_bypass`, `i_data`, `i_raddr` are used to set the `o_data` signal such as:\n- If `i_bypass == 1`, then `o_data = i_data`.\n- If `i_bypass == 0`, then `o_data = reg_bank[i_raddr]`.\n\n**Modify** the module `event_storage` so that it is fully parameterizable. The parameters for this block are:\n\n- `NBW_STR`: Defines the bit width of the input and output data, as well as the bit width of each register in the register bank.\n- `NS_EVT`: Defines the number of parallel events stored by the module.\n- `NBW_EVT`: Defines the bit width of the read address used to select one of the event counters in `reg_bank`.\n\n----------\n\nThe `event_array` module implements a **2D pipeline of event processors** (called `event_storage` units), structured as a grid of **NS_ROWS \u00d7 NS_COLS**. Each processor operates on a stream of input data and associated events, performing updates and passing data to the next row in the same column. **All of the top module connections are fully combinational**. A testbench for it is provided.\n\n**Create** an `event_array` module in the rtl directory, and make sure it is fully parameterizable.\n\n### Specifications\n\n- **Module Name**: `event_array`\n\n- **Parameters**:\n    - `NS_ROWS`: Number of rows in the 2D processing array.\n        - Default value: 4.\n        - Related interface signals: `i_en_overflow`, `i_event`, `i_bypass`.\n    - `NS_COLS`: Number of columns in the 2D processing array.\n        - Default value: 4. Must always be $`2^{NBW\\_COL}`$\n        - Related interface signals: `i_en_overflow`, `i_event`, `i_data`, `i_col_sel`.\n    - `NBW_COL`: Bit width of the column selection signal.\n        - Default value: 2.\n        - Related interface signals: `i_col_sel`.\n    - `NBW_STR`: Bit width of the data processed in each `event_storage`.\n        - Default value: 8.\n        - Related interface signals: `i_data`, `o_data`.\n    - `NS_EVT`: Number of event bits handled by each `event_storage`.\n        - Default value: 8. Must always be $`2^{NBW\\_EVT}`$\n        - Related interface signals: `i_event`.\n    - `NBW_EVT`: Bit width of the read address used for event selection inside each `event_storage`.\n        - Default value: 3.\n        - Related interface signals: `i_raddr`.\n\n### Interface Signals\n\n- **Clock** (`clk`): Synchronizes operation at the rising edge.\n- **Reset** (`rst_async_n`): Active-low asynchronous reset. Resets the internal storage elements.\n- **Column Select** (`[NBW_COL-1:0] i_col_sel`): Selects which column\u2019s output from the last row will be assigned to `o_data`.\n- **Overflow Enable** (`[NS_ROWS*NS_COLS-1:0] i_en_overflow`): One-bit flag per `event_storage`. When high, enables overflow in `event_storage`'s internal registers.\n- **Event Input** (`[(NS_ROWS*NS_COLS*NS_EVT)-1:0] i_event`): All events (flattened) to be applied across the array. Each `event_storage` receives `NS_EVT` bits.\n- **Input Data** (`[(NS_COLS*NBW_STR)-1:0] i_data`): Parallel input data for the **first row only**, one value per column.\n- **Bypass Control** (`[NS_ROWS-1:0] i_bypass`): One bit per row. When high, it bypasses the event logic in that row's `event_storage`.\n- **Read Address** (`[NBW_EVT-1:0] i_raddr`): Address input used to read specific event-mapped data from each `event_storage`.\n- **Output Data** (`[NBW_STR-1:0] o_data`): Output from the selected column in the **last row**.\n\n### Functional Description\n\nThe `event_array` module is structured as a **2D pipeline** of `event_storage` units. Each unit represents a processing cell that performs bit-based updates to its internal data register according to the received `i_event` bits and the `i_en_overflow` flag.\n\nThe array is organized as `NS_ROWS` rows and `NS_COLS` columns.\n\n#### Input Flow:\n- Input data (`i_data`) is injected only into the **first row** of the array.\n- Each subsequent row receives the processed output from the `event_storage` directly above it in the same column.\n- All `event_storage` receive a unique slice of the flattened `i_event` and `i_en_overflow` arrays:\n   - In `event_array`, the `i_event` input is a flat vector that holds all event bits for every cell in the grid, with each `event_storage` requiring `NS_EVT` bits. The module slices this vector by assigning `NS_EVT` bits to each `event_storage` based on its row and column. The slicing starts from the most significant bit and moves left to right across columns, then top to bottom across rows \u2014 like reading a table row by row. This way, each cell gets exactly the bits intended for its position in the array.\n      - For example, if `NS_ROWS = 2`, `NS_COLS = 2`, and `NS_EVT = 4`, then `i_event` is 16 bits wide. The cell at row 0, column 0 gets the top 4 bits `[15:12]`, row 0, column 1 gets `[11:8]`, row 1, column 0 gets `[7:4]`, and row 1, column 1 gets the lowest 4 bits `[3:0]`.\n\n   - The `i_en_overflow` input is a flat bit vector with one bit per `event_storage` in the grid. The vector is sliced using a row-major order: starting from the least significant bit, it maps left to right across columns, then top to bottom across rows.\n      - For example, if `NS_ROWS = 2` and `NS_COLS = 2`, then `i_en_overflow` is 4 bits wide. The cell at row 0, column 0 gets bit `[0]`, row 0, column 1 gets bit `[1]`, row 1, column 0 gets bit `[2]`, and row 1, column 1 gets bit `[3]`.\n\n\n#### Output Logic:\n- After data has propagated through all rows, each column's final output is collected:\n   - A `data_col_sel` signal is constructed by collecting the output data from each column in the last row of the array. For each column, the module takes the `data_out` of the `event_storage` cell at row `NS_ROWS - 1` and column `col`. These outputs are concatenated from **left to right** in **increasing column index order**, meaning **column 0 goes into the most significant bits**, and **column `NS_COLS - 1` goes into the least significant bits**. This signal is then connected to the input of the `column_selector` module.\n      - For example, if `NS_COLS = 4` and `NBW_STR = 8`, then `data_col_sel` is 32 bits wide. The output from column 0 goes into bits `[31:24]`, column 1 into `[23:16]`, column 2 into `[15:8]`, and column 3 into `[7:0]`.\n\n- The `column_selector` submodule then selects one column based on `i_col_sel` to produce the module's final output `o_data`.\n\n", "context": {"rtl/column_selector.sv": "module column_selector #(\n    parameter NBW_STR = 'd8,\n    parameter NBW_COL = 'd2,\n    parameter NS_COLS = 'd4\n) (\n    input  logic [NBW_COL-1:0]           i_col_sel,\n    input  logic [(NBW_STR*NS_COLS)-1:0] i_data,\n    output logic [NBW_STR-1:0]           o_data\n);\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_STR-1:0] data [0:NS_COLS-1];\n\n// ----------------------------------------\n// - Unpack input data\n// ----------------------------------------\ngenerate\n    for(genvar i = 0; i < NS_COLS; i++) begin : unpack_data\n        assign data[i] = i_data[(NBW_STR*NS_COLS)-i*NBW_STR-1-:NBW_STR];\n    end\nendgenerate\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nalways_comb begin : output_assignment\n    o_data = data[i_col_sel];\nend\n\nendmodule : column_selector", "rtl/event_storage.sv": "module event_storage #(\n    parameter NBW_STR = 'd4,\n    parameter NS_EVT  = 'd4,\n    parameter NBW_EVT = 'd2\n) (\n    input  logic       clk,\n    input  logic       rst_async_n,\n    input  logic       i_en_overflow,\n    input  logic [3:0] i_event,\n    input  logic [3:0] i_data,\n    input  logic       i_bypass,\n    input  logic [1:0] i_raddr,\n    output logic [3:0] o_data\n);\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [3:0] reg_bank [0:3];\n\n// ----------------------------------------\n// - Block logic\n// ----------------------------------------\ngenerate\n    for (genvar i = 0; i < 4; i++) begin : instantiate_regs\n        always_ff @ (posedge clk or negedge rst_async_n) begin\n            if(!rst_async_n) begin\n                reg_bank[i] <= 0;\n            end else begin\n                if(i_en_overflow) begin\n                    reg_bank[i] <= reg_bank[i] + i_event[i];\n                end else begin\n                    if(reg_bank[i] == 4'd15) begin\n                        reg_bank[i] <= reg_bank[i];\n                    end else begin\n                        reg_bank[i] <= reg_bank[i] + i_event[i];\n                    end\n                end\n            end\n        end\n    end\nendgenerate\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nalways_comb begin : output_assignment\n    if(i_bypass) begin\n        o_data = i_data;\n    end else begin\n        o_data = reg_bank[i_raddr];\n    end\nend\n\nendmodule : event_storage", "verif/tb.sv": "module tb;\n\nlocalparam NS_ROWS = 'd4;\nlocalparam NS_COLS = 'd4;\nlocalparam NBW_COL = 'd2;\nlocalparam NBW_STR = 'd8;\nlocalparam NS_EVT  = 'd8;\nlocalparam NBW_EVT = 'd3;\n\nlogic                                clk;\nlogic                                rst_async_n;\nlogic [NBW_COL-1:0]                  i_col_sel;\nlogic [NS_ROWS*NS_COLS-1:0]          i_en_overflow;\nlogic [(NS_ROWS*NS_COLS*NS_EVT)-1:0] i_event;\nlogic [(NS_ROWS*NBW_STR)-1:0]        i_data;\nlogic [NS_ROWS-1:0]                  i_bypass;\nlogic [NBW_EVT-1:0]                  i_raddr;\nlogic [NBW_STR-1:0]                  o_data;\n\nevent_array #(\n    .NS_ROWS(NS_ROWS),\n    .NS_COLS(NS_COLS),\n    .NBW_COL(NBW_COL),\n    .NBW_STR(NBW_STR),\n    .NS_EVT(NS_EVT),\n    .NBW_EVT(NBW_EVT)\n) uu_event_array (\n    .clk          (clk          ),\n    .rst_async_n  (rst_async_n  ),\n    .i_col_sel    (i_col_sel    ),\n    .i_en_overflow(i_en_overflow),\n    .i_event      (i_event      ),\n    .i_data       (i_data       ),\n    .i_bypass     (i_bypass     ),\n    .i_raddr      (i_raddr      ),\n    .o_data       (o_data       )\n);\n\ninitial begin\n    $dumpfile(\"test.vcd\");\n    $dumpvars(0,tb);\nend\n\ntask SimpleTest(int line_to_read, int col_to_read, int r_addr);\n    $display(\"---------------\");\n    $display(\"Running test reading row %2d, column %2d, address %2d\", line_to_read, col_to_read, r_addr);\n    @(negedge clk);\n    i_en_overflow = 0;\n    i_bypass = {NS_ROWS{1'b1}};\n    i_bypass[line_to_read] = 1'b0;\n    i_raddr = r_addr;\n    i_col_sel = col_to_read;\n    i_event = 0;\n\n    for(int i = 1; i <= NS_ROWS*NS_COLS*NS_EVT; i++) begin\n        for(int j = 0; j < i; j++) begin\n            i_event[NS_ROWS*NS_COLS*NS_EVT-i] = 1'b1;\n            @(negedge clk);\n        end\n        i_event = 0;\n    end\n\n    @(negedge clk);\n\n    if((NS_EVT - r_addr + line_to_read*NS_COLS*NS_EVT + col_to_read*NS_EVT) > 2**NBW_STR - 1) begin\n        if(o_data != 2**NBW_STR - 1) begin\n            $display(\"FAIL! Received o_data = %2d, when it should have been %2d\", o_data, 2**NBW_STR - 1);\n        end else begin\n            $display(\"PASS! Received o_data = %2d\", o_data);\n        end\n    end else begin\n        if(o_data != (NS_EVT - r_addr + line_to_read*NS_COLS*NS_EVT + col_to_read*NS_EVT)) begin\n            $display(\"FAIL! Received o_data = %d, when it should have been %2d\", o_data, (NS_EVT - r_addr + line_to_read*NS_COLS*NS_EVT + col_to_read*NS_EVT));\n        end else begin\n            $display(\"PASS! Received o_data = %d\", o_data);\n        end\n    end\nendtask\n\ntask Reset();\n    i_col_sel     = 0;\n    i_en_overflow = 0;\n    i_event       = 0;\n    i_data        = 0;\n    i_bypass      = 0;\n    i_raddr       = 0;\n    rst_async_n = 1;\n    #1;\n    rst_async_n = 0;\n    #2;\n    rst_async_n = 1;\n    @(negedge clk);\nendtask\n\ntask TestOverflow(logic overflow);\n    $display(\"---------------\");\n    $display(\"Testing overflow in row 0, column 0, address 0\");\n    @(negedge clk);\n    i_en_overflow = overflow;\n    i_bypass = {NS_ROWS{1'b1}};\n    i_bypass[0] = 1'b0;\n    i_raddr = 0;\n    i_col_sel = 0;\n    i_event = 0;\n\n    for(int i = 0; i <= 2**NBW_STR; i++) begin\n        i_event[NS_ROWS*NS_COLS*NS_EVT-NS_EVT] = 1'b1;\n        @(negedge clk);\n    end\n    i_event = 0;\n\n    @(negedge clk);\n\n    if(overflow == 0) begin\n        if(o_data != 2**NBW_STR - 1) begin\n            $display(\"FAIL! Received o_data = %2d, when it should have been %2d\", o_data, 2**NBW_STR - 1);\n        end else begin\n            $display(\"PASS! Received o_data = %2d\", o_data);\n        end\n    end else begin\n        if(o_data != 1) begin\n            $display(\"FAIL! Received o_data = %2d, when it should have been %2d\", o_data, 1);\n        end else begin\n            $display(\"PASS! Received o_data = %2d\", o_data);\n        end\n    end\nendtask\n\nalways #5 clk = ~clk;\n\nint value;\n\ninitial begin\n    clk = 0;\n    value = 1;\n    Reset();\n\n    $display(\"----------------------\");\n    $display(\"This testbench writes:\");\n    for(int row = 0; row < NS_ROWS; row++) begin\n        for(int col = 0; col < NS_COLS; col++) begin\n            for(int addr = NS_EVT-1; addr >= 0; addr--) begin\n                $display(\"%2d in row %2d, col %2d, address %2d\", value, row, col, addr);\n                value++;\n            end\n        end\n    end\n\n    $display(\"----------------------\");\n    $display(\"Note that, if any of those values are bigger than %2d, it will saturate when i_en_overflow = 0, and wrap around when i_en_overflow = 1.\", 2**NBW_STR - 1);\n    $display(\"----------------------\");\n\n    // Tasks go here\n    SimpleTest(0, 0, 0);\n    Reset();\n    SimpleTest(1, 0, 0);\n    Reset();\n    SimpleTest(0, 1, 0);\n    Reset();\n    SimpleTest(0, 0, 1);\n    Reset();\n    SimpleTest(2, 1, 0);\n    Reset();\n    SimpleTest(1, 2, 2);\n    Reset();\n    SimpleTest(1, 2, 7);\n    Reset();\n    TestOverflow(1'b0);\n    Reset();\n    TestOverflow(1'b1);\n    Reset();\n\n    @(negedge clk);\n    @(negedge clk);\n\n    $finish();\nend\n\nendmodule"}, "patch": {"rtl/event_array.sv": "", "rtl/event_storage.sv": ""}, "harness": {"docker-compose.yml": "services:\n  sanity:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest /src/test_runner_event_array.py -s -v -o cache_dir=/rundir/harness/.cache\n\n  storage_sanity:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src:/src/      \n    working_dir : /code/rundir\n    env_file    : ./src/.env_event_storage\n    command     : pytest /src/test_runner_event_storage.py -s -v -o cache_dir=/rundir/harness/.cache\n", "src/.env": "VERILOG_SOURCES = /code/rtl/event_array.sv /code/rtl/column_selector.sv /code/rtl/event_storage.sv \nTOPLEVEL        = event_array\nMODULE          = test_event_array\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 1-modify-event-storage-and-create-event-array\nWAVE            = true", "src/.env_event_storage": "VERILOG_SOURCES = /code/rtl/event_storage.sv\nTOPLEVEL        = event_storage\nMODULE          = test_event_storage\nSIM             = icarus\nTOPLEVEL_LANG   = verilog\nPYTHONPATH      = /src\nHASH            = 1-modify-event-storage-and-create-event-array\nWAVE            = true", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom collections import deque\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nclass EventArray:\n    def __init__(self, NS_ROWS=4, NS_COLS=4, NBW_STR=8, NS_EVT=8):\n        self.NS_ROWS = NS_ROWS\n        self.NS_COLS = NS_COLS\n        self.NBW_STR = NBW_STR\n        self.NS_EVT  = NS_EVT\n        self.reset()\n\n    def reset(self):\n        self.reg_bank = [[[0 for _ in range(self.NS_EVT)]\n                          for _ in range(self.NS_COLS)]\n                         for _ in range(self.NS_ROWS)]\n        self.o_data = 0\n\n    def event_update(self, i_event, i_en_overflow):\n        total_bits = self.NS_ROWS * self.NS_COLS * self.NS_EVT\n        bin_event = bin(i_event)[2:].zfill(total_bits)  # MSB-first\n\n        MAX_VAL = (1 << self.NBW_STR) - 1\n\n        byte_index = 0\n        for row in range(self.NS_ROWS):\n            for col in range(self.NS_COLS):\n                # Calculate flat index for this (row, col)\n                flat_index = row * self.NS_COLS + col\n                overflow_en = (i_en_overflow >> (flat_index)) & 1\n\n                for evt in range(self.NS_EVT):\n                    bit_index = byte_index * self.NS_EVT + evt\n                    if bin_event[bit_index] == '1':\n                        current_val = self.reg_bank[row][col][self.NS_EVT - 1 - evt]\n                        if overflow_en:\n                            self.reg_bank[row][col][self.NS_EVT - 1 - evt] = (current_val + 1) & MAX_VAL\n                        else:\n                            if current_val < MAX_VAL:\n                                self.reg_bank[row][col][self.NS_EVT - 1 - evt] += 1\n                byte_index += 1\n\n\n    def read_data(self, bypass, r_addr, col_sel, i_data):\n        # Convert i_data to array of NBW_STR slices (MSB to LSB)\n        array_i_data = []\n        mask = (1 << self.NBW_STR) - 1\n        for i in range(self.NS_COLS):\n            shift = self.NBW_STR * (self.NS_COLS - 1 - i)\n            array_i_data.append((i_data >> shift) & mask)\n\n        selected_row = None\n\n        # Priority decoder tree: walk MSB \u2192 LSB, match original behavior\n        for row in range(self.NS_ROWS):\n            bit = (bypass >> (self.NS_ROWS - 1 - row)) & 1\n            if bit == 0:\n                selected_row = self.NS_ROWS - 1 - row\n                break\n\n        # All bypass bits = 1 \u2192 use i_data\n        if selected_row is None:\n            out_row = array_i_data\n        else:\n            out_row = [self.reg_bank[selected_row][i][r_addr] for i in range(self.NS_COLS)]\n\n        self.o_data = out_row[col_sel]\n", "src/test_event_array.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_data.value.integer\n\n    model_data = model.o_data\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\ndef row_to_bypass(row, ns_rows):\n    if row < 0 or row >= ns_rows:\n        raise ValueError(\"Invalid row index\")\n\n    # Full set of 1s: (1 << ns_rows) - 1\n    # Clear the bit at (ns_rows - row - 1)\n    return ((1 << ns_rows) - 1) ^ (1 << (ns_rows - row - 1))\n\n@cocotb.test()\nasync def test_event_array(dut):\n    \"\"\"Test the event_array module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Retrieve parameters from the DUT\n    NS_ROWS = dut.NS_ROWS.value.integer\n    NS_COLS = dut.NS_COLS.value.integer\n    NBW_STR = dut.NBW_STR.value.integer\n    NS_EVT  = dut.NS_EVT.value.integer\n\n    model = hrs_lb.EventArray(NS_ROWS, NS_COLS, NBW_STR, NS_EVT)\n\n    resets = 4\n    runs = 2**(NBW_STR+1) # Run it 2 times the 2**NBW_STR so it's very likely that there will be an overflow and no overflow\n\n    event_min = 0\n    event_max = 2**(NS_ROWS*NS_COLS*NS_EVT) - 1\n\n    data_min = 0\n    data_max = 2**(NS_COLS*NBW_STR) - 1\n\n    overflow_min = 0\n    overflow_max = 2**(NS_ROWS*NS_COLS) - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        dut._log.info(f\"Starting {i+1} test...\")\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_col_sel.value     = 0\n        dut.i_en_overflow.value = 0\n        dut.i_event.value       = 0\n        dut.i_data.value        = 0\n        dut.i_bypass.value      = 0\n        dut.i_raddr.value       = 0\n        dut.rst_async_n.value   = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        en_overflow = random.randint(overflow_min, overflow_max)\n        for j in range(runs):\n            event = random.randint(event_min, event_max)\n\n            dut.i_en_overflow.value = en_overflow\n            dut.i_event.value       = event\n            model.event_update(event, en_overflow)\n\n            await RisingEdge(dut.clk)\n        \n        dut.i_event.value = 0\n        # Compare all values\n        # First compare the full bypass\n        data = random.randint(data_min, data_max)\n        dut._log.info(f\"Loop for columns bypass...\")\n        for col in range(NS_COLS):\n            for addr in range(NS_EVT):\n                bypass = (1 << NS_ROWS) - 1\n                model.read_data(bypass, addr, col, data)\n                dut.i_col_sel.value     = col\n                dut.i_data.value        = data\n                dut.i_bypass.value      = bypass\n                dut.i_raddr.value       = addr\n                await RisingEdge(dut.clk)\n                compare_values(dut, model)\n\n        dut._log.info(f\"Loop for columns complete...\")\n        for col in range(NS_COLS):\n            for row in range(NS_ROWS):\n                for addr in range(NS_EVT):\n                    bypass = row_to_bypass(row, NS_ROWS)\n                    model.read_data(bypass, addr, col, data)\n                    dut.i_col_sel.value     = col\n                    dut.i_data.value        = data\n                    dut.i_bypass.value      = bypass\n                    dut.i_raddr.value       = addr\n                    await RisingEdge(dut.clk)\n                    compare_values(dut, model)\n", "src/test_event_storage.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_data.value.integer\n\n    model_data = model.o_data\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_data  = {hex(dut_data)} \\nMODEL o_data  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_data does not match model o_data: {hex(dut_data)} != {hex(model_data)}\"\n\ndef row_to_bypass(row, ns_rows):\n    if row < 0 or row >= ns_rows:\n        raise ValueError(\"Invalid row index\")\n\n    # Full set of 1s: (1 << ns_rows) - 1\n    # Clear the bit at (ns_rows - row - 1)\n    return ((1 << ns_rows) - 1) ^ (1 << (ns_rows - row - 1))\n\n@cocotb.test()\nasync def test_event_storage(dut):\n    \"\"\"Test the event_storage module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Retrieve parameters from the DUT\n    NS_ROWS = 1\n    NS_COLS = 1\n    NBW_STR = dut.NBW_STR.value.integer\n    NS_EVT  = dut.NS_EVT.value.integer\n\n    model = hrs_lb.EventArray(NS_ROWS, NS_COLS, NBW_STR, NS_EVT)\n\n    resets = 4\n    runs = 2**(NBW_STR+1) # Run it 2 times the 2**NBW_STR so it's very likely that there will be an overflow and no overflow\n\n    event_min = 0\n    event_max = 2**(NS_ROWS*NS_COLS*NS_EVT) - 1\n\n    data_min = 0\n    data_max = 2**(NS_COLS*NBW_STR) - 1\n\n    overflow_min = 0\n    overflow_max = 2**(NS_ROWS*NS_COLS) - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        dut.i_en_overflow.value = 0\n        dut.i_event.value       = 0\n        dut.i_data.value        = 0\n        dut.i_bypass.value      = 0\n        dut.i_raddr.value       = 0\n        dut.rst_async_n.value   = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n\n        en_overflow = random.randint(overflow_min, overflow_max)\n        for j in range(runs):\n            event = random.randint(event_min, event_max)\n\n            dut.i_en_overflow.value = en_overflow\n            dut.i_event.value       = event\n            model.event_update(event, en_overflow)\n\n            await RisingEdge(dut.clk)\n        \n        dut.i_event.value = 0\n        # Compare all values\n        # First compare the full bypass\n        data = random.randint(data_min, data_max)\n        for col in range(NS_COLS):\n            for addr in range(NS_EVT):\n                bypass = (1 << NS_ROWS) - 1\n                model.read_data(bypass, addr, col, data)\n                dut.i_data.value        = data\n                dut.i_bypass.value      = bypass\n                dut.i_raddr.value       = addr\n                await RisingEdge(dut.clk)\n                compare_values(dut, model)\n\n        for col in range(NS_COLS):\n            for row in range(NS_ROWS):\n                for addr in range(NS_EVT):\n                    bypass = row_to_bypass(row, NS_ROWS)\n                    model.read_data(bypass, addr, col, data)\n                    dut.i_data.value        = data\n                    dut.i_bypass.value      = bypass\n                    dut.i_raddr.value       = addr\n                    await RisingEdge(dut.clk)\n                    compare_values(dut, model)\n", "src/test_runner_event_array.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(NS_ROWS: int = 4, NS_COLS: int = 4, NBW_COL: int = 2, NBW_STR: int = 8, NS_EVT: int = 8, NBW_EVT: int = 3):\n\n    parameter = {\n        \"NS_ROWS\": NS_ROWS,\n        \"NS_COLS\": NS_COLS,\n        \"NBW_COL\": NBW_COL,\n        \"NBW_STR\": NBW_STR,\n        \"NS_EVT\": NS_EVT,\n        \"NBW_EVT\": NBW_EVT\n    }\n\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Generate minimum and more random sizes\nrandom_nbw_rows = [2] + [random.randint(3, 4)]\nrandom_nbw_cols = [2] + [random.randint(3, 4)]\nrandom_nbw_str  = [4] + [random.randint(5, 6)]\nrandom_nbw_evt  = [2] + [random.randint(3, 4)]\n\n@pytest.mark.parametrize(\"NBW_ROWS\", random_nbw_rows)\n@pytest.mark.parametrize(\"NBW_COLS\", random_nbw_cols)\n@pytest.mark.parametrize(\"NBW_STR\", random_nbw_str)\n@pytest.mark.parametrize(\"NBW_EVT\", random_nbw_evt)\ndef test_data(NBW_ROWS, NBW_COLS, NBW_STR, NBW_EVT):\n    NS_COLS = 2**NBW_COLS\n    NS_ROWS = 2**NBW_ROWS\n    NS_EVT  = 2**NBW_EVT\n    # Run the simulation with specified parameters\n    runner(NS_ROWS=NS_ROWS, NS_COLS=NS_COLS, NBW_COL=NBW_COLS, NBW_STR=NBW_STR, NS_EVT=NS_EVT, NBW_EVT=NBW_EVT)\n", "src/test_runner_event_storage.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(NBW_STR: int = 8, NS_EVT: int = 8, NBW_EVT: int = 3):\n\n    parameter = {\n        \"NBW_STR\": NBW_STR,\n        \"NS_EVT\": NS_EVT,\n        \"NBW_EVT\": NBW_EVT\n    }\n\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Generate minimum and more random sizes\nrandom_nbw_str  = [4] + [random.randint(5, 8) for _ in range(1)]\nrandom_nbw_evt  = [2] + [random.randint(3, 5) for _ in range(1)]\n\n@pytest.mark.parametrize(\"NBW_STR\", random_nbw_str)\n@pytest.mark.parametrize(\"NBW_EVT\", random_nbw_evt)\ndef test_data(NBW_STR, NBW_EVT):\n    NS_EVT  = 2**NBW_EVT\n    # Run the simulation with specified parameters\n    runner(NBW_STR=NBW_STR, NS_EVT=NS_EVT, NBW_EVT=NBW_EVT)", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest /src/test_runner_event_array.py -s -v -o cache_dir=/rundir/harness/.cache'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_gcd_0007", "categories": ["cid005", "hard"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Design a cryptographic accelerator that performs RSA-like encryption operations, details of which are given in the specification provided in the `docs` folder.\nThe required RTL files are present in the `rtl` folder, and their corresponding specifications are in the `docs` directory. Choose the appropriate RTL modules based on the descriptions given in the RTL specification documents, and create the System Verilog RTL module `crypto_accelerator` and add it to the `rtl` directory.\nUse the existing module that calculates the GCD using Stein's algorithm (as described in the specification) to perform the check for coprimes. If the public exponent (e) and totient \u03c6(n) are coprimes, then perform the encryption using the module that performs modular exponentiation of the inputs.\n\nThe existing modular_exponentiation provides incorrect output. Resolve the RTL issues in the module and update it.\n\nBelow is the port list of the `crypto_accelerator` module that you have to generate:\n```verilog\nmodule crypto_accelerator #(\n    parameter WIDTH = 8\n)(\n    input                     clk,\n    input                     rst,\n    input      [WIDTH-1:0]    candidate_e,     // Candidate public exponent.\n    input      [WIDTH-1:0]    totient,             // Euler's totient \u03c6(n).\n    input                     start_key_check,\n    output logic              key_valid,\n    output logic              done_key_check,\n    input      [WIDTH-1:0]    plaintext,\n    input      [WIDTH-1:0]    modulus,\n    output logic [WIDTH-1:0]  ciphertext,\n    output logic              done_encryption\n);\n```\n", "context": {"docs/GCD_specification.md": "# RTL Specification for GCD Calculation using Stein's Algorithm\n\nThis document describes the high-level RTL architecture for a GCD calculator based on Stein's algorithm. The design is separated into three main modules: a top-level module that interconnects the datapath and control path, a control path module for sequencing, and a datapath module for arithmetic and data manipulation.\n\n- **Stein's Algorithm (Binary GCD):**\n    Stein\u2019s algorithm or binary GCD algorithm is an algorithm that computes the greatest common divisor of two non-negative integers. Stein\u2019s algorithm replaces division with arithmetic shifts, comparisons, and subtraction. Following is the algorithm to find GCD using Stein\u2019s algorithm gcd(a, b):\n    - Base case:\n        - If both a and b are 0, gcd is zero gcd(0, 0) = 0.\n        - gcd(a, 0) = a and gcd(0, b) = b because everything divides 0.\n\n    - Step 1: Remove Common Factors of 2:\n        - If a and b are both even, gcd(a, b) = 2*gcd(a/2, b/2) because 2 is a common divisor. Multiplication with 2 can be done with a bitwise shift operator.\n\n    - Step 2: Handling Even and Odd Cases:\n        - If a is even and b is odd, gcd(a, b) = gcd(a/2, b). Similarly, if a is odd and b is even, then gcd(a, b) = gcd(a, b/2). It is because 2 is not a common divisor.\n\n    - Step 3: Handling Odd Numbers:\n        - If both a and b are odd, then gcd(a, b) = gcd(|a-b|/2, b). Note that the difference between two odd numbers is even\n\n    - Step 4:Final GCD:\n        - Repeat steps 1\u20133 until a = b, or until a = 0.\n        - In either case, the GCD is  2<sup>k</sup> *b, where k is the number of factors of 2 removed in Step 1.\n\t\t\n---\n\n## 1. Top-Level Module: `gcd_top_1`\n\n### Overview\nThe top-level module orchestrates the GCD calculation by instantiating both the control path and datapath modules. The parameterizable `WIDTH` defines the bit width of the input operands and output.\n\n### Ports\n- **Inputs:**\n  - `clk`: Clock signal. Design is synced to the posedge of clk.\n  - `rst`: Reset signal. Active high.\n  - `A [WIDTH-1:0]`: First operand.\n  - `B [WIDTH-1:0]`: Second operand.\n  - `go`: Start signal for beginning the computation. Active high.\n- **Outputs:**\n  - `OUT [WIDTH-1:0]`: Output containing the computed GCD.\n  - `done`: Indicates the completion of the GCD calculation. Active high.\n\n### Internal Signals\n- **`equal`**: A signal computed in the datapath; indicates whether the current values of the operands are equal.\n- **`controlpath_state [1:0]`**: Encodes the state of the control path.  \n- **`done`**: Generated by the control path when the calculation is finished.\n\n### Instance Connections\n- **Control Path Instance (`gcd_controlpath_3`):**  \n  - Receives `clk`, `rst`, `go`, and the `equal` signal.\n  - Outputs the current state (`controlpath_state`) and the `done` flag.\n  \n- **Datapath Instance (`gcd_datapath_6`):**  \n  - Receives `clk`, `rst`, inputs `A` and `B`, and the current control state (`controlpath_state`).\n  - Computes and outputs the `equal` flag and the GCD result (`OUT`).\n\n---\n\n## 2. Control Path Module: `gcd_controlpath_3`\n\n### Purpose\nThis module generates control signals based on an internal state machine, dictating when to load new values, continue processing, or finish the computation.\n\n### Ports\n- **Inputs:**\n  - `clk`: Clock signal. Design is synced to the posedge of clk.\n  - `rst`: Reset signal. Active high.\n  - `go`: Start signal. Active high.\n  - `equal`: Signal from the datapath indicating if both operands are equal. Active high.\n- **Outputs:**\n  - `controlpath_state [1:0]`: Current state of the control logic.\n  - `done`: Computation completion flag. Active high.\n\n### State Machine Description\n- **States:**\n  - **S0 = 2'd0 (Idle/Load):**  \n    When `go` is inactive, the state remains in S0. When active, the state transitions to S2.\n  - **S2 = 2'd2 (Processing):**  \n    The state loops in S2 while waiting for the operands to become equal. Once `equal` is asserted, the state moves to S1.\n  - **S1 = 2'd1 (Completion):**  \n    A one-cycle state to signal the end of computation before returning to S0.\n- Note : The control path RTL stores the FSM state in `curr_state`  \n- **State Transitions:**\n  - From **S0**: Remains in S0 if `go` is low; otherwise transitions to S2.\n  - From **S2**: If `equal` is true, transitions to S1; otherwise remains in S2.\n  - From **S1**: Transitions back to S0.\n\n- **Signal Generation:**\n  - The output `done` is asserted 1 clock cycle after entering the state S1.\n  - The current state is continuously assigned to `controlpath_state`.\n\n- On reset assertion transition so S0 state and deassert `done`.\n\n---\n\n## 3. Datapath Module: `gcd_datapath_6`\n\n### Purpose\nThis module implements the arithmetic operations of Stein's GCD algorithm. It conditionally shifts and subtracts the input operands based on the algorithm until the final GCD is computed.\n\n### Parameter\n- **`WIDTH`**: Bit width of the input operands (and the output).\n\n### Ports\n- **Inputs:**\n  - `clk`: Clock signal. Design is synced to the posedge of clk.\n  - `rst`: Reset signal. Active high.\n  - `A [WIDTH-1:0]`: First operand.\n  - `B [WIDTH-1:0]`: Second operand.\n  - `controlpath_state [1:0]`: State signal from the control module.\n- **Outputs:**\n  - `equal`: A flag indicating if the two operands (after internal updates) are equal. Active high.\n  - `OUT [WIDTH-1:0]`: The computed greatest common divisor.\n\n### Internal Signals and Registers\n- **Registered Data:**\n  - `A_ff [WIDTH-1:0]`, `B_ff [WIDTH-1:0]`: Register copies of the operands.\n  - `OUT_ff [WIDTH-1:0]`: Output register for the GCD result.\n  - `k_ff`: Register used to count the number of common factors of 2 (shifts).\n  \n- **Next-State Signals:**\n  - `next_A_ff, next_B_ff, next_OUT`: Next values computed for `A_ff`, `B_ff`, and `OUT_ff`.\n  - `next_k_ff`: Next value for `k_ff`.\n\n- **Computational Signals:**\n  - `diff`: Holds the difference result used when subtracting the operands.\n  - `gcd_val`: Intermediate computed GCD value.\n  - `a_even`: Indicates if `A_ff` is even.\n  - `b_even`: Indicates if `B_ff` is even.\n  - `both_even`: Indicates if both `A_ff` and `B_ff` are even.\n\n### Datapath Control Based on `controlpath_state`\n- **State S0 (Load / Initialization):**\n  - Loads input values (`A` and `B`) into the registers.\n  - Resets the factor counter `k_ff` and the output register.\n  \n- **State S2 (Processing / Iterative Reduction):**\n  - **Both Operands Even:**  \n    If both `A_ff` and `B_ff` are even, both values are shifted right (divided by 2), and `k_ff` is incremented.\n  - **One Operand Even:**  \n    If one operand is even, only the even operand is shifted right.\n  - **Both Operands Odd:**  \n    When both operands are odd, subtract the smaller from the larger, shift the difference right, and reassign the registers.\n  - **Edge Cases:**  \n    If one of the registers becomes 0, the module redirects values to converge on the non-zero operand.\n  \n- **State S1 (Completion / Final Computation):**\n  - When the operands become equal, perform final computation:\n    - If both registers are zero, `gcd_val` is set to 0.\n    - Otherwise, the non-zero operand is combined with the shift count `k_ff` (the common factors of 2) to produce the final result.\n  - The computed GCD (`gcd_val`) is then saved to `OUT_ff`.\n\n### Data Path Signal Propagation\n- The updated values (`A_ff`, `B_ff`, `k_ff`, and `OUT_ff`) are registered at every positive edge of the clock. On reset, all these registers are cleared.", "docs/crypto_accelerator_specification.md": "# Crypto Accelerator Module Specification\nThis module implements a cryptographic accelerator that integrates two essential functions:\n\n1. **Key Validation:**  \n   Evaluates a candidate public key component against its corresponding totient using a greatest common divisor (GCD) algorithm to check if they are coprimes. A successful check (i.e., the GCD equals 1) deems the key valid.\n\n2. **Encryption:**  \n   When the key is valid, the module performs encryption by executing a modular exponentiation operation on provided plaintext data. If the key check fails, the encryption step is bypassed and a zero is output on the `ciphertext`.\n\nA finite state machine (FSM) governs the sequencing of these operations, ensuring synchronous operation with a system clock and providing reset-based initialization.\n\n## Port List\n\n| Port Name           | Direction | Bit-Width                   | Description                                                                                     |\n|---------------------|-----------|-----------------------------|-------------------------------------------------------------------------------------------------|\n| **clk**             | Input     | 1                           | System clock that synchronizes all operations.                                                  |\n| **rst**             | Input     | 1                           | Initializes the module to a known state; resets the FSM and all outputs. Active-high.           |\n| **candidate_e**     | Input     | WIDTH                       | Represents the candidate public key component used in validation.                               |\n| **totient**         | Input     | WIDTH                       | Represents Euler\u2019s totient value associated with the key.                                       |\n| **start_key_check** | Input     | 1                           | Triggers the key validation process when asserted. Active-high.                                 |\n| **key_valid**       | Output    | 1                           | Indicates that the candidate key is valid (if the GCD equals 1). Active-high.                   |\n| **done_key_check**  | Output    | 1                           | Signals the completion of the key validation process.  Active-high.                             |\n| **plaintext**       | Input     | WIDTH                       | The data to be encrypted if the key is validated.                                               |\n| **modulus**         | Input     | WIDTH                       | The modulus used in the encryption operation via modular exponentiation.                        |\n| **ciphertext**      | Output    | WIDTH                       | The result of the encryption operation (or a default value if the key is invalid).              |\n| **done_encryption** | Output    | 1                           | Indicates that the encryption operation (or its bypass) is completed. Active-high.              |\n\n| Parameter Name | Description                                                     |\n|----------------|-----------------------------------------------------------------|\n| **WIDTH**      | Determines the bit width of input and output signals. Default:8.|\n\n## Functional Description\n\n### Key Validation\n\n- **Triggering:**  \n  The validation process begins when the external start command is asserted.\n\n- **Operation:**  \n  Two numeric inputs (the candidate key and totient) are processed via a GCD computation. The output of this computation determines the validity of the candidate key:\n  - **Valid Key:** When the GCD equals 1  (the candidate key and totient are coprimes).\n  - **Invalid Key:** When the GCD does not equal 1  (the candidate key and totient are not coprimes).\n\n- **Outputs:**  \n  - `key_valid` is asserted or deasserted based on the GCD calculation output, and `done_key_check`, which indicates that the key validation process is complete, is asserted.\n  - `done_key_check` and `key_valid` are held high till the whole operation is completed, this may or may not include the encryption depending on whether the key is valid.\n\n### Encryption\n\n- **Conditional Execution:**  \n  The encryption operation is only initiated if the key validation process confirms that the candidate key is valid.\n\n- **Operation:**  \n  Upon successful validation, the module calculates the modular exponentiation based on the provided plaintext, using the candidate key (as the exponent) and the modulus input (to calculate the modulus of the exponentiation operation) .\n\n- **Default Behavior:**  \n  If the key is not valid, the module bypasses encryption and outputs a predetermined default value (i.e. zero) as the ciphertext. If the key is valid the module outputs the result from above calculation as ciphertext.\n\n### Sequencing and Control\n\nAn internal finite state machine (FSM) coordinates the following steps:\n  \n1. **Idle/Initialization:**  \n   Sets all internal signals (driven sequentially) and outputs to zero and waits for the start command.\n  \n2. **Key Validation:**  \n   Initiates and then waits for the GCD computation to complete.\n  \n3. **Decision Phase:**  \n   Based on the result of the key validation, the FSM either:\n   - Proceeds to trigger the encryption operation, or  \n   - Immediately outputs the default ciphertext.\n  \n4. **Encryption Execution:**  \n   Activates the modular exponentiation process and awaits its completion.\n  \n5. **Completion:**  \n   Signals the conclusion of both key validation and encryption (or bypass), and holds the final outputs till the start command is deasserted.\n\n## Timing and Reset\n\n- **Synchronous Operation:**  \n  All transitions and operations are synchronized to the positive edge of the system clock, ensuring consistent and predictable behavior.\n\n- **Reset Behavior:**  \n  The synchronous reset signal reinitializes the FSM and all outputs to IDLE and zeros respectively to allow for error-free start-up and operation.", "docs/modular_exponentiation_specification.md": "# RTL Specification: modular_exponentiation\n\n## 1. Overview\nThe **modular_exponentiation** module calculates  \n[result = (base<sup>exponent</sup>) % mod_val]  \nusing the square-and-multiply algorithm. It uses a dedicated modular multiplication unit for its arithmetic operations.\n\nThe square-and-multiply algorithm, also known as exponentiation by squaring, computes a<sup>b</sup> by first converting b into its binary representation, then iteratively updating an accumulator that starts at 1: for each bit of b, it squares the accumulator and multiplies by a when the bit is 1. Because a<sup>b</sup> can grow very large, apply modular operation at every step to keep the intermediate numbers small and manageable. This method dramatically reduces the number of multiplications compared to a naive approach, making it especially effective for large numbers and widely used in cryptography and modular arithmetic.\n\n## 2. Parameter\n- **WIDTH**: Sets the bit width for the operands, modulus, and result (default: 8).\n\n## 3. Interface\n\n### 3.1 Inputs\n- **clk**: Clock signal. Design is synchronised to the posedge of clk.\n- **rst**: Synchronous reset. Active-high.\n- **start**: Initiates the modular exponentiation process. Active-high. All steps of the operation occur sequentially after start is asserted.\n- **base**: Base operand, [WIDTH-1:0]. Unsigned integer.\n- **exponent**: Exponent operand, [WIDTH-1:0]. Unsigned integer.\n- **mod_val**: Modulus, [WIDTH-1:0]. Unsigned integer greater than 0.\n\n### 3.2 Outputs\n- **result**: The computed result ((base<sup>exponent</sup>) % mod_val), [WIDTH-1:0].\n- **done**: Indicates when the computation is complete. Active-high.\n\n## 4. Internal Architecture\n- **Control Logic**: A finite state machine (FSM) governs the overall operation, initiating the process, managing the iterative algorithm, and signaling completion.\n- **Modular Multiplier Instance**: The module integrates a separate modular multiplication unit to perform the required modular arithmetic without exposing its internal details.\n- **Registers**: Internal registers are used to hold intermediate results, the reduced base, and the exponent as it is processed.\n\n## 5. Remarks\n- It leverages the modular multiplication unit to maintain clarity and reusability.", "docs/modular_multiplier_specification.md": "# RTL Specification: modular_multiplier\n\n## 1. Overview\nThe **modular_multiplier** computes the modular product  \n\n (A * B\\) % mod_val\n\nusing a sequential shift-and-add algorithm over a configurable bit width.\nThe shift-add algorithm for multiplication works by examining each bit of one binary number; for every bit that is 1, \nit adds the other number shifted left by the bit\u2019s position to a running total. This method efficiently decomposes multiplication into simple bit shifts and \nadditions, mirroring manual multiplication in binary and optimizing it for digital hardware.\n\n## 2. Parameter\n- **WIDTH**: Bit width for operands, result, and intermediate signals (default: 8).\n\n## 3. Interface\n\n### 3.1 Inputs\n- **clk**: Clock signal. Design is synchronised to the posedge of clk.\n- **rst**: Synchronous reset. Active-high.\n- **start**: Initiates the multiplication operation. Active-high. All steps of the operation occur sequentially after start is asserted.\n- **A**: Multiplicand, [WIDTH-1:0]. Unsigned integer.\n- **B**: Multiplier, [WIDTH-1:0]. Unsigned integer.\n- **mod_val**: Modulus, [WIDTH-1:0]. Unsigned integer greater than 0.\n\n### 3.2 Outputs\n- **result**: Final computed value ((A * B\\) % mod_val), [WIDTH-1:0].\n- **done**: Indicates completion of the operation. Active-high.\n\n## 4. Functional Description\nWhen a **start** signal is received, the module:\n- Processes the multiplication sequentially.\n- Produces the final result when all computations are complete, asserting the **done** flag.\n\n## 5. Remarks\n- Keep intermediate values within bounds.", "rtl/gcd_controlpath_3.sv": "module gcd_controlpath_3 (\n   input                    clk,\n   input                    rst,\n   input                    go,\n   input                    equal,\n   output logic [1:0]       controlpath_state,\n   output logic             done\n);\n   localparam S0 = 2'd0;\n   localparam S1 = 2'd1;\n   localparam S2 = 2'd2;\n\n   logic [1:0] curr_state, next_state;\n\n   always_comb begin\n      next_state = curr_state;\n      case (curr_state)\n         S0: begin\n            if (!go)\n               next_state = S0;\n            else\n               next_state = S2;\n         end\n         S1: begin\n            next_state = S0;\n         end\n         S2: begin\n            if (equal)\n               next_state = S1;\n            else\n               next_state = S2;\n         end\n         default: begin\n            next_state = S0;\n         end\n      endcase\n   end\n\n   always_ff @(posedge clk) begin\n      if (rst)\n         curr_state <= S0;\n      else\n         curr_state <= next_state;\n   end\n\n   always_ff @(posedge clk) begin\n      if (rst)\n         done <= 1'b0;\n      else\n         done <= (curr_state == S1);\n   end\n\n   assign controlpath_state = curr_state;\n\nendmodule", "rtl/gcd_controlpath_4.sv": "module gcd_controlpath_4 (\n   input                    clk,\n   input                    rst,\n   input                    go,\n   input                    equal,\n   input                    greater_than,\n   output logic [1:0]       controlpath_state,\n   output logic             done\n);\n\n\n   logic [1:0] curr_state;\n   logic [1:0] next_state;\n\n   localparam S0 = 2'd0;\n   localparam S1 = 2'd1;\n   localparam S2 = 2'd2;\n   localparam S3 = 2'd3;\n\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         curr_state   <= S0;\n      end else begin\n         curr_state   <= next_state;\n      end\n   end\n\n   always_comb begin\n      case(curr_state)\n         S0: begin\n             if(!go)\n                next_state = S0;\n             else if (equal)\n                next_state = S1;\n             else if (greater_than)\n                next_state = S2;\n             else\n                next_state = S3;\n         end\n         S1: begin\n             next_state = S0;\n         end\n         S2: begin\n             if(equal)\n                next_state = S1;\n             else if (greater_than)\n                next_state = S2;\n             else\n                next_state = S3;\n         end\n         S3: begin\n             if (equal)\n                next_state = S1;\n             else if (greater_than)\n                next_state = S2;\n             else\n                next_state = S3;\n         end\n         default: begin\n             next_state = S0;\n         end\n      endcase\n   end\n\n   always_ff @ (posedge clk) begin\n     if(rst) begin\n        done <= 1'b0;\n     end else begin\n        done <= (curr_state == S1);\n     end\n   end\n\n   assign controlpath_state = curr_state;\n\nendmodule", "rtl/gcd_datapath_5.sv": "module gcd_datapath_5  #(\n   parameter WIDTH = 4\n   )(\n   input                     clk,\n   input                     rst,\n   input  [WIDTH-1:0]        A,\n   input  [WIDTH-1:0]        B,\n   input  [1:0]              controlpath_state,\n   output logic              equal,\n   output logic              greater_than,\n   output logic  [WIDTH-1:0] OUT\n);\n\n   logic [WIDTH-1:0] A_ff;\n   logic [WIDTH-1:0] B_ff;\n\n   localparam S0 = 2'd0;\n   localparam S1 = 2'd1;\n   localparam S2 = 2'd2;\n   localparam S3 = 2'd3;\n\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         A_ff <= 'b0;\n         B_ff <= 'b0;\n         OUT  <= 'b0;\n      end else begin\n         case (controlpath_state)\n            S0: begin\n                A_ff <= A;\n                B_ff <= B;\n             end\n            S1: begin\n                OUT  <= A_ff;\n             end\n            S2: begin\n                if (greater_than)\n                   A_ff <= A_ff - B_ff;\n             end\n            S3: begin\n                if (!equal & !greater_than)\n                   B_ff <= B_ff - A_ff;\n             end\n            default: begin\n                A_ff <= 'b0;\n                B_ff <= 'b0;\n                OUT <= 'b0;\n            end\n         endcase\n      end\n   end\n\n   always_comb begin\n      case(controlpath_state)\n         S0: begin\n            equal        = (A == B)? 1'b1 : 1'b0;\n            greater_than = (A >  B)? 1'b1 : 1'b0;\n          end\n          default: begin\n            equal        = (A_ff == B_ff)? 1'b1 : 1'b0;\n            greater_than = (A_ff >  B_ff)? 1'b1 : 1'b0;\n          end\n      endcase\n   end\nendmodule", "rtl/gcd_datapath_6.sv": "module gcd_datapath_6  #(\n   parameter WIDTH = 4\n)(\n   input                     clk,\n   input                     rst,\n   input      [WIDTH-1:0]    A,\n   input      [WIDTH-1:0]    B,\n   input      [1:0]          controlpath_state,\n   output logic              equal,\n   output logic [WIDTH-1:0]  OUT\n);\n   logic [WIDTH-1:0] A_ff, B_ff, OUT_ff;\n   logic [$clog2(WIDTH+1):0] k_ff;\n\n   logic [WIDTH-1:0] next_A_ff, next_B_ff, next_OUT;\n   logic [$clog2(WIDTH+1):0] next_k_ff;\n\n   logic [WIDTH-1:0] diff;\n   logic [WIDTH-1:0] gcd_val;\n   logic both_even, a_even, b_even;\n\n   localparam S0 = 2'd0;\n   localparam S1 = 2'd1;\n   localparam S2 = 2'd2;\n\n   always_comb begin\n      next_A_ff = A_ff;\n      next_B_ff = B_ff;\n      next_k_ff = k_ff;\n      next_OUT  = OUT_ff;\n      gcd_val   = OUT_ff;\n      diff      = 'b0;\n\n      a_even    = (A_ff[0] == 1'b0);\n      b_even    = (B_ff[0] == 1'b0);\n      both_even = a_even && b_even;\n      equal     = (A_ff == B_ff);\n\n      case (controlpath_state)\n         S0: begin\n            next_A_ff = A;\n            next_B_ff = B;\n            next_k_ff = 'b0;\n            next_OUT  = 'b0;\n         end\n\n         S1: begin\n            if (A_ff == 0 && B_ff == 0) begin\n               gcd_val = 0;\n            end else if (A_ff == 0) begin\n               gcd_val = (B_ff << k_ff);\n            end else begin\n               gcd_val = (A_ff << k_ff);\n            end\n            next_OUT = gcd_val;\n         end\n\n         S2: begin\n            if ((A_ff != 0) && (B_ff != 0)) begin\n               if (both_even) begin\n                  next_A_ff = A_ff >> 1;\n                  next_B_ff = B_ff >> 1;\n                  next_k_ff = k_ff + 1;\n               end else if (a_even && !b_even) begin\n                  next_A_ff = A_ff >> 1;\n               end else if (b_even && !a_even) begin\n                  next_B_ff = B_ff >> 1;\n               end else begin\n                  if (A_ff >= B_ff) begin\n                     diff = A_ff - B_ff;\n                     next_A_ff = diff >> 1;\n                     next_B_ff = B_ff;\n                  end else begin\n                     diff = B_ff - A_ff;\n                     next_B_ff = diff >> 1;\n                     next_A_ff = A_ff;\n                  end\n               end\n            end else if (A_ff == 0 && B_ff != 0) begin\n               next_A_ff = B_ff;\n               next_B_ff = B_ff;\n            end else if (B_ff == 0 && A_ff != 0) begin\n               next_B_ff = A_ff;\n               next_A_ff = A_ff;\n            end\n         end\n\n         default: begin\n            next_A_ff = 'b0;\n            next_B_ff = 'b0;\n            next_k_ff = 'b0;\n            next_OUT  = 'b0;\n         end\n      endcase\n   end\n\n   always_ff @(posedge clk) begin\n      if (rst) begin\n         A_ff  <= 'b0;\n         B_ff  <= 'b0;\n         k_ff  <= 'b0;\n         OUT_ff <= 'b0;\n      end else begin\n         A_ff  <= next_A_ff;\n         B_ff  <= next_B_ff;\n         k_ff  <= next_k_ff;\n         OUT_ff <= next_OUT;\n      end\n   end\n\n   assign OUT = OUT_ff;\n\nendmodule", "rtl/gcd_top_1.sv": "module gcd_top_1 #(\n   parameter WIDTH = 4\n)(\n   input                     clk,\n   input                     rst,\n   input  [WIDTH-1:0]        A,\n   input  [WIDTH-1:0]        B,\n   input                     go,\n   output logic [WIDTH-1:0]  OUT,\n   output logic              done\n);\n\n   logic equal;\n   logic [1:0] controlpath_state;\n\n   gcd_controlpath_3 ctrl_inst (\n      .clk               (clk),\n      .rst               (rst),\n      .go                (go),\n      .equal             (equal),\n      .controlpath_state (controlpath_state),\n      .done              (done)\n   );\n\n   gcd_datapath_6 #( .WIDTH(WIDTH) ) dp_inst (\n      .clk               (clk),\n      .rst               (rst),\n      .A                 (A),\n      .B                 (B),\n      .controlpath_state (controlpath_state),\n      .equal             (equal),\n      .OUT               (OUT)\n   );\n\nendmodule", "rtl/gcd_top_2.sv": "module gcd_top_2 #(\n   parameter WIDTH = 4\n)(\n   input                     clk,\n   input                     rst,\n   input  [WIDTH-1:0]        A,\n   input  [WIDTH-1:0]        B,\n   input                     go,\n   output logic [WIDTH-1:0]  OUT,\n   output logic              done\n);\n\n   logic equal;\n   logic greater_than;\n   logic [1:0] controlpath_state;\n\n   gcd_controlpath_4 ctrl_inst (\n      .clk               (clk),\n      .rst               (rst),\n      .go                (go),\n      .equal             (equal),\n      .greater_than      (greater_than),\n      .controlpath_state (controlpath_state),\n      .done              (done)\n   );\n\n   gcd_datapath_5 #( .WIDTH(WIDTH) ) dp_inst (\n      .clk               (clk),\n      .rst               (rst),\n      .A                 (A),\n      .B                 (B),\n      .controlpath_state (controlpath_state),\n      .equal             (equal),\n      .greater_than      (greater_than),\n      .OUT               (OUT)\n   );\n\nendmodule", "rtl/modular_exponentiation.sv": "`timescale 1ns/1ps\n//-----------------------------------------------------------------------------\n// modular_exponentiation module: Computes (base^exponent) mod mod_val using the\n// square-and-multiply algorithm.\n// This module reuses the modular_multiplier module for multiplication operations.\n//-----------------------------------------------------------------------------\nmodule modular_exponentiation #(\n    parameter WIDTH = 8\n)(\n    input                     clk,\n    input                     rst,\n    input                     start,\n    input      [WIDTH-1:0]    base,\n    input      [WIDTH-1:0]    exponent,\n    input      [WIDTH-1:0]    mod_val,\n    output reg [WIDTH-1:0]    result,\n    output reg                done\n);\n    // FSM state definitions.\n    localparam STATE_IDLE        = 0;\n    localparam STATE_INIT        = 1;\n    localparam STATE_CHECK       = 2;\n    localparam STATE_WAIT_RESULT = 3;\n    localparam STATE_MULT_BASE   = 4;\n    localparam STATE_WAIT_BASE   = 5;\n    localparam STATE_SHIFT       = 6;\n    localparam STATE_DONE        = 7;\n\n    reg [3:0]       state;\n    reg [WIDTH-1:0] res_reg;\n    reg [WIDTH-1:0] base_reg;\n    reg [WIDTH-1:0] exp_reg;\n\n    // Signals for the modular multiplier instance.\n    reg mult_start;\n    reg [WIDTH-1:0] mult_A, mult_B, mult_mod;\n    wire [WIDTH-1:0] mult_result;\n    wire mult_done;\n\n    // Instantiate the modular_multiplier.\n    modular_multiplier #(\n        .WIDTH(WIDTH)\n    ) mod_mult_inst (\n        .clk(clk),\n        .rst(rst),\n        .start(mult_start),\n        .A(mult_A),\n        .B(mult_B),\n        .mod_val(mult_mod),\n        .result(mult_result),\n        .done(mult_done)\n    );\n\n    always @(posedge clk) begin\n        if(rst) begin\n            state      <= STATE_IDLE;\n            res_reg    <= 0;\n            base_reg   <= 0;\n            exp_reg    <= 0;\n            result     <= 0;\n            done       <= 0;\n            mult_start <= 0;\n        end else begin\n            case(state)\n                STATE_IDLE: begin\n                    done <= 0;\n                    if(start)\n                        state <= STATE_INIT;\n                end\n                STATE_INIT: begin\n                    res_reg  <= 1;                // Initialize result to 1.\n                    base_reg <= base % mod_val;    // Reduce base modulo mod_val.\n                    exp_reg  <= exponent;\n                    state    <= STATE_CHECK;\n                end\n                STATE_CHECK: begin\n                    if(exp_reg == 0) begin\n                        if(base_reg == 0 & mod_val==1)\n                            result <= 0;\n                        else\n                            result <= res_reg;\n                        state  <= STATE_DONE;\n                    end else begin\n                        if(exp_reg[0] == 1'b1) begin\n                            mult_A   <= base_reg;\n                            mult_B   <= base_reg;\n                            mult_mod <= mod_val;\n                            mult_start <= 1;\n                            state <= STATE_WAIT_RESULT;\n                        end else begin\n                            state <= STATE_MULT_BASE;\n                        end\n                    end\n                end\n                STATE_WAIT_RESULT: begin\n                    mult_start <= 0;\n                    if(mult_done) begin\n                        res_reg <= mult_result;\n                        state <= STATE_MULT_BASE;\n                    end\n                end\n                STATE_MULT_BASE: begin\n                    mult_A   <= base_reg;\n                    mult_B   <= res_reg;\n                    mult_mod <= mod_val;\n                    mult_start <= 1;\n                    state <= STATE_WAIT_BASE;\n                end\n                STATE_WAIT_BASE: begin\n                    mult_start <= 0;\n                    if(mult_done) begin\n                        base_reg <= mult_result;\n                        state <= STATE_SHIFT;\n                    end\n                end\n                STATE_SHIFT: begin\n                    exp_reg <= exp_reg >> 1; // Shift exponent right.\n                    state   <= STATE_CHECK;\n                end\n                STATE_DONE: begin\n                    done <= 1;\n                    // Remain in DONE state until start is deasserted.\n                    if(!start)\n                        state <= STATE_IDLE;\n                end\n                default: state <= STATE_IDLE;\n            endcase\n        end\n    end\nendmodule", "rtl/modular_multiplier.sv": "`timescale 1ns/1ps\n//-----------------------------------------------------------------------------\n// modular_multiplier module: Computes (A * B) mod mod_val\n// Implements a sequential shift\u2010and\u2010add multiplication followed by a\n// single modulo operation at the end.\n//-----------------------------------------------------------------------------\nmodule modular_multiplier #(\n    parameter WIDTH = 8\n)(\n    input                     clk,\n    input                     rst,\n    input                     start,\n    input      [WIDTH-1:0]    A,\n    input      [WIDTH-1:0]    B,\n    input      [WIDTH-1:0]    mod_val,\n    output reg [WIDTH-1:0]    result,\n    output reg                done\n);\n    // a_reg now stores A extended to 2*WIDTH bits to accommodate shifts.\n    reg [2*WIDTH-1:0] a_reg;\n    reg [WIDTH-1:0]   b_reg;\n    reg [2*WIDTH-1:0] prod;   // Accumulates the full product\n    reg [($clog2(WIDTH+1))-1:0] count;  // Iteration counter for WIDTH bits\n    reg busy;\n\n    always @(posedge clk) begin\n        if(rst) begin\n            result  <= 0;\n            prod    <= 0;\n            a_reg   <= 0;\n            b_reg   <= 0;\n            count   <= 0;\n            busy    <= 0;\n            done    <= 0;\n        end else begin\n            if(start && !busy) begin\n                busy    <= 1;\n                // Initialize registers.\n                // Extend A to 2*WIDTH bits.\n                a_reg   <= { {WIDTH{1'b0}}, A };\n                b_reg   <= B;\n                prod    <= 0;\n                count   <= WIDTH;\n                done    <= 0;\n            end else if(busy) begin\n                if(count > 0) begin\n                    // If the current LSB of b_reg is 1, add a_reg to the product.\n                    if(b_reg[0] == 1'b1)\n                        prod <= prod + a_reg;\n                    // Shift a_reg left to align with the next bit.\n                    a_reg <= a_reg << 1;\n                    // Shift b_reg right to process the next bit.\n                    b_reg <= b_reg >> 1;\n                    count <= count - 1;\n                end else begin\n                    // Once multiplication is done, perform the modulo operation.\n                    result <= prod % mod_val;\n                    done   <= 1;\n                    busy   <= 0;\n                end\n            end else begin\n                done <= 0;\n            end\n        end\n    end\nendmodule"}, "patch": {"rtl/crypto_accelerator.sv": "", "rtl/modular_exponentiation.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image:  __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n\n", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/gcd_top_1.sv /code/rtl/gcd_top_2.sv /code/rtl/gcd_datapath_5.sv /code/rtl/gcd_controlpath_3.sv /code/rtl/gcd_datapath_6.sv /code/rtl/gcd_controlpath_4.sv /code/rtl/modular_multiplier.sv /code/rtl/modular_exponentiation.sv /code/rtl/crypto_accelerator.sv\nTOPLEVEL        = crypto_accelerator\nMODULE          = test_crypto_accelerator\nPYTHONPATH      = /src\nHASH            = 7-generate-crypto_accelerator-top", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\n", "src/test_crypto_accelerator.py": "import random\nfrom math import gcd\n\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, ClockCycles\n\n\nasync def wait_for_operation_done(dut):\n    \"\"\"\n    Wait until both key validation and encryption processes signal completion.\n    This helper function waits until both 'done_key_check' and 'done_encryption'\n    are asserted.\n    \"\"\"\n    while True:\n        await RisingEdge(dut.clk)\n        if int(dut.done_key_check.value) == 1 and int(dut.done_encryption.value) == 1:\n            break\n\n\ndef get_width(dut):\n    \"\"\"\n    Retrieve the WIDTH parameter from the DUT if available.\n    If unavailable, default to 8.\n    \"\"\"\n    try:\n        width = int(dut.WIDTH.value)\n    except AttributeError:\n        width = 8\n    return width\n\n\n@cocotb.test()\nasync def test_key_validation_and_encryption(dut):\n    \"\"\"\n    Production-level testbench for the crypto accelerator:\n      - Validates key validation for both valid and invalid keys.\n      - Executes randomized stress tests using the parameterized WIDTH.\n      - Checks boundary conditions based on the computed maximum value.\n    \"\"\"\n    # Start clock on 'clk' with a 10 ns period using start_soon\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    width = get_width(dut)\n    max_val = (2 ** width) - 1\n\n    dut._log.info(f\"Testbench started with WIDTH={width} (max value = {max_val})\")\n\n    # Reset the DUT.\n    dut.rst.value             = 1\n    dut.start_key_check.value = 0\n    dut.candidate_e.value     = 0\n    dut.totient.value         = 0\n    dut.plaintext.value       = 0\n    dut.modulus.value         = 0\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    dut.rst.value             = 0\n\n    ##############\n    # Test Case 1: Valid Key Scenario\n    # For a valid key, choose candidate_e and totient such that gcd(candidate_e, totient)==1.\n    ##############\n    valid_candidate   = 3 if 3 <= max_val else 1\n    valid_totient     = 10 if 10 <= max_val else max_val - 1\n    valid_plaintext   = 7 if 7 <= max_val else 1\n    valid_modulus     = 11 if 11 <= max_val else max_val - 1\n    expected_key_valid = 1\n    expected_ciphertext = pow(valid_plaintext, valid_candidate, valid_modulus)\n\n    dut._log.info(\"Test Case 1: Valid Key Scenario\")\n    dut._log.info(f\"Stimulus: candidate_e = {valid_candidate}, totient = {valid_totient}, \"\n                   f\"plaintext = {valid_plaintext}, modulus = {valid_modulus}\")\n    dut._log.info(f\"Expected: key_valid = {expected_key_valid} and ciphertext = {expected_ciphertext}\")\n    dut.candidate_e.value     = valid_candidate\n    dut.totient.value         = valid_totient\n    dut.plaintext.value       = valid_plaintext\n    dut.modulus.value         = valid_modulus\n    dut.start_key_check.value = 1  # Trigger the operation.\n    await RisingEdge(dut.clk)\n    dut.start_key_check.value = 0  # Deassert after one clock cycle.\n\n    await wait_for_operation_done(dut)\n\n    actual_key_valid = int(dut.key_valid.value)\n    actual_ciphertext = int(dut.ciphertext.value)\n    dut._log.info(f\"Actual: key_valid = {actual_key_valid}, ciphertext = {actual_ciphertext}\")\n\n    assert actual_key_valid == expected_key_valid, (\n        f\"Test Case 1: Valid key not detected. Expected key_valid=1, got {actual_key_valid}.\"\n    )\n    assert actual_ciphertext == expected_ciphertext, (\n        f\"Test Case 1: Incorrect ciphertext. Expected {expected_ciphertext}, got {actual_ciphertext}.\"\n    )\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    ##############\n    # Test Case 2: Invalid Key Scenario\n    # Use candidate_e = 4 and totient = 10, so that gcd(4,10)==2.\n    ##############\n    invalid_candidate = 4 if 4 <= max_val else 2\n    expected_key_valid = 0\n    # For an invalid key, expected ciphertext should be 0.\n    expected_ciphertext = 0\n\n    dut._log.info(\"Test Case 2: Invalid Key Scenario\")\n    dut._log.info(f\"Stimulus: candidate_e = {invalid_candidate}, totient = {valid_totient}, \"\n                   f\"plaintext = {valid_plaintext}, modulus = {valid_modulus}\")\n    dut._log.info(f\"Expected: key_valid = {expected_key_valid} and ciphertext = {expected_ciphertext}\")\n    dut.candidate_e.value     = invalid_candidate\n    dut.totient.value         = valid_totient  # Reuse totient from above.\n    dut.plaintext.value       = valid_plaintext\n    dut.modulus.value         = valid_modulus\n    dut.start_key_check.value = 1\n    await RisingEdge(dut.clk)\n    dut.start_key_check.value = 0\n\n    await wait_for_operation_done(dut)\n\n    actual_key_valid = int(dut.key_valid.value)\n    actual_ciphertext = int(dut.ciphertext.value)\n    dut._log.info(f\"Actual: key_valid = {actual_key_valid}, ciphertext = {actual_ciphertext}\")\n\n    assert actual_key_valid == expected_key_valid, (\n        f\"Test Case 2: Invalid key not detected. Expected key_valid=0, got {actual_key_valid}.\"\n    )\n    assert actual_ciphertext == expected_ciphertext, (\n        f\"Test Case 2: Incorrect ciphertext. Expected {expected_ciphertext}, got {actual_ciphertext}.\"\n    )\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    ##############\n    # Test Case 3: Randomized Stress Test\n    # Run multiple randomized test iterations using parameterized max_val.\n    ##############\n    NUM_RANDOM_TESTS = 50\n    dut._log.info(\"Test Case 3: Randomized Stress Test\")\n    for i in range(NUM_RANDOM_TESTS):\n        candidate   = random.randint(1, max_val)\n        totient_val = random.randint(1, max_val)\n        plaintext_val = random.randint(0, max_val)\n        modulus_val   = random.randint(1, max_val)\n\n        # Determine expected key valid flag.\n        expected_key_valid = 1 if gcd(candidate, totient_val) == 1 else 0\n        # If key is valid, compute expected ciphertext; otherwise, it should be 0.\n        if expected_key_valid == 1:\n            expected_ciphertext = pow(plaintext_val, candidate, modulus_val)\n        else:\n            expected_ciphertext = 0\n\n        dut.candidate_e.value     = candidate\n        dut.totient.value         = totient_val\n        dut.plaintext.value       = plaintext_val\n        dut.modulus.value         = modulus_val\n        dut.start_key_check.value = 1\n\n        await RisingEdge(dut.clk)\n        dut.start_key_check.value = 0\n\n        await wait_for_operation_done(dut)\n\n        actual_key_valid = int(dut.key_valid.value)\n        actual_ciphertext = int(dut.ciphertext.value)\n\n        dut._log.info(\n            f\"Iteration {i}: Stimulus - candidate_e = {candidate}, totient = {totient_val}, \"\n            f\"plaintext = {plaintext_val}, modulus = {modulus_val}\"\n        )\n        dut._log.info(\n            f\"Iteration {i}: Expected - key_valid = {expected_key_valid}, ciphertext = {expected_ciphertext}\"\n        )\n        dut._log.info(\n            f\"Iteration {i}: Actual - key_valid = {actual_key_valid}, ciphertext = {actual_ciphertext}\"\n        )\n\n        assert actual_key_valid == expected_key_valid, (\n            f\"Stress Test Iteration {i}: key_valid mismatch. Candidate = {candidate}, \"\n            f\"Totient = {totient_val}. Expected key_valid = {expected_key_valid}, got {actual_key_valid}.\"\n        )\n        assert actual_ciphertext == expected_ciphertext, (\n            f\"Stress Test Iteration {i}: ciphertext mismatch. Candidate = {candidate}, \"\n            f\"Plaintext = {plaintext_val}, Modulus = {modulus_val}. Expected ciphertext = {expected_ciphertext}, \"\n            f\"got {actual_ciphertext}.\"\n        )\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n\n    ##############\n    # Test Case 4: Boundary Conditions\n    # Apply maximum boundary values as determined by WIDTH.\n    ##############\n    expected_key_valid = 0\n    expected_ciphertext = 0\n\n    dut._log.info(\"Test Case 4: Boundary Conditions\")\n    dut._log.info(f\"Stimulus: candidate_e, totient, plaintext, modulus = {max_val} (maximum value)\")\n    dut._log.info(f\"Expected: key_valid = {expected_key_valid} and ciphertext = {expected_ciphertext}\")\n    dut.candidate_e.value     = max_val\n    dut.totient.value         = max_val\n    dut.plaintext.value       = max_val\n    dut.modulus.value         = max_val\n    dut.start_key_check.value = 1\n\n    await RisingEdge(dut.clk)\n    dut.start_key_check.value = 0\n\n    await wait_for_operation_done(dut)\n\n    actual_key_valid = int(dut.key_valid.value)\n    actual_ciphertext = int(dut.ciphertext.value)\n    dut._log.info(f\"Actual: key_valid = {actual_key_valid}, ciphertext = {actual_ciphertext}\")\n\n    assert actual_key_valid == expected_key_valid, (\n        f\"Boundary Test: Expected key_valid = {expected_key_valid}, got {actual_key_valid}.\"\n    )\n    assert actual_ciphertext == expected_ciphertext, (\n        f\"Boundary Test: Expected ciphertext = {expected_ciphertext}, got {actual_ciphertext}.\"\n    )\n\n    dut._log.info(\"All tests passed successfully for the crypto accelerator.\")\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner(WIDTH: int=5):\n    \n    parameter = {\"WIDTH\":WIDTH}\n    # Debug information\n    print(f\"[DEBUG] Running simulation with WIDTH={WIDTH}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        parameters=parameter,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Parametrize test for different WIDTH\n@pytest.mark.parametrize(\"WIDTH\", [4,6,8,16])\n\ndef test_crypto_accelerator(WIDTH):\n    # Run the simulation with specified parameters\n    test_runner(WIDTH=WIDTH)", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_hdbn_codec_0001", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Design a hierarchical **HDBN Encoder/Decoder module** in SystemVerilog according to the provided specification in `docs/specification.md`. The design should consist of a top-level module named **`hdbn_top`**, which instantiates two submodules: **`hdbn_encoder`** and **`hdbn_decoder`**. Ensure your implementation adheres strictly to the specification, including:\n\n- Parameterized selection between HDB3 and HDB2 encoding (`encoder_type`).\n- Configurable pulse active state (`pulse_active_state`).\n\nThe encoder module (`hdbn_encoder`) must:\n\n- Register input digital data and encode it into bipolar pulses (`P` and `N`).\n- Implement zero-counting logic to insert violations, preventing DC bias.\n- Alternate pulse polarity correctly, considering violation conditions.\n\nThe decoder module (`hdbn_decoder`) must:\n\n- Register incoming bipolar pulse inputs (`P` and `N`).\n- Decode the bipolar pulses back into digital data.\n- Detect and indicate encoding errors, including violations, simultaneous pulses, and excessive consecutive zeros.\n", "context": {"docs/specification.md": "# **HDBn (HDB3/HDB2) Codec Specification Document**\n\n## **1. Overview**\nThe HDBn (High-Density Bipolar) coding scheme was developed to solve critical issues in digital telecommunications transmission. Traditional AMI (Alternate Mark Inversion) coding faced problems with long sequences of zeros, which made clock recovery difficult and could lead to DC bias accumulation. HDBn improves upon AMI by introducing controlled violations that maintain synchronization while preserving DC balance.\n\nhe HDBn encoder/decoder implements High-Density Bipolar line coding, specifically HDB3 (used in E1/T1 systems) and HDB2/B3ZS (used in T3 systems). These schemes prevent long sequences of zeros to maintain clock recovery and eliminate DC bias in transmission lines. The encoder converts binary data into bipolar pulses with intentional violations, while the decoder recovers the original data and detects transmission errors.\n\n\nThe key innovation in HDBn is its replacement mechanism for zero sequences:\n- **HDB3**: Replaces every 4 consecutive zeros with either \"000V\" or \"B00V\"\n- **HDB2/B3ZS**: Replaces every 3 consecutive zeros with \"B0V\"\n\nIn HDBn coding schemes, **B** and **V** are special pulse markers used to maintain synchronization and DC balance:\n\n### **V (Violation Pulse)**\n- A deliberate **polarity violation** of the AMI (Alternate Mark Inversion) rule.\n- Normally, pulses alternate between positive (+) and negative (-). A **V** intentionally repeats the same polarity as the previous pulse to create a detectable event.\n- **Purpose**: \n  - Guarantees a signal transition (for clock recovery).\n  - Marks the position where zeros were replaced.\n\n### **B (Balance Pulse)**\n- A normal pulse (following AMI rules) inserted to maintain **DC balance**.\n- **Purpose**: \n  - Ensures the total number of positive and negative pulses remains equal over time (preventing DC buildup).\n  - Counts as a valid \"1\" in the decoded data.\n\nThese substitutions guarantee sufficient signal transitions while maintaining the zero-DC property through careful violation polarity selection. The violation patterns are chosen to ensure the overall pulse count remains balanced (equal number of positive and negative pulses).\n\n## **2. Module Descriptions**\n\n### **2.1 Top-Level Module: hdbn_top**\nThis module integrates both encoding and decoding functionality for complete HDBn processing. The encoder converts NRZ (Non-Return-to-Zero) data into bipolar HDBn pulses, while the decoder performs the reverse operation while also detecting transmission errors.\n\nThe dual functionality allows for full-duplex communication systems where both transmission and reception need HDBn processing. The shared parameterization (EncoderType, PulseActiveState) ensures consistent operation across both directions.\n\n#### Configuration Parameters\n\n| Parameter             | Type    | Default | Description                                       |\n|-----------------------|---------|---------|---------------------------------------------------|\n| `encoder_type`        | integer | 3       | Select encoding type: 3 for HDB3, 2 for HDB2/B3ZS |\n| `pulse_active_state`  | logic   | 1'b1    | Defines active state of P and N signals           |\n\n#### I/O Port List\n\n| Port              | Direction | Description                                           |\n|-------------------|-----------|-------------------------------------------------------|\n| `reset_in`        | input     | Active high asynchronous reset signal                 |\n| `clk_in`          | input     | Input clock signal (rising-edge triggered)            |\n| `clk_enable_in`   | input     | Clock enable, active high                             |\n| `data_in`         | input     | Digital data input to encoder (active high)           |\n| `output_gate_in`  | input     | Gate control, '0' disables encoder outputs (P, N)     |\n| `p_out`           | output    | Encoder positive pulse output                         |\n| `n_out`           | output    | Encoder negative pulse output                         |\n| `p_in`            | input     | Decoder positive pulse input                          |\n| `n_in`            | input     | Decoder negative pulse input                          |\n| `data_out`        | output    | Digital data output from decoder (active high)        |\n| `code_error_out`  | output    | Decoder error indication (active high)                |\n\n\n### **2.2 Encoder Module (hdbn_encoder)**\nThe encoder implements the complete HDBn substitution algorithm through several coordinated processes:\n\n**Input Processing and Zero Detection**\nThe input data first passes through a synchronization register to align with the system clock. A zero counter monitors consecutive zero bits, incrementing until either a '1' is encountered or the EncoderType limit (3 or 4) is reached. This counter is the trigger for violation insertion.\n\n**Violation Insertion Logic**\nWhen the zero counter reaches its maximum, the encoder must replace the zero sequence. The replacement pattern depends on two factors:\n1. The current polarity state (AMI flip-flop)\n2. The number of pulses since the last violation (ViolationType)\n\nFor HDB3 (4-zero replacement):\n- If the previous violation count is odd: \"000V\" (same polarity as last pulse)\n- If even: \"B00V\" (B pulse opposite polarity to maintain balance)\n\nThe shift registers in the design should properly align these inserted pulses with the original data stream while maintaining the correct timing relationships.\n\n**Pulse Generation and Output Control**\nThe final stage generates the actual P and N outputs based on the processed data stream. The AMI flip-flop ensures proper alternation of pulse polarities, while the output gate provides a master disable function for transmission control.\n\n#### Configuration Parameters\n\n| Parameter             | Type    | Default | Description                                       |\n|-----------------------|---------|---------|---------------------------------------------------|\n| `encoder_type`        | integer | 3       | Select encoding type: 3 for HDB3, 2 for HDB2/B3ZS |\n| `pulse_active_state`  | logic   | 1'b1    | Defines active state of P and N signals           |\n\n#### I/O Port List\n\n| Port              | Direction | Description                                           |\n|-------------------|-----------|-------------------------------------------------------|\n| `reset_in`        | input     | Active high asynchronous reset signal                 |\n| `clk_in`          | input     | Input clock signal (rising-edge triggered)            |\n| `clk_enable_in`   | input     | Clock enable, active high                             |\n| `data_in`         | input     | Digital data input (active high)                      |\n| `output_gate_in`  | input     | Gate control, '0' disables outputs                    |\n| `p_out`           | output    | Positive pulse output                                 |\n| `n_out`           | output    | Negative pulse output                                 |\n\n### **2.3 Decoder Module (hdbn_decoder)**\nThe decoder performs three critical functions: pulse interpretation, violation detection, and error checking.\n\n**Pulse Processing**\nInput pulses are first registered and normalized to active-high signaling internally. The decoder tracks the polarity of each pulse to identify violations (consecutive pulses of same polarity). Valid violations are stripped out while maintaining the original data timing.\n\n**Violation Validation**\nThe decoder verifies that all violations follow HDBn rules:\n- Violations must occur at precise intervals (every 3 or 4 zeros)\n- The polarity must alternate correctly from previous violations\n- Balance pulses (B) must properly offset the DC component\n\n**Error Detection System**\nThree distinct error conditions are monitored:\n1. **Pulse Errors**: Simultaneous P and N pulses (physically impossible in proper transmission)\n2. **Violation Errors**: Incorrect violation polarity or timing\n3. **Zero Count Errors**: Missing violations (too many consecutive zeros)\n\nThese checks provide robust monitoring of transmission line quality and protocol compliance.\n\n#### Configuration Parameters\n\n| Parameter             | Type    | Default | Description                                       |\n|-----------------------|---------|---------|---------------------------------------------------|\n| `encoder_type`        | integer | 3       | Select encoding type: 3 for HDB3, 2 for HDB2/B3ZS |\n| `pulse_active_state`  | logic   | 1'b1    | Defines active state of P and N signals           |\n\n#### I/O Port List\n\n| Port               | Direction | Description                                           |\n|--------------------|-----------|-------------------------------------------------------|\n| `reset_in`         | input     | Active high asynchronous reset signal                 |\n| `clk_in`           | input     | Input clock signal (rising-edge triggered)            |\n| `clk_enable_in`    | input     | Clock enable, active high                             |\n| `p_in`             | input     | Positive pulse input                                  |\n| `n_in`             | input     | Negative pulse input                                  |\n| `data_out`         | output    | Digital data output (active high)                     |\n| `code_error_out`   | output    | Error indicator output (active high on errors)        |\n\n## **3. Timing and Performance Characteristics**\nThe complete processing pipeline introduces predictable latency:\n- **Encoder**: 6 clock cycles (input sync + 5-stage processing)\n- **Decoder**: 6 clock cycles (input sync + 5-stage processing)\n\nThe critical timing path involves the violation detection and AMI toggling logic, which must complete within one clock cycle to maintain proper data alignment.\n\n## **4. Error Handling and Diagnostics**\nThe decoder's error detection provides valuable system diagnostics:\n- **CodeError_o** signals any protocol violation\n- Persistent errors indicate line quality issues\n- Specific error types help diagnose root causes:\n  * Violation errors suggest timing or synchronization problems\n  * Pulse errors indicate physical layer faults\n  * Zero count errors reveal missing violations\n\n\n"}, "patch": {"rtl/hdbn_decoder.sv": "", "rtl/hdbn_encoder.sv": "", "rtl/hdbn_top.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v -s\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/hdbn_top.sv /code/rtl/hdbn_encoder.sv /code/rtl/hdbn_decoder.sv \nTOPLEVEL        = hdbn_top\nMODULE          = test_hdbn_top\nPYTHONPATH      = /src\nHASH            = 2d02ffadf32fdd91f5a1dccbbbc21d479f812824\n", "src/test_hdbn_top.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n\nasync def initialize_dut(dut):\n    \"\"\"Reset and initialize DUT signals.\"\"\"\n    dut.reset_in.value = 1\n    dut.clk_enable_in.value = 0\n    dut.data_in.value = 0\n    dut.output_gate_in.value = 0\n    dut.p_in.value = 0\n    dut.n_in.value = 0\n\n    cocotb.start_soon(Clock(dut.clk_in, 488, units=\"ns\").start())\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    dut.reset_in.value = 0\n    dut.clk_enable_in.value = 1\n    dut.output_gate_in.value = 1\n\n    cocotb.log.info(\"[TB] DUT initialized\")\n\n\ndef generate_prbs15(shiftreg):\n    \"\"\"Generate next PRBS15 value.\"\"\"\n    feedback = not ((shiftreg >> 14) ^ (shiftreg >> 13)) & 1\n    shiftreg = ((shiftreg << 1) | feedback) & 0x7FFF\n    return shiftreg, (shiftreg >> 0) & 1\n\n\ndef get_expected_delayed_bit(shiftreg, encoder_type):\n    return (shiftreg >> (6 + 2 * encoder_type)) & 1\n\ndef get_expected_random_delayed_bit(buffer, index, encoder_type):\n    delay = 6 + 2 * encoder_type\n    if index >= delay:\n        return buffer[index - delay]\n    else:\n        return None  # Still in delay region\n\ndef update_dc_balance(p, n, pulse_active_state, running_sum):\n    \"\"\"Update the running DC balance sum.\"\"\"\n    if p == pulse_active_state:\n        running_sum += 1\n    elif n == pulse_active_state:\n        running_sum -= 1\n    return running_sum\n\n\ndef update_zero_count(p, n, pulse_active_state, zero_count):\n    \"\"\"Update the zero count.\"\"\"\n    if p == pulse_active_state or n == pulse_active_state:\n        return 0\n    else:\n        return zero_count + 1\n\n\ndef check_errors(cycle, decoded, expected, running_sum, zero_count,\n                 encoder_type, p, n, pulse_active_state, code_error):\n    \"\"\"Perform all error checks.\"\"\"\n    errors = 0\n\n    if running_sum >= 2 or running_sum <= -2:\n        cocotb.log.error(f\"[CHECK] Running Sum Error ({running_sum}) at cycle {cycle}\")\n        errors += 1\n\n    if p == pulse_active_state and n == pulse_active_state:\n        cocotb.log.error(f\"[CHECK] Simultaneous P and N Pulse Error at cycle {cycle}\")\n        errors += 1\n\n    if zero_count > encoder_type:\n        cocotb.log.error(f\"[CHECK] Long String Of Zeros ({zero_count}) at cycle {cycle}\")\n        errors += 1\n\n    if decoded != expected:\n        cocotb.log.error(f\"[CHECK] Decoder Bit Error: Expected {expected}, Got {decoded} at cycle {cycle}\")\n        errors += 1\n\n    if code_error != 0:\n        cocotb.log.error(f\"[CHECK] Decoder Code Error flag set at cycle {cycle}\")\n        errors += 1\n\n    return errors\n\n\n@cocotb.test()\nasync def hdbn_prbs15_test(dut):\n    \"\"\"\n    Full loopback test: PRBS source, encoder, loopback, decoder, error checking.\n    \"\"\"\n    # Constants\n    StartupTransient = 15000  # ns\n    clock_period_ns = 488\n\n    # Parameters from DUT\n    EncoderType = int(dut.encoder_type.value)\n    PulseActiveState = int(dut.pulse_active_state.value)\n\n    # Initialize state\n    RunningSum = 0\n    ZeroCount = 0\n    ErrorCount = 0\n    BitCount = 0\n    CorrectBits = 0\n    shiftreg = 0\n    total_time_ns = 0\n\n    await initialize_dut(dut)\n    cocotb.log.info(\"[TB] Starting full loopback test\")\n\n    for cycle in range(500):\n        # PRBS generation\n        shiftreg, input_bit = generate_prbs15(shiftreg)\n        expected_delayed = get_expected_delayed_bit(shiftreg, EncoderType)\n\n        # Drive encoder\n        dut.data_in.value = input_bit\n        await RisingEdge(dut.clk_in)\n\n        # Loopback\n        dut.p_in.value = dut.p_out.value.integer\n        dut.n_in.value = dut.n_out.value.integer\n\n        # Sample DUT outputs\n        p = int(dut.p_out.value)\n        n = int(dut.n_out.value)\n        decoded = int(dut.data_out.value)\n        code_error = int(dut.code_error_out.value)\n\n        # Update tracking\n        total_time_ns += clock_period_ns\n        BitCount += 1\n        RunningSum = update_dc_balance(p, n, PulseActiveState, RunningSum)\n        ZeroCount = update_zero_count(p, n, PulseActiveState, ZeroCount)\n\n        cocotb.log.info(\n            f\"[Cycle {cycle:03d}] input={input_bit} | p_out={p} n_out={n} | \"\n            f\"data_out={decoded} | code_err={code_error} | RunningSum={RunningSum}\"\n        )\n\n        # Error checks after transient period\n        if total_time_ns >= StartupTransient:\n            errors = check_errors(\n                cycle, decoded, expected_delayed, RunningSum, ZeroCount,\n                EncoderType, p, n, PulseActiveState, code_error\n            )\n            ErrorCount += errors\n            if errors == 0:\n                CorrectBits += 1\n\n    # Final report\n    cocotb.log.info(\"\\n[TB] Loopback Simulation Results:\")\n    cocotb.log.info(f\"[TB] Total bits processed: {BitCount}\")\n    cocotb.log.info(f\"[TB] Correctly decoded bits: {CorrectBits} ({(100.0*CorrectBits)/BitCount:.2f}%)\")\n    cocotb.log.info(f\"[TB] Total errors detected: {ErrorCount}\")\n\n    assert ErrorCount == 0, f\"Loopback test failed with {ErrorCount} errors.\"\n\n\n@cocotb.test()\nasync def hdbn_random_parallel_test(dut):\n    \"\"\"\n    Loopback test using random 500-bit data.\n    Serializes input, loopbacks encoded signal, parallelizes decoder output.\n    Compares decoded data with expected delayed input.\n    \"\"\"\n    EncoderType = int(dut.encoder_type.value)\n    PulseActiveState = int(dut.pulse_active_state.value)\n    clock_period_ns = 488\n    StartupTransient = 15000\n\n    await initialize_dut(dut)\n    cocotb.log.info(\"[TB] Starting parallel random data loopback test\")\n\n    # Generate 500-bit random binary data\n    test_bits = [random.randint(0, 1) for _ in range(500)]\n    decoded_bits = []\n    total_time_ns = 0\n    ErrorCount = 0\n\n    for i, bit in enumerate(test_bits):\n        dut.data_in.value = bit\n\n        await RisingEdge(dut.clk_in)\n\n        # Loopback\n        dut.p_in.value = dut.p_out.value.integer\n        dut.n_in.value = dut.n_out.value.integer\n\n        total_time_ns += clock_period_ns\n\n        decoded = int(dut.data_out.value)\n        decoded_bits.append(decoded)\n\n        expected = get_expected_random_delayed_bit(test_bits, i, EncoderType)\n\n        cocotb.log.info(\n            f\"[Cycle {i:03d}] input={bit} | decoded={decoded} | expected={expected} | \"\n            f\"p_out={int(dut.p_out.value)} n_out={int(dut.n_out.value)}\"\n        )\n\n        if expected is not None and total_time_ns > StartupTransient:\n            if decoded != expected:\n                cocotb.log.error(\n                    f\"[CHECK] Decoder Bit Error at index {i}: Expected {expected}, Got {decoded}\"\n                )\n                ErrorCount += 1\n\n            if int(dut.code_error_out.value) != 0:\n                cocotb.log.error(f\"[CHECK] Decoder Code Error flag set at cycle {i}\")\n                ErrorCount += 1\n\n    cocotb.log.info(\"\\n[TB] Random Parallel Test Results:\")\n    cocotb.log.info(f\"[TB] Total bits tested: {len(test_bits)}\")\n    cocotb.log.info(f\"[TB] Total errors detected: {ErrorCount}\")\n\n    assert ErrorCount == 0, f\"Random parallel loopback test failed with {ErrorCount} errors.\"\n\n@cocotb.test()\nasync def hdbn_reset_behavior_test(dut):\n    \"\"\"\n    Verifies that the DUT resets correctly: outputs clear, decoder resets, and normal operation resumes.\n    \"\"\"\n    clock_period_ns = 488\n    EncoderType = int(dut.encoder_type.value)\n    PulseActiveState = int(dut.pulse_active_state.value)\n\n    await initialize_dut(dut)\n    cocotb.log.info(\"[TB] Starting reset behavior test\")\n\n    # Step 1: Send a few bits normally\n    dut.data_in.value = 1\n    for _ in range(5):\n        await RisingEdge(dut.clk_in)\n        dut.p_in.value = dut.p_out.value.integer\n        dut.n_in.value = dut.n_out.value.integer\n\n    cocotb.log.info(\"[TB] DUT operating normally, applying reset now...\")\n\n    # Step 2: Assert reset mid-operation\n    dut.reset_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    # Step 3: Check outputs are reset/cleared\n    data_out = int(dut.data_out.value)\n    code_err = int(dut.code_error_out.value)\n    p = int(dut.p_out.value)\n    n = int(dut.n_out.value)\n\n    cocotb.log.info(\n        f\"[TB] After reset: data_out={data_out}, code_error_out={code_err}, \"\n        f\"p_out={p}, n_out={n}\"\n    )\n\n    assert data_out in (0, 1), \"data_out should be valid after reset (some decoders may default to 0)\"\n    assert code_err == 0, \"code_error_out should not be cleared on reset\"\n    # Optionally: assert p/n go to 0 if known behavior\n    # assert p == 0 and n == 0, \"p_out and n_out should be low on reset\"\n\n    # Step 4: Deassert reset and resume operation\n    dut.reset_in.value = 0\n    dut.data_in.value = 1\n\n    for _ in range(10):\n        await RisingEdge(dut.clk_in)\n        dut.p_in.value = dut.p_out.value.integer\n        dut.n_in.value = dut.n_out.value.integer\n\n    cocotb.log.info(\"[TB] DUT resumed operation after reset\")\n\n    # Step 5: Confirm output is valid again\n    resumed_data_out = int(dut.data_out.value)\n    resumed_code_err = int(dut.code_error_out.value)\n\n    assert resumed_code_err == 1, \"code_error_out should be HIGH Initially after reset if input is valid\"\n    cocotb.log.info(f\"[TB] Resumed data_out={resumed_data_out}, code_error_out={resumed_code_err}\")\n\n@cocotb.test()\nasync def hdbn_encoder_only_test(dut):\n    \"\"\"\n    Encoder-only test: Provide known input bits, wait for encoder latency, and observe p_out/n_out.\n    Checks for illegal simultaneous pulses and logs outputs aligned with input.\n    \"\"\"\n    await initialize_dut(dut)\n    cocotb.log.info(\"[TB] Starting encoder-only test (7-cycle latency aware)\")\n\n    PulseActiveState = int(dut.pulse_active_state.value)\n    latency = 7\n\n    # Input pattern (known simple sequence)\n    input_bits = [0, 1, 0, 1, 1, 0, 0, 1, 1, 0]\n    delayed_input = []\n\n    for cycle, bit in enumerate(input_bits):\n        dut.data_in.value = bit\n        await RisingEdge(dut.clk_in)\n\n        # Track input bits for output comparison post-latency\n        delayed_input.append(bit)\n\n        if len(delayed_input) >= latency:\n            aligned_input = delayed_input.pop(0)\n            p = int(dut.p_out.value)\n            n = int(dut.n_out.value)\n\n            cocotb.log.info(\n                f\"[Cycle {cycle}] input={aligned_input} | p_out={p} | n_out={n}\"\n            )\n\n            # Protocol check: p and n should not be high at the same time\n            if p == PulseActiveState and n == PulseActiveState:\n                cocotb.log.error(\n                    f\"[ENC] Invalid: Both P and N active at cycle {cycle}\"\n                )\n                assert False, f\"Encoder violation at cycle {cycle}: both p_out and n_out are high\"\n\n    cocotb.log.info(\"[TB] Encoder-only test passed.\")\n\n@cocotb.test()\nasync def hdbn_decoder_only_test(dut):\n    \"\"\"\n    Decoder-only test: Feed known p/n pulses, verify data_out after 7-cycle latency.\n    \"\"\"\n    await initialize_dut(dut)\n    cocotb.log.info(\"[TB] Starting decoder-only test (7-cycle latency aware)\")\n\n    PulseActiveState = int(dut.pulse_active_state.value)\n\n    # Format: (p_in, n_in, expected_data)\n    input_sequence = [\n        (1, 0, 1),\n        (0, 0, 0),\n        (0, 1, 1),\n        (0, 0, 0),\n        (0, 0, 0),\n        (1, 0, 1),\n        (0, 0, 0),\n        (0, 0, 1),\n    ]\n\n    latency = 6\n    expected_fifo = []\n\n    for cycle, (p_in, n_in, expected_data) in enumerate(input_sequence):\n        dut.p_in.value = p_in\n        dut.n_in.value = n_in\n        dut.data_in.value = 0  # unused\n        await RisingEdge(dut.clk_in)\n\n        # Push expected value into latency FIFO\n        expected_fifo.append(expected_data)\n\n        # Check output if we're past the latency window\n        if len(expected_fifo) >= latency:\n            expected = expected_fifo.pop(0)\n            actual = int(dut.data_out.value)\n            code_err = int(dut.code_error_out.value)\n\n            cocotb.log.info(\n                f\"[Cycle {cycle}] p_in={p_in} n_in={n_in} | data_out={actual} | expected={expected} | code_err={code_err}\"\n            )\n\n            if actual != expected:\n                cocotb.log.error(f\"[DEC] Bit mismatch at cycle {cycle}: Expected {expected}, got {actual}\")\n                assert False, \"Decoder output mismatch\"\n\n            if code_err != 0:\n                cocotb.log.error(f\"[DEC] Unexpected code error at cycle {cycle}\")\n                assert False, \"Decoder raised unexpected error\"\n\n    cocotb.log.info(\"[TB] Decoder-only test passed.\")\n\n\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n# Runner to execute tests\ndef test_runner():\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\nif __name__ == \"__main__\":\n    test_runner()\n", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v -s'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_jpeg_runlength_enc_0001", "categories": ["cid005", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Integrate a JPEG run-length encoder consisting of a **run-length stage module (`jpeg_runlength_stage1`)** and a **zero-run suppression module (`jpeg_runlength_rzs`)**, and implement a top-level pipelined encoder at **`rtl/jpeg_runlength_enc.sv`**. The design must follow the JPEG compression protocol and stream over 8\u00d78 DCT coefficient blocks. All module behavior must strictly conform to the design rules and compression behavior defined in **`docs/specification.md`**.\n\nUse the following steps for module integration:\n\n- Implement the **run-length stage** in `rtl/jpeg_runlength_stage1.sv` and **zero-run suppression stage** in `rtl/jpeg_runlength_rzs.sv`.\n  - Run-length encoding stage module must detect and distinguish between DC and AC terms, maintain a sample counter for 8\u00d78 block traversal, track zero run-lengths, compute coefficient category (bit size), format the amplitude accordingly, and assert valid output and DC indicators for downstream processing.\n  - Zero-run suppression stage module must suppress repeated zero-blocks (run-length = 15, size = 0) using a compact FSM, emit an End-of-Block (EOB) marker when applicable, and ensure proper sequencing of run-length, size, amplitude, and control signals through the pipeline.\n\n- Integrate the full encoding pipeline in the top-level module at `rtl/jpeg_runlength_enc.sv`, connecting the stage-1 run-length encoder(`jpeg_runlength_stage1`) to **four cascaded zero-run suppression stages(`jpeg_runlength_rzs`)**. The top-level module must manage pipeline control (clock/reset/enable), accept incoming 12-bit DCT data, and emit the final encoded run-length, size, amplitude, and control flags with full JPEG compliance.\n", "context": {"docs/specification.md": "# **JPEG Run-Length Encoder Specification Document**\n\n## **1. Overview**\n\nThis document describes the design and function of a JPEG-compliant run-length encoder that processes 12-bit quantized DCT coefficients from 8x8 image blocks. The encoder operates in a pipelined fashion and produces output triples of (Run-Length, Size, Amplitude), conforming to JPEG's entropy encoding requirements. \n\nThe architecture features a dedicated initial stage for coefficient analysis and four subsequent zero-run suppression stages. This structured pipeline reduces redundancy in AC coefficient sequences and simplifies downstream Huffman encoding.\n\n\n## **2. Top-Level Module: `jpeg_runlength_enc`**\n\n### **Function**\nThe `jpeg_runlength_enc` module manages the full pipeline, receiving serialized DCT coefficients and outputting encoded data along with flags indicating output validity and DC term presence.\n\nIt connects five submodules in a sequential pipeline. The first submodule (`jpeg_runlength_stage1`) performs coefficient classification and initial encoding. The outputs of this stage \u2014 namely the encoded run-length, size category, amplitude, data-valid flag, and DC-term flag \u2014 are then passed through four identical suppression stages (`jpeg_runlength_rzs`). Each suppression stage refines the run-length output by collapsing sequences of maximum-length zero blocks, a common pattern in JPEG AC coefficients.\n\nAll submodules operate synchronously under the same clock, reset, and enable signals. The `dstrb_in` signal is used only by the first stage to detect the start of a new block. The final stage outputs the final encoded (R, S, A) values, as well as the validity and DC term indicators.\n\n### **IO Ports**\n\n| Port Name     | Direction | Width | Description                                                              |\n|---------------|-----------|-------|--------------------------------------------------------------------------|\n| `clk_in`      | input     | 1     | System clock, positive edge triggered.                                   |\n| `reset_in`    | input     | 1     | Synchronous active-high reset.                                           |\n| `enable_in`   | input     | 1     | Clock enable for gated operation.                                        |\n| `dstrb_in`    | input     | 1     | Data strobe to initiate encoding of a new 8x8 block.                     |\n| `din_in`      | input     | 12    | Signed 12-bit DCT coefficient input.                                     |\n| `rlen_out`    | output    | 4     | Encoded run-length of zeros preceding a non-zero coefficient.            |\n| `size_out`    | output    | 4     | Size category representing bit width needed to encode the amplitude.     |\n| `amp_out`     | output    | 12    | Adjusted coefficient amplitude.                                          |\n| `douten_out`  | output    | 1     | Data output valid signal.                                                |\n| `bstart_out`  | output    | 1     | High when output corresponds to the DC coefficient of a new block.       |\n\n\n## **3. Submodule Descriptions**\n\n### **3.1 Coefficient Analysis Stage (`jpeg_runlength_stage1`)**\n\n#### **Function**\nThis module identifies and encodes the DC and AC coefficients of a JPEG block. It uses the `dstrb_in` signal to detect the start of a block and to classify the first coefficient as the DC term.\n\n- For the **DC coefficient** (first input after `dstrb_in` is high), it outputs a zero run-length and calculates the size category based on the number of bits required to encode the absolute value of the coefficient. The coefficient is also amplitude-adjusted to match JPEG encoding conventions, preserving the sign and offsetting the value as required.\n\n- For **AC coefficients**, the module tracks sequences of zero-valued inputs. When a non-zero coefficient is detected, it emits the count of preceding zeros as the run-length and calculates the size and amplitude of the current coefficient. If 15 consecutive zeros are encountered, the module emits a special run-length code and resets the count. It also detects the end of block condition when the final coefficient is received and emits an End-of-Block marker if the value is zero.\n\nThe output includes the encoded run-length, size, and amplitude fields, a flag indicating data validity, and a flag identifying the DC term.\n\n#### **Ports**\n\n| Port Name     | Direction | Width | Description                                                          |\n|---------------|-----------|-------|----------------------------------------------------------------------|\n| `clk_in`      | input     | 1     | System clock.                                                        |\n| `reset_in`    | input     | 1     | Synchronous reset.                                                   |\n| `enable_in`   | input     | 1     | Clock enable.                                                        |\n| `go_in`       | input     | 1     | Indicates start of a new block.                                      |\n| `din_in`      | input     | 12    | DCT coefficient input.                                               |\n| `rlen_out`    | output    | 4     | Run-length of zeros before a non-zero coefficient.                   |\n| `size_out`    | output    | 4     | Bit size needed to represent the coefficient.                        |\n| `amp_out`     | output    | 12    | JPEG-compliant adjusted amplitude.                                   |\n| `den_out`     | output    | 1     | Output valid indicator.                                              |\n| `dcterm_out`  | output    | 1     | High when output is the DC coefficient.                              |\n\n\n\n### **3.2 Zero-Run Suppression Stage (`jpeg_runlength_rzs`)**\n\n#### **Function**\nThis module filters out redundant zero-block outputs (e.g., `(15, 0)` pairs) which frequently appear in JPEG AC data. Each instance of this module receives encoded data from a previous stage and decides whether to pass it on or suppress it.\n\n- When a `(15, 0)` encoded value is received (meaning 15 consecutive zeros), it may suppress this value if it is part of a longer zero run.\n- If a non-zero coefficient follows one or more `(15, 0)` entries, the module re-emits a single `(15, 0)` followed by the new data.\n- If an End-of-Block marker `(0, 0)` is detected, it is always passed through to indicate block completion.\n\nEach stage independently maintains suppression state, which allows efficient filtering of long runs in a distributed and pipelined fashion.\n\nThese stages collectively improve compression efficiency by minimizing redundant entries and reducing the size of the output stream.\n\n#### **Ports**\n\n| Port Name     | Direction | Width | Description                                                           |\n|---------------|-----------|-------|-----------------------------------------------------------------------|\n| `clk_in`      | input     | 1     | System clock.                                                         |\n| `reset_in`    | input     | 1     | Synchronous reset.                                                    |\n| `enable_in`   | input     | 1     | Clock enable.                                                         |\n| `rlen_in`     | input     | 4     | Input run-length.                                                     |\n| `size_in`     | input     | 4     | Input size category.                                                  |\n| `amp_in`      | input     | 12    | Input amplitude.                                                      |\n| `den_in`      | input     | 1     | Input data valid signal.                                              |\n| `dc_in`       | input     | 1     | Input flag: high if DC coefficient.                                   |\n| `rlen_out`    | output    | 4     | Filtered run-length output.                                           |\n| `size_out`    | output    | 4     | Filtered size output.                                                 |\n| `amp_out`     | output    | 12    | Filtered amplitude output.                                            |\n| `den_out`     | output    | 1     | Output valid flag.                                                    |\n| `dc_out`      | output    | 1     | Output DC flag.                                                       |\n\n\n\n## **4. Pipeline and Latency Characteristics**\n\nThe encoder operates as a 5-stage synchronous pipeline:\n- Stage 1: Coefficient analysis\n- Stages 2\u20135: Zero-run suppression\n\nWith continuous valid input and `enable_in` asserted, the module produces one encoded output every cycle after a pipeline fill latency of 5 cycles.\n\n- **Latency**: 5 clock cycles from `din_in` to `rlen_out/size_out/amp_out`\n\n"}, "patch": {"rtl/jpeg_runlength_enc.sv": "", "rtl/jpeg_runlength_rzs.sv": "", "rtl/jpeg_runlength_stage1.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v -s\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/jpeg_runlength_enc.sv /code/rtl/jpeg_runlength_rzs.sv /code/rtl/jpeg_runlength_stage1.sv \nTOPLEVEL        = jpeg_runlength_enc\nMODULE          = test_jpeg_runlength_enc\nPYTHONPATH      = /src\nHASH            = 115908b1dd98c06c52224d613f8335d15a106181\n", "src/test_jpeg_runlength_enc.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nimport math\n\nclass JPEGRLEReference:\n    \"\"\"Reference model for JPEG Run-Length Encoding (RLE) behavior\"\"\"\n    def __init__(self):\n        self.zero_run = 0      # Current count of consecutive zeros\n        self.block_pos = 0     # Position in current block (0-63)\n        self.block_size = 64   # JPEG block size (8x8)\n        self.debug = True      # Debug print enable\n    \n    def process_sample(self, sample, is_block_start):\n        \"\"\"Process a single sample through the reference model\"\"\"\n        outputs = []\n        \n        if is_block_start:\n            # DC term processing (must be first in block)\n            if self.debug:\n                print(f\"\\n[REF] BLOCK START: DC = {sample}\")\n            self.block_pos = 0\n            self.zero_run = 0\n            size = self.get_size(sample)\n            outputs.append((0, size, sample, True))  # (rlen, size, amp, is_dc)\n        else:\n            # AC term processing\n            self.block_pos += 1\n            if self.debug:\n                print(f\"[REF] AC #{self.block_pos}: Input = {sample}, Zero Run = {self.zero_run}\")\n            \n            if sample == 0:\n                self.zero_run += 1\n                if self.zero_run == 16:\n                    # Emit Zero Run Length (ZRL) marker (15,0)\n                    if self.debug:\n                        print(\"[REF] Emitting ZRL (15,0,0)\")\n                    outputs.append((15, 0, 0, False))\n                    self.zero_run = 0\n            else:\n                # Emit pending zeros followed by current non-zero value\n                if self.zero_run > 0:\n                    size = self.get_size(sample)\n                    if self.debug:\n                        print(f\"[REF] Emitting (rlen={self.zero_run}, size={size}, amp={sample})\")\n                    outputs.append((self.zero_run, size, sample, False))\n                    self.zero_run = 0\n                else:\n                    # Immediate non-zero value\n                    size = self.get_size(sample)\n                    if self.debug:\n                        print(f\"[REF] Emitting (rlen=0, size={size}, amp={sample})\")\n                    outputs.append((0, size, sample, False))\n            \n            # Check for End-of-Block (EOB)\n            if self.block_pos == self.block_size - 1 and self.zero_run > 0:\n                if self.debug:\n                    print(\"[REF] Emitting EOB (0,0,0)\")\n                outputs.append((0, 0, 0, False))  # EOB marker\n        \n        return outputs\n    \n    def get_size(self, value):\n        \"\"\"Calculate the size/category for a given value\"\"\"\n        abs_val = abs(value)\n        return math.ceil(math.log2(abs_val + 1)) if abs_val != 0 else 0\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT with proper reset sequence\"\"\"\n    dut.reset_in.value = 1\n    dut.enable_in.value = 0\n    dut.dstrb_in.value = 0\n    dut.din_in.value = 0\n\n    # Start clock generator\n    cocotb.start_soon(Clock(dut.clk_in, 10, units=\"ns\").start())\n\n    # Wait for two clock edges\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    # Activate reset and enable\n    dut.reset_in.value = 0\n    dut.enable_in.value = 1\n\n    await RisingEdge(dut.clk_in)\n    print(\"\\n[TB] DUT initialized\\n\")\n\nasync def apply_input(dut, sample, is_block_start):\n    \"\"\"Apply input to DUT and print debug info\"\"\"\n    print(f\"[IN] {'DC' if is_block_start else 'AC'}: {sample} (dstrb_in={1 if is_block_start else 0})\")\n    dut.din_in.value = sample\n    dut.dstrb_in.value = 1 if is_block_start else 0\n    await RisingEdge(dut.clk_in)\n    dut.dstrb_in.value = 0\n\nasync def verify_output(dut, expected, test_case, cycle):\n    \"\"\"Verify DUT output against expected values\"\"\"\n    if dut.douten_out.value == 1:\n        actual = (\n            int(dut.rlen_out.value),\n            int(dut.size_out.value),\n            int(dut.amp_out.value.signed_integer),\n            bool(dut.bstart_out.value)\n        )\n        \n        print(f\"\\n[TEST {test_case}.{cycle}] OUTPUT COMPARISON:\")\n        print(\"=\"*50)\n        print(f\"[ACTUAL]   rlen={actual[0]}, size={actual[1]}, amp={actual[2]}, bstart={actual[3]}\")\n        print(f\"[EXPECTED] rlen={expected[0]}, size={expected[1]}, amp={expected[2]}, bstart={expected[3]}\")\n        print(\"=\"*50)\n        \n        assert actual == expected, f\"Test {test_case}.{cycle} failed: Expected {expected}, got {actual}\"\n        return True\n    return False\n\n# =============================================================================\n# Test Case 1: Basic Functional Test\n# =============================================================================\n@cocotb.test()\nasync def test_basic_functionality(dut):\n    \"\"\"Test basic functionality with mixed coefficients\"\"\"\n    await initialize_dut(dut)\n    ref_model = JPEGRLEReference()\n    \n    print(f\"\\n{'='*60}\")\n    print(\"TEST CASE 1: Basic block with mixed coefficients\")\n    print(f\"{'='*60}\\n\")\n    \n    # DC term\n    sample = 42\n    expected_outputs = ref_model.process_sample(sample, True)\n    await apply_input(dut, sample, True)\n    await verify_output(dut, expected_outputs[0], 1, 1)\n    \n    # AC terms\n    samples = [0, 0, 15, 0, 127] + [0]*59\n    for i, sample in enumerate(samples, 2):  # Start counting from 2 (after DC)\n        expected_outputs = ref_model.process_sample(sample, False)\n        await apply_input(dut, sample, False)\n        \n        for expected in expected_outputs:\n            if await verify_output(dut, expected, 1, i):\n                await RisingEdge(dut.clk_in)\n\n# =============================================================================\n# Test Case 2: Zero Run Length (ZRL) Handling\n# =============================================================================\n@cocotb.test()\nasync def test_zrl_handling(dut):\n    \"\"\"Test Zero Run Length (15,0) sequences\"\"\"\n    await initialize_dut(dut)\n    ref_model = JPEGRLEReference()\n    \n    print(f\"\\n{'='*60}\")\n    print(\"TEST CASE 2: Block with Zero Run Length (ZRL)\")\n    print(f\"{'='*60}\\n\")\n    \n    # DC term\n    sample = 128\n    expected_outputs = ref_model.process_sample(sample, True)\n    await apply_input(dut, sample, True)\n    await verify_output(dut, expected_outputs[0], 2, 1)\n    \n    # 16 zeros (should produce ZRL:15,0)\n    samples = [0]*16 + [255] + [0]*47\n    for i, sample in enumerate(samples, 2):\n        expected_outputs = ref_model.process_sample(sample, False)\n        await apply_input(dut, sample, False)\n        \n        for expected in expected_outputs:\n            if await verify_output(dut, expected, 2, i):\n                await RisingEdge(dut.clk_in)\n\n# =============================================================================\n# Test Case 3: End-of-Block (EOB) Handling\n# =============================================================================\n@cocotb.test()\nasync def test_eob_handling(dut):\n    \"\"\"Test End-of-Block (0,0) marker generation\"\"\"\n    await initialize_dut(dut)\n    ref_model = JPEGRLEReference()\n    \n    print(f\"\\n{'='*60}\")\n    print(\"TEST CASE 3: All zeros after DC (EOB only)\")\n    print(f\"{'='*60}\\n\")\n    \n    # DC term\n    sample = 64\n    expected_outputs = ref_model.process_sample(sample, True)\n    await apply_input(dut, sample, True)\n    await verify_output(dut, expected_outputs[0], 3, 1)\n    \n    # All zeros (should produce EOB immediately)\n    samples = [0]*63\n    for i, sample in enumerate(samples, 2):\n        expected_outputs = ref_model.process_sample(sample, False)\n        await apply_input(dut, sample, False)\n        \n        for expected in expected_outputs:\n            if await verify_output(dut, expected, 3, i):\n                await RisingEdge(dut.clk_in)\n\n# =============================================================================\n# Test Case 4: Negative Coefficient Handling\n# =============================================================================\n@cocotb.test()\nasync def test_negative_coefficients(dut):\n    \"\"\"Test negative coefficient handling\"\"\"\n    await initialize_dut(dut)\n    ref_model = JPEGRLEReference()\n    \n    print(f\"\\n{'='*60}\")\n    print(\"TEST CASE 4: Negative coefficients\")\n    print(f\"{'='*60}\\n\")\n    \n    # DC term (must be positive)\n    sample = 64\n    expected_outputs = ref_model.process_sample(sample, True)\n    await apply_input(dut, sample, True)\n    await verify_output(dut, expected_outputs[0], 4, 1)\n    \n    # AC terms with negative values\n    samples = [-5, 0, 0, -12, -25, 0, -3] + [0]*57\n    for i, sample in enumerate(samples, 2):\n        expected_outputs = ref_model.process_sample(sample, False)\n        await apply_input(dut, sample, False)\n        \n        for expected in expected_outputs:\n            if await verify_output(dut, expected, 4, i):\n                await RisingEdge(dut.clk_in)\n\n# =============================================================================\n# Test Case 5: Multiple ZRL Sequences\n# =============================================================================\n@cocotb.test()\nasync def test_multiple_zrl_sequences(dut):\n    \"\"\"Test multiple Zero Run Length sequences in one block\"\"\"\n    await initialize_dut(dut)\n    ref_model = JPEGRLEReference()\n    \n    print(f\"\\n{'='*60}\")\n    print(\"TEST CASE 5: Multiple ZRL sequences\")\n    print(f\"{'='*60}\\n\")\n    \n    # DC term\n    sample = 100\n    expected_outputs = ref_model.process_sample(sample, True)\n    await apply_input(dut, sample, True)\n    await verify_output(dut, expected_outputs[0], 5, 1)\n    \n    # Create multiple ZRL sequences (16+ zeros) with values in between\n    samples = [0]*20 + [5] + [0]*18 + [10] + [0]*24\n    for i, sample in enumerate(samples, 2):\n        expected_outputs = ref_model.process_sample(sample, False)\n        await apply_input(dut, sample, False)\n        \n        for expected in expected_outputs:\n            if await verify_output(dut, expected, 5, i):\n                await RisingEdge(dut.clk_in)\n\n# =============================================================================\n# Test Case 6: Consecutive ZRL and Single Non-Zero\n# =============================================================================\n@cocotb.test()\nasync def test_consecutive_zrl(dut):\n    \"\"\"Test consecutive ZRL sequences with single non-zero\"\"\"\n    await initialize_dut(dut)\n    ref_model = JPEGRLEReference()\n    \n    print(f\"\\n{'='*60}\")\n    print(\"TEST CASE 6: Consecutive ZRL and single non-zero\")\n    print(f\"{'='*60}\\n\")\n    \n    # DC term\n    sample = -32\n    expected_outputs = ref_model.process_sample(sample, True)\n    await apply_input(dut, sample, True)\n    await verify_output(dut, expected_outputs[0], 6, 1)\n    \n    # 32 zeros (should produce two ZRLs)\n    samples = [0]*32 + [10] + [0]*31\n    for i, sample in enumerate(samples, 2):\n        expected_outputs = ref_model.process_sample(sample, False)\n        await apply_input(dut, sample, False)\n        \n        for expected in expected_outputs:\n            if await verify_output(dut, expected, 6, i):\n                await RisingEdge(dut.clk_in)\n\n# =============================================================================\n# Test Case 7: Large Negative DC with All Zeros\n# =============================================================================\n@cocotb.test()\nasync def test_large_negative_dc(dut):\n    \"\"\"Test large negative DC coefficient with all zero AC\"\"\"\n    await initialize_dut(dut)\n    ref_model = JPEGRLEReference()\n    \n    print(f\"\\n{'='*60}\")\n    print(\"TEST CASE 7: Large negative DC with all zeros\")\n    print(f\"{'='*60}\\n\")\n    \n    # DC term\n    sample = -2047\n    expected_outputs = ref_model.process_sample(sample, True)\n    await apply_input(dut, sample, True)\n    await verify_output(dut, expected_outputs[0], 7, 1)\n    \n    # All zeros (should produce EOB)\n    samples = [0]*63\n    for i, sample in enumerate(samples, 2):\n        expected_outputs = ref_model.process_sample(sample, False)\n        await apply_input(dut, sample, False)\n        \n        for expected in expected_outputs:\n            if await verify_output(dut, expected, 7, i):\n                await RisingEdge(dut.clk_in)\n\n\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n# Runner to execute tests\ndef test_runner():\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\nif __name__ == \"__main__\":\n    test_runner()\n", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v -s'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_low_power_channel_0001", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I need to implement a **low-power communication channel** that efficiently manages **data transfer, wakeup control, and Q-channel handshaking**. The **`low_power_channel.sv`** module needs to integrate a **synchronous FIFO (`sync_fifo.sv`) for buffering writes** and a **control unit (`low_power_ctrl.sv`) for managing data flow and power states**. The system should properly handle **FIFO overflow/underflow, wakeup signals, and flush operations** while ensuring minimal power consumption.  \n\nI have the **FIFO module at `/code/rtl/sync_fifo.sv`** and the **control unit at `/code/rtl/low_power_ctrl.sv`**, and I need to create the **top-level module `/code/rtl/low_power_channel.sv`** that correctly integrates them. The module should **instantiate and connect the FIFO and control logic**, implement **Q-channel signaling (`qreqn`, `qacceptn`, `qactive`)**, and handle **read/write transactions** efficiently. To verify functionality, a testbench is available at **`/code/verif/tb_low_power_channel.sv`**. The final implementation should ensure **proper synchronization, low-latency operation, and power efficiency**\n", "context": {"rtl/low_power_ctrl.sv": "module low_power_ctrl (\n  // Clock/Reset\n  input  logic        clk,\n  input  logic        reset,\n\n  // Wakeup input\n  input  logic        if_wakeup_i,\n\n  // FIFO statuses\n  input  logic        wr_fifo_full,\n  input  logic        wr_fifo_empty,\n\n  // Write/Read requests\n  input  logic        wr_valid_i,\n  input  logic        rd_valid_i,\n\n  // Upstream flush interface\n  input  logic        wr_done_i,\n  output logic        wr_flush_o,\n\n  // Q-channel interface\n  input  logic        qreqn_i,\n  output logic        qacceptn_o,\n  output logic        qactive_o,\n\n  // FIFO push/pop controls\n  output logic        wr_fifo_push,\n  output logic        wr_fifo_pop\n);\n\n  // --------------------------------------------------------\n  // Internal signals\n  // --------------------------------------------------------\n  typedef enum logic [1:0] {\n    ST_Q_RUN      = 2'b00,\n    ST_Q_REQUEST  = 2'b01,\n    ST_Q_STOPPED  = 2'b10,\n    ST_Q_EXIT     = 2'b11\n  } state_t;\n\n  state_t state_q, nxt_state;\n\n  logic   nxt_qactive;\n  logic   qactive_q;\n\n  logic   nxt_qaccept;\n  logic   nxt_qacceptn;\n  logic   qacceptn_en;\n  logic   qacceptn_q;\n\n  // --------------------------------------------------------\n  // Gate writes/reads based on FIFO full/empty\n  // --------------------------------------------------------\n  // The same lines from your original code, but now in the control module:\n  assign wr_fifo_push = wr_valid_i & ~wr_fifo_full;\n  assign wr_fifo_pop  = rd_valid_i & ~wr_fifo_empty;\n\n  // --------------------------------------------------------\n  // QACTIVE signal (same logic as original)\n  // --------------------------------------------------------\n  // Next-cycle active if the FIFO has data, or a new valid read/write\n  assign nxt_qactive = (~wr_fifo_empty) | wr_valid_i | rd_valid_i;\n\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset)\n      qactive_q <= 1'b0;\n    else\n      qactive_q <= nxt_qactive;\n  end\n\n  assign qactive_o = qactive_q | if_wakeup_i;\n\n  // --------------------------------------------------------\n  // State Machine\n  // --------------------------------------------------------\n  always_comb begin\n    nxt_state = state_q;\n    case (state_q)\n      ST_Q_RUN:\n        if (~qreqn_i)\n          nxt_state = ST_Q_REQUEST;\n\n      ST_Q_REQUEST:\n        // The design goes to ST_Q_STOPPED once we accept => qacceptn=0\n        if (~qacceptn_q)\n          nxt_state = ST_Q_STOPPED;\n\n      ST_Q_STOPPED:\n        // The design goes to ST_Q_EXIT once qreqn_i=1 again\n        if (qreqn_i)\n          nxt_state = ST_Q_EXIT;\n\n      ST_Q_EXIT:\n        // Return to ST_Q_RUN when qacceptn=1\n        if (qacceptn_q)\n          nxt_state = ST_Q_RUN;\n    endcase\n  end\n\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset)\n      state_q <= ST_Q_RUN;\n    else\n      state_q <= nxt_state;\n  end\n\n  // --------------------------------------------------------\n  // Flush Control (combinational)\n  // --------------------------------------------------------\n  // The original requirement: wr_flush_o=1 in ST_Q_REQUEST if wr_done_i=0,\n  // then remain high until wr_done_i=1.\n  assign wr_flush_o = (state_q == ST_Q_REQUEST) & (~wr_done_i);\n\n  // --------------------------------------------------------\n  // QACCEPTn logic\n  // --------------------------------------------------------\n  // Accept once FIFO is empty + wr_done_i=1 + qreqn_i=0 => qaccept=1 => qacceptn=0\n  // Then remain in ST_Q_STOPPED until qreqn_i reasserts => ST_Q_EXIT => eventually qacceptn=1 => ST_Q_RUN\n  assign nxt_qaccept  = (wr_done_i & wr_fifo_empty & ~qreqn_i);\n  assign nxt_qacceptn = ~nxt_qaccept;\n\n  // Enable capturing qacceptn in ST_Q_REQUEST or ST_Q_EXIT\n  assign qacceptn_en = (state_q == ST_Q_REQUEST) | (state_q == ST_Q_EXIT);\n\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset)\n      qacceptn_q <= 1'b1;\n    else if (qacceptn_en)\n      qacceptn_q <= nxt_qacceptn;\n  end\n\n  assign qacceptn_o = qacceptn_q;\n\nendmodule", "rtl/sync_fifo.sv": "module sync_fifo #(\n  parameter DEPTH   = 8,  // Must be power-of-two for ring-pointer indexing\n  parameter DATA_W  = 8\n)(\n  input  wire              clk,\n  input  wire              reset,\n\n  input  wire              push_i,\n  input  wire [DATA_W-1:0] push_data_i,\n\n  input  wire              pop_i,\n  output wire [DATA_W-1:0] pop_data_o,\n\n  output wire              full_o,\n  output wire              empty_o\n);\n\n  localparam PTR_W = $clog2(DEPTH);\n\n  logic [PTR_W:0] rd_ptr_q, nxt_rd_ptr;\n  logic [PTR_W:0] wr_ptr_q, nxt_wr_ptr;\n\n  // Memory array of size DEPTH=8\n  logic [DATA_W-1:0] fifo_mem [0:DEPTH-1];\n  logic [DATA_W-1:0] fifo_pop_data;\n\n  assign pop_data_o = fifo_pop_data;\n\n  // Pointer flops\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n      rd_ptr_q <= '0;\n      wr_ptr_q <= '0;\n    end else begin\n      rd_ptr_q <= nxt_rd_ptr;\n      wr_ptr_q <= nxt_wr_ptr;\n    end\n  end\n\n  // Next-state logic for pointers\n  always_comb begin\n    // Default no movement\n    nxt_rd_ptr    = rd_ptr_q;\n    nxt_wr_ptr    = wr_ptr_q;\n    fifo_pop_data = fifo_mem[rd_ptr_q[PTR_W-1:0]];\n\n    case ({pop_i, push_i})\n      2'b01: // PUSH\n        nxt_wr_ptr = wr_ptr_q + 1;\n      2'b10: // POP\n        nxt_rd_ptr = rd_ptr_q + 1;\n      2'b11: // PUSH + POP\n        begin\n          nxt_wr_ptr = wr_ptr_q + 1;\n          nxt_rd_ptr = rd_ptr_q + 1;\n        end\n      default: /* 2'b00 */ ;\n    endcase\n  end\n\n  // Write memory\n  always_ff @(posedge clk) begin\n    if (push_i) begin\n      fifo_mem[wr_ptr_q[PTR_W-1:0]] <= push_data_i;\n    end\n  end\n\n  // Empty/Full checks\n  assign empty_o = (wr_ptr_q == rd_ptr_q);\n  assign full_o  = (wr_ptr_q[PTR_W]  != rd_ptr_q[PTR_W]) &&\n                   (wr_ptr_q[PTR_W-1:0] == rd_ptr_q[PTR_W-1:0]);\n\nendmodule", "verif/tb_low_power_channel.sv": "`timescale 1ns / 1ps\n\nmodule tb_low_power_channel;\n\n  // -------------------------------------------------------------------\n  // DUT Interface Signals\n  // -------------------------------------------------------------------\n  logic         clk;\n  logic         reset;\n\n  // DUT inputs\n  logic         if_wakeup_i;\n  logic         wr_valid_i;\n  logic [7:0]   wr_payload_i;\n  logic         wr_done_i;\n  logic         rd_valid_i;\n  logic         qreqn_i;\n\n  // DUT outputs\n  wire          wr_flush_o;\n  wire [7:0]    rd_payload_o;\n  wire          qacceptn_o;\n  wire          qactive_o;\n\n  // -------------------------------------------------------------------\n  // DUT Instantiation\n  // -------------------------------------------------------------------\n  low_power_channel dut (\n    .clk          (clk),\n    .reset        (reset),\n    .if_wakeup_i  (if_wakeup_i),\n    .wr_valid_i   (wr_valid_i),\n    .wr_payload_i (wr_payload_i),\n    .wr_flush_o   (wr_flush_o),\n    .wr_done_i    (wr_done_i),\n    .rd_valid_i   (rd_valid_i),\n    .rd_payload_o (rd_payload_o),\n    .qreqn_i      (qreqn_i),\n    .qacceptn_o   (qacceptn_o),\n    .qactive_o    (qactive_o)\n  );\n\n  // -------------------------------------------------------------------\n  // Clock Generation\n  // -------------------------------------------------------------------\n  always #5 clk = ~clk;\n\n  // -------------------------------------------------------------------\n  // Scoreboard / Tracking\n  // -------------------------------------------------------------------\n  // We will store written data in a queue and compare with read data\n  // to ensure correctness.\n  typedef bit [7:0] data_t;\n  data_t write_queue[$];\n  data_t read_data;\n\n  // Track errors\n  integer error_count = 0;\n\n  // Simple mechanism to log errors\n  task report_error(string msg);\n    begin\n      error_count++;\n      $display(\"[ERROR] %s at time %0t\", msg, $time);\n    end\n  endtask\n\n  // -------------------------------------------------------------------\n  // Initialization & Reset\n  // -------------------------------------------------------------------\n  initial begin\n    clk          = 0;\n    reset        = 0;\n    if_wakeup_i  = 0;\n    wr_valid_i   = 0;\n    wr_payload_i = 0;\n    wr_done_i    = 0;\n    rd_valid_i   = 0;\n    qreqn_i      = 1; // Start in ST_Q_RUN\n\n    // Apply reset\n    apply_reset;\n    // Run test scenarios\n    scenario1_reset_behavior;\n    scenario2_write_read;\n    scenario3_fifo_overflow_attempt;\n    scenario4_fifo_underflow_attempt;\n    scenario5_qreq_flush_handshake;\n    scenario6_wakeup_signal_test;\n\n    // Optional random/stress test\n    scenario7_random_stress;\n\n    // Final summary\n    if (error_count == 0) begin\n      $display(\"\\nAll tests PASSED!\");\n    end else begin\n      $display(\"\\nTest FAILED with %0d errors!\", error_count);\n    end\n\n    $finish;\n  end\n\n  // -------------------------------------------------------------------\n  // Reset Task\n  // -------------------------------------------------------------------\n  task apply_reset;\n    begin\n      reset = 1;\n      repeat (2) @(posedge clk); // hold reset for a couple of cycles\n      reset = 0;\n      repeat (2) @(posedge clk);\n    end\n  endtask\n\n  // -------------------------------------------------------------------\n  // Scenario #1: Reset Behavior\n  //   Pass/Fail Criteria:\n  //   - After reset, qacceptn_o == 1, qactive_o == 0, wr_flush_o == 0\n  // -------------------------------------------------------------------\n  task scenario1_reset_behavior;\n    begin\n      $display(\"\\n--- SCENARIO 1: Reset Behavior ---\");\n      // Right after apply_reset, check signals\n      @(negedge clk);\n      if (qacceptn_o !== 1'b1)\n        report_error(\"qacceptn_o should be 1 after reset\");\n      if (qactive_o !== 1'b0)\n        report_error(\"qactive_o should be 0 after reset\");\n      if (wr_flush_o !== 1'b0)\n        report_error(\"wr_flush_o should be 0 after reset\");\n\n      $display(\"Scenario 1 completed.\");\n    end\n  endtask\n\n  // -------------------------------------------------------------------\n  // Scenario #2: Simple Write/Read\n  //   Pass/Fail Criteria:\n  //   - Data read = Data written (in order).\n  //   - No unexpected assertions of wr_flush_o.\n  // -------------------------------------------------------------------\n  task scenario2_write_read;\n    begin\n      $display(\"\\n--- SCENARIO 2: Simple Write/Read ---\");\n      // Write a few data items\n      write_data(8'hAA);\n      write_data(8'hBB);\n      write_data(8'hCC);\n\n      // Now read them back\n      read_data_item; // expects 8'hAA\n      read_data_item; // expects 8'hBB\n      read_data_item; // expects 8'hCC\n\n      // Check no extra flush was triggered\n      if (wr_flush_o !== 1'b0)\n        report_error(\"wr_flush_o should not have asserted in normal write/read scenario\");\n\n      $display(\"Scenario 2 completed.\");\n    end\n  endtask\n\n  // Write a data item into the DUT\n  task write_data(input [7:0] data_in);\n    begin\n      @(posedge clk);\n      wr_valid_i   = 1'b1;\n      wr_payload_i = data_in;\n      write_queue.push_back(data_in);\n      @(posedge clk);\n      wr_valid_i   = 1'b0;\n      wr_payload_i = 8'h00; // idle\n      @(posedge clk);\n    end\n  endtask\n\n  // Read a data item from the DUT and check scoreboard\n  task read_data_item;\n    begin\n      // Only attempt read if scoreboard says we have data\n      if (write_queue.size() == 0) begin\n        report_error(\"Read requested but scoreboard is empty\");\n        return;\n      end\n\n      // Drive read\n      @(posedge clk);\n      rd_valid_i = 1'b1;\n      @(posedge clk);\n      rd_valid_i = 1'b0;\n\n      // The read data will appear combinationally at rd_payload_o\n      // We'll sample at the next clock for stable checking\n      read_data = rd_payload_o;\n      // Compare with scoreboard front\n      if (read_data !== write_queue[0]) begin\n        report_error($sformatf(\"Read data mismatch. Expected %h, got %h\",\n                               write_queue[0], read_data));\n      end\n      // Pop from scoreboard\n      write_queue.pop_front();\n      @(posedge clk);\n    end\n  endtask\n\n  // -------------------------------------------------------------------\n  // Scenario #3: FIFO Overflow Attempt\n  //   Pass/Fail Criteria:\n  //   - Confirm design\u2019s defined behavior. Possibly losing data or ignoring push\n  //     if the FIFO is full. Make sure no unexpected lock-ups.\n  // -------------------------------------------------------------------\n  task scenario3_fifo_overflow_attempt;\n    integer i;\n    begin\n      $display(\"\\n--- SCENARIO 3: FIFO Overflow Attempt ---\");\n      // FIFO has DEPTH=6 in the DUT. Let's write more than 6 without reads.\n      for (i = 0; i < 8; i++) begin\n        write_data(i[7:0]);\n      end\n\n      // Now read all we can. The scoreboard expects 8 items, but the\n      // actual FIFO can only hold 6. If the design does not gate wr_valid,\n      // you might see data lost or overwritten.\n      // We read 8 times to see what comes out.\n      for (i = 0; i < 8; i++) begin\n        read_data_item;\n      end\n\n      // If the design is not gating writes, you may see mismatch errors.\n      // We only confirm it doesn't wedge or produce X states unexpectedly.\n      $display(\"Scenario 3 completed. Check for mismatch errors or stable behavior.\");\n    end\n  endtask\n\n  // -------------------------------------------------------------------\n  // Scenario #4: FIFO Underflow Attempt\n  //   Pass/Fail Criteria:\n  //   - Attempt reading from empty FIFO. Check that no corruption or\n  //     unexpected transitions occur.\n  // -------------------------------------------------------------------\n  task scenario4_fifo_underflow_attempt;\n    integer i;\n    begin\n      $display(\"\\n--- SCENARIO 4: FIFO Underflow Attempt ---\");\n      // Ensure FIFO is empty: no writes\n      // Attempt multiple reads\n      for (i = 0; i < 3; i++) begin\n        @(posedge clk);\n        rd_valid_i = 1'b1;\n        @(posedge clk);\n        rd_valid_i = 1'b0;\n        // Check read data (may remain at a previous or undefined value)\n        $display(\"Read data = %h (expected empty FIFO)\", rd_payload_o);\n      end\n\n      // As long as the design does not hang or produce spurious flush,\n      // we consider this scenario pass if no errors have been reported.\n      $display(\"Scenario 4 completed.\");\n    end\n  endtask\n\n  // -------------------------------------------------------------------\n  // Scenario #5: QREQ Handshake and Flush\n  //   Pass/Fail Criteria:\n  //   - wr_flush_o must assert when qreqn_i goes low (ST_Q_REQUEST)\n  //     and remain asserted until wr_done_i is high and FIFO empties.\n  //   - qacceptn_o must go low once flush completes in ST_Q_STOPPED.\n  // -------------------------------------------------------------------\n  task scenario5_qreq_flush_handshake;\n    begin\n      $display(\"\\n--- SCENARIO 5: QREQ Handshake and Flush ---\");\n      // 1) Put some data in FIFO, do not read them\n      write_data(8'hA0);\n      write_data(8'hB1);\n\n      // 2) Deassert wr_done_i, so the flush cannot complete\n      wr_done_i = 0;\n\n      // 3) Pull qreqn_i low => request Q-channel\n      @(posedge clk);\n      qreqn_i = 0;\n\n      // Expect the state machine to move from ST_Q_RUN -> ST_Q_REQUEST\n      // Check if wr_flush_o = 1\n      // We'll wait a few cycles and check\n      repeat (2) @(posedge clk);\n      if (wr_flush_o !== 1'b1) begin\n        report_error(\"wr_flush_o should be asserted in ST_Q_REQUEST\");\n      end\n\n      // 4) Now let the upstream complete: wr_done_i=1 => flush completes\n      //    Wait for FIFO to empty as well. Let's do a quick read:\n      read_data_item; // read 8'hA0\n      read_data_item; // read 8'hB1\n\n      // The FIFO is now empty but we also must keep wr_done_i = 1\n      @(posedge clk);\n      wr_done_i = 1'b1;\n\n      // Wait a bit to let state machine transition\n      repeat (2) @(posedge clk);\n\n      // Now, we expect wr_flush_o = 0 (since flush completed) and\n      // qacceptn_o to drive low (since ST_Q_STOPPED).\n      if (wr_flush_o !== 1'b0)\n        report_error(\"wr_flush_o should be deasserted after flush completes\");\n      \n      // Because we are in ST_Q_STOPPED, qacceptn_o should be 1'b0\n      // (the design sets qacceptn_o = ~qaccept, so if we accept=1 => qacceptn=0)\n      if (qacceptn_o !== 1'b0)\n        report_error(\"qacceptn_o should be 0 in ST_Q_STOPPED\");\n\n      // 5) Re-assert qreqn_i => ST_Q_EXIT => eventually qacceptn_o = 1,\n      @(posedge clk);\n      qreqn_i = 1'b1;\n      repeat (2) @(posedge clk);\n      repeat(2) @(posedge clk);  // <---- ADD at least 2 cycles of wait\n      if (qacceptn_o !== 1'b1)\n        report_error(\"qacceptn_o should go back to 1 in ST_Q_RUN eventually\");\n\n      // Return signals to idle\n      wr_done_i = 0;\n      $display(\"Scenario 5 completed.\");\n    end\n  endtask\n\n  // -------------------------------------------------------------------\n  // Scenario #6: Wakeup Signal Check\n  //   Pass/Fail Criteria:\n  //   - If if_wakeup_i=1 with an empty FIFO, qactive_o should still assert.\n  //   - When if_wakeup_i=0, qactive_o should deassert if no FIFO activity.\n  // -------------------------------------------------------------------\n  task scenario6_wakeup_signal_test;\n    begin\n      $display(\"\\n--- SCENARIO 6: Wakeup Signal Check ---\");\n      // Ensure FIFO is empty from previous scenario\n      // No writes or reads\n      if_wakeup_i = 1'b1;\n      @(posedge clk);\n      if (qactive_o !== 1'b1)\n        report_error(\"qactive_o should be high due to wakeup\");\n\n      // Now deassert wakeup\n      if_wakeup_i = 1'b0;\n      repeat (2) @(posedge clk);\n      if (qactive_o !== 1'b0)\n        report_error(\"qactive_o should return low when wakeup is cleared and FIFO idle\");\n\n      $display(\"Scenario 6 completed.\");\n    end\n  endtask\n\n  // -------------------------------------------------------------------\n  // Scenario #7: Optional Random/Stress (example skeleton)\n  //   Pass/Fail Criteria:\n  //   - No data mismatches or illegal state machine transitions.\n  //   - Potential to uncover corner cases more systematically.\n  // -------------------------------------------------------------------\n  \n  task scenario7_random_stress;\n    integer i;\n    begin\n      $display(\"\\n--- SCENARIO 7: Random/Stress Test ---\");\n      for (i = 0; i < 100; i++) begin\n        // Random writes\n        wr_valid_i   = $urandom_range(0,1);\n        wr_payload_i = $urandom_range(0,255);\n        if (wr_valid_i) write_queue.push_back(wr_payload_i);\n\n        // Random reads\n        rd_valid_i   = $urandom_range(0,1);\n        if (rd_valid_i && write_queue.size() > 0) begin\n          // scoreboard check after the cycle\n        end\n\n        // Random QREQ toggles\n        if ($urandom_range(0,50) == 0) qreqn_i = ~qreqn_i;\n\n        // Random wakeup\n        if_wakeup_i = $urandom_range(0,1);\n\n        // Random wr_done_i\n        wr_done_i  = $urandom_range(0,1);\n\n        @(posedge clk);\n      end\n\n      // Turn off writes, reads, wait some cycles\n      wr_valid_i   = 0;\n      rd_valid_i   = 0;\n      if_wakeup_i  = 0;\n      wr_done_i    = 1;\n      repeat (10) @(posedge clk);\n\n      $display(\"Scenario 7 completed (Random/Stress).\");\n    end\n  endtask\n  \n\nendmodule"}, "patch": {"rtl/low_power_channel.sv": ""}, "harness": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/low_power_ctrl.sv /code/rtl/sync_fifo.sv /code/rtl/low_power_channel.sv\nTOPLEVEL        = low_power_channel\nMODULE          = test_low_power_channel\nPYTHONPATH      = /src\nHASH            = 83bfc74ecf5366b40b9b2c3fc5344cfa865aed66\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_low_power_channel.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\n\n###############################################################################\n# Global scoreboard / tracking\n###############################################################################\nwrite_queue = []  # Stores reference data written to the FIFO\n\nasync def report_error(msg):\n    \"\"\"Simple mechanism to raise an assertion error (increments error count).\"\"\"\n    raise AssertionError(f\"[ERROR] {msg}\")\n\n###############################################################################\n# Utility / Helper Tasks\n###############################################################################\nasync def apply_reset(dut, cycles=2):\n    \"\"\"Apply and release reset.\"\"\"\n    dut.reset.value = 1\n    for _ in range(cycles):\n        await RisingEdge(dut.clk)\n    dut.reset.value = 0\n    for _ in range(cycles):\n        await RisingEdge(dut.clk)\n\nasync def write_data(dut, data_in):\n    \"\"\"Write a byte into the DUT FIFO and store it in the scoreboard.\"\"\"\n    await RisingEdge(dut.clk)\n    dut.wr_valid_i.value = 1\n    dut.wr_payload_i.value = data_in\n    write_queue.append(data_in)\n    await RisingEdge(dut.clk)\n    dut.wr_valid_i.value = 0\n    dut.wr_payload_i.value = 0\n    await RisingEdge(dut.clk)\n\nasync def read_data_item(dut):\n    \"\"\"Read a byte from the DUT and compare with the scoreboard.\"\"\"\n    if len(write_queue) == 0:\n        await report_error(\"Read requested but scoreboard is empty\")\n        return\n\n    # Drive read\n    await RisingEdge(dut.clk)\n    dut.rd_valid_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.rd_valid_i.value = 0\n\n    # Sample read data\n    read_data = dut.rd_payload_o.value.integer\n\n    # Compare with the oldest data in scoreboard\n    expected_data = write_queue.pop(0)\n    if read_data != expected_data:\n        await report_error(\n            f\"Read data mismatch. Expected 0x{expected_data:02X}, got 0x{read_data:02X}\"\n        )\n\n    await RisingEdge(dut.clk)\n\n###############################################################################\n# Scenarios\n###############################################################################\nasync def scenario1_reset_behavior(dut):\n    \"\"\"\n    Scenario #1: Reset Behavior\n      - After reset, qacceptn_o == 1, qactive_o == 0, wr_flush_o == 0\n    \"\"\"\n    cocotb.log.info(\"--- SCENARIO 1: Reset Behavior ---\")\n    await RisingEdge(dut.clk)  # Wait at least one cycle after reset\n    if dut.qacceptn_o.value != 1:\n        await report_error(\"qacceptn_o should be 1 after reset\")\n    if dut.qactive_o.value != 0:\n        await report_error(\"qactive_o should be 0 after reset\")\n    if dut.wr_flush_o.value != 0:\n        await report_error(\"wr_flush_o should be 0 after reset\")\n\nasync def scenario2_write_read(dut):\n    \"\"\"\n    Scenario #2: Simple Write/Read\n      - Data read = Data written (in order).\n      - No unexpected assertions of wr_flush_o.\n    \"\"\"\n    cocotb.log.info(\"--- SCENARIO 2: Simple Write/Read ---\")\n    # Write three bytes\n    await write_data(dut, 0xAA)\n    await write_data(dut, 0xBB)\n    await write_data(dut, 0xCC)\n\n    # Read them back\n    await read_data_item(dut)  # expects 0xAA\n    await read_data_item(dut)  # expects 0xBB\n    await read_data_item(dut)  # expects 0xCC\n\n    # Check no flush triggered\n    if dut.wr_flush_o.value != 0:\n        await report_error(\"wr_flush_o should not assert in normal write/read\")\n\nasync def scenario3_fifo_overflow_attempt(dut):\n    \"\"\"\n    Scenario #3: FIFO Overflow Attempt\n      - Write more data than FIFO depth, then read it out\n      - Check behavior with lost data, ignoring pushes, etc.\n    \"\"\"\n    cocotb.log.info(\"--- SCENARIO 3: FIFO Overflow Attempt ---\")\n    # Example assumption: FIFO depth is 6. Write 8 consecutive items\n    for i in range(8):\n        await write_data(dut, i)\n\n    # Now read them back 8 times\n    for _ in range(8):\n        await read_data_item(dut)\n    cocotb.log.info(\"Check for mismatch errors or stable behavior above.\")\n\nasync def scenario4_fifo_underflow_attempt(dut):\n    \"\"\"\n    Scenario #4: FIFO Underflow Attempt\n      - Attempt reading from empty FIFO\n      - Ensure no corruption or invalid flush/hang states\n    \"\"\"\n    cocotb.log.info(\"--- SCENARIO 4: FIFO Underflow Attempt ---\")\n    for _ in range(3):\n        await RisingEdge(dut.clk)\n        dut.rd_valid_i.value = 1\n        await RisingEdge(dut.clk)\n        dut.rd_valid_i.value = 0\n        cocotb.log.info(f\"Read data = 0x{dut.rd_payload_o.value.integer:02X} (empty FIFO)\")\n\nasync def scenario5_qreq_flush_handshake(dut):\n    \"\"\"\n    Scenario #5: QREQ Handshake and Flush\n      - wr_flush_o asserts when qreqn_i goes low, remains until wr_done_i=1 & FIFO empties\n      - qacceptn_o goes low once flush completes (ST_Q_STOPPED)\n    \"\"\"\n    cocotb.log.info(\"--- SCENARIO 5: QREQ Handshake and Flush ---\")\n    # 1) Put some data in FIFO\n    await write_data(dut, 0xA0)\n    await write_data(dut, 0xB1)\n\n    # 2) Keep wr_done_i low\n    dut.wr_done_i.value = 0\n\n    # 3) Pull qreqn_i low => ST_Q_REQUEST => expect wr_flush_o=1\n    await RisingEdge(dut.clk)\n    dut.qreqn_i.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    if dut.wr_flush_o.value != 1:\n        await report_error(\"wr_flush_o should assert in ST_Q_REQUEST\")\n\n    # 4) Now let flush complete: wr_done_i=1, read out data, check flush deassert\n    await read_data_item(dut)  # read 0xA0\n    await read_data_item(dut)  # read 0xB1\n\n    await RisingEdge(dut.clk)\n    dut.wr_done_i.value = 1\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n    if dut.wr_flush_o.value != 0:\n        await report_error(\"wr_flush_o should deassert after flush completes\")\n    if dut.qacceptn_o.value != 0:\n        await report_error(\"qacceptn_o should be 0 in ST_Q_STOPPED\")\n\n    # 5) Re-assert qreqn_i => back to ST_Q_RUN => qacceptn_o=1 eventually\n    await RisingEdge(dut.clk)\n    dut.qreqn_i.value = 1\n    for _ in range(4):\n        await RisingEdge(dut.clk)\n    if dut.qacceptn_o.value != 1:\n        await report_error(\"qacceptn_o should return to 1 in ST_Q_RUN\")\n\n    # Return signals to idle\n    dut.wr_done_i.value = 0\n\nasync def scenario6_wakeup_signal_test(dut):\n    \"\"\"\n    Scenario #6: Wakeup Signal Check\n      - if_wakeup_i=1 with empty FIFO => qactive_o=1\n      - if_wakeup_i=0 => qactive_o=0 if no FIFO activity\n    \"\"\"\n    cocotb.log.info(\"--- SCENARIO 6: Wakeup Signal Check ---\")\n    dut.if_wakeup_i.value = 1\n    await RisingEdge(dut.clk)\n    if dut.qactive_o.value != 1:\n        await report_error(\"qactive_o should be 1 due to wakeup\")\n\n    dut.if_wakeup_i.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    if dut.qactive_o.value != 0:\n        await report_error(\"qactive_o should go 0 after wakeup cleared & FIFO idle\")\n\n###############################################################################\n# Main Test\n###############################################################################\n@cocotb.test()\nasync def test_low_power_channel(dut):\n    \"\"\"Top-level cocotb test for low_power_channel.\"\"\"\n    # Create a clock on dut.clk, 10ns period => 100MHz\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Initialize signals\n    dut.reset.value        = 0\n    dut.if_wakeup_i.value  = 0\n    dut.wr_valid_i.value   = 0\n    dut.wr_payload_i.value = 0\n    dut.wr_done_i.value    = 0\n    dut.rd_valid_i.value   = 0\n    dut.qreqn_i.value      = 1\n\n    # Apply reset\n    await apply_reset(dut)\n\n    # Run scenarios in order\n    await scenario1_reset_behavior(dut)\n    await scenario2_write_read(dut)\n    await scenario3_fifo_overflow_attempt(dut)\n    await scenario4_fifo_underflow_attempt(dut)\n    await scenario5_qreq_flush_handshake(dut)\n    await scenario6_wakeup_signal_test(dut)\n\n    cocotb.log.info(\"All scenarios completed. If no assertion errors, test PASSED!\")\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom cocotb.runner import get_runner\nimport pytest\nimport pickle\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\n@pytest.mark.tb\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\n#if __name__ == \"__main__\":\n#    test_runner()", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_phase_rotation_0010", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Design a `phase_rotation_viterbi` module (`phase_rotation_viterbi.sv`) in **SystemVerilog** that implements **phase estimation and correction** using **fourth-power phase detection**. The module takes complex input samples (**I, Q**) and processes them through a hierarchical pipeline structure, integrating the following submodules `power4`, `saturation`, `phase_lut` and `top_phase_rotation`.\n \nPlease refer to `docs/spec_viterbi.md` for design requirements and specifications.\n", "context": {"rtl/gen_cos_sin_lut.sv": "module gen_cos_sin_lut #(\n    parameter NBW_ANG  =  'd7,      \n    parameter NBW_COS  =  'd10\n)\n(    \n    input  logic signed [NBW_ANG-1:0] i_angle,\n    output logic signed [NBW_COS-1:0] o_cos  ,\n    output logic signed [NBW_COS-1:0] o_sin    \n);  \n  \nalways_comb begin\n    case(i_angle)\n        7'd000:   {o_cos,o_sin} = {10'b0100000000, 10'b0000000000};\n        7'd001:   {o_cos,o_sin} = {10'b0100000000, 10'b0000001101};\n        7'd002:   {o_cos,o_sin} = {10'b0011111111, 10'b0000011001};\n        7'd003:   {o_cos,o_sin} = {10'b0011111101, 10'b0000100110};\n        7'd004:   {o_cos,o_sin} = {10'b0011111011, 10'b0000110010};\n        7'd005:   {o_cos,o_sin} = {10'b0011111000, 10'b0000111110};\n        7'd006:   {o_cos,o_sin} = {10'b0011110101, 10'b0001001010};\n        7'd007:   {o_cos,o_sin} = {10'b0011110001, 10'b0001010110};\n        7'd008:   {o_cos,o_sin} = {10'b0011101101, 10'b0001100010};\n        7'd009:   {o_cos,o_sin} = {10'b0011100111, 10'b0001101101};\n        7'd010:   {o_cos,o_sin} = {10'b0011100010, 10'b0001111001};\n        7'd011:   {o_cos,o_sin} = {10'b0011011100, 10'b0010000100};\n        7'd012:   {o_cos,o_sin} = {10'b0011010101, 10'b0010001110};\n        7'd013:   {o_cos,o_sin} = {10'b0011001110, 10'b0010011000};\n        7'd014:   {o_cos,o_sin} = {10'b0011000110, 10'b0010100010};\n        7'd015:   {o_cos,o_sin} = {10'b0010111110, 10'b0010101100};\n        7'd016:   {o_cos,o_sin} = {10'b0010110101, 10'b0010110101};\n        7'd017:   {o_cos,o_sin} = {10'b0010101100, 10'b0010111110};\n        7'd018:   {o_cos,o_sin} = {10'b0010100010, 10'b0011000110};\n        7'd019:   {o_cos,o_sin} = {10'b0010011000, 10'b0011001110};\n        7'd020:   {o_cos,o_sin} = {10'b0010001110, 10'b0011010101};\n        7'd021:   {o_cos,o_sin} = {10'b0010000100, 10'b0011011100};\n        7'd022:   {o_cos,o_sin} = {10'b0001111001, 10'b0011100010};\n        7'd023:   {o_cos,o_sin} = {10'b0001101101, 10'b0011100111};\n        7'd024:   {o_cos,o_sin} = {10'b0001100010, 10'b0011101101};\n        7'd025:   {o_cos,o_sin} = {10'b0001010110, 10'b0011110001};\n        7'd026:   {o_cos,o_sin} = {10'b0001001010, 10'b0011110101};\n        7'd027:   {o_cos,o_sin} = {10'b0000111110, 10'b0011111000};\n        7'd028:   {o_cos,o_sin} = {10'b0000110010, 10'b0011111011};\n        7'd029:   {o_cos,o_sin} = {10'b0000100110, 10'b0011111101};\n        7'd030:   {o_cos,o_sin} = {10'b0000011001, 10'b0011111111};\n        7'd031:   {o_cos,o_sin} = {10'b0000001101, 10'b0100000000};\n        7'd032:   {o_cos,o_sin} = {10'b0000000000, 10'b0100000000};\n        7'd033:   {o_cos,o_sin} = {10'b1111110011, 10'b0100000000};\n        7'd034:   {o_cos,o_sin} = {10'b1111100111, 10'b0011111111};\n        7'd035:   {o_cos,o_sin} = {10'b1111011010, 10'b0011111101};\n        7'd036:   {o_cos,o_sin} = {10'b1111001110, 10'b0011111011};\n        7'd037:   {o_cos,o_sin} = {10'b1111000010, 10'b0011111000};\n        7'd038:   {o_cos,o_sin} = {10'b1110110110, 10'b0011110101};\n        7'd039:   {o_cos,o_sin} = {10'b1110101010, 10'b0011110001};\n        7'd040:   {o_cos,o_sin} = {10'b1110011110, 10'b0011101101};\n        7'd041:   {o_cos,o_sin} = {10'b1110010011, 10'b0011100111};\n        7'd042:   {o_cos,o_sin} = {10'b1110000111, 10'b0011100010};\n        7'd043:   {o_cos,o_sin} = {10'b1101111100, 10'b0011011100};\n        7'd044:   {o_cos,o_sin} = {10'b1101110010, 10'b0011010101};\n        7'd045:   {o_cos,o_sin} = {10'b1101101000, 10'b0011001110};\n        7'd046:   {o_cos,o_sin} = {10'b1101011110, 10'b0011000110};\n        7'd047:   {o_cos,o_sin} = {10'b1101010100, 10'b0010111110};\n        7'd048:   {o_cos,o_sin} = {10'b1101001011, 10'b0010110101};\n        7'd049:   {o_cos,o_sin} = {10'b1101000010, 10'b0010101100};\n        7'd050:   {o_cos,o_sin} = {10'b1100111010, 10'b0010100010};\n        7'd051:   {o_cos,o_sin} = {10'b1100110010, 10'b0010011000};\n        7'd052:   {o_cos,o_sin} = {10'b1100101011, 10'b0010001110};\n        7'd053:   {o_cos,o_sin} = {10'b1100100100, 10'b0010000100};\n        7'd054:   {o_cos,o_sin} = {10'b1100011110, 10'b0001111001};\n        7'd055:   {o_cos,o_sin} = {10'b1100011001, 10'b0001101101};\n        7'd056:   {o_cos,o_sin} = {10'b1100010011, 10'b0001100010};\n        7'd057:   {o_cos,o_sin} = {10'b1100001111, 10'b0001010110};\n        7'd058:   {o_cos,o_sin} = {10'b1100001011, 10'b0001001010};\n        7'd059:   {o_cos,o_sin} = {10'b1100001000, 10'b0000111110};\n        7'd060:   {o_cos,o_sin} = {10'b1100000101, 10'b0000110010};\n        7'd061:   {o_cos,o_sin} = {10'b1100000011, 10'b0000100110};\n        7'd062:   {o_cos,o_sin} = {10'b1100000001, 10'b0000011001};\n        7'd063:   {o_cos,o_sin} = {10'b1100000000, 10'b0000001101};\n        7'd064:   {o_cos,o_sin} = {10'b1100000000, 10'b0000000000};\n        7'd065:   {o_cos,o_sin} = {10'b1100000000, 10'b1111110011};\n        7'd066:   {o_cos,o_sin} = {10'b1100000001, 10'b1111100111};\n        7'd067:   {o_cos,o_sin} = {10'b1100000011, 10'b1111011010};\n        7'd068:   {o_cos,o_sin} = {10'b1100000101, 10'b1111001110};\n        7'd069:   {o_cos,o_sin} = {10'b1100001000, 10'b1111000010};\n        7'd070:   {o_cos,o_sin} = {10'b1100001011, 10'b1110110110};\n        7'd071:   {o_cos,o_sin} = {10'b1100001111, 10'b1110101010};\n        7'd072:   {o_cos,o_sin} = {10'b1100010011, 10'b1110011110};\n        7'd073:   {o_cos,o_sin} = {10'b1100011001, 10'b1110010011};\n        7'd074:   {o_cos,o_sin} = {10'b1100011110, 10'b1110000111};\n        7'd075:   {o_cos,o_sin} = {10'b1100100100, 10'b1101111100};\n        7'd076:   {o_cos,o_sin} = {10'b1100101011, 10'b1101110010};\n        7'd077:   {o_cos,o_sin} = {10'b1100110010, 10'b1101101000};\n        7'd078:   {o_cos,o_sin} = {10'b1100111010, 10'b1101011110};\n        7'd079:   {o_cos,o_sin} = {10'b1101000010, 10'b1101010100};\n        7'd080:   {o_cos,o_sin} = {10'b1101001011, 10'b1101001011};\n        7'd081:   {o_cos,o_sin} = {10'b1101010100, 10'b1101000010};\n        7'd082:   {o_cos,o_sin} = {10'b1101011110, 10'b1100111010};\n        7'd083:   {o_cos,o_sin} = {10'b1101101000, 10'b1100110010};\n        7'd084:   {o_cos,o_sin} = {10'b1101110010, 10'b1100101011};\n        7'd085:   {o_cos,o_sin} = {10'b1101111100, 10'b1100100100};\n        7'd086:   {o_cos,o_sin} = {10'b1110000111, 10'b1100011110};\n        7'd087:   {o_cos,o_sin} = {10'b1110010011, 10'b1100011001};\n        7'd088:   {o_cos,o_sin} = {10'b1110011110, 10'b1100010011};\n        7'd089:   {o_cos,o_sin} = {10'b1110101010, 10'b1100001111};\n        7'd090:   {o_cos,o_sin} = {10'b1110110110, 10'b1100001011};\n        7'd091:   {o_cos,o_sin} = {10'b1111000010, 10'b1100001000};\n        7'd092:   {o_cos,o_sin} = {10'b1111001110, 10'b1100000101};\n        7'd093:   {o_cos,o_sin} = {10'b1111011010, 10'b1100000011};\n        7'd094:   {o_cos,o_sin} = {10'b1111100111, 10'b1100000001};\n        7'd095:   {o_cos,o_sin} = {10'b1111110011, 10'b1100000000};\n        7'd096:   {o_cos,o_sin} = {10'b0000000000, 10'b1100000000};\n        7'd097:   {o_cos,o_sin} = {10'b0000001101, 10'b1100000000};\n        7'd098:   {o_cos,o_sin} = {10'b0000011001, 10'b1100000001};\n        7'd099:   {o_cos,o_sin} = {10'b0000100110, 10'b1100000011};\n        7'd100:   {o_cos,o_sin} = {10'b0000110010, 10'b1100000101};\n        7'd101:   {o_cos,o_sin} = {10'b0000111110, 10'b1100001000};\n        7'd102:   {o_cos,o_sin} = {10'b0001001010, 10'b1100001011};\n        7'd103:   {o_cos,o_sin} = {10'b0001010110, 10'b1100001111};\n        7'd104:   {o_cos,o_sin} = {10'b0001100010, 10'b1100010011};\n        7'd105:   {o_cos,o_sin} = {10'b0001101101, 10'b1100011001};\n        7'd106:   {o_cos,o_sin} = {10'b0001111001, 10'b1100011110};\n        7'd107:   {o_cos,o_sin} = {10'b0010000100, 10'b1100100100};\n        7'd108:   {o_cos,o_sin} = {10'b0010001110, 10'b1100101011};\n        7'd109:   {o_cos,o_sin} = {10'b0010011000, 10'b1100110010};\n        7'd110:   {o_cos,o_sin} = {10'b0010100010, 10'b1100111010};\n        7'd111:   {o_cos,o_sin} = {10'b0010101100, 10'b1101000010};\n        7'd112:   {o_cos,o_sin} = {10'b0010110101, 10'b1101001011};\n        7'd113:   {o_cos,o_sin} = {10'b0010111110, 10'b1101010100};\n        7'd114:   {o_cos,o_sin} = {10'b0011000110, 10'b1101011110};\n        7'd115:   {o_cos,o_sin} = {10'b0011001110, 10'b1101101000};\n        7'd116:   {o_cos,o_sin} = {10'b0011010101, 10'b1101110010};\n        7'd117:   {o_cos,o_sin} = {10'b0011011100, 10'b1101111100};\n        7'd118:   {o_cos,o_sin} = {10'b0011100010, 10'b1110000111};\n        7'd119:   {o_cos,o_sin} = {10'b0011100111, 10'b1110010011};\n        7'd120:   {o_cos,o_sin} = {10'b0011101101, 10'b1110011110};\n        7'd121:   {o_cos,o_sin} = {10'b0011110001, 10'b1110101010};\n        7'd122:   {o_cos,o_sin} = {10'b0011110101, 10'b1110110110};\n        7'd123:   {o_cos,o_sin} = {10'b0011111000, 10'b1111000010};\n        7'd124:   {o_cos,o_sin} = {10'b0011111011, 10'b1111001110};\n        7'd125:   {o_cos,o_sin} = {10'b0011111101, 10'b1111011010};\n        7'd126:   {o_cos,o_sin} = {10'b0011111111, 10'b1111100111};\n        7'd127:   {o_cos,o_sin} = {10'b0100000000, 10'b1111110011};\n    endcase\nend\n\nendmodule", "rtl/phase_lut.sv": "module phase_lut #(\n   parameter NBW_IN    = 6,\n   parameter NBW_PHASE = 9\n)\n(\n   input logic signed [NBW_IN-1:0]     i_data_i,\n   input logic signed [NBW_IN-1:0]     i_data_q,\n   output logic signed [NBW_PHASE-1:0] o_phase\n);\n\nlocalparam LUT_IDX = 2*NBW_IN;\nlogic [LUT_IDX-1:0] lut_index;\n\nassign lut_index = {$unsigned(i_data_i),$unsigned(i_data_q)};\n\nalways_comb begin\n\tcase(lut_index)\n\t0: o_phase = +9'd0;\t //LUT[0] \tphase : 0.000000\t(data_i, data_q): (0.000000,0.000000)\n\t1: o_phase = +9'd128;\t //LUT[1] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.031250)\n\t2: o_phase = +9'd128;\t //LUT[2] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.062500)\n\t3: o_phase = +9'd128;\t //LUT[3] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.093750)\n\t4: o_phase = +9'd128;\t //LUT[4] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.125000)\n\t5: o_phase = +9'd128;\t //LUT[5] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.156250)\n\t6: o_phase = +9'd128;\t //LUT[6] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.187500)\n\t7: o_phase = +9'd128;\t //LUT[7] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.218750)\n\t8: o_phase = +9'd128;\t //LUT[8] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.250000)\n\t9: o_phase = +9'd128;\t //LUT[9] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.281250)\n\t10: o_phase = +9'd128;\t //LUT[10] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.312500)\n\t11: o_phase = +9'd128;\t //LUT[11] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.343750)\n\t12: o_phase = +9'd128;\t //LUT[12] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.375000)\n\t13: o_phase = +9'd128;\t //LUT[13] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.406250)\n\t14: o_phase = +9'd128;\t //LUT[14] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.437500)\n\t15: o_phase = +9'd128;\t //LUT[15] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.468750)\n\t16: o_phase = +9'd128;\t //LUT[16] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.500000)\n\t17: o_phase = +9'd128;\t //LUT[17] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.531250)\n\t18: o_phase = +9'd128;\t //LUT[18] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.562500)\n\t19: o_phase = +9'd128;\t //LUT[19] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.593750)\n\t20: o_phase = +9'd128;\t //LUT[20] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.625000)\n\t21: o_phase = +9'd128;\t //LUT[21] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.656250)\n\t22: o_phase = +9'd128;\t //LUT[22] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.687500)\n\t23: o_phase = +9'd128;\t //LUT[23] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.718750)\n\t24: o_phase = +9'd128;\t //LUT[24] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.750000)\n\t25: o_phase = +9'd128;\t //LUT[25] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.781250)\n\t26: o_phase = +9'd128;\t //LUT[26] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.812500)\n\t27: o_phase = +9'd128;\t //LUT[27] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.843750)\n\t28: o_phase = +9'd128;\t //LUT[28] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.875000)\n\t29: o_phase = +9'd128;\t //LUT[29] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.906250)\n\t30: o_phase = +9'd128;\t //LUT[30] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.937500)\n\t31: o_phase = +9'd128;\t //LUT[31] \tphase : 0.500000\t(data_i, data_q): (0.000000,0.968750)\n\t32: o_phase = -9'd128;\t //LUT[32] \tphase : -0.500000\t(data_i, data_q): (0.000000,-1.000000)\n\t33: o_phase = -9'd128;\t //LUT[33] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.968750)\n\t34: o_phase = -9'd128;\t //LUT[34] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.937500)\n\t35: o_phase = -9'd128;\t //LUT[35] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.906250)\n\t36: o_phase = -9'd128;\t //LUT[36] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.875000)\n\t37: o_phase = -9'd128;\t //LUT[37] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.843750)\n\t38: o_phase = -9'd128;\t //LUT[38] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.812500)\n\t39: o_phase = -9'd128;\t //LUT[39] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.781250)\n\t40: o_phase = -9'd128;\t //LUT[40] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.750000)\n\t41: o_phase = -9'd128;\t //LUT[41] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.718750)\n\t42: o_phase = -9'd128;\t //LUT[42] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.687500)\n\t43: o_phase = -9'd128;\t //LUT[43] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.656250)\n\t44: o_phase = -9'd128;\t //LUT[44] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.625000)\n\t45: o_phase = -9'd128;\t //LUT[45] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.593750)\n\t46: o_phase = -9'd128;\t //LUT[46] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.562500)\n\t47: o_phase = -9'd128;\t //LUT[47] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.531250)\n\t48: o_phase = -9'd128;\t //LUT[48] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.500000)\n\t49: o_phase = -9'd128;\t //LUT[49] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.468750)\n\t50: o_phase = -9'd128;\t //LUT[50] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.437500)\n\t51: o_phase = -9'd128;\t //LUT[51] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.406250)\n\t52: o_phase = -9'd128;\t //LUT[52] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.375000)\n\t53: o_phase = -9'd128;\t //LUT[53] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.343750)\n\t54: o_phase = -9'd128;\t //LUT[54] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.312500)\n\t55: o_phase = -9'd128;\t //LUT[55] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.281250)\n\t56: o_phase = -9'd128;\t //LUT[56] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.250000)\n\t57: o_phase = -9'd128;\t //LUT[57] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.218750)\n\t58: o_phase = -9'd128;\t //LUT[58] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.187500)\n\t59: o_phase = -9'd128;\t //LUT[59] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.156250)\n\t60: o_phase = -9'd128;\t //LUT[60] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.125000)\n\t61: o_phase = -9'd128;\t //LUT[61] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.093750)\n\t62: o_phase = -9'd128;\t //LUT[62] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.062500)\n\t63: o_phase = -9'd128;\t //LUT[63] \tphase : -0.500000\t(data_i, data_q): (0.000000,-0.031250)\n\t64: o_phase = +9'd0;\t //LUT[64] \tphase : 0.000000\t(data_i, data_q): (0.031250,0.000000)\n\t65: o_phase = +9'd64;\t //LUT[65] \tphase : 0.250000\t(data_i, data_q): (0.031250,0.031250)\n\t66: o_phase = +9'd90;\t //LUT[66] \tphase : 0.351562\t(data_i, data_q): (0.031250,0.062500)\n\t67: o_phase = +9'd102;\t //LUT[67] \tphase : 0.398438\t(data_i, data_q): (0.031250,0.093750)\n\t68: o_phase = +9'd108;\t //LUT[68] \tphase : 0.421875\t(data_i, data_q): (0.031250,0.125000)\n\t69: o_phase = +9'd112;\t //LUT[69] \tphase : 0.437500\t(data_i, data_q): (0.031250,0.156250)\n\t70: o_phase = +9'd115;\t //LUT[70] \tphase : 0.449219\t(data_i, data_q): (0.031250,0.187500)\n\t71: o_phase = +9'd116;\t //LUT[71] \tphase : 0.453125\t(data_i, data_q): (0.031250,0.218750)\n\t72: o_phase = +9'd118;\t //LUT[72] \tphase : 0.460938\t(data_i, data_q): (0.031250,0.250000)\n\t73: o_phase = +9'd119;\t //LUT[73] \tphase : 0.464844\t(data_i, data_q): (0.031250,0.281250)\n\t74: o_phase = +9'd120;\t //LUT[74] \tphase : 0.468750\t(data_i, data_q): (0.031250,0.312500)\n\t75: o_phase = +9'd121;\t //LUT[75] \tphase : 0.472656\t(data_i, data_q): (0.031250,0.343750)\n\t76: o_phase = +9'd121;\t //LUT[76] \tphase : 0.472656\t(data_i, data_q): (0.031250,0.375000)\n\t77: o_phase = +9'd122;\t //LUT[77] \tphase : 0.476562\t(data_i, data_q): (0.031250,0.406250)\n\t78: o_phase = +9'd122;\t //LUT[78] \tphase : 0.476562\t(data_i, data_q): (0.031250,0.437500)\n\t79: o_phase = +9'd123;\t //LUT[79] \tphase : 0.480469\t(data_i, data_q): (0.031250,0.468750)\n\t80: o_phase = +9'd123;\t //LUT[80] \tphase : 0.480469\t(data_i, data_q): (0.031250,0.500000)\n\t81: o_phase = +9'd123;\t //LUT[81] \tphase : 0.480469\t(data_i, data_q): (0.031250,0.531250)\n\t82: o_phase = +9'd123;\t //LUT[82] \tphase : 0.480469\t(data_i, data_q): (0.031250,0.562500)\n\t83: o_phase = +9'd124;\t //LUT[83] \tphase : 0.484375\t(data_i, data_q): (0.031250,0.593750)\n\t84: o_phase = +9'd124;\t //LUT[84] \tphase : 0.484375\t(data_i, data_q): (0.031250,0.625000)\n\t85: o_phase = +9'd124;\t //LUT[85] \tphase : 0.484375\t(data_i, data_q): (0.031250,0.656250)\n\t86: o_phase = +9'd124;\t //LUT[86] \tphase : 0.484375\t(data_i, data_q): (0.031250,0.687500)\n\t87: o_phase = +9'd124;\t //LUT[87] \tphase : 0.484375\t(data_i, data_q): (0.031250,0.718750)\n\t88: o_phase = +9'd125;\t //LUT[88] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.750000)\n\t89: o_phase = +9'd125;\t //LUT[89] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.781250)\n\t90: o_phase = +9'd125;\t //LUT[90] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.812500)\n\t91: o_phase = +9'd125;\t //LUT[91] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.843750)\n\t92: o_phase = +9'd125;\t //LUT[92] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.875000)\n\t93: o_phase = +9'd125;\t //LUT[93] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.906250)\n\t94: o_phase = +9'd125;\t //LUT[94] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.937500)\n\t95: o_phase = +9'd125;\t //LUT[95] \tphase : 0.488281\t(data_i, data_q): (0.031250,0.968750)\n\t96: o_phase = -9'd125;\t //LUT[96] \tphase : -0.488281\t(data_i, data_q): (0.031250,-1.000000)\n\t97: o_phase = -9'd125;\t //LUT[97] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.968750)\n\t98: o_phase = -9'd125;\t //LUT[98] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.937500)\n\t99: o_phase = -9'd125;\t //LUT[99] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.906250)\n\t100: o_phase = -9'd125;\t //LUT[100] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.875000)\n\t101: o_phase = -9'd125;\t //LUT[101] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.843750)\n\t102: o_phase = -9'd125;\t //LUT[102] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.812500)\n\t103: o_phase = -9'd125;\t //LUT[103] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.781250)\n\t104: o_phase = -9'd125;\t //LUT[104] \tphase : -0.488281\t(data_i, data_q): (0.031250,-0.750000)\n\t105: o_phase = -9'd124;\t //LUT[105] \tphase : -0.484375\t(data_i, data_q): (0.031250,-0.718750)\n\t106: o_phase = -9'd124;\t //LUT[106] \tphase : -0.484375\t(data_i, data_q): (0.031250,-0.687500)\n\t107: o_phase = -9'd124;\t //LUT[107] \tphase : -0.484375\t(data_i, data_q): (0.031250,-0.656250)\n\t108: o_phase = -9'd124;\t //LUT[108] \tphase : -0.484375\t(data_i, data_q): (0.031250,-0.625000)\n\t109: o_phase = -9'd124;\t //LUT[109] \tphase : -0.484375\t(data_i, data_q): (0.031250,-0.593750)\n\t110: o_phase = -9'd123;\t //LUT[110] \tphase : -0.480469\t(data_i, data_q): (0.031250,-0.562500)\n\t111: o_phase = -9'd123;\t //LUT[111] \tphase : -0.480469\t(data_i, data_q): (0.031250,-0.531250)\n\t112: o_phase = -9'd123;\t //LUT[112] \tphase : -0.480469\t(data_i, data_q): (0.031250,-0.500000)\n\t113: o_phase = -9'd123;\t //LUT[113] \tphase : -0.480469\t(data_i, data_q): (0.031250,-0.468750)\n\t114: o_phase = -9'd122;\t //LUT[114] \tphase : -0.476562\t(data_i, data_q): (0.031250,-0.437500)\n\t115: o_phase = -9'd122;\t //LUT[115] \tphase : -0.476562\t(data_i, data_q): (0.031250,-0.406250)\n\t116: o_phase = -9'd121;\t //LUT[116] \tphase : -0.472656\t(data_i, data_q): (0.031250,-0.375000)\n\t117: o_phase = -9'd121;\t //LUT[117] \tphase : -0.472656\t(data_i, data_q): (0.031250,-0.343750)\n\t118: o_phase = -9'd120;\t //LUT[118] \tphase : -0.468750\t(data_i, data_q): (0.031250,-0.312500)\n\t119: o_phase = -9'd119;\t //LUT[119] \tphase : -0.464844\t(data_i, data_q): (0.031250,-0.281250)\n\t120: o_phase = -9'd118;\t //LUT[120] \tphase : -0.460938\t(data_i, data_q): (0.031250,-0.250000)\n\t121: o_phase = -9'd116;\t //LUT[121] \tphase : -0.453125\t(data_i, data_q): (0.031250,-0.218750)\n\t122: o_phase = -9'd115;\t //LUT[122] \tphase : -0.449219\t(data_i, data_q): (0.031250,-0.187500)\n\t123: o_phase = -9'd112;\t //LUT[123] \tphase : -0.437500\t(data_i, data_q): (0.031250,-0.156250)\n\t124: o_phase = -9'd108;\t //LUT[124] \tphase : -0.421875\t(data_i, data_q): (0.031250,-0.125000)\n\t125: o_phase = -9'd102;\t //LUT[125] \tphase : -0.398438\t(data_i, data_q): (0.031250,-0.093750)\n\t126: o_phase = -9'd90;\t //LUT[126] \tphase : -0.351562\t(data_i, data_q): (0.031250,-0.062500)\n\t127: o_phase = -9'd64;\t //LUT[127] \tphase : -0.250000\t(data_i, data_q): (0.031250,-0.031250)\n\t128: o_phase = +9'd0;\t //LUT[128] \tphase : 0.000000\t(data_i, data_q): (0.062500,0.000000)\n\t129: o_phase = +9'd38;\t //LUT[129] \tphase : 0.148438\t(data_i, data_q): (0.062500,0.031250)\n\t130: o_phase = +9'd64;\t //LUT[130] \tphase : 0.250000\t(data_i, data_q): (0.062500,0.062500)\n\t131: o_phase = +9'd80;\t //LUT[131] \tphase : 0.312500\t(data_i, data_q): (0.062500,0.093750)\n\t132: o_phase = +9'd90;\t //LUT[132] \tphase : 0.351562\t(data_i, data_q): (0.062500,0.125000)\n\t133: o_phase = +9'd97;\t //LUT[133] \tphase : 0.378906\t(data_i, data_q): (0.062500,0.156250)\n\t134: o_phase = +9'd102;\t //LUT[134] \tphase : 0.398438\t(data_i, data_q): (0.062500,0.187500)\n\t135: o_phase = +9'd105;\t //LUT[135] \tphase : 0.410156\t(data_i, data_q): (0.062500,0.218750)\n\t136: o_phase = +9'd108;\t //LUT[136] \tphase : 0.421875\t(data_i, data_q): (0.062500,0.250000)\n\t137: o_phase = +9'd110;\t //LUT[137] \tphase : 0.429688\t(data_i, data_q): (0.062500,0.281250)\n\t138: o_phase = +9'd112;\t //LUT[138] \tphase : 0.437500\t(data_i, data_q): (0.062500,0.312500)\n\t139: o_phase = +9'd113;\t //LUT[139] \tphase : 0.441406\t(data_i, data_q): (0.062500,0.343750)\n\t140: o_phase = +9'd115;\t //LUT[140] \tphase : 0.449219\t(data_i, data_q): (0.062500,0.375000)\n\t141: o_phase = +9'd116;\t //LUT[141] \tphase : 0.453125\t(data_i, data_q): (0.062500,0.406250)\n\t142: o_phase = +9'd116;\t //LUT[142] \tphase : 0.453125\t(data_i, data_q): (0.062500,0.437500)\n\t143: o_phase = +9'd117;\t //LUT[143] \tphase : 0.457031\t(data_i, data_q): (0.062500,0.468750)\n\t144: o_phase = +9'd118;\t //LUT[144] \tphase : 0.460938\t(data_i, data_q): (0.062500,0.500000)\n\t145: o_phase = +9'd118;\t //LUT[145] \tphase : 0.460938\t(data_i, data_q): (0.062500,0.531250)\n\t146: o_phase = +9'd119;\t //LUT[146] \tphase : 0.464844\t(data_i, data_q): (0.062500,0.562500)\n\t147: o_phase = +9'd119;\t //LUT[147] \tphase : 0.464844\t(data_i, data_q): (0.062500,0.593750)\n\t148: o_phase = +9'd120;\t //LUT[148] \tphase : 0.468750\t(data_i, data_q): (0.062500,0.625000)\n\t149: o_phase = +9'd120;\t //LUT[149] \tphase : 0.468750\t(data_i, data_q): (0.062500,0.656250)\n\t150: o_phase = +9'd121;\t //LUT[150] \tphase : 0.472656\t(data_i, data_q): (0.062500,0.687500)\n\t151: o_phase = +9'd121;\t //LUT[151] \tphase : 0.472656\t(data_i, data_q): (0.062500,0.718750)\n\t152: o_phase = +9'd121;\t //LUT[152] \tphase : 0.472656\t(data_i, data_q): (0.062500,0.750000)\n\t153: o_phase = +9'd121;\t //LUT[153] \tphase : 0.472656\t(data_i, data_q): (0.062500,0.781250)\n\t154: o_phase = +9'd122;\t //LUT[154] \tphase : 0.476562\t(data_i, data_q): (0.062500,0.812500)\n\t155: o_phase = +9'd122;\t //LUT[155] \tphase : 0.476562\t(data_i, data_q): (0.062500,0.843750)\n\t156: o_phase = +9'd122;\t //LUT[156] \tphase : 0.476562\t(data_i, data_q): (0.062500,0.875000)\n\t157: o_phase = +9'd122;\t //LUT[157] \tphase : 0.476562\t(data_i, data_q): (0.062500,0.906250)\n\t158: o_phase = +9'd123;\t //LUT[158] \tphase : 0.480469\t(data_i, data_q): (0.062500,0.937500)\n\t159: o_phase = +9'd123;\t //LUT[159] \tphase : 0.480469\t(data_i, data_q): (0.062500,0.968750)\n\t160: o_phase = -9'd123;\t //LUT[160] \tphase : -0.480469\t(data_i, data_q): (0.062500,-1.000000)\n\t161: o_phase = -9'd123;\t //LUT[161] \tphase : -0.480469\t(data_i, data_q): (0.062500,-0.968750)\n\t162: o_phase = -9'd123;\t //LUT[162] \tphase : -0.480469\t(data_i, data_q): (0.062500,-0.937500)\n\t163: o_phase = -9'd122;\t //LUT[163] \tphase : -0.476562\t(data_i, data_q): (0.062500,-0.906250)\n\t164: o_phase = -9'd122;\t //LUT[164] \tphase : -0.476562\t(data_i, data_q): (0.062500,-0.875000)\n\t165: o_phase = -9'd122;\t //LUT[165] \tphase : -0.476562\t(data_i, data_q): (0.062500,-0.843750)\n\t166: o_phase = -9'd122;\t //LUT[166] \tphase : -0.476562\t(data_i, data_q): (0.062500,-0.812500)\n\t167: o_phase = -9'd121;\t //LUT[167] \tphase : -0.472656\t(data_i, data_q): (0.062500,-0.781250)\n\t168: o_phase = -9'd121;\t //LUT[168] \tphase : -0.472656\t(data_i, data_q): (0.062500,-0.750000)\n\t169: o_phase = -9'd121;\t //LUT[169] \tphase : -0.472656\t(data_i, data_q): (0.062500,-0.718750)\n\t170: o_phase = -9'd121;\t //LUT[170] \tphase : -0.472656\t(data_i, data_q): (0.062500,-0.687500)\n\t171: o_phase = -9'd120;\t //LUT[171] \tphase : -0.468750\t(data_i, data_q): (0.062500,-0.656250)\n\t172: o_phase = -9'd120;\t //LUT[172] \tphase : -0.468750\t(data_i, data_q): (0.062500,-0.625000)\n\t173: o_phase = -9'd119;\t //LUT[173] \tphase : -0.464844\t(data_i, data_q): (0.062500,-0.593750)\n\t174: o_phase = -9'd119;\t //LUT[174] \tphase : -0.464844\t(data_i, data_q): (0.062500,-0.562500)\n\t175: o_phase = -9'd118;\t //LUT[175] \tphase : -0.460938\t(data_i, data_q): (0.062500,-0.531250)\n\t176: o_phase = -9'd118;\t //LUT[176] \tphase : -0.460938\t(data_i, data_q): (0.062500,-0.500000)\n\t177: o_phase = -9'd117;\t //LUT[177] \tphase : -0.457031\t(data_i, data_q): (0.062500,-0.468750)\n\t178: o_phase = -9'd116;\t //LUT[178] \tphase : -0.453125\t(data_i, data_q): (0.062500,-0.437500)\n\t179: o_phase = -9'd116;\t //LUT[179] \tphase : -0.453125\t(data_i, data_q): (0.062500,-0.406250)\n\t180: o_phase = -9'd115;\t //LUT[180] \tphase : -0.449219\t(data_i, data_q): (0.062500,-0.375000)\n\t181: o_phase = -9'd113;\t //LUT[181] \tphase : -0.441406\t(data_i, data_q): (0.062500,-0.343750)\n\t182: o_phase = -9'd112;\t //LUT[182] \tphase : -0.437500\t(data_i, data_q): (0.062500,-0.312500)\n\t183: o_phase = -9'd110;\t //LUT[183] \tphase : -0.429688\t(data_i, data_q): (0.062500,-0.281250)\n\t184: o_phase = -9'd108;\t //LUT[184] \tphase : -0.421875\t(data_i, data_q): (0.062500,-0.250000)\n\t185: o_phase = -9'd105;\t //LUT[185] \tphase : -0.410156\t(data_i, data_q): (0.062500,-0.218750)\n\t186: o_phase = -9'd102;\t //LUT[186] \tphase : -0.398438\t(data_i, data_q): (0.062500,-0.187500)\n\t187: o_phase = -9'd97;\t //LUT[187] \tphase : -0.378906\t(data_i, data_q): (0.062500,-0.156250)\n\t188: o_phase = -9'd90;\t //LUT[188] \tphase : -0.351562\t(data_i, data_q): (0.062500,-0.125000)\n\t189: o_phase = -9'd80;\t //LUT[189] \tphase : -0.312500\t(data_i, data_q): (0.062500,-0.093750)\n\t190: o_phase = -9'd64;\t //LUT[190] \tphase : -0.250000\t(data_i, data_q): (0.062500,-0.062500)\n\t191: o_phase = -9'd38;\t //LUT[191] \tphase : -0.148438\t(data_i, data_q): (0.062500,-0.031250)\n\t192: o_phase = +9'd0;\t //LUT[192] \tphase : 0.000000\t(data_i, data_q): (0.093750,0.000000)\n\t193: o_phase = +9'd26;\t //LUT[193] \tphase : 0.101562\t(data_i, data_q): (0.093750,0.031250)\n\t194: o_phase = +9'd48;\t //LUT[194] \tphase : 0.187500\t(data_i, data_q): (0.093750,0.062500)\n\t195: o_phase = +9'd64;\t //LUT[195] \tphase : 0.250000\t(data_i, data_q): (0.093750,0.093750)\n\t196: o_phase = +9'd76;\t //LUT[196] \tphase : 0.296875\t(data_i, data_q): (0.093750,0.125000)\n\t197: o_phase = +9'd84;\t //LUT[197] \tphase : 0.328125\t(data_i, data_q): (0.093750,0.156250)\n\t198: o_phase = +9'd90;\t //LUT[198] \tphase : 0.351562\t(data_i, data_q): (0.093750,0.187500)\n\t199: o_phase = +9'd95;\t //LUT[199] \tphase : 0.371094\t(data_i, data_q): (0.093750,0.218750)\n\t200: o_phase = +9'd99;\t //LUT[200] \tphase : 0.386719\t(data_i, data_q): (0.093750,0.250000)\n\t201: o_phase = +9'd102;\t //LUT[201] \tphase : 0.398438\t(data_i, data_q): (0.093750,0.281250)\n\t202: o_phase = +9'd104;\t //LUT[202] \tphase : 0.406250\t(data_i, data_q): (0.093750,0.312500)\n\t203: o_phase = +9'd106;\t //LUT[203] \tphase : 0.414062\t(data_i, data_q): (0.093750,0.343750)\n\t204: o_phase = +9'd108;\t //LUT[204] \tphase : 0.421875\t(data_i, data_q): (0.093750,0.375000)\n\t205: o_phase = +9'd110;\t //LUT[205] \tphase : 0.429688\t(data_i, data_q): (0.093750,0.406250)\n\t206: o_phase = +9'd111;\t //LUT[206] \tphase : 0.433594\t(data_i, data_q): (0.093750,0.437500)\n\t207: o_phase = +9'd112;\t //LUT[207] \tphase : 0.437500\t(data_i, data_q): (0.093750,0.468750)\n\t208: o_phase = +9'd113;\t //LUT[208] \tphase : 0.441406\t(data_i, data_q): (0.093750,0.500000)\n\t209: o_phase = +9'd114;\t //LUT[209] \tphase : 0.445312\t(data_i, data_q): (0.093750,0.531250)\n\t210: o_phase = +9'd115;\t //LUT[210] \tphase : 0.449219\t(data_i, data_q): (0.093750,0.562500)\n\t211: o_phase = +9'd115;\t //LUT[211] \tphase : 0.449219\t(data_i, data_q): (0.093750,0.593750)\n\t212: o_phase = +9'd116;\t //LUT[212] \tphase : 0.453125\t(data_i, data_q): (0.093750,0.625000)\n\t213: o_phase = +9'd116;\t //LUT[213] \tphase : 0.453125\t(data_i, data_q): (0.093750,0.656250)\n\t214: o_phase = +9'd117;\t //LUT[214] \tphase : 0.457031\t(data_i, data_q): (0.093750,0.687500)\n\t215: o_phase = +9'd117;\t //LUT[215] \tphase : 0.457031\t(data_i, data_q): (0.093750,0.718750)\n\t216: o_phase = +9'd118;\t //LUT[216] \tphase : 0.460938\t(data_i, data_q): (0.093750,0.750000)\n\t217: o_phase = +9'd118;\t //LUT[217] \tphase : 0.460938\t(data_i, data_q): (0.093750,0.781250)\n\t218: o_phase = +9'd119;\t //LUT[218] \tphase : 0.464844\t(data_i, data_q): (0.093750,0.812500)\n\t219: o_phase = +9'd119;\t //LUT[219] \tphase : 0.464844\t(data_i, data_q): (0.093750,0.843750)\n\t220: o_phase = +9'd119;\t //LUT[220] \tphase : 0.464844\t(data_i, data_q): (0.093750,0.875000)\n\t221: o_phase = +9'd120;\t //LUT[221] \tphase : 0.468750\t(data_i, data_q): (0.093750,0.906250)\n\t222: o_phase = +9'd120;\t //LUT[222] \tphase : 0.468750\t(data_i, data_q): (0.093750,0.937500)\n\t223: o_phase = +9'd120;\t //LUT[223] \tphase : 0.468750\t(data_i, data_q): (0.093750,0.968750)\n\t224: o_phase = -9'd120;\t //LUT[224] \tphase : -0.468750\t(data_i, data_q): (0.093750,-1.000000)\n\t225: o_phase = -9'd120;\t //LUT[225] \tphase : -0.468750\t(data_i, data_q): (0.093750,-0.968750)\n\t226: o_phase = -9'd120;\t //LUT[226] \tphase : -0.468750\t(data_i, data_q): (0.093750,-0.937500)\n\t227: o_phase = -9'd120;\t //LUT[227] \tphase : -0.468750\t(data_i, data_q): (0.093750,-0.906250)\n\t228: o_phase = -9'd119;\t //LUT[228] \tphase : -0.464844\t(data_i, data_q): (0.093750,-0.875000)\n\t229: o_phase = -9'd119;\t //LUT[229] \tphase : -0.464844\t(data_i, data_q): (0.093750,-0.843750)\n\t230: o_phase = -9'd119;\t //LUT[230] \tphase : -0.464844\t(data_i, data_q): (0.093750,-0.812500)\n\t231: o_phase = -9'd118;\t //LUT[231] \tphase : -0.460938\t(data_i, data_q): (0.093750,-0.781250)\n\t232: o_phase = -9'd118;\t //LUT[232] \tphase : -0.460938\t(data_i, data_q): (0.093750,-0.750000)\n\t233: o_phase = -9'd117;\t //LUT[233] \tphase : -0.457031\t(data_i, data_q): (0.093750,-0.718750)\n\t234: o_phase = -9'd117;\t //LUT[234] \tphase : -0.457031\t(data_i, data_q): (0.093750,-0.687500)\n\t235: o_phase = -9'd116;\t //LUT[235] \tphase : -0.453125\t(data_i, data_q): (0.093750,-0.656250)\n\t236: o_phase = -9'd116;\t //LUT[236] \tphase : -0.453125\t(data_i, data_q): (0.093750,-0.625000)\n\t237: o_phase = -9'd115;\t //LUT[237] \tphase : -0.449219\t(data_i, data_q): (0.093750,-0.593750)\n\t238: o_phase = -9'd115;\t //LUT[238] \tphase : -0.449219\t(data_i, data_q): (0.093750,-0.562500)\n\t239: o_phase = -9'd114;\t //LUT[239] \tphase : -0.445312\t(data_i, data_q): (0.093750,-0.531250)\n\t240: o_phase = -9'd113;\t //LUT[240] \tphase : -0.441406\t(data_i, data_q): (0.093750,-0.500000)\n\t241: o_phase = -9'd112;\t //LUT[241] \tphase : -0.437500\t(data_i, data_q): (0.093750,-0.468750)\n\t242: o_phase = -9'd111;\t //LUT[242] \tphase : -0.433594\t(data_i, data_q): (0.093750,-0.437500)\n\t243: o_phase = -9'd110;\t //LUT[243] \tphase : -0.429688\t(data_i, data_q): (0.093750,-0.406250)\n\t244: o_phase = -9'd108;\t //LUT[244] \tphase : -0.421875\t(data_i, data_q): (0.093750,-0.375000)\n\t245: o_phase = -9'd106;\t //LUT[245] \tphase : -0.414062\t(data_i, data_q): (0.093750,-0.343750)\n\t246: o_phase = -9'd104;\t //LUT[246] \tphase : -0.406250\t(data_i, data_q): (0.093750,-0.312500)\n\t247: o_phase = -9'd102;\t //LUT[247] \tphase : -0.398438\t(data_i, data_q): (0.093750,-0.281250)\n\t248: o_phase = -9'd99;\t //LUT[248] \tphase : -0.386719\t(data_i, data_q): (0.093750,-0.250000)\n\t249: o_phase = -9'd95;\t //LUT[249] \tphase : -0.371094\t(data_i, data_q): (0.093750,-0.218750)\n\t250: o_phase = -9'd90;\t //LUT[250] \tphase : -0.351562\t(data_i, data_q): (0.093750,-0.187500)\n\t251: o_phase = -9'd84;\t //LUT[251] \tphase : -0.328125\t(data_i, data_q): (0.093750,-0.156250)\n\t252: o_phase = -9'd76;\t //LUT[252] \tphase : -0.296875\t(data_i, data_q): (0.093750,-0.125000)\n\t253: o_phase = -9'd64;\t //LUT[253] \tphase : -0.250000\t(data_i, data_q): (0.093750,-0.093750)\n\t254: o_phase = -9'd48;\t //LUT[254] \tphase : -0.187500\t(data_i, data_q): (0.093750,-0.062500)\n\t255: o_phase = -9'd26;\t //LUT[255] \tphase : -0.101562\t(data_i, data_q): (0.093750,-0.031250)\n\t256: o_phase = +9'd0;\t //LUT[256] \tphase : 0.000000\t(data_i, data_q): (0.125000,0.000000)\n\t257: o_phase = +9'd20;\t //LUT[257] \tphase : 0.078125\t(data_i, data_q): (0.125000,0.031250)\n\t258: o_phase = +9'd38;\t //LUT[258] \tphase : 0.148438\t(data_i, data_q): (0.125000,0.062500)\n\t259: o_phase = +9'd52;\t //LUT[259] \tphase : 0.203125\t(data_i, data_q): (0.125000,0.093750)\n\t260: o_phase = +9'd64;\t //LUT[260] \tphase : 0.250000\t(data_i, data_q): (0.125000,0.125000)\n\t261: o_phase = +9'd73;\t //LUT[261] \tphase : 0.285156\t(data_i, data_q): (0.125000,0.156250)\n\t262: o_phase = +9'd80;\t //LUT[262] \tphase : 0.312500\t(data_i, data_q): (0.125000,0.187500)\n\t263: o_phase = +9'd86;\t //LUT[263] \tphase : 0.335938\t(data_i, data_q): (0.125000,0.218750)\n\t264: o_phase = +9'd90;\t //LUT[264] \tphase : 0.351562\t(data_i, data_q): (0.125000,0.250000)\n\t265: o_phase = +9'd94;\t //LUT[265] \tphase : 0.367188\t(data_i, data_q): (0.125000,0.281250)\n\t266: o_phase = +9'd97;\t //LUT[266] \tphase : 0.378906\t(data_i, data_q): (0.125000,0.312500)\n\t267: o_phase = +9'd100;\t //LUT[267] \tphase : 0.390625\t(data_i, data_q): (0.125000,0.343750)\n\t268: o_phase = +9'd102;\t //LUT[268] \tphase : 0.398438\t(data_i, data_q): (0.125000,0.375000)\n\t269: o_phase = +9'd104;\t //LUT[269] \tphase : 0.406250\t(data_i, data_q): (0.125000,0.406250)\n\t270: o_phase = +9'd105;\t //LUT[270] \tphase : 0.410156\t(data_i, data_q): (0.125000,0.437500)\n\t271: o_phase = +9'd107;\t //LUT[271] \tphase : 0.417969\t(data_i, data_q): (0.125000,0.468750)\n\t272: o_phase = +9'd108;\t //LUT[272] \tphase : 0.421875\t(data_i, data_q): (0.125000,0.500000)\n\t273: o_phase = +9'd109;\t //LUT[273] \tphase : 0.425781\t(data_i, data_q): (0.125000,0.531250)\n\t274: o_phase = +9'd110;\t //LUT[274] \tphase : 0.429688\t(data_i, data_q): (0.125000,0.562500)\n\t275: o_phase = +9'd111;\t //LUT[275] \tphase : 0.433594\t(data_i, data_q): (0.125000,0.593750)\n\t276: o_phase = +9'd112;\t //LUT[276] \tphase : 0.437500\t(data_i, data_q): (0.125000,0.625000)\n\t277: o_phase = +9'd113;\t //LUT[277] \tphase : 0.441406\t(data_i, data_q): (0.125000,0.656250)\n\t278: o_phase = +9'd113;\t //LUT[278] \tphase : 0.441406\t(data_i, data_q): (0.125000,0.687500)\n\t279: o_phase = +9'd114;\t //LUT[279] \tphase : 0.445312\t(data_i, data_q): (0.125000,0.718750)\n\t280: o_phase = +9'd115;\t //LUT[280] \tphase : 0.449219\t(data_i, data_q): (0.125000,0.750000)\n\t281: o_phase = +9'd115;\t //LUT[281] \tphase : 0.449219\t(data_i, data_q): (0.125000,0.781250)\n\t282: o_phase = +9'd116;\t //LUT[282] \tphase : 0.453125\t(data_i, data_q): (0.125000,0.812500)\n\t283: o_phase = +9'd116;\t //LUT[283] \tphase : 0.453125\t(data_i, data_q): (0.125000,0.843750)\n\t284: o_phase = +9'd116;\t //LUT[284] \tphase : 0.453125\t(data_i, data_q): (0.125000,0.875000)\n\t285: o_phase = +9'd117;\t //LUT[285] \tphase : 0.457031\t(data_i, data_q): (0.125000,0.906250)\n\t286: o_phase = +9'd117;\t //LUT[286] \tphase : 0.457031\t(data_i, data_q): (0.125000,0.937500)\n\t287: o_phase = +9'd118;\t //LUT[287] \tphase : 0.460938\t(data_i, data_q): (0.125000,0.968750)\n\t288: o_phase = -9'd118;\t //LUT[288] \tphase : -0.460938\t(data_i, data_q): (0.125000,-1.000000)\n\t289: o_phase = -9'd118;\t //LUT[289] \tphase : -0.460938\t(data_i, data_q): (0.125000,-0.968750)\n\t290: o_phase = -9'd117;\t //LUT[290] \tphase : -0.457031\t(data_i, data_q): (0.125000,-0.937500)\n\t291: o_phase = -9'd117;\t //LUT[291] \tphase : -0.457031\t(data_i, data_q): (0.125000,-0.906250)\n\t292: o_phase = -9'd116;\t //LUT[292] \tphase : -0.453125\t(data_i, data_q): (0.125000,-0.875000)\n\t293: o_phase = -9'd116;\t //LUT[293] \tphase : -0.453125\t(data_i, data_q): (0.125000,-0.843750)\n\t294: o_phase = -9'd116;\t //LUT[294] \tphase : -0.453125\t(data_i, data_q): (0.125000,-0.812500)\n\t295: o_phase = -9'd115;\t //LUT[295] \tphase : -0.449219\t(data_i, data_q): (0.125000,-0.781250)\n\t296: o_phase = -9'd115;\t //LUT[296] \tphase : -0.449219\t(data_i, data_q): (0.125000,-0.750000)\n\t297: o_phase = -9'd114;\t //LUT[297] \tphase : -0.445312\t(data_i, data_q): (0.125000,-0.718750)\n\t298: o_phase = -9'd113;\t //LUT[298] \tphase : -0.441406\t(data_i, data_q): (0.125000,-0.687500)\n\t299: o_phase = -9'd113;\t //LUT[299] \tphase : -0.441406\t(data_i, data_q): (0.125000,-0.656250)\n\t300: o_phase = -9'd112;\t //LUT[300] \tphase : -0.437500\t(data_i, data_q): (0.125000,-0.625000)\n\t301: o_phase = -9'd111;\t //LUT[301] \tphase : -0.433594\t(data_i, data_q): (0.125000,-0.593750)\n\t302: o_phase = -9'd110;\t //LUT[302] \tphase : -0.429688\t(data_i, data_q): (0.125000,-0.562500)\n\t303: o_phase = -9'd109;\t //LUT[303] \tphase : -0.425781\t(data_i, data_q): (0.125000,-0.531250)\n\t304: o_phase = -9'd108;\t //LUT[304] \tphase : -0.421875\t(data_i, data_q): (0.125000,-0.500000)\n\t305: o_phase = -9'd107;\t //LUT[305] \tphase : -0.417969\t(data_i, data_q): (0.125000,-0.468750)\n\t306: o_phase = -9'd105;\t //LUT[306] \tphase : -0.410156\t(data_i, data_q): (0.125000,-0.437500)\n\t307: o_phase = -9'd104;\t //LUT[307] \tphase : -0.406250\t(data_i, data_q): (0.125000,-0.406250)\n\t308: o_phase = -9'd102;\t //LUT[308] \tphase : -0.398438\t(data_i, data_q): (0.125000,-0.375000)\n\t309: o_phase = -9'd100;\t //LUT[309] \tphase : -0.390625\t(data_i, data_q): (0.125000,-0.343750)\n\t310: o_phase = -9'd97;\t //LUT[310] \tphase : -0.378906\t(data_i, data_q): (0.125000,-0.312500)\n\t311: o_phase = -9'd94;\t //LUT[311] \tphase : -0.367188\t(data_i, data_q): (0.125000,-0.281250)\n\t312: o_phase = -9'd90;\t //LUT[312] \tphase : -0.351562\t(data_i, data_q): (0.125000,-0.250000)\n\t313: o_phase = -9'd86;\t //LUT[313] \tphase : -0.335938\t(data_i, data_q): (0.125000,-0.218750)\n\t314: o_phase = -9'd80;\t //LUT[314] \tphase : -0.312500\t(data_i, data_q): (0.125000,-0.187500)\n\t315: o_phase = -9'd73;\t //LUT[315] \tphase : -0.285156\t(data_i, data_q): (0.125000,-0.156250)\n\t316: o_phase = -9'd64;\t //LUT[316] \tphase : -0.250000\t(data_i, data_q): (0.125000,-0.125000)\n\t317: o_phase = -9'd52;\t //LUT[317] \tphase : -0.203125\t(data_i, data_q): (0.125000,-0.093750)\n\t318: o_phase = -9'd38;\t //LUT[318] \tphase : -0.148438\t(data_i, data_q): (0.125000,-0.062500)\n\t319: o_phase = -9'd20;\t //LUT[319] \tphase : -0.078125\t(data_i, data_q): (0.125000,-0.031250)\n\t320: o_phase = +9'd0;\t //LUT[320] \tphase : 0.000000\t(data_i, data_q): (0.156250,0.000000)\n\t321: o_phase = +9'd16;\t //LUT[321] \tphase : 0.062500\t(data_i, data_q): (0.156250,0.031250)\n\t322: o_phase = +9'd31;\t //LUT[322] \tphase : 0.121094\t(data_i, data_q): (0.156250,0.062500)\n\t323: o_phase = +9'd44;\t //LUT[323] \tphase : 0.171875\t(data_i, data_q): (0.156250,0.093750)\n\t324: o_phase = +9'd55;\t //LUT[324] \tphase : 0.214844\t(data_i, data_q): (0.156250,0.125000)\n\t325: o_phase = +9'd64;\t //LUT[325] \tphase : 0.250000\t(data_i, data_q): (0.156250,0.156250)\n\t326: o_phase = +9'd71;\t //LUT[326] \tphase : 0.277344\t(data_i, data_q): (0.156250,0.187500)\n\t327: o_phase = +9'd77;\t //LUT[327] \tphase : 0.300781\t(data_i, data_q): (0.156250,0.218750)\n\t328: o_phase = +9'd82;\t //LUT[328] \tphase : 0.320312\t(data_i, data_q): (0.156250,0.250000)\n\t329: o_phase = +9'd87;\t //LUT[329] \tphase : 0.339844\t(data_i, data_q): (0.156250,0.281250)\n\t330: o_phase = +9'd90;\t //LUT[330] \tphase : 0.351562\t(data_i, data_q): (0.156250,0.312500)\n\t331: o_phase = +9'd93;\t //LUT[331] \tphase : 0.363281\t(data_i, data_q): (0.156250,0.343750)\n\t332: o_phase = +9'd96;\t //LUT[332] \tphase : 0.375000\t(data_i, data_q): (0.156250,0.375000)\n\t333: o_phase = +9'd98;\t //LUT[333] \tphase : 0.382812\t(data_i, data_q): (0.156250,0.406250)\n\t334: o_phase = +9'd100;\t //LUT[334] \tphase : 0.390625\t(data_i, data_q): (0.156250,0.437500)\n\t335: o_phase = +9'd102;\t //LUT[335] \tphase : 0.398438\t(data_i, data_q): (0.156250,0.468750)\n\t336: o_phase = +9'd103;\t //LUT[336] \tphase : 0.402344\t(data_i, data_q): (0.156250,0.500000)\n\t337: o_phase = +9'd105;\t //LUT[337] \tphase : 0.410156\t(data_i, data_q): (0.156250,0.531250)\n\t338: o_phase = +9'd106;\t //LUT[338] \tphase : 0.414062\t(data_i, data_q): (0.156250,0.562500)\n\t339: o_phase = +9'd107;\t //LUT[339] \tphase : 0.417969\t(data_i, data_q): (0.156250,0.593750)\n\t340: o_phase = +9'd108;\t //LUT[340] \tphase : 0.421875\t(data_i, data_q): (0.156250,0.625000)\n\t341: o_phase = +9'd109;\t //LUT[341] \tphase : 0.425781\t(data_i, data_q): (0.156250,0.656250)\n\t342: o_phase = +9'd110;\t //LUT[342] \tphase : 0.429688\t(data_i, data_q): (0.156250,0.687500)\n\t343: o_phase = +9'd111;\t //LUT[343] \tphase : 0.433594\t(data_i, data_q): (0.156250,0.718750)\n\t344: o_phase = +9'd111;\t //LUT[344] \tphase : 0.433594\t(data_i, data_q): (0.156250,0.750000)\n\t345: o_phase = +9'd112;\t //LUT[345] \tphase : 0.437500\t(data_i, data_q): (0.156250,0.781250)\n\t346: o_phase = +9'd113;\t //LUT[346] \tphase : 0.441406\t(data_i, data_q): (0.156250,0.812500)\n\t347: o_phase = +9'd113;\t //LUT[347] \tphase : 0.441406\t(data_i, data_q): (0.156250,0.843750)\n\t348: o_phase = +9'd114;\t //LUT[348] \tphase : 0.445312\t(data_i, data_q): (0.156250,0.875000)\n\t349: o_phase = +9'd114;\t //LUT[349] \tphase : 0.445312\t(data_i, data_q): (0.156250,0.906250)\n\t350: o_phase = +9'd115;\t //LUT[350] \tphase : 0.449219\t(data_i, data_q): (0.156250,0.937500)\n\t351: o_phase = +9'd115;\t //LUT[351] \tphase : 0.449219\t(data_i, data_q): (0.156250,0.968750)\n\t352: o_phase = -9'd115;\t //LUT[352] \tphase : -0.449219\t(data_i, data_q): (0.156250,-1.000000)\n\t353: o_phase = -9'd115;\t //LUT[353] \tphase : -0.449219\t(data_i, data_q): (0.156250,-0.968750)\n\t354: o_phase = -9'd115;\t //LUT[354] \tphase : -0.449219\t(data_i, data_q): (0.156250,-0.937500)\n\t355: o_phase = -9'd114;\t //LUT[355] \tphase : -0.445312\t(data_i, data_q): (0.156250,-0.906250)\n\t356: o_phase = -9'd114;\t //LUT[356] \tphase : -0.445312\t(data_i, data_q): (0.156250,-0.875000)\n\t357: o_phase = -9'd113;\t //LUT[357] \tphase : -0.441406\t(data_i, data_q): (0.156250,-0.843750)\n\t358: o_phase = -9'd113;\t //LUT[358] \tphase : -0.441406\t(data_i, data_q): (0.156250,-0.812500)\n\t359: o_phase = -9'd112;\t //LUT[359] \tphase : -0.437500\t(data_i, data_q): (0.156250,-0.781250)\n\t360: o_phase = -9'd111;\t //LUT[360] \tphase : -0.433594\t(data_i, data_q): (0.156250,-0.750000)\n\t361: o_phase = -9'd111;\t //LUT[361] \tphase : -0.433594\t(data_i, data_q): (0.156250,-0.718750)\n\t362: o_phase = -9'd110;\t //LUT[362] \tphase : -0.429688\t(data_i, data_q): (0.156250,-0.687500)\n\t363: o_phase = -9'd109;\t //LUT[363] \tphase : -0.425781\t(data_i, data_q): (0.156250,-0.656250)\n\t364: o_phase = -9'd108;\t //LUT[364] \tphase : -0.421875\t(data_i, data_q): (0.156250,-0.625000)\n\t365: o_phase = -9'd107;\t //LUT[365] \tphase : -0.417969\t(data_i, data_q): (0.156250,-0.593750)\n\t366: o_phase = -9'd106;\t //LUT[366] \tphase : -0.414062\t(data_i, data_q): (0.156250,-0.562500)\n\t367: o_phase = -9'd105;\t //LUT[367] \tphase : -0.410156\t(data_i, data_q): (0.156250,-0.531250)\n\t368: o_phase = -9'd103;\t //LUT[368] \tphase : -0.402344\t(data_i, data_q): (0.156250,-0.500000)\n\t369: o_phase = -9'd102;\t //LUT[369] \tphase : -0.398438\t(data_i, data_q): (0.156250,-0.468750)\n\t370: o_phase = -9'd100;\t //LUT[370] \tphase : -0.390625\t(data_i, data_q): (0.156250,-0.437500)\n\t371: o_phase = -9'd98;\t //LUT[371] \tphase : -0.382812\t(data_i, data_q): (0.156250,-0.406250)\n\t372: o_phase = -9'd96;\t //LUT[372] \tphase : -0.375000\t(data_i, data_q): (0.156250,-0.375000)\n\t373: o_phase = -9'd93;\t //LUT[373] \tphase : -0.363281\t(data_i, data_q): (0.156250,-0.343750)\n\t374: o_phase = -9'd90;\t //LUT[374] \tphase : -0.351562\t(data_i, data_q): (0.156250,-0.312500)\n\t375: o_phase = -9'd87;\t //LUT[375] \tphase : -0.339844\t(data_i, data_q): (0.156250,-0.281250)\n\t376: o_phase = -9'd82;\t //LUT[376] \tphase : -0.320312\t(data_i, data_q): (0.156250,-0.250000)\n\t377: o_phase = -9'd77;\t //LUT[377] \tphase : -0.300781\t(data_i, data_q): (0.156250,-0.218750)\n\t378: o_phase = -9'd71;\t //LUT[378] \tphase : -0.277344\t(data_i, data_q): (0.156250,-0.187500)\n\t379: o_phase = -9'd64;\t //LUT[379] \tphase : -0.250000\t(data_i, data_q): (0.156250,-0.156250)\n\t380: o_phase = -9'd55;\t //LUT[380] \tphase : -0.214844\t(data_i, data_q): (0.156250,-0.125000)\n\t381: o_phase = -9'd44;\t //LUT[381] \tphase : -0.171875\t(data_i, data_q): (0.156250,-0.093750)\n\t382: o_phase = -9'd31;\t //LUT[382] \tphase : -0.121094\t(data_i, data_q): (0.156250,-0.062500)\n\t383: o_phase = -9'd16;\t //LUT[383] \tphase : -0.062500\t(data_i, data_q): (0.156250,-0.031250)\n\t384: o_phase = +9'd0;\t //LUT[384] \tphase : 0.000000\t(data_i, data_q): (0.187500,0.000000)\n\t385: o_phase = +9'd13;\t //LUT[385] \tphase : 0.050781\t(data_i, data_q): (0.187500,0.031250)\n\t386: o_phase = +9'd26;\t //LUT[386] \tphase : 0.101562\t(data_i, data_q): (0.187500,0.062500)\n\t387: o_phase = +9'd38;\t //LUT[387] \tphase : 0.148438\t(data_i, data_q): (0.187500,0.093750)\n\t388: o_phase = +9'd48;\t //LUT[388] \tphase : 0.187500\t(data_i, data_q): (0.187500,0.125000)\n\t389: o_phase = +9'd57;\t //LUT[389] \tphase : 0.222656\t(data_i, data_q): (0.187500,0.156250)\n\t390: o_phase = +9'd64;\t //LUT[390] \tphase : 0.250000\t(data_i, data_q): (0.187500,0.187500)\n\t391: o_phase = +9'd70;\t //LUT[391] \tphase : 0.273438\t(data_i, data_q): (0.187500,0.218750)\n\t392: o_phase = +9'd76;\t //LUT[392] \tphase : 0.296875\t(data_i, data_q): (0.187500,0.250000)\n\t393: o_phase = +9'd80;\t //LUT[393] \tphase : 0.312500\t(data_i, data_q): (0.187500,0.281250)\n\t394: o_phase = +9'd84;\t //LUT[394] \tphase : 0.328125\t(data_i, data_q): (0.187500,0.312500)\n\t395: o_phase = +9'd87;\t //LUT[395] \tphase : 0.339844\t(data_i, data_q): (0.187500,0.343750)\n\t396: o_phase = +9'd90;\t //LUT[396] \tphase : 0.351562\t(data_i, data_q): (0.187500,0.375000)\n\t397: o_phase = +9'd93;\t //LUT[397] \tphase : 0.363281\t(data_i, data_q): (0.187500,0.406250)\n\t398: o_phase = +9'd95;\t //LUT[398] \tphase : 0.371094\t(data_i, data_q): (0.187500,0.437500)\n\t399: o_phase = +9'd97;\t //LUT[399] \tphase : 0.378906\t(data_i, data_q): (0.187500,0.468750)\n\t400: o_phase = +9'd99;\t //LUT[400] \tphase : 0.386719\t(data_i, data_q): (0.187500,0.500000)\n\t401: o_phase = +9'd100;\t //LUT[401] \tphase : 0.390625\t(data_i, data_q): (0.187500,0.531250)\n\t402: o_phase = +9'd102;\t //LUT[402] \tphase : 0.398438\t(data_i, data_q): (0.187500,0.562500)\n\t403: o_phase = +9'd103;\t //LUT[403] \tphase : 0.402344\t(data_i, data_q): (0.187500,0.593750)\n\t404: o_phase = +9'd104;\t //LUT[404] \tphase : 0.406250\t(data_i, data_q): (0.187500,0.625000)\n\t405: o_phase = +9'd105;\t //LUT[405] \tphase : 0.410156\t(data_i, data_q): (0.187500,0.656250)\n\t406: o_phase = +9'd106;\t //LUT[406] \tphase : 0.414062\t(data_i, data_q): (0.187500,0.687500)\n\t407: o_phase = +9'd107;\t //LUT[407] \tphase : 0.417969\t(data_i, data_q): (0.187500,0.718750)\n\t408: o_phase = +9'd108;\t //LUT[408] \tphase : 0.421875\t(data_i, data_q): (0.187500,0.750000)\n\t409: o_phase = +9'd109;\t //LUT[409] \tphase : 0.425781\t(data_i, data_q): (0.187500,0.781250)\n\t410: o_phase = +9'd110;\t //LUT[410] \tphase : 0.429688\t(data_i, data_q): (0.187500,0.812500)\n\t411: o_phase = +9'd110;\t //LUT[411] \tphase : 0.429688\t(data_i, data_q): (0.187500,0.843750)\n\t412: o_phase = +9'd111;\t //LUT[412] \tphase : 0.433594\t(data_i, data_q): (0.187500,0.875000)\n\t413: o_phase = +9'd111;\t //LUT[413] \tphase : 0.433594\t(data_i, data_q): (0.187500,0.906250)\n\t414: o_phase = +9'd112;\t //LUT[414] \tphase : 0.437500\t(data_i, data_q): (0.187500,0.937500)\n\t415: o_phase = +9'd112;\t //LUT[415] \tphase : 0.437500\t(data_i, data_q): (0.187500,0.968750)\n\t416: o_phase = -9'd113;\t //LUT[416] \tphase : -0.441406\t(data_i, data_q): (0.187500,-1.000000)\n\t417: o_phase = -9'd112;\t //LUT[417] \tphase : -0.437500\t(data_i, data_q): (0.187500,-0.968750)\n\t418: o_phase = -9'd112;\t //LUT[418] \tphase : -0.437500\t(data_i, data_q): (0.187500,-0.937500)\n\t419: o_phase = -9'd111;\t //LUT[419] \tphase : -0.433594\t(data_i, data_q): (0.187500,-0.906250)\n\t420: o_phase = -9'd111;\t //LUT[420] \tphase : -0.433594\t(data_i, data_q): (0.187500,-0.875000)\n\t421: o_phase = -9'd110;\t //LUT[421] \tphase : -0.429688\t(data_i, data_q): (0.187500,-0.843750)\n\t422: o_phase = -9'd110;\t //LUT[422] \tphase : -0.429688\t(data_i, data_q): (0.187500,-0.812500)\n\t423: o_phase = -9'd109;\t //LUT[423] \tphase : -0.425781\t(data_i, data_q): (0.187500,-0.781250)\n\t424: o_phase = -9'd108;\t //LUT[424] \tphase : -0.421875\t(data_i, data_q): (0.187500,-0.750000)\n\t425: o_phase = -9'd107;\t //LUT[425] \tphase : -0.417969\t(data_i, data_q): (0.187500,-0.718750)\n\t426: o_phase = -9'd106;\t //LUT[426] \tphase : -0.414062\t(data_i, data_q): (0.187500,-0.687500)\n\t427: o_phase = -9'd105;\t //LUT[427] \tphase : -0.410156\t(data_i, data_q): (0.187500,-0.656250)\n\t428: o_phase = -9'd104;\t //LUT[428] \tphase : -0.406250\t(data_i, data_q): (0.187500,-0.625000)\n\t429: o_phase = -9'd103;\t //LUT[429] \tphase : -0.402344\t(data_i, data_q): (0.187500,-0.593750)\n\t430: o_phase = -9'd102;\t //LUT[430] \tphase : -0.398438\t(data_i, data_q): (0.187500,-0.562500)\n\t431: o_phase = -9'd100;\t //LUT[431] \tphase : -0.390625\t(data_i, data_q): (0.187500,-0.531250)\n\t432: o_phase = -9'd99;\t //LUT[432] \tphase : -0.386719\t(data_i, data_q): (0.187500,-0.500000)\n\t433: o_phase = -9'd97;\t //LUT[433] \tphase : -0.378906\t(data_i, data_q): (0.187500,-0.468750)\n\t434: o_phase = -9'd95;\t //LUT[434] \tphase : -0.371094\t(data_i, data_q): (0.187500,-0.437500)\n\t435: o_phase = -9'd93;\t //LUT[435] \tphase : -0.363281\t(data_i, data_q): (0.187500,-0.406250)\n\t436: o_phase = -9'd90;\t //LUT[436] \tphase : -0.351562\t(data_i, data_q): (0.187500,-0.375000)\n\t437: o_phase = -9'd87;\t //LUT[437] \tphase : -0.339844\t(data_i, data_q): (0.187500,-0.343750)\n\t438: o_phase = -9'd84;\t //LUT[438] \tphase : -0.328125\t(data_i, data_q): (0.187500,-0.312500)\n\t439: o_phase = -9'd80;\t //LUT[439] \tphase : -0.312500\t(data_i, data_q): (0.187500,-0.281250)\n\t440: o_phase = -9'd76;\t //LUT[440] \tphase : -0.296875\t(data_i, data_q): (0.187500,-0.250000)\n\t441: o_phase = -9'd70;\t //LUT[441] \tphase : -0.273438\t(data_i, data_q): (0.187500,-0.218750)\n\t442: o_phase = -9'd64;\t //LUT[442] \tphase : -0.250000\t(data_i, data_q): (0.187500,-0.187500)\n\t443: o_phase = -9'd57;\t //LUT[443] \tphase : -0.222656\t(data_i, data_q): (0.187500,-0.156250)\n\t444: o_phase = -9'd48;\t //LUT[444] \tphase : -0.187500\t(data_i, data_q): (0.187500,-0.125000)\n\t445: o_phase = -9'd38;\t //LUT[445] \tphase : -0.148438\t(data_i, data_q): (0.187500,-0.093750)\n\t446: o_phase = -9'd26;\t //LUT[446] \tphase : -0.101562\t(data_i, data_q): (0.187500,-0.062500)\n\t447: o_phase = -9'd13;\t //LUT[447] \tphase : -0.050781\t(data_i, data_q): (0.187500,-0.031250)\n\t448: o_phase = +9'd0;\t //LUT[448] \tphase : 0.000000\t(data_i, data_q): (0.218750,0.000000)\n\t449: o_phase = +9'd12;\t //LUT[449] \tphase : 0.046875\t(data_i, data_q): (0.218750,0.031250)\n\t450: o_phase = +9'd23;\t //LUT[450] \tphase : 0.089844\t(data_i, data_q): (0.218750,0.062500)\n\t451: o_phase = +9'd33;\t //LUT[451] \tphase : 0.128906\t(data_i, data_q): (0.218750,0.093750)\n\t452: o_phase = +9'd42;\t //LUT[452] \tphase : 0.164062\t(data_i, data_q): (0.218750,0.125000)\n\t453: o_phase = +9'd51;\t //LUT[453] \tphase : 0.199219\t(data_i, data_q): (0.218750,0.156250)\n\t454: o_phase = +9'd58;\t //LUT[454] \tphase : 0.226562\t(data_i, data_q): (0.218750,0.187500)\n\t455: o_phase = +9'd64;\t //LUT[455] \tphase : 0.250000\t(data_i, data_q): (0.218750,0.218750)\n\t456: o_phase = +9'd69;\t //LUT[456] \tphase : 0.269531\t(data_i, data_q): (0.218750,0.250000)\n\t457: o_phase = +9'd74;\t //LUT[457] \tphase : 0.289062\t(data_i, data_q): (0.218750,0.281250)\n\t458: o_phase = +9'd78;\t //LUT[458] \tphase : 0.304688\t(data_i, data_q): (0.218750,0.312500)\n\t459: o_phase = +9'd82;\t //LUT[459] \tphase : 0.320312\t(data_i, data_q): (0.218750,0.343750)\n\t460: o_phase = +9'd85;\t //LUT[460] \tphase : 0.332031\t(data_i, data_q): (0.218750,0.375000)\n\t461: o_phase = +9'd88;\t //LUT[461] \tphase : 0.343750\t(data_i, data_q): (0.218750,0.406250)\n\t462: o_phase = +9'd90;\t //LUT[462] \tphase : 0.351562\t(data_i, data_q): (0.218750,0.437500)\n\t463: o_phase = +9'd92;\t //LUT[463] \tphase : 0.359375\t(data_i, data_q): (0.218750,0.468750)\n\t464: o_phase = +9'd94;\t //LUT[464] \tphase : 0.367188\t(data_i, data_q): (0.218750,0.500000)\n\t465: o_phase = +9'd96;\t //LUT[465] \tphase : 0.375000\t(data_i, data_q): (0.218750,0.531250)\n\t466: o_phase = +9'd98;\t //LUT[466] \tphase : 0.382812\t(data_i, data_q): (0.218750,0.562500)\n\t467: o_phase = +9'd99;\t //LUT[467] \tphase : 0.386719\t(data_i, data_q): (0.218750,0.593750)\n\t468: o_phase = +9'd101;\t //LUT[468] \tphase : 0.394531\t(data_i, data_q): (0.218750,0.625000)\n\t469: o_phase = +9'd102;\t //LUT[469] \tphase : 0.398438\t(data_i, data_q): (0.218750,0.656250)\n\t470: o_phase = +9'd103;\t //LUT[470] \tphase : 0.402344\t(data_i, data_q): (0.218750,0.687500)\n\t471: o_phase = +9'd104;\t //LUT[471] \tphase : 0.406250\t(data_i, data_q): (0.218750,0.718750)\n\t472: o_phase = +9'd105;\t //LUT[472] \tphase : 0.410156\t(data_i, data_q): (0.218750,0.750000)\n\t473: o_phase = +9'd106;\t //LUT[473] \tphase : 0.414062\t(data_i, data_q): (0.218750,0.781250)\n\t474: o_phase = +9'd107;\t //LUT[474] \tphase : 0.417969\t(data_i, data_q): (0.218750,0.812500)\n\t475: o_phase = +9'd107;\t //LUT[475] \tphase : 0.417969\t(data_i, data_q): (0.218750,0.843750)\n\t476: o_phase = +9'd108;\t //LUT[476] \tphase : 0.421875\t(data_i, data_q): (0.218750,0.875000)\n\t477: o_phase = +9'd109;\t //LUT[477] \tphase : 0.425781\t(data_i, data_q): (0.218750,0.906250)\n\t478: o_phase = +9'd109;\t //LUT[478] \tphase : 0.425781\t(data_i, data_q): (0.218750,0.937500)\n\t479: o_phase = +9'd110;\t //LUT[479] \tphase : 0.429688\t(data_i, data_q): (0.218750,0.968750)\n\t480: o_phase = -9'd110;\t //LUT[480] \tphase : -0.429688\t(data_i, data_q): (0.218750,-1.000000)\n\t481: o_phase = -9'd110;\t //LUT[481] \tphase : -0.429688\t(data_i, data_q): (0.218750,-0.968750)\n\t482: o_phase = -9'd109;\t //LUT[482] \tphase : -0.425781\t(data_i, data_q): (0.218750,-0.937500)\n\t483: o_phase = -9'd109;\t //LUT[483] \tphase : -0.425781\t(data_i, data_q): (0.218750,-0.906250)\n\t484: o_phase = -9'd108;\t //LUT[484] \tphase : -0.421875\t(data_i, data_q): (0.218750,-0.875000)\n\t485: o_phase = -9'd107;\t //LUT[485] \tphase : -0.417969\t(data_i, data_q): (0.218750,-0.843750)\n\t486: o_phase = -9'd107;\t //LUT[486] \tphase : -0.417969\t(data_i, data_q): (0.218750,-0.812500)\n\t487: o_phase = -9'd106;\t //LUT[487] \tphase : -0.414062\t(data_i, data_q): (0.218750,-0.781250)\n\t488: o_phase = -9'd105;\t //LUT[488] \tphase : -0.410156\t(data_i, data_q): (0.218750,-0.750000)\n\t489: o_phase = -9'd104;\t //LUT[489] \tphase : -0.406250\t(data_i, data_q): (0.218750,-0.718750)\n\t490: o_phase = -9'd103;\t //LUT[490] \tphase : -0.402344\t(data_i, data_q): (0.218750,-0.687500)\n\t491: o_phase = -9'd102;\t //LUT[491] \tphase : -0.398438\t(data_i, data_q): (0.218750,-0.656250)\n\t492: o_phase = -9'd101;\t //LUT[492] \tphase : -0.394531\t(data_i, data_q): (0.218750,-0.625000)\n\t493: o_phase = -9'd99;\t //LUT[493] \tphase : -0.386719\t(data_i, data_q): (0.218750,-0.593750)\n\t494: o_phase = -9'd98;\t //LUT[494] \tphase : -0.382812\t(data_i, data_q): (0.218750,-0.562500)\n\t495: o_phase = -9'd96;\t //LUT[495] \tphase : -0.375000\t(data_i, data_q): (0.218750,-0.531250)\n\t496: o_phase = -9'd94;\t //LUT[496] \tphase : -0.367188\t(data_i, data_q): (0.218750,-0.500000)\n\t497: o_phase = -9'd92;\t //LUT[497] \tphase : -0.359375\t(data_i, data_q): (0.218750,-0.468750)\n\t498: o_phase = -9'd90;\t //LUT[498] \tphase : -0.351562\t(data_i, data_q): (0.218750,-0.437500)\n\t499: o_phase = -9'd88;\t //LUT[499] \tphase : -0.343750\t(data_i, data_q): (0.218750,-0.406250)\n\t500: o_phase = -9'd85;\t //LUT[500] \tphase : -0.332031\t(data_i, data_q): (0.218750,-0.375000)\n\t501: o_phase = -9'd82;\t //LUT[501] \tphase : -0.320312\t(data_i, data_q): (0.218750,-0.343750)\n\t502: o_phase = -9'd78;\t //LUT[502] \tphase : -0.304688\t(data_i, data_q): (0.218750,-0.312500)\n\t503: o_phase = -9'd74;\t //LUT[503] \tphase : -0.289062\t(data_i, data_q): (0.218750,-0.281250)\n\t504: o_phase = -9'd69;\t //LUT[504] \tphase : -0.269531\t(data_i, data_q): (0.218750,-0.250000)\n\t505: o_phase = -9'd64;\t //LUT[505] \tphase : -0.250000\t(data_i, data_q): (0.218750,-0.218750)\n\t506: o_phase = -9'd58;\t //LUT[506] \tphase : -0.226562\t(data_i, data_q): (0.218750,-0.187500)\n\t507: o_phase = -9'd51;\t //LUT[507] \tphase : -0.199219\t(data_i, data_q): (0.218750,-0.156250)\n\t508: o_phase = -9'd42;\t //LUT[508] \tphase : -0.164062\t(data_i, data_q): (0.218750,-0.125000)\n\t509: o_phase = -9'd33;\t //LUT[509] \tphase : -0.128906\t(data_i, data_q): (0.218750,-0.093750)\n\t510: o_phase = -9'd23;\t //LUT[510] \tphase : -0.089844\t(data_i, data_q): (0.218750,-0.062500)\n\t511: o_phase = -9'd12;\t //LUT[511] \tphase : -0.046875\t(data_i, data_q): (0.218750,-0.031250)\n\t512: o_phase = +9'd0;\t //LUT[512] \tphase : 0.000000\t(data_i, data_q): (0.250000,0.000000)\n\t513: o_phase = +9'd10;\t //LUT[513] \tphase : 0.039062\t(data_i, data_q): (0.250000,0.031250)\n\t514: o_phase = +9'd20;\t //LUT[514] \tphase : 0.078125\t(data_i, data_q): (0.250000,0.062500)\n\t515: o_phase = +9'd29;\t //LUT[515] \tphase : 0.113281\t(data_i, data_q): (0.250000,0.093750)\n\t516: o_phase = +9'd38;\t //LUT[516] \tphase : 0.148438\t(data_i, data_q): (0.250000,0.125000)\n\t517: o_phase = +9'd46;\t //LUT[517] \tphase : 0.179688\t(data_i, data_q): (0.250000,0.156250)\n\t518: o_phase = +9'd52;\t //LUT[518] \tphase : 0.203125\t(data_i, data_q): (0.250000,0.187500)\n\t519: o_phase = +9'd59;\t //LUT[519] \tphase : 0.230469\t(data_i, data_q): (0.250000,0.218750)\n\t520: o_phase = +9'd64;\t //LUT[520] \tphase : 0.250000\t(data_i, data_q): (0.250000,0.250000)\n\t521: o_phase = +9'd69;\t //LUT[521] \tphase : 0.269531\t(data_i, data_q): (0.250000,0.281250)\n\t522: o_phase = +9'd73;\t //LUT[522] \tphase : 0.285156\t(data_i, data_q): (0.250000,0.312500)\n\t523: o_phase = +9'd77;\t //LUT[523] \tphase : 0.300781\t(data_i, data_q): (0.250000,0.343750)\n\t524: o_phase = +9'd80;\t //LUT[524] \tphase : 0.312500\t(data_i, data_q): (0.250000,0.375000)\n\t525: o_phase = +9'd83;\t //LUT[525] \tphase : 0.324219\t(data_i, data_q): (0.250000,0.406250)\n\t526: o_phase = +9'd86;\t //LUT[526] \tphase : 0.335938\t(data_i, data_q): (0.250000,0.437500)\n\t527: o_phase = +9'd88;\t //LUT[527] \tphase : 0.343750\t(data_i, data_q): (0.250000,0.468750)\n\t528: o_phase = +9'd90;\t //LUT[528] \tphase : 0.351562\t(data_i, data_q): (0.250000,0.500000)\n\t529: o_phase = +9'd92;\t //LUT[529] \tphase : 0.359375\t(data_i, data_q): (0.250000,0.531250)\n\t530: o_phase = +9'd94;\t //LUT[530] \tphase : 0.367188\t(data_i, data_q): (0.250000,0.562500)\n\t531: o_phase = +9'd96;\t //LUT[531] \tphase : 0.375000\t(data_i, data_q): (0.250000,0.593750)\n\t532: o_phase = +9'd97;\t //LUT[532] \tphase : 0.378906\t(data_i, data_q): (0.250000,0.625000)\n\t533: o_phase = +9'd98;\t //LUT[533] \tphase : 0.382812\t(data_i, data_q): (0.250000,0.656250)\n\t534: o_phase = +9'd100;\t //LUT[534] \tphase : 0.390625\t(data_i, data_q): (0.250000,0.687500)\n\t535: o_phase = +9'd101;\t //LUT[535] \tphase : 0.394531\t(data_i, data_q): (0.250000,0.718750)\n\t536: o_phase = +9'd102;\t //LUT[536] \tphase : 0.398438\t(data_i, data_q): (0.250000,0.750000)\n\t537: o_phase = +9'd103;\t //LUT[537] \tphase : 0.402344\t(data_i, data_q): (0.250000,0.781250)\n\t538: o_phase = +9'd104;\t //LUT[538] \tphase : 0.406250\t(data_i, data_q): (0.250000,0.812500)\n\t539: o_phase = +9'd105;\t //LUT[539] \tphase : 0.410156\t(data_i, data_q): (0.250000,0.843750)\n\t540: o_phase = +9'd105;\t //LUT[540] \tphase : 0.410156\t(data_i, data_q): (0.250000,0.875000)\n\t541: o_phase = +9'd106;\t //LUT[541] \tphase : 0.414062\t(data_i, data_q): (0.250000,0.906250)\n\t542: o_phase = +9'd107;\t //LUT[542] \tphase : 0.417969\t(data_i, data_q): (0.250000,0.937500)\n\t543: o_phase = +9'd107;\t //LUT[543] \tphase : 0.417969\t(data_i, data_q): (0.250000,0.968750)\n\t544: o_phase = -9'd108;\t //LUT[544] \tphase : -0.421875\t(data_i, data_q): (0.250000,-1.000000)\n\t545: o_phase = -9'd107;\t //LUT[545] \tphase : -0.417969\t(data_i, data_q): (0.250000,-0.968750)\n\t546: o_phase = -9'd107;\t //LUT[546] \tphase : -0.417969\t(data_i, data_q): (0.250000,-0.937500)\n\t547: o_phase = -9'd106;\t //LUT[547] \tphase : -0.414062\t(data_i, data_q): (0.250000,-0.906250)\n\t548: o_phase = -9'd105;\t //LUT[548] \tphase : -0.410156\t(data_i, data_q): (0.250000,-0.875000)\n\t549: o_phase = -9'd105;\t //LUT[549] \tphase : -0.410156\t(data_i, data_q): (0.250000,-0.843750)\n\t550: o_phase = -9'd104;\t //LUT[550] \tphase : -0.406250\t(data_i, data_q): (0.250000,-0.812500)\n\t551: o_phase = -9'd103;\t //LUT[551] \tphase : -0.402344\t(data_i, data_q): (0.250000,-0.781250)\n\t552: o_phase = -9'd102;\t //LUT[552] \tphase : -0.398438\t(data_i, data_q): (0.250000,-0.750000)\n\t553: o_phase = -9'd101;\t //LUT[553] \tphase : -0.394531\t(data_i, data_q): (0.250000,-0.718750)\n\t554: o_phase = -9'd100;\t //LUT[554] \tphase : -0.390625\t(data_i, data_q): (0.250000,-0.687500)\n\t555: o_phase = -9'd98;\t //LUT[555] \tphase : -0.382812\t(data_i, data_q): (0.250000,-0.656250)\n\t556: o_phase = -9'd97;\t //LUT[556] \tphase : -0.378906\t(data_i, data_q): (0.250000,-0.625000)\n\t557: o_phase = -9'd96;\t //LUT[557] \tphase : -0.375000\t(data_i, data_q): (0.250000,-0.593750)\n\t558: o_phase = -9'd94;\t //LUT[558] \tphase : -0.367188\t(data_i, data_q): (0.250000,-0.562500)\n\t559: o_phase = -9'd92;\t //LUT[559] \tphase : -0.359375\t(data_i, data_q): (0.250000,-0.531250)\n\t560: o_phase = -9'd90;\t //LUT[560] \tphase : -0.351562\t(data_i, data_q): (0.250000,-0.500000)\n\t561: o_phase = -9'd88;\t //LUT[561] \tphase : -0.343750\t(data_i, data_q): (0.250000,-0.468750)\n\t562: o_phase = -9'd86;\t //LUT[562] \tphase : -0.335938\t(data_i, data_q): (0.250000,-0.437500)\n\t563: o_phase = -9'd83;\t //LUT[563] \tphase : -0.324219\t(data_i, data_q): (0.250000,-0.406250)\n\t564: o_phase = -9'd80;\t //LUT[564] \tphase : -0.312500\t(data_i, data_q): (0.250000,-0.375000)\n\t565: o_phase = -9'd77;\t //LUT[565] \tphase : -0.300781\t(data_i, data_q): (0.250000,-0.343750)\n\t566: o_phase = -9'd73;\t //LUT[566] \tphase : -0.285156\t(data_i, data_q): (0.250000,-0.312500)\n\t567: o_phase = -9'd69;\t //LUT[567] \tphase : -0.269531\t(data_i, data_q): (0.250000,-0.281250)\n\t568: o_phase = -9'd64;\t //LUT[568] \tphase : -0.250000\t(data_i, data_q): (0.250000,-0.250000)\n\t569: o_phase = -9'd59;\t //LUT[569] \tphase : -0.230469\t(data_i, data_q): (0.250000,-0.218750)\n\t570: o_phase = -9'd52;\t //LUT[570] \tphase : -0.203125\t(data_i, data_q): (0.250000,-0.187500)\n\t571: o_phase = -9'd46;\t //LUT[571] \tphase : -0.179688\t(data_i, data_q): (0.250000,-0.156250)\n\t572: o_phase = -9'd38;\t //LUT[572] \tphase : -0.148438\t(data_i, data_q): (0.250000,-0.125000)\n\t573: o_phase = -9'd29;\t //LUT[573] \tphase : -0.113281\t(data_i, data_q): (0.250000,-0.093750)\n\t574: o_phase = -9'd20;\t //LUT[574] \tphase : -0.078125\t(data_i, data_q): (0.250000,-0.062500)\n\t575: o_phase = -9'd10;\t //LUT[575] \tphase : -0.039062\t(data_i, data_q): (0.250000,-0.031250)\n\t576: o_phase = +9'd0;\t //LUT[576] \tphase : 0.000000\t(data_i, data_q): (0.281250,0.000000)\n\t577: o_phase = +9'd9;\t //LUT[577] \tphase : 0.035156\t(data_i, data_q): (0.281250,0.031250)\n\t578: o_phase = +9'd18;\t //LUT[578] \tphase : 0.070312\t(data_i, data_q): (0.281250,0.062500)\n\t579: o_phase = +9'd26;\t //LUT[579] \tphase : 0.101562\t(data_i, data_q): (0.281250,0.093750)\n\t580: o_phase = +9'd34;\t //LUT[580] \tphase : 0.132812\t(data_i, data_q): (0.281250,0.125000)\n\t581: o_phase = +9'd41;\t //LUT[581] \tphase : 0.160156\t(data_i, data_q): (0.281250,0.156250)\n\t582: o_phase = +9'd48;\t //LUT[582] \tphase : 0.187500\t(data_i, data_q): (0.281250,0.187500)\n\t583: o_phase = +9'd54;\t //LUT[583] \tphase : 0.210938\t(data_i, data_q): (0.281250,0.218750)\n\t584: o_phase = +9'd59;\t //LUT[584] \tphase : 0.230469\t(data_i, data_q): (0.281250,0.250000)\n\t585: o_phase = +9'd64;\t //LUT[585] \tphase : 0.250000\t(data_i, data_q): (0.281250,0.281250)\n\t586: o_phase = +9'd68;\t //LUT[586] \tphase : 0.265625\t(data_i, data_q): (0.281250,0.312500)\n\t587: o_phase = +9'd72;\t //LUT[587] \tphase : 0.281250\t(data_i, data_q): (0.281250,0.343750)\n\t588: o_phase = +9'd76;\t //LUT[588] \tphase : 0.296875\t(data_i, data_q): (0.281250,0.375000)\n\t589: o_phase = +9'd79;\t //LUT[589] \tphase : 0.308594\t(data_i, data_q): (0.281250,0.406250)\n\t590: o_phase = +9'd81;\t //LUT[590] \tphase : 0.316406\t(data_i, data_q): (0.281250,0.437500)\n\t591: o_phase = +9'd84;\t //LUT[591] \tphase : 0.328125\t(data_i, data_q): (0.281250,0.468750)\n\t592: o_phase = +9'd86;\t //LUT[592] \tphase : 0.335938\t(data_i, data_q): (0.281250,0.500000)\n\t593: o_phase = +9'd88;\t //LUT[593] \tphase : 0.343750\t(data_i, data_q): (0.281250,0.531250)\n\t594: o_phase = +9'd90;\t //LUT[594] \tphase : 0.351562\t(data_i, data_q): (0.281250,0.562500)\n\t595: o_phase = +9'd92;\t //LUT[595] \tphase : 0.359375\t(data_i, data_q): (0.281250,0.593750)\n\t596: o_phase = +9'd94;\t //LUT[596] \tphase : 0.367188\t(data_i, data_q): (0.281250,0.625000)\n\t597: o_phase = +9'd95;\t //LUT[597] \tphase : 0.371094\t(data_i, data_q): (0.281250,0.656250)\n\t598: o_phase = +9'd96;\t //LUT[598] \tphase : 0.375000\t(data_i, data_q): (0.281250,0.687500)\n\t599: o_phase = +9'd98;\t //LUT[599] \tphase : 0.382812\t(data_i, data_q): (0.281250,0.718750)\n\t600: o_phase = +9'd99;\t //LUT[600] \tphase : 0.386719\t(data_i, data_q): (0.281250,0.750000)\n\t601: o_phase = +9'd100;\t //LUT[601] \tphase : 0.390625\t(data_i, data_q): (0.281250,0.781250)\n\t602: o_phase = +9'd101;\t //LUT[602] \tphase : 0.394531\t(data_i, data_q): (0.281250,0.812500)\n\t603: o_phase = +9'd102;\t //LUT[603] \tphase : 0.398438\t(data_i, data_q): (0.281250,0.843750)\n\t604: o_phase = +9'd103;\t //LUT[604] \tphase : 0.402344\t(data_i, data_q): (0.281250,0.875000)\n\t605: o_phase = +9'd103;\t //LUT[605] \tphase : 0.402344\t(data_i, data_q): (0.281250,0.906250)\n\t606: o_phase = +9'd104;\t //LUT[606] \tphase : 0.406250\t(data_i, data_q): (0.281250,0.937500)\n\t607: o_phase = +9'd105;\t //LUT[607] \tphase : 0.410156\t(data_i, data_q): (0.281250,0.968750)\n\t608: o_phase = -9'd106;\t //LUT[608] \tphase : -0.414062\t(data_i, data_q): (0.281250,-1.000000)\n\t609: o_phase = -9'd105;\t //LUT[609] \tphase : -0.410156\t(data_i, data_q): (0.281250,-0.968750)\n\t610: o_phase = -9'd104;\t //LUT[610] \tphase : -0.406250\t(data_i, data_q): (0.281250,-0.937500)\n\t611: o_phase = -9'd103;\t //LUT[611] \tphase : -0.402344\t(data_i, data_q): (0.281250,-0.906250)\n\t612: o_phase = -9'd103;\t //LUT[612] \tphase : -0.402344\t(data_i, data_q): (0.281250,-0.875000)\n\t613: o_phase = -9'd102;\t //LUT[613] \tphase : -0.398438\t(data_i, data_q): (0.281250,-0.843750)\n\t614: o_phase = -9'd101;\t //LUT[614] \tphase : -0.394531\t(data_i, data_q): (0.281250,-0.812500)\n\t615: o_phase = -9'd100;\t //LUT[615] \tphase : -0.390625\t(data_i, data_q): (0.281250,-0.781250)\n\t616: o_phase = -9'd99;\t //LUT[616] \tphase : -0.386719\t(data_i, data_q): (0.281250,-0.750000)\n\t617: o_phase = -9'd98;\t //LUT[617] \tphase : -0.382812\t(data_i, data_q): (0.281250,-0.718750)\n\t618: o_phase = -9'd96;\t //LUT[618] \tphase : -0.375000\t(data_i, data_q): (0.281250,-0.687500)\n\t619: o_phase = -9'd95;\t //LUT[619] \tphase : -0.371094\t(data_i, data_q): (0.281250,-0.656250)\n\t620: o_phase = -9'd94;\t //LUT[620] \tphase : -0.367188\t(data_i, data_q): (0.281250,-0.625000)\n\t621: o_phase = -9'd92;\t //LUT[621] \tphase : -0.359375\t(data_i, data_q): (0.281250,-0.593750)\n\t622: o_phase = -9'd90;\t //LUT[622] \tphase : -0.351562\t(data_i, data_q): (0.281250,-0.562500)\n\t623: o_phase = -9'd88;\t //LUT[623] \tphase : -0.343750\t(data_i, data_q): (0.281250,-0.531250)\n\t624: o_phase = -9'd86;\t //LUT[624] \tphase : -0.335938\t(data_i, data_q): (0.281250,-0.500000)\n\t625: o_phase = -9'd84;\t //LUT[625] \tphase : -0.328125\t(data_i, data_q): (0.281250,-0.468750)\n\t626: o_phase = -9'd81;\t //LUT[626] \tphase : -0.316406\t(data_i, data_q): (0.281250,-0.437500)\n\t627: o_phase = -9'd79;\t //LUT[627] \tphase : -0.308594\t(data_i, data_q): (0.281250,-0.406250)\n\t628: o_phase = -9'd76;\t //LUT[628] \tphase : -0.296875\t(data_i, data_q): (0.281250,-0.375000)\n\t629: o_phase = -9'd72;\t //LUT[629] \tphase : -0.281250\t(data_i, data_q): (0.281250,-0.343750)\n\t630: o_phase = -9'd68;\t //LUT[630] \tphase : -0.265625\t(data_i, data_q): (0.281250,-0.312500)\n\t631: o_phase = -9'd64;\t //LUT[631] \tphase : -0.250000\t(data_i, data_q): (0.281250,-0.281250)\n\t632: o_phase = -9'd59;\t //LUT[632] \tphase : -0.230469\t(data_i, data_q): (0.281250,-0.250000)\n\t633: o_phase = -9'd54;\t //LUT[633] \tphase : -0.210938\t(data_i, data_q): (0.281250,-0.218750)\n\t634: o_phase = -9'd48;\t //LUT[634] \tphase : -0.187500\t(data_i, data_q): (0.281250,-0.187500)\n\t635: o_phase = -9'd41;\t //LUT[635] \tphase : -0.160156\t(data_i, data_q): (0.281250,-0.156250)\n\t636: o_phase = -9'd34;\t //LUT[636] \tphase : -0.132812\t(data_i, data_q): (0.281250,-0.125000)\n\t637: o_phase = -9'd26;\t //LUT[637] \tphase : -0.101562\t(data_i, data_q): (0.281250,-0.093750)\n\t638: o_phase = -9'd18;\t //LUT[638] \tphase : -0.070312\t(data_i, data_q): (0.281250,-0.062500)\n\t639: o_phase = -9'd9;\t //LUT[639] \tphase : -0.035156\t(data_i, data_q): (0.281250,-0.031250)\n\t640: o_phase = +9'd0;\t //LUT[640] \tphase : 0.000000\t(data_i, data_q): (0.312500,0.000000)\n\t641: o_phase = +9'd8;\t //LUT[641] \tphase : 0.031250\t(data_i, data_q): (0.312500,0.031250)\n\t642: o_phase = +9'd16;\t //LUT[642] \tphase : 0.062500\t(data_i, data_q): (0.312500,0.062500)\n\t643: o_phase = +9'd24;\t //LUT[643] \tphase : 0.093750\t(data_i, data_q): (0.312500,0.093750)\n\t644: o_phase = +9'd31;\t //LUT[644] \tphase : 0.121094\t(data_i, data_q): (0.312500,0.125000)\n\t645: o_phase = +9'd38;\t //LUT[645] \tphase : 0.148438\t(data_i, data_q): (0.312500,0.156250)\n\t646: o_phase = +9'd44;\t //LUT[646] \tphase : 0.171875\t(data_i, data_q): (0.312500,0.187500)\n\t647: o_phase = +9'd50;\t //LUT[647] \tphase : 0.195312\t(data_i, data_q): (0.312500,0.218750)\n\t648: o_phase = +9'd55;\t //LUT[648] \tphase : 0.214844\t(data_i, data_q): (0.312500,0.250000)\n\t649: o_phase = +9'd60;\t //LUT[649] \tphase : 0.234375\t(data_i, data_q): (0.312500,0.281250)\n\t650: o_phase = +9'd64;\t //LUT[650] \tphase : 0.250000\t(data_i, data_q): (0.312500,0.312500)\n\t651: o_phase = +9'd68;\t //LUT[651] \tphase : 0.265625\t(data_i, data_q): (0.312500,0.343750)\n\t652: o_phase = +9'd71;\t //LUT[652] \tphase : 0.277344\t(data_i, data_q): (0.312500,0.375000)\n\t653: o_phase = +9'd75;\t //LUT[653] \tphase : 0.292969\t(data_i, data_q): (0.312500,0.406250)\n\t654: o_phase = +9'd77;\t //LUT[654] \tphase : 0.300781\t(data_i, data_q): (0.312500,0.437500)\n\t655: o_phase = +9'd80;\t //LUT[655] \tphase : 0.312500\t(data_i, data_q): (0.312500,0.468750)\n\t656: o_phase = +9'd82;\t //LUT[656] \tphase : 0.320312\t(data_i, data_q): (0.312500,0.500000)\n\t657: o_phase = +9'd85;\t //LUT[657] \tphase : 0.332031\t(data_i, data_q): (0.312500,0.531250)\n\t658: o_phase = +9'd87;\t //LUT[658] \tphase : 0.339844\t(data_i, data_q): (0.312500,0.562500)\n\t659: o_phase = +9'd89;\t //LUT[659] \tphase : 0.347656\t(data_i, data_q): (0.312500,0.593750)\n\t660: o_phase = +9'd90;\t //LUT[660] \tphase : 0.351562\t(data_i, data_q): (0.312500,0.625000)\n\t661: o_phase = +9'd92;\t //LUT[661] \tphase : 0.359375\t(data_i, data_q): (0.312500,0.656250)\n\t662: o_phase = +9'd93;\t //LUT[662] \tphase : 0.363281\t(data_i, data_q): (0.312500,0.687500)\n\t663: o_phase = +9'd95;\t //LUT[663] \tphase : 0.371094\t(data_i, data_q): (0.312500,0.718750)\n\t664: o_phase = +9'd96;\t //LUT[664] \tphase : 0.375000\t(data_i, data_q): (0.312500,0.750000)\n\t665: o_phase = +9'd97;\t //LUT[665] \tphase : 0.378906\t(data_i, data_q): (0.312500,0.781250)\n\t666: o_phase = +9'd98;\t //LUT[666] \tphase : 0.382812\t(data_i, data_q): (0.312500,0.812500)\n\t667: o_phase = +9'd99;\t //LUT[667] \tphase : 0.386719\t(data_i, data_q): (0.312500,0.843750)\n\t668: o_phase = +9'd100;\t //LUT[668] \tphase : 0.390625\t(data_i, data_q): (0.312500,0.875000)\n\t669: o_phase = +9'd101;\t //LUT[669] \tphase : 0.394531\t(data_i, data_q): (0.312500,0.906250)\n\t670: o_phase = +9'd102;\t //LUT[670] \tphase : 0.398438\t(data_i, data_q): (0.312500,0.937500)\n\t671: o_phase = +9'd103;\t //LUT[671] \tphase : 0.402344\t(data_i, data_q): (0.312500,0.968750)\n\t672: o_phase = -9'd103;\t //LUT[672] \tphase : -0.402344\t(data_i, data_q): (0.312500,-1.000000)\n\t673: o_phase = -9'd103;\t //LUT[673] \tphase : -0.402344\t(data_i, data_q): (0.312500,-0.968750)\n\t674: o_phase = -9'd102;\t //LUT[674] \tphase : -0.398438\t(data_i, data_q): (0.312500,-0.937500)\n\t675: o_phase = -9'd101;\t //LUT[675] \tphase : -0.394531\t(data_i, data_q): (0.312500,-0.906250)\n\t676: o_phase = -9'd100;\t //LUT[676] \tphase : -0.390625\t(data_i, data_q): (0.312500,-0.875000)\n\t677: o_phase = -9'd99;\t //LUT[677] \tphase : -0.386719\t(data_i, data_q): (0.312500,-0.843750)\n\t678: o_phase = -9'd98;\t //LUT[678] \tphase : -0.382812\t(data_i, data_q): (0.312500,-0.812500)\n\t679: o_phase = -9'd97;\t //LUT[679] \tphase : -0.378906\t(data_i, data_q): (0.312500,-0.781250)\n\t680: o_phase = -9'd96;\t //LUT[680] \tphase : -0.375000\t(data_i, data_q): (0.312500,-0.750000)\n\t681: o_phase = -9'd95;\t //LUT[681] \tphase : -0.371094\t(data_i, data_q): (0.312500,-0.718750)\n\t682: o_phase = -9'd93;\t //LUT[682] \tphase : -0.363281\t(data_i, data_q): (0.312500,-0.687500)\n\t683: o_phase = -9'd92;\t //LUT[683] \tphase : -0.359375\t(data_i, data_q): (0.312500,-0.656250)\n\t684: o_phase = -9'd90;\t //LUT[684] \tphase : -0.351562\t(data_i, data_q): (0.312500,-0.625000)\n\t685: o_phase = -9'd89;\t //LUT[685] \tphase : -0.347656\t(data_i, data_q): (0.312500,-0.593750)\n\t686: o_phase = -9'd87;\t //LUT[686] \tphase : -0.339844\t(data_i, data_q): (0.312500,-0.562500)\n\t687: o_phase = -9'd85;\t //LUT[687] \tphase : -0.332031\t(data_i, data_q): (0.312500,-0.531250)\n\t688: o_phase = -9'd82;\t //LUT[688] \tphase : -0.320312\t(data_i, data_q): (0.312500,-0.500000)\n\t689: o_phase = -9'd80;\t //LUT[689] \tphase : -0.312500\t(data_i, data_q): (0.312500,-0.468750)\n\t690: o_phase = -9'd77;\t //LUT[690] \tphase : -0.300781\t(data_i, data_q): (0.312500,-0.437500)\n\t691: o_phase = -9'd75;\t //LUT[691] \tphase : -0.292969\t(data_i, data_q): (0.312500,-0.406250)\n\t692: o_phase = -9'd71;\t //LUT[692] \tphase : -0.277344\t(data_i, data_q): (0.312500,-0.375000)\n\t693: o_phase = -9'd68;\t //LUT[693] \tphase : -0.265625\t(data_i, data_q): (0.312500,-0.343750)\n\t694: o_phase = -9'd64;\t //LUT[694] \tphase : -0.250000\t(data_i, data_q): (0.312500,-0.312500)\n\t695: o_phase = -9'd60;\t //LUT[695] \tphase : -0.234375\t(data_i, data_q): (0.312500,-0.281250)\n\t696: o_phase = -9'd55;\t //LUT[696] \tphase : -0.214844\t(data_i, data_q): (0.312500,-0.250000)\n\t697: o_phase = -9'd50;\t //LUT[697] \tphase : -0.195312\t(data_i, data_q): (0.312500,-0.218750)\n\t698: o_phase = -9'd44;\t //LUT[698] \tphase : -0.171875\t(data_i, data_q): (0.312500,-0.187500)\n\t699: o_phase = -9'd38;\t //LUT[699] \tphase : -0.148438\t(data_i, data_q): (0.312500,-0.156250)\n\t700: o_phase = -9'd31;\t //LUT[700] \tphase : -0.121094\t(data_i, data_q): (0.312500,-0.125000)\n\t701: o_phase = -9'd24;\t //LUT[701] \tphase : -0.093750\t(data_i, data_q): (0.312500,-0.093750)\n\t702: o_phase = -9'd16;\t //LUT[702] \tphase : -0.062500\t(data_i, data_q): (0.312500,-0.062500)\n\t703: o_phase = -9'd8;\t //LUT[703] \tphase : -0.031250\t(data_i, data_q): (0.312500,-0.031250)\n\t704: o_phase = +9'd0;\t //LUT[704] \tphase : 0.000000\t(data_i, data_q): (0.343750,0.000000)\n\t705: o_phase = +9'd7;\t //LUT[705] \tphase : 0.027344\t(data_i, data_q): (0.343750,0.031250)\n\t706: o_phase = +9'd15;\t //LUT[706] \tphase : 0.058594\t(data_i, data_q): (0.343750,0.062500)\n\t707: o_phase = +9'd22;\t //LUT[707] \tphase : 0.085938\t(data_i, data_q): (0.343750,0.093750)\n\t708: o_phase = +9'd28;\t //LUT[708] \tphase : 0.109375\t(data_i, data_q): (0.343750,0.125000)\n\t709: o_phase = +9'd35;\t //LUT[709] \tphase : 0.136719\t(data_i, data_q): (0.343750,0.156250)\n\t710: o_phase = +9'd41;\t //LUT[710] \tphase : 0.160156\t(data_i, data_q): (0.343750,0.187500)\n\t711: o_phase = +9'd46;\t //LUT[711] \tphase : 0.179688\t(data_i, data_q): (0.343750,0.218750)\n\t712: o_phase = +9'd51;\t //LUT[712] \tphase : 0.199219\t(data_i, data_q): (0.343750,0.250000)\n\t713: o_phase = +9'd56;\t //LUT[713] \tphase : 0.218750\t(data_i, data_q): (0.343750,0.281250)\n\t714: o_phase = +9'd60;\t //LUT[714] \tphase : 0.234375\t(data_i, data_q): (0.343750,0.312500)\n\t715: o_phase = +9'd64;\t //LUT[715] \tphase : 0.250000\t(data_i, data_q): (0.343750,0.343750)\n\t716: o_phase = +9'd68;\t //LUT[716] \tphase : 0.265625\t(data_i, data_q): (0.343750,0.375000)\n\t717: o_phase = +9'd71;\t //LUT[717] \tphase : 0.277344\t(data_i, data_q): (0.343750,0.406250)\n\t718: o_phase = +9'd74;\t //LUT[718] \tphase : 0.289062\t(data_i, data_q): (0.343750,0.437500)\n\t719: o_phase = +9'd76;\t //LUT[719] \tphase : 0.296875\t(data_i, data_q): (0.343750,0.468750)\n\t720: o_phase = +9'd79;\t //LUT[720] \tphase : 0.308594\t(data_i, data_q): (0.343750,0.500000)\n\t721: o_phase = +9'd81;\t //LUT[721] \tphase : 0.316406\t(data_i, data_q): (0.343750,0.531250)\n\t722: o_phase = +9'd83;\t //LUT[722] \tphase : 0.324219\t(data_i, data_q): (0.343750,0.562500)\n\t723: o_phase = +9'd85;\t //LUT[723] \tphase : 0.332031\t(data_i, data_q): (0.343750,0.593750)\n\t724: o_phase = +9'd87;\t //LUT[724] \tphase : 0.339844\t(data_i, data_q): (0.343750,0.625000)\n\t725: o_phase = +9'd89;\t //LUT[725] \tphase : 0.347656\t(data_i, data_q): (0.343750,0.656250)\n\t726: o_phase = +9'd90;\t //LUT[726] \tphase : 0.351562\t(data_i, data_q): (0.343750,0.687500)\n\t727: o_phase = +9'd92;\t //LUT[727] \tphase : 0.359375\t(data_i, data_q): (0.343750,0.718750)\n\t728: o_phase = +9'd93;\t //LUT[728] \tphase : 0.363281\t(data_i, data_q): (0.343750,0.750000)\n\t729: o_phase = +9'd94;\t //LUT[729] \tphase : 0.367188\t(data_i, data_q): (0.343750,0.781250)\n\t730: o_phase = +9'd95;\t //LUT[730] \tphase : 0.371094\t(data_i, data_q): (0.343750,0.812500)\n\t731: o_phase = +9'd96;\t //LUT[731] \tphase : 0.375000\t(data_i, data_q): (0.343750,0.843750)\n\t732: o_phase = +9'd97;\t //LUT[732] \tphase : 0.378906\t(data_i, data_q): (0.343750,0.875000)\n\t733: o_phase = +9'd98;\t //LUT[733] \tphase : 0.382812\t(data_i, data_q): (0.343750,0.906250)\n\t734: o_phase = +9'd99;\t //LUT[734] \tphase : 0.386719\t(data_i, data_q): (0.343750,0.937500)\n\t735: o_phase = +9'd100;\t //LUT[735] \tphase : 0.390625\t(data_i, data_q): (0.343750,0.968750)\n\t736: o_phase = -9'd101;\t //LUT[736] \tphase : -0.394531\t(data_i, data_q): (0.343750,-1.000000)\n\t737: o_phase = -9'd100;\t //LUT[737] \tphase : -0.390625\t(data_i, data_q): (0.343750,-0.968750)\n\t738: o_phase = -9'd99;\t //LUT[738] \tphase : -0.386719\t(data_i, data_q): (0.343750,-0.937500)\n\t739: o_phase = -9'd98;\t //LUT[739] \tphase : -0.382812\t(data_i, data_q): (0.343750,-0.906250)\n\t740: o_phase = -9'd97;\t //LUT[740] \tphase : -0.378906\t(data_i, data_q): (0.343750,-0.875000)\n\t741: o_phase = -9'd96;\t //LUT[741] \tphase : -0.375000\t(data_i, data_q): (0.343750,-0.843750)\n\t742: o_phase = -9'd95;\t //LUT[742] \tphase : -0.371094\t(data_i, data_q): (0.343750,-0.812500)\n\t743: o_phase = -9'd94;\t //LUT[743] \tphase : -0.367188\t(data_i, data_q): (0.343750,-0.781250)\n\t744: o_phase = -9'd93;\t //LUT[744] \tphase : -0.363281\t(data_i, data_q): (0.343750,-0.750000)\n\t745: o_phase = -9'd92;\t //LUT[745] \tphase : -0.359375\t(data_i, data_q): (0.343750,-0.718750)\n\t746: o_phase = -9'd90;\t //LUT[746] \tphase : -0.351562\t(data_i, data_q): (0.343750,-0.687500)\n\t747: o_phase = -9'd89;\t //LUT[747] \tphase : -0.347656\t(data_i, data_q): (0.343750,-0.656250)\n\t748: o_phase = -9'd87;\t //LUT[748] \tphase : -0.339844\t(data_i, data_q): (0.343750,-0.625000)\n\t749: o_phase = -9'd85;\t //LUT[749] \tphase : -0.332031\t(data_i, data_q): (0.343750,-0.593750)\n\t750: o_phase = -9'd83;\t //LUT[750] \tphase : -0.324219\t(data_i, data_q): (0.343750,-0.562500)\n\t751: o_phase = -9'd81;\t //LUT[751] \tphase : -0.316406\t(data_i, data_q): (0.343750,-0.531250)\n\t752: o_phase = -9'd79;\t //LUT[752] \tphase : -0.308594\t(data_i, data_q): (0.343750,-0.500000)\n\t753: o_phase = -9'd76;\t //LUT[753] \tphase : -0.296875\t(data_i, data_q): (0.343750,-0.468750)\n\t754: o_phase = -9'd74;\t //LUT[754] \tphase : -0.289062\t(data_i, data_q): (0.343750,-0.437500)\n\t755: o_phase = -9'd71;\t //LUT[755] \tphase : -0.277344\t(data_i, data_q): (0.343750,-0.406250)\n\t756: o_phase = -9'd68;\t //LUT[756] \tphase : -0.265625\t(data_i, data_q): (0.343750,-0.375000)\n\t757: o_phase = -9'd64;\t //LUT[757] \tphase : -0.250000\t(data_i, data_q): (0.343750,-0.343750)\n\t758: o_phase = -9'd60;\t //LUT[758] \tphase : -0.234375\t(data_i, data_q): (0.343750,-0.312500)\n\t759: o_phase = -9'd56;\t //LUT[759] \tphase : -0.218750\t(data_i, data_q): (0.343750,-0.281250)\n\t760: o_phase = -9'd51;\t //LUT[760] \tphase : -0.199219\t(data_i, data_q): (0.343750,-0.250000)\n\t761: o_phase = -9'd46;\t //LUT[761] \tphase : -0.179688\t(data_i, data_q): (0.343750,-0.218750)\n\t762: o_phase = -9'd41;\t //LUT[762] \tphase : -0.160156\t(data_i, data_q): (0.343750,-0.187500)\n\t763: o_phase = -9'd35;\t //LUT[763] \tphase : -0.136719\t(data_i, data_q): (0.343750,-0.156250)\n\t764: o_phase = -9'd28;\t //LUT[764] \tphase : -0.109375\t(data_i, data_q): (0.343750,-0.125000)\n\t765: o_phase = -9'd22;\t //LUT[765] \tphase : -0.085938\t(data_i, data_q): (0.343750,-0.093750)\n\t766: o_phase = -9'd15;\t //LUT[766] \tphase : -0.058594\t(data_i, data_q): (0.343750,-0.062500)\n\t767: o_phase = -9'd7;\t //LUT[767] \tphase : -0.027344\t(data_i, data_q): (0.343750,-0.031250)\n\t768: o_phase = +9'd0;\t //LUT[768] \tphase : 0.000000\t(data_i, data_q): (0.375000,0.000000)\n\t769: o_phase = +9'd7;\t //LUT[769] \tphase : 0.027344\t(data_i, data_q): (0.375000,0.031250)\n\t770: o_phase = +9'd13;\t //LUT[770] \tphase : 0.050781\t(data_i, data_q): (0.375000,0.062500)\n\t771: o_phase = +9'd20;\t //LUT[771] \tphase : 0.078125\t(data_i, data_q): (0.375000,0.093750)\n\t772: o_phase = +9'd26;\t //LUT[772] \tphase : 0.101562\t(data_i, data_q): (0.375000,0.125000)\n\t773: o_phase = +9'd32;\t //LUT[773] \tphase : 0.125000\t(data_i, data_q): (0.375000,0.156250)\n\t774: o_phase = +9'd38;\t //LUT[774] \tphase : 0.148438\t(data_i, data_q): (0.375000,0.187500)\n\t775: o_phase = +9'd43;\t //LUT[775] \tphase : 0.167969\t(data_i, data_q): (0.375000,0.218750)\n\t776: o_phase = +9'd48;\t //LUT[776] \tphase : 0.187500\t(data_i, data_q): (0.375000,0.250000)\n\t777: o_phase = +9'd52;\t //LUT[777] \tphase : 0.203125\t(data_i, data_q): (0.375000,0.281250)\n\t778: o_phase = +9'd57;\t //LUT[778] \tphase : 0.222656\t(data_i, data_q): (0.375000,0.312500)\n\t779: o_phase = +9'd60;\t //LUT[779] \tphase : 0.234375\t(data_i, data_q): (0.375000,0.343750)\n\t780: o_phase = +9'd64;\t //LUT[780] \tphase : 0.250000\t(data_i, data_q): (0.375000,0.375000)\n\t781: o_phase = +9'd67;\t //LUT[781] \tphase : 0.261719\t(data_i, data_q): (0.375000,0.406250)\n\t782: o_phase = +9'd70;\t //LUT[782] \tphase : 0.273438\t(data_i, data_q): (0.375000,0.437500)\n\t783: o_phase = +9'd73;\t //LUT[783] \tphase : 0.285156\t(data_i, data_q): (0.375000,0.468750)\n\t784: o_phase = +9'd76;\t //LUT[784] \tphase : 0.296875\t(data_i, data_q): (0.375000,0.500000)\n\t785: o_phase = +9'd78;\t //LUT[785] \tphase : 0.304688\t(data_i, data_q): (0.375000,0.531250)\n\t786: o_phase = +9'd80;\t //LUT[786] \tphase : 0.312500\t(data_i, data_q): (0.375000,0.562500)\n\t787: o_phase = +9'd82;\t //LUT[787] \tphase : 0.320312\t(data_i, data_q): (0.375000,0.593750)\n\t788: o_phase = +9'd84;\t //LUT[788] \tphase : 0.328125\t(data_i, data_q): (0.375000,0.625000)\n\t789: o_phase = +9'd86;\t //LUT[789] \tphase : 0.335938\t(data_i, data_q): (0.375000,0.656250)\n\t790: o_phase = +9'd87;\t //LUT[790] \tphase : 0.339844\t(data_i, data_q): (0.375000,0.687500)\n\t791: o_phase = +9'd89;\t //LUT[791] \tphase : 0.347656\t(data_i, data_q): (0.375000,0.718750)\n\t792: o_phase = +9'd90;\t //LUT[792] \tphase : 0.351562\t(data_i, data_q): (0.375000,0.750000)\n\t793: o_phase = +9'd92;\t //LUT[793] \tphase : 0.359375\t(data_i, data_q): (0.375000,0.781250)\n\t794: o_phase = +9'd93;\t //LUT[794] \tphase : 0.363281\t(data_i, data_q): (0.375000,0.812500)\n\t795: o_phase = +9'd94;\t //LUT[795] \tphase : 0.367188\t(data_i, data_q): (0.375000,0.843750)\n\t796: o_phase = +9'd95;\t //LUT[796] \tphase : 0.371094\t(data_i, data_q): (0.375000,0.875000)\n\t797: o_phase = +9'd96;\t //LUT[797] \tphase : 0.375000\t(data_i, data_q): (0.375000,0.906250)\n\t798: o_phase = +9'd97;\t //LUT[798] \tphase : 0.378906\t(data_i, data_q): (0.375000,0.937500)\n\t799: o_phase = +9'd98;\t //LUT[799] \tphase : 0.382812\t(data_i, data_q): (0.375000,0.968750)\n\t800: o_phase = -9'd99;\t //LUT[800] \tphase : -0.386719\t(data_i, data_q): (0.375000,-1.000000)\n\t801: o_phase = -9'd98;\t //LUT[801] \tphase : -0.382812\t(data_i, data_q): (0.375000,-0.968750)\n\t802: o_phase = -9'd97;\t //LUT[802] \tphase : -0.378906\t(data_i, data_q): (0.375000,-0.937500)\n\t803: o_phase = -9'd96;\t //LUT[803] \tphase : -0.375000\t(data_i, data_q): (0.375000,-0.906250)\n\t804: o_phase = -9'd95;\t //LUT[804] \tphase : -0.371094\t(data_i, data_q): (0.375000,-0.875000)\n\t805: o_phase = -9'd94;\t //LUT[805] \tphase : -0.367188\t(data_i, data_q): (0.375000,-0.843750)\n\t806: o_phase = -9'd93;\t //LUT[806] \tphase : -0.363281\t(data_i, data_q): (0.375000,-0.812500)\n\t807: o_phase = -9'd92;\t //LUT[807] \tphase : -0.359375\t(data_i, data_q): (0.375000,-0.781250)\n\t808: o_phase = -9'd90;\t //LUT[808] \tphase : -0.351562\t(data_i, data_q): (0.375000,-0.750000)\n\t809: o_phase = -9'd89;\t //LUT[809] \tphase : -0.347656\t(data_i, data_q): (0.375000,-0.718750)\n\t810: o_phase = -9'd87;\t //LUT[810] \tphase : -0.339844\t(data_i, data_q): (0.375000,-0.687500)\n\t811: o_phase = -9'd86;\t //LUT[811] \tphase : -0.335938\t(data_i, data_q): (0.375000,-0.656250)\n\t812: o_phase = -9'd84;\t //LUT[812] \tphase : -0.328125\t(data_i, data_q): (0.375000,-0.625000)\n\t813: o_phase = -9'd82;\t //LUT[813] \tphase : -0.320312\t(data_i, data_q): (0.375000,-0.593750)\n\t814: o_phase = -9'd80;\t //LUT[814] \tphase : -0.312500\t(data_i, data_q): (0.375000,-0.562500)\n\t815: o_phase = -9'd78;\t //LUT[815] \tphase : -0.304688\t(data_i, data_q): (0.375000,-0.531250)\n\t816: o_phase = -9'd76;\t //LUT[816] \tphase : -0.296875\t(data_i, data_q): (0.375000,-0.500000)\n\t817: o_phase = -9'd73;\t //LUT[817] \tphase : -0.285156\t(data_i, data_q): (0.375000,-0.468750)\n\t818: o_phase = -9'd70;\t //LUT[818] \tphase : -0.273438\t(data_i, data_q): (0.375000,-0.437500)\n\t819: o_phase = -9'd67;\t //LUT[819] \tphase : -0.261719\t(data_i, data_q): (0.375000,-0.406250)\n\t820: o_phase = -9'd64;\t //LUT[820] \tphase : -0.250000\t(data_i, data_q): (0.375000,-0.375000)\n\t821: o_phase = -9'd60;\t //LUT[821] \tphase : -0.234375\t(data_i, data_q): (0.375000,-0.343750)\n\t822: o_phase = -9'd57;\t //LUT[822] \tphase : -0.222656\t(data_i, data_q): (0.375000,-0.312500)\n\t823: o_phase = -9'd52;\t //LUT[823] \tphase : -0.203125\t(data_i, data_q): (0.375000,-0.281250)\n\t824: o_phase = -9'd48;\t //LUT[824] \tphase : -0.187500\t(data_i, data_q): (0.375000,-0.250000)\n\t825: o_phase = -9'd43;\t //LUT[825] \tphase : -0.167969\t(data_i, data_q): (0.375000,-0.218750)\n\t826: o_phase = -9'd38;\t //LUT[826] \tphase : -0.148438\t(data_i, data_q): (0.375000,-0.187500)\n\t827: o_phase = -9'd32;\t //LUT[827] \tphase : -0.125000\t(data_i, data_q): (0.375000,-0.156250)\n\t828: o_phase = -9'd26;\t //LUT[828] \tphase : -0.101562\t(data_i, data_q): (0.375000,-0.125000)\n\t829: o_phase = -9'd20;\t //LUT[829] \tphase : -0.078125\t(data_i, data_q): (0.375000,-0.093750)\n\t830: o_phase = -9'd13;\t //LUT[830] \tphase : -0.050781\t(data_i, data_q): (0.375000,-0.062500)\n\t831: o_phase = -9'd7;\t //LUT[831] \tphase : -0.027344\t(data_i, data_q): (0.375000,-0.031250)\n\t832: o_phase = +9'd0;\t //LUT[832] \tphase : 0.000000\t(data_i, data_q): (0.406250,0.000000)\n\t833: o_phase = +9'd6;\t //LUT[833] \tphase : 0.023438\t(data_i, data_q): (0.406250,0.031250)\n\t834: o_phase = +9'd12;\t //LUT[834] \tphase : 0.046875\t(data_i, data_q): (0.406250,0.062500)\n\t835: o_phase = +9'd18;\t //LUT[835] \tphase : 0.070312\t(data_i, data_q): (0.406250,0.093750)\n\t836: o_phase = +9'd24;\t //LUT[836] \tphase : 0.093750\t(data_i, data_q): (0.406250,0.125000)\n\t837: o_phase = +9'd30;\t //LUT[837] \tphase : 0.117188\t(data_i, data_q): (0.406250,0.156250)\n\t838: o_phase = +9'd35;\t //LUT[838] \tphase : 0.136719\t(data_i, data_q): (0.406250,0.187500)\n\t839: o_phase = +9'd40;\t //LUT[839] \tphase : 0.156250\t(data_i, data_q): (0.406250,0.218750)\n\t840: o_phase = +9'd45;\t //LUT[840] \tphase : 0.175781\t(data_i, data_q): (0.406250,0.250000)\n\t841: o_phase = +9'd49;\t //LUT[841] \tphase : 0.191406\t(data_i, data_q): (0.406250,0.281250)\n\t842: o_phase = +9'd53;\t //LUT[842] \tphase : 0.207031\t(data_i, data_q): (0.406250,0.312500)\n\t843: o_phase = +9'd57;\t //LUT[843] \tphase : 0.222656\t(data_i, data_q): (0.406250,0.343750)\n\t844: o_phase = +9'd61;\t //LUT[844] \tphase : 0.238281\t(data_i, data_q): (0.406250,0.375000)\n\t845: o_phase = +9'd64;\t //LUT[845] \tphase : 0.250000\t(data_i, data_q): (0.406250,0.406250)\n\t846: o_phase = +9'd67;\t //LUT[846] \tphase : 0.261719\t(data_i, data_q): (0.406250,0.437500)\n\t847: o_phase = +9'd70;\t //LUT[847] \tphase : 0.273438\t(data_i, data_q): (0.406250,0.468750)\n\t848: o_phase = +9'd72;\t //LUT[848] \tphase : 0.281250\t(data_i, data_q): (0.406250,0.500000)\n\t849: o_phase = +9'd75;\t //LUT[849] \tphase : 0.292969\t(data_i, data_q): (0.406250,0.531250)\n\t850: o_phase = +9'd77;\t //LUT[850] \tphase : 0.300781\t(data_i, data_q): (0.406250,0.562500)\n\t851: o_phase = +9'd79;\t //LUT[851] \tphase : 0.308594\t(data_i, data_q): (0.406250,0.593750)\n\t852: o_phase = +9'd81;\t //LUT[852] \tphase : 0.316406\t(data_i, data_q): (0.406250,0.625000)\n\t853: o_phase = +9'd83;\t //LUT[853] \tphase : 0.324219\t(data_i, data_q): (0.406250,0.656250)\n\t854: o_phase = +9'd85;\t //LUT[854] \tphase : 0.332031\t(data_i, data_q): (0.406250,0.687500)\n\t855: o_phase = +9'd86;\t //LUT[855] \tphase : 0.335938\t(data_i, data_q): (0.406250,0.718750)\n\t856: o_phase = +9'd88;\t //LUT[856] \tphase : 0.343750\t(data_i, data_q): (0.406250,0.750000)\n\t857: o_phase = +9'd89;\t //LUT[857] \tphase : 0.347656\t(data_i, data_q): (0.406250,0.781250)\n\t858: o_phase = +9'd90;\t //LUT[858] \tphase : 0.351562\t(data_i, data_q): (0.406250,0.812500)\n\t859: o_phase = +9'd91;\t //LUT[859] \tphase : 0.355469\t(data_i, data_q): (0.406250,0.843750)\n\t860: o_phase = +9'd93;\t //LUT[860] \tphase : 0.363281\t(data_i, data_q): (0.406250,0.875000)\n\t861: o_phase = +9'd94;\t //LUT[861] \tphase : 0.367188\t(data_i, data_q): (0.406250,0.906250)\n\t862: o_phase = +9'd95;\t //LUT[862] \tphase : 0.371094\t(data_i, data_q): (0.406250,0.937500)\n\t863: o_phase = +9'd96;\t //LUT[863] \tphase : 0.375000\t(data_i, data_q): (0.406250,0.968750)\n\t864: o_phase = -9'd97;\t //LUT[864] \tphase : -0.378906\t(data_i, data_q): (0.406250,-1.000000)\n\t865: o_phase = -9'd96;\t //LUT[865] \tphase : -0.375000\t(data_i, data_q): (0.406250,-0.968750)\n\t866: o_phase = -9'd95;\t //LUT[866] \tphase : -0.371094\t(data_i, data_q): (0.406250,-0.937500)\n\t867: o_phase = -9'd94;\t //LUT[867] \tphase : -0.367188\t(data_i, data_q): (0.406250,-0.906250)\n\t868: o_phase = -9'd93;\t //LUT[868] \tphase : -0.363281\t(data_i, data_q): (0.406250,-0.875000)\n\t869: o_phase = -9'd91;\t //LUT[869] \tphase : -0.355469\t(data_i, data_q): (0.406250,-0.843750)\n\t870: o_phase = -9'd90;\t //LUT[870] \tphase : -0.351562\t(data_i, data_q): (0.406250,-0.812500)\n\t871: o_phase = -9'd89;\t //LUT[871] \tphase : -0.347656\t(data_i, data_q): (0.406250,-0.781250)\n\t872: o_phase = -9'd88;\t //LUT[872] \tphase : -0.343750\t(data_i, data_q): (0.406250,-0.750000)\n\t873: o_phase = -9'd86;\t //LUT[873] \tphase : -0.335938\t(data_i, data_q): (0.406250,-0.718750)\n\t874: o_phase = -9'd85;\t //LUT[874] \tphase : -0.332031\t(data_i, data_q): (0.406250,-0.687500)\n\t875: o_phase = -9'd83;\t //LUT[875] \tphase : -0.324219\t(data_i, data_q): (0.406250,-0.656250)\n\t876: o_phase = -9'd81;\t //LUT[876] \tphase : -0.316406\t(data_i, data_q): (0.406250,-0.625000)\n\t877: o_phase = -9'd79;\t //LUT[877] \tphase : -0.308594\t(data_i, data_q): (0.406250,-0.593750)\n\t878: o_phase = -9'd77;\t //LUT[878] \tphase : -0.300781\t(data_i, data_q): (0.406250,-0.562500)\n\t879: o_phase = -9'd75;\t //LUT[879] \tphase : -0.292969\t(data_i, data_q): (0.406250,-0.531250)\n\t880: o_phase = -9'd72;\t //LUT[880] \tphase : -0.281250\t(data_i, data_q): (0.406250,-0.500000)\n\t881: o_phase = -9'd70;\t //LUT[881] \tphase : -0.273438\t(data_i, data_q): (0.406250,-0.468750)\n\t882: o_phase = -9'd67;\t //LUT[882] \tphase : -0.261719\t(data_i, data_q): (0.406250,-0.437500)\n\t883: o_phase = -9'd64;\t //LUT[883] \tphase : -0.250000\t(data_i, data_q): (0.406250,-0.406250)\n\t884: o_phase = -9'd61;\t //LUT[884] \tphase : -0.238281\t(data_i, data_q): (0.406250,-0.375000)\n\t885: o_phase = -9'd57;\t //LUT[885] \tphase : -0.222656\t(data_i, data_q): (0.406250,-0.343750)\n\t886: o_phase = -9'd53;\t //LUT[886] \tphase : -0.207031\t(data_i, data_q): (0.406250,-0.312500)\n\t887: o_phase = -9'd49;\t //LUT[887] \tphase : -0.191406\t(data_i, data_q): (0.406250,-0.281250)\n\t888: o_phase = -9'd45;\t //LUT[888] \tphase : -0.175781\t(data_i, data_q): (0.406250,-0.250000)\n\t889: o_phase = -9'd40;\t //LUT[889] \tphase : -0.156250\t(data_i, data_q): (0.406250,-0.218750)\n\t890: o_phase = -9'd35;\t //LUT[890] \tphase : -0.136719\t(data_i, data_q): (0.406250,-0.187500)\n\t891: o_phase = -9'd30;\t //LUT[891] \tphase : -0.117188\t(data_i, data_q): (0.406250,-0.156250)\n\t892: o_phase = -9'd24;\t //LUT[892] \tphase : -0.093750\t(data_i, data_q): (0.406250,-0.125000)\n\t893: o_phase = -9'd18;\t //LUT[893] \tphase : -0.070312\t(data_i, data_q): (0.406250,-0.093750)\n\t894: o_phase = -9'd12;\t //LUT[894] \tphase : -0.046875\t(data_i, data_q): (0.406250,-0.062500)\n\t895: o_phase = -9'd6;\t //LUT[895] \tphase : -0.023438\t(data_i, data_q): (0.406250,-0.031250)\n\t896: o_phase = +9'd0;\t //LUT[896] \tphase : 0.000000\t(data_i, data_q): (0.437500,0.000000)\n\t897: o_phase = +9'd6;\t //LUT[897] \tphase : 0.023438\t(data_i, data_q): (0.437500,0.031250)\n\t898: o_phase = +9'd12;\t //LUT[898] \tphase : 0.046875\t(data_i, data_q): (0.437500,0.062500)\n\t899: o_phase = +9'd17;\t //LUT[899] \tphase : 0.066406\t(data_i, data_q): (0.437500,0.093750)\n\t900: o_phase = +9'd23;\t //LUT[900] \tphase : 0.089844\t(data_i, data_q): (0.437500,0.125000)\n\t901: o_phase = +9'd28;\t //LUT[901] \tphase : 0.109375\t(data_i, data_q): (0.437500,0.156250)\n\t902: o_phase = +9'd33;\t //LUT[902] \tphase : 0.128906\t(data_i, data_q): (0.437500,0.187500)\n\t903: o_phase = +9'd38;\t //LUT[903] \tphase : 0.148438\t(data_i, data_q): (0.437500,0.218750)\n\t904: o_phase = +9'd42;\t //LUT[904] \tphase : 0.164062\t(data_i, data_q): (0.437500,0.250000)\n\t905: o_phase = +9'd47;\t //LUT[905] \tphase : 0.183594\t(data_i, data_q): (0.437500,0.281250)\n\t906: o_phase = +9'd51;\t //LUT[906] \tphase : 0.199219\t(data_i, data_q): (0.437500,0.312500)\n\t907: o_phase = +9'd54;\t //LUT[907] \tphase : 0.210938\t(data_i, data_q): (0.437500,0.343750)\n\t908: o_phase = +9'd58;\t //LUT[908] \tphase : 0.226562\t(data_i, data_q): (0.437500,0.375000)\n\t909: o_phase = +9'd61;\t //LUT[909] \tphase : 0.238281\t(data_i, data_q): (0.437500,0.406250)\n\t910: o_phase = +9'd64;\t //LUT[910] \tphase : 0.250000\t(data_i, data_q): (0.437500,0.437500)\n\t911: o_phase = +9'd67;\t //LUT[911] \tphase : 0.261719\t(data_i, data_q): (0.437500,0.468750)\n\t912: o_phase = +9'd69;\t //LUT[912] \tphase : 0.269531\t(data_i, data_q): (0.437500,0.500000)\n\t913: o_phase = +9'd72;\t //LUT[913] \tphase : 0.281250\t(data_i, data_q): (0.437500,0.531250)\n\t914: o_phase = +9'd74;\t //LUT[914] \tphase : 0.289062\t(data_i, data_q): (0.437500,0.562500)\n\t915: o_phase = +9'd76;\t //LUT[915] \tphase : 0.296875\t(data_i, data_q): (0.437500,0.593750)\n\t916: o_phase = +9'd78;\t //LUT[916] \tphase : 0.304688\t(data_i, data_q): (0.437500,0.625000)\n\t917: o_phase = +9'd80;\t //LUT[917] \tphase : 0.312500\t(data_i, data_q): (0.437500,0.656250)\n\t918: o_phase = +9'd82;\t //LUT[918] \tphase : 0.320312\t(data_i, data_q): (0.437500,0.687500)\n\t919: o_phase = +9'd83;\t //LUT[919] \tphase : 0.324219\t(data_i, data_q): (0.437500,0.718750)\n\t920: o_phase = +9'd85;\t //LUT[920] \tphase : 0.332031\t(data_i, data_q): (0.437500,0.750000)\n\t921: o_phase = +9'd86;\t //LUT[921] \tphase : 0.335938\t(data_i, data_q): (0.437500,0.781250)\n\t922: o_phase = +9'd88;\t //LUT[922] \tphase : 0.343750\t(data_i, data_q): (0.437500,0.812500)\n\t923: o_phase = +9'd89;\t //LUT[923] \tphase : 0.347656\t(data_i, data_q): (0.437500,0.843750)\n\t924: o_phase = +9'd90;\t //LUT[924] \tphase : 0.351562\t(data_i, data_q): (0.437500,0.875000)\n\t925: o_phase = +9'd91;\t //LUT[925] \tphase : 0.355469\t(data_i, data_q): (0.437500,0.906250)\n\t926: o_phase = +9'd92;\t //LUT[926] \tphase : 0.359375\t(data_i, data_q): (0.437500,0.937500)\n\t927: o_phase = +9'd93;\t //LUT[927] \tphase : 0.363281\t(data_i, data_q): (0.437500,0.968750)\n\t928: o_phase = -9'd94;\t //LUT[928] \tphase : -0.367188\t(data_i, data_q): (0.437500,-1.000000)\n\t929: o_phase = -9'd93;\t //LUT[929] \tphase : -0.363281\t(data_i, data_q): (0.437500,-0.968750)\n\t930: o_phase = -9'd92;\t //LUT[930] \tphase : -0.359375\t(data_i, data_q): (0.437500,-0.937500)\n\t931: o_phase = -9'd91;\t //LUT[931] \tphase : -0.355469\t(data_i, data_q): (0.437500,-0.906250)\n\t932: o_phase = -9'd90;\t //LUT[932] \tphase : -0.351562\t(data_i, data_q): (0.437500,-0.875000)\n\t933: o_phase = -9'd89;\t //LUT[933] \tphase : -0.347656\t(data_i, data_q): (0.437500,-0.843750)\n\t934: o_phase = -9'd88;\t //LUT[934] \tphase : -0.343750\t(data_i, data_q): (0.437500,-0.812500)\n\t935: o_phase = -9'd86;\t //LUT[935] \tphase : -0.335938\t(data_i, data_q): (0.437500,-0.781250)\n\t936: o_phase = -9'd85;\t //LUT[936] \tphase : -0.332031\t(data_i, data_q): (0.437500,-0.750000)\n\t937: o_phase = -9'd83;\t //LUT[937] \tphase : -0.324219\t(data_i, data_q): (0.437500,-0.718750)\n\t938: o_phase = -9'd82;\t //LUT[938] \tphase : -0.320312\t(data_i, data_q): (0.437500,-0.687500)\n\t939: o_phase = -9'd80;\t //LUT[939] \tphase : -0.312500\t(data_i, data_q): (0.437500,-0.656250)\n\t940: o_phase = -9'd78;\t //LUT[940] \tphase : -0.304688\t(data_i, data_q): (0.437500,-0.625000)\n\t941: o_phase = -9'd76;\t //LUT[941] \tphase : -0.296875\t(data_i, data_q): (0.437500,-0.593750)\n\t942: o_phase = -9'd74;\t //LUT[942] \tphase : -0.289062\t(data_i, data_q): (0.437500,-0.562500)\n\t943: o_phase = -9'd72;\t //LUT[943] \tphase : -0.281250\t(data_i, data_q): (0.437500,-0.531250)\n\t944: o_phase = -9'd69;\t //LUT[944] \tphase : -0.269531\t(data_i, data_q): (0.437500,-0.500000)\n\t945: o_phase = -9'd67;\t //LUT[945] \tphase : -0.261719\t(data_i, data_q): (0.437500,-0.468750)\n\t946: o_phase = -9'd64;\t //LUT[946] \tphase : -0.250000\t(data_i, data_q): (0.437500,-0.437500)\n\t947: o_phase = -9'd61;\t //LUT[947] \tphase : -0.238281\t(data_i, data_q): (0.437500,-0.406250)\n\t948: o_phase = -9'd58;\t //LUT[948] \tphase : -0.226562\t(data_i, data_q): (0.437500,-0.375000)\n\t949: o_phase = -9'd54;\t //LUT[949] \tphase : -0.210938\t(data_i, data_q): (0.437500,-0.343750)\n\t950: o_phase = -9'd51;\t //LUT[950] \tphase : -0.199219\t(data_i, data_q): (0.437500,-0.312500)\n\t951: o_phase = -9'd47;\t //LUT[951] \tphase : -0.183594\t(data_i, data_q): (0.437500,-0.281250)\n\t952: o_phase = -9'd42;\t //LUT[952] \tphase : -0.164062\t(data_i, data_q): (0.437500,-0.250000)\n\t953: o_phase = -9'd38;\t //LUT[953] \tphase : -0.148438\t(data_i, data_q): (0.437500,-0.218750)\n\t954: o_phase = -9'd33;\t //LUT[954] \tphase : -0.128906\t(data_i, data_q): (0.437500,-0.187500)\n\t955: o_phase = -9'd28;\t //LUT[955] \tphase : -0.109375\t(data_i, data_q): (0.437500,-0.156250)\n\t956: o_phase = -9'd23;\t //LUT[956] \tphase : -0.089844\t(data_i, data_q): (0.437500,-0.125000)\n\t957: o_phase = -9'd17;\t //LUT[957] \tphase : -0.066406\t(data_i, data_q): (0.437500,-0.093750)\n\t958: o_phase = -9'd12;\t //LUT[958] \tphase : -0.046875\t(data_i, data_q): (0.437500,-0.062500)\n\t959: o_phase = -9'd6;\t //LUT[959] \tphase : -0.023438\t(data_i, data_q): (0.437500,-0.031250)\n\t960: o_phase = +9'd0;\t //LUT[960] \tphase : 0.000000\t(data_i, data_q): (0.468750,0.000000)\n\t961: o_phase = +9'd5;\t //LUT[961] \tphase : 0.019531\t(data_i, data_q): (0.468750,0.031250)\n\t962: o_phase = +9'd11;\t //LUT[962] \tphase : 0.042969\t(data_i, data_q): (0.468750,0.062500)\n\t963: o_phase = +9'd16;\t //LUT[963] \tphase : 0.062500\t(data_i, data_q): (0.468750,0.093750)\n\t964: o_phase = +9'd21;\t //LUT[964] \tphase : 0.082031\t(data_i, data_q): (0.468750,0.125000)\n\t965: o_phase = +9'd26;\t //LUT[965] \tphase : 0.101562\t(data_i, data_q): (0.468750,0.156250)\n\t966: o_phase = +9'd31;\t //LUT[966] \tphase : 0.121094\t(data_i, data_q): (0.468750,0.187500)\n\t967: o_phase = +9'd36;\t //LUT[967] \tphase : 0.140625\t(data_i, data_q): (0.468750,0.218750)\n\t968: o_phase = +9'd40;\t //LUT[968] \tphase : 0.156250\t(data_i, data_q): (0.468750,0.250000)\n\t969: o_phase = +9'd44;\t //LUT[969] \tphase : 0.171875\t(data_i, data_q): (0.468750,0.281250)\n\t970: o_phase = +9'd48;\t //LUT[970] \tphase : 0.187500\t(data_i, data_q): (0.468750,0.312500)\n\t971: o_phase = +9'd52;\t //LUT[971] \tphase : 0.203125\t(data_i, data_q): (0.468750,0.343750)\n\t972: o_phase = +9'd55;\t //LUT[972] \tphase : 0.214844\t(data_i, data_q): (0.468750,0.375000)\n\t973: o_phase = +9'd58;\t //LUT[973] \tphase : 0.226562\t(data_i, data_q): (0.468750,0.406250)\n\t974: o_phase = +9'd61;\t //LUT[974] \tphase : 0.238281\t(data_i, data_q): (0.468750,0.437500)\n\t975: o_phase = +9'd64;\t //LUT[975] \tphase : 0.250000\t(data_i, data_q): (0.468750,0.468750)\n\t976: o_phase = +9'd67;\t //LUT[976] \tphase : 0.261719\t(data_i, data_q): (0.468750,0.500000)\n\t977: o_phase = +9'd69;\t //LUT[977] \tphase : 0.269531\t(data_i, data_q): (0.468750,0.531250)\n\t978: o_phase = +9'd71;\t //LUT[978] \tphase : 0.277344\t(data_i, data_q): (0.468750,0.562500)\n\t979: o_phase = +9'd74;\t //LUT[979] \tphase : 0.289062\t(data_i, data_q): (0.468750,0.593750)\n\t980: o_phase = +9'd76;\t //LUT[980] \tphase : 0.296875\t(data_i, data_q): (0.468750,0.625000)\n\t981: o_phase = +9'd77;\t //LUT[981] \tphase : 0.300781\t(data_i, data_q): (0.468750,0.656250)\n\t982: o_phase = +9'd79;\t //LUT[982] \tphase : 0.308594\t(data_i, data_q): (0.468750,0.687500)\n\t983: o_phase = +9'd81;\t //LUT[983] \tphase : 0.316406\t(data_i, data_q): (0.468750,0.718750)\n\t984: o_phase = +9'd82;\t //LUT[984] \tphase : 0.320312\t(data_i, data_q): (0.468750,0.750000)\n\t985: o_phase = +9'd84;\t //LUT[985] \tphase : 0.328125\t(data_i, data_q): (0.468750,0.781250)\n\t986: o_phase = +9'd85;\t //LUT[986] \tphase : 0.332031\t(data_i, data_q): (0.468750,0.812500)\n\t987: o_phase = +9'd87;\t //LUT[987] \tphase : 0.339844\t(data_i, data_q): (0.468750,0.843750)\n\t988: o_phase = +9'd88;\t //LUT[988] \tphase : 0.343750\t(data_i, data_q): (0.468750,0.875000)\n\t989: o_phase = +9'd89;\t //LUT[989] \tphase : 0.347656\t(data_i, data_q): (0.468750,0.906250)\n\t990: o_phase = +9'd90;\t //LUT[990] \tphase : 0.351562\t(data_i, data_q): (0.468750,0.937500)\n\t991: o_phase = +9'd91;\t //LUT[991] \tphase : 0.355469\t(data_i, data_q): (0.468750,0.968750)\n\t992: o_phase = -9'd92;\t //LUT[992] \tphase : -0.359375\t(data_i, data_q): (0.468750,-1.000000)\n\t993: o_phase = -9'd91;\t //LUT[993] \tphase : -0.355469\t(data_i, data_q): (0.468750,-0.968750)\n\t994: o_phase = -9'd90;\t //LUT[994] \tphase : -0.351562\t(data_i, data_q): (0.468750,-0.937500)\n\t995: o_phase = -9'd89;\t //LUT[995] \tphase : -0.347656\t(data_i, data_q): (0.468750,-0.906250)\n\t996: o_phase = -9'd88;\t //LUT[996] \tphase : -0.343750\t(data_i, data_q): (0.468750,-0.875000)\n\t997: o_phase = -9'd87;\t //LUT[997] \tphase : -0.339844\t(data_i, data_q): (0.468750,-0.843750)\n\t998: o_phase = -9'd85;\t //LUT[998] \tphase : -0.332031\t(data_i, data_q): (0.468750,-0.812500)\n\t999: o_phase = -9'd84;\t //LUT[999] \tphase : -0.328125\t(data_i, data_q): (0.468750,-0.781250)\n\t1000: o_phase = -9'd82;\t //LUT[1000] \tphase : -0.320312\t(data_i, data_q): (0.468750,-0.750000)\n\t1001: o_phase = -9'd81;\t //LUT[1001] \tphase : -0.316406\t(data_i, data_q): (0.468750,-0.718750)\n\t1002: o_phase = -9'd79;\t //LUT[1002] \tphase : -0.308594\t(data_i, data_q): (0.468750,-0.687500)\n\t1003: o_phase = -9'd77;\t //LUT[1003] \tphase : -0.300781\t(data_i, data_q): (0.468750,-0.656250)\n\t1004: o_phase = -9'd76;\t //LUT[1004] \tphase : -0.296875\t(data_i, data_q): (0.468750,-0.625000)\n\t1005: o_phase = -9'd74;\t //LUT[1005] \tphase : -0.289062\t(data_i, data_q): (0.468750,-0.593750)\n\t1006: o_phase = -9'd71;\t //LUT[1006] \tphase : -0.277344\t(data_i, data_q): (0.468750,-0.562500)\n\t1007: o_phase = -9'd69;\t //LUT[1007] \tphase : -0.269531\t(data_i, data_q): (0.468750,-0.531250)\n\t1008: o_phase = -9'd67;\t //LUT[1008] \tphase : -0.261719\t(data_i, data_q): (0.468750,-0.500000)\n\t1009: o_phase = -9'd64;\t //LUT[1009] \tphase : -0.250000\t(data_i, data_q): (0.468750,-0.468750)\n\t1010: o_phase = -9'd61;\t //LUT[1010] \tphase : -0.238281\t(data_i, data_q): (0.468750,-0.437500)\n\t1011: o_phase = -9'd58;\t //LUT[1011] \tphase : -0.226562\t(data_i, data_q): (0.468750,-0.406250)\n\t1012: o_phase = -9'd55;\t //LUT[1012] \tphase : -0.214844\t(data_i, data_q): (0.468750,-0.375000)\n\t1013: o_phase = -9'd52;\t //LUT[1013] \tphase : -0.203125\t(data_i, data_q): (0.468750,-0.343750)\n\t1014: o_phase = -9'd48;\t //LUT[1014] \tphase : -0.187500\t(data_i, data_q): (0.468750,-0.312500)\n\t1015: o_phase = -9'd44;\t //LUT[1015] \tphase : -0.171875\t(data_i, data_q): (0.468750,-0.281250)\n\t1016: o_phase = -9'd40;\t //LUT[1016] \tphase : -0.156250\t(data_i, data_q): (0.468750,-0.250000)\n\t1017: o_phase = -9'd36;\t //LUT[1017] \tphase : -0.140625\t(data_i, data_q): (0.468750,-0.218750)\n\t1018: o_phase = -9'd31;\t //LUT[1018] \tphase : -0.121094\t(data_i, data_q): (0.468750,-0.187500)\n\t1019: o_phase = -9'd26;\t //LUT[1019] \tphase : -0.101562\t(data_i, data_q): (0.468750,-0.156250)\n\t1020: o_phase = -9'd21;\t //LUT[1020] \tphase : -0.082031\t(data_i, data_q): (0.468750,-0.125000)\n\t1021: o_phase = -9'd16;\t //LUT[1021] \tphase : -0.062500\t(data_i, data_q): (0.468750,-0.093750)\n\t1022: o_phase = -9'd11;\t //LUT[1022] \tphase : -0.042969\t(data_i, data_q): (0.468750,-0.062500)\n\t1023: o_phase = -9'd5;\t //LUT[1023] \tphase : -0.019531\t(data_i, data_q): (0.468750,-0.031250)\n\t1024: o_phase = +9'd0;\t //LUT[1024] \tphase : 0.000000\t(data_i, data_q): (0.500000,0.000000)\n\t1025: o_phase = +9'd5;\t //LUT[1025] \tphase : 0.019531\t(data_i, data_q): (0.500000,0.031250)\n\t1026: o_phase = +9'd10;\t //LUT[1026] \tphase : 0.039062\t(data_i, data_q): (0.500000,0.062500)\n\t1027: o_phase = +9'd15;\t //LUT[1027] \tphase : 0.058594\t(data_i, data_q): (0.500000,0.093750)\n\t1028: o_phase = +9'd20;\t //LUT[1028] \tphase : 0.078125\t(data_i, data_q): (0.500000,0.125000)\n\t1029: o_phase = +9'd25;\t //LUT[1029] \tphase : 0.097656\t(data_i, data_q): (0.500000,0.156250)\n\t1030: o_phase = +9'd29;\t //LUT[1030] \tphase : 0.113281\t(data_i, data_q): (0.500000,0.187500)\n\t1031: o_phase = +9'd34;\t //LUT[1031] \tphase : 0.132812\t(data_i, data_q): (0.500000,0.218750)\n\t1032: o_phase = +9'd38;\t //LUT[1032] \tphase : 0.148438\t(data_i, data_q): (0.500000,0.250000)\n\t1033: o_phase = +9'd42;\t //LUT[1033] \tphase : 0.164062\t(data_i, data_q): (0.500000,0.281250)\n\t1034: o_phase = +9'd46;\t //LUT[1034] \tphase : 0.179688\t(data_i, data_q): (0.500000,0.312500)\n\t1035: o_phase = +9'd49;\t //LUT[1035] \tphase : 0.191406\t(data_i, data_q): (0.500000,0.343750)\n\t1036: o_phase = +9'd52;\t //LUT[1036] \tphase : 0.203125\t(data_i, data_q): (0.500000,0.375000)\n\t1037: o_phase = +9'd56;\t //LUT[1037] \tphase : 0.218750\t(data_i, data_q): (0.500000,0.406250)\n\t1038: o_phase = +9'd59;\t //LUT[1038] \tphase : 0.230469\t(data_i, data_q): (0.500000,0.437500)\n\t1039: o_phase = +9'd61;\t //LUT[1039] \tphase : 0.238281\t(data_i, data_q): (0.500000,0.468750)\n\t1040: o_phase = +9'd64;\t //LUT[1040] \tphase : 0.250000\t(data_i, data_q): (0.500000,0.500000)\n\t1041: o_phase = +9'd66;\t //LUT[1041] \tphase : 0.257812\t(data_i, data_q): (0.500000,0.531250)\n\t1042: o_phase = +9'd69;\t //LUT[1042] \tphase : 0.269531\t(data_i, data_q): (0.500000,0.562500)\n\t1043: o_phase = +9'd71;\t //LUT[1043] \tphase : 0.277344\t(data_i, data_q): (0.500000,0.593750)\n\t1044: o_phase = +9'd73;\t //LUT[1044] \tphase : 0.285156\t(data_i, data_q): (0.500000,0.625000)\n\t1045: o_phase = +9'd75;\t //LUT[1045] \tphase : 0.292969\t(data_i, data_q): (0.500000,0.656250)\n\t1046: o_phase = +9'd77;\t //LUT[1046] \tphase : 0.300781\t(data_i, data_q): (0.500000,0.687500)\n\t1047: o_phase = +9'd78;\t //LUT[1047] \tphase : 0.304688\t(data_i, data_q): (0.500000,0.718750)\n\t1048: o_phase = +9'd80;\t //LUT[1048] \tphase : 0.312500\t(data_i, data_q): (0.500000,0.750000)\n\t1049: o_phase = +9'd82;\t //LUT[1049] \tphase : 0.320312\t(data_i, data_q): (0.500000,0.781250)\n\t1050: o_phase = +9'd83;\t //LUT[1050] \tphase : 0.324219\t(data_i, data_q): (0.500000,0.812500)\n\t1051: o_phase = +9'd84;\t //LUT[1051] \tphase : 0.328125\t(data_i, data_q): (0.500000,0.843750)\n\t1052: o_phase = +9'd86;\t //LUT[1052] \tphase : 0.335938\t(data_i, data_q): (0.500000,0.875000)\n\t1053: o_phase = +9'd87;\t //LUT[1053] \tphase : 0.339844\t(data_i, data_q): (0.500000,0.906250)\n\t1054: o_phase = +9'd88;\t //LUT[1054] \tphase : 0.343750\t(data_i, data_q): (0.500000,0.937500)\n\t1055: o_phase = +9'd89;\t //LUT[1055] \tphase : 0.347656\t(data_i, data_q): (0.500000,0.968750)\n\t1056: o_phase = -9'd90;\t //LUT[1056] \tphase : -0.351562\t(data_i, data_q): (0.500000,-1.000000)\n\t1057: o_phase = -9'd89;\t //LUT[1057] \tphase : -0.347656\t(data_i, data_q): (0.500000,-0.968750)\n\t1058: o_phase = -9'd88;\t //LUT[1058] \tphase : -0.343750\t(data_i, data_q): (0.500000,-0.937500)\n\t1059: o_phase = -9'd87;\t //LUT[1059] \tphase : -0.339844\t(data_i, data_q): (0.500000,-0.906250)\n\t1060: o_phase = -9'd86;\t //LUT[1060] \tphase : -0.335938\t(data_i, data_q): (0.500000,-0.875000)\n\t1061: o_phase = -9'd84;\t //LUT[1061] \tphase : -0.328125\t(data_i, data_q): (0.500000,-0.843750)\n\t1062: o_phase = -9'd83;\t //LUT[1062] \tphase : -0.324219\t(data_i, data_q): (0.500000,-0.812500)\n\t1063: o_phase = -9'd82;\t //LUT[1063] \tphase : -0.320312\t(data_i, data_q): (0.500000,-0.781250)\n\t1064: o_phase = -9'd80;\t //LUT[1064] \tphase : -0.312500\t(data_i, data_q): (0.500000,-0.750000)\n\t1065: o_phase = -9'd78;\t //LUT[1065] \tphase : -0.304688\t(data_i, data_q): (0.500000,-0.718750)\n\t1066: o_phase = -9'd77;\t //LUT[1066] \tphase : -0.300781\t(data_i, data_q): (0.500000,-0.687500)\n\t1067: o_phase = -9'd75;\t //LUT[1067] \tphase : -0.292969\t(data_i, data_q): (0.500000,-0.656250)\n\t1068: o_phase = -9'd73;\t //LUT[1068] \tphase : -0.285156\t(data_i, data_q): (0.500000,-0.625000)\n\t1069: o_phase = -9'd71;\t //LUT[1069] \tphase : -0.277344\t(data_i, data_q): (0.500000,-0.593750)\n\t1070: o_phase = -9'd69;\t //LUT[1070] \tphase : -0.269531\t(data_i, data_q): (0.500000,-0.562500)\n\t1071: o_phase = -9'd66;\t //LUT[1071] \tphase : -0.257812\t(data_i, data_q): (0.500000,-0.531250)\n\t1072: o_phase = -9'd64;\t //LUT[1072] \tphase : -0.250000\t(data_i, data_q): (0.500000,-0.500000)\n\t1073: o_phase = -9'd61;\t //LUT[1073] \tphase : -0.238281\t(data_i, data_q): (0.500000,-0.468750)\n\t1074: o_phase = -9'd59;\t //LUT[1074] \tphase : -0.230469\t(data_i, data_q): (0.500000,-0.437500)\n\t1075: o_phase = -9'd56;\t //LUT[1075] \tphase : -0.218750\t(data_i, data_q): (0.500000,-0.406250)\n\t1076: o_phase = -9'd52;\t //LUT[1076] \tphase : -0.203125\t(data_i, data_q): (0.500000,-0.375000)\n\t1077: o_phase = -9'd49;\t //LUT[1077] \tphase : -0.191406\t(data_i, data_q): (0.500000,-0.343750)\n\t1078: o_phase = -9'd46;\t //LUT[1078] \tphase : -0.179688\t(data_i, data_q): (0.500000,-0.312500)\n\t1079: o_phase = -9'd42;\t //LUT[1079] \tphase : -0.164062\t(data_i, data_q): (0.500000,-0.281250)\n\t1080: o_phase = -9'd38;\t //LUT[1080] \tphase : -0.148438\t(data_i, data_q): (0.500000,-0.250000)\n\t1081: o_phase = -9'd34;\t //LUT[1081] \tphase : -0.132812\t(data_i, data_q): (0.500000,-0.218750)\n\t1082: o_phase = -9'd29;\t //LUT[1082] \tphase : -0.113281\t(data_i, data_q): (0.500000,-0.187500)\n\t1083: o_phase = -9'd25;\t //LUT[1083] \tphase : -0.097656\t(data_i, data_q): (0.500000,-0.156250)\n\t1084: o_phase = -9'd20;\t //LUT[1084] \tphase : -0.078125\t(data_i, data_q): (0.500000,-0.125000)\n\t1085: o_phase = -9'd15;\t //LUT[1085] \tphase : -0.058594\t(data_i, data_q): (0.500000,-0.093750)\n\t1086: o_phase = -9'd10;\t //LUT[1086] \tphase : -0.039062\t(data_i, data_q): (0.500000,-0.062500)\n\t1087: o_phase = -9'd5;\t //LUT[1087] \tphase : -0.019531\t(data_i, data_q): (0.500000,-0.031250)\n\t1088: o_phase = +9'd0;\t //LUT[1088] \tphase : 0.000000\t(data_i, data_q): (0.531250,0.000000)\n\t1089: o_phase = +9'd5;\t //LUT[1089] \tphase : 0.019531\t(data_i, data_q): (0.531250,0.031250)\n\t1090: o_phase = +9'd10;\t //LUT[1090] \tphase : 0.039062\t(data_i, data_q): (0.531250,0.062500)\n\t1091: o_phase = +9'd14;\t //LUT[1091] \tphase : 0.054688\t(data_i, data_q): (0.531250,0.093750)\n\t1092: o_phase = +9'd19;\t //LUT[1092] \tphase : 0.074219\t(data_i, data_q): (0.531250,0.125000)\n\t1093: o_phase = +9'd23;\t //LUT[1093] \tphase : 0.089844\t(data_i, data_q): (0.531250,0.156250)\n\t1094: o_phase = +9'd28;\t //LUT[1094] \tphase : 0.109375\t(data_i, data_q): (0.531250,0.187500)\n\t1095: o_phase = +9'd32;\t //LUT[1095] \tphase : 0.125000\t(data_i, data_q): (0.531250,0.218750)\n\t1096: o_phase = +9'd36;\t //LUT[1096] \tphase : 0.140625\t(data_i, data_q): (0.531250,0.250000)\n\t1097: o_phase = +9'd40;\t //LUT[1097] \tphase : 0.156250\t(data_i, data_q): (0.531250,0.281250)\n\t1098: o_phase = +9'd43;\t //LUT[1098] \tphase : 0.167969\t(data_i, data_q): (0.531250,0.312500)\n\t1099: o_phase = +9'd47;\t //LUT[1099] \tphase : 0.183594\t(data_i, data_q): (0.531250,0.343750)\n\t1100: o_phase = +9'd50;\t //LUT[1100] \tphase : 0.195312\t(data_i, data_q): (0.531250,0.375000)\n\t1101: o_phase = +9'd53;\t //LUT[1101] \tphase : 0.207031\t(data_i, data_q): (0.531250,0.406250)\n\t1102: o_phase = +9'd56;\t //LUT[1102] \tphase : 0.218750\t(data_i, data_q): (0.531250,0.437500)\n\t1103: o_phase = +9'd59;\t //LUT[1103] \tphase : 0.230469\t(data_i, data_q): (0.531250,0.468750)\n\t1104: o_phase = +9'd62;\t //LUT[1104] \tphase : 0.242188\t(data_i, data_q): (0.531250,0.500000)\n\t1105: o_phase = +9'd64;\t //LUT[1105] \tphase : 0.250000\t(data_i, data_q): (0.531250,0.531250)\n\t1106: o_phase = +9'd66;\t //LUT[1106] \tphase : 0.257812\t(data_i, data_q): (0.531250,0.562500)\n\t1107: o_phase = +9'd69;\t //LUT[1107] \tphase : 0.269531\t(data_i, data_q): (0.531250,0.593750)\n\t1108: o_phase = +9'd71;\t //LUT[1108] \tphase : 0.277344\t(data_i, data_q): (0.531250,0.625000)\n\t1109: o_phase = +9'd73;\t //LUT[1109] \tphase : 0.285156\t(data_i, data_q): (0.531250,0.656250)\n\t1110: o_phase = +9'd74;\t //LUT[1110] \tphase : 0.289062\t(data_i, data_q): (0.531250,0.687500)\n\t1111: o_phase = +9'd76;\t //LUT[1111] \tphase : 0.296875\t(data_i, data_q): (0.531250,0.718750)\n\t1112: o_phase = +9'd78;\t //LUT[1112] \tphase : 0.304688\t(data_i, data_q): (0.531250,0.750000)\n\t1113: o_phase = +9'd79;\t //LUT[1113] \tphase : 0.308594\t(data_i, data_q): (0.531250,0.781250)\n\t1114: o_phase = +9'd81;\t //LUT[1114] \tphase : 0.316406\t(data_i, data_q): (0.531250,0.812500)\n\t1115: o_phase = +9'd82;\t //LUT[1115] \tphase : 0.320312\t(data_i, data_q): (0.531250,0.843750)\n\t1116: o_phase = +9'd84;\t //LUT[1116] \tphase : 0.328125\t(data_i, data_q): (0.531250,0.875000)\n\t1117: o_phase = +9'd85;\t //LUT[1117] \tphase : 0.332031\t(data_i, data_q): (0.531250,0.906250)\n\t1118: o_phase = +9'd86;\t //LUT[1118] \tphase : 0.335938\t(data_i, data_q): (0.531250,0.937500)\n\t1119: o_phase = +9'd87;\t //LUT[1119] \tphase : 0.339844\t(data_i, data_q): (0.531250,0.968750)\n\t1120: o_phase = -9'd88;\t //LUT[1120] \tphase : -0.343750\t(data_i, data_q): (0.531250,-1.000000)\n\t1121: o_phase = -9'd87;\t //LUT[1121] \tphase : -0.339844\t(data_i, data_q): (0.531250,-0.968750)\n\t1122: o_phase = -9'd86;\t //LUT[1122] \tphase : -0.335938\t(data_i, data_q): (0.531250,-0.937500)\n\t1123: o_phase = -9'd85;\t //LUT[1123] \tphase : -0.332031\t(data_i, data_q): (0.531250,-0.906250)\n\t1124: o_phase = -9'd84;\t //LUT[1124] \tphase : -0.328125\t(data_i, data_q): (0.531250,-0.875000)\n\t1125: o_phase = -9'd82;\t //LUT[1125] \tphase : -0.320312\t(data_i, data_q): (0.531250,-0.843750)\n\t1126: o_phase = -9'd81;\t //LUT[1126] \tphase : -0.316406\t(data_i, data_q): (0.531250,-0.812500)\n\t1127: o_phase = -9'd79;\t //LUT[1127] \tphase : -0.308594\t(data_i, data_q): (0.531250,-0.781250)\n\t1128: o_phase = -9'd78;\t //LUT[1128] \tphase : -0.304688\t(data_i, data_q): (0.531250,-0.750000)\n\t1129: o_phase = -9'd76;\t //LUT[1129] \tphase : -0.296875\t(data_i, data_q): (0.531250,-0.718750)\n\t1130: o_phase = -9'd74;\t //LUT[1130] \tphase : -0.289062\t(data_i, data_q): (0.531250,-0.687500)\n\t1131: o_phase = -9'd73;\t //LUT[1131] \tphase : -0.285156\t(data_i, data_q): (0.531250,-0.656250)\n\t1132: o_phase = -9'd71;\t //LUT[1132] \tphase : -0.277344\t(data_i, data_q): (0.531250,-0.625000)\n\t1133: o_phase = -9'd69;\t //LUT[1133] \tphase : -0.269531\t(data_i, data_q): (0.531250,-0.593750)\n\t1134: o_phase = -9'd66;\t //LUT[1134] \tphase : -0.257812\t(data_i, data_q): (0.531250,-0.562500)\n\t1135: o_phase = -9'd64;\t //LUT[1135] \tphase : -0.250000\t(data_i, data_q): (0.531250,-0.531250)\n\t1136: o_phase = -9'd62;\t //LUT[1136] \tphase : -0.242188\t(data_i, data_q): (0.531250,-0.500000)\n\t1137: o_phase = -9'd59;\t //LUT[1137] \tphase : -0.230469\t(data_i, data_q): (0.531250,-0.468750)\n\t1138: o_phase = -9'd56;\t //LUT[1138] \tphase : -0.218750\t(data_i, data_q): (0.531250,-0.437500)\n\t1139: o_phase = -9'd53;\t //LUT[1139] \tphase : -0.207031\t(data_i, data_q): (0.531250,-0.406250)\n\t1140: o_phase = -9'd50;\t //LUT[1140] \tphase : -0.195312\t(data_i, data_q): (0.531250,-0.375000)\n\t1141: o_phase = -9'd47;\t //LUT[1141] \tphase : -0.183594\t(data_i, data_q): (0.531250,-0.343750)\n\t1142: o_phase = -9'd43;\t //LUT[1142] \tphase : -0.167969\t(data_i, data_q): (0.531250,-0.312500)\n\t1143: o_phase = -9'd40;\t //LUT[1143] \tphase : -0.156250\t(data_i, data_q): (0.531250,-0.281250)\n\t1144: o_phase = -9'd36;\t //LUT[1144] \tphase : -0.140625\t(data_i, data_q): (0.531250,-0.250000)\n\t1145: o_phase = -9'd32;\t //LUT[1145] \tphase : -0.125000\t(data_i, data_q): (0.531250,-0.218750)\n\t1146: o_phase = -9'd28;\t //LUT[1146] \tphase : -0.109375\t(data_i, data_q): (0.531250,-0.187500)\n\t1147: o_phase = -9'd23;\t //LUT[1147] \tphase : -0.089844\t(data_i, data_q): (0.531250,-0.156250)\n\t1148: o_phase = -9'd19;\t //LUT[1148] \tphase : -0.074219\t(data_i, data_q): (0.531250,-0.125000)\n\t1149: o_phase = -9'd14;\t //LUT[1149] \tphase : -0.054688\t(data_i, data_q): (0.531250,-0.093750)\n\t1150: o_phase = -9'd10;\t //LUT[1150] \tphase : -0.039062\t(data_i, data_q): (0.531250,-0.062500)\n\t1151: o_phase = -9'd5;\t //LUT[1151] \tphase : -0.019531\t(data_i, data_q): (0.531250,-0.031250)\n\t1152: o_phase = +9'd0;\t //LUT[1152] \tphase : 0.000000\t(data_i, data_q): (0.562500,0.000000)\n\t1153: o_phase = +9'd5;\t //LUT[1153] \tphase : 0.019531\t(data_i, data_q): (0.562500,0.031250)\n\t1154: o_phase = +9'd9;\t //LUT[1154] \tphase : 0.035156\t(data_i, data_q): (0.562500,0.062500)\n\t1155: o_phase = +9'd13;\t //LUT[1155] \tphase : 0.050781\t(data_i, data_q): (0.562500,0.093750)\n\t1156: o_phase = +9'd18;\t //LUT[1156] \tphase : 0.070312\t(data_i, data_q): (0.562500,0.125000)\n\t1157: o_phase = +9'd22;\t //LUT[1157] \tphase : 0.085938\t(data_i, data_q): (0.562500,0.156250)\n\t1158: o_phase = +9'd26;\t //LUT[1158] \tphase : 0.101562\t(data_i, data_q): (0.562500,0.187500)\n\t1159: o_phase = +9'd30;\t //LUT[1159] \tphase : 0.117188\t(data_i, data_q): (0.562500,0.218750)\n\t1160: o_phase = +9'd34;\t //LUT[1160] \tphase : 0.132812\t(data_i, data_q): (0.562500,0.250000)\n\t1161: o_phase = +9'd38;\t //LUT[1161] \tphase : 0.148438\t(data_i, data_q): (0.562500,0.281250)\n\t1162: o_phase = +9'd41;\t //LUT[1162] \tphase : 0.160156\t(data_i, data_q): (0.562500,0.312500)\n\t1163: o_phase = +9'd45;\t //LUT[1163] \tphase : 0.175781\t(data_i, data_q): (0.562500,0.343750)\n\t1164: o_phase = +9'd48;\t //LUT[1164] \tphase : 0.187500\t(data_i, data_q): (0.562500,0.375000)\n\t1165: o_phase = +9'd51;\t //LUT[1165] \tphase : 0.199219\t(data_i, data_q): (0.562500,0.406250)\n\t1166: o_phase = +9'd54;\t //LUT[1166] \tphase : 0.210938\t(data_i, data_q): (0.562500,0.437500)\n\t1167: o_phase = +9'd57;\t //LUT[1167] \tphase : 0.222656\t(data_i, data_q): (0.562500,0.468750)\n\t1168: o_phase = +9'd59;\t //LUT[1168] \tphase : 0.230469\t(data_i, data_q): (0.562500,0.500000)\n\t1169: o_phase = +9'd62;\t //LUT[1169] \tphase : 0.242188\t(data_i, data_q): (0.562500,0.531250)\n\t1170: o_phase = +9'd64;\t //LUT[1170] \tphase : 0.250000\t(data_i, data_q): (0.562500,0.562500)\n\t1171: o_phase = +9'd66;\t //LUT[1171] \tphase : 0.257812\t(data_i, data_q): (0.562500,0.593750)\n\t1172: o_phase = +9'd68;\t //LUT[1172] \tphase : 0.265625\t(data_i, data_q): (0.562500,0.625000)\n\t1173: o_phase = +9'd70;\t //LUT[1173] \tphase : 0.273438\t(data_i, data_q): (0.562500,0.656250)\n\t1174: o_phase = +9'd72;\t //LUT[1174] \tphase : 0.281250\t(data_i, data_q): (0.562500,0.687500)\n\t1175: o_phase = +9'd74;\t //LUT[1175] \tphase : 0.289062\t(data_i, data_q): (0.562500,0.718750)\n\t1176: o_phase = +9'd76;\t //LUT[1176] \tphase : 0.296875\t(data_i, data_q): (0.562500,0.750000)\n\t1177: o_phase = +9'd77;\t //LUT[1177] \tphase : 0.300781\t(data_i, data_q): (0.562500,0.781250)\n\t1178: o_phase = +9'd79;\t //LUT[1178] \tphase : 0.308594\t(data_i, data_q): (0.562500,0.812500)\n\t1179: o_phase = +9'd80;\t //LUT[1179] \tphase : 0.312500\t(data_i, data_q): (0.562500,0.843750)\n\t1180: o_phase = +9'd81;\t //LUT[1180] \tphase : 0.316406\t(data_i, data_q): (0.562500,0.875000)\n\t1181: o_phase = +9'd83;\t //LUT[1181] \tphase : 0.324219\t(data_i, data_q): (0.562500,0.906250)\n\t1182: o_phase = +9'd84;\t //LUT[1182] \tphase : 0.328125\t(data_i, data_q): (0.562500,0.937500)\n\t1183: o_phase = +9'd85;\t //LUT[1183] \tphase : 0.332031\t(data_i, data_q): (0.562500,0.968750)\n\t1184: o_phase = -9'd86;\t //LUT[1184] \tphase : -0.335938\t(data_i, data_q): (0.562500,-1.000000)\n\t1185: o_phase = -9'd85;\t //LUT[1185] \tphase : -0.332031\t(data_i, data_q): (0.562500,-0.968750)\n\t1186: o_phase = -9'd84;\t //LUT[1186] \tphase : -0.328125\t(data_i, data_q): (0.562500,-0.937500)\n\t1187: o_phase = -9'd83;\t //LUT[1187] \tphase : -0.324219\t(data_i, data_q): (0.562500,-0.906250)\n\t1188: o_phase = -9'd81;\t //LUT[1188] \tphase : -0.316406\t(data_i, data_q): (0.562500,-0.875000)\n\t1189: o_phase = -9'd80;\t //LUT[1189] \tphase : -0.312500\t(data_i, data_q): (0.562500,-0.843750)\n\t1190: o_phase = -9'd79;\t //LUT[1190] \tphase : -0.308594\t(data_i, data_q): (0.562500,-0.812500)\n\t1191: o_phase = -9'd77;\t //LUT[1191] \tphase : -0.300781\t(data_i, data_q): (0.562500,-0.781250)\n\t1192: o_phase = -9'd76;\t //LUT[1192] \tphase : -0.296875\t(data_i, data_q): (0.562500,-0.750000)\n\t1193: o_phase = -9'd74;\t //LUT[1193] \tphase : -0.289062\t(data_i, data_q): (0.562500,-0.718750)\n\t1194: o_phase = -9'd72;\t //LUT[1194] \tphase : -0.281250\t(data_i, data_q): (0.562500,-0.687500)\n\t1195: o_phase = -9'd70;\t //LUT[1195] \tphase : -0.273438\t(data_i, data_q): (0.562500,-0.656250)\n\t1196: o_phase = -9'd68;\t //LUT[1196] \tphase : -0.265625\t(data_i, data_q): (0.562500,-0.625000)\n\t1197: o_phase = -9'd66;\t //LUT[1197] \tphase : -0.257812\t(data_i, data_q): (0.562500,-0.593750)\n\t1198: o_phase = -9'd64;\t //LUT[1198] \tphase : -0.250000\t(data_i, data_q): (0.562500,-0.562500)\n\t1199: o_phase = -9'd62;\t //LUT[1199] \tphase : -0.242188\t(data_i, data_q): (0.562500,-0.531250)\n\t1200: o_phase = -9'd59;\t //LUT[1200] \tphase : -0.230469\t(data_i, data_q): (0.562500,-0.500000)\n\t1201: o_phase = -9'd57;\t //LUT[1201] \tphase : -0.222656\t(data_i, data_q): (0.562500,-0.468750)\n\t1202: o_phase = -9'd54;\t //LUT[1202] \tphase : -0.210938\t(data_i, data_q): (0.562500,-0.437500)\n\t1203: o_phase = -9'd51;\t //LUT[1203] \tphase : -0.199219\t(data_i, data_q): (0.562500,-0.406250)\n\t1204: o_phase = -9'd48;\t //LUT[1204] \tphase : -0.187500\t(data_i, data_q): (0.562500,-0.375000)\n\t1205: o_phase = -9'd45;\t //LUT[1205] \tphase : -0.175781\t(data_i, data_q): (0.562500,-0.343750)\n\t1206: o_phase = -9'd41;\t //LUT[1206] \tphase : -0.160156\t(data_i, data_q): (0.562500,-0.312500)\n\t1207: o_phase = -9'd38;\t //LUT[1207] \tphase : -0.148438\t(data_i, data_q): (0.562500,-0.281250)\n\t1208: o_phase = -9'd34;\t //LUT[1208] \tphase : -0.132812\t(data_i, data_q): (0.562500,-0.250000)\n\t1209: o_phase = -9'd30;\t //LUT[1209] \tphase : -0.117188\t(data_i, data_q): (0.562500,-0.218750)\n\t1210: o_phase = -9'd26;\t //LUT[1210] \tphase : -0.101562\t(data_i, data_q): (0.562500,-0.187500)\n\t1211: o_phase = -9'd22;\t //LUT[1211] \tphase : -0.085938\t(data_i, data_q): (0.562500,-0.156250)\n\t1212: o_phase = -9'd18;\t //LUT[1212] \tphase : -0.070312\t(data_i, data_q): (0.562500,-0.125000)\n\t1213: o_phase = -9'd13;\t //LUT[1213] \tphase : -0.050781\t(data_i, data_q): (0.562500,-0.093750)\n\t1214: o_phase = -9'd9;\t //LUT[1214] \tphase : -0.035156\t(data_i, data_q): (0.562500,-0.062500)\n\t1215: o_phase = -9'd5;\t //LUT[1215] \tphase : -0.019531\t(data_i, data_q): (0.562500,-0.031250)\n\t1216: o_phase = +9'd0;\t //LUT[1216] \tphase : 0.000000\t(data_i, data_q): (0.593750,0.000000)\n\t1217: o_phase = +9'd4;\t //LUT[1217] \tphase : 0.015625\t(data_i, data_q): (0.593750,0.031250)\n\t1218: o_phase = +9'd9;\t //LUT[1218] \tphase : 0.035156\t(data_i, data_q): (0.593750,0.062500)\n\t1219: o_phase = +9'd13;\t //LUT[1219] \tphase : 0.050781\t(data_i, data_q): (0.593750,0.093750)\n\t1220: o_phase = +9'd17;\t //LUT[1220] \tphase : 0.066406\t(data_i, data_q): (0.593750,0.125000)\n\t1221: o_phase = +9'd21;\t //LUT[1221] \tphase : 0.082031\t(data_i, data_q): (0.593750,0.156250)\n\t1222: o_phase = +9'd25;\t //LUT[1222] \tphase : 0.097656\t(data_i, data_q): (0.593750,0.187500)\n\t1223: o_phase = +9'd29;\t //LUT[1223] \tphase : 0.113281\t(data_i, data_q): (0.593750,0.218750)\n\t1224: o_phase = +9'd32;\t //LUT[1224] \tphase : 0.125000\t(data_i, data_q): (0.593750,0.250000)\n\t1225: o_phase = +9'd36;\t //LUT[1225] \tphase : 0.140625\t(data_i, data_q): (0.593750,0.281250)\n\t1226: o_phase = +9'd39;\t //LUT[1226] \tphase : 0.152344\t(data_i, data_q): (0.593750,0.312500)\n\t1227: o_phase = +9'd43;\t //LUT[1227] \tphase : 0.167969\t(data_i, data_q): (0.593750,0.343750)\n\t1228: o_phase = +9'd46;\t //LUT[1228] \tphase : 0.179688\t(data_i, data_q): (0.593750,0.375000)\n\t1229: o_phase = +9'd49;\t //LUT[1229] \tphase : 0.191406\t(data_i, data_q): (0.593750,0.406250)\n\t1230: o_phase = +9'd52;\t //LUT[1230] \tphase : 0.203125\t(data_i, data_q): (0.593750,0.437500)\n\t1231: o_phase = +9'd54;\t //LUT[1231] \tphase : 0.210938\t(data_i, data_q): (0.593750,0.468750)\n\t1232: o_phase = +9'd57;\t //LUT[1232] \tphase : 0.222656\t(data_i, data_q): (0.593750,0.500000)\n\t1233: o_phase = +9'd59;\t //LUT[1233] \tphase : 0.230469\t(data_i, data_q): (0.593750,0.531250)\n\t1234: o_phase = +9'd62;\t //LUT[1234] \tphase : 0.242188\t(data_i, data_q): (0.593750,0.562500)\n\t1235: o_phase = +9'd64;\t //LUT[1235] \tphase : 0.250000\t(data_i, data_q): (0.593750,0.593750)\n\t1236: o_phase = +9'd66;\t //LUT[1236] \tphase : 0.257812\t(data_i, data_q): (0.593750,0.625000)\n\t1237: o_phase = +9'd68;\t //LUT[1237] \tphase : 0.265625\t(data_i, data_q): (0.593750,0.656250)\n\t1238: o_phase = +9'd70;\t //LUT[1238] \tphase : 0.273438\t(data_i, data_q): (0.593750,0.687500)\n\t1239: o_phase = +9'd72;\t //LUT[1239] \tphase : 0.281250\t(data_i, data_q): (0.593750,0.718750)\n\t1240: o_phase = +9'd73;\t //LUT[1240] \tphase : 0.285156\t(data_i, data_q): (0.593750,0.750000)\n\t1241: o_phase = +9'd75;\t //LUT[1241] \tphase : 0.292969\t(data_i, data_q): (0.593750,0.781250)\n\t1242: o_phase = +9'd77;\t //LUT[1242] \tphase : 0.300781\t(data_i, data_q): (0.593750,0.812500)\n\t1243: o_phase = +9'd78;\t //LUT[1243] \tphase : 0.304688\t(data_i, data_q): (0.593750,0.843750)\n\t1244: o_phase = +9'd79;\t //LUT[1244] \tphase : 0.308594\t(data_i, data_q): (0.593750,0.875000)\n\t1245: o_phase = +9'd81;\t //LUT[1245] \tphase : 0.316406\t(data_i, data_q): (0.593750,0.906250)\n\t1246: o_phase = +9'd82;\t //LUT[1246] \tphase : 0.320312\t(data_i, data_q): (0.593750,0.937500)\n\t1247: o_phase = +9'd83;\t //LUT[1247] \tphase : 0.324219\t(data_i, data_q): (0.593750,0.968750)\n\t1248: o_phase = -9'd84;\t //LUT[1248] \tphase : -0.328125\t(data_i, data_q): (0.593750,-1.000000)\n\t1249: o_phase = -9'd83;\t //LUT[1249] \tphase : -0.324219\t(data_i, data_q): (0.593750,-0.968750)\n\t1250: o_phase = -9'd82;\t //LUT[1250] \tphase : -0.320312\t(data_i, data_q): (0.593750,-0.937500)\n\t1251: o_phase = -9'd81;\t //LUT[1251] \tphase : -0.316406\t(data_i, data_q): (0.593750,-0.906250)\n\t1252: o_phase = -9'd79;\t //LUT[1252] \tphase : -0.308594\t(data_i, data_q): (0.593750,-0.875000)\n\t1253: o_phase = -9'd78;\t //LUT[1253] \tphase : -0.304688\t(data_i, data_q): (0.593750,-0.843750)\n\t1254: o_phase = -9'd77;\t //LUT[1254] \tphase : -0.300781\t(data_i, data_q): (0.593750,-0.812500)\n\t1255: o_phase = -9'd75;\t //LUT[1255] \tphase : -0.292969\t(data_i, data_q): (0.593750,-0.781250)\n\t1256: o_phase = -9'd73;\t //LUT[1256] \tphase : -0.285156\t(data_i, data_q): (0.593750,-0.750000)\n\t1257: o_phase = -9'd72;\t //LUT[1257] \tphase : -0.281250\t(data_i, data_q): (0.593750,-0.718750)\n\t1258: o_phase = -9'd70;\t //LUT[1258] \tphase : -0.273438\t(data_i, data_q): (0.593750,-0.687500)\n\t1259: o_phase = -9'd68;\t //LUT[1259] \tphase : -0.265625\t(data_i, data_q): (0.593750,-0.656250)\n\t1260: o_phase = -9'd66;\t //LUT[1260] \tphase : -0.257812\t(data_i, data_q): (0.593750,-0.625000)\n\t1261: o_phase = -9'd64;\t //LUT[1261] \tphase : -0.250000\t(data_i, data_q): (0.593750,-0.593750)\n\t1262: o_phase = -9'd62;\t //LUT[1262] \tphase : -0.242188\t(data_i, data_q): (0.593750,-0.562500)\n\t1263: o_phase = -9'd59;\t //LUT[1263] \tphase : -0.230469\t(data_i, data_q): (0.593750,-0.531250)\n\t1264: o_phase = -9'd57;\t //LUT[1264] \tphase : -0.222656\t(data_i, data_q): (0.593750,-0.500000)\n\t1265: o_phase = -9'd54;\t //LUT[1265] \tphase : -0.210938\t(data_i, data_q): (0.593750,-0.468750)\n\t1266: o_phase = -9'd52;\t //LUT[1266] \tphase : -0.203125\t(data_i, data_q): (0.593750,-0.437500)\n\t1267: o_phase = -9'd49;\t //LUT[1267] \tphase : -0.191406\t(data_i, data_q): (0.593750,-0.406250)\n\t1268: o_phase = -9'd46;\t //LUT[1268] \tphase : -0.179688\t(data_i, data_q): (0.593750,-0.375000)\n\t1269: o_phase = -9'd43;\t //LUT[1269] \tphase : -0.167969\t(data_i, data_q): (0.593750,-0.343750)\n\t1270: o_phase = -9'd39;\t //LUT[1270] \tphase : -0.152344\t(data_i, data_q): (0.593750,-0.312500)\n\t1271: o_phase = -9'd36;\t //LUT[1271] \tphase : -0.140625\t(data_i, data_q): (0.593750,-0.281250)\n\t1272: o_phase = -9'd32;\t //LUT[1272] \tphase : -0.125000\t(data_i, data_q): (0.593750,-0.250000)\n\t1273: o_phase = -9'd29;\t //LUT[1273] \tphase : -0.113281\t(data_i, data_q): (0.593750,-0.218750)\n\t1274: o_phase = -9'd25;\t //LUT[1274] \tphase : -0.097656\t(data_i, data_q): (0.593750,-0.187500)\n\t1275: o_phase = -9'd21;\t //LUT[1275] \tphase : -0.082031\t(data_i, data_q): (0.593750,-0.156250)\n\t1276: o_phase = -9'd17;\t //LUT[1276] \tphase : -0.066406\t(data_i, data_q): (0.593750,-0.125000)\n\t1277: o_phase = -9'd13;\t //LUT[1277] \tphase : -0.050781\t(data_i, data_q): (0.593750,-0.093750)\n\t1278: o_phase = -9'd9;\t //LUT[1278] \tphase : -0.035156\t(data_i, data_q): (0.593750,-0.062500)\n\t1279: o_phase = -9'd4;\t //LUT[1279] \tphase : -0.015625\t(data_i, data_q): (0.593750,-0.031250)\n\t1280: o_phase = +9'd0;\t //LUT[1280] \tphase : 0.000000\t(data_i, data_q): (0.625000,0.000000)\n\t1281: o_phase = +9'd4;\t //LUT[1281] \tphase : 0.015625\t(data_i, data_q): (0.625000,0.031250)\n\t1282: o_phase = +9'd8;\t //LUT[1282] \tphase : 0.031250\t(data_i, data_q): (0.625000,0.062500)\n\t1283: o_phase = +9'd12;\t //LUT[1283] \tphase : 0.046875\t(data_i, data_q): (0.625000,0.093750)\n\t1284: o_phase = +9'd16;\t //LUT[1284] \tphase : 0.062500\t(data_i, data_q): (0.625000,0.125000)\n\t1285: o_phase = +9'd20;\t //LUT[1285] \tphase : 0.078125\t(data_i, data_q): (0.625000,0.156250)\n\t1286: o_phase = +9'd24;\t //LUT[1286] \tphase : 0.093750\t(data_i, data_q): (0.625000,0.187500)\n\t1287: o_phase = +9'd27;\t //LUT[1287] \tphase : 0.105469\t(data_i, data_q): (0.625000,0.218750)\n\t1288: o_phase = +9'd31;\t //LUT[1288] \tphase : 0.121094\t(data_i, data_q): (0.625000,0.250000)\n\t1289: o_phase = +9'd34;\t //LUT[1289] \tphase : 0.132812\t(data_i, data_q): (0.625000,0.281250)\n\t1290: o_phase = +9'd38;\t //LUT[1290] \tphase : 0.148438\t(data_i, data_q): (0.625000,0.312500)\n\t1291: o_phase = +9'd41;\t //LUT[1291] \tphase : 0.160156\t(data_i, data_q): (0.625000,0.343750)\n\t1292: o_phase = +9'd44;\t //LUT[1292] \tphase : 0.171875\t(data_i, data_q): (0.625000,0.375000)\n\t1293: o_phase = +9'd47;\t //LUT[1293] \tphase : 0.183594\t(data_i, data_q): (0.625000,0.406250)\n\t1294: o_phase = +9'd50;\t //LUT[1294] \tphase : 0.195312\t(data_i, data_q): (0.625000,0.437500)\n\t1295: o_phase = +9'd52;\t //LUT[1295] \tphase : 0.203125\t(data_i, data_q): (0.625000,0.468750)\n\t1296: o_phase = +9'd55;\t //LUT[1296] \tphase : 0.214844\t(data_i, data_q): (0.625000,0.500000)\n\t1297: o_phase = +9'd57;\t //LUT[1297] \tphase : 0.222656\t(data_i, data_q): (0.625000,0.531250)\n\t1298: o_phase = +9'd60;\t //LUT[1298] \tphase : 0.234375\t(data_i, data_q): (0.625000,0.562500)\n\t1299: o_phase = +9'd62;\t //LUT[1299] \tphase : 0.242188\t(data_i, data_q): (0.625000,0.593750)\n\t1300: o_phase = +9'd64;\t //LUT[1300] \tphase : 0.250000\t(data_i, data_q): (0.625000,0.625000)\n\t1301: o_phase = +9'd66;\t //LUT[1301] \tphase : 0.257812\t(data_i, data_q): (0.625000,0.656250)\n\t1302: o_phase = +9'd68;\t //LUT[1302] \tphase : 0.265625\t(data_i, data_q): (0.625000,0.687500)\n\t1303: o_phase = +9'd70;\t //LUT[1303] \tphase : 0.273438\t(data_i, data_q): (0.625000,0.718750)\n\t1304: o_phase = +9'd71;\t //LUT[1304] \tphase : 0.277344\t(data_i, data_q): (0.625000,0.750000)\n\t1305: o_phase = +9'd73;\t //LUT[1305] \tphase : 0.285156\t(data_i, data_q): (0.625000,0.781250)\n\t1306: o_phase = +9'd75;\t //LUT[1306] \tphase : 0.292969\t(data_i, data_q): (0.625000,0.812500)\n\t1307: o_phase = +9'd76;\t //LUT[1307] \tphase : 0.296875\t(data_i, data_q): (0.625000,0.843750)\n\t1308: o_phase = +9'd77;\t //LUT[1308] \tphase : 0.300781\t(data_i, data_q): (0.625000,0.875000)\n\t1309: o_phase = +9'd79;\t //LUT[1309] \tphase : 0.308594\t(data_i, data_q): (0.625000,0.906250)\n\t1310: o_phase = +9'd80;\t //LUT[1310] \tphase : 0.312500\t(data_i, data_q): (0.625000,0.937500)\n\t1311: o_phase = +9'd81;\t //LUT[1311] \tphase : 0.316406\t(data_i, data_q): (0.625000,0.968750)\n\t1312: o_phase = -9'd82;\t //LUT[1312] \tphase : -0.320312\t(data_i, data_q): (0.625000,-1.000000)\n\t1313: o_phase = -9'd81;\t //LUT[1313] \tphase : -0.316406\t(data_i, data_q): (0.625000,-0.968750)\n\t1314: o_phase = -9'd80;\t //LUT[1314] \tphase : -0.312500\t(data_i, data_q): (0.625000,-0.937500)\n\t1315: o_phase = -9'd79;\t //LUT[1315] \tphase : -0.308594\t(data_i, data_q): (0.625000,-0.906250)\n\t1316: o_phase = -9'd77;\t //LUT[1316] \tphase : -0.300781\t(data_i, data_q): (0.625000,-0.875000)\n\t1317: o_phase = -9'd76;\t //LUT[1317] \tphase : -0.296875\t(data_i, data_q): (0.625000,-0.843750)\n\t1318: o_phase = -9'd75;\t //LUT[1318] \tphase : -0.292969\t(data_i, data_q): (0.625000,-0.812500)\n\t1319: o_phase = -9'd73;\t //LUT[1319] \tphase : -0.285156\t(data_i, data_q): (0.625000,-0.781250)\n\t1320: o_phase = -9'd71;\t //LUT[1320] \tphase : -0.277344\t(data_i, data_q): (0.625000,-0.750000)\n\t1321: o_phase = -9'd70;\t //LUT[1321] \tphase : -0.273438\t(data_i, data_q): (0.625000,-0.718750)\n\t1322: o_phase = -9'd68;\t //LUT[1322] \tphase : -0.265625\t(data_i, data_q): (0.625000,-0.687500)\n\t1323: o_phase = -9'd66;\t //LUT[1323] \tphase : -0.257812\t(data_i, data_q): (0.625000,-0.656250)\n\t1324: o_phase = -9'd64;\t //LUT[1324] \tphase : -0.250000\t(data_i, data_q): (0.625000,-0.625000)\n\t1325: o_phase = -9'd62;\t //LUT[1325] \tphase : -0.242188\t(data_i, data_q): (0.625000,-0.593750)\n\t1326: o_phase = -9'd60;\t //LUT[1326] \tphase : -0.234375\t(data_i, data_q): (0.625000,-0.562500)\n\t1327: o_phase = -9'd57;\t //LUT[1327] \tphase : -0.222656\t(data_i, data_q): (0.625000,-0.531250)\n\t1328: o_phase = -9'd55;\t //LUT[1328] \tphase : -0.214844\t(data_i, data_q): (0.625000,-0.500000)\n\t1329: o_phase = -9'd52;\t //LUT[1329] \tphase : -0.203125\t(data_i, data_q): (0.625000,-0.468750)\n\t1330: o_phase = -9'd50;\t //LUT[1330] \tphase : -0.195312\t(data_i, data_q): (0.625000,-0.437500)\n\t1331: o_phase = -9'd47;\t //LUT[1331] \tphase : -0.183594\t(data_i, data_q): (0.625000,-0.406250)\n\t1332: o_phase = -9'd44;\t //LUT[1332] \tphase : -0.171875\t(data_i, data_q): (0.625000,-0.375000)\n\t1333: o_phase = -9'd41;\t //LUT[1333] \tphase : -0.160156\t(data_i, data_q): (0.625000,-0.343750)\n\t1334: o_phase = -9'd38;\t //LUT[1334] \tphase : -0.148438\t(data_i, data_q): (0.625000,-0.312500)\n\t1335: o_phase = -9'd34;\t //LUT[1335] \tphase : -0.132812\t(data_i, data_q): (0.625000,-0.281250)\n\t1336: o_phase = -9'd31;\t //LUT[1336] \tphase : -0.121094\t(data_i, data_q): (0.625000,-0.250000)\n\t1337: o_phase = -9'd27;\t //LUT[1337] \tphase : -0.105469\t(data_i, data_q): (0.625000,-0.218750)\n\t1338: o_phase = -9'd24;\t //LUT[1338] \tphase : -0.093750\t(data_i, data_q): (0.625000,-0.187500)\n\t1339: o_phase = -9'd20;\t //LUT[1339] \tphase : -0.078125\t(data_i, data_q): (0.625000,-0.156250)\n\t1340: o_phase = -9'd16;\t //LUT[1340] \tphase : -0.062500\t(data_i, data_q): (0.625000,-0.125000)\n\t1341: o_phase = -9'd12;\t //LUT[1341] \tphase : -0.046875\t(data_i, data_q): (0.625000,-0.093750)\n\t1342: o_phase = -9'd8;\t //LUT[1342] \tphase : -0.031250\t(data_i, data_q): (0.625000,-0.062500)\n\t1343: o_phase = -9'd4;\t //LUT[1343] \tphase : -0.015625\t(data_i, data_q): (0.625000,-0.031250)\n\t1344: o_phase = +9'd0;\t //LUT[1344] \tphase : 0.000000\t(data_i, data_q): (0.656250,0.000000)\n\t1345: o_phase = +9'd4;\t //LUT[1345] \tphase : 0.015625\t(data_i, data_q): (0.656250,0.031250)\n\t1346: o_phase = +9'd8;\t //LUT[1346] \tphase : 0.031250\t(data_i, data_q): (0.656250,0.062500)\n\t1347: o_phase = +9'd12;\t //LUT[1347] \tphase : 0.046875\t(data_i, data_q): (0.656250,0.093750)\n\t1348: o_phase = +9'd15;\t //LUT[1348] \tphase : 0.058594\t(data_i, data_q): (0.656250,0.125000)\n\t1349: o_phase = +9'd19;\t //LUT[1349] \tphase : 0.074219\t(data_i, data_q): (0.656250,0.156250)\n\t1350: o_phase = +9'd23;\t //LUT[1350] \tphase : 0.089844\t(data_i, data_q): (0.656250,0.187500)\n\t1351: o_phase = +9'd26;\t //LUT[1351] \tphase : 0.101562\t(data_i, data_q): (0.656250,0.218750)\n\t1352: o_phase = +9'd30;\t //LUT[1352] \tphase : 0.117188\t(data_i, data_q): (0.656250,0.250000)\n\t1353: o_phase = +9'd33;\t //LUT[1353] \tphase : 0.128906\t(data_i, data_q): (0.656250,0.281250)\n\t1354: o_phase = +9'd36;\t //LUT[1354] \tphase : 0.140625\t(data_i, data_q): (0.656250,0.312500)\n\t1355: o_phase = +9'd39;\t //LUT[1355] \tphase : 0.152344\t(data_i, data_q): (0.656250,0.343750)\n\t1356: o_phase = +9'd42;\t //LUT[1356] \tphase : 0.164062\t(data_i, data_q): (0.656250,0.375000)\n\t1357: o_phase = +9'd45;\t //LUT[1357] \tphase : 0.175781\t(data_i, data_q): (0.656250,0.406250)\n\t1358: o_phase = +9'd48;\t //LUT[1358] \tphase : 0.187500\t(data_i, data_q): (0.656250,0.437500)\n\t1359: o_phase = +9'd51;\t //LUT[1359] \tphase : 0.199219\t(data_i, data_q): (0.656250,0.468750)\n\t1360: o_phase = +9'd53;\t //LUT[1360] \tphase : 0.207031\t(data_i, data_q): (0.656250,0.500000)\n\t1361: o_phase = +9'd55;\t //LUT[1361] \tphase : 0.214844\t(data_i, data_q): (0.656250,0.531250)\n\t1362: o_phase = +9'd58;\t //LUT[1362] \tphase : 0.226562\t(data_i, data_q): (0.656250,0.562500)\n\t1363: o_phase = +9'd60;\t //LUT[1363] \tphase : 0.234375\t(data_i, data_q): (0.656250,0.593750)\n\t1364: o_phase = +9'd62;\t //LUT[1364] \tphase : 0.242188\t(data_i, data_q): (0.656250,0.625000)\n\t1365: o_phase = +9'd64;\t //LUT[1365] \tphase : 0.250000\t(data_i, data_q): (0.656250,0.656250)\n\t1366: o_phase = +9'd66;\t //LUT[1366] \tphase : 0.257812\t(data_i, data_q): (0.656250,0.687500)\n\t1367: o_phase = +9'd68;\t //LUT[1367] \tphase : 0.265625\t(data_i, data_q): (0.656250,0.718750)\n\t1368: o_phase = +9'd69;\t //LUT[1368] \tphase : 0.269531\t(data_i, data_q): (0.656250,0.750000)\n\t1369: o_phase = +9'd71;\t //LUT[1369] \tphase : 0.277344\t(data_i, data_q): (0.656250,0.781250)\n\t1370: o_phase = +9'd73;\t //LUT[1370] \tphase : 0.285156\t(data_i, data_q): (0.656250,0.812500)\n\t1371: o_phase = +9'd74;\t //LUT[1371] \tphase : 0.289062\t(data_i, data_q): (0.656250,0.843750)\n\t1372: o_phase = +9'd76;\t //LUT[1372] \tphase : 0.296875\t(data_i, data_q): (0.656250,0.875000)\n\t1373: o_phase = +9'd77;\t //LUT[1373] \tphase : 0.300781\t(data_i, data_q): (0.656250,0.906250)\n\t1374: o_phase = +9'd78;\t //LUT[1374] \tphase : 0.304688\t(data_i, data_q): (0.656250,0.937500)\n\t1375: o_phase = +9'd79;\t //LUT[1375] \tphase : 0.308594\t(data_i, data_q): (0.656250,0.968750)\n\t1376: o_phase = -9'd81;\t //LUT[1376] \tphase : -0.316406\t(data_i, data_q): (0.656250,-1.000000)\n\t1377: o_phase = -9'd79;\t //LUT[1377] \tphase : -0.308594\t(data_i, data_q): (0.656250,-0.968750)\n\t1378: o_phase = -9'd78;\t //LUT[1378] \tphase : -0.304688\t(data_i, data_q): (0.656250,-0.937500)\n\t1379: o_phase = -9'd77;\t //LUT[1379] \tphase : -0.300781\t(data_i, data_q): (0.656250,-0.906250)\n\t1380: o_phase = -9'd76;\t //LUT[1380] \tphase : -0.296875\t(data_i, data_q): (0.656250,-0.875000)\n\t1381: o_phase = -9'd74;\t //LUT[1381] \tphase : -0.289062\t(data_i, data_q): (0.656250,-0.843750)\n\t1382: o_phase = -9'd73;\t //LUT[1382] \tphase : -0.285156\t(data_i, data_q): (0.656250,-0.812500)\n\t1383: o_phase = -9'd71;\t //LUT[1383] \tphase : -0.277344\t(data_i, data_q): (0.656250,-0.781250)\n\t1384: o_phase = -9'd69;\t //LUT[1384] \tphase : -0.269531\t(data_i, data_q): (0.656250,-0.750000)\n\t1385: o_phase = -9'd68;\t //LUT[1385] \tphase : -0.265625\t(data_i, data_q): (0.656250,-0.718750)\n\t1386: o_phase = -9'd66;\t //LUT[1386] \tphase : -0.257812\t(data_i, data_q): (0.656250,-0.687500)\n\t1387: o_phase = -9'd64;\t //LUT[1387] \tphase : -0.250000\t(data_i, data_q): (0.656250,-0.656250)\n\t1388: o_phase = -9'd62;\t //LUT[1388] \tphase : -0.242188\t(data_i, data_q): (0.656250,-0.625000)\n\t1389: o_phase = -9'd60;\t //LUT[1389] \tphase : -0.234375\t(data_i, data_q): (0.656250,-0.593750)\n\t1390: o_phase = -9'd58;\t //LUT[1390] \tphase : -0.226562\t(data_i, data_q): (0.656250,-0.562500)\n\t1391: o_phase = -9'd55;\t //LUT[1391] \tphase : -0.214844\t(data_i, data_q): (0.656250,-0.531250)\n\t1392: o_phase = -9'd53;\t //LUT[1392] \tphase : -0.207031\t(data_i, data_q): (0.656250,-0.500000)\n\t1393: o_phase = -9'd51;\t //LUT[1393] \tphase : -0.199219\t(data_i, data_q): (0.656250,-0.468750)\n\t1394: o_phase = -9'd48;\t //LUT[1394] \tphase : -0.187500\t(data_i, data_q): (0.656250,-0.437500)\n\t1395: o_phase = -9'd45;\t //LUT[1395] \tphase : -0.175781\t(data_i, data_q): (0.656250,-0.406250)\n\t1396: o_phase = -9'd42;\t //LUT[1396] \tphase : -0.164062\t(data_i, data_q): (0.656250,-0.375000)\n\t1397: o_phase = -9'd39;\t //LUT[1397] \tphase : -0.152344\t(data_i, data_q): (0.656250,-0.343750)\n\t1398: o_phase = -9'd36;\t //LUT[1398] \tphase : -0.140625\t(data_i, data_q): (0.656250,-0.312500)\n\t1399: o_phase = -9'd33;\t //LUT[1399] \tphase : -0.128906\t(data_i, data_q): (0.656250,-0.281250)\n\t1400: o_phase = -9'd30;\t //LUT[1400] \tphase : -0.117188\t(data_i, data_q): (0.656250,-0.250000)\n\t1401: o_phase = -9'd26;\t //LUT[1401] \tphase : -0.101562\t(data_i, data_q): (0.656250,-0.218750)\n\t1402: o_phase = -9'd23;\t //LUT[1402] \tphase : -0.089844\t(data_i, data_q): (0.656250,-0.187500)\n\t1403: o_phase = -9'd19;\t //LUT[1403] \tphase : -0.074219\t(data_i, data_q): (0.656250,-0.156250)\n\t1404: o_phase = -9'd15;\t //LUT[1404] \tphase : -0.058594\t(data_i, data_q): (0.656250,-0.125000)\n\t1405: o_phase = -9'd12;\t //LUT[1405] \tphase : -0.046875\t(data_i, data_q): (0.656250,-0.093750)\n\t1406: o_phase = -9'd8;\t //LUT[1406] \tphase : -0.031250\t(data_i, data_q): (0.656250,-0.062500)\n\t1407: o_phase = -9'd4;\t //LUT[1407] \tphase : -0.015625\t(data_i, data_q): (0.656250,-0.031250)\n\t1408: o_phase = +9'd0;\t //LUT[1408] \tphase : 0.000000\t(data_i, data_q): (0.687500,0.000000)\n\t1409: o_phase = +9'd4;\t //LUT[1409] \tphase : 0.015625\t(data_i, data_q): (0.687500,0.031250)\n\t1410: o_phase = +9'd7;\t //LUT[1410] \tphase : 0.027344\t(data_i, data_q): (0.687500,0.062500)\n\t1411: o_phase = +9'd11;\t //LUT[1411] \tphase : 0.042969\t(data_i, data_q): (0.687500,0.093750)\n\t1412: o_phase = +9'd15;\t //LUT[1412] \tphase : 0.058594\t(data_i, data_q): (0.687500,0.125000)\n\t1413: o_phase = +9'd18;\t //LUT[1413] \tphase : 0.070312\t(data_i, data_q): (0.687500,0.156250)\n\t1414: o_phase = +9'd22;\t //LUT[1414] \tphase : 0.085938\t(data_i, data_q): (0.687500,0.187500)\n\t1415: o_phase = +9'd25;\t //LUT[1415] \tphase : 0.097656\t(data_i, data_q): (0.687500,0.218750)\n\t1416: o_phase = +9'd28;\t //LUT[1416] \tphase : 0.109375\t(data_i, data_q): (0.687500,0.250000)\n\t1417: o_phase = +9'd32;\t //LUT[1417] \tphase : 0.125000\t(data_i, data_q): (0.687500,0.281250)\n\t1418: o_phase = +9'd35;\t //LUT[1418] \tphase : 0.136719\t(data_i, data_q): (0.687500,0.312500)\n\t1419: o_phase = +9'd38;\t //LUT[1419] \tphase : 0.148438\t(data_i, data_q): (0.687500,0.343750)\n\t1420: o_phase = +9'd41;\t //LUT[1420] \tphase : 0.160156\t(data_i, data_q): (0.687500,0.375000)\n\t1421: o_phase = +9'd43;\t //LUT[1421] \tphase : 0.167969\t(data_i, data_q): (0.687500,0.406250)\n\t1422: o_phase = +9'd46;\t //LUT[1422] \tphase : 0.179688\t(data_i, data_q): (0.687500,0.437500)\n\t1423: o_phase = +9'd49;\t //LUT[1423] \tphase : 0.191406\t(data_i, data_q): (0.687500,0.468750)\n\t1424: o_phase = +9'd51;\t //LUT[1424] \tphase : 0.199219\t(data_i, data_q): (0.687500,0.500000)\n\t1425: o_phase = +9'd54;\t //LUT[1425] \tphase : 0.210938\t(data_i, data_q): (0.687500,0.531250)\n\t1426: o_phase = +9'd56;\t //LUT[1426] \tphase : 0.218750\t(data_i, data_q): (0.687500,0.562500)\n\t1427: o_phase = +9'd58;\t //LUT[1427] \tphase : 0.226562\t(data_i, data_q): (0.687500,0.593750)\n\t1428: o_phase = +9'd60;\t //LUT[1428] \tphase : 0.234375\t(data_i, data_q): (0.687500,0.625000)\n\t1429: o_phase = +9'd62;\t //LUT[1429] \tphase : 0.242188\t(data_i, data_q): (0.687500,0.656250)\n\t1430: o_phase = +9'd64;\t //LUT[1430] \tphase : 0.250000\t(data_i, data_q): (0.687500,0.687500)\n\t1431: o_phase = +9'd66;\t //LUT[1431] \tphase : 0.257812\t(data_i, data_q): (0.687500,0.718750)\n\t1432: o_phase = +9'd68;\t //LUT[1432] \tphase : 0.265625\t(data_i, data_q): (0.687500,0.750000)\n\t1433: o_phase = +9'd69;\t //LUT[1433] \tphase : 0.269531\t(data_i, data_q): (0.687500,0.781250)\n\t1434: o_phase = +9'd71;\t //LUT[1434] \tphase : 0.277344\t(data_i, data_q): (0.687500,0.812500)\n\t1435: o_phase = +9'd72;\t //LUT[1435] \tphase : 0.281250\t(data_i, data_q): (0.687500,0.843750)\n\t1436: o_phase = +9'd74;\t //LUT[1436] \tphase : 0.289062\t(data_i, data_q): (0.687500,0.875000)\n\t1437: o_phase = +9'd75;\t //LUT[1437] \tphase : 0.292969\t(data_i, data_q): (0.687500,0.906250)\n\t1438: o_phase = +9'd76;\t //LUT[1438] \tphase : 0.296875\t(data_i, data_q): (0.687500,0.937500)\n\t1439: o_phase = +9'd78;\t //LUT[1439] \tphase : 0.304688\t(data_i, data_q): (0.687500,0.968750)\n\t1440: o_phase = -9'd79;\t //LUT[1440] \tphase : -0.308594\t(data_i, data_q): (0.687500,-1.000000)\n\t1441: o_phase = -9'd78;\t //LUT[1441] \tphase : -0.304688\t(data_i, data_q): (0.687500,-0.968750)\n\t1442: o_phase = -9'd76;\t //LUT[1442] \tphase : -0.296875\t(data_i, data_q): (0.687500,-0.937500)\n\t1443: o_phase = -9'd75;\t //LUT[1443] \tphase : -0.292969\t(data_i, data_q): (0.687500,-0.906250)\n\t1444: o_phase = -9'd74;\t //LUT[1444] \tphase : -0.289062\t(data_i, data_q): (0.687500,-0.875000)\n\t1445: o_phase = -9'd72;\t //LUT[1445] \tphase : -0.281250\t(data_i, data_q): (0.687500,-0.843750)\n\t1446: o_phase = -9'd71;\t //LUT[1446] \tphase : -0.277344\t(data_i, data_q): (0.687500,-0.812500)\n\t1447: o_phase = -9'd69;\t //LUT[1447] \tphase : -0.269531\t(data_i, data_q): (0.687500,-0.781250)\n\t1448: o_phase = -9'd68;\t //LUT[1448] \tphase : -0.265625\t(data_i, data_q): (0.687500,-0.750000)\n\t1449: o_phase = -9'd66;\t //LUT[1449] \tphase : -0.257812\t(data_i, data_q): (0.687500,-0.718750)\n\t1450: o_phase = -9'd64;\t //LUT[1450] \tphase : -0.250000\t(data_i, data_q): (0.687500,-0.687500)\n\t1451: o_phase = -9'd62;\t //LUT[1451] \tphase : -0.242188\t(data_i, data_q): (0.687500,-0.656250)\n\t1452: o_phase = -9'd60;\t //LUT[1452] \tphase : -0.234375\t(data_i, data_q): (0.687500,-0.625000)\n\t1453: o_phase = -9'd58;\t //LUT[1453] \tphase : -0.226562\t(data_i, data_q): (0.687500,-0.593750)\n\t1454: o_phase = -9'd56;\t //LUT[1454] \tphase : -0.218750\t(data_i, data_q): (0.687500,-0.562500)\n\t1455: o_phase = -9'd54;\t //LUT[1455] \tphase : -0.210938\t(data_i, data_q): (0.687500,-0.531250)\n\t1456: o_phase = -9'd51;\t //LUT[1456] \tphase : -0.199219\t(data_i, data_q): (0.687500,-0.500000)\n\t1457: o_phase = -9'd49;\t //LUT[1457] \tphase : -0.191406\t(data_i, data_q): (0.687500,-0.468750)\n\t1458: o_phase = -9'd46;\t //LUT[1458] \tphase : -0.179688\t(data_i, data_q): (0.687500,-0.437500)\n\t1459: o_phase = -9'd43;\t //LUT[1459] \tphase : -0.167969\t(data_i, data_q): (0.687500,-0.406250)\n\t1460: o_phase = -9'd41;\t //LUT[1460] \tphase : -0.160156\t(data_i, data_q): (0.687500,-0.375000)\n\t1461: o_phase = -9'd38;\t //LUT[1461] \tphase : -0.148438\t(data_i, data_q): (0.687500,-0.343750)\n\t1462: o_phase = -9'd35;\t //LUT[1462] \tphase : -0.136719\t(data_i, data_q): (0.687500,-0.312500)\n\t1463: o_phase = -9'd32;\t //LUT[1463] \tphase : -0.125000\t(data_i, data_q): (0.687500,-0.281250)\n\t1464: o_phase = -9'd28;\t //LUT[1464] \tphase : -0.109375\t(data_i, data_q): (0.687500,-0.250000)\n\t1465: o_phase = -9'd25;\t //LUT[1465] \tphase : -0.097656\t(data_i, data_q): (0.687500,-0.218750)\n\t1466: o_phase = -9'd22;\t //LUT[1466] \tphase : -0.085938\t(data_i, data_q): (0.687500,-0.187500)\n\t1467: o_phase = -9'd18;\t //LUT[1467] \tphase : -0.070312\t(data_i, data_q): (0.687500,-0.156250)\n\t1468: o_phase = -9'd15;\t //LUT[1468] \tphase : -0.058594\t(data_i, data_q): (0.687500,-0.125000)\n\t1469: o_phase = -9'd11;\t //LUT[1469] \tphase : -0.042969\t(data_i, data_q): (0.687500,-0.093750)\n\t1470: o_phase = -9'd7;\t //LUT[1470] \tphase : -0.027344\t(data_i, data_q): (0.687500,-0.062500)\n\t1471: o_phase = -9'd4;\t //LUT[1471] \tphase : -0.015625\t(data_i, data_q): (0.687500,-0.031250)\n\t1472: o_phase = +9'd0;\t //LUT[1472] \tphase : 0.000000\t(data_i, data_q): (0.718750,0.000000)\n\t1473: o_phase = +9'd4;\t //LUT[1473] \tphase : 0.015625\t(data_i, data_q): (0.718750,0.031250)\n\t1474: o_phase = +9'd7;\t //LUT[1474] \tphase : 0.027344\t(data_i, data_q): (0.718750,0.062500)\n\t1475: o_phase = +9'd11;\t //LUT[1475] \tphase : 0.042969\t(data_i, data_q): (0.718750,0.093750)\n\t1476: o_phase = +9'd14;\t //LUT[1476] \tphase : 0.054688\t(data_i, data_q): (0.718750,0.125000)\n\t1477: o_phase = +9'd17;\t //LUT[1477] \tphase : 0.066406\t(data_i, data_q): (0.718750,0.156250)\n\t1478: o_phase = +9'd21;\t //LUT[1478] \tphase : 0.082031\t(data_i, data_q): (0.718750,0.187500)\n\t1479: o_phase = +9'd24;\t //LUT[1479] \tphase : 0.093750\t(data_i, data_q): (0.718750,0.218750)\n\t1480: o_phase = +9'd27;\t //LUT[1480] \tphase : 0.105469\t(data_i, data_q): (0.718750,0.250000)\n\t1481: o_phase = +9'd30;\t //LUT[1481] \tphase : 0.117188\t(data_i, data_q): (0.718750,0.281250)\n\t1482: o_phase = +9'd33;\t //LUT[1482] \tphase : 0.128906\t(data_i, data_q): (0.718750,0.312500)\n\t1483: o_phase = +9'd36;\t //LUT[1483] \tphase : 0.140625\t(data_i, data_q): (0.718750,0.343750)\n\t1484: o_phase = +9'd39;\t //LUT[1484] \tphase : 0.152344\t(data_i, data_q): (0.718750,0.375000)\n\t1485: o_phase = +9'd42;\t //LUT[1485] \tphase : 0.164062\t(data_i, data_q): (0.718750,0.406250)\n\t1486: o_phase = +9'd45;\t //LUT[1486] \tphase : 0.175781\t(data_i, data_q): (0.718750,0.437500)\n\t1487: o_phase = +9'd47;\t //LUT[1487] \tphase : 0.183594\t(data_i, data_q): (0.718750,0.468750)\n\t1488: o_phase = +9'd50;\t //LUT[1488] \tphase : 0.195312\t(data_i, data_q): (0.718750,0.500000)\n\t1489: o_phase = +9'd52;\t //LUT[1489] \tphase : 0.203125\t(data_i, data_q): (0.718750,0.531250)\n\t1490: o_phase = +9'd54;\t //LUT[1490] \tphase : 0.210938\t(data_i, data_q): (0.718750,0.562500)\n\t1491: o_phase = +9'd56;\t //LUT[1491] \tphase : 0.218750\t(data_i, data_q): (0.718750,0.593750)\n\t1492: o_phase = +9'd58;\t //LUT[1492] \tphase : 0.226562\t(data_i, data_q): (0.718750,0.625000)\n\t1493: o_phase = +9'd60;\t //LUT[1493] \tphase : 0.234375\t(data_i, data_q): (0.718750,0.656250)\n\t1494: o_phase = +9'd62;\t //LUT[1494] \tphase : 0.242188\t(data_i, data_q): (0.718750,0.687500)\n\t1495: o_phase = +9'd64;\t //LUT[1495] \tphase : 0.250000\t(data_i, data_q): (0.718750,0.718750)\n\t1496: o_phase = +9'd66;\t //LUT[1496] \tphase : 0.257812\t(data_i, data_q): (0.718750,0.750000)\n\t1497: o_phase = +9'd67;\t //LUT[1497] \tphase : 0.261719\t(data_i, data_q): (0.718750,0.781250)\n\t1498: o_phase = +9'd69;\t //LUT[1498] \tphase : 0.269531\t(data_i, data_q): (0.718750,0.812500)\n\t1499: o_phase = +9'd71;\t //LUT[1499] \tphase : 0.277344\t(data_i, data_q): (0.718750,0.843750)\n\t1500: o_phase = +9'd72;\t //LUT[1500] \tphase : 0.281250\t(data_i, data_q): (0.718750,0.875000)\n\t1501: o_phase = +9'd73;\t //LUT[1501] \tphase : 0.285156\t(data_i, data_q): (0.718750,0.906250)\n\t1502: o_phase = +9'd75;\t //LUT[1502] \tphase : 0.292969\t(data_i, data_q): (0.718750,0.937500)\n\t1503: o_phase = +9'd76;\t //LUT[1503] \tphase : 0.296875\t(data_i, data_q): (0.718750,0.968750)\n\t1504: o_phase = -9'd77;\t //LUT[1504] \tphase : -0.300781\t(data_i, data_q): (0.718750,-1.000000)\n\t1505: o_phase = -9'd76;\t //LUT[1505] \tphase : -0.296875\t(data_i, data_q): (0.718750,-0.968750)\n\t1506: o_phase = -9'd75;\t //LUT[1506] \tphase : -0.292969\t(data_i, data_q): (0.718750,-0.937500)\n\t1507: o_phase = -9'd73;\t //LUT[1507] \tphase : -0.285156\t(data_i, data_q): (0.718750,-0.906250)\n\t1508: o_phase = -9'd72;\t //LUT[1508] \tphase : -0.281250\t(data_i, data_q): (0.718750,-0.875000)\n\t1509: o_phase = -9'd71;\t //LUT[1509] \tphase : -0.277344\t(data_i, data_q): (0.718750,-0.843750)\n\t1510: o_phase = -9'd69;\t //LUT[1510] \tphase : -0.269531\t(data_i, data_q): (0.718750,-0.812500)\n\t1511: o_phase = -9'd67;\t //LUT[1511] \tphase : -0.261719\t(data_i, data_q): (0.718750,-0.781250)\n\t1512: o_phase = -9'd66;\t //LUT[1512] \tphase : -0.257812\t(data_i, data_q): (0.718750,-0.750000)\n\t1513: o_phase = -9'd64;\t //LUT[1513] \tphase : -0.250000\t(data_i, data_q): (0.718750,-0.718750)\n\t1514: o_phase = -9'd62;\t //LUT[1514] \tphase : -0.242188\t(data_i, data_q): (0.718750,-0.687500)\n\t1515: o_phase = -9'd60;\t //LUT[1515] \tphase : -0.234375\t(data_i, data_q): (0.718750,-0.656250)\n\t1516: o_phase = -9'd58;\t //LUT[1516] \tphase : -0.226562\t(data_i, data_q): (0.718750,-0.625000)\n\t1517: o_phase = -9'd56;\t //LUT[1517] \tphase : -0.218750\t(data_i, data_q): (0.718750,-0.593750)\n\t1518: o_phase = -9'd54;\t //LUT[1518] \tphase : -0.210938\t(data_i, data_q): (0.718750,-0.562500)\n\t1519: o_phase = -9'd52;\t //LUT[1519] \tphase : -0.203125\t(data_i, data_q): (0.718750,-0.531250)\n\t1520: o_phase = -9'd50;\t //LUT[1520] \tphase : -0.195312\t(data_i, data_q): (0.718750,-0.500000)\n\t1521: o_phase = -9'd47;\t //LUT[1521] \tphase : -0.183594\t(data_i, data_q): (0.718750,-0.468750)\n\t1522: o_phase = -9'd45;\t //LUT[1522] \tphase : -0.175781\t(data_i, data_q): (0.718750,-0.437500)\n\t1523: o_phase = -9'd42;\t //LUT[1523] \tphase : -0.164062\t(data_i, data_q): (0.718750,-0.406250)\n\t1524: o_phase = -9'd39;\t //LUT[1524] \tphase : -0.152344\t(data_i, data_q): (0.718750,-0.375000)\n\t1525: o_phase = -9'd36;\t //LUT[1525] \tphase : -0.140625\t(data_i, data_q): (0.718750,-0.343750)\n\t1526: o_phase = -9'd33;\t //LUT[1526] \tphase : -0.128906\t(data_i, data_q): (0.718750,-0.312500)\n\t1527: o_phase = -9'd30;\t //LUT[1527] \tphase : -0.117188\t(data_i, data_q): (0.718750,-0.281250)\n\t1528: o_phase = -9'd27;\t //LUT[1528] \tphase : -0.105469\t(data_i, data_q): (0.718750,-0.250000)\n\t1529: o_phase = -9'd24;\t //LUT[1529] \tphase : -0.093750\t(data_i, data_q): (0.718750,-0.218750)\n\t1530: o_phase = -9'd21;\t //LUT[1530] \tphase : -0.082031\t(data_i, data_q): (0.718750,-0.187500)\n\t1531: o_phase = -9'd17;\t //LUT[1531] \tphase : -0.066406\t(data_i, data_q): (0.718750,-0.156250)\n\t1532: o_phase = -9'd14;\t //LUT[1532] \tphase : -0.054688\t(data_i, data_q): (0.718750,-0.125000)\n\t1533: o_phase = -9'd11;\t //LUT[1533] \tphase : -0.042969\t(data_i, data_q): (0.718750,-0.093750)\n\t1534: o_phase = -9'd7;\t //LUT[1534] \tphase : -0.027344\t(data_i, data_q): (0.718750,-0.062500)\n\t1535: o_phase = -9'd4;\t //LUT[1535] \tphase : -0.015625\t(data_i, data_q): (0.718750,-0.031250)\n\t1536: o_phase = +9'd0;\t //LUT[1536] \tphase : 0.000000\t(data_i, data_q): (0.750000,0.000000)\n\t1537: o_phase = +9'd3;\t //LUT[1537] \tphase : 0.011719\t(data_i, data_q): (0.750000,0.031250)\n\t1538: o_phase = +9'd7;\t //LUT[1538] \tphase : 0.027344\t(data_i, data_q): (0.750000,0.062500)\n\t1539: o_phase = +9'd10;\t //LUT[1539] \tphase : 0.039062\t(data_i, data_q): (0.750000,0.093750)\n\t1540: o_phase = +9'd13;\t //LUT[1540] \tphase : 0.050781\t(data_i, data_q): (0.750000,0.125000)\n\t1541: o_phase = +9'd17;\t //LUT[1541] \tphase : 0.066406\t(data_i, data_q): (0.750000,0.156250)\n\t1542: o_phase = +9'd20;\t //LUT[1542] \tphase : 0.078125\t(data_i, data_q): (0.750000,0.187500)\n\t1543: o_phase = +9'd23;\t //LUT[1543] \tphase : 0.089844\t(data_i, data_q): (0.750000,0.218750)\n\t1544: o_phase = +9'd26;\t //LUT[1544] \tphase : 0.101562\t(data_i, data_q): (0.750000,0.250000)\n\t1545: o_phase = +9'd29;\t //LUT[1545] \tphase : 0.113281\t(data_i, data_q): (0.750000,0.281250)\n\t1546: o_phase = +9'd32;\t //LUT[1546] \tphase : 0.125000\t(data_i, data_q): (0.750000,0.312500)\n\t1547: o_phase = +9'd35;\t //LUT[1547] \tphase : 0.136719\t(data_i, data_q): (0.750000,0.343750)\n\t1548: o_phase = +9'd38;\t //LUT[1548] \tphase : 0.148438\t(data_i, data_q): (0.750000,0.375000)\n\t1549: o_phase = +9'd40;\t //LUT[1549] \tphase : 0.156250\t(data_i, data_q): (0.750000,0.406250)\n\t1550: o_phase = +9'd43;\t //LUT[1550] \tphase : 0.167969\t(data_i, data_q): (0.750000,0.437500)\n\t1551: o_phase = +9'd46;\t //LUT[1551] \tphase : 0.179688\t(data_i, data_q): (0.750000,0.468750)\n\t1552: o_phase = +9'd48;\t //LUT[1552] \tphase : 0.187500\t(data_i, data_q): (0.750000,0.500000)\n\t1553: o_phase = +9'd50;\t //LUT[1553] \tphase : 0.195312\t(data_i, data_q): (0.750000,0.531250)\n\t1554: o_phase = +9'd52;\t //LUT[1554] \tphase : 0.203125\t(data_i, data_q): (0.750000,0.562500)\n\t1555: o_phase = +9'd55;\t //LUT[1555] \tphase : 0.214844\t(data_i, data_q): (0.750000,0.593750)\n\t1556: o_phase = +9'd57;\t //LUT[1556] \tphase : 0.222656\t(data_i, data_q): (0.750000,0.625000)\n\t1557: o_phase = +9'd59;\t //LUT[1557] \tphase : 0.230469\t(data_i, data_q): (0.750000,0.656250)\n\t1558: o_phase = +9'd60;\t //LUT[1558] \tphase : 0.234375\t(data_i, data_q): (0.750000,0.687500)\n\t1559: o_phase = +9'd62;\t //LUT[1559] \tphase : 0.242188\t(data_i, data_q): (0.750000,0.718750)\n\t1560: o_phase = +9'd64;\t //LUT[1560] \tphase : 0.250000\t(data_i, data_q): (0.750000,0.750000)\n\t1561: o_phase = +9'd66;\t //LUT[1561] \tphase : 0.257812\t(data_i, data_q): (0.750000,0.781250)\n\t1562: o_phase = +9'd67;\t //LUT[1562] \tphase : 0.261719\t(data_i, data_q): (0.750000,0.812500)\n\t1563: o_phase = +9'd69;\t //LUT[1563] \tphase : 0.269531\t(data_i, data_q): (0.750000,0.843750)\n\t1564: o_phase = +9'd70;\t //LUT[1564] \tphase : 0.273438\t(data_i, data_q): (0.750000,0.875000)\n\t1565: o_phase = +9'd72;\t //LUT[1565] \tphase : 0.281250\t(data_i, data_q): (0.750000,0.906250)\n\t1566: o_phase = +9'd73;\t //LUT[1566] \tphase : 0.285156\t(data_i, data_q): (0.750000,0.937500)\n\t1567: o_phase = +9'd74;\t //LUT[1567] \tphase : 0.289062\t(data_i, data_q): (0.750000,0.968750)\n\t1568: o_phase = -9'd76;\t //LUT[1568] \tphase : -0.296875\t(data_i, data_q): (0.750000,-1.000000)\n\t1569: o_phase = -9'd74;\t //LUT[1569] \tphase : -0.289062\t(data_i, data_q): (0.750000,-0.968750)\n\t1570: o_phase = -9'd73;\t //LUT[1570] \tphase : -0.285156\t(data_i, data_q): (0.750000,-0.937500)\n\t1571: o_phase = -9'd72;\t //LUT[1571] \tphase : -0.281250\t(data_i, data_q): (0.750000,-0.906250)\n\t1572: o_phase = -9'd70;\t //LUT[1572] \tphase : -0.273438\t(data_i, data_q): (0.750000,-0.875000)\n\t1573: o_phase = -9'd69;\t //LUT[1573] \tphase : -0.269531\t(data_i, data_q): (0.750000,-0.843750)\n\t1574: o_phase = -9'd67;\t //LUT[1574] \tphase : -0.261719\t(data_i, data_q): (0.750000,-0.812500)\n\t1575: o_phase = -9'd66;\t //LUT[1575] \tphase : -0.257812\t(data_i, data_q): (0.750000,-0.781250)\n\t1576: o_phase = -9'd64;\t //LUT[1576] \tphase : -0.250000\t(data_i, data_q): (0.750000,-0.750000)\n\t1577: o_phase = -9'd62;\t //LUT[1577] \tphase : -0.242188\t(data_i, data_q): (0.750000,-0.718750)\n\t1578: o_phase = -9'd60;\t //LUT[1578] \tphase : -0.234375\t(data_i, data_q): (0.750000,-0.687500)\n\t1579: o_phase = -9'd59;\t //LUT[1579] \tphase : -0.230469\t(data_i, data_q): (0.750000,-0.656250)\n\t1580: o_phase = -9'd57;\t //LUT[1580] \tphase : -0.222656\t(data_i, data_q): (0.750000,-0.625000)\n\t1581: o_phase = -9'd55;\t //LUT[1581] \tphase : -0.214844\t(data_i, data_q): (0.750000,-0.593750)\n\t1582: o_phase = -9'd52;\t //LUT[1582] \tphase : -0.203125\t(data_i, data_q): (0.750000,-0.562500)\n\t1583: o_phase = -9'd50;\t //LUT[1583] \tphase : -0.195312\t(data_i, data_q): (0.750000,-0.531250)\n\t1584: o_phase = -9'd48;\t //LUT[1584] \tphase : -0.187500\t(data_i, data_q): (0.750000,-0.500000)\n\t1585: o_phase = -9'd46;\t //LUT[1585] \tphase : -0.179688\t(data_i, data_q): (0.750000,-0.468750)\n\t1586: o_phase = -9'd43;\t //LUT[1586] \tphase : -0.167969\t(data_i, data_q): (0.750000,-0.437500)\n\t1587: o_phase = -9'd40;\t //LUT[1587] \tphase : -0.156250\t(data_i, data_q): (0.750000,-0.406250)\n\t1588: o_phase = -9'd38;\t //LUT[1588] \tphase : -0.148438\t(data_i, data_q): (0.750000,-0.375000)\n\t1589: o_phase = -9'd35;\t //LUT[1589] \tphase : -0.136719\t(data_i, data_q): (0.750000,-0.343750)\n\t1590: o_phase = -9'd32;\t //LUT[1590] \tphase : -0.125000\t(data_i, data_q): (0.750000,-0.312500)\n\t1591: o_phase = -9'd29;\t //LUT[1591] \tphase : -0.113281\t(data_i, data_q): (0.750000,-0.281250)\n\t1592: o_phase = -9'd26;\t //LUT[1592] \tphase : -0.101562\t(data_i, data_q): (0.750000,-0.250000)\n\t1593: o_phase = -9'd23;\t //LUT[1593] \tphase : -0.089844\t(data_i, data_q): (0.750000,-0.218750)\n\t1594: o_phase = -9'd20;\t //LUT[1594] \tphase : -0.078125\t(data_i, data_q): (0.750000,-0.187500)\n\t1595: o_phase = -9'd17;\t //LUT[1595] \tphase : -0.066406\t(data_i, data_q): (0.750000,-0.156250)\n\t1596: o_phase = -9'd13;\t //LUT[1596] \tphase : -0.050781\t(data_i, data_q): (0.750000,-0.125000)\n\t1597: o_phase = -9'd10;\t //LUT[1597] \tphase : -0.039062\t(data_i, data_q): (0.750000,-0.093750)\n\t1598: o_phase = -9'd7;\t //LUT[1598] \tphase : -0.027344\t(data_i, data_q): (0.750000,-0.062500)\n\t1599: o_phase = -9'd3;\t //LUT[1599] \tphase : -0.011719\t(data_i, data_q): (0.750000,-0.031250)\n\t1600: o_phase = +9'd0;\t //LUT[1600] \tphase : 0.000000\t(data_i, data_q): (0.781250,0.000000)\n\t1601: o_phase = +9'd3;\t //LUT[1601] \tphase : 0.011719\t(data_i, data_q): (0.781250,0.031250)\n\t1602: o_phase = +9'd7;\t //LUT[1602] \tphase : 0.027344\t(data_i, data_q): (0.781250,0.062500)\n\t1603: o_phase = +9'd10;\t //LUT[1603] \tphase : 0.039062\t(data_i, data_q): (0.781250,0.093750)\n\t1604: o_phase = +9'd13;\t //LUT[1604] \tphase : 0.050781\t(data_i, data_q): (0.781250,0.125000)\n\t1605: o_phase = +9'd16;\t //LUT[1605] \tphase : 0.062500\t(data_i, data_q): (0.781250,0.156250)\n\t1606: o_phase = +9'd19;\t //LUT[1606] \tphase : 0.074219\t(data_i, data_q): (0.781250,0.187500)\n\t1607: o_phase = +9'd22;\t //LUT[1607] \tphase : 0.085938\t(data_i, data_q): (0.781250,0.218750)\n\t1608: o_phase = +9'd25;\t //LUT[1608] \tphase : 0.097656\t(data_i, data_q): (0.781250,0.250000)\n\t1609: o_phase = +9'd28;\t //LUT[1609] \tphase : 0.109375\t(data_i, data_q): (0.781250,0.281250)\n\t1610: o_phase = +9'd31;\t //LUT[1610] \tphase : 0.121094\t(data_i, data_q): (0.781250,0.312500)\n\t1611: o_phase = +9'd34;\t //LUT[1611] \tphase : 0.132812\t(data_i, data_q): (0.781250,0.343750)\n\t1612: o_phase = +9'd36;\t //LUT[1612] \tphase : 0.140625\t(data_i, data_q): (0.781250,0.375000)\n\t1613: o_phase = +9'd39;\t //LUT[1613] \tphase : 0.152344\t(data_i, data_q): (0.781250,0.406250)\n\t1614: o_phase = +9'd42;\t //LUT[1614] \tphase : 0.164062\t(data_i, data_q): (0.781250,0.437500)\n\t1615: o_phase = +9'd44;\t //LUT[1615] \tphase : 0.171875\t(data_i, data_q): (0.781250,0.468750)\n\t1616: o_phase = +9'd46;\t //LUT[1616] \tphase : 0.179688\t(data_i, data_q): (0.781250,0.500000)\n\t1617: o_phase = +9'd49;\t //LUT[1617] \tphase : 0.191406\t(data_i, data_q): (0.781250,0.531250)\n\t1618: o_phase = +9'd51;\t //LUT[1618] \tphase : 0.199219\t(data_i, data_q): (0.781250,0.562500)\n\t1619: o_phase = +9'd53;\t //LUT[1619] \tphase : 0.207031\t(data_i, data_q): (0.781250,0.593750)\n\t1620: o_phase = +9'd55;\t //LUT[1620] \tphase : 0.214844\t(data_i, data_q): (0.781250,0.625000)\n\t1621: o_phase = +9'd57;\t //LUT[1621] \tphase : 0.222656\t(data_i, data_q): (0.781250,0.656250)\n\t1622: o_phase = +9'd59;\t //LUT[1622] \tphase : 0.230469\t(data_i, data_q): (0.781250,0.687500)\n\t1623: o_phase = +9'd61;\t //LUT[1623] \tphase : 0.238281\t(data_i, data_q): (0.781250,0.718750)\n\t1624: o_phase = +9'd62;\t //LUT[1624] \tphase : 0.242188\t(data_i, data_q): (0.781250,0.750000)\n\t1625: o_phase = +9'd64;\t //LUT[1625] \tphase : 0.250000\t(data_i, data_q): (0.781250,0.781250)\n\t1626: o_phase = +9'd66;\t //LUT[1626] \tphase : 0.257812\t(data_i, data_q): (0.781250,0.812500)\n\t1627: o_phase = +9'd67;\t //LUT[1627] \tphase : 0.261719\t(data_i, data_q): (0.781250,0.843750)\n\t1628: o_phase = +9'd69;\t //LUT[1628] \tphase : 0.269531\t(data_i, data_q): (0.781250,0.875000)\n\t1629: o_phase = +9'd70;\t //LUT[1629] \tphase : 0.273438\t(data_i, data_q): (0.781250,0.906250)\n\t1630: o_phase = +9'd71;\t //LUT[1630] \tphase : 0.277344\t(data_i, data_q): (0.781250,0.937500)\n\t1631: o_phase = +9'd73;\t //LUT[1631] \tphase : 0.285156\t(data_i, data_q): (0.781250,0.968750)\n\t1632: o_phase = -9'd74;\t //LUT[1632] \tphase : -0.289062\t(data_i, data_q): (0.781250,-1.000000)\n\t1633: o_phase = -9'd73;\t //LUT[1633] \tphase : -0.285156\t(data_i, data_q): (0.781250,-0.968750)\n\t1634: o_phase = -9'd71;\t //LUT[1634] \tphase : -0.277344\t(data_i, data_q): (0.781250,-0.937500)\n\t1635: o_phase = -9'd70;\t //LUT[1635] \tphase : -0.273438\t(data_i, data_q): (0.781250,-0.906250)\n\t1636: o_phase = -9'd69;\t //LUT[1636] \tphase : -0.269531\t(data_i, data_q): (0.781250,-0.875000)\n\t1637: o_phase = -9'd67;\t //LUT[1637] \tphase : -0.261719\t(data_i, data_q): (0.781250,-0.843750)\n\t1638: o_phase = -9'd66;\t //LUT[1638] \tphase : -0.257812\t(data_i, data_q): (0.781250,-0.812500)\n\t1639: o_phase = -9'd64;\t //LUT[1639] \tphase : -0.250000\t(data_i, data_q): (0.781250,-0.781250)\n\t1640: o_phase = -9'd62;\t //LUT[1640] \tphase : -0.242188\t(data_i, data_q): (0.781250,-0.750000)\n\t1641: o_phase = -9'd61;\t //LUT[1641] \tphase : -0.238281\t(data_i, data_q): (0.781250,-0.718750)\n\t1642: o_phase = -9'd59;\t //LUT[1642] \tphase : -0.230469\t(data_i, data_q): (0.781250,-0.687500)\n\t1643: o_phase = -9'd57;\t //LUT[1643] \tphase : -0.222656\t(data_i, data_q): (0.781250,-0.656250)\n\t1644: o_phase = -9'd55;\t //LUT[1644] \tphase : -0.214844\t(data_i, data_q): (0.781250,-0.625000)\n\t1645: o_phase = -9'd53;\t //LUT[1645] \tphase : -0.207031\t(data_i, data_q): (0.781250,-0.593750)\n\t1646: o_phase = -9'd51;\t //LUT[1646] \tphase : -0.199219\t(data_i, data_q): (0.781250,-0.562500)\n\t1647: o_phase = -9'd49;\t //LUT[1647] \tphase : -0.191406\t(data_i, data_q): (0.781250,-0.531250)\n\t1648: o_phase = -9'd46;\t //LUT[1648] \tphase : -0.179688\t(data_i, data_q): (0.781250,-0.500000)\n\t1649: o_phase = -9'd44;\t //LUT[1649] \tphase : -0.171875\t(data_i, data_q): (0.781250,-0.468750)\n\t1650: o_phase = -9'd42;\t //LUT[1650] \tphase : -0.164062\t(data_i, data_q): (0.781250,-0.437500)\n\t1651: o_phase = -9'd39;\t //LUT[1651] \tphase : -0.152344\t(data_i, data_q): (0.781250,-0.406250)\n\t1652: o_phase = -9'd36;\t //LUT[1652] \tphase : -0.140625\t(data_i, data_q): (0.781250,-0.375000)\n\t1653: o_phase = -9'd34;\t //LUT[1653] \tphase : -0.132812\t(data_i, data_q): (0.781250,-0.343750)\n\t1654: o_phase = -9'd31;\t //LUT[1654] \tphase : -0.121094\t(data_i, data_q): (0.781250,-0.312500)\n\t1655: o_phase = -9'd28;\t //LUT[1655] \tphase : -0.109375\t(data_i, data_q): (0.781250,-0.281250)\n\t1656: o_phase = -9'd25;\t //LUT[1656] \tphase : -0.097656\t(data_i, data_q): (0.781250,-0.250000)\n\t1657: o_phase = -9'd22;\t //LUT[1657] \tphase : -0.085938\t(data_i, data_q): (0.781250,-0.218750)\n\t1658: o_phase = -9'd19;\t //LUT[1658] \tphase : -0.074219\t(data_i, data_q): (0.781250,-0.187500)\n\t1659: o_phase = -9'd16;\t //LUT[1659] \tphase : -0.062500\t(data_i, data_q): (0.781250,-0.156250)\n\t1660: o_phase = -9'd13;\t //LUT[1660] \tphase : -0.050781\t(data_i, data_q): (0.781250,-0.125000)\n\t1661: o_phase = -9'd10;\t //LUT[1661] \tphase : -0.039062\t(data_i, data_q): (0.781250,-0.093750)\n\t1662: o_phase = -9'd7;\t //LUT[1662] \tphase : -0.027344\t(data_i, data_q): (0.781250,-0.062500)\n\t1663: o_phase = -9'd3;\t //LUT[1663] \tphase : -0.011719\t(data_i, data_q): (0.781250,-0.031250)\n\t1664: o_phase = +9'd0;\t //LUT[1664] \tphase : 0.000000\t(data_i, data_q): (0.812500,0.000000)\n\t1665: o_phase = +9'd3;\t //LUT[1665] \tphase : 0.011719\t(data_i, data_q): (0.812500,0.031250)\n\t1666: o_phase = +9'd6;\t //LUT[1666] \tphase : 0.023438\t(data_i, data_q): (0.812500,0.062500)\n\t1667: o_phase = +9'd9;\t //LUT[1667] \tphase : 0.035156\t(data_i, data_q): (0.812500,0.093750)\n\t1668: o_phase = +9'd12;\t //LUT[1668] \tphase : 0.046875\t(data_i, data_q): (0.812500,0.125000)\n\t1669: o_phase = +9'd15;\t //LUT[1669] \tphase : 0.058594\t(data_i, data_q): (0.812500,0.156250)\n\t1670: o_phase = +9'd18;\t //LUT[1670] \tphase : 0.070312\t(data_i, data_q): (0.812500,0.187500)\n\t1671: o_phase = +9'd21;\t //LUT[1671] \tphase : 0.082031\t(data_i, data_q): (0.812500,0.218750)\n\t1672: o_phase = +9'd24;\t //LUT[1672] \tphase : 0.093750\t(data_i, data_q): (0.812500,0.250000)\n\t1673: o_phase = +9'd27;\t //LUT[1673] \tphase : 0.105469\t(data_i, data_q): (0.812500,0.281250)\n\t1674: o_phase = +9'd30;\t //LUT[1674] \tphase : 0.117188\t(data_i, data_q): (0.812500,0.312500)\n\t1675: o_phase = +9'd33;\t //LUT[1675] \tphase : 0.128906\t(data_i, data_q): (0.812500,0.343750)\n\t1676: o_phase = +9'd35;\t //LUT[1676] \tphase : 0.136719\t(data_i, data_q): (0.812500,0.375000)\n\t1677: o_phase = +9'd38;\t //LUT[1677] \tphase : 0.148438\t(data_i, data_q): (0.812500,0.406250)\n\t1678: o_phase = +9'd40;\t //LUT[1678] \tphase : 0.156250\t(data_i, data_q): (0.812500,0.437500)\n\t1679: o_phase = +9'd43;\t //LUT[1679] \tphase : 0.167969\t(data_i, data_q): (0.812500,0.468750)\n\t1680: o_phase = +9'd45;\t //LUT[1680] \tphase : 0.175781\t(data_i, data_q): (0.812500,0.500000)\n\t1681: o_phase = +9'd47;\t //LUT[1681] \tphase : 0.183594\t(data_i, data_q): (0.812500,0.531250)\n\t1682: o_phase = +9'd49;\t //LUT[1682] \tphase : 0.191406\t(data_i, data_q): (0.812500,0.562500)\n\t1683: o_phase = +9'd51;\t //LUT[1683] \tphase : 0.199219\t(data_i, data_q): (0.812500,0.593750)\n\t1684: o_phase = +9'd53;\t //LUT[1684] \tphase : 0.207031\t(data_i, data_q): (0.812500,0.625000)\n\t1685: o_phase = +9'd55;\t //LUT[1685] \tphase : 0.214844\t(data_i, data_q): (0.812500,0.656250)\n\t1686: o_phase = +9'd57;\t //LUT[1686] \tphase : 0.222656\t(data_i, data_q): (0.812500,0.687500)\n\t1687: o_phase = +9'd59;\t //LUT[1687] \tphase : 0.230469\t(data_i, data_q): (0.812500,0.718750)\n\t1688: o_phase = +9'd61;\t //LUT[1688] \tphase : 0.238281\t(data_i, data_q): (0.812500,0.750000)\n\t1689: o_phase = +9'd62;\t //LUT[1689] \tphase : 0.242188\t(data_i, data_q): (0.812500,0.781250)\n\t1690: o_phase = +9'd64;\t //LUT[1690] \tphase : 0.250000\t(data_i, data_q): (0.812500,0.812500)\n\t1691: o_phase = +9'd66;\t //LUT[1691] \tphase : 0.257812\t(data_i, data_q): (0.812500,0.843750)\n\t1692: o_phase = +9'd67;\t //LUT[1692] \tphase : 0.261719\t(data_i, data_q): (0.812500,0.875000)\n\t1693: o_phase = +9'd68;\t //LUT[1693] \tphase : 0.265625\t(data_i, data_q): (0.812500,0.906250)\n\t1694: o_phase = +9'd70;\t //LUT[1694] \tphase : 0.273438\t(data_i, data_q): (0.812500,0.937500)\n\t1695: o_phase = +9'd71;\t //LUT[1695] \tphase : 0.277344\t(data_i, data_q): (0.812500,0.968750)\n\t1696: o_phase = -9'd72;\t //LUT[1696] \tphase : -0.281250\t(data_i, data_q): (0.812500,-1.000000)\n\t1697: o_phase = -9'd71;\t //LUT[1697] \tphase : -0.277344\t(data_i, data_q): (0.812500,-0.968750)\n\t1698: o_phase = -9'd70;\t //LUT[1698] \tphase : -0.273438\t(data_i, data_q): (0.812500,-0.937500)\n\t1699: o_phase = -9'd68;\t //LUT[1699] \tphase : -0.265625\t(data_i, data_q): (0.812500,-0.906250)\n\t1700: o_phase = -9'd67;\t //LUT[1700] \tphase : -0.261719\t(data_i, data_q): (0.812500,-0.875000)\n\t1701: o_phase = -9'd66;\t //LUT[1701] \tphase : -0.257812\t(data_i, data_q): (0.812500,-0.843750)\n\t1702: o_phase = -9'd64;\t //LUT[1702] \tphase : -0.250000\t(data_i, data_q): (0.812500,-0.812500)\n\t1703: o_phase = -9'd62;\t //LUT[1703] \tphase : -0.242188\t(data_i, data_q): (0.812500,-0.781250)\n\t1704: o_phase = -9'd61;\t //LUT[1704] \tphase : -0.238281\t(data_i, data_q): (0.812500,-0.750000)\n\t1705: o_phase = -9'd59;\t //LUT[1705] \tphase : -0.230469\t(data_i, data_q): (0.812500,-0.718750)\n\t1706: o_phase = -9'd57;\t //LUT[1706] \tphase : -0.222656\t(data_i, data_q): (0.812500,-0.687500)\n\t1707: o_phase = -9'd55;\t //LUT[1707] \tphase : -0.214844\t(data_i, data_q): (0.812500,-0.656250)\n\t1708: o_phase = -9'd53;\t //LUT[1708] \tphase : -0.207031\t(data_i, data_q): (0.812500,-0.625000)\n\t1709: o_phase = -9'd51;\t //LUT[1709] \tphase : -0.199219\t(data_i, data_q): (0.812500,-0.593750)\n\t1710: o_phase = -9'd49;\t //LUT[1710] \tphase : -0.191406\t(data_i, data_q): (0.812500,-0.562500)\n\t1711: o_phase = -9'd47;\t //LUT[1711] \tphase : -0.183594\t(data_i, data_q): (0.812500,-0.531250)\n\t1712: o_phase = -9'd45;\t //LUT[1712] \tphase : -0.175781\t(data_i, data_q): (0.812500,-0.500000)\n\t1713: o_phase = -9'd43;\t //LUT[1713] \tphase : -0.167969\t(data_i, data_q): (0.812500,-0.468750)\n\t1714: o_phase = -9'd40;\t //LUT[1714] \tphase : -0.156250\t(data_i, data_q): (0.812500,-0.437500)\n\t1715: o_phase = -9'd38;\t //LUT[1715] \tphase : -0.148438\t(data_i, data_q): (0.812500,-0.406250)\n\t1716: o_phase = -9'd35;\t //LUT[1716] \tphase : -0.136719\t(data_i, data_q): (0.812500,-0.375000)\n\t1717: o_phase = -9'd33;\t //LUT[1717] \tphase : -0.128906\t(data_i, data_q): (0.812500,-0.343750)\n\t1718: o_phase = -9'd30;\t //LUT[1718] \tphase : -0.117188\t(data_i, data_q): (0.812500,-0.312500)\n\t1719: o_phase = -9'd27;\t //LUT[1719] \tphase : -0.105469\t(data_i, data_q): (0.812500,-0.281250)\n\t1720: o_phase = -9'd24;\t //LUT[1720] \tphase : -0.093750\t(data_i, data_q): (0.812500,-0.250000)\n\t1721: o_phase = -9'd21;\t //LUT[1721] \tphase : -0.082031\t(data_i, data_q): (0.812500,-0.218750)\n\t1722: o_phase = -9'd18;\t //LUT[1722] \tphase : -0.070312\t(data_i, data_q): (0.812500,-0.187500)\n\t1723: o_phase = -9'd15;\t //LUT[1723] \tphase : -0.058594\t(data_i, data_q): (0.812500,-0.156250)\n\t1724: o_phase = -9'd12;\t //LUT[1724] \tphase : -0.046875\t(data_i, data_q): (0.812500,-0.125000)\n\t1725: o_phase = -9'd9;\t //LUT[1725] \tphase : -0.035156\t(data_i, data_q): (0.812500,-0.093750)\n\t1726: o_phase = -9'd6;\t //LUT[1726] \tphase : -0.023438\t(data_i, data_q): (0.812500,-0.062500)\n\t1727: o_phase = -9'd3;\t //LUT[1727] \tphase : -0.011719\t(data_i, data_q): (0.812500,-0.031250)\n\t1728: o_phase = +9'd0;\t //LUT[1728] \tphase : 0.000000\t(data_i, data_q): (0.843750,0.000000)\n\t1729: o_phase = +9'd3;\t //LUT[1729] \tphase : 0.011719\t(data_i, data_q): (0.843750,0.031250)\n\t1730: o_phase = +9'd6;\t //LUT[1730] \tphase : 0.023438\t(data_i, data_q): (0.843750,0.062500)\n\t1731: o_phase = +9'd9;\t //LUT[1731] \tphase : 0.035156\t(data_i, data_q): (0.843750,0.093750)\n\t1732: o_phase = +9'd12;\t //LUT[1732] \tphase : 0.046875\t(data_i, data_q): (0.843750,0.125000)\n\t1733: o_phase = +9'd15;\t //LUT[1733] \tphase : 0.058594\t(data_i, data_q): (0.843750,0.156250)\n\t1734: o_phase = +9'd18;\t //LUT[1734] \tphase : 0.070312\t(data_i, data_q): (0.843750,0.187500)\n\t1735: o_phase = +9'd21;\t //LUT[1735] \tphase : 0.082031\t(data_i, data_q): (0.843750,0.218750)\n\t1736: o_phase = +9'd23;\t //LUT[1736] \tphase : 0.089844\t(data_i, data_q): (0.843750,0.250000)\n\t1737: o_phase = +9'd26;\t //LUT[1737] \tphase : 0.101562\t(data_i, data_q): (0.843750,0.281250)\n\t1738: o_phase = +9'd29;\t //LUT[1738] \tphase : 0.113281\t(data_i, data_q): (0.843750,0.312500)\n\t1739: o_phase = +9'd32;\t //LUT[1739] \tphase : 0.125000\t(data_i, data_q): (0.843750,0.343750)\n\t1740: o_phase = +9'd34;\t //LUT[1740] \tphase : 0.132812\t(data_i, data_q): (0.843750,0.375000)\n\t1741: o_phase = +9'd37;\t //LUT[1741] \tphase : 0.144531\t(data_i, data_q): (0.843750,0.406250)\n\t1742: o_phase = +9'd39;\t //LUT[1742] \tphase : 0.152344\t(data_i, data_q): (0.843750,0.437500)\n\t1743: o_phase = +9'd41;\t //LUT[1743] \tphase : 0.160156\t(data_i, data_q): (0.843750,0.468750)\n\t1744: o_phase = +9'd44;\t //LUT[1744] \tphase : 0.171875\t(data_i, data_q): (0.843750,0.500000)\n\t1745: o_phase = +9'd46;\t //LUT[1745] \tphase : 0.179688\t(data_i, data_q): (0.843750,0.531250)\n\t1746: o_phase = +9'd48;\t //LUT[1746] \tphase : 0.187500\t(data_i, data_q): (0.843750,0.562500)\n\t1747: o_phase = +9'd50;\t //LUT[1747] \tphase : 0.195312\t(data_i, data_q): (0.843750,0.593750)\n\t1748: o_phase = +9'd52;\t //LUT[1748] \tphase : 0.203125\t(data_i, data_q): (0.843750,0.625000)\n\t1749: o_phase = +9'd54;\t //LUT[1749] \tphase : 0.210938\t(data_i, data_q): (0.843750,0.656250)\n\t1750: o_phase = +9'd56;\t //LUT[1750] \tphase : 0.218750\t(data_i, data_q): (0.843750,0.687500)\n\t1751: o_phase = +9'd57;\t //LUT[1751] \tphase : 0.222656\t(data_i, data_q): (0.843750,0.718750)\n\t1752: o_phase = +9'd59;\t //LUT[1752] \tphase : 0.230469\t(data_i, data_q): (0.843750,0.750000)\n\t1753: o_phase = +9'd61;\t //LUT[1753] \tphase : 0.238281\t(data_i, data_q): (0.843750,0.781250)\n\t1754: o_phase = +9'd62;\t //LUT[1754] \tphase : 0.242188\t(data_i, data_q): (0.843750,0.812500)\n\t1755: o_phase = +9'd64;\t //LUT[1755] \tphase : 0.250000\t(data_i, data_q): (0.843750,0.843750)\n\t1756: o_phase = +9'd65;\t //LUT[1756] \tphase : 0.253906\t(data_i, data_q): (0.843750,0.875000)\n\t1757: o_phase = +9'd67;\t //LUT[1757] \tphase : 0.261719\t(data_i, data_q): (0.843750,0.906250)\n\t1758: o_phase = +9'd68;\t //LUT[1758] \tphase : 0.265625\t(data_i, data_q): (0.843750,0.937500)\n\t1759: o_phase = +9'd70;\t //LUT[1759] \tphase : 0.273438\t(data_i, data_q): (0.843750,0.968750)\n\t1760: o_phase = -9'd71;\t //LUT[1760] \tphase : -0.277344\t(data_i, data_q): (0.843750,-1.000000)\n\t1761: o_phase = -9'd70;\t //LUT[1761] \tphase : -0.273438\t(data_i, data_q): (0.843750,-0.968750)\n\t1762: o_phase = -9'd68;\t //LUT[1762] \tphase : -0.265625\t(data_i, data_q): (0.843750,-0.937500)\n\t1763: o_phase = -9'd67;\t //LUT[1763] \tphase : -0.261719\t(data_i, data_q): (0.843750,-0.906250)\n\t1764: o_phase = -9'd65;\t //LUT[1764] \tphase : -0.253906\t(data_i, data_q): (0.843750,-0.875000)\n\t1765: o_phase = -9'd64;\t //LUT[1765] \tphase : -0.250000\t(data_i, data_q): (0.843750,-0.843750)\n\t1766: o_phase = -9'd62;\t //LUT[1766] \tphase : -0.242188\t(data_i, data_q): (0.843750,-0.812500)\n\t1767: o_phase = -9'd61;\t //LUT[1767] \tphase : -0.238281\t(data_i, data_q): (0.843750,-0.781250)\n\t1768: o_phase = -9'd59;\t //LUT[1768] \tphase : -0.230469\t(data_i, data_q): (0.843750,-0.750000)\n\t1769: o_phase = -9'd57;\t //LUT[1769] \tphase : -0.222656\t(data_i, data_q): (0.843750,-0.718750)\n\t1770: o_phase = -9'd56;\t //LUT[1770] \tphase : -0.218750\t(data_i, data_q): (0.843750,-0.687500)\n\t1771: o_phase = -9'd54;\t //LUT[1771] \tphase : -0.210938\t(data_i, data_q): (0.843750,-0.656250)\n\t1772: o_phase = -9'd52;\t //LUT[1772] \tphase : -0.203125\t(data_i, data_q): (0.843750,-0.625000)\n\t1773: o_phase = -9'd50;\t //LUT[1773] \tphase : -0.195312\t(data_i, data_q): (0.843750,-0.593750)\n\t1774: o_phase = -9'd48;\t //LUT[1774] \tphase : -0.187500\t(data_i, data_q): (0.843750,-0.562500)\n\t1775: o_phase = -9'd46;\t //LUT[1775] \tphase : -0.179688\t(data_i, data_q): (0.843750,-0.531250)\n\t1776: o_phase = -9'd44;\t //LUT[1776] \tphase : -0.171875\t(data_i, data_q): (0.843750,-0.500000)\n\t1777: o_phase = -9'd41;\t //LUT[1777] \tphase : -0.160156\t(data_i, data_q): (0.843750,-0.468750)\n\t1778: o_phase = -9'd39;\t //LUT[1778] \tphase : -0.152344\t(data_i, data_q): (0.843750,-0.437500)\n\t1779: o_phase = -9'd37;\t //LUT[1779] \tphase : -0.144531\t(data_i, data_q): (0.843750,-0.406250)\n\t1780: o_phase = -9'd34;\t //LUT[1780] \tphase : -0.132812\t(data_i, data_q): (0.843750,-0.375000)\n\t1781: o_phase = -9'd32;\t //LUT[1781] \tphase : -0.125000\t(data_i, data_q): (0.843750,-0.343750)\n\t1782: o_phase = -9'd29;\t //LUT[1782] \tphase : -0.113281\t(data_i, data_q): (0.843750,-0.312500)\n\t1783: o_phase = -9'd26;\t //LUT[1783] \tphase : -0.101562\t(data_i, data_q): (0.843750,-0.281250)\n\t1784: o_phase = -9'd23;\t //LUT[1784] \tphase : -0.089844\t(data_i, data_q): (0.843750,-0.250000)\n\t1785: o_phase = -9'd21;\t //LUT[1785] \tphase : -0.082031\t(data_i, data_q): (0.843750,-0.218750)\n\t1786: o_phase = -9'd18;\t //LUT[1786] \tphase : -0.070312\t(data_i, data_q): (0.843750,-0.187500)\n\t1787: o_phase = -9'd15;\t //LUT[1787] \tphase : -0.058594\t(data_i, data_q): (0.843750,-0.156250)\n\t1788: o_phase = -9'd12;\t //LUT[1788] \tphase : -0.046875\t(data_i, data_q): (0.843750,-0.125000)\n\t1789: o_phase = -9'd9;\t //LUT[1789] \tphase : -0.035156\t(data_i, data_q): (0.843750,-0.093750)\n\t1790: o_phase = -9'd6;\t //LUT[1790] \tphase : -0.023438\t(data_i, data_q): (0.843750,-0.062500)\n\t1791: o_phase = -9'd3;\t //LUT[1791] \tphase : -0.011719\t(data_i, data_q): (0.843750,-0.031250)\n\t1792: o_phase = +9'd0;\t //LUT[1792] \tphase : 0.000000\t(data_i, data_q): (0.875000,0.000000)\n\t1793: o_phase = +9'd3;\t //LUT[1793] \tphase : 0.011719\t(data_i, data_q): (0.875000,0.031250)\n\t1794: o_phase = +9'd6;\t //LUT[1794] \tphase : 0.023438\t(data_i, data_q): (0.875000,0.062500)\n\t1795: o_phase = +9'd9;\t //LUT[1795] \tphase : 0.035156\t(data_i, data_q): (0.875000,0.093750)\n\t1796: o_phase = +9'd12;\t //LUT[1796] \tphase : 0.046875\t(data_i, data_q): (0.875000,0.125000)\n\t1797: o_phase = +9'd14;\t //LUT[1797] \tphase : 0.054688\t(data_i, data_q): (0.875000,0.156250)\n\t1798: o_phase = +9'd17;\t //LUT[1798] \tphase : 0.066406\t(data_i, data_q): (0.875000,0.187500)\n\t1799: o_phase = +9'd20;\t //LUT[1799] \tphase : 0.078125\t(data_i, data_q): (0.875000,0.218750)\n\t1800: o_phase = +9'd23;\t //LUT[1800] \tphase : 0.089844\t(data_i, data_q): (0.875000,0.250000)\n\t1801: o_phase = +9'd25;\t //LUT[1801] \tphase : 0.097656\t(data_i, data_q): (0.875000,0.281250)\n\t1802: o_phase = +9'd28;\t //LUT[1802] \tphase : 0.109375\t(data_i, data_q): (0.875000,0.312500)\n\t1803: o_phase = +9'd31;\t //LUT[1803] \tphase : 0.121094\t(data_i, data_q): (0.875000,0.343750)\n\t1804: o_phase = +9'd33;\t //LUT[1804] \tphase : 0.128906\t(data_i, data_q): (0.875000,0.375000)\n\t1805: o_phase = +9'd35;\t //LUT[1805] \tphase : 0.136719\t(data_i, data_q): (0.875000,0.406250)\n\t1806: o_phase = +9'd38;\t //LUT[1806] \tphase : 0.148438\t(data_i, data_q): (0.875000,0.437500)\n\t1807: o_phase = +9'd40;\t //LUT[1807] \tphase : 0.156250\t(data_i, data_q): (0.875000,0.468750)\n\t1808: o_phase = +9'd42;\t //LUT[1808] \tphase : 0.164062\t(data_i, data_q): (0.875000,0.500000)\n\t1809: o_phase = +9'd44;\t //LUT[1809] \tphase : 0.171875\t(data_i, data_q): (0.875000,0.531250)\n\t1810: o_phase = +9'd47;\t //LUT[1810] \tphase : 0.183594\t(data_i, data_q): (0.875000,0.562500)\n\t1811: o_phase = +9'd49;\t //LUT[1811] \tphase : 0.191406\t(data_i, data_q): (0.875000,0.593750)\n\t1812: o_phase = +9'd51;\t //LUT[1812] \tphase : 0.199219\t(data_i, data_q): (0.875000,0.625000)\n\t1813: o_phase = +9'd52;\t //LUT[1813] \tphase : 0.203125\t(data_i, data_q): (0.875000,0.656250)\n\t1814: o_phase = +9'd54;\t //LUT[1814] \tphase : 0.210938\t(data_i, data_q): (0.875000,0.687500)\n\t1815: o_phase = +9'd56;\t //LUT[1815] \tphase : 0.218750\t(data_i, data_q): (0.875000,0.718750)\n\t1816: o_phase = +9'd58;\t //LUT[1816] \tphase : 0.226562\t(data_i, data_q): (0.875000,0.750000)\n\t1817: o_phase = +9'd59;\t //LUT[1817] \tphase : 0.230469\t(data_i, data_q): (0.875000,0.781250)\n\t1818: o_phase = +9'd61;\t //LUT[1818] \tphase : 0.238281\t(data_i, data_q): (0.875000,0.812500)\n\t1819: o_phase = +9'd63;\t //LUT[1819] \tphase : 0.246094\t(data_i, data_q): (0.875000,0.843750)\n\t1820: o_phase = +9'd64;\t //LUT[1820] \tphase : 0.250000\t(data_i, data_q): (0.875000,0.875000)\n\t1821: o_phase = +9'd65;\t //LUT[1821] \tphase : 0.253906\t(data_i, data_q): (0.875000,0.906250)\n\t1822: o_phase = +9'd67;\t //LUT[1822] \tphase : 0.261719\t(data_i, data_q): (0.875000,0.937500)\n\t1823: o_phase = +9'd68;\t //LUT[1823] \tphase : 0.265625\t(data_i, data_q): (0.875000,0.968750)\n\t1824: o_phase = -9'd69;\t //LUT[1824] \tphase : -0.269531\t(data_i, data_q): (0.875000,-1.000000)\n\t1825: o_phase = -9'd68;\t //LUT[1825] \tphase : -0.265625\t(data_i, data_q): (0.875000,-0.968750)\n\t1826: o_phase = -9'd67;\t //LUT[1826] \tphase : -0.261719\t(data_i, data_q): (0.875000,-0.937500)\n\t1827: o_phase = -9'd65;\t //LUT[1827] \tphase : -0.253906\t(data_i, data_q): (0.875000,-0.906250)\n\t1828: o_phase = -9'd64;\t //LUT[1828] \tphase : -0.250000\t(data_i, data_q): (0.875000,-0.875000)\n\t1829: o_phase = -9'd63;\t //LUT[1829] \tphase : -0.246094\t(data_i, data_q): (0.875000,-0.843750)\n\t1830: o_phase = -9'd61;\t //LUT[1830] \tphase : -0.238281\t(data_i, data_q): (0.875000,-0.812500)\n\t1831: o_phase = -9'd59;\t //LUT[1831] \tphase : -0.230469\t(data_i, data_q): (0.875000,-0.781250)\n\t1832: o_phase = -9'd58;\t //LUT[1832] \tphase : -0.226562\t(data_i, data_q): (0.875000,-0.750000)\n\t1833: o_phase = -9'd56;\t //LUT[1833] \tphase : -0.218750\t(data_i, data_q): (0.875000,-0.718750)\n\t1834: o_phase = -9'd54;\t //LUT[1834] \tphase : -0.210938\t(data_i, data_q): (0.875000,-0.687500)\n\t1835: o_phase = -9'd52;\t //LUT[1835] \tphase : -0.203125\t(data_i, data_q): (0.875000,-0.656250)\n\t1836: o_phase = -9'd51;\t //LUT[1836] \tphase : -0.199219\t(data_i, data_q): (0.875000,-0.625000)\n\t1837: o_phase = -9'd49;\t //LUT[1837] \tphase : -0.191406\t(data_i, data_q): (0.875000,-0.593750)\n\t1838: o_phase = -9'd47;\t //LUT[1838] \tphase : -0.183594\t(data_i, data_q): (0.875000,-0.562500)\n\t1839: o_phase = -9'd44;\t //LUT[1839] \tphase : -0.171875\t(data_i, data_q): (0.875000,-0.531250)\n\t1840: o_phase = -9'd42;\t //LUT[1840] \tphase : -0.164062\t(data_i, data_q): (0.875000,-0.500000)\n\t1841: o_phase = -9'd40;\t //LUT[1841] \tphase : -0.156250\t(data_i, data_q): (0.875000,-0.468750)\n\t1842: o_phase = -9'd38;\t //LUT[1842] \tphase : -0.148438\t(data_i, data_q): (0.875000,-0.437500)\n\t1843: o_phase = -9'd35;\t //LUT[1843] \tphase : -0.136719\t(data_i, data_q): (0.875000,-0.406250)\n\t1844: o_phase = -9'd33;\t //LUT[1844] \tphase : -0.128906\t(data_i, data_q): (0.875000,-0.375000)\n\t1845: o_phase = -9'd31;\t //LUT[1845] \tphase : -0.121094\t(data_i, data_q): (0.875000,-0.343750)\n\t1846: o_phase = -9'd28;\t //LUT[1846] \tphase : -0.109375\t(data_i, data_q): (0.875000,-0.312500)\n\t1847: o_phase = -9'd25;\t //LUT[1847] \tphase : -0.097656\t(data_i, data_q): (0.875000,-0.281250)\n\t1848: o_phase = -9'd23;\t //LUT[1848] \tphase : -0.089844\t(data_i, data_q): (0.875000,-0.250000)\n\t1849: o_phase = -9'd20;\t //LUT[1849] \tphase : -0.078125\t(data_i, data_q): (0.875000,-0.218750)\n\t1850: o_phase = -9'd17;\t //LUT[1850] \tphase : -0.066406\t(data_i, data_q): (0.875000,-0.187500)\n\t1851: o_phase = -9'd14;\t //LUT[1851] \tphase : -0.054688\t(data_i, data_q): (0.875000,-0.156250)\n\t1852: o_phase = -9'd12;\t //LUT[1852] \tphase : -0.046875\t(data_i, data_q): (0.875000,-0.125000)\n\t1853: o_phase = -9'd9;\t //LUT[1853] \tphase : -0.035156\t(data_i, data_q): (0.875000,-0.093750)\n\t1854: o_phase = -9'd6;\t //LUT[1854] \tphase : -0.023438\t(data_i, data_q): (0.875000,-0.062500)\n\t1855: o_phase = -9'd3;\t //LUT[1855] \tphase : -0.011719\t(data_i, data_q): (0.875000,-0.031250)\n\t1856: o_phase = +9'd0;\t //LUT[1856] \tphase : 0.000000\t(data_i, data_q): (0.906250,0.000000)\n\t1857: o_phase = +9'd3;\t //LUT[1857] \tphase : 0.011719\t(data_i, data_q): (0.906250,0.031250)\n\t1858: o_phase = +9'd6;\t //LUT[1858] \tphase : 0.023438\t(data_i, data_q): (0.906250,0.062500)\n\t1859: o_phase = +9'd8;\t //LUT[1859] \tphase : 0.031250\t(data_i, data_q): (0.906250,0.093750)\n\t1860: o_phase = +9'd11;\t //LUT[1860] \tphase : 0.042969\t(data_i, data_q): (0.906250,0.125000)\n\t1861: o_phase = +9'd14;\t //LUT[1861] \tphase : 0.054688\t(data_i, data_q): (0.906250,0.156250)\n\t1862: o_phase = +9'd17;\t //LUT[1862] \tphase : 0.066406\t(data_i, data_q): (0.906250,0.187500)\n\t1863: o_phase = +9'd19;\t //LUT[1863] \tphase : 0.074219\t(data_i, data_q): (0.906250,0.218750)\n\t1864: o_phase = +9'd22;\t //LUT[1864] \tphase : 0.085938\t(data_i, data_q): (0.906250,0.250000)\n\t1865: o_phase = +9'd25;\t //LUT[1865] \tphase : 0.097656\t(data_i, data_q): (0.906250,0.281250)\n\t1866: o_phase = +9'd27;\t //LUT[1866] \tphase : 0.105469\t(data_i, data_q): (0.906250,0.312500)\n\t1867: o_phase = +9'd30;\t //LUT[1867] \tphase : 0.117188\t(data_i, data_q): (0.906250,0.343750)\n\t1868: o_phase = +9'd32;\t //LUT[1868] \tphase : 0.125000\t(data_i, data_q): (0.906250,0.375000)\n\t1869: o_phase = +9'd34;\t //LUT[1869] \tphase : 0.132812\t(data_i, data_q): (0.906250,0.406250)\n\t1870: o_phase = +9'd37;\t //LUT[1870] \tphase : 0.144531\t(data_i, data_q): (0.906250,0.437500)\n\t1871: o_phase = +9'd39;\t //LUT[1871] \tphase : 0.152344\t(data_i, data_q): (0.906250,0.468750)\n\t1872: o_phase = +9'd41;\t //LUT[1872] \tphase : 0.160156\t(data_i, data_q): (0.906250,0.500000)\n\t1873: o_phase = +9'd43;\t //LUT[1873] \tphase : 0.167969\t(data_i, data_q): (0.906250,0.531250)\n\t1874: o_phase = +9'd45;\t //LUT[1874] \tphase : 0.175781\t(data_i, data_q): (0.906250,0.562500)\n\t1875: o_phase = +9'd47;\t //LUT[1875] \tphase : 0.183594\t(data_i, data_q): (0.906250,0.593750)\n\t1876: o_phase = +9'd49;\t //LUT[1876] \tphase : 0.191406\t(data_i, data_q): (0.906250,0.625000)\n\t1877: o_phase = +9'd51;\t //LUT[1877] \tphase : 0.199219\t(data_i, data_q): (0.906250,0.656250)\n\t1878: o_phase = +9'd53;\t //LUT[1878] \tphase : 0.207031\t(data_i, data_q): (0.906250,0.687500)\n\t1879: o_phase = +9'd55;\t //LUT[1879] \tphase : 0.214844\t(data_i, data_q): (0.906250,0.718750)\n\t1880: o_phase = +9'd56;\t //LUT[1880] \tphase : 0.218750\t(data_i, data_q): (0.906250,0.750000)\n\t1881: o_phase = +9'd58;\t //LUT[1881] \tphase : 0.226562\t(data_i, data_q): (0.906250,0.781250)\n\t1882: o_phase = +9'd60;\t //LUT[1882] \tphase : 0.234375\t(data_i, data_q): (0.906250,0.812500)\n\t1883: o_phase = +9'd61;\t //LUT[1883] \tphase : 0.238281\t(data_i, data_q): (0.906250,0.843750)\n\t1884: o_phase = +9'd63;\t //LUT[1884] \tphase : 0.246094\t(data_i, data_q): (0.906250,0.875000)\n\t1885: o_phase = +9'd64;\t //LUT[1885] \tphase : 0.250000\t(data_i, data_q): (0.906250,0.906250)\n\t1886: o_phase = +9'd65;\t //LUT[1886] \tphase : 0.253906\t(data_i, data_q): (0.906250,0.937500)\n\t1887: o_phase = +9'd67;\t //LUT[1887] \tphase : 0.261719\t(data_i, data_q): (0.906250,0.968750)\n\t1888: o_phase = -9'd68;\t //LUT[1888] \tphase : -0.265625\t(data_i, data_q): (0.906250,-1.000000)\n\t1889: o_phase = -9'd67;\t //LUT[1889] \tphase : -0.261719\t(data_i, data_q): (0.906250,-0.968750)\n\t1890: o_phase = -9'd65;\t //LUT[1890] \tphase : -0.253906\t(data_i, data_q): (0.906250,-0.937500)\n\t1891: o_phase = -9'd64;\t //LUT[1891] \tphase : -0.250000\t(data_i, data_q): (0.906250,-0.906250)\n\t1892: o_phase = -9'd63;\t //LUT[1892] \tphase : -0.246094\t(data_i, data_q): (0.906250,-0.875000)\n\t1893: o_phase = -9'd61;\t //LUT[1893] \tphase : -0.238281\t(data_i, data_q): (0.906250,-0.843750)\n\t1894: o_phase = -9'd60;\t //LUT[1894] \tphase : -0.234375\t(data_i, data_q): (0.906250,-0.812500)\n\t1895: o_phase = -9'd58;\t //LUT[1895] \tphase : -0.226562\t(data_i, data_q): (0.906250,-0.781250)\n\t1896: o_phase = -9'd56;\t //LUT[1896] \tphase : -0.218750\t(data_i, data_q): (0.906250,-0.750000)\n\t1897: o_phase = -9'd55;\t //LUT[1897] \tphase : -0.214844\t(data_i, data_q): (0.906250,-0.718750)\n\t1898: o_phase = -9'd53;\t //LUT[1898] \tphase : -0.207031\t(data_i, data_q): (0.906250,-0.687500)\n\t1899: o_phase = -9'd51;\t //LUT[1899] \tphase : -0.199219\t(data_i, data_q): (0.906250,-0.656250)\n\t1900: o_phase = -9'd49;\t //LUT[1900] \tphase : -0.191406\t(data_i, data_q): (0.906250,-0.625000)\n\t1901: o_phase = -9'd47;\t //LUT[1901] \tphase : -0.183594\t(data_i, data_q): (0.906250,-0.593750)\n\t1902: o_phase = -9'd45;\t //LUT[1902] \tphase : -0.175781\t(data_i, data_q): (0.906250,-0.562500)\n\t1903: o_phase = -9'd43;\t //LUT[1903] \tphase : -0.167969\t(data_i, data_q): (0.906250,-0.531250)\n\t1904: o_phase = -9'd41;\t //LUT[1904] \tphase : -0.160156\t(data_i, data_q): (0.906250,-0.500000)\n\t1905: o_phase = -9'd39;\t //LUT[1905] \tphase : -0.152344\t(data_i, data_q): (0.906250,-0.468750)\n\t1906: o_phase = -9'd37;\t //LUT[1906] \tphase : -0.144531\t(data_i, data_q): (0.906250,-0.437500)\n\t1907: o_phase = -9'd34;\t //LUT[1907] \tphase : -0.132812\t(data_i, data_q): (0.906250,-0.406250)\n\t1908: o_phase = -9'd32;\t //LUT[1908] \tphase : -0.125000\t(data_i, data_q): (0.906250,-0.375000)\n\t1909: o_phase = -9'd30;\t //LUT[1909] \tphase : -0.117188\t(data_i, data_q): (0.906250,-0.343750)\n\t1910: o_phase = -9'd27;\t //LUT[1910] \tphase : -0.105469\t(data_i, data_q): (0.906250,-0.312500)\n\t1911: o_phase = -9'd25;\t //LUT[1911] \tphase : -0.097656\t(data_i, data_q): (0.906250,-0.281250)\n\t1912: o_phase = -9'd22;\t //LUT[1912] \tphase : -0.085938\t(data_i, data_q): (0.906250,-0.250000)\n\t1913: o_phase = -9'd19;\t //LUT[1913] \tphase : -0.074219\t(data_i, data_q): (0.906250,-0.218750)\n\t1914: o_phase = -9'd17;\t //LUT[1914] \tphase : -0.066406\t(data_i, data_q): (0.906250,-0.187500)\n\t1915: o_phase = -9'd14;\t //LUT[1915] \tphase : -0.054688\t(data_i, data_q): (0.906250,-0.156250)\n\t1916: o_phase = -9'd11;\t //LUT[1916] \tphase : -0.042969\t(data_i, data_q): (0.906250,-0.125000)\n\t1917: o_phase = -9'd8;\t //LUT[1917] \tphase : -0.031250\t(data_i, data_q): (0.906250,-0.093750)\n\t1918: o_phase = -9'd6;\t //LUT[1918] \tphase : -0.023438\t(data_i, data_q): (0.906250,-0.062500)\n\t1919: o_phase = -9'd3;\t //LUT[1919] \tphase : -0.011719\t(data_i, data_q): (0.906250,-0.031250)\n\t1920: o_phase = +9'd0;\t //LUT[1920] \tphase : 0.000000\t(data_i, data_q): (0.937500,0.000000)\n\t1921: o_phase = +9'd3;\t //LUT[1921] \tphase : 0.011719\t(data_i, data_q): (0.937500,0.031250)\n\t1922: o_phase = +9'd5;\t //LUT[1922] \tphase : 0.019531\t(data_i, data_q): (0.937500,0.062500)\n\t1923: o_phase = +9'd8;\t //LUT[1923] \tphase : 0.031250\t(data_i, data_q): (0.937500,0.093750)\n\t1924: o_phase = +9'd11;\t //LUT[1924] \tphase : 0.042969\t(data_i, data_q): (0.937500,0.125000)\n\t1925: o_phase = +9'd13;\t //LUT[1925] \tphase : 0.050781\t(data_i, data_q): (0.937500,0.156250)\n\t1926: o_phase = +9'd16;\t //LUT[1926] \tphase : 0.062500\t(data_i, data_q): (0.937500,0.187500)\n\t1927: o_phase = +9'd19;\t //LUT[1927] \tphase : 0.074219\t(data_i, data_q): (0.937500,0.218750)\n\t1928: o_phase = +9'd21;\t //LUT[1928] \tphase : 0.082031\t(data_i, data_q): (0.937500,0.250000)\n\t1929: o_phase = +9'd24;\t //LUT[1929] \tphase : 0.093750\t(data_i, data_q): (0.937500,0.281250)\n\t1930: o_phase = +9'd26;\t //LUT[1930] \tphase : 0.101562\t(data_i, data_q): (0.937500,0.312500)\n\t1931: o_phase = +9'd29;\t //LUT[1931] \tphase : 0.113281\t(data_i, data_q): (0.937500,0.343750)\n\t1932: o_phase = +9'd31;\t //LUT[1932] \tphase : 0.121094\t(data_i, data_q): (0.937500,0.375000)\n\t1933: o_phase = +9'd33;\t //LUT[1933] \tphase : 0.128906\t(data_i, data_q): (0.937500,0.406250)\n\t1934: o_phase = +9'd36;\t //LUT[1934] \tphase : 0.140625\t(data_i, data_q): (0.937500,0.437500)\n\t1935: o_phase = +9'd38;\t //LUT[1935] \tphase : 0.148438\t(data_i, data_q): (0.937500,0.468750)\n\t1936: o_phase = +9'd40;\t //LUT[1936] \tphase : 0.156250\t(data_i, data_q): (0.937500,0.500000)\n\t1937: o_phase = +9'd42;\t //LUT[1937] \tphase : 0.164062\t(data_i, data_q): (0.937500,0.531250)\n\t1938: o_phase = +9'd44;\t //LUT[1938] \tphase : 0.171875\t(data_i, data_q): (0.937500,0.562500)\n\t1939: o_phase = +9'd46;\t //LUT[1939] \tphase : 0.179688\t(data_i, data_q): (0.937500,0.593750)\n\t1940: o_phase = +9'd48;\t //LUT[1940] \tphase : 0.187500\t(data_i, data_q): (0.937500,0.625000)\n\t1941: o_phase = +9'd50;\t //LUT[1941] \tphase : 0.195312\t(data_i, data_q): (0.937500,0.656250)\n\t1942: o_phase = +9'd52;\t //LUT[1942] \tphase : 0.203125\t(data_i, data_q): (0.937500,0.687500)\n\t1943: o_phase = +9'd53;\t //LUT[1943] \tphase : 0.207031\t(data_i, data_q): (0.937500,0.718750)\n\t1944: o_phase = +9'd55;\t //LUT[1944] \tphase : 0.214844\t(data_i, data_q): (0.937500,0.750000)\n\t1945: o_phase = +9'd57;\t //LUT[1945] \tphase : 0.222656\t(data_i, data_q): (0.937500,0.781250)\n\t1946: o_phase = +9'd58;\t //LUT[1946] \tphase : 0.226562\t(data_i, data_q): (0.937500,0.812500)\n\t1947: o_phase = +9'd60;\t //LUT[1947] \tphase : 0.234375\t(data_i, data_q): (0.937500,0.843750)\n\t1948: o_phase = +9'd61;\t //LUT[1948] \tphase : 0.238281\t(data_i, data_q): (0.937500,0.875000)\n\t1949: o_phase = +9'd63;\t //LUT[1949] \tphase : 0.246094\t(data_i, data_q): (0.937500,0.906250)\n\t1950: o_phase = +9'd64;\t //LUT[1950] \tphase : 0.250000\t(data_i, data_q): (0.937500,0.937500)\n\t1951: o_phase = +9'd65;\t //LUT[1951] \tphase : 0.253906\t(data_i, data_q): (0.937500,0.968750)\n\t1952: o_phase = -9'd67;\t //LUT[1952] \tphase : -0.261719\t(data_i, data_q): (0.937500,-1.000000)\n\t1953: o_phase = -9'd65;\t //LUT[1953] \tphase : -0.253906\t(data_i, data_q): (0.937500,-0.968750)\n\t1954: o_phase = -9'd64;\t //LUT[1954] \tphase : -0.250000\t(data_i, data_q): (0.937500,-0.937500)\n\t1955: o_phase = -9'd63;\t //LUT[1955] \tphase : -0.246094\t(data_i, data_q): (0.937500,-0.906250)\n\t1956: o_phase = -9'd61;\t //LUT[1956] \tphase : -0.238281\t(data_i, data_q): (0.937500,-0.875000)\n\t1957: o_phase = -9'd60;\t //LUT[1957] \tphase : -0.234375\t(data_i, data_q): (0.937500,-0.843750)\n\t1958: o_phase = -9'd58;\t //LUT[1958] \tphase : -0.226562\t(data_i, data_q): (0.937500,-0.812500)\n\t1959: o_phase = -9'd57;\t //LUT[1959] \tphase : -0.222656\t(data_i, data_q): (0.937500,-0.781250)\n\t1960: o_phase = -9'd55;\t //LUT[1960] \tphase : -0.214844\t(data_i, data_q): (0.937500,-0.750000)\n\t1961: o_phase = -9'd53;\t //LUT[1961] \tphase : -0.207031\t(data_i, data_q): (0.937500,-0.718750)\n\t1962: o_phase = -9'd52;\t //LUT[1962] \tphase : -0.203125\t(data_i, data_q): (0.937500,-0.687500)\n\t1963: o_phase = -9'd50;\t //LUT[1963] \tphase : -0.195312\t(data_i, data_q): (0.937500,-0.656250)\n\t1964: o_phase = -9'd48;\t //LUT[1964] \tphase : -0.187500\t(data_i, data_q): (0.937500,-0.625000)\n\t1965: o_phase = -9'd46;\t //LUT[1965] \tphase : -0.179688\t(data_i, data_q): (0.937500,-0.593750)\n\t1966: o_phase = -9'd44;\t //LUT[1966] \tphase : -0.171875\t(data_i, data_q): (0.937500,-0.562500)\n\t1967: o_phase = -9'd42;\t //LUT[1967] \tphase : -0.164062\t(data_i, data_q): (0.937500,-0.531250)\n\t1968: o_phase = -9'd40;\t //LUT[1968] \tphase : -0.156250\t(data_i, data_q): (0.937500,-0.500000)\n\t1969: o_phase = -9'd38;\t //LUT[1969] \tphase : -0.148438\t(data_i, data_q): (0.937500,-0.468750)\n\t1970: o_phase = -9'd36;\t //LUT[1970] \tphase : -0.140625\t(data_i, data_q): (0.937500,-0.437500)\n\t1971: o_phase = -9'd33;\t //LUT[1971] \tphase : -0.128906\t(data_i, data_q): (0.937500,-0.406250)\n\t1972: o_phase = -9'd31;\t //LUT[1972] \tphase : -0.121094\t(data_i, data_q): (0.937500,-0.375000)\n\t1973: o_phase = -9'd29;\t //LUT[1973] \tphase : -0.113281\t(data_i, data_q): (0.937500,-0.343750)\n\t1974: o_phase = -9'd26;\t //LUT[1974] \tphase : -0.101562\t(data_i, data_q): (0.937500,-0.312500)\n\t1975: o_phase = -9'd24;\t //LUT[1975] \tphase : -0.093750\t(data_i, data_q): (0.937500,-0.281250)\n\t1976: o_phase = -9'd21;\t //LUT[1976] \tphase : -0.082031\t(data_i, data_q): (0.937500,-0.250000)\n\t1977: o_phase = -9'd19;\t //LUT[1977] \tphase : -0.074219\t(data_i, data_q): (0.937500,-0.218750)\n\t1978: o_phase = -9'd16;\t //LUT[1978] \tphase : -0.062500\t(data_i, data_q): (0.937500,-0.187500)\n\t1979: o_phase = -9'd13;\t //LUT[1979] \tphase : -0.050781\t(data_i, data_q): (0.937500,-0.156250)\n\t1980: o_phase = -9'd11;\t //LUT[1980] \tphase : -0.042969\t(data_i, data_q): (0.937500,-0.125000)\n\t1981: o_phase = -9'd8;\t //LUT[1981] \tphase : -0.031250\t(data_i, data_q): (0.937500,-0.093750)\n\t1982: o_phase = -9'd5;\t //LUT[1982] \tphase : -0.019531\t(data_i, data_q): (0.937500,-0.062500)\n\t1983: o_phase = -9'd3;\t //LUT[1983] \tphase : -0.011719\t(data_i, data_q): (0.937500,-0.031250)\n\t1984: o_phase = +9'd0;\t //LUT[1984] \tphase : 0.000000\t(data_i, data_q): (0.968750,0.000000)\n\t1985: o_phase = +9'd3;\t //LUT[1985] \tphase : 0.011719\t(data_i, data_q): (0.968750,0.031250)\n\t1986: o_phase = +9'd5;\t //LUT[1986] \tphase : 0.019531\t(data_i, data_q): (0.968750,0.062500)\n\t1987: o_phase = +9'd8;\t //LUT[1987] \tphase : 0.031250\t(data_i, data_q): (0.968750,0.093750)\n\t1988: o_phase = +9'd10;\t //LUT[1988] \tphase : 0.039062\t(data_i, data_q): (0.968750,0.125000)\n\t1989: o_phase = +9'd13;\t //LUT[1989] \tphase : 0.050781\t(data_i, data_q): (0.968750,0.156250)\n\t1990: o_phase = +9'd16;\t //LUT[1990] \tphase : 0.062500\t(data_i, data_q): (0.968750,0.187500)\n\t1991: o_phase = +9'd18;\t //LUT[1991] \tphase : 0.070312\t(data_i, data_q): (0.968750,0.218750)\n\t1992: o_phase = +9'd21;\t //LUT[1992] \tphase : 0.082031\t(data_i, data_q): (0.968750,0.250000)\n\t1993: o_phase = +9'd23;\t //LUT[1993] \tphase : 0.089844\t(data_i, data_q): (0.968750,0.281250)\n\t1994: o_phase = +9'd25;\t //LUT[1994] \tphase : 0.097656\t(data_i, data_q): (0.968750,0.312500)\n\t1995: o_phase = +9'd28;\t //LUT[1995] \tphase : 0.109375\t(data_i, data_q): (0.968750,0.343750)\n\t1996: o_phase = +9'd30;\t //LUT[1996] \tphase : 0.117188\t(data_i, data_q): (0.968750,0.375000)\n\t1997: o_phase = +9'd32;\t //LUT[1997] \tphase : 0.125000\t(data_i, data_q): (0.968750,0.406250)\n\t1998: o_phase = +9'd35;\t //LUT[1998] \tphase : 0.136719\t(data_i, data_q): (0.968750,0.437500)\n\t1999: o_phase = +9'd37;\t //LUT[1999] \tphase : 0.144531\t(data_i, data_q): (0.968750,0.468750)\n\t2000: o_phase = +9'd39;\t //LUT[2000] \tphase : 0.152344\t(data_i, data_q): (0.968750,0.500000)\n\t2001: o_phase = +9'd41;\t //LUT[2001] \tphase : 0.160156\t(data_i, data_q): (0.968750,0.531250)\n\t2002: o_phase = +9'd43;\t //LUT[2002] \tphase : 0.167969\t(data_i, data_q): (0.968750,0.562500)\n\t2003: o_phase = +9'd45;\t //LUT[2003] \tphase : 0.175781\t(data_i, data_q): (0.968750,0.593750)\n\t2004: o_phase = +9'd47;\t //LUT[2004] \tphase : 0.183594\t(data_i, data_q): (0.968750,0.625000)\n\t2005: o_phase = +9'd49;\t //LUT[2005] \tphase : 0.191406\t(data_i, data_q): (0.968750,0.656250)\n\t2006: o_phase = +9'd50;\t //LUT[2006] \tphase : 0.195312\t(data_i, data_q): (0.968750,0.687500)\n\t2007: o_phase = +9'd52;\t //LUT[2007] \tphase : 0.203125\t(data_i, data_q): (0.968750,0.718750)\n\t2008: o_phase = +9'd54;\t //LUT[2008] \tphase : 0.210938\t(data_i, data_q): (0.968750,0.750000)\n\t2009: o_phase = +9'd55;\t //LUT[2009] \tphase : 0.214844\t(data_i, data_q): (0.968750,0.781250)\n\t2010: o_phase = +9'd57;\t //LUT[2010] \tphase : 0.222656\t(data_i, data_q): (0.968750,0.812500)\n\t2011: o_phase = +9'd58;\t //LUT[2011] \tphase : 0.226562\t(data_i, data_q): (0.968750,0.843750)\n\t2012: o_phase = +9'd60;\t //LUT[2012] \tphase : 0.234375\t(data_i, data_q): (0.968750,0.875000)\n\t2013: o_phase = +9'd61;\t //LUT[2013] \tphase : 0.238281\t(data_i, data_q): (0.968750,0.906250)\n\t2014: o_phase = +9'd63;\t //LUT[2014] \tphase : 0.246094\t(data_i, data_q): (0.968750,0.937500)\n\t2015: o_phase = +9'd64;\t //LUT[2015] \tphase : 0.250000\t(data_i, data_q): (0.968750,0.968750)\n\t2016: o_phase = -9'd65;\t //LUT[2016] \tphase : -0.253906\t(data_i, data_q): (0.968750,-1.000000)\n\t2017: o_phase = -9'd64;\t //LUT[2017] \tphase : -0.250000\t(data_i, data_q): (0.968750,-0.968750)\n\t2018: o_phase = -9'd63;\t //LUT[2018] \tphase : -0.246094\t(data_i, data_q): (0.968750,-0.937500)\n\t2019: o_phase = -9'd61;\t //LUT[2019] \tphase : -0.238281\t(data_i, data_q): (0.968750,-0.906250)\n\t2020: o_phase = -9'd60;\t //LUT[2020] \tphase : -0.234375\t(data_i, data_q): (0.968750,-0.875000)\n\t2021: o_phase = -9'd58;\t //LUT[2021] \tphase : -0.226562\t(data_i, data_q): (0.968750,-0.843750)\n\t2022: o_phase = -9'd57;\t //LUT[2022] \tphase : -0.222656\t(data_i, data_q): (0.968750,-0.812500)\n\t2023: o_phase = -9'd55;\t //LUT[2023] \tphase : -0.214844\t(data_i, data_q): (0.968750,-0.781250)\n\t2024: o_phase = -9'd54;\t //LUT[2024] \tphase : -0.210938\t(data_i, data_q): (0.968750,-0.750000)\n\t2025: o_phase = -9'd52;\t //LUT[2025] \tphase : -0.203125\t(data_i, data_q): (0.968750,-0.718750)\n\t2026: o_phase = -9'd50;\t //LUT[2026] \tphase : -0.195312\t(data_i, data_q): (0.968750,-0.687500)\n\t2027: o_phase = -9'd49;\t //LUT[2027] \tphase : -0.191406\t(data_i, data_q): (0.968750,-0.656250)\n\t2028: o_phase = -9'd47;\t //LUT[2028] \tphase : -0.183594\t(data_i, data_q): (0.968750,-0.625000)\n\t2029: o_phase = -9'd45;\t //LUT[2029] \tphase : -0.175781\t(data_i, data_q): (0.968750,-0.593750)\n\t2030: o_phase = -9'd43;\t //LUT[2030] \tphase : -0.167969\t(data_i, data_q): (0.968750,-0.562500)\n\t2031: o_phase = -9'd41;\t //LUT[2031] \tphase : -0.160156\t(data_i, data_q): (0.968750,-0.531250)\n\t2032: o_phase = -9'd39;\t //LUT[2032] \tphase : -0.152344\t(data_i, data_q): (0.968750,-0.500000)\n\t2033: o_phase = -9'd37;\t //LUT[2033] \tphase : -0.144531\t(data_i, data_q): (0.968750,-0.468750)\n\t2034: o_phase = -9'd35;\t //LUT[2034] \tphase : -0.136719\t(data_i, data_q): (0.968750,-0.437500)\n\t2035: o_phase = -9'd32;\t //LUT[2035] \tphase : -0.125000\t(data_i, data_q): (0.968750,-0.406250)\n\t2036: o_phase = -9'd30;\t //LUT[2036] \tphase : -0.117188\t(data_i, data_q): (0.968750,-0.375000)\n\t2037: o_phase = -9'd28;\t //LUT[2037] \tphase : -0.109375\t(data_i, data_q): (0.968750,-0.343750)\n\t2038: o_phase = -9'd25;\t //LUT[2038] \tphase : -0.097656\t(data_i, data_q): (0.968750,-0.312500)\n\t2039: o_phase = -9'd23;\t //LUT[2039] \tphase : -0.089844\t(data_i, data_q): (0.968750,-0.281250)\n\t2040: o_phase = -9'd21;\t //LUT[2040] \tphase : -0.082031\t(data_i, data_q): (0.968750,-0.250000)\n\t2041: o_phase = -9'd18;\t //LUT[2041] \tphase : -0.070312\t(data_i, data_q): (0.968750,-0.218750)\n\t2042: o_phase = -9'd16;\t //LUT[2042] \tphase : -0.062500\t(data_i, data_q): (0.968750,-0.187500)\n\t2043: o_phase = -9'd13;\t //LUT[2043] \tphase : -0.050781\t(data_i, data_q): (0.968750,-0.156250)\n\t2044: o_phase = -9'd10;\t //LUT[2044] \tphase : -0.039062\t(data_i, data_q): (0.968750,-0.125000)\n\t2045: o_phase = -9'd8;\t //LUT[2045] \tphase : -0.031250\t(data_i, data_q): (0.968750,-0.093750)\n\t2046: o_phase = -9'd5;\t //LUT[2046] \tphase : -0.019531\t(data_i, data_q): (0.968750,-0.062500)\n\t2047: o_phase = -9'd3;\t //LUT[2047] \tphase : -0.011719\t(data_i, data_q): (0.968750,-0.031250)\n\t2048: o_phase = -9'd256;\t //LUT[2048] \tphase : -1.000000\t(data_i, data_q): (-1.000000,0.000000)\n\t2049: o_phase = +9'd253;\t //LUT[2049] \tphase : 0.988281\t(data_i, data_q): (-1.000000,0.031250)\n\t2050: o_phase = +9'd251;\t //LUT[2050] \tphase : 0.980469\t(data_i, data_q): (-1.000000,0.062500)\n\t2051: o_phase = +9'd248;\t //LUT[2051] \tphase : 0.968750\t(data_i, data_q): (-1.000000,0.093750)\n\t2052: o_phase = +9'd246;\t //LUT[2052] \tphase : 0.960938\t(data_i, data_q): (-1.000000,0.125000)\n\t2053: o_phase = +9'd243;\t //LUT[2053] \tphase : 0.949219\t(data_i, data_q): (-1.000000,0.156250)\n\t2054: o_phase = +9'd241;\t //LUT[2054] \tphase : 0.941406\t(data_i, data_q): (-1.000000,0.187500)\n\t2055: o_phase = +9'd238;\t //LUT[2055] \tphase : 0.929688\t(data_i, data_q): (-1.000000,0.218750)\n\t2056: o_phase = +9'd236;\t //LUT[2056] \tphase : 0.921875\t(data_i, data_q): (-1.000000,0.250000)\n\t2057: o_phase = +9'd234;\t //LUT[2057] \tphase : 0.914062\t(data_i, data_q): (-1.000000,0.281250)\n\t2058: o_phase = +9'd231;\t //LUT[2058] \tphase : 0.902344\t(data_i, data_q): (-1.000000,0.312500)\n\t2059: o_phase = +9'd229;\t //LUT[2059] \tphase : 0.894531\t(data_i, data_q): (-1.000000,0.343750)\n\t2060: o_phase = +9'd227;\t //LUT[2060] \tphase : 0.886719\t(data_i, data_q): (-1.000000,0.375000)\n\t2061: o_phase = +9'd225;\t //LUT[2061] \tphase : 0.878906\t(data_i, data_q): (-1.000000,0.406250)\n\t2062: o_phase = +9'd222;\t //LUT[2062] \tphase : 0.867188\t(data_i, data_q): (-1.000000,0.437500)\n\t2063: o_phase = +9'd220;\t //LUT[2063] \tphase : 0.859375\t(data_i, data_q): (-1.000000,0.468750)\n\t2064: o_phase = +9'd218;\t //LUT[2064] \tphase : 0.851562\t(data_i, data_q): (-1.000000,0.500000)\n\t2065: o_phase = +9'd216;\t //LUT[2065] \tphase : 0.843750\t(data_i, data_q): (-1.000000,0.531250)\n\t2066: o_phase = +9'd214;\t //LUT[2066] \tphase : 0.835938\t(data_i, data_q): (-1.000000,0.562500)\n\t2067: o_phase = +9'd212;\t //LUT[2067] \tphase : 0.828125\t(data_i, data_q): (-1.000000,0.593750)\n\t2068: o_phase = +9'd210;\t //LUT[2068] \tphase : 0.820312\t(data_i, data_q): (-1.000000,0.625000)\n\t2069: o_phase = +9'd209;\t //LUT[2069] \tphase : 0.816406\t(data_i, data_q): (-1.000000,0.656250)\n\t2070: o_phase = +9'd207;\t //LUT[2070] \tphase : 0.808594\t(data_i, data_q): (-1.000000,0.687500)\n\t2071: o_phase = +9'd205;\t //LUT[2071] \tphase : 0.800781\t(data_i, data_q): (-1.000000,0.718750)\n\t2072: o_phase = +9'd204;\t //LUT[2072] \tphase : 0.796875\t(data_i, data_q): (-1.000000,0.750000)\n\t2073: o_phase = +9'd202;\t //LUT[2073] \tphase : 0.789062\t(data_i, data_q): (-1.000000,0.781250)\n\t2074: o_phase = +9'd200;\t //LUT[2074] \tphase : 0.781250\t(data_i, data_q): (-1.000000,0.812500)\n\t2075: o_phase = +9'd199;\t //LUT[2075] \tphase : 0.777344\t(data_i, data_q): (-1.000000,0.843750)\n\t2076: o_phase = +9'd197;\t //LUT[2076] \tphase : 0.769531\t(data_i, data_q): (-1.000000,0.875000)\n\t2077: o_phase = +9'd196;\t //LUT[2077] \tphase : 0.765625\t(data_i, data_q): (-1.000000,0.906250)\n\t2078: o_phase = +9'd195;\t //LUT[2078] \tphase : 0.761719\t(data_i, data_q): (-1.000000,0.937500)\n\t2079: o_phase = +9'd193;\t //LUT[2079] \tphase : 0.753906\t(data_i, data_q): (-1.000000,0.968750)\n\t2080: o_phase = -9'd192;\t //LUT[2080] \tphase : -0.750000\t(data_i, data_q): (-1.000000,-1.000000)\n\t2081: o_phase = -9'd193;\t //LUT[2081] \tphase : -0.753906\t(data_i, data_q): (-1.000000,-0.968750)\n\t2082: o_phase = -9'd195;\t //LUT[2082] \tphase : -0.761719\t(data_i, data_q): (-1.000000,-0.937500)\n\t2083: o_phase = -9'd196;\t //LUT[2083] \tphase : -0.765625\t(data_i, data_q): (-1.000000,-0.906250)\n\t2084: o_phase = -9'd197;\t //LUT[2084] \tphase : -0.769531\t(data_i, data_q): (-1.000000,-0.875000)\n\t2085: o_phase = -9'd199;\t //LUT[2085] \tphase : -0.777344\t(data_i, data_q): (-1.000000,-0.843750)\n\t2086: o_phase = -9'd200;\t //LUT[2086] \tphase : -0.781250\t(data_i, data_q): (-1.000000,-0.812500)\n\t2087: o_phase = -9'd202;\t //LUT[2087] \tphase : -0.789062\t(data_i, data_q): (-1.000000,-0.781250)\n\t2088: o_phase = -9'd204;\t //LUT[2088] \tphase : -0.796875\t(data_i, data_q): (-1.000000,-0.750000)\n\t2089: o_phase = -9'd205;\t //LUT[2089] \tphase : -0.800781\t(data_i, data_q): (-1.000000,-0.718750)\n\t2090: o_phase = -9'd207;\t //LUT[2090] \tphase : -0.808594\t(data_i, data_q): (-1.000000,-0.687500)\n\t2091: o_phase = -9'd209;\t //LUT[2091] \tphase : -0.816406\t(data_i, data_q): (-1.000000,-0.656250)\n\t2092: o_phase = -9'd210;\t //LUT[2092] \tphase : -0.820312\t(data_i, data_q): (-1.000000,-0.625000)\n\t2093: o_phase = -9'd212;\t //LUT[2093] \tphase : -0.828125\t(data_i, data_q): (-1.000000,-0.593750)\n\t2094: o_phase = -9'd214;\t //LUT[2094] \tphase : -0.835938\t(data_i, data_q): (-1.000000,-0.562500)\n\t2095: o_phase = -9'd216;\t //LUT[2095] \tphase : -0.843750\t(data_i, data_q): (-1.000000,-0.531250)\n\t2096: o_phase = -9'd218;\t //LUT[2096] \tphase : -0.851562\t(data_i, data_q): (-1.000000,-0.500000)\n\t2097: o_phase = -9'd220;\t //LUT[2097] \tphase : -0.859375\t(data_i, data_q): (-1.000000,-0.468750)\n\t2098: o_phase = -9'd222;\t //LUT[2098] \tphase : -0.867188\t(data_i, data_q): (-1.000000,-0.437500)\n\t2099: o_phase = -9'd225;\t //LUT[2099] \tphase : -0.878906\t(data_i, data_q): (-1.000000,-0.406250)\n\t2100: o_phase = -9'd227;\t //LUT[2100] \tphase : -0.886719\t(data_i, data_q): (-1.000000,-0.375000)\n\t2101: o_phase = -9'd229;\t //LUT[2101] \tphase : -0.894531\t(data_i, data_q): (-1.000000,-0.343750)\n\t2102: o_phase = -9'd231;\t //LUT[2102] \tphase : -0.902344\t(data_i, data_q): (-1.000000,-0.312500)\n\t2103: o_phase = -9'd234;\t //LUT[2103] \tphase : -0.914062\t(data_i, data_q): (-1.000000,-0.281250)\n\t2104: o_phase = -9'd236;\t //LUT[2104] \tphase : -0.921875\t(data_i, data_q): (-1.000000,-0.250000)\n\t2105: o_phase = -9'd238;\t //LUT[2105] \tphase : -0.929688\t(data_i, data_q): (-1.000000,-0.218750)\n\t2106: o_phase = -9'd241;\t //LUT[2106] \tphase : -0.941406\t(data_i, data_q): (-1.000000,-0.187500)\n\t2107: o_phase = -9'd243;\t //LUT[2107] \tphase : -0.949219\t(data_i, data_q): (-1.000000,-0.156250)\n\t2108: o_phase = -9'd246;\t //LUT[2108] \tphase : -0.960938\t(data_i, data_q): (-1.000000,-0.125000)\n\t2109: o_phase = -9'd248;\t //LUT[2109] \tphase : -0.968750\t(data_i, data_q): (-1.000000,-0.093750)\n\t2110: o_phase = -9'd251;\t //LUT[2110] \tphase : -0.980469\t(data_i, data_q): (-1.000000,-0.062500)\n\t2111: o_phase = -9'd253;\t //LUT[2111] \tphase : -0.988281\t(data_i, data_q): (-1.000000,-0.031250)\n\t2112: o_phase = -9'd256;\t //LUT[2112] \tphase : -1.000000\t(data_i, data_q): (-0.968750,0.000000)\n\t2113: o_phase = +9'd253;\t //LUT[2113] \tphase : 0.988281\t(data_i, data_q): (-0.968750,0.031250)\n\t2114: o_phase = +9'd251;\t //LUT[2114] \tphase : 0.980469\t(data_i, data_q): (-0.968750,0.062500)\n\t2115: o_phase = +9'd248;\t //LUT[2115] \tphase : 0.968750\t(data_i, data_q): (-0.968750,0.093750)\n\t2116: o_phase = +9'd246;\t //LUT[2116] \tphase : 0.960938\t(data_i, data_q): (-0.968750,0.125000)\n\t2117: o_phase = +9'd243;\t //LUT[2117] \tphase : 0.949219\t(data_i, data_q): (-0.968750,0.156250)\n\t2118: o_phase = +9'd240;\t //LUT[2118] \tphase : 0.937500\t(data_i, data_q): (-0.968750,0.187500)\n\t2119: o_phase = +9'd238;\t //LUT[2119] \tphase : 0.929688\t(data_i, data_q): (-0.968750,0.218750)\n\t2120: o_phase = +9'd235;\t //LUT[2120] \tphase : 0.917969\t(data_i, data_q): (-0.968750,0.250000)\n\t2121: o_phase = +9'd233;\t //LUT[2121] \tphase : 0.910156\t(data_i, data_q): (-0.968750,0.281250)\n\t2122: o_phase = +9'd231;\t //LUT[2122] \tphase : 0.902344\t(data_i, data_q): (-0.968750,0.312500)\n\t2123: o_phase = +9'd228;\t //LUT[2123] \tphase : 0.890625\t(data_i, data_q): (-0.968750,0.343750)\n\t2124: o_phase = +9'd226;\t //LUT[2124] \tphase : 0.882812\t(data_i, data_q): (-0.968750,0.375000)\n\t2125: o_phase = +9'd224;\t //LUT[2125] \tphase : 0.875000\t(data_i, data_q): (-0.968750,0.406250)\n\t2126: o_phase = +9'd221;\t //LUT[2126] \tphase : 0.863281\t(data_i, data_q): (-0.968750,0.437500)\n\t2127: o_phase = +9'd219;\t //LUT[2127] \tphase : 0.855469\t(data_i, data_q): (-0.968750,0.468750)\n\t2128: o_phase = +9'd217;\t //LUT[2128] \tphase : 0.847656\t(data_i, data_q): (-0.968750,0.500000)\n\t2129: o_phase = +9'd215;\t //LUT[2129] \tphase : 0.839844\t(data_i, data_q): (-0.968750,0.531250)\n\t2130: o_phase = +9'd213;\t //LUT[2130] \tphase : 0.832031\t(data_i, data_q): (-0.968750,0.562500)\n\t2131: o_phase = +9'd211;\t //LUT[2131] \tphase : 0.824219\t(data_i, data_q): (-0.968750,0.593750)\n\t2132: o_phase = +9'd209;\t //LUT[2132] \tphase : 0.816406\t(data_i, data_q): (-0.968750,0.625000)\n\t2133: o_phase = +9'd207;\t //LUT[2133] \tphase : 0.808594\t(data_i, data_q): (-0.968750,0.656250)\n\t2134: o_phase = +9'd206;\t //LUT[2134] \tphase : 0.804688\t(data_i, data_q): (-0.968750,0.687500)\n\t2135: o_phase = +9'd204;\t //LUT[2135] \tphase : 0.796875\t(data_i, data_q): (-0.968750,0.718750)\n\t2136: o_phase = +9'd202;\t //LUT[2136] \tphase : 0.789062\t(data_i, data_q): (-0.968750,0.750000)\n\t2137: o_phase = +9'd201;\t //LUT[2137] \tphase : 0.785156\t(data_i, data_q): (-0.968750,0.781250)\n\t2138: o_phase = +9'd199;\t //LUT[2138] \tphase : 0.777344\t(data_i, data_q): (-0.968750,0.812500)\n\t2139: o_phase = +9'd198;\t //LUT[2139] \tphase : 0.773438\t(data_i, data_q): (-0.968750,0.843750)\n\t2140: o_phase = +9'd196;\t //LUT[2140] \tphase : 0.765625\t(data_i, data_q): (-0.968750,0.875000)\n\t2141: o_phase = +9'd195;\t //LUT[2141] \tphase : 0.761719\t(data_i, data_q): (-0.968750,0.906250)\n\t2142: o_phase = +9'd193;\t //LUT[2142] \tphase : 0.753906\t(data_i, data_q): (-0.968750,0.937500)\n\t2143: o_phase = +9'd192;\t //LUT[2143] \tphase : 0.750000\t(data_i, data_q): (-0.968750,0.968750)\n\t2144: o_phase = -9'd191;\t //LUT[2144] \tphase : -0.746094\t(data_i, data_q): (-0.968750,-1.000000)\n\t2145: o_phase = -9'd192;\t //LUT[2145] \tphase : -0.750000\t(data_i, data_q): (-0.968750,-0.968750)\n\t2146: o_phase = -9'd193;\t //LUT[2146] \tphase : -0.753906\t(data_i, data_q): (-0.968750,-0.937500)\n\t2147: o_phase = -9'd195;\t //LUT[2147] \tphase : -0.761719\t(data_i, data_q): (-0.968750,-0.906250)\n\t2148: o_phase = -9'd196;\t //LUT[2148] \tphase : -0.765625\t(data_i, data_q): (-0.968750,-0.875000)\n\t2149: o_phase = -9'd198;\t //LUT[2149] \tphase : -0.773438\t(data_i, data_q): (-0.968750,-0.843750)\n\t2150: o_phase = -9'd199;\t //LUT[2150] \tphase : -0.777344\t(data_i, data_q): (-0.968750,-0.812500)\n\t2151: o_phase = -9'd201;\t //LUT[2151] \tphase : -0.785156\t(data_i, data_q): (-0.968750,-0.781250)\n\t2152: o_phase = -9'd202;\t //LUT[2152] \tphase : -0.789062\t(data_i, data_q): (-0.968750,-0.750000)\n\t2153: o_phase = -9'd204;\t //LUT[2153] \tphase : -0.796875\t(data_i, data_q): (-0.968750,-0.718750)\n\t2154: o_phase = -9'd206;\t //LUT[2154] \tphase : -0.804688\t(data_i, data_q): (-0.968750,-0.687500)\n\t2155: o_phase = -9'd207;\t //LUT[2155] \tphase : -0.808594\t(data_i, data_q): (-0.968750,-0.656250)\n\t2156: o_phase = -9'd209;\t //LUT[2156] \tphase : -0.816406\t(data_i, data_q): (-0.968750,-0.625000)\n\t2157: o_phase = -9'd211;\t //LUT[2157] \tphase : -0.824219\t(data_i, data_q): (-0.968750,-0.593750)\n\t2158: o_phase = -9'd213;\t //LUT[2158] \tphase : -0.832031\t(data_i, data_q): (-0.968750,-0.562500)\n\t2159: o_phase = -9'd215;\t //LUT[2159] \tphase : -0.839844\t(data_i, data_q): (-0.968750,-0.531250)\n\t2160: o_phase = -9'd217;\t //LUT[2160] \tphase : -0.847656\t(data_i, data_q): (-0.968750,-0.500000)\n\t2161: o_phase = -9'd219;\t //LUT[2161] \tphase : -0.855469\t(data_i, data_q): (-0.968750,-0.468750)\n\t2162: o_phase = -9'd221;\t //LUT[2162] \tphase : -0.863281\t(data_i, data_q): (-0.968750,-0.437500)\n\t2163: o_phase = -9'd224;\t //LUT[2163] \tphase : -0.875000\t(data_i, data_q): (-0.968750,-0.406250)\n\t2164: o_phase = -9'd226;\t //LUT[2164] \tphase : -0.882812\t(data_i, data_q): (-0.968750,-0.375000)\n\t2165: o_phase = -9'd228;\t //LUT[2165] \tphase : -0.890625\t(data_i, data_q): (-0.968750,-0.343750)\n\t2166: o_phase = -9'd231;\t //LUT[2166] \tphase : -0.902344\t(data_i, data_q): (-0.968750,-0.312500)\n\t2167: o_phase = -9'd233;\t //LUT[2167] \tphase : -0.910156\t(data_i, data_q): (-0.968750,-0.281250)\n\t2168: o_phase = -9'd235;\t //LUT[2168] \tphase : -0.917969\t(data_i, data_q): (-0.968750,-0.250000)\n\t2169: o_phase = -9'd238;\t //LUT[2169] \tphase : -0.929688\t(data_i, data_q): (-0.968750,-0.218750)\n\t2170: o_phase = -9'd240;\t //LUT[2170] \tphase : -0.937500\t(data_i, data_q): (-0.968750,-0.187500)\n\t2171: o_phase = -9'd243;\t //LUT[2171] \tphase : -0.949219\t(data_i, data_q): (-0.968750,-0.156250)\n\t2172: o_phase = -9'd246;\t //LUT[2172] \tphase : -0.960938\t(data_i, data_q): (-0.968750,-0.125000)\n\t2173: o_phase = -9'd248;\t //LUT[2173] \tphase : -0.968750\t(data_i, data_q): (-0.968750,-0.093750)\n\t2174: o_phase = -9'd251;\t //LUT[2174] \tphase : -0.980469\t(data_i, data_q): (-0.968750,-0.062500)\n\t2175: o_phase = -9'd253;\t //LUT[2175] \tphase : -0.988281\t(data_i, data_q): (-0.968750,-0.031250)\n\t2176: o_phase = -9'd256;\t //LUT[2176] \tphase : -1.000000\t(data_i, data_q): (-0.937500,0.000000)\n\t2177: o_phase = +9'd253;\t //LUT[2177] \tphase : 0.988281\t(data_i, data_q): (-0.937500,0.031250)\n\t2178: o_phase = +9'd251;\t //LUT[2178] \tphase : 0.980469\t(data_i, data_q): (-0.937500,0.062500)\n\t2179: o_phase = +9'd248;\t //LUT[2179] \tphase : 0.968750\t(data_i, data_q): (-0.937500,0.093750)\n\t2180: o_phase = +9'd245;\t //LUT[2180] \tphase : 0.957031\t(data_i, data_q): (-0.937500,0.125000)\n\t2181: o_phase = +9'd243;\t //LUT[2181] \tphase : 0.949219\t(data_i, data_q): (-0.937500,0.156250)\n\t2182: o_phase = +9'd240;\t //LUT[2182] \tphase : 0.937500\t(data_i, data_q): (-0.937500,0.187500)\n\t2183: o_phase = +9'd237;\t //LUT[2183] \tphase : 0.925781\t(data_i, data_q): (-0.937500,0.218750)\n\t2184: o_phase = +9'd235;\t //LUT[2184] \tphase : 0.917969\t(data_i, data_q): (-0.937500,0.250000)\n\t2185: o_phase = +9'd232;\t //LUT[2185] \tphase : 0.906250\t(data_i, data_q): (-0.937500,0.281250)\n\t2186: o_phase = +9'd230;\t //LUT[2186] \tphase : 0.898438\t(data_i, data_q): (-0.937500,0.312500)\n\t2187: o_phase = +9'd227;\t //LUT[2187] \tphase : 0.886719\t(data_i, data_q): (-0.937500,0.343750)\n\t2188: o_phase = +9'd225;\t //LUT[2188] \tphase : 0.878906\t(data_i, data_q): (-0.937500,0.375000)\n\t2189: o_phase = +9'd223;\t //LUT[2189] \tphase : 0.871094\t(data_i, data_q): (-0.937500,0.406250)\n\t2190: o_phase = +9'd220;\t //LUT[2190] \tphase : 0.859375\t(data_i, data_q): (-0.937500,0.437500)\n\t2191: o_phase = +9'd218;\t //LUT[2191] \tphase : 0.851562\t(data_i, data_q): (-0.937500,0.468750)\n\t2192: o_phase = +9'd216;\t //LUT[2192] \tphase : 0.843750\t(data_i, data_q): (-0.937500,0.500000)\n\t2193: o_phase = +9'd214;\t //LUT[2193] \tphase : 0.835938\t(data_i, data_q): (-0.937500,0.531250)\n\t2194: o_phase = +9'd212;\t //LUT[2194] \tphase : 0.828125\t(data_i, data_q): (-0.937500,0.562500)\n\t2195: o_phase = +9'd210;\t //LUT[2195] \tphase : 0.820312\t(data_i, data_q): (-0.937500,0.593750)\n\t2196: o_phase = +9'd208;\t //LUT[2196] \tphase : 0.812500\t(data_i, data_q): (-0.937500,0.625000)\n\t2197: o_phase = +9'd206;\t //LUT[2197] \tphase : 0.804688\t(data_i, data_q): (-0.937500,0.656250)\n\t2198: o_phase = +9'd204;\t //LUT[2198] \tphase : 0.796875\t(data_i, data_q): (-0.937500,0.687500)\n\t2199: o_phase = +9'd203;\t //LUT[2199] \tphase : 0.792969\t(data_i, data_q): (-0.937500,0.718750)\n\t2200: o_phase = +9'd201;\t //LUT[2200] \tphase : 0.785156\t(data_i, data_q): (-0.937500,0.750000)\n\t2201: o_phase = +9'd199;\t //LUT[2201] \tphase : 0.777344\t(data_i, data_q): (-0.937500,0.781250)\n\t2202: o_phase = +9'd198;\t //LUT[2202] \tphase : 0.773438\t(data_i, data_q): (-0.937500,0.812500)\n\t2203: o_phase = +9'd196;\t //LUT[2203] \tphase : 0.765625\t(data_i, data_q): (-0.937500,0.843750)\n\t2204: o_phase = +9'd195;\t //LUT[2204] \tphase : 0.761719\t(data_i, data_q): (-0.937500,0.875000)\n\t2205: o_phase = +9'd193;\t //LUT[2205] \tphase : 0.753906\t(data_i, data_q): (-0.937500,0.906250)\n\t2206: o_phase = +9'd192;\t //LUT[2206] \tphase : 0.750000\t(data_i, data_q): (-0.937500,0.937500)\n\t2207: o_phase = +9'd191;\t //LUT[2207] \tphase : 0.746094\t(data_i, data_q): (-0.937500,0.968750)\n\t2208: o_phase = -9'd189;\t //LUT[2208] \tphase : -0.738281\t(data_i, data_q): (-0.937500,-1.000000)\n\t2209: o_phase = -9'd191;\t //LUT[2209] \tphase : -0.746094\t(data_i, data_q): (-0.937500,-0.968750)\n\t2210: o_phase = -9'd192;\t //LUT[2210] \tphase : -0.750000\t(data_i, data_q): (-0.937500,-0.937500)\n\t2211: o_phase = -9'd193;\t //LUT[2211] \tphase : -0.753906\t(data_i, data_q): (-0.937500,-0.906250)\n\t2212: o_phase = -9'd195;\t //LUT[2212] \tphase : -0.761719\t(data_i, data_q): (-0.937500,-0.875000)\n\t2213: o_phase = -9'd196;\t //LUT[2213] \tphase : -0.765625\t(data_i, data_q): (-0.937500,-0.843750)\n\t2214: o_phase = -9'd198;\t //LUT[2214] \tphase : -0.773438\t(data_i, data_q): (-0.937500,-0.812500)\n\t2215: o_phase = -9'd199;\t //LUT[2215] \tphase : -0.777344\t(data_i, data_q): (-0.937500,-0.781250)\n\t2216: o_phase = -9'd201;\t //LUT[2216] \tphase : -0.785156\t(data_i, data_q): (-0.937500,-0.750000)\n\t2217: o_phase = -9'd203;\t //LUT[2217] \tphase : -0.792969\t(data_i, data_q): (-0.937500,-0.718750)\n\t2218: o_phase = -9'd204;\t //LUT[2218] \tphase : -0.796875\t(data_i, data_q): (-0.937500,-0.687500)\n\t2219: o_phase = -9'd206;\t //LUT[2219] \tphase : -0.804688\t(data_i, data_q): (-0.937500,-0.656250)\n\t2220: o_phase = -9'd208;\t //LUT[2220] \tphase : -0.812500\t(data_i, data_q): (-0.937500,-0.625000)\n\t2221: o_phase = -9'd210;\t //LUT[2221] \tphase : -0.820312\t(data_i, data_q): (-0.937500,-0.593750)\n\t2222: o_phase = -9'd212;\t //LUT[2222] \tphase : -0.828125\t(data_i, data_q): (-0.937500,-0.562500)\n\t2223: o_phase = -9'd214;\t //LUT[2223] \tphase : -0.835938\t(data_i, data_q): (-0.937500,-0.531250)\n\t2224: o_phase = -9'd216;\t //LUT[2224] \tphase : -0.843750\t(data_i, data_q): (-0.937500,-0.500000)\n\t2225: o_phase = -9'd218;\t //LUT[2225] \tphase : -0.851562\t(data_i, data_q): (-0.937500,-0.468750)\n\t2226: o_phase = -9'd220;\t //LUT[2226] \tphase : -0.859375\t(data_i, data_q): (-0.937500,-0.437500)\n\t2227: o_phase = -9'd223;\t //LUT[2227] \tphase : -0.871094\t(data_i, data_q): (-0.937500,-0.406250)\n\t2228: o_phase = -9'd225;\t //LUT[2228] \tphase : -0.878906\t(data_i, data_q): (-0.937500,-0.375000)\n\t2229: o_phase = -9'd227;\t //LUT[2229] \tphase : -0.886719\t(data_i, data_q): (-0.937500,-0.343750)\n\t2230: o_phase = -9'd230;\t //LUT[2230] \tphase : -0.898438\t(data_i, data_q): (-0.937500,-0.312500)\n\t2231: o_phase = -9'd232;\t //LUT[2231] \tphase : -0.906250\t(data_i, data_q): (-0.937500,-0.281250)\n\t2232: o_phase = -9'd235;\t //LUT[2232] \tphase : -0.917969\t(data_i, data_q): (-0.937500,-0.250000)\n\t2233: o_phase = -9'd237;\t //LUT[2233] \tphase : -0.925781\t(data_i, data_q): (-0.937500,-0.218750)\n\t2234: o_phase = -9'd240;\t //LUT[2234] \tphase : -0.937500\t(data_i, data_q): (-0.937500,-0.187500)\n\t2235: o_phase = -9'd243;\t //LUT[2235] \tphase : -0.949219\t(data_i, data_q): (-0.937500,-0.156250)\n\t2236: o_phase = -9'd245;\t //LUT[2236] \tphase : -0.957031\t(data_i, data_q): (-0.937500,-0.125000)\n\t2237: o_phase = -9'd248;\t //LUT[2237] \tphase : -0.968750\t(data_i, data_q): (-0.937500,-0.093750)\n\t2238: o_phase = -9'd251;\t //LUT[2238] \tphase : -0.980469\t(data_i, data_q): (-0.937500,-0.062500)\n\t2239: o_phase = -9'd253;\t //LUT[2239] \tphase : -0.988281\t(data_i, data_q): (-0.937500,-0.031250)\n\t2240: o_phase = -9'd256;\t //LUT[2240] \tphase : -1.000000\t(data_i, data_q): (-0.906250,0.000000)\n\t2241: o_phase = +9'd253;\t //LUT[2241] \tphase : 0.988281\t(data_i, data_q): (-0.906250,0.031250)\n\t2242: o_phase = +9'd250;\t //LUT[2242] \tphase : 0.976562\t(data_i, data_q): (-0.906250,0.062500)\n\t2243: o_phase = +9'd248;\t //LUT[2243] \tphase : 0.968750\t(data_i, data_q): (-0.906250,0.093750)\n\t2244: o_phase = +9'd245;\t //LUT[2244] \tphase : 0.957031\t(data_i, data_q): (-0.906250,0.125000)\n\t2245: o_phase = +9'd242;\t //LUT[2245] \tphase : 0.945312\t(data_i, data_q): (-0.906250,0.156250)\n\t2246: o_phase = +9'd239;\t //LUT[2246] \tphase : 0.933594\t(data_i, data_q): (-0.906250,0.187500)\n\t2247: o_phase = +9'd237;\t //LUT[2247] \tphase : 0.925781\t(data_i, data_q): (-0.906250,0.218750)\n\t2248: o_phase = +9'd234;\t //LUT[2248] \tphase : 0.914062\t(data_i, data_q): (-0.906250,0.250000)\n\t2249: o_phase = +9'd231;\t //LUT[2249] \tphase : 0.902344\t(data_i, data_q): (-0.906250,0.281250)\n\t2250: o_phase = +9'd229;\t //LUT[2250] \tphase : 0.894531\t(data_i, data_q): (-0.906250,0.312500)\n\t2251: o_phase = +9'd226;\t //LUT[2251] \tphase : 0.882812\t(data_i, data_q): (-0.906250,0.343750)\n\t2252: o_phase = +9'd224;\t //LUT[2252] \tphase : 0.875000\t(data_i, data_q): (-0.906250,0.375000)\n\t2253: o_phase = +9'd222;\t //LUT[2253] \tphase : 0.867188\t(data_i, data_q): (-0.906250,0.406250)\n\t2254: o_phase = +9'd219;\t //LUT[2254] \tphase : 0.855469\t(data_i, data_q): (-0.906250,0.437500)\n\t2255: o_phase = +9'd217;\t //LUT[2255] \tphase : 0.847656\t(data_i, data_q): (-0.906250,0.468750)\n\t2256: o_phase = +9'd215;\t //LUT[2256] \tphase : 0.839844\t(data_i, data_q): (-0.906250,0.500000)\n\t2257: o_phase = +9'd213;\t //LUT[2257] \tphase : 0.832031\t(data_i, data_q): (-0.906250,0.531250)\n\t2258: o_phase = +9'd211;\t //LUT[2258] \tphase : 0.824219\t(data_i, data_q): (-0.906250,0.562500)\n\t2259: o_phase = +9'd209;\t //LUT[2259] \tphase : 0.816406\t(data_i, data_q): (-0.906250,0.593750)\n\t2260: o_phase = +9'd207;\t //LUT[2260] \tphase : 0.808594\t(data_i, data_q): (-0.906250,0.625000)\n\t2261: o_phase = +9'd205;\t //LUT[2261] \tphase : 0.800781\t(data_i, data_q): (-0.906250,0.656250)\n\t2262: o_phase = +9'd203;\t //LUT[2262] \tphase : 0.792969\t(data_i, data_q): (-0.906250,0.687500)\n\t2263: o_phase = +9'd201;\t //LUT[2263] \tphase : 0.785156\t(data_i, data_q): (-0.906250,0.718750)\n\t2264: o_phase = +9'd200;\t //LUT[2264] \tphase : 0.781250\t(data_i, data_q): (-0.906250,0.750000)\n\t2265: o_phase = +9'd198;\t //LUT[2265] \tphase : 0.773438\t(data_i, data_q): (-0.906250,0.781250)\n\t2266: o_phase = +9'd196;\t //LUT[2266] \tphase : 0.765625\t(data_i, data_q): (-0.906250,0.812500)\n\t2267: o_phase = +9'd195;\t //LUT[2267] \tphase : 0.761719\t(data_i, data_q): (-0.906250,0.843750)\n\t2268: o_phase = +9'd193;\t //LUT[2268] \tphase : 0.753906\t(data_i, data_q): (-0.906250,0.875000)\n\t2269: o_phase = +9'd192;\t //LUT[2269] \tphase : 0.750000\t(data_i, data_q): (-0.906250,0.906250)\n\t2270: o_phase = +9'd191;\t //LUT[2270] \tphase : 0.746094\t(data_i, data_q): (-0.906250,0.937500)\n\t2271: o_phase = +9'd189;\t //LUT[2271] \tphase : 0.738281\t(data_i, data_q): (-0.906250,0.968750)\n\t2272: o_phase = -9'd188;\t //LUT[2272] \tphase : -0.734375\t(data_i, data_q): (-0.906250,-1.000000)\n\t2273: o_phase = -9'd189;\t //LUT[2273] \tphase : -0.738281\t(data_i, data_q): (-0.906250,-0.968750)\n\t2274: o_phase = -9'd191;\t //LUT[2274] \tphase : -0.746094\t(data_i, data_q): (-0.906250,-0.937500)\n\t2275: o_phase = -9'd192;\t //LUT[2275] \tphase : -0.750000\t(data_i, data_q): (-0.906250,-0.906250)\n\t2276: o_phase = -9'd193;\t //LUT[2276] \tphase : -0.753906\t(data_i, data_q): (-0.906250,-0.875000)\n\t2277: o_phase = -9'd195;\t //LUT[2277] \tphase : -0.761719\t(data_i, data_q): (-0.906250,-0.843750)\n\t2278: o_phase = -9'd196;\t //LUT[2278] \tphase : -0.765625\t(data_i, data_q): (-0.906250,-0.812500)\n\t2279: o_phase = -9'd198;\t //LUT[2279] \tphase : -0.773438\t(data_i, data_q): (-0.906250,-0.781250)\n\t2280: o_phase = -9'd200;\t //LUT[2280] \tphase : -0.781250\t(data_i, data_q): (-0.906250,-0.750000)\n\t2281: o_phase = -9'd201;\t //LUT[2281] \tphase : -0.785156\t(data_i, data_q): (-0.906250,-0.718750)\n\t2282: o_phase = -9'd203;\t //LUT[2282] \tphase : -0.792969\t(data_i, data_q): (-0.906250,-0.687500)\n\t2283: o_phase = -9'd205;\t //LUT[2283] \tphase : -0.800781\t(data_i, data_q): (-0.906250,-0.656250)\n\t2284: o_phase = -9'd207;\t //LUT[2284] \tphase : -0.808594\t(data_i, data_q): (-0.906250,-0.625000)\n\t2285: o_phase = -9'd209;\t //LUT[2285] \tphase : -0.816406\t(data_i, data_q): (-0.906250,-0.593750)\n\t2286: o_phase = -9'd211;\t //LUT[2286] \tphase : -0.824219\t(data_i, data_q): (-0.906250,-0.562500)\n\t2287: o_phase = -9'd213;\t //LUT[2287] \tphase : -0.832031\t(data_i, data_q): (-0.906250,-0.531250)\n\t2288: o_phase = -9'd215;\t //LUT[2288] \tphase : -0.839844\t(data_i, data_q): (-0.906250,-0.500000)\n\t2289: o_phase = -9'd217;\t //LUT[2289] \tphase : -0.847656\t(data_i, data_q): (-0.906250,-0.468750)\n\t2290: o_phase = -9'd219;\t //LUT[2290] \tphase : -0.855469\t(data_i, data_q): (-0.906250,-0.437500)\n\t2291: o_phase = -9'd222;\t //LUT[2291] \tphase : -0.867188\t(data_i, data_q): (-0.906250,-0.406250)\n\t2292: o_phase = -9'd224;\t //LUT[2292] \tphase : -0.875000\t(data_i, data_q): (-0.906250,-0.375000)\n\t2293: o_phase = -9'd226;\t //LUT[2293] \tphase : -0.882812\t(data_i, data_q): (-0.906250,-0.343750)\n\t2294: o_phase = -9'd229;\t //LUT[2294] \tphase : -0.894531\t(data_i, data_q): (-0.906250,-0.312500)\n\t2295: o_phase = -9'd231;\t //LUT[2295] \tphase : -0.902344\t(data_i, data_q): (-0.906250,-0.281250)\n\t2296: o_phase = -9'd234;\t //LUT[2296] \tphase : -0.914062\t(data_i, data_q): (-0.906250,-0.250000)\n\t2297: o_phase = -9'd237;\t //LUT[2297] \tphase : -0.925781\t(data_i, data_q): (-0.906250,-0.218750)\n\t2298: o_phase = -9'd239;\t //LUT[2298] \tphase : -0.933594\t(data_i, data_q): (-0.906250,-0.187500)\n\t2299: o_phase = -9'd242;\t //LUT[2299] \tphase : -0.945312\t(data_i, data_q): (-0.906250,-0.156250)\n\t2300: o_phase = -9'd245;\t //LUT[2300] \tphase : -0.957031\t(data_i, data_q): (-0.906250,-0.125000)\n\t2301: o_phase = -9'd248;\t //LUT[2301] \tphase : -0.968750\t(data_i, data_q): (-0.906250,-0.093750)\n\t2302: o_phase = -9'd250;\t //LUT[2302] \tphase : -0.976562\t(data_i, data_q): (-0.906250,-0.062500)\n\t2303: o_phase = -9'd253;\t //LUT[2303] \tphase : -0.988281\t(data_i, data_q): (-0.906250,-0.031250)\n\t2304: o_phase = -9'd256;\t //LUT[2304] \tphase : -1.000000\t(data_i, data_q): (-0.875000,0.000000)\n\t2305: o_phase = +9'd253;\t //LUT[2305] \tphase : 0.988281\t(data_i, data_q): (-0.875000,0.031250)\n\t2306: o_phase = +9'd250;\t //LUT[2306] \tphase : 0.976562\t(data_i, data_q): (-0.875000,0.062500)\n\t2307: o_phase = +9'd247;\t //LUT[2307] \tphase : 0.964844\t(data_i, data_q): (-0.875000,0.093750)\n\t2308: o_phase = +9'd244;\t //LUT[2308] \tphase : 0.953125\t(data_i, data_q): (-0.875000,0.125000)\n\t2309: o_phase = +9'd242;\t //LUT[2309] \tphase : 0.945312\t(data_i, data_q): (-0.875000,0.156250)\n\t2310: o_phase = +9'd239;\t //LUT[2310] \tphase : 0.933594\t(data_i, data_q): (-0.875000,0.187500)\n\t2311: o_phase = +9'd236;\t //LUT[2311] \tphase : 0.921875\t(data_i, data_q): (-0.875000,0.218750)\n\t2312: o_phase = +9'd233;\t //LUT[2312] \tphase : 0.910156\t(data_i, data_q): (-0.875000,0.250000)\n\t2313: o_phase = +9'd231;\t //LUT[2313] \tphase : 0.902344\t(data_i, data_q): (-0.875000,0.281250)\n\t2314: o_phase = +9'd228;\t //LUT[2314] \tphase : 0.890625\t(data_i, data_q): (-0.875000,0.312500)\n\t2315: o_phase = +9'd225;\t //LUT[2315] \tphase : 0.878906\t(data_i, data_q): (-0.875000,0.343750)\n\t2316: o_phase = +9'd223;\t //LUT[2316] \tphase : 0.871094\t(data_i, data_q): (-0.875000,0.375000)\n\t2317: o_phase = +9'd221;\t //LUT[2317] \tphase : 0.863281\t(data_i, data_q): (-0.875000,0.406250)\n\t2318: o_phase = +9'd218;\t //LUT[2318] \tphase : 0.851562\t(data_i, data_q): (-0.875000,0.437500)\n\t2319: o_phase = +9'd216;\t //LUT[2319] \tphase : 0.843750\t(data_i, data_q): (-0.875000,0.468750)\n\t2320: o_phase = +9'd214;\t //LUT[2320] \tphase : 0.835938\t(data_i, data_q): (-0.875000,0.500000)\n\t2321: o_phase = +9'd212;\t //LUT[2321] \tphase : 0.828125\t(data_i, data_q): (-0.875000,0.531250)\n\t2322: o_phase = +9'd209;\t //LUT[2322] \tphase : 0.816406\t(data_i, data_q): (-0.875000,0.562500)\n\t2323: o_phase = +9'd207;\t //LUT[2323] \tphase : 0.808594\t(data_i, data_q): (-0.875000,0.593750)\n\t2324: o_phase = +9'd205;\t //LUT[2324] \tphase : 0.800781\t(data_i, data_q): (-0.875000,0.625000)\n\t2325: o_phase = +9'd204;\t //LUT[2325] \tphase : 0.796875\t(data_i, data_q): (-0.875000,0.656250)\n\t2326: o_phase = +9'd202;\t //LUT[2326] \tphase : 0.789062\t(data_i, data_q): (-0.875000,0.687500)\n\t2327: o_phase = +9'd200;\t //LUT[2327] \tphase : 0.781250\t(data_i, data_q): (-0.875000,0.718750)\n\t2328: o_phase = +9'd198;\t //LUT[2328] \tphase : 0.773438\t(data_i, data_q): (-0.875000,0.750000)\n\t2329: o_phase = +9'd197;\t //LUT[2329] \tphase : 0.769531\t(data_i, data_q): (-0.875000,0.781250)\n\t2330: o_phase = +9'd195;\t //LUT[2330] \tphase : 0.761719\t(data_i, data_q): (-0.875000,0.812500)\n\t2331: o_phase = +9'd193;\t //LUT[2331] \tphase : 0.753906\t(data_i, data_q): (-0.875000,0.843750)\n\t2332: o_phase = +9'd192;\t //LUT[2332] \tphase : 0.750000\t(data_i, data_q): (-0.875000,0.875000)\n\t2333: o_phase = +9'd191;\t //LUT[2333] \tphase : 0.746094\t(data_i, data_q): (-0.875000,0.906250)\n\t2334: o_phase = +9'd189;\t //LUT[2334] \tphase : 0.738281\t(data_i, data_q): (-0.875000,0.937500)\n\t2335: o_phase = +9'd188;\t //LUT[2335] \tphase : 0.734375\t(data_i, data_q): (-0.875000,0.968750)\n\t2336: o_phase = -9'd187;\t //LUT[2336] \tphase : -0.730469\t(data_i, data_q): (-0.875000,-1.000000)\n\t2337: o_phase = -9'd188;\t //LUT[2337] \tphase : -0.734375\t(data_i, data_q): (-0.875000,-0.968750)\n\t2338: o_phase = -9'd189;\t //LUT[2338] \tphase : -0.738281\t(data_i, data_q): (-0.875000,-0.937500)\n\t2339: o_phase = -9'd191;\t //LUT[2339] \tphase : -0.746094\t(data_i, data_q): (-0.875000,-0.906250)\n\t2340: o_phase = -9'd192;\t //LUT[2340] \tphase : -0.750000\t(data_i, data_q): (-0.875000,-0.875000)\n\t2341: o_phase = -9'd193;\t //LUT[2341] \tphase : -0.753906\t(data_i, data_q): (-0.875000,-0.843750)\n\t2342: o_phase = -9'd195;\t //LUT[2342] \tphase : -0.761719\t(data_i, data_q): (-0.875000,-0.812500)\n\t2343: o_phase = -9'd197;\t //LUT[2343] \tphase : -0.769531\t(data_i, data_q): (-0.875000,-0.781250)\n\t2344: o_phase = -9'd198;\t //LUT[2344] \tphase : -0.773438\t(data_i, data_q): (-0.875000,-0.750000)\n\t2345: o_phase = -9'd200;\t //LUT[2345] \tphase : -0.781250\t(data_i, data_q): (-0.875000,-0.718750)\n\t2346: o_phase = -9'd202;\t //LUT[2346] \tphase : -0.789062\t(data_i, data_q): (-0.875000,-0.687500)\n\t2347: o_phase = -9'd204;\t //LUT[2347] \tphase : -0.796875\t(data_i, data_q): (-0.875000,-0.656250)\n\t2348: o_phase = -9'd205;\t //LUT[2348] \tphase : -0.800781\t(data_i, data_q): (-0.875000,-0.625000)\n\t2349: o_phase = -9'd207;\t //LUT[2349] \tphase : -0.808594\t(data_i, data_q): (-0.875000,-0.593750)\n\t2350: o_phase = -9'd209;\t //LUT[2350] \tphase : -0.816406\t(data_i, data_q): (-0.875000,-0.562500)\n\t2351: o_phase = -9'd212;\t //LUT[2351] \tphase : -0.828125\t(data_i, data_q): (-0.875000,-0.531250)\n\t2352: o_phase = -9'd214;\t //LUT[2352] \tphase : -0.835938\t(data_i, data_q): (-0.875000,-0.500000)\n\t2353: o_phase = -9'd216;\t //LUT[2353] \tphase : -0.843750\t(data_i, data_q): (-0.875000,-0.468750)\n\t2354: o_phase = -9'd218;\t //LUT[2354] \tphase : -0.851562\t(data_i, data_q): (-0.875000,-0.437500)\n\t2355: o_phase = -9'd221;\t //LUT[2355] \tphase : -0.863281\t(data_i, data_q): (-0.875000,-0.406250)\n\t2356: o_phase = -9'd223;\t //LUT[2356] \tphase : -0.871094\t(data_i, data_q): (-0.875000,-0.375000)\n\t2357: o_phase = -9'd225;\t //LUT[2357] \tphase : -0.878906\t(data_i, data_q): (-0.875000,-0.343750)\n\t2358: o_phase = -9'd228;\t //LUT[2358] \tphase : -0.890625\t(data_i, data_q): (-0.875000,-0.312500)\n\t2359: o_phase = -9'd231;\t //LUT[2359] \tphase : -0.902344\t(data_i, data_q): (-0.875000,-0.281250)\n\t2360: o_phase = -9'd233;\t //LUT[2360] \tphase : -0.910156\t(data_i, data_q): (-0.875000,-0.250000)\n\t2361: o_phase = -9'd236;\t //LUT[2361] \tphase : -0.921875\t(data_i, data_q): (-0.875000,-0.218750)\n\t2362: o_phase = -9'd239;\t //LUT[2362] \tphase : -0.933594\t(data_i, data_q): (-0.875000,-0.187500)\n\t2363: o_phase = -9'd242;\t //LUT[2363] \tphase : -0.945312\t(data_i, data_q): (-0.875000,-0.156250)\n\t2364: o_phase = -9'd244;\t //LUT[2364] \tphase : -0.953125\t(data_i, data_q): (-0.875000,-0.125000)\n\t2365: o_phase = -9'd247;\t //LUT[2365] \tphase : -0.964844\t(data_i, data_q): (-0.875000,-0.093750)\n\t2366: o_phase = -9'd250;\t //LUT[2366] \tphase : -0.976562\t(data_i, data_q): (-0.875000,-0.062500)\n\t2367: o_phase = -9'd253;\t //LUT[2367] \tphase : -0.988281\t(data_i, data_q): (-0.875000,-0.031250)\n\t2368: o_phase = -9'd256;\t //LUT[2368] \tphase : -1.000000\t(data_i, data_q): (-0.843750,0.000000)\n\t2369: o_phase = +9'd253;\t //LUT[2369] \tphase : 0.988281\t(data_i, data_q): (-0.843750,0.031250)\n\t2370: o_phase = +9'd250;\t //LUT[2370] \tphase : 0.976562\t(data_i, data_q): (-0.843750,0.062500)\n\t2371: o_phase = +9'd247;\t //LUT[2371] \tphase : 0.964844\t(data_i, data_q): (-0.843750,0.093750)\n\t2372: o_phase = +9'd244;\t //LUT[2372] \tphase : 0.953125\t(data_i, data_q): (-0.843750,0.125000)\n\t2373: o_phase = +9'd241;\t //LUT[2373] \tphase : 0.941406\t(data_i, data_q): (-0.843750,0.156250)\n\t2374: o_phase = +9'd238;\t //LUT[2374] \tphase : 0.929688\t(data_i, data_q): (-0.843750,0.187500)\n\t2375: o_phase = +9'd235;\t //LUT[2375] \tphase : 0.917969\t(data_i, data_q): (-0.843750,0.218750)\n\t2376: o_phase = +9'd233;\t //LUT[2376] \tphase : 0.910156\t(data_i, data_q): (-0.843750,0.250000)\n\t2377: o_phase = +9'd230;\t //LUT[2377] \tphase : 0.898438\t(data_i, data_q): (-0.843750,0.281250)\n\t2378: o_phase = +9'd227;\t //LUT[2378] \tphase : 0.886719\t(data_i, data_q): (-0.843750,0.312500)\n\t2379: o_phase = +9'd224;\t //LUT[2379] \tphase : 0.875000\t(data_i, data_q): (-0.843750,0.343750)\n\t2380: o_phase = +9'd222;\t //LUT[2380] \tphase : 0.867188\t(data_i, data_q): (-0.843750,0.375000)\n\t2381: o_phase = +9'd219;\t //LUT[2381] \tphase : 0.855469\t(data_i, data_q): (-0.843750,0.406250)\n\t2382: o_phase = +9'd217;\t //LUT[2382] \tphase : 0.847656\t(data_i, data_q): (-0.843750,0.437500)\n\t2383: o_phase = +9'd215;\t //LUT[2383] \tphase : 0.839844\t(data_i, data_q): (-0.843750,0.468750)\n\t2384: o_phase = +9'd212;\t //LUT[2384] \tphase : 0.828125\t(data_i, data_q): (-0.843750,0.500000)\n\t2385: o_phase = +9'd210;\t //LUT[2385] \tphase : 0.820312\t(data_i, data_q): (-0.843750,0.531250)\n\t2386: o_phase = +9'd208;\t //LUT[2386] \tphase : 0.812500\t(data_i, data_q): (-0.843750,0.562500)\n\t2387: o_phase = +9'd206;\t //LUT[2387] \tphase : 0.804688\t(data_i, data_q): (-0.843750,0.593750)\n\t2388: o_phase = +9'd204;\t //LUT[2388] \tphase : 0.796875\t(data_i, data_q): (-0.843750,0.625000)\n\t2389: o_phase = +9'd202;\t //LUT[2389] \tphase : 0.789062\t(data_i, data_q): (-0.843750,0.656250)\n\t2390: o_phase = +9'd200;\t //LUT[2390] \tphase : 0.781250\t(data_i, data_q): (-0.843750,0.687500)\n\t2391: o_phase = +9'd199;\t //LUT[2391] \tphase : 0.777344\t(data_i, data_q): (-0.843750,0.718750)\n\t2392: o_phase = +9'd197;\t //LUT[2392] \tphase : 0.769531\t(data_i, data_q): (-0.843750,0.750000)\n\t2393: o_phase = +9'd195;\t //LUT[2393] \tphase : 0.761719\t(data_i, data_q): (-0.843750,0.781250)\n\t2394: o_phase = +9'd194;\t //LUT[2394] \tphase : 0.757812\t(data_i, data_q): (-0.843750,0.812500)\n\t2395: o_phase = +9'd192;\t //LUT[2395] \tphase : 0.750000\t(data_i, data_q): (-0.843750,0.843750)\n\t2396: o_phase = +9'd191;\t //LUT[2396] \tphase : 0.746094\t(data_i, data_q): (-0.843750,0.875000)\n\t2397: o_phase = +9'd189;\t //LUT[2397] \tphase : 0.738281\t(data_i, data_q): (-0.843750,0.906250)\n\t2398: o_phase = +9'd188;\t //LUT[2398] \tphase : 0.734375\t(data_i, data_q): (-0.843750,0.937500)\n\t2399: o_phase = +9'd186;\t //LUT[2399] \tphase : 0.726562\t(data_i, data_q): (-0.843750,0.968750)\n\t2400: o_phase = -9'd185;\t //LUT[2400] \tphase : -0.722656\t(data_i, data_q): (-0.843750,-1.000000)\n\t2401: o_phase = -9'd186;\t //LUT[2401] \tphase : -0.726562\t(data_i, data_q): (-0.843750,-0.968750)\n\t2402: o_phase = -9'd188;\t //LUT[2402] \tphase : -0.734375\t(data_i, data_q): (-0.843750,-0.937500)\n\t2403: o_phase = -9'd189;\t //LUT[2403] \tphase : -0.738281\t(data_i, data_q): (-0.843750,-0.906250)\n\t2404: o_phase = -9'd191;\t //LUT[2404] \tphase : -0.746094\t(data_i, data_q): (-0.843750,-0.875000)\n\t2405: o_phase = -9'd192;\t //LUT[2405] \tphase : -0.750000\t(data_i, data_q): (-0.843750,-0.843750)\n\t2406: o_phase = -9'd194;\t //LUT[2406] \tphase : -0.757812\t(data_i, data_q): (-0.843750,-0.812500)\n\t2407: o_phase = -9'd195;\t //LUT[2407] \tphase : -0.761719\t(data_i, data_q): (-0.843750,-0.781250)\n\t2408: o_phase = -9'd197;\t //LUT[2408] \tphase : -0.769531\t(data_i, data_q): (-0.843750,-0.750000)\n\t2409: o_phase = -9'd199;\t //LUT[2409] \tphase : -0.777344\t(data_i, data_q): (-0.843750,-0.718750)\n\t2410: o_phase = -9'd200;\t //LUT[2410] \tphase : -0.781250\t(data_i, data_q): (-0.843750,-0.687500)\n\t2411: o_phase = -9'd202;\t //LUT[2411] \tphase : -0.789062\t(data_i, data_q): (-0.843750,-0.656250)\n\t2412: o_phase = -9'd204;\t //LUT[2412] \tphase : -0.796875\t(data_i, data_q): (-0.843750,-0.625000)\n\t2413: o_phase = -9'd206;\t //LUT[2413] \tphase : -0.804688\t(data_i, data_q): (-0.843750,-0.593750)\n\t2414: o_phase = -9'd208;\t //LUT[2414] \tphase : -0.812500\t(data_i, data_q): (-0.843750,-0.562500)\n\t2415: o_phase = -9'd210;\t //LUT[2415] \tphase : -0.820312\t(data_i, data_q): (-0.843750,-0.531250)\n\t2416: o_phase = -9'd212;\t //LUT[2416] \tphase : -0.828125\t(data_i, data_q): (-0.843750,-0.500000)\n\t2417: o_phase = -9'd215;\t //LUT[2417] \tphase : -0.839844\t(data_i, data_q): (-0.843750,-0.468750)\n\t2418: o_phase = -9'd217;\t //LUT[2418] \tphase : -0.847656\t(data_i, data_q): (-0.843750,-0.437500)\n\t2419: o_phase = -9'd219;\t //LUT[2419] \tphase : -0.855469\t(data_i, data_q): (-0.843750,-0.406250)\n\t2420: o_phase = -9'd222;\t //LUT[2420] \tphase : -0.867188\t(data_i, data_q): (-0.843750,-0.375000)\n\t2421: o_phase = -9'd224;\t //LUT[2421] \tphase : -0.875000\t(data_i, data_q): (-0.843750,-0.343750)\n\t2422: o_phase = -9'd227;\t //LUT[2422] \tphase : -0.886719\t(data_i, data_q): (-0.843750,-0.312500)\n\t2423: o_phase = -9'd230;\t //LUT[2423] \tphase : -0.898438\t(data_i, data_q): (-0.843750,-0.281250)\n\t2424: o_phase = -9'd233;\t //LUT[2424] \tphase : -0.910156\t(data_i, data_q): (-0.843750,-0.250000)\n\t2425: o_phase = -9'd235;\t //LUT[2425] \tphase : -0.917969\t(data_i, data_q): (-0.843750,-0.218750)\n\t2426: o_phase = -9'd238;\t //LUT[2426] \tphase : -0.929688\t(data_i, data_q): (-0.843750,-0.187500)\n\t2427: o_phase = -9'd241;\t //LUT[2427] \tphase : -0.941406\t(data_i, data_q): (-0.843750,-0.156250)\n\t2428: o_phase = -9'd244;\t //LUT[2428] \tphase : -0.953125\t(data_i, data_q): (-0.843750,-0.125000)\n\t2429: o_phase = -9'd247;\t //LUT[2429] \tphase : -0.964844\t(data_i, data_q): (-0.843750,-0.093750)\n\t2430: o_phase = -9'd250;\t //LUT[2430] \tphase : -0.976562\t(data_i, data_q): (-0.843750,-0.062500)\n\t2431: o_phase = -9'd253;\t //LUT[2431] \tphase : -0.988281\t(data_i, data_q): (-0.843750,-0.031250)\n\t2432: o_phase = -9'd256;\t //LUT[2432] \tphase : -1.000000\t(data_i, data_q): (-0.812500,0.000000)\n\t2433: o_phase = +9'd253;\t //LUT[2433] \tphase : 0.988281\t(data_i, data_q): (-0.812500,0.031250)\n\t2434: o_phase = +9'd250;\t //LUT[2434] \tphase : 0.976562\t(data_i, data_q): (-0.812500,0.062500)\n\t2435: o_phase = +9'd247;\t //LUT[2435] \tphase : 0.964844\t(data_i, data_q): (-0.812500,0.093750)\n\t2436: o_phase = +9'd244;\t //LUT[2436] \tphase : 0.953125\t(data_i, data_q): (-0.812500,0.125000)\n\t2437: o_phase = +9'd241;\t //LUT[2437] \tphase : 0.941406\t(data_i, data_q): (-0.812500,0.156250)\n\t2438: o_phase = +9'd238;\t //LUT[2438] \tphase : 0.929688\t(data_i, data_q): (-0.812500,0.187500)\n\t2439: o_phase = +9'd235;\t //LUT[2439] \tphase : 0.917969\t(data_i, data_q): (-0.812500,0.218750)\n\t2440: o_phase = +9'd232;\t //LUT[2440] \tphase : 0.906250\t(data_i, data_q): (-0.812500,0.250000)\n\t2441: o_phase = +9'd229;\t //LUT[2441] \tphase : 0.894531\t(data_i, data_q): (-0.812500,0.281250)\n\t2442: o_phase = +9'd226;\t //LUT[2442] \tphase : 0.882812\t(data_i, data_q): (-0.812500,0.312500)\n\t2443: o_phase = +9'd223;\t //LUT[2443] \tphase : 0.871094\t(data_i, data_q): (-0.812500,0.343750)\n\t2444: o_phase = +9'd221;\t //LUT[2444] \tphase : 0.863281\t(data_i, data_q): (-0.812500,0.375000)\n\t2445: o_phase = +9'd218;\t //LUT[2445] \tphase : 0.851562\t(data_i, data_q): (-0.812500,0.406250)\n\t2446: o_phase = +9'd216;\t //LUT[2446] \tphase : 0.843750\t(data_i, data_q): (-0.812500,0.437500)\n\t2447: o_phase = +9'd213;\t //LUT[2447] \tphase : 0.832031\t(data_i, data_q): (-0.812500,0.468750)\n\t2448: o_phase = +9'd211;\t //LUT[2448] \tphase : 0.824219\t(data_i, data_q): (-0.812500,0.500000)\n\t2449: o_phase = +9'd209;\t //LUT[2449] \tphase : 0.816406\t(data_i, data_q): (-0.812500,0.531250)\n\t2450: o_phase = +9'd207;\t //LUT[2450] \tphase : 0.808594\t(data_i, data_q): (-0.812500,0.562500)\n\t2451: o_phase = +9'd205;\t //LUT[2451] \tphase : 0.800781\t(data_i, data_q): (-0.812500,0.593750)\n\t2452: o_phase = +9'd203;\t //LUT[2452] \tphase : 0.792969\t(data_i, data_q): (-0.812500,0.625000)\n\t2453: o_phase = +9'd201;\t //LUT[2453] \tphase : 0.785156\t(data_i, data_q): (-0.812500,0.656250)\n\t2454: o_phase = +9'd199;\t //LUT[2454] \tphase : 0.777344\t(data_i, data_q): (-0.812500,0.687500)\n\t2455: o_phase = +9'd197;\t //LUT[2455] \tphase : 0.769531\t(data_i, data_q): (-0.812500,0.718750)\n\t2456: o_phase = +9'd195;\t //LUT[2456] \tphase : 0.761719\t(data_i, data_q): (-0.812500,0.750000)\n\t2457: o_phase = +9'd194;\t //LUT[2457] \tphase : 0.757812\t(data_i, data_q): (-0.812500,0.781250)\n\t2458: o_phase = +9'd192;\t //LUT[2458] \tphase : 0.750000\t(data_i, data_q): (-0.812500,0.812500)\n\t2459: o_phase = +9'd190;\t //LUT[2459] \tphase : 0.742188\t(data_i, data_q): (-0.812500,0.843750)\n\t2460: o_phase = +9'd189;\t //LUT[2460] \tphase : 0.738281\t(data_i, data_q): (-0.812500,0.875000)\n\t2461: o_phase = +9'd188;\t //LUT[2461] \tphase : 0.734375\t(data_i, data_q): (-0.812500,0.906250)\n\t2462: o_phase = +9'd186;\t //LUT[2462] \tphase : 0.726562\t(data_i, data_q): (-0.812500,0.937500)\n\t2463: o_phase = +9'd185;\t //LUT[2463] \tphase : 0.722656\t(data_i, data_q): (-0.812500,0.968750)\n\t2464: o_phase = -9'd184;\t //LUT[2464] \tphase : -0.718750\t(data_i, data_q): (-0.812500,-1.000000)\n\t2465: o_phase = -9'd185;\t //LUT[2465] \tphase : -0.722656\t(data_i, data_q): (-0.812500,-0.968750)\n\t2466: o_phase = -9'd186;\t //LUT[2466] \tphase : -0.726562\t(data_i, data_q): (-0.812500,-0.937500)\n\t2467: o_phase = -9'd188;\t //LUT[2467] \tphase : -0.734375\t(data_i, data_q): (-0.812500,-0.906250)\n\t2468: o_phase = -9'd189;\t //LUT[2468] \tphase : -0.738281\t(data_i, data_q): (-0.812500,-0.875000)\n\t2469: o_phase = -9'd190;\t //LUT[2469] \tphase : -0.742188\t(data_i, data_q): (-0.812500,-0.843750)\n\t2470: o_phase = -9'd192;\t //LUT[2470] \tphase : -0.750000\t(data_i, data_q): (-0.812500,-0.812500)\n\t2471: o_phase = -9'd194;\t //LUT[2471] \tphase : -0.757812\t(data_i, data_q): (-0.812500,-0.781250)\n\t2472: o_phase = -9'd195;\t //LUT[2472] \tphase : -0.761719\t(data_i, data_q): (-0.812500,-0.750000)\n\t2473: o_phase = -9'd197;\t //LUT[2473] \tphase : -0.769531\t(data_i, data_q): (-0.812500,-0.718750)\n\t2474: o_phase = -9'd199;\t //LUT[2474] \tphase : -0.777344\t(data_i, data_q): (-0.812500,-0.687500)\n\t2475: o_phase = -9'd201;\t //LUT[2475] \tphase : -0.785156\t(data_i, data_q): (-0.812500,-0.656250)\n\t2476: o_phase = -9'd203;\t //LUT[2476] \tphase : -0.792969\t(data_i, data_q): (-0.812500,-0.625000)\n\t2477: o_phase = -9'd205;\t //LUT[2477] \tphase : -0.800781\t(data_i, data_q): (-0.812500,-0.593750)\n\t2478: o_phase = -9'd207;\t //LUT[2478] \tphase : -0.808594\t(data_i, data_q): (-0.812500,-0.562500)\n\t2479: o_phase = -9'd209;\t //LUT[2479] \tphase : -0.816406\t(data_i, data_q): (-0.812500,-0.531250)\n\t2480: o_phase = -9'd211;\t //LUT[2480] \tphase : -0.824219\t(data_i, data_q): (-0.812500,-0.500000)\n\t2481: o_phase = -9'd213;\t //LUT[2481] \tphase : -0.832031\t(data_i, data_q): (-0.812500,-0.468750)\n\t2482: o_phase = -9'd216;\t //LUT[2482] \tphase : -0.843750\t(data_i, data_q): (-0.812500,-0.437500)\n\t2483: o_phase = -9'd218;\t //LUT[2483] \tphase : -0.851562\t(data_i, data_q): (-0.812500,-0.406250)\n\t2484: o_phase = -9'd221;\t //LUT[2484] \tphase : -0.863281\t(data_i, data_q): (-0.812500,-0.375000)\n\t2485: o_phase = -9'd223;\t //LUT[2485] \tphase : -0.871094\t(data_i, data_q): (-0.812500,-0.343750)\n\t2486: o_phase = -9'd226;\t //LUT[2486] \tphase : -0.882812\t(data_i, data_q): (-0.812500,-0.312500)\n\t2487: o_phase = -9'd229;\t //LUT[2487] \tphase : -0.894531\t(data_i, data_q): (-0.812500,-0.281250)\n\t2488: o_phase = -9'd232;\t //LUT[2488] \tphase : -0.906250\t(data_i, data_q): (-0.812500,-0.250000)\n\t2489: o_phase = -9'd235;\t //LUT[2489] \tphase : -0.917969\t(data_i, data_q): (-0.812500,-0.218750)\n\t2490: o_phase = -9'd238;\t //LUT[2490] \tphase : -0.929688\t(data_i, data_q): (-0.812500,-0.187500)\n\t2491: o_phase = -9'd241;\t //LUT[2491] \tphase : -0.941406\t(data_i, data_q): (-0.812500,-0.156250)\n\t2492: o_phase = -9'd244;\t //LUT[2492] \tphase : -0.953125\t(data_i, data_q): (-0.812500,-0.125000)\n\t2493: o_phase = -9'd247;\t //LUT[2493] \tphase : -0.964844\t(data_i, data_q): (-0.812500,-0.093750)\n\t2494: o_phase = -9'd250;\t //LUT[2494] \tphase : -0.976562\t(data_i, data_q): (-0.812500,-0.062500)\n\t2495: o_phase = -9'd253;\t //LUT[2495] \tphase : -0.988281\t(data_i, data_q): (-0.812500,-0.031250)\n\t2496: o_phase = -9'd256;\t //LUT[2496] \tphase : -1.000000\t(data_i, data_q): (-0.781250,0.000000)\n\t2497: o_phase = +9'd253;\t //LUT[2497] \tphase : 0.988281\t(data_i, data_q): (-0.781250,0.031250)\n\t2498: o_phase = +9'd249;\t //LUT[2498] \tphase : 0.972656\t(data_i, data_q): (-0.781250,0.062500)\n\t2499: o_phase = +9'd246;\t //LUT[2499] \tphase : 0.960938\t(data_i, data_q): (-0.781250,0.093750)\n\t2500: o_phase = +9'd243;\t //LUT[2500] \tphase : 0.949219\t(data_i, data_q): (-0.781250,0.125000)\n\t2501: o_phase = +9'd240;\t //LUT[2501] \tphase : 0.937500\t(data_i, data_q): (-0.781250,0.156250)\n\t2502: o_phase = +9'd237;\t //LUT[2502] \tphase : 0.925781\t(data_i, data_q): (-0.781250,0.187500)\n\t2503: o_phase = +9'd234;\t //LUT[2503] \tphase : 0.914062\t(data_i, data_q): (-0.781250,0.218750)\n\t2504: o_phase = +9'd231;\t //LUT[2504] \tphase : 0.902344\t(data_i, data_q): (-0.781250,0.250000)\n\t2505: o_phase = +9'd228;\t //LUT[2505] \tphase : 0.890625\t(data_i, data_q): (-0.781250,0.281250)\n\t2506: o_phase = +9'd225;\t //LUT[2506] \tphase : 0.878906\t(data_i, data_q): (-0.781250,0.312500)\n\t2507: o_phase = +9'd222;\t //LUT[2507] \tphase : 0.867188\t(data_i, data_q): (-0.781250,0.343750)\n\t2508: o_phase = +9'd220;\t //LUT[2508] \tphase : 0.859375\t(data_i, data_q): (-0.781250,0.375000)\n\t2509: o_phase = +9'd217;\t //LUT[2509] \tphase : 0.847656\t(data_i, data_q): (-0.781250,0.406250)\n\t2510: o_phase = +9'd214;\t //LUT[2510] \tphase : 0.835938\t(data_i, data_q): (-0.781250,0.437500)\n\t2511: o_phase = +9'd212;\t //LUT[2511] \tphase : 0.828125\t(data_i, data_q): (-0.781250,0.468750)\n\t2512: o_phase = +9'd210;\t //LUT[2512] \tphase : 0.820312\t(data_i, data_q): (-0.781250,0.500000)\n\t2513: o_phase = +9'd207;\t //LUT[2513] \tphase : 0.808594\t(data_i, data_q): (-0.781250,0.531250)\n\t2514: o_phase = +9'd205;\t //LUT[2514] \tphase : 0.800781\t(data_i, data_q): (-0.781250,0.562500)\n\t2515: o_phase = +9'd203;\t //LUT[2515] \tphase : 0.792969\t(data_i, data_q): (-0.781250,0.593750)\n\t2516: o_phase = +9'd201;\t //LUT[2516] \tphase : 0.785156\t(data_i, data_q): (-0.781250,0.625000)\n\t2517: o_phase = +9'd199;\t //LUT[2517] \tphase : 0.777344\t(data_i, data_q): (-0.781250,0.656250)\n\t2518: o_phase = +9'd197;\t //LUT[2518] \tphase : 0.769531\t(data_i, data_q): (-0.781250,0.687500)\n\t2519: o_phase = +9'd195;\t //LUT[2519] \tphase : 0.761719\t(data_i, data_q): (-0.781250,0.718750)\n\t2520: o_phase = +9'd194;\t //LUT[2520] \tphase : 0.757812\t(data_i, data_q): (-0.781250,0.750000)\n\t2521: o_phase = +9'd192;\t //LUT[2521] \tphase : 0.750000\t(data_i, data_q): (-0.781250,0.781250)\n\t2522: o_phase = +9'd190;\t //LUT[2522] \tphase : 0.742188\t(data_i, data_q): (-0.781250,0.812500)\n\t2523: o_phase = +9'd189;\t //LUT[2523] \tphase : 0.738281\t(data_i, data_q): (-0.781250,0.843750)\n\t2524: o_phase = +9'd187;\t //LUT[2524] \tphase : 0.730469\t(data_i, data_q): (-0.781250,0.875000)\n\t2525: o_phase = +9'd186;\t //LUT[2525] \tphase : 0.726562\t(data_i, data_q): (-0.781250,0.906250)\n\t2526: o_phase = +9'd185;\t //LUT[2526] \tphase : 0.722656\t(data_i, data_q): (-0.781250,0.937500)\n\t2527: o_phase = +9'd183;\t //LUT[2527] \tphase : 0.714844\t(data_i, data_q): (-0.781250,0.968750)\n\t2528: o_phase = -9'd182;\t //LUT[2528] \tphase : -0.710938\t(data_i, data_q): (-0.781250,-1.000000)\n\t2529: o_phase = -9'd183;\t //LUT[2529] \tphase : -0.714844\t(data_i, data_q): (-0.781250,-0.968750)\n\t2530: o_phase = -9'd185;\t //LUT[2530] \tphase : -0.722656\t(data_i, data_q): (-0.781250,-0.937500)\n\t2531: o_phase = -9'd186;\t //LUT[2531] \tphase : -0.726562\t(data_i, data_q): (-0.781250,-0.906250)\n\t2532: o_phase = -9'd187;\t //LUT[2532] \tphase : -0.730469\t(data_i, data_q): (-0.781250,-0.875000)\n\t2533: o_phase = -9'd189;\t //LUT[2533] \tphase : -0.738281\t(data_i, data_q): (-0.781250,-0.843750)\n\t2534: o_phase = -9'd190;\t //LUT[2534] \tphase : -0.742188\t(data_i, data_q): (-0.781250,-0.812500)\n\t2535: o_phase = -9'd192;\t //LUT[2535] \tphase : -0.750000\t(data_i, data_q): (-0.781250,-0.781250)\n\t2536: o_phase = -9'd194;\t //LUT[2536] \tphase : -0.757812\t(data_i, data_q): (-0.781250,-0.750000)\n\t2537: o_phase = -9'd195;\t //LUT[2537] \tphase : -0.761719\t(data_i, data_q): (-0.781250,-0.718750)\n\t2538: o_phase = -9'd197;\t //LUT[2538] \tphase : -0.769531\t(data_i, data_q): (-0.781250,-0.687500)\n\t2539: o_phase = -9'd199;\t //LUT[2539] \tphase : -0.777344\t(data_i, data_q): (-0.781250,-0.656250)\n\t2540: o_phase = -9'd201;\t //LUT[2540] \tphase : -0.785156\t(data_i, data_q): (-0.781250,-0.625000)\n\t2541: o_phase = -9'd203;\t //LUT[2541] \tphase : -0.792969\t(data_i, data_q): (-0.781250,-0.593750)\n\t2542: o_phase = -9'd205;\t //LUT[2542] \tphase : -0.800781\t(data_i, data_q): (-0.781250,-0.562500)\n\t2543: o_phase = -9'd207;\t //LUT[2543] \tphase : -0.808594\t(data_i, data_q): (-0.781250,-0.531250)\n\t2544: o_phase = -9'd210;\t //LUT[2544] \tphase : -0.820312\t(data_i, data_q): (-0.781250,-0.500000)\n\t2545: o_phase = -9'd212;\t //LUT[2545] \tphase : -0.828125\t(data_i, data_q): (-0.781250,-0.468750)\n\t2546: o_phase = -9'd214;\t //LUT[2546] \tphase : -0.835938\t(data_i, data_q): (-0.781250,-0.437500)\n\t2547: o_phase = -9'd217;\t //LUT[2547] \tphase : -0.847656\t(data_i, data_q): (-0.781250,-0.406250)\n\t2548: o_phase = -9'd220;\t //LUT[2548] \tphase : -0.859375\t(data_i, data_q): (-0.781250,-0.375000)\n\t2549: o_phase = -9'd222;\t //LUT[2549] \tphase : -0.867188\t(data_i, data_q): (-0.781250,-0.343750)\n\t2550: o_phase = -9'd225;\t //LUT[2550] \tphase : -0.878906\t(data_i, data_q): (-0.781250,-0.312500)\n\t2551: o_phase = -9'd228;\t //LUT[2551] \tphase : -0.890625\t(data_i, data_q): (-0.781250,-0.281250)\n\t2552: o_phase = -9'd231;\t //LUT[2552] \tphase : -0.902344\t(data_i, data_q): (-0.781250,-0.250000)\n\t2553: o_phase = -9'd234;\t //LUT[2553] \tphase : -0.914062\t(data_i, data_q): (-0.781250,-0.218750)\n\t2554: o_phase = -9'd237;\t //LUT[2554] \tphase : -0.925781\t(data_i, data_q): (-0.781250,-0.187500)\n\t2555: o_phase = -9'd240;\t //LUT[2555] \tphase : -0.937500\t(data_i, data_q): (-0.781250,-0.156250)\n\t2556: o_phase = -9'd243;\t //LUT[2556] \tphase : -0.949219\t(data_i, data_q): (-0.781250,-0.125000)\n\t2557: o_phase = -9'd246;\t //LUT[2557] \tphase : -0.960938\t(data_i, data_q): (-0.781250,-0.093750)\n\t2558: o_phase = -9'd249;\t //LUT[2558] \tphase : -0.972656\t(data_i, data_q): (-0.781250,-0.062500)\n\t2559: o_phase = -9'd253;\t //LUT[2559] \tphase : -0.988281\t(data_i, data_q): (-0.781250,-0.031250)\n\t2560: o_phase = -9'd256;\t //LUT[2560] \tphase : -1.000000\t(data_i, data_q): (-0.750000,0.000000)\n\t2561: o_phase = +9'd253;\t //LUT[2561] \tphase : 0.988281\t(data_i, data_q): (-0.750000,0.031250)\n\t2562: o_phase = +9'd249;\t //LUT[2562] \tphase : 0.972656\t(data_i, data_q): (-0.750000,0.062500)\n\t2563: o_phase = +9'd246;\t //LUT[2563] \tphase : 0.960938\t(data_i, data_q): (-0.750000,0.093750)\n\t2564: o_phase = +9'd243;\t //LUT[2564] \tphase : 0.949219\t(data_i, data_q): (-0.750000,0.125000)\n\t2565: o_phase = +9'd239;\t //LUT[2565] \tphase : 0.933594\t(data_i, data_q): (-0.750000,0.156250)\n\t2566: o_phase = +9'd236;\t //LUT[2566] \tphase : 0.921875\t(data_i, data_q): (-0.750000,0.187500)\n\t2567: o_phase = +9'd233;\t //LUT[2567] \tphase : 0.910156\t(data_i, data_q): (-0.750000,0.218750)\n\t2568: o_phase = +9'd230;\t //LUT[2568] \tphase : 0.898438\t(data_i, data_q): (-0.750000,0.250000)\n\t2569: o_phase = +9'd227;\t //LUT[2569] \tphase : 0.886719\t(data_i, data_q): (-0.750000,0.281250)\n\t2570: o_phase = +9'd224;\t //LUT[2570] \tphase : 0.875000\t(data_i, data_q): (-0.750000,0.312500)\n\t2571: o_phase = +9'd221;\t //LUT[2571] \tphase : 0.863281\t(data_i, data_q): (-0.750000,0.343750)\n\t2572: o_phase = +9'd218;\t //LUT[2572] \tphase : 0.851562\t(data_i, data_q): (-0.750000,0.375000)\n\t2573: o_phase = +9'd216;\t //LUT[2573] \tphase : 0.843750\t(data_i, data_q): (-0.750000,0.406250)\n\t2574: o_phase = +9'd213;\t //LUT[2574] \tphase : 0.832031\t(data_i, data_q): (-0.750000,0.437500)\n\t2575: o_phase = +9'd210;\t //LUT[2575] \tphase : 0.820312\t(data_i, data_q): (-0.750000,0.468750)\n\t2576: o_phase = +9'd208;\t //LUT[2576] \tphase : 0.812500\t(data_i, data_q): (-0.750000,0.500000)\n\t2577: o_phase = +9'd206;\t //LUT[2577] \tphase : 0.804688\t(data_i, data_q): (-0.750000,0.531250)\n\t2578: o_phase = +9'd204;\t //LUT[2578] \tphase : 0.796875\t(data_i, data_q): (-0.750000,0.562500)\n\t2579: o_phase = +9'd201;\t //LUT[2579] \tphase : 0.785156\t(data_i, data_q): (-0.750000,0.593750)\n\t2580: o_phase = +9'd199;\t //LUT[2580] \tphase : 0.777344\t(data_i, data_q): (-0.750000,0.625000)\n\t2581: o_phase = +9'd197;\t //LUT[2581] \tphase : 0.769531\t(data_i, data_q): (-0.750000,0.656250)\n\t2582: o_phase = +9'd196;\t //LUT[2582] \tphase : 0.765625\t(data_i, data_q): (-0.750000,0.687500)\n\t2583: o_phase = +9'd194;\t //LUT[2583] \tphase : 0.757812\t(data_i, data_q): (-0.750000,0.718750)\n\t2584: o_phase = +9'd192;\t //LUT[2584] \tphase : 0.750000\t(data_i, data_q): (-0.750000,0.750000)\n\t2585: o_phase = +9'd190;\t //LUT[2585] \tphase : 0.742188\t(data_i, data_q): (-0.750000,0.781250)\n\t2586: o_phase = +9'd189;\t //LUT[2586] \tphase : 0.738281\t(data_i, data_q): (-0.750000,0.812500)\n\t2587: o_phase = +9'd187;\t //LUT[2587] \tphase : 0.730469\t(data_i, data_q): (-0.750000,0.843750)\n\t2588: o_phase = +9'd186;\t //LUT[2588] \tphase : 0.726562\t(data_i, data_q): (-0.750000,0.875000)\n\t2589: o_phase = +9'd184;\t //LUT[2589] \tphase : 0.718750\t(data_i, data_q): (-0.750000,0.906250)\n\t2590: o_phase = +9'd183;\t //LUT[2590] \tphase : 0.714844\t(data_i, data_q): (-0.750000,0.937500)\n\t2591: o_phase = +9'd182;\t //LUT[2591] \tphase : 0.710938\t(data_i, data_q): (-0.750000,0.968750)\n\t2592: o_phase = -9'd180;\t //LUT[2592] \tphase : -0.703125\t(data_i, data_q): (-0.750000,-1.000000)\n\t2593: o_phase = -9'd182;\t //LUT[2593] \tphase : -0.710938\t(data_i, data_q): (-0.750000,-0.968750)\n\t2594: o_phase = -9'd183;\t //LUT[2594] \tphase : -0.714844\t(data_i, data_q): (-0.750000,-0.937500)\n\t2595: o_phase = -9'd184;\t //LUT[2595] \tphase : -0.718750\t(data_i, data_q): (-0.750000,-0.906250)\n\t2596: o_phase = -9'd186;\t //LUT[2596] \tphase : -0.726562\t(data_i, data_q): (-0.750000,-0.875000)\n\t2597: o_phase = -9'd187;\t //LUT[2597] \tphase : -0.730469\t(data_i, data_q): (-0.750000,-0.843750)\n\t2598: o_phase = -9'd189;\t //LUT[2598] \tphase : -0.738281\t(data_i, data_q): (-0.750000,-0.812500)\n\t2599: o_phase = -9'd190;\t //LUT[2599] \tphase : -0.742188\t(data_i, data_q): (-0.750000,-0.781250)\n\t2600: o_phase = -9'd192;\t //LUT[2600] \tphase : -0.750000\t(data_i, data_q): (-0.750000,-0.750000)\n\t2601: o_phase = -9'd194;\t //LUT[2601] \tphase : -0.757812\t(data_i, data_q): (-0.750000,-0.718750)\n\t2602: o_phase = -9'd196;\t //LUT[2602] \tphase : -0.765625\t(data_i, data_q): (-0.750000,-0.687500)\n\t2603: o_phase = -9'd197;\t //LUT[2603] \tphase : -0.769531\t(data_i, data_q): (-0.750000,-0.656250)\n\t2604: o_phase = -9'd199;\t //LUT[2604] \tphase : -0.777344\t(data_i, data_q): (-0.750000,-0.625000)\n\t2605: o_phase = -9'd201;\t //LUT[2605] \tphase : -0.785156\t(data_i, data_q): (-0.750000,-0.593750)\n\t2606: o_phase = -9'd204;\t //LUT[2606] \tphase : -0.796875\t(data_i, data_q): (-0.750000,-0.562500)\n\t2607: o_phase = -9'd206;\t //LUT[2607] \tphase : -0.804688\t(data_i, data_q): (-0.750000,-0.531250)\n\t2608: o_phase = -9'd208;\t //LUT[2608] \tphase : -0.812500\t(data_i, data_q): (-0.750000,-0.500000)\n\t2609: o_phase = -9'd210;\t //LUT[2609] \tphase : -0.820312\t(data_i, data_q): (-0.750000,-0.468750)\n\t2610: o_phase = -9'd213;\t //LUT[2610] \tphase : -0.832031\t(data_i, data_q): (-0.750000,-0.437500)\n\t2611: o_phase = -9'd216;\t //LUT[2611] \tphase : -0.843750\t(data_i, data_q): (-0.750000,-0.406250)\n\t2612: o_phase = -9'd218;\t //LUT[2612] \tphase : -0.851562\t(data_i, data_q): (-0.750000,-0.375000)\n\t2613: o_phase = -9'd221;\t //LUT[2613] \tphase : -0.863281\t(data_i, data_q): (-0.750000,-0.343750)\n\t2614: o_phase = -9'd224;\t //LUT[2614] \tphase : -0.875000\t(data_i, data_q): (-0.750000,-0.312500)\n\t2615: o_phase = -9'd227;\t //LUT[2615] \tphase : -0.886719\t(data_i, data_q): (-0.750000,-0.281250)\n\t2616: o_phase = -9'd230;\t //LUT[2616] \tphase : -0.898438\t(data_i, data_q): (-0.750000,-0.250000)\n\t2617: o_phase = -9'd233;\t //LUT[2617] \tphase : -0.910156\t(data_i, data_q): (-0.750000,-0.218750)\n\t2618: o_phase = -9'd236;\t //LUT[2618] \tphase : -0.921875\t(data_i, data_q): (-0.750000,-0.187500)\n\t2619: o_phase = -9'd239;\t //LUT[2619] \tphase : -0.933594\t(data_i, data_q): (-0.750000,-0.156250)\n\t2620: o_phase = -9'd243;\t //LUT[2620] \tphase : -0.949219\t(data_i, data_q): (-0.750000,-0.125000)\n\t2621: o_phase = -9'd246;\t //LUT[2621] \tphase : -0.960938\t(data_i, data_q): (-0.750000,-0.093750)\n\t2622: o_phase = -9'd249;\t //LUT[2622] \tphase : -0.972656\t(data_i, data_q): (-0.750000,-0.062500)\n\t2623: o_phase = -9'd253;\t //LUT[2623] \tphase : -0.988281\t(data_i, data_q): (-0.750000,-0.031250)\n\t2624: o_phase = -9'd256;\t //LUT[2624] \tphase : -1.000000\t(data_i, data_q): (-0.718750,0.000000)\n\t2625: o_phase = +9'd252;\t //LUT[2625] \tphase : 0.984375\t(data_i, data_q): (-0.718750,0.031250)\n\t2626: o_phase = +9'd249;\t //LUT[2626] \tphase : 0.972656\t(data_i, data_q): (-0.718750,0.062500)\n\t2627: o_phase = +9'd245;\t //LUT[2627] \tphase : 0.957031\t(data_i, data_q): (-0.718750,0.093750)\n\t2628: o_phase = +9'd242;\t //LUT[2628] \tphase : 0.945312\t(data_i, data_q): (-0.718750,0.125000)\n\t2629: o_phase = +9'd239;\t //LUT[2629] \tphase : 0.933594\t(data_i, data_q): (-0.718750,0.156250)\n\t2630: o_phase = +9'd235;\t //LUT[2630] \tphase : 0.917969\t(data_i, data_q): (-0.718750,0.187500)\n\t2631: o_phase = +9'd232;\t //LUT[2631] \tphase : 0.906250\t(data_i, data_q): (-0.718750,0.218750)\n\t2632: o_phase = +9'd229;\t //LUT[2632] \tphase : 0.894531\t(data_i, data_q): (-0.718750,0.250000)\n\t2633: o_phase = +9'd226;\t //LUT[2633] \tphase : 0.882812\t(data_i, data_q): (-0.718750,0.281250)\n\t2634: o_phase = +9'd223;\t //LUT[2634] \tphase : 0.871094\t(data_i, data_q): (-0.718750,0.312500)\n\t2635: o_phase = +9'd220;\t //LUT[2635] \tphase : 0.859375\t(data_i, data_q): (-0.718750,0.343750)\n\t2636: o_phase = +9'd217;\t //LUT[2636] \tphase : 0.847656\t(data_i, data_q): (-0.718750,0.375000)\n\t2637: o_phase = +9'd214;\t //LUT[2637] \tphase : 0.835938\t(data_i, data_q): (-0.718750,0.406250)\n\t2638: o_phase = +9'd211;\t //LUT[2638] \tphase : 0.824219\t(data_i, data_q): (-0.718750,0.437500)\n\t2639: o_phase = +9'd209;\t //LUT[2639] \tphase : 0.816406\t(data_i, data_q): (-0.718750,0.468750)\n\t2640: o_phase = +9'd206;\t //LUT[2640] \tphase : 0.804688\t(data_i, data_q): (-0.718750,0.500000)\n\t2641: o_phase = +9'd204;\t //LUT[2641] \tphase : 0.796875\t(data_i, data_q): (-0.718750,0.531250)\n\t2642: o_phase = +9'd202;\t //LUT[2642] \tphase : 0.789062\t(data_i, data_q): (-0.718750,0.562500)\n\t2643: o_phase = +9'd200;\t //LUT[2643] \tphase : 0.781250\t(data_i, data_q): (-0.718750,0.593750)\n\t2644: o_phase = +9'd198;\t //LUT[2644] \tphase : 0.773438\t(data_i, data_q): (-0.718750,0.625000)\n\t2645: o_phase = +9'd196;\t //LUT[2645] \tphase : 0.765625\t(data_i, data_q): (-0.718750,0.656250)\n\t2646: o_phase = +9'd194;\t //LUT[2646] \tphase : 0.757812\t(data_i, data_q): (-0.718750,0.687500)\n\t2647: o_phase = +9'd192;\t //LUT[2647] \tphase : 0.750000\t(data_i, data_q): (-0.718750,0.718750)\n\t2648: o_phase = +9'd190;\t //LUT[2648] \tphase : 0.742188\t(data_i, data_q): (-0.718750,0.750000)\n\t2649: o_phase = +9'd189;\t //LUT[2649] \tphase : 0.738281\t(data_i, data_q): (-0.718750,0.781250)\n\t2650: o_phase = +9'd187;\t //LUT[2650] \tphase : 0.730469\t(data_i, data_q): (-0.718750,0.812500)\n\t2651: o_phase = +9'd185;\t //LUT[2651] \tphase : 0.722656\t(data_i, data_q): (-0.718750,0.843750)\n\t2652: o_phase = +9'd184;\t //LUT[2652] \tphase : 0.718750\t(data_i, data_q): (-0.718750,0.875000)\n\t2653: o_phase = +9'd183;\t //LUT[2653] \tphase : 0.714844\t(data_i, data_q): (-0.718750,0.906250)\n\t2654: o_phase = +9'd181;\t //LUT[2654] \tphase : 0.707031\t(data_i, data_q): (-0.718750,0.937500)\n\t2655: o_phase = +9'd180;\t //LUT[2655] \tphase : 0.703125\t(data_i, data_q): (-0.718750,0.968750)\n\t2656: o_phase = -9'd179;\t //LUT[2656] \tphase : -0.699219\t(data_i, data_q): (-0.718750,-1.000000)\n\t2657: o_phase = -9'd180;\t //LUT[2657] \tphase : -0.703125\t(data_i, data_q): (-0.718750,-0.968750)\n\t2658: o_phase = -9'd181;\t //LUT[2658] \tphase : -0.707031\t(data_i, data_q): (-0.718750,-0.937500)\n\t2659: o_phase = -9'd183;\t //LUT[2659] \tphase : -0.714844\t(data_i, data_q): (-0.718750,-0.906250)\n\t2660: o_phase = -9'd184;\t //LUT[2660] \tphase : -0.718750\t(data_i, data_q): (-0.718750,-0.875000)\n\t2661: o_phase = -9'd185;\t //LUT[2661] \tphase : -0.722656\t(data_i, data_q): (-0.718750,-0.843750)\n\t2662: o_phase = -9'd187;\t //LUT[2662] \tphase : -0.730469\t(data_i, data_q): (-0.718750,-0.812500)\n\t2663: o_phase = -9'd189;\t //LUT[2663] \tphase : -0.738281\t(data_i, data_q): (-0.718750,-0.781250)\n\t2664: o_phase = -9'd190;\t //LUT[2664] \tphase : -0.742188\t(data_i, data_q): (-0.718750,-0.750000)\n\t2665: o_phase = -9'd192;\t //LUT[2665] \tphase : -0.750000\t(data_i, data_q): (-0.718750,-0.718750)\n\t2666: o_phase = -9'd194;\t //LUT[2666] \tphase : -0.757812\t(data_i, data_q): (-0.718750,-0.687500)\n\t2667: o_phase = -9'd196;\t //LUT[2667] \tphase : -0.765625\t(data_i, data_q): (-0.718750,-0.656250)\n\t2668: o_phase = -9'd198;\t //LUT[2668] \tphase : -0.773438\t(data_i, data_q): (-0.718750,-0.625000)\n\t2669: o_phase = -9'd200;\t //LUT[2669] \tphase : -0.781250\t(data_i, data_q): (-0.718750,-0.593750)\n\t2670: o_phase = -9'd202;\t //LUT[2670] \tphase : -0.789062\t(data_i, data_q): (-0.718750,-0.562500)\n\t2671: o_phase = -9'd204;\t //LUT[2671] \tphase : -0.796875\t(data_i, data_q): (-0.718750,-0.531250)\n\t2672: o_phase = -9'd206;\t //LUT[2672] \tphase : -0.804688\t(data_i, data_q): (-0.718750,-0.500000)\n\t2673: o_phase = -9'd209;\t //LUT[2673] \tphase : -0.816406\t(data_i, data_q): (-0.718750,-0.468750)\n\t2674: o_phase = -9'd211;\t //LUT[2674] \tphase : -0.824219\t(data_i, data_q): (-0.718750,-0.437500)\n\t2675: o_phase = -9'd214;\t //LUT[2675] \tphase : -0.835938\t(data_i, data_q): (-0.718750,-0.406250)\n\t2676: o_phase = -9'd217;\t //LUT[2676] \tphase : -0.847656\t(data_i, data_q): (-0.718750,-0.375000)\n\t2677: o_phase = -9'd220;\t //LUT[2677] \tphase : -0.859375\t(data_i, data_q): (-0.718750,-0.343750)\n\t2678: o_phase = -9'd223;\t //LUT[2678] \tphase : -0.871094\t(data_i, data_q): (-0.718750,-0.312500)\n\t2679: o_phase = -9'd226;\t //LUT[2679] \tphase : -0.882812\t(data_i, data_q): (-0.718750,-0.281250)\n\t2680: o_phase = -9'd229;\t //LUT[2680] \tphase : -0.894531\t(data_i, data_q): (-0.718750,-0.250000)\n\t2681: o_phase = -9'd232;\t //LUT[2681] \tphase : -0.906250\t(data_i, data_q): (-0.718750,-0.218750)\n\t2682: o_phase = -9'd235;\t //LUT[2682] \tphase : -0.917969\t(data_i, data_q): (-0.718750,-0.187500)\n\t2683: o_phase = -9'd239;\t //LUT[2683] \tphase : -0.933594\t(data_i, data_q): (-0.718750,-0.156250)\n\t2684: o_phase = -9'd242;\t //LUT[2684] \tphase : -0.945312\t(data_i, data_q): (-0.718750,-0.125000)\n\t2685: o_phase = -9'd245;\t //LUT[2685] \tphase : -0.957031\t(data_i, data_q): (-0.718750,-0.093750)\n\t2686: o_phase = -9'd249;\t //LUT[2686] \tphase : -0.972656\t(data_i, data_q): (-0.718750,-0.062500)\n\t2687: o_phase = -9'd252;\t //LUT[2687] \tphase : -0.984375\t(data_i, data_q): (-0.718750,-0.031250)\n\t2688: o_phase = -9'd256;\t //LUT[2688] \tphase : -1.000000\t(data_i, data_q): (-0.687500,0.000000)\n\t2689: o_phase = +9'd252;\t //LUT[2689] \tphase : 0.984375\t(data_i, data_q): (-0.687500,0.031250)\n\t2690: o_phase = +9'd249;\t //LUT[2690] \tphase : 0.972656\t(data_i, data_q): (-0.687500,0.062500)\n\t2691: o_phase = +9'd245;\t //LUT[2691] \tphase : 0.957031\t(data_i, data_q): (-0.687500,0.093750)\n\t2692: o_phase = +9'd241;\t //LUT[2692] \tphase : 0.941406\t(data_i, data_q): (-0.687500,0.125000)\n\t2693: o_phase = +9'd238;\t //LUT[2693] \tphase : 0.929688\t(data_i, data_q): (-0.687500,0.156250)\n\t2694: o_phase = +9'd234;\t //LUT[2694] \tphase : 0.914062\t(data_i, data_q): (-0.687500,0.187500)\n\t2695: o_phase = +9'd231;\t //LUT[2695] \tphase : 0.902344\t(data_i, data_q): (-0.687500,0.218750)\n\t2696: o_phase = +9'd228;\t //LUT[2696] \tphase : 0.890625\t(data_i, data_q): (-0.687500,0.250000)\n\t2697: o_phase = +9'd224;\t //LUT[2697] \tphase : 0.875000\t(data_i, data_q): (-0.687500,0.281250)\n\t2698: o_phase = +9'd221;\t //LUT[2698] \tphase : 0.863281\t(data_i, data_q): (-0.687500,0.312500)\n\t2699: o_phase = +9'd218;\t //LUT[2699] \tphase : 0.851562\t(data_i, data_q): (-0.687500,0.343750)\n\t2700: o_phase = +9'd215;\t //LUT[2700] \tphase : 0.839844\t(data_i, data_q): (-0.687500,0.375000)\n\t2701: o_phase = +9'd213;\t //LUT[2701] \tphase : 0.832031\t(data_i, data_q): (-0.687500,0.406250)\n\t2702: o_phase = +9'd210;\t //LUT[2702] \tphase : 0.820312\t(data_i, data_q): (-0.687500,0.437500)\n\t2703: o_phase = +9'd207;\t //LUT[2703] \tphase : 0.808594\t(data_i, data_q): (-0.687500,0.468750)\n\t2704: o_phase = +9'd205;\t //LUT[2704] \tphase : 0.800781\t(data_i, data_q): (-0.687500,0.500000)\n\t2705: o_phase = +9'd202;\t //LUT[2705] \tphase : 0.789062\t(data_i, data_q): (-0.687500,0.531250)\n\t2706: o_phase = +9'd200;\t //LUT[2706] \tphase : 0.781250\t(data_i, data_q): (-0.687500,0.562500)\n\t2707: o_phase = +9'd198;\t //LUT[2707] \tphase : 0.773438\t(data_i, data_q): (-0.687500,0.593750)\n\t2708: o_phase = +9'd196;\t //LUT[2708] \tphase : 0.765625\t(data_i, data_q): (-0.687500,0.625000)\n\t2709: o_phase = +9'd194;\t //LUT[2709] \tphase : 0.757812\t(data_i, data_q): (-0.687500,0.656250)\n\t2710: o_phase = +9'd192;\t //LUT[2710] \tphase : 0.750000\t(data_i, data_q): (-0.687500,0.687500)\n\t2711: o_phase = +9'd190;\t //LUT[2711] \tphase : 0.742188\t(data_i, data_q): (-0.687500,0.718750)\n\t2712: o_phase = +9'd188;\t //LUT[2712] \tphase : 0.734375\t(data_i, data_q): (-0.687500,0.750000)\n\t2713: o_phase = +9'd187;\t //LUT[2713] \tphase : 0.730469\t(data_i, data_q): (-0.687500,0.781250)\n\t2714: o_phase = +9'd185;\t //LUT[2714] \tphase : 0.722656\t(data_i, data_q): (-0.687500,0.812500)\n\t2715: o_phase = +9'd184;\t //LUT[2715] \tphase : 0.718750\t(data_i, data_q): (-0.687500,0.843750)\n\t2716: o_phase = +9'd182;\t //LUT[2716] \tphase : 0.710938\t(data_i, data_q): (-0.687500,0.875000)\n\t2717: o_phase = +9'd181;\t //LUT[2717] \tphase : 0.707031\t(data_i, data_q): (-0.687500,0.906250)\n\t2718: o_phase = +9'd180;\t //LUT[2718] \tphase : 0.703125\t(data_i, data_q): (-0.687500,0.937500)\n\t2719: o_phase = +9'd178;\t //LUT[2719] \tphase : 0.695312\t(data_i, data_q): (-0.687500,0.968750)\n\t2720: o_phase = -9'd177;\t //LUT[2720] \tphase : -0.691406\t(data_i, data_q): (-0.687500,-1.000000)\n\t2721: o_phase = -9'd178;\t //LUT[2721] \tphase : -0.695312\t(data_i, data_q): (-0.687500,-0.968750)\n\t2722: o_phase = -9'd180;\t //LUT[2722] \tphase : -0.703125\t(data_i, data_q): (-0.687500,-0.937500)\n\t2723: o_phase = -9'd181;\t //LUT[2723] \tphase : -0.707031\t(data_i, data_q): (-0.687500,-0.906250)\n\t2724: o_phase = -9'd182;\t //LUT[2724] \tphase : -0.710938\t(data_i, data_q): (-0.687500,-0.875000)\n\t2725: o_phase = -9'd184;\t //LUT[2725] \tphase : -0.718750\t(data_i, data_q): (-0.687500,-0.843750)\n\t2726: o_phase = -9'd185;\t //LUT[2726] \tphase : -0.722656\t(data_i, data_q): (-0.687500,-0.812500)\n\t2727: o_phase = -9'd187;\t //LUT[2727] \tphase : -0.730469\t(data_i, data_q): (-0.687500,-0.781250)\n\t2728: o_phase = -9'd188;\t //LUT[2728] \tphase : -0.734375\t(data_i, data_q): (-0.687500,-0.750000)\n\t2729: o_phase = -9'd190;\t //LUT[2729] \tphase : -0.742188\t(data_i, data_q): (-0.687500,-0.718750)\n\t2730: o_phase = -9'd192;\t //LUT[2730] \tphase : -0.750000\t(data_i, data_q): (-0.687500,-0.687500)\n\t2731: o_phase = -9'd194;\t //LUT[2731] \tphase : -0.757812\t(data_i, data_q): (-0.687500,-0.656250)\n\t2732: o_phase = -9'd196;\t //LUT[2732] \tphase : -0.765625\t(data_i, data_q): (-0.687500,-0.625000)\n\t2733: o_phase = -9'd198;\t //LUT[2733] \tphase : -0.773438\t(data_i, data_q): (-0.687500,-0.593750)\n\t2734: o_phase = -9'd200;\t //LUT[2734] \tphase : -0.781250\t(data_i, data_q): (-0.687500,-0.562500)\n\t2735: o_phase = -9'd202;\t //LUT[2735] \tphase : -0.789062\t(data_i, data_q): (-0.687500,-0.531250)\n\t2736: o_phase = -9'd205;\t //LUT[2736] \tphase : -0.800781\t(data_i, data_q): (-0.687500,-0.500000)\n\t2737: o_phase = -9'd207;\t //LUT[2737] \tphase : -0.808594\t(data_i, data_q): (-0.687500,-0.468750)\n\t2738: o_phase = -9'd210;\t //LUT[2738] \tphase : -0.820312\t(data_i, data_q): (-0.687500,-0.437500)\n\t2739: o_phase = -9'd213;\t //LUT[2739] \tphase : -0.832031\t(data_i, data_q): (-0.687500,-0.406250)\n\t2740: o_phase = -9'd215;\t //LUT[2740] \tphase : -0.839844\t(data_i, data_q): (-0.687500,-0.375000)\n\t2741: o_phase = -9'd218;\t //LUT[2741] \tphase : -0.851562\t(data_i, data_q): (-0.687500,-0.343750)\n\t2742: o_phase = -9'd221;\t //LUT[2742] \tphase : -0.863281\t(data_i, data_q): (-0.687500,-0.312500)\n\t2743: o_phase = -9'd224;\t //LUT[2743] \tphase : -0.875000\t(data_i, data_q): (-0.687500,-0.281250)\n\t2744: o_phase = -9'd228;\t //LUT[2744] \tphase : -0.890625\t(data_i, data_q): (-0.687500,-0.250000)\n\t2745: o_phase = -9'd231;\t //LUT[2745] \tphase : -0.902344\t(data_i, data_q): (-0.687500,-0.218750)\n\t2746: o_phase = -9'd234;\t //LUT[2746] \tphase : -0.914062\t(data_i, data_q): (-0.687500,-0.187500)\n\t2747: o_phase = -9'd238;\t //LUT[2747] \tphase : -0.929688\t(data_i, data_q): (-0.687500,-0.156250)\n\t2748: o_phase = -9'd241;\t //LUT[2748] \tphase : -0.941406\t(data_i, data_q): (-0.687500,-0.125000)\n\t2749: o_phase = -9'd245;\t //LUT[2749] \tphase : -0.957031\t(data_i, data_q): (-0.687500,-0.093750)\n\t2750: o_phase = -9'd249;\t //LUT[2750] \tphase : -0.972656\t(data_i, data_q): (-0.687500,-0.062500)\n\t2751: o_phase = -9'd252;\t //LUT[2751] \tphase : -0.984375\t(data_i, data_q): (-0.687500,-0.031250)\n\t2752: o_phase = -9'd256;\t //LUT[2752] \tphase : -1.000000\t(data_i, data_q): (-0.656250,0.000000)\n\t2753: o_phase = +9'd252;\t //LUT[2753] \tphase : 0.984375\t(data_i, data_q): (-0.656250,0.031250)\n\t2754: o_phase = +9'd248;\t //LUT[2754] \tphase : 0.968750\t(data_i, data_q): (-0.656250,0.062500)\n\t2755: o_phase = +9'd244;\t //LUT[2755] \tphase : 0.953125\t(data_i, data_q): (-0.656250,0.093750)\n\t2756: o_phase = +9'd241;\t //LUT[2756] \tphase : 0.941406\t(data_i, data_q): (-0.656250,0.125000)\n\t2757: o_phase = +9'd237;\t //LUT[2757] \tphase : 0.925781\t(data_i, data_q): (-0.656250,0.156250)\n\t2758: o_phase = +9'd233;\t //LUT[2758] \tphase : 0.910156\t(data_i, data_q): (-0.656250,0.187500)\n\t2759: o_phase = +9'd230;\t //LUT[2759] \tphase : 0.898438\t(data_i, data_q): (-0.656250,0.218750)\n\t2760: o_phase = +9'd226;\t //LUT[2760] \tphase : 0.882812\t(data_i, data_q): (-0.656250,0.250000)\n\t2761: o_phase = +9'd223;\t //LUT[2761] \tphase : 0.871094\t(data_i, data_q): (-0.656250,0.281250)\n\t2762: o_phase = +9'd220;\t //LUT[2762] \tphase : 0.859375\t(data_i, data_q): (-0.656250,0.312500)\n\t2763: o_phase = +9'd217;\t //LUT[2763] \tphase : 0.847656\t(data_i, data_q): (-0.656250,0.343750)\n\t2764: o_phase = +9'd214;\t //LUT[2764] \tphase : 0.835938\t(data_i, data_q): (-0.656250,0.375000)\n\t2765: o_phase = +9'd211;\t //LUT[2765] \tphase : 0.824219\t(data_i, data_q): (-0.656250,0.406250)\n\t2766: o_phase = +9'd208;\t //LUT[2766] \tphase : 0.812500\t(data_i, data_q): (-0.656250,0.437500)\n\t2767: o_phase = +9'd205;\t //LUT[2767] \tphase : 0.800781\t(data_i, data_q): (-0.656250,0.468750)\n\t2768: o_phase = +9'd203;\t //LUT[2768] \tphase : 0.792969\t(data_i, data_q): (-0.656250,0.500000)\n\t2769: o_phase = +9'd201;\t //LUT[2769] \tphase : 0.785156\t(data_i, data_q): (-0.656250,0.531250)\n\t2770: o_phase = +9'd198;\t //LUT[2770] \tphase : 0.773438\t(data_i, data_q): (-0.656250,0.562500)\n\t2771: o_phase = +9'd196;\t //LUT[2771] \tphase : 0.765625\t(data_i, data_q): (-0.656250,0.593750)\n\t2772: o_phase = +9'd194;\t //LUT[2772] \tphase : 0.757812\t(data_i, data_q): (-0.656250,0.625000)\n\t2773: o_phase = +9'd192;\t //LUT[2773] \tphase : 0.750000\t(data_i, data_q): (-0.656250,0.656250)\n\t2774: o_phase = +9'd190;\t //LUT[2774] \tphase : 0.742188\t(data_i, data_q): (-0.656250,0.687500)\n\t2775: o_phase = +9'd188;\t //LUT[2775] \tphase : 0.734375\t(data_i, data_q): (-0.656250,0.718750)\n\t2776: o_phase = +9'd187;\t //LUT[2776] \tphase : 0.730469\t(data_i, data_q): (-0.656250,0.750000)\n\t2777: o_phase = +9'd185;\t //LUT[2777] \tphase : 0.722656\t(data_i, data_q): (-0.656250,0.781250)\n\t2778: o_phase = +9'd183;\t //LUT[2778] \tphase : 0.714844\t(data_i, data_q): (-0.656250,0.812500)\n\t2779: o_phase = +9'd182;\t //LUT[2779] \tphase : 0.710938\t(data_i, data_q): (-0.656250,0.843750)\n\t2780: o_phase = +9'd180;\t //LUT[2780] \tphase : 0.703125\t(data_i, data_q): (-0.656250,0.875000)\n\t2781: o_phase = +9'd179;\t //LUT[2781] \tphase : 0.699219\t(data_i, data_q): (-0.656250,0.906250)\n\t2782: o_phase = +9'd178;\t //LUT[2782] \tphase : 0.695312\t(data_i, data_q): (-0.656250,0.937500)\n\t2783: o_phase = +9'd177;\t //LUT[2783] \tphase : 0.691406\t(data_i, data_q): (-0.656250,0.968750)\n\t2784: o_phase = -9'd175;\t //LUT[2784] \tphase : -0.683594\t(data_i, data_q): (-0.656250,-1.000000)\n\t2785: o_phase = -9'd177;\t //LUT[2785] \tphase : -0.691406\t(data_i, data_q): (-0.656250,-0.968750)\n\t2786: o_phase = -9'd178;\t //LUT[2786] \tphase : -0.695312\t(data_i, data_q): (-0.656250,-0.937500)\n\t2787: o_phase = -9'd179;\t //LUT[2787] \tphase : -0.699219\t(data_i, data_q): (-0.656250,-0.906250)\n\t2788: o_phase = -9'd180;\t //LUT[2788] \tphase : -0.703125\t(data_i, data_q): (-0.656250,-0.875000)\n\t2789: o_phase = -9'd182;\t //LUT[2789] \tphase : -0.710938\t(data_i, data_q): (-0.656250,-0.843750)\n\t2790: o_phase = -9'd183;\t //LUT[2790] \tphase : -0.714844\t(data_i, data_q): (-0.656250,-0.812500)\n\t2791: o_phase = -9'd185;\t //LUT[2791] \tphase : -0.722656\t(data_i, data_q): (-0.656250,-0.781250)\n\t2792: o_phase = -9'd187;\t //LUT[2792] \tphase : -0.730469\t(data_i, data_q): (-0.656250,-0.750000)\n\t2793: o_phase = -9'd188;\t //LUT[2793] \tphase : -0.734375\t(data_i, data_q): (-0.656250,-0.718750)\n\t2794: o_phase = -9'd190;\t //LUT[2794] \tphase : -0.742188\t(data_i, data_q): (-0.656250,-0.687500)\n\t2795: o_phase = -9'd192;\t //LUT[2795] \tphase : -0.750000\t(data_i, data_q): (-0.656250,-0.656250)\n\t2796: o_phase = -9'd194;\t //LUT[2796] \tphase : -0.757812\t(data_i, data_q): (-0.656250,-0.625000)\n\t2797: o_phase = -9'd196;\t //LUT[2797] \tphase : -0.765625\t(data_i, data_q): (-0.656250,-0.593750)\n\t2798: o_phase = -9'd198;\t //LUT[2798] \tphase : -0.773438\t(data_i, data_q): (-0.656250,-0.562500)\n\t2799: o_phase = -9'd201;\t //LUT[2799] \tphase : -0.785156\t(data_i, data_q): (-0.656250,-0.531250)\n\t2800: o_phase = -9'd203;\t //LUT[2800] \tphase : -0.792969\t(data_i, data_q): (-0.656250,-0.500000)\n\t2801: o_phase = -9'd205;\t //LUT[2801] \tphase : -0.800781\t(data_i, data_q): (-0.656250,-0.468750)\n\t2802: o_phase = -9'd208;\t //LUT[2802] \tphase : -0.812500\t(data_i, data_q): (-0.656250,-0.437500)\n\t2803: o_phase = -9'd211;\t //LUT[2803] \tphase : -0.824219\t(data_i, data_q): (-0.656250,-0.406250)\n\t2804: o_phase = -9'd214;\t //LUT[2804] \tphase : -0.835938\t(data_i, data_q): (-0.656250,-0.375000)\n\t2805: o_phase = -9'd217;\t //LUT[2805] \tphase : -0.847656\t(data_i, data_q): (-0.656250,-0.343750)\n\t2806: o_phase = -9'd220;\t //LUT[2806] \tphase : -0.859375\t(data_i, data_q): (-0.656250,-0.312500)\n\t2807: o_phase = -9'd223;\t //LUT[2807] \tphase : -0.871094\t(data_i, data_q): (-0.656250,-0.281250)\n\t2808: o_phase = -9'd226;\t //LUT[2808] \tphase : -0.882812\t(data_i, data_q): (-0.656250,-0.250000)\n\t2809: o_phase = -9'd230;\t //LUT[2809] \tphase : -0.898438\t(data_i, data_q): (-0.656250,-0.218750)\n\t2810: o_phase = -9'd233;\t //LUT[2810] \tphase : -0.910156\t(data_i, data_q): (-0.656250,-0.187500)\n\t2811: o_phase = -9'd237;\t //LUT[2811] \tphase : -0.925781\t(data_i, data_q): (-0.656250,-0.156250)\n\t2812: o_phase = -9'd241;\t //LUT[2812] \tphase : -0.941406\t(data_i, data_q): (-0.656250,-0.125000)\n\t2813: o_phase = -9'd244;\t //LUT[2813] \tphase : -0.953125\t(data_i, data_q): (-0.656250,-0.093750)\n\t2814: o_phase = -9'd248;\t //LUT[2814] \tphase : -0.968750\t(data_i, data_q): (-0.656250,-0.062500)\n\t2815: o_phase = -9'd252;\t //LUT[2815] \tphase : -0.984375\t(data_i, data_q): (-0.656250,-0.031250)\n\t2816: o_phase = -9'd256;\t //LUT[2816] \tphase : -1.000000\t(data_i, data_q): (-0.625000,0.000000)\n\t2817: o_phase = +9'd252;\t //LUT[2817] \tphase : 0.984375\t(data_i, data_q): (-0.625000,0.031250)\n\t2818: o_phase = +9'd248;\t //LUT[2818] \tphase : 0.968750\t(data_i, data_q): (-0.625000,0.062500)\n\t2819: o_phase = +9'd244;\t //LUT[2819] \tphase : 0.953125\t(data_i, data_q): (-0.625000,0.093750)\n\t2820: o_phase = +9'd240;\t //LUT[2820] \tphase : 0.937500\t(data_i, data_q): (-0.625000,0.125000)\n\t2821: o_phase = +9'd236;\t //LUT[2821] \tphase : 0.921875\t(data_i, data_q): (-0.625000,0.156250)\n\t2822: o_phase = +9'd232;\t //LUT[2822] \tphase : 0.906250\t(data_i, data_q): (-0.625000,0.187500)\n\t2823: o_phase = +9'd229;\t //LUT[2823] \tphase : 0.894531\t(data_i, data_q): (-0.625000,0.218750)\n\t2824: o_phase = +9'd225;\t //LUT[2824] \tphase : 0.878906\t(data_i, data_q): (-0.625000,0.250000)\n\t2825: o_phase = +9'd222;\t //LUT[2825] \tphase : 0.867188\t(data_i, data_q): (-0.625000,0.281250)\n\t2826: o_phase = +9'd218;\t //LUT[2826] \tphase : 0.851562\t(data_i, data_q): (-0.625000,0.312500)\n\t2827: o_phase = +9'd215;\t //LUT[2827] \tphase : 0.839844\t(data_i, data_q): (-0.625000,0.343750)\n\t2828: o_phase = +9'd212;\t //LUT[2828] \tphase : 0.828125\t(data_i, data_q): (-0.625000,0.375000)\n\t2829: o_phase = +9'd209;\t //LUT[2829] \tphase : 0.816406\t(data_i, data_q): (-0.625000,0.406250)\n\t2830: o_phase = +9'd206;\t //LUT[2830] \tphase : 0.804688\t(data_i, data_q): (-0.625000,0.437500)\n\t2831: o_phase = +9'd204;\t //LUT[2831] \tphase : 0.796875\t(data_i, data_q): (-0.625000,0.468750)\n\t2832: o_phase = +9'd201;\t //LUT[2832] \tphase : 0.785156\t(data_i, data_q): (-0.625000,0.500000)\n\t2833: o_phase = +9'd199;\t //LUT[2833] \tphase : 0.777344\t(data_i, data_q): (-0.625000,0.531250)\n\t2834: o_phase = +9'd196;\t //LUT[2834] \tphase : 0.765625\t(data_i, data_q): (-0.625000,0.562500)\n\t2835: o_phase = +9'd194;\t //LUT[2835] \tphase : 0.757812\t(data_i, data_q): (-0.625000,0.593750)\n\t2836: o_phase = +9'd192;\t //LUT[2836] \tphase : 0.750000\t(data_i, data_q): (-0.625000,0.625000)\n\t2837: o_phase = +9'd190;\t //LUT[2837] \tphase : 0.742188\t(data_i, data_q): (-0.625000,0.656250)\n\t2838: o_phase = +9'd188;\t //LUT[2838] \tphase : 0.734375\t(data_i, data_q): (-0.625000,0.687500)\n\t2839: o_phase = +9'd186;\t //LUT[2839] \tphase : 0.726562\t(data_i, data_q): (-0.625000,0.718750)\n\t2840: o_phase = +9'd185;\t //LUT[2840] \tphase : 0.722656\t(data_i, data_q): (-0.625000,0.750000)\n\t2841: o_phase = +9'd183;\t //LUT[2841] \tphase : 0.714844\t(data_i, data_q): (-0.625000,0.781250)\n\t2842: o_phase = +9'd181;\t //LUT[2842] \tphase : 0.707031\t(data_i, data_q): (-0.625000,0.812500)\n\t2843: o_phase = +9'd180;\t //LUT[2843] \tphase : 0.703125\t(data_i, data_q): (-0.625000,0.843750)\n\t2844: o_phase = +9'd179;\t //LUT[2844] \tphase : 0.699219\t(data_i, data_q): (-0.625000,0.875000)\n\t2845: o_phase = +9'd177;\t //LUT[2845] \tphase : 0.691406\t(data_i, data_q): (-0.625000,0.906250)\n\t2846: o_phase = +9'd176;\t //LUT[2846] \tphase : 0.687500\t(data_i, data_q): (-0.625000,0.937500)\n\t2847: o_phase = +9'd175;\t //LUT[2847] \tphase : 0.683594\t(data_i, data_q): (-0.625000,0.968750)\n\t2848: o_phase = -9'd174;\t //LUT[2848] \tphase : -0.679688\t(data_i, data_q): (-0.625000,-1.000000)\n\t2849: o_phase = -9'd175;\t //LUT[2849] \tphase : -0.683594\t(data_i, data_q): (-0.625000,-0.968750)\n\t2850: o_phase = -9'd176;\t //LUT[2850] \tphase : -0.687500\t(data_i, data_q): (-0.625000,-0.937500)\n\t2851: o_phase = -9'd177;\t //LUT[2851] \tphase : -0.691406\t(data_i, data_q): (-0.625000,-0.906250)\n\t2852: o_phase = -9'd179;\t //LUT[2852] \tphase : -0.699219\t(data_i, data_q): (-0.625000,-0.875000)\n\t2853: o_phase = -9'd180;\t //LUT[2853] \tphase : -0.703125\t(data_i, data_q): (-0.625000,-0.843750)\n\t2854: o_phase = -9'd181;\t //LUT[2854] \tphase : -0.707031\t(data_i, data_q): (-0.625000,-0.812500)\n\t2855: o_phase = -9'd183;\t //LUT[2855] \tphase : -0.714844\t(data_i, data_q): (-0.625000,-0.781250)\n\t2856: o_phase = -9'd185;\t //LUT[2856] \tphase : -0.722656\t(data_i, data_q): (-0.625000,-0.750000)\n\t2857: o_phase = -9'd186;\t //LUT[2857] \tphase : -0.726562\t(data_i, data_q): (-0.625000,-0.718750)\n\t2858: o_phase = -9'd188;\t //LUT[2858] \tphase : -0.734375\t(data_i, data_q): (-0.625000,-0.687500)\n\t2859: o_phase = -9'd190;\t //LUT[2859] \tphase : -0.742188\t(data_i, data_q): (-0.625000,-0.656250)\n\t2860: o_phase = -9'd192;\t //LUT[2860] \tphase : -0.750000\t(data_i, data_q): (-0.625000,-0.625000)\n\t2861: o_phase = -9'd194;\t //LUT[2861] \tphase : -0.757812\t(data_i, data_q): (-0.625000,-0.593750)\n\t2862: o_phase = -9'd196;\t //LUT[2862] \tphase : -0.765625\t(data_i, data_q): (-0.625000,-0.562500)\n\t2863: o_phase = -9'd199;\t //LUT[2863] \tphase : -0.777344\t(data_i, data_q): (-0.625000,-0.531250)\n\t2864: o_phase = -9'd201;\t //LUT[2864] \tphase : -0.785156\t(data_i, data_q): (-0.625000,-0.500000)\n\t2865: o_phase = -9'd204;\t //LUT[2865] \tphase : -0.796875\t(data_i, data_q): (-0.625000,-0.468750)\n\t2866: o_phase = -9'd206;\t //LUT[2866] \tphase : -0.804688\t(data_i, data_q): (-0.625000,-0.437500)\n\t2867: o_phase = -9'd209;\t //LUT[2867] \tphase : -0.816406\t(data_i, data_q): (-0.625000,-0.406250)\n\t2868: o_phase = -9'd212;\t //LUT[2868] \tphase : -0.828125\t(data_i, data_q): (-0.625000,-0.375000)\n\t2869: o_phase = -9'd215;\t //LUT[2869] \tphase : -0.839844\t(data_i, data_q): (-0.625000,-0.343750)\n\t2870: o_phase = -9'd218;\t //LUT[2870] \tphase : -0.851562\t(data_i, data_q): (-0.625000,-0.312500)\n\t2871: o_phase = -9'd222;\t //LUT[2871] \tphase : -0.867188\t(data_i, data_q): (-0.625000,-0.281250)\n\t2872: o_phase = -9'd225;\t //LUT[2872] \tphase : -0.878906\t(data_i, data_q): (-0.625000,-0.250000)\n\t2873: o_phase = -9'd229;\t //LUT[2873] \tphase : -0.894531\t(data_i, data_q): (-0.625000,-0.218750)\n\t2874: o_phase = -9'd232;\t //LUT[2874] \tphase : -0.906250\t(data_i, data_q): (-0.625000,-0.187500)\n\t2875: o_phase = -9'd236;\t //LUT[2875] \tphase : -0.921875\t(data_i, data_q): (-0.625000,-0.156250)\n\t2876: o_phase = -9'd240;\t //LUT[2876] \tphase : -0.937500\t(data_i, data_q): (-0.625000,-0.125000)\n\t2877: o_phase = -9'd244;\t //LUT[2877] \tphase : -0.953125\t(data_i, data_q): (-0.625000,-0.093750)\n\t2878: o_phase = -9'd248;\t //LUT[2878] \tphase : -0.968750\t(data_i, data_q): (-0.625000,-0.062500)\n\t2879: o_phase = -9'd252;\t //LUT[2879] \tphase : -0.984375\t(data_i, data_q): (-0.625000,-0.031250)\n\t2880: o_phase = -9'd256;\t //LUT[2880] \tphase : -1.000000\t(data_i, data_q): (-0.593750,0.000000)\n\t2881: o_phase = +9'd252;\t //LUT[2881] \tphase : 0.984375\t(data_i, data_q): (-0.593750,0.031250)\n\t2882: o_phase = +9'd247;\t //LUT[2882] \tphase : 0.964844\t(data_i, data_q): (-0.593750,0.062500)\n\t2883: o_phase = +9'd243;\t //LUT[2883] \tphase : 0.949219\t(data_i, data_q): (-0.593750,0.093750)\n\t2884: o_phase = +9'd239;\t //LUT[2884] \tphase : 0.933594\t(data_i, data_q): (-0.593750,0.125000)\n\t2885: o_phase = +9'd235;\t //LUT[2885] \tphase : 0.917969\t(data_i, data_q): (-0.593750,0.156250)\n\t2886: o_phase = +9'd231;\t //LUT[2886] \tphase : 0.902344\t(data_i, data_q): (-0.593750,0.187500)\n\t2887: o_phase = +9'd227;\t //LUT[2887] \tphase : 0.886719\t(data_i, data_q): (-0.593750,0.218750)\n\t2888: o_phase = +9'd224;\t //LUT[2888] \tphase : 0.875000\t(data_i, data_q): (-0.593750,0.250000)\n\t2889: o_phase = +9'd220;\t //LUT[2889] \tphase : 0.859375\t(data_i, data_q): (-0.593750,0.281250)\n\t2890: o_phase = +9'd217;\t //LUT[2890] \tphase : 0.847656\t(data_i, data_q): (-0.593750,0.312500)\n\t2891: o_phase = +9'd213;\t //LUT[2891] \tphase : 0.832031\t(data_i, data_q): (-0.593750,0.343750)\n\t2892: o_phase = +9'd210;\t //LUT[2892] \tphase : 0.820312\t(data_i, data_q): (-0.593750,0.375000)\n\t2893: o_phase = +9'd207;\t //LUT[2893] \tphase : 0.808594\t(data_i, data_q): (-0.593750,0.406250)\n\t2894: o_phase = +9'd204;\t //LUT[2894] \tphase : 0.796875\t(data_i, data_q): (-0.593750,0.437500)\n\t2895: o_phase = +9'd202;\t //LUT[2895] \tphase : 0.789062\t(data_i, data_q): (-0.593750,0.468750)\n\t2896: o_phase = +9'd199;\t //LUT[2896] \tphase : 0.777344\t(data_i, data_q): (-0.593750,0.500000)\n\t2897: o_phase = +9'd197;\t //LUT[2897] \tphase : 0.769531\t(data_i, data_q): (-0.593750,0.531250)\n\t2898: o_phase = +9'd194;\t //LUT[2898] \tphase : 0.757812\t(data_i, data_q): (-0.593750,0.562500)\n\t2899: o_phase = +9'd192;\t //LUT[2899] \tphase : 0.750000\t(data_i, data_q): (-0.593750,0.593750)\n\t2900: o_phase = +9'd190;\t //LUT[2900] \tphase : 0.742188\t(data_i, data_q): (-0.593750,0.625000)\n\t2901: o_phase = +9'd188;\t //LUT[2901] \tphase : 0.734375\t(data_i, data_q): (-0.593750,0.656250)\n\t2902: o_phase = +9'd186;\t //LUT[2902] \tphase : 0.726562\t(data_i, data_q): (-0.593750,0.687500)\n\t2903: o_phase = +9'd184;\t //LUT[2903] \tphase : 0.718750\t(data_i, data_q): (-0.593750,0.718750)\n\t2904: o_phase = +9'd183;\t //LUT[2904] \tphase : 0.714844\t(data_i, data_q): (-0.593750,0.750000)\n\t2905: o_phase = +9'd181;\t //LUT[2905] \tphase : 0.707031\t(data_i, data_q): (-0.593750,0.781250)\n\t2906: o_phase = +9'd179;\t //LUT[2906] \tphase : 0.699219\t(data_i, data_q): (-0.593750,0.812500)\n\t2907: o_phase = +9'd178;\t //LUT[2907] \tphase : 0.695312\t(data_i, data_q): (-0.593750,0.843750)\n\t2908: o_phase = +9'd177;\t //LUT[2908] \tphase : 0.691406\t(data_i, data_q): (-0.593750,0.875000)\n\t2909: o_phase = +9'd175;\t //LUT[2909] \tphase : 0.683594\t(data_i, data_q): (-0.593750,0.906250)\n\t2910: o_phase = +9'd174;\t //LUT[2910] \tphase : 0.679688\t(data_i, data_q): (-0.593750,0.937500)\n\t2911: o_phase = +9'd173;\t //LUT[2911] \tphase : 0.675781\t(data_i, data_q): (-0.593750,0.968750)\n\t2912: o_phase = -9'd172;\t //LUT[2912] \tphase : -0.671875\t(data_i, data_q): (-0.593750,-1.000000)\n\t2913: o_phase = -9'd173;\t //LUT[2913] \tphase : -0.675781\t(data_i, data_q): (-0.593750,-0.968750)\n\t2914: o_phase = -9'd174;\t //LUT[2914] \tphase : -0.679688\t(data_i, data_q): (-0.593750,-0.937500)\n\t2915: o_phase = -9'd175;\t //LUT[2915] \tphase : -0.683594\t(data_i, data_q): (-0.593750,-0.906250)\n\t2916: o_phase = -9'd177;\t //LUT[2916] \tphase : -0.691406\t(data_i, data_q): (-0.593750,-0.875000)\n\t2917: o_phase = -9'd178;\t //LUT[2917] \tphase : -0.695312\t(data_i, data_q): (-0.593750,-0.843750)\n\t2918: o_phase = -9'd179;\t //LUT[2918] \tphase : -0.699219\t(data_i, data_q): (-0.593750,-0.812500)\n\t2919: o_phase = -9'd181;\t //LUT[2919] \tphase : -0.707031\t(data_i, data_q): (-0.593750,-0.781250)\n\t2920: o_phase = -9'd183;\t //LUT[2920] \tphase : -0.714844\t(data_i, data_q): (-0.593750,-0.750000)\n\t2921: o_phase = -9'd184;\t //LUT[2921] \tphase : -0.718750\t(data_i, data_q): (-0.593750,-0.718750)\n\t2922: o_phase = -9'd186;\t //LUT[2922] \tphase : -0.726562\t(data_i, data_q): (-0.593750,-0.687500)\n\t2923: o_phase = -9'd188;\t //LUT[2923] \tphase : -0.734375\t(data_i, data_q): (-0.593750,-0.656250)\n\t2924: o_phase = -9'd190;\t //LUT[2924] \tphase : -0.742188\t(data_i, data_q): (-0.593750,-0.625000)\n\t2925: o_phase = -9'd192;\t //LUT[2925] \tphase : -0.750000\t(data_i, data_q): (-0.593750,-0.593750)\n\t2926: o_phase = -9'd194;\t //LUT[2926] \tphase : -0.757812\t(data_i, data_q): (-0.593750,-0.562500)\n\t2927: o_phase = -9'd197;\t //LUT[2927] \tphase : -0.769531\t(data_i, data_q): (-0.593750,-0.531250)\n\t2928: o_phase = -9'd199;\t //LUT[2928] \tphase : -0.777344\t(data_i, data_q): (-0.593750,-0.500000)\n\t2929: o_phase = -9'd202;\t //LUT[2929] \tphase : -0.789062\t(data_i, data_q): (-0.593750,-0.468750)\n\t2930: o_phase = -9'd204;\t //LUT[2930] \tphase : -0.796875\t(data_i, data_q): (-0.593750,-0.437500)\n\t2931: o_phase = -9'd207;\t //LUT[2931] \tphase : -0.808594\t(data_i, data_q): (-0.593750,-0.406250)\n\t2932: o_phase = -9'd210;\t //LUT[2932] \tphase : -0.820312\t(data_i, data_q): (-0.593750,-0.375000)\n\t2933: o_phase = -9'd213;\t //LUT[2933] \tphase : -0.832031\t(data_i, data_q): (-0.593750,-0.343750)\n\t2934: o_phase = -9'd217;\t //LUT[2934] \tphase : -0.847656\t(data_i, data_q): (-0.593750,-0.312500)\n\t2935: o_phase = -9'd220;\t //LUT[2935] \tphase : -0.859375\t(data_i, data_q): (-0.593750,-0.281250)\n\t2936: o_phase = -9'd224;\t //LUT[2936] \tphase : -0.875000\t(data_i, data_q): (-0.593750,-0.250000)\n\t2937: o_phase = -9'd227;\t //LUT[2937] \tphase : -0.886719\t(data_i, data_q): (-0.593750,-0.218750)\n\t2938: o_phase = -9'd231;\t //LUT[2938] \tphase : -0.902344\t(data_i, data_q): (-0.593750,-0.187500)\n\t2939: o_phase = -9'd235;\t //LUT[2939] \tphase : -0.917969\t(data_i, data_q): (-0.593750,-0.156250)\n\t2940: o_phase = -9'd239;\t //LUT[2940] \tphase : -0.933594\t(data_i, data_q): (-0.593750,-0.125000)\n\t2941: o_phase = -9'd243;\t //LUT[2941] \tphase : -0.949219\t(data_i, data_q): (-0.593750,-0.093750)\n\t2942: o_phase = -9'd247;\t //LUT[2942] \tphase : -0.964844\t(data_i, data_q): (-0.593750,-0.062500)\n\t2943: o_phase = -9'd252;\t //LUT[2943] \tphase : -0.984375\t(data_i, data_q): (-0.593750,-0.031250)\n\t2944: o_phase = -9'd256;\t //LUT[2944] \tphase : -1.000000\t(data_i, data_q): (-0.562500,0.000000)\n\t2945: o_phase = +9'd251;\t //LUT[2945] \tphase : 0.980469\t(data_i, data_q): (-0.562500,0.031250)\n\t2946: o_phase = +9'd247;\t //LUT[2946] \tphase : 0.964844\t(data_i, data_q): (-0.562500,0.062500)\n\t2947: o_phase = +9'd243;\t //LUT[2947] \tphase : 0.949219\t(data_i, data_q): (-0.562500,0.093750)\n\t2948: o_phase = +9'd238;\t //LUT[2948] \tphase : 0.929688\t(data_i, data_q): (-0.562500,0.125000)\n\t2949: o_phase = +9'd234;\t //LUT[2949] \tphase : 0.914062\t(data_i, data_q): (-0.562500,0.156250)\n\t2950: o_phase = +9'd230;\t //LUT[2950] \tphase : 0.898438\t(data_i, data_q): (-0.562500,0.187500)\n\t2951: o_phase = +9'd226;\t //LUT[2951] \tphase : 0.882812\t(data_i, data_q): (-0.562500,0.218750)\n\t2952: o_phase = +9'd222;\t //LUT[2952] \tphase : 0.867188\t(data_i, data_q): (-0.562500,0.250000)\n\t2953: o_phase = +9'd218;\t //LUT[2953] \tphase : 0.851562\t(data_i, data_q): (-0.562500,0.281250)\n\t2954: o_phase = +9'd215;\t //LUT[2954] \tphase : 0.839844\t(data_i, data_q): (-0.562500,0.312500)\n\t2955: o_phase = +9'd211;\t //LUT[2955] \tphase : 0.824219\t(data_i, data_q): (-0.562500,0.343750)\n\t2956: o_phase = +9'd208;\t //LUT[2956] \tphase : 0.812500\t(data_i, data_q): (-0.562500,0.375000)\n\t2957: o_phase = +9'd205;\t //LUT[2957] \tphase : 0.800781\t(data_i, data_q): (-0.562500,0.406250)\n\t2958: o_phase = +9'd202;\t //LUT[2958] \tphase : 0.789062\t(data_i, data_q): (-0.562500,0.437500)\n\t2959: o_phase = +9'd199;\t //LUT[2959] \tphase : 0.777344\t(data_i, data_q): (-0.562500,0.468750)\n\t2960: o_phase = +9'd197;\t //LUT[2960] \tphase : 0.769531\t(data_i, data_q): (-0.562500,0.500000)\n\t2961: o_phase = +9'd194;\t //LUT[2961] \tphase : 0.757812\t(data_i, data_q): (-0.562500,0.531250)\n\t2962: o_phase = +9'd192;\t //LUT[2962] \tphase : 0.750000\t(data_i, data_q): (-0.562500,0.562500)\n\t2963: o_phase = +9'd190;\t //LUT[2963] \tphase : 0.742188\t(data_i, data_q): (-0.562500,0.593750)\n\t2964: o_phase = +9'd188;\t //LUT[2964] \tphase : 0.734375\t(data_i, data_q): (-0.562500,0.625000)\n\t2965: o_phase = +9'd186;\t //LUT[2965] \tphase : 0.726562\t(data_i, data_q): (-0.562500,0.656250)\n\t2966: o_phase = +9'd184;\t //LUT[2966] \tphase : 0.718750\t(data_i, data_q): (-0.562500,0.687500)\n\t2967: o_phase = +9'd182;\t //LUT[2967] \tphase : 0.710938\t(data_i, data_q): (-0.562500,0.718750)\n\t2968: o_phase = +9'd180;\t //LUT[2968] \tphase : 0.703125\t(data_i, data_q): (-0.562500,0.750000)\n\t2969: o_phase = +9'd179;\t //LUT[2969] \tphase : 0.699219\t(data_i, data_q): (-0.562500,0.781250)\n\t2970: o_phase = +9'd177;\t //LUT[2970] \tphase : 0.691406\t(data_i, data_q): (-0.562500,0.812500)\n\t2971: o_phase = +9'd176;\t //LUT[2971] \tphase : 0.687500\t(data_i, data_q): (-0.562500,0.843750)\n\t2972: o_phase = +9'd175;\t //LUT[2972] \tphase : 0.683594\t(data_i, data_q): (-0.562500,0.875000)\n\t2973: o_phase = +9'd173;\t //LUT[2973] \tphase : 0.675781\t(data_i, data_q): (-0.562500,0.906250)\n\t2974: o_phase = +9'd172;\t //LUT[2974] \tphase : 0.671875\t(data_i, data_q): (-0.562500,0.937500)\n\t2975: o_phase = +9'd171;\t //LUT[2975] \tphase : 0.667969\t(data_i, data_q): (-0.562500,0.968750)\n\t2976: o_phase = -9'd170;\t //LUT[2976] \tphase : -0.664062\t(data_i, data_q): (-0.562500,-1.000000)\n\t2977: o_phase = -9'd171;\t //LUT[2977] \tphase : -0.667969\t(data_i, data_q): (-0.562500,-0.968750)\n\t2978: o_phase = -9'd172;\t //LUT[2978] \tphase : -0.671875\t(data_i, data_q): (-0.562500,-0.937500)\n\t2979: o_phase = -9'd173;\t //LUT[2979] \tphase : -0.675781\t(data_i, data_q): (-0.562500,-0.906250)\n\t2980: o_phase = -9'd175;\t //LUT[2980] \tphase : -0.683594\t(data_i, data_q): (-0.562500,-0.875000)\n\t2981: o_phase = -9'd176;\t //LUT[2981] \tphase : -0.687500\t(data_i, data_q): (-0.562500,-0.843750)\n\t2982: o_phase = -9'd177;\t //LUT[2982] \tphase : -0.691406\t(data_i, data_q): (-0.562500,-0.812500)\n\t2983: o_phase = -9'd179;\t //LUT[2983] \tphase : -0.699219\t(data_i, data_q): (-0.562500,-0.781250)\n\t2984: o_phase = -9'd180;\t //LUT[2984] \tphase : -0.703125\t(data_i, data_q): (-0.562500,-0.750000)\n\t2985: o_phase = -9'd182;\t //LUT[2985] \tphase : -0.710938\t(data_i, data_q): (-0.562500,-0.718750)\n\t2986: o_phase = -9'd184;\t //LUT[2986] \tphase : -0.718750\t(data_i, data_q): (-0.562500,-0.687500)\n\t2987: o_phase = -9'd186;\t //LUT[2987] \tphase : -0.726562\t(data_i, data_q): (-0.562500,-0.656250)\n\t2988: o_phase = -9'd188;\t //LUT[2988] \tphase : -0.734375\t(data_i, data_q): (-0.562500,-0.625000)\n\t2989: o_phase = -9'd190;\t //LUT[2989] \tphase : -0.742188\t(data_i, data_q): (-0.562500,-0.593750)\n\t2990: o_phase = -9'd192;\t //LUT[2990] \tphase : -0.750000\t(data_i, data_q): (-0.562500,-0.562500)\n\t2991: o_phase = -9'd194;\t //LUT[2991] \tphase : -0.757812\t(data_i, data_q): (-0.562500,-0.531250)\n\t2992: o_phase = -9'd197;\t //LUT[2992] \tphase : -0.769531\t(data_i, data_q): (-0.562500,-0.500000)\n\t2993: o_phase = -9'd199;\t //LUT[2993] \tphase : -0.777344\t(data_i, data_q): (-0.562500,-0.468750)\n\t2994: o_phase = -9'd202;\t //LUT[2994] \tphase : -0.789062\t(data_i, data_q): (-0.562500,-0.437500)\n\t2995: o_phase = -9'd205;\t //LUT[2995] \tphase : -0.800781\t(data_i, data_q): (-0.562500,-0.406250)\n\t2996: o_phase = -9'd208;\t //LUT[2996] \tphase : -0.812500\t(data_i, data_q): (-0.562500,-0.375000)\n\t2997: o_phase = -9'd211;\t //LUT[2997] \tphase : -0.824219\t(data_i, data_q): (-0.562500,-0.343750)\n\t2998: o_phase = -9'd215;\t //LUT[2998] \tphase : -0.839844\t(data_i, data_q): (-0.562500,-0.312500)\n\t2999: o_phase = -9'd218;\t //LUT[2999] \tphase : -0.851562\t(data_i, data_q): (-0.562500,-0.281250)\n\t3000: o_phase = -9'd222;\t //LUT[3000] \tphase : -0.867188\t(data_i, data_q): (-0.562500,-0.250000)\n\t3001: o_phase = -9'd226;\t //LUT[3001] \tphase : -0.882812\t(data_i, data_q): (-0.562500,-0.218750)\n\t3002: o_phase = -9'd230;\t //LUT[3002] \tphase : -0.898438\t(data_i, data_q): (-0.562500,-0.187500)\n\t3003: o_phase = -9'd234;\t //LUT[3003] \tphase : -0.914062\t(data_i, data_q): (-0.562500,-0.156250)\n\t3004: o_phase = -9'd238;\t //LUT[3004] \tphase : -0.929688\t(data_i, data_q): (-0.562500,-0.125000)\n\t3005: o_phase = -9'd243;\t //LUT[3005] \tphase : -0.949219\t(data_i, data_q): (-0.562500,-0.093750)\n\t3006: o_phase = -9'd247;\t //LUT[3006] \tphase : -0.964844\t(data_i, data_q): (-0.562500,-0.062500)\n\t3007: o_phase = -9'd251;\t //LUT[3007] \tphase : -0.980469\t(data_i, data_q): (-0.562500,-0.031250)\n\t3008: o_phase = -9'd256;\t //LUT[3008] \tphase : -1.000000\t(data_i, data_q): (-0.531250,0.000000)\n\t3009: o_phase = +9'd251;\t //LUT[3009] \tphase : 0.980469\t(data_i, data_q): (-0.531250,0.031250)\n\t3010: o_phase = +9'd246;\t //LUT[3010] \tphase : 0.960938\t(data_i, data_q): (-0.531250,0.062500)\n\t3011: o_phase = +9'd242;\t //LUT[3011] \tphase : 0.945312\t(data_i, data_q): (-0.531250,0.093750)\n\t3012: o_phase = +9'd237;\t //LUT[3012] \tphase : 0.925781\t(data_i, data_q): (-0.531250,0.125000)\n\t3013: o_phase = +9'd233;\t //LUT[3013] \tphase : 0.910156\t(data_i, data_q): (-0.531250,0.156250)\n\t3014: o_phase = +9'd228;\t //LUT[3014] \tphase : 0.890625\t(data_i, data_q): (-0.531250,0.187500)\n\t3015: o_phase = +9'd224;\t //LUT[3015] \tphase : 0.875000\t(data_i, data_q): (-0.531250,0.218750)\n\t3016: o_phase = +9'd220;\t //LUT[3016] \tphase : 0.859375\t(data_i, data_q): (-0.531250,0.250000)\n\t3017: o_phase = +9'd216;\t //LUT[3017] \tphase : 0.843750\t(data_i, data_q): (-0.531250,0.281250)\n\t3018: o_phase = +9'd213;\t //LUT[3018] \tphase : 0.832031\t(data_i, data_q): (-0.531250,0.312500)\n\t3019: o_phase = +9'd209;\t //LUT[3019] \tphase : 0.816406\t(data_i, data_q): (-0.531250,0.343750)\n\t3020: o_phase = +9'd206;\t //LUT[3020] \tphase : 0.804688\t(data_i, data_q): (-0.531250,0.375000)\n\t3021: o_phase = +9'd203;\t //LUT[3021] \tphase : 0.792969\t(data_i, data_q): (-0.531250,0.406250)\n\t3022: o_phase = +9'd200;\t //LUT[3022] \tphase : 0.781250\t(data_i, data_q): (-0.531250,0.437500)\n\t3023: o_phase = +9'd197;\t //LUT[3023] \tphase : 0.769531\t(data_i, data_q): (-0.531250,0.468750)\n\t3024: o_phase = +9'd194;\t //LUT[3024] \tphase : 0.757812\t(data_i, data_q): (-0.531250,0.500000)\n\t3025: o_phase = +9'd192;\t //LUT[3025] \tphase : 0.750000\t(data_i, data_q): (-0.531250,0.531250)\n\t3026: o_phase = +9'd190;\t //LUT[3026] \tphase : 0.742188\t(data_i, data_q): (-0.531250,0.562500)\n\t3027: o_phase = +9'd187;\t //LUT[3027] \tphase : 0.730469\t(data_i, data_q): (-0.531250,0.593750)\n\t3028: o_phase = +9'd185;\t //LUT[3028] \tphase : 0.722656\t(data_i, data_q): (-0.531250,0.625000)\n\t3029: o_phase = +9'd183;\t //LUT[3029] \tphase : 0.714844\t(data_i, data_q): (-0.531250,0.656250)\n\t3030: o_phase = +9'd182;\t //LUT[3030] \tphase : 0.710938\t(data_i, data_q): (-0.531250,0.687500)\n\t3031: o_phase = +9'd180;\t //LUT[3031] \tphase : 0.703125\t(data_i, data_q): (-0.531250,0.718750)\n\t3032: o_phase = +9'd178;\t //LUT[3032] \tphase : 0.695312\t(data_i, data_q): (-0.531250,0.750000)\n\t3033: o_phase = +9'd177;\t //LUT[3033] \tphase : 0.691406\t(data_i, data_q): (-0.531250,0.781250)\n\t3034: o_phase = +9'd175;\t //LUT[3034] \tphase : 0.683594\t(data_i, data_q): (-0.531250,0.812500)\n\t3035: o_phase = +9'd174;\t //LUT[3035] \tphase : 0.679688\t(data_i, data_q): (-0.531250,0.843750)\n\t3036: o_phase = +9'd172;\t //LUT[3036] \tphase : 0.671875\t(data_i, data_q): (-0.531250,0.875000)\n\t3037: o_phase = +9'd171;\t //LUT[3037] \tphase : 0.667969\t(data_i, data_q): (-0.531250,0.906250)\n\t3038: o_phase = +9'd170;\t //LUT[3038] \tphase : 0.664062\t(data_i, data_q): (-0.531250,0.937500)\n\t3039: o_phase = +9'd169;\t //LUT[3039] \tphase : 0.660156\t(data_i, data_q): (-0.531250,0.968750)\n\t3040: o_phase = -9'd168;\t //LUT[3040] \tphase : -0.656250\t(data_i, data_q): (-0.531250,-1.000000)\n\t3041: o_phase = -9'd169;\t //LUT[3041] \tphase : -0.660156\t(data_i, data_q): (-0.531250,-0.968750)\n\t3042: o_phase = -9'd170;\t //LUT[3042] \tphase : -0.664062\t(data_i, data_q): (-0.531250,-0.937500)\n\t3043: o_phase = -9'd171;\t //LUT[3043] \tphase : -0.667969\t(data_i, data_q): (-0.531250,-0.906250)\n\t3044: o_phase = -9'd172;\t //LUT[3044] \tphase : -0.671875\t(data_i, data_q): (-0.531250,-0.875000)\n\t3045: o_phase = -9'd174;\t //LUT[3045] \tphase : -0.679688\t(data_i, data_q): (-0.531250,-0.843750)\n\t3046: o_phase = -9'd175;\t //LUT[3046] \tphase : -0.683594\t(data_i, data_q): (-0.531250,-0.812500)\n\t3047: o_phase = -9'd177;\t //LUT[3047] \tphase : -0.691406\t(data_i, data_q): (-0.531250,-0.781250)\n\t3048: o_phase = -9'd178;\t //LUT[3048] \tphase : -0.695312\t(data_i, data_q): (-0.531250,-0.750000)\n\t3049: o_phase = -9'd180;\t //LUT[3049] \tphase : -0.703125\t(data_i, data_q): (-0.531250,-0.718750)\n\t3050: o_phase = -9'd182;\t //LUT[3050] \tphase : -0.710938\t(data_i, data_q): (-0.531250,-0.687500)\n\t3051: o_phase = -9'd183;\t //LUT[3051] \tphase : -0.714844\t(data_i, data_q): (-0.531250,-0.656250)\n\t3052: o_phase = -9'd185;\t //LUT[3052] \tphase : -0.722656\t(data_i, data_q): (-0.531250,-0.625000)\n\t3053: o_phase = -9'd187;\t //LUT[3053] \tphase : -0.730469\t(data_i, data_q): (-0.531250,-0.593750)\n\t3054: o_phase = -9'd190;\t //LUT[3054] \tphase : -0.742188\t(data_i, data_q): (-0.531250,-0.562500)\n\t3055: o_phase = -9'd192;\t //LUT[3055] \tphase : -0.750000\t(data_i, data_q): (-0.531250,-0.531250)\n\t3056: o_phase = -9'd194;\t //LUT[3056] \tphase : -0.757812\t(data_i, data_q): (-0.531250,-0.500000)\n\t3057: o_phase = -9'd197;\t //LUT[3057] \tphase : -0.769531\t(data_i, data_q): (-0.531250,-0.468750)\n\t3058: o_phase = -9'd200;\t //LUT[3058] \tphase : -0.781250\t(data_i, data_q): (-0.531250,-0.437500)\n\t3059: o_phase = -9'd203;\t //LUT[3059] \tphase : -0.792969\t(data_i, data_q): (-0.531250,-0.406250)\n\t3060: o_phase = -9'd206;\t //LUT[3060] \tphase : -0.804688\t(data_i, data_q): (-0.531250,-0.375000)\n\t3061: o_phase = -9'd209;\t //LUT[3061] \tphase : -0.816406\t(data_i, data_q): (-0.531250,-0.343750)\n\t3062: o_phase = -9'd213;\t //LUT[3062] \tphase : -0.832031\t(data_i, data_q): (-0.531250,-0.312500)\n\t3063: o_phase = -9'd216;\t //LUT[3063] \tphase : -0.843750\t(data_i, data_q): (-0.531250,-0.281250)\n\t3064: o_phase = -9'd220;\t //LUT[3064] \tphase : -0.859375\t(data_i, data_q): (-0.531250,-0.250000)\n\t3065: o_phase = -9'd224;\t //LUT[3065] \tphase : -0.875000\t(data_i, data_q): (-0.531250,-0.218750)\n\t3066: o_phase = -9'd228;\t //LUT[3066] \tphase : -0.890625\t(data_i, data_q): (-0.531250,-0.187500)\n\t3067: o_phase = -9'd233;\t //LUT[3067] \tphase : -0.910156\t(data_i, data_q): (-0.531250,-0.156250)\n\t3068: o_phase = -9'd237;\t //LUT[3068] \tphase : -0.925781\t(data_i, data_q): (-0.531250,-0.125000)\n\t3069: o_phase = -9'd242;\t //LUT[3069] \tphase : -0.945312\t(data_i, data_q): (-0.531250,-0.093750)\n\t3070: o_phase = -9'd246;\t //LUT[3070] \tphase : -0.960938\t(data_i, data_q): (-0.531250,-0.062500)\n\t3071: o_phase = -9'd251;\t //LUT[3071] \tphase : -0.980469\t(data_i, data_q): (-0.531250,-0.031250)\n\t3072: o_phase = -9'd256;\t //LUT[3072] \tphase : -1.000000\t(data_i, data_q): (-0.500000,0.000000)\n\t3073: o_phase = +9'd251;\t //LUT[3073] \tphase : 0.980469\t(data_i, data_q): (-0.500000,0.031250)\n\t3074: o_phase = +9'd246;\t //LUT[3074] \tphase : 0.960938\t(data_i, data_q): (-0.500000,0.062500)\n\t3075: o_phase = +9'd241;\t //LUT[3075] \tphase : 0.941406\t(data_i, data_q): (-0.500000,0.093750)\n\t3076: o_phase = +9'd236;\t //LUT[3076] \tphase : 0.921875\t(data_i, data_q): (-0.500000,0.125000)\n\t3077: o_phase = +9'd231;\t //LUT[3077] \tphase : 0.902344\t(data_i, data_q): (-0.500000,0.156250)\n\t3078: o_phase = +9'd227;\t //LUT[3078] \tphase : 0.886719\t(data_i, data_q): (-0.500000,0.187500)\n\t3079: o_phase = +9'd222;\t //LUT[3079] \tphase : 0.867188\t(data_i, data_q): (-0.500000,0.218750)\n\t3080: o_phase = +9'd218;\t //LUT[3080] \tphase : 0.851562\t(data_i, data_q): (-0.500000,0.250000)\n\t3081: o_phase = +9'd214;\t //LUT[3081] \tphase : 0.835938\t(data_i, data_q): (-0.500000,0.281250)\n\t3082: o_phase = +9'd210;\t //LUT[3082] \tphase : 0.820312\t(data_i, data_q): (-0.500000,0.312500)\n\t3083: o_phase = +9'd207;\t //LUT[3083] \tphase : 0.808594\t(data_i, data_q): (-0.500000,0.343750)\n\t3084: o_phase = +9'd204;\t //LUT[3084] \tphase : 0.796875\t(data_i, data_q): (-0.500000,0.375000)\n\t3085: o_phase = +9'd200;\t //LUT[3085] \tphase : 0.781250\t(data_i, data_q): (-0.500000,0.406250)\n\t3086: o_phase = +9'd197;\t //LUT[3086] \tphase : 0.769531\t(data_i, data_q): (-0.500000,0.437500)\n\t3087: o_phase = +9'd195;\t //LUT[3087] \tphase : 0.761719\t(data_i, data_q): (-0.500000,0.468750)\n\t3088: o_phase = +9'd192;\t //LUT[3088] \tphase : 0.750000\t(data_i, data_q): (-0.500000,0.500000)\n\t3089: o_phase = +9'd190;\t //LUT[3089] \tphase : 0.742188\t(data_i, data_q): (-0.500000,0.531250)\n\t3090: o_phase = +9'd187;\t //LUT[3090] \tphase : 0.730469\t(data_i, data_q): (-0.500000,0.562500)\n\t3091: o_phase = +9'd185;\t //LUT[3091] \tphase : 0.722656\t(data_i, data_q): (-0.500000,0.593750)\n\t3092: o_phase = +9'd183;\t //LUT[3092] \tphase : 0.714844\t(data_i, data_q): (-0.500000,0.625000)\n\t3093: o_phase = +9'd181;\t //LUT[3093] \tphase : 0.707031\t(data_i, data_q): (-0.500000,0.656250)\n\t3094: o_phase = +9'd179;\t //LUT[3094] \tphase : 0.699219\t(data_i, data_q): (-0.500000,0.687500)\n\t3095: o_phase = +9'd178;\t //LUT[3095] \tphase : 0.695312\t(data_i, data_q): (-0.500000,0.718750)\n\t3096: o_phase = +9'd176;\t //LUT[3096] \tphase : 0.687500\t(data_i, data_q): (-0.500000,0.750000)\n\t3097: o_phase = +9'd174;\t //LUT[3097] \tphase : 0.679688\t(data_i, data_q): (-0.500000,0.781250)\n\t3098: o_phase = +9'd173;\t //LUT[3098] \tphase : 0.675781\t(data_i, data_q): (-0.500000,0.812500)\n\t3099: o_phase = +9'd172;\t //LUT[3099] \tphase : 0.671875\t(data_i, data_q): (-0.500000,0.843750)\n\t3100: o_phase = +9'd170;\t //LUT[3100] \tphase : 0.664062\t(data_i, data_q): (-0.500000,0.875000)\n\t3101: o_phase = +9'd169;\t //LUT[3101] \tphase : 0.660156\t(data_i, data_q): (-0.500000,0.906250)\n\t3102: o_phase = +9'd168;\t //LUT[3102] \tphase : 0.656250\t(data_i, data_q): (-0.500000,0.937500)\n\t3103: o_phase = +9'd167;\t //LUT[3103] \tphase : 0.652344\t(data_i, data_q): (-0.500000,0.968750)\n\t3104: o_phase = -9'd166;\t //LUT[3104] \tphase : -0.648438\t(data_i, data_q): (-0.500000,-1.000000)\n\t3105: o_phase = -9'd167;\t //LUT[3105] \tphase : -0.652344\t(data_i, data_q): (-0.500000,-0.968750)\n\t3106: o_phase = -9'd168;\t //LUT[3106] \tphase : -0.656250\t(data_i, data_q): (-0.500000,-0.937500)\n\t3107: o_phase = -9'd169;\t //LUT[3107] \tphase : -0.660156\t(data_i, data_q): (-0.500000,-0.906250)\n\t3108: o_phase = -9'd170;\t //LUT[3108] \tphase : -0.664062\t(data_i, data_q): (-0.500000,-0.875000)\n\t3109: o_phase = -9'd172;\t //LUT[3109] \tphase : -0.671875\t(data_i, data_q): (-0.500000,-0.843750)\n\t3110: o_phase = -9'd173;\t //LUT[3110] \tphase : -0.675781\t(data_i, data_q): (-0.500000,-0.812500)\n\t3111: o_phase = -9'd174;\t //LUT[3111] \tphase : -0.679688\t(data_i, data_q): (-0.500000,-0.781250)\n\t3112: o_phase = -9'd176;\t //LUT[3112] \tphase : -0.687500\t(data_i, data_q): (-0.500000,-0.750000)\n\t3113: o_phase = -9'd178;\t //LUT[3113] \tphase : -0.695312\t(data_i, data_q): (-0.500000,-0.718750)\n\t3114: o_phase = -9'd179;\t //LUT[3114] \tphase : -0.699219\t(data_i, data_q): (-0.500000,-0.687500)\n\t3115: o_phase = -9'd181;\t //LUT[3115] \tphase : -0.707031\t(data_i, data_q): (-0.500000,-0.656250)\n\t3116: o_phase = -9'd183;\t //LUT[3116] \tphase : -0.714844\t(data_i, data_q): (-0.500000,-0.625000)\n\t3117: o_phase = -9'd185;\t //LUT[3117] \tphase : -0.722656\t(data_i, data_q): (-0.500000,-0.593750)\n\t3118: o_phase = -9'd187;\t //LUT[3118] \tphase : -0.730469\t(data_i, data_q): (-0.500000,-0.562500)\n\t3119: o_phase = -9'd190;\t //LUT[3119] \tphase : -0.742188\t(data_i, data_q): (-0.500000,-0.531250)\n\t3120: o_phase = -9'd192;\t //LUT[3120] \tphase : -0.750000\t(data_i, data_q): (-0.500000,-0.500000)\n\t3121: o_phase = -9'd195;\t //LUT[3121] \tphase : -0.761719\t(data_i, data_q): (-0.500000,-0.468750)\n\t3122: o_phase = -9'd197;\t //LUT[3122] \tphase : -0.769531\t(data_i, data_q): (-0.500000,-0.437500)\n\t3123: o_phase = -9'd200;\t //LUT[3123] \tphase : -0.781250\t(data_i, data_q): (-0.500000,-0.406250)\n\t3124: o_phase = -9'd204;\t //LUT[3124] \tphase : -0.796875\t(data_i, data_q): (-0.500000,-0.375000)\n\t3125: o_phase = -9'd207;\t //LUT[3125] \tphase : -0.808594\t(data_i, data_q): (-0.500000,-0.343750)\n\t3126: o_phase = -9'd210;\t //LUT[3126] \tphase : -0.820312\t(data_i, data_q): (-0.500000,-0.312500)\n\t3127: o_phase = -9'd214;\t //LUT[3127] \tphase : -0.835938\t(data_i, data_q): (-0.500000,-0.281250)\n\t3128: o_phase = -9'd218;\t //LUT[3128] \tphase : -0.851562\t(data_i, data_q): (-0.500000,-0.250000)\n\t3129: o_phase = -9'd222;\t //LUT[3129] \tphase : -0.867188\t(data_i, data_q): (-0.500000,-0.218750)\n\t3130: o_phase = -9'd227;\t //LUT[3130] \tphase : -0.886719\t(data_i, data_q): (-0.500000,-0.187500)\n\t3131: o_phase = -9'd231;\t //LUT[3131] \tphase : -0.902344\t(data_i, data_q): (-0.500000,-0.156250)\n\t3132: o_phase = -9'd236;\t //LUT[3132] \tphase : -0.921875\t(data_i, data_q): (-0.500000,-0.125000)\n\t3133: o_phase = -9'd241;\t //LUT[3133] \tphase : -0.941406\t(data_i, data_q): (-0.500000,-0.093750)\n\t3134: o_phase = -9'd246;\t //LUT[3134] \tphase : -0.960938\t(data_i, data_q): (-0.500000,-0.062500)\n\t3135: o_phase = -9'd251;\t //LUT[3135] \tphase : -0.980469\t(data_i, data_q): (-0.500000,-0.031250)\n\t3136: o_phase = -9'd256;\t //LUT[3136] \tphase : -1.000000\t(data_i, data_q): (-0.468750,0.000000)\n\t3137: o_phase = +9'd251;\t //LUT[3137] \tphase : 0.980469\t(data_i, data_q): (-0.468750,0.031250)\n\t3138: o_phase = +9'd245;\t //LUT[3138] \tphase : 0.957031\t(data_i, data_q): (-0.468750,0.062500)\n\t3139: o_phase = +9'd240;\t //LUT[3139] \tphase : 0.937500\t(data_i, data_q): (-0.468750,0.093750)\n\t3140: o_phase = +9'd235;\t //LUT[3140] \tphase : 0.917969\t(data_i, data_q): (-0.468750,0.125000)\n\t3141: o_phase = +9'd230;\t //LUT[3141] \tphase : 0.898438\t(data_i, data_q): (-0.468750,0.156250)\n\t3142: o_phase = +9'd225;\t //LUT[3142] \tphase : 0.878906\t(data_i, data_q): (-0.468750,0.187500)\n\t3143: o_phase = +9'd220;\t //LUT[3143] \tphase : 0.859375\t(data_i, data_q): (-0.468750,0.218750)\n\t3144: o_phase = +9'd216;\t //LUT[3144] \tphase : 0.843750\t(data_i, data_q): (-0.468750,0.250000)\n\t3145: o_phase = +9'd212;\t //LUT[3145] \tphase : 0.828125\t(data_i, data_q): (-0.468750,0.281250)\n\t3146: o_phase = +9'd208;\t //LUT[3146] \tphase : 0.812500\t(data_i, data_q): (-0.468750,0.312500)\n\t3147: o_phase = +9'd204;\t //LUT[3147] \tphase : 0.796875\t(data_i, data_q): (-0.468750,0.343750)\n\t3148: o_phase = +9'd201;\t //LUT[3148] \tphase : 0.785156\t(data_i, data_q): (-0.468750,0.375000)\n\t3149: o_phase = +9'd198;\t //LUT[3149] \tphase : 0.773438\t(data_i, data_q): (-0.468750,0.406250)\n\t3150: o_phase = +9'd195;\t //LUT[3150] \tphase : 0.761719\t(data_i, data_q): (-0.468750,0.437500)\n\t3151: o_phase = +9'd192;\t //LUT[3151] \tphase : 0.750000\t(data_i, data_q): (-0.468750,0.468750)\n\t3152: o_phase = +9'd189;\t //LUT[3152] \tphase : 0.738281\t(data_i, data_q): (-0.468750,0.500000)\n\t3153: o_phase = +9'd187;\t //LUT[3153] \tphase : 0.730469\t(data_i, data_q): (-0.468750,0.531250)\n\t3154: o_phase = +9'd185;\t //LUT[3154] \tphase : 0.722656\t(data_i, data_q): (-0.468750,0.562500)\n\t3155: o_phase = +9'd182;\t //LUT[3155] \tphase : 0.710938\t(data_i, data_q): (-0.468750,0.593750)\n\t3156: o_phase = +9'd180;\t //LUT[3156] \tphase : 0.703125\t(data_i, data_q): (-0.468750,0.625000)\n\t3157: o_phase = +9'd179;\t //LUT[3157] \tphase : 0.699219\t(data_i, data_q): (-0.468750,0.656250)\n\t3158: o_phase = +9'd177;\t //LUT[3158] \tphase : 0.691406\t(data_i, data_q): (-0.468750,0.687500)\n\t3159: o_phase = +9'd175;\t //LUT[3159] \tphase : 0.683594\t(data_i, data_q): (-0.468750,0.718750)\n\t3160: o_phase = +9'd174;\t //LUT[3160] \tphase : 0.679688\t(data_i, data_q): (-0.468750,0.750000)\n\t3161: o_phase = +9'd172;\t //LUT[3161] \tphase : 0.671875\t(data_i, data_q): (-0.468750,0.781250)\n\t3162: o_phase = +9'd171;\t //LUT[3162] \tphase : 0.667969\t(data_i, data_q): (-0.468750,0.812500)\n\t3163: o_phase = +9'd169;\t //LUT[3163] \tphase : 0.660156\t(data_i, data_q): (-0.468750,0.843750)\n\t3164: o_phase = +9'd168;\t //LUT[3164] \tphase : 0.656250\t(data_i, data_q): (-0.468750,0.875000)\n\t3165: o_phase = +9'd167;\t //LUT[3165] \tphase : 0.652344\t(data_i, data_q): (-0.468750,0.906250)\n\t3166: o_phase = +9'd166;\t //LUT[3166] \tphase : 0.648438\t(data_i, data_q): (-0.468750,0.937500)\n\t3167: o_phase = +9'd165;\t //LUT[3167] \tphase : 0.644531\t(data_i, data_q): (-0.468750,0.968750)\n\t3168: o_phase = -9'd164;\t //LUT[3168] \tphase : -0.640625\t(data_i, data_q): (-0.468750,-1.000000)\n\t3169: o_phase = -9'd165;\t //LUT[3169] \tphase : -0.644531\t(data_i, data_q): (-0.468750,-0.968750)\n\t3170: o_phase = -9'd166;\t //LUT[3170] \tphase : -0.648438\t(data_i, data_q): (-0.468750,-0.937500)\n\t3171: o_phase = -9'd167;\t //LUT[3171] \tphase : -0.652344\t(data_i, data_q): (-0.468750,-0.906250)\n\t3172: o_phase = -9'd168;\t //LUT[3172] \tphase : -0.656250\t(data_i, data_q): (-0.468750,-0.875000)\n\t3173: o_phase = -9'd169;\t //LUT[3173] \tphase : -0.660156\t(data_i, data_q): (-0.468750,-0.843750)\n\t3174: o_phase = -9'd171;\t //LUT[3174] \tphase : -0.667969\t(data_i, data_q): (-0.468750,-0.812500)\n\t3175: o_phase = -9'd172;\t //LUT[3175] \tphase : -0.671875\t(data_i, data_q): (-0.468750,-0.781250)\n\t3176: o_phase = -9'd174;\t //LUT[3176] \tphase : -0.679688\t(data_i, data_q): (-0.468750,-0.750000)\n\t3177: o_phase = -9'd175;\t //LUT[3177] \tphase : -0.683594\t(data_i, data_q): (-0.468750,-0.718750)\n\t3178: o_phase = -9'd177;\t //LUT[3178] \tphase : -0.691406\t(data_i, data_q): (-0.468750,-0.687500)\n\t3179: o_phase = -9'd179;\t //LUT[3179] \tphase : -0.699219\t(data_i, data_q): (-0.468750,-0.656250)\n\t3180: o_phase = -9'd180;\t //LUT[3180] \tphase : -0.703125\t(data_i, data_q): (-0.468750,-0.625000)\n\t3181: o_phase = -9'd182;\t //LUT[3181] \tphase : -0.710938\t(data_i, data_q): (-0.468750,-0.593750)\n\t3182: o_phase = -9'd185;\t //LUT[3182] \tphase : -0.722656\t(data_i, data_q): (-0.468750,-0.562500)\n\t3183: o_phase = -9'd187;\t //LUT[3183] \tphase : -0.730469\t(data_i, data_q): (-0.468750,-0.531250)\n\t3184: o_phase = -9'd189;\t //LUT[3184] \tphase : -0.738281\t(data_i, data_q): (-0.468750,-0.500000)\n\t3185: o_phase = -9'd192;\t //LUT[3185] \tphase : -0.750000\t(data_i, data_q): (-0.468750,-0.468750)\n\t3186: o_phase = -9'd195;\t //LUT[3186] \tphase : -0.761719\t(data_i, data_q): (-0.468750,-0.437500)\n\t3187: o_phase = -9'd198;\t //LUT[3187] \tphase : -0.773438\t(data_i, data_q): (-0.468750,-0.406250)\n\t3188: o_phase = -9'd201;\t //LUT[3188] \tphase : -0.785156\t(data_i, data_q): (-0.468750,-0.375000)\n\t3189: o_phase = -9'd204;\t //LUT[3189] \tphase : -0.796875\t(data_i, data_q): (-0.468750,-0.343750)\n\t3190: o_phase = -9'd208;\t //LUT[3190] \tphase : -0.812500\t(data_i, data_q): (-0.468750,-0.312500)\n\t3191: o_phase = -9'd212;\t //LUT[3191] \tphase : -0.828125\t(data_i, data_q): (-0.468750,-0.281250)\n\t3192: o_phase = -9'd216;\t //LUT[3192] \tphase : -0.843750\t(data_i, data_q): (-0.468750,-0.250000)\n\t3193: o_phase = -9'd220;\t //LUT[3193] \tphase : -0.859375\t(data_i, data_q): (-0.468750,-0.218750)\n\t3194: o_phase = -9'd225;\t //LUT[3194] \tphase : -0.878906\t(data_i, data_q): (-0.468750,-0.187500)\n\t3195: o_phase = -9'd230;\t //LUT[3195] \tphase : -0.898438\t(data_i, data_q): (-0.468750,-0.156250)\n\t3196: o_phase = -9'd235;\t //LUT[3196] \tphase : -0.917969\t(data_i, data_q): (-0.468750,-0.125000)\n\t3197: o_phase = -9'd240;\t //LUT[3197] \tphase : -0.937500\t(data_i, data_q): (-0.468750,-0.093750)\n\t3198: o_phase = -9'd245;\t //LUT[3198] \tphase : -0.957031\t(data_i, data_q): (-0.468750,-0.062500)\n\t3199: o_phase = -9'd251;\t //LUT[3199] \tphase : -0.980469\t(data_i, data_q): (-0.468750,-0.031250)\n\t3200: o_phase = -9'd256;\t //LUT[3200] \tphase : -1.000000\t(data_i, data_q): (-0.437500,0.000000)\n\t3201: o_phase = +9'd250;\t //LUT[3201] \tphase : 0.976562\t(data_i, data_q): (-0.437500,0.031250)\n\t3202: o_phase = +9'd244;\t //LUT[3202] \tphase : 0.953125\t(data_i, data_q): (-0.437500,0.062500)\n\t3203: o_phase = +9'd239;\t //LUT[3203] \tphase : 0.933594\t(data_i, data_q): (-0.437500,0.093750)\n\t3204: o_phase = +9'd233;\t //LUT[3204] \tphase : 0.910156\t(data_i, data_q): (-0.437500,0.125000)\n\t3205: o_phase = +9'd228;\t //LUT[3205] \tphase : 0.890625\t(data_i, data_q): (-0.437500,0.156250)\n\t3206: o_phase = +9'd223;\t //LUT[3206] \tphase : 0.871094\t(data_i, data_q): (-0.437500,0.187500)\n\t3207: o_phase = +9'd218;\t //LUT[3207] \tphase : 0.851562\t(data_i, data_q): (-0.437500,0.218750)\n\t3208: o_phase = +9'd214;\t //LUT[3208] \tphase : 0.835938\t(data_i, data_q): (-0.437500,0.250000)\n\t3209: o_phase = +9'd209;\t //LUT[3209] \tphase : 0.816406\t(data_i, data_q): (-0.437500,0.281250)\n\t3210: o_phase = +9'd205;\t //LUT[3210] \tphase : 0.800781\t(data_i, data_q): (-0.437500,0.312500)\n\t3211: o_phase = +9'd202;\t //LUT[3211] \tphase : 0.789062\t(data_i, data_q): (-0.437500,0.343750)\n\t3212: o_phase = +9'd198;\t //LUT[3212] \tphase : 0.773438\t(data_i, data_q): (-0.437500,0.375000)\n\t3213: o_phase = +9'd195;\t //LUT[3213] \tphase : 0.761719\t(data_i, data_q): (-0.437500,0.406250)\n\t3214: o_phase = +9'd192;\t //LUT[3214] \tphase : 0.750000\t(data_i, data_q): (-0.437500,0.437500)\n\t3215: o_phase = +9'd189;\t //LUT[3215] \tphase : 0.738281\t(data_i, data_q): (-0.437500,0.468750)\n\t3216: o_phase = +9'd187;\t //LUT[3216] \tphase : 0.730469\t(data_i, data_q): (-0.437500,0.500000)\n\t3217: o_phase = +9'd184;\t //LUT[3217] \tphase : 0.718750\t(data_i, data_q): (-0.437500,0.531250)\n\t3218: o_phase = +9'd182;\t //LUT[3218] \tphase : 0.710938\t(data_i, data_q): (-0.437500,0.562500)\n\t3219: o_phase = +9'd180;\t //LUT[3219] \tphase : 0.703125\t(data_i, data_q): (-0.437500,0.593750)\n\t3220: o_phase = +9'd178;\t //LUT[3220] \tphase : 0.695312\t(data_i, data_q): (-0.437500,0.625000)\n\t3221: o_phase = +9'd176;\t //LUT[3221] \tphase : 0.687500\t(data_i, data_q): (-0.437500,0.656250)\n\t3222: o_phase = +9'd174;\t //LUT[3222] \tphase : 0.679688\t(data_i, data_q): (-0.437500,0.687500)\n\t3223: o_phase = +9'd173;\t //LUT[3223] \tphase : 0.675781\t(data_i, data_q): (-0.437500,0.718750)\n\t3224: o_phase = +9'd171;\t //LUT[3224] \tphase : 0.667969\t(data_i, data_q): (-0.437500,0.750000)\n\t3225: o_phase = +9'd170;\t //LUT[3225] \tphase : 0.664062\t(data_i, data_q): (-0.437500,0.781250)\n\t3226: o_phase = +9'd168;\t //LUT[3226] \tphase : 0.656250\t(data_i, data_q): (-0.437500,0.812500)\n\t3227: o_phase = +9'd167;\t //LUT[3227] \tphase : 0.652344\t(data_i, data_q): (-0.437500,0.843750)\n\t3228: o_phase = +9'd166;\t //LUT[3228] \tphase : 0.648438\t(data_i, data_q): (-0.437500,0.875000)\n\t3229: o_phase = +9'd165;\t //LUT[3229] \tphase : 0.644531\t(data_i, data_q): (-0.437500,0.906250)\n\t3230: o_phase = +9'd164;\t //LUT[3230] \tphase : 0.640625\t(data_i, data_q): (-0.437500,0.937500)\n\t3231: o_phase = +9'd163;\t //LUT[3231] \tphase : 0.636719\t(data_i, data_q): (-0.437500,0.968750)\n\t3232: o_phase = -9'd162;\t //LUT[3232] \tphase : -0.632812\t(data_i, data_q): (-0.437500,-1.000000)\n\t3233: o_phase = -9'd163;\t //LUT[3233] \tphase : -0.636719\t(data_i, data_q): (-0.437500,-0.968750)\n\t3234: o_phase = -9'd164;\t //LUT[3234] \tphase : -0.640625\t(data_i, data_q): (-0.437500,-0.937500)\n\t3235: o_phase = -9'd165;\t //LUT[3235] \tphase : -0.644531\t(data_i, data_q): (-0.437500,-0.906250)\n\t3236: o_phase = -9'd166;\t //LUT[3236] \tphase : -0.648438\t(data_i, data_q): (-0.437500,-0.875000)\n\t3237: o_phase = -9'd167;\t //LUT[3237] \tphase : -0.652344\t(data_i, data_q): (-0.437500,-0.843750)\n\t3238: o_phase = -9'd168;\t //LUT[3238] \tphase : -0.656250\t(data_i, data_q): (-0.437500,-0.812500)\n\t3239: o_phase = -9'd170;\t //LUT[3239] \tphase : -0.664062\t(data_i, data_q): (-0.437500,-0.781250)\n\t3240: o_phase = -9'd171;\t //LUT[3240] \tphase : -0.667969\t(data_i, data_q): (-0.437500,-0.750000)\n\t3241: o_phase = -9'd173;\t //LUT[3241] \tphase : -0.675781\t(data_i, data_q): (-0.437500,-0.718750)\n\t3242: o_phase = -9'd174;\t //LUT[3242] \tphase : -0.679688\t(data_i, data_q): (-0.437500,-0.687500)\n\t3243: o_phase = -9'd176;\t //LUT[3243] \tphase : -0.687500\t(data_i, data_q): (-0.437500,-0.656250)\n\t3244: o_phase = -9'd178;\t //LUT[3244] \tphase : -0.695312\t(data_i, data_q): (-0.437500,-0.625000)\n\t3245: o_phase = -9'd180;\t //LUT[3245] \tphase : -0.703125\t(data_i, data_q): (-0.437500,-0.593750)\n\t3246: o_phase = -9'd182;\t //LUT[3246] \tphase : -0.710938\t(data_i, data_q): (-0.437500,-0.562500)\n\t3247: o_phase = -9'd184;\t //LUT[3247] \tphase : -0.718750\t(data_i, data_q): (-0.437500,-0.531250)\n\t3248: o_phase = -9'd187;\t //LUT[3248] \tphase : -0.730469\t(data_i, data_q): (-0.437500,-0.500000)\n\t3249: o_phase = -9'd189;\t //LUT[3249] \tphase : -0.738281\t(data_i, data_q): (-0.437500,-0.468750)\n\t3250: o_phase = -9'd192;\t //LUT[3250] \tphase : -0.750000\t(data_i, data_q): (-0.437500,-0.437500)\n\t3251: o_phase = -9'd195;\t //LUT[3251] \tphase : -0.761719\t(data_i, data_q): (-0.437500,-0.406250)\n\t3252: o_phase = -9'd198;\t //LUT[3252] \tphase : -0.773438\t(data_i, data_q): (-0.437500,-0.375000)\n\t3253: o_phase = -9'd202;\t //LUT[3253] \tphase : -0.789062\t(data_i, data_q): (-0.437500,-0.343750)\n\t3254: o_phase = -9'd205;\t //LUT[3254] \tphase : -0.800781\t(data_i, data_q): (-0.437500,-0.312500)\n\t3255: o_phase = -9'd209;\t //LUT[3255] \tphase : -0.816406\t(data_i, data_q): (-0.437500,-0.281250)\n\t3256: o_phase = -9'd214;\t //LUT[3256] \tphase : -0.835938\t(data_i, data_q): (-0.437500,-0.250000)\n\t3257: o_phase = -9'd218;\t //LUT[3257] \tphase : -0.851562\t(data_i, data_q): (-0.437500,-0.218750)\n\t3258: o_phase = -9'd223;\t //LUT[3258] \tphase : -0.871094\t(data_i, data_q): (-0.437500,-0.187500)\n\t3259: o_phase = -9'd228;\t //LUT[3259] \tphase : -0.890625\t(data_i, data_q): (-0.437500,-0.156250)\n\t3260: o_phase = -9'd233;\t //LUT[3260] \tphase : -0.910156\t(data_i, data_q): (-0.437500,-0.125000)\n\t3261: o_phase = -9'd239;\t //LUT[3261] \tphase : -0.933594\t(data_i, data_q): (-0.437500,-0.093750)\n\t3262: o_phase = -9'd244;\t //LUT[3262] \tphase : -0.953125\t(data_i, data_q): (-0.437500,-0.062500)\n\t3263: o_phase = -9'd250;\t //LUT[3263] \tphase : -0.976562\t(data_i, data_q): (-0.437500,-0.031250)\n\t3264: o_phase = -9'd256;\t //LUT[3264] \tphase : -1.000000\t(data_i, data_q): (-0.406250,0.000000)\n\t3265: o_phase = +9'd250;\t //LUT[3265] \tphase : 0.976562\t(data_i, data_q): (-0.406250,0.031250)\n\t3266: o_phase = +9'd244;\t //LUT[3266] \tphase : 0.953125\t(data_i, data_q): (-0.406250,0.062500)\n\t3267: o_phase = +9'd238;\t //LUT[3267] \tphase : 0.929688\t(data_i, data_q): (-0.406250,0.093750)\n\t3268: o_phase = +9'd232;\t //LUT[3268] \tphase : 0.906250\t(data_i, data_q): (-0.406250,0.125000)\n\t3269: o_phase = +9'd226;\t //LUT[3269] \tphase : 0.882812\t(data_i, data_q): (-0.406250,0.156250)\n\t3270: o_phase = +9'd221;\t //LUT[3270] \tphase : 0.863281\t(data_i, data_q): (-0.406250,0.187500)\n\t3271: o_phase = +9'd216;\t //LUT[3271] \tphase : 0.843750\t(data_i, data_q): (-0.406250,0.218750)\n\t3272: o_phase = +9'd211;\t //LUT[3272] \tphase : 0.824219\t(data_i, data_q): (-0.406250,0.250000)\n\t3273: o_phase = +9'd207;\t //LUT[3273] \tphase : 0.808594\t(data_i, data_q): (-0.406250,0.281250)\n\t3274: o_phase = +9'd203;\t //LUT[3274] \tphase : 0.792969\t(data_i, data_q): (-0.406250,0.312500)\n\t3275: o_phase = +9'd199;\t //LUT[3275] \tphase : 0.777344\t(data_i, data_q): (-0.406250,0.343750)\n\t3276: o_phase = +9'd195;\t //LUT[3276] \tphase : 0.761719\t(data_i, data_q): (-0.406250,0.375000)\n\t3277: o_phase = +9'd192;\t //LUT[3277] \tphase : 0.750000\t(data_i, data_q): (-0.406250,0.406250)\n\t3278: o_phase = +9'd189;\t //LUT[3278] \tphase : 0.738281\t(data_i, data_q): (-0.406250,0.437500)\n\t3279: o_phase = +9'd186;\t //LUT[3279] \tphase : 0.726562\t(data_i, data_q): (-0.406250,0.468750)\n\t3280: o_phase = +9'd184;\t //LUT[3280] \tphase : 0.718750\t(data_i, data_q): (-0.406250,0.500000)\n\t3281: o_phase = +9'd181;\t //LUT[3281] \tphase : 0.707031\t(data_i, data_q): (-0.406250,0.531250)\n\t3282: o_phase = +9'd179;\t //LUT[3282] \tphase : 0.699219\t(data_i, data_q): (-0.406250,0.562500)\n\t3283: o_phase = +9'd177;\t //LUT[3283] \tphase : 0.691406\t(data_i, data_q): (-0.406250,0.593750)\n\t3284: o_phase = +9'd175;\t //LUT[3284] \tphase : 0.683594\t(data_i, data_q): (-0.406250,0.625000)\n\t3285: o_phase = +9'd173;\t //LUT[3285] \tphase : 0.675781\t(data_i, data_q): (-0.406250,0.656250)\n\t3286: o_phase = +9'd171;\t //LUT[3286] \tphase : 0.667969\t(data_i, data_q): (-0.406250,0.687500)\n\t3287: o_phase = +9'd170;\t //LUT[3287] \tphase : 0.664062\t(data_i, data_q): (-0.406250,0.718750)\n\t3288: o_phase = +9'd168;\t //LUT[3288] \tphase : 0.656250\t(data_i, data_q): (-0.406250,0.750000)\n\t3289: o_phase = +9'd167;\t //LUT[3289] \tphase : 0.652344\t(data_i, data_q): (-0.406250,0.781250)\n\t3290: o_phase = +9'd166;\t //LUT[3290] \tphase : 0.648438\t(data_i, data_q): (-0.406250,0.812500)\n\t3291: o_phase = +9'd165;\t //LUT[3291] \tphase : 0.644531\t(data_i, data_q): (-0.406250,0.843750)\n\t3292: o_phase = +9'd163;\t //LUT[3292] \tphase : 0.636719\t(data_i, data_q): (-0.406250,0.875000)\n\t3293: o_phase = +9'd162;\t //LUT[3293] \tphase : 0.632812\t(data_i, data_q): (-0.406250,0.906250)\n\t3294: o_phase = +9'd161;\t //LUT[3294] \tphase : 0.628906\t(data_i, data_q): (-0.406250,0.937500)\n\t3295: o_phase = +9'd160;\t //LUT[3295] \tphase : 0.625000\t(data_i, data_q): (-0.406250,0.968750)\n\t3296: o_phase = -9'd159;\t //LUT[3296] \tphase : -0.621094\t(data_i, data_q): (-0.406250,-1.000000)\n\t3297: o_phase = -9'd160;\t //LUT[3297] \tphase : -0.625000\t(data_i, data_q): (-0.406250,-0.968750)\n\t3298: o_phase = -9'd161;\t //LUT[3298] \tphase : -0.628906\t(data_i, data_q): (-0.406250,-0.937500)\n\t3299: o_phase = -9'd162;\t //LUT[3299] \tphase : -0.632812\t(data_i, data_q): (-0.406250,-0.906250)\n\t3300: o_phase = -9'd163;\t //LUT[3300] \tphase : -0.636719\t(data_i, data_q): (-0.406250,-0.875000)\n\t3301: o_phase = -9'd165;\t //LUT[3301] \tphase : -0.644531\t(data_i, data_q): (-0.406250,-0.843750)\n\t3302: o_phase = -9'd166;\t //LUT[3302] \tphase : -0.648438\t(data_i, data_q): (-0.406250,-0.812500)\n\t3303: o_phase = -9'd167;\t //LUT[3303] \tphase : -0.652344\t(data_i, data_q): (-0.406250,-0.781250)\n\t3304: o_phase = -9'd168;\t //LUT[3304] \tphase : -0.656250\t(data_i, data_q): (-0.406250,-0.750000)\n\t3305: o_phase = -9'd170;\t //LUT[3305] \tphase : -0.664062\t(data_i, data_q): (-0.406250,-0.718750)\n\t3306: o_phase = -9'd171;\t //LUT[3306] \tphase : -0.667969\t(data_i, data_q): (-0.406250,-0.687500)\n\t3307: o_phase = -9'd173;\t //LUT[3307] \tphase : -0.675781\t(data_i, data_q): (-0.406250,-0.656250)\n\t3308: o_phase = -9'd175;\t //LUT[3308] \tphase : -0.683594\t(data_i, data_q): (-0.406250,-0.625000)\n\t3309: o_phase = -9'd177;\t //LUT[3309] \tphase : -0.691406\t(data_i, data_q): (-0.406250,-0.593750)\n\t3310: o_phase = -9'd179;\t //LUT[3310] \tphase : -0.699219\t(data_i, data_q): (-0.406250,-0.562500)\n\t3311: o_phase = -9'd181;\t //LUT[3311] \tphase : -0.707031\t(data_i, data_q): (-0.406250,-0.531250)\n\t3312: o_phase = -9'd184;\t //LUT[3312] \tphase : -0.718750\t(data_i, data_q): (-0.406250,-0.500000)\n\t3313: o_phase = -9'd186;\t //LUT[3313] \tphase : -0.726562\t(data_i, data_q): (-0.406250,-0.468750)\n\t3314: o_phase = -9'd189;\t //LUT[3314] \tphase : -0.738281\t(data_i, data_q): (-0.406250,-0.437500)\n\t3315: o_phase = -9'd192;\t //LUT[3315] \tphase : -0.750000\t(data_i, data_q): (-0.406250,-0.406250)\n\t3316: o_phase = -9'd195;\t //LUT[3316] \tphase : -0.761719\t(data_i, data_q): (-0.406250,-0.375000)\n\t3317: o_phase = -9'd199;\t //LUT[3317] \tphase : -0.777344\t(data_i, data_q): (-0.406250,-0.343750)\n\t3318: o_phase = -9'd203;\t //LUT[3318] \tphase : -0.792969\t(data_i, data_q): (-0.406250,-0.312500)\n\t3319: o_phase = -9'd207;\t //LUT[3319] \tphase : -0.808594\t(data_i, data_q): (-0.406250,-0.281250)\n\t3320: o_phase = -9'd211;\t //LUT[3320] \tphase : -0.824219\t(data_i, data_q): (-0.406250,-0.250000)\n\t3321: o_phase = -9'd216;\t //LUT[3321] \tphase : -0.843750\t(data_i, data_q): (-0.406250,-0.218750)\n\t3322: o_phase = -9'd221;\t //LUT[3322] \tphase : -0.863281\t(data_i, data_q): (-0.406250,-0.187500)\n\t3323: o_phase = -9'd226;\t //LUT[3323] \tphase : -0.882812\t(data_i, data_q): (-0.406250,-0.156250)\n\t3324: o_phase = -9'd232;\t //LUT[3324] \tphase : -0.906250\t(data_i, data_q): (-0.406250,-0.125000)\n\t3325: o_phase = -9'd238;\t //LUT[3325] \tphase : -0.929688\t(data_i, data_q): (-0.406250,-0.093750)\n\t3326: o_phase = -9'd244;\t //LUT[3326] \tphase : -0.953125\t(data_i, data_q): (-0.406250,-0.062500)\n\t3327: o_phase = -9'd250;\t //LUT[3327] \tphase : -0.976562\t(data_i, data_q): (-0.406250,-0.031250)\n\t3328: o_phase = -9'd256;\t //LUT[3328] \tphase : -1.000000\t(data_i, data_q): (-0.375000,0.000000)\n\t3329: o_phase = +9'd249;\t //LUT[3329] \tphase : 0.972656\t(data_i, data_q): (-0.375000,0.031250)\n\t3330: o_phase = +9'd243;\t //LUT[3330] \tphase : 0.949219\t(data_i, data_q): (-0.375000,0.062500)\n\t3331: o_phase = +9'd236;\t //LUT[3331] \tphase : 0.921875\t(data_i, data_q): (-0.375000,0.093750)\n\t3332: o_phase = +9'd230;\t //LUT[3332] \tphase : 0.898438\t(data_i, data_q): (-0.375000,0.125000)\n\t3333: o_phase = +9'd224;\t //LUT[3333] \tphase : 0.875000\t(data_i, data_q): (-0.375000,0.156250)\n\t3334: o_phase = +9'd218;\t //LUT[3334] \tphase : 0.851562\t(data_i, data_q): (-0.375000,0.187500)\n\t3335: o_phase = +9'd213;\t //LUT[3335] \tphase : 0.832031\t(data_i, data_q): (-0.375000,0.218750)\n\t3336: o_phase = +9'd208;\t //LUT[3336] \tphase : 0.812500\t(data_i, data_q): (-0.375000,0.250000)\n\t3337: o_phase = +9'd204;\t //LUT[3337] \tphase : 0.796875\t(data_i, data_q): (-0.375000,0.281250)\n\t3338: o_phase = +9'd199;\t //LUT[3338] \tphase : 0.777344\t(data_i, data_q): (-0.375000,0.312500)\n\t3339: o_phase = +9'd196;\t //LUT[3339] \tphase : 0.765625\t(data_i, data_q): (-0.375000,0.343750)\n\t3340: o_phase = +9'd192;\t //LUT[3340] \tphase : 0.750000\t(data_i, data_q): (-0.375000,0.375000)\n\t3341: o_phase = +9'd189;\t //LUT[3341] \tphase : 0.738281\t(data_i, data_q): (-0.375000,0.406250)\n\t3342: o_phase = +9'd186;\t //LUT[3342] \tphase : 0.726562\t(data_i, data_q): (-0.375000,0.437500)\n\t3343: o_phase = +9'd183;\t //LUT[3343] \tphase : 0.714844\t(data_i, data_q): (-0.375000,0.468750)\n\t3344: o_phase = +9'd180;\t //LUT[3344] \tphase : 0.703125\t(data_i, data_q): (-0.375000,0.500000)\n\t3345: o_phase = +9'd178;\t //LUT[3345] \tphase : 0.695312\t(data_i, data_q): (-0.375000,0.531250)\n\t3346: o_phase = +9'd176;\t //LUT[3346] \tphase : 0.687500\t(data_i, data_q): (-0.375000,0.562500)\n\t3347: o_phase = +9'd174;\t //LUT[3347] \tphase : 0.679688\t(data_i, data_q): (-0.375000,0.593750)\n\t3348: o_phase = +9'd172;\t //LUT[3348] \tphase : 0.671875\t(data_i, data_q): (-0.375000,0.625000)\n\t3349: o_phase = +9'd170;\t //LUT[3349] \tphase : 0.664062\t(data_i, data_q): (-0.375000,0.656250)\n\t3350: o_phase = +9'd169;\t //LUT[3350] \tphase : 0.660156\t(data_i, data_q): (-0.375000,0.687500)\n\t3351: o_phase = +9'd167;\t //LUT[3351] \tphase : 0.652344\t(data_i, data_q): (-0.375000,0.718750)\n\t3352: o_phase = +9'd166;\t //LUT[3352] \tphase : 0.648438\t(data_i, data_q): (-0.375000,0.750000)\n\t3353: o_phase = +9'd164;\t //LUT[3353] \tphase : 0.640625\t(data_i, data_q): (-0.375000,0.781250)\n\t3354: o_phase = +9'd163;\t //LUT[3354] \tphase : 0.636719\t(data_i, data_q): (-0.375000,0.812500)\n\t3355: o_phase = +9'd162;\t //LUT[3355] \tphase : 0.632812\t(data_i, data_q): (-0.375000,0.843750)\n\t3356: o_phase = +9'd161;\t //LUT[3356] \tphase : 0.628906\t(data_i, data_q): (-0.375000,0.875000)\n\t3357: o_phase = +9'd160;\t //LUT[3357] \tphase : 0.625000\t(data_i, data_q): (-0.375000,0.906250)\n\t3358: o_phase = +9'd159;\t //LUT[3358] \tphase : 0.621094\t(data_i, data_q): (-0.375000,0.937500)\n\t3359: o_phase = +9'd158;\t //LUT[3359] \tphase : 0.617188\t(data_i, data_q): (-0.375000,0.968750)\n\t3360: o_phase = -9'd157;\t //LUT[3360] \tphase : -0.613281\t(data_i, data_q): (-0.375000,-1.000000)\n\t3361: o_phase = -9'd158;\t //LUT[3361] \tphase : -0.617188\t(data_i, data_q): (-0.375000,-0.968750)\n\t3362: o_phase = -9'd159;\t //LUT[3362] \tphase : -0.621094\t(data_i, data_q): (-0.375000,-0.937500)\n\t3363: o_phase = -9'd160;\t //LUT[3363] \tphase : -0.625000\t(data_i, data_q): (-0.375000,-0.906250)\n\t3364: o_phase = -9'd161;\t //LUT[3364] \tphase : -0.628906\t(data_i, data_q): (-0.375000,-0.875000)\n\t3365: o_phase = -9'd162;\t //LUT[3365] \tphase : -0.632812\t(data_i, data_q): (-0.375000,-0.843750)\n\t3366: o_phase = -9'd163;\t //LUT[3366] \tphase : -0.636719\t(data_i, data_q): (-0.375000,-0.812500)\n\t3367: o_phase = -9'd164;\t //LUT[3367] \tphase : -0.640625\t(data_i, data_q): (-0.375000,-0.781250)\n\t3368: o_phase = -9'd166;\t //LUT[3368] \tphase : -0.648438\t(data_i, data_q): (-0.375000,-0.750000)\n\t3369: o_phase = -9'd167;\t //LUT[3369] \tphase : -0.652344\t(data_i, data_q): (-0.375000,-0.718750)\n\t3370: o_phase = -9'd169;\t //LUT[3370] \tphase : -0.660156\t(data_i, data_q): (-0.375000,-0.687500)\n\t3371: o_phase = -9'd170;\t //LUT[3371] \tphase : -0.664062\t(data_i, data_q): (-0.375000,-0.656250)\n\t3372: o_phase = -9'd172;\t //LUT[3372] \tphase : -0.671875\t(data_i, data_q): (-0.375000,-0.625000)\n\t3373: o_phase = -9'd174;\t //LUT[3373] \tphase : -0.679688\t(data_i, data_q): (-0.375000,-0.593750)\n\t3374: o_phase = -9'd176;\t //LUT[3374] \tphase : -0.687500\t(data_i, data_q): (-0.375000,-0.562500)\n\t3375: o_phase = -9'd178;\t //LUT[3375] \tphase : -0.695312\t(data_i, data_q): (-0.375000,-0.531250)\n\t3376: o_phase = -9'd180;\t //LUT[3376] \tphase : -0.703125\t(data_i, data_q): (-0.375000,-0.500000)\n\t3377: o_phase = -9'd183;\t //LUT[3377] \tphase : -0.714844\t(data_i, data_q): (-0.375000,-0.468750)\n\t3378: o_phase = -9'd186;\t //LUT[3378] \tphase : -0.726562\t(data_i, data_q): (-0.375000,-0.437500)\n\t3379: o_phase = -9'd189;\t //LUT[3379] \tphase : -0.738281\t(data_i, data_q): (-0.375000,-0.406250)\n\t3380: o_phase = -9'd192;\t //LUT[3380] \tphase : -0.750000\t(data_i, data_q): (-0.375000,-0.375000)\n\t3381: o_phase = -9'd196;\t //LUT[3381] \tphase : -0.765625\t(data_i, data_q): (-0.375000,-0.343750)\n\t3382: o_phase = -9'd199;\t //LUT[3382] \tphase : -0.777344\t(data_i, data_q): (-0.375000,-0.312500)\n\t3383: o_phase = -9'd204;\t //LUT[3383] \tphase : -0.796875\t(data_i, data_q): (-0.375000,-0.281250)\n\t3384: o_phase = -9'd208;\t //LUT[3384] \tphase : -0.812500\t(data_i, data_q): (-0.375000,-0.250000)\n\t3385: o_phase = -9'd213;\t //LUT[3385] \tphase : -0.832031\t(data_i, data_q): (-0.375000,-0.218750)\n\t3386: o_phase = -9'd218;\t //LUT[3386] \tphase : -0.851562\t(data_i, data_q): (-0.375000,-0.187500)\n\t3387: o_phase = -9'd224;\t //LUT[3387] \tphase : -0.875000\t(data_i, data_q): (-0.375000,-0.156250)\n\t3388: o_phase = -9'd230;\t //LUT[3388] \tphase : -0.898438\t(data_i, data_q): (-0.375000,-0.125000)\n\t3389: o_phase = -9'd236;\t //LUT[3389] \tphase : -0.921875\t(data_i, data_q): (-0.375000,-0.093750)\n\t3390: o_phase = -9'd243;\t //LUT[3390] \tphase : -0.949219\t(data_i, data_q): (-0.375000,-0.062500)\n\t3391: o_phase = -9'd249;\t //LUT[3391] \tphase : -0.972656\t(data_i, data_q): (-0.375000,-0.031250)\n\t3392: o_phase = -9'd256;\t //LUT[3392] \tphase : -1.000000\t(data_i, data_q): (-0.343750,0.000000)\n\t3393: o_phase = +9'd249;\t //LUT[3393] \tphase : 0.972656\t(data_i, data_q): (-0.343750,0.031250)\n\t3394: o_phase = +9'd241;\t //LUT[3394] \tphase : 0.941406\t(data_i, data_q): (-0.343750,0.062500)\n\t3395: o_phase = +9'd234;\t //LUT[3395] \tphase : 0.914062\t(data_i, data_q): (-0.343750,0.093750)\n\t3396: o_phase = +9'd228;\t //LUT[3396] \tphase : 0.890625\t(data_i, data_q): (-0.343750,0.125000)\n\t3397: o_phase = +9'd221;\t //LUT[3397] \tphase : 0.863281\t(data_i, data_q): (-0.343750,0.156250)\n\t3398: o_phase = +9'd215;\t //LUT[3398] \tphase : 0.839844\t(data_i, data_q): (-0.343750,0.187500)\n\t3399: o_phase = +9'd210;\t //LUT[3399] \tphase : 0.820312\t(data_i, data_q): (-0.343750,0.218750)\n\t3400: o_phase = +9'd205;\t //LUT[3400] \tphase : 0.800781\t(data_i, data_q): (-0.343750,0.250000)\n\t3401: o_phase = +9'd200;\t //LUT[3401] \tphase : 0.781250\t(data_i, data_q): (-0.343750,0.281250)\n\t3402: o_phase = +9'd196;\t //LUT[3402] \tphase : 0.765625\t(data_i, data_q): (-0.343750,0.312500)\n\t3403: o_phase = +9'd192;\t //LUT[3403] \tphase : 0.750000\t(data_i, data_q): (-0.343750,0.343750)\n\t3404: o_phase = +9'd188;\t //LUT[3404] \tphase : 0.734375\t(data_i, data_q): (-0.343750,0.375000)\n\t3405: o_phase = +9'd185;\t //LUT[3405] \tphase : 0.722656\t(data_i, data_q): (-0.343750,0.406250)\n\t3406: o_phase = +9'd182;\t //LUT[3406] \tphase : 0.710938\t(data_i, data_q): (-0.343750,0.437500)\n\t3407: o_phase = +9'd180;\t //LUT[3407] \tphase : 0.703125\t(data_i, data_q): (-0.343750,0.468750)\n\t3408: o_phase = +9'd177;\t //LUT[3408] \tphase : 0.691406\t(data_i, data_q): (-0.343750,0.500000)\n\t3409: o_phase = +9'd175;\t //LUT[3409] \tphase : 0.683594\t(data_i, data_q): (-0.343750,0.531250)\n\t3410: o_phase = +9'd173;\t //LUT[3410] \tphase : 0.675781\t(data_i, data_q): (-0.343750,0.562500)\n\t3411: o_phase = +9'd171;\t //LUT[3411] \tphase : 0.667969\t(data_i, data_q): (-0.343750,0.593750)\n\t3412: o_phase = +9'd169;\t //LUT[3412] \tphase : 0.660156\t(data_i, data_q): (-0.343750,0.625000)\n\t3413: o_phase = +9'd167;\t //LUT[3413] \tphase : 0.652344\t(data_i, data_q): (-0.343750,0.656250)\n\t3414: o_phase = +9'd166;\t //LUT[3414] \tphase : 0.648438\t(data_i, data_q): (-0.343750,0.687500)\n\t3415: o_phase = +9'd164;\t //LUT[3415] \tphase : 0.640625\t(data_i, data_q): (-0.343750,0.718750)\n\t3416: o_phase = +9'd163;\t //LUT[3416] \tphase : 0.636719\t(data_i, data_q): (-0.343750,0.750000)\n\t3417: o_phase = +9'd162;\t //LUT[3417] \tphase : 0.632812\t(data_i, data_q): (-0.343750,0.781250)\n\t3418: o_phase = +9'd161;\t //LUT[3418] \tphase : 0.628906\t(data_i, data_q): (-0.343750,0.812500)\n\t3419: o_phase = +9'd160;\t //LUT[3419] \tphase : 0.625000\t(data_i, data_q): (-0.343750,0.843750)\n\t3420: o_phase = +9'd159;\t //LUT[3420] \tphase : 0.621094\t(data_i, data_q): (-0.343750,0.875000)\n\t3421: o_phase = +9'd158;\t //LUT[3421] \tphase : 0.617188\t(data_i, data_q): (-0.343750,0.906250)\n\t3422: o_phase = +9'd157;\t //LUT[3422] \tphase : 0.613281\t(data_i, data_q): (-0.343750,0.937500)\n\t3423: o_phase = +9'd156;\t //LUT[3423] \tphase : 0.609375\t(data_i, data_q): (-0.343750,0.968750)\n\t3424: o_phase = -9'd155;\t //LUT[3424] \tphase : -0.605469\t(data_i, data_q): (-0.343750,-1.000000)\n\t3425: o_phase = -9'd156;\t //LUT[3425] \tphase : -0.609375\t(data_i, data_q): (-0.343750,-0.968750)\n\t3426: o_phase = -9'd157;\t //LUT[3426] \tphase : -0.613281\t(data_i, data_q): (-0.343750,-0.937500)\n\t3427: o_phase = -9'd158;\t //LUT[3427] \tphase : -0.617188\t(data_i, data_q): (-0.343750,-0.906250)\n\t3428: o_phase = -9'd159;\t //LUT[3428] \tphase : -0.621094\t(data_i, data_q): (-0.343750,-0.875000)\n\t3429: o_phase = -9'd160;\t //LUT[3429] \tphase : -0.625000\t(data_i, data_q): (-0.343750,-0.843750)\n\t3430: o_phase = -9'd161;\t //LUT[3430] \tphase : -0.628906\t(data_i, data_q): (-0.343750,-0.812500)\n\t3431: o_phase = -9'd162;\t //LUT[3431] \tphase : -0.632812\t(data_i, data_q): (-0.343750,-0.781250)\n\t3432: o_phase = -9'd163;\t //LUT[3432] \tphase : -0.636719\t(data_i, data_q): (-0.343750,-0.750000)\n\t3433: o_phase = -9'd164;\t //LUT[3433] \tphase : -0.640625\t(data_i, data_q): (-0.343750,-0.718750)\n\t3434: o_phase = -9'd166;\t //LUT[3434] \tphase : -0.648438\t(data_i, data_q): (-0.343750,-0.687500)\n\t3435: o_phase = -9'd167;\t //LUT[3435] \tphase : -0.652344\t(data_i, data_q): (-0.343750,-0.656250)\n\t3436: o_phase = -9'd169;\t //LUT[3436] \tphase : -0.660156\t(data_i, data_q): (-0.343750,-0.625000)\n\t3437: o_phase = -9'd171;\t //LUT[3437] \tphase : -0.667969\t(data_i, data_q): (-0.343750,-0.593750)\n\t3438: o_phase = -9'd173;\t //LUT[3438] \tphase : -0.675781\t(data_i, data_q): (-0.343750,-0.562500)\n\t3439: o_phase = -9'd175;\t //LUT[3439] \tphase : -0.683594\t(data_i, data_q): (-0.343750,-0.531250)\n\t3440: o_phase = -9'd177;\t //LUT[3440] \tphase : -0.691406\t(data_i, data_q): (-0.343750,-0.500000)\n\t3441: o_phase = -9'd180;\t //LUT[3441] \tphase : -0.703125\t(data_i, data_q): (-0.343750,-0.468750)\n\t3442: o_phase = -9'd182;\t //LUT[3442] \tphase : -0.710938\t(data_i, data_q): (-0.343750,-0.437500)\n\t3443: o_phase = -9'd185;\t //LUT[3443] \tphase : -0.722656\t(data_i, data_q): (-0.343750,-0.406250)\n\t3444: o_phase = -9'd188;\t //LUT[3444] \tphase : -0.734375\t(data_i, data_q): (-0.343750,-0.375000)\n\t3445: o_phase = -9'd192;\t //LUT[3445] \tphase : -0.750000\t(data_i, data_q): (-0.343750,-0.343750)\n\t3446: o_phase = -9'd196;\t //LUT[3446] \tphase : -0.765625\t(data_i, data_q): (-0.343750,-0.312500)\n\t3447: o_phase = -9'd200;\t //LUT[3447] \tphase : -0.781250\t(data_i, data_q): (-0.343750,-0.281250)\n\t3448: o_phase = -9'd205;\t //LUT[3448] \tphase : -0.800781\t(data_i, data_q): (-0.343750,-0.250000)\n\t3449: o_phase = -9'd210;\t //LUT[3449] \tphase : -0.820312\t(data_i, data_q): (-0.343750,-0.218750)\n\t3450: o_phase = -9'd215;\t //LUT[3450] \tphase : -0.839844\t(data_i, data_q): (-0.343750,-0.187500)\n\t3451: o_phase = -9'd221;\t //LUT[3451] \tphase : -0.863281\t(data_i, data_q): (-0.343750,-0.156250)\n\t3452: o_phase = -9'd228;\t //LUT[3452] \tphase : -0.890625\t(data_i, data_q): (-0.343750,-0.125000)\n\t3453: o_phase = -9'd234;\t //LUT[3453] \tphase : -0.914062\t(data_i, data_q): (-0.343750,-0.093750)\n\t3454: o_phase = -9'd241;\t //LUT[3454] \tphase : -0.941406\t(data_i, data_q): (-0.343750,-0.062500)\n\t3455: o_phase = -9'd249;\t //LUT[3455] \tphase : -0.972656\t(data_i, data_q): (-0.343750,-0.031250)\n\t3456: o_phase = -9'd256;\t //LUT[3456] \tphase : -1.000000\t(data_i, data_q): (-0.312500,0.000000)\n\t3457: o_phase = +9'd248;\t //LUT[3457] \tphase : 0.968750\t(data_i, data_q): (-0.312500,0.031250)\n\t3458: o_phase = +9'd240;\t //LUT[3458] \tphase : 0.937500\t(data_i, data_q): (-0.312500,0.062500)\n\t3459: o_phase = +9'd232;\t //LUT[3459] \tphase : 0.906250\t(data_i, data_q): (-0.312500,0.093750)\n\t3460: o_phase = +9'd225;\t //LUT[3460] \tphase : 0.878906\t(data_i, data_q): (-0.312500,0.125000)\n\t3461: o_phase = +9'd218;\t //LUT[3461] \tphase : 0.851562\t(data_i, data_q): (-0.312500,0.156250)\n\t3462: o_phase = +9'd212;\t //LUT[3462] \tphase : 0.828125\t(data_i, data_q): (-0.312500,0.187500)\n\t3463: o_phase = +9'd206;\t //LUT[3463] \tphase : 0.804688\t(data_i, data_q): (-0.312500,0.218750)\n\t3464: o_phase = +9'd201;\t //LUT[3464] \tphase : 0.785156\t(data_i, data_q): (-0.312500,0.250000)\n\t3465: o_phase = +9'd196;\t //LUT[3465] \tphase : 0.765625\t(data_i, data_q): (-0.312500,0.281250)\n\t3466: o_phase = +9'd192;\t //LUT[3466] \tphase : 0.750000\t(data_i, data_q): (-0.312500,0.312500)\n\t3467: o_phase = +9'd188;\t //LUT[3467] \tphase : 0.734375\t(data_i, data_q): (-0.312500,0.343750)\n\t3468: o_phase = +9'd185;\t //LUT[3468] \tphase : 0.722656\t(data_i, data_q): (-0.312500,0.375000)\n\t3469: o_phase = +9'd181;\t //LUT[3469] \tphase : 0.707031\t(data_i, data_q): (-0.312500,0.406250)\n\t3470: o_phase = +9'd179;\t //LUT[3470] \tphase : 0.699219\t(data_i, data_q): (-0.312500,0.437500)\n\t3471: o_phase = +9'd176;\t //LUT[3471] \tphase : 0.687500\t(data_i, data_q): (-0.312500,0.468750)\n\t3472: o_phase = +9'd174;\t //LUT[3472] \tphase : 0.679688\t(data_i, data_q): (-0.312500,0.500000)\n\t3473: o_phase = +9'd171;\t //LUT[3473] \tphase : 0.667969\t(data_i, data_q): (-0.312500,0.531250)\n\t3474: o_phase = +9'd169;\t //LUT[3474] \tphase : 0.660156\t(data_i, data_q): (-0.312500,0.562500)\n\t3475: o_phase = +9'd167;\t //LUT[3475] \tphase : 0.652344\t(data_i, data_q): (-0.312500,0.593750)\n\t3476: o_phase = +9'd166;\t //LUT[3476] \tphase : 0.648438\t(data_i, data_q): (-0.312500,0.625000)\n\t3477: o_phase = +9'd164;\t //LUT[3477] \tphase : 0.640625\t(data_i, data_q): (-0.312500,0.656250)\n\t3478: o_phase = +9'd163;\t //LUT[3478] \tphase : 0.636719\t(data_i, data_q): (-0.312500,0.687500)\n\t3479: o_phase = +9'd161;\t //LUT[3479] \tphase : 0.628906\t(data_i, data_q): (-0.312500,0.718750)\n\t3480: o_phase = +9'd160;\t //LUT[3480] \tphase : 0.625000\t(data_i, data_q): (-0.312500,0.750000)\n\t3481: o_phase = +9'd159;\t //LUT[3481] \tphase : 0.621094\t(data_i, data_q): (-0.312500,0.781250)\n\t3482: o_phase = +9'd158;\t //LUT[3482] \tphase : 0.617188\t(data_i, data_q): (-0.312500,0.812500)\n\t3483: o_phase = +9'd157;\t //LUT[3483] \tphase : 0.613281\t(data_i, data_q): (-0.312500,0.843750)\n\t3484: o_phase = +9'd156;\t //LUT[3484] \tphase : 0.609375\t(data_i, data_q): (-0.312500,0.875000)\n\t3485: o_phase = +9'd155;\t //LUT[3485] \tphase : 0.605469\t(data_i, data_q): (-0.312500,0.906250)\n\t3486: o_phase = +9'd154;\t //LUT[3486] \tphase : 0.601562\t(data_i, data_q): (-0.312500,0.937500)\n\t3487: o_phase = +9'd153;\t //LUT[3487] \tphase : 0.597656\t(data_i, data_q): (-0.312500,0.968750)\n\t3488: o_phase = -9'd153;\t //LUT[3488] \tphase : -0.597656\t(data_i, data_q): (-0.312500,-1.000000)\n\t3489: o_phase = -9'd153;\t //LUT[3489] \tphase : -0.597656\t(data_i, data_q): (-0.312500,-0.968750)\n\t3490: o_phase = -9'd154;\t //LUT[3490] \tphase : -0.601562\t(data_i, data_q): (-0.312500,-0.937500)\n\t3491: o_phase = -9'd155;\t //LUT[3491] \tphase : -0.605469\t(data_i, data_q): (-0.312500,-0.906250)\n\t3492: o_phase = -9'd156;\t //LUT[3492] \tphase : -0.609375\t(data_i, data_q): (-0.312500,-0.875000)\n\t3493: o_phase = -9'd157;\t //LUT[3493] \tphase : -0.613281\t(data_i, data_q): (-0.312500,-0.843750)\n\t3494: o_phase = -9'd158;\t //LUT[3494] \tphase : -0.617188\t(data_i, data_q): (-0.312500,-0.812500)\n\t3495: o_phase = -9'd159;\t //LUT[3495] \tphase : -0.621094\t(data_i, data_q): (-0.312500,-0.781250)\n\t3496: o_phase = -9'd160;\t //LUT[3496] \tphase : -0.625000\t(data_i, data_q): (-0.312500,-0.750000)\n\t3497: o_phase = -9'd161;\t //LUT[3497] \tphase : -0.628906\t(data_i, data_q): (-0.312500,-0.718750)\n\t3498: o_phase = -9'd163;\t //LUT[3498] \tphase : -0.636719\t(data_i, data_q): (-0.312500,-0.687500)\n\t3499: o_phase = -9'd164;\t //LUT[3499] \tphase : -0.640625\t(data_i, data_q): (-0.312500,-0.656250)\n\t3500: o_phase = -9'd166;\t //LUT[3500] \tphase : -0.648438\t(data_i, data_q): (-0.312500,-0.625000)\n\t3501: o_phase = -9'd167;\t //LUT[3501] \tphase : -0.652344\t(data_i, data_q): (-0.312500,-0.593750)\n\t3502: o_phase = -9'd169;\t //LUT[3502] \tphase : -0.660156\t(data_i, data_q): (-0.312500,-0.562500)\n\t3503: o_phase = -9'd171;\t //LUT[3503] \tphase : -0.667969\t(data_i, data_q): (-0.312500,-0.531250)\n\t3504: o_phase = -9'd174;\t //LUT[3504] \tphase : -0.679688\t(data_i, data_q): (-0.312500,-0.500000)\n\t3505: o_phase = -9'd176;\t //LUT[3505] \tphase : -0.687500\t(data_i, data_q): (-0.312500,-0.468750)\n\t3506: o_phase = -9'd179;\t //LUT[3506] \tphase : -0.699219\t(data_i, data_q): (-0.312500,-0.437500)\n\t3507: o_phase = -9'd181;\t //LUT[3507] \tphase : -0.707031\t(data_i, data_q): (-0.312500,-0.406250)\n\t3508: o_phase = -9'd185;\t //LUT[3508] \tphase : -0.722656\t(data_i, data_q): (-0.312500,-0.375000)\n\t3509: o_phase = -9'd188;\t //LUT[3509] \tphase : -0.734375\t(data_i, data_q): (-0.312500,-0.343750)\n\t3510: o_phase = -9'd192;\t //LUT[3510] \tphase : -0.750000\t(data_i, data_q): (-0.312500,-0.312500)\n\t3511: o_phase = -9'd196;\t //LUT[3511] \tphase : -0.765625\t(data_i, data_q): (-0.312500,-0.281250)\n\t3512: o_phase = -9'd201;\t //LUT[3512] \tphase : -0.785156\t(data_i, data_q): (-0.312500,-0.250000)\n\t3513: o_phase = -9'd206;\t //LUT[3513] \tphase : -0.804688\t(data_i, data_q): (-0.312500,-0.218750)\n\t3514: o_phase = -9'd212;\t //LUT[3514] \tphase : -0.828125\t(data_i, data_q): (-0.312500,-0.187500)\n\t3515: o_phase = -9'd218;\t //LUT[3515] \tphase : -0.851562\t(data_i, data_q): (-0.312500,-0.156250)\n\t3516: o_phase = -9'd225;\t //LUT[3516] \tphase : -0.878906\t(data_i, data_q): (-0.312500,-0.125000)\n\t3517: o_phase = -9'd232;\t //LUT[3517] \tphase : -0.906250\t(data_i, data_q): (-0.312500,-0.093750)\n\t3518: o_phase = -9'd240;\t //LUT[3518] \tphase : -0.937500\t(data_i, data_q): (-0.312500,-0.062500)\n\t3519: o_phase = -9'd248;\t //LUT[3519] \tphase : -0.968750\t(data_i, data_q): (-0.312500,-0.031250)\n\t3520: o_phase = -9'd256;\t //LUT[3520] \tphase : -1.000000\t(data_i, data_q): (-0.281250,0.000000)\n\t3521: o_phase = +9'd247;\t //LUT[3521] \tphase : 0.964844\t(data_i, data_q): (-0.281250,0.031250)\n\t3522: o_phase = +9'd238;\t //LUT[3522] \tphase : 0.929688\t(data_i, data_q): (-0.281250,0.062500)\n\t3523: o_phase = +9'd230;\t //LUT[3523] \tphase : 0.898438\t(data_i, data_q): (-0.281250,0.093750)\n\t3524: o_phase = +9'd222;\t //LUT[3524] \tphase : 0.867188\t(data_i, data_q): (-0.281250,0.125000)\n\t3525: o_phase = +9'd215;\t //LUT[3525] \tphase : 0.839844\t(data_i, data_q): (-0.281250,0.156250)\n\t3526: o_phase = +9'd208;\t //LUT[3526] \tphase : 0.812500\t(data_i, data_q): (-0.281250,0.187500)\n\t3527: o_phase = +9'd202;\t //LUT[3527] \tphase : 0.789062\t(data_i, data_q): (-0.281250,0.218750)\n\t3528: o_phase = +9'd197;\t //LUT[3528] \tphase : 0.769531\t(data_i, data_q): (-0.281250,0.250000)\n\t3529: o_phase = +9'd192;\t //LUT[3529] \tphase : 0.750000\t(data_i, data_q): (-0.281250,0.281250)\n\t3530: o_phase = +9'd188;\t //LUT[3530] \tphase : 0.734375\t(data_i, data_q): (-0.281250,0.312500)\n\t3531: o_phase = +9'd184;\t //LUT[3531] \tphase : 0.718750\t(data_i, data_q): (-0.281250,0.343750)\n\t3532: o_phase = +9'd180;\t //LUT[3532] \tphase : 0.703125\t(data_i, data_q): (-0.281250,0.375000)\n\t3533: o_phase = +9'd177;\t //LUT[3533] \tphase : 0.691406\t(data_i, data_q): (-0.281250,0.406250)\n\t3534: o_phase = +9'd175;\t //LUT[3534] \tphase : 0.683594\t(data_i, data_q): (-0.281250,0.437500)\n\t3535: o_phase = +9'd172;\t //LUT[3535] \tphase : 0.671875\t(data_i, data_q): (-0.281250,0.468750)\n\t3536: o_phase = +9'd170;\t //LUT[3536] \tphase : 0.664062\t(data_i, data_q): (-0.281250,0.500000)\n\t3537: o_phase = +9'd168;\t //LUT[3537] \tphase : 0.656250\t(data_i, data_q): (-0.281250,0.531250)\n\t3538: o_phase = +9'd166;\t //LUT[3538] \tphase : 0.648438\t(data_i, data_q): (-0.281250,0.562500)\n\t3539: o_phase = +9'd164;\t //LUT[3539] \tphase : 0.640625\t(data_i, data_q): (-0.281250,0.593750)\n\t3540: o_phase = +9'd162;\t //LUT[3540] \tphase : 0.632812\t(data_i, data_q): (-0.281250,0.625000)\n\t3541: o_phase = +9'd161;\t //LUT[3541] \tphase : 0.628906\t(data_i, data_q): (-0.281250,0.656250)\n\t3542: o_phase = +9'd160;\t //LUT[3542] \tphase : 0.625000\t(data_i, data_q): (-0.281250,0.687500)\n\t3543: o_phase = +9'd158;\t //LUT[3543] \tphase : 0.617188\t(data_i, data_q): (-0.281250,0.718750)\n\t3544: o_phase = +9'd157;\t //LUT[3544] \tphase : 0.613281\t(data_i, data_q): (-0.281250,0.750000)\n\t3545: o_phase = +9'd156;\t //LUT[3545] \tphase : 0.609375\t(data_i, data_q): (-0.281250,0.781250)\n\t3546: o_phase = +9'd155;\t //LUT[3546] \tphase : 0.605469\t(data_i, data_q): (-0.281250,0.812500)\n\t3547: o_phase = +9'd154;\t //LUT[3547] \tphase : 0.601562\t(data_i, data_q): (-0.281250,0.843750)\n\t3548: o_phase = +9'd153;\t //LUT[3548] \tphase : 0.597656\t(data_i, data_q): (-0.281250,0.875000)\n\t3549: o_phase = +9'd153;\t //LUT[3549] \tphase : 0.597656\t(data_i, data_q): (-0.281250,0.906250)\n\t3550: o_phase = +9'd152;\t //LUT[3550] \tphase : 0.593750\t(data_i, data_q): (-0.281250,0.937500)\n\t3551: o_phase = +9'd151;\t //LUT[3551] \tphase : 0.589844\t(data_i, data_q): (-0.281250,0.968750)\n\t3552: o_phase = -9'd150;\t //LUT[3552] \tphase : -0.585938\t(data_i, data_q): (-0.281250,-1.000000)\n\t3553: o_phase = -9'd151;\t //LUT[3553] \tphase : -0.589844\t(data_i, data_q): (-0.281250,-0.968750)\n\t3554: o_phase = -9'd152;\t //LUT[3554] \tphase : -0.593750\t(data_i, data_q): (-0.281250,-0.937500)\n\t3555: o_phase = -9'd153;\t //LUT[3555] \tphase : -0.597656\t(data_i, data_q): (-0.281250,-0.906250)\n\t3556: o_phase = -9'd153;\t //LUT[3556] \tphase : -0.597656\t(data_i, data_q): (-0.281250,-0.875000)\n\t3557: o_phase = -9'd154;\t //LUT[3557] \tphase : -0.601562\t(data_i, data_q): (-0.281250,-0.843750)\n\t3558: o_phase = -9'd155;\t //LUT[3558] \tphase : -0.605469\t(data_i, data_q): (-0.281250,-0.812500)\n\t3559: o_phase = -9'd156;\t //LUT[3559] \tphase : -0.609375\t(data_i, data_q): (-0.281250,-0.781250)\n\t3560: o_phase = -9'd157;\t //LUT[3560] \tphase : -0.613281\t(data_i, data_q): (-0.281250,-0.750000)\n\t3561: o_phase = -9'd158;\t //LUT[3561] \tphase : -0.617188\t(data_i, data_q): (-0.281250,-0.718750)\n\t3562: o_phase = -9'd160;\t //LUT[3562] \tphase : -0.625000\t(data_i, data_q): (-0.281250,-0.687500)\n\t3563: o_phase = -9'd161;\t //LUT[3563] \tphase : -0.628906\t(data_i, data_q): (-0.281250,-0.656250)\n\t3564: o_phase = -9'd162;\t //LUT[3564] \tphase : -0.632812\t(data_i, data_q): (-0.281250,-0.625000)\n\t3565: o_phase = -9'd164;\t //LUT[3565] \tphase : -0.640625\t(data_i, data_q): (-0.281250,-0.593750)\n\t3566: o_phase = -9'd166;\t //LUT[3566] \tphase : -0.648438\t(data_i, data_q): (-0.281250,-0.562500)\n\t3567: o_phase = -9'd168;\t //LUT[3567] \tphase : -0.656250\t(data_i, data_q): (-0.281250,-0.531250)\n\t3568: o_phase = -9'd170;\t //LUT[3568] \tphase : -0.664062\t(data_i, data_q): (-0.281250,-0.500000)\n\t3569: o_phase = -9'd172;\t //LUT[3569] \tphase : -0.671875\t(data_i, data_q): (-0.281250,-0.468750)\n\t3570: o_phase = -9'd175;\t //LUT[3570] \tphase : -0.683594\t(data_i, data_q): (-0.281250,-0.437500)\n\t3571: o_phase = -9'd177;\t //LUT[3571] \tphase : -0.691406\t(data_i, data_q): (-0.281250,-0.406250)\n\t3572: o_phase = -9'd180;\t //LUT[3572] \tphase : -0.703125\t(data_i, data_q): (-0.281250,-0.375000)\n\t3573: o_phase = -9'd184;\t //LUT[3573] \tphase : -0.718750\t(data_i, data_q): (-0.281250,-0.343750)\n\t3574: o_phase = -9'd188;\t //LUT[3574] \tphase : -0.734375\t(data_i, data_q): (-0.281250,-0.312500)\n\t3575: o_phase = -9'd192;\t //LUT[3575] \tphase : -0.750000\t(data_i, data_q): (-0.281250,-0.281250)\n\t3576: o_phase = -9'd197;\t //LUT[3576] \tphase : -0.769531\t(data_i, data_q): (-0.281250,-0.250000)\n\t3577: o_phase = -9'd202;\t //LUT[3577] \tphase : -0.789062\t(data_i, data_q): (-0.281250,-0.218750)\n\t3578: o_phase = -9'd208;\t //LUT[3578] \tphase : -0.812500\t(data_i, data_q): (-0.281250,-0.187500)\n\t3579: o_phase = -9'd215;\t //LUT[3579] \tphase : -0.839844\t(data_i, data_q): (-0.281250,-0.156250)\n\t3580: o_phase = -9'd222;\t //LUT[3580] \tphase : -0.867188\t(data_i, data_q): (-0.281250,-0.125000)\n\t3581: o_phase = -9'd230;\t //LUT[3581] \tphase : -0.898438\t(data_i, data_q): (-0.281250,-0.093750)\n\t3582: o_phase = -9'd238;\t //LUT[3582] \tphase : -0.929688\t(data_i, data_q): (-0.281250,-0.062500)\n\t3583: o_phase = -9'd247;\t //LUT[3583] \tphase : -0.964844\t(data_i, data_q): (-0.281250,-0.031250)\n\t3584: o_phase = -9'd256;\t //LUT[3584] \tphase : -1.000000\t(data_i, data_q): (-0.250000,0.000000)\n\t3585: o_phase = +9'd246;\t //LUT[3585] \tphase : 0.960938\t(data_i, data_q): (-0.250000,0.031250)\n\t3586: o_phase = +9'd236;\t //LUT[3586] \tphase : 0.921875\t(data_i, data_q): (-0.250000,0.062500)\n\t3587: o_phase = +9'd227;\t //LUT[3587] \tphase : 0.886719\t(data_i, data_q): (-0.250000,0.093750)\n\t3588: o_phase = +9'd218;\t //LUT[3588] \tphase : 0.851562\t(data_i, data_q): (-0.250000,0.125000)\n\t3589: o_phase = +9'd210;\t //LUT[3589] \tphase : 0.820312\t(data_i, data_q): (-0.250000,0.156250)\n\t3590: o_phase = +9'd204;\t //LUT[3590] \tphase : 0.796875\t(data_i, data_q): (-0.250000,0.187500)\n\t3591: o_phase = +9'd197;\t //LUT[3591] \tphase : 0.769531\t(data_i, data_q): (-0.250000,0.218750)\n\t3592: o_phase = +9'd192;\t //LUT[3592] \tphase : 0.750000\t(data_i, data_q): (-0.250000,0.250000)\n\t3593: o_phase = +9'd187;\t //LUT[3593] \tphase : 0.730469\t(data_i, data_q): (-0.250000,0.281250)\n\t3594: o_phase = +9'd183;\t //LUT[3594] \tphase : 0.714844\t(data_i, data_q): (-0.250000,0.312500)\n\t3595: o_phase = +9'd179;\t //LUT[3595] \tphase : 0.699219\t(data_i, data_q): (-0.250000,0.343750)\n\t3596: o_phase = +9'd176;\t //LUT[3596] \tphase : 0.687500\t(data_i, data_q): (-0.250000,0.375000)\n\t3597: o_phase = +9'd173;\t //LUT[3597] \tphase : 0.675781\t(data_i, data_q): (-0.250000,0.406250)\n\t3598: o_phase = +9'd170;\t //LUT[3598] \tphase : 0.664062\t(data_i, data_q): (-0.250000,0.437500)\n\t3599: o_phase = +9'd168;\t //LUT[3599] \tphase : 0.656250\t(data_i, data_q): (-0.250000,0.468750)\n\t3600: o_phase = +9'd166;\t //LUT[3600] \tphase : 0.648438\t(data_i, data_q): (-0.250000,0.500000)\n\t3601: o_phase = +9'd164;\t //LUT[3601] \tphase : 0.640625\t(data_i, data_q): (-0.250000,0.531250)\n\t3602: o_phase = +9'd162;\t //LUT[3602] \tphase : 0.632812\t(data_i, data_q): (-0.250000,0.562500)\n\t3603: o_phase = +9'd160;\t //LUT[3603] \tphase : 0.625000\t(data_i, data_q): (-0.250000,0.593750)\n\t3604: o_phase = +9'd159;\t //LUT[3604] \tphase : 0.621094\t(data_i, data_q): (-0.250000,0.625000)\n\t3605: o_phase = +9'd158;\t //LUT[3605] \tphase : 0.617188\t(data_i, data_q): (-0.250000,0.656250)\n\t3606: o_phase = +9'd156;\t //LUT[3606] \tphase : 0.609375\t(data_i, data_q): (-0.250000,0.687500)\n\t3607: o_phase = +9'd155;\t //LUT[3607] \tphase : 0.605469\t(data_i, data_q): (-0.250000,0.718750)\n\t3608: o_phase = +9'd154;\t //LUT[3608] \tphase : 0.601562\t(data_i, data_q): (-0.250000,0.750000)\n\t3609: o_phase = +9'd153;\t //LUT[3609] \tphase : 0.597656\t(data_i, data_q): (-0.250000,0.781250)\n\t3610: o_phase = +9'd152;\t //LUT[3610] \tphase : 0.593750\t(data_i, data_q): (-0.250000,0.812500)\n\t3611: o_phase = +9'd151;\t //LUT[3611] \tphase : 0.589844\t(data_i, data_q): (-0.250000,0.843750)\n\t3612: o_phase = +9'd151;\t //LUT[3612] \tphase : 0.589844\t(data_i, data_q): (-0.250000,0.875000)\n\t3613: o_phase = +9'd150;\t //LUT[3613] \tphase : 0.585938\t(data_i, data_q): (-0.250000,0.906250)\n\t3614: o_phase = +9'd149;\t //LUT[3614] \tphase : 0.582031\t(data_i, data_q): (-0.250000,0.937500)\n\t3615: o_phase = +9'd149;\t //LUT[3615] \tphase : 0.582031\t(data_i, data_q): (-0.250000,0.968750)\n\t3616: o_phase = -9'd148;\t //LUT[3616] \tphase : -0.578125\t(data_i, data_q): (-0.250000,-1.000000)\n\t3617: o_phase = -9'd149;\t //LUT[3617] \tphase : -0.582031\t(data_i, data_q): (-0.250000,-0.968750)\n\t3618: o_phase = -9'd149;\t //LUT[3618] \tphase : -0.582031\t(data_i, data_q): (-0.250000,-0.937500)\n\t3619: o_phase = -9'd150;\t //LUT[3619] \tphase : -0.585938\t(data_i, data_q): (-0.250000,-0.906250)\n\t3620: o_phase = -9'd151;\t //LUT[3620] \tphase : -0.589844\t(data_i, data_q): (-0.250000,-0.875000)\n\t3621: o_phase = -9'd151;\t //LUT[3621] \tphase : -0.589844\t(data_i, data_q): (-0.250000,-0.843750)\n\t3622: o_phase = -9'd152;\t //LUT[3622] \tphase : -0.593750\t(data_i, data_q): (-0.250000,-0.812500)\n\t3623: o_phase = -9'd153;\t //LUT[3623] \tphase : -0.597656\t(data_i, data_q): (-0.250000,-0.781250)\n\t3624: o_phase = -9'd154;\t //LUT[3624] \tphase : -0.601562\t(data_i, data_q): (-0.250000,-0.750000)\n\t3625: o_phase = -9'd155;\t //LUT[3625] \tphase : -0.605469\t(data_i, data_q): (-0.250000,-0.718750)\n\t3626: o_phase = -9'd156;\t //LUT[3626] \tphase : -0.609375\t(data_i, data_q): (-0.250000,-0.687500)\n\t3627: o_phase = -9'd158;\t //LUT[3627] \tphase : -0.617188\t(data_i, data_q): (-0.250000,-0.656250)\n\t3628: o_phase = -9'd159;\t //LUT[3628] \tphase : -0.621094\t(data_i, data_q): (-0.250000,-0.625000)\n\t3629: o_phase = -9'd160;\t //LUT[3629] \tphase : -0.625000\t(data_i, data_q): (-0.250000,-0.593750)\n\t3630: o_phase = -9'd162;\t //LUT[3630] \tphase : -0.632812\t(data_i, data_q): (-0.250000,-0.562500)\n\t3631: o_phase = -9'd164;\t //LUT[3631] \tphase : -0.640625\t(data_i, data_q): (-0.250000,-0.531250)\n\t3632: o_phase = -9'd166;\t //LUT[3632] \tphase : -0.648438\t(data_i, data_q): (-0.250000,-0.500000)\n\t3633: o_phase = -9'd168;\t //LUT[3633] \tphase : -0.656250\t(data_i, data_q): (-0.250000,-0.468750)\n\t3634: o_phase = -9'd170;\t //LUT[3634] \tphase : -0.664062\t(data_i, data_q): (-0.250000,-0.437500)\n\t3635: o_phase = -9'd173;\t //LUT[3635] \tphase : -0.675781\t(data_i, data_q): (-0.250000,-0.406250)\n\t3636: o_phase = -9'd176;\t //LUT[3636] \tphase : -0.687500\t(data_i, data_q): (-0.250000,-0.375000)\n\t3637: o_phase = -9'd179;\t //LUT[3637] \tphase : -0.699219\t(data_i, data_q): (-0.250000,-0.343750)\n\t3638: o_phase = -9'd183;\t //LUT[3638] \tphase : -0.714844\t(data_i, data_q): (-0.250000,-0.312500)\n\t3639: o_phase = -9'd187;\t //LUT[3639] \tphase : -0.730469\t(data_i, data_q): (-0.250000,-0.281250)\n\t3640: o_phase = -9'd192;\t //LUT[3640] \tphase : -0.750000\t(data_i, data_q): (-0.250000,-0.250000)\n\t3641: o_phase = -9'd197;\t //LUT[3641] \tphase : -0.769531\t(data_i, data_q): (-0.250000,-0.218750)\n\t3642: o_phase = -9'd204;\t //LUT[3642] \tphase : -0.796875\t(data_i, data_q): (-0.250000,-0.187500)\n\t3643: o_phase = -9'd210;\t //LUT[3643] \tphase : -0.820312\t(data_i, data_q): (-0.250000,-0.156250)\n\t3644: o_phase = -9'd218;\t //LUT[3644] \tphase : -0.851562\t(data_i, data_q): (-0.250000,-0.125000)\n\t3645: o_phase = -9'd227;\t //LUT[3645] \tphase : -0.886719\t(data_i, data_q): (-0.250000,-0.093750)\n\t3646: o_phase = -9'd236;\t //LUT[3646] \tphase : -0.921875\t(data_i, data_q): (-0.250000,-0.062500)\n\t3647: o_phase = -9'd246;\t //LUT[3647] \tphase : -0.960938\t(data_i, data_q): (-0.250000,-0.031250)\n\t3648: o_phase = -9'd256;\t //LUT[3648] \tphase : -1.000000\t(data_i, data_q): (-0.218750,0.000000)\n\t3649: o_phase = +9'd244;\t //LUT[3649] \tphase : 0.953125\t(data_i, data_q): (-0.218750,0.031250)\n\t3650: o_phase = +9'd233;\t //LUT[3650] \tphase : 0.910156\t(data_i, data_q): (-0.218750,0.062500)\n\t3651: o_phase = +9'd223;\t //LUT[3651] \tphase : 0.871094\t(data_i, data_q): (-0.218750,0.093750)\n\t3652: o_phase = +9'd214;\t //LUT[3652] \tphase : 0.835938\t(data_i, data_q): (-0.218750,0.125000)\n\t3653: o_phase = +9'd205;\t //LUT[3653] \tphase : 0.800781\t(data_i, data_q): (-0.218750,0.156250)\n\t3654: o_phase = +9'd198;\t //LUT[3654] \tphase : 0.773438\t(data_i, data_q): (-0.218750,0.187500)\n\t3655: o_phase = +9'd192;\t //LUT[3655] \tphase : 0.750000\t(data_i, data_q): (-0.218750,0.218750)\n\t3656: o_phase = +9'd187;\t //LUT[3656] \tphase : 0.730469\t(data_i, data_q): (-0.218750,0.250000)\n\t3657: o_phase = +9'd182;\t //LUT[3657] \tphase : 0.710938\t(data_i, data_q): (-0.218750,0.281250)\n\t3658: o_phase = +9'd178;\t //LUT[3658] \tphase : 0.695312\t(data_i, data_q): (-0.218750,0.312500)\n\t3659: o_phase = +9'd174;\t //LUT[3659] \tphase : 0.679688\t(data_i, data_q): (-0.218750,0.343750)\n\t3660: o_phase = +9'd171;\t //LUT[3660] \tphase : 0.667969\t(data_i, data_q): (-0.218750,0.375000)\n\t3661: o_phase = +9'd168;\t //LUT[3661] \tphase : 0.656250\t(data_i, data_q): (-0.218750,0.406250)\n\t3662: o_phase = +9'd166;\t //LUT[3662] \tphase : 0.648438\t(data_i, data_q): (-0.218750,0.437500)\n\t3663: o_phase = +9'd164;\t //LUT[3663] \tphase : 0.640625\t(data_i, data_q): (-0.218750,0.468750)\n\t3664: o_phase = +9'd162;\t //LUT[3664] \tphase : 0.632812\t(data_i, data_q): (-0.218750,0.500000)\n\t3665: o_phase = +9'd160;\t //LUT[3665] \tphase : 0.625000\t(data_i, data_q): (-0.218750,0.531250)\n\t3666: o_phase = +9'd158;\t //LUT[3666] \tphase : 0.617188\t(data_i, data_q): (-0.218750,0.562500)\n\t3667: o_phase = +9'd157;\t //LUT[3667] \tphase : 0.613281\t(data_i, data_q): (-0.218750,0.593750)\n\t3668: o_phase = +9'd155;\t //LUT[3668] \tphase : 0.605469\t(data_i, data_q): (-0.218750,0.625000)\n\t3669: o_phase = +9'd154;\t //LUT[3669] \tphase : 0.601562\t(data_i, data_q): (-0.218750,0.656250)\n\t3670: o_phase = +9'd153;\t //LUT[3670] \tphase : 0.597656\t(data_i, data_q): (-0.218750,0.687500)\n\t3671: o_phase = +9'd152;\t //LUT[3671] \tphase : 0.593750\t(data_i, data_q): (-0.218750,0.718750)\n\t3672: o_phase = +9'd151;\t //LUT[3672] \tphase : 0.589844\t(data_i, data_q): (-0.218750,0.750000)\n\t3673: o_phase = +9'd150;\t //LUT[3673] \tphase : 0.585938\t(data_i, data_q): (-0.218750,0.781250)\n\t3674: o_phase = +9'd149;\t //LUT[3674] \tphase : 0.582031\t(data_i, data_q): (-0.218750,0.812500)\n\t3675: o_phase = +9'd149;\t //LUT[3675] \tphase : 0.582031\t(data_i, data_q): (-0.218750,0.843750)\n\t3676: o_phase = +9'd148;\t //LUT[3676] \tphase : 0.578125\t(data_i, data_q): (-0.218750,0.875000)\n\t3677: o_phase = +9'd147;\t //LUT[3677] \tphase : 0.574219\t(data_i, data_q): (-0.218750,0.906250)\n\t3678: o_phase = +9'd147;\t //LUT[3678] \tphase : 0.574219\t(data_i, data_q): (-0.218750,0.937500)\n\t3679: o_phase = +9'd146;\t //LUT[3679] \tphase : 0.570312\t(data_i, data_q): (-0.218750,0.968750)\n\t3680: o_phase = -9'd146;\t //LUT[3680] \tphase : -0.570312\t(data_i, data_q): (-0.218750,-1.000000)\n\t3681: o_phase = -9'd146;\t //LUT[3681] \tphase : -0.570312\t(data_i, data_q): (-0.218750,-0.968750)\n\t3682: o_phase = -9'd147;\t //LUT[3682] \tphase : -0.574219\t(data_i, data_q): (-0.218750,-0.937500)\n\t3683: o_phase = -9'd147;\t //LUT[3683] \tphase : -0.574219\t(data_i, data_q): (-0.218750,-0.906250)\n\t3684: o_phase = -9'd148;\t //LUT[3684] \tphase : -0.578125\t(data_i, data_q): (-0.218750,-0.875000)\n\t3685: o_phase = -9'd149;\t //LUT[3685] \tphase : -0.582031\t(data_i, data_q): (-0.218750,-0.843750)\n\t3686: o_phase = -9'd149;\t //LUT[3686] \tphase : -0.582031\t(data_i, data_q): (-0.218750,-0.812500)\n\t3687: o_phase = -9'd150;\t //LUT[3687] \tphase : -0.585938\t(data_i, data_q): (-0.218750,-0.781250)\n\t3688: o_phase = -9'd151;\t //LUT[3688] \tphase : -0.589844\t(data_i, data_q): (-0.218750,-0.750000)\n\t3689: o_phase = -9'd152;\t //LUT[3689] \tphase : -0.593750\t(data_i, data_q): (-0.218750,-0.718750)\n\t3690: o_phase = -9'd153;\t //LUT[3690] \tphase : -0.597656\t(data_i, data_q): (-0.218750,-0.687500)\n\t3691: o_phase = -9'd154;\t //LUT[3691] \tphase : -0.601562\t(data_i, data_q): (-0.218750,-0.656250)\n\t3692: o_phase = -9'd155;\t //LUT[3692] \tphase : -0.605469\t(data_i, data_q): (-0.218750,-0.625000)\n\t3693: o_phase = -9'd157;\t //LUT[3693] \tphase : -0.613281\t(data_i, data_q): (-0.218750,-0.593750)\n\t3694: o_phase = -9'd158;\t //LUT[3694] \tphase : -0.617188\t(data_i, data_q): (-0.218750,-0.562500)\n\t3695: o_phase = -9'd160;\t //LUT[3695] \tphase : -0.625000\t(data_i, data_q): (-0.218750,-0.531250)\n\t3696: o_phase = -9'd162;\t //LUT[3696] \tphase : -0.632812\t(data_i, data_q): (-0.218750,-0.500000)\n\t3697: o_phase = -9'd164;\t //LUT[3697] \tphase : -0.640625\t(data_i, data_q): (-0.218750,-0.468750)\n\t3698: o_phase = -9'd166;\t //LUT[3698] \tphase : -0.648438\t(data_i, data_q): (-0.218750,-0.437500)\n\t3699: o_phase = -9'd168;\t //LUT[3699] \tphase : -0.656250\t(data_i, data_q): (-0.218750,-0.406250)\n\t3700: o_phase = -9'd171;\t //LUT[3700] \tphase : -0.667969\t(data_i, data_q): (-0.218750,-0.375000)\n\t3701: o_phase = -9'd174;\t //LUT[3701] \tphase : -0.679688\t(data_i, data_q): (-0.218750,-0.343750)\n\t3702: o_phase = -9'd178;\t //LUT[3702] \tphase : -0.695312\t(data_i, data_q): (-0.218750,-0.312500)\n\t3703: o_phase = -9'd182;\t //LUT[3703] \tphase : -0.710938\t(data_i, data_q): (-0.218750,-0.281250)\n\t3704: o_phase = -9'd187;\t //LUT[3704] \tphase : -0.730469\t(data_i, data_q): (-0.218750,-0.250000)\n\t3705: o_phase = -9'd192;\t //LUT[3705] \tphase : -0.750000\t(data_i, data_q): (-0.218750,-0.218750)\n\t3706: o_phase = -9'd198;\t //LUT[3706] \tphase : -0.773438\t(data_i, data_q): (-0.218750,-0.187500)\n\t3707: o_phase = -9'd205;\t //LUT[3707] \tphase : -0.800781\t(data_i, data_q): (-0.218750,-0.156250)\n\t3708: o_phase = -9'd214;\t //LUT[3708] \tphase : -0.835938\t(data_i, data_q): (-0.218750,-0.125000)\n\t3709: o_phase = -9'd223;\t //LUT[3709] \tphase : -0.871094\t(data_i, data_q): (-0.218750,-0.093750)\n\t3710: o_phase = -9'd233;\t //LUT[3710] \tphase : -0.910156\t(data_i, data_q): (-0.218750,-0.062500)\n\t3711: o_phase = -9'd244;\t //LUT[3711] \tphase : -0.953125\t(data_i, data_q): (-0.218750,-0.031250)\n\t3712: o_phase = -9'd256;\t //LUT[3712] \tphase : -1.000000\t(data_i, data_q): (-0.187500,0.000000)\n\t3713: o_phase = +9'd243;\t //LUT[3713] \tphase : 0.949219\t(data_i, data_q): (-0.187500,0.031250)\n\t3714: o_phase = +9'd230;\t //LUT[3714] \tphase : 0.898438\t(data_i, data_q): (-0.187500,0.062500)\n\t3715: o_phase = +9'd218;\t //LUT[3715] \tphase : 0.851562\t(data_i, data_q): (-0.187500,0.093750)\n\t3716: o_phase = +9'd208;\t //LUT[3716] \tphase : 0.812500\t(data_i, data_q): (-0.187500,0.125000)\n\t3717: o_phase = +9'd199;\t //LUT[3717] \tphase : 0.777344\t(data_i, data_q): (-0.187500,0.156250)\n\t3718: o_phase = +9'd192;\t //LUT[3718] \tphase : 0.750000\t(data_i, data_q): (-0.187500,0.187500)\n\t3719: o_phase = +9'd186;\t //LUT[3719] \tphase : 0.726562\t(data_i, data_q): (-0.187500,0.218750)\n\t3720: o_phase = +9'd180;\t //LUT[3720] \tphase : 0.703125\t(data_i, data_q): (-0.187500,0.250000)\n\t3721: o_phase = +9'd176;\t //LUT[3721] \tphase : 0.687500\t(data_i, data_q): (-0.187500,0.281250)\n\t3722: o_phase = +9'd172;\t //LUT[3722] \tphase : 0.671875\t(data_i, data_q): (-0.187500,0.312500)\n\t3723: o_phase = +9'd169;\t //LUT[3723] \tphase : 0.660156\t(data_i, data_q): (-0.187500,0.343750)\n\t3724: o_phase = +9'd166;\t //LUT[3724] \tphase : 0.648438\t(data_i, data_q): (-0.187500,0.375000)\n\t3725: o_phase = +9'd163;\t //LUT[3725] \tphase : 0.636719\t(data_i, data_q): (-0.187500,0.406250)\n\t3726: o_phase = +9'd161;\t //LUT[3726] \tphase : 0.628906\t(data_i, data_q): (-0.187500,0.437500)\n\t3727: o_phase = +9'd159;\t //LUT[3727] \tphase : 0.621094\t(data_i, data_q): (-0.187500,0.468750)\n\t3728: o_phase = +9'd157;\t //LUT[3728] \tphase : 0.613281\t(data_i, data_q): (-0.187500,0.500000)\n\t3729: o_phase = +9'd156;\t //LUT[3729] \tphase : 0.609375\t(data_i, data_q): (-0.187500,0.531250)\n\t3730: o_phase = +9'd154;\t //LUT[3730] \tphase : 0.601562\t(data_i, data_q): (-0.187500,0.562500)\n\t3731: o_phase = +9'd153;\t //LUT[3731] \tphase : 0.597656\t(data_i, data_q): (-0.187500,0.593750)\n\t3732: o_phase = +9'd152;\t //LUT[3732] \tphase : 0.593750\t(data_i, data_q): (-0.187500,0.625000)\n\t3733: o_phase = +9'd151;\t //LUT[3733] \tphase : 0.589844\t(data_i, data_q): (-0.187500,0.656250)\n\t3734: o_phase = +9'd150;\t //LUT[3734] \tphase : 0.585938\t(data_i, data_q): (-0.187500,0.687500)\n\t3735: o_phase = +9'd149;\t //LUT[3735] \tphase : 0.582031\t(data_i, data_q): (-0.187500,0.718750)\n\t3736: o_phase = +9'd148;\t //LUT[3736] \tphase : 0.578125\t(data_i, data_q): (-0.187500,0.750000)\n\t3737: o_phase = +9'd147;\t //LUT[3737] \tphase : 0.574219\t(data_i, data_q): (-0.187500,0.781250)\n\t3738: o_phase = +9'd146;\t //LUT[3738] \tphase : 0.570312\t(data_i, data_q): (-0.187500,0.812500)\n\t3739: o_phase = +9'd146;\t //LUT[3739] \tphase : 0.570312\t(data_i, data_q): (-0.187500,0.843750)\n\t3740: o_phase = +9'd145;\t //LUT[3740] \tphase : 0.566406\t(data_i, data_q): (-0.187500,0.875000)\n\t3741: o_phase = +9'd145;\t //LUT[3741] \tphase : 0.566406\t(data_i, data_q): (-0.187500,0.906250)\n\t3742: o_phase = +9'd144;\t //LUT[3742] \tphase : 0.562500\t(data_i, data_q): (-0.187500,0.937500)\n\t3743: o_phase = +9'd144;\t //LUT[3743] \tphase : 0.562500\t(data_i, data_q): (-0.187500,0.968750)\n\t3744: o_phase = -9'd143;\t //LUT[3744] \tphase : -0.558594\t(data_i, data_q): (-0.187500,-1.000000)\n\t3745: o_phase = -9'd144;\t //LUT[3745] \tphase : -0.562500\t(data_i, data_q): (-0.187500,-0.968750)\n\t3746: o_phase = -9'd144;\t //LUT[3746] \tphase : -0.562500\t(data_i, data_q): (-0.187500,-0.937500)\n\t3747: o_phase = -9'd145;\t //LUT[3747] \tphase : -0.566406\t(data_i, data_q): (-0.187500,-0.906250)\n\t3748: o_phase = -9'd145;\t //LUT[3748] \tphase : -0.566406\t(data_i, data_q): (-0.187500,-0.875000)\n\t3749: o_phase = -9'd146;\t //LUT[3749] \tphase : -0.570312\t(data_i, data_q): (-0.187500,-0.843750)\n\t3750: o_phase = -9'd146;\t //LUT[3750] \tphase : -0.570312\t(data_i, data_q): (-0.187500,-0.812500)\n\t3751: o_phase = -9'd147;\t //LUT[3751] \tphase : -0.574219\t(data_i, data_q): (-0.187500,-0.781250)\n\t3752: o_phase = -9'd148;\t //LUT[3752] \tphase : -0.578125\t(data_i, data_q): (-0.187500,-0.750000)\n\t3753: o_phase = -9'd149;\t //LUT[3753] \tphase : -0.582031\t(data_i, data_q): (-0.187500,-0.718750)\n\t3754: o_phase = -9'd150;\t //LUT[3754] \tphase : -0.585938\t(data_i, data_q): (-0.187500,-0.687500)\n\t3755: o_phase = -9'd151;\t //LUT[3755] \tphase : -0.589844\t(data_i, data_q): (-0.187500,-0.656250)\n\t3756: o_phase = -9'd152;\t //LUT[3756] \tphase : -0.593750\t(data_i, data_q): (-0.187500,-0.625000)\n\t3757: o_phase = -9'd153;\t //LUT[3757] \tphase : -0.597656\t(data_i, data_q): (-0.187500,-0.593750)\n\t3758: o_phase = -9'd154;\t //LUT[3758] \tphase : -0.601562\t(data_i, data_q): (-0.187500,-0.562500)\n\t3759: o_phase = -9'd156;\t //LUT[3759] \tphase : -0.609375\t(data_i, data_q): (-0.187500,-0.531250)\n\t3760: o_phase = -9'd157;\t //LUT[3760] \tphase : -0.613281\t(data_i, data_q): (-0.187500,-0.500000)\n\t3761: o_phase = -9'd159;\t //LUT[3761] \tphase : -0.621094\t(data_i, data_q): (-0.187500,-0.468750)\n\t3762: o_phase = -9'd161;\t //LUT[3762] \tphase : -0.628906\t(data_i, data_q): (-0.187500,-0.437500)\n\t3763: o_phase = -9'd163;\t //LUT[3763] \tphase : -0.636719\t(data_i, data_q): (-0.187500,-0.406250)\n\t3764: o_phase = -9'd166;\t //LUT[3764] \tphase : -0.648438\t(data_i, data_q): (-0.187500,-0.375000)\n\t3765: o_phase = -9'd169;\t //LUT[3765] \tphase : -0.660156\t(data_i, data_q): (-0.187500,-0.343750)\n\t3766: o_phase = -9'd172;\t //LUT[3766] \tphase : -0.671875\t(data_i, data_q): (-0.187500,-0.312500)\n\t3767: o_phase = -9'd176;\t //LUT[3767] \tphase : -0.687500\t(data_i, data_q): (-0.187500,-0.281250)\n\t3768: o_phase = -9'd180;\t //LUT[3768] \tphase : -0.703125\t(data_i, data_q): (-0.187500,-0.250000)\n\t3769: o_phase = -9'd186;\t //LUT[3769] \tphase : -0.726562\t(data_i, data_q): (-0.187500,-0.218750)\n\t3770: o_phase = -9'd192;\t //LUT[3770] \tphase : -0.750000\t(data_i, data_q): (-0.187500,-0.187500)\n\t3771: o_phase = -9'd199;\t //LUT[3771] \tphase : -0.777344\t(data_i, data_q): (-0.187500,-0.156250)\n\t3772: o_phase = -9'd208;\t //LUT[3772] \tphase : -0.812500\t(data_i, data_q): (-0.187500,-0.125000)\n\t3773: o_phase = -9'd218;\t //LUT[3773] \tphase : -0.851562\t(data_i, data_q): (-0.187500,-0.093750)\n\t3774: o_phase = -9'd230;\t //LUT[3774] \tphase : -0.898438\t(data_i, data_q): (-0.187500,-0.062500)\n\t3775: o_phase = -9'd243;\t //LUT[3775] \tphase : -0.949219\t(data_i, data_q): (-0.187500,-0.031250)\n\t3776: o_phase = -9'd256;\t //LUT[3776] \tphase : -1.000000\t(data_i, data_q): (-0.156250,0.000000)\n\t3777: o_phase = +9'd240;\t //LUT[3777] \tphase : 0.937500\t(data_i, data_q): (-0.156250,0.031250)\n\t3778: o_phase = +9'd225;\t //LUT[3778] \tphase : 0.878906\t(data_i, data_q): (-0.156250,0.062500)\n\t3779: o_phase = +9'd212;\t //LUT[3779] \tphase : 0.828125\t(data_i, data_q): (-0.156250,0.093750)\n\t3780: o_phase = +9'd201;\t //LUT[3780] \tphase : 0.785156\t(data_i, data_q): (-0.156250,0.125000)\n\t3781: o_phase = +9'd192;\t //LUT[3781] \tphase : 0.750000\t(data_i, data_q): (-0.156250,0.156250)\n\t3782: o_phase = +9'd185;\t //LUT[3782] \tphase : 0.722656\t(data_i, data_q): (-0.156250,0.187500)\n\t3783: o_phase = +9'd179;\t //LUT[3783] \tphase : 0.699219\t(data_i, data_q): (-0.156250,0.218750)\n\t3784: o_phase = +9'd174;\t //LUT[3784] \tphase : 0.679688\t(data_i, data_q): (-0.156250,0.250000)\n\t3785: o_phase = +9'd169;\t //LUT[3785] \tphase : 0.660156\t(data_i, data_q): (-0.156250,0.281250)\n\t3786: o_phase = +9'd166;\t //LUT[3786] \tphase : 0.648438\t(data_i, data_q): (-0.156250,0.312500)\n\t3787: o_phase = +9'd163;\t //LUT[3787] \tphase : 0.636719\t(data_i, data_q): (-0.156250,0.343750)\n\t3788: o_phase = +9'd160;\t //LUT[3788] \tphase : 0.625000\t(data_i, data_q): (-0.156250,0.375000)\n\t3789: o_phase = +9'd158;\t //LUT[3789] \tphase : 0.617188\t(data_i, data_q): (-0.156250,0.406250)\n\t3790: o_phase = +9'd156;\t //LUT[3790] \tphase : 0.609375\t(data_i, data_q): (-0.156250,0.437500)\n\t3791: o_phase = +9'd154;\t //LUT[3791] \tphase : 0.601562\t(data_i, data_q): (-0.156250,0.468750)\n\t3792: o_phase = +9'd153;\t //LUT[3792] \tphase : 0.597656\t(data_i, data_q): (-0.156250,0.500000)\n\t3793: o_phase = +9'd151;\t //LUT[3793] \tphase : 0.589844\t(data_i, data_q): (-0.156250,0.531250)\n\t3794: o_phase = +9'd150;\t //LUT[3794] \tphase : 0.585938\t(data_i, data_q): (-0.156250,0.562500)\n\t3795: o_phase = +9'd149;\t //LUT[3795] \tphase : 0.582031\t(data_i, data_q): (-0.156250,0.593750)\n\t3796: o_phase = +9'd148;\t //LUT[3796] \tphase : 0.578125\t(data_i, data_q): (-0.156250,0.625000)\n\t3797: o_phase = +9'd147;\t //LUT[3797] \tphase : 0.574219\t(data_i, data_q): (-0.156250,0.656250)\n\t3798: o_phase = +9'd146;\t //LUT[3798] \tphase : 0.570312\t(data_i, data_q): (-0.156250,0.687500)\n\t3799: o_phase = +9'd145;\t //LUT[3799] \tphase : 0.566406\t(data_i, data_q): (-0.156250,0.718750)\n\t3800: o_phase = +9'd145;\t //LUT[3800] \tphase : 0.566406\t(data_i, data_q): (-0.156250,0.750000)\n\t3801: o_phase = +9'd144;\t //LUT[3801] \tphase : 0.562500\t(data_i, data_q): (-0.156250,0.781250)\n\t3802: o_phase = +9'd143;\t //LUT[3802] \tphase : 0.558594\t(data_i, data_q): (-0.156250,0.812500)\n\t3803: o_phase = +9'd143;\t //LUT[3803] \tphase : 0.558594\t(data_i, data_q): (-0.156250,0.843750)\n\t3804: o_phase = +9'd142;\t //LUT[3804] \tphase : 0.554688\t(data_i, data_q): (-0.156250,0.875000)\n\t3805: o_phase = +9'd142;\t //LUT[3805] \tphase : 0.554688\t(data_i, data_q): (-0.156250,0.906250)\n\t3806: o_phase = +9'd141;\t //LUT[3806] \tphase : 0.550781\t(data_i, data_q): (-0.156250,0.937500)\n\t3807: o_phase = +9'd141;\t //LUT[3807] \tphase : 0.550781\t(data_i, data_q): (-0.156250,0.968750)\n\t3808: o_phase = -9'd141;\t //LUT[3808] \tphase : -0.550781\t(data_i, data_q): (-0.156250,-1.000000)\n\t3809: o_phase = -9'd141;\t //LUT[3809] \tphase : -0.550781\t(data_i, data_q): (-0.156250,-0.968750)\n\t3810: o_phase = -9'd141;\t //LUT[3810] \tphase : -0.550781\t(data_i, data_q): (-0.156250,-0.937500)\n\t3811: o_phase = -9'd142;\t //LUT[3811] \tphase : -0.554688\t(data_i, data_q): (-0.156250,-0.906250)\n\t3812: o_phase = -9'd142;\t //LUT[3812] \tphase : -0.554688\t(data_i, data_q): (-0.156250,-0.875000)\n\t3813: o_phase = -9'd143;\t //LUT[3813] \tphase : -0.558594\t(data_i, data_q): (-0.156250,-0.843750)\n\t3814: o_phase = -9'd143;\t //LUT[3814] \tphase : -0.558594\t(data_i, data_q): (-0.156250,-0.812500)\n\t3815: o_phase = -9'd144;\t //LUT[3815] \tphase : -0.562500\t(data_i, data_q): (-0.156250,-0.781250)\n\t3816: o_phase = -9'd145;\t //LUT[3816] \tphase : -0.566406\t(data_i, data_q): (-0.156250,-0.750000)\n\t3817: o_phase = -9'd145;\t //LUT[3817] \tphase : -0.566406\t(data_i, data_q): (-0.156250,-0.718750)\n\t3818: o_phase = -9'd146;\t //LUT[3818] \tphase : -0.570312\t(data_i, data_q): (-0.156250,-0.687500)\n\t3819: o_phase = -9'd147;\t //LUT[3819] \tphase : -0.574219\t(data_i, data_q): (-0.156250,-0.656250)\n\t3820: o_phase = -9'd148;\t //LUT[3820] \tphase : -0.578125\t(data_i, data_q): (-0.156250,-0.625000)\n\t3821: o_phase = -9'd149;\t //LUT[3821] \tphase : -0.582031\t(data_i, data_q): (-0.156250,-0.593750)\n\t3822: o_phase = -9'd150;\t //LUT[3822] \tphase : -0.585938\t(data_i, data_q): (-0.156250,-0.562500)\n\t3823: o_phase = -9'd151;\t //LUT[3823] \tphase : -0.589844\t(data_i, data_q): (-0.156250,-0.531250)\n\t3824: o_phase = -9'd153;\t //LUT[3824] \tphase : -0.597656\t(data_i, data_q): (-0.156250,-0.500000)\n\t3825: o_phase = -9'd154;\t //LUT[3825] \tphase : -0.601562\t(data_i, data_q): (-0.156250,-0.468750)\n\t3826: o_phase = -9'd156;\t //LUT[3826] \tphase : -0.609375\t(data_i, data_q): (-0.156250,-0.437500)\n\t3827: o_phase = -9'd158;\t //LUT[3827] \tphase : -0.617188\t(data_i, data_q): (-0.156250,-0.406250)\n\t3828: o_phase = -9'd160;\t //LUT[3828] \tphase : -0.625000\t(data_i, data_q): (-0.156250,-0.375000)\n\t3829: o_phase = -9'd163;\t //LUT[3829] \tphase : -0.636719\t(data_i, data_q): (-0.156250,-0.343750)\n\t3830: o_phase = -9'd166;\t //LUT[3830] \tphase : -0.648438\t(data_i, data_q): (-0.156250,-0.312500)\n\t3831: o_phase = -9'd169;\t //LUT[3831] \tphase : -0.660156\t(data_i, data_q): (-0.156250,-0.281250)\n\t3832: o_phase = -9'd174;\t //LUT[3832] \tphase : -0.679688\t(data_i, data_q): (-0.156250,-0.250000)\n\t3833: o_phase = -9'd179;\t //LUT[3833] \tphase : -0.699219\t(data_i, data_q): (-0.156250,-0.218750)\n\t3834: o_phase = -9'd185;\t //LUT[3834] \tphase : -0.722656\t(data_i, data_q): (-0.156250,-0.187500)\n\t3835: o_phase = -9'd192;\t //LUT[3835] \tphase : -0.750000\t(data_i, data_q): (-0.156250,-0.156250)\n\t3836: o_phase = -9'd201;\t //LUT[3836] \tphase : -0.785156\t(data_i, data_q): (-0.156250,-0.125000)\n\t3837: o_phase = -9'd212;\t //LUT[3837] \tphase : -0.828125\t(data_i, data_q): (-0.156250,-0.093750)\n\t3838: o_phase = -9'd225;\t //LUT[3838] \tphase : -0.878906\t(data_i, data_q): (-0.156250,-0.062500)\n\t3839: o_phase = -9'd240;\t //LUT[3839] \tphase : -0.937500\t(data_i, data_q): (-0.156250,-0.031250)\n\t3840: o_phase = -9'd256;\t //LUT[3840] \tphase : -1.000000\t(data_i, data_q): (-0.125000,0.000000)\n\t3841: o_phase = +9'd236;\t //LUT[3841] \tphase : 0.921875\t(data_i, data_q): (-0.125000,0.031250)\n\t3842: o_phase = +9'd218;\t //LUT[3842] \tphase : 0.851562\t(data_i, data_q): (-0.125000,0.062500)\n\t3843: o_phase = +9'd204;\t //LUT[3843] \tphase : 0.796875\t(data_i, data_q): (-0.125000,0.093750)\n\t3844: o_phase = +9'd192;\t //LUT[3844] \tphase : 0.750000\t(data_i, data_q): (-0.125000,0.125000)\n\t3845: o_phase = +9'd183;\t //LUT[3845] \tphase : 0.714844\t(data_i, data_q): (-0.125000,0.156250)\n\t3846: o_phase = +9'd176;\t //LUT[3846] \tphase : 0.687500\t(data_i, data_q): (-0.125000,0.187500)\n\t3847: o_phase = +9'd170;\t //LUT[3847] \tphase : 0.664062\t(data_i, data_q): (-0.125000,0.218750)\n\t3848: o_phase = +9'd166;\t //LUT[3848] \tphase : 0.648438\t(data_i, data_q): (-0.125000,0.250000)\n\t3849: o_phase = +9'd162;\t //LUT[3849] \tphase : 0.632812\t(data_i, data_q): (-0.125000,0.281250)\n\t3850: o_phase = +9'd159;\t //LUT[3850] \tphase : 0.621094\t(data_i, data_q): (-0.125000,0.312500)\n\t3851: o_phase = +9'd156;\t //LUT[3851] \tphase : 0.609375\t(data_i, data_q): (-0.125000,0.343750)\n\t3852: o_phase = +9'd154;\t //LUT[3852] \tphase : 0.601562\t(data_i, data_q): (-0.125000,0.375000)\n\t3853: o_phase = +9'd152;\t //LUT[3853] \tphase : 0.593750\t(data_i, data_q): (-0.125000,0.406250)\n\t3854: o_phase = +9'd151;\t //LUT[3854] \tphase : 0.589844\t(data_i, data_q): (-0.125000,0.437500)\n\t3855: o_phase = +9'd149;\t //LUT[3855] \tphase : 0.582031\t(data_i, data_q): (-0.125000,0.468750)\n\t3856: o_phase = +9'd148;\t //LUT[3856] \tphase : 0.578125\t(data_i, data_q): (-0.125000,0.500000)\n\t3857: o_phase = +9'd147;\t //LUT[3857] \tphase : 0.574219\t(data_i, data_q): (-0.125000,0.531250)\n\t3858: o_phase = +9'd146;\t //LUT[3858] \tphase : 0.570312\t(data_i, data_q): (-0.125000,0.562500)\n\t3859: o_phase = +9'd145;\t //LUT[3859] \tphase : 0.566406\t(data_i, data_q): (-0.125000,0.593750)\n\t3860: o_phase = +9'd144;\t //LUT[3860] \tphase : 0.562500\t(data_i, data_q): (-0.125000,0.625000)\n\t3861: o_phase = +9'd143;\t //LUT[3861] \tphase : 0.558594\t(data_i, data_q): (-0.125000,0.656250)\n\t3862: o_phase = +9'd143;\t //LUT[3862] \tphase : 0.558594\t(data_i, data_q): (-0.125000,0.687500)\n\t3863: o_phase = +9'd142;\t //LUT[3863] \tphase : 0.554688\t(data_i, data_q): (-0.125000,0.718750)\n\t3864: o_phase = +9'd141;\t //LUT[3864] \tphase : 0.550781\t(data_i, data_q): (-0.125000,0.750000)\n\t3865: o_phase = +9'd141;\t //LUT[3865] \tphase : 0.550781\t(data_i, data_q): (-0.125000,0.781250)\n\t3866: o_phase = +9'd140;\t //LUT[3866] \tphase : 0.546875\t(data_i, data_q): (-0.125000,0.812500)\n\t3867: o_phase = +9'd140;\t //LUT[3867] \tphase : 0.546875\t(data_i, data_q): (-0.125000,0.843750)\n\t3868: o_phase = +9'd140;\t //LUT[3868] \tphase : 0.546875\t(data_i, data_q): (-0.125000,0.875000)\n\t3869: o_phase = +9'd139;\t //LUT[3869] \tphase : 0.542969\t(data_i, data_q): (-0.125000,0.906250)\n\t3870: o_phase = +9'd139;\t //LUT[3870] \tphase : 0.542969\t(data_i, data_q): (-0.125000,0.937500)\n\t3871: o_phase = +9'd138;\t //LUT[3871] \tphase : 0.539062\t(data_i, data_q): (-0.125000,0.968750)\n\t3872: o_phase = -9'd138;\t //LUT[3872] \tphase : -0.539062\t(data_i, data_q): (-0.125000,-1.000000)\n\t3873: o_phase = -9'd138;\t //LUT[3873] \tphase : -0.539062\t(data_i, data_q): (-0.125000,-0.968750)\n\t3874: o_phase = -9'd139;\t //LUT[3874] \tphase : -0.542969\t(data_i, data_q): (-0.125000,-0.937500)\n\t3875: o_phase = -9'd139;\t //LUT[3875] \tphase : -0.542969\t(data_i, data_q): (-0.125000,-0.906250)\n\t3876: o_phase = -9'd140;\t //LUT[3876] \tphase : -0.546875\t(data_i, data_q): (-0.125000,-0.875000)\n\t3877: o_phase = -9'd140;\t //LUT[3877] \tphase : -0.546875\t(data_i, data_q): (-0.125000,-0.843750)\n\t3878: o_phase = -9'd140;\t //LUT[3878] \tphase : -0.546875\t(data_i, data_q): (-0.125000,-0.812500)\n\t3879: o_phase = -9'd141;\t //LUT[3879] \tphase : -0.550781\t(data_i, data_q): (-0.125000,-0.781250)\n\t3880: o_phase = -9'd141;\t //LUT[3880] \tphase : -0.550781\t(data_i, data_q): (-0.125000,-0.750000)\n\t3881: o_phase = -9'd142;\t //LUT[3881] \tphase : -0.554688\t(data_i, data_q): (-0.125000,-0.718750)\n\t3882: o_phase = -9'd143;\t //LUT[3882] \tphase : -0.558594\t(data_i, data_q): (-0.125000,-0.687500)\n\t3883: o_phase = -9'd143;\t //LUT[3883] \tphase : -0.558594\t(data_i, data_q): (-0.125000,-0.656250)\n\t3884: o_phase = -9'd144;\t //LUT[3884] \tphase : -0.562500\t(data_i, data_q): (-0.125000,-0.625000)\n\t3885: o_phase = -9'd145;\t //LUT[3885] \tphase : -0.566406\t(data_i, data_q): (-0.125000,-0.593750)\n\t3886: o_phase = -9'd146;\t //LUT[3886] \tphase : -0.570312\t(data_i, data_q): (-0.125000,-0.562500)\n\t3887: o_phase = -9'd147;\t //LUT[3887] \tphase : -0.574219\t(data_i, data_q): (-0.125000,-0.531250)\n\t3888: o_phase = -9'd148;\t //LUT[3888] \tphase : -0.578125\t(data_i, data_q): (-0.125000,-0.500000)\n\t3889: o_phase = -9'd149;\t //LUT[3889] \tphase : -0.582031\t(data_i, data_q): (-0.125000,-0.468750)\n\t3890: o_phase = -9'd151;\t //LUT[3890] \tphase : -0.589844\t(data_i, data_q): (-0.125000,-0.437500)\n\t3891: o_phase = -9'd152;\t //LUT[3891] \tphase : -0.593750\t(data_i, data_q): (-0.125000,-0.406250)\n\t3892: o_phase = -9'd154;\t //LUT[3892] \tphase : -0.601562\t(data_i, data_q): (-0.125000,-0.375000)\n\t3893: o_phase = -9'd156;\t //LUT[3893] \tphase : -0.609375\t(data_i, data_q): (-0.125000,-0.343750)\n\t3894: o_phase = -9'd159;\t //LUT[3894] \tphase : -0.621094\t(data_i, data_q): (-0.125000,-0.312500)\n\t3895: o_phase = -9'd162;\t //LUT[3895] \tphase : -0.632812\t(data_i, data_q): (-0.125000,-0.281250)\n\t3896: o_phase = -9'd166;\t //LUT[3896] \tphase : -0.648438\t(data_i, data_q): (-0.125000,-0.250000)\n\t3897: o_phase = -9'd170;\t //LUT[3897] \tphase : -0.664062\t(data_i, data_q): (-0.125000,-0.218750)\n\t3898: o_phase = -9'd176;\t //LUT[3898] \tphase : -0.687500\t(data_i, data_q): (-0.125000,-0.187500)\n\t3899: o_phase = -9'd183;\t //LUT[3899] \tphase : -0.714844\t(data_i, data_q): (-0.125000,-0.156250)\n\t3900: o_phase = -9'd192;\t //LUT[3900] \tphase : -0.750000\t(data_i, data_q): (-0.125000,-0.125000)\n\t3901: o_phase = -9'd204;\t //LUT[3901] \tphase : -0.796875\t(data_i, data_q): (-0.125000,-0.093750)\n\t3902: o_phase = -9'd218;\t //LUT[3902] \tphase : -0.851562\t(data_i, data_q): (-0.125000,-0.062500)\n\t3903: o_phase = -9'd236;\t //LUT[3903] \tphase : -0.921875\t(data_i, data_q): (-0.125000,-0.031250)\n\t3904: o_phase = -9'd256;\t //LUT[3904] \tphase : -1.000000\t(data_i, data_q): (-0.093750,0.000000)\n\t3905: o_phase = +9'd230;\t //LUT[3905] \tphase : 0.898438\t(data_i, data_q): (-0.093750,0.031250)\n\t3906: o_phase = +9'd208;\t //LUT[3906] \tphase : 0.812500\t(data_i, data_q): (-0.093750,0.062500)\n\t3907: o_phase = +9'd192;\t //LUT[3907] \tphase : 0.750000\t(data_i, data_q): (-0.093750,0.093750)\n\t3908: o_phase = +9'd180;\t //LUT[3908] \tphase : 0.703125\t(data_i, data_q): (-0.093750,0.125000)\n\t3909: o_phase = +9'd172;\t //LUT[3909] \tphase : 0.671875\t(data_i, data_q): (-0.093750,0.156250)\n\t3910: o_phase = +9'd166;\t //LUT[3910] \tphase : 0.648438\t(data_i, data_q): (-0.093750,0.187500)\n\t3911: o_phase = +9'd161;\t //LUT[3911] \tphase : 0.628906\t(data_i, data_q): (-0.093750,0.218750)\n\t3912: o_phase = +9'd157;\t //LUT[3912] \tphase : 0.613281\t(data_i, data_q): (-0.093750,0.250000)\n\t3913: o_phase = +9'd154;\t //LUT[3913] \tphase : 0.601562\t(data_i, data_q): (-0.093750,0.281250)\n\t3914: o_phase = +9'd152;\t //LUT[3914] \tphase : 0.593750\t(data_i, data_q): (-0.093750,0.312500)\n\t3915: o_phase = +9'd150;\t //LUT[3915] \tphase : 0.585938\t(data_i, data_q): (-0.093750,0.343750)\n\t3916: o_phase = +9'd148;\t //LUT[3916] \tphase : 0.578125\t(data_i, data_q): (-0.093750,0.375000)\n\t3917: o_phase = +9'd146;\t //LUT[3917] \tphase : 0.570312\t(data_i, data_q): (-0.093750,0.406250)\n\t3918: o_phase = +9'd145;\t //LUT[3918] \tphase : 0.566406\t(data_i, data_q): (-0.093750,0.437500)\n\t3919: o_phase = +9'd144;\t //LUT[3919] \tphase : 0.562500\t(data_i, data_q): (-0.093750,0.468750)\n\t3920: o_phase = +9'd143;\t //LUT[3920] \tphase : 0.558594\t(data_i, data_q): (-0.093750,0.500000)\n\t3921: o_phase = +9'd142;\t //LUT[3921] \tphase : 0.554688\t(data_i, data_q): (-0.093750,0.531250)\n\t3922: o_phase = +9'd141;\t //LUT[3922] \tphase : 0.550781\t(data_i, data_q): (-0.093750,0.562500)\n\t3923: o_phase = +9'd141;\t //LUT[3923] \tphase : 0.550781\t(data_i, data_q): (-0.093750,0.593750)\n\t3924: o_phase = +9'd140;\t //LUT[3924] \tphase : 0.546875\t(data_i, data_q): (-0.093750,0.625000)\n\t3925: o_phase = +9'd140;\t //LUT[3925] \tphase : 0.546875\t(data_i, data_q): (-0.093750,0.656250)\n\t3926: o_phase = +9'd139;\t //LUT[3926] \tphase : 0.542969\t(data_i, data_q): (-0.093750,0.687500)\n\t3927: o_phase = +9'd139;\t //LUT[3927] \tphase : 0.542969\t(data_i, data_q): (-0.093750,0.718750)\n\t3928: o_phase = +9'd138;\t //LUT[3928] \tphase : 0.539062\t(data_i, data_q): (-0.093750,0.750000)\n\t3929: o_phase = +9'd138;\t //LUT[3929] \tphase : 0.539062\t(data_i, data_q): (-0.093750,0.781250)\n\t3930: o_phase = +9'd137;\t //LUT[3930] \tphase : 0.535156\t(data_i, data_q): (-0.093750,0.812500)\n\t3931: o_phase = +9'd137;\t //LUT[3931] \tphase : 0.535156\t(data_i, data_q): (-0.093750,0.843750)\n\t3932: o_phase = +9'd137;\t //LUT[3932] \tphase : 0.535156\t(data_i, data_q): (-0.093750,0.875000)\n\t3933: o_phase = +9'd136;\t //LUT[3933] \tphase : 0.531250\t(data_i, data_q): (-0.093750,0.906250)\n\t3934: o_phase = +9'd136;\t //LUT[3934] \tphase : 0.531250\t(data_i, data_q): (-0.093750,0.937500)\n\t3935: o_phase = +9'd136;\t //LUT[3935] \tphase : 0.531250\t(data_i, data_q): (-0.093750,0.968750)\n\t3936: o_phase = -9'd136;\t //LUT[3936] \tphase : -0.531250\t(data_i, data_q): (-0.093750,-1.000000)\n\t3937: o_phase = -9'd136;\t //LUT[3937] \tphase : -0.531250\t(data_i, data_q): (-0.093750,-0.968750)\n\t3938: o_phase = -9'd136;\t //LUT[3938] \tphase : -0.531250\t(data_i, data_q): (-0.093750,-0.937500)\n\t3939: o_phase = -9'd136;\t //LUT[3939] \tphase : -0.531250\t(data_i, data_q): (-0.093750,-0.906250)\n\t3940: o_phase = -9'd137;\t //LUT[3940] \tphase : -0.535156\t(data_i, data_q): (-0.093750,-0.875000)\n\t3941: o_phase = -9'd137;\t //LUT[3941] \tphase : -0.535156\t(data_i, data_q): (-0.093750,-0.843750)\n\t3942: o_phase = -9'd137;\t //LUT[3942] \tphase : -0.535156\t(data_i, data_q): (-0.093750,-0.812500)\n\t3943: o_phase = -9'd138;\t //LUT[3943] \tphase : -0.539062\t(data_i, data_q): (-0.093750,-0.781250)\n\t3944: o_phase = -9'd138;\t //LUT[3944] \tphase : -0.539062\t(data_i, data_q): (-0.093750,-0.750000)\n\t3945: o_phase = -9'd139;\t //LUT[3945] \tphase : -0.542969\t(data_i, data_q): (-0.093750,-0.718750)\n\t3946: o_phase = -9'd139;\t //LUT[3946] \tphase : -0.542969\t(data_i, data_q): (-0.093750,-0.687500)\n\t3947: o_phase = -9'd140;\t //LUT[3947] \tphase : -0.546875\t(data_i, data_q): (-0.093750,-0.656250)\n\t3948: o_phase = -9'd140;\t //LUT[3948] \tphase : -0.546875\t(data_i, data_q): (-0.093750,-0.625000)\n\t3949: o_phase = -9'd141;\t //LUT[3949] \tphase : -0.550781\t(data_i, data_q): (-0.093750,-0.593750)\n\t3950: o_phase = -9'd141;\t //LUT[3950] \tphase : -0.550781\t(data_i, data_q): (-0.093750,-0.562500)\n\t3951: o_phase = -9'd142;\t //LUT[3951] \tphase : -0.554688\t(data_i, data_q): (-0.093750,-0.531250)\n\t3952: o_phase = -9'd143;\t //LUT[3952] \tphase : -0.558594\t(data_i, data_q): (-0.093750,-0.500000)\n\t3953: o_phase = -9'd144;\t //LUT[3953] \tphase : -0.562500\t(data_i, data_q): (-0.093750,-0.468750)\n\t3954: o_phase = -9'd145;\t //LUT[3954] \tphase : -0.566406\t(data_i, data_q): (-0.093750,-0.437500)\n\t3955: o_phase = -9'd146;\t //LUT[3955] \tphase : -0.570312\t(data_i, data_q): (-0.093750,-0.406250)\n\t3956: o_phase = -9'd148;\t //LUT[3956] \tphase : -0.578125\t(data_i, data_q): (-0.093750,-0.375000)\n\t3957: o_phase = -9'd150;\t //LUT[3957] \tphase : -0.585938\t(data_i, data_q): (-0.093750,-0.343750)\n\t3958: o_phase = -9'd152;\t //LUT[3958] \tphase : -0.593750\t(data_i, data_q): (-0.093750,-0.312500)\n\t3959: o_phase = -9'd154;\t //LUT[3959] \tphase : -0.601562\t(data_i, data_q): (-0.093750,-0.281250)\n\t3960: o_phase = -9'd157;\t //LUT[3960] \tphase : -0.613281\t(data_i, data_q): (-0.093750,-0.250000)\n\t3961: o_phase = -9'd161;\t //LUT[3961] \tphase : -0.628906\t(data_i, data_q): (-0.093750,-0.218750)\n\t3962: o_phase = -9'd166;\t //LUT[3962] \tphase : -0.648438\t(data_i, data_q): (-0.093750,-0.187500)\n\t3963: o_phase = -9'd172;\t //LUT[3963] \tphase : -0.671875\t(data_i, data_q): (-0.093750,-0.156250)\n\t3964: o_phase = -9'd180;\t //LUT[3964] \tphase : -0.703125\t(data_i, data_q): (-0.093750,-0.125000)\n\t3965: o_phase = -9'd192;\t //LUT[3965] \tphase : -0.750000\t(data_i, data_q): (-0.093750,-0.093750)\n\t3966: o_phase = -9'd208;\t //LUT[3966] \tphase : -0.812500\t(data_i, data_q): (-0.093750,-0.062500)\n\t3967: o_phase = -9'd230;\t //LUT[3967] \tphase : -0.898438\t(data_i, data_q): (-0.093750,-0.031250)\n\t3968: o_phase = -9'd256;\t //LUT[3968] \tphase : -1.000000\t(data_i, data_q): (-0.062500,0.000000)\n\t3969: o_phase = +9'd218;\t //LUT[3969] \tphase : 0.851562\t(data_i, data_q): (-0.062500,0.031250)\n\t3970: o_phase = +9'd192;\t //LUT[3970] \tphase : 0.750000\t(data_i, data_q): (-0.062500,0.062500)\n\t3971: o_phase = +9'd176;\t //LUT[3971] \tphase : 0.687500\t(data_i, data_q): (-0.062500,0.093750)\n\t3972: o_phase = +9'd166;\t //LUT[3972] \tphase : 0.648438\t(data_i, data_q): (-0.062500,0.125000)\n\t3973: o_phase = +9'd159;\t //LUT[3973] \tphase : 0.621094\t(data_i, data_q): (-0.062500,0.156250)\n\t3974: o_phase = +9'd154;\t //LUT[3974] \tphase : 0.601562\t(data_i, data_q): (-0.062500,0.187500)\n\t3975: o_phase = +9'd151;\t //LUT[3975] \tphase : 0.589844\t(data_i, data_q): (-0.062500,0.218750)\n\t3976: o_phase = +9'd148;\t //LUT[3976] \tphase : 0.578125\t(data_i, data_q): (-0.062500,0.250000)\n\t3977: o_phase = +9'd146;\t //LUT[3977] \tphase : 0.570312\t(data_i, data_q): (-0.062500,0.281250)\n\t3978: o_phase = +9'd144;\t //LUT[3978] \tphase : 0.562500\t(data_i, data_q): (-0.062500,0.312500)\n\t3979: o_phase = +9'd143;\t //LUT[3979] \tphase : 0.558594\t(data_i, data_q): (-0.062500,0.343750)\n\t3980: o_phase = +9'd141;\t //LUT[3980] \tphase : 0.550781\t(data_i, data_q): (-0.062500,0.375000)\n\t3981: o_phase = +9'd140;\t //LUT[3981] \tphase : 0.546875\t(data_i, data_q): (-0.062500,0.406250)\n\t3982: o_phase = +9'd140;\t //LUT[3982] \tphase : 0.546875\t(data_i, data_q): (-0.062500,0.437500)\n\t3983: o_phase = +9'd139;\t //LUT[3983] \tphase : 0.542969\t(data_i, data_q): (-0.062500,0.468750)\n\t3984: o_phase = +9'd138;\t //LUT[3984] \tphase : 0.539062\t(data_i, data_q): (-0.062500,0.500000)\n\t3985: o_phase = +9'd138;\t //LUT[3985] \tphase : 0.539062\t(data_i, data_q): (-0.062500,0.531250)\n\t3986: o_phase = +9'd137;\t //LUT[3986] \tphase : 0.535156\t(data_i, data_q): (-0.062500,0.562500)\n\t3987: o_phase = +9'd137;\t //LUT[3987] \tphase : 0.535156\t(data_i, data_q): (-0.062500,0.593750)\n\t3988: o_phase = +9'd136;\t //LUT[3988] \tphase : 0.531250\t(data_i, data_q): (-0.062500,0.625000)\n\t3989: o_phase = +9'd136;\t //LUT[3989] \tphase : 0.531250\t(data_i, data_q): (-0.062500,0.656250)\n\t3990: o_phase = +9'd135;\t //LUT[3990] \tphase : 0.527344\t(data_i, data_q): (-0.062500,0.687500)\n\t3991: o_phase = +9'd135;\t //LUT[3991] \tphase : 0.527344\t(data_i, data_q): (-0.062500,0.718750)\n\t3992: o_phase = +9'd135;\t //LUT[3992] \tphase : 0.527344\t(data_i, data_q): (-0.062500,0.750000)\n\t3993: o_phase = +9'd135;\t //LUT[3993] \tphase : 0.527344\t(data_i, data_q): (-0.062500,0.781250)\n\t3994: o_phase = +9'd134;\t //LUT[3994] \tphase : 0.523438\t(data_i, data_q): (-0.062500,0.812500)\n\t3995: o_phase = +9'd134;\t //LUT[3995] \tphase : 0.523438\t(data_i, data_q): (-0.062500,0.843750)\n\t3996: o_phase = +9'd134;\t //LUT[3996] \tphase : 0.523438\t(data_i, data_q): (-0.062500,0.875000)\n\t3997: o_phase = +9'd134;\t //LUT[3997] \tphase : 0.523438\t(data_i, data_q): (-0.062500,0.906250)\n\t3998: o_phase = +9'd133;\t //LUT[3998] \tphase : 0.519531\t(data_i, data_q): (-0.062500,0.937500)\n\t3999: o_phase = +9'd133;\t //LUT[3999] \tphase : 0.519531\t(data_i, data_q): (-0.062500,0.968750)\n\t4000: o_phase = -9'd133;\t //LUT[4000] \tphase : -0.519531\t(data_i, data_q): (-0.062500,-1.000000)\n\t4001: o_phase = -9'd133;\t //LUT[4001] \tphase : -0.519531\t(data_i, data_q): (-0.062500,-0.968750)\n\t4002: o_phase = -9'd133;\t //LUT[4002] \tphase : -0.519531\t(data_i, data_q): (-0.062500,-0.937500)\n\t4003: o_phase = -9'd134;\t //LUT[4003] \tphase : -0.523438\t(data_i, data_q): (-0.062500,-0.906250)\n\t4004: o_phase = -9'd134;\t //LUT[4004] \tphase : -0.523438\t(data_i, data_q): (-0.062500,-0.875000)\n\t4005: o_phase = -9'd134;\t //LUT[4005] \tphase : -0.523438\t(data_i, data_q): (-0.062500,-0.843750)\n\t4006: o_phase = -9'd134;\t //LUT[4006] \tphase : -0.523438\t(data_i, data_q): (-0.062500,-0.812500)\n\t4007: o_phase = -9'd135;\t //LUT[4007] \tphase : -0.527344\t(data_i, data_q): (-0.062500,-0.781250)\n\t4008: o_phase = -9'd135;\t //LUT[4008] \tphase : -0.527344\t(data_i, data_q): (-0.062500,-0.750000)\n\t4009: o_phase = -9'd135;\t //LUT[4009] \tphase : -0.527344\t(data_i, data_q): (-0.062500,-0.718750)\n\t4010: o_phase = -9'd135;\t //LUT[4010] \tphase : -0.527344\t(data_i, data_q): (-0.062500,-0.687500)\n\t4011: o_phase = -9'd136;\t //LUT[4011] \tphase : -0.531250\t(data_i, data_q): (-0.062500,-0.656250)\n\t4012: o_phase = -9'd136;\t //LUT[4012] \tphase : -0.531250\t(data_i, data_q): (-0.062500,-0.625000)\n\t4013: o_phase = -9'd137;\t //LUT[4013] \tphase : -0.535156\t(data_i, data_q): (-0.062500,-0.593750)\n\t4014: o_phase = -9'd137;\t //LUT[4014] \tphase : -0.535156\t(data_i, data_q): (-0.062500,-0.562500)\n\t4015: o_phase = -9'd138;\t //LUT[4015] \tphase : -0.539062\t(data_i, data_q): (-0.062500,-0.531250)\n\t4016: o_phase = -9'd138;\t //LUT[4016] \tphase : -0.539062\t(data_i, data_q): (-0.062500,-0.500000)\n\t4017: o_phase = -9'd139;\t //LUT[4017] \tphase : -0.542969\t(data_i, data_q): (-0.062500,-0.468750)\n\t4018: o_phase = -9'd140;\t //LUT[4018] \tphase : -0.546875\t(data_i, data_q): (-0.062500,-0.437500)\n\t4019: o_phase = -9'd140;\t //LUT[4019] \tphase : -0.546875\t(data_i, data_q): (-0.062500,-0.406250)\n\t4020: o_phase = -9'd141;\t //LUT[4020] \tphase : -0.550781\t(data_i, data_q): (-0.062500,-0.375000)\n\t4021: o_phase = -9'd143;\t //LUT[4021] \tphase : -0.558594\t(data_i, data_q): (-0.062500,-0.343750)\n\t4022: o_phase = -9'd144;\t //LUT[4022] \tphase : -0.562500\t(data_i, data_q): (-0.062500,-0.312500)\n\t4023: o_phase = -9'd146;\t //LUT[4023] \tphase : -0.570312\t(data_i, data_q): (-0.062500,-0.281250)\n\t4024: o_phase = -9'd148;\t //LUT[4024] \tphase : -0.578125\t(data_i, data_q): (-0.062500,-0.250000)\n\t4025: o_phase = -9'd151;\t //LUT[4025] \tphase : -0.589844\t(data_i, data_q): (-0.062500,-0.218750)\n\t4026: o_phase = -9'd154;\t //LUT[4026] \tphase : -0.601562\t(data_i, data_q): (-0.062500,-0.187500)\n\t4027: o_phase = -9'd159;\t //LUT[4027] \tphase : -0.621094\t(data_i, data_q): (-0.062500,-0.156250)\n\t4028: o_phase = -9'd166;\t //LUT[4028] \tphase : -0.648438\t(data_i, data_q): (-0.062500,-0.125000)\n\t4029: o_phase = -9'd176;\t //LUT[4029] \tphase : -0.687500\t(data_i, data_q): (-0.062500,-0.093750)\n\t4030: o_phase = -9'd192;\t //LUT[4030] \tphase : -0.750000\t(data_i, data_q): (-0.062500,-0.062500)\n\t4031: o_phase = -9'd218;\t //LUT[4031] \tphase : -0.851562\t(data_i, data_q): (-0.062500,-0.031250)\n\t4032: o_phase = -9'd256;\t //LUT[4032] \tphase : -1.000000\t(data_i, data_q): (-0.031250,0.000000)\n\t4033: o_phase = +9'd192;\t //LUT[4033] \tphase : 0.750000\t(data_i, data_q): (-0.031250,0.031250)\n\t4034: o_phase = +9'd166;\t //LUT[4034] \tphase : 0.648438\t(data_i, data_q): (-0.031250,0.062500)\n\t4035: o_phase = +9'd154;\t //LUT[4035] \tphase : 0.601562\t(data_i, data_q): (-0.031250,0.093750)\n\t4036: o_phase = +9'd148;\t //LUT[4036] \tphase : 0.578125\t(data_i, data_q): (-0.031250,0.125000)\n\t4037: o_phase = +9'd144;\t //LUT[4037] \tphase : 0.562500\t(data_i, data_q): (-0.031250,0.156250)\n\t4038: o_phase = +9'd141;\t //LUT[4038] \tphase : 0.550781\t(data_i, data_q): (-0.031250,0.187500)\n\t4039: o_phase = +9'd140;\t //LUT[4039] \tphase : 0.546875\t(data_i, data_q): (-0.031250,0.218750)\n\t4040: o_phase = +9'd138;\t //LUT[4040] \tphase : 0.539062\t(data_i, data_q): (-0.031250,0.250000)\n\t4041: o_phase = +9'd137;\t //LUT[4041] \tphase : 0.535156\t(data_i, data_q): (-0.031250,0.281250)\n\t4042: o_phase = +9'd136;\t //LUT[4042] \tphase : 0.531250\t(data_i, data_q): (-0.031250,0.312500)\n\t4043: o_phase = +9'd135;\t //LUT[4043] \tphase : 0.527344\t(data_i, data_q): (-0.031250,0.343750)\n\t4044: o_phase = +9'd135;\t //LUT[4044] \tphase : 0.527344\t(data_i, data_q): (-0.031250,0.375000)\n\t4045: o_phase = +9'd134;\t //LUT[4045] \tphase : 0.523438\t(data_i, data_q): (-0.031250,0.406250)\n\t4046: o_phase = +9'd134;\t //LUT[4046] \tphase : 0.523438\t(data_i, data_q): (-0.031250,0.437500)\n\t4047: o_phase = +9'd133;\t //LUT[4047] \tphase : 0.519531\t(data_i, data_q): (-0.031250,0.468750)\n\t4048: o_phase = +9'd133;\t //LUT[4048] \tphase : 0.519531\t(data_i, data_q): (-0.031250,0.500000)\n\t4049: o_phase = +9'd133;\t //LUT[4049] \tphase : 0.519531\t(data_i, data_q): (-0.031250,0.531250)\n\t4050: o_phase = +9'd133;\t //LUT[4050] \tphase : 0.519531\t(data_i, data_q): (-0.031250,0.562500)\n\t4051: o_phase = +9'd132;\t //LUT[4051] \tphase : 0.515625\t(data_i, data_q): (-0.031250,0.593750)\n\t4052: o_phase = +9'd132;\t //LUT[4052] \tphase : 0.515625\t(data_i, data_q): (-0.031250,0.625000)\n\t4053: o_phase = +9'd132;\t //LUT[4053] \tphase : 0.515625\t(data_i, data_q): (-0.031250,0.656250)\n\t4054: o_phase = +9'd132;\t //LUT[4054] \tphase : 0.515625\t(data_i, data_q): (-0.031250,0.687500)\n\t4055: o_phase = +9'd132;\t //LUT[4055] \tphase : 0.515625\t(data_i, data_q): (-0.031250,0.718750)\n\t4056: o_phase = +9'd131;\t //LUT[4056] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.750000)\n\t4057: o_phase = +9'd131;\t //LUT[4057] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.781250)\n\t4058: o_phase = +9'd131;\t //LUT[4058] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.812500)\n\t4059: o_phase = +9'd131;\t //LUT[4059] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.843750)\n\t4060: o_phase = +9'd131;\t //LUT[4060] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.875000)\n\t4061: o_phase = +9'd131;\t //LUT[4061] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.906250)\n\t4062: o_phase = +9'd131;\t //LUT[4062] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.937500)\n\t4063: o_phase = +9'd131;\t //LUT[4063] \tphase : 0.511719\t(data_i, data_q): (-0.031250,0.968750)\n\t4064: o_phase = -9'd131;\t //LUT[4064] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-1.000000)\n\t4065: o_phase = -9'd131;\t //LUT[4065] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.968750)\n\t4066: o_phase = -9'd131;\t //LUT[4066] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.937500)\n\t4067: o_phase = -9'd131;\t //LUT[4067] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.906250)\n\t4068: o_phase = -9'd131;\t //LUT[4068] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.875000)\n\t4069: o_phase = -9'd131;\t //LUT[4069] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.843750)\n\t4070: o_phase = -9'd131;\t //LUT[4070] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.812500)\n\t4071: o_phase = -9'd131;\t //LUT[4071] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.781250)\n\t4072: o_phase = -9'd131;\t //LUT[4072] \tphase : -0.511719\t(data_i, data_q): (-0.031250,-0.750000)\n\t4073: o_phase = -9'd132;\t //LUT[4073] \tphase : -0.515625\t(data_i, data_q): (-0.031250,-0.718750)\n\t4074: o_phase = -9'd132;\t //LUT[4074] \tphase : -0.515625\t(data_i, data_q): (-0.031250,-0.687500)\n\t4075: o_phase = -9'd132;\t //LUT[4075] \tphase : -0.515625\t(data_i, data_q): (-0.031250,-0.656250)\n\t4076: o_phase = -9'd132;\t //LUT[4076] \tphase : -0.515625\t(data_i, data_q): (-0.031250,-0.625000)\n\t4077: o_phase = -9'd132;\t //LUT[4077] \tphase : -0.515625\t(data_i, data_q): (-0.031250,-0.593750)\n\t4078: o_phase = -9'd133;\t //LUT[4078] \tphase : -0.519531\t(data_i, data_q): (-0.031250,-0.562500)\n\t4079: o_phase = -9'd133;\t //LUT[4079] \tphase : -0.519531\t(data_i, data_q): (-0.031250,-0.531250)\n\t4080: o_phase = -9'd133;\t //LUT[4080] \tphase : -0.519531\t(data_i, data_q): (-0.031250,-0.500000)\n\t4081: o_phase = -9'd133;\t //LUT[4081] \tphase : -0.519531\t(data_i, data_q): (-0.031250,-0.468750)\n\t4082: o_phase = -9'd134;\t //LUT[4082] \tphase : -0.523438\t(data_i, data_q): (-0.031250,-0.437500)\n\t4083: o_phase = -9'd134;\t //LUT[4083] \tphase : -0.523438\t(data_i, data_q): (-0.031250,-0.406250)\n\t4084: o_phase = -9'd135;\t //LUT[4084] \tphase : -0.527344\t(data_i, data_q): (-0.031250,-0.375000)\n\t4085: o_phase = -9'd135;\t //LUT[4085] \tphase : -0.527344\t(data_i, data_q): (-0.031250,-0.343750)\n\t4086: o_phase = -9'd136;\t //LUT[4086] \tphase : -0.531250\t(data_i, data_q): (-0.031250,-0.312500)\n\t4087: o_phase = -9'd137;\t //LUT[4087] \tphase : -0.535156\t(data_i, data_q): (-0.031250,-0.281250)\n\t4088: o_phase = -9'd138;\t //LUT[4088] \tphase : -0.539062\t(data_i, data_q): (-0.031250,-0.250000)\n\t4089: o_phase = -9'd140;\t //LUT[4089] \tphase : -0.546875\t(data_i, data_q): (-0.031250,-0.218750)\n\t4090: o_phase = -9'd141;\t //LUT[4090] \tphase : -0.550781\t(data_i, data_q): (-0.031250,-0.187500)\n\t4091: o_phase = -9'd144;\t //LUT[4091] \tphase : -0.562500\t(data_i, data_q): (-0.031250,-0.156250)\n\t4092: o_phase = -9'd148;\t //LUT[4092] \tphase : -0.578125\t(data_i, data_q): (-0.031250,-0.125000)\n\t4093: o_phase = -9'd154;\t //LUT[4093] \tphase : -0.601562\t(data_i, data_q): (-0.031250,-0.093750)\n\t4094: o_phase = -9'd166;\t //LUT[4094] \tphase : -0.648438\t(data_i, data_q): (-0.031250,-0.062500)\n\t4095: o_phase = -9'd192; \t //LUT[4095] \tphase : -0.750000\t(data_i, data_q): (-0.031250,-0.031250)\n\tendcase\nend\n\nendmodule", "rtl/phase_rotation.sv": "module phase_rotation #(\n   parameter NBW_IN_DATA  = 8,\n   parameter NBW_COS      = 8,\n   parameter NBW_MULT     = NBW_IN_DATA + NBW_COS,\n   parameter NBW_SUM      = NBW_MULT + 1,\n   parameter NBW_OUT_DATA = NBW_SUM\n) (\n   input  logic clk,\n   input  logic signed [NBW_IN_DATA-1:0]  i_data_re,\n   input  logic signed [NBW_IN_DATA-1:0]  i_data_im,\n   input  logic signed [NBW_COS-1:0]      i_cos,\n   input  logic signed [NBW_COS-1:0]      i_sin,\n   output logic signed [NBW_OUT_DATA-1:0] o_data_re,\n   output logic signed [NBW_OUT_DATA-1:0] o_data_im\n);\n\n   logic signed [NBW_IN_DATA-1:0]  data_re_reg;\n   logic signed [NBW_IN_DATA-1:0]  data_im_reg;\n   logic signed [NBW_COS-1:0]      cos_reg;\n   logic signed [NBW_COS-1:0]      sin_reg;\n\n   logic signed [NBW_MULT-1:0] data_a;\n   logic signed [NBW_MULT-1:0] data_b;\n   logic signed [NBW_MULT-1:0] data_c;\n   logic signed [NBW_MULT-1:0] data_d;\n\n   logic signed [NBW_SUM-1:0] sum_1;\n   logic signed [NBW_SUM-1:0] sum_2;\n\n   always_ff @(posedge clk) begin\n      data_re_reg <= i_data_re;\n      data_im_reg <= i_data_im;\n      cos_reg     <= i_cos;\n      sin_reg     <= i_sin;\n   end\n\n   assign data_a = cos_reg*data_re_reg;\n   assign data_b = sin_reg*data_im_reg;\n   assign data_c = sin_reg*data_re_reg;\n   assign data_d = cos_reg*data_im_reg;\n\n   assign sum_1  = data_a - data_b;\n   assign sum_2  = data_c + data_d;\n\n   always_comb begin\n      o_data_re = sum_1;\n      o_data_im = sum_2;\n   end\n\nendmodule", "rtl/power4.sv": "module power4 #(\n   parameter NBW_IN = 8,\n   parameter NBW_OUT= NBW_IN*4\n)\n(\n   input  logic clk,\n   input  logic rst_async_n,\n   input  logic signed [NBW_IN-1:0]  i_data_i,\n   input  logic signed [NBW_IN-1:0]  i_data_q,\n   output logic signed [NBW_OUT-1:0] o_data_i,  \n   output logic signed [NBW_OUT-1:0] o_data_q\n);\n\nlocalparam NBW_SQUARE = 2*NBW_IN;\nlocalparam NBW_FOURTH = 2*NBW_SQUARE;\n// Fourth power \nlogic signed [NBW_SQUARE-1:0] data_i2;\nlogic signed [NBW_SQUARE-1:0] data_q2;\nlogic signed [NBW_FOURTH-1:0] data_i4;\nlogic signed [NBW_FOURTH-1:0] data_q4;\n\n\nassign data_i2 = i_data_i*i_data_i;\nassign data_i4 = data_i2*data_i2;\n\nassign data_q2 = i_data_q*i_data_q;\nassign data_q4 = data_q2*data_q2;\n\nalways_ff @(posedge clk or negedge rst_async_n) begin\n   if(!rst_async_n) begin\n      o_data_i <= 'd0;\n      o_data_q <= 'd0;\n   end\n   else begin\n      o_data_i <= data_i4;\n      o_data_q <= data_q4;\n   end\nend\n\n\nendmodule", "rtl/saturation.sv": "module saturation #(\n   parameter NBW_IN  = 8,\n   parameter NBW_OUT = 6\n)\n(\n   input  logic [NBW_IN-1:0]  i_data,\n   output logic [NBW_OUT-1:0] o_data\n);\n\nlocalparam NB_TRIM = NBW_IN - NBW_OUT;\nlocalparam NB_REPL = NBW_OUT - 1;\n\n    generate\n        if (NB_TRIM == 1) begin\n            always_comb begin : trim\n                if (i_data[NBW_IN-1] == i_data[NBW_OUT-1]) begin //sat\n                    o_data = $signed(i_data[NBW_OUT-1:0]);\n                end else begin\n                    o_data = $signed({i_data[NBW_IN-1],{NB_REPL{!i_data[NBW_IN-1]}}});\n                end\n            end\n\n        end else if (NB_TRIM > 1) begin\n\n            always_comb begin : trim\n                if ({(NB_TRIM){i_data[NBW_IN-1]}} == i_data[NBW_IN-2:NBW_OUT-1]) begin //sat\n                    o_data = $signed(i_data[NBW_OUT-1:0]);\n                end else begin\n                    o_data = $signed({i_data[NBW_IN-1],{NB_REPL{!i_data[NBW_IN-1]}}});\n                end\n            end\n\n        end\n    endgenerate\n\n\nendmodule", "rtl/top_phase_rotation.sv": "module top_phase_rotation #(\n   parameter NBW_ANG  =  'd7,      \n   parameter NBW_COS  =  'd10,\n   parameter NBW_IN_DATA  = 8,\n   parameter NS_IN        = 2,\n   parameter NBW_MULT     = NBW_IN_DATA + NBW_COS,\n   parameter NBW_SUM      = NBW_MULT + 1,\n   parameter NBW_OUT_DATA = NBW_SUM    \n)\n(    \n   input  logic clk,\n   input  logic [NBW_IN_DATA*NS_IN-1:0]   i_data_re,\n   input  logic [NBW_IN_DATA*NS_IN-1:0]   i_data_im,    \n   input  logic [NBW_ANG*NS_IN-1:0]             i_angle,\n   output logic signed [NBW_OUT_DATA*NS_IN-1:0] o_data_re,\n   output logic signed [NBW_OUT_DATA*NS_IN-1:0] o_data_im   \n);\n\nlogic signed [NBW_IN_DATA-1:0]  i_data_re_2d [NS_IN-1:0];\nlogic signed [NBW_IN_DATA-1:0]  i_data_im_2d [NS_IN-1:0];\nlogic signed [NBW_OUT_DATA-1:0] o_data_re_2d [NS_IN-1:0];\nlogic signed [NBW_OUT_DATA-1:0] o_data_im_2d [NS_IN-1:0];\nlogic signed [NBW_ANG-1:0]      i_angle_2d [NS_IN-1:0];\nlogic signed [NBW_COS-1:0]      cos_2d [NS_IN-1:0];\nlogic signed [NBW_COS-1:0]      sin_2d [NS_IN-1:0];\n\nalways_comb begin : convert_2d_array_to_1d_input_data\n   for(int i=0; i < NS_IN; i++) begin\n      i_data_re_2d[i] = $signed(i_data_re[(i+1)*NBW_IN_DATA-1-:NBW_IN_DATA]);\n      i_data_im_2d[i] = $signed(i_data_im[(i+1)*NBW_IN_DATA-1-:NBW_IN_DATA]);\n   end\nend\n\nalways_comb begin : convert_2d_array_to_1d_input_angle\n   for(int i=0; i < NS_IN; i++) begin\n      i_angle_2d[i] = $signed(i_angle[(i+1)*NBW_ANG-1-:NBW_ANG]);\n   end\nend\n\ngenvar j;\ngenerate\n   for(j = 0; j < NS_IN; j++) begin : gen_lut_phase_rot\n      gen_cos_sin_lut uu_gen_cos_sin_lut (\n         .i_angle(i_angle_2d[j]),\n         .o_cos(cos_2d[j]),\n         .o_sin(sin_2d[j])\n      );\n\n      phase_rotation #(\n         .NBW_IN_DATA (NBW_IN_DATA ),\n         .NBW_COS     (NBW_COS     ),\n         .NBW_MULT    (NBW_MULT    ),\n         .NBW_SUM     (NBW_SUM     ),\n         .NBW_OUT_DATA(NBW_OUT_DATA)\n      ) uu_phase_rotation(\n         .clk(clk),\n         .i_data_re(i_data_re_2d[j]),\n         .i_data_im(i_data_im_2d[j]),\n         .i_cos(cos_2d[j]),\n         .i_sin(sin_2d[j]),\n         .o_data_re(o_data_re_2d[j]),\n         .o_data_im(o_data_im_2d[j]) \n      );\n   end\nendgenerate\n\n\nalways_comb begin : convert_2d_array_to_1d_output_data\n   for(int i=0; i < NS_IN; i++) begin\n      o_data_re[(i+1)*NBW_OUT_DATA-1-:NBW_OUT_DATA] = $unsigned(o_data_re_2d[i]);\n      o_data_im[(i+1)*NBW_OUT_DATA-1-:NBW_OUT_DATA] = $unsigned(o_data_im_2d[i]);\n   end\nend\n\nendmodule", "docs/spec_viterbi.md": "## Overview\nThe `phase_rotation_viterbi` module implements **phase estimation and correction** using **fourth-power phase detection**. The module processes complex input samples (**I, Q**) and applies a **pipeline-based architecture** to compute and correct the phase.\n\n## Parameters\n| Parameter  | Description                                                                                                                         |\n|------------|-------------------------------------------------------------------------------------------------------------------------------------|\n| `NBW_IN`   | Bit width of input data (Can be updated by user)                                                                                    |\n| `NBW_OUT`  | Sufficient bit width to accommodate fourth-power operations and final phase rotation (Can not be changed by user, only pre-defined) |\n\n## Interface\n| Signal        | Direction| Width       | Description                                     |\n|---------------|----------|-------------|-------------------------------------------------|\n| `clk`         | Input    | 1 bit       | System clock (rising edge)                      |\n| `rst_async_n` | Input    | 1 bit       | Asynchronous reset (Async active low)           |\n| `i_data_i`    | Input    | `NBW_IN`    | I-phase input data                              |\n| `i_data_q`    | Input    | `NBW_IN`    | Q-phase input data                              |\n| `o_data_i`    | Output   | `NBW_OUT`   | I-phase output data after phase rotation        |\n| `o_data_q`    | Output   | `NBW_OUT`   | Q-phase output data after phase rotation        |\n\n## Design Details\nThe `phase_rotation_viterbi` module integrates the following submodules in sequence:\n\n- **`power4`**: Computes the **fourth power** of the input signals (`i_data_i`, `i_data_q`).  \n  - **Latency:** 1 clock cycle.\n\n- **`saturation` (2 instances)**: \n  - Fully combinational\n  - Saturates the **fourth-power outputs** to **6-bit signed values**.\n\n- **`phase_lut`**: Computes the **normalized phase** from the **6-bit complex input (`I/Q`)** that comes from fourth power saturated data.\n  - Fully combinational\n  - **Output:** 9-bit phase, normalized by PI.\n\n- **Phase division by 4**: \n  - The **9-bit phase** from `phase_lut` is **right-shifted by 2** to obtain a 9-bit divided phase.\n\n- **`saturation` (1 instance)**:\n  - Saturates the **divided phase** from **9 bits to 7 bits (signed)**.\n\n- **`top_phase_rotation`**:\n  - Applies phase rotation using the **delayed** I/Q signals (1-cycle delay, reset to zero) and the **7-bit phase**.\n  - **Outputs:** `o_data_i`, `o_data_q`.", "docs/spec_slicer_top.md": "# Slicer Top-Level Module (`slicer_top.sv`)\n\n## Overview\nThe `slicer` module is a fully combinational design that classifies an input sample based on predefined thresholds. It determines the appropriate output value based on its relation to the provided threshold levels.\n\nThe `slicer_top` module integrates two instances of `slicer` to process the components of a complex sample, represented by **I (phase)** and **Q (quadrature)**.\n\n## Parameters\nThe parameters for `slicer_top` follow the same structure as `slicer.sv`.\n\n| Parameter  | Description                                  |\n|------------|----------------------------------------------|\n| `NBW_IN`   | Bit width of input data                      |\n| `NBW_TH`   | Bit width of threshold input                 |\n| `NBW_REF`  | Bit width of reference values                |\n| `NS_TH`    | Fixed at 2                                   |\n\n## Interface\n\n| Signal           | Direction| Width                  | Description                                        |\n|------------------|----------|------------------------|----------------------------------------------------|\n| `clk`            | Input    | 1 bit                  | System clock (rising edge)                         |\n| `rst_async_n`    | Input    | 1 bit                  | Asynchronous reset (active low)                    |\n| `i_data_i`       | Input    | `NBW_IN`               | I-phase input data                                 |\n| `i_data_q`       | Input    | `NBW_IN`               | Q-phase input data                                 |\n| `i_threshold`    | Input    | `NBW_TH * NS_TH`       | Threshold values for comparison                    |\n| `i_sample_1_pos` | Input    | `NBW_REF`              | Reference for `+1` classification                  |\n| `i_sample_0_pos` | Input    | `NBW_REF`              | Reference for `0+` classification                  |\n| `i_sample_0_neg` | Input    | `NBW_REF`              | Reference for `0-` classification                  |\n| `i_sample_1_neg` | Input    | `NBW_REF`              | Reference for `-1` classification                  |\n| `i_calc_cost`    | Input    | 1 bit                  | Cost calculation enable signal                     |\n| `o_calc_cost`    | Output   | 1 bit                  | Delayed cost calculation signal (2-stage pipeline) |\n| `o_energy`       | Output   | *Computed width*       | Energy calculation output                          |\n\n## Design Requirements\n### Pipeline for `i_calc_cost`\n- The signal `i_calc_cost` must be **registered through two pipeline stages** before reaching `o_calc_cost`.\n- On reset (`rst_async_n` = 0), both pipeline registers must be set to **zero**.\n\n### Registering Slicer Outputs\n- The outputs of `slicer` instances should be **registered** in `slicer_top`.\n- If the first pipeline stage of `i_calc_cost` is `1`, the output registers must **update with new slicer results**.\n- If the first pipeline stage of `i_calc_cost` is `0`, the output registers must **retain their previous values**.\n- On reset (`rst_async_n` = 0), the output registers must be set to **zero**.\n\n### Energy Calculation\n- The `o_energy` output represents the energy of the complex sample after slicing.\n- It is obtained by computing the sum of the squared values of the outputs from both `slicer` instances.\n- This value provides a measure of the signal magnitude after slicing and is useful for subsequent processing steps.\n- The bit width of `o_energy` must be large enough to **fully accommodate the squared sum computation**.", "docs/spec_top_phase_rotation.md": "## Overview\nThe `top_phase_rotation` module implements **phase rotation** for complex input samples (**I, Q**) using **lookup table-based sine and cosine generation**. The module processes multiple input samples (`NS_IN`) in parallel and applies a **pipeline-based architecture** to compute the rotated outputs.\n\n## Parameters\n| Parameter     | Description                                                                       |\n|---------------|-----------------------------------------------------------------------------------|\n| `NBW_ANG`     | Bit width of the phase angle input (fixed at 7)                                   |\n| `NBW_COS`     | Bit width of the cosine/sine values generated from the lookup table (fixed at 10) |\n| `NBW_IN_DATA` | Bit width of input data                                                           |\n| `NS_IN`       | Number of input samples processed in parallel                                     |\n| `NBW_MULT`    | Bit width of the multiplication result (`NBW_IN_DATA + NBW_COS`)                  |\n| `NBW_SUM`     | Bit width of the sum operation (`NBW_MULT + 1`)                                   |\n| `NBW_OUT_DATA`| Bit width of output data (`NBW_SUM`)                                              |\n\n## Interface\n| Signal      | Direction | Width                    | Description                                  |\n|-------------|-----------|--------------------------|----------------------------------------------|\n| `clk`       | Input     | 1 bit                    | System clock (rising edge)                   |\n| `i_data_re` | Input     | `NBW_IN_DATA * NS_IN`    | Real part of the input complex samples       |\n| `i_data_im` | Input     | `NBW_IN_DATA * NS_IN`    | Imaginary part of the input complex samples  |\n| `i_angle`   | Input     | `NBW_ANG * NS_IN`        | Phase angle input for rotation               |\n| `o_data_re` | Output    | `NBW_OUT_DATA * NS_IN`   | Rotated real part of the output samples      |\n| `o_data_im` | Output    | `NBW_OUT_DATA * NS_IN`   | Rotated imaginary part of the output samples |\n\n## Design Details\nThe `top_phase_rotation` module integrates the following submodules:\n\n- **`gen_cos_sin_lut`**:\n  - Generates **cosine** and **sine** values based on the input angle using a lookup table (LUT).\n  - Each phase angle in `i_angle` is mapped to corresponding cosine (`o_cos`) and sine (`o_sin`) values.\n  - Parameters available on interface `NBW_ANG` and `NBW_COS`.\n\n- **`phase_rotation`**:\n  - Performs phase rotation using the equation:\n  - Multiplies the input signals with cosine and sine values.\n  - Parameters available on interface `NBW_IN_DATA`, `NBW_COS`, `NBW_MULT`, `NBW_SUM` and `NBW_OUT_DATA`\n\nThe following processes should be performed before and after the modules presented above:\n- **Input Data Formatting**:\n  - Converts `i_data_re`, `i_data_im`, and `i_angle` from **1D array** format to **2D arrays** (`NS_IN` elements each).\n  - Ensures correct signed representation for computations.\n\n- **Output Formatting**:\n  - Converts the **2D output arrays** (`o_data_re_2d` and `o_data_im_2d`) back into **1D format**.\n  - Uses **unsigned representation** before assigning to `o_data_re` and `o_data_im`.\n\n## Functionality\n1. **Receives parallel complex input samples (`NS_IN`)**.\n2. **Retrieves cosine and sine values** from the lookup table.\n3. **Computes the rotated output** using multiplications and summations.\n4. **Formats the output data** into a single vector for efficient transmission.\n\n## Latency and Pipeline\n- The **cos/sin LUT** operates combinationally.\n- The **phase rotation** module uses **pipeline registers** for multiplication and summation (1 clock cycle).\n\n## Summary\nThe `top_phase_rotation` module is designed for **efficient phase rotation** of complex signals using LUT-based trigonometric functions. It supports **parametric bit widths** and **parallel input processing** for high-throughput applications."}, "patch": {"rtl/phase_rotation_viterbi.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : /bin/sh -c \"pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -s\"", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/phase_rotation_viterbi.sv /code/rtl/phase_lut.sv /code/rtl/top_phase_rotation.sv /code/rtl/gen_cos_sin_lut.sv /code/rtl/phase_rotation.sv /code/rtl/saturation.sv /code/rtl/power4.sv\nTOPLEVEL        = phase_rotation_viterbi\nMODULE          = test_phase_rotation_viterbi\nPYTHONPATH      = /src\nHASH            = 10-integrate-blocks-phase-rotation-viterbi", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# Reset the DUT (design under test)\nasync def reset_dut(reset_n, duration_ns=10):\n    reset_n.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")   ", "src/test_phase_rotation_viterbi.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport harness_library as hrs_lb\nimport random\nimport math\nimport cmath\n\n@cocotb.test()\nasync def test_low_pass_filter(dut):\n    \"\"\"Test the Phase Rotation Viterbi module with edge cases and random data.\"\"\"\n\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Debug mode\n    debug = 0\n    \n    ERROR_LIMIT = 5\n\n    # Retrieve parameters from the DUT\n    NBW_IN  = int(dut.NBW_IN.value)\n    NBW_OUT  = int(dut.NBW_OUT.value)\n\n    # Initialize DUT\n    await hrs_lb.dut_init(dut)\n\n    # Apply reset and enable\n    await hrs_lb.reset_dut(dut.rst_async_n)\n\n    await RisingEdge(dut.clk)\n\n    # Calculate min and max values for data and coefficients\n    data_min = int(-2**NBW_IN / 2)\n    data_max = int((2**NBW_IN / 2) - 1)\n\n    # Number of random test iterations\n    num_random_iterations = 100\n\n    data_i4 = 0\n    data_q4 = 0 \n    data_i4_delayed = 0\n    data_q4_delayed = 0 \n\n    i_data_i       = 0\n    i_data_q       = 0\n\n    i_data_i_delayed = 0\n    i_data_q_delayed = 0 \n\n    data_out_i = 0\n    data_out_q = 0\n    data_out_i_delayed = 0\n    data_out_q_delayed = 0\n\n    for _ in range(num_random_iterations):\n\n        i_data_i_delayed = i_data_i\n        i_data_q_delayed = i_data_q\n        # Randomly generate input data\n        i_data_i       = random.randint(data_min, data_max)\n        i_data_q       = random.randint(data_min, data_max)\n\n        # Apply input data\n        dut.i_data_i.value       = i_data_i\n        dut.i_data_q.value       = i_data_q\n\n        await RisingEdge(dut.clk)\n\n        ## Power4 DUT\n        dut_data_i4_ff = dut.data_i4_ff.value.to_signed()\n        dut_data_q4_ff = dut.data_q4_ff.value.to_signed()\n\n        # EXP\n        data_i4_delayed = data_i4\n        data_q4_delayed = data_q4\n\n        data_i4 = i_data_i**4\n        data_q4 = i_data_q**4\n\n        # Print\n        if debug:\n            cocotb.log.info(f\"[INPUTS] i_data_i = {i_data_i}, i_data_q = {i_data_q}\")\n            cocotb.log.info(f\"[DUT] i^4 = {dut_data_i4_ff}, q^4 = {dut_data_q4_ff}\")\n            cocotb.log.info(f\"[EXP] i^4 = {data_i4_delayed}, q^4 = {data_q4_delayed}\")\n        assert dut_data_i4_ff == data_i4_delayed, f\"Mismatch, expected: {data_i4_delayed}, got: {dut_data_i4_ff}\"\n        assert dut_data_q4_ff == data_q4_delayed, f\"Mismatch, expected: {data_q4_delayed}, got: {dut_data_q4_ff}\"\n\n        # SAT Power4\n        dut_data_i4_ff_sat = dut.data_i4_ff_sat.value.to_signed()\n        dut_data_q4_ff_sat = dut.data_q4_ff_sat.value.to_signed()\n\n        # EXP\n        exp_i4_sat = 0\n        exp_q4_sat = 0\n        if data_i4_delayed > 31:\n            exp_i4_sat = 31\n        elif data_i4_delayed < -32:\n            exp_i4_sat = -32\n        else:\n            exp_i4_sat = data_i4_delayed\n\n        if data_q4_delayed > 31:\n            exp_q4_sat = 31\n        elif data_q4_delayed < -32:\n            exp_q4_sat = -32\n        else:\n            exp_q4_sat = data_q4_delayed\n        # Print\n        if debug:\n            cocotb.log.info(f\"[DUT] SAT i^4 = {dut_data_i4_ff_sat}, q^4 = {dut_data_q4_ff_sat}\")\n            cocotb.log.info(f\"[EXP] SAT i^4 = {exp_i4_sat}, q^4 = {exp_q4_sat}\")\n        assert dut_data_i4_ff_sat == exp_i4_sat, f\"Mismatch, expected: {exp_i4_sat}, got: {dut_data_i4_ff_sat}\"\n        assert dut_data_q4_ff_sat == exp_q4_sat, f\"Mismatch, expected: {exp_q4_sat}, got: {dut_data_q4_ff_sat}\"\n\n        dut_phase = dut.phase.value.to_signed()\n        phase = (math.atan2(exp_q4_sat,exp_i4_sat))*256/math.pi\n\n        if debug:\n            cocotb.log.info(f\"[DUT PHASE] phase = {dut_phase}\")\n            cocotb.log.info(f\"[EXP PHASE] phase = {phase}\")\n        diff = abs(dut_phase - phase)\n        assert diff <= 1, f\"Mismatch, expected: {phase}, got: {dut_phase}\"\n\n        # Phase/4\n        phase_div4 = int((phase) / 4)\n        dut_phase_div4 = dut.phase_div4.value.to_signed()\n        if debug:\n            cocotb.log.info(f\"[DUT PHASE/4] phase sat = {dut_phase_div4}\")\n            cocotb.log.info(f\"[EXP PHASE/4] phase sat = {phase_div4}\")\n        \n        phase_div4_sat = 0\n        if phase_div4 > 63:\n            phase_div4_sat = 63\n        elif phase_div4 < -64:\n            phase_div4_sat = -64\n        else:\n            phase_div4_sat = phase_div4        \n        \n        dut_phase_div4_sat = dut.phase_div4_sat.value.to_signed()\n        if debug:\n            cocotb.log.info(f\"[DUT PHASE SAT] phase sat = {dut_phase_div4_sat}\")\n            cocotb.log.info(f\"[EXP PHASE SAT] phase sat = {phase_div4_sat}\")\n\n        data_out_i_delayed = data_out_i\n        data_out_q_delayed = data_out_q\n\n        phase_rad = (phase_div4_sat/64)*math.pi\n\n        data_complex = i_data_i_delayed + 1j*i_data_q_delayed\n        rotation = (cmath.exp(1j * phase_rad))*data_complex\n\n        data_out_i = rotation.real*256\n        data_out_q = rotation.imag*256\n\n        o_dut_data_i = dut.o_data_i.value.to_signed()\n        o_dut_data_q = dut.o_data_q.value.to_signed()\n\n        exp_out_phase = math.atan2(data_out_q_delayed, data_out_i_delayed)\n        dut_out_phase = math.atan2(o_dut_data_q, o_dut_data_q)\n        final_diff = abs(exp_out_phase - dut_out_phase)\n\n        if debug:\n            cocotb.log.info(f\"[DIFF] diff phase = {final_diff}\")\n            cocotb.log.info(f\"[EXPECTED OUTPUT] o_data = {data_out_i_delayed}, {data_out_q_delayed}\")\n            cocotb.log.info(f\"[DUT      OUTPUT] o_data = {o_dut_data_i}, {o_dut_data_q} \\n\")\n        \n        # Check phase\n        assert final_diff <= ERROR_LIMIT, f\"Diff phase is greater than {ERROR_LIMIT}, got = {final_diff}\"\n\n\n    cocotb.log.info(f\"All tests passed successfully.\")\n", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(NBW_IN: int = 7):\n    # Simulation parameters\n    parameter = {\n        \"NBW_IN\": NBW_IN\n    }\n\n    # Debug information\n    print(f\"[DEBUG] Running simulation with NBW_IN={NBW_IN}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Generate default sizes (commented alternative with random values)\nNBW_IN_vals    = [8] + [random.randint(8, 16) for _ in range(5)]\n\n# Parametrize test for default data sizes\n@pytest.mark.parametrize(\"NBW_IN\", NBW_IN_vals)\n@pytest.mark.parametrize(\"test\", range(3))\ndef test_data(NBW_IN, test):\n    # Run the simulation with specified parameters\n    runner(NBW_IN=NBW_IN)", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -s'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_phase_rotation_0028", "categories": ["cid005", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a **cross_correlation** module that performs complex cross-correlation and energy computation over input I/Q data. This module handles the internal processing logic required for computing correlation with conjugate reference sequences.\n\nCan you implement the top-level module **`detect_sequence`** by integrating the **cross_correlation** module at `detect_sequence.sv`?\n\nThe design should be fully parameterizable and support flexible configurations to adapt to different processing requirements. Additional glue logic must be implemented both before and after the instantiation of the **cross_correlation** module to handle input data preparation and output result processing.\n\nPlease refer to `docs/spec_detect_sequence.md` for design requirements and specifications.\n", "context": {"docs/spec_conj.md": "# Conjugate Sequence Specification (`conj_proc_h` and `conj_proc_v`)\n\n## Purpose\n\nThis document describes how to derive the conjugate reference sequences used in the `detect_sequence` module, specifically:\n\n- Real part of the horizontal conjugate sequence  \n- Imag part of the horizontal conjugate sequence  \n- Real part of the vertical conjugate sequence  \n- Imag part of the vertical conjugate sequence\n\nThese sequences are used for cross-correlation against known pilot symbols in complex form. Each sample is represented by its real (`I`) and imaginary (`Q`) parts, both normalized to `+1` or `-1`.\n\n---\n\n## Generation Process\n\n1. **Start from the ideal complex pilot sequence** (row-wise and column-wise).\n2. **Apply complex conjugation**, inverting the imaginary part:\nconj(x + j\u00b7y) = x - j\u00b7y\n4. **Normalize** each value to sign-only:\n- If real/imag \u2265 0 \u2192 `+1`\n- If real/imag <  0 \u2192 `-1`\n4. **Encode** these into two parallel vectors per sequence:\n- One for real parts\n- One for imag parts\n5. These bits are stored as logic vectors of width 23.\n\n---\n\n## Symbol Mapping\n\nEach position in the sequence represents a normalized complex symbol `(Re, Im)`:\n\n| Symbol Value | Encoded as |\n|--------------|------------|\n| `(+1, +1)`   | Real = 0, Imag = 0 |\n| `(+1, -1)`   | Real = 0, Imag = 1 |\n| `(-1, +1)`   | Real = 1, Imag = 0 |\n| `(-1, -1)`   | Real = 1, Imag = 1 |\n\n---\n\n## Table: Sequence Interpretation\n\nEach row below corresponds to one of the 23 complex samples in the sequence. The real and imag parts are shown as `+1` or `-1`.\n\n### `conj_proc_h` \u2014 Horizontal Conjugate Sequence\n\n| Index | Real Part                    | Imag Part                    |\n|-------|------------------------------|------------------------------|\n| 0     | +1                           | -1                           |\n| 1     | -1                           | -1                           |\n| 2     | +1                           | +1                           |\n| 3     | -1                           | -1                           |\n| 4     | +1                           | +1                           |\n| 5     | +1                           | -1                           |\n| 6     | -1                           | -1                           |\n| 7     | -1                           | +1                           |\n| 8     | +1                           | -1                           |\n| 9     | +1                           | +1                           |\n| 10    | +1                           | -1                           |\n| 11    | -1                           | -1                           |\n| 12    | +1                           | -1                           |\n| 13    | -1                           | +1                           |\n| 14    | +1                           | -1                           |\n| 15    | +1                           | +1                           |\n| 16    | -1                           | -1                           |\n| 17    | +1                           | +1                           |\n| 18    | +1                           | -1                           |\n| 19    | -1                           | +1                           |\n| 20    | -1                           | +1                           |\n| 21    | +1                           | +1                           |\n| 22    | +1                           | +1                           |\n\n### `conj_proc_v` \u2014 Vertical Conjugate Sequence\n\n| Index | Real Part                    | Imag Part                    |\n|-------|------------------------------|------------------------------|\n| 0     | -1                           | +1                           |\n| 1     | -1                           | -1                           |\n| 2     | +1                           | +1                           |\n| 3     | -1                           | +1                           |\n| 4     | +1                           | -1                           |\n| 5     | -1                           | -1                           |\n| 6     | -1                           | +1                           |\n| 7     | +1                           | -1                           |\n| 8     | -1                           | -1                           |\n| 9     | +1                           | +1                           |\n| 10    | +1                           | -1                           |\n| 11    | -1                           | +1                           |\n| 12    | +1                           | +1                           |\n| 13    | -1                           | -1                           |\n| 14    | +1                           | -1                           |\n| 15    | +1                           | +1                           |\n| 16    | +1                           | -1                           |\n| 17    | +1                           | +1                           |\n| 18    | -1                           | -1                           |\n| 19    | -1                           | +1                           |\n| 20    | +1                           | -1                           |\n| 21    | +1                           | +1                           |\n| 22    | -1                           | +1                           |", "docs/spec_cross_correlation.md": "# Cross Correlation Top-Level Module (`cross_correlation.sv`)\n\n## Overview\nThe `cross_correlation` module must be implemented to perform energy-based correlation of complex sequences composed of **I (in-phase)** and **Q (quadrature)** components. This top-level module is responsible for integrating two main functional blocks:\n\n- A **correlation stage**, performed by an existing module `correlate`.\n- A **reduction and energy computation stage**, to be implemented in a new module called `adder_2d_layers`.\n\nThe goal is to produce a scalar energy output derived from the correlation between input data and a conjugate reference sequence.\n\n---\n\n## Required Modules\n\n### `cross_correlation` (to be implemented)\nThis is the top-level module and must instantiate:\n\n- The existing `correlate` module to compute intermediate correlation terms.\n- The `adder_2d_layers` module, which will be created to perform summation and energy computation.\n\nThis module must expose configuration parameters and connect all data paths accordingly. All internal parameters required by submodules (e.g., widths, number of symbols, levels of the tree, register configurations) must be configured through the top-level module.\n\n#### Parameters\n| Parameter         | Description                                  | Default Value | Constraints                                               |\n|-------------------|----------------------------------------------|---------------|-----------------------------------------------------------|\n| `NS_DATA_IN`      | Number of input data samples                 | `2`           | $\\geq$ 2                                                  |\n| `NBW_DATA_IN`     | Bit width of each input data sample          | `5`           | $\\geq$ 3                                                  |\n| `NBI_DATA_IN`     | Number of integer bits in the input data     | `1`           | $\\leq$ `NBW_DATA_IN - 2`                                  |\n| `NBW_ENERGY`      | Bit width of the final energy output         | `5`           | Between `3` and `NBW_DATA_IN`, inclusive                  |\n\n\n#### Interface\n\n| Signal           | Direction | Width                               | Description                                               |\n|------------------|-----------|-------------------------------------|-----------------------------------------------------------|\n| `clk`            | Input     | 1 bit                               | System clock                                              |\n| `i_enable`       | Input     | 1 bit                               | Enable signal for pipeline stages                         |\n| `i_data_i`       | Input     | `NBW_DATA_IN * NS_DATA_IN`          | Input data (I component)                                  |\n| `i_data_q`       | Input     | `NBW_DATA_IN * NS_DATA_IN`          | Input data (Q component)                                  |\n| `i_conj_seq_i`   | Input     | `NS_DATA_IN`                        | Conjugate sequence for I                                  |\n| `i_conj_seq_q`   | Input     | `NS_DATA_IN`                        | Conjugate sequence for Q                                  |\n| `o_energy`       | Output    | `NBW_ENERGY`                        | Computed energy value from cross correlation              |\n\n---\n\n### `adder_2d_layers` (to be implemented)\nThis module sits between `cross_correlation` and the existing `adder_tree_2d` module. It is responsible for:\n\n1. **Instantiating two `adder_tree_2d` modules** (one for I and one for Q correlation results) to perform 2D summation of the outputs from `correlate`. These modules should be used with no clock cycles for latency.\n2. **Aditional Logic**: A pipeline stage must be implemented that **registers the outputs** of both adder trees **only when the enable signal is asserted**. No reset signal is required. After registering the outputs, using combinational logic, the energy must be calculated as the **sum of the squares** of the I and Q results. This energy value must then be **truncated** to retain only the **most significant bits**, based on a top-level parameter defining the energy output width.\n\nAll internal parameters must be **configured from the top-level** `cross_correlation` module to ensure flexibility and consistency.\n\n| Parameter             | Default Value | Description                                                                |\n|-----------------------|---------------|----------------------------------------------------------------------------|\n| `NBW_IN`              | 8             | Bit width of each correlation input sample                                 |\n| `NS_IN`               | 80            | Number of input samples to the adder tree                                  |\n| `N_LEVELS`            | 7             | Number of levels in the adder tree                                         |\n| `REGS`                | 8'b100010_0   | Bitmask that enables pipelining per level: each bit corresponds to a level |\n| `NBW_ADDER_TREE_OUT`  | 8             | Output bit width of the adder tree                                         |\n| `NBW_ENERGY`          | 5             | Output bit width for energy (after truncation)                             |\n\n\n#### Interface\n\n| Signal           | Direction | Width                                | Description                                               |\n|------------------|-----------|---------------------------------------|-----------------------------------------------------------|\n| `clk`            | Input     | 1 bit                                 | System clock                                              |\n| `i_enable`       | Input     | 1 bit                                 | Enable signal to control output registration              |\n| `i_data_i`       | Input     | `NBW_IN * NS_IN`                      | Input correlation data (I component)                      |\n| `i_data_q`       | Input     | `NBW_IN * NS_IN`                      | Input correlation data (Q component)                      |\n| `o_data_i`       | Output    | `NBW_IN + N_LEVELS`                   | Accumulated correlation result for I                      |\n| `o_data_q`       | Output    | `NBW_IN + N_LEVELS`                   | Accumulated correlation result for Q                      |\n| `o_energy`       | Output    | `NBW_ENERGY`                          | Truncated energy result from the squared I and Q results  |\n\n---\n\n## Parameter Inference and Top-Level Propagation\n\nTo ensure proper functionality and maintainability of the design, additional internal configuration parameters must be created at the top level to support the submodules \u2014 particularly the adder tree components.\n\nThe following guidelines describe how these parameters should be inferred:\n\n1. **Tree Depth Parameterization**  \n   A parameter must be derived to represent the number of reduction levels in the adder tree structure. This value should be computed based on the total number of input elements and should represent the minimum number of binary reduction stages needed to produce a single accumulated result.\n\n2. **Register Placement Configuration**  \n   A configuration mask must be defined to control the placement of pipeline registers across the different summation levels of the tree. Each bit in the mask corresponds to one level, and activating a bit means inserting a register stage at that point. This allows fine-grained control over timing and latency.\n\n3. **Data Width Growth Calculation**  \n   Parameters must be created to determine the required width of the signals entering and exiting the adder tree. These widths must account for the growth caused by successive additions and must guarantee that no overflow occurs. This includes the signed bit growth of the accumulated values. All internal signals should be able to perform operations without rounding, saturating, or truncating any bits. Only the output `o_energy` is subject to specific truncation guidelines.\n\nAll of these derived values must be determined and set at the top level and passed as parameters to all relevant submodules. These derivations must follow consistent arithmetic rules and must not be hardcoded inside the internal modules to preserve modularity.\n\n\n## Notes\n\n- The `correlate` and `adder_tree_2d` modules already exist and should **not be reimplemented**.\n- The modules `cross_correlation` and `adder_2d_layers` must be developed based on the descriptions above.\n- The `adder_2d_layers` module must include both sequential (pipelining) and combinational (energy calculation) logic as specified.\n- All configuration must be managed through top-level parameters to ensure consistency across submodules.", "docs/spec_detect_sequence.md": "# Sequence Detection Module (`detect_sequence.sv`)\n\n## Parameters\n\n| Parameter         | Description                                               | Default | Constraints                                                             |\n|-------------------|-----------------------------------------------------------|---------|-------------------------------------------------------------------------|\n| `NS`              | Number of pilot symbols                                   | 64      | Minimum 32, maximum 64, must be a multiple of 2                         |\n| `NBW_PILOT_POS`   | Bit width to address position within `NS`                 | 6       | Must be equal to `ceil(log2(NS))`                                       |\n| `NBW_DATA_SYMB`   | Bit width of each I/Q data sample                         | 8       | Minimum 3                                                               |\n| `NBI_DATA_SYMB`   | Number of integer bits within each sample                 | 2       | Must be `NBW_DATA_SYMB - 2`                                             |\n| `NBW_TH_FAW`      | Bit width of static threshold                             | 10      | Must be equal to `NBW_DATA_SYMB + 2`                                    |\n| `NBW_ENERGY`      | Bit width of energy output from correlation               | 10      | Must be equal to `NBW_TH_FAW`                                           |\n| `NS_FAW`          | Number of samples used in FAW correlation                 | 23      | Fixed value                                                             |\n| `NS_FAW_OVERLAP`  | Overlap used in FAW correlation                           | 22      | Must be equal to `NS_FAW - 1`                                           |\n\n---\n\n## Interfaces\n\n### Inputs\n\n| Signal               | Width                                   | Description                                      |\n|----------------------|-----------------------------------------|--------------------------------------------------|\n| `clk`                | 1                                       | System clock                                     |\n| `rst_async_n`        | 1                                       | Asynchronous active-low reset                    |\n| `i_valid`            | 1                                       | Valid signal to indicate valid input window      |\n| `i_enable`           | 1                                       | Global enable for detection                      |\n| `i_proc_pol`         | 1                                       | Sequence polarity selector (horizontal/vertical) |\n| `i_proc_pos`         | `NBW_PILOT_POS`                         | Processing start position                        |\n| `i_static_threshold` | `NBW_TH_FAW`                            | Threshold to compare with the computed energy    |\n| `i_data_i`           | `NBW_DATA_SYMB * (NS + NS_FAW_OVERLAP)` | Flattened I input samples for full window        |\n| `i_data_q`           | `NBW_DATA_SYMB * (NS + NS_FAW_OVERLAP)` | Flattened Q input samples for full window        |\n\n### Outputs\n\n| Signal            | Width  | Description                                |\n|-------------------|--------|--------------------------------------------|\n| `o_proc_detected` | 1      | Detection flag output (1 = sequence found) |\n\n---\n\n## Logic Description\n\n### Conjugate Sequence Setup\n\nTwo predefined sequences must be stored to represent conjugate reference signals in the complex plane. These sequences correspond to expected pilot patterns in both horizontal and vertical orientations. The values should be constructed by computing the complex conjugate of the ideal signal, converting it to fixed-point representation, and then encoding the real and imaginary parts as bitstreams.\n\nThe module must allow dynamic selection between these two sequences based on a polarity signal. The selected conjugate must be assigned combinationally using the registered version of `i_proc_pol`.\n\nFor more information, refer docs/spec_conj.md\n### Enable Pipeline\n\nA global `enable` signal must be formed by combining `i_valid` and `i_enable`. This signal must be propagated through a pipeline of flip-flops. The number of stages in the pipeline must match the internal latency of the `cross_correlation` module.\n\n- The **first stage** of the pipeline is used to drive the `i_enable` input of `cross_correlation`.\n- The **last stage** must be used to validate the final detection output (`o_proc_detected`).\n- When reset is active, all pipeline stages must be cleared to zero.\n\n### Input Data Buffering\n\nOn the rising edge of the clock, when the global enable is active **before** the pipeline, a window of `NS_PROC` samples must be extracted from both `i_data_i` and `i_data_q` starting at position `i_proc_pos`. These samples must be stored in internal registers.\n\n### Conjugate Selection\n\nThe conjugate sequence to be used must be selected based on the **registered value** of `i_proc_pol`. This selection must occur using combinational logic.\n\n### Cross-Correlation Output Processing\n\nThe output energy from the `cross_correlation` module must be compared against the static threshold using the `>=` operator. If the comparison is true **and** the last stage of the enable pipeline is active, the detection result is `1`. Otherwise, it is `0`.\n\nThis detection result must be registered and then assigned to `o_proc_detected`.\n\n---", "rtl/adder_2d_layers.sv": "module adder_2d_layers #(\n    parameter NBW_IN   = 'd8        ,\n    parameter NS_IN    = 'd80       ,\n    parameter N_LEVELS = 'd7        ,\n    parameter REGS     = 8'b100010_0,\n    parameter NBW_ADDER_TREE_OUT = 8,\n    parameter NBW_ENERGY = 5\n) (\n    input  logic                                clk    ,\n    input  logic                               i_enable,\n    input  logic [           NBW_IN*NS_IN-1:0] i_data_i,\n    input  logic [           NBW_IN*NS_IN-1:0] i_data_q,\n    output logic [(NBW_IN+N_LEVELS)-1:0] o_data_i,\n    output logic [(NBW_IN+N_LEVELS)-1:0] o_data_q,\n    output logic [NBW_IN-1:0] o_energy    \n);\n\nlogic signed [NBW_ADDER_TREE_OUT-1:0] correlation_i_dff;\nlogic signed [NBW_ADDER_TREE_OUT-1:0] correlation_q_dff;\n\nwire signed [2*NBW_ADDER_TREE_OUT-1:0] energy_i;\nwire signed [2*NBW_ADDER_TREE_OUT-1:0] energy_q;\nwire signed [2*NBW_ADDER_TREE_OUT:0] energy;\n\n/*Sum all corelation_i components */\nadder_tree_2d #(\n    .NBW_IN  (NBW_IN  ),\n    .NS_IN   (NS_IN   ),\n    .N_LEVELS(N_LEVELS),\n    .REGS    (REGS    ) \n) uu_sum_corr_i (\n        .clk   (clk            ),\n        .i_data(i_data_i       ),\n        .o_data(o_data_i       )\n);\n\n/*Sum all corelation_q components */\nadder_tree_2d #(\n    .NBW_IN  (NBW_IN  ),\n    .NS_IN   (NS_IN   ),\n    .N_LEVELS(N_LEVELS),\n    .REGS    (REGS    ) \n) uu_sum_corr_q (\n        .clk   (clk            ),\n        .i_data(i_data_q       ),\n        .o_data(o_data_q       )\n);\n\nalways_ff @(posedge clk) begin : proc_correlation_dff\n  if(i_enable) begin\n      correlation_i_dff <= o_data_i;\n      correlation_q_dff <= o_data_q;\n   end \nend\n\nassign energy_i  = correlation_i_dff*correlation_i_dff;\nassign energy_q  = correlation_q_dff*correlation_q_dff;\nassign energy    = $unsigned(energy_i) + $unsigned(energy_q);\nassign o_energy  = energy[2*NBW_ADDER_TREE_OUT-:NBW_ENERGY];\n\n\nendmodule", "rtl/adder_tree_2d.sv": "module adder_tree_2d #(\n    parameter NBW_IN   = 'd8        ,\n    parameter NS_IN    = 'd80       ,\n    parameter N_LEVELS = 'd7        ,\n    parameter REGS     = 8'b100010_0\n) (\n    input  logic                                clk               ,\n    input  logic        [NBW_IN*NS_IN-1:0]      i_data,\n    output logic signed [(NBW_IN+N_LEVELS)-1:0] o_data\n);\n    logic signed [NBW_IN-1:0] i_data_2d [NS_IN-1:0];\n\n    always_comb begin\n      for(int k = 0; k < NS_IN; k++) begin\n         i_data_2d[k] = $signed(i_data[(k+1)*NBW_IN-1-:NBW_IN]);\n      end\n    end\n\n    function automatic integer func_nadd (input integer level);\n        integer i;\n        integer nadd;\n        begin\n            nadd = $signed(NS_IN);\n            for (i=0; i<level; i=i+1) begin\n                nadd = (nadd+1)/2;\n            end\n            func_nadd = nadd;\n        end\n    endfunction\n\n    genvar i,j;\n    generate\n        for (i=0; i<=N_LEVELS; i=i+1) begin : levels\n\n            for (j=0; j<func_nadd(i); j=j+1 ) begin : nodes\n\n                reg signed [i+NBW_IN-1:0] result;\n\n                if (i == 0) begin : gen_initial\n\n                    if (REGS[i]) begin: gen_init_reg\n                        always_ff @ (posedge clk) begin : in_split_reg\n                            begin\n                                result <= $signed(i_data_2d[j]);\n                            end\n                        end\n                    end else begin : gen_comb\n                        always_comb begin : in_split_comb\n                            result = $signed(i_data_2d[j]);\n                        end\n                    end\n\n                end else if (2*j+1 == func_nadd(i-1)) begin : gen_others\n\n                    if (REGS[i]) begin : gen_reg\n                        always_ff @ (posedge clk) begin : odd_reg\n                            begin\n                                result <= levels[i-1].nodes[2*j+0].result;\n                            end\n                        end\n                    end else begin : gen_comb\n                        always_comb begin : odd \n                            result = levels[i-1].nodes[2*j+0].result;\n                        end\n\n                    end\n\n                end else begin : gen_final\n\n                    if (REGS[i]) begin : gen_end_ff\n                        always_ff @(posedge clk) begin : add_reg\n                            begin\n                                result <= levels[i-1].nodes[2*j+0].result +\n                                    levels[i-1].nodes[2*j+1].result;\n                            end\n                        end\n                    end else begin : gen_end_comb\n                        always_comb begin : add \n                            result = levels[i-1].nodes[2*j+0].result +\n                                levels[i-1].nodes[2*j+1].result;\n                        end\n                    end\n\n                end\n            end\n        end\n    endgenerate\n\n    assign o_data = levels[N_LEVELS].nodes[0].result;\n\nendmodule", "rtl/correlate.sv": "module correlate #(\n   parameter  NS_DATA_IN        = 'd11,\n   parameter  NBW_DATA_IN = 'd08,\n   parameter  NBW_ADDER_TREE_IN = 3\n)\n(\n input  logic [NBW_DATA_IN*NS_DATA_IN-1 : 0]  i_data_i    ,\n input  logic [NBW_DATA_IN*NS_DATA_IN-1 : 0]  i_data_q    ,\n input  logic        [       NS_DATA_IN-1 : 0]  i_conj_seq_i,\n input  logic        [       NS_DATA_IN-1 : 0]  i_conj_seq_q,   \n output logic [NBW_ADDER_TREE_IN*NS_DATA_IN-1:0]o_sum_i,\n output logic [NBW_ADDER_TREE_IN*NS_DATA_IN-1:0]o_sum_q\n\n);\n\nwire signed  [      NBW_DATA_IN:0] add[NS_DATA_IN];\nwire signed  [      NBW_DATA_IN:0] sub[NS_DATA_IN];\n\nlogic signed [NBW_ADDER_TREE_IN-1:0] sum_i[NS_DATA_IN];\nlogic signed [NBW_ADDER_TREE_IN-1:0] sum_q[NS_DATA_IN];\n\nlogic signed [NBW_DATA_IN-1:0]  i_data_i_2d [NS_DATA_IN-1:0]; \nlogic signed [NBW_DATA_IN-1:0]  i_data_q_2d [NS_DATA_IN-1:0]; \n\nwire [NS_DATA_IN-1:0] signal_seq_i;\nwire [NS_DATA_IN-1:0] signal_seq_q;\n\nalways_comb begin\n    for (int i=0; i<NS_DATA_IN; i++) begin\n        i_data_i_2d[i] = $signed(i_data_i[(i+1)*NBW_DATA_IN-1-:NBW_DATA_IN]);\n        i_data_q_2d[i] = $signed(i_data_q[(i+1)*NBW_DATA_IN-1-:NBW_DATA_IN]);\n    end\nend\n\ngenerate\n    for(genvar i = 0 ; i < NS_DATA_IN; i++) begin\n        \n        /*determinate the signal of the FAW symbs*/\n        assign signal_seq_i[i] = i_conj_seq_i[i];\n        assign signal_seq_q[i] = i_conj_seq_q[i];\n\n\n        assign add[i] = i_data_i_2d[i] + i_data_q_2d[i];\n        assign sub[i] = i_data_i_2d[i] - i_data_q_2d[i];\n    \n        always_comb begin\n            case({signal_seq_i[i],signal_seq_q[i]})\n                2'b00: begin\n                            sum_i[i]  = sub[i];\n                            sum_q[i]  = add[i];\n                       end\n\n                2'b01: begin\n                            sum_i[i]  =  add[i];\n                            sum_q[i]  = -sub[i];\n                       end    \n\n                2'b10: begin\n                            sum_i[i]  = -add[i];\n                            sum_q[i]  =  sub[i];\n                       end    \n\n                2'b11: begin\n                            sum_i[i]  = -sub[i];\n                            sum_q[i]  = -add[i];\n                       end    \n            endcase \n        end\n    end    \nendgenerate\n\nalways_comb begin\n    for (int i=0; i<NS_DATA_IN; ++i) begin\n        o_sum_i[(i+1)*NBW_ADDER_TREE_IN-1-:NBW_ADDER_TREE_IN] = sum_i[i];\n        o_sum_q[(i+1)*NBW_ADDER_TREE_IN-1-:NBW_ADDER_TREE_IN] = sum_q[i];\n    end\nend\nendmodule", "rtl/cross_correlation.sv": "module cross_correlation #(\n   parameter  NS_DATA_IN  = 5,\n   parameter  NBW_DATA_IN = 2,\n   parameter  NBI_DATA_IN = 1,\n   parameter  NBW_ENERGY  = 5\n)\n( \n input  logic                                clk         ,\n input  logic                                i_enable    , \n input  logic [NBW_DATA_IN*NS_DATA_IN-1 : 0] i_data_i    ,\n input  logic [NBW_DATA_IN*NS_DATA_IN-1 : 0] i_data_q    ,\n input  logic [NS_DATA_IN-1:0]               i_conj_seq_i,\n input  logic [NS_DATA_IN-1:0]               i_conj_seq_q,\n output logic [NBW_ENERGY-1:0]               o_energy  \n);\nlocalparam N_ADDER_LEVELS= $clog2(NS_DATA_IN);\nlocalparam N_REG_LEVELS  = 8'b00000000;\n\nlocalparam NBW_ADDER_TREE_IN  = NBW_DATA_IN + 2;\nlocalparam NBI_ADDER_TREE_IN  = NBI_DATA_IN + 2;\n\nlocalparam NBW_ADDER_TREE_OUT = NBW_ADDER_TREE_IN  + N_ADDER_LEVELS;\nlocalparam NBI_ADDER_TREE_OUT = NBI_ADDER_TREE_IN  + N_ADDER_LEVELS;\nlocalparam NBF_ADDER_TREE_OUT = NBW_ADDER_TREE_OUT - NBI_ADDER_TREE_OUT;\n\nlogic [NBW_ADDER_TREE_IN*NS_DATA_IN-1:0] sum_i_1d;\nlogic [NBW_ADDER_TREE_IN*NS_DATA_IN-1:0] sum_q_1d;\n\n/*Correlation result for i and q data component*/\nwire signed [NBW_ADDER_TREE_OUT-1:0] correlation_i;\nwire signed [NBW_ADDER_TREE_OUT-1:0] correlation_q;\n\ncorrelate #(\n    .NS_DATA_IN       (NS_DATA_IN       ),\n    .NBW_DATA_IN      (NBW_DATA_IN      ),\n    .NBW_ADDER_TREE_IN(NBW_ADDER_TREE_IN)\n) uu_correlate(\n    .i_data_i    (i_data_i    ),\n    .i_data_q    (i_data_q    ),\n    .i_conj_seq_i(i_conj_seq_i),\n    .i_conj_seq_q(i_conj_seq_q),   \n    .o_sum_i     (sum_i_1d    ),\n    .o_sum_q     (sum_q_1d    )\n);\n\nadder_2d_layers  #(\n    .NBW_IN            (NBW_ADDER_TREE_IN ),\n    .NS_IN             (NS_DATA_IN        ),\n    .N_LEVELS          (N_ADDER_LEVELS    ),\n    .REGS              (N_REG_LEVELS      ),\n    .NBW_ADDER_TREE_OUT(NBW_ADDER_TREE_OUT),\n    .NBW_ENERGY        (NBW_ENERGY        )\n) uu_adder_2d_layers (\n        .clk     (clk            ),\n        .i_enable(i_enable       ),\n        .i_data_i(sum_i_1d       ),\n        .i_data_q(sum_q_1d       ),\n        .o_data_i(correlation_i  ),\n        .o_data_q(correlation_q  ),\n        .o_energy(o_energy)            \n);\n\nendmodule"}, "patch": {"rtl/detect_sequence.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : /bin/sh -c \"pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -s\"", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/detect_sequence.sv /code/rtl/cross_correlation.sv /code/rtl/adder_tree_2d.sv /code/rtl/adder_2d_layers.sv /code/rtl/correlate.sv\nTOPLEVEL        = detect_sequence\nMODULE          = test_detect_sequence\nPYTHONPATH      = /src\nHASH            = 28-integrate-modules-detect-sequence", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nimport math\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# Reset the DUT (design under test)\nasync def reset_dut(reset_n, duration_ns=10):\n    reset_n.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")   \n\ndef check_instances(dut):\n    assert hasattr(dut, 'uu_cross_correlation'), \"Module cross_correlation does not exist\"\n    assert hasattr(dut.uu_cross_correlation, 'uu_adder_2d_layers'), \"Module adder_2d_layers does not exist\"\n    assert hasattr(dut.uu_cross_correlation, 'uu_correlate'), \"Module correlate does not exist\"\n    assert hasattr(dut.uu_cross_correlation.uu_adder_2d_layers, 'uu_sum_corr_i'), \"Module uu_sum_corr_i does not exist\"\n    assert hasattr(dut.uu_cross_correlation.uu_adder_2d_layers, 'uu_sum_corr_q'), \"Module uu_sum_corr_q does not exist\"    \n\nclass detect_sequence:\n    def __init__(self, ns = 64, nbw_pilot_pos = 6, nbw_data_symb = 8, nbw_th_proc = 8, nbw_energy = 10, ns_proc = 23, ns_proc_overlap = 22):\n        self.ns = ns\n        self.nbw_pilot_pos = nbw_pilot_pos\n        self.nbw_data_symb = nbw_data_symb\n        self.nbw_th_proc = nbw_th_proc\n        self.nbw_energy = nbw_energy\n        self.ns_proc_overlap = ns_proc_overlap\n        self.ns_proc = ns_proc\n        self.pipe_depth = 4\n        self.proc_enable_dff = self.pipe_depth * [0]\n        self.proc_buffer_i_dff = self.ns_proc * [0]\n        self.proc_buffer_q_dff = self.ns_proc * [0]\n        self.i_data_i_2d_delayed = (self.ns + self.ns_proc_overlap) * [0]\n        self.i_data_q_2d_delayed = (self.ns + self.ns_proc_overlap) * [0]\n        self.i_proc_pos_delayed = 0\n        self.proc_buffer_i_dff_delayed_2 = self.ns_proc * [0]\n        self.proc_buffer_q_dff_delayed_2 = self.ns_proc * [0]                \n        self.proc_detected = 0\n        self.proc_detected_dff = 0\n        self.proc_pol_dff = 0\n        self.proc_pol_dff_delayed = 0\n        self.conj_proc_h_1 = 0b11011001100011010001110\n        self.conj_proc_v_1 = 0b10000101011110000101011\n        self.conj_proc_h_0 = 0b10101010111011101000000\n        self.conj_proc_v_0 = 0b11010110101100100001110        \n        self.conj_proc_0 = 0 \n        self.conj_proc_1 = 0\n\n        N_ADDER_LEVELS = math.ceil(math.log2(self.ns_proc))\n        NBW_ADDER_TREE_IN = self.nbw_data_symb + 2\n        NBW_ADDER_TREE_OUT = NBW_ADDER_TREE_IN + N_ADDER_LEVELS\n\n        self.proc_processor = FawSymbolProcessor(\n            ns_data_in=self.ns_proc,\n            nbw_adder_tree_out=NBW_ADDER_TREE_OUT,\n            nbw_energy=nbw_energy\n        )\n\n    def insert_data_and_process(self, i_valid, i_enable, i_proc_pol, i_proc_pos, i_static_threshold, i_data_i_2d, i_data_q_2d):\n        print(f\"using function insert_data_and_process\")\n        self.proc_enable = i_valid & i_enable\n        for i in reversed(range(self.pipe_depth-1)):\n            self.proc_enable_dff[i+1] = self.proc_enable_dff[i]\n        self.proc_enable_dff[0] = self.proc_enable\n\n        self.proc_buffer_i_dff_delayed = self.proc_buffer_i_dff\n        self.proc_buffer_q_dff_delayed = self.proc_buffer_q_dff\n        self.proc_pol_dff_delayed = self.proc_pol_dff\n\n        for i in range(self.ns_proc):\n            self.proc_buffer_i_dff[i] = self.i_data_i_2d_delayed[self.i_proc_pos_delayed+i]\n            self.proc_buffer_q_dff[i] = self.i_data_q_2d_delayed[self.i_proc_pos_delayed+i]\n        if self.proc_enable:\n            self.proc_pol_dff = i_proc_pol\n            self.i_proc_pos_delayed = i_proc_pos\n            self.i_data_i_2d_delayed = i_data_i_2d\n            self.i_data_q_2d_delayed = i_data_q_2d\n\n\n        if self.proc_pol_dff_delayed:\n            self.conj_proc_0 = self.conj_proc_v_0\n            self.conj_proc_1 = self.conj_proc_v_1\n        else:\n            self.conj_proc_0 = self.conj_proc_h_0\n            self.conj_proc_1 = self.conj_proc_h_1  \n\n        sum_i, sum_q = self.proc_processor.process(\n            i_enable=self.proc_enable_dff[1],\n            i_conj_seq_i_int=self.conj_proc_0,\n            i_conj_seq_q_int=self.conj_proc_1,\n            i_data_i_2d=self.proc_buffer_i_dff_delayed,\n            i_data_q_2d=self.proc_buffer_q_dff_delayed\n        )\n\n        self.proc_detected_dff = self.proc_detected\n        if self.proc_processor.o_energy_delayed >= i_static_threshold:\n            self.proc_detected = 1  & self.proc_enable_dff[3]\n        else:\n            self.proc_detected = 0                \n\nclass FawSymbolProcessor:\n    def __init__(self, ns_data_in, nbw_adder_tree_out, nbw_energy):\n        self.ns_data_in = ns_data_in\n        self.nbw_adder_tree_out = nbw_adder_tree_out\n        self.nbw_energy = nbw_energy\n        self.energy_i_delayed = 0 \n        self.energy_q_delayed = 0 \n        self.energy_delayed   = 0 \n        self.o_energy_delayed = 0\n        self.energy_i = 0 \n        self.energy_q = 0 \n        self.energy   = 0 \n        self.o_energy = 0\n        self.model_sum_all_i = 0\n        self.model_sum_all_q = 0\n\n    def _int_to_bit_list(self, value):\n        return [(value >> i) & 1 for i in range(self.ns_data_in)]\n    \n    def process(self, i_enable, i_conj_seq_i_int, i_conj_seq_q_int, i_data_i_2d, i_data_q_2d):\n        i_enable_0 = i_enable & 1\n        #i_enable_1 = (i_enable >> 1) & 1\n\n        i_conj_seq_i = self._int_to_bit_list(i_conj_seq_i_int)\n        i_conj_seq_q = self._int_to_bit_list(i_conj_seq_q_int)\n\n        assert len(i_data_i_2d) == self.ns_data_in\n        assert len(i_data_q_2d) == self.ns_data_in\n        sum_i = []\n        sum_q = []\n\n        for i in range(self.ns_data_in):\n            signal_seq_i = i_conj_seq_i[i]\n            signal_seq_q = i_conj_seq_q[i]\n\n            add = i_data_i_2d[i] + i_data_q_2d[i]\n            sub = i_data_i_2d[i] - i_data_q_2d[i]\n\n            selector = (signal_seq_i << 1) | signal_seq_q\n            if selector == 0b00:\n                sum_i.append(sub)\n                sum_q.append(add)\n            elif selector == 0b01:\n                sum_i.append(add)\n                sum_q.append(-sub)\n            elif selector == 0b10:\n                sum_i.append(-add)\n                sum_q.append(sub)\n            elif selector == 0b11:\n                sum_i.append(-sub)\n                sum_q.append(-add)\n            else:\n                raise ValueError(f\"Invalid selector: {selector}\")\n\n        self.model_sum_all_i = sum(sum_i)        \n        self.model_sum_all_q = sum(sum_q)        \n\n        self.energy_i_delayed = self.energy_i\n        self.energy_q_delayed = self.energy_q\n        self.energy_delayed   = self.energy\n        self.o_energy_delayed = self.o_energy  \n\n        if i_enable_0:\n            self.energy_i = self.model_sum_all_i*self.model_sum_all_i\n            self.energy_q = self.model_sum_all_q*self.model_sum_all_q\n            self.energy   = self.energy_i + self.energy_q\n            self.o_energy = (self.energy >> int((2*self.nbw_adder_tree_out+1-self.nbw_energy))) & (2**self.nbw_energy-1)\n            #print(f\"self.nbw_adder_tree_out:{self.nbw_adder_tree_out}, self.energy:{self.energy}\")\n                \n        return sum_i, sum_q\n", "src/test_detect_sequence.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport harness_library as hrs_lb\nimport random\nimport math\nimport cmath\n\n@cocotb.test()\nasync def test_low_pass_filter(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Debug mode\n    debug = 0\n    \n    # Retrieve parameters from the DUT\n    NS_PROC = int(dut.NS_PROC.value)\n    NS_PROC_OVERLAP = NS_PROC - 1\n    NS  = int(dut.NS.value)\n    NS_DATA_IN = NS + NS_PROC_OVERLAP\n    NBW_PILOT_POS = int(dut.NBW_PILOT_POS.value)\n    NBW_DATA_IN = int(dut.NBW_DATA_IN.value)\n    NBI_DATA_IN = int(dut.NBI_DATA_IN.value)\n    NBW_TH_PROC  = int(dut.NBW_TH_PROC.value)\n    NBW_ENERGY  = int(dut.NBW_ENERGY.value)\n\n    cocotb.log.warning(f\"NS_PROC: {NS_PROC}, NS_PROC_OVERLAP: {NS_PROC_OVERLAP}, NS_DATA_IN: {NS_DATA_IN}, NBW_PILOT_POS: {NBW_PILOT_POS}, NBW_DATA_IN: {NBW_DATA_IN}, NBI_DATA_IN: {NBI_DATA_IN}, NBW_TH_PROC: {NBW_TH_PROC}, NBW_ENERGY: {NBW_ENERGY}\")\n\n    #model = hrs_lb.FawSymbolProcessor(ns_data_in=NS_DATA_IN, nbw_adder_tree_out=NBW_ADDER_TREE_OUT, nbw_energy=NBW_ENERGY)\n    model = hrs_lb.detect_sequence(ns=NS, nbw_pilot_pos=NBW_PILOT_POS, nbw_data_symb=NBW_DATA_IN, nbw_th_proc=NBW_TH_PROC, nbw_energy=NBW_ENERGY, ns_proc=NS_PROC, ns_proc_overlap=NS_PROC_OVERLAP)\n    # Initialize DUT\n    await hrs_lb.dut_init(dut)\n\n    # Apply reset and enable\n    await hrs_lb.reset_dut(dut.rst_async_n)\n\n    await RisingEdge(dut.clk)\n\n    # Calculate min and max values for data and coefficients\n    data_min = int(-2**NBW_DATA_IN / 2)\n    data_max = int((2**NBW_DATA_IN / 2) - 1)\n\n    # Number of random test iterations\n    num_random_iterations = 15\n\n    # Follow registers does not have reset on DUT, \n    # to prevent X error, 0 is assign to them\n    dut.uu_cross_correlation.uu_adder_2d_layers.energy_i.value = 0\n    dut.uu_cross_correlation.uu_adder_2d_layers.energy_q.value = 0\n    for i in range(NS_PROC):\n        dut.proc_buffer_i_dff[i].value = 0\n        dut.proc_buffer_q_dff[i].value = 0\n\n    ###########################################################################\n    ## Check if all modules exists\n    ###########################################################################    \n    hrs_lb.check_instances(dut)\n\n    i_static_threshold = random.randint(0,2**NBW_TH_PROC - 1)\n    dut.i_static_threshold.value = i_static_threshold\n\n    for _ in range(num_random_iterations):\n        \n        ###########################################################################\n        ## Generate INPUTS\n        ###########################################################################\n\n        i_enable  = random.randint(0,1)\n        i_valid   = random.randint(0,1)\n        i_proc_pol = random.randint(0,1) \n        i_proc_pos = random.randint(0,2**NBW_PILOT_POS - 1)\n        dut.i_enable.value = i_enable\n        dut.i_valid.value = i_valid\n        dut.i_proc_pol.value = i_proc_pol\n        dut.i_proc_pos.value = i_proc_pos\n\n        # Gera lista de valores aleat\u00f3rios\n        i_data_i_list = [random.randint(data_min, data_max) for _ in range(NS_DATA_IN)]\n        i_data_q_list = [random.randint(data_min, data_max) for _ in range(NS_DATA_IN)]\n\n        i_data_i_value = 0\n        i_data_q_value = 0\n        for idx in range(NS_DATA_IN):\n            i_data_i_value |= (i_data_i_list[idx] & ((1 << NBW_DATA_IN) - 1)) << (NBW_DATA_IN * idx)\n            i_data_q_value |= (i_data_q_list[idx] & ((1 << NBW_DATA_IN) - 1)) << (NBW_DATA_IN * idx)\n\n        dut.i_data_i.value = i_data_i_value\n        dut.i_data_q.value = i_data_q_value\n\n        model.insert_data_and_process(i_valid, i_enable, i_proc_pol, i_proc_pos, i_static_threshold, i_data_i_list, i_data_q_list)\n\n        if debug:\n            cocotb.log.info(f\"[INPUTS] i_data_i: {i_data_i_list}\")\n            cocotb.log.info(f\"[INPUTS] i_data_q: {i_data_q_list}\")\n            cocotb.log.info(f\"[INPUTS] i_valid : {i_valid}\")\n            cocotb.log.info(f\"[INPUTS] i_enable : {i_enable}\")\n            cocotb.log.info(f\"[INPUTS] i_proc_pol: {i_proc_pol}\")\n            cocotb.log.info(f\"[INPUTS] i_proc_pos: {i_proc_pos}\")\n            cocotb.log.info(f\"[INPUTS] i_static_threshold: {i_static_threshold}\")\n            cocotb.log.info(f\"[DEBUG] start sample: {i_data_i_list[i_proc_pos]}\")\n\n        await RisingEdge(dut.clk)\n        \n        if debug:\n            cocotb.log.info(f\"[DUT] buffer i: {dut.proc_buffer_i_dff.value[0].to_signed()}\")\n            cocotb.log.info(f\"[MOD] buffer i: {model.proc_buffer_i_dff_delayed[0]}\")\n            cocotb.log.info(f\"[DUT] energy: {dut.proc_calc_energy.value.to_signed()}\")\n            cocotb.log.info(f\"[MOD] energy: {model.proc_processor.o_energy_delayed}\")\n        \n        # Checking internal signals\n        assert dut.proc_buffer_i_dff.value[0].to_signed() == model.proc_buffer_i_dff_delayed[0]\n        assert dut.proc_pol_dff.value.integer == model.proc_pol_dff_delayed\n        assert dut.conj_proc_seq.value[0].integer == model.conj_proc_0\n        assert dut.conj_proc_seq.value[1].integer == model.conj_proc_1\n        assert dut.proc_calc_energy.value.to_signed() == model.proc_processor.o_energy_delayed\n\n        if debug:\n            cocotb.log.info(f\"dut: {dut.o_proc_detected.value.integer} , model: {model.proc_detected_dff}\")\n            cocotb.log.info(f\"[DETECTED] dut: {dut.proc_enable_dff.value[2]} , model: {model.proc_enable_dff[3]}\")\n\n        # Checking DUT output\n        assert dut.o_proc_detected.value.integer == model.proc_detected_dff\n        \n    cocotb.log.info(f\"All tests passed finished.\")\n", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nimport math\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef runner(NBW_DATA_IN: int, NS_DATA_IN: int, NBI_DATA_IN: int, NBW_ENERGY: int, NBW_PILOT_POS: int, NBW_TH_PROC: int):\n    parameters = {\n        \"NBW_DATA_IN\":    NBW_DATA_IN,\n        \"NS\":             NS_DATA_IN,\n        \"NBI_DATA_IN\":    NBI_DATA_IN,\n        \"NBW_ENERGY\":     NBW_ENERGY,\n        \"NBW_PILOT_POS\":  NBW_PILOT_POS,\n        \"NBW_TH_PROC\":    NBW_TH_PROC,\n        \"NS_PROC\":        23,\n        \"NS_PROC_OVERLAP\":22\n    }\n\n    # Debug information\n    print(f\"[DEBUG] Running simulation with:\")\n    for k, v in parameters.items():\n        print(f\"  {k} = {v}\")\n\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameters,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\n# Generate valid parameter combinations\ndef generate_param_combinations():\n    combinations = []\n\n    for ns in range(32, 65, 2):  # NS: 32 to 64, step 2\n        nbw_pilot_pos = int(math.ceil(math.log2(ns)))\n\n        for nbw in range(3, 9):  # NBW_DATA_IN: at least 3\n            nbi = nbw - 2  # NBI = NBW - 2\n            if nbi < 1:\n                continue\n\n            nbw_th_faw = nbw + 2\n            nbw_energy = nbw_th_faw\n\n            combinations.append((nbw, ns, nbi, nbw_energy, nbw_pilot_pos, nbw_th_faw))\n\n    return combinations\n\n\n# Generate and limit number of tests\nN_TESTS = 5\nvalid_param_combinations = generate_param_combinations()\nlimited_param_combinations = valid_param_combinations[:N_TESTS]  # Change [:3] to run more/less\n\n\n# Parametrize using valid (NBW_DATA_IN, NS_DATA_IN, NBI_DATA_IN, NBW_ENERGY, ...) tuples\n@pytest.mark.parametrize(\"NBW_DATA_IN, NS_DATA_IN, NBI_DATA_IN, NBW_ENERGY, NBW_PILOT_POS, NBW_TH_PROC\", limited_param_combinations)\n@pytest.mark.parametrize(\"test\", range(3))\ndef test_data(NBW_DATA_IN, NS_DATA_IN, NBI_DATA_IN, NBW_ENERGY, NBW_PILOT_POS, NBW_TH_PROC, test):\n    runner(\n        NBW_DATA_IN=NBW_DATA_IN,\n        NS_DATA_IN=NS_DATA_IN,\n        NBI_DATA_IN=NBI_DATA_IN,\n        NBW_ENERGY=NBW_ENERGY,\n        NBW_PILOT_POS=NBW_PILOT_POS,\n        NBW_TH_PROC=NBW_TH_PROC\n    )", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -s'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_poly_decimator_0001", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Edit files** by using:\n    - `sed -i 's/old_text/new_text/g' <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "You are required to design a System Verilog module `poly_decimator`. The `poly_decimator` is a top-module and it must integrate a number of provided files. The detailed specification of `poly_decimator` is provided in the document `docs/poly_decimator.md`.\n\n## Integration Instructions\n- The **`poly_decimator`** module, that should be defined in `rtl/poly_decimator.sv`, must serve as the top-level design. It is responsible for handling the overall decimation operation of M samples.\n\nYou are also provided with a library of pre-designed modules that must be integrated into the target module. The library modules are:\n\n- **adder_tree**  \n  - **Design File:** `rtl/adder_tree.sv`  \n  - **Specifications:** `docs/adder_tree.md`  \n  - **Functionality:** Implements a pipelined adder tree for summing multiple data inputs.\n\n- **shift_register**  \n  - **Design File:** `rtl/shift_register.sv`  \n  - **Specifications:** `docs/shift_register.md`  \n  - **Functionality:** Implements a shift register that stores a history of input samples.\n\n- **coeff_ram**  \n  - **Design File:** `rtl/coeff_ram.sv`  \n  - **Specifications:** `docs/coeff_ram.md`  \n  - **Functionality:** Provides a synchronous memory block for storing filter coefficients.\n\n- **poly_filter**  \n  - **Design File:** `rtl/poly_filter.sv`  \n  - **Specifications:** `docs/poly_filter.md`  \n  - **Functionality:** Implements the filtering operation for each polyphase branch: it multiplies a subset of input samples by the proper coefficients, then sums the products.\n\nEnsure that you fully understand the functionality and interfaces of these modules as described in their specification documents. They must be integrated properly to achieve the desired polyphase decimation functionality\n", "context": {"docs/adder_tree.md": "## Adder Tree Design\n\nThe `adder_tree` module takes an array of `NUM_INPUTS` data words (each of width `DATA_WIDTH`) and computes their sum using a pipelined adder tree structure. The design is fully pipelined, meaning that at each clock cycle a new sum can be produced after the pipeline is filled.\n\nThe addition process is divided into several stages:\n- **Stage 0:** The input data is registered and sign-extended to ensure proper arithmetic addition.\n- **Subsequent Stages:** Each stage halves the number of elements by summing adjacent pairs. The number of stages required is calculated as `NUM_STAGES = $clog2(NUM_INPUTS)`.\n- **Final Stage:** The final sum is available at the output along with a valid flag (`valid_out`) that propagates through the pipeline.\n\n---\n\n## Parameters\n\n- **NUM_INPUTS**  \n  **Type:** Integer  \n  **Description:** Number of input data words to be summed.  \n  **Default Value:** 8\n\n- **DATA_WIDTH**  \n  **Type:** Integer  \n  **Description:** Bit width of each input data word.  \n  **Default Value:** 32\n\nThe output width is automatically computed as `DATA_WIDTH + $clog2(NUM_INPUTS)` to accommodate the growth in bit width due to the summation of multiple inputs.\n\n---\n\n## Interface Table\n\n| Signal Name | Direction | Width                                                       | Description                             |\n|-------------|-----------|-------------------------------------------------------------|-----------------------------------------|\n| `clk`       | Input     | 1                                                           | Clock signal                            |\n| `arst_n`    | Input     | 1                                                           | Active-low asynchronous reset           |\n| `valid_in`  | Input     | 1                                                           | Valid signal for the input data         |\n| `data_in`   | Input     | Array of `NUM_INPUTS` elements, each `DATA_WIDTH` bits wide | Array of input data words to be summed. |\n| `sum_out`   | Output    | `DATA_WIDTH + $clog2(NUM_INPUTS)` bits                      | The computed sum of the data            |\n| `valid_out` | Output    | 1                                                           | Valid signal for the output sum         |\n\n\n---\n\n## Detailed Operation\n\n### Stage 0: Input Registration\n- **Function:**  \n  On the rising edge of `clk`, if `valid_in` is asserted, each input word from `data_in` is registered into the first stage of the pipeline (`stage_reg[0]`).  \n- **Sign Extension:**  \n  Each input is sign-extended to a width of `DATA_WIDTH + $clog2(NUM_INPUTS)` bits. This ensures that when negative numbers are involved, the additions are computed correctly.\n- **Valid Signal:**  \n  If `valid_in` is high, `valid_stage[0]` is set to `1` to indicate that the first stage has valid data.\n\n### Subsequent Pipeline Stages\n- **Function:**  \n  A generate block creates `NUM_STAGES` pipeline stages. In each stage, the number of data words is halved by adding pairs from the previous stage.  \n- **Computation:**  \n  For stage `s`, there are `NUM_INPUTS >> s` elements. Each element is computed as:  \n  ```\n  stage_reg[s][j] = stage_reg[s-1][2*j] + stage_reg[s-1][2*j+1]\n  ```\n- **Valid Propagation:**  \n  The valid flag propagates from one stage to the next. If the previous stage's valid signal (`valid_stage[s-1]`) is high, then `valid_stage[s]` is set high after the addition.\n\n### Final Output\n- **Sum Output:**  \n  The final sum is taken from `stage_reg[NUM_STAGES][0]` and assigned to `sum_out`.\n- **Valid Output:**  \n  The final valid signal is available on `valid_out`, which is assigned from `valid_stage[NUM_STAGES]`.", "docs/coeff_ram.md": "# Coefficient RAM\n\nThe `coeff_ram` module implements a simple synchronous read-only memory that stores a set of coefficients. It should be used in `polyphase filtering` to fetch the filtering coefficients\n\nWhen an address is provided at the `addr` input, the module outputs the corresponding coefficient stored in its internal memory array (`mem`).\n\n---\n\n## Parameters\n\n- **NUM_COEFFS**  \n  - **Type:** Integer  \n  - **Description:** Specifies the total number of coefficients stored in the RAM.  \n  - **Default Value:** 32\n\n- **DATA_WIDTH**  \n  - **Type:** Integer  \n  - **Description:** Specifies the bit width of each coefficient.  \n  - **Default Value:** 16\n\n---\n\n## Interface Table\n\n| Signal Name | Direction | Width                     | Description                                                 |\n|-------------|-----------|---------------------------|-------------------------------------------------------------|\n| `clk`       | Input     | 1                         | Clock signal.                                               |\n| `addr`      | Input     | `$clog2(NUM_COEFFS)` bits | Address input used to index the coefficient memory array.   |\n| `data_out`  | Output    | `DATA_WIDTH` bits         | Synchronously outputs the coefficient stored at the address |\n\n\n---\n\n## How the Module Works\n\n1. **Memory Storage:**  \n   The module contains an internal memory array `mem` that holds `NUM_COEFFS` coefficients. Each coefficient is `DATA_WIDTH` bits wide.\n\n2. **Synchronous Read Operation:**  \n   On every rising edge of the clock (`clk`), the module reads the coefficient at the address specified by `addr` and outputs it on `data_out`.\n\n3. **No Write Capability:**  \n   This module is designed as a read-only memory block. Coefficient values are typically preloaded. It should be populated with a testbench.\n\n---\n\n\n## How to Use This Module in a Polyphase Filter (poly_filter) Design\n\nIn a polyphase filter design:\n- **Coefficient Arrangement:**  \n  Coefficients are usually organized into groups corresponding to the filter's phases and taps. For instance, if the polyphase filter has `N` phases and `TAPS` taps per phase, the total number of coefficients is `N * TAPS`.\n  \n- **Address Calculation:**  \n  The poly_filter computes an address to retrieve the proper coefficient for a given phase and tap index. For example, the address may be calculated as:\n  ```\n  addr = phase_reg * TAPS + tap_index\n  ```\n  \n- **Integration:**  \n  The poly_filter instantiates one or more `coeff_ram` modules (often within a generate loop) to supply coefficients for its multiply-accumulate operations. The coefficient retrieved from `coeff_ram` is then used to multiply against a sample from the shift register, contributing to the final filter output.", "docs/poly_decimator.md": "# Polyphase Decimator Module\n\nThe `poly_decimator` module takes an input sample stream and produces one decimated output sample every *M* input samples. Instead of generating multiple outputs per input sample (as in interpolation), the decimator collects a full window of samples, decomposes the FIR filtering operation into *M* polyphase branches, and then sums the branch outputs to generate a single filtered, decimated sample. Each branch computes a partial product using a subset of the input window, and an adder tree combines the branch results to form the final output.\n\n---\n\n## Parameters\n\n- **M**  \n  **Decimation factor.**  \n  Specifies that one output sample is generated for every *M* input samples.  \n  **Default Value:** 4\n\n- **TAPS**    \n  Defines the length of each FIR sub-filter that computes one partial dot\u2013product in every branch.  \n  **Default Value:** 8\n\n- **COEFF_WIDTH**\n  Width of the filter coefficients used in the multiplication with input samples.  \n  **Default Value:** 16\n\n- **DATA_WIDTH**   \n  Bit width of the input samples that are filtered.  \n  **Default Value:** 16\n\n- **ACC_WIDTH**    \n  The word width computed as:\n  \n  **ACC_WIDTH = DATA_WIDTH + COEFF_WIDTH + $clog2(TAPS)**\n\n- **TOTAL_TAPS**  \n  Total number of stored samples. \n  Defined as: **TOTAL_TAPS = M * TAPS**\n\n---\n\n## Interface\n\n| **Signal Name** | **Direction** | **Width / Type**             | **Description**                          |\n|-----------------|---------------|------------------------------|------------------------------------------|\n| `clk`           | Input         | 1                            | Clock signal.                            |\n| `arst_n`        | Input         | 1                            | Active-low asynchronous reset.           |\n| `in_sample`     | Input         | `DATA_WIDTH` bits            | The input sample stream to be decimated. |\n| `in_valid`      | Input         | 1                            | Indicates that `in_sample` is valid.     |\n| `in_ready`      | Output        | 1                            | Ready to accept a new input sample.      |\n| `out_sample`    | Output        | `ACC_WIDTH + $clog2(M)` bits | The decimated output sample.             |\n| `out_valid`     | Output        | 1                            | Indicates that `out_sample` is valid.    |\n\n\n---\n\n## Internal Operation\n\nThe polyphase decimator should operate in the following steps:\n\n1. **Input Storage:**  \n - An input shift register (of depth **TOTAL_TAPS = M * TAPS**) captures the most recent input samples.\n - As new samples are accepted (while `in_valid` and `in_ready` are high), the register shifts its contents.\n - A sample counter keeps track of the number of samples received. When the counter reaches *M* (indicating that a complete window has been collected), filtering is triggered.\n\n2. **Polyphase Filtering:**  \n - The shift register output is decomposed into *M* branches. Each branch extracts **TAPS** samples from the window using a stride of *M* (starting from a unique offset).\n - Each branch instantiates a `poly_filter` submodule. The branch's fixed phase (given by its index) is used to fetch the corresponding coefficients from coefficient RAM.\n - In each branch, the `poly_filter` multiplies its sample vector by the set of coefficients and computes a dot\u2013product, outputting a partial result along with a valid signal.\n\n3. **Result Summation and Output:**  \n - A reduction is performed to ensure that all the *M* branches have produced valid results.\n - An adder tree will collect the *M* branch outputs, summing them to form the final decimated output sample.\n - The final sample is registered and presented on the `out_sample` output, while `out_valid` is asserted to indicate its validity.\n - The FSM controlling the decimator will be operating in two primary states:\n   - **ACCUMULATE:** Continuously accepts input samples, incrementing the sample counter until *M* samples are collected.\n   - **OUTPUT:** Once a complete window is received and all branch outputs are valid, the filtered output is computed, and the decimated sample is released. The counter is reset afterwards.\n\n---\n\n## Submodule Integration\n\n### Shift Register\n\n- **Purpose:**  \nStores the most recent **TOTAL_TAPS** input samples so that each decimation window is complete.\n- **Integration:**  \nThe instance `u_shift_reg_decim` should be implemented as a standard shift register whose depth is parameterized by **TOTAL_TAPS**. It provides an array output (`shift_data`) and a corresponding valid signal (`shift_data_val`).\n\n### Polyphase Filter\n\n- **Purpose:**  \nEach `poly_filter` submodule instantiated performs filtering on one polyphase branch. It registers the branch's sample vector, fetches corresponding coefficients using a computed address (based on its phase), multiplies the samples by the coefficients, and sums the products.\n- **Integration:**  \nA generate block should be used to instantiate *M* branches, each with:\n- A dedicated sub-array (`branch_samples`) of **TAPS** samples extracted from the shift register.\n- A fixed phase number corresponding to its branch index (used to fetch the proper coefficient set).\n- An output (`branch_out`) and a valid flag (`branch_valid`).\n\n### Adder Tree\n\n- **Purpose:**  \nCombines the outputs from the *M* polyphase branches to produce a single decimated output sample.\n- **Integration:**  \nThe `adder_tree` module is shared across the design. It accepts the vector of branch outputs and performs a hierarchical sum (with the output width growing by `$clog2(M)` bits) to produce the final filtered result.\n\n", "docs/poly_filter.md": "# Polyphase Filter Module\n\nThe `poly_filter` module performs the multiply-accumulate (MAC) operations required in a polyphase filter structure. It takes as inputs:\n- A **sample buffer** (from a shift register) containing the history of input samples.\n- A **phase selection** signal that determines which group of filter coefficients to use.\n- A **valid_in** flag indicating that new input data is available.\n\nThe module operates in four main stages:\n\n1. **Stage 0: Input Registration**  \n   The incoming sample buffer and the phase signal are registered into internal registers (`sample_reg` and `phase_reg`). A valid flag (`valid_stage0`) is generated when the input data is valid.\n\n2. **Stage 1: Coefficient Fetch**  \n   For each tap, a coefficient is fetched from an instance of the **coeff_ram** module.\n\n3. **Stage 2: Multiplication**  \n   Each registered sample is multiplied by its corresponding coefficient to produce a set of products.\n\n4. **Stage 3: Summation**  \n   The products are summed using a pipelined **adder_tree** module. The output of the adder tree is a single sum representing the filtered result.\n\n5. **Stage 4: Output Registration**  \n   The final sum is registered and output along with a valid flag, indicating that the filter output is ready.\n\n---\n\n## Interface Table\n\n| Signal Name     | Direction | Width                                                 | Description                                                         |\n|-----------------|-----------|-------------------------------------------------------|---------------------------------------------------------------------|\n| `clk`           | Input     | 1                                                     | Clock signal                                                        |\n| `arst_n`        | Input     | 1                                                     | Active-low asynchronous reset                                       |\n| `sample_buffer` | Input     | Array of `TAPS` elements, each `DATA_WIDTH` bits wide | Input sample history, from a shift register                         |\n| `valid_in`      | Input     | 1                                                     | Valid flag for the sample_buffer.                                   |\n| `phase`         | Input     | `$clog2(N)` bits                                      | Phase selection signal used to choose the correct coefficient group |\n| `filter_out`    | Output    | `ACC_WIDTH`                                           | Final filter output                                                 |\n| `valid`         | Output    | 1                                                     | Valid flag indicating that the output on `filter_out`               |\n\n\n---\n\n## Submodule Integration\n\n### Coefficient RAM (coeff_ram)\n\n- **Purpose:**  \n  The **coeff_ram** module stores filter coefficients. In the poly_filter, a generate block named `coeff_fetch` instantiates one `coeff_ram` instance per tap.\n  \n- **Operation:**  \n  For each tap (index `j`), the coefficient RAM is accessed with an address computed as:\n  ```\n  addr = phase_reg * TAPS + j\n  ```\n  This fetches the coefficient corresponding to the current phase and tap.\n  \n- **Integration:**  \n  The output of each coefficient RAM instance is assigned to an array (`coeff[j]`), which is later used in the multiplication stage.\n\n### Adder Tree (adder_tree)\n\n- **Purpose:**  \n  The **adder_tree** module sums an array of products obtained from multiplying the registered samples and the fetched coefficients.\n  \n- **Operation:**  \n  The multiplication results are stored in the `products` array. The adder_tree uses a pipelined structure where the number of values is halved at each stage until a single summed value is produced.\n  \n- **Integration:**  \n  The adder_tree is instantiated with the parameters:\n  - `NUM_INPUTS = TAPS`\n  - `DATA_WIDTH = DATA_WIDTH + COEFF_WIDTH`\n  \n  Its output is assigned to the final filter result (`sum_result`), and a valid flag (`valid_adder`) indicates when the summed result is valid.\n\n---\n\n## Detailed Operation Flow\n\n1. **Stage 0 \u2013 Input Registration:**  \n   - Registers each element of `sample_buffer` into `sample_reg`.\n   - Registers the `phase` signal into `phase_reg`.\n   - Generates `valid_stage0` if `valid_in` is high.\n\n2. **Stage 1 \u2013 Coefficient Fetch:**  \n   - For each tap `j`, calculates the coefficient address: `addr = phase_reg * TAPS + j`.\n   - Instantiates `coeff_ram` to retrieve the coefficient at the computed address.\n   - Outputs are stored in the `coeff` array.\n\n3. **Stage 2 \u2013 Multiplication:**  \n   - For each tap `j`, multiplies `sample_reg[j]` with `coeff[j]` to obtain `products[j]`.\n\n4. **Stage 3 \u2013 Summation via Adder Tree:**  \n   - The `products` array is input to the adder_tree module.\n   - The adder_tree computes the sum of all products.\n   - The final sum is available at `sum_result` and is accompanied by a valid signal (`valid_adder`).\n\n5. **Stage 4 \u2013 Output Registration:**  \n   - The `sum_result` is registered and assigned to `filter_out`.\n   - The output valid flag `valid` is set based on `valid_adder`.", "docs/shift_register.md": "## Overview\n\nThe `shift_register` module captures a stream of data samples into an internal register array. When a new sample is loaded (when the `load` signal is asserted), the module inserts the new sample at the beginning of the register array (index 0) and shifts the previous samples down the chain. The module also provides a valid flag (`data_out_val`) that indicates when new data has been loaded into the register array.\n\n---\n\n## Parameters\n\n- **TAPS**   \n  **Description:** Specifies the number of storage elements (or \"taps\") in the shift register. \n  **Default Value:** 32\n\n- **DATA_WIDTH**  \n  **Description:** Specifies the bit width of each data sample stored in the shift register.  \n  **Default Value:** 16\n\n---\n\n## Interface\n\n### Interface Table\n\n| Signal Name    | Direction | Width                                   | Description                                                                                                              |\n|----------------|-----------|-----------------------------------------|--------------------------------------------------------------------------------------------------------------------------|\n| `clk`          | Input     | 1                                       | Clock signal. The module updates its registers on the rising edge of this clock.                                         |\n| `arst_n`       | Input     | 1                                       | Active-low asynchronous reset. When low, all stored samples are reset to 0.                                              |\n| `load`         | Input     | 1                                       | Load enable signal. When high, the module loads a new sample and shifts the existing data.                               |\n| `new_sample`   | Input     | `DATA_WIDTH` bits                       | The new data sample to be inserted into the shift register at index 0 when `load` is asserted.                           |\n| `data_out`     | Output    | Array of `DATA_WIDTH` bits, size `TAPS` | Current content of the shift register; `data_out[0]` is the most recent sample, `data_out[TAPS-1]` is the oldest sample. |\n| `data_out_val` | Output    | 1                                       | Valid flag that is asserted for one clock cycle when new data is loaded into the shift register.                         |\n\n\n---\n\n## Internal Operation\n\n1. **Asynchronous Reset:**  \n   - When `arst_n` is deasserted (set to 0), all internal register elements are reset to 0 and the valid flag (`data_out_val`) is cleared.\n\n2. **Loading a New Sample:**  \n   - On the rising edge of the `clk`, if the `load` signal is asserted:\n     - The new sample from `new_sample` is loaded into the first register (`reg_array[0]`).\n     - All previous samples in the register array are shifted down by one index.\n     - The valid flag (`data_out_val`) is set to `1` for one clock cycle to indicate that new data is available.\n  \n3. **No Load Condition:**  \n   - When `load` is not asserted, the internal registers retain their current values, and the valid flag remains at 0.\n\n4. **Output Assignment:**  \n   - The internal register array (`reg_array`) is continuously assigned to the output array (`data_out`), so the latest sample history is always available at the module outputs.", "rtl/adder_tree.sv": "module adder_tree #(\n  parameter NUM_INPUTS = 8,\n  parameter DATA_WIDTH = 32\n)\n(\n  input  logic                                     clk,\n  input  logic                                     arst_n,\n  input  logic                                     valid_in,\n  input  logic [DATA_WIDTH-1:0]                    data_in [NUM_INPUTS],\n  output logic [DATA_WIDTH+$clog2(NUM_INPUTS)-1:0] sum_out,\n  output logic                                     valid_out\n);\n\n  // Calculate the number of pipeline stages:\n  localparam NUM_STAGES = $clog2(NUM_INPUTS);\n\n  // Pipeline registers for data and valid signals.\n  logic [DATA_WIDTH+$clog2(NUM_INPUTS)-1:0] stage_reg [0:NUM_STAGES][0:NUM_INPUTS-1];\n  logic valid_stage [0:NUM_STAGES];\n  integer i, s, j;\n\n  // Stage 0: Register the input data.\n  always_ff @(posedge clk or negedge arst_n) begin\n    if (!arst_n) begin\n      for (i = 0; i < NUM_INPUTS; i = i + 1)\n        stage_reg[0][i] <= '0;\n      valid_stage[0] <= 1'b0;\n    end\n    else if (valid_in) begin\n      for (i = 0; i < NUM_INPUTS; i = i + 1)\n        // Sign extend if needed.\n        stage_reg[0][i] <= {{($clog2(NUM_INPUTS)){data_in[i][DATA_WIDTH-1]}}, data_in[i]};\n      valid_stage[0] <= 1'b1;\n    end \n    else begin\n      valid_stage[0] <= 1'b0;\n    end\n  end\n\n  // Subsequent stages: each stage halves the number of values.\n  generate\n    for (genvar s = 1; s <= NUM_STAGES; s = s + 1) begin : stage_pipeline\n      localparam int NUM_ELEMS = NUM_INPUTS >> s;\n      always_ff @(posedge clk or negedge arst_n) begin\n        if (!arst_n) begin\n          for (j = 0; j < NUM_ELEMS; j = j + 1)\n            stage_reg[s][j] <= '0;\n          valid_stage[s] <= 1'b0;\n        end\n        else if (valid_stage[s-1]) begin\n          for (j = 0; j < NUM_ELEMS; j = j + 1)\n            stage_reg[s][j] <= stage_reg[s-1][2*j] + stage_reg[s-1][2*j+1];\n          valid_stage[s] <= 1'b1;\n        end\n        else begin\n          valid_stage[s] <= 1'b0;\n        end\n      end\n    end\n  endgenerate\n\n  assign sum_out  = stage_reg[NUM_STAGES][0];\n  assign valid_out = valid_stage[NUM_STAGES];\n\nendmodule", "rtl/coeff_ram.sv": "module coeff_ram #(\n  parameter NUM_COEFFS  = 32,\n  parameter DATA_WIDTH  = 16\n)\n(\n  input  logic                          clk,\n  input  logic [$clog2(NUM_COEFFS)-1:0] addr,\n  output logic [DATA_WIDTH-1:0]         data_out\n);\n\n  // Memory array for coefficients.\n  logic [DATA_WIDTH-1:0] mem [0:NUM_COEFFS-1];\n  integer i;\n\n  // Synchronous read.\n  always_ff @(posedge clk) begin\n    data_out <= mem[addr];\n  end\n\nendmodule", "rtl/poly_filter.sv": "module poly_filter #(\n  parameter  M           = 4,    // decimation factor\n  parameter  TAPS        = 8,    // Taps per phase\n  parameter  COEFF_WIDTH = 16,   // Coefficient bit width\n  parameter  DATA_WIDTH  = 16,   // Sample data bit width\n  localparam ACC_WIDTH   = DATA_WIDTH + COEFF_WIDTH + $clog2(TAPS)\n)\n(\n  input  logic                         clk,\n  input  logic                         arst_n,\n  input  logic [DATA_WIDTH-1:0]        sample_buffer [0:TAPS-1],\n  input  logic                         valid_in,\n  // The branch's phase number\n  input  logic [$clog2(M)-1:0]         phase,\n  output logic [ACC_WIDTH-1:0]         filter_out,\n  output logic                         valid\n);\n\n  // ---- Stage 0: Register the input sample vector and phase. ----\n  logic [DATA_WIDTH-1:0] sample_reg [0:TAPS-1];\n  logic [$clog2(M)-1:0]  phase_reg;\n  logic                  valid_stage0;\n  integer i;\n  always_ff @(posedge clk or negedge arst_n) begin\n    if (!arst_n) begin\n      for (i = 0; i < TAPS; i = i + 1)\n        sample_reg[i] <= '0;\n      phase_reg    <= '0;\n      valid_stage0 <= 1'b0;\n    end\n    else begin\n      if (valid_in) begin\n        for (i = 0; i < TAPS; i = i + 1)\n          sample_reg[i] <= sample_buffer[i];\n        phase_reg    <= phase;\n        valid_stage0 <= 1'b1;\n      end\n      else begin\n        valid_stage0 <= 1'b0;\n      end\n    end\n  end\n\n  // ---- Stage 1: Coefficient Fetch ----\n  logic [COEFF_WIDTH-1:0] coeff [0:TAPS-1];\n  genvar j;\n  generate\n    for (j = 0; j < TAPS; j = j + 1) begin : coeff_fetch\n      logic [$clog2(M*TAPS)-1:0] addr;\n      assign addr = phase_reg * TAPS + j;\n      coeff_ram #(\n        .NUM_COEFFS(M*TAPS),\n        .DATA_WIDTH(COEFF_WIDTH)\n      ) u_coeff_ram (\n        .clk     (clk),\n        .addr    (addr),\n        .data_out(coeff[j])\n      );\n    end\n  endgenerate\n\n  logic valid_stage1;\n  always_ff @(posedge clk or negedge arst_n) begin\n    if (!arst_n)\n      valid_stage1 <= 1'b0;\n    else\n      valid_stage1 <= valid_stage0;\n  end\n\n  // ---- Stage 2: Multiply the registered samples with coefficients ----\n  logic [DATA_WIDTH+COEFF_WIDTH-1:0] products [0:TAPS-1];\n  integer k;\n  always_comb begin\n    for (k = 0; k < TAPS; k = k + 1)\n      products[k] = sample_reg[k] * coeff[k];\n  end\n\n  // ---- Stage 3: Sum the products using the adder_tree ----\n  logic [ACC_WIDTH-1:0] sum_result;\n  logic                 valid_adder;\n  adder_tree #(\n    .NUM_INPUTS(TAPS),\n    .DATA_WIDTH(DATA_WIDTH+COEFF_WIDTH)\n  ) u_adder_tree_filter (\n    .clk      (clk),\n    .arst_n   (arst_n),\n    .valid_in (valid_stage1),\n    .data_in  (products),\n    .sum_out  (sum_result),\n    .valid_out(valid_adder)\n  );\n\n  // ---- Stage 4: Output Registration ----\n  always_ff @(posedge clk or negedge arst_n) begin\n    if (!arst_n) begin\n      filter_out <= '0;\n      valid      <= 1'b0;\n    end\n    else begin\n      filter_out <= sum_result;\n      valid      <= valid_adder;\n    end\n  end\n\nendmodule", "rtl/shift_register.sv": "module shift_register #(\n  parameter TAPS  = 32,   // TOTAL_TAPS = N * TAPS\n  parameter DATA_WIDTH  = 16\n)\n(\n  input  logic                  clk,\n  input  logic                  arst_n,\n  input  logic                  load,         // Asserted when a new sample is to be shifted in\n  input  logic [DATA_WIDTH-1:0] new_sample,\n  output logic [DATA_WIDTH-1:0] data_out [0:TAPS-1],\n  output logic                  data_out_val  // Indicates that data_out is updated.\n);\n\n  // Internal register array for storing samples.\n  logic [DATA_WIDTH-1:0] reg_array [0:TAPS-1];\n  integer i;\n\n  always_ff @(posedge clk or negedge arst_n) begin\n    if (!arst_n) begin\n      for (i = 0; i < TAPS; i = i + 1)\n        reg_array[i] <= '0;\n      data_out_val <= 1'b0;\n    end\n    else if (load) begin\n      reg_array[0] <= new_sample;\n      for (i = TAPS-1; i > 0; i = i - 1)\n        reg_array[i] <= reg_array[i-1];\n      data_out_val <= 1'b1;\n    end\n    else begin\n      data_out_val <= 1'b0;\n    end\n  end\n\n  // Continuous assignment of the stored register values to the outputs.\n  generate\n    for (genvar j = 0; j < TAPS; j = j + 1) begin : assign_output\n      assign data_out[j] = reg_array[j];\n    end\n  endgenerate\n\nendmodule"}, "patch": {"rtl/poly_decimator.sv": ""}, "harness": {"docker-compose.yml": "services:\n  test_poly_decimator:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/test_poly_decimator/.env\n    command     : pytest --log-cli-level=INFO -o cache_dir=/code/rundir/.cache /src/test_poly_decimator/test_runner.py -v -s", "src/test_poly_decimator/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/adder_tree.sv /code/rtl/coeff_ram.sv /code/rtl/shift_register.sv /code/rtl/poly_filter.sv /code/rtl/poly_decimator.sv\nTOPLEVEL        = poly_decimator\nMODULE          = test_poly_decimator\nWAVE            = True\nPYTHONPATH      = /src\nHASH            = 1-rtl-modules-integration-for-polyphase-decimation\n", "src/test_poly_decimator/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n\n", "src/test_poly_decimator/test_poly_decimator.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ClockCycles, Timer\nimport harness_library as hrs_lb\nimport random\nimport time\nfrom cocotb.triggers import with_timeout\nimport cocotb.simulator\n\n\ncocotb.simulator.dump_enabled = True\n\n#----------------------------------------------------------------------------\n# Utility Task\n#----------------------------------------------------------------------------\nasync def populate_coeff_ram(dut, coeff_list):\n    \"\"\"\n    Populate all coefficient RAMs\n    \"\"\"\n    await Timer(1, units='ns')\n    tap_count = int(dut.poly_branches[0].u_poly_filter.TAPS.value)\n    phase_count = int(dut.M.value)\n    total_coeffs = tap_count * phase_count\n    dut._log.info(f\"Populating coefficient RAMs (decimator): tap_count = {tap_count}, phase_count = {phase_count}, total_coeffs = {total_coeffs}\")\n\n    assert len(coeff_list) == total_coeffs, (\n        f\"Coefficient list length {len(coeff_list)} does not match expected {total_coeffs}\"\n    )\n\n    for p in range(phase_count):\n        for j in range(tap_count):\n            addr = p * tap_count + j\n            coeff_value = coeff_list[addr]\n            try:\n                dut.poly_branches[p].u_poly_filter.coeff_fetch[j].u_coeff_ram.mem[addr].value = coeff_value\n                dut._log.info(f\"Set coefficient for phase {p}, tap {j} (addr {addr}) to {coeff_value}\")\n            except Exception as e:\n                dut._log.error(f\"Failed to set coefficient for phase {p}, tap {j} (addr {addr}): {e}\")\n    await Timer(1, units='ns')\n\n# Test 1: One Sample Decimation\n\n@cocotb.test()\nasync def test_one_sample_decimation(dut):\n    \"\"\"\n    Test that after feeding M input samples, one decimated output is generated.\n    \"\"\"\n    # Start clock.\n    cocotb.start_soon(Clock(dut.clk, 5, units=\"ns\").start())\n    await hrs_lb.dut_init(dut)\n\n    # Apply reset.\n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n    dut._log.info(\"Starting test_one_sample_decimation\")\n\n    # For decimation with M=2, TAPS=2, total coefficients = 4.\n    coeffs = [1, 2, 3, 4]\n    await populate_coeff_ram(dut, coeffs)\n\n    # Apply two input samples.\n    X1 = 10\n    X2 = 20\n\n    # First sample\n    await RisingEdge(dut.clk)\n    dut.in_sample.value = X1\n    dut.in_valid.value = 1\n    await RisingEdge(dut.clk)\n    dut.in_valid.value = 0\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    while not int(dut.in_ready.value):\n        await RisingEdge(dut.clk)\n\n    # Second sample\n    dut.in_sample.value = X2\n    dut.in_valid.value = 1\n    await RisingEdge(dut.clk)\n    dut.in_valid.value = 0\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    while not int(dut.in_ready.value):\n        await RisingEdge(dut.clk)\n\n    # Capture decimated output.\n    outputs = []\n    timeout_cycles = 50\n    cycle = 0\n    while len(outputs) < 1 and cycle < timeout_cycles:\n        await RisingEdge(dut.clk)\n        if int(dut.out_valid.value) == 1:\n            outputs.append(int(dut.out_sample.value))\n            dut._log.info(f\"Captured decimated output: {int(dut.out_sample.value)}\")\n        cycle += 1\n\n    expected = [50]\n    assert outputs == expected, f\"test_one_sample_decimation failed: expected {expected}, got {outputs}\"\n    dut._log.info(\"test_one_sample_decimation passed.\")\n\n\n\n# Test 2: Back-to-Back Samples Decimation\n@cocotb.test()\nasync def test_back_to_back_samples_decimation(dut):\n    \"\"\"\n    Test that two back-to-back decimation events produce consecutive outputs.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 5, units=\"ns\").start())\n    await hrs_lb.dut_init(dut)\n\n    dut._log.info(\"Starting test_back_to_back_samples_decimation\")\n    coeffs = [1, 2, 3, 4]\n    await populate_coeff_ram(dut, coeffs)\n\n    # Apply reset.\n    dut.arst_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n\n    # First decimation event: feed X1 and X2.\n    X1 = 10\n    X2 = 20\n\n    while not int(dut.in_ready.value):\n        await RisingEdge(dut.clk)\n    dut.in_sample.value = X1\n    dut.in_valid.value = 1\n    await RisingEdge(dut.clk)\n    dut.in_valid.value = 0\n\n    while not int(dut.in_ready.value):\n        await RisingEdge(dut.clk)\n    dut.in_sample.value = X2\n    dut.in_valid.value = 1\n    await RisingEdge(dut.clk)\n    dut.in_valid.value = 0\n\n    outputs1 = []\n    timeout_cycles = 50\n    cycle = 0\n    while len(outputs1) < 1 and cycle < timeout_cycles:\n        await RisingEdge(dut.clk)\n        if int(dut.out_valid.value) == 1:\n            outputs1.append(int(dut.out_sample.value))\n            dut._log.info(f\"Captured first decimated output: {int(dut.out_sample.value)}\")\n        cycle += 1\n\n    expected1 = [50]\n\n    # Second decimation feed X3 and X4.\n    X3 = 30\n    X4 = 40\n\n    while not int(dut.in_ready.value):\n        await RisingEdge(dut.clk)\n    dut.in_sample.value = X3\n    dut.in_valid.value = 1\n    await RisingEdge(dut.clk)\n    dut.in_valid.value = 0\n\n    while not int(dut.in_ready.value):\n        await RisingEdge(dut.clk)\n    dut.in_sample.value = X4\n    dut.in_valid.value = 1\n    await RisingEdge(dut.clk)\n    dut.in_valid.value = 0\n\n    outputs2 = []\n    cycle = 0\n    while len(outputs2) < 1 and cycle < timeout_cycles:\n        await RisingEdge(dut.clk)\n        if int(dut.out_valid.value) == 1:\n            outputs2.append(int(dut.out_sample.value))\n            dut._log.info(f\"Captured second decimated output: {int(dut.out_sample.value)}\")\n        cycle += 1\n\n    expected2 = [210]\n\n    assert outputs1 == expected1, f\"First decimation event failed: expected {expected1}, got {outputs1}\"\n    assert outputs2 == expected2, f\"Second decimation event failed: expected {expected2}, got {outputs2}\"\n    dut._log.info(\"test_back_to_back_samples_decimation passed.\")\n\n\n\n# Test 3: Edge Cases Decimation\n@cocotb.test()\nasync def test_edge_cases_decimation(dut):\n    \"\"\"\n    Test decimation with edge-case inputs.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 5, units=\"ns\").start())\n    await hrs_lb.dut_init(dut)\n\n    dut._log.info(\"Starting test_edge_cases_decimation\")\n    coeffs = [1, 2, 3, 4]\n    await populate_coeff_ram(dut, coeffs)\n\n    # Apply reset.\n    dut.arst_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n\n    # Edge case 1\n    X = 0\n    for _ in range(2):\n        while not int(dut.in_ready.value):\n            await RisingEdge(dut.clk)\n        dut.in_sample.value = X\n        dut.in_valid.value = 1\n        await RisingEdge(dut.clk)\n        dut.in_valid.value = 0\n\n    outputs = []\n    timeout_cycles = 50\n    cycle = 0\n    while len(outputs) < 1 and cycle < timeout_cycles:\n        await RisingEdge(dut.clk)\n        if int(dut.out_valid.value) == 1:\n            outputs.append(int(dut.out_sample.value))\n            dut._log.info(f\"Captured output for 0 input: {int(dut.out_sample.value)}\")\n        cycle += 1\n\n    expected = [0]\n    assert outputs == expected, f\"Edge-case (0) failed: expected {expected}, got {outputs}\"\n\n    # Edge case 2\n    X = 32767\n    for _ in range(2):\n        while not int(dut.in_ready.value):\n            await RisingEdge(dut.clk)\n        dut.in_sample.value = X\n        dut.in_valid.value = 1\n        await RisingEdge(dut.clk)\n        dut.in_valid.value = 0\n\n    outputs = []\n    cycle = 0\n    while len(outputs) < 1 and cycle < timeout_cycles:\n        await RisingEdge(dut.clk)\n        if int(dut.out_valid.value) == 1:\n            outputs.append(int(dut.out_sample.value))\n            dut._log.info(f\"Captured output for 32767 input: {int(dut.out_sample.value)}\")\n        cycle += 1\n\n    expected = [131068]\n    assert outputs == expected, f\"Edge-case (32767) failed: expected {expected}, got {outputs}\"\n    dut._log.info(\"test_edge_cases_decimation passed.\")\n\n\n@cocotb.test()\nasync def test_random_samples_decimation(dut):\n    \"\"\"\n    Test decimation with random input samples.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 5, units=\"ns\").start())\n    await hrs_lb.dut_init(dut)\n    dut._log.info(\"Starting test_random_samples_decimation (decimator)\")\n\n    # Apply reset.\n    dut.arst_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n\n    # Read parameters.\n    tap_count = int(dut.poly_branches[0].u_poly_filter.TAPS.value)\n    M_val     = int(dut.M.value)\n    total_taps = M_val * tap_count\n    dut._log.info(f\"Detected parameters: M = {M_val}, TAPS = {tap_count}, TOTAL_TAPS = {total_taps}\")\n\n    coeffs = [i + 1 for i in range(total_taps)]\n    await populate_coeff_ram(dut, coeffs)\n\n    num_samples = 10\n    random.seed(12345)\n    random_inputs = [random.randint(0, 100) for _ in range(num_samples)]\n    dut._log.info(f\"Random input samples: {random_inputs}\")\n\n    shift_reg = [0] * total_taps\n    all_expected = []\n    captured_outputs = []\n\n    for k, sample in enumerate(random_inputs):\n        shift_reg = [sample] + shift_reg[:-1]\n        \n        await RisingEdge(dut.clk)\n        while not int(dut.in_ready.value):\n            await RisingEdge(dut.clk)\n        dut.in_sample.value = sample\n        dut.in_valid.value  = 1\n        await RisingEdge(dut.clk)\n        dut.in_valid.value  = 0\n        await RisingEdge(dut.clk)\n\n        if ((k + 1) % M_val) == 0:\n            branch0 = shift_reg[0] * coeffs[0] + shift_reg[2] * coeffs[1]\n            branch1 = shift_reg[1] * coeffs[2] + shift_reg[3] * coeffs[3]\n            expected_val = branch0 + branch1\n            all_expected.append(expected_val)\n            dut._log.info(f\"After sample index {k} (sample={sample}), modeled shift_reg = {shift_reg}, \"\n                          f\"expected decimated output = {expected_val}\")\n\n            # Capture the produced decimated output.\n            captured = []\n            timeout_cycles = 50\n            cycle = 0\n            while len(captured) < 1 and cycle < timeout_cycles:\n                await RisingEdge(dut.clk)\n                if int(dut.out_valid.value) == 1:\n                    captured.append(int(dut.out_sample.value))\n                    dut._log.info(f\"Captured decimated output after sample index {k}: {int(dut.out_sample.value)}\")\n                cycle += 1\n            assert len(captured) >= 1, f\"Timeout waiting for decimated output after sample index {k}\"\n            captured_outputs.append(captured[0])\n            assert captured[0] == expected_val, \\\n                f\"Decimation failed at sample index {k}: expected {expected_val}, got {captured[0]}\"\n\n    dut._log.info(f\"test_random_samples_decimation passed. Expected outputs: {all_expected}, \"\n                  f\"Captured outputs: {captured_outputs}\")\n", "src/test_poly_decimator/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(plusargs=[], parameter={}):\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=1,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=1,plusargs=plusargs)\n\n@pytest.mark.parametrize(\"M\", [2])\n@pytest.mark.parametrize(\"TAPS\", [2])\n@pytest.mark.parametrize(\"COEFF_WIDTH\", [16])\n@pytest.mark.parametrize(\"DATA_WIDTH\", [16])\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_poly_decimator(M, TAPS, COEFF_WIDTH, DATA_WIDTH, test):\n    runner(parameter={\"M\": M, \"TAPS\": TAPS, \"COEFF_WIDTH\": COEFF_WIDTH, \"DATA_WIDTH\": DATA_WIDTH})\n", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest --log-cli-level=INFO -o cache_dir=/code/rundir/.cache /src/test_poly_decimator/test_runner.py -v -s'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_prbs_0001", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a **prbs_gen_check** module that generates or checks  pseudo-random bit sequence (PRBS) data,\n\nThe **prbs_gen_check** module is available at `/rtl/prbs_gen_check.sv` and its' specification in the `/docs` directory. Can you implement the **`scrambler_descrambler.sv`** in the `/rtl` folder? Details of the `scrambler_descrambler` module is as given below\n\n### Purpose\nThe **`scrambler_descrambler`** module should perform a simple data scrambling or descrambling function using a pseudo-random bit sequence (PRBS). It should instantiate the `prbs_gen_check` module to generate the random sequence used for XOR-based scrambling/descrambling. Scrambling involves XORing data with a pseudo-random bit sequence to randomize its pattern. Descrambling uses the same pseudo-random sequence to restore the original data from the scrambled stream.\n\n- It should support a parameterizable data bus width (`WIDTH`).  \n- It should rely on a specific polynomial length (`POLY_LENGTH`) and tap (`POLY_TAP`) for the underlying PRBS generation.  \n- Following features should be added:\n   - Add the input bypass_scrambling. When asserted the input data should be sent unmodified to data_out with a latency of 1 clock cycle.\n   - Add parameter CHECK_MODE. When 0, operate normally as a scrambler or a descrambler. When 1, check if the incoming data is a PRBS pattern or not.\n   - Add output bit_count. This will be used to check the throughput of the module and should be equal to the total valid data bits sent out from this module.\n- Latency considerations: This module should have the following latencies for the cases given:\n   - bypass_scrambling asserted: 1 clk latency\n   - bypass_scrambling deasserted and CHECK_MODE=0 (perform scrambling or descrambling): 1 clk latency.\n   - bypass_scrambling deasserted and CHECK_MODE=1 (perform data_in checking for PRBS): 2 clk latency.\n\n## Interface Definition\n\n\n| **Parameter**   | **Type** | **Default** | **Description**                                                 |\n|-----------------|----------|-------------|-----------------------------------------------------------------|\n| `POLY_LENGTH`   | int      | 31          | Length of the LFSR in the PRBS generator/checker.               |\n| `POLY_TAP`      | int      | 3           | Tap position(s) in the LFSR polynomial for feedback.            |\n| `WIDTH`         | int      | 16          | Data width (in bits) for `data_in` and `data_out`.              |\n| `CHECK_MODE`    | bit      | 0           | 0 => Generator mode (scrambler), 1 => Checker mode (PRBS check).|\n\n| **Port Name**         | **I/O** | **Width**           | **Description**                                                                                 |\n|-----------------------|---------|---------------------|-------------------------------------------------------------------------------------------------|\n| `clk`                 | Input   | 1                   | Primary clock input. Rising edge triggered.                                                     |\n| `rst`                 | Input   | 1                   | Active-high synchronous reset.                                                                  |\n| `bypass_scrambling`   | Input   | 1                   | 1 => pass data directly from `data_in` to `data_out`. 0 => normal scrambler/descrambler path.   |\n| `data_in`             | Input   | `WIDTH` bits        | Data word input for scrambling, descrambling, or checking.                                      |\n| `valid_in`            | Input   | 1                   | Indicates `data_in` is valid on the current cycle. Active-high.                                 |\n| `data_out`            | Output  | `WIDTH` bits        | Scrambled/descrambled (or pass-through) data.                                                   |\n| `valid_out`           | Output  | 1                   | Indicates `data_out` is valid on the current cycle. Active-high.                                |\n| `bit_count`           | Output  | 32 bits             | Total number of valid bits processed (increments by `WIDTH` every time `valid_in`=1).           |\n", "context": {"docs/prbs_specification.md": "# RTL Specification\n\n## 1. Overview\n\n### 1.1 Purpose\nThe **`prbs_gen_check`** module operates in two modes:\n- **Generation Mode**: Outputs a pseudo-random bit sequence (PRBS).\n- **Checker Mode**: Checks incoming data against an internal PRBS reference and flags mismatches.\n\n### 1.2 Scope\n- Supports a configurable data path width (`WIDTH`).\n- Uses a linear feedback shift register (LFSR) defined by polynomial length (`POLY_LENGTH`) and tap location (`POLY_TAP`).\n- Synchronous design with an active-high reset.\n\n---\n\n## 2. Functional Description\n\n### 2.1 Generation Mode (`CHECK_MODE=0`)\n1. On reset, the internal PRBS register (`prbs_reg`) is initialized (commonly to all 1\u2019s).  \n2. Each clock cycle, the LFSR shifts based on its feedback polynomial, producing the next pseudo-random word on `data_out`.\n\n### 2.2 Checker Mode (`CHECK_MODE=1`)\n1. On reset, `prbs_reg` is similarly initialized.  \n2. Each clock cycle, the module generates the \u201cexpected\u201d PRBS bit(s). It then compares each bit of the incoming data (`data_in`) to the internal PRBS reference.  \n3. The output `data_out` is set to `1` on any bit that mismatches, and `0` otherwise.\n\n### 2.3 Reset Behavior\n- `rst` is synchronous, active high.\n- On reset, `prbs_reg` is re-initialized, and the output may be driven to all 1\u2019s until the reset is released.\n\n---\n\n## 3. Interface Definition\n\n| **Port Name** | **I/O** | **Width**   | **Description**                                                                                  |\n|---------------|---------|-------------|--------------------------------------------------------------------------------------------------|\n| `clk`         | In      | 1           | Synchronous clock input.                                                                         |\n| `rst`         | In      | 1           | Synchronous reset, active high.                                                                  |\n| `data_in`     | In      | `WIDTH`     | In checker mode: Data to compare with the PRBS reference. In generator mode: tied to 0.          |\n| `data_out`    | Out     | `WIDTH`     | In generator mode: PRBS output. In checker mode: Bitwise error flags (`1` = mismatch).           |\n\n### 3.1 Parameters\n\n| **Parameter**   | **Type** | **Default** | **Description**                                                                             |\n|-----------------|----------|-------------|---------------------------------------------------------------------------------------------|\n| `CHECK_MODE`    | int      | `0`         | - `0`: Generation Mode <br/> - `1`: Checker Mode                                            |\n| `POLY_LENGTH`   | int      | `31`        | Number of shift register stages in the LFSR.                                                |\n| `POLY_TAP`      | int      | `3`         | Defines which bit(s) is XORed with the final stage for feedback.                            |\n| `WIDTH`         | int      | `16`        | Data path width.                                                                            |\n\n\n---\n\n## 4. Internal Architecture\n\n### 4.1 LFSR\n- A shift register (LFSR) generates the pseudo-random sequence.\n- Feedback is formed by XORing selected bits (defined by `POLY_TAP` and the MSB).\n\n### 4.2 Register Update\n- On each rising clock edge:\n  - If `rst` is asserted, the LFSR is re-initialized.\n  - Otherwise, it shifts in the new feedback bit each cycle.\n\n### 4.3 Output Behavior\n- **Generator Mode**: `data_out` is the new PRBS word each cycle.  \n- **Checker Mode**: `data_out` is the bitwise difference between the incoming data and the expected PRBS sequence.", "rtl/prbs_gen_check.sv": "/**************************************************************************\nFILENAME:    prbs_gen_check.sv\nDESCRIPTION: This module generates or checks a PRBS pattern.\n**************************************************************************/\n\nmodule prbs_gen_check #(\n   parameter CHECK_MODE  = 0,              // 0: uses LFSR structure to generate a PRBS pattern, 1: the incoming data is loaded into prbs registers and compared with locally generated PRBS pattern.\n   parameter POLY_LENGTH = 31,             // length of the polynomial.(number of shift register stages)\n   parameter POLY_TAP    = 3,              // Intermedite stage that is xored with the last stage to generate the next prbs bit.\n   parameter WIDTH       = 16              // Bus size of data_in and data_out.\n   )(\n   input                         clk     , // clock input\n   input                         rst     , // synchronous reset, active high\n   input         [WIDTH-1:0]     data_in , // input data to be checked(checker mode), tied to 0 (generator mode)\n   output logic  [WIDTH-1:0]     data_out  // generated prbs pattern (generator mode), error found (checker mode).\n);\n\nlogic [1:POLY_LENGTH] prbs [WIDTH:0];\nlogic [WIDTH-1:0]     prbs_xor_a;\nlogic [WIDTH-1:0]     prbs_xor_b;\nlogic [WIDTH:1]       prbs_msb;\nlogic [1:POLY_LENGTH] prbs_reg = {(POLY_LENGTH){1'b1}};\n\nassign prbs[0]   = prbs_reg;\n\ngenvar i;\ngenerate for(i=0; i<WIDTH; i=i+1) begin\n   assign prbs_xor_a[i] = prbs[i][POLY_TAP] ^ prbs[i][POLY_LENGTH];\n   assign prbs_xor_b[i] = prbs_xor_a[i] ^ data_in[i];\n   assign prbs_msb[i+1] = (CHECK_MODE==0) ? prbs_xor_a[i] : data_in[i];\n   assign prbs[i+1]     = {prbs_msb[i+1],prbs[i][1:POLY_LENGTH-1]};\nend\nendgenerate\n\nalways_ff @ (posedge clk) begin\n   if(rst) begin\n      prbs_reg <= {POLY_LENGTH{1'b1}};\n      data_out <= {WIDTH{1'b1}};\n   end else begin\n      prbs_reg <= prbs[WIDTH];\n      data_out <= prbs_xor_b;   \n   end\nend\n  \nendmodule"}, "patch": {"rtl/scrambler_descrambler.sv": ""}, "harness": {"docker-compose.yml": "services:\n  \n direct:\n    image: hdlc/sim:osvb\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command: pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/prbs_gen_check.sv /code/rtl/scrambler_descrambler.sv\nTOPLEVEL        = scrambler_descrambler\nMODULE          = test_scrambler_descrambler\nPYTHONPATH      = /src\nHASH            = 1-component-integration-scramblerdescrambler", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner(WIDTH: int=4,CHECK_MODE: int=0,POLY_LENGTH:int=31,POLY_TAP: int=3):\n    \n    parameter = {\"WIDTH\":WIDTH, \"CHECK_MODE\":CHECK_MODE, \"POLY_LENGTH\":POLY_LENGTH, \"POLY_TAP\":POLY_TAP}\n    # Debug information\n    print(f\"[DEBUG] Running simulation with WIDTH={WIDTH}, CHECK_MODE={CHECK_MODE}, POLY_LENGTH={POLY_LENGTH}, POLY_TAP={POLY_TAP}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        parameters=parameter,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Parametrize test for different WIDTH,CHECK_MODE,POLY_LENGTH,POLY_TAP\n@pytest.mark.parametrize(\"WIDTH\", [4,5,8,12])\n@pytest.mark.parametrize(\"CHECK_MODE\", [0,1])\n@pytest.mark.parametrize(\"POLY_LENGTH\", [7,23,31])\n@pytest.mark.parametrize(\"POLY_TAP\", [1,3,5])\n\ndef test_sort(WIDTH,CHECK_MODE,POLY_LENGTH,POLY_TAP):\n    # Run the simulation with specified parameters\n    test_runner(WIDTH=WIDTH,CHECK_MODE=CHECK_MODE,POLY_LENGTH=POLY_LENGTH,POLY_TAP=POLY_TAP)\n", "src/test_scrambler_descrambler.py": "###############################################################################\n# test_scrambler_descrambler.py\n###############################################################################\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, ClockCycles\n\nimport random\nimport os\n\nasync def reset_dut(dut, cycles=2):\n    \"\"\"Helper routine to reset the DUT for a specified number of clock cycles.\"\"\"\n    dut.rst.value = 1\n    dut.data_in.value = 0\n    dut.valid_in.value = 0\n    dut.bypass_scrambling.value = 0\n    await RisingEdge(dut.clk)\n    for _ in range(cycles):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n# Helper function to generate expected PRBS sequence\ndef generate_prbs(seed, poly_length, poly_tap, width, num_cycles):\n    prbs_reg = [int(x) for x in f'{seed:0{poly_length}b}']\n    prbs_out = []\n\n    for _ in range(num_cycles):\n        prbs_xor_a = []\n        prbs = [prbs_reg]  # Initialize prbs[0] with the current PRBS register\n\n        # Loop through each bit of the output width\n        for i in range(width):\n            # Perform XOR operation between specified tap and last stage of PRBS\n            xor_a = prbs[i][poly_tap - 1] ^ prbs[i][poly_length - 1]\n            prbs_xor_a.append(xor_a)\n\n            # Shift the LFSR and insert the new XOR result to generate next state\n            prbs_next = [xor_a] + prbs[i][0:poly_length - 1]\n            prbs.append(prbs_next)\n\n        # Collect the XOR result as the output for this cycle\n        prbs_out.append(int(''.join(map(str, prbs_xor_a[::-1])), 2))\n\n        # Update the PRBS register with the last stage (prbs[width])\n        prbs_reg = prbs[width]\n\n    return prbs_out\n\n@cocotb.test()\nasync def test_scrambler_descrambler_sequential(dut):\n    \"\"\"\n    Perform a single-run test of the scrambler_descrambler module in two phases:\n      1) Scrambler Phase:\n         - Reset the module\n         - Feed incremental data (0, 1, 2, ...)\n         - Capture the scrambled output\n      2) Descrambler Phase:\n         - Reset the same module again (re-initializing the PRBS)\n         - Feed the previously captured scrambled data\n         - The output should match the original incremental data exactly\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    dut.rst.value = 0\n    dut.data_in.value = 0\n    dut.valid_in.value = 0\n    dut.bypass_scrambling.value = 0\n    check_mode = dut.CHECK_MODE.value\n    await RisingEdge(dut.clk)\n    \n    if(check_mode == 0):\n        # Start the clock\n\n        ######################################################################\n        # PHASE 1: SCRAMBLER\n        ######################################################################\n        # 1) Reset the DUT so the PRBS starts from its known seed\n        await reset_dut(dut,cycles=2)\n\n        # 2) Feed incremental data\n        NUM_WORDS = int(dut.WIDTH.value)\n        scrambled_data = []\n        for i in range(2**NUM_WORDS):\n            dut.data_in.value = i\n            dut.valid_in.value = 1\n            await RisingEdge(dut.clk)\n\n            # Capture the scrambled output\n            out_val = int(dut.data_out.value)\n            scrambled_data.append(out_val)\n\n        # Stop driving valid\n        dut.valid_in.value = 0\n\n        # Let a few cycles pass\n        for _ in range(5):\n            await RisingEdge(dut.clk)\n\n        ######################################################################\n        # PHASE 2: DESCRAMBLER\n        ######################################################################\n        # 1) Reset again so the PRBS restarts from the *same* seed\n        dut.rst.value = 1\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        dut.rst.value = 0\n        await RisingEdge(dut.clk)\n\n        # 2) Feed the scrambled data\n        descrambled_data = []\n        valid_out = []\n        for i in range((2**NUM_WORDS)-1):\n            dut.data_in.value = scrambled_data[i+1]\n            dut.valid_in.value = 1\n            await RisingEdge(dut.clk)\n\n            # Capture the descrambled output\n            out_val = int(dut.data_out.value)\n            if(dut.valid_out.value.integer):\n                descrambled_data.append(out_val)\n            valid_out.append(dut.valid_out.value)\n\n        # Stop driving valid\n        dut.valid_in.value = 0\n        for _ in range(5):\n            await RisingEdge(dut.clk)\n\n        ######################################################################\n        # FINAL CHECK\n        ######################################################################\n        # Compare the descrambled data with the original incremental data\n        mismatches = 0\n        for i, data in enumerate(descrambled_data):\n            if(i!= 0):\n                if ((data != i)):\n                    mismatches += 1\n                    cocotb.log.error(f\"Mismatch at index {i}: expected {i-1}, got {data}\")\n\n        assert mismatches == 0, f\"Found {mismatches} mismatches!\"\n        cocotb.log.info(\"TEST PASSED: Descrambled data matches original incremental data.\")\n\n    else:\n        \n        await reset_dut(dut,cycles=2)\n        # Test Parameters\n        check_mode  = int(dut.CHECK_MODE.value)   # Select mode: generator or checker\n        poly_length = int(dut.POLY_LENGTH.value)  # Length of the polynomial\n        poly_tap    = int(dut.POLY_TAP.value)     # Tap position in the polynomial\n        width       = int(dut.WIDTH.value)        # Width of the PRBS output\n        num_cycles  = 10                          # Number of cycles to run the test\n\n        # Seed value for PRBS generation (all bits set to 1 initially)\n        seed = int('1' * poly_length, 2)\n        # Reset the DUT (Device Under Test)\n        dut.rst.value = 1\n        dut.bypass_scrambling.value = 0\n        dut.data_in.value = 0  # Initialize data_in to 0\n        await ClockCycles(dut.clk, 5)  # Wait for 5 clock cycles\n\n        # Release the reset and enable PRBS checking\n        dut.rst.value = 0  # Release reset\n        dut.valid_in.value = 1\n\n        # Generate expected PRBS sequence to feed into data_in\n        prbs_sequence = generate_prbs(seed, poly_length, poly_tap, width, num_cycles+1)\n\n        cocotb.log.info(f\"prbs_sequence: {prbs_sequence}\")\n        # Initialize error flag\n        error_flag = 0\n\n        # Wait for a rising edge of the clock to ensure reset is low\n        # await RisingEdge(dut.clk)\n        # Apply PRBS data_in\n        dut.data_in.value = prbs_sequence[0]\n\n        # Wait for a clock cycle\n        await RisingEdge(dut.clk)\n        dut.data_in.value = prbs_sequence[1]\n\n        # Wait for a clock cycle\n        await RisingEdge(dut.clk)\n\n        # Send the PRBS sequence to the DUT via data_in\n        for cycle in range(2,num_cycles):\n            # Apply PRBS data_in\n            dut.data_in.value = prbs_sequence[cycle]\n\n            # Wait for a clock cycle\n            await RisingEdge(dut.clk)\n\n            # Read the error flag from data_out (assuming data_out is the error indicator)\n            error_flag = dut.data_out.value.integer\n\n            if(cycle>0):\n            # Check that error_flag is 0 (no error)\n                assert error_flag == 0, f\"No error expected, but error detected at cycle {cycle}, data out: {error_flag}\"\n                assert dut.valid_out.value.integer == 1, f\"Valid not asserted\"\n\n        # Introduce an error in the data_in\n        dut.data_in.value = prbs_sequence[num_cycles] ^ 0x1  # Flip one bit to introduce error\n\n        # Wait for a few clock cycles\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        \n        # Read the error flag after introducing the error\n        error_flag = dut.data_out.value.integer\n\n        # Check that error_flag is 1 (error detected)\n        assert error_flag >0, f\"Error expected, but no error detected\"\n        assert dut.valid_out.value.integer == 1, f\"Valid not asserted\"\n\n@cocotb.test()\nasync def test_bypass_mode(dut):\n    \"\"\"\n    Test that bypass_scrambling=1 passes input data directly to output,\n    without PRBS alteration.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await RisingEdge(dut.clk)\n\n    await reset_dut(dut, cycles=3)\n    dut.bypass_scrambling.value = 1  # Enable bypass\n\n    test_size = 20\n    width = int(getattr(dut, \"WIDTH\", 16).value)\n\n    random_data = [random.randint(0, (1 << width) - 1) for _ in range(test_size)]\n    observed_data = []\n\n    for val in random_data:\n        dut.data_in.value = val\n        dut.valid_in.value = 1\n        await RisingEdge(dut.clk)\n        if(dut.valid_out.value.integer):\n            out_val = int(dut.data_out.value)\n            observed_data.append(out_val)\n\n    # Stop driving valid\n    dut.valid_in.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    # Verify output == input\n    mismatches = 0\n     # Check if observed_data is empty and raise an error if so\n    if not observed_data:\n        raise cocotb.log.error(\"No output data was observed!\")\n    else:\n        for idx, (inp, obs) in enumerate(zip(random_data, observed_data)):\n            if inp != obs:\n                mismatches += 1\n                cocotb.log.error(f\"Bypass mismatch idx={idx}: sent=0x{inp:X}, got=0x{obs:X}\")\n\n    assert mismatches == 0, f\"Bypass mode: Found {mismatches} mismatch(es)!\"\n    cocotb.log.info(\"TEST PASSED: Bypass mode correctly forwards input to output.\")\n\n\n@cocotb.test()\nasync def test_bit_count(dut):\n    \"\"\"\n    Test the DUT's bit counter. We'll do two runs of valid data and\n    ensure bit_count increments by (num_words * WIDTH) each time.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await RisingEdge(dut.clk)\n    await reset_dut(dut, cycles=3)\n\n    width = int(getattr(dut, \"WIDTH\", 16).value)\n\n    # 1) First run\n    num_words_1 = 10\n    num_words_2 = 15\n    poly_length = int(dut.POLY_LENGTH.value)  # Length of the polynomial\n    poly_tap    = int(dut.POLY_TAP.value)     # Tap position in the polynomial\n    width       = int(dut.WIDTH.value)        # Width of the PRBS output\n    check_mode = dut.CHECK_MODE.value\n    # Seed value for PRBS generation (all bits set to 1 initially)\n    seed = int('1' * poly_length, 2)\n    if(check_mode == 0):\n        for i in range(num_words_1):\n            dut.data_in.value = i\n            dut.valid_in.value = 1\n            await RisingEdge(dut.clk)\n    \n        # Flush\n        dut.valid_in.value = 0\n        for _ in range(2):\n            await RisingEdge(dut.clk)\n    \n        # Check the counter\n        expected_bits_1 = num_words_1 * width\n            \n        actual_bits_1 = int(dut.bit_count.value)\n        cocotb.log.info(f\"[BitCount] After first run: bit_count={actual_bits_1}, expected={expected_bits_1}\")\n        assert actual_bits_1 == expected_bits_1, \"Bit count mismatch after first run!\"\n    \n        # 2) Second run\n        for i in range(num_words_2):\n            dut.data_in.value = i\n            dut.valid_in.value = 1\n            await RisingEdge(dut.clk)\n    \n        # Flush\n        dut.valid_in.value = 0\n        for _ in range(2):\n            await RisingEdge(dut.clk)\n    \n        # Check the counter\n        expected_bits_2 = (num_words_1 + num_words_2) * width\n        actual_bits_2 = int(dut.bit_count.value)\n        cocotb.log.info(f\"[BitCount] After second run: bit_count={actual_bits_2}, expected={expected_bits_2}\")\n        assert actual_bits_2 == expected_bits_2, \"Bit count mismatch after second run!\"\n    \n        cocotb.log.info(\"TEST PASSED: bit_count increments exactly as expected.\")\n    else :\n        # Reset the DUT (Device Under Test)\n        dut.rst.value = 1\n        dut.bypass_scrambling.value = 0\n        dut.data_in.value = 0  # Initialize data_in to 0\n        await ClockCycles(dut.clk, 5)  # Wait for 5 clock cycles\n\n        # Release the reset and enable PRBS checking\n        dut.rst.value = 0  # Release reset\n        dut.valid_in.value = 1\n        # Generate expected PRBS sequence to feed into data_in\n        prbs_sequence = generate_prbs(seed, poly_length, poly_tap, width, num_words_1+num_words_2)\n        for i in range(num_words_1+num_words_2):\n            dut.data_in.value = prbs_sequence[i]\n            dut.valid_in.value = 1\n            await RisingEdge(dut.clk)\n            if(i==num_words_1):\n                actual_bits_1 = int(dut.bit_count.value)\n        dut.valid_in.value = 0\n        await RisingEdge(dut.clk)\n        actual_bits_2 = int(dut.bit_count.value)\n        \n        # Check the counter\n        expected_bits_1 = num_words_1 * width\n        cocotb.log.info(f\"[BitCount] After first run: bit_count={actual_bits_1}, expected={expected_bits_1}\")\n        assert actual_bits_1 == expected_bits_1, \"Bit count mismatch after first run!\"\n    \n        # Check the counter\n        expected_bits_2 = (num_words_1 + num_words_2) * width\n        cocotb.log.info(f\"[BitCount] After second run: bit_count={actual_bits_2}, expected={expected_bits_2}\")\n        assert actual_bits_2 == expected_bits_2, \"Bit count mismatch after second run!\"\n    \n        cocotb.log.info(\"TEST PASSED: bit_count increments exactly as expected.\")\n", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_sorter_0016", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a **sorting_engine** module that sorts the input data in ascending order.\n\nThe **sorting_engine** module is available at `/rtl/sorting_engine.sv` and its' specification in the `/docs` directory.\nCan you implement the **`order_matching_engine.sv`** in the `/rtl` folder? Details of the `order_matching_engine` module is as given below\n\n**Description - Order Matching Engine**\n\nThe goal is to build a module that efficiently processes and matches buy (bid) and sell (ask) orders. Here\u2019s what the design must accomplish:\n\n- **Input Handling:**  \n  The engine accepts two flat input vectors\u2014one for bid orders and one for ask orders. Each vector contains 8 orders (prices) of configurable bit-width (`PRICE_WIDTH`).\n\n- **Sorting:**  \n  Use the provided sorting engine to sort each set of orders:\n  - Bid orders are sorted in ascending order (so the highest bid is at the last position).\n  - Ask orders are sorted in ascending order (so the lowest ask is at the first position).\n\n- **Order Matching:**  \n  After sorting, extract the best bid (highest bid) and best ask (lowest ask). If the best bid is greater than or equal to the best ask, a match occurs. The matching price is taken as the best ask.\n\n- **Latency Requirement:**  \n  The design must contain logic to measure and ensure that the total processing latency, from the issuance of a start signal to the output being valid, is exactly 21 clock cycles.\n\n- **Port List:**\n```verilog\n   module order_matching_engine #(\n    parameter PRICE_WIDTH = 16  // width of the price field\n)(\n    input                      clk,\n    input                      rst,\n    input                      start,         // start matching operation\n    input  [8*PRICE_WIDTH-1:0] bid_orders,    // 8 bid orders (flat vector)\n    input  [8*PRICE_WIDTH-1:0] ask_orders,    // 8 ask orders (flat vector)\n    output reg                 match_valid,   // high if a match occurs\n    output reg [PRICE_WIDTH-1:0] matched_price, // matched price (best ask)\n    output reg                 done,          // matching engine done\n    output reg                 latency_error  // asserted if latency \u2260 20 cycles\n);\n```\n", "context": {"docs/specification.md": "# Sorting Engine Specification Document\n\n## Introduction\n\nThe **Sorting Engine** should implement an **8-element parallel merge sort** algorithm. This module is designed to sort 8 inputs of configurable bit-width (parameterized by `WIDTH`) in ascending order (lowest value at LSB and highest at MSB). The design must leverage the parallelism inherent in the merge sort algorithm by dividing the sort process into multiple stages. Each stage performs compare\u2013swap and merging operations in a pipelined finite state machine (FSM) manner.\n\n---\n\n## Algorithm Overview\n\n**Merge Sort** is a well-known divide-and-conquer sorting algorithm. The basic idea is to divide the unsorted list into smaller sub-lists, sort each sub-list, and then merge them to produce a sorted list. The parallel merge sort algorithm to be implemented in this module works as follows:\n\n1. **Pair Sorting:**  \n   The input array is divided into 4 pairs. Each pair is independently sorted using a compare\u2013swap operation. This is the step where parallel operation happens for all pairs.\n\n2. **Merge Sorted Pairs:**  \n   Two consecutive sorted pairs are merged sequentially into a 4-element sorted group. This is done for both halves of the array, the first 4 pairs of elements and the last 4 elements.\n\n3. **Final Merge:**  \n   The two 4-element groups are merged to produce the final sorted 8-element array.\n\n### Example\n\nConsider the input array (from lowest index to highest):\n\n```\n[8, 7, 6, 5, 4, 3, 2, 1]\n```\n\n**Stage 1 \u2013 Pair Sorting:**  \n- Pairs are sorted:  \n  - Compare 8 and 7 \u2192 [7, 8]  \n  - Compare 6 and 5 \u2192 [5, 6]  \n  - Compare 4 and 3 \u2192 [3, 4]  \n  - Compare 2 and 1 \u2192 [1, 2]\n\n**Stage 2 \u2013 Merge Sorted Pairs:**  \n- Merge the first two pairs: [7, 8] and [5, 6] \u2192 [5, 6, 7, 8]  \n- Merge the next two pairs: [3, 4] and [1, 2] \u2192 [1, 2, 3, 4]\n\n**Stage 3 \u2013 Final Merge:**  \n- Merge the two 4-element groups: [5, 6, 7, 8] and [1, 2, 3, 4] \u2192 [1, 2, 3, 4, 5, 6, 7, 8]\n\nThe final output is the sorted list in ascending order.\n\n---\n\n## Module Interface\n\nThe module should be defined as follows:\n\n```verilog\nmodule sorting_engine #(parameter WIDTH = 8)(\n    input                     clk,\n    input                     rst,\n    input                     start,  \n    input  [8*WIDTH-1:0]      in_data,\n    output reg                done,   \n    output reg [8*WIDTH-1:0]  out_data\n);\n```\n\n### Port Description\n\n- **clk:** Clock signal.\n- **rst:** Active-high asynchronous reset to set the outputs to 0.\n- **start:** Active-high signal to initiate the sort operation. High for 1 clock cycle.\n- **in_data:** Flat input bus representing 8 data elements, each `WIDTH` bits wide.\n- **done:** Active-high signal indicating the completion of the sort operation. High for 1 clock cycle after sorting completes.\n- **out_data:** Flat output bus containing the sorted data. Updated along with done signal and remains stable until data from next sorting operation is updated.\n\n---\n\n## Internal Architecture\n\nThe internal architecture must be organized into several stages controlled by an FSM:\n\n1. **Data Loading:**  \n   The flat `in_data` vector should be unpacked into an internal array.\n\n2. **Stage 1 \u2013 Pair Compare\u2013Swap:**  \n   Four pairs of data must be compared and swapped in parallel if necessary. The sorted pairs should be stored for subsequent merging.\n\n3. **Stage 2 \u2013 Merging Sorted Pairs:**  \n   Two merge operations to be performed sequentially:\n   - The first merge combines pairs `[0,1]` with `[2,3]` into a sorted 4-element group.\n   - The second merge combines pairs `[4,5]` with `[6,7]` into another sorted 4-element group.\n\n4. **Stage 3 \u2013 Final Merge:**  \n   The two 4-element groups should be merged to produce the final sorted array.\n\nThe design should utilize sequential merging with pointer and counter logic, allowing the design to be pipelined and easily scalable for production.\n\n---\n\n## Timing and Latency\n\nThe design should be fully synchronous with a pipelined FSM. The expected latency from asserting the start signal to asserting the done signal is **20 clock cycles**. This includes:\n- A few cycles for data loading.\n- Cycles dedicated to the pair sorting and merging stages.\n- Final packaging of the sorted output into the flat bus.", "rtl/sorting_engine.sv": "module sorting_engine #(parameter WIDTH = 8)(\n    input                     clk,\n    input                     rst,\n    input                     start,      // Start the sort when start=1\n    input  [8*WIDTH-1:0]      in_data,    // 8 inputs, each WIDTH bits\n    output reg                done,\n    output reg [8*WIDTH-1:0]  out_data    // 8 outputs, sorted ascending\n);\n\n  // FSM state encoding\n  localparam IDLE      = 3'd0,\n             LOAD      = 3'd1,\n             SORT_PAIRS= 3'd2,\n             MERGE_2_1 = 3'd3,  // Merge first two sorted pairs into a 4-element group\n             MERGE_2_2 = 3'd4,  // Merge second two sorted pairs into a 4-element group\n             MERGE_4   = 3'd5,  // Merge the two 4-element groups into final 8-element sorted list\n             DONE      = 3'd6;\n\n  reg [2:0] state;\n\n  // Internal storage for data at different stages.\n  reg [WIDTH-1:0] stage0 [7:0];           // Loaded input data\n  reg [WIDTH-1:0] sorted_pairs [7:0];     // After pair compare\u2013swap\n  reg [WIDTH-1:0] merge4_right [3:0];      // First 4\u2013element sorted group (from indices 0\u20133)\n  reg [WIDTH-1:0] merge4_left [3:0];     // Second 4\u2013element sorted group (from indices 4\u20137)\n  reg [WIDTH-1:0] final_sorted [7:0];     // Final 8\u2013element sorted result\n\n  // Merge pointers and counter used for sequential merging\n  reg [3:0] merge_count;  // Counts how many outputs have been merged in current merge stage\n  reg [2:0] ptr1, ptr2;   // Pointers for the two arrays being merged\n\n  integer i; // loop variable for for\u2013loops\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      state      <= IDLE;\n      done       <= 0;\n      out_data   <= 0;\n      merge_count<= 0;\n      ptr1       <= 0;\n      ptr2       <= 0;\n    end else begin\n      case (state)\n        // Wait for the start signal.\n        IDLE: begin\n          done <= 0;\n          if (start)\n            state <= LOAD;\n        end\n\n        // Capture the 8 input elements from the flat bus into an array.\n        LOAD: begin\n          for (i = 0; i < 8; i = i + 1) begin\n            stage0[i] <= in_data[i*WIDTH +: WIDTH];\n          end\n          state <= SORT_PAIRS;\n        end\n\n        // Stage 1: Compare-swap each adjacent pair.\n        // The 8 numbers are divided into 4 pairs: indices {0,1}, {2,3}, {4,5}, {6,7}.\n        SORT_PAIRS: begin\n          // Pair 0\n          if (stage0[0] <= stage0[1]) begin\n            sorted_pairs[0] <= stage0[0];\n            sorted_pairs[1] <= stage0[1];\n          end else begin\n            sorted_pairs[0] <= stage0[1];\n            sorted_pairs[1] <= stage0[0];\n          end\n          // Pair 1\n          if (stage0[2] <= stage0[3]) begin\n            sorted_pairs[2] <= stage0[2];\n            sorted_pairs[3] <= stage0[3];\n          end else begin\n            sorted_pairs[2] <= stage0[3];\n            sorted_pairs[3] <= stage0[2];\n          end\n          // Pair 2\n          if (stage0[4] <= stage0[5]) begin\n            sorted_pairs[4] <= stage0[4];\n            sorted_pairs[5] <= stage0[5];\n          end else begin\n            sorted_pairs[4] <= stage0[5];\n            sorted_pairs[5] <= stage0[4];\n          end\n          // Pair 3\n          if (stage0[6] <= stage0[7]) begin\n            sorted_pairs[6] <= stage0[6];\n            sorted_pairs[7] <= stage0[7];\n          end else begin\n            sorted_pairs[6] <= stage0[7];\n            sorted_pairs[7] <= stage0[6];\n          end\n          // Initialize pointers for first merge stage (MERGE_2_1)\n          ptr1        <= 0;\n          ptr2        <= 0;\n          merge_count <= 0;\n          state       <= MERGE_2_1;\n        end\n\n        // Stage 2a: Merge the first two sorted pairs (indices 0\u20131 and 2\u20133)\n        MERGE_2_1: begin\n          // Use ptr1 for sorted_pairs[0:1] and ptr2 for sorted_pairs[2:3].\n          if ((ptr1 < 2) && (ptr2 < 2)) begin\n            if (sorted_pairs[ptr1] <= sorted_pairs[ptr2+2]) begin\n              merge4_right[merge_count] <= sorted_pairs[ptr1];\n              ptr1 <= ptr1 + 1;\n            end else begin\n              merge4_right[merge_count] <= sorted_pairs[ptr2+2];\n              ptr2 <= ptr2 + 1;\n            end\n          end else if (ptr1 < 2) begin\n            merge4_right[merge_count] <= sorted_pairs[ptr1];\n            ptr1 <= ptr1 + 1;\n          end else if (ptr2 < 2) begin\n            merge4_right[merge_count] <= sorted_pairs[ptr2+2];\n            ptr2 <= ptr2 + 1;\n          end\n          // Check if 4 elements have been merged.\n          if (merge_count == 3) begin\n            merge_count <= 0;\n            ptr1        <= 0;\n            ptr2        <= 0;\n            state       <= MERGE_2_2;\n          end else begin\n            merge_count <= merge_count + 1;\n          end\n        end\n\n        // Stage 2b: Merge the second two sorted pairs (indices 4\u20135 and 6\u20137)\n        MERGE_2_2: begin\n          // Use ptr1 for sorted_pairs[4:5] and ptr2 for sorted_pairs[6:7].\n          if ((ptr1 < 2) && (ptr2 < 2)) begin\n            if (sorted_pairs[ptr1+4] <= sorted_pairs[ptr2+6]) begin\n              merge4_left[merge_count] <= sorted_pairs[ptr1+4];\n              ptr1 <= ptr1 + 1;\n            end else begin\n              merge4_left[merge_count] <= sorted_pairs[ptr2+6];\n              ptr2 <= ptr2 + 1;\n            end\n          end else if (ptr1 < 2) begin\n            merge4_left[merge_count] <= sorted_pairs[ptr1+4];\n            ptr1 <= ptr1 + 1;\n          end else if (ptr2 < 2) begin\n            merge4_left[merge_count] <= sorted_pairs[ptr2+6];\n            ptr2 <= ptr2 + 1;\n          end\n          // Check if merge of 4 elements is complete.\n          if (merge_count == 3) begin\n            merge_count <= 0;\n            ptr1        <= 0;\n            ptr2        <= 0;\n            state       <= MERGE_4;\n          end else begin\n            merge_count <= merge_count + 1;\n          end\n        end\n\n        // Stage 3: Merge the two 4\u2013element groups (merge4_right and merge4_left)\n        MERGE_4: begin\n          if ((ptr1 < 4) && (ptr2 < 4)) begin\n            if (merge4_right[ptr1] <= merge4_left[ptr2]) begin\n              final_sorted[merge_count] <= merge4_right[ptr1];\n              ptr1 <= ptr1 + 1;\n            end else begin\n              final_sorted[merge_count] <= merge4_left[ptr2];\n              ptr2 <= ptr2 + 1;\n            end\n          end else if (ptr1 < 4) begin\n            final_sorted[merge_count] <= merge4_right[ptr1];\n            ptr1 <= ptr1 + 1;\n          end else if (ptr2 < 4) begin\n            final_sorted[merge_count] <= merge4_left[ptr2];\n            ptr2 <= ptr2 + 1;\n          end\n          // Check if all 8 elements have been merged.\n          if (merge_count == 7) begin\n            merge_count <= 0;\n            state       <= DONE;\n          end else begin\n            merge_count <= merge_count + 1;\n          end\n        end\n\n        // Final state: pack the final_sorted array back into out_data and assert done.\n        DONE: begin\n          for (i = 0; i < 8; i = i + 1) begin\n            out_data[i*WIDTH +: WIDTH] <= final_sorted[i];\n          end\n          done  <= 1;\n          // Optionally, return to IDLE (or hold in DONE) so a new sort can begin.\n          state <= IDLE;\n        end\n\n        default: state <= IDLE;\n      endcase\n    end\n  end\n    \nendmodule"}, "patch": {"rtl/order_matching_engine.sv": ""}, "harness": {"docker-compose.yml": "services:\n  \n direct:\n    image: hdlc/sim:osvb\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command: pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/order_matching_engine.sv /code/rtl/sorting_engine.sv\nTOPLEVEL        = order_matching_engine\nMODULE          = test_order_matching_engine\nPYTHONPATH      = /src\nHASH            = 16-parallel-sorter-component-integration-2\n", "src/test_order_matching_engine.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\ndef pack_vector(orders, width):\n    \"\"\"\n    Pack a list of integers (orders[0] ... orders[7]) into a flat integer.\n    The flat vector is constructed as {orders[7], orders[6], ..., orders[0]}\n    so that orders[0] occupies the least-significant bits.\n    \"\"\"\n    value = 0\n    for order in orders[::-1]:\n        value = (value << width) | (order & ((1 << width) - 1))\n    return value\n\ndef scale_orders(orders, max_val):\n    \"\"\"\n    Scale a list of order percentages (0-100) into the range [0, max_val].\n    \"\"\"\n    return [int(val * max_val / 100) for val in orders]\n\n@cocotb.test()\nasync def test_order_matching_engine(dut):\n    \"\"\"\n    Cocotb testbench for order_matching_engine.\n    This test applies several corner-case and random test vectors,\n    verifies that the matching result (match_valid and matched_price)\n    is correct, and checks that the overall latency from start to done is exactly 20 cycles.\n    \"\"\"\n    # Create and start clock (10 ns period)\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Retrieve PRICE_WIDTH parameter from DUT (default to 16)\n    try:\n        price_width = int(dut.PRICE_WIDTH.value)\n    except Exception as e:\n        dut._log.warning(\"Unable to read PRICE_WIDTH parameter, defaulting to 16. Error: %s\", e)\n        price_width = 16\n\n    max_val = (1 << price_width) - 1\n    NUM_ELEMS = 8\n\n    # Helper: Measure latency from start pulse to when done is asserted.\n    async def measure_latency():\n        cycle_count = 0\n        while int(dut.done.value) == 0:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n        return cycle_count\n\n    # Define test cases.\n    tests = []\n\n    # Test 1: Matching scenario (bid >= ask)\n    # Original percentages for bid: [40, 80, 20, 70, 60, 30, 10, 50]\n    # and ask: [35, 15, 45, 55, 25, 65, 75, 78].\n    tests.append({\n        \"description\": \"Matching scenario: valid match\",\n        \"bid\": scale_orders([40, 80, 20, 70, 60, 30, 10, 50], max_val),\n        \"ask\": scale_orders([35, 15, 45, 55, 25, 65, 75, 78], max_val),\n        \"expected_match\": True,\n        \"expected_price\": int(15 * max_val / 100)  # 15% of max_val\n    })\n\n    # Test 2: No match scenario (bid < ask)\n    tests.append({\n        \"description\": \"No match scenario: no match\",\n        \"bid\": scale_orders([10, 20, 30, 40, 50, 60, 70, 75], max_val),\n        \"ask\": scale_orders([80, 90, 95, 85, 88, 82, 91, 87], max_val),\n        \"expected_match\": False,\n        \"expected_price\": 0\n    })\n\n    # Test 3: Extreme values at boundaries.\n    tests.append({\n        \"description\": \"Extreme values: match at boundary\",\n        \"bid\": [0, 0, 0, 0, 0, 0, 0, max_val],\n        \"ask\": [max_val] * NUM_ELEMS,\n        \"expected_match\": True,\n        \"expected_price\": max_val\n    })\n\n    # Test 4: Random stress tests (10 iterations)\n    for t in range(10):\n        bid_rand = [random.randint(0, max_val) for _ in range(NUM_ELEMS)]\n        ask_rand = [random.randint(0, max_val) for _ in range(NUM_ELEMS)]\n        best_bid = max(bid_rand)\n        best_ask = min(ask_rand)\n        expected_match = best_bid >= best_ask\n        expected_price = best_ask if expected_match else 0\n        tests.append({\n            \"description\": f\"Random stress test iteration {t+1}\",\n            \"bid\": bid_rand,\n            \"ask\": ask_rand,\n            \"expected_match\": expected_match,\n            \"expected_price\": expected_price\n        })\n\n    # Iterate through each test case.\n    for test in tests:\n        dut._log.info(\"---------------------------------------------------\")\n        dut._log.info(\"Starting test: %s\", test[\"description\"])\n\n        # Pack bid and ask orders.\n        bid_flat = pack_vector(test[\"bid\"], price_width)\n        ask_flat = pack_vector(test[\"ask\"], price_width)\n\n        # Drive the inputs.\n        dut.bid_orders.value = bid_flat\n        dut.ask_orders.value = ask_flat\n\n        # Apply a reset before starting the test.\n        dut.rst.value = 1\n        await RisingEdge(dut.clk)\n        dut.rst.value = 0\n        await RisingEdge(dut.clk)\n\n        # Issue the start pulse.\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        # Measure latency.\n        latency = await measure_latency()\n        dut._log.info(\"Test '%s': Measured latency = %d cycles\", test[\"description\"], latency)\n        assert latency == 21, f\"Latency error in test '{test['description']}': expected 20 cycles, got {latency}\"\n\n        # Check DUT's latency_error signal.\n        assert int(dut.latency_error.value) == 0, f\"Latency error flag is asserted in test '{test['description']}'\"\n\n        # Retrieve matching outputs.\n        match_valid = int(dut.match_valid.value)\n        matched_price = int(dut.matched_price.value)\n\n        # Compute expected matching result.\n        expected_best_bid = max(test[\"bid\"])\n        expected_best_ask = min(test[\"ask\"])\n        if expected_best_bid >= expected_best_ask:\n            exp_match_valid = 1\n            exp_matched_price = expected_best_ask\n        else:\n            exp_match_valid = 0\n            exp_matched_price = 0\n\n        # Alternatively, use the test case provided expected values.\n        exp_match_valid = 1 if test[\"expected_match\"] else 0\n        exp_matched_price = test[\"expected_price\"]\n\n        # Check matching result.\n        assert match_valid == exp_match_valid, f\"Test '{test['description']}' failed: Expected match_valid {exp_match_valid}, got {match_valid}\"\n        if match_valid:\n            assert matched_price == exp_matched_price, f\"Test '{test['description']}' failed: Expected matched_price {exp_matched_price}, got {matched_price}\"\n\n        dut._log.info(\"Test '%s' PASSED: Best bid = %d, Best ask = %d, Matched price = %d\", \n                      test[\"description\"], expected_best_bid, expected_best_ask, matched_price)\n\n        # Wait a few cycles before the next test.\n        await Timer(20, units=\"ns\")\n\n    dut._log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner(PRICE_WIDTH: int=4):\n    \n    parameter = {\"PRICE_WIDTH\":PRICE_WIDTH}\n    # Debug information\n    print(f\"[DEBUG] Running simulation with PRICE_WIDTH={PRICE_WIDTH}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        parameters=parameter,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Parametrize test for different PRICE_WIDTH\n@pytest.mark.parametrize(\"PRICE_WIDTH\", [4,5,8,12])\n\ndef test_sort(PRICE_WIDTH):\n    # Run the simulation with specified parameters\n    test_runner(PRICE_WIDTH=PRICE_WIDTH)\n", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_sorter_0026", "categories": ["cid005", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a few **sorting_engine** modules that sort the input data in ascending order. The **sorting_engine** modules are available at `rtl/` directory. Each module present in the folder implements a different sorting algorithm to perform the sorting operation. The sorting algorithm used by a module is mentioned in the name of the module.\n\nCan you implement the **`order_matching_engine.sv`** in the `rtl` folder? Details of the `order_matching_engine` module are as given below\n\n**Description - Order Matching Engine**\n\nThe goal is to build a module that efficiently processes and matches buy (bid) and sell (ask) orders. Here\u2019s what the design must accomplish:\n\n- **Input Handling:**  \n  The engine accepts two flat input vectors\u2014one for bid orders and one for ask orders. Following are the bid and ask order vectors:\nBid: 42,74,10,21,108,53,95,106\nAsk: 130,108,205,129,192,213,244,141\n\n- **Sorting:**  \n  Select the sorting_engine module that has the lowest latency for the provided input to sort each set of orders. Use the same sorting algorithm implementation for sorting both bid and ask orders.\n  - Bid orders are sorted in ascending order (so the highest bid is at the last position).\n  - Ask orders are sorted in ascending order (so the lowest ask is at the first position).\n\n- **Order Matching:**  \n  After sorting, extract the best bid (highest bid) and best ask (lowest ask). If the best bid is greater than or equal to the best ask, a match occurs. The matching price is taken as the best bid.\n\n- **Safeguarding:**\n   The design should have a safeguard to cap the total loss in the event this module is used for trading purpose. Use the input circuit breaker that should disable any successful matches irrespective of the incoming bid and ask orders.\n\n- **Latency:**\n   The order_matching_engine that is generated should add a latency of exactly 1 clock cycle on top of the latency of the sorting_engine module it uses.\n\n- **Port List:**\n```verilog\n   module order_matching_engine #(\n    parameter PRICE_WIDTH = 16  // width of the price field\n)(\n    input                      clk,\n    input                      rst,\n    input                      start,         // Active high. Start matching operation\n    input                      circuit_breaker, //Active high. Circuit breaker\n    input  [8*PRICE_WIDTH-1:0] bid_orders,    // 8 bid orders (flat vector)\n    input  [8*PRICE_WIDTH-1:0] ask_orders,    // 8 ask orders (flat vector)\n    output reg                 match_valid,   // High if a match occurs\n    output reg [PRICE_WIDTH-1:0] matched_price, // Matched price (best bid)\n    output reg                 done          // Active high. Matching engine done\n);\n```\n", "context": {"rtl/brick_sort.sv": "module brick_sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // ----------------------------------------------------------\n    // Internal Parameters and State Encoding\n    // ----------------------------------------------------------\n    localparam IDLE = 2'd0,\n               LOAD = 2'd1,\n               SORT = 2'd2,\n               DONE = 2'd3;\n\n    // ----------------------------------------------------------\n    // Internal Registers\n    // ----------------------------------------------------------\n    reg [1:0]  state, next_state;\n\n    // Store data in a register array for easy swapping\n    reg [WIDTH-1:0] data_array [0:N-1];\n\n    // Pass counter: we will run up to N passes\n    reg [$clog2(N+1)-1:0] pass_cnt;\n\n    // Pair index: on each pass, we compare-swap one pair per clock\n    reg [$clog2(N/2+1):0] pair_idx;\n\n    // ----------------------------------------------------------\n    // Next-State Logic\n    // ----------------------------------------------------------\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = LOAD;\n            end\n\n            LOAD: begin\n                // After loading input data, go to SORT state\n                next_state = SORT;\n            end\n\n            SORT: begin\n                // Once we've completed N passes, sorting is done\n                if (pass_cnt == N)\n                    next_state = DONE;\n            end\n\n            DONE: begin\n                // Optionally return to IDLE if desired\n                // For a one-shot, we can just stay in DONE unless reset\n                // Here, we return to IDLE if start is deasserted\n                if (!start)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // ----------------------------------------------------------\n    // Sequential State Update\n    // ----------------------------------------------------------\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // ----------------------------------------------------------\n    // Main Control: pass_cnt, pair_idx, and compare-swap\n    // ----------------------------------------------------------\n    integer i;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done      <= 1'b0;\n            pass_cnt  <= 0;\n            pair_idx  <= 0;\n        end\n        else begin\n            case (state)\n\n                //--------------------------------------\n                // IDLE: wait for start, clear signals\n                //--------------------------------------\n                IDLE: begin\n                    done     <= 1'b0;\n                    pass_cnt <= 0;\n                    pair_idx <= 0;\n                end\n\n                //--------------------------------------\n                // LOAD: capture input data into array\n                //--------------------------------------\n                LOAD: begin\n                    // Load all N elements from in_data\n                    for (i = 0; i < N; i = i + 1) begin\n                        data_array[i] <= in_data[i*WIDTH +: WIDTH];\n                    end\n                    // Initialize counters\n                    pass_cnt <= 0;\n                    pair_idx <= 0;\n                end\n\n                //--------------------------------------\n                // SORT: perform Brick Sort passes\n                //--------------------------------------\n                SORT: begin\n                    // Compare-swap the current pair\n                    // Check if we are within the valid pair range\n                    // Distinguish odd-even pass from even-odd pass\n                    if (pass_cnt[0] == 1'b0) begin\n                        // even-odd pass => pair = (2*pair_idx, 2*pair_idx+1)\n                        for(pair_idx=0; pair_idx<(N+1)/2; pair_idx=pair_idx+1) begin\n                            if (data_array[2*pair_idx] > data_array[2*pair_idx+1]) begin\n                                // Swap\n                                {data_array[2*pair_idx], data_array[2*pair_idx+1]} <= {data_array[2*pair_idx+1], data_array[2*pair_idx]};\n                            end\n                        end\n                    end\n                    else begin\n                        // odd-even pass => pair = (2*pair_idx+1, 2*pair_idx+2\n                        for(pair_idx=0; pair_idx<((N+1)/2) - 1; pair_idx=pair_idx+1) begin\n                            if ((2*pair_idx+2) < N) begin\n                                if (data_array[2*pair_idx+1] > data_array[2*pair_idx+2]) begin\n                                    // Swap\n                                    {data_array[2*pair_idx+1], data_array[2*pair_idx+2]} <= {data_array[2*pair_idx+2], data_array[2*pair_idx+1]};\n                                end\n                            end\n                        end\n                    end\n\n                    // Completed all pairs in this pass -> next pass\n                    pass_cnt <= pass_cnt + 1;\n\n                end // SORT\n\n                //--------------------------------------\n                // DONE: output final data, assert done\n                //--------------------------------------\n                DONE: begin\n                    done <= 1'b1;\n                    // Drive out_data from data_array\n                    for (i = 0; i < N; i = i + 1) begin\n                        out_data[i*WIDTH +: WIDTH] <= data_array[i];\n                    end\n                end\n\n            endcase\n        end\n    end\n\nendmodule", "rtl/bubble_sort.sv": "module bubble_sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // Internal registers to hold the array\n    reg [WIDTH-1:0] array [0:N-1];\n\n    // FSM states\n    localparam IDLE    = 2'd0;\n    localparam SORTING = 2'd1;\n    localparam DONE    = 2'd2;\n\n    reg [1:0]  state, next_state;\n\n    // Variables for bubble sort indexing\n    reg [$clog2(N)-1:0] i;  // Outer loop index\n    reg [$clog2(N)-1:0] j;  // Inner loop index\n\n    // Wires for comparison and swap\n    wire [WIDTH-1:0] val_j;\n    wire [WIDTH-1:0] val_j1;\n\n    assign val_j  = array[j];\n    assign val_j1 = array[j+1];\n\n    // FSM: Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = SORTING;\n            end\n            SORTING: begin\n                // Transition to DONE once all passes are complete\n                if (i == (N-1) && j == (N-2))\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM: Output and counter updates\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            i <= 0;\n            j <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (start) begin\n                        // Load the array from in_data\n                        for (int k = 0; k < N; k = k + 1) begin\n                            array[k] <= in_data[(k+1)*WIDTH-1 -: WIDTH];\n                        end\n                        i <= 0;\n                        j <= 0;\n                    end\n                end\n\n                SORTING: begin\n                    // Perform a single comparison and swap if needed\n                    if (val_j > val_j1) begin\n                        array[j]   <= val_j1;\n                        array[j+1] <= val_j;\n                    end\n\n                    // Update j\n                    if (j == N-2) begin\n                        // One pass completed, increment i\n                        j <= 0;\n                        i <= i + 1;\n                    end else begin\n                        j <= j + 1;\n                    end\n                end\n\n                DONE: begin\n                    // Sorting complete\n                    done <= 1;\n                    // Output the sorted data\n                    for (int m = 0; m < N; m = m + 1) begin\n                        out_data[(m+1)*WIDTH-1 -: WIDTH] <= array[m];\n                    end\n                end\n                default: begin\n                end\n            endcase\n        end\n    end\n\nendmodule", "rtl/merge_sort.sv": "module merge_sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    //-------------------------------------------------\n    // Local Parameters & Functions\n    //-------------------------------------------------\n    localparam IDLE  = 0;\n    localparam LOAD  = 1;\n    localparam SORT  = 2;\n    localparam MERGE = 3;\n    localparam DONE  = 4;\n\n    // Function to compute floor(log2(value)) at compile time\n    function integer clog2;\n        input integer value;\n        integer i;\n        begin\n            clog2 = 0;\n            for (i = 1; i < value; i = i << 1) begin\n                clog2 = clog2 + 1;\n            end\n        end\n    endfunction\n\n    // We choose ADDR_WIDTH big enough so we can store up to ~4*N in subarray_size\n    // For N=8, 4*N=32 => log2(32)=5 => plus 1 => 6 bits => can store up to 63 safely.\n    localparam ADDR_WIDTH = clog2(4 * N) + 1;\n\n    //-------------------------------------------------\n    // Internal Signals\n    //-------------------------------------------------\n    reg [2:0]                 state; // Enough for 5 states: IDLE..DONE\n\n    // Internal memory of N elements\n    reg [WIDTH-1:0]           data_mem [0:N-1];\n\n    // Indices and counters with widened bit-width\n    reg [ADDR_WIDTH-1:0]      base_idx;\n    reg [ADDR_WIDTH-1:0]      left_idx;\n    reg [ADDR_WIDTH-1:0]      right_idx;\n    reg [ADDR_WIDTH-1:0]      merge_idx;\n    reg [ADDR_WIDTH-1:0]      subarray_size;\n\n    // Temporary buffer for merged sub-array\n    reg [WIDTH-1:0]           tmp_merge [0:N-1];\n\n    // Temporary registers for current left/right values\n    reg [WIDTH-1:0]           left_val;\n    reg [WIDTH-1:0]           right_val;\n\n    integer i, k;\n    integer left_end, right_end;\n    integer l_addr,    r_addr;\n\n    //-------------------------------------------------\n    // State Machine\n    //-------------------------------------------------\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset\n            state         <= IDLE;\n            done          <= 1'b0;\n            out_data      <= {N*WIDTH{1'b0}};\n            base_idx      <= 0;\n            left_idx      <= 0;\n            right_idx     <= 0;\n            merge_idx     <= 0;\n            subarray_size <= 1;\n        end else begin\n            case (state)\n\n                //----------------------------------\n                // IDLE: Wait for start signal\n                //----------------------------------\n                IDLE: begin\n                    done <= 1'b0;\n                    if (start) begin\n                        state <= LOAD;\n                    end\n                end\n\n                //----------------------------------\n                // LOAD: Copy from in_data to data_mem\n                //----------------------------------\n                LOAD: begin\n                    for (i = 0; i < N; i = i + 1) begin\n                        data_mem[i] <= in_data[i*WIDTH +: WIDTH];\n                    end\n\n                    // Initialize for sorting\n                    base_idx      <= 0;\n                    left_idx      <= 0;\n                    right_idx     <= 0;\n                    merge_idx     <= 0;\n                    subarray_size <= 1;\n\n                    state <= SORT;\n                end\n\n                //----------------------------------\n                // SORT: Each pass merges sub-arrays of size subarray_size\n                //----------------------------------\n                SORT: begin\n                    // If subarray_size is strictly greater than N, we've fully sorted\n                    // (ensures we do a merge pass at subarray_size == N)\n                    if (subarray_size >= N) begin\n                        state <= DONE;\n                    end else begin\n                        // Prepare to merge pairs of sub-arrays\n                        base_idx  <= 0;\n                        merge_idx <= 0;\n                        left_idx  <= 0;\n                        right_idx <= 0;\n                        state     <= MERGE;\n                    end\n                end\n\n                //----------------------------------\n                // MERGE: Merge one pair of sub-arrays\n                //----------------------------------\n                MERGE: begin\n                    // Compare/pick smaller\n                    if ((l_addr <= left_end) && (r_addr <= right_end)) begin\n                        if (left_val <= right_val) begin\n                            tmp_merge[merge_idx] <= left_val;\n                            left_idx <= left_idx + 1;\n                        end else begin\n                            tmp_merge[merge_idx] <= right_val;\n                            right_idx <= right_idx + 1;\n                        end\n                        merge_idx <= merge_idx + 1;\n                    end\n                    else if (l_addr <= left_end) begin\n                        // Only left sub-array has data\n                        tmp_merge[merge_idx] <= left_val;\n                        left_idx <= left_idx + 1;\n                        merge_idx <= merge_idx + 1;\n                    end\n                    else if (r_addr <= right_end) begin\n                        // Only right sub-array has data\n                        tmp_merge[merge_idx] <= right_val;\n                        right_idx <= right_idx + 1;\n                        merge_idx <= merge_idx + 1;\n                    end\n                    else begin\n                        // Both sub-arrays are exhausted => write back merged results\n                        for (k = 0; k < N; k = k + 1) begin\n                            if ( (k < merge_idx) && (k < (subarray_size << 1)) && ((base_idx + k) < N) )\n                            begin\n                                data_mem[base_idx + k] <= tmp_merge[k];\n                            end\n                        end\n\n                        // Move base_idx to next pair of sub-arrays\n                        base_idx  <= base_idx + (subarray_size << 1);\n                        left_idx  <= 0;\n                        right_idx <= 0;\n                        merge_idx <= 0;\n\n                        // If we merged all pairs in this pass, double subarray_size\n                        if ((base_idx + (subarray_size << 1)) >= N) begin\n                            subarray_size <= subarray_size << 1;\n                            state         <= SORT;\n                        end\n                    end\n                end\n\n                //----------------------------------\n                // DONE: Output the fully sorted array\n                //----------------------------------\n                DONE: begin\n                    for (i = 0; i < N; i = i + 1) begin\n                        out_data[i*WIDTH +: WIDTH] <= data_mem[i];\n                    end\n                    done  <= 1'b1;\n                    state <= IDLE;  // or remain in DONE, your preference\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nalways @ (*) begin\n    if(state == MERGE) begin\n        left_end  = base_idx + subarray_size - 1;\n        right_end = base_idx + (subarray_size << 1) - 1;\n\n        // Boundaries of left and right sub-arrays\n        if (left_end >= N) left_end = N - 1;\n        if (right_end >= N) right_end = N - 1;\n\n        // Calculate addresses\n        l_addr = base_idx + left_idx;\n        r_addr = base_idx + subarray_size + right_idx;\n\n        // Safe read for left_val\n        if ((l_addr <= left_end) && (l_addr < N))\n            left_val = data_mem[l_addr];\n        else\n            left_val = {WIDTH{1'b1}};  // or '0' if you prefer\n\n        // Safe read for right_val\n        if ((r_addr <= right_end) && (r_addr < N))\n            right_val = data_mem[r_addr];\n        else\n            right_val = {WIDTH{1'b1}};\n    end else begin\n        left_end = 0;\n        right_end = 0;\n        l_addr = 0;\n        r_addr = 0;\n        left_val = 0;\n        right_val = 0;\n    end\nend\n\nendmodule", "rtl/selection_sort.sv": "module selection_sorting_engine #(\n    parameter N = 8,\n    parameter WIDTH = 8\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    typedef enum logic [2:0] {\n        IDLE  = 3'd0,\n        LOAD  = 3'd1,\n        FIND  = 3'd2,\n        CHECK = 3'd3,\n        SWAP  = 3'd4,\n        NEXT  = 3'd5,\n        DONE  = 3'd6\n    } state_t;\n\n    state_t current_state, next_state;\n\n    reg [WIDTH-1:0] data_array [0:N-1];\n\n    reg [$clog2(N)-1:0] i;\n    reg [$clog2(N)-1:0] j;\n    reg [$clog2(N)-1:0] min_idx;\n\n    reg [WIDTH-1:0] min_val;\n    integer idx;\n    integer k;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = current_state;\n        case (current_state)\n            IDLE: begin\n                if (start)\n                    next_state = LOAD;\n            end\n\n            LOAD: begin\n                next_state = FIND;\n            end\n\n            FIND: begin\n                next_state = CHECK;\n            end\n\n            CHECK: begin\n                if (j == N-1)\n                    next_state = SWAP;\n                else\n                    next_state = CHECK;\n            end\n\n            SWAP: begin\n                next_state = NEXT;\n            end\n\n            NEXT: begin\n                if (i == N-2)\n                    next_state = DONE;\n                else\n                    next_state = FIND;\n            end\n\n            DONE: begin\n                next_state = IDLE;\n            end\n\n            default: next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done     <= 1'b0;\n            out_data <= {N*WIDTH{1'b0}};\n        end\n        else begin\n            done <= (current_state == DONE);\n\n            if (current_state == DONE) begin\n                for (idx = 0; idx < N; idx = idx + 1) begin\n                    out_data[idx*WIDTH +: WIDTH] <= data_array[idx];\n                end\n            end\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            for (k = 0; k < N; k = k + 1) begin\n                data_array[k] <= {WIDTH{1'b0}};\n            end\n            i       <= 0;\n            j       <= 0;\n            min_idx <= 0;\n            min_val <= {WIDTH{1'b0}};\n        end\n        else begin\n            case (current_state)\n\n                IDLE: begin\n                end\n\n                LOAD: begin\n                    for (k = 0; k < N; k = k + 1) begin\n                        data_array[k] <= in_data[k*WIDTH +: WIDTH];\n                    end\n                    i       <= 0;\n                    j       <= 0;\n                    min_idx <= 0;\n                    min_val <= {WIDTH{1'b0}};\n                end\n\n                FIND: begin\n                    j          <= i + 1;\n                    min_idx    <= i;\n                    min_val    <= data_array[i];\n                end\n\n                CHECK: begin\n                    if (data_array[j] < min_val) begin\n                        min_val    <= data_array[j];\n                        min_idx    <= j;\n                    end\n\n                    if (j < N-1) begin\n                        j <= j + 1;\n                    end\n                end\n\n                SWAP: begin\n                    if (min_idx != i) begin\n                        data_array[i]        <= data_array[min_idx];\n                        data_array[min_idx]  <= data_array[i];\n                    end\n                end\n\n                NEXT: begin\n                    i <= i + 1;\n                end\n\n                DONE: begin\n                end\n\n                default: begin\n                end\n            endcase\n        end\n    end\n\nendmodule"}, "patch": {"rtl/order_matching_engine.sv": ""}, "harness": {"docker-compose.yml": "services:\n  \n direct:\n    image: hdlc/sim:osvb\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command: pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/order_matching_engine.sv /code/rtl/brick_sort.sv /code/rtl/bubble_sort.sv /code/rtl/merge_sort.sv /code/rtl/selection_sort.sv\nTOPLEVEL        = order_matching_engine\nMODULE          = test_order_matching_engine\nPYTHONPATH      = /src\nHASH            = 26-order-matching-engine-hard\n", "src/test_order_matching_engine.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\ndef pack_vector(orders, width):\n    \"\"\"\n    Pack a list of integers (orders[0] ... orders[7]) into a flat integer.\n    The flat vector is constructed as {orders[7], orders[6], ..., orders[0]}\n    so that orders[0] occupies the least-significant bits.\n    \"\"\"\n    value = 0\n    for order in orders[::-1]:\n        value = (value << width) | (order & ((1 << width) - 1))\n    return value\n\ndef scale_orders(orders, max_val):\n    \"\"\"\n    Scale a list of order percentages (0-100) into the range [0, max_val].\n    \"\"\"\n    return [int(val * max_val / 100) for val in orders]\n\n@cocotb.test()\nasync def test_order_matching_engine(dut):\n    \"\"\"\n    Cocotb testbench for order_matching_engine.\n    This test applies several corner-case and random test vectors,\n    verifies that the matching result (match_valid and matched_price)\n    is correct, and checks that the overall latency from start to done\n    is exactly 10 cycles.\n    \"\"\"\n    # Create and start clock (10 ns period)\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Retrieve PRICE_WIDTH parameter from DUT (default to 16)\n    try:\n        price_width = int(dut.PRICE_WIDTH.value)\n    except Exception as e:\n        dut._log.warning(\"Unable to read PRICE_WIDTH parameter, defaulting to 16. Error: %s\", e)\n        price_width = 16\n\n    max_val = (1 << price_width) - 1\n    NUM_ELEMS = 8\n\n    # Helper: Measure latency from start pulse to when done is asserted.\n    async def measure_latency():\n        cycle_count = 0\n        while int(dut.done.value) == 0:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n        return cycle_count\n\n    # Define test cases.\n    tests = []\n\n    #-----------------------------------------------------------------------\n    # 1) Normal matching scenario (circuit_breaker=0)\n    #    bid: [42,74,10,21,108,53,95,106]\n    #    ask: [130,108,205,129,192,213,244,141]\n    #\n    #    Here we expect a valid match, with matched_price = 108\n    #    (assuming best bid >= best ask).\n    #-----------------------------------------------------------------------\n    tests.append({\n        \"description\": \"Matching scenario: valid match, circuit breaker off\",\n        \"bid\": scale_orders([42,74,10,21,108,53,95,106], 100),\n        \"ask\": scale_orders([130,108,205,129,192,213,244,141], 100),\n        \"circuit_breaker\": 0,\n        \"expected_match\": True,\n        \"expected_price\": 108\n    })\n\n    #-----------------------------------------------------------------------\n    # 2) Circuit breaker scenario\n    #    Even though best_bid >= best_ask, circuit_breaker=1 must block the match.\n    #\n    #    bid: [80,90,100,85,95,81,99,120]\n    #    ask: [70,75,60,65,64,68,66,72]\n    #\n    #    Normally, best_bid=120, best_ask=60 => match_valid=1, matched_price=120.\n    #    But with circuit_breaker=1, match_valid must be 0.\n    #-----------------------------------------------------------------------\n    tests.append({\n        \"description\": \"Circuit breaker scenario: best bid >= best ask but breaker is active\",\n        \"bid\": scale_orders([80,90,100,85,95,81,99,120], 100),\n        \"ask\": scale_orders([70,75,60,65,64,68,66,72], 100),\n        \"circuit_breaker\": 1,\n        \"expected_match\": False,\n        \"expected_price\": 0\n    })\n\n    #-----------------------------------------------------------------------\n    # Additional tests can be appended here if needed\n    #-----------------------------------------------------------------------\n\n    # Iterate through each test case.\n    for test in tests:\n        dut._log.info(\"---------------------------------------------------\")\n        dut._log.info(\"Starting test: %s\", test[\"description\"])\n\n        # Pack bid and ask orders.\n        bid_flat = pack_vector(test[\"bid\"], price_width)\n        ask_flat = pack_vector(test[\"ask\"], price_width)\n\n        # Drive the inputs.\n        dut.bid_orders.value = bid_flat\n        dut.ask_orders.value = ask_flat\n        dut.circuit_breaker.value = test[\"circuit_breaker\"]\n\n        # Apply a reset before starting the test.\n        dut.rst.value = 1\n        dut.start.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst.value = 0\n        await RisingEdge(dut.clk)\n\n        # Issue the start pulse.\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        # Measure latency.\n        latency = await measure_latency()\n        dut._log.info(\"Test '%s': Measured latency = %d cycles\", test[\"description\"], latency)\n        assert latency == 13, f\"Latency error in test '{test['description']}': expected 10 cycles, got {latency}\"\n\n        # Retrieve matching outputs.\n        match_valid = int(dut.match_valid.value)\n        matched_price = int(dut.matched_price.value)\n\n        # Compute expected matching result from test vector\n        exp_match_valid = 1 if test[\"expected_match\"] else 0\n        exp_matched_price = test[\"expected_price\"]\n\n        # Check matching result.\n        assert match_valid == exp_match_valid, \\\n            f\"Test '{test['description']}' failed: Expected match_valid {exp_match_valid}, got {match_valid}\"\n        if match_valid:\n            assert matched_price == exp_matched_price, \\\n                f\"Test '{test['description']}' failed: Expected matched_price {exp_matched_price}, got {matched_price}\"\n\n        dut._log.info(\"Test '%s' PASSED: match_valid=%d, matched_price=%d\",\n                      test[\"description\"], match_valid, matched_price)\n\n        # Wait a few cycles before the next test.\n        await Timer(20, units=\"ns\")\n\n    dut._log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner(PRICE_WIDTH: int=8):\n    \n    parameter = {\"PRICE_WIDTH\":PRICE_WIDTH}\n    # Debug information\n    print(f\"[DEBUG] Running simulation with PRICE_WIDTH={PRICE_WIDTH}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        parameters=parameter,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Parametrize test for different PRICE_WIDTH\n@pytest.mark.parametrize(\"PRICE_WIDTH\", [8])\n\ndef test_sort(PRICE_WIDTH):\n    # Run the simulation with specified parameters\n    test_runner(PRICE_WIDTH=PRICE_WIDTH)\n", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_swizzler_0005", "categories": ["cid005", "medium"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a **swizzler** module that performs complex cross-correlation and energy computation over input I/Q data. This module handles the internal processing logic required for computing correlation with conjugate reference sequences. It unpacks the input data into individual lanes, applies a swizzle map for remapping the lanes, detects invalid mappings, computes parity errors (if enabled), and finally performs a bit reversal on each lane before packing the data back into a flat output vector. The **swizzler** module is available at `/rtl/swizzler.sv` and its detailed specification is provided in the `/docs` directory.\n\nCan you implement a top-level module called **`swizzler_supervisor`** ? The supervisor should integrate the **swizzler** module and augment its functionality with additional glue logic as described below.\n\nThe **swizzler_supervisor** module is designed to enhance the raw functionality of the **swizzler** subcomponent by:\n  \n- **Input Handling:**  \n  - Pre-processing the input I/Q data to ensure proper formatting and conditioning prior to processing by the swizzler.\n  - Applying potential reordering or scaling operations to align with the swizzler\u2019s processing requirements.\n\n- **Processing the Swizzler's Output:**  \n  - Performing post-processing on the swizzler\u2019s output, which includes computing a checksum across all lanes.\n  - Comparing the computed checksum with a pre-defined expected value.\n  - Generating error flags if a parity error, invalid mapping, or checksum mismatch is detected.\n  - Applying additional bit manipulations (such as inverting the least significant bit in each lane) to produce the final data output.\n\n- **Parameterization:**  \n  - The design must be fully parameterizable to adapt to various configurations. Key parameters include:\n    - **NUM_LANES**: Number of data lanes.\n    - **DATA_WIDTH**: Bit-width of each lane.\n    - **REGISTER_OUTPUT**: Option to pipeline outputs.\n    - **ENABLE_PARITY_CHECK**: Toggle for parity error computation.\n    - **OP_MODE_WIDTH**: Width of the operation mode signal.\n    - **SWIZZLE_MAP_WIDTH**: Derived width for swizzle mapping.\n    - **EXPECTED_CHECKSUM**: The checksum value against which the output is verified.\n\n- **Error Supervision:**  \n  - Integrate supervisory logic that validates the swizzler output by comparing the computed checksum with the expected value.\n  - Assert a top-level error signal if any discrepancies arise (i.e., parity errors, invalid mapping errors, or checksum mismatches).\n\n```verilog\nmodule swizzler_supervisor #(\n  parameter integer NUM_LANES           = 4,\n  parameter integer DATA_WIDTH          = 8,\n  parameter integer REGISTER_OUTPUT     = 1,\n  parameter integer ENABLE_PARITY_CHECK = 1,\n  parameter integer OP_MODE_WIDTH       = 2,\n  parameter integer SWIZZLE_MAP_WIDTH   = $clog2(NUM_LANES)+1,\n  parameter [DATA_WIDTH-1:0] EXPECTED_CHECKSUM = 8'hA5\n)(\n  input  wire                           clk,\n  input  wire                           rst_n,\n  input  wire                           bypass,\n  input  wire [NUM_LANES*DATA_WIDTH-1:0] data_in,\n  input  wire [NUM_LANES*SWIZZLE_MAP_WIDTH-1:0] swizzle_map_flat,\n  input  wire [OP_MODE_WIDTH-1:0]         operation_mode,\n  output reg  [NUM_LANES*DATA_WIDTH-1:0]  final_data_out,\n  output reg                            top_error\n);\n  // [Internal implementation...]\nendmodule\n```\n\nPlease refer to `docs/swizzler_specification.md` for detailed design requirements and specifications of the subcomponent swizzler. \n", "context": {"docs/swizzler_specification.md": "# Swizzler Specification Document\n\n## Introduction\n\nThe Swizzler module is a configurable hardware component designed to perform lane remapping (swizzling) on a multi-lane data bus. It allows for flexible data routing by rearranging the input data lanes according to an encoded swizzle map. This version of the Swizzler adds advanced features including an operation mode input for additional control, invalid mapping detection, a three-stage pipeline with bit reversal processing, and optional parity checking and output registering.\n\n## Functional Overview\n\n1. **Data Unpacking:**  \n   The flat input bus (`data_in`) is partitioned into individual data lanes. Each lane is extracted based on the defined data width.\n\n2. **Swizzle Map Unpacking:**  \n   The encoded flat swizzle map (`swizzle_map_flat`) is converted into an array of mapping values. The width of each element is defined as `$clog2(NUM_LANES)+1`, which provides extra bits for error detection.\n\n3. **Invalid Mapping Detection:**  \n   Each element of the swizzle map is compared against `NUM_LANES` to detect invalid mapping values. If any element is out of the valid range, an invalid mapping flag is raised and later captured by the pipeline.\n\n4. **Lane Remapping:**  \n   In normal operation, the module remaps the input lanes based on the swizzle map. When the `bypass` signal is asserted, the input lanes pass through unchanged. The lower bits of each mapping element are used as the valid index for lane selection.\n\n5. **Pipeline Stage 1:**  \n   The remapped (or bypassed) lanes are captured into a set of registers. This stage creates a buffered version of the swizzled lanes that can be further processed.\n\n6. **Pipeline Stage 2:**  \n   The current `operation_mode` is captured into a register along with the invalid mapping detection signal. This stage isolates control and error status information before final processing.\n\n7. **Bit Reversal:**  \n   A bit reversal function processes each lane. In the final pipeline stage, the bits of each captured lane are reversed to produce the final output data.\n\n8. **Pipeline Stage 3:**  \n   The bit-reversed lanes are stored in a final set of registers, which are then repacked into the flat output bus (`data_out`). Depending on the configuration, the final output may be registered or directly passed through combinational logic.\n\n9. **Optional Parity Checking:**  \n   When parity checking is enabled, the module calculates the parity for each final output lane. If any lane has nonzero parity, the `parity_error` output is asserted.\n\n10. **Invalid Mapping Error Output:**  \n    The result of invalid mapping detection is propagated to the top level via the `invalid_mapping_error` output, signaling if any swizzle map element is outside the allowed range.\n\n## Module Interface\n\n### Parameters\n\n- **NUM_LANES**  \n  Number of data lanes in the module.\n\n- **DATA_WIDTH**  \n  Width of each data lane in bits.\n\n- **REGISTER_OUTPUT**  \n  Determines whether the final output data is registered. If set to 1, data is clocked out; if 0, data is passed combinationally.\n\n- **ENABLE_PARITY_CHECK**  \n  Enables parity error detection across the output lanes when set to 1.\n\n- **OP_MODE_WIDTH**  \n  Defines the width of the operation mode input, used for auxiliary control purposes.\n\n- **SWIZZLE_MAP_WIDTH**  \n  Calculated as `$clog2(NUM_LANES)+1`, this defines the width of each element in the swizzle map, allowing for error detection by providing an extra bit.\n\n### Ports\n\n- **clk (input):**  \n  Clock signal for synchronizing operations.\n\n- **rst_n (input):**  \n  Active-low reset that initializes internal registers.\n\n- **bypass (input):**  \n  When asserted, the module bypasses the swizzling logic and forwards the input lanes directly to the output.\n\n- **data_in (input):**  \n  Flat data input bus with a width of `NUM_LANES * DATA_WIDTH`.\n\n- **swizzle_map_flat (input):**  \n  Flat swizzle map with a width of `NUM_LANES * SWIZZLE_MAP_WIDTH` which specifies the remapping of input lanes.\n\n- **operation_mode (input):**  \n  Input specifying the operational mode. Captured and used in pipeline stage 2 for additional control.\n\n- **data_out (output):**  \n  Flat data output bus with a width of `NUM_LANES * DATA_WIDTH` that carries the processed (remapped and bit-reversed) data.\n\n- **parity_error (output):**  \n  When parity checking is enabled, this output is asserted if any lane\u2019s computed parity is nonzero.\n\n- **invalid_mapping_error (output):**  \n  Indicates that one or more elements in the swizzle map contained an invalid mapping (i.e., a mapping value not less than NUM_LANES).\n\n```verilog\nmodule swizzler #(\n  parameter integer NUM_LANES           = 4,\n  parameter integer DATA_WIDTH          = 8,\n  parameter integer REGISTER_OUTPUT     = 0,\n  parameter integer ENABLE_PARITY_CHECK = 0,\n  parameter integer OP_MODE_WIDTH       = 2,\n  parameter integer SWIZZLE_MAP_WIDTH   = $clog2(NUM_LANES)+1\n)(\n  input  wire                           clk,\n  input  wire                           rst_n,\n  input  wire                           bypass,\n  input  wire [NUM_LANES*DATA_WIDTH-1:0]  data_in,\n  input  wire [NUM_LANES*SWIZZLE_MAP_WIDTH-1:0] swizzle_map_flat,\n  input  wire [OP_MODE_WIDTH-1:0]         operation_mode,\n  output reg  [NUM_LANES*DATA_WIDTH-1:0]  data_out,\n  output reg                            parity_error,\n  output reg                            invalid_mapping_error\n);\n  // Internal RTL implementation as described in the functional overview.\nendmodule", "rtl/swizzler.sv": "`timescale 1ns/1ps\n\nmodule swizzler #(\n  parameter integer NUM_LANES           = 4,\n  parameter integer DATA_WIDTH          = 8,\n  parameter integer REGISTER_OUTPUT     = 0,\n  parameter integer ENABLE_PARITY_CHECK = 0,\n  parameter integer OP_MODE_WIDTH       = 2,\n  parameter integer SWIZZLE_MAP_WIDTH   = $clog2(NUM_LANES)+1\n)(\n  input  wire                           clk,\n  input  wire                           rst_n,\n  input  wire                           bypass,\n  input  wire [NUM_LANES*DATA_WIDTH-1:0]  data_in,\n  input  wire [NUM_LANES*SWIZZLE_MAP_WIDTH-1:0] swizzle_map_flat,\n  input  wire [OP_MODE_WIDTH-1:0]         operation_mode,\n  output reg  [NUM_LANES*DATA_WIDTH-1:0]  data_out,\n  output reg                            parity_error,\n  output reg                            invalid_mapping_error\n);\n\n  // Unpack data_in into lanes\n  wire [DATA_WIDTH-1:0] lane_in [0:NUM_LANES-1];\n  genvar gi;\n  generate\n    for (gi = 0; gi < NUM_LANES; gi = gi + 1) begin : UNPACK_INPUT\n      assign lane_in[gi] = data_in[DATA_WIDTH*(gi+1)-1 : DATA_WIDTH*gi];\n    end\n  endgenerate\n\n  // Unpack swizzle_map_flat into swizzle_map array\n  wire [SWIZZLE_MAP_WIDTH-1:0] swizzle_map [0:NUM_LANES-1];\n  generate\n    for (gi = 0; gi < NUM_LANES; gi = gi + 1) begin : UNPACK_SWIZZLE\n      assign swizzle_map[gi] = swizzle_map_flat[SWIZZLE_MAP_WIDTH*(gi+1)-1 : SWIZZLE_MAP_WIDTH*gi];\n    end\n  endgenerate\n\n  // Invalid mapping detection\n  wire [NUM_LANES-1:0] invalid_map_flag;\n  generate\n    for (gi = 0; gi < NUM_LANES; gi = gi + 1) begin : INVALID_CHECK\n      assign invalid_map_flag[gi] = (swizzle_map[gi] >= NUM_LANES) ? 1'b1 : 1'b0;\n    end\n  endgenerate\n  wire invalid_mapping_detected = |invalid_map_flag;\n\n  // Remap lanes according to swizzle_map or bypass\n  wire [DATA_WIDTH-1:0] swizzled [0:NUM_LANES-1];\n  generate\n    for (gi = 0; gi < NUM_LANES; gi = gi + 1) begin : REMAP\n      // Use lower bits of swizzle_map to index valid lanes.\n      assign swizzled[gi] = bypass ? lane_in[gi] : lane_in[ swizzle_map[gi][$clog2(NUM_LANES)-1:0] ];\n    end\n  endgenerate\n\n  // Pipeline Stage 1: Capture swizzled lanes\n  reg [DATA_WIDTH-1:0] swizzle_reg [0:NUM_LANES-1];\n  integer i;\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      for (i = 0; i < NUM_LANES; i = i + 1)\n        swizzle_reg[i] <= {DATA_WIDTH{1'b0}};\n    else\n      for (i = 0; i < NUM_LANES; i = i + 1)\n        swizzle_reg[i] <= swizzled[i];\n  end\n\n  // Pipeline Stage 2: Capture operation mode and invalid mapping status\n  reg [OP_MODE_WIDTH-1:0] op_reg;\n  reg op_invalid_reg;\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      op_reg <= {OP_MODE_WIDTH{1'b0}};\n      op_invalid_reg <= 1'b0;\n    end else begin\n      op_reg <= operation_mode;\n      op_invalid_reg <= invalid_mapping_detected;\n    end\n  end\n\n  // Bit reversal function\n  function automatic [DATA_WIDTH-1:0] bit_reverse;\n    input [DATA_WIDTH-1:0] in;\n    integer k;\n    begin\n      bit_reverse = {DATA_WIDTH{1'b0}};\n      for (k = 0; k < DATA_WIDTH; k = k + 1)\n        bit_reverse[k] = in[DATA_WIDTH-1-k];\n    end\n  endfunction\n\n  // Pipeline Stage 3: Final output stage with bit reversal\n  reg [DATA_WIDTH-1:0] final_reg [0:NUM_LANES-1];\n  integer m;\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      for (m = 0; m < NUM_LANES; m = m + 1)\n        final_reg[m] <= {DATA_WIDTH{1'b0}};\n    else\n      for (m = 0; m < NUM_LANES; m = m + 1)\n        final_reg[m] <= bit_reverse(swizzle_reg[m]);\n  end\n\n  // Pack final_reg into a flat output vector\n  wire [NUM_LANES*DATA_WIDTH-1:0] final_packed;\n  genvar q;\n  generate\n    for (q = 0; q < NUM_LANES; q = q + 1) begin : PACK_FINAL\n      assign final_packed[DATA_WIDTH*(q+1)-1 : DATA_WIDTH*q] = final_reg[q];\n    end\n  endgenerate\n\n  generate\n    if (REGISTER_OUTPUT) begin : REG_FINAL\n      always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n          data_out <= {NUM_LANES*DATA_WIDTH{1'b0}};\n        else\n          data_out <= final_packed;\n      end\n    end else begin : COMB_FINAL\n      always @* begin\n        data_out = final_packed;\n      end\n    end\n  endgenerate\n\n  // Updated parity error calculation using a generate block\n  generate\n    if (ENABLE_PARITY_CHECK) begin : GEN_PARITY\n      // Calculate parity from final_reg if parity check is enabled.\n      wire [NUM_LANES-1:0] final_parity;\n      genvar p;\n      for (p = 0; p < NUM_LANES; p = p + 1) begin : PARITY_CALC\n        assign final_parity[p] = ^final_reg[p];\n      end\n      wire computed_parity = |final_parity;\n      always @* begin\n        parity_error = computed_parity;\n      end\n    end else begin : NO_PARITY\n      // Drive parity_error to 0 when parity check is disabled.\n      always @* begin\n        parity_error = 1'b0;\n      end\n    end\n  endgenerate\n\n  // Pass the invalid mapping flag\n  always @* begin\n    invalid_mapping_error = op_invalid_reg;\n  end\n\nendmodule", "verif/swizzler_tb.sv": "`timescale 1ns/1ps\n\nmodule tb_swizzler;\n  parameter NUM_LANES = 4;\n  parameter DATA_WIDTH = 8;\n  parameter REGISTER_OUTPUT = 1;\n  parameter ENABLE_PARITY_CHECK = 0;\n  parameter OP_MODE_WIDTH = 2;\n  parameter SWIZZLE_MAP_WIDTH = 3;\n\n  reg clk;\n  reg rst_n;\n  reg bypass;\n  reg [NUM_LANES*DATA_WIDTH-1:0] data_in;\n  reg [NUM_LANES*SWIZZLE_MAP_WIDTH-1:0] swizzle_map_flat;\n  reg [OP_MODE_WIDTH-1:0] operation_mode;\n  wire [NUM_LANES*DATA_WIDTH-1:0] data_out;\n  wire parity_error;\n  wire invalid_mapping_error;\n\n  swizzler #(\n    .NUM_LANES(NUM_LANES),\n    .DATA_WIDTH(DATA_WIDTH),\n    .REGISTER_OUTPUT(REGISTER_OUTPUT),\n    .ENABLE_PARITY_CHECK(ENABLE_PARITY_CHECK),\n    .OP_MODE_WIDTH(OP_MODE_WIDTH),\n    .SWIZZLE_MAP_WIDTH(SWIZZLE_MAP_WIDTH)\n  ) dut (\n    .clk(clk),\n    .rst_n(rst_n),\n    .bypass(bypass),\n    .data_in(data_in),\n    .swizzle_map_flat(swizzle_map_flat),\n    .operation_mode(operation_mode),\n    .data_out(data_out),\n    .parity_error(parity_error),\n    .invalid_mapping_error(invalid_mapping_error)\n  );\n\n  reg [DATA_WIDTH-1:0] expected [0:NUM_LANES-1];\n  reg [DATA_WIDTH-1:0] out_lane [0:NUM_LANES-1];\n  integer i;\n\n  function [DATA_WIDTH-1:0] bit_reverse;\n    input [DATA_WIDTH-1:0] in;\n    integer j;\n    reg [DATA_WIDTH-1:0] out;\n    begin\n      out = 0;\n      for(j = 0; j < DATA_WIDTH; j = j + 1)\n        out[j] = in[DATA_WIDTH-1-j];\n      bit_reverse = out;\n    end\n  endfunction\n\n  function [DATA_WIDTH-1:0] get_lane;\n    input integer index;\n    begin\n      get_lane = data_out[DATA_WIDTH*(index+1)-1 -: DATA_WIDTH];\n    end\n  endfunction\n\n  initial begin\n    clk = 0;\n    forever #5 clk = ~clk;\n  end\n\n  initial begin\n    rst_n = 0;\n    bypass = 0;\n    data_in = 0;\n    swizzle_map_flat = 0;\n    operation_mode = 0;\n    #12;\n    rst_n = 1;\n    repeat (5) @(posedge clk);\n    // TEST 1: Bypass disabled, identity mapping with bit reversal.\n    data_in = {8'h04, 8'h03, 8'h02, 8'h01};\n    swizzle_map_flat = {3'b011, 3'b010, 3'b001, 3'b000};\n    bypass = 0;\n    operation_mode = 0;\n    repeat (5) @(posedge clk);\n    for(i = 0; i < NUM_LANES; i = i + 1)\n      out_lane[i] = get_lane(i);\n    expected[0] = bit_reverse(8'h01);\n    expected[1] = bit_reverse(8'h02);\n    expected[2] = bit_reverse(8'h03);\n    expected[3] = bit_reverse(8'h04);\n    if(out_lane[0]==expected[0] && out_lane[1]==expected[1] &&\n       out_lane[2]==expected[2] && out_lane[3]==expected[3])\n      $display(\"TEST 1 PASS\");\n    else\n      $display(\"TEST 1 FAIL: Expected %h %h %h %h, Got %h %h %h %h\",\n               expected[0], expected[1], expected[2], expected[3],\n               out_lane[0], out_lane[1], out_lane[2], out_lane[3]);\n    if(invalid_mapping_error==0)\n      $display(\"TEST 1 INVALID MAPPING PASS\");\n    else\n      $display(\"TEST 1 INVALID MAPPING FAIL\");\n\n    // TEST 2: Reverse mapping.\n    data_in = {8'hAA, 8'hBB, 8'hCC, 8'hDD};\n    swizzle_map_flat = {3'b000, 3'b001, 3'b010, 3'b011};\n    bypass = 0;\n    operation_mode = 0;\n    repeat (5) @(posedge clk);\n    for(i = 0; i < NUM_LANES; i = i + 1)\n      out_lane[i] = get_lane(i);\n    // Expected output is reversed compared to input lane order.\n    expected[0] = bit_reverse(8'hAA);\n    expected[1] = bit_reverse(8'hBB);\n    expected[2] = bit_reverse(8'hCC);\n    expected[3] = bit_reverse(8'hDD);\n    if(out_lane[0]==expected[0] && out_lane[1]==expected[1] &&\n       out_lane[2]==expected[2] && out_lane[3]==expected[3])\n      $display(\"TEST 2 PASS\");\n    else\n      $display(\"TEST 2 FAIL: Expected %h %h %h %h, Got %h %h %h %h\",\n               expected[0], expected[1], expected[2], expected[3],\n               out_lane[0], out_lane[1], out_lane[2], out_lane[3]);\n\n    // TEST 3: Bypass mode active.\n    data_in = {8'h11, 8'h22, 8'h33, 8'h44};\n    swizzle_map_flat = {3'b001, 3'b000, 3'b011, 3'b010};\n    bypass = 1;\n    operation_mode = 0;\n    repeat (5) @(posedge clk);\n    for(i = 0; i < NUM_LANES; i = i + 1)\n      out_lane[i] = get_lane(i);\n    expected[0] = bit_reverse(8'h44);\n    expected[1] = bit_reverse(8'h33);\n    expected[2] = bit_reverse(8'h22);\n    expected[3] = bit_reverse(8'h11);\n    if(out_lane[0]==expected[0] && out_lane[1]==expected[1] &&\n       out_lane[2]==expected[2] && out_lane[3]==expected[3])\n      $display(\"TEST 3 PASS\");\n    else\n      $display(\"TEST 3 FAIL: Expected %h %h %h %h, Got %h %h %h %h\",\n               expected[0], expected[1], expected[2], expected[3],\n               out_lane[0], out_lane[1], out_lane[2], out_lane[3]);\n\n    // TEST 4: Invalid mapping detection.\n    data_in = {8'h55, 8'h66, 8'h77, 8'h88};\n    swizzle_map_flat = {3'b011, 3'b010, 3'b001, 3'b100};\n    bypass = 0;\n    operation_mode = 0;\n    repeat (5) @(posedge clk);\n    if(invalid_mapping_error==1)\n      $display(\"TEST 4 PASS: Invalid mapping detected\");\n    else\n      $display(\"TEST 4 FAIL: Invalid mapping not detected\");\n    $finish;\n  end\n\nendmodule"}, "patch": {"rtl/swizzler_supervisor.sv": ""}, "harness": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\nRUN pip install cocotb-bus", "docker-compose.yml": "services:\n\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/swizzler.sv /code/rtl/swizzler_supervisor.sv\nTOPLEVEL        = swizzler_supervisor\nMODULE          = test_swizzler_supervisor\nPYTHONPATH      = /src\nHASH            = 5-integration-of-swizzler-module-in-to-swizzler-based-processor", "src/test_runner.py": "import os\nfrom cocotb.runner import get_runner\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\", \"\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\", \"1\")\n\nbuild_clean     = os.getenv(\"BUILD_CLEAN\", \"1\") == \"1\"\nbuild_always    = os.getenv(\"BUILD_ALWAYS\", \"1\") == \"1\"\nbuild_verbose   = os.getenv(\"BUILD_VERBOSE\", \"1\") == \"1\"\ntimescale_env   = os.getenv(\"TIMESCALE\", \"1ns,1ns\").split(\",\")\nlog_file        = os.getenv(\"LOG_FILE\", \"build.log\")\n\ndef test_runner():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=build_always,\n        clean=build_clean,\n        waves=(wave==\"1\"),\n        verbose=build_verbose,\n        timescale=(timescale_env[0], timescale_env[1]),\n        log_file=log_file\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=(wave==\"1\"))\n\nif __name__ == \"__main__\":\n    test_runner()\n", "src/test_swizzler_supervisor.py": "import os\nos.environ[\"COCOTB_RESOLVE_X\"] = \"0\"\n\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n@cocotb.test()\nasync def test_basic(dut):\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    dut.rst_n.value = 0\n    await Timer(20, units=\"ns\")\n    dut.rst_n.value = 1\n    await RisingEdge(dut.clk)\n    dut.bypass.value = 0\n    dut.data_in.value = int(\"55\" * 4, 16)\n    mapping = (3 << (3*3)) | (2 << (2*3)) | (1 << (1*3)) | (0 << (0*3))\n    dut.swizzle_map_flat.value = mapping\n    dut.operation_mode.value = 0\n    # Wait several clock cycles for pipelined state machine to update\n    for _ in range(5):\n        await RisingEdge(dut.clk)\n    value_str = dut.final_data_out.value.binstr.replace(\"x\", \"0\")\n    sw_out = int(value_str, 2)\n    checksum = 0\n    for i in range(4):\n        lane = (sw_out >> (i*8)) & 0xFF\n        checksum ^= lane\n    expected_top = 0 if (checksum == int(dut.EXPECTED_CHECKSUM.value)) else 1\n    assert int(dut.top_error.value) == expected_top, f\"Basic test failed: checksum={hex(checksum)} EXPECTED={hex(int(dut.EXPECTED_CHECKSUM.value))} top_error={dut.top_error.value}\"\n    dut._log.info(f\"Basic test passed: final_data_out={hex(sw_out)} checksum={hex(checksum)} top_error={dut.top_error.value}\")\n\n@cocotb.test()\nasync def test_random(dut):\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    dut.rst_n.value = 0\n    await Timer(20, units=\"ns\")\n    dut.rst_n.value = 1\n    await RisingEdge(dut.clk)\n    for i in range(10):\n        dut.bypass.value = random.randint(0,1)\n        data = 0\n        for j in range(4):\n            data = (data << 8) | random.randint(0,255)\n        dut.data_in.value = data\n        mapping = 0\n        for j in range(4):\n            mapping |= (random.randint(0,3) << (j*3))\n        dut.swizzle_map_flat.value = mapping\n        dut.operation_mode.value = random.randint(0,3)\n        await Timer(40, units=\"ns\")\n        # Wait an extra cycle for state machine update\n        await RisingEdge(dut.clk)\n        value_str = dut.final_data_out.value.binstr.replace(\"x\", \"0\")\n        sw_out = int(value_str, 2)\n        checksum = 0\n        for j in range(4):\n            lane = (sw_out >> (j*8)) & 0xFF\n            checksum ^= lane\n        exp_top = 0 if (checksum == int(dut.EXPECTED_CHECKSUM.value)) else 1\n        assert int(dut.top_error.value) == exp_top, f\"Random test iteration {i} failed: checksum={hex(checksum)} EXPECTED={hex(int(dut.EXPECTED_CHECKSUM.value))} top_error={dut.top_error.value}\"\n        dut._log.info(f\"Random test iteration {i} passed: final_data_out={hex(sw_out)} checksum={hex(checksum)} top_error={dut.top_error.value}\")\n\n@cocotb.test()\nasync def test_edge(dut):\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    dut.rst_n.value = 0\n    await Timer(20, units=\"ns\")\n    dut.rst_n.value = 1\n    await RisingEdge(dut.clk)\n    dut.bypass.value = 0\n    dut.data_in.value = int(\"AA\" * 4, 16)\n    mapping = (3 << (3*3)) | (3 << (2*3)) | (2 << (1*3)) | (4 << (0*3))\n    dut.swizzle_map_flat.value = mapping\n    dut.operation_mode.value = 0\n    await Timer(40, units=\"ns\")\n    # Wait an extra cycle for update\n    await RisingEdge(dut.clk)\n    assert int(dut.top_error.value) == 1, f\"Edge test failed: expected top_error=1, got {dut.top_error.value}\"\n    dut._log.info(f\"Edge test passed: final_data_out={hex(int(dut.final_data_out.value))} top_error={dut.top_error.value}\")\n", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR=''\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
{"id": "cvdp_agentic_systolic_array_0001", "categories": ["cid005", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  Your task is to create a Verilog module based on the provided specifications and integrate it into an existing system using proper module instantiation and connections. At the end, please prepare a Linux patch file for me to finalize the request. \n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I need to implement a **systolic array architecture** for **matrix multiplication acceleration** by integrating four **`weight_stationary_pe`** processing elements (PEs) in a **2x2 configuration**. Each PE performs **multiply-accumulate (MAC) operations** and passes intermediate results to its neighboring PE in a wavefront manner. The system should correctly **load weights, propagate input data, accumulate partial sums, and assert the `done` signal** when computations are complete.  \n\nI have the **Processing Element module at `/code/rtl/weight_stationary_pe.sv`** and need to create the **top-level `systolic_array.sv` module**. This module must **instantiate and connect all 4 PEs**, ensure **proper data flow and synchronization**, and implement **latency-aware pipeline control**. To verify functionality, a testbench is available at **/code/verif/systolic_array_tb.sv`**. The final design should use **registered outputs for `y0` and `y1`**, maintain **low-latency operation**, and assert `done` after the computation cycles complete. \n", "context": {"rtl/weight_stationary_pe.sv": "`timescale 1ns/1ns\n\n//-----------------------------\n// Processing Element\n//-----------------------------\nmodule weight_stationary_pe #(\n  parameter DATA_WIDTH = 8  // Bit width of weights and activations\n)\n(\n  input  wire                 clk,\n  input  wire                 reset,\n  input  wire                 load_weight,   // load the weight into the PE if high\n  input  wire                 valid,         // signal to indicate new data is valid\n\n  input  wire [DATA_WIDTH-1:0] input_in,     // input from left PE or from memory\n  input  wire [DATA_WIDTH-1:0] weight,       // new weight to be loaded\n  input  wire [DATA_WIDTH-1:0] psum_in,      // accumulated sum from the PE above\n\n  output reg  [DATA_WIDTH-1:0] input_out,    // pass input to the right PE\n  output reg  [DATA_WIDTH-1:0] psum_out      // pass accumulated sum downward\n);\n\n  reg [DATA_WIDTH-1:0] weight_reg; // register for holding weight locally\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      weight_reg <= {DATA_WIDTH{1'b0}};\n      input_out  <= {DATA_WIDTH{1'b0}};\n      psum_out   <= {DATA_WIDTH{1'b0}};\n    end \n    else begin\n      // Load the new weight if load_weight is high\n      if (load_weight) begin\n        weight_reg <= weight;\n      end\n\n      // Only update psum_out and input_out if 'valid' is high\n      if (valid) begin\n        psum_out  <= psum_in + (input_in * weight_reg);\n        input_out <= input_in;\n      end\n      else begin\n        // Hold the old values when not valid\n        psum_out  <= psum_out;\n        input_out <= input_out;\n      end\n    end\n  end\n\nendmodule", "verif/systolic_array_tb.sv": "`timescale 1ns/1ns\n\nmodule systolic_array_tb;\n\n  // --------------------------------------------------------------------------\n  // Parameters & Local Variables\n  // --------------------------------------------------------------------------\n  localparam DATA_WIDTH = 8;\n  localparam CLK_PERIOD = 10;  // 10 ns = 100 MHz\n\n  // We'll run multiple tests in sequence.\n  // For each test, we store:\n  //    w00, w01, w10, w11, x0, x1, and the expected y0, y1\n  // The results are: \n  //    y0 = (x0 * w00) + (x1 * w10)\n  //    y1 = (x0 * w01) + (x1 * w11)\n  //\n  // NOTE: In the provided design, psum_out is only 8 bits, so the results\n  //       may wrap around (overflow) if the sum exceeds 8 bits (255 for unsigned).\n  //       If you want to test overflow behavior, see the last test case.\n\n  // We'll store multiple test vectors in arrays.\n  // Increase TEST_COUNT if you add more test vectors.\n  localparam TEST_COUNT = 7;\n\n  reg [DATA_WIDTH-1:0] w00_test [0:TEST_COUNT-1];\n  reg [DATA_WIDTH-1:0] w01_test [0:TEST_COUNT-1];\n  reg [DATA_WIDTH-1:0] w10_test [0:TEST_COUNT-1];\n  reg [DATA_WIDTH-1:0] w11_test [0:TEST_COUNT-1];\n  reg [DATA_WIDTH-1:0] x0_test  [0:TEST_COUNT-1];\n  reg [DATA_WIDTH-1:0] x1_test  [0:TEST_COUNT-1];\n  reg [DATA_WIDTH-1:0] y0_exp   [0:TEST_COUNT-1];\n  reg [DATA_WIDTH-1:0] y1_exp   [0:TEST_COUNT-1];\n\n  // --------------------------------------------------------------------------\n  // Testbench signals\n  // --------------------------------------------------------------------------\n  reg                      clk;\n  reg                      reset;\n  reg                      load_weights;\n  reg                      start;\n  reg  [DATA_WIDTH-1:0]    w00, w01, w10, w11;\n  reg  [DATA_WIDTH-1:0]    x0,  x1;\n  wire [DATA_WIDTH-1:0]    y0,  y1;\n  wire                     done;\n\n  // --------------------------------------------------------------------------\n  // Instantiate the DUT (Device Under Test)\n  // --------------------------------------------------------------------------\n  systolic_array #(\n    .DATA_WIDTH(DATA_WIDTH)\n  ) dut (\n    .clk         (clk),\n    .reset       (reset),\n    .load_weights(load_weights),\n    .start       (start),\n    .w00         (w00),\n    .w01         (w01),\n    .w10         (w10),\n    .w11         (w11),\n    .x0          (x0),\n    .x1          (x1),\n    .y0          (y0),\n    .y1          (y1),\n    .done        (done)\n  );\n\n  // --------------------------------------------------------------------------\n  // Clock Generation\n  // --------------------------------------------------------------------------\n  always begin\n    clk = 1'b0; \n    #(CLK_PERIOD/2);\n    clk = 1'b1; \n    #(CLK_PERIOD/2);\n  end\n\n  // --------------------------------------------------------------------------\n  // Test Vector Initialization\n  // --------------------------------------------------------------------------\n  initial begin\n    // Test 0: Simple: All weights = 1, x0=2, x1=3\n    //   y0 = 2*1 + 3*1 = 5\n    //   y1 = 2*1 + 3*1 = 5\n    w00_test[0] = 8'd1; w01_test[0] = 8'd1; w10_test[0] = 8'd1; w11_test[0] = 8'd1;\n    x0_test[0]  = 8'd2; x1_test[0]  = 8'd3;\n    y0_exp[0]   = 8'd5; y1_exp[0]   = 8'd5;\n\n    // Test 1: Another normal case\n    //   w00=2, w01=3, w10=4, w11=5, x0=6, x1=7\n    //   y0 = 6*2 + 7*4 = 12 + 28 = 40 (0x28)\n    //   y1 = 6*3 + 7*5 = 18 + 35 = 53 (0x35)\n    w00_test[1] = 8'd2;  w01_test[1] = 8'd3;  w10_test[1] = 8'd4;  w11_test[1] = 8'd5;\n    x0_test[1]  = 8'd6;  x1_test[1]  = 8'd7;\n    y0_exp[1]   = 8'd40; y1_exp[1]   = 8'd53;\n\n    // Test 2: Check zero weights\n    //   w00=0, w01=0, w10=0, w11=0, x0=10, x1=20\n    //   y0 = 10*0 + 20*0 = 0\n    //   y1 = 10*0 + 20*0 = 0\n    w00_test[2] = 8'd0;  w01_test[2] = 8'd0;  w10_test[2] = 8'd0;  w11_test[2] = 8'd0;\n    x0_test[2]  = 8'd10; x1_test[2]  = 8'd20;\n    y0_exp[2]   = 8'd0;  y1_exp[2]   = 8'd0;\n\n    // Test 3: Check zero inputs\n    //   w00=5, w01=4, w10=3, w11=2, x0=0, x1=0\n    //   y0 = 0*5 + 0*3 = 0\n    //   y1 = 0*4 + 0*2 = 0\n    w00_test[3] = 8'd5;  w01_test[3] = 8'd4;  w10_test[3] = 8'd3;  w11_test[3] = 8'd2;\n    x0_test[3]  = 8'd0;  x1_test[3]  = 8'd0;\n    y0_exp[3]   = 8'd0;  y1_exp[3]   = 8'd0;\n\n    // Test 4: Check maximum values (unsigned interpretation)\n    //   w00=255, w01=255, w10=255, w11=255, x0=255, x1=255\n    //   The multiplication 255*255 = 65025 decimal = 0xFE01 in 16 bits,\n    //   but only lower 8 bits stored => 0x01. Then psum_in + 0x01 => might cause repeated overflow.\n    //   Pipeline flow for y0 =>  (255*255)(LSB only) + (255*255)(LSB only) ...\n    //   This test will show how it saturates/overflows within 8 bits.\n    //   Expected result is not typical for \"true multiply,\" it's the truncated 8-bit result:\n    //   The design does: psum_out <= (psum_in + (input_in * weight_reg)) & 0xFF\n    //   So 255*255=65025 => 8-bit truncated = 0x01\n    //   So y0 = 0x01 + 0x01 = 0x02, y1 = 0x01 + 0x01 = 0x02 in final pipeline stage\n    //   (Because of the pipeline, the final sums can shift. Let's keep it simple \n    //    and say we expect 2 for both. For a pure 2\u00d72 multiply, \"real\" result is 255*255*2=~130050, \n    //    but we are only capturing LSB in each step.)\n    w00_test[4] = 8'hFF; w01_test[4] = 8'hFF; w10_test[4] = 8'hFF; w11_test[4] = 8'hFF;\n    x0_test[4]  = 8'hFF; x1_test[4]  = 8'hFF;\n    y0_exp[4]   = 8'd2;  y1_exp[4]   = 8'd2;\n\n    // Test 5: Mixed smaller large values for partial demonstration\n    //   w00=100, w01=150, w10=200, w11=250, x0=8, x1=3\n    //   y0 = 8*100 + 3*200 = 800 + 600 = 1400 => truncated to 8 bits => 1400 mod 256 = 1400 - 5*256= 1400-1280=120\n    //   y1 = 8*150 + 3*250 = 1200 + 750 = 1950 => mod 256 => 1950 - 7*256= 1950-1792=158\n    w00_test[5] = 8'd100; w01_test[5] = 8'd150; w10_test[5] = 8'd200; w11_test[5] = 8'd250;\n    x0_test[5]  = 8'd8;   x1_test[5]  = 8'd3;\n    y0_exp[5]   = 8'd120; y1_exp[5]   = 8'd158;\n\n    // Test 6: Minimal/edge case (all zeros) repeated, to show no glitch\n    //   wXX=0, xX=0 => y0=0, y1=0\n    w00_test[6] = 8'd0;  w01_test[6] = 8'd0;  w10_test[6] = 8'd0;  w11_test[6] = 8'd0;\n    x0_test[6]  = 8'd0;  x1_test[6]  = 8'd0;\n    y0_exp[6]   = 8'd0;  y1_exp[6]   = 8'd0;\n  end\n\n  // --------------------------------------------------------------------------\n  // Main Test Sequence\n  // --------------------------------------------------------------------------\n  integer i;\n  initial begin\n    // Display header\n    $display(\"==========================================\");\n    $display(\" Starting 2x2 Systolic Array Testbench...\");\n    $display(\"==========================================\");\n\n    // Initialize signals\n    clk           = 1'b0;\n    reset         = 1'b1;\n    load_weights  = 1'b0;\n    start         = 1'b0;\n    w00           = {DATA_WIDTH{1'b0}};\n    w01           = {DATA_WIDTH{1'b0}};\n    w10           = {DATA_WIDTH{1'b0}};\n    w11           = {DATA_WIDTH{1'b0}};\n    x0            = {DATA_WIDTH{1'b0}};\n    x1            = {DATA_WIDTH{1'b0}};\n\n    // Wait a few cycles before deasserting reset\n    #(5*CLK_PERIOD);\n    reset = 1'b0;\n    #(2*CLK_PERIOD);\n\n    // Run through each test\n    for (i = 0; i < TEST_COUNT; i = i + 1) begin\n      // 1) Load the weights\n      w00 = w00_test[i];\n      w01 = w01_test[i];\n      w10 = w10_test[i];\n      w11 = w11_test[i];\n\n      // Assert load_weights for at least one cycle so the PEs can latch the new weights\n      load_weights = 1'b1;\n      #(CLK_PERIOD);\n      load_weights = 1'b0;\n\n      // 2) Apply inputs and start\n      x0    = x0_test[i];\n      x1    = x1_test[i];\n      start = 1'b1;\n\n      // Wait for done to assert\n      wait(done === 1'b1);\n\n      // Once done is high for at least one cycle, we can capture the outputs.\n      //   (You could wait for the negedge of done as well if the design pulses it, \n      //    but in this example, once it goes high it remains high until start is deasserted)\n      #(CLK_PERIOD);\n\n      // 3) Compare with expected\n      if ((y0 === y0_exp[i]) && (y1 === y1_exp[i])) begin\n        $display(\"Test %0d PASSED. y0=%0d, y1=%0d (Expected %0d, %0d)\",\n                  i, y0, y1, y0_exp[i], y1_exp[i]);\n      end else begin\n        $display(\"Test %0d FAILED. y0=%0d, y1=%0d (Expected %0d, %0d)\",\n                  i, y0, y1, y0_exp[i], y1_exp[i]);\n      end\n\n      // Deassert start and wait a couple of cycles before next test\n      start = 1'b0;\n      #(2*CLK_PERIOD);\n    end\n\n    // End of all tests\n    $display(\"==========================================\");\n    $display(\" All tests completed.\");\n    $display(\"==========================================\");\n\n    $finish;\n  end\n\nendmodule"}, "patch": {"rtl/systolic_array.sv": ""}, "harness": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/weight_stationary_pe.sv /code/rtl/systolic_array.sv\nTOPLEVEL        = systolic_array\nMODULE          = test_systolic_array\nPYTHONPATH      = /src\nHASH            = 2b9a9f8548819692fb735414f960e0f47d08db41\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "# test_runner.py\n# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\nimport os\nimport pytest\nfrom cocotb.runner import get_runner\n\n# Environment variables provided externally (e.g. via Makefile or CI config)\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\n\n@pytest.mark.tb\n@pytest.mark.parametrize(\"DATA_WIDTH\", [8, 16, 32])\ndef test_runner(DATA_WIDTH):\n\n    runner = get_runner(sim)\n\n    # Build step: pass the parameter to the simulator so that the Verilog code\n    # uses the specified DATA_WIDTH. The specifics depend on the simulator.\n    # The 'parameters' dict is supported in newer versions of cocotb-test/cocotb.\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters={\"DATA_WIDTH\": DATA_WIDTH},  \n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run step: the specified top-level and test module are used.\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n", "src/test_systolic_array.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\n\n@cocotb.test()\nasync def run_systolic_array_test(dut):\n    \"\"\"\n    Cocotb test for the 2x2 systolic array.\n\n    This test replicates the same sequence and test vectors\n    demonstrated in the original Verilog testbench.\n    \"\"\"\n\n    # ------------------------------------------------------------------------\n    # Parameters\n    # ------------------------------------------------------------------------\n    CLK_PERIOD = 10  # ns (equivalent to 100 MHz)\n\n    # ------------------------------------------------------------------------\n    # Create and start the clock\n    # ------------------------------------------------------------------------\n    clock = Clock(dut.clk, CLK_PERIOD, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # ------------------------------------------------------------------------\n    # Reset logic\n    # ------------------------------------------------------------------------\n    dut.reset.value        = 1\n    dut.load_weights.value = 0\n    dut.start.value        = 0\n    dut.w00.value          = 0\n    dut.w01.value          = 0\n    dut.w10.value          = 0\n    dut.w11.value          = 0\n    dut.x0.value           = 0\n    dut.x1.value           = 0\n\n    # Hold reset high for a few cycles\n    for _ in range(5):\n        await RisingEdge(dut.clk)\n\n    # Deassert reset\n    dut.reset.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n    # ------------------------------------------------------------------------\n    # Define test vectors\n    #\n    # Each test is a dictionary holding:\n    #   w00, w01, w10, w11, x0, x1, y0_exp, y1_exp\n    # ------------------------------------------------------------------------\n    tests = [\n        # Test 0: Simple: All weights = 1, x0=2, x1=3 => y0=5, y1=5\n        {\"w00\":1,  \"w01\":1,  \"w10\":1,  \"w11\":1,\n         \"x0\":2,  \"x1\":3,\n         \"y0_exp\":5,  \"y1_exp\":5},\n\n        # Test 1: Normal case => w00=2,w01=3,w10=4,w11=5, x0=6,x1=7 => y0=40, y1=53\n        {\"w00\":2,  \"w01\":3,  \"w10\":4,  \"w11\":5,\n         \"x0\":6,  \"x1\":7,\n         \"y0_exp\":40, \"y1_exp\":53},\n\n        # Test 2: Zero weights => all wXX=0 => y0=0, y1=0\n        {\"w00\":0,  \"w01\":0,  \"w10\":0,  \"w11\":0,\n         \"x0\":10, \"x1\":20,\n         \"y0_exp\":0,  \"y1_exp\":0},\n\n        # Test 3: Zero inputs => x0=0, x1=0 => y0=0, y1=0\n        {\"w00\":5,  \"w01\":4,  \"w10\":3,  \"w11\":2,\n         \"x0\":0,  \"x1\":0,\n         \"y0_exp\":0, \"y1_exp\":0},\n\n        # Test 4: Maximum unsigned => 255*255 => truncated in 8 bits\n        # Expect each partial product = 0xFF * 0xFF => 65025 => 0x01 LSB\n        # The final sums in a 2x2 pipeline lead to y0=2, y1=2\n        {\"w00\":255, \"w01\":255, \"w10\":255, \"w11\":255,\n         \"x0\":255, \"x1\":255,\n         \"y0_exp\":2,  \"y1_exp\":2},\n\n        # Test 5: Mixed partial overflow\n        # w00=100, w01=150, w10=200, w11=250, x0=8, x1=3\n        # => y0= (8*100 + 3*200)=1400 => 1400 mod 256=120\n        # => y1= (8*150 + 3*250)=1950 => 1950 mod 256=158\n        {\"w00\":100, \"w01\":150, \"w10\":200, \"w11\":250,\n         \"x0\":8,    \"x1\":3,\n         \"y0_exp\":120, \"y1_exp\":158},\n\n        # Test 6: Repeated zero case\n        {\"w00\":0,  \"w01\":0,  \"w10\":0,  \"w11\":0,\n         \"x0\":0,   \"x1\":0,\n         \"y0_exp\":0,  \"y1_exp\":0},\n    ]\n\n    # ------------------------------------------------------------------------\n    # Test execution loop\n    # ------------------------------------------------------------------------\n    for i, test_vec in enumerate(tests):\n\n        # 1) Load the weights\n        dut.w00.value = test_vec[\"w00\"]\n        dut.w01.value = test_vec[\"w01\"]\n        dut.w10.value = test_vec[\"w10\"]\n        dut.w11.value = test_vec[\"w11\"]\n\n        dut.load_weights.value = 1\n        await RisingEdge(dut.clk)\n        dut.load_weights.value = 0\n\n        # 2) Apply inputs and start\n        dut.x0.value = test_vec[\"x0\"]\n        dut.x1.value = test_vec[\"x1\"]\n\n        dut.start.value = 1\n\n        # Wait until done is asserted\n        while True:\n            await RisingEdge(dut.clk)\n            if dut.done.value == 1:\n                break\n\n        # Additional cycle to let outputs settle\n        await RisingEdge(dut.clk)\n\n        # 3) Read outputs and compare\n        y0_val = dut.y0.value.integer\n        y1_val = dut.y1.value.integer\n        y0_exp = test_vec[\"y0_exp\"]\n        y1_exp = test_vec[\"y1_exp\"]\n\n        if (y0_val == y0_exp) and (y1_val == y1_exp):\n            dut._log.info(f\"Test {i} PASSED. y0={y0_val}, y1={y1_val} (Expected {y0_exp}, {y1_exp})\")\n        else:\n            dut._log.error(f\"Test {i} FAILED. y0={y0_val}, y1={y1_val} (Expected {y0_exp}, {y1_exp})\")\n\n        # Deassert start and wait some cycles\n        dut.start.value = 0\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n\n    dut._log.info(\"All tests completed successfully.\")\n", "local_harness.sh": "#!/bin/bash\nset -euo pipefail\nISSUE_DIR=\"${CVDP_ISSUE_DIR:-$(pwd)}\"\nSRC_DIR=\"${CVDP_SRC_DIR:-$ISSUE_DIR/src}\"\nCODE_DIR=\"${CVDP_CODE_DIR:-$ISSUE_DIR}\"\nRUNDIR_DIR=\"${CVDP_RUNDIR_DIR:-$ISSUE_DIR/rundir}\"\nENV_FILE=\"$SRC_DIR/.env\"\n\nif [ -n \"${CVDP_VENV_PYTHON:-}\" ]; then\n  VENV_BIN=\"$(dirname \"$CVDP_VENV_PYTHON\")\"\n  export PATH=\"$VENV_BIN:$PATH\"\nfi\n\nif [ -f \"$ENV_FILE\" ]; then\n  while IFS= read -r line || [ -n \"$line\" ]; do\n    line=\"${line%%#*}\"\n    if [ -z \"${line// }\" ]; then\n      continue\n    fi\n    if ! echo \"$line\" | grep -q \"=\"; then\n      continue\n    fi\n    key=\"${line%%=*}\"\n    value=\"${line#*=}\"\n    key=\"$(echo \"$key\" | xargs)\"\n    value=\"$(echo \"$value\" | xargs)\"\n    value=\"${value//\\/code/$CODE_DIR}\"\n    value=\"${value//\\/src/$SRC_DIR}\"\n    value=\"${value//\\/rundir/$RUNDIR_DIR}\"\n    export \"$key=$value\"\n  done < \"$ENV_FILE\"\nfi\n\nif [ -n \"${PYTHONPATH:-}\" ]; then\n  export PYTHONPATH=\"$PYTHONPATH:$SRC_DIR\"\nelse\n  export PYTHONPATH=\"$SRC_DIR\"\nfi\n\nmkdir -p \"$RUNDIR_DIR\"\nif [ \"${TOPLEVEL_LANG:-verilog}\" = \"verilog\" ] && [ -n \"${VERILOG_SOURCES:-}\" ]; then\n  TS_FILE=\"$RUNDIR_DIR/cvdp_timescale.v\"\n  if [ ! -f \"$TS_FILE\" ]; then\n    cat > \"$TS_FILE\" <<'EOF'\n`timescale 1ns/1ps\nmodule cvdp_timescale_dummy;\nendmodule\nEOF\n  fi\n  export VERILOG_SOURCES=\"$TS_FILE $VERILOG_SOURCES\"\nfi\n\nCMD='pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v'\n# Avoid double-substitution for /code/rundir paths\nCMD=\"${CMD//\\/code\\/rundir/$RUNDIR_DIR}\"\nCMD=\"${CMD//\\/code/$CODE_DIR}\"\nCMD=\"${CMD//\\/src/$SRC_DIR}\"\n# Replace standalone /rundir tokens only\nRUNDIR_ESC=\"$(printf '%s' \"$RUNDIR_DIR\" | sed -e 's/[\\/&]/\\\\&/g')\"\nCMD=\"$(printf '%s' \"$CMD\" | sed -E \"s#(^|[[:space:]]|=)/rundir#\\1${RUNDIR_ESC}#g\")\"\n\nWORKDIR='/code/rundir'\nif [ -z \"$WORKDIR\" ]; then\n  WORKDIR=\"$ISSUE_DIR\"\nfi\nif [[ \"$WORKDIR\" == /code/rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/code/rundir}\"\nelif [[ \"$WORKDIR\" == /code* ]]; then\n  WORKDIR=\"$CODE_DIR${WORKDIR#/code}\"\nelif [[ \"$WORKDIR\" == /src* ]]; then\n  WORKDIR=\"$SRC_DIR${WORKDIR#/src}\"\nelif [[ \"$WORKDIR\" == /rundir* ]]; then\n  WORKDIR=\"$RUNDIR_DIR${WORKDIR#/rundir}\"\nfi\n\ncd \"$WORKDIR\"\necho \"Running harness: $CMD\"\neval \"$CMD\"\n", "src/cocotb_tools/__init__.py": "\"\"\"Compatibility shim for cocotb_tools package.\"\"\"\n\nfrom .runner import get_runner  # re-export for convenience\n\n__all__ = [\"get_runner\"]\n", "src/cocotb_tools/runner.py": "\"\"\"Compat shim for cocotb_tools.runner on cocotb<2.x environments.\"\"\"\n\nimport re\n\ntry:\n    from cocotb.runner import get_runner as _get_runner\nexcept Exception:  # pragma: no cover - fallback when cocotb isn't present\n    _get_runner = None\n\n_UNIT_ORDER = [\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"fs\"]\n_UNIT_TO_FS = {\n    \"s\": 10**15,\n    \"ms\": 10**12,\n    \"us\": 10**9,\n    \"ns\": 10**6,\n    \"ps\": 10**3,\n    \"fs\": 1,\n}\n\n\ndef _parse_time(value):\n    match = re.match(r\"^\\\\s*(\\\\d+)\\\\s*([a-zA-Z]+)\\\\s*$\", str(value))\n    if not match:\n        return None\n    num = int(match.group(1))\n    unit = match.group(2).lower()\n    if unit not in _UNIT_TO_FS:\n        return None\n    return num, unit\n\n\ndef _to_fs(parsed):\n    num, unit = parsed\n    return num * _UNIT_TO_FS[unit]\n\n\ndef _smaller_unit(unit):\n    try:\n        idx = _UNIT_ORDER.index(unit)\n    except ValueError:\n        return None\n    if idx + 1 >= len(_UNIT_ORDER):\n        return None\n    return _UNIT_ORDER[idx + 1]\n\n\ndef _normalize_timescale(timescale):\n    if not isinstance(timescale, (tuple, list)) or len(timescale) != 2:\n        return timescale\n    unit, precision = timescale\n    unit_parsed = _parse_time(unit)\n    prec_parsed = _parse_time(precision)\n    if not unit_parsed or not prec_parsed:\n        return timescale\n    if _to_fs(prec_parsed) < _to_fs(unit_parsed):\n        return timescale\n    smaller = _smaller_unit(unit_parsed[1])\n    if not smaller:\n        return timescale\n    return (unit, f\"1{smaller}\")\n\n\nclass _RunnerWrapper:\n    def __init__(self, runner):\n        self._runner = runner\n\n    def build(self, *args, **kwargs):\n        if \"timescale\" in kwargs and kwargs[\"timescale\"] is not None:\n            kwargs[\"timescale\"] = _normalize_timescale(kwargs[\"timescale\"])\n        return self._runner.build(*args, **kwargs)\n\n    def test(self, *args, **kwargs):\n        return self._runner.test(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._runner, name)\n\n\ndef get_runner(sim=None):\n    if _get_runner is None:\n        raise ImportError(\"cocotb.runner.get_runner is unavailable\")\n    return _RunnerWrapper(_get_runner(sim))\n\n\n__all__ = [\"get_runner\"]\n", "src/sitecustomize.py": "\"\"\"Site customizations for cocotb runner compatibility.\"\"\"\n\ntry:\n    import cocotb.runner as _cocotb_runner\n    from cocotb_tools import runner as _shim_runner\n\n    _cocotb_runner.get_runner = _shim_runner.get_runner\nexcept Exception:\n    # Best-effort patching only\n    pass\n"}}
