{"id": "cvdp_agentic_8b10b_codec_0001", "categories": ["cid003", "hard"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Based on the contents of specification `docs/decoder_specification.md`, implement a complete SystemVerilog RTL design for the decoder module and create an accompanying SystemVerilog testbench.\n\n**RTL Module Implementation**  \n- **Specification:** Refer to `docs/decoder_specification.md` for detailed functional requirements, performance constraints, and expected behavior.\n- **Module Functionality:**  \n  - Convert a 10-bit encoded input into an 8-bit decoded output.\n  - Utilize separate decoding paths for control symbols and data symbols, determined by a dedicated control signal.\n  - Ensure robust handling of clock, reset, and input-valid signals.\n- **Location:** Save the RTL module file (`decoder_8b10b.sv`) in the `rtl` directory.\n\n**Testbench Implementation:**  \n- **Testbench File:** Create a SystemVerilog testbench (`tb_decoder_8b10b.sv`) that generates stimulus only and save it in the `verif` directory.\n- **Responsibilities:**  \n  - Develop comprehensive test cases that cover all aspects of the decoder\u2019s operation, including both control symbol and data symbol decoding.\n  - Simulate various scenarios such as normal operation, reset behavior, and potential edge cases to achieve maximum coverage.\n", "context": {"docs/decoder_specification.md": "# 8b10b Decoder Module Specification Document\n\n## 1. Introduction\n\nThe **8b10b Decoder Module (decoder_8b10b)** is a high-speed digital block designed to convert 10-bit encoded words into their corresponding 8-bit symbols. This conversion is essential in serial communication protocols where 8b/10b encoding is used to ensure DC balance and facilitate clock recovery. The decoder supports both **control symbols** and **data symbols**, selecting the appropriate decoding path based on an external indicator. The design is optimized for synchronous operation with low latency.\n\n## 2. Module Functionality\n\nThe decoder's primary function is to translate a 10-bit input into an 8-bit output while simultaneously determining whether the decoded output represents a data symbol or a control symbol. The key points of functionality include:\n\n- **Symbol Identification:**  \n  - **Control Symbols:** When the external `control_in` signal is asserted high, the module decodes the input using a predefined lookup table. This ensures that control characters (used for protocol management and synchronization) are correctly identified.  \n  - **Data Symbols:** When `control_in` is low, the module performs data decoding, where the 10-bit word is processed by logical and arithmetic operations to generate a valid 8-bit data output.\n\n- **Latency:**  \n  - The output is updated with a single clock-cycle latency. All data capturing, combinational decoding, and output selection are pipelined to ensure high-speed operation.\n\n### 2.1 Symbol Types\n\n- **Control Symbols:**  \n  Special synchronization and management symbols. When the `control_in` signal is high, the module employs a direct combinational lookup function to decode the input into a corresponding control word. Control symbols are critical for maintaining data stream integrity and protocol management.\n\n- **Data Symbols:**  \n  Standard 8-bit data values that have been transmitted as 10-bit encoded words. These symbols are detected when `control_in` is low. In addition to using direct lookup when applicable, an arithmetic logic network processes the input bits\u2014performing bit-level comparisons and generating parity conditions\u2014to produce the final 8-bit data word.\n\n### 2.2 Data Symbol Decoding Rules\n\nData symbol decoding involves:\n- **Segmentation and Processing:**  \n  The 10-bit input is logically divided and processed. One decoding path uses a combinational function that maps specific 10-bit words to control outputs. Another path computes bit-level logic operations (via XOR, AND, OR combinations) to generate the final 8-bit output from the individual bits of the input.\n  \n- **Decoding Tables:**  \n  Although the module uses a lookup function for several control-related code groups, it also relies on algorithmically derived parity and comparison signals. This approach is consistent with typical 5b/6b and 3b/4b decoding methods used in standard 8b/10b decoders, where:\n  - The upper portion of the 10-bit word is generally associated with a 5b/6b decoding table.\n  - The lower portion is mapped according to a 3b/4b decoding table.\n  \n  The module integrates these principles by combining results from the lookup function with additional combinational logic to verify and refine the decoded output.\n\n## 3. Algorithm Overview\n\nThe decoding process is divided into two main paths corresponding to control and data symbols, determined by the `control_in` signal:\n\n1. **Input Capture and Latching:**  \n   - The module operates on a synchronous clock (`clk_in`) and supports an active-high asynchronous reset (`reset_in`).\n   - When a valid input is detected on `decoder_valid_in`, the 10-bit encoded word is captured. This registered value is used in both the control decoding and the data symbol processing paths.\n   \n2. **Control Symbol Decoding Path:**  \n   - When `control_in` is asserted, a combinational decoding function is executed. This function compares the 10-bit input to a series of predefined patterns corresponding to control characters.\n   - For each matching pattern, the function produces a decoded 8-bit control symbol accompanied by an indicator that the symbol is a control character.\n   - The final output for this path is provided on `decoder_out` and `control_out`, with the valid signal synchronized to the input via `decoder_valid_out`.\n\n3. **Data Symbol Decoding Path:**  \n   - For data symbols (when `control_in` is low), additional combinational logic takes effect.\n   - Bit-level operations such as XOR, AND, OR, and parity checks are performed on the incoming 10-bit word. These operations mirror the functionality of conventional 5b/6b and 3b/4b decoding tables:\n     - **5b/6b Decoding:** The higher-order bits are processed to generate 5 significant bits.\n     - **3b/4b Decoding:** The lower-order bits are processed to yield 3 significant bits.\n   - The results are then concatenated to form the final 8-bit data word.\n   - This data path also registers control information indicative of the symbol type for downstream processing.\n\n4. **Output Multiplexing:**  \n   - A multiplexer selects between the two decoded outputs:\n     - If `control_in` is high, the output from the control decoding path is forwarded.\n     - Otherwise, the output from the data decoding path is selected.\n   - The valid output signal (`decoder_valid_out`) and the control signal (`control_out`) are provided accordingly.\n\n## 4. Module Interface\n\nThe following table summarizes the top-level ports of the 8b10b decoder module:\n\n| **Port Name**         | **Direction** | **Width** | **Description**                                                                                                 |\n|-----------------------|---------------|-----------|-----------------------------------------------------------------------------------------------------------------|\n| **clk_in**            | Input         | 1 bit     | Rising edge triggered clock input.                                                                              |\n| **reset_in**          | Input         | 1 bit     | Asynchronous active-high reset signal.                                                                          |\n| **control_in**        | Input         | 1 bit     | Active HIGH Control symbol indicator. When high, indicates a control symbol; when low, indicates a data symbol. |\n| **decoder_in**        | Input         | 10 bits   | The 10-bit encoded input word to be decoded.                                                                    |\n| **decoder_valid_in**  | Input         | 1 bit     | Active HIGH Input valid signal. A high level indicates that the data on `decoder_in` is valid for decoding.     |\n| **decoder_out**       | Output        | 8 bits    | The final 8-bit decoded output word.                                                                            |\n| **decoder_valid_out** | Output        | 1 bit     | Active HIGH Output valid signal. Indicates that `decoder_out` and `control_out` reflect valid decoded data.     |\n| **control_out**       | Output        | 1 bit     | Output control indicator. High when the decoded output corresponds to a control symbol and low for data symbols.|\n\n## 5. Internal Architecture\n\nTo achieve its functionality, the design is partitioned into several key blocks and pipeline stages:\n\n### 5.1 Input Capture and Latching\n\n- **Registering the Input:**  \n  When `decoder_valid_in` is asserted, the 10-bit input word is captured synchronously on the rising edge of `clk_in`. This registered value is used by both decoding paths, ensuring that the operations are performed on a stable data snapshot.\n  \n- **Valid Signal Generation:**  \n  A dedicated pipeline register tracks the validity of the input data, propagating a valid flag which is used to synchronize downstream computations.\n\n### 5.2 Control Symbol Decoding\n\n- **Combinational Lookup Function:**  \n  For control symbols, a combinational function (implemented using a case statement) maps the incoming 10-bit word directly to an 8-bit control code along with a control indicator.  \n- **Output Selection:**  \n  The results from this function are available immediately in the combinational domain and registered to be selected if `control_in` is high.\n\nThe decoder should support the control symbols, and special codes used for synchronization and control purposes and should decode them as follows.\n\n| **10-bit Input**      | **8-bit Output** | **Symbol** | **DEC Value** | **HEX Value** |\n|-----------------------|------------------|------------|---------------|---------------|\n| 001111 0100           | 000 11100        | K.28.0     | 28            | 1C            |\n| 110000 1011           | 000 11100        | K.28.0     | 28            | 1C            |\n| 001111 1001           | 001 11100        | K.28.1     | 60            | 3C            |\n| 110000 0110           | 001 11100        | K.28.1     | 60            | 3C            |\n| 001111 0101           | 010 11100        | K.28.2     | 92            | 5C            |\n| 110000 1010           | 010 11100        | K.28.2     | 92            | 5C            |\n| 001111 0011           | 011 11100        | K.28.3     | 124           | 7C            |\n| 110000 1100           | 011 11100        | K.28.3     | 124           | 7C            |\n| 001111 0010           | 100 11100        | K.28.4     | 156           | 9C            |\n| 110000 1101           | 100 11100        | K.28.4     | 156           | 9C            |\n| 001111 1010           | 101 11100        | K.28.5     | 188           | BC            |\n| 110000 0101           | 101 11100        | K.28.5     | 188           | BC            |\n| 001111 0110           | 110 11100        | K.28.6     | 220           | DC            |\n| 110000 1001           | 110 11100        | K.28.6     | 220           | DC            |\n| 001111 1000           | 111 11100        | K.28.7     | 252           | FC            |\n| 110000 0111           | 111 11100        | K.28.7     | 252           | FC            |\n| 111010 1000           | 111 10111        | K.23.7     | 247           | F7            |\n| 000101 0111           | 111 10111        | K.23.7     | 247           | F7            |\n| 110110 1000           | 111 11011        | K.27.7     | 251           | FB            |\n| 001001 0111           | 111 11011        | K.27.7     | 251           | FB            |\n| 101110 1000           | 111 11101        | K.29.7     | 253           | FD            |\n| 010001 0111           | 111 11101        | K.29.7     | 253           | FD            |\n| 011110 1000           | 111 11110        | K.30.7     | 254           | FE            |\n| 100001 0111           | 111 11110        | K.30.7     | 254           | FE            |\n\n### 5.3 Data Symbol Decoding Logic\n\n- **Bitwise Operations:**  \n  The data decoding path employs a sequence of logical operations (XOR, AND, OR) on individual bits extracted from the 10-bit input. These operations effectively perform the role of translating the encoded 10-bit word into an 8-bit data symbol.  \n- **Parity and Pattern Checking:**  \n  Logical conditions are evaluated to derive parity signals, matching conditions, and candidate bit outputs analogous to the traditional 5b/6b and 3b/4b decoders.  \n- **Final Data Assembly:**  \n  The outputs from these operations are concatenated into the final 8-bit result for the data symbol and forwarded to the output multiplexer.\n\n#### **5b/6b Decoding Table**\n\nThe MSB 6-bit of the 10-bit input is mapped back to its corresponding 5-bit (`EDCBA`).\n\n| Encoded 6-bit (abcdei)       | Decoded 5-bit (EDCBA) |\n|------------------------------|-----------------------|\n| 100111, 011000               | 00000                 |\n| 011101, 100010               | 00001                 |\n| 101101, 010010               | 00010                 |\n| 110001                       | 00011                 |\n| 110101, 001010               | 00100                 |\n| 101001                       | 00101                 |\n| 011001                       | 00110                 |\n| 111000, 000111               | 00111                 |\n| 111001, 000110               | 01000                 |\n| 100101                       | 01001                 |\n| 010101                       | 01010                 |\n| 110100                       | 01011                 |\n| 001101                       | 01100                 |\n| 101100                       | 01101                 |\n| 011100                       | 01110                 |\n| 010111, 101000               | 01111                 |\n| 011011, 100100               | 10000                 |\n| 100011                       | 10001                 |\n| 010011                       | 10010                 |\n| 110010                       | 10011                 |\n| 001011                       | 10100                 |\n| 101010                       | 10101                 |\n| 011010                       | 10110                 |\n| 111010, 000101               | 10111                 |\n| 110011, 001100               | 11000                 |\n| 100110                       | 11001                 |\n| 010110                       | 11010                 |\n| 110110, 001001               | 11011                 |\n| 001110                       | 11100                 |\n| 101110, 010001               | 11101                 |\n| 011110, 100001               | 11110                 |\n| 101011, 010100               | 11111                 |\n\n#### **3b/4b Decoding Table**\n\nThe LSB 4-bit of the 10-bit input is mapped back to its corresponding 3-bit (`HGF`).\n\n| Encoded 4-bit (fghj)         | Decoded 3-bit (HGF) |\n|------------------------------|---------------------|\n| 0100, 1011                   | 000                 |\n| 1001                         | 001                 |\n| 0101                         | 010                 |\n| 0011, 1100                   | 011                 |\n| 0010, 1101                   | 100                 |\n| 1010                         | 101                 |\n| 0110                         | 110                 |\n| 1110, 0001                   | 111                 |\n\n\n### 5.4 Output Multiplexing and Synchronization\n\n- **Multiplexing Based on Symbol Type:**  \n  A simple multiplexer selects the appropriate output:\n  - **Control Path Selected:** When `control_in` is high, the pre-decoded control symbol and associated indicator are transmitted.\n  - **Data Path Selected:** When `control_in` is low, the processed data symbol and its valid flag are forwarded.\n  \n- **Clock Domain Synchronization:**  \n  The combined outputs are registered on the rising edge of the clock, ensuring that the `decoder_valid_out` signal is properly synchronized with the decoded data. The overall system latency is maintained at one clock cycle from valid input to valid output.\n\n## 6. Timing and Latency\n\n- **Synchronous Operation:**  \n  All internal operations are triggered by the rising edge of `clk_in`. The asynchronous reset (`reset_in`) ensures that the internal state is immediately cleared when asserted.\n\n- **Latency:**  \n  The design ensures a fixed output latency of one clock cycle. This is accomplished by registering the input data and propagating the associated valid signal through the pipeline stages before it reaches the final output multiplexer.\n  \n- **Pipeline Considerations:**  \n  Although the control decoding (via the lookup function) and the data path (via bit-level combinational logic) operate concurrently, both paths are synchronized to align their outputs. This guarantees that regardless of the symbol type, the final decoded word and the valid signal are updated simultaneously.\n\n\n\n"}, "patch": {"rtl/decoder_8b10b.sv": "", "verif/tb_decoder_8b10b.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir  \n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true  \n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/decoder_8b10b.sv \nTOPLEVEL        = decoder_8b10b\nMODULE          = test_decoder_8b10b\nPYTHONPATH      = /src\nHASH            = 11258d3243c38941434c245dccc84451a6d31a04\nTARGET          = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /code/rtl/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n        \n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    \n", "src/test_decoder_8b10b.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nfrom collections import deque\n\n# Special character code values\nK28d0_RD0 = \"0011110100\"\nK28d0_RD1 = \"1100001011\"\nK28d1_RD0 = \"0011111001\"\nK28d1_RD1 = \"1100000110\"\nK28d2_RD0 = \"0011110101\"\nK28d2_RD1 = \"1100001010\"\nK28d3_RD0 = \"0011110011\"\nK28d3_RD1 = \"1100001100\"\nK28d4_RD0 = \"0011110010\"\nK28d4_RD1 = \"1100001101\"\nK28d5_RD0 = \"0011111010\"\nK28d5_RD1 = \"1100000101\"\nK28d6_RD0 = \"0011110110\"\nK28d6_RD1 = \"1100001001\"\nK28d7_RD0 = \"0011111000\"\nK28d7_RD1 = \"1100000111\"\nK23d7_RD0 = \"1110101000\"\nK23d7_RD1 = \"0001010111\"\nK27d7_RD0 = \"1101101000\"\nK27d7_RD1 = \"0010010111\"\nK29d7_RD0 = \"1011101000\"\nK29d7_RD1 = \"0100010111\"\nK30d7_RD0 = \"0111101000\"\nK30d7_RD1 = \"1000010111\"\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and start the clock.\"\"\"\n    dut.reset_in.value = 1\n    dut.decoder_in.value = 0\n    dut.decoder_valid_in.value = 0\n    dut.control_in.value = 0\n\n    clock = Clock(dut.clk_in, 50, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    dut.reset_in.value = 0\n\nasync def check_output(dut, expected_value, expected_control, input_value):\n    \"\"\"Check the output of the DUT against the expected value.\"\"\"\n    expected_value_bin = f\"{int(expected_value, 16):08b}\"  # Convert hex to binary\n    print(f\"Expected: {hex(int(expected_value, 16)):>4}, Got: {hex(int(str(dut.decoder_out.value), 2)):>4}, Input: {input_value}\")\n    assert str(dut.decoder_out.value) == expected_value_bin, f\"Expected {expected_value_bin}, got {str(dut.decoder_out.value)}\"\n    assert dut.control_out.value == expected_control, f\"Expected control {expected_control}, got {dut.control_out.value}\"\n\ndef calculate_expected_value(codeword):\n    \"\"\"Calculate the expected value based on the 10-bit codeword.\"\"\"\n    if codeword in [K28d0_RD0, K28d0_RD1]:\n        return \"1C\"\n    elif codeword in [K28d1_RD0, K28d1_RD1]:\n        return \"3C\"\n    elif codeword in [K28d2_RD0, K28d2_RD1]:\n        return \"5C\"\n    elif codeword in [K28d3_RD0, K28d3_RD1]:\n        return \"7C\"\n    elif codeword in [K28d4_RD0, K28d4_RD1]:\n        return \"9C\"\n    elif codeword in [K28d5_RD0, K28d5_RD1]:\n        return \"BC\"\n    elif codeword in [K28d6_RD0, K28d6_RD1]:\n        return \"DC\"\n    elif codeword in [K28d7_RD0, K28d7_RD1]:\n        return \"FC\"\n    elif codeword in [K23d7_RD0, K23d7_RD1]:\n        return \"F7\"\n    elif codeword in [K27d7_RD0, K27d7_RD1]:\n        return \"FB\"\n    elif codeword in [K29d7_RD0, K29d7_RD1]:\n        return \"FD\"\n    elif codeword in [K30d7_RD0, K30d7_RD1]:\n        return \"FE\"\n    else:\n        return \"00\"\n\n# Data symbols for 8b10b decoder\nDATA_SYMBOLS = [\n     \"1001110100\", \"0110001011\", \"0111010010\", \"1000101101\", \"1011010101\", \"0100100101\", \"1100010110\", \"1100010110\",\n     \"0111010100\", \"1000101011\", \"1011010010\", \"0100101101\", \"1100010101\", \"1100010101\", \"1101010110\", \"0010100110\",\n     \"1011010100\", \"0100101011\", \"1100011101\", \"1100010010\", \"1101010101\", \"0010100101\", \"1010010110\", \"1010010110\",\n     \"1100011011\", \"1100010100\", \"1101010010\", \"0010101101\", \"1010010101\", \"1010010101\", \"0110010110\", \"0110010110\",\n     \"1101010100\", \"0010101011\", \"1010011101\", \"1010010010\", \"0110010101\", \"0110010101\", \"1110000110\", \"0001110110\",\n     \"1010011011\", \"1010010100\", \"0110011101\", \"0110010010\", \"1110000101\", \"0001110101\", \"1110010110\", \"0001100110\",\n     \"0110011011\", \"0110010100\", \"1110001101\", \"0001110010\", \"1110010101\", \"0001100101\", \"1001010110\", \"1001010110\",\n     \"1110001011\", \"0001110100\", \"1110010010\", \"0001101101\", \"1001010101\", \"1001010101\", \"0101010110\", \"0101010110\",\n     \"1110010100\", \"0001101011\", \"1001011101\", \"1001010010\", \"0101010101\", \"0101010101\", \"1101000110\", \"1101000110\",\n     \"1001011011\", \"1001010100\", \"0101011101\", \"0101010010\", \"1101000101\", \"1101000101\", \"0011010110\", \"0011010110\",\n     \"0101011011\", \"0101010100\", \"1101001101\", \"1101000010\", \"0011010101\", \"0011010101\", \"1011000110\", \"1011000110\",\n     \"1101001011\", \"1101000100\", \"0011011101\", \"0011010010\", \"1011000101\", \"1011000101\", \"0111000110\", \"0111000110\",\n     \"0011011011\", \"0011010100\", \"1011001101\", \"1011000010\", \"0111000101\", \"0111000101\", \"0101110110\", \"1010000110\",\n     \"1011001011\", \"1011000100\", \"0111001101\", \"0111000010\", \"0101110101\", \"1010000101\", \"0110110110\", \"1001000110\",\n     \"0111001011\", \"0111000100\", \"0101110010\", \"1010001101\", \"0110110101\", \"1001000101\", \"1000110110\", \"1000110110\",\n     \"0101110100\", \"1010001011\", \"0110110010\", \"1001001101\", \"1000110101\", \"1000110101\", \"0100110110\", \"0100110110\",\n     \"0110110100\", \"1001001011\", \"1000111101\", \"1000110010\", \"0100110101\", \"0100110101\", \"1100100110\", \"1100100110\",\n     \"1000111011\", \"1000110100\", \"0100111101\", \"0100110010\", \"1100100101\", \"1100100101\", \"0010110110\", \"0010110110\",\n     \"0100111011\", \"0100110100\", \"1100101101\", \"1100100010\", \"0010110101\", \"0010110101\", \"1010100110\", \"1010100110\",\n     \"1100101011\", \"1100100100\", \"0010111101\", \"0010110010\", \"1010100101\", \"1010100101\", \"0110100110\", \"0110100110\",\n     \"0010111011\", \"0010110100\", \"1010101101\", \"1010100010\", \"0110100101\", \"0110100101\", \"1110100110\", \"0001010110\",\n     \"1010101011\", \"1010100100\", \"0110101101\", \"0110100010\", \"1110100101\", \"0001010101\", \"1100110110\", \"0011000110\",\n     \"0110101011\", \"0110100100\", \"1110100010\", \"0001011101\", \"1100110101\", \"0011000101\", \"1001100110\", \"1001100110\",\n     \"1110100100\", \"0001011011\", \"1100110010\", \"0011001101\", \"1001100101\", \"1001100101\", \"0101100110\", \"0101100110\",\n     \"1100110100\", \"0011001011\", \"1001101101\", \"1001100010\", \"0101100101\", \"0101100101\", \"1101100110\", \"0010010110\",\n     \"1001101011\", \"1001100100\", \"0101101101\", \"0101100010\", \"1101100101\", \"0010010101\", \"0011100110\", \"0011100110\",\n     \"0101101011\", \"0101100100\", \"1101100010\", \"0010011101\", \"0011100101\", \"0011100101\", \"1011100110\", \"0100010110\",\n     \"1101100100\", \"0010011011\", \"0011101101\", \"0011100010\", \"1011100101\", \"0100010101\", \"0111100110\", \"1000010110\",\n     \"0011101011\", \"0011100100\", \"1011100010\", \"0100011101\", \"0111100101\", \"1000010101\", \"1010110110\", \"0101000110\",\n     \"1011100100\", \"0100011011\", \"0111100010\", \"1000011101\", \"1010110101\", \"0101000101\", \"1001110001\", \"0110001110\",\n     \"0111100100\", \"1000011011\", \"1010110010\", \"0101001101\", \"1001110011\", \"0110001100\", \"0111010001\", \"1000101110\",\n     \"1010110100\", \"0101001011\", \"1001111010\", \"0110001010\", \"0111010011\", \"1000101100\", \"1011010001\", \"0100101110\",\n     \"1001111001\", \"0110001001\", \"0111011010\", \"1000101010\", \"1011010011\", \"0100101100\", \"1100011110\", \"1100010001\",\n     \"0111011001\", \"1000101001\", \"1011011010\", \"0100101010\", \"1100011100\", \"1100010011\", \"1101010001\", \"0010101110\",\n     \"1011011001\", \"0100101001\", \"1100011010\", \"1100011010\", \"1101010011\", \"0010101100\", \"1010011110\", \"1010010001\",\n     \"1100011001\", \"1100011001\", \"1101011010\", \"0010101010\", \"1010011100\", \"1010010011\", \"0110011110\", \"0110010001\",\n     \"1101011001\", \"0010101001\", \"1010011010\", \"1010011010\", \"0110011100\", \"0110010011\", \"1110001110\", \"0001110001\",\n     \"1010011001\", \"1010011001\", \"0110011010\", \"0110011010\", \"1110001100\", \"0001110011\", \"1110010001\", \"0001101110\",\n     \"0110011001\", \"0110011001\", \"1110001010\", \"0001111010\", \"1110010011\", \"0001101100\", \"1001011110\", \"1001010001\",\n     \"1110001001\", \"0001111001\", \"1110011010\", \"0001101010\", \"1001011100\", \"1001010011\", \"0101011110\", \"0101010001\",\n     \"1110011001\", \"0001101001\", \"1001011010\", \"1001011010\", \"0101011100\", \"0101010011\", \"1101001110\", \"1101001000\",\n     \"1001011001\", \"1001011001\", \"0101011010\", \"0101011010\", \"1101001100\", \"1101000011\", \"0011011110\", \"0011010001\",\n     \"0101011001\", \"0101011001\", \"1101001010\", \"1101001010\", \"0011011100\", \"0011010011\", \"1011001110\", \"1011001000\",\n     \"1101001001\", \"1101001001\", \"0011011010\", \"0011011010\", \"1011001100\", \"1011000011\", \"0111001110\", \"0111001000\",\n     \"0011011001\", \"0011011001\", \"1011001010\", \"1011001010\", \"0111001100\", \"0111000011\", \"0101110001\", \"1010001110\",\n     \"1011001001\", \"1011001001\", \"0111001010\", \"0111001010\", \"0101110011\", \"1010001100\", \"0110110001\", \"1001001110\",\n     \"0111001001\", \"0111001001\", \"0101111010\", \"1010001010\", \"0110110011\", \"1001001100\", \"1000110111\", \"1000110001\",\n     \"0101111001\", \"1010001001\", \"0110111010\", \"1001001010\", \"1000111100\", \"1000110011\", \"0100110111\", \"0100110001\",\n     \"0110111001\", \"1001001001\", \"1000111010\", \"1000111010\", \"0100111100\", \"0100110011\", \"1100101110\", \"1100100001\",\n     \"1000111001\", \"1000111001\", \"0100111010\", \"0100111010\", \"1100101100\", \"1100100011\", \"0010110111\", \"0010110001\",\n     \"0100111001\", \"0100111001\", \"1100101010\", \"1100101010\", \"0010111100\", \"0010110011\", \"1010101110\", \"1010100001\",\n     \"1100101001\", \"1100101001\", \"0010111010\", \"0010111010\", \"1010101100\", \"1010100011\", \"0110101110\", \"0110100001\",\n     \"0010111001\", \"0010111001\", \"1010101010\", \"1010101010\", \"0110101100\", \"0110100011\", \"1110100001\", \"0001011110\",\n     \"1010101001\", \"1010101001\", \"0110101010\", \"0110101010\", \"1110100011\", \"0001011100\", \"1100110001\", \"0011001110\",\n     \"0110101001\", \"0110101001\", \"1110101010\", \"0001011010\", \"1100110011\", \"0011001100\", \"1001101110\", \"1001100001\",\n     \"1110101001\", \"0001011001\", \"1100111010\", \"0011001010\", \"1001101100\", \"1001100011\", \"0101101110\", \"0101100001\",\n     \"1100111001\", \"0011001001\", \"1001101010\", \"1001101010\", \"0101101100\", \"0101100011\", \"1101100001\", \"0010011110\",\n     \"1001101001\", \"1001101001\", \"0101101010\", \"0101101010\", \"1101100011\", \"0010011100\", \"0011101110\", \"0011100001\",\n     \"0101101001\", \"0101101001\", \"1101101010\", \"0010011010\", \"0011101100\", \"0011100011\", \"1011100001\", \"0100011110\",\n     \"1101101001\", \"0010011001\", \"0011101010\", \"0011101010\", \"1011100011\", \"0100011100\", \"0111100001\", \"1000011110\",\n     \"0011101001\", \"0011101001\", \"1011101010\", \"0100011010\", \"0111100011\", \"1000011100\", \"1010110001\", \"0101001110\",\n     \"1011101001\", \"0100011001\", \"0111101010\", \"1000011010\", \"1010110011\", \"0101001100\", \"1001110010\", \"0110001101\",\n     \"0111101001\", \"1000011001\", \"1010111010\", \"0101001010\", \"1001110101\", \"0110000101\", \"0111010110\", \"1000100110\",\n     \"1010111001\", \"0101001001\", \"1001110110\", \"0110000110\", \"0111010101\", \"1000100101\", \"1011010110\", \"0100100110\" \n]\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and start the clock.\"\"\"\n    dut.reset_in.value = 1\n    dut.decoder_in.value = 0\n    dut.decoder_valid_in.value = 0\n    dut.control_in.value = 0\n\n    clock = Clock(dut.clk_in, 50, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    dut.reset_in.value = 0\n\ndef calculate_doi(d):\n    d = [int(bit) for bit in f\"{int(d, 2):010b}\"][::-1] \n    def not_(x): return 1 if x == 0 else 0\n\n    doi = [0] * 8\n\n    doi[7] = (((d[0] ^ d[1]) & not_(\n        (not_(d[3]) & d[2] & not_(d[1]) & d[0] & not_(not_(d[7] | d[6] | d[5] | d[4]))) |\n        (not_(d[3]) & d[2] & d[1] & not_(d[0]) & not_(d[7] | d[6] | d[5] | d[4])) |\n        (d[3] & not_(d[2]) & not_(d[1]) & d[0] & not_(not_(d[7] | d[6] | d[5] | d[4]))) |\n        (d[3] & not_(d[2]) & d[1] & not_(d[0]) & not_(d[7] | d[6] | d[5] | d[4]))\n    ))) | (not_(d[3]) & d[2] & d[1] & d[0]) | (d[3] & not_(d[2]) & not_(d[1]) & not_(d[0]))\n\n    doi[6] = ((d[0] & not_(d[3]) & (d[1] | not_(d[2]) | not_(not_(d[7] | d[6] | d[5] | d[4])))) |\n              (d[3] & not_(d[0]) & (not_(d[1]) | d[2] | not_(d[7] | d[6] | d[5] | d[4]))) |\n              (not_(not_(d[7] | d[6] | d[5] | d[4])) & d[2] & d[1]) |\n              (not_(d[7] | d[6] | d[5] | d[4]) & not_(d[2]) & not_(d[1])))\n\n    doi[5] = ((d[0] & not_(d[3]) & (d[1] | not_(d[2]) | not_(d[7] | d[6] | d[5] | d[4]))) |\n              (d[3] & not_(d[0]) & (not_(d[1]) | d[2] | not_(not_(d[7] | d[6] | d[5] | d[4])))) |\n              (not_(d[7] | d[6] | d[5] | d[4]) & d[2] & d[1]) |\n              (not_(not_(d[7] | d[6] | d[5] | d[4])) & not_(d[2]) & not_(d[1])))\n\n    \n\n    term32 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term33 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term34 = (term32 | term33) & not_(d[5])\n    term35 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term36 = not_(d[9]) & not_(d[8]) & not_(d[5]) & not_(d[4])\n    term37 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term38 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term39 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term40 = (term37 | term38 | term39) & not_(d[9]) & not_(d[7]) & not_(d[5] ^ d[4])\n    term41 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term42 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term43 = (term41 | term42) & not_(d[4])\n    term44 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term45 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term46 = (term44 | term45) & d[6] & d[5] & d[4]\n    term47 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term48 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term49 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term50 = (term47 | term48 | term49) & not_(d[8]) & not_(d[7]) & not_(d[5] ^ d[4])\n\n    doi[4] = d[5] ^ (term34 | term35 | term36 | term40 | term43 | term46 | term50)\n\n    term1 = d[9] & d[8] & d[5] & d[4]\n    term2 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term3 = (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6])\n    term4 = (not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8])\n    term5 = (term3 | term4) & d[4]\n\n    term6 = (\n        ((d[9] & d[8] & not_(d[7]) & not_(d[6])) |\n         (d[7] & d[6] & not_(d[9]) & not_(d[8])) |\n         (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))))\n        ) & d[9] & d[7] & not_(d[5] ^ d[4])\n    )\n    term7 = (\n        (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])) |\n        (not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8]))\n    ) & not_(d[5])\n    term8 = (\n        (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])) |\n        (not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8]))\n    ) & d[6] & d[5] & d[4]\n    term9 = (\n        ((d[9] & d[8] & not_(d[7]) & not_(d[6])) |\n         (d[7] & d[6] & not_(d[9]) & not_(d[8])) |\n         (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))))\n        ) & not_(d[8]) & not_(d[7]) & not_(d[5] ^ d[4])\n    )\n\n    doi[3] = d[6] ^ (term1 | term2 | term5 | term6 | term7 | term8 | term9)\n\n\n    \n    term10 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term11 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term12 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term13 = (term10 | term11 | term12) & not_(d[9]) & not_(d[7]) & not_(d[5] ^ d[4])\n    term14 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term15 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term16 = (term14 | term15) & not_(d[5])\n    term17 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6]\n    term18 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8]\n    term19 = (term17 | term18) & d[4]\n    term20 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term21 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term22 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term23 = (term20 | term21 | term22) & d[8] & d[7] & not_(d[5] ^ d[4])\n    term24 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term25 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term26 = (term24 | term25) & d[6] & d[5] & d[4]\n    term27 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term28 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term29 = (term27 | term28) & not_(d[5])\n    term30 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term31 = not_(d[9]) & not_(d[8]) & not_(d[5]) & not_(d[4])\n\n    doi[2] = d[7] ^ (term13 | term16 | term19 | term23 | term26 | term29 | term30 | term31)\n\n       \n    term51 = d[9] & d[8] & d[5] & d[4]\n    term52 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term53 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6]\n    term54 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8]\n    term55 = (term53 | term54) & d[4]\n    term56 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6]\n    term57 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8]\n    term58 = (term56 | term57) & d[4]\n    term59 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term60 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term61 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term62 = (term59 | term60 | term61) & d[8] & d[7] & not_(d[5] ^ d[4])\n    term63 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term64 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term65 = (term63 | term64) & d[6] & d[5] & d[4]\n    term66 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term67 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term68 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term69 = (term66 | term67 | term68) & d[9] & d[7] & not_(d[5] ^ d[4])\n    term70 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term71 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term72 = (term70 | term71) & not_(d[5])\n\n    doi[1] = d[8] ^ (term51 | term52 | term55 | term58 | term62 | term65 | term69 | term72)\n\n   \n    term73 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term74 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term75 = (term73 | term74) & d[6] & d[5] & d[4]\n    term76 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term77 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term78 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term79 = (term76 | term77 | term78) & not_(d[8]) & not_(d[7]) & not_(d[5] ^ d[4])\n    term80 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term81 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term82 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term83 = (term80 | term81 | term82) & not_(d[9]) & not_(d[7]) & not_(d[5] ^ d[4])\n    term84 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term85 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term86 = (term84 | term85) & not_(d[5])\n    term87 = d[9] & d[8] & d[5] & d[4]\n    term88 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term89 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6]\n    term90 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8]\n    term91 = (term89 | term90) & d[4]\n\n    doi[0] = d[9] ^ (term75 | term79 | term83 | term86 | term87 | term88 | term91)\n\n       \n    return \"\".join(map(str, reversed(doi)))\n\n\n@cocotb.test()\nasync def test_decoder_8b10b_reset(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols and reset HIGH.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n    dut.reset_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    expected_value = \"00\"\n    expected_control = 0\n    await check_output(dut, expected_value, expected_control, \"0000000000\")\n\n@cocotb.test()\nasync def test_continuous_control_symbol(dut):\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(28):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n    await Timer(100, units=\"ns\")\n\n\n@cocotb.test()\nasync def test_random_control_symbol(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n@cocotb.test()\nasync def test_same_control_symbol(dut):\n    \"\"\"Test sending the same control symbol continuously.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d6_RD0, K28d6_RD1]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(20):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n@cocotb.test()\nasync def test_random_invalid_control_input(dut):\n    \"\"\"Test sending any 10-bit input other than 12 control symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_data = random.randint(0, 1023)\n        while f\"{random_data:010b}\" in control_symbols:\n            random_data = random.randint(0, 1023)\n        dut.decoder_in.value = random_data\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n    await Timer(100, units=\"ns\")\n\n@cocotb.test()\nasync def test_random_imbalanced_control_symbol(dut):\n    \"\"\"Test sending any random control symbol continuously out of 5 imbalanced symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(20):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n@cocotb.test()\nasync def test_seq_data_symbols(dut):\n    \"\"\"Test sequential data symbols.\"\"\"\n    await initialize_dut(dut)\n\n    default_value = int('1001110100', 2)  # This will be 628\n\n    # Initialize the deque with the default value\n    decoder_in_queue = deque([default_value, default_value], maxlen=2)\n\n    for symbol in DATA_SYMBOLS:  # Iterate through all symbols in DATA_SYMBOLS\n        dut.decoder_in.value = int(symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 0  # Data symbols\n        await RisingEdge(dut.clk_in)\n        decoder_in_queue.append(dut.decoder_in.value)\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n\n        # Wait for decoder_valid_out to be HIGH\n        while not dut.decoder_valid_out.value:\n            await RisingEdge(dut.clk_in)\n\n        expected_value = calculate_doi(delayed_decoder_in)\n        dut_doi = f\"{int(dut.decoder_out.value):08b}\"\n\n        print(f\"Expected: {hex(int(expected_value, 2)):>4}, Got: {hex(int(str(dut_doi), 2)):>4}, Input: {delayed_decoder_in}\")\n\n        assert dut_doi == expected_value, f\"Mismatch: Input={symbol}, Expected={expected_value}, Got={dut_doi}\"\n\n@cocotb.test()\nasync def test_random_data_symbols(dut):\n    \"\"\"Test random data symbols with random selection for 10 cycles\"\"\"\n    await initialize_dut(dut)\n\n    default_value = int('1001110100', 2)  # This will be 628\n\n    # Initialize the deque with the default value\n    decoder_in_queue = deque([default_value, default_value], maxlen=2)\n\n    for _ in range(10):  # Run for 10 cycles\n        # Randomly select a symbol from DATA_SYMBOLS\n        symbol = random.choice(DATA_SYMBOLS)\n        dut.decoder_in.value = int(symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 0  # Data symbols\n        await RisingEdge(dut.clk_in)\n        decoder_in_queue.append(dut.decoder_in.value)\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n\n        # Wait for decoder_valid_out to be HIGH\n        while not dut.decoder_valid_out.value:\n            await RisingEdge(dut.clk_in)\n\n        expected_value = calculate_doi(delayed_decoder_in)\n        dut_doi = f\"{int(dut.decoder_out.value):08b}\"\n\n        print(f\"Expected: {hex(int(expected_value, 2)):>4}, Got: {hex(int(str(dut_doi), 2)):>4}, Input: {delayed_decoder_in}\")\n\n        assert dut_doi == expected_value, f\"Mismatch: Input={symbol}, Expected={expected_value}, Got={dut_doi}\"\n\n\n# Define the allowed_values array\n@cocotb.test()\nasync def test_incrementing_data_symbols(dut):\n    \"\"\"Test data symbols using the allowed_values array for 10 cycles\"\"\"\n    await initialize_dut(dut)\n    allowed_values = [\n    0x274, 0x1d4, 0x2d4, 0x31b, 0x0ab, 0x294, 0x19b, 0x074,\n    0x394, 0x25b, 0x154, 0x34b, 0x0d4, 0x2cb, 0x1c4, 0x174,\n    0x1b4, 0x23b, 0x134, 0x32b, 0x0b4, 0x2ab, 0x1a4, 0x3a4\n    ]\n\n    default_value = int('1001110100', 2)  # This will be 628\n\n    # Initialize the deque with the default value\n    decoder_in_queue = deque([default_value, default_value], maxlen=2)\n\n    for i in range(24):  # Run for 10 cycles\n        symbol = allowed_values[i % len(allowed_values)]\n\n        dut.decoder_in.value = symbol\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 0  # Data symbols\n        await RisingEdge(dut.clk_in)\n        decoder_in_queue.append(dut.decoder_in.value)\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n\n        # Wait for decoder_valid_out to be HIGH\n        while not dut.decoder_valid_out.value:\n            await RisingEdge(dut.clk_in)\n\n        expected_value = calculate_doi(delayed_decoder_in)\n        dut_doi = f\"{int(dut.decoder_out.value):08b}\"\n\n        print(f\"Expected: {hex(int(expected_value, 2)):>4}, Got: {hex(int(str(dut_doi), 2)):>4}, Input: {delayed_decoder_in}\")\n\n        assert dut_doi == expected_value, f\"Mismatch: Input={symbol:03x}, Expected={expected_value}, Got={dut_doi}\"\n\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n# Runner to execute tests\ndef test_runner():\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\nif __name__ == \"__main__\":\n    test_runner()\n"}}
{"id": "cvdp_agentic_dram_controller_0001", "categories": ["cid003", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from old content to new content**\n    - `sed -i  \"problematic_line_number s/problematic_statement/non_problematic_statement/\" Buggy_RTL_code.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt, and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach: \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Design a `dramcntrl` module in SystemVerilog (filename: **dramcntrl.sv**) according to the specification detailed in `docs/specs.md`. The design must support DRAM initialization\u2014including a 100\u202f\u00b5s power-up delay, precharge, two auto-refresh cycles, and mode register programming\u2014followed by normal read/write operations. Parameterize the module with:\n\n- **del:** Delay counter width for initialization and auto-refresh.\n- **len_auto_ref:** Width for the auto-refresh counter.\n- **len_small:** Width for timing delays (tRCD, tRP, tRFC, etc.).\n- **addr_bits_to_dram, addr_bits_from_up, ba_bits:** For DRAM and upstream addressing.\n\nThe controller must drive DRAM control signals (`addr`, `ba`, `clk`, `cke`, `cs_n`, `ras_n`, `cas_n`, `we_n`, `dqm`) via an internal FSM that sequences commands (`ACTIVE`, `READ`, `WRITE`, `BURST TERMINATE`, `PRECHARGE`, `AUTO-REFRESH`). After a defined CAS latency for read commands, it must generate a read-data-ready signal. Include functions for vector increment and decrement, proper reset handling, edge detection for new read/write requests, and auto-refresh scheduling with saturation logic.\n\nAdditionally, provide a comprehensive SystemVerilog testbench (filename: **dramcntrl_tb.sv**) aligned with the provided testbench code requirements. The testbench must:\n\n- Generate a 100 MHz clock.\n- Apply reset, verify initialization (`dram_init_done` asserted), and simulate basic write and read operations.\n- Test concurrent read/write requests.\n- Stress auto-refresh scheduling (including saturating the auto-refresh counter) and verify `dram_busy`.\n- Force operations while busy and cover all branches of the RTL, ensuring 100% code coverage.\n\nProvide complete RTL (`dramcntrl.sv`) and testbench (`dramcntrl_tb.sv`) code that simulates and validates all functionality together.\n", "context": {"docs/specs.md": "## Overview\n\nAn SDRAM controller that manages DRAM initialization, auto-refresh, and read/write operations. It uses counters, state machines, and vector arithmetic (`incr_vec`/`dcr_vec`) to schedule commands and generate DRAM control signals (`addr`, `ba`, `clk`, `cke`, `cs`, `ras`, `cas`, `we`, `dqm`) based on defined timing parameters and external inputs.\n\nThe module implements an SDRAM controller that handles power-up initialization, periodic auto-refresh, and read/write command sequencing for a DRAM device. The design is fully parameterized to allow flexibility in timing, address width, and bank selection.\n\n---\n\n## Parameterization\n\n- **del:** Delay counter width for 100\u202f\u00b5s initialization and subsequent auto-refresh intervals.\n- **len_auto_ref:** Width of the counter tracking pending auto-refresh cycles.\n- **len_small:** Width of the small timing counter used to generate delays for `tRCD`, `tRP`, `tRFC`, etc.\n- **addr_bits_to_dram:** Width of the DRAM address bus.\n- **addr_bits_from_up:** Width of the upstream address input.\n- **ba_bits:** Bank address width.\n\n---\n\n## Interfaces\n\n### DRAM Pins\n\n- **addr:** DRAM address output.\n- **ba:** Bank address output.\n- **clk:** DRAM clock (synchronized to `clk_in`).\n- **cke:** Clock enable for DRAM.\n- **cs_n, ras_n, cas_n, we_n:** DRAM command signals.\n- **dqm:** Data mask signals.\n\n### Clock and Reset\n\n- **clk_in:** System clock input.\n- **reset:** Synchronous reset.\n\n### Upstream Control\n\n- **addr_from_up:** Address input from external logic.\n- **rd_n_from_up, wr_n_from_up:** Read and write control signals.\n- **bus_term_from_up:** Bus termination signal.\n- **dram_init_done:** Indicates completion of DRAM initialization.\n- **dram_busy:** Indicates the controller is busy (e.g., during auto-refresh cycles).\n\n---\n\n## Detailed Functionality\n\n### 1. Initialization Sequence\n\n- **Step 1:** On reset, a 100\u202f\u00b5s delay is generated using the delay counter (`delay_reg`). During this period, the controller issues either NOP or INHIBIT commands as required by the SDRAM power-up specification.\n- **Step 2:** A PRECHARGE command is issued to precharge all banks.\n- **Step 3:** Two AUTO-REFRESH commands are executed (each triggered after a delay interval, typically 7.81\u202f\u00b5s) to properly refresh all cells.\n- **Step 4:** The Mode Register is programmed with a predefined value (`mod_reg_val`). After a short wait (`tmrd` cycles), initialization is complete, and the signal **`dram_init_done`** is asserted.\n\n### 2. Auto-Refresh Scheduling\n\nOnce initialized, the delay counter generates periodic 7.81\u202f\u00b5s intervals. A saturating counter (`no_of_refs_needed`) counts the number of auto-refreshes required. When pending, the controller issues AUTO-REFRESH commands and decrements the counter.\n\n### 3. Read/Write Operation\n\n- **Write Operation:**\n  - On a write request (`wr_n_from_up` low) and when the previous transaction is complete (`rd_wr_just_terminated` is 0), the controller first issues an ACTIVE command to open the corresponding row (using part of the upstream address for row and bank selection).\n  - After a delay of `tRCD`, the WRITE command is issued with the lower bits used as the column address.\n\n- **Read Operation:**\n  - Similarly, on a read request (`rd_n_from_up` low), an ACTIVE command is issued to open the row, followed after `tRCD` by a READ command.\n  - A separate CAS latency pipeline asserts a read-data ready signal (`rd_dat_from_dram_ready`) after the defined CAS delay, and later the read operation is terminated with a BURST TERMINATE command and a precharge.\n\n### 4. Timing and Counters\n\n- **Delay Counter (`delay_reg`):** Implements the 100\u202f\u00b5s initialization delay and counts auto-refresh intervals.\n- **Small Counter (`small_count`):** Provides delays for command timing (`tRCD`, `tRP`, `tRFC`).\n- **Increment/Decrement Functions:** Custom functions (`incr_vec` and `dcr_vec`) manipulate vector counters, rolling over or saturating as required.\n\n### 5. Command Bus & Signal Generation\n\n- A 6-bit command bus encodes DRAM commands (`cs`, `ras`, `cas`, `we`, and two `dqm` bits).\n- Output signals (`addr`, `ba`, `clk`, `cke`, `cs_n`, `ras_n`, `cas_n`, `we_n`, `dqm`) are driven based on the command bus state.\n- The clock input (`clk_in`) is directly mapped to the output clock (`clk`).\n\n### 6. Control and Edge Detection\n\n- Edge detection circuits generate pulses (e.g., `wr_n_from_up_pulse`) based on upstream read/write signals to detect new requests.\n- A busy signal (`dram_busy`) indicates the controller is processing auto-refresh cycles or otherwise occupied.\n\n---\n\n## Summary\n\nThe DRAM controller module provides robust DRAM initialization, periodic auto-refresh, and precise read/write command sequencing. Its parameterized design and internal timing counters enable flexible integration with various DRAM devices and system clock frequencies, ensuring reliable operation in page burst mode with minimal CPU intervention."}, "patch": {"rtl/dramcntrl.sv": "", "verif/dramcntrl_tb.sv": ""}, "harness": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/dramcntrl.sv\nTOPLEVEL        = dramcntrl\nMODULE          = test_dramcntrl\nPYTHONPATH      = /src\nHASH            = b1db949850c50f699bdd407db0a58faf95edc193\nTARGET          = 81\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/dramcntrl.sv": "`timescale 1ns / 1ps\n\nmodule dramcntrl \n#(\n    //==========================================================================\n    // Parameters\n    //==========================================================================\n    parameter integer del               = 15, // for the delay counter width\n    parameter integer len_auto_ref      = 10, // auto-refresh scheduling counter\n    parameter integer len_small         = 8,  // small timings counter (tRCD, tRP, etc.)\n    parameter integer addr_bits_to_dram = 13,\n    parameter integer addr_bits_from_up = 24,\n    parameter integer ba_bits           = 2\n)\n(\n    //==========================================================================\n    // Ports\n    //==========================================================================\n\n    // -- DRAM pins\n    output reg [addr_bits_to_dram-1 : 0] addr,\n    output reg [ba_bits-1 : 0]          ba,\n    output reg                          clk,\n    output reg                          cke,\n    output reg                          cs_n,\n    output reg                          ras_n,\n    output reg                          cas_n,\n    output reg                          we_n,\n    output reg [1:0]                    dqm,\n\n    // -- Clock and reset inputs\n    input  wire                         clk_in,\n    input  wire                         reset,\n\n    // -- Interface from \"up\" to DRAM controller\n    input  wire [addr_bits_from_up-1:0] addr_from_up,\n    input  wire                         rd_n_from_up,\n    input  wire                         wr_n_from_up,\n    input  wire                         bus_term_from_up,\n    output wire                         dram_init_done,\n    output wire                         dram_busy\n);\n\n//\n//=============================================================================\n// Function Definitions: incr_vec and dcr_vec for different widths\n//=============================================================================\n\nfunction [del-1 : 0] incr_vec_15;\n    input [del-1 : 0] s1;\n    reg   [del-1 : 0] V, tb;\n    integer i;\nbegin\n    tb[0] = 1'b1;\n    V     = s1;\n    for (i = 1; i < del; i = i + 1) begin\n        tb[i] = V[i-1] & tb[i-1];\n    end\n    for (i = 0; i < del; i = i + 1) begin\n        if (tb[i] == 1'b1) V[i] = ~V[i];\n    end\n    incr_vec_15 = V;\nend\nendfunction\n\nfunction [len_auto_ref-1 : 0] incr_vec_10;\n    input [len_auto_ref-1 : 0] s1;\n    reg   [len_auto_ref-1 : 0] V, tb;\n    integer i;\nbegin\n    tb[0] = 1'b1;\n    V     = s1;\n    for (i = 1; i < len_auto_ref; i = i + 1) begin\n        tb[i] = V[i-1] & tb[i-1];\n    end\n    for (i = 0; i < len_auto_ref; i = i + 1) begin\n        if (tb[i] == 1'b1) V[i] = ~V[i];\n    end\n    incr_vec_10 = V;\nend\nendfunction\n\nfunction [len_small-1 : 0] incr_vec_8;\n    input [len_small-1 : 0] s1;\n    reg   [len_small-1 : 0] V, tb;\n    integer i;\nbegin\n    tb[0] = 1'b1;\n    V     = s1;\n    for (i = 1; i < len_small; i = i + 1) begin\n        tb[i] = V[i-1] & tb[i-1];\n    end\n    for (i = 0; i < len_small; i = i + 1) begin\n        if (tb[i] == 1'b1) V[i] = ~V[i];\n    end\n    incr_vec_8 = V;\nend\nendfunction\n\nfunction [del-1 : 0] dcr_vec_15;\n    input [del-1 : 0] s1;\n    reg   [del-1 : 0] V, tb;\n    integer i;\nbegin\n    tb[0] = 1'b0;\n    V     = s1;\n    for (i = 1; i < del; i = i + 1) begin\n        tb[i] = V[i-1] | tb[i-1];\n    end\n    for (i = 0; i < del; i = i + 1) begin\n        if (tb[i] == 1'b0) V[i] = ~V[i];\n    end\n    dcr_vec_15 = V;\nend\nendfunction\n\nfunction [len_auto_ref-1 : 0] dcr_vec_10;\n    input [len_auto_ref-1 : 0] s1;\n    reg   [len_auto_ref-1 : 0] V, tb;\n    integer i;\nbegin\n    tb[0] = 1'b0;\n    V     = s1;\n    for (i = 1; i < len_auto_ref; i = i + 1) begin\n        tb[i] = V[i-1] | tb[i-1];\n    end\n    for (i = 0; i < len_auto_ref; i = i + 1) begin\n        if (tb[i] == 1'b0) V[i] = ~V[i];\n    end\n    dcr_vec_10 = V;\nend\nendfunction\n\nfunction [len_small-1 : 0] dcr_vec_8;\n    input [len_small-1 : 0] s1;\n    reg   [len_small-1 : 0] V, tb;\n    integer i;\nbegin\n    tb[0] = 1'b0;\n    V     = s1;\n    for (i = 1; i < len_small; i = i + 1) begin\n        tb[i] = V[i-1] | tb[i-1];\n    end\n    for (i = 0; i < len_small; i = i + 1) begin\n        if (tb[i] == 1'b0) V[i] = ~V[i];\n    end\n    dcr_vec_8 = V;\nend\nendfunction\n\n//\n//=============================================================================\n// Internal Signals\n//=============================================================================\n\n// The \"delay_reg\" is 'del' bits wide\nreg [del-1 : 0] delay_reg;\n\n// For address and bank signals\nreg [addr_bits_to_dram-1 : 0] addr_sig;\nreg [ba_bits-1 : 0]           ba_sig;\n\n// DRAM init done signals\nreg dram_init_done_s;\nreg dram_init_done_s_del;\nreg reset_del_count;\n\n// Scheduling auto\u2011ref\nreg [len_auto_ref-1 : 0] no_of_refs_needed;\nreg one_auto_ref_time_done;\nreg one_auto_ref_complete;\nreg auto_ref_pending;\n\n// For small timing counters\nreg [len_small-1 : 0] small_count;\nreg small_all_zeros;\n\n// Delayed wr_n signals to detect pulses\nreg wr_n_from_up_del_1;\nreg wr_n_from_up_del_2;\nwire wr_n_from_up_pulse;  // purely combinational\n\n// Control signals\nreg rd_wr_just_terminated;\nreg dram_busy_sig;\n\n// Command bus [5:0]: bit5=cs, bit4=ras, bit3=cas, bit2=we, bit1=dqm(1), bit0=dqm(0)\nreg [5:0] command_bus;\n\n// \n//=============================================================================\n// Localparams for constants\n//=============================================================================\nlocalparam [11:0] mod_reg_val  = 12'b000000100111; //  \"000000100111\"\nlocalparam integer sd_init     = 10000;            // = 1000 * freq(100MHz) => ~100us\nlocalparam integer trp         = 4;                // = ~20ns\nlocalparam integer trfc        = 8;                // = ~66ns\nlocalparam integer tmrd        = 3;                // wait after mode reg load\nlocalparam integer trcd        = 2;                // ~15ns\nlocalparam integer auto_ref_co = 780;              // ~7.81us at 100MHz\n\n// Command patterns\nlocalparam [5:0] inhibit         = 6'b111111;\nlocalparam [5:0] nop             = 6'b011111;\nlocalparam [5:0] active          = 6'b001111;\nlocalparam [5:0] read_cmd        = 6'b010100;  \nlocalparam [5:0] write_cmd       = 6'b010000;  \nlocalparam [5:0] burst_terminate = 6'b011011;\nlocalparam [5:0] precharge       = 6'b001011;\nlocalparam [5:0] auto_ref_cmd    = 6'b000111;\nlocalparam [5:0] load_mode_reg   = 6'b000011;\nlocalparam [5:0] rd_wr_in_prog   = 6'b011100;  // command bus for ongoing RD/WR\n\n//=============================================================================\n// Main always blocks\n//=============================================================================\n\n// init_delay_reg:\n//      increments a counter for 100 us during initialization,\n//      then used for auto-ref scheduling (7.81 us).\n//\nalways @(posedge clk_in) begin\n    if (reset == 1'b1) begin\n        delay_reg              <= {del{1'b0}};\n        one_auto_ref_time_done <= 1'b0;\n    end \n    else begin\n        if (reset_del_count == 1'b1) begin\n            delay_reg <= {del{1'b0}};\n        end\n        // once dram_init_done_s_del is '1', we track the 7.81 us intervals\n        else if (dram_init_done_s_del == 1'b1) begin\n            if ($unsigned(delay_reg) == auto_ref_co) begin\n                delay_reg              <= {del{1'b0}};\n                one_auto_ref_time_done <= 1'b1;\n            end \n            else begin\n                delay_reg              <= incr_vec_15(delay_reg);\n                one_auto_ref_time_done <= 1'b0;\n            end\n        end\n        else begin\n            // still in initialization or counting up to init\n            delay_reg              <= incr_vec_15(delay_reg);\n            one_auto_ref_time_done <= 1'b0;\n        end\n    end\nend\n\n//\n// init_auto_ref_count_reg:\n//      Keeps track of how many auto-refs we still need to do.\n//      This is the \"typical\" Verilog style without overshadowing assignments.\n//\nalways @(posedge clk_in) begin\n    if (reset == 1'b1) begin\n        no_of_refs_needed <= {len_auto_ref{1'b0}};\n    end \n    else begin\n        // Only do increment/decrement if we have finished initialization\n        if (dram_init_done_s == 1'b1) begin\n            // saturate at all 1s if you want that behavior\n            if (no_of_refs_needed == {len_auto_ref{1'b1}}) begin\n                // remain saturated\n                no_of_refs_needed <= no_of_refs_needed;\n            end\n            else begin\n                // If we detect the 7.81us mark, increment\n                if (one_auto_ref_time_done == 1'b1) begin\n                    no_of_refs_needed <= incr_vec_10(no_of_refs_needed);\n                end\n                // If an auto-ref just finished, decrement\n                else if (one_auto_ref_complete == 1'b1) begin\n                    no_of_refs_needed <= dcr_vec_10(no_of_refs_needed);\n                end\n                else begin\n                    // no change\n                    no_of_refs_needed <= no_of_refs_needed;\n                end\n            end\n        end\n        else begin\n            // still 0 until init completes\n            no_of_refs_needed <= no_of_refs_needed;\n        end\n    end\nend\n\n//\n// init_reg:\n//      - SDRAM initialization steps\n//      - normal read/write commands\n//      - burst terminate & precharge\n//      - auto-refresh\n//\nalways @(posedge clk_in) begin\n    if (reset == 1'b1) begin\n        dram_init_done_s      <= 1'b0;\n        command_bus           <= inhibit;\n        one_auto_ref_complete <= 1'b0;\n        rd_wr_just_terminated <= 1'b0;\n        addr_sig              <= {addr_bits_to_dram{1'b0}};\n        ba_sig                <= {ba_bits{1'b0}};\n    end\n    else begin\n        //==========================================================\n        // STILL IN INITIALIZATION PHASE\n        //==========================================================\n        if (dram_init_done_s == 1'b0) begin\n            // Wait for ~100us => sd_init cycles\n            if      ($unsigned(delay_reg) == sd_init) begin\n                command_bus           <= precharge;\n                // A10=1 => precharge all\n                addr_sig              <= {addr_bits_to_dram{1'b0}};\n                addr_sig[10]          <= 1'b1; \n            end\n            else if ($unsigned(delay_reg) == (sd_init + trp)) begin\n                command_bus           <= auto_ref_cmd;\n            end\n            else if ($unsigned(delay_reg) == (sd_init + trp + trfc)) begin\n                command_bus           <= auto_ref_cmd;\n            end\n            else if ($unsigned(delay_reg) == (sd_init + trp + 2*trfc)) begin\n                command_bus           <= load_mode_reg;\n                // load mode reg => place mod_reg_val in addr[11:0]\n                addr_sig              <= {addr_bits_to_dram{1'b0}};\n                addr_sig[11:0]        <= mod_reg_val;\n            end\n            else if ($unsigned(delay_reg) == (sd_init + trp + 2*trfc + tmrd)) begin\n                dram_init_done_s      <= 1'b1;\n                command_bus           <= nop;\n            end\n            else begin\n                command_bus           <= nop;\n            end\n        end\n        //==========================================================\n        // NORMAL OPERATION\n        //==========================================================\n        else begin\n            //-------------------------\n            // DRAM WRITE request\n            //-------------------------\n            if ((wr_n_from_up == 1'b0) && (rd_wr_just_terminated == 1'b0)) begin\n                // Detect a \"new\" falling edge from idle => wr request\n                if (wr_n_from_up_del_1 == 1'b1) begin\n                    ba_sig      <= addr_from_up[23:22];\n                    command_bus <= active;\n                    // row address => 21:9\n                    addr_sig    <= addr_from_up[21:9];\n                end\n                // after tRCD cycles, issue WRITE\n                else if (small_count == trcd[len_small-1:0]) begin\n                    ba_sig      <= addr_from_up[23:22];\n                    command_bus <= write_cmd;\n                    // col address => 8:0\n                    addr_sig[8:0] <= addr_from_up[8:0];\n                end\n                else begin\n                    // stay in read/write in progress => dqm=00\n                    command_bus <= rd_wr_in_prog;\n                end\n            end\n\n            //-------------------------\n            // DRAM READ request\n            //-------------------------\n            else if ((rd_n_from_up == 1'b0) && (rd_wr_just_terminated == 1'b0)) begin\n                if (wr_n_from_up_del_1 == 1'b1) begin\n                    ba_sig      <= addr_from_up[23:22];\n                    command_bus <= active;\n                    addr_sig    <= addr_from_up[21:9];\n                end\n                else if (small_count == trcd[len_small-1:0]) begin\n                    command_bus <= read_cmd;\n                    addr_sig[8:0] <= addr_from_up[8:0];\n                end\n                else begin\n                    command_bus <= rd_wr_in_prog;\n                end\n            end\n\n            //-------------------------\n            // Burst Terminate when \n            // read/write finishes\n            //-------------------------\n            else if (((wr_n_from_up == 1'b1) || (rd_n_from_up == 1'b1)) &&\n                     (wr_n_from_up_del_1 == 1'b0)) begin\n                command_bus           <= burst_terminate;\n                rd_wr_just_terminated <= 1'b1;\n            end\n\n            //-------------------------\n            // Precharge after \n            // read/write completes\n            //-------------------------\n            else if (rd_wr_just_terminated == 1'b1) begin\n                // after 1 cycle, issue precharge\n                if (small_count == 1) begin\n                    ba_sig      <= addr_from_up[23:22];\n                    command_bus <= precharge;\n                end\n                // after tRP cycles, done\n                else if (small_count == trp[len_small-1:0]) begin\n                    command_bus           <= nop;\n                    rd_wr_just_terminated <= 1'b0;\n                end\n                else begin\n                    command_bus <= nop;\n                end\n            end\n\n            //-------------------------\n            // AUTO-REFRESH \n            //-------------------------\n            else if (auto_ref_pending == 1'b1) begin\n                // if small_count=0 => issue auto_ref\n                if (small_all_zeros == 1'b1) begin\n                    command_bus           <= auto_ref_cmd;\n                    one_auto_ref_complete <= 1'b0;\n                end\n                // after tRFC cycles => done\n                else if (small_count == trfc[len_small-1:0]) begin\n                    command_bus           <= nop;\n                    one_auto_ref_complete <= 1'b1;\n                end\n                else begin\n                    command_bus           <= nop;\n                    one_auto_ref_complete <= 1'b0;\n                end\n            end\n            else begin\n                // idle\n                command_bus <= nop;\n            end\n        end\n    end\nend\n\n//\n// reset_del_count_gen_reg:\n//      used to generate a pulse on reset_del_count\n//      when dram_init_done_s goes from 0 -> 1\n//\nalways @(posedge clk_in) begin\n    if (reset == 1'b1) begin\n        dram_init_done_s_del <= 1'b0;\n    end \n    else begin\n        dram_init_done_s_del <= dram_init_done_s;\n    end\nend\n\n// combinational pulse\nalways @(*) begin\n    reset_del_count = dram_init_done_s & (~dram_init_done_s_del);\nend\n\n//\n// gen_auto_ref_pending_cmb:\n//      sets auto_ref_pending=1 if no_of_refs_needed != 0\n//\nalways @(*) begin\n    if (no_of_refs_needed == {len_auto_ref{1'b0}}) \n        auto_ref_pending = 1'b0;\n    else\n        auto_ref_pending = 1'b1;\nend\n\n//\n// small_count_reg:\n//      timing counter for tRCD, tRP, tRFC, etc.\n//      resets on certain triggers\n//\nalways @(posedge clk_in or posedge reset) begin\n    if (reset == 1'b1) begin\n        small_count <= {len_small{1'b0}};\n    end \n    else begin\n        integer i;\n        reg all_ones;\n        all_ones = small_count[0];\n        for (i = 1; i < len_small; i = i + 1) begin\n            all_ones = all_ones & small_count[i];\n        end\n\n        // Reset small_count on these conditions:\n        if (\n           // after a read/write + precharge is done\n           ((one_auto_ref_time_done == 1'b1) && (wr_n_from_up == 1'b1) && (rd_n_from_up == 1'b1)) ||\n           ((one_auto_ref_complete   == 1'b1) && (wr_n_from_up == 1'b1) && (rd_n_from_up == 1'b1)) ||\n           ((wr_n_from_up_del_1     == 1'b0) && (rd_n_from_up == 1'b1) && (wr_n_from_up == 1'b1)) ||\n           (wr_n_from_up_pulse == 1'b1) ||\n           ((small_count == trp[len_small-1:0]) && (rd_wr_just_terminated == 1'b1))\n          )\n        begin\n            small_count <= {len_small{1'b0}};\n        end \n        else if (all_ones == 1'b1) begin\n            // saturate\n            small_count <= small_count;\n        end \n        else begin\n            // increment\n            small_count <= incr_vec_8(small_count);\n        end\n    end\nend\n\n//\n// gen_small_all_zeros_cmb:\n//      asserts small_all_zeros=1 if small_count==0\n//\nalways @(*) begin\n    integer i;\n    reg any_bit;\n    any_bit = small_count[0];\n    for (i = 1; i < len_small; i = i + 1) begin\n        any_bit = any_bit | small_count[i];\n    end\n    small_all_zeros = ~any_bit;\nend\n\n//\n// wr_n_from_up_del_reg:\n//      used to produce pulses on wr_n_from_up \n//      for read/write requests (detect falling edge from (1,1))\n// \nalways @(posedge clk_in) begin\n    // We combine wr_n_from_up & rd_n_from_up => \n    // \"both high means idle or no request\"\n    wr_n_from_up_del_1 <= wr_n_from_up & rd_n_from_up;\n    wr_n_from_up_del_2 <= wr_n_from_up_del_1;\nend\n\n// falling edge detect for wr_n_from_up & rd_n_from_up\nassign wr_n_from_up_pulse = (~(wr_n_from_up & rd_n_from_up)) & (wr_n_from_up_del_1);\n\n//\n// dram_busy_gen:\n//      Asserts dram_busy if auto-refs are pending\n//      and no read/write is in progress\n//\nalways @(posedge clk_in) begin\n    if (reset == 1'b1) begin\n        dram_busy_sig <= 1'b0;\n    end \n    else begin\n        // If we have pending auto-refs and the bus is idle\n        if ((no_of_refs_needed != {len_auto_ref{1'b0}}) && \n            (wr_n_from_up_del_1 == 1'b0) &&\n            (rd_n_from_up == 1'b1) && (wr_n_from_up == 1'b1)) \n        begin\n            dram_busy_sig <= 1'b1;\n        end \n        // If a new read/write request arrives, we drop busy\n        else if ((no_of_refs_needed != {len_auto_ref{1'b0}}) &&\n                 ((wr_n_from_up == 1'b0) || (rd_n_from_up == 1'b0))) \n        begin\n            dram_busy_sig <= 1'b0;\n        end\n        // If no refs needed, not busy\n        else if (no_of_refs_needed == {len_auto_ref{1'b0}}) begin\n            dram_busy_sig <= 1'b0;\n        end\n        else begin\n            dram_busy_sig <= 1'b1;\n        end\n    end\nend\n\n//\n// cke_gen_reg:\n//       cke = 1 after reset deasserts\n//\nalways @(posedge clk_in) begin\n    if (reset == 1'b1) begin\n        cke <= 1'b0;\n    end \n    else begin\n        cke <= 1'b1;\n    end\nend\n\n//\n//=============================================================================\n// Final Output Assignments\n//=============================================================================\n\n// Clock out\nalways @(*) begin\n    clk = clk_in;\nend\n\n// From command_bus => chip selects, addresses, etc.\nalways @(*) begin\n    cs_n  = command_bus[5];\n    ras_n = command_bus[4];\n    cas_n = command_bus[3];\n    we_n  = command_bus[2];\n    dqm   = command_bus[1:0];\nend\n\n// DRAM address and bank\nalways @(*) begin\n    ba   = ba_sig;\n    addr = addr_sig;\nend\n\n// Signals to \"up\"\nassign dram_init_done        = dram_init_done_s;\nassign dram_busy             = dram_busy_sig;\n\nendmodule\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"DUT\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/test_dramcntrl.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.utils import get_sim_time\n\n###############################################################################\n# Helper: wait_cycles()\n###############################################################################\nasync def wait_cycles(dut, num_cycles):\n    \"\"\"Wait for `num_cycles` rising edges of dut.clk_in.\"\"\"\n    for _ in range(num_cycles):\n        await RisingEdge(dut.clk_in)\n\n@cocotb.test()\nasync def test_dramcntrl(dut):\n    \"\"\"\n    Cocotb test for the dramcntrl module, replicating the updated Verilog TB steps:\n\n    PHASE 1:  Reset + Initialization\n    PHASE 2:  Basic Writes\n    PHASE 3:  Basic Reads\n    PHASE 4:  Check auto-refresh\n    PHASE 5:  Concurrent read/write\n    PHASE 6:  Mid-test reset + re-init\n    PHASE 7:  Saturate no_of_refs_needed\n    PHASE 8:  Read/Write while busy\n    \"\"\"\n\n    ############################################################################\n    # Local pass/fail counters\n    ############################################################################\n    PASS_count = 0\n    FAIL_count = 0\n\n    ############################################################################\n    # Create a 100 MHz clock (10 ns period) on `dut.clk_in`\n    ############################################################################\n    clock = Clock(dut.clk_in, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    ############################################################################\n    # Initialize signals\n    ############################################################################\n    dut.reset.value            = 0\n    dut.addr_from_up.value     = 0\n    dut.rd_n_from_up.value     = 1\n    dut.wr_n_from_up.value     = 1\n    dut.bus_term_from_up.value = 1\n\n    ###########################################################################\n    # Define Tasks (async coroutines) converted from the Verilog tasks\n    ###########################################################################\n\n    async def apply_reset():\n        \"\"\"\n        Replicates the Verilog task: set reset=1 for 10 cycles, then back to 0\n        \"\"\"\n        dut.reset.value = 1\n        await wait_cycles(dut, 10)\n        dut.reset.value = 0\n\n    async def check_init_done():\n        \"\"\"\n        Waits up to 200000 clock cycles for dram_init_done to go high.\n        If it never does, it's a FAIL. Otherwise, PASS.\n        \"\"\"\n        nonlocal PASS_count, FAIL_count\n        max_wait_cycles = 200000\n        found_init = False\n\n        for _ in range(max_wait_cycles):\n            if dut.dram_init_done.value == 1:\n                cocotb.log.info(\n                    f\"Time {get_sim_time('ns')}: [PASS] dram_init_done asserted.\"\n                )\n                PASS_count += 1\n                found_init = True\n                break\n            await RisingEdge(dut.clk_in)\n\n        if not found_init:\n            cocotb.log.error(\n                f\"Time {get_sim_time('ns')}: [FAIL] dram_init_done not asserted within time limit!\"\n            )\n            FAIL_count += 1\n\n    async def do_write(address):\n        \"\"\"\n        Issues a WRITE to `address`.\n        - wr_n_from_up=0 for 3 cycles\n        - then deassert\n        - wait 12 cycles\n        \"\"\"\n        cocotb.log.info(\n            f\"Time {get_sim_time('ns')}: Starting WRITE to address 0x{address:X}\"\n        )\n        dut.wr_n_from_up.value     = 0\n        dut.addr_from_up.value     = address\n        dut.rd_n_from_up.value     = 1\n        dut.bus_term_from_up.value = 1\n\n        # Keep asserted for 3 cycles\n        await wait_cycles(dut, 3)\n\n        # Deassert\n        dut.wr_n_from_up.value = 1\n\n        # Wait 12 cycles for burst terminate + precharge\n        await wait_cycles(dut, 12)\n\n    async def do_read(address):\n        \"\"\"\n        Issues a READ to `address`.\n        - rd_n_from_up=0 for 3 cycles\n        - then deassert\n        - wait 12 cycles\n        \"\"\"\n        cocotb.log.info(\n            f\"Time {get_sim_time('ns')}: Starting READ from address 0x{address:X}\"\n        )\n        dut.rd_n_from_up.value     = 0\n        dut.addr_from_up.value     = address\n        dut.wr_n_from_up.value     = 1\n        dut.bus_term_from_up.value = 1\n\n        # Keep asserted for 3 cycles\n        await wait_cycles(dut, 3)\n\n        # Deassert\n        dut.rd_n_from_up.value = 1\n\n        # Wait 12 cycles for burst terminate + precharge\n        await wait_cycles(dut, 12)\n\n    async def do_concurrent_rd_wr(address_wr, address_rd):\n        \"\"\"\n        Forces read & write requests simultaneously:\n        1) wr_n_from_up=0, rd_n_from_up=0 at same time\n        2) Switch addresses mid-flight\n        3) Deassert write first, then read\n        \"\"\"\n        cocotb.log.info(\n            f\"Time {get_sim_time('ns')}: Starting concurrent RD & WR \"\n            f\"(WR=0x{address_wr:X}, RD=0x{address_rd:X})\"\n        )\n        # Step 1: Assert both\n        dut.wr_n_from_up.value     = 0\n        dut.rd_n_from_up.value     = 0\n        dut.addr_from_up.value     = address_wr\n        dut.bus_term_from_up.value = 1\n        await wait_cycles(dut, 5)\n\n        # Step 2: Switch addresses mid-flight\n        cocotb.log.info(f\"Time {get_sim_time('ns')}: Switching to read address 0x{address_rd:X}\")\n        dut.addr_from_up.value = address_rd\n        await wait_cycles(dut, 5)\n\n        # Step 3: Deassert write first\n        cocotb.log.info(\"Time %d: Deasserting write, keeping read active\" % get_sim_time('ns'))\n        dut.wr_n_from_up.value = 1\n        await wait_cycles(dut, 5)\n\n        # Step 4: Deassert read\n        cocotb.log.info(\"Time %d: Deasserting read\" % get_sim_time('ns'))\n        dut.rd_n_from_up.value = 1\n\n        # Wait for the precharge, etc.\n        await wait_cycles(dut, 12)\n\n    async def check_auto_ref_pending():\n        \"\"\"\n        Checks auto-refresh scheduling.\n        - Wait 1000 cycles\n        - See if no_of_refs_needed == 0 or if dram_busy=1\n        - Then wait 20 more cycles to see if dram_busy=0\n        \"\"\"\n        nonlocal PASS_count, FAIL_count\n\n        cocotb.log.info(\n            f\"Time {get_sim_time('ns')}: Checking auto-refresh scheduling ...\"\n        )\n        # Wait 1000 cycles\n        await wait_cycles(dut, 1000)\n\n        # Attempt to read internal signal no_of_refs_needed, if visible\n        try:\n            no_of_refs = int(dut.DUT.no_of_refs_needed.value)\n            if no_of_refs == 0:\n                cocotb.log.info(\n                    f\"Time {get_sim_time('ns')}: [INFO] No auto-refs needed yet (no_of_refs_needed=0).\"\n                )\n                PASS_count += 1\n            elif dut.dram_busy.value == 1:\n                cocotb.log.info(\n                    f\"Time {get_sim_time('ns')}: [INFO] dram_busy=1 => auto-refresh pending.\"\n                )\n                PASS_count += 1\n            else:\n                cocotb.log.warning(\n                    f\"Time {get_sim_time('ns')}: [WARNING] no_of_refs_needed={no_of_refs}, but dram_busy=0.\"\n                )\n        except AttributeError:\n            # If simulator hides internal signals:\n            cocotb.log.warning(\n                \"Could not read internal DUT.no_of_refs_needed. Skipping that portion of the check.\"\n            )\n\n        # Wait another 20 cycles\n        await wait_cycles(dut, 20)\n\n        if dut.dram_busy.value == 0:\n            cocotb.log.info(\n                f\"Time {get_sim_time('ns')}: [PASS] auto-refresh done (dram_busy=0).\"\n            )\n            PASS_count += 1\n        else:\n            cocotb.log.error(\n                f\"Time {get_sim_time('ns')}: [FAIL] auto-refresh still busy (dram_busy=1)!\"\n            )\n            FAIL_count += 1\n\n    async def saturate_no_of_refs():\n        \"\"\"\n        Forces many auto-refresh increments to drive no_of_refs_needed\n        toward saturation.\n        The Verilog code loops ~ (1 << (len_auto_ref - 2)) times,\n        each time waiting 800 cycles to trigger the 7.81us intervals.\n        NOTE: This can be very time-consuming in simulation.\n        \"\"\"\n        cocotb.log.info(\n            f\"Time {get_sim_time('ns')}: Attempting to saturate no_of_refs_needed...\"\n        )\n\n        try:\n            # We'll try to read the parameter len_auto_ref from the design if possible.\n            # Or just hard-code the known value. By default the user set len_auto_ref=10.\n            # If you want to read it from the HDL directly, that depends on your environment.\n            len_auto_ref = 10  # as per the localparam in the RTL\n            limit = 1 << (len_auto_ref - 2)\n        except:\n            limit = 256  # fallback\n\n        for _ in range(limit):\n            # ~800 cycles is enough time for the internal controller to increment\n            # one_auto_ref_time_done multiple times, building up no_of_refs_needed.\n            await wait_cycles(dut, 800)\n\n        # After the loop, print the final value if visible\n        try:\n            val = int(dut.DUT.no_of_refs_needed.value)\n            cocotb.log.info(\n                f\"Time {get_sim_time('ns')}: Done saturating no_of_refs_needed. Value = {val:b}\"\n            )\n        except AttributeError:\n            cocotb.log.warning(\"Could not read no_of_refs_needed after saturation.\")\n\n    async def do_test_during_busy():\n        \"\"\"\n        Forces a read and write while auto-refs are presumably pending (dram_busy=1).\n        NOTE: We rely on saturate_no_of_refs to have built up auto-ref backlog.\n        \"\"\"\n        cocotb.log.info(\n            f\"Time {get_sim_time('ns')}: Forcing new read/write while dram_busy may be active...\"\n        )\n        await do_read(0xFFFFAA)\n        await do_write(0xFFFBBB)\n\n    ###########################################################################\n    # PHASE 1: Basic Reset + Init\n    ###########################################################################\n    cocotb.log.info(\"==========================================================\")\n    cocotb.log.info(\"= Starting dramcntrl_tb (Cocotb) simulation              =\")\n    cocotb.log.info(\"==========================================================\")\n\n    # Apply reset & wait for initialization\n    await apply_reset()\n    await check_init_done()\n\n    ###########################################################################\n    # PHASE 2: Basic Writes\n    ###########################################################################\n    await do_write(0x000001)\n    await do_write(0x300123)\n    await do_write(0x1A0456)\n\n    ###########################################################################\n    # PHASE 3: Basic Reads\n    ###########################################################################\n    await do_read(0x000001)\n    await do_read(0x300123)\n    await do_read(0x1A0456)\n\n    ###########################################################################\n    # PHASE 4: Check auto-refresh\n    ###########################################################################\n    await check_auto_ref_pending()\n\n    ###########################################################################\n    # PHASE 5: Concurrent read/write\n    ###########################################################################\n    await do_concurrent_rd_wr(0xAAAAAA, 0xBBBBBB)\n\n    ###########################################################################\n    # PHASE 6: Mid-test reset + re-init\n    ###########################################################################\n    cocotb.log.info(\n        f\"Time {get_sim_time('ns')}: Applying mid-test reset to check re-init...\"\n    )\n    await apply_reset()\n    await check_init_done()\n\n    ###########################################################################\n    # PHASE 7: Saturate no_of_refs_needed\n    ###########################################################################\n    await saturate_no_of_refs()\n\n    ###########################################################################\n    # PHASE 8: Attempt read/write while busy\n    ###########################################################################\n    await do_test_during_busy()\n\n    # Check auto-refresh again after the above\n    await check_auto_ref_pending()\n\n    ###########################################################################\n    # Final results\n    ###########################################################################\n    cocotb.log.info(\"==========================================================\")\n    cocotb.log.info(f\"= TEST DONE.  PASSED={PASS_count},  FAILED={FAIL_count}\")\n    cocotb.log.info(\"==========================================================\")\n\n    if FAIL_count == 0:\n        cocotb.log.info(\"Overall: [PASS]\")\n    else:\n        cocotb.log.error(\"Overall: [FAIL]\")\n        # You can raise an exception if you want the test runner to mark it as failed:\n        # raise cocotb.result.TestFailure(\"Some checks failed.\")\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom cocotb.runner import get_runner\nimport pytest\nimport pickle\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\n@pytest.mark.tb\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\n#if __name__ == \"__main__\":\n#    test_runner()"}}
{"id": "cvdp_agentic_simd_matrix_engine_0001", "categories": ["cid003", "hard"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"problematic_line_number s/problematic_statement/non_problematic_statement/\" Buggy_RTL_code.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Design a SystemVerilog module named `simd_matrix_engine_top` that implements a **two\u2011level SIMD-based matrix arithmetic engine**. The module processes two flattened square input matrices using **SIMD vector instructions** and produces a flattened result matrix through parallel lane computation.\n\n---\n\n### Module Requirements:\n\nThe module should accept two sets of flattened matrix inputs, one for matrix A and one for matrix B, and apply a specified vector operation (ADD, SUB, or MUL) in **SIMD-width chunks**. It should generate a flattened result matrix as output and indicate when the computation is complete using a `done` signal.\n\n---\n\n### Two\u2011Level Execution Logic:\n\n#### Primary Level: FSM-Based Matrix Traversal\nUse a finite state machine (FSM) to manage matrix traversal row-by-row and column-by-column. The FSM must include the following states:\n\n- `IDLE`: Waits for `start` to assert.\n- `COMPUTE`: Slices rows into `SIMD_WIDTH` chunks and feeds them into the SIMD datapath.\n- `STORE`: Captures and writes the SIMD results into the output buffer.\n- `DONE`: Asserts `done` and resets the FSM to IDLE.\n\n#### Secondary Level: SIMD Lane Computation\nThe sliced matrix chunks are passed into a `simd_datapath` submodule that instantiates parallel `simd_lane` units. Each lane performs the selected operation (ADD, SUB, or MUL) and returns individual results. These are packed into the output result vector for storage.\n\n---\n\n###  Default Behavior:\n\n- If no valid operation is selected (`op_select` outside `000`, `001`, `010`), default all SIMD results to 0.\n- If `start` is not asserted, the FSM remains in the `IDLE` state, and all outputs remain inactive.\n- If no lane is valid, the result should be zero, and `ready` should be asserted immediately.\n\n---\n\n### Interfaces\n\n Parameterization\n\n- N: Defines the number of rows and columns in each square matrix (default: 8).\n\nSIMD_WIDTH:\n- Number of parallel processing lanes (default: 4). This allows row slices to be processed in parallel across the SIMD datapath.\n\nDATA_WIDTH:\n- Bit-width of each matrix element (default: 16).\n\n#### Clock and Reset\n\n- `clk` (1-bit): Clock input\n- `rst` (1-bit): Synchronous active-high reset\n\n#### Data Inputs\n\n- `mat_a_flat` (N\u00d7N\u00d7DATA_WIDTH): Flattened input matrix A\n- `mat_b_flat` (N\u00d7N\u00d7DATA_WIDTH): Flattened input matrix B\n\n#### Control Inputs\n\n- `start` (1-bit): Start computation\n- `op_select`: Operation code:\n  - `3'b000`: ADD\n  - `3'b001`: SUB\n  - `3'b010`: MUL\n\n#### Outputs\n\n- `mat_result_flat` (N\u00d7N\u00d7DATA_WIDTH): Flattened result matrix\n- `done` (1-bit): Asserted for one cycle when processing is complete\n\n---\n\n### Comprehensive Testbench:\n\nDevelop a complete SystemVerilog testbench that:\n\n- Instantiates the `simd_matrix_engine_top` module\n- Applies a wide range of **matrix operand test vectors** including:\n  - All-zero matrices\n  - All-maximum-value matrices\n  - Alternating bit patterns\n  - Identity matrix patterns\n  - Fully randomized values\n- Applies all supported operations (ADD, SUB, MUL)\n- Includes matrix slicing and flattening helpers (`flatten_matrix`, `unflatten_matrix`)\n- Uses `$display` to report:\n  - Current test ID\n  - Operation performed\n  - Input and output matrix content\n- Uses `$monitor` to trace signal transitions (e.g., FSM states, `done`)\n- Ends simulation with `$finish` after all test cases are completed\n\n---\n\n### Design Reference:\n\nRefer to the functional specification in `docs/simd_datapath_specs.md` and `docs/simd_lane_specs.md` for functional specifications and creation.\n\n---\n", "context": {"docs/simd_datapath_specs.md": "# SIMD Datapath Submodule Analysis\n\nThe `simd_datapath` module performs **SIMD-style parallel arithmetic processing** across multiple data lanes. It connects and coordinates multiple instances of the `simd_lane` submodule to apply vectorized operations such as addition, subtraction, and multiplication in parallel. This module is typically integrated into larger systems like matrix arithmetic engines, vector processors, or data-parallel accelerators.\n\n---\n\n## Parameterization\n\n- **SIMD_WIDTH:**  \n  Specifies the number of parallel SIMD lanes. Each lane operates on one scalar element. This allows the datapath to scale with the desired level of parallelism. Default: 4.\n\n- **DATA_WIDTH:**  \n  Defines the bit-width of each operand and result element within a lane. Default: 16.\n\n---\n\n## Interfaces\n\n### Data and Control Inputs\n\n- **a_flat (SIMD_WIDTH \u00d7 DATA_WIDTH bits):**  \n  Packed input vector A. Each segment corresponds to one SIMD lane.\n\n- **b_flat (SIMD_WIDTH \u00d7 DATA_WIDTH bits):**  \n  Packed input vector B. Each segment corresponds to one SIMD lane.\n\n- **valid_lanes (SIMD_WIDTH bits):**  \n  Lane mask enabling operation on a per-lane basis. A bit value of `1` enables that lane for computation.\n\n- **op_sel [2:0 bits]:**  \n  Operation selector:\n  - `3'b000`: ADD\n  - `3'b001`: SUB\n  - `3'b010`: MUL\n\n### Data Outputs\n\n- **result_flat (SIMD_WIDTH \u00d7 DATA_WIDTH bits):**  \n  Packed result vector. Each segment corresponds to the computed output from a SIMD lane.\n\n- **ready (1 bit):**  \n  Global ready signal. Asserted (`1`) when **all enabled lanes** have completed their operation.\n\n---\n\n## Detailed Functionality\n\n### 1. Lane Extraction\n\n- The `a_flat` and `b_flat` input vectors are unpacked into individual lane elements (`a_arr[i]`, `b_arr[i]`) using bit slicing logic.  \n- Each lane is sized as `DATA_WIDTH` bits and mapped to a unique SIMD index.\n\n### 2. SIMD Lane Instantiation\n\n- A `for-generate` block creates `SIMD_WIDTH` instances of the `simd_lane` module.\n- Each lane is connected to the corresponding elements of `a_arr[i]` and `b_arr[i]`.\n- The control signals `valid_lanes[i]` and `op_sel` are passed into each `simd_lane` instance.\n\n### 3. Output Assembly\n\n- Each lane returns a result (`result_arr[i]`) and a lane-local ready flag (`lane_ready[i]`).\n- The `result_arr` values are packed into `result_flat` using assign statements.\n- The global `ready` output is computed as a bitwise AND (`&lane_ready`) of all lane readiness signals.\n\n---\n\n## Safe and Scalable Design\n\n- If a lane is disabled (`valid_lanes[i] = 0`), the lane outputs `0`, and its ready signal is also considered asserted (`1`), ensuring **correct aggregation** of readiness.\n\n- This approach supports **partial vector operation**, where only a subset of lanes are active.\n\n- Designed with scalability in mind: increasing `SIMD_WIDTH` or `DATA_WIDTH` only requires regenerating the module with new parameters.\n\n---\n\n## Summary\n\n- **Purpose and Function:**  \n  The `simd_datapath` module enables parallel execution of arithmetic operations across multiple SIMD lanes using a vector-wide `op_sel`. It abstracts the complexity of individual lane control while preserving full parallelism.\n\n- **Parallelism and Flexibility:**  \n  Parameterized for lane count and data width. Allows for efficient implementation of wide vector operations such as vector addition, subtraction, and multiplication.\n\n- **Modular Composition:**  \n  Reuses the `simd_lane` submodule to ensure code reuse, scalability, and isolated verification.\n\n- **Latency and Timing:**  \n  Entirely combinational. Each operation completes in a single cycle assuming `simd_lane` is fully combinational. Ready signal reflects instant availability of results.\n---", "docs/simd_lane_specs.md": "# SIMD Lane Submodule Analysis\n\nThe `simd_lane` submodule implements a single-lane arithmetic datapath for SIMD-style parallel processing. It performs element-wise operations\u2014addition, subtraction, and multiplication\u2014on scalar inputs, and provides per-lane operation completion tracking. This module is intended to be instantiated multiple times within a higher-level `simd_datapath` module to realize full SIMD parallelism.\n\n---\n\n## Parameterization\n\n- **DATA_WIDTH:**  \n  Defines the bit-width of each input operand and output result (default is 16 bits). This parameter allows the SIMD lane to operate on different data sizes without structural changes.\n\n---\n\n## Interfaces\n\n### Data and Control Inputs\n\n- **a (DATA_WIDTH):**  \n  First operand for the lane operation.\n\n- **b (DATA_WIDTH):**  \n  Second operand for the lane operation.\n\n- **op_sel (3 bits):**  \n  Selects the operation to perform:\n  - `3'b000`: ADD\n  - `3'b001`: SUB\n  - `3'b010`: MUL\n\n- **valid (1 bit):**  \n  A control signal indicating whether the lane should perform the operation during the current cycle.\n\n### Data Outputs\n\n- **result (DATA_WIDTH):**  \n  Result of the selected arithmetic operation applied to inputs `a` and `b`.\n\n- **ready (1 bit):**  \n  Indicates that the lane has completed its computation. Set to `1` if `valid` is high and the operation has been executed.\n\n---\n\n## Detailed Functionality\n\n### 1. Combinational Arithmetic Logic\n\n- The lane is implemented using an `always_comb` block to ensure that outputs respond **immediately** to any change in inputs.\n\n- The logic first checks the `valid` signal. If `valid` is **not asserted**, the lane output `result` is set to `0`, and `ready` is deasserted (`0`), indicating the lane is idle.\n\n- If `valid` is asserted, the lane proceeds to evaluate the operation selector `op_sel`:\n\n  - **ADD (`3'b000`):**  \n    Performs unsigned addition: `result = a + b`.\n\n  - **SUB (`3'b001`):**  \n    Performs unsigned subtraction: `result = a - b`.\n\n  - **MUL (`3'b010`):**  \n    Performs unsigned multiplication: `result = a * b`.\n\n  - **Default Case:**  \n    Any unrecognized `op_sel` results in a zero output (`result = 0`), ensuring safe fallback behavior.\n\n- In all valid cases, the `ready` output is asserted (`1'b1`) to indicate the result is available.\n\n---\n\n## Safe Default Behavior\n\n- The design provides safe fallback behavior for **invalid or undefined operations**:\n  - If `valid` is low, the lane remains idle and outputs zero.\n  - If an unknown operation code is received, the lane defaults the `result` to `0`.\n\n- This ensures robust operation, especially during startup, resets, or unused lane configurations.\n\n---\n\n## Summary\n\n- **Purpose and Function:**  \n  The `simd_lane` submodule performs a **single scalar arithmetic operation** under SIMD control. It is designed for **parallel instantiation**, with independent enable (`valid`) and result tracking (`ready`) per lane.\n\n- **Parameter Flexibility:**  \n  The `DATA_WIDTH` parameter allows the lane to adapt to various bit-widths, supporting 8-, 16-, or 32-bit SIMD processing pipelines.\n\n- **Combinational Design:**  \n  The use of `always_comb` ensures **zero-latency propagation** from inputs to outputs, enabling efficient vector operations across all lanes without clocking.\n\n- **Error Handling and Defaults:**  \n  Default outputs (`0`) for invalid states provide safe and predictable behavior, making this submodule highly robust in larger vector pipelines.\n\n---\n\n### Integration\n\n- In a SIMD datapath (`simd_datapath`), instantiate `N` copies of `simd_lane`, each with its own slice of `a`, `b`, `result`, and `valid`.\n\n- Collect all `ready` signals to determine when all SIMD operations are complete (`&ready_array`).\n\n- Use this submodule to implement low-power, scalable arithmetic engines in image, DSP, or machine-learning accelerators.\n\n---"}, "patch": {"rtl/simd_datapath.sv": "", "rtl/simd_lane.sv": "", "rtl/simd_matrix_engine_top.sv": "", "verif/simd_matrix_engine_tb.sv": ""}, "harness": {"docker-compose.yml": "services:\n\n  direct:\n    image: hdlc/sim:osvb\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir  \n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true  ", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/simd_matrix_engine_top.sv /code/rtl/simd_datapath.sv /code/rtl/simd_lane.sv\nTOPLEVEL        = simd_matrix_engine_top\nMODULE          = test_simd_matrix_engine_top\nPYTHONPATH      = /src\nHASH            = 95a70e92de5ffefb794893c6aed28a8c08e94796\nTARGET          = 88\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /code/rtl/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        while len(info) < 3:\n            info.append(\"0%\")\n\n        inst = re.sub(r'[\\W]', '', info[0])\n\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n\n    # Check if the required key exists in the metrics\n    if \"dut\" not in metrics:\n        raise KeyError(\"Metrics data for 'dut' is missing in the coverage log.\")\n\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 88.0))  \n    assert metrics[\"dut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['dut']['Average']}, Target: {target}\"\n", "src/simd_matrix_engine_top.sv": "module simd_lane #(\n    parameter DATA_WIDTH = 16\n)(\n    input  wire [DATA_WIDTH-1:0] a,\n    input  wire [DATA_WIDTH-1:0] b,\n    input  wire [2:0] op_sel,\n    input  wire valid,\n    output reg  [DATA_WIDTH-1:0] result,\n    output reg  ready\n);\n\n    always @(*) begin\n        if (!valid) begin\n            result = 0;\n            ready  = 0;\n        end else begin\n            case (op_sel)\n                3'b000: result = a + b;\n                3'b001: result = a - b;\n                3'b010: result = a * b;\n                default: result = 0;\n            endcase\n            ready = 1;\n        end\n    end\n\nendmodule\nmodule simd_datapath #(\n    parameter SIMD_WIDTH = 4,\n    parameter DATA_WIDTH = 16\n)(\n    input  wire [SIMD_WIDTH*DATA_WIDTH-1:0] a_flat,\n    input  wire [SIMD_WIDTH*DATA_WIDTH-1:0] b_flat,\n    input  wire [SIMD_WIDTH-1:0] valid_lanes,\n    input  wire [2:0] op_sel,\n    output wire [SIMD_WIDTH*DATA_WIDTH-1:0] result_flat,\n    output wire ready\n);\n\n    wire [DATA_WIDTH-1:0] a_arr [0:SIMD_WIDTH-1];\n    wire [DATA_WIDTH-1:0] b_arr [0:SIMD_WIDTH-1];\n    wire [DATA_WIDTH-1:0] result_arr [0:SIMD_WIDTH-1];\n    wire [SIMD_WIDTH-1:0] lane_ready;\n\n    genvar i;\n    generate\n        for (i = 0; i < SIMD_WIDTH; i = i + 1) begin : SIMD_LANES\n            assign a_arr[i] = a_flat[i*DATA_WIDTH +: DATA_WIDTH];\n            assign b_arr[i] = b_flat[i*DATA_WIDTH +: DATA_WIDTH];\n\n            simd_lane #(.DATA_WIDTH(DATA_WIDTH)) u_lane (\n                .a(a_arr[i]),\n                .b(b_arr[i]),\n                .op_sel(op_sel),\n                .valid(valid_lanes[i]),\n                .result(result_arr[i]),\n                .ready(lane_ready[i])\n            );\n\n            assign result_flat[i*DATA_WIDTH +: DATA_WIDTH] = result_arr[i];\n        end\n    endgenerate\n\n    assign ready = &lane_ready;\n\nendmodule\nmodule simd_matrix_engine_top #(\n    parameter N = 8,\n    parameter SIMD_WIDTH = 4,\n    parameter DATA_WIDTH = 16\n)(\n    input  wire clk,\n    input  wire rst,\n    input  wire start,\n    input  wire [2:0] op_select,\n\n    input  wire [N*N*DATA_WIDTH-1:0] mat_a_flat,\n    input  wire [N*N*DATA_WIDTH-1:0] mat_b_flat,\n    output reg  [N*N*DATA_WIDTH-1:0] mat_result_flat,\n\n    output reg done\n);\n\n    // --- Internal State ---\n    reg [SIMD_WIDTH*DATA_WIDTH-1:0] a_row_flat;\n    reg [SIMD_WIDTH*DATA_WIDTH-1:0] b_row_flat;\n    wire [SIMD_WIDTH*DATA_WIDTH-1:0] result_flat;\n    wire [SIMD_WIDTH-1:0] valid_lanes;\n    wire simd_ready;\n\n    reg [$clog2(N)-1:0] row_idx;\n    reg [$clog2(N)-1:0] col_idx;\n    reg [1:0] state;\n\n    localparam IDLE    = 2'b00;\n    localparam COMPUTE = 2'b01;\n    localparam STORE   = 2'b10;\n    localparam DONE    = 2'b11;\n\n    // Valid mask for all SIMD lanes\n    assign valid_lanes = {SIMD_WIDTH{1'b1}};\n\n    // SIMD datapath\n    simd_datapath #(\n        .SIMD_WIDTH(SIMD_WIDTH),\n        .DATA_WIDTH(DATA_WIDTH)\n    ) u_simd (\n        .a_flat(a_row_flat),\n        .b_flat(b_row_flat),\n        .valid_lanes(valid_lanes),\n        .op_sel(op_select),\n        .result_flat(result_flat),\n        .ready(simd_ready)\n    );\n\n    // FSM + control\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            row_idx <= 0;\n            col_idx <= 0;\n            done <= 0;\n            a_row_flat <= 0;\n            b_row_flat <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (start) begin\n                        row_idx <= 0;\n                        col_idx <= 0;\n                        state <= COMPUTE;\n                    end\n                end\n\n                COMPUTE: begin\n                    // Extract current SIMD-width row chunk\n                    for (int i = 0; i < SIMD_WIDTH; i++) begin\n                        a_row_flat[i*DATA_WIDTH +: DATA_WIDTH] <=\n                            mat_a_flat[((row_idx * N) + col_idx + i) * DATA_WIDTH +: DATA_WIDTH];\n                        b_row_flat[i*DATA_WIDTH +: DATA_WIDTH] <=\n                            mat_b_flat[((row_idx * N) + col_idx + i) * DATA_WIDTH +: DATA_WIDTH];\n                    end\n\n                    if (simd_ready)\n                        state <= STORE;\n                end\n\n                STORE: begin\n                    for (int i = 0; i < SIMD_WIDTH; i++) begin\n                        mat_result_flat[((row_idx * N) + col_idx + i) * DATA_WIDTH +: DATA_WIDTH] <=\n                            result_flat[i*DATA_WIDTH +: DATA_WIDTH];\n                    end\n\n                    if (col_idx + SIMD_WIDTH >= N) begin\n                        col_idx <= 0;\n                        if (row_idx + 1 == N) begin\n                            state <= DONE;\n                        end else begin\n                            row_idx <= row_idx + 1;\n                            state <= COMPUTE;\n                        end\n                    end else begin\n                        col_idx <= col_idx + SIMD_WIDTH;\n                        state <= COMPUTE;\n                    end\n                end\n\n                DONE: begin\n                    done <= 1;\n                    state <= IDLE;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport re\nimport logging\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()", "src/test_simd_matrix_engine_top.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport random\n\nN = 8\nDATA_WIDTH = 16\n\ndef flatten_matrix(matrix):\n    flat = 0\n    for i in reversed(range(N)):\n        for j in reversed(range(N)):\n            flat = (flat << DATA_WIDTH) | (matrix[i][j] & ((1 << DATA_WIDTH) - 1))\n    return flat\n\ndef unflatten_matrix(bitvector):\n    matrix = [[0 for _ in range(N)] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            idx = i * N + j\n            matrix[i][j] = (bitvector >> (idx * DATA_WIDTH)) & ((1 << DATA_WIDTH) - 1)\n    return matrix\n\ndef compute_expected(A, B, op_sel):\n    result = [[0 for _ in range(N)] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            a, b = A[i][j], B[i][j]\n            if op_sel == 0:\n                result[i][j] = (a + b) & 0xFFFF\n            elif op_sel == 1:\n                result[i][j] = (a - b) & 0xFFFF\n            elif op_sel == 2:\n                result[i][j] = (a * b) & 0xFFFF\n    return result\n\ndef display_matrix(title, mat, dut):\n    dut._log.info(f\"\\n{title}\")\n    for row in mat:\n        dut._log.info(\"[\" + \", \".join(f\"{val:5d}\" for val in row) + \"]\")\n\n@cocotb.test()\nasync def test_simd_matrix_engine(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Reset\n    dut.rst.value = 1\n    dut.start.value = 0\n    dut.op_select.value = 0\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n\n    # Random test data\n    A = [[random.randint(0, 255) for _ in range(N)] for _ in range(N)]\n    B = [[random.randint(0, 255) for _ in range(N)] for _ in range(N)]\n    op_sel = random.choice([0, 1, 2])\n\n    dut._log.info(f\"\\n Testing Operation: {['ADD', 'SUB', 'MUL'][op_sel]}\")\n    display_matrix(\"Matrix A:\", A, dut)\n    display_matrix(\"Matrix B:\", B, dut)\n\n    # Drive inputs\n    dut.mat_a_flat.value = flatten_matrix(A)\n    dut.mat_b_flat.value = flatten_matrix(B)\n    dut.op_select.value = op_sel\n\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Wait for done\n    timeout = 1000\n    while dut.done.value == 0 and timeout > 0:\n        await RisingEdge(dut.clk)\n        timeout -= 1\n    assert timeout > 0, \" Timeout waiting for DUT to complete\"\n\n    # Read output\n    binstr = str(dut.mat_result_flat.value).lower().replace('x', '0')\n    result_flat = int(binstr, 2)\n    result_matrix = unflatten_matrix(result_flat)\n    expected_matrix = compute_expected(A, B, op_sel)\n\n    display_matrix(\"DUT Result Matrix:\", result_matrix, dut)\n    display_matrix(\"Expected Matrix   :\", expected_matrix, dut)\n\n    # Compare\n    errors = 0\n    for i in range(N):\n        for j in range(N):\n            if result_matrix[i][j] != expected_matrix[i][j]:\n                dut._log.error(f\" Mismatch at ({i},{j}): DUT={result_matrix[i][j]}, Expected={expected_matrix[i][j]}\")\n                errors += 1\n\n    assert errors == 0, f\"Test failed with {errors} mismatches.\"\n    dut._log.info(\" Test passed.\")\n"}}
