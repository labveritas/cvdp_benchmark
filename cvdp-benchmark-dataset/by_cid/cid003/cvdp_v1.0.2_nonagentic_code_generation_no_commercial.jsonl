{"id": "cvdp_copilot_16qam_mapper_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design a combinational RTL (using SystemVerilog) module to implement a QAM16 mapper with interpolation. The module maps input bits into QAM16 symbols, computes interpolated values between adjacent symbols, and outputs real (`I`) and imaginary (`Q`) components of the mapped and interpolated values.\n\n### Module Name:\n`qam16_mapper_interpolated`\n\nThe module is parameterized for flexibility in the number of input symbols while maintaining fixed bit widths for inputs and outputs to support QAM16 mapping.\n\n---\n\n## Parameters\n\n# Parameter Table\n\n| Parameter   | Description                            | Default | Constraints             |\n|-------------|----------------------------------------|---------|-------------------------|\n| `N`         | Number of input symbols               | 4       | \u2265 2 and multiple of 2 (e.g., 2, 4, 6, 8, etc.) |\n| `IN_WIDTH`  | Bit width of each input symbol (fixed) | 4       | Fixed at 4              |\n| `OUT_WIDTH` | Bit width of the output components (fixed) | 3   | Fixed at 3              |\n\n\n---\n\n## Inputs and Outputs\n\n### Inputs\n\n| Name        | Width                     | Description                                                                                     |\n|-------------|---------------------------|-------------------------------------------------------------------------------------------------|\n| `bits`      | `N*IN_WIDTH`              | Packed input bits. Each group of 4 bits (of width `IN_WIDTH`) represents a QAM16 symbol. Any combination of 4 bits is valid. The input is a packed set of `N` entries, each of `IN_WIDTH` (4 bits). |\n\n### Outputs\n\n| Name        | Width                     | Description                                                                                                               |\n|-------------|---------------------------|---------------------------------------------------------------------------------------------------------------------------|\n| `I`         | `(N + N/2)*OUT_WIDTH`     | Packed output of real (I) components, including mapped and interpolated values. Each `OUT_WIDTH` interval represents a signed integer. The size is automatically determined based on the existing parameters `N` and `OUT_WIDTH`. |\n| `Q`         | `(N + N/2)*OUT_WIDTH`     | Packed output of imaginary (Q) components, including mapped and interpolated values. Each `OUT_WIDTH` interval represents a signed integer. The size is automatically determined based on the existing parameters `N` and `OUT_WIDTH`. |\n\n---\n\n## Behavioral Definitions\n\n1. **Mapping Input Bits**:\n   - Each input symbol is divided into two distinct parts, based on the bit positions within the `IN_WIDTH` group:\n     - **MSBs** (most significant 2 bits): These correspond to bits `[IN_WIDTH-1 : IN_WIDTH-2]` of the symbol and are mapped to the `I` (real) component using the following values:\n       - `00`: `-3`\n       - `01`: `-1`\n       - `10`: `1`\n       - `11`: `3`\n     - **LSBs** (least significant 2 bits): These correspond to bits `[1 : 0]` of the symbol and are mapped to the `Q` (imaginary) component using the same values as above.\n   - This process is repeated for all `N` input symbols, with each symbol being extracted sequentially from the packed `bits` input vector.\n\n2. **Interpolation**:\n   - For every two consecutive symbols, compute the interpolated values for the `I` and `Q` components using a simple arithmetic mean:\n     - **Interpolated `I`**: This is the result of adding the `I` components of the two symbols and dividing the sum by 2.\n     - **Interpolated `Q`**: This is the result of adding the `Q` components of the two symbols and dividing the sum by 2.\n   - This process is repeated for all pairs of consecutive input symbols.\n   - The signals holding the interpolated samples need to have 1 bit more than `OUT_WIDTH` to accommodate the addition of two signed `OUT_WIDTH` signals.\n\n3. **Output Arrangement**:\n   - The outputs `I` and `Q` are arranged in the following order:\n     - First mapped symbol\n     - Interpolated value\n     - Second mapped symbol\n   - This pattern repeats for every pair of input symbols.\n\n---\n\n## Timing and Synchronization\n- The module operates entirely combinationally, with no clock or reset inputs.\n- Outputs are updated based on the current values of the input bits.", "context": {}}, "output": {"response": "", "context": {"rtl/16qam_mapper.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : /bin/sh -c \"pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -s\"", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/16qam_mapper.sv\nTOPLEVEL        = qam16_mapper_interpolated\nMODULE          = test_qam16_mapper_interpolated\nPYTHONPATH      = /src\nHASH            = 1-create-a-rtl-of-16qam-mapper", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def extract_signed(signal, width, total_elements):\n         signed_values = []\n         for i in reversed(range(total_elements)):\n             # Extract the unsigned value\n             unsigned_value = (signal.value.to_signed() >> (width * i)) & ((1 << width) - 1)\n             # Convert to signed\n             signed_value = unsigned_value - (1 << width) if unsigned_value & (1 << (width - 1)) else unsigned_value\n             signed_values.append(signed_value)\n         return signed_values", "src/test_qam16_mapper_interpolated.py": "import cocotb\nfrom cocotb.triggers import Timer\nimport random\nimport harness_library as hrs_lb\n\n\n@cocotb.test()\nasync def test_qam16_mapper_interpolated(dut):\n    \"\"\"Test the 16-QAM mapper with interpolation.\"\"\"\n\n    # Parameters from the DUT\n    N = int(dut.N.value)\n    IN_WIDTH = int(dut.IN_WIDTH.value)\n    OUT_WIDTH = int(dut.OUT_WIDTH.value)\n\n    # Debug mode\n    debug = 0\n\n    # Number of random test iterations\n    num_random_iterations = 98  # Adjust to complement the explicit cases for 100 total tests\n\n    # Explicit test cases to ensure edge coverage\n    test_cases = [\n        [0] * N,             # All zeros\n        [(1 << IN_WIDTH) - 1] * N  # All maximum values (e.g., 15 for IN_WIDTH=4)\n    ]\n\n    # Add random test cases\n    for _ in range(num_random_iterations):\n        test_cases.append([random.randint(0, (1 << IN_WIDTH) - 1) for _ in range(N)])\n\n    # Iterate through all test cases\n    for test_num, bits in enumerate(test_cases):\n        # Flatten the bits into a single input vector\n        bits_concat = sum((b << (i * IN_WIDTH)) for i, b in enumerate(reversed(bits)))\n\n        # Apply the input to the DUT\n        dut.bits.value = bits_concat\n\n        # Wait for 10 ns (1 clock cycle duration)\n        await Timer(10, units='ns')\n\n        # Extract the mapped I/Q values for validation\n        mapped_I = []\n        mapped_Q = []\n        for b in bits:\n            mapped_I.append({0b00: -3, 0b01: -1, 0b10: 1, 0b11: 3}[b >> 2])\n            mapped_Q.append({0b00: -3, 0b01: -1, 0b10: 1, 0b11: 3}[b & 0b11])\n\n        # Calculate interpolated I/Q values and build the expected output vectors\n        expected_I = []\n        expected_Q = []\n        for i in range(N // 2):\n            expected_I.extend([\n                mapped_I[2 * i],\n                (mapped_I[2 * i] + mapped_I[2 * i + 1]) // 2,\n                mapped_I[2 * i + 1]\n            ])\n            expected_Q.extend([\n                mapped_Q[2 * i],\n                (mapped_Q[2 * i] + mapped_Q[2 * i + 1]) // 2,\n                mapped_Q[2 * i + 1]\n            ])\n\n        # Use the helper function to extract DUT outputs\n        dut_I = await hrs_lb.extract_signed(dut.I, OUT_WIDTH, N + N // 2)\n        dut_Q = await hrs_lb.extract_signed(dut.Q, OUT_WIDTH, N + N // 2)\n\n        # Assertions\n        assert dut_I == expected_I, f\"Test {test_num}: I mismatch: DUT={dut_I}, Expected={expected_I}\"\n        assert dut_Q == expected_Q, f\"Test {test_num}: Q mismatch: DUT={dut_Q}, Expected={expected_Q}\"\n\n        if debug:\n            cocotb.log.info(f\"[DEBUG] Test {test_num}\")\n            cocotb.log.info(f\"[DEBUG] Input bits: {bits}\")\n            cocotb.log.info(f\"[DEBUG] Mapped I: {mapped_I}\")\n            cocotb.log.info(f\"[DEBUG] Mapped Q: {mapped_Q}\")\n            cocotb.log.info(f\"[DEBUG] DUT I: {dut_I}\")\n            cocotb.log.info(f\"[DEBUG] DUT Q: {dut_Q}\")\n            cocotb.log.info(f\"[DEBUG] Expected I: {expected_I}\")\n            cocotb.log.info(f\"[DEBUG] Expected Q: {expected_Q}\")\n\n    cocotb.log.info(f\"All {len(test_cases)} tests passed successfully.\")\n", "src/test_runner.py": "import os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(N: int = 4):\n    # Simulation parameters\n    parameter = {\n        \"N\": N\n    }\n\n    # Debug information\n    print(f\"[DEBUG] Running simulation with N={N}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Generate minimum(2), default(4), and random even values for N\nrandom_n_values = [2] + [4] + [random.randint(2, 8) * 2 for _ in range(3)]\n\n# Parametrize test for different even sizes of N\n@pytest.mark.parametrize(\"N\", random_n_values)\n@pytest.mark.parametrize(\"test\", range(3))\ndef test_data(N, test):\n    # Run the simulation with specified parameters\n    runner(N=N)"}}}
{"id": "cvdp_copilot_16qam_mapper_0006", "categories": ["cid003", "medium"], "input": {"prompt": "Design a combinational RTL (using SystemVerilog) module to implement a QAM16 demapper with error detection based on interpolated values. **QAM16** (16-Quadrature Amplitude Modulation) is a modulation scheme that represents data as combinations of four amplitude levels and four phase states, resulting in 16 unique symbols mapped in a 2D I/Q plane. The module converts QAM16 I/Q samples back into bit streams, checks the interpolated values for potential noise or errors, and sets an error flag if any discrepancies are detected.\n\n## Module Name\n`qam16_demapper_interpolated`\n\n## Parameters\n\n| Parameter   | Description                                    | Default | Constraints                                     |\n|-------------|------------------------------------------------|---------|-------------------------------------------------|\n| `N`         | Number of original input symbols               | 4       | \u2265 2 and a multiple of 2 (e.g., 2, 4, 6, 8, etc.)|\n| `OUT_WIDTH` | Bit width of each output symbol (fixed)        | 4       | Fixed at 4                                      |\n| `IN_WIDTH`  | Bit width of I/Q components (fixed)            | 3       | Fixed at 3                                      |\n\n## Inputs and Outputs\n\n### Inputs\n\n| Name | Width                | Description                                                                                     |\n|------|----------------------|-------------------------------------------------------------------------------------------------|\n| `I`  | `(N + N/2)*IN_WIDTH` | Packed input vector containing real (I) components of QAM16 symbols. The samples are organized in a repeating pattern: **mapped sample**, **interpolated sample**, **mapped sample**. Each `IN_WIDTH` segment represents a signed integer. |\n| `Q`  | `(N + N/2)*IN_WIDTH` | Packed input vector containing imaginary (Q) components of QAM16 symbols. The organization follows the same pattern as `I`: **mapped sample**, **interpolated sample**, **mapped sample**. Each `IN_WIDTH` segment represents a signed integer. |\n\n### Outputs\n\n| Name        | Width         | Description                                                                                  |\n|-------------|---------------|----------------------------------------------------------------------------------------------|\n| `bits`      | `N*OUT_WIDTH` | Packed output vector representing the original bit stream decoded from the input I/Q values. |\n| `error_flag`| 1             | Global flag indicating whether any errors were detected in the interpolated values.          |\n\n---\n\n## Example Inputs and Outputs for \\( N = 4 \\)\n### Inputs\n\n1. **Real (I) Input Vector**:\n   - Width: \\((N + N/2) * IN\\_WIDTH = (4 + 2) * 3 = 18\\) bits\n   - Example:\n     ```text\n     I = [Mapped 1, Interpolated 1, Mapped 2, Mapped 3, Interpolated 2, Mapped 4]\n     I = [-3, 0, 1, 1, -1, 3]\n     ```\n     Each value is a 3-bit signed integer.\n\n2. **Imaginary (Q) Input Vector**:\n   - Width: \\((N + N/2) * IN\\_WIDTH = 18\\) bits\n   - Example:\n     ```text\n     Q = [Mapped 1, Interpolated 1, Mapped 2, Mapped 3, Interpolated 2, Mapped 4]\n     Q = [-1, 2, 1, 3, -3, -3]\n     ```\n     Each value is a 3-bit signed integer.\n\n### Outputs\n\n1. **Bits Vector**:\n   - Width: \\(N * OUT\\_WIDTH = 4 * 4 = 16\\) bits\n   - Example Mapping:\n     ```text\n     bits = [MSB_1|LSB_1, MSB_2|LSB_2, MSB_3|LSB_3, MSB_4|LSB_4]\n     bits = [10|01, 01|10, 10|11, 11|00]\n     ```\n     Each 4-bit segment represents the demapped symbol, combining 2 bits from the real (`I`) component and 2 bits from the imaginary (`Q`) component.\n\n2. **Error Flag**:\n   - Width: \\(1\\) bit\n   - Example:\n     ```text\n     error_flag = 1\n     ```\n     Indicates that at least one interpolated value deviated beyond the acceptable threshold.\n\n---\n\n\n## Behavioral Definitions\n\n### Input Parsing\nThe input vectors consist of alternating **mapped** and **interpolated** values, structured in a repeating pattern. For every group of input symbols, the sequence includes the first mapped value, the interpolated value between the first and second mapped values, and the second mapped value. This pattern repeats across the entire input, ensuring that the real (`I`) and imaginary (`Q`) components follow the same structure.\n\n### Error Detection\n\nThe expected interpolated values for both `I` and `Q` mapped components are calculated as the average of two mapped values that surround the interpolated position. This is done by summing the two mapped values and dividing the result by 2. To ensure precision and prevent overflow, the calculation uses a signal size of `IN_WIDTH + 1` bits, as the addition of two signed values can produce a result with an extra bit due to carry.\n\nThe difference between the interpolated values and the expected values is calculated to measure deviations. This subtraction operation also requires a signal size of `IN_WIDTH + 1` bits to represent all possible outcomes. The absolute value of the difference is then computed to quantify the magnitude of deviation, ensuring the sign is irrelevant. The error flag is set to `1` if the absolute difference exceeds a predefined threshold (e.g., `ERROR_THRESHOLD`).\n\n### Mapping I/Q Components to Bits\nEach I/Q component is converted back into a 4-bit representation. The most significant 2 bits (MSBs) are derived from the `I` (real) component, where the normalized amplitude levels of the QAM16 constellation points (`-3`, `-1`, `1`, `3`) map to binary values as follows:\n- `-3`: `00`\n- `-1`: `01`\n- `1`: `10`\n- `3`: `11`\n\nSimilarly, the least significant 2 bits (LSBs) are derived from the `Q` (imaginary) component using the same mapping.\n\n### Output Arrangement\nThe output `bits` vector contains the demapped bit stream for all mapped symbols in the input. Each segment of `OUT_WIDTH` bits represents a mapped output derived from the corresponding mapped `I` and `Q` components of the input.\n\n---\n\n## Timing and Synchronization\nThe module operates combinationally, with no clock or reset signals. Outputs are updated immediately based on the current input values.", "context": {}}, "output": {"response": "", "context": {"rtl/16qam_demapper.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : /bin/sh -c \"pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -s\"", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/16qam_demapper.sv\nTOPLEVEL        = qam16_demapper_interpolated\nMODULE          = test_qam16_demapper_interpolated\nPYTHONPATH      = /src\nHASH            = 6-create-a-rtl-of-16qam-demapper", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def extract_signed(signal, width, total_elements):\n         signed_values = []\n         for i in reversed(range(total_elements)):\n             # Extract the unsigned value\n             unsigned_value = (signal.value.to_signed() >> (width * i)) & ((1 << width) - 1)\n             # Convert to signed\n             signed_value = unsigned_value - (1 << width) if unsigned_value & (1 << (width - 1)) else unsigned_value\n             signed_values.append(signed_value)\n         return signed_values\n\ndef generate_samples(N):\n    # Valid values\n    mapped_values = [-3, -1, 1, 3]  # Valid values for mapped symbols\n    interp_values = [-3, -2, -1, 0, 1, 2, 3]  # Valid values for interpolated symbols\n\n    # Initialize lists\n    I_values = []\n    Q_values = []\n\n    # Generate samples dynamically\n    for i in range(N // 2):\n        I_values.extend([\n            random.choice(mapped_values),  # First mapped\n            random.choice(interp_values),  # Interpolated\n            random.choice(mapped_values)   # Second mapped\n        ])\n        Q_values.extend([\n            random.choice(mapped_values),  # First mapped\n            random.choice(interp_values),  # Interpolated\n            random.choice(mapped_values)   # Second mapped\n        ])\n\n    return I_values, Q_values\n\ndef pack_signal(values, width):\n    packed_signal = 0\n    for i, value in enumerate(reversed(values)):\n        # Convert the signed value to unsigned representation\n        unsigned_value = value & ((1 << width) - 1)\n        # Shift and combine into the packed signal\n        packed_signal |= (unsigned_value << (i * width))\n    return packed_signal\n\ndef map_to_bits_vector(I_values, Q_values, N):\n    bits = []  # Initialize an empty list for the bit stream\n\n    for i in range(N):\n        # Map I (real component) to MSBs (Most Significant Bits)\n        if I_values[i] == -3:\n            bits.extend([0, 0])  # MSBs = 00\n        elif I_values[i] == -1:\n            bits.extend([0, 1])  # MSBs = 01\n        elif I_values[i] == 1:\n            bits.extend([1, 0])  # MSBs = 10\n        elif I_values[i] == 3:\n            bits.extend([1, 1])  # MSBs = 11\n\n        # Map Q (imaginary component) to LSBs (Least Significant Bits)\n        if Q_values[i] == -3:\n            bits.extend([0, 0])  # LSBs = 00\n        elif Q_values[i] == -1:\n            bits.extend([0, 1])  # LSBs = 01\n        elif Q_values[i] == 1:\n            bits.extend([1, 0])  # LSBs = 10\n        elif Q_values[i] == 3:\n            bits.extend([1, 1])  # LSBs = 11\n\n    return bits\n\n", "src/test_qam16_demapper_interpolated.py": "import cocotb\nfrom cocotb.triggers import Timer\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_qam16_demapper_interpolated(dut):\n    # Parameters from the DUT\n    N = int(dut.N.value)  # Number of mapped symbols\n    IN_WIDTH = int(dut.IN_WIDTH.value)\n    threshold = int(dut.ERROR_THRESHOLD.value)\n\n    # Debug mode\n    debug = 0\n\n    I_values, Q_values = hrs_lb.generate_samples(N)\n    mapped_indices = []\n    for i in range(N // 2):\n        mapped_indices.extend([3 * i, 3 * i + 2])  # First mapped and second mapped\n    \n    # Indices for interpolated values\n    interp_indices = [3 * i + 1 for i in range(N // 2)]  # Interpolated indices are always the middle (3*i + 1)\n    # Extract mapped values\n    mapped_I = [I_values[idx] for idx in mapped_indices]\n    mapped_Q = [Q_values[idx] for idx in mapped_indices]    \n\n    # Extract interpolated values\n    interp_I = [I_values[idx] for idx in interp_indices]\n    interp_Q = [Q_values[idx] for idx in interp_indices]\n    \n    error_flag = 0\n    for i in range(len(interp_I)):\n           # Calculate averages of mapped pairs\n           avg_I = (mapped_I[2 * i] + mapped_I[2 * i + 1]) / 2\n           avg_Q = (mapped_Q[2 * i] + mapped_Q[2 * i + 1]) / 2\n           cocotb.log.info(f'avg I= {avg_I}')\n           cocotb.log.info(f'avg Q= {avg_Q}')\n           # Compare with interpolated values\n           if abs(avg_I - interp_I[i]) > threshold or abs(avg_Q - interp_Q[i]) > threshold:\n               error_flag = 1\n\n    bit_vec = hrs_lb.map_to_bits_vector(mapped_I, mapped_Q, N)\n    bit_stream =\"\".join(str(bit) for bit in bit_vec)\n    packed_I = hrs_lb.pack_signal(I_values, IN_WIDTH)\n    packed_Q = hrs_lb.pack_signal(Q_values, IN_WIDTH)    \n    dut.I.value = packed_I\n    dut.Q.value = packed_Q\n\n    await Timer(1, units=\"ns\")\n    assert dut.bits.value == bit_stream\n    assert dut.error_flag.value == error_flag\n\n    if debug:\n      cocotb.log.info(f\"I_values: {I_values}\")\n      cocotb.log.info(f\"Q_values: {Q_values}\")\n      cocotb.log.info(f\"interp_I: {interp_I}\")\n      cocotb.log.info(f\"interp_Q: {interp_Q}\")\n      cocotb.log.info(f'error flag     = {error_flag}')\n      cocotb.log.info(f'error_flag dut = {dut.error_flag.value}')          \n      cocotb.log.info(f\"Packed I: {bin(packed_I)}\")\n      cocotb.log.info(f\"Packed Q: {bin(packed_Q)}\")    \n      cocotb.log.info(f\"DUT I_values: {dut.I.value}\")\n      cocotb.log.info(f\"DUT Q_values: {dut.Q.value}\")\n      cocotb.log.info(f'bits dut = {dut.bits.value}')\n      cocotb.log.info(f'bit model = {(bit_stream)}')\n", "src/test_runner.py": "import os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(N: int = 4):\n    # Simulation parameters\n    parameter = {\n        \"N\": N\n    }\n\n    # Debug information\n    print(f\"[DEBUG] Running simulation with N={N}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Generate minimum(2), default(4), and random even values for N\nrandom_n_values = [2] + [4] + [random.randint(2, 8) * 2 for _ in range(10)]\n\n# Parametrize test for different even sizes of N\n@pytest.mark.parametrize(\"N\", random_n_values)\n@pytest.mark.parametrize(\"test\", range(5))\ndef test_data(N, test):\n    # Run the simulation with specified parameters\n    runner(N=N)"}}}
{"id": "cvdp_copilot_64b66b_encoder_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design a 64b/66b encoder that supports data encoding with a 2-bit sync header. The encoder should take a 64-bit data input and a corresponding 8-bit control word. The 8-bit control word indicates which data octets (8-bit segments) within the 64-bit word are either pure data or contain control characters. Implement only pure data encoding that encodes 64b to 66b when the 8-bit control word is 8'b00000000.\n\n### Design Specification:\n\nA 64b/66b encoder is a digital circuit that converts a 64-bit data word into a 66-bit encoded output, commonly used in high-speed communication protocol like Ethernet. This encoding scheme appends a 2-bit sync header to the data to maintain synchronization and differentiate data from control words using 8-bit control input.\n\n#### Control Word Interpretation:\nThe encoder receives both:\n- A **64-bit data word**: Represented as 8 octets (8-bit segments).\n- An **8-bit control word**: Each bit represents whether the corresponding data octet contains pure data (`0`) or a control character (`1`).\n- **Control Bit = 0**: Indicates a pure data octet.\n- **Control Bit = 1**: Indicates a control character in the corresponding data octet, but only pure data encoding has to be implemented in the RTL.\n\n#### Supported Sync Word and Output Behavior:\nThe encoder appends a 2-bit sync header at the MSBs of the encoded output, based on the presence of control characters:\n- **Sync Word and Output data**:\n  - `2'b01`: All 8 octets are pure data. The 64-bit data word is passed directly to the encoded output.\n  - `2'b10`: At least one of the 8 octets is a control character. However, 64'd0 is passed in the output as control word encoding is not supported.\n\n### Inputs and Outputs:\n\n- **Inputs**:\n  - `clk_in`:  clock signal, triggering on the rising edge.\n  - `rst_in`: 1-bit Active HIGH asynchronous reset. When HIGH, the `encoder_data_out` is zero\n  - `encoder_data_in ([63:0])`: 64-bit data word.\n  - `encoder_control_in ([7:0])`: 8-bit control word indicating pure data (`0`) or control character (`1`) per octet. A value of `8'b00000000` indicates data encoding.\n\n- **Output**:\n  - `encoder_data_out ([65:0])`: 66-bit encoded output, consisting of a 2-bit sync word at the MSBs followed by 64-bit data word. Output Latency is one clock cycle.\n\n### Example Operations:\n\n**Example 1**: Encoding a Data Word (All Data Octets)\n\n- **Input**: `encoder_control_in = 8'b00000000`, `encoder_data_in = 64'hA5A5A5A5A5A5A5A5`\n- **Expected Output**: `encoder_data_out = {2'b01, 64'hA5A5A5A5A5A5A5A5}`\n\n**Example 2**: Control Word (Not Supported in RTL)\n\n- **Input**: `encoder_control_in = 8'b00001111`, `encoder_data_in = 64'hA5A5A5A5A5A5A5A5`\n- **Expected Output**: `encoder_data_out = {2'b10, 64'h0000000000000000}`", "context": {}}, "output": {"response": "", "context": {"rtl/encoder_64b66b.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v -s\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/encoder_64b66b.sv \nTOPLEVEL        = encoder_64b66b\nMODULE          = test_encoder_64b66b\nPYTHONPATH      = /src\nHASH            = df990f8d23b386f0f323c52fe0ca70ff9fca4aa4\n", "src/test_encoder_64b66b.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n# Helper function to initialize DUT inputs\nasync def dut_initialization(dut):\n    \"\"\" Initialize all inputs for DUT \"\"\"\n    dut.rst_in.value = 1\n    dut.encoder_data_in.value = 0\n    dut.encoder_control_in.value = 0\n    await RisingEdge(dut.clk_in)  # Wait for one clock cycle\n\n# Helper function to check the output with debug logging\nasync def check_output(dut, expected_sync, expected_data):\n    await RisingEdge(dut.clk_in)\n    actual_output = dut.encoder_data_out.value.integer\n    expected_output = (expected_sync << 64) | expected_data\n\n    # Log the actual and expected outputs\n    dut._log.info(f\"Checking output:\\n\"\n                  f\"  Actual encoder_data_out: {hex(actual_output)}\\n\"\n                  f\"  Expected encoder_data_out: {hex(expected_output)}\\n\")\n\n    assert actual_output == expected_output, \\\n        f\"Test failed: encoder_data_out={hex(actual_output)} (expected {hex(expected_output)})\"\n\n@cocotb.test()\nasync def reset_test(dut):\n    \"\"\" Test the reset behavior of the encoder \"\"\"\n    # Start the clock\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    \n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    # Log the output after reset\n    dut._log.info(f\"Reset Test:\\n  encoder_data_out: {hex(dut.encoder_data_out.value.integer)}\\n  Expected: 0\")\n\n    # Check that output is zero after reset\n    assert dut.encoder_data_out.value == 0, \"Reset test failed: encoder_data_out should be zero after reset\"\n\n@cocotb.test()\nasync def data_encoding_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0xA5A5A5A5A5A5A5A5\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(dut.encoder_data_in.value.integer)}\\n\"\n                  f\"  encoder_control_in: {bin(dut.encoder_control_in.value.integer)}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0xA5A5A5A5A5A5A5A5)\n\n@cocotb.test()\nasync def control_encoding_test(dut):\n    \"\"\" Test encoding when control characters are in the last four octets \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    \n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    # Set test inputs\n    dut.encoder_data_in.value = 0xFFFFFFFFFFFFFFFF\n    dut.encoder_control_in.value = 0x0F  # Control in last four octets\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for control encoding test\n    dut._log.info(f\"Control Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(dut.encoder_data_in.value.integer)}\\n\"\n                  f\"  encoder_control_in: {bin(dut.encoder_control_in.value.integer)}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b10, expected_data=0x0000000000000000)  # Expected data output is zero\n\n@cocotb.test()\nasync def mixed_data_control_test(dut):\n    \"\"\" Test encoding when control characters are mixed in the data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Set test inputs\n    dut.encoder_data_in.value = 0x123456789ABCDEF0\n    dut.encoder_control_in.value = 0x81  # Control in first and last octets\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for mixed data and control test\n    dut._log.info(f\"Mixed Data and Control Test:\\n\"\n                  f\"  encoder_data_in: {hex(dut.encoder_data_in.value.integer)}\\n\"\n                  f\"  encoder_control_in: {bin(dut.encoder_control_in.value.integer)}\")\n\n    # Apply test and check output\n    await RisingEdge(dut.clk_in)\n    await check_output(dut, expected_sync=0b10, expected_data=0x0000000000000000)  # Expected data output is zero\n\n@cocotb.test()\nasync def all_control_symbols_test(dut):\n    \"\"\" Test encoding when all characters are control \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Set test inputs\n    dut.encoder_data_in.value = 0xA5A5A5A5A5A5A5A5\n    dut.encoder_control_in.value = 0xFF  # All control\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for all control symbols test\n    dut._log.info(f\"All Control Symbols Test:\\n\"\n                  f\"  encoder_data_in: {hex(dut.encoder_data_in.value.integer)}\\n\"\n                  f\"  encoder_control_in: {bin(dut.encoder_control_in.value.integer)}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b10, expected_data=0x0000000000000000)  # Expected data output is zero\n\n@cocotb.test()\nasync def random_data_control_test(dut):\n    \"\"\" Test encoding with random data and control inputs \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    \n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    for i in range(5):  # Run 10 random tests\n        # Generate random data and control inputs\n        random_data = random.getrandbits(64)\n        random_control = random.getrandbits(8)\n\n        dut.encoder_data_in.value = random_data\n        dut.encoder_control_in.value = random_control\n\n        # Determine expected sync word and data based on control input\n        expected_sync = 0b01 if random_control == 0 else 0b10\n        expected_data = random_data if random_control == 0 else 0x0000000000000000\n\n        await RisingEdge(dut.clk_in)\n        # Log inputs for each random test\n        dut._log.info(f\"Random Test {i+1}:\\n\"\n                      f\"  encoder_data_in: {hex(dut.encoder_data_in.value.integer)}\\n\"\n                      f\"  encoder_control_in: {bin(dut.encoder_control_in.value.integer)}\")\n\n        await check_output(dut, expected_sync=expected_sync, expected_data=expected_data)\n\n        await Timer(10, units=\"ns\")  # Wait for next random test\n\n    dut._log.info(\"Randomized tests completed successfully\")\n\n@cocotb.test()\nasync def random_data_only_test(dut):\n    \"\"\" Test encoding with random data and control inputs \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    \n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    dut.encoder_control_in.value = 0  # All data\n    await RisingEdge(dut.clk_in)\n\n    for i in range(5):  # Run 10 random tests\n        # Generate random data and control inputs\n        random_data = random.getrandbits(64)\n\n        dut.encoder_data_in.value = random_data\n\n        # Determine expected sync word and data based on control input\n        expected_sync = 0b01\n        expected_data = random_data\n\n        await RisingEdge(dut.clk_in)\n        # Log inputs for each random test\n        dut._log.info(f\"Random Test {i+1}:\\n\"\n                      f\"  encoder_data_in: {hex(dut.encoder_data_in.value.integer)}\\n\"\n                      f\"  encoder_control_in: {bin(dut.encoder_control_in.value.integer)}\")\n\n        await check_output(dut, expected_sync=expected_sync, expected_data=expected_data)\n\n        await Timer(10, units=\"ns\")  # Wait for next random test\n\n    dut._log.info(\"Randomized tests completed successfully\")\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n# Runner to execute tests\ndef test_runner():\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\nif __name__ == \"__main__\":\n    test_runner()\n"}}}
{"id": "cvdp_copilot_8x3_priority_encoder_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design and implement an 8x3 priority encoder using Verilog. The priority encoder should take 8-bit input signal and output a 3-bit binary code representing the position of the highest-priority active input. The encoder should follow the priority order from the highest bit (bit 7) to the lowest bit (bit 0).\n\n**Specifications for module `priority_encoder_8x3 ` :**\n\n- Inputs:\n    - [7:0] in: An 8-bit input vector. The priority of the inputs decreases from bit 7 to bit 0.\n\n- Output:\n    - [2:0] out: A 3-bit output vector that represents the binary code corresponding to the highest-priority active input.\n\n**Priority Rules:**\n\n- The priority encoder should output the binary index of the highest active input line.\n    - For example, if in[7] is high, the output should be 3'b111 regardless of the state of the lower-priority bits.\n    - If none of the input lines are active (in is all zeros), the output should default to 3'b000.\n\n**Additional Details:**\n\n- Ensure that the output is updated immediately whenever there is a change in the input.", "context": {}}, "output": {"response": "", "context": {"rtl/priority_encoder.v": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n  \n  pytest:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/priority_encoder.v\nTOPLEVEL        = priority_encoder_8x3\nMODULE          = test_penc\nPYTHONPATH      = /src\nHASH            = ddd696ce558e45bcf35ea7b974f555a58ffd3aaf", "src/Makefile": "include $(shell cocotb-config --makefiles)/Makefile.sim", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 10):\n    # Restart Interface\n    reset_n.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n\ndef highbit_number(number: int, length=8, msb=True) -> int:\n    str_num = bin(number)[2:].zfill(length)\n    print(str_num)    \n    if '1' not in str_num:\n        return 0  # Return 0 if the number has no '1' bits\n    \n    if msb:\n        return length - str_num.index('1') - 1\n    else:\n        return str_num[::-1].index('1')\n", "src/test_penc.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport harness_library as hrs_lb\n\n# ----------------------------------------\n# - Tests\n# ----------------------------------------\n\n@cocotb.test()\nasync def test_penc(dut):\n\n    encoder_in = int(cocotb.plusargs[\"encoder_in\"])\n    \n    print(\"input value =\", bin(encoder_in))\n\n    await hrs_lb.dut_init(dut)\n    \n    # print(dir(dut))\n    dut['in'].value = encoder_in \n    await Timer(10, units=\"ns\")\n\n    # print(dut['in'].value)\n    msb_1_bit_num = hrs_lb.highbit_number(encoder_in, msb=True, length=8)\n    # print(f\"msb_1_bit_num = {msb_1_bit_num}\")\n\n    # ----------------------------------------\n    # - Check No Operation\n    # ----------------------------------------\n    # print(f\"encoder input = {encoder_in}, highest bit number is {msb_1_bit_num} and output is {dut.out.value}\")\n    if dut['in'].value.is_resolvable and dut.out.value.is_resolvable:\n        assert (dut.out.value == msb_1_bit_num), f\"encoder input = {encoder_in} binary is {bin(encoder_in)}, highest bit number is {msb_1_bit_num} and output is {dut.out.value}\"\n    else:\n        raise Exception(\"Error, input and output are not resolveable\")\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport random\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n# plus_args       = os.getenv(\"PLUSARGS\")\n# compile_args    = os.getenv(\"COMPILE_ARGS\")\n\n@pytest.mark.parametrize(\"test\", range(10))\ndef test_moving_run(test):\n    encoder_in = random.randint(0, 255)\n\n    plusargs=[f'+encoder_in={encoder_in}']\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        # parameters=parameter,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, plusargs=plusargs, waves=True)\n"}}}
{"id": "cvdp_copilot_Carry_Lookahead_Adder_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design a **Generate/Propagate (GP) module** in Verilog .v format for use in a **carry lookahead adder** design.The **Generate/Propagate (GP)** module is an essential part of the **carry lookahead adder** (CLA) architecture, which is designed to speed up the process of adding binary numbers by precomputing the carry signals in parallel. \n\n\n## Interface\n\n### Outputs:\n- **generate** signal (`o_generate`) : 1-bit signal, true if both `i_A` and `i_B` are 1 (indicates carry generation).\n- **propagate** signal (`o_propagate`) : 1-bit signal, true if either `i_A` or `i_B` is 1 (indicates carry propagation).\n- **carry-out** signal (`o_Cout `) : 1-bit carry-out signal, computed using the generate, propagate, and carry-in signals.\n\n### Inputs:\n- **i_A** : 1-bit input signal representing one operand bit.\n- **i_B** : 1-bit input signal representing the other operand bit.\n- **i_Cin** : 1-bit carry-in signal from the previous stage.\n\n\n## Truth Table:\n| i_A   | i_B   | i_Cin| o_generate | o_propagate | o_Cout (carry-out) |\n| --- | --- | --- | ------------ | ------------- | ---------------- |\n|  0  |  0  |  0  |      0       |       0       |        0         |\n|  0  |  0  |  1  |      0       |       0       |        0         |\n|  0  |  1  |  0  |      0       |       1       |        0         |\n|  0  |  1  |  1  |      0       |       1       |        1         |\n|  1  |  0  |  0  |      0       |       1       |        0         |\n|  1  |  0  |  1  |      0       |       1       |        1         |\n|  1  |  1  |  0  |      1       |       1       |        1         |\n|  1  |  1  |  1  |      1       |       1       |        1         |", "context": {}}, "output": {"response": "", "context": {"rtl/GP.v": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  07-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/GP.v\nTOPLEVEL        = GP\nMODULE          = test_gp_test\nPYTHONPATH      = /src\nHASH            = 38aac0f72a6904319272ac237e0ec054cfd2910b", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(dut, duration_ns = 10):\n    # Restart Interface\n    dut.reset.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    dut.reset.value = 0\n    await Timer(duration_ns, units='ns')\n    dut.reset._log.debug(\"Reset complete\")\n\nasync def enable_dut(dut):\n    # Restart Interface\n    dut.enable.value = 0\n    await RisingEdge(dut.clk)\n    dut.enable.value = 1\n    await RisingEdge(dut.clk)\n    dut.enable._log.debug(\"enable complete\")\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def calculate_moving_average(data_queue, current_sum, new_data, window):\n    if len(data_queue) < window:\n        data_queue.append(new_data)\n        current_sum += new_data\n    else:\n        oldest_data = data_queue.pop(0)\n        current_sum += new_data - oldest_data\n        data_queue.append(new_data)\n\n    expected_avg = current_sum // window\n    \n    return expected_avg, current_sum", "src/test_gp_test.py": "import cocotb\nfrom cocotb.triggers import Timer\n\n# Function to compute the expected output\ndef expected_outputs(i_A, i_B, i_Cin):\n    o_generate = i_A & i_B\n    o_propagate = i_A | i_B\n    o_Cout = o_generate | (o_propagate & i_Cin)\n    return o_generate, o_propagate, o_Cout\n\n@cocotb.test()\nasync def test_gp_test(dut):\n    \"\"\"Test GP module for all possible input combinations.\"\"\"\n    \n    for i_A in range(2):\n        for i_B in range(2):\n            for i_Cin in range(2):\n                \n                # Apply the inputs\n                dut.i_A.value = i_A\n                dut.i_B.value = i_B\n                dut.i_Cin.value = i_Cin\n                \n                # Wait for a short time to simulate signal propagation\n                await Timer(2, units='ns')\n                \n                # Get the output values from DUT\n                o_generate = int(dut.o_generate.value)\n                o_propagate = int(dut.o_propagate.value)\n                o_Cout = int(dut.o_Cout.value)\n                \n                # Get the expected values\n                expected_generate, expected_propagate, expected_Cout = expected_outputs(i_A, i_B, i_Cin)\n                \n                # Compare outputs with expected values\n                assert o_generate == expected_generate, f\"Mismatch for A={i_A}, B={i_B}, Cin={i_Cin}: o_generate={o_generate}, expected={expected_generate}\"\n                assert o_propagate == expected_propagate, f\"Mismatch for A={i_A}, B={i_B}, Cin={i_Cin}: o_propagate={o_propagate}, expected={expected_propagate}\"\n                assert o_Cout == expected_Cout, f\"Mismatch for A={i_A}, B={i_B}, Cin={i_Cin}: o_Cout={o_Cout}, expected={expected_Cout}\"\n                \n                dut._log.info(f\"Test passed for A={i_A}, B={i_B}, Cin={i_Cin}.\")\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n# random test\ndef test_gp_test():\n    runner()"}}}
{"id": "cvdp_copilot_GFCM_0001", "categories": ["cid003", "easy"], "input": {"prompt": "# Glitch-Free Clock Switching (MUX) RTL Design Specification\n\n### Objective:\nDesign an RTL module `glitch_free_mux` that switches between two input clock signals (`clk1` and `clk2`) based on a select input signal (`sel`). The output clock (`clkout`) must switch glitch-free. When `sel = 0`, the output clock should be `clk1`; when `sel = 1`, the output clock should be `clk2`. The transition between clocks must happen smoothly without any glitches. `rst_n` is asynchronous active-low reset input signal. When `rst_n` is asserted (`rst_n = 0`), `clkout` should be driven low.\n\n## Requirements\n1. **Glitch-Free Switching**:\n   - The output clock (`clkout`) must switch between `clk1` and `clk2` without any glitches. \n   - Assume that clk1 and clk2 are synchronous clocks. (Synchronous clocks have a predictable, consistent phase difference.)\n     - The waveform below shows examples of synchronous clocks with a fixed phase difference.\n     - `T` represents the fixed phase difference between `clk1` and `clk2`.\n     - `T` can be any value, as long as the minimum time between launching and capturing edges are greater than the maximum combinational delay between time arcs between `clk1` and `clk2`\n  ---\n   ```wavedrom\n{\n    signal:[\n        {name: \"clk1\", wave: \"010101010101010\", node: '.a...c......' },\n        {},\n        {name: \"clk2\", wave: \"0.1.0.1.0.1.0.1\",node: '..b...d......' },\n        {},\n        {},\n        {name: \"clk1\", wave: \"0.10101010101010\" , node: '..e.f......' },\n        {},\n        {name: \"clk2\", wave: \"010101010101010\" , node: '.g.h......'},\n        {},\n        {},\n        {name: \"clk1\", wave: \"0.1.0.1.0.1.0.1.0.1.0.1.0.1.0.\" , period: 0.5 , node: '..u.......v......'},\n        {},\n        {name: \"clk2\", wave: \"0..1...0...1...0...1...0...1..\" , period: 0.5, node: '...k.......l......'},\n        ],\n        edge: [\n    'a~b T', 'c~d T', 'g~e T', 'h~f T', 'u~k T', 'v~l T',\n    ],\n    head: {text:\n  ['tspan',\n    ['tspan', {class:'info h3'}, 'synchronous with fixed phase clocks examples '],\n    \n  ],\n  \n},\n}\n```\n---\n   - The `sel` signal is assumed to be driven by one of the two input clock sources (clk1 or clk2). It is synchronous to one of the input clocks.\n   - When `sel` changes from 0 to 1, `clk1` is disabled on the first positive edge of `clk1` after the `sel` change. Subsequently, `clk2` is enabled on the first positive edge of `clk2` after `clk1` is disabled.\n   - When `sel` changes from 1 to 0, `clk2` is disabled on the first positive edge of `clk2` after the `sel` change. Subsequently, `clk1` is enabled on the first positive edge of `clk1` after `clk2` is disabled.\n   - Glitch-free switching from `clk1` to `clk2` example waveform is shown below\n---   \n```wavedrom\n{\n    signal:[\n        {name: \"clk1\", wave: \"010101010101010\" },\n        {name: \"clk2\", wave: \"01.0.1.0.1.0.1.\"},\n        {name: \"sel\", wave: \"0..1...........\"},\n        {name: \"clk1_en\", wave: \"1....0.........\"},\n        {name: \"clk2_en\", wave: \"0........1.....\"},\n        {\"name\":\"clkout\", \"wave\" :\"01010....1.0.1.\" },\n        ],\n}\n```\n----", "context": {}}, "output": {"response": "", "context": {"rtl/glitch_free_mux.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\r\nWAVE            = True\r\nTOPLEVEL_LANG   = verilog\r\nVERILOG_SOURCES = /code/rtl/glitch_free_mux.sv\r\nTOPLEVEL        = glitch_free_mux\r\nMODULE          = test_glitch_free_mux\r\nPYTHONPATH      = /src\r\nHASH            = a4f72f37c406d4041d3a9fb9f783cd8ba30210f2\r\n", "src/harness_library.py": "import cocotb\r\nfrom cocotb.triggers import Timer,  RisingEdge, ReadOnly\r\nimport random\r\n\r\n#@cocotb.coroutine\r\nasync def phase_shifted_clock(signal, period, phase_shift, units=\"ns\"):\r\n    \"\"\"Generates a clock with a phase shift.\"\"\"\r\n    signal.value = 0 \r\n    # Timer doesn't accept zero offset\r\n    if phase_shift > 0:\r\n        await Timer(phase_shift, units=units)\r\n    while True:\r\n        await Timer(period // 2, units=units)\r\n        signal.value = ~ signal.value\r\n\r\nasync def check_glitch_free_transition(dut):\r\n    dut._log.info(f\"SEL EDGE\")\r\n    await ReadOnly()\r\n    if dut.sel.value == 0:\r\n        dut._log.info(f\"SEL 1->0\")\r\n        #Glitch condition\r\n        await RisingEdge(dut.clk2)\r\n        dut._log.info(f\"CLK2 POSEEDGE\")\r\n        await ReadOnly()\r\n        # Assert clkout is no longer follwing clk2 by the first edge of clk2 after sel deassertion\r\n        assert dut.clkout.value == 0, f\"Glitch detected, clkout is {dut.clkout.value}\"\r\n        await RisingEdge(dut.clk1)\r\n        dut._log.info(f\"CLK1 POSEEDGE\")\r\n\r\n    elif dut.sel.value == 1:\r\n        dut._log.info(f\"SEL 0->1\")\r\n        await RisingEdge(dut.clk1)\r\n        dut._log.info(f\"CLK1 POSEEDGE\")\r\n        await ReadOnly()\r\n        # Assert clkout is no longer follwing clk1 by the first edge of clk2 after sel assertion\r\n        assert dut.clkout.value == 0, f\"Glitch detected, clkout is {dut.clkout.value}\"\r\n        await RisingEdge(dut.clk2)\r\n        dut._log.info(f\"CLK2 POSEEDGE\")\r\n    await ReadOnly()\r\n\r\ndef random_clock_select(dut):\r\n    # List of clock signals\r\n    clocks = [dut.clk1, dut.clk2]\r\n    # Randomly choose between clk1 and clk2\r\n    selected_clk = random.choice(clocks)\r\n    return selected_clk", "src/test_glitch_free_mux.py": "import cocotb\r\nfrom cocotb.triggers import  Timer, RisingEdge, FallingEdge\r\nfrom cocotb.clock import Clock\r\nimport harness_library as util\r\nimport random\r\n\r\n@cocotb.test()\r\nasync def test_glitch_free_mux(dut):\r\n    # Generate two random period clock signals\r\n    clk1_period = random.randint(5, 20) # CLK1 with random clk period \r\n    await cocotb.start(util.phase_shifted_clock(dut.clk1, clk1_period, 0, \"ns\"))\r\n    dut._log.info(f\"clk1 STARTED, period: {clk1_period}, phase: 0\")\r\n\r\n    clk2_period = random.randint(1, 10) * clk1_period # clk2 is sync to clk1\r\n    clk2_phase = random.randint(0, clk2_period//2)\r\n    await cocotb.start(util.phase_shifted_clock(dut.clk2,clk2_period,clk2_phase, \"ns\"))\r\n    dut._log.info(f\"clk2 STARTED, period: {clk2_period}, phase: {clk2_phase}\")\r\n\r\n    # DUT RESET \r\n    dut.rst_n.value = 0 \r\n    await Timer(random.randint(1, 30), units=\"ns\") # Assert reset for random time \r\n    dut.rst_n.value = 1\r\n    dut._log.info(f\"DUT IS OUT OF RESET\") \r\n    \r\n    # Excercise sel signal with random assertion/deassertion time\r\n    dut.sel.value = 0 ; \r\n    await Timer(20, units=\"ns\")\r\n\r\n\r\n    # Randomly choose which clk sel will be driven by.\r\n    sel_sync_clock = util.random_clock_select(dut)\r\n    #cocotb.start_soon(util.verification_check(dut))\r\n    for i in range(50):\r\n        await RisingEdge(sel_sync_clock)\r\n        await FallingEdge(sel_sync_clock)\r\n        dut.sel.value = ~ dut.sel.value\r\n        \r\n        # After sel change\r\n        # 1. Wait one clock cycle to avoid glitches \r\n        # 2. Start the second clock on the next posedge, meanwhile clkout should be zero\r\n        await util.check_glitch_free_transition(dut)\r\n        \r\n\r\n        sel_time =  random.randint(50, 500)\r\n        for _ in range (sel_time):\r\n            if  dut.sel.value == 0 :\r\n                assert dut.clkout.value == dut.clk1.value, f\"clkout isn't follwing clk1\"\r\n            else:\r\n                assert dut.clkout.value == dut.clk2.value, f\"clkout isn't follwing clk2\"\r\n            await Timer(1, units=\"ns\")\r\n\r\n\r\n", "src/test_runner.py": "import os\r\nfrom cocotb_tools.runner import get_runner\r\nimport pytest\r\n\r\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\r\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\r\nsim             = os.getenv(\"SIM\", \"icarus\")\r\ntoplevel        = os.getenv(\"TOPLEVEL\")\r\nmodule          = os.getenv(\"MODULE\")\r\nwave            = bool(os.getenv(\"WAVE\"))\r\n\r\ndef runner():\r\n    runner = get_runner(sim)\r\n    runner.build(\r\n        sources=verilog_sources,\r\n        hdl_toplevel=toplevel,\r\n        always=True,\r\n        clean=True,\r\n        waves=wave,\r\n        verbose=False,\r\n        timescale=(\"1ns\", \"1ns\"),\r\n        log_file=\"sim.log\")\r\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\r\n\r\n# random test\r\ndef test_gfcm():\r\n    runner()"}}}
{"id": "cvdp_copilot_apb_dsp_unit_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design a **`apb_dsp_unit`** module in Verilog that serves as an APB interface for configuring internal registers. These registers specify which memory addresses are used for arithmetic operations (addition or multiplication). The computed result is then made available through a designated register.\n\n---\n\n## Register Descriptions\n\n1. **`r_operand_1`**  \n   - **Address:** 0x0  \n   - **Function:** Holds the memory address of the first operand.\n\n2. **`r_operand_2`**  \n   - **Address:** 0x1  \n   - **Function:** Holds the memory address of the second operand.\n\n3. **`r_Enable`**  \n   - **Address:** 0x2  \n   - **Values:**  \n     - `0`: DSP disabled  \n     - `1`: Addition mode  \n     - `2`: Multiplication mode  \n     - `3`: Data Writing mode  \n\n4. **`r_write_address`**  \n   - **Address:** 0x3  \n   - **Function:** Specifies the address in memory where data will be written.  \n   - **Default Value:** 0x00000000  \n   - **Usage:** If `r_Enable` = 3, the data in the `r_write_data` register is written to the address specified by this register.\n\n5. **`r_write_data`**  \n   - **Address:** 0x4  \n   - **Function:** Specifies the data to be written into memory.  \n   - **Default Value:** 0x00000000  \n   - **Usage:** If `r_Enable` = 3, the data in this register is written to the address specified by `r_write_address`.\n\n---\n\n## APB Interface: \n### Clock & Reset Signals\n- `pclk`: APB clock input for synchronous operations.  \n- `presetn`: Active-low asynchronous reset signal for system initialization.\n\n### APB Signals\n- `paddr` (input, 10 bits): Address bus for accessing internal CSR registers and Memory.  \n- `pselx` (input): APB select signal, indicating CSR and Memory selection.  \n- `penable` (input): APB enable signal, marking transaction progression.  \n- `pwrite` (input): Write-enable signal, distinguishing read from write operations, high for write and low for read operation.\n- `pwdata` (input, 8 bits): Write data bus for sending data to CSR registers and Memory.  \n- `pready` (output, reg): Ready signal, indicating the completion of a transaction.  \n- `prdata` (output, reg, 8 bits): Read data bus for retrieving data.  \n- `pslverr` (output, reg): Error signal for invalid addresses or unsupported operations.\n\n## SRAM Interface:\n- `sram_valid`: At positive edge of this signal, data in `r_write_data` is latched to address in `r_write_address`.\n\n---\n\n## APB Protocol\n\n1. **Read Operations**  \n   - In the **READ_STATE**, drive `prdata` with the register value corresponding to `paddr`.\n   - After operation, return to **IDLE**.\n\n2. **Write Operations**  \n   - In the **WRITE_STATE**, update the register selected by `paddr` with `pwdata`.  \n   - After updating the register, return to **IDLE**.\n\n3. **Reset Behavior**  \n   - When `presetn` is deasserted (active-low), reset all outputs and internal registers to their default values:\n     - Set `pready` and `pslverr` to 0.  \n     - Clear `prdata`.  \n     - Initialize `r_operand_1`, `r_operand_2`, `r_Enable`, `r_write_address`, and `r_write_data` to 0.\n\n---\n\n## Functional Behavior\n\n1. **APB Interface Control**  \n   - Memory is accessed via the APB interface.  \n   - The operational mode is controlled by **`r_Enable`**:\n     - **Default (0x0):** DSP is disabled.  \n     - **Write Mode (0x3):** Data can be written to memory.  \n     - **Addition Mode (0x1):** Values at the addresses specified by **`r_operand_1`** and **`r_operand_2`** are added. The result is stored at address **0x5**.  \n     - **Multiplication Mode (0x2):** Values at the addresses specified by **`r_operand_1`** and **`r_operand_2`** are multiplied. The result is stored at address **0x5**.  \n   - To read computed data directly via APB, use address **0x5** and retrieve it through **`PRDATA`**.\n\n2. **Error Handling**  \n   - If a read or write operation is attempted on an address outside the defined registers, **`PSLVERR`** is driven high (`1'b1`).\n\n3. **Wait States**  \n   - This design does not support wait states. All APB read/write operations complete in two clock cycles, with **`PREADY`** always driven high (`1'b1`).\n\n4. **Memory Interface**  \n   - A 1 KB SRAM module serves as the memory.\n\n**Note:** Addresses from **0x00** to **0x05** are reserved for configuration registers.", "context": {}}, "output": {"response": "", "context": {"rtl/apb_dsp_unit.v": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/apb_dsp_unit.v\nTOPLEVEL        = apb_dsp_unit\nMODULE          = test_apb_dsp_unit\nPYTHONPATH      = /src\nHASH            = 1-rtl-design", "src/test_apb_dsp_unit.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\n\ndef assert_equal(actual, expected, msg=\"\"):\n    \"\"\"Custom assertion with message.\"\"\"\n    assert actual == expected, f\"{msg}: Expected {expected}, but got {actual}\"\n\n# Helper function to perform an APB write\nasync def apb_write(dut, addr, data):\n    \"\"\"Perform a single APB write transaction: Setup + Access phase.\"\"\"\n    # Setup phase\n    dut.pselx.value = 1\n    dut.pwrite.value = 1\n    dut.paddr.value = addr\n    dut.pwdata.value = data\n    dut.penable.value = 0\n    await RisingEdge(dut.pclk)\n\n    # Access phase\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n\n    # De-assert\n    dut.pselx.value = 0\n    dut.penable.value = 0\n    dut.pwrite.value = 0\n    dut.paddr.value = 0\n    dut.pwdata.value = 0\n    await RisingEdge(dut.pclk)\n\n# Helper function to perform an APB read\nasync def apb_read(dut, addr):\n    \"\"\"Perform a single APB read transaction: Setup + Access phase. Returns the read data.\"\"\"\n    # Setup phase\n    dut.pselx.value = 1\n    dut.pwrite.value = 0\n    dut.paddr.value = addr\n    dut.penable.value = 0\n    await RisingEdge(dut.pclk)\n\n    # Access phase\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n    await Timer(1, units=\"ns\")\n    read_data = dut.prdata.value.integer\n\n    # De-assert\n    dut.pselx.value = 0\n    dut.penable.value = 0\n    dut.paddr.value = 0\n    await RisingEdge(dut.pclk)\n\n    return read_data\n\n@cocotb.test()\nasync def test_apb_dsp_unit(dut):\n    \"\"\"Testbench for the APB DSP Unit.\"\"\"\n\n    # Create a clock\n    clock = Clock(dut.pclk, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initially drive inputs to known values\n    dut.pselx.value = 0\n    dut.penable.value = 0\n    dut.pwrite.value = 0\n    dut.pwdata.value = 0\n    dut.paddr.value = 0\n    dut.presetn.value = 1\n\n    # Apply asynchronous reset\n    dut.presetn.value = 0\n    await Timer(20, units=\"ns\")  # hold reset low\n    dut.presetn.value = 1\n    await RisingEdge(dut.pclk)\n    await RisingEdge(dut.pclk)\n\n    #--------------------------------------------------------------------------\n    # Constants / Addresses (matching localparams in RTL)\n    #--------------------------------------------------------------------------\n    ADDR_OPERAND1   = 0x0\n    ADDR_OPERAND2   = 0x1\n    ADDR_ENABLE     = 0x2\n    ADDR_WRITE_ADDR = 0x3\n    ADDR_WRITE_DATA = 0x4\n    ADDR_RESULT     = 0x5\n\n    MODE_DISABLED   = 0x0\n    MODE_ADD        = 0x1\n    MODE_MULT       = 0x2\n    MODE_WRITE      = 0x3\n\n    #--------------------------------------------------------------------------\n    # 1. Check Reset Values\n    #--------------------------------------------------------------------------\n    # The RTL should have reset all registers to 0. Let's confirm.\n    op1 = await apb_read(dut, ADDR_OPERAND1)\n    assert_equal(op1, 0, \"After reset, r_operand_1 should be 0\")\n\n    op2 = await apb_read(dut, ADDR_OPERAND2)\n    assert_equal(op2, 0, \"After reset, r_operand_2 should be 0\")\n\n    enable = await apb_read(dut, ADDR_ENABLE)\n    assert_equal(enable, 0, \"After reset, r_enable should be 0\")\n\n    write_addr = await apb_read(dut, ADDR_WRITE_ADDR)\n    assert_equal(write_addr, 0, \"After reset, r_write_address should be 0\")\n\n    write_data = await apb_read(dut, ADDR_WRITE_DATA)\n    assert_equal(write_data, 0, \"After reset, r_write_data should be 0\")\n\n    #--------------------------------------------------------------------------\n    # 2. Write Mode Test\n    #--------------------------------------------------------------------------\n    # We'll write a value into memory (e.g., at address 100).\n    TEST_MEM_ADDR = 100\n    TEST_MEM_DATA = 0x55\n    dut.sram_valid.value = 0\n    # Set up the DSP for write mode\n    await apb_write(dut, ADDR_ENABLE, MODE_WRITE)        # r_enable = 3\n    await apb_write(dut, ADDR_WRITE_ADDR, TEST_MEM_ADDR) # r_write_address = 100\n    await apb_write(dut, ADDR_WRITE_DATA, TEST_MEM_DATA) # r_write_data = 0x55\n\n    # Now read back the memory at address 100 to confirm\n    dut.sram_valid.value = 1\n    await Timer(10, units=\"ns\")\n    dut.sram_valid.value = 0\n\n    read_val = await apb_read(dut, TEST_MEM_ADDR)\n    assert_equal(read_val, TEST_MEM_DATA, f\"Memory at address {TEST_MEM_ADDR} should hold 0x55\")\n\n    #--------------------------------------------------------------------------\n    # 3. Addition Mode Test\n    #--------------------------------------------------------------------------\n    # Let's store two different values in memory for addition. We'll use addresses 10 and 11.\n    await apb_write(dut, ADDR_WRITE_ADDR, 10)   # memory[10] = 0xA0\n    await apb_write(dut, ADDR_WRITE_DATA, 0xA0)\n    dut.sram_valid.value = 1\n    await Timer(10, units=\"ns\")\n    dut.sram_valid.value = 0\n    await apb_write(dut, ADDR_WRITE_ADDR, 11)   # memory[11] = 0x05\n    await apb_write(dut, ADDR_WRITE_DATA, 0x05)\n    dut.sram_valid.value = 1\n    await Timer(10, units=\"ns\")\n    dut.sram_valid.value = 0\n\n    # Switch to addition mode\n    await apb_write(dut, ADDR_ENABLE, MODE_ADD)\n    # Set the operand addresses\n    await apb_write(dut, ADDR_OPERAND1, 10)  # r_operand_1 = 10\n    await apb_write(dut, ADDR_OPERAND2, 11)  # r_operand_2 = 11\n\n    # Wait a cycle or two to let the DSP perform the operation\n    await RisingEdge(dut.pclk)\n    await RisingEdge(dut.pclk)\n\n    # Read the result from address 0x5\n    result_val = await apb_read(dut, ADDR_RESULT)\n    expected_sum = 0xA0 + 0x05\n    assert_equal(result_val, expected_sum & 0xFF,\n                 \"Addition result should be 0xA5 (lowest 8 bits if overflow)\")\n\n    #--------------------------------------------------------------------------\n    # 4. Multiplication Mode Test\n    #--------------------------------------------------------------------------\n    # Let's store two different values in memory for multiplication. We'll reuse addresses 10 and 11.\n    await apb_write(dut, ADDR_ENABLE, MODE_WRITE)        # r_enable = 3\n    await apb_write(dut, ADDR_WRITE_ADDR, 10)   # memory[10] = 0x02\n    await apb_write(dut, ADDR_WRITE_DATA, 0x02)\n    dut.sram_valid.value = 1\n    await Timer(10, units=\"ns\")\n    dut.sram_valid.value = 0\n    await apb_write(dut, ADDR_WRITE_ADDR, 11)   # memory[11] = 0x03\n    await apb_write(dut, ADDR_WRITE_DATA, 0x03)\n    dut.sram_valid.value = 1\n    await Timer(10, units=\"ns\")\n    dut.sram_valid.value = 0\n\n    # Switch to multiplication mode\n    await apb_write(dut, ADDR_ENABLE, MODE_MULT)\n\n    # Operands remain 10 and 11\n    await RisingEdge(dut.pclk)\n    await RisingEdge(dut.pclk)\n\n    # Read the result\n    result_val = await apb_read(dut, ADDR_RESULT)\n    expected_mult = 0x02 * 0x03\n    assert_equal(result_val, expected_mult & 0xFF,\n                 \"Multiplication result should be 6\")\n\n    \n    #--------------------------------------------------------------------------\n    # 6. Conclusion\n    #--------------------------------------------------------------------------\n    dut._log.info(\"APB DSP Unit test completed successfully.\")\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_apb_gpio_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design a GPIO module compatible with the Advanced Peripheral Bus (APB) protocol. The module should support configurable GPIO width, bidirectional control, interrupt generation, and robust synchronization. The design should be scalable, well-documented, and free of ambiguities.\n\n---\n\n### **APB Protocol Overview**\n\nThe Advanced Peripheral Bus (APB) is a simple, low-latency bus protocol commonly used for connecting peripheral devices in a system. It operates in two phases: \n1. **SETUP Phase**: Signals are configured to initiate a transaction.\n2. **ACCESS Phase**: Data transfer occurs when `penable` is asserted.\n\nThis design assumes:\n- **Always-High Ready**: The `pready` signal remains high, indicating no wait states are introduced.\n- **Error-Free Operation**: The `pslverr` signal remains low, indicating no errors occur.\n\nThis module supports write and read transactions, aligning with the standard APB protocol behaviors.\n\n---\n\n### **Module Requirements**\n\n#### **1. Module Name and Parameters**\n- **Module Name**: `cvdp_copilot_apb_gpio`\n- **Parameters**:\n  - `GPIO_WIDTH = 8` (default, configurable). Defines the number of GPIO pins.\n\n#### **2. Implementation Language**\nThe module must be implemented in SystemVerilog, leveraging its advanced features, such as parameterized modules, enumerated types, and enhanced hardware modeling capabilities.\n\n---\n\n#### **3. Input/Output Interfaces**\n- **Inputs**:\n  - `pclk`: Clock signal (rising-edge triggered).\n  - `preset_n`: Active-low asynchronous reset. Initializes all outputs and registers to their reset values.\n  - `psel`: APB peripheral select signal.\n  - `paddr[7:2]`: APB address bus.\n  - `penable`: APB transfer control signal.\n  - `pwrite`: APB write control signal.\n  - `pwdata[31:0]`: APB write data bus.\n  - `gpio_in[GPIO_WIDTH-1:0]`: Input signals from GPIO pins.\n\n- **Outputs**:\n  - `prdata[31:0]`: APB read data bus. Reflects the content of the addressed register.\n  - `pready`: APB ready signal (always high).\n  - `pslverr`: APB error signal (always low).\n  - `gpio_out[GPIO_WIDTH-1:0]`: Output signals to GPIO pins, driven by internal registers.\n  - `gpio_enable[GPIO_WIDTH-1:0]`: Direction control signals for GPIO pins. **High for output, low for input.**\n  - `gpio_int[GPIO_WIDTH-1:0]`: Individual interrupt signals for GPIO pins.\n  - `comb_int`: Combined interrupt signal (logical OR of all `gpio_int` signals).\n\n---\n\n#### **4. Register Map**\nThe module should implement the following registers:\n- `0x00`: **GPIO Input Data** (Read-only). Reflects the synchronized state of `gpio_in`.\n- `0x04`: **GPIO Output Data**. Controls the `gpio_out` signals.\n- `0x08`: **GPIO Output Enable**. Configures the direction via `gpio_enable`.\n- `0x0C`: **GPIO Interrupt Enable**. Enables/disables interrupts for individual GPIOs.\n- `0x10`: **GPIO Interrupt Type**. Configures edge or level sensitivity for interrupts.\n- `0x14`: **GPIO Interrupt Polarity**. Determines **active-high or active-low** interrupt behavior.\n- `0x18`: **GPIO Interrupt State** (Read-only). Reflects the current interrupt status.\n\n---\n\n#### **5. Behavioral and Timing Requirements**\n- **Clocking and Reset**:\n  - The module operates on the **rising edge** of `pclk`.\n  - All outputs and internal registers reset to `0` when `preset_n` is asserted (active-low).\n\n- **APB Read/Write Logic**:\n  - Decode APB addresses to select the appropriate register.\n  - Align `prdata` with the content of the addressed register during read operations.\n  - Writes update the corresponding registers on valid address and control signals.\n\n- **GPIO Behavior**:\n  - `gpio_out` is driven by the output data register (`reg_out`).\n  - `gpio_enable` configures the direction: **High for output, low for input.**\n  - Synchronize `gpio_in` with `pclk` using a two-stage flip-flop.\n\n- **Interrupt Logic**:\n  - **Edge- or Level-Sensitive Configuration**:\n    - The interrupt type is defined in the **GPIO Interrupt Type Register (`0x10`)**.\n    - **Edge-Sensitive Mode**: Interrupts are triggered on the rising or falling edge of the input signal, as configured.\n    - **Level-Sensitive Mode**: Interrupts are triggered based on the sustained high or low state of the input signal.\n  - **Polarity Configuration**:\n    - The **GPIO Interrupt Polarity Register (`0x14`)** allows the configuration of **active-high or active-low behavior**, applicable to both edge-sensitive and level-sensitive modes.\n  - **Combined Interrupt Signal**:\n    - The combined interrupt (`comb_int`) is the logical OR of all individual interrupt signals (`gpio_int`), reflecting the configured edge or level sensitivity.\n\n- **Edge Case Handling**:\n  - Undefined APB addresses result in `prdata = 0` and `pslverr = 0`.\n  - Handle simultaneous interrupts gracefully by giving priority to lower GPIO numbers.\n\n- **Timing and Latency**:\n  - The module introduces no additional latency; all outputs respond within a single clock cycle of the triggering input.\n\n---\n\n#### **6. Constraints and Edge Cases**\n- **Undefined Address Access**:\n  - Reads return `0`, writes have no effect.\n- **Reset Behavior**:\n  - All registers and outputs reset to `0` when `preset_n` is low.\n- **Interrupt Generation**:\n  - Ensure edge-sensitive interrupts detect both rising and falling edges when configured.\n  - Level-sensitive interrupts reflect the sustained state of the input.\n\n---\n\n#### **7. Implementation Guidelines**\n1. **Interfaces**:\n   - Declare all ports with proper directions and bit widths.\n   - Ensure signal names are consistent across the design and documentation.\n\n2. **Synchronization**:\n   - Use two-stage flip-flops for metastability mitigation on `gpio_in`.\n\n3. **Register Logic**:\n   - Implement all specified registers with clear read and write enable conditions.\n   - Ensure address decoding covers only defined registers.\n\n4. **Interrupt Logic**:\n   - Use bitwise operations to enable, mask, and generate interrupts.\n   - Include polarity and sensitivity configuration.\n\n5. **Edge Cases**:\n   - Test for invalid address accesses, simultaneous interrupt triggering, and reset conditions.\n\n---\n\n### **Testing Guidelines**\n- **Functional Verification**:\n  - Verify correct APB read/write operations and GPIO pin control.\n  - Test both edge-sensitive and level-sensitive interrupts.\n- **Reset Testing**:\n  - Ensure all outputs and registers reset correctly.\n- **Corner Cases**:\n  - Test simultaneous interrupts, invalid address accesses, and transitions during resets.\n\n---", "context": {}}, "output": {"response": "", "context": {"rtl/cvdp_copilot_apb_gpio.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cvdp_copilot_apb_gpio.sv\nTOPLEVEL        = cvdp_copilot_apb_gpio\nMODULE          = test_gpio_harness\nPYTHONPATH      = /src\nHASH            = 1-apb-compatible-gpio-module-design-with-interrupt-and-bidirectional-control\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_gpio_harness.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport logging\n\n# Constants\nAPB_ADDRESSES = {\n    'DATA_IN': 0x00,       # Address 0x00 >> 2 = 0x00\n    'DATA_OUT': 0x01,      # Address 0x04 >> 2 = 0x01\n    'DATA_OUT_EN': 0x02,   # Address 0x08 >> 2 = 0x02\n    'INT_ENABLE': 0x03,    # Address 0x0C >> 2 = 0x03\n    'INT_TYPE': 0x04,      # Address 0x10 >> 2 = 0x04\n    'INT_POLARITY': 0x05,  # Address 0x14 >> 2 = 0x05\n    'INT_STATE': 0x06      # Address 0x18 >> 2 = 0x06\n}\n\nasync def apb_write(dut, address, data):\n    \"\"\"Perform an APB write transaction\"\"\"\n    # Set APB write signals\n    dut.psel.value = 1\n    dut.paddr.value = address  # Word address\n    dut.pwrite.value = 1\n    dut.pwdata.value = data\n    dut.penable.value = 0\n\n    # Wait for posedge pclk\n    await RisingEdge(dut.pclk)\n\n    # Enable transfer\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n\n    # De-assert psel and penable\n    dut.psel.value = 0\n    dut.penable.value = 0\n\nasync def apb_read(dut, address):\n    \"\"\"Perform an APB read transaction and return the read data\"\"\"\n    # Set APB read signals\n    dut.psel.value = 1\n    dut.paddr.value = address  # Word address\n    dut.pwrite.value = 0\n    dut.penable.value = 0\n\n    # Wait for posedge pclk\n    await RisingEdge(dut.pclk)\n\n    # Enable transfer\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n\n    # Read prdata\n    read_data = int(dut.prdata.value)\n\n    # De-assert psel and penable\n    dut.psel.value = 0\n    dut.penable.value = 0\n\n    return read_data\n\ndef check_condition(condition, fail_msg, pass_msg, test_failures):\n    \"\"\"Helper function to log test results\"\"\"\n    if not condition:\n        logging.getLogger().error(fail_msg)\n        test_failures.append(fail_msg)\n    else:\n        logging.getLogger().info(pass_msg)\n\n@cocotb.test()\nasync def test1_write_read_data_output(dut):\n    \"\"\"Test 1: Write and Read Data Output Register (reg_dout)\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Test 1: Write and Read Data Output Register\")\n\n    # Retrieve GPIO_WIDTH from DUT parameters\n    GPIO_WIDTH = int(dut.GPIO_WIDTH.value)\n\n    # Start the clock\n    cocotb.start_soon(Clock(dut.pclk, 20, units=\"ns\").start())\n\n    # Reset\n    dut.preset_n.value = 0\n    await Timer(50, units='ns')  # Hold reset low for 50 ns\n    dut.preset_n.value = 1\n\n    # Wait for reset deassertion\n    await RisingEdge(dut.pclk)\n\n    # Perform APB write to DATA_OUT\n    write_data = 0xA5A5A5A5  # Write a pattern\n    write_data_masked = write_data & ((1 << GPIO_WIDTH) - 1)\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT'], write_data_masked)\n\n    # Perform APB read from DATA_OUT\n    read_data = await apb_read(dut, APB_ADDRESSES['DATA_OUT'])\n    expected_data = write_data_masked\n    actual_data = read_data\n\n    # Check Data Output Register\n    check_condition(\n        actual_data == expected_data,\n        f\"FAIL: Data Output Register mismatch. Expected: 0x{expected_data:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{actual_data:0{(GPIO_WIDTH + 3) // 4}X}\",\n        f\"PASS: Data Output Register value: 0x{actual_data:0{(GPIO_WIDTH + 3) // 4}X}\",\n        []\n    )\n\n@cocotb.test()\nasync def test2_write_read_output_enable(dut):\n    \"\"\"Test 2: Write and Read Output Enable Register (reg_dout_en)\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Test 2: Write and Read Output Enable Register\")\n\n    # Retrieve GPIO_WIDTH from DUT parameters\n    GPIO_WIDTH = int(dut.GPIO_WIDTH.value)\n\n    # Start the clock\n    cocotb.start_soon(Clock(dut.pclk, 20, units=\"ns\").start())\n\n    # Reset\n    dut.preset_n.value = 0\n    await Timer(50, units='ns')  # Hold reset low for 50 ns\n    dut.preset_n.value = 1\n\n    # Initialize list to collect failures\n    test_failures = []\n\n    # Perform APB write to DATA_OUT\n    write_data = 0xA5A5A5A5  # Write a pattern\n    write_data_masked = write_data & ((1 << GPIO_WIDTH) - 1)\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT'], write_data_masked)\n\n    # Perform APB write to DATA_OUT_EN\n    write_en = (1 << GPIO_WIDTH) - 1  # Enable all GPIOs based on GPIO_WIDTH\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT_EN'], write_en)\n\n    # Perform APB read from DATA_OUT_EN\n    read_data = await apb_read(dut, APB_ADDRESSES['DATA_OUT_EN'])\n    expected_en = write_en\n    actual_en = read_data\n\n    # Check Output Enable Register\n    check_condition(\n        actual_en == expected_en,\n        f\"FAIL: Output Enable Register mismatch. Expected: 0x{expected_en:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{actual_en:0{(GPIO_WIDTH + 3) // 4}X}\",\n        f\"PASS: Output Enable Register value: 0x{actual_en:0{(GPIO_WIDTH + 3) // 4}X}\",\n        test_failures\n    )\n\n    # Verify GPIO Outputs and Enables\n    gpio_out = int(dut.gpio_out.value)\n    gpio_enable = int(dut.gpio_enable.value)\n    expected_gpio_out = write_data_masked\n    expected_gpio_enable = write_en\n\n    check_condition(\n        gpio_out == expected_gpio_out,\n        f\"FAIL: GPIO Output mismatch. Expected: 0x{expected_gpio_out:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{gpio_out:0{(GPIO_WIDTH + 3) // 4}X}\",\n        f\"PASS: GPIO Output matches expected value: 0x{gpio_out:0{(GPIO_WIDTH + 3) // 4}X}\",\n        test_failures\n    )\n\n    check_condition(\n        gpio_enable == expected_gpio_enable,\n        f\"FAIL: GPIO Enable mismatch. Expected: 0x{expected_gpio_enable:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{gpio_enable:0{(GPIO_WIDTH + 3) // 4}X}\",\n        f\"PASS: GPIO Enable matches expected value: 0x{gpio_enable:0{(GPIO_WIDTH + 3) // 4}X}\",\n        test_failures\n    )\n\n    # Report failures if any\n    if test_failures:\n        failure_message = \"\\n\".join(test_failures)\n        logger.error(f\"Test 2 completed with failures:\\n{failure_message}\")\n        assert False, f\"Some test cases failed. Check the log for details:\\n{failure_message}\"\n    else:\n        logger.info(\"Test 2 completed successfully\")\n\n@cocotb.test()\nasync def test3_gpio_input_synchronization(dut):\n    \"\"\"Test 3: Test GPIO Input Synchronization\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Test 3: GPIO Input Synchronization\")\n\n    # Retrieve GPIO_WIDTH from DUT parameters\n    GPIO_WIDTH = int(dut.GPIO_WIDTH.value)\n\n    # Start the clock\n    cocotb.start_soon(Clock(dut.pclk, 20, units=\"ns\").start())\n\n    # Reset\n    dut.preset_n.value = 0\n    await Timer(50, units='ns')  # Hold reset low for 50 ns\n    dut.preset_n.value = 1\n\n    # Initialize list to collect failures\n    test_failures = []\n\n    # Perform APB write to DATA_OUT and DATA_OUT_EN\n    write_data = (0xA5A5A5A5 >> (32 - GPIO_WIDTH))  # Adjust based on GPIO_WIDTH\n    write_en = (1 << GPIO_WIDTH) - 1\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT'], write_data)\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT_EN'], write_en)\n\n    # Change GPIO inputs\n    gpio_input = 0x3C\n    gpio_input_masked = gpio_input & ((1 << GPIO_WIDTH) - 1)\n    dut.gpio_in.value = gpio_input_masked\n    for _ in range(3):\n        await RisingEdge(dut.pclk)  # Wait for synchronization\n\n    # Perform APB read from DATA_IN\n    read_data = await apb_read(dut, APB_ADDRESSES['DATA_IN'])\n    expected_data = gpio_input_masked\n    actual_data = read_data\n\n    # Check GPIO Input Data\n    check_condition(\n        actual_data == expected_data,\n        f\"FAIL: GPIO Input Data mismatch. Expected: 0x{expected_data:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{actual_data:0{(GPIO_WIDTH + 3) // 4}X}\",\n        f\"PASS: GPIO Input Data value: 0x{actual_data:0{(GPIO_WIDTH + 3) // 4}X}\",\n        test_failures\n    )\n\n    # Report failures if any\n    if test_failures:\n        failure_message = \"\\n\".join(test_failures)\n        logger.error(f\"Test 3 completed with failures:\\n{failure_message}\")\n        assert False, f\"Some test cases failed. Check the log for details:\\n{failure_message}\"\n    else:\n        logger.info(\"Test 3 completed successfully\")\n\n@cocotb.test()\nasync def test4_configure_level_triggered_interrupts(dut):\n    \"\"\"Test 4: Configure Level-Triggered Interrupts (Positive Polarity)\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Test 4: Configure Level-Triggered Interrupts (Positive Polarity)\")\n\n    # Retrieve GPIO_WIDTH from DUT parameters\n    GPIO_WIDTH = int(dut.GPIO_WIDTH.value)\n\n    # Start the clock\n    cocotb.start_soon(Clock(dut.pclk, 20, units=\"ns\").start())\n\n    # Reset\n    dut.preset_n.value = 0\n    await Timer(50, units='ns')  # Hold reset low for 50 ns\n    dut.preset_n.value = 1\n\n    # Initialize list to collect failures\n    test_failures = []\n\n    # Perform APB writes to set up GPIO and Interrupts\n    write_data = (0xA5A5A5A5 >> (32 - GPIO_WIDTH))\n    write_en = (1 << GPIO_WIDTH) - 1\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT'], write_data)\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT_EN'], write_en)\n    await apb_write(dut, APB_ADDRESSES['INT_TYPE'], 0x00)       # Level-triggered\n    await apb_write(dut, APB_ADDRESSES['INT_POLARITY'], 0x00)   # Active High\n    await apb_write(dut, APB_ADDRESSES['INT_ENABLE'], write_en) # Enable all interrupts\n\n    # Generate GPIO Input to Trigger Interrupts\n    gpio_input = 0x55\n    gpio_input_masked = gpio_input & ((1 << GPIO_WIDTH) - 1)\n    dut.gpio_in.value = gpio_input_masked\n    for _ in range(3):\n        await RisingEdge(dut.pclk)  # Wait for synchronization and interrupt update\n\n    # Perform APB read from INT_STATE\n    read_data = await apb_read(dut, APB_ADDRESSES['INT_STATE'])\n    expected_int_state = gpio_input_masked\n    actual_int_state = read_data\n\n    # Check Interrupt State Register\n    check_condition(\n        actual_int_state == expected_int_state,\n        f\"FAIL: Interrupt State Register mismatch (Level-Triggered). Expected: 0x{expected_int_state:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{actual_int_state:0{(GPIO_WIDTH + 3) // 4}X}\",\n        f\"PASS: Interrupt State Register value: 0x{actual_int_state:0{(GPIO_WIDTH + 3) // 4}X}\",\n        test_failures\n    )\n\n    # Check Combined Interrupt Signal\n    comb_int = int(dut.comb_int.value)\n    expected_comb_int = 1 if expected_int_state != 0 else 0\n    check_condition(\n        comb_int == expected_comb_int,\n        f\"FAIL: Combined Interrupt Signal should be {'high' if expected_comb_int else 'low'}. Got: {comb_int}\",\n        f\"PASS: Combined Interrupt Signal is {'high' if comb_int else 'low'} as expected\",\n        test_failures\n    )\n\n    # Report failures if any\n    if test_failures:\n        failure_message = \"\\n\".join(test_failures)\n        logger.error(f\"Test 4 completed with failures:\\n{failure_message}\")\n        assert False, f\"Some test cases failed. Check the log for details:\\n{failure_message}\"\n    else:\n        logger.info(\"Test 4 completed successfully\")\n\n@cocotb.test()\nasync def test5_clear_level_triggered_interrupts(dut):\n    \"\"\"Test 5: Clear Level-Triggered Interrupts by Changing Input\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Test 5: Clear Level-Triggered Interrupts by Changing Input\")\n\n    # Retrieve GPIO_WIDTH from DUT parameters\n    GPIO_WIDTH = int(dut.GPIO_WIDTH.value)\n\n    # Start the clock\n    cocotb.start_soon(Clock(dut.pclk, 20, units=\"ns\").start())\n\n    # Reset\n    dut.preset_n.value = 0\n    await Timer(50, units='ns')  # Hold reset low for 50 ns\n    dut.preset_n.value = 1\n\n    # Initialize list to collect failures\n    test_failures = []\n\n    # Perform APB writes to set up GPIO and Interrupts\n    write_data = (0xA5A5A5A5 >> (32 - GPIO_WIDTH))\n    write_en = (1 << GPIO_WIDTH) - 1\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT'], write_data)\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT_EN'], write_en)\n    await apb_write(dut, APB_ADDRESSES['INT_TYPE'], 0x00)       # Level-triggered\n    await apb_write(dut, APB_ADDRESSES['INT_POLARITY'], 0x00)   # Active High\n    await apb_write(dut, APB_ADDRESSES['INT_ENABLE'], write_en) # Enable all interrupts\n\n    # Generate GPIO Input to Trigger Interrupts\n    gpio_input = 0x55\n    gpio_input_masked = gpio_input & ((1 << GPIO_WIDTH) - 1)\n    dut.gpio_in.value = gpio_input_masked\n    for _ in range(3):\n        await RisingEdge(dut.pclk)  # Wait for synchronization and interrupt update\n\n    # Clear interrupts by changing GPIO inputs\n    gpio_input_clear = 0x00\n    gpio_input_clear_masked = gpio_input_clear & ((1 << GPIO_WIDTH) - 1)\n    dut.gpio_in.value = gpio_input_clear_masked\n    for _ in range(3):\n        await RisingEdge(dut.pclk)  # Wait for synchronization\n\n    # Perform APB read from INT_STATE\n    read_data = await apb_read(dut, APB_ADDRESSES['INT_STATE'])\n    expected_int_state = gpio_input_clear_masked\n    actual_int_state = read_data\n\n    # Check Interrupt State Register\n    check_condition(\n        actual_int_state == expected_int_state,\n        f\"FAIL: Level-triggered interrupts not cleared. Expected: 0x{expected_int_state:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{actual_int_state:0{(GPIO_WIDTH + 3) // 4}X}\",\n        \"PASS: Level-triggered interrupts cleared successfully\",\n        test_failures\n    )\n\n    # Verify Combined Interrupt Signal is Low\n    comb_int = int(dut.comb_int.value)\n    expected_comb_int = 1 if expected_int_state != 0 else 0\n    check_condition(\n        comb_int == expected_comb_int,\n        f\"FAIL: Combined Interrupt Signal should be {'high' if expected_comb_int else 'low'}. Got: {comb_int}\",\n        f\"PASS: Combined Interrupt Signal is {'high' if comb_int else 'low'} as expected\",\n        test_failures\n    )\n\n    # Report failures if any\n    if test_failures:\n        failure_message = \"\\n\".join(test_failures)\n        logger.error(f\"Test 5 completed with failures:\\n{failure_message}\")\n        assert False, f\"Some test cases failed. Check the log for details:\\n{failure_message}\"\n    else:\n        logger.info(\"Test 5 completed successfully\")\n\n@cocotb.test()\nasync def test6_configure_edge_triggered_interrupts(dut):\n    \"\"\"Test 6: Configure Edge-Triggered Interrupts (Negative Polarity)\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Test 6: Configure Edge-Triggered Interrupts (Negative Polarity)\")\n\n    # Retrieve GPIO_WIDTH from DUT parameters\n    GPIO_WIDTH = int(dut.GPIO_WIDTH.value)\n\n    # Start the clock\n    cocotb.start_soon(Clock(dut.pclk, 20, units=\"ns\").start())\n\n    # Reset\n    dut.preset_n.value = 0\n    await Timer(50, units='ns')  # Hold reset low for 50 ns\n    dut.preset_n.value = 1\n\n    # Initialize list to collect failures\n    test_failures = []\n\n    # Perform APB writes to set up GPIO and Interrupts\n    write_data = (0xFFFF >> (32 - GPIO_WIDTH))  # For GPIO_WIDTH=16, 0xFFFF\n    write_en = (1 << GPIO_WIDTH) - 1\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT'], write_data)\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT_EN'], write_en)\n    await apb_write(dut, APB_ADDRESSES['INT_TYPE'], (1 << GPIO_WIDTH) - 1)       # Edge-triggered\n    await apb_write(dut, APB_ADDRESSES['INT_POLARITY'], (1 << GPIO_WIDTH) - 1)   # Active Low\n    await apb_write(dut, APB_ADDRESSES['INT_ENABLE'], write_en)                  # Enable all interrupts\n    await apb_write(dut, APB_ADDRESSES['INT_STATE'], (1 << GPIO_WIDTH) - 1)       # Clear any pending interrupts\n\n    # Generate Falling Edge on GPIO Inputs (Active Low Polarity)\n    initial_gpio = (1 << GPIO_WIDTH) - 1  # All high\n    gpio_falling = 0xAAAA & ((1 << GPIO_WIDTH) - 1)  # Example pattern with falling edges\n    dut.gpio_in.value = initial_gpio\n    for _ in range(3):\n        await RisingEdge(dut.pclk)\n\n    # Generate Falling Edges\n    dut.gpio_in.value = gpio_falling\n    for _ in range(3):\n        await RisingEdge(dut.pclk)\n\n    # Calculate expected interrupts: bits that transitioned from 1 to 0\n    transitions = initial_gpio ^ gpio_falling\n    expected_int_state = transitions & ((1 << GPIO_WIDTH) - 1)\n\n    # Perform APB read from INT_STATE\n    read_data = await apb_read(dut, APB_ADDRESSES['INT_STATE'])\n    actual_int_state = read_data\n\n    # Check Interrupt State Register\n    check_condition(\n        actual_int_state == expected_int_state,\n        f\"FAIL: Interrupt State Register mismatch (Edge-Triggered). Expected: 0x{expected_int_state:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{actual_int_state:0{(GPIO_WIDTH + 3) // 4}X}\",\n        f\"PASS: Interrupt State Register value: 0x{actual_int_state:0{(GPIO_WIDTH + 3) // 4}X}\",\n        test_failures\n    )\n\n    # Clear Edge-Triggered Interrupts\n    await apb_write(dut, APB_ADDRESSES['INT_STATE'], (1 << GPIO_WIDTH) - 1)  # Clear all interrupts\n    await RisingEdge(dut.pclk)\n\n    # Perform APB read from INT_STATE\n    read_data = await apb_read(dut, APB_ADDRESSES['INT_STATE'])\n    expected_int_state_cleared = 0x00\n    actual_int_state_cleared = read_data & ((1 << GPIO_WIDTH) - 1)\n\n    # Check Interrupt State Register after clearing\n    check_condition(\n        actual_int_state_cleared == expected_int_state_cleared,\n        f\"FAIL: Edge-triggered interrupts not cleared. Expected: 0x{expected_int_state_cleared:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{actual_int_state_cleared:0{(GPIO_WIDTH + 3) // 4}X}\",\n        \"PASS: Edge-triggered interrupts cleared successfully\",\n        test_failures\n    )\n\n    # Report failures if any\n    if test_failures:\n        failure_message = \"\\n\".join(test_failures)\n        logger.error(f\"Test 6 completed with failures:\\n{failure_message}\")\n        assert False, f\"Some test cases failed. Check the log for details:\\n{failure_message}\"\n    else:\n        logger.info(\"Test 6 completed successfully\")\n\n@cocotb.test()\nasync def test7_mask_interrupts(dut):\n    \"\"\"Test 7: Mask Interrupts Using Interrupt Enable Register\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Test 7: Mask Interrupts Using Interrupt Enable Register\")\n\n    # Retrieve GPIO_WIDTH from DUT parameters\n    GPIO_WIDTH = int(dut.GPIO_WIDTH.value)\n\n    # Start the clock\n    cocotb.start_soon(Clock(dut.pclk, 20, units=\"ns\").start())\n\n    # Reset\n    dut.preset_n.value = 0\n    await Timer(50, units='ns')  # Hold reset low for 50 ns\n    dut.preset_n.value = 1\n\n    # Initialize list to collect failures\n    test_failures = []\n\n    # Perform APB writes to set up GPIO and Interrupts\n    write_data = (0xFFFF >> (32 - GPIO_WIDTH))  # For GPIO_WIDTH=16, 0xFFFF\n    write_en = (1 << GPIO_WIDTH) - 1\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT'], write_data)\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT_EN'], write_en)\n    await apb_write(dut, APB_ADDRESSES['INT_ENABLE'], 0x0F)     # Enable lower 4 interrupts\n    await apb_write(dut, APB_ADDRESSES['INT_TYPE'], 0x00)       # Level-triggered\n    await apb_write(dut, APB_ADDRESSES['INT_POLARITY'], 0x00)   # Active High\n\n    # Clear any pending interrupts\n    await apb_write(dut, APB_ADDRESSES['INT_STATE'], (1 << GPIO_WIDTH) - 1)\n    await RisingEdge(dut.pclk)\n\n    # Generate Edge on GPIO Inputs\n    dut.gpio_in.value = 0x00  # All inputs low\n    for _ in range(3):\n        await RisingEdge(dut.pclk)\n\n    dut.gpio_in.value = 0xFF  # All inputs high (should generate edges on all bits)\n    for _ in range(3):\n        await RisingEdge(dut.pclk)\n\n    # Expected interrupts only on lower 4 bits\n    expected_int_state = 0x0F & ((1 << GPIO_WIDTH) - 1)\n    read_data = await apb_read(dut, APB_ADDRESSES['INT_STATE'])\n    actual_int_state = read_data & ((1 << GPIO_WIDTH) - 1)\n\n    # Check Interrupt State Register\n    check_condition(\n        actual_int_state == expected_int_state,\n        f\"FAIL: Interrupts not masked correctly. Expected: 0x{expected_int_state:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{actual_int_state:0{(GPIO_WIDTH + 3) // 4}X}\",\n        f\"PASS: Interrupts masked correctly, Interrupt State: 0x{actual_int_state:0{(GPIO_WIDTH + 3) // 4}X}\",\n        test_failures\n    )\n\n    # Verify Combined Interrupt Signal\n    comb_int = int(dut.comb_int.value)\n    expected_comb_int = 1 if expected_int_state != 0 else 0\n    check_condition(\n        comb_int == expected_comb_int,\n        f\"FAIL: Combined Interrupt Signal should be {'high' if expected_comb_int else 'low'}. Got: {comb_int}\",\n        f\"PASS: Combined Interrupt Signal is {'high' if comb_int else 'low'} as expected\",\n        test_failures\n    )\n\n    # Perform APB writes to further test masking\n    # Reconfigure Interrupt Polarity to Active High (already active high, but for completeness)\n    await apb_write(dut, APB_ADDRESSES['INT_POLARITY'], 0x00)\n    await RisingEdge(dut.pclk)\n\n    # Generate edges again\n    dut.gpio_in.value = 0x00\n    for _ in range(3):\n        await RisingEdge(dut.pclk)\n    dut.gpio_in.value = 0xFF\n    for _ in range(3):\n        await RisingEdge(dut.pclk)\n\n    # Expected interrupts still only on lower 4 bits\n    read_data = await apb_read(dut, APB_ADDRESSES['INT_STATE'])\n    actual_int_state = read_data & ((1 << GPIO_WIDTH) - 1)\n\n    # Check Interrupt State Register again\n    check_condition(\n        actual_int_state == expected_int_state,\n        f\"FAIL: Interrupts not masked correctly after re-triggering. Expected: 0x{expected_int_state:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{actual_int_state:0{(GPIO_WIDTH + 3) // 4}X}\",\n        f\"PASS: Interrupts masked correctly after re-triggering, Interrupt State: 0x{actual_int_state:0{(GPIO_WIDTH + 3) // 4}X}\",\n        test_failures\n    )\n\n    # Report failures if any\n    if test_failures:\n        failure_message = \"\\n\".join(test_failures)\n        logger.error(f\"Test 7 completed with failures:\\n{failure_message}\")\n        assert False, f\"Some test cases failed. Check the log for details:\\n{failure_message}\"\n    else:\n        logger.info(\"Test 7 completed successfully\")\n\n@cocotb.test()\nasync def test8_invalid_address_access(dut):\n    \"\"\"Test 8: Attempt to Access Invalid Address\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Test 8: Attempt to Access Invalid Address\")\n\n    # Retrieve GPIO_WIDTH from DUT parameters\n    GPIO_WIDTH = int(dut.GPIO_WIDTH.value)\n\n    # Start the clock\n    cocotb.start_soon(Clock(dut.pclk, 20, units=\"ns\").start())\n\n    # Reset\n    dut.preset_n.value = 0\n    await Timer(50, units='ns')  # Hold reset low for 50 ns\n    dut.preset_n.value = 1\n\n    # Initialize list to collect failures\n    test_failures = []\n\n    # Attempt to write to an invalid address (e.g., 0x3F)\n    invalid_address = 0x3F\n    write_data = 0xDEADBEEF\n    await apb_write(dut, invalid_address, write_data)\n\n    # Attempt to read from the invalid address\n    read_data = await apb_read(dut, invalid_address)\n    expected_data = 0x00\n\n    # Check that invalid address returns zero\n    check_condition(\n        read_data == expected_data,\n        f\"FAIL: Invalid address should return zero data. Expected: 0x{expected_data:08X}, Got: 0x{read_data:08X}\",\n        \"PASS: Invalid address access returned zero as expected\",\n        test_failures\n    )\n\n    # Report failures if any\n    if test_failures:\n        failure_message = \"\\n\".join(test_failures)\n        logger.error(f\"Test 8 completed with failures:\\n{failure_message}\")\n        assert False, f\"Some test cases failed. Check the log for details:\\n{failure_message}\"\n    else:\n        logger.info(\"Test 8 completed successfully\")\n\n@cocotb.test()\nasync def test9_multiple_simultaneous_interrupts(dut):\n    \"\"\"Test 9: Multiple Interrupts Occurring Simultaneously\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Test 9: Multiple Interrupts Occurring Simultaneously\")\n\n    # Retrieve GPIO_WIDTH from DUT parameters\n    GPIO_WIDTH = int(dut.GPIO_WIDTH.value)\n\n    # Start the clock\n    cocotb.start_soon(Clock(dut.pclk, 20, units=\"ns\").start())\n\n    # Reset\n    dut.preset_n.value = 0\n    await Timer(50, units='ns')  # Hold reset low for 50 ns\n    dut.preset_n.value = 1\n\n    # Initialize list to collect failures\n    test_failures = []\n\n    # Perform APB writes to set up GPIO and Interrupts\n    write_data = 0x0000  # Initialize gpio_out to 0x0000\n    write_en = (1 << GPIO_WIDTH) - 1\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT'], write_data)\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT_EN'], write_en)\n    await apb_write(dut, APB_ADDRESSES['INT_ENABLE'], write_en)       # Enable all interrupts\n    await apb_write(dut, APB_ADDRESSES['INT_TYPE'], 0xFF)           # Edge-triggered\n    await apb_write(dut, APB_ADDRESSES['INT_POLARITY'], 0x00)       # Active High\n    await apb_write(dut, APB_ADDRESSES['INT_STATE'], (1 << GPIO_WIDTH) - 1)  # Clear any pending interrupts\n\n    # Generate multiple simultaneous interrupts\n    dut.gpio_in.value = 0x00  # Initial state\n    for _ in range(3):\n        await RisingEdge(dut.pclk)\n\n    # Change multiple bits simultaneously\n    gpio_change = 0xF0 | 0x0F  # Example pattern: upper and lower 4 bits change\n    gpio_change_masked = gpio_change & ((1 << GPIO_WIDTH) - 1)\n    dut.gpio_in.value = gpio_change_masked\n    for _ in range(3):\n        await RisingEdge(dut.pclk)\n\n    # Calculate expected interrupts: bits that transitioned from 0 to 1\n    # Since polarity is active high and edge-triggered, rising edges trigger interrupts\n    transitions = gpio_change_masked\n    expected_int_state = transitions\n\n    # Perform APB read from INT_STATE\n    read_data = await apb_read(dut, APB_ADDRESSES['INT_STATE'])\n    actual_int_state = read_data\n\n    # Check Interrupt State Register\n    check_condition(\n        actual_int_state == expected_int_state,\n        f\"FAIL: Not all interrupts captured. Expected: 0x{expected_int_state:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{actual_int_state:0{(GPIO_WIDTH + 3) // 4}X}\",\n        \"PASS: All interrupts captured successfully\",\n        test_failures\n    )\n\n    # Report failures if any\n    if test_failures:\n        failure_message = \"\\n\".join(test_failures)\n        logger.error(f\"Test 9 completed with failures:\\n{failure_message}\")\n        assert False, f\"Some test cases failed. Check the log for details:\\n{failure_message}\"\n    else:\n        logger.info(\"Test 9 completed successfully\")\n\n@cocotb.test()\nasync def test10_reset_conditions(dut):\n    \"\"\"Test 10: Reset Conditions\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Test 10: Reset Conditions\")\n\n    # Retrieve GPIO_WIDTH from DUT parameters\n    GPIO_WIDTH = int(dut.GPIO_WIDTH.value)\n\n    # Start the clock\n    cocotb.start_soon(Clock(dut.pclk, 20, units=\"ns\").start())\n\n    # Reset\n    dut.preset_n.value = 0\n    await Timer(50, units='ns')  # Hold reset low for 50 ns\n    dut.preset_n.value = 1\n\n    # Initialize list to collect failures\n    test_failures = []\n\n    # Perform APB writes to set up GPIO and Interrupts before reset\n    write_data = (0xA5A5A5A5 >> (32 - GPIO_WIDTH))\n    write_en = (1 << GPIO_WIDTH) - 1\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT'], write_data)\n    await apb_write(dut, APB_ADDRESSES['DATA_OUT_EN'], write_en)\n    await apb_write(dut, APB_ADDRESSES['INT_ENABLE'], write_en)       # Enable all interrupts\n    await apb_write(dut, APB_ADDRESSES['INT_STATE'], (1 << GPIO_WIDTH) - 1)  # Clear any pending interrupts\n\n    # Assert reset\n    dut.preset_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.pclk)\n\n    # Deassert reset\n    dut.preset_n.value = 1\n    for _ in range(2):\n        await RisingEdge(dut.pclk)\n\n    # Perform APB reads to verify reset\n    # Data Output Register\n    read_data = await apb_read(dut, APB_ADDRESSES['DATA_OUT'])\n    expected_data = 0x00\n    actual_data = read_data & ((1 << GPIO_WIDTH) - 1)\n    check_condition(\n        actual_data == expected_data,\n        f\"FAIL: Data Output Register not reset. Expected: 0x{expected_data:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{actual_data:0{(GPIO_WIDTH + 3) // 4}X}\",\n        \"PASS: Data Output Register reset correctly\",\n        test_failures\n    )\n\n    # Output Enable Register\n    read_data = await apb_read(dut, APB_ADDRESSES['DATA_OUT_EN'])\n    expected_en = 0x00\n    actual_en = read_data & ((1 << GPIO_WIDTH) - 1)\n    check_condition(\n        actual_en == expected_en,\n        f\"FAIL: Output Enable Register not reset. Expected: 0x{expected_en:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{actual_en:0{(GPIO_WIDTH + 3) // 4}X}\",\n        \"PASS: Output Enable Register reset correctly\",\n        test_failures\n    )\n\n    # Interrupt Enable Register\n    read_data = await apb_read(dut, APB_ADDRESSES['INT_ENABLE'])\n    expected_en = 0x00\n    actual_en = read_data & ((1 << GPIO_WIDTH) - 1)\n    check_condition(\n        actual_en == expected_en,\n        f\"FAIL: Interrupt Enable Register not reset. Expected: 0x{expected_en:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{actual_en:0{(GPIO_WIDTH + 3) // 4}X}\",\n        \"PASS: Interrupt Enable Register reset correctly\",\n        test_failures\n    )\n\n    # Interrupt State Register\n    read_data = await apb_read(dut, APB_ADDRESSES['INT_STATE'])\n    expected_int_state = 0x00\n    actual_int_state = read_data & ((1 << GPIO_WIDTH) - 1)\n    check_condition(\n        actual_int_state == expected_int_state,\n        f\"FAIL: Interrupt State Register not reset. Expected: 0x{expected_int_state:0{(GPIO_WIDTH + 3) // 4}X}, \"\n        f\"Got: 0x{actual_int_state:0{(GPIO_WIDTH + 3) // 4}X}\",\n        \"PASS: Interrupt State Register reset correctly\",\n        test_failures\n    )\n\n    # Report failures if any\n    if test_failures:\n        failure_message = \"\\n\".join(test_failures)\n        logger.error(f\"Test 10 completed with failures:\\n{failure_message}\")\n        assert False, f\"Some test cases failed. Check the log for details:\\n{failure_message}\"\n    else:\n        logger.info(\"PASS: All registers reset correctly\")\n        logger.info(\"Test 10 completed successfully\")\n", "src/test_runner.py": "# test_runner.py\n\nimport os\nfrom cocotb.runner import get_runner\nimport pytest\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Fetch environment variables\nverilog_sources = os.getenv(\"VERILOG_SOURCES\", \"\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\", \"verilog\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\ndef runner(gpio_width):\n    \"\"\"\n    Runs the cocotb simulation with the specified GPIO_WIDTH parameter.\n\n    Args:\n        gpio_width (int): The GPIO_WIDTH value to test.\n    \"\"\"\n    logger.info(f\"Starting simulation with GPIO_WIDTH = {gpio_width}\")\n\n    # Initialize the simulator runner\n    runner = get_runner(sim)\n\n    # Build the simulation with the specified GPIO_WIDTH parameter\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters={\"GPIO_WIDTH\": gpio_width},  # Pass GPIO_WIDTH parameter\n        # Simulator Arguments\n        always=True,\n        clean=True,\n        waves=False,        # Disable waveform generation for faster runs\n        verbose=False,      # Set to True for detailed simulator logs\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=f\"sim_{gpio_width}.log\"\n    )\n\n    # Run the simulation\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=False\n    )\n\n    logger.info(f\"Completed simulation with GPIO_WIDTH = {gpio_width}\")\n\n@pytest.mark.parametrize(\"gpio_width\", [8, 11, 30])  # Add desired GPIO_WIDTH values here\ndef test_cvdp_copilot_apb_gpio(gpio_width):\n    \"\"\"\n    Pytest function to run cocotb simulations with different GPIO_WIDTH parameters.\n\n    Args:\n        gpio_width (int): The GPIO_WIDTH value to test.\n    \"\"\"\n    try:\n        runner(gpio_width)\n    except Exception as e:\n        logger.error(f\"Simulation failed for GPIO_WIDTH = {gpio_width}: {e}\")\n        # Using assert False to report failure without halting other tests\n        assert False, f\"Simulation failed for GPIO_WIDTH = {gpio_width}: {e}\"\n"}}}
{"id": "cvdp_copilot_apb_history_shift_register_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design an **8-bit** an APB-accessible, global history shift register for a branch prediction module named `APBGlobalHistoryRegister` in Verilog. The register updates synchronously on every gated rising edge of the `history_shift_valid` clock, shifting in predicted outcomes or restoring history on mispredictions. An asynchronous reset (`presetn`) clears all internal state. Mispredictions have the highest priority to enable accurate pipeline recovery and state management. Additionally, the design includes clock gating for power efficiency and provides interrupt signals when the shift register is full or when an error is detected.\n\n---\n\n## 1. Interface\n\n### 1.1 Clock & Reset Signals\n- **`pclk`** (input): APB clock input used for all synchronous operations.  \n- **`presetn`** (input, active-low): Asynchronous reset for system initialization.\n\n### 1.2 APB Signals\n- **`paddr`** (input, 10 bits): Address bus for accessing internal CSR registers.  \n- **`pselx`** (input): APB select signal, indicates CSR/memory selection.  \n- **`penable`** (input): APB enable signal, marks transaction progression.  \n- **`pwrite`** (input): Write-enable signal. High for writes, low for reads.  \n- **`pwdata`** (input, 8 bits): Write data bus for sending data to CSR registers or memory.  \n- **`pready`** (output, reg): Ready signal, driven high to indicate the end of a transaction.  \n- **`prdata`** (output, reg, 8 bits): Read data bus for retrieving data from the module.  \n- **`pslverr`** (output, reg): Error signal, asserted on invalid addresses.\n\n### 1.3 History Shift Interface\n- **`history_shift_valid`** (input): On the rising edge of this signal, the values in `control_register` and `train_history` are considered valid and will trigger an update of the predict_history register.\n### 1.4 Clock Gating Enable\n- **`clk_gate_en`** (input): Signal in domain of `pclk`, which will be toggle only on negative edge of `pclk` to avoid glitches. Assertion of this signal will gate the `pclk` internally to minimize switching power.\n### 1.4 Status & Interrupt Signals\n- **`history_full`** (output): Indicates if the 8-bit shift register is full (all bits set to 1).\n- **`history_empty`** (output): Indicates if the 8-bit shift register is empty (all bits cleared to 0).\n- **`error_flag`** (output): Indicates detected errors for invalid address.\n- **`interrupt_full`** (output): Asserted high to signal an interrupt when history_full is set.\n- **`interrupt_error`** (output): Asserted high to signal an interrupt when error_flag is set.\n---\n\n## 2. Register Descriptions\n\n1. **`control_register`**  \n   - **Address:** `0x0`  \n   - Bit fields (from LSB to MSB):\n     - `predict_valid` (control_register[0]): Indicates a valid branch prediction.  \n     - `predict_taken` (control_register[1]): Predicted direction of the branch (1 = taken, 0 = not taken).  \n     - `train_mispredicted` (control_register[2]): Indicates a branch misprediction occurred.  \n     - `train_taken` (control_register[3]): Actual direction of the mispredicted branch (1 = taken, 0 = not taken).  \n     - control_register[7:4]: Reserved and will be read 0.\n     - Read and write register.\n2. **`train_history`**  \n   - **Address:** `0x1`  \n   - 7 bits (`train_history[6:0]`) representing the recorded branch history prior to the mispredicted branch.\n   - train_history[7]: Reserved and will be read 0.\n   - Read and write register.\n\n3. **`predict_history`**  \n   - **Address:** `0x2`  \n   - 8-bit register representing the current state of the branch history shift register.\n   - Updated only on the rising edge of `history_shift_valid`.\n   - Can be read via the APB interface (using `prdata`).\n   - Can't be written via APB interface.\n\n---\n\n## 3. Functional Description\n\n### 3.1 APB Protocol\n\n1. **Read Operations**  \n   - In the **READ_STATE**:  \n     - Drive `prdata` with the register value corresponding to `paddr`.  \n   - After the read completes, return to **IDLE**.\n\n2. **Write Operations**  \n   - In the **WRITE_STATE**:  \n     - Update the register selected by `paddr` with `pwdata`.  \n   - After the write completes, return to **IDLE**.\n\n3. **Reset Behavior**  \n   - When `presetn` is deasserted (active-low):  \n     - Reset `pready` and `pslverr` to 0.  \n     - Clear `prdata`.  \n     - Initialize `control_register` and `train_history` to 0.  \n     - Reset the shift register to zero (`predict_history = 8'b0`).\n\n### 3.2 APB Interface Control\n\n1. **Basics**  \n   - Registers are accessed via the APB interface using `paddr`.  \n   - To read the computed prediction history, use address **0x2**; the data is returned on `prdata`.\n\n2. **Error Handling**  \n   - If `paddr` does not correspond to a valid register, assert `pslverr` (`1'b1`).\n\n3. **Wait States**  \n   - This design does not support wait states. All read/write operations complete in two clock cycles, and `pready` is always driven high (`1'b1`).\n\n---\n\n## 4. Prediction Update Logic\n\n1. **Normal Update**  \n   - If `predict_valid = 1` and no misprediction occurs (`train_mispredicted = 0`), the shift register updates by shifting in `predict_taken` from the least significant bit (LSB). The youngest branch direction is stored in `predict_history[0]`.\n\n2. **Misprediction Handling**  \n   - If `train_mispredicted = 1`, the shift register is updated synchronously with `history_shift_valid` to load the concatenation of `train_history` (7 bits) with `train_taken` (1 bit). This restores the history state before the mispredicted branch while incorporating the actual outcome of the mispredicted branch.\n\n\n3. **Priority**  \n   - If both `predict_valid` and `train_mispredicted` are asserted simultaneously, `train_mispredicted` takes precedence. The misprediction state overrides any prediction to ensure correct recovery of the pipeline state.\n\n4. **Output Behavior**  \n   - `predict_history` (the shift register) is updated only on the rising edge of `history_shift_valid`.\n   - `history_full` is asserted if predict_history contains all ones (8'hFF) else it will be deasserted.\n   - `history_empty` is asserted if predict_history contains all zeros (8'h00)  else it will be deasserted.\n   - `interrupt_full` is directly driven by history_full.\n   - `interrupt_error` is directly driven by error_flag.\n\nNote: Need not to worry about mixing synchronous (pclk) and asynchronous (history_shift_valid) control which can lead to metastability and timing issues. The history_shift_valid will trigger only in absense of pclk.", "context": {}}, "output": {"response": "", "context": {"rtl/APBGlobalHistoryRegister.v": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/APBGlobalHistoryRegister.v\nTOPLEVEL        = APBGlobalHistoryRegister\nMODULE          = test_APBGlobalHistoryRegister\nPYTHONPATH      = /src\nHASH            = 1-synchronous-32-bit-global-history-shift-register", "src/test_APBGlobalHistoryRegister.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nfrom cocotb.clock import Clock\n\n# -----------------------------------------------------------------------------\n# Helper assertion\n# -----------------------------------------------------------------------------\ndef assert_equal(actual, expected, msg=\"\"):\n    \"\"\"Custom assertion with an optional message.\"\"\"\n    assert actual == expected, f\"{msg}: Expected {hex(expected)}, got {hex(actual)}\"\n\n# -----------------------------------------------------------------------------\n# APB Read/Write Helpers\n# -----------------------------------------------------------------------------\nasync def apb_write(dut, addr, data):\n    \"\"\"Perform a single APB write transaction: Setup + Access phase.\"\"\"\n    # Setup phase\n    dut.pselx.value = 1\n    dut.pwrite.value = 1\n    dut.paddr.value  = addr\n    dut.pwdata.value = data\n    dut.penable.value = 0\n    await RisingEdge(dut.pclk)\n\n    # Access phase\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n\n    # De-assert\n    dut.pselx.value   = 0\n    dut.penable.value = 0\n    dut.pwrite.value  = 0\n    dut.paddr.value   = 0\n    dut.pwdata.value  = 0\n    await RisingEdge(dut.pclk)\n\nasync def apb_read(dut, addr):\n    \"\"\"Perform a single APB read transaction: Setup + Access phase. Returns the read data.\"\"\"\n    # Setup phase\n    dut.pselx.value   = 1\n    dut.pwrite.value  = 0\n    dut.paddr.value   = addr\n    dut.penable.value = 0\n    await RisingEdge(dut.pclk)\n\n    # Access phase\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n    await Timer(1, units=\"ns\")  # small delay to allow prdata to settle\n    read_data = dut.prdata.value.integer\n\n    # De-assert\n    dut.pselx.value   = 0\n    dut.penable.value = 0\n    dut.paddr.value   = 0\n    await RisingEdge(dut.pclk)\n    return read_data\n\n# -----------------------------------------------------------------------------\n# Actual Test\n# -----------------------------------------------------------------------------\n@cocotb.test()\nasync def test_APBGlobalHistoryRegister(dut):\n    \"\"\"Cocotb testbench for APBGlobalHistoryRegister.\"\"\"\n\n    # Create and start a clock on pclk\n    clock = Clock(dut.pclk, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize inputs\n    dut.pselx.value   = 0\n    dut.penable.value = 0\n    dut.pwrite.value  = 0\n    dut.pwdata.value  = 0\n    dut.paddr.value   = 0\n    dut.presetn.value = 1\n    dut.history_shift_valid.value = 0\n    dut.clk_gate_en.value = 0   # clock gating disabled by default\n\n    # Apply asynchronous reset\n    dut.presetn.value = 0\n    await Timer(20, units=\"ns\")  # hold reset low\n    dut.presetn.value = 1\n    await RisingEdge(dut.pclk)\n    await RisingEdge(dut.pclk)\n\n    #--------------------------------------------------------------------------\n    # Local constants (addresses)\n    # Match these to localparams in RTL if needed\n    #--------------------------------------------------------------------------\n    ADDR_CTRL_REG     = 0x0\n    ADDR_TRAIN_HIS    = 0x1\n    ADDR_PREDICT_HIS  = 0x2\n\n    #--------------------------------------------------------------------------\n    # 1) Check reset behavior\n    #--------------------------------------------------------------------------\n    ctrl_reg_val   = await apb_read(dut, ADDR_CTRL_REG)\n    train_his_val  = await apb_read(dut, ADDR_TRAIN_HIS)\n    predict_his_val= await apb_read(dut, ADDR_PREDICT_HIS)\n    await Timer(1, units=\"ns\")\n    assert_equal(ctrl_reg_val,   0x00, \"control_register not reset to 0\")\n    assert_equal(train_his_val,  0x00, \"train_history not reset to 0\")\n    assert_equal(predict_his_val,0x00, \"predict_history not reset to 0\")\n\n    # Confirm status signals are reset\n    assert dut.history_empty.value == 1, \"history_empty should be 1 after reset\"\n    assert dut.history_full.value  == 0, \"history_full should be 0 after reset\"\n    assert dut.interrupt_full.value == 0, \"interrupt_full should be 0 after reset\"\n    assert dut.interrupt_error.value == 0, \"interrupt_error should be 0 after reset\"\n\n    #--------------------------------------------------------------------------\n    # 2) Basic APB Write/Read to control_register\n    #--------------------------------------------------------------------------\n    # We only use bits [3:0].\n    # Bits: predict_valid=1 (LSB), predict_taken=1, train_mispredicted=0, train_taken=1 => 0b1011 = 0x0B\n    await apb_write(dut, ADDR_CTRL_REG, 0x0B)\n    await Timer(1, units=\"ns\")\n    ctrl_reg_val = await apb_read(dut, ADDR_CTRL_REG)\n    await Timer(1, units=\"ns\")\n    # Check only lower 4 bits\n    assert_equal(ctrl_reg_val & 0x0F, 0x0B, \"control_register readback mismatch\")\n\n    #--------------------------------------------------------------------------\n    # 3) Basic APB Write/Read to train_history\n    #--------------------------------------------------------------------------\n    # Bits [6:0] used, bit[7] reserved => if we write 0xAA => that is 10101010 in binary\n    # The upper bit [7] is reserved => should read back as 0 => resulting in 0x2A in decimal = 0b0101010\n    await apb_write(dut, ADDR_TRAIN_HIS, 0xAA)\n    train_his_val = await apb_read(dut, ADDR_TRAIN_HIS)\n    # train_his_val[7] should be 0 => so we expect 0x2A if the 7 bits are 1010101 = 0x55 >> but let's see:\n    #  0xAA = 10101010 => the top bit is 1 (bit7). That is reserved => read as 0 => real stored bits = 0x2A\n    await Timer(1, units=\"ns\")\n    assert_equal(train_his_val, 0x2A, \"train_history readback mismatch on reserved bit\")\n\n    #--------------------------------------------------------------------------\n    # 4) Read predict_history (should still be 0)\n    #--------------------------------------------------------------------------\n    predict_his_val = await apb_read(dut, ADDR_PREDICT_HIS)\n    assert_equal(predict_his_val, 0x00, \"predict_history not expected zero before any shifts\")\n\n    #--------------------------------------------------------------------------\n    # 5) Check error handling (invalid address => PSLVERR => interrupt_error)\n    #--------------------------------------------------------------------------\n    # Write to an invalid address, e.g., 0x3 or 0x100\n    await apb_write(dut, 0x3, 0x55)  # outside valid range 0x0..0x2\n    await Timer(1, units=\"ns\")\n    # Wait a cycle to see the effect\n    await RisingEdge(dut.pclk)\n\n    # PSLVERR => pslverr, error_flag, interrupt_error should be asserted\n    assert dut.pslverr.value == 1, \"pslverr not asserted on invalid address\"\n    assert dut.error_flag.value == 1, \"error_flag not asserted on invalid address\"\n    assert dut.interrupt_error.value == 1, \"interrupt_error not asserted on invalid address\"\n\n    #--------------------------------------------------------------------------\n    # Clear the error by writing a valid address\n    # (The design automatically clears PSLVERR next cycle when paddr is valid)\n    #--------------------------------------------------------------------------\n    await apb_write(dut, ADDR_CTRL_REG, 0x00)\n    await Timer(1, units=\"ns\")\n    assert dut.pslverr.value == 0, \"pslverr should be cleared after valid transaction\"\n    assert dut.error_flag.value == 0, \"error_flag should be cleared\"\n    assert dut.interrupt_error.value == 0, \"interrupt_error should be cleared\"\n\n    #--------------------------------------------------------------------------\n    # 6) Test normal shift update on rising edge of history_shift_valid\n    #--------------------------------------------------------------------------\n    # Let's set control_register => predict_valid=1 (bit0=1), predict_taken=1 (bit1=1)\n    await apb_write(dut, ADDR_CTRL_REG, 0x03)  # 0b0011 => mispredict=0, train_taken=0\n    await Timer(2, units=\"ns\")\n\n    # Toggle history_shift_valid\n    dut.history_shift_valid.value = 1\n    await Timer(2, units=\"ns\")  # rising edge\n    dut.history_shift_valid.value = 0\n\n    # Wait a bit so the GHSR can update (as it's asynchronous).\n    await Timer(5, units=\"ns\")\n\n    # Check updated predict_history\n    #   old=0x00 => shift in '1' => LSB=1 => new=0x01\n    predict_his_val = await apb_read(dut, ADDR_PREDICT_HIS)\n    assert_equal(predict_his_val, 0x01, \"predict_history should shift in bit=1 at LSB\")\n\n    #--------------------------------------------------------------------------\n    # 7) Shift repeatedly to fill up to 0xFF => check history_full and interrupt_full\n    #--------------------------------------------------------------------------\n    # We'll keep predict_valid=1, predict_taken=1 => each rising edge of history_shift_valid sets LSB=1\n    # So repeated shifts should eventually get 0xFF after enough toggles.\n    for _ in range(7):\n        dut.history_shift_valid.value = 1\n        await Timer(2, units=\"ns\")\n        dut.history_shift_valid.value = 0\n        await Timer(5, units=\"ns\")\n\n    predict_his_val = await apb_read(dut, ADDR_PREDICT_HIS)\n    assert_equal(predict_his_val, 0xFF, \"predict_history not 0xFF after 8 consecutive bits=1\")\n\n    assert dut.history_full.value == 1, \"history_full should be asserted at 0xFF\"\n    assert dut.interrupt_full.value == 1, \"interrupt_full should be asserted at 0xFF\"\n    assert dut.history_empty.value == 0, \"history_empty should not be set at 0xFF\"\n\n    #--------------------------------------------------------------------------\n    # 8) Test misprediction handling\n    #--------------------------------------------------------------------------\n    # Suppose we wrote train_history=0x55 earlier. Let's re-write it to confirm.\n    # For example, 0x55 => 0101_0101 => only bits [6:0] are used => 0x55 => 1010101 => plus bit7=0\n    await apb_write(dut, ADDR_TRAIN_HIS, 0x55)  # store 0x55 => which effectively 0x55 & 0x7F\n    # Then set train_mispredicted=1, train_taken=1 => bits => 0b1100 => predict_valid=0, predict_taken=0\n    await apb_write(dut, ADDR_CTRL_REG, 0x0C)\n    await Timer(2, units=\"ns\")\n\n    # Toggle shift valid => misprediction should have highest priority\n    dut.history_shift_valid.value = 1\n    await Timer(2, units=\"ns\")\n    dut.history_shift_valid.value = 0\n    await Timer(5, units=\"ns\")\n\n    # The GHSR should be restored from train_history[6:0] => which is 0x55 & 0x7F = 0x55 => plus train_taken=1 => => new GHSR=0xAB\n    # Explanation: train_history = 0x55 => 0b0101_0101 => ignoring bit7 => it's effectively 1010101 in bits [6:0]\n    # => {train_history[6:0], train_taken} => {0x55, 1} => 0x55 << 1 + 1 => 0xAA + 0x01 = 0xAB\n    predict_his_val = await apb_read(dut, ADDR_PREDICT_HIS)\n    assert_equal(predict_his_val, 0xAB, \"predict_history not restored properly on misprediction\")\n\n    # Check if full/empty changed\n    assert dut.history_full.value == 0, \"history_full incorrectly asserted after misprediction restore\"\n    assert dut.history_empty.value == 0, \"history_empty incorrectly asserted after misprediction restore\"\n    assert dut.interrupt_full.value == 0, \"interrupt_full incorrectly asserted\"\n\n    #--------------------------------------------------------------------------\n    # 9) Priority check: If predict_valid=1 and train_mispredicted=1 together => misprediction wins\n    #--------------------------------------------------------------------------\n    # Make control_register => predict_valid=1, predict_taken=1, train_mispredicted=1, train_taken=0 => 0b0111 => 0x07\n    # So if both are set, we should do the misprediction path.\n    # Let's re-store train_history=0x22 => 0b0010_0010 => ignoring bit7 => actually 0x22 => bits [6:0]=0x22\n    await apb_write(dut, ADDR_TRAIN_HIS, 0x22)\n    await apb_write(dut, ADDR_CTRL_REG, 0x07)\n    await Timer(2, units=\"ns\")\n\n    # Trigger shift\n    dut.history_shift_valid.value = 1\n    await Timer(2, units=\"ns\")\n    dut.history_shift_valid.value = 0\n    await Timer(5, units=\"ns\")\n\n    # We expect => predict_history = {train_history[6:0], train_taken} => 0x22 << 1 + 0 => 0x44\n    # 0x22 => 0010_0010 => ignoring bit7 => it's 0x22 in [6:0]\n    # appended train_taken=0 => => 0x44 in decimal\n    predict_his_val = await apb_read(dut, ADDR_PREDICT_HIS)\n    await Timer(1, units=\"ns\")\n    assert_equal(predict_his_val, 0x44,\n                 \"Priority fail: misprediction did not override normal predict_valid=1 condition\")\n\n    #--------------------------------------------------------------------------\n    # 10) Drive predict_history back to 0x00 => check empty/interrupt\n    #--------------------------------------------------------------------------\n    # We'll do this by writing a misprediction to restore 7 bits=0, plus train_taken=0\n    await apb_write(dut, ADDR_TRAIN_HIS, 0x00)\n    # train_mispredicted=1, train_taken=0 => 0b0100 => plus predict_valid=0 => 0x04\n    await apb_write(dut, ADDR_CTRL_REG, 0x04)\n    dut.history_shift_valid.value = 1\n    await Timer(2, units=\"ns\")\n    dut.history_shift_valid.value = 0\n    await Timer(5, units=\"ns\")\n\n    predict_his_val = await apb_read(dut, ADDR_PREDICT_HIS)\n    assert_equal(predict_his_val, 0x00, \"predict_history not reset to 0 via misprediction restore\")\n\n    assert dut.history_empty.value == 1, \"history_empty not asserted at 0x00\"\n    assert dut.history_full.value  == 0, \"history_full incorrectly asserted at 0x00\"\n\n    #--------------------------------------------------------------------------\n    # 11) Simple clock gating check\n    #--------------------------------------------------------------------------\n    # Toggle clk_gate_en => This will effectively 'stop' pclk_gated in the RTL,\n    # meaning no register updates. We'll do an APB write, then verify it didn't change.\n    dut.clk_gate_en.value = 1\n    await RisingEdge(dut.pclk)\n\n    # Attempt to write to ctrl_reg => should NOT update if gating is truly working\n    await apb_write(dut, ADDR_CTRL_REG, 0x0F)\n    # Read it back\n    await FallingEdge(dut.pclk)\n    dut.clk_gate_en.value = 0\n    reg_val = await apb_read(dut, ADDR_CTRL_REG)\n    # Because gating is conceptual in RTL, some synthesis flows might not simulate gating literally,\n    # but let's assume it does. If gating is real, the design's internal pclk is off, so no update => remains 0x04\n    # (the last value we wrote was 0x04).\n    # NOTE: The actual behavior depends on your gate logic. If your gating is purely structural,\n    # we might see 0x0F or 0x04. Adjust expectations accordingly.\n\n    # For a realistic test, let's expect no update:\n    expected_val = 0x04  \n    assert_equal(reg_val, expected_val,\n                 \"control_register changed despite clock gating\")\n\n    # Turn gating back off\n    dut.clk_gate_en.value = 0\n    await RisingEdge(dut.pclk)\n    await RisingEdge(dut.pclk)\n\n    # Write again => now it should succeed\n    await apb_write(dut, ADDR_CTRL_REG, 0x0F)\n    reg_val = await apb_read(dut, ADDR_CTRL_REG)\n    assert_equal(reg_val & 0x0F, 0x0F, \"control_register not updated when gating disabled\")\n\n    dut._log.info(\"All APBGlobalHistoryRegister tests completed successfully.\")\n\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_axi_register_0001", "categories": ["cid003", "medium"], "input": {"prompt": "\nDesign a **SystemVerilog module** named `axi_register` that implements a configurable **AXI4-Lite Slave** interface for controlling and monitoring specific hardware registers. This module allows software to interact with hardware by performing read and write operations via the AXI4-Lite protocol. The supported functionalities include:\n\n- **Beat Counter**: A 20-bit counter that can be set and read by the AXI master.  \n- **Start Signal**: A single-bit control signal to trigger a hardware operation.  \n- **Done Status**: A single-bit flag indicating the completion of a hardware task.  \n- **Writeback Signal**: A single-bit control signal to trigger a writeback operation.  \n- **ID Register**: A fixed, read-only 32-bit register for identification purposes.\n\nThe module should adhere to the AXI4-Lite protocol, ensure proper handshaking, and handle valid data transfers with error handling for invalid operations.\n\n---\n\n## Design Specification\n\n### AXI4-Lite Protocol Features\n\n- **Handshake Mechanism**  \n  Implements the AXI handshake protocol using valid and ready signals for read (`arvalid_i`, `arready_o`, `rvalid_o`, `rready_i`) and write (`awvalid_i`, `awready_o`, `wvalid_i`, `wready_o`, `bvalid_o`, `bready_i`) operations.\n\n- **Address Decoding**  \n  Decodes incoming AXI addresses (using `awaddr_i` or `araddr_i`) to access specific registers based on the lower address bits.\n\n- **Flow Control**  \n  Supports backpressure and flow control using ready signals to properly synchronize with the AXI master.\n\n---\n\n## Interface\n\n### Parameters\n\n1. **`ADDR_WIDTH`**: Specifies the width of the AXI address bus. The default value is `32`. This parameter determines the maximum addressable range of the registers. It must be a positive integer greater than or equal to 12.\n\n2. **`DATA_WIDTH`**: Specifies the width of the AXI data bus. The default value is `32`. This parameter defines the size of the data transferred during read and write operations, and it must be a positive integer greater than or equal to 8.\n\n### Inputs\n\n- **`clk_i`**: The clock signal for synchronous operations. The design operates on the positive edge of the clock signal.\n- **`rst_n_i`**: Active-low asynchronous reset. When de-asserted, the module returns to its initial state.\n- **`[ADDR_WIDTH-1:0] awaddr_i`**: Address for write operations.\n- **`awvalid_i`**: Indicates the write address is valid.\n- **`[DATA_WIDTH-1:0] wdata_i`**: Data to be written, matching the address specified.\n- **`wvalid_i`**: Indicates that the written data is valid.\n- **`[(DATA_WIDTH/8)-1:0] wstrb_i`**: Byte-enable signals for partial or full writes.\n- **`bready_i`**: Indicates that the master is ready to receive the completed response for the write.\n- **`[ADDR_WIDTH-1:0] araddr_i`**: Address for read operations.\n- **`arvalid_i`**: Indicates that the read address is valid.\n- **`rready_i`**: Indicates that the master is ready to receive the read data.\n- **`done_i`**: Indicates that a hardware task has been completed, to be reflected in the status register.\n\n---\n\n### Outputs\n\n- **`awready_o`**: Indicates that the module is ready to accept the write address.\n- **`wready_o`**: Indicates that the module is ready to accept the write data.\n- **`[1:0] bresp_o`**: Two-bit field indicating success or error for the write transaction.\n- **`bvalid_o`**: Indicates that the write completion response is valid.\n- **`arready_o`**: Indicates that the module is ready to accept the read address.\n- **`[DATA_WIDTH-1:0] rdata_o`**: Data returned to the master for a read request.\n- **`rvalid_o`**: Indicates that read data is valid.\n- **`[1:0] rresp_o`**: A two-bit field indicating success or error for the read transaction.\n- **`[19:0] beat_o`**: Reflects the current value of the beat counter, configured via AXI writes.\n- **`start_o`**: Single-bit control signal triggered via AXI write.\n- **`writeback_o`**: Single-bit control signal to trigger a writeback operation, also set via AXI.\n\n---\n\n## Register Map\n\n| **Register**  | **Offset** | **Description**              | **Access**   | **Bit Width** |\n|---------------|------------|------------------------------|--------------|---------------|\n| Beat          | 0x100      | 20-bit beat counter          | Read/Write   | 20            |\n| Start         | 0x200      | Single-bit trigger signal    | Read/Write   | 1             |\n| Done          | 0x300      | Single-bit done status       | Read/Write   | 1             |\n| Writeback     | 0x400      | Single-bit writeback control | Read/Write   | 1             |\n| ID            | 0x500      | Fixed identification value   | Read-Only    | 32            |\n\n---\n\n## Functional Description\n\n### Write Transactions\n\n#### Address Phase\n- Provides a write address on **`awaddr_i`** and asserts **`awvalid_i`** to indicate the validity of the address.  \n- The module asserts **`awready_o`** to confirm that it is ready to accept the address.  \n- Once the address is accepted, **`awready_o`** is de-asserted, and the module transitions to the data phase.\n\n#### Data Phase\n- Provides the write data on **`wdata_i`**, along with byte-enable signals on **`wstrb_i`**, and asserts **`wvalid_i`**.  \n- The module asserts **`wready_o`** to indicate it is ready to accept the write data.\n\n##### Conditions:\n\n1. **Full Write**  \n   If **`wvalid_i`** is asserted and all bits in **`wstrb_i`** are set (indicating that all bytes in **`wdata_i`** are valid), the module performs a complete update of the targeted register.\n\n2. **Partial Write**  \n   If **`wvalid_i`** is asserted but not all bits in **`wstrb_i`** are set, the module acknowledges the write without modifying the targeted register. The register remains unchanged.\n\n##### Register Updates\n- The module uses the lower bits of **`awaddr_i`** to determine the target register, then updates the corresponding outputs:\n  - **Beat Counter**: Updates the 20-bit counter with the lower bits of **`wdata_i`** and reflects on **`beat_o`**.\n  - **Start Signal**: Sets **`start_o`** to `1` if the least significant bit of **`wdata_i`** is `1` and the corresponding byte is enabled by **`wstrb_i`**.\n  - **Done Signal**: Clears **`done_i`** internally if the least significant bit is `1`, effectively resetting the done status in the module\u2019s logic.\n  - **Writeback Signal**: Sets **`writeback_o`** to `1` if the least significant bit of **`wdata_i`** is `1` and the corresponding byte is enabled by **`wstrb_i`**.\n  - **ID Register**: Attempts to write to this read-only register generate an error on **`bresp_o`**.\n\n#### Completion Phase\n- After processing the write data, the module generates a write response on **`bresp_o`** and asserts **`bvalid_o`**.  \n- Asserts **`bready_i`** to acknowledge the response, after which **`bvalid_o`** is deasserted.\n- Possible responses:\n  - **OKAY (`2'b00`)**: Indicates a successful write operation.\n  - **SLVERR (`2'b10`)**: Indicates an error, such as an invalid address or an attempt to write to the read-only register.\n\n---\n\n### Read Transactions\n\n#### Address Phase\n- Provides a read address on **`araddr_i`** and asserts **`arvalid_i`** to indicate the validity of the address. \n- The module asserts **`arready_o`** to confirm that it is ready to accept the address. \n- Once the address is accepted, **`arready_o`** is de-asserted, and the module transitions to the data phase.\n\n#### Data Phase\n- The module decodes the address from **`araddr_i`** and retrieves the corresponding data:\n  - **Beat Counter**: Returns the current 20-bit counter value on **`rdata_o`**, padded to match the data width.\n  - **Done Signal**: Returns the status of **`done_i`** (e.g., `1` if the hardware task is done, `0` otherwise).\n  - **ID Register**: Returns the fixed 32-bit identification value.\n  - **Invalid Address**: Generates an error on **`rresp_o`**.\n\n#### Completion Phase\n- The module provides the read data on **`rdata_o`** and asserts **`rvalid_o`**.  \n- The AXI master asserts **`rready_i`** to acknowledge the read data, after which **`rvalid_o`** is deasserted.\n- Possible responses:\n  - **OKAY (`2'b00`)**: Indicates a successful read operation.\n  - **SLVERR (`2'b10`)**: Indicates an error, such as an invalid address.\n\n---\n\n## Edge Cases\n\n1. **Reset (`rst_n_i`)**:  \n   When reset is active, all outputs (`beat_o`, `start_o`, `writeback_o`) are deasserted, and registers are cleared to default values.\n\n2. **Read-Only Registers**:  \n   Attempts to write to the ID register generate an error response (`SLVERR`) on **`bresp_o`**, preventing unwanted modifications.\n\n3. **Invalid Addresses**:  \n   Any read or write operation targeting an undefined address generates an error response on **`rresp_o`** or **`bresp_o`**.\n\n---\n\n## Example Operations\n\n### Write Example\n- **Operation**: Write `0x5678` to the Beat register.  \n  - **Address**: `0x100`  \n  - **Data**: `0x00005678`  \n  - **Result**: The 20-bit counter updates to `0x5678`, and `beat_o` reflects this new value.\n\n### Read Example\n- **Operation**: Read from the ID register.  \n  - **Address**: `0x500`  \n  - **Result**: The module returns `0x0001_0001` on **`rdata_o`**, indicating the fixed ID value.\n\n### Error Example\n- **Operation**: Attempt to write to the ID register.  \n  - **Address**: `0x500`  \n  - **Data**: Any value  \n  - **Result**: The module returns an error response (`SLVERR`) on **`bresp_o`**, and the register remains unchanged.", "context": {}}, "output": {"response": "", "context": {"rtl/axi_register.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v ", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/axi_register.sv\nTOPLEVEL        = axi_register\nMODULE          = test_axi_register\nPYTHONPATH      = /src\nHASH            = 748c8466993ff067bc3f8a4953d002e1b5913109", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_axi_register.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ReadOnly , Timer\n\nimport harness_library as hrs_lb\nimport random\n\n# AXI Write Helper Function\nasync def axi_write(dut, awaddr, wdata, wstrb=None):\n\n    wstrb_width = len(dut.wstrb_i)  # Get the width of wstrb_i\n    if wstrb is None:\n        # Generate default wstrb to enable all valid bytes\n        wstrb = (1 << wstrb_width) - 1\n\n    # Mask wstrb to match the actual width of wstrb_i\n    adjusted_wstrb = wstrb & ((1 << wstrb_width) - 1)\n\n    dut.awaddr_i.value = awaddr\n    dut.awvalid_i.value = 1\n    dut.wdata_i.value = wdata & ((1 << len(dut.wdata_i)) - 1)  # Mask wdata to DATA_WIDTH\n    dut.wstrb_i.value = adjusted_wstrb\n    dut.wvalid_i.value = 1\n    dut.bready_i.value = 1\n\n    # Wait for the write response\n    while not dut.bvalid_o.value:\n        await RisingEdge(dut.clk_i)\n        dut.awvalid_i.value = 0\n        dut.wvalid_i.value = 0\n        dut.bready_i.value = 0\n\n    # Check the write response\n    if dut.bresp_o.value != 0:\n        dut._log.error(f\"Write operation failed: addr={hex(awaddr)}, data={hex(wdata)}, strb={bin(wstrb)}\")\n    else:\n        dut._log.info(f\"Write operation succeeded: addr={hex(awaddr)}, data={hex(wdata)}, strb={bin(wstrb)}\")\n    await RisingEdge(dut.clk_i)\n\n \n\n# AXI Read Helper Function\nasync def axi_read(dut, araddr):\n\n    dut.araddr_i.value = araddr\n    dut.arvalid_i.value = 1\n    dut.rready_i.value = 1\n    await RisingEdge(dut.clk_i)\n    await RisingEdge(dut.clk_i)\n    rdata = dut.rdata_o.value\n    assert dut.rresp_o.value == 0, f\"Read response error: {dut.rresp_o.value}\"\n\n    return rdata\n# Test CTRL_START\nasync def test_ctrl_start(dut, awaddr, start_value,wstrb_all_one):\n    \"\"\"\n    Test CTRL_START: Verifies that the start signal is set correctly.\n    \"\"\"\n    await axi_write(dut, awaddr, start_value, wstrb_all_one)\n    await RisingEdge(dut.clk_i)\n    await RisingEdge(dut.clk_i)\n    assert (\n        dut.start_o.value == start_value\n    ), f\"CTRL_START failed: expected={start_value}, got={dut.start_o.value}\"\n    dut._log.info(f\"CTRL_START test passed: start_value={start_value}\")\n\nasync def test_ctrl_done(dut, done_addr,wstrb_all_ones):\n\n    # Step 1: Simulate the DONE signal\n    dut.done_i.value = 1  # Assert done\n    await RisingEdge(dut.clk_i)\n    dut.done_i.value = 0  # Deassert done\n\n    # Step 2: Read CTRL_DONE to verify it is set\n    rdata = await axi_read(dut, done_addr)\n    rdata = int(rdata)  # Convert LogicArray to int\n    if rdata & 0x1 != 1:\n        dut._log.error(f\"CTRL_DONE set test failed: expected=1, got={rdata & 0x1}\")\n        assert False, \"CTRL_DONE set test failed\"\n    else:\n        dut._log.info(f\"CTRL_DONE set test passed: expected=1, got={rdata & 0x1}\")\n\n    # Step 3: Clear CTRL_DONE using axi_write\n    await axi_write(dut, done_addr, 1, wstrb_all_ones)  # Write '1' to clear CTRL_DONE\n    # Add delay to ensure proper processing\n    for _ in range(5):\n        await RisingEdge(dut.clk_i)\n\n    # Step 4: Read CTRL_DONE to verify it is cleared\n    rdata = await axi_read(dut, done_addr)\n    rdata = int(rdata)  # Convert LogicArray to int\n    if rdata & 0x1 != 0:\n        dut._log.error(f\"CTRL_DONE clear test failed: expected=0, got={rdata & 0x1}\")\n        assert False, \"CTRL_DONE clear test failed\"\n    else:\n        dut._log.info(f\"CTRL_DONE clear test passed: expected=0, got={rdata & 0x1}\")\n\nasync def test_ctrl_writeback(dut, writeback_addr, writeback_value,wstrb_all_ones):\n\n    # Step 1: Calculate the expected data\n    expected_data = writeback_value & 0x1  # Only the LSB is relevant for writeback\n\n    # Step 2: Write to the CTRL_WRITEBACK register\n    await axi_write(dut, writeback_addr, expected_data, wstrb_all_ones)  # Write the value with all strobes enabled\n    # Add delay to ensure proper processing\n    for _ in range(4):\n        await RisingEdge(dut.clk_i)\n    # Step 3: Verify the writeback_o signal\n    if dut.writeback_o.value != expected_data:\n        dut._log.error(f\"CTRL_WRITEBACK test failed: expected={expected_data}, got={dut.writeback_o.value}\")\n        assert False, f\"CTRL_WRITEBACK test failed: expected={expected_data}, got={dut.writeback_o.value}\"\n    else:\n        dut._log.info(f\"CTRL_WRITEBACK test passed: expected={expected_data}, got={dut.writeback_o.value}\")\n\nasync def test_ctrl_id(dut, id_addr, expected_id_value):\n\n    expected_id_value = expected_id_value& ((1 << len(dut.wdata_i)) - 1) \n    # Step 1: Read the CTRL_ID register\n    dut.araddr_i.value = id_addr\n    dut.arvalid_i.value = 1\n    dut.rready_i.value = 1\n    await RisingEdge(dut.clk_i)\n    await RisingEdge(dut.clk_i)\n    await RisingEdge(dut.clk_i)\n\n    # Step 2: Wait for the read data to be valid\n    while not dut.rvalid_o.value:\n        await RisingEdge(dut.clk_i)\n\n    # Step 3: Read the CTRL_ID value\n    rdata = int(dut.rdata_o.value)\n\n    # Step 4: Verify the read value matches the expected value\n    if rdata == expected_id_value:\n        dut._log.info(f\"CTRL_ID test passed: expected={hex(expected_id_value)}, got={hex(rdata)}\")\n    else:\n        dut._log.error(f\"CTRL_ID test failed: expected={hex(expected_id_value)}, got={hex(rdata)}\")\n        assert False, f\"CTRL_ID test failed: expected={hex(expected_id_value)}, got={hex(rdata)}\"\n\n    # Step 5: Deassert rready\n    dut.rready_i.value = 0\n\nasync def test_partial_write_invalid_strobe(dut, beat_addr, random_data, invalid_strobe):\n    \"\"\"\n    Test partial write with an invalid strobe and verify that bresp_next = AXI_RESP_OK\n    and beat_o retains its previous value.\n    Args:\n        dut: The DUT instance.\n        beat_addr: The address of the CTRL_BEAT register.\n        random_data: Random data to write.\n        invalid_strobe: The invalid write strobe value.\n    \"\"\"\n    # Step 1: Record the initial value of beat_o\n    prev_rdata_value = int(dut.rdata_o.value)\n\n    # Step 2: Perform a partial write with invalid strobe\n    await axi_write(dut, beat_addr, random_data, invalid_strobe)\n\n    # Step 3: Check bresp_o for AXI_RESP_OK\n    while not dut.bvalid_o.value:\n        await RisingEdge(dut.clk_i)\n    assert (\n        dut.bresp_o.value == 0\n    ), f\"Partial write failed: expected AXI_RESP_OK, got={dut.bresp_o.value}\"\n    dut._log.info(\"Partial write response is OK (AXI_RESP_OK).\")\n\n    read_data = await axi_read(dut, beat_addr)\n    assert (\n        int(read_data) == prev_rdata_value\n    ), f\"Partial write corrupted the register: expected={prev_beat_value}, got={int(read_data)}\"\n    dut._log.info(f\"Partial write did not affect the register: read_data={int(read_data)}\")\n\n\n@cocotb.test()\nasync def test_axi_register(dut):\n    ADDR_WIDTH = int(dut.ADDR_WIDTH.value)\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n\n    # Start the clock with a 10ns time period (100 MHz clock)\n    cocotb.start_soon(Clock(dut.clk_i, 10, units='ns').start())\n    \n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.rst_n_i, duration_ns=10, active=True)\n\n    await RisingEdge(dut.clk_i) \n    \n    # Define Constants\n    CTRL_BEAT = 0x100\n    CTRL_START = 0x200\n    CTRL_DONE = 0x300\n    CTRL_WRITEBACK = 0x400\n    CTRL_ID = 0x500\n    ID_VALUE = 0x00010001\n\n    wstrb_all_ones = (1 << (DATA_WIDTH // 8)) - 1  # All bits of wstrb set to 1\n\n    # Generate random data and use all-ones wstrb\n    for i in range(10):  # Perform 10 tests\n        # Generate random data\n        random_data = random.randint(0, (1 << DATA_WIDTH) - 1)\n        # Calculate expected data\n        expected_data = random_data & 0xFFFFF  # Retain only the lower 20 bits\n        expected_data = expected_data | (0 << 20)  # Set upper 12 bits to 0\n        # Write random data\n        await axi_write(dut, CTRL_BEAT, random_data, wstrb_all_ones)\n\n        # Add delay to ensure proper processing\n        for _ in range(5):\n            await RisingEdge(dut.clk_i)\n\n        # Read back and verify\n        rdata = await axi_read(dut, CTRL_BEAT)\n\n        # Log read operation details\n        dut._log.info(f\"Test {i}: Read Data: {hex(int(rdata))} from Address: {hex(CTRL_BEAT)}\")\n\n        assert (\n            int(rdata) == expected_data\n        ), f\"Test {i}: Mismatch! Expected: {hex(random_data)}, Got: {hex(int(rdata))}\"\n        # Wait for Read Response\n        while not dut.rvalid_o.value:\n            await RisingEdge(dut.clk_i)\n            dut.rready_i.value = 0\n            dut.arvalid_i.value = 0\n    dut._log.info(\"Randomized AXI register tests with all-ones wstrb passed successfully!\")\n\n    await RisingEdge(dut.clk_i)\n    # Test CTRL_START\n    await test_ctrl_start(dut, CTRL_START, 1 ,wstrb_all_ones)\n    await RisingEdge(dut.clk_i)\n    # Test CTRL_DONE\n    await test_ctrl_done(dut, CTRL_DONE,wstrb_all_ones)\n    await RisingEdge(dut.clk_i)\n    # Generate a random writeback value and test CTRL_WRITEBACK\n    random_writeback_value = random.randint(0, 1)\n    await test_ctrl_writeback(dut, CTRL_WRITEBACK, random_writeback_value,wstrb_all_ones)\n    await RisingEdge(dut.clk_i) \n    await test_ctrl_id(dut, CTRL_ID, ID_VALUE)\n    await RisingEdge(dut.clk_i)\n    # Generate Random Data and Invalid Strobe\n    random_data = random.randint(0, (1 << DATA_WIDTH) - 1)\n    invalid_strobe = random.randint(0, 9)  # Example invalid strobe: only the second byte\n\n    # Test Partial Write with Invalid Strobe\n    await test_partial_write_invalid_strobe(dut, CTRL_BEAT, random_data, invalid_strobe)\n    await RisingEdge(dut.clk_i)", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(ADDR_WIDTH : int = 32 ,DATA_WIDTH: int= 32 ):\n\n    parameter = {\n        \"ADDR_WIDTH\": ADDR_WIDTH,\n        \"DATA_WIDTH\": DATA_WIDTH\n    }\n    print(f\"[DEBUG] Parameters: {parameter}\") \n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n\n@pytest.mark.parametrize(\"test\", range(1))\n@pytest.mark.parametrize(\"ADDR_WIDTH\", [12,16,32])\n@pytest.mark.parametrize(\"DATA_WIDTH\", [8,16,32,64])\ndef test_axi_reg(test,ADDR_WIDTH,DATA_WIDTH):\n        runner(DATA_WIDTH = DATA_WIDTH ,ADDR_WIDTH = ADDR_WIDTH )"}}}
{"id": "cvdp_copilot_axi_stream_upscale_0001", "categories": ["cid003", "easy"], "input": {"prompt": "A **AXI stream data upsizer** is a digital circuit used to upscale single-channel input data from a smaller 24-bit width to a larger width of 32-bits, supporting features like sign extension, and data format selection, while maintaining a single pipeline register stage.\n\n## Design Specification of `axis_upscale` module:\n\n### Interface:\n\n#### Inputs:\n- **`clk`** (1-bit): Global Clock signal.\n- **`resetn`** (1-bit): An active-low synchronous reset signal. When asserted, this signal resets the internal flip-flops, forcing the output to a known state.\n\n- **`dfmt_enable`** (1-bit): Data format enable.\n- **`dfmt_type`** (1-bit): Data format type 1 = inverted version of slave MSB will be carry forwarded, 0 = slave msb slave msb will be carry forwarded.\n- **`dfmt_se`** (1-bit): Data format sign extension, 1= expected 23rd bit will be extended, 0 = 0 will be extended.\n\n- **`s_axis_valid`** (1-bit): Indicates that the slave is driving a valid transfer.\n- **`s_axis_data`** (24-bits, [23:0] ): This is the primary payload data from AXI slave.\n- **`m_axis_ready`** (1-bit):  indicates that the slave can accept a transfer in the current cycle.\n\n#### Output:\n- **`s_axis_ready`** (1-bit): Indicates that the slave can accept a transfer in the current cycle.\n- **`m_axis_valid`** (1-bit): Indicates that the master is driving a valid transfer.\n- **`m_axis_data`** (32-bits, [31:0] ): This is the primary payload data to AXI master.\n\n### Description of AXI stream data upsizer Functionality:\n\n The functionality `axis_upscale` module is to upscale single-channel input data from a smaller width to a larger width. and when upscaling the extra bit positions will be filed with zero's or one's based on the data format signals such as `dfmt_type`, `dfmt_se` and `dfmt_enable`. each signals functionality is explained below\n\n- `dfmt_enable`: Data format enable. if this enabled then only the other 2 signal are valid, if `dfmt_enable` is disabled output data will be concatenation of 24 times zero and input `s_axis_data` data.\n\n- `dfmt_type`: Data format type if `dfmt_type` = 1, then inverted version of `s_axis_data's` MSB will be carry forwarded, and for 0  `s_axis_data's` MSB will be carry forwarded to m_axis_data[23].\n\n- `dfmt_se` Data format sign extension, if `dfmt_se` 1= expected 23rd bit of `s_axis_data's` will be extended, if `dfmt_se` = 0, zero will be extended.\n\n**Reset Behavior (resetn):**\n- When the` resetn` signal is de-asserted (active low):\n- All flip-flops in the encoder are reset to a known state (typically logic low).\n- The `m_axis_data` signal is held at a known value (e.g., all zeroes) while the reset is active.\n\n", "context": {}}, "output": {"response": "", "context": {"rtl/axis_upscale.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py\n\n", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/axis_upscale.sv \nTOPLEVEL        = axis_upscale\nMODULE          = test_axis_upscale\nPYTHONPATH      = /src\nHASH            = 629cd8684802f51d0b520797a6ccedf7482f2b70\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(rst, dut):\n    # Restart Interface\n    await FallingEdge(dut.clk)\n    rst.value = 0\n    await FallingEdge(dut.clk)\n    rst.value = 1\n    await FallingEdge(dut.clk)\n    rst._log.debug(\"Reset complete\")\n\nasync def enable_dut(enable, duration_ns = 10):\n    # Restart Interface\n    enable.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    enable.value = 1\n    await Timer(duration_ns, units='ns')\n    enable._log.debug(\"enable complete\")\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def calculate_moving_average(data_queue, current_sum, new_data, window):\n    if len(data_queue) < window:\n        data_queue.append(new_data)\n        current_sum += new_data\n    else:\n        oldest_data = data_queue.pop(0)\n        current_sum += new_data - oldest_data\n        data_queue.append(new_data)\n\n    expected_avg = current_sum // window\n    \n    return expected_avg, current_sum\n\n", "src/test_axis_upscale.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport time\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_axis_upscale(dut):\n    # Seed the random number generator with the current time or another unique value\n    random.seed(time.time())\n    # Start clock\n    cocotb.start_soon(Clock(dut.clk, 100, units='ns').start())\n    \n    \n    # Initialize DUT\n    print(f'm_axis_data before initialization = {dut.m_axis_data.value}') ####need to remove\n    await hrs_lb.dut_init(dut) \n    print(f'm_axis_data after initialization   = {dut.m_axis_data.value}') ####need to remove\n    # Apply reset \n    await hrs_lb.reset_dut(dut.resetn, dut)\n    assert dut.m_axis_valid.value == 0, f\"[ERROR] s_axis_valid : {dut.m_axis_valid.value}\"\n    assert dut.m_axis_data.value == 00000000000000000000000000000000, f\"[ERROR] m_axis_data : {dut.m_axis_data.value}\"\n    assert dut.s_axis_ready.value == 0, f\"[ERROR] s_axis_ready : {dut.s_axis_ready.value}\"\n\n    print(f'reset succesfull') \n    \n\n    await FallingEdge(dut.clk)\n    dfmt_enable = 1\n    dfmt_type = 1\n    dfmt_se =  1\n    s_axis_data = 0b000000000000000000000100 \n    s_axis_valid = 1\n    dut.s_axis_data.value = s_axis_data\n    dut.s_axis_valid.value = s_axis_valid\n    dut.dfmt_enable.value = dfmt_enable\n    dut.dfmt_type.value = dfmt_type\n    dut.dfmt_se.value = dfmt_se\n\n    await FallingEdge(dut.clk)\n\n    print(f'm_axis_valid   = {dut.m_axis_valid.value}') ####need to remove\n    print(f'm_axis_data   = {dut.m_axis_data.value}') ####need to remove\n    assert dut.m_axis_valid.value == s_axis_valid, f\"[ERROR] s_axis_valid : {dut.m_axis_valid.value}\"\n\n    if(dfmt_enable == 1):\n        if(dfmt_type == 1):\n            if(dfmt_se == 1):\n              assert  dut.m_axis_data.value[23] == ~dut.s_axis_data.value[23], f\"[ERROR] m_axis_data is not matching to s_axis_data : {dut.m_axis_data.value}\"\n              assert  dut.m_axis_data.value[31:24] == 8 * str(~dut.s_axis_data.value[23]), f\"[ERROR] m_axis_data is not matching to s_axis_data : {dut.m_axis_data.value}\"\n              assert dut.m_axis_data.value[22:0] == dut.s_axis_data.value[22:0], f\"[ERROR] m_axis_data is not matching to s_axis_data : {dut.m_axis_data.value}\"\n            else:\n                assert dut.m_axis_data.value[23] == ~dut.s_axis_data.value[23], f\"[ERROR] m_axis_data is not matching to s_axis_data : {dut.m_axis_data.value}\"\n                assert dut.m_axis_data.value[31:24] == 8 * (0), f\"[ERROR] m_axis_data is not matching to s_axis_data : {dut.m_axis_data.value}\"\n                assert dut.m_axis_data.value[22:0] == dut.s_axis_data.value[22:0], f\"[ERROR] m_axis_data is not matching to s_axis_data : {dut.m_axis_data.value}\"\n        else:\n            if(dfmt_se == 1):\n                assert dut.m_axis_data.value[23] == dut.s_axis_data.value[23], f\"[ERROR] m_axis_data is not matching to s_axis_data : {dut.m_axis_data.value}\"\n                assert dut.m_axis_data.value[31:24] == 8 * str(~dut.s_axis_data.value[23]), f\"[ERROR] m_axis_data is not matching to s_axis_data : {dut.m_axis_data.value}\"\n                assert dut.m_axis_data.value[22:0] == dut.s_axis_data.value[22:0], f\"[ERROR] m_axis_data is not matching to s_axis_data : {dut.m_axis_data.value}\"\n            else:\n                assert dut.m_axis_data.value[23] == dut.s_axis_data.value[23], f\"[ERROR] m_axis_data is not matching to s_axis_data : {dut.m_axis_data.value}\"\n                assert dut.m_axis_data.value[31:24] == 8 * (0), f\"[ERROR] m_axis_data is not matching to s_axis_data : {dut.m_axis_data.value}\"\n                assert dut.m_axis_data.value[22:0] == dut.s_axis_data.value[22:0], f\"[ERROR] m_axis_data is not matching to s_axis_data : {dut.m_axis_data.value}\"\n\n    else :    \n        assert dut.m_axis_data.value == s_axis_data, f\"[ERROR] m_axis_data is not matching to s_axis_data : {dut.m_axis_data.value}\"\n\n    m_axis_ready = 1\n    dut.m_axis_ready.value = m_axis_ready\n\n    await FallingEdge(dut.clk)\n\n    print(f's_axis_ready   = {dut.s_axis_valid.value}') ####need to remove\n    \n\n    print(f'Testing completed succesfully') \n    \n    ", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=False,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module)\n\n# random test\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_axis_upscale(test):\n    runner()"}}}
{"id": "cvdp_copilot_axil_precision_counter_0001", "categories": ["cid003", "medium"], "input": {"prompt": "\nDesign a Verilog module named precision_counter_axi that implements a configurable AXI4-Lite Slave interface to manage a high-precision countdown counter. The module facilitates software control through read and write operations, supporting features such as starting and stopping the counter, interrupt generation based on configurable thresholds, and tracking elapsed time after countdown completion. The module adheres to the AXI4-Lite protocol, ensuring proper handshaking, flow control, and error handling for invalid or undefined operations.\n\n---\n\n## Design Specification\n\n### AXI4-Lite Protocol Features\n\n### 1. Handshake Mechanism\nThe AXI4-Lite protocol uses a valid-and-ready handshake mechanism to ensure successful transactions:\n\n- **Write Transaction Handshake**:\n  - The AXI master asserts `axi_awvalid` to indicate a valid write address and control signals.\n  - The slave asserts `axi_awready` when ready to accept the address.\n  - After the write address handshake, the master asserts `axi_wvalid` with valid data, and the slave responds with `axi_wready` when ready to accept the data.\n  - Finally, the slave sends a write response (`axi_bresp`), asserting `axi_bvalid` when the response is valid. The master acknowledges the response by asserting `axi_bready`.\n\n- **Read Transaction Handshake**:\n  - The AXI master asserts `axi_arvalid` to indicate a valid read address.\n  - The slave asserts `axi_arready` when ready to accept the address.\n  - After address handshaking, the slave provides the requested data (`axi_rdata`) and response (`axi_rresp`), asserting `axi_rvalid` to indicate data availability. The master asserts `axi_rready` to acknowledge the data reception.\n\n### 2. Flow Control\n- The module ensures proper flow control by using `axi_awready`, `axi_wready`, and `axi_arready` signals. These signals allow the slave to introduce backpressure, preventing data loss or overflow when it is not ready to process requests.\n\n### 3. Address Decoding\n- The incoming address (`axi_awaddr` or `axi_araddr`) is decoded to access specific control and data registers. Unrecognized addresses result in error responses (`axi_bresp` or `axi_rresp` set to `2'b10`).\n\n---\n\n### Interface\n\n#### Parameters\n- `C_S_AXI_DATA_WIDTH`: Specifies the width of the AXI data bus. The default value is 32. This parameter defines the size of the data transferred during read and write operations, and it must be a positive integer greater than or equal to 8.\n- `C_S_AXI_ADDR_WIDTH`: Specifies the width of the AXI address bus. The default value is 8. This parameter determines the maximum addressable range of the registers. It must be a positive integer greater than or equal to 8.\n\n#### Inputs\n- **Clock and Reset Signals:**\n  - `axi_aclk`:The clock signal for synchronous operations. The design operates on the positive edge of the clock signal..\n  - `axi_aresetn`: Active-low asynchronous reset. When de-asserted, the module returns to its initial state.\n\n- **AXI Write Address Channel:**\n  - `[C_S_AXI_ADDR_WIDTH-1:0] axi_awaddr`: Write the address from the AXI master.\n  - `axi_awvalid`: Indicates that the write address and control signals are valid.\n\n- **AXI Write Data Channel:**\n  - `[C_S_AXI_DATA_WIDTH-1:0] axi_wdata`: Data to be written to the addressed location.\n  - `[(C_S_AXI_DATA_WIDTH/8)-1:0] axi_wstrb`: Write strobes, indicating which bytes in `axi_wdata` are valid.\n  - `axi_wvalid`: Indicates that valid write data is available.\n\n- **AXI Write Response Channel:**\n  - `axi_bready`: Indicates that the AXI master is ready to accept the write response.\n\n- **AXI Read Address Channel:**\n  - `[C_S_AXI_ADDR_WIDTH-1:0] axi_araddr`: Read address from the AXI master.\n  - `axi_arvalid`: Indicates that the read address and control signals are valid.\n\n- **AXI Read Response Channel:**\n  - `axi_rready`: Indicates that the AXI master is ready to accept the read data.\n\n#### Outputs\n- **AXI Write Address Channel:**\n  - `axi_awready`: Indicates that the module is ready to accept a write address.\n\n- **AXI Write Data Channel:**\n  - `axi_wready`: Indicates that the module is ready to accept write data.\n\n- **AXI Write Response Channel:**\n  - `[1:0] axi_bresp`: Write response, where `2'b00` indicates success and `2'b10` indicates an error.\n  - `axi_bvalid`: Indicates that the write response is valid.\n\n- **AXI Read Address Channel:**\n  - `axi_arready`: Indicates that the module is ready to accept a read address.\n\n- **AXI Read Data Channel:**\n  - `[C_S_AXI_DATA_WIDTH-1:0] axi_rdata`: Data being read by the AXI master.\n  - `[1:0] axi_rresp`: Read response, where `2'b00` indicates success and `2'b10` indicates an error.\n  - `axi_rvalid`: Indicates that the read data is valid.\n\n- **Control Outputs:**\n  - `axi_ap_done`: Indicates that the countdown has completed.\n  - `irq`: Interrupt request signal triggered when the interrupt threshold is reached.\n\n---\n\n### Register Map\n\n| Register             | Offset | Description                                   | Access      | Bit Width |\n|----------------------|--------|-----------------------------------------------|-------------|-----------|\n| `slv_reg_ctl`        | 0x00   | Control register (start/stop countdown)       | Read/Write  | 32        |\n| `slv_reg_t`          | 0x10   | Elapsed time counter                          | Read/Write  | 32        |\n| `slv_reg_v`          | 0x20   | Countdown value                               | Read/Write  | 32        |\n| `slv_reg_irq_mask`   | 0x24   | Mask to enable or disable interrupt requests  | Read/Write  | 32        |\n| `slv_reg_irq_thresh` | 0x28   | Threshold value for generating interrupts     | Read/Write  | 32        |\n\n---\n\n\n\n### Functional Description\n\n#### 1. **Control Register (`slv_reg_ctl`):**\n- **Bit 0 (Start/Stop):**\n  - Writing `1` starts the countdown.\n  - Writing `0` stops the countdown.\n  - When stopped, the countdown value (`slv_reg_v`) retains its current value.\n- **Reset Behavior:**\n  - Writing to this register resets the elapsed time register (`slv_reg_t`) to zero.\n- **Default Value:**\n  - Initializes to `0` after reset, meaning the countdown is stopped.\n\n#### 2. **Countdown Register (`slv_reg_v`):**\n- **Purpose:**\n  - Holds the countdown value.\n  - The counter decrements by `1` every clock cycle while running.\n- **Completion Behavior:**\n  - When the countdown reaches `0`, the `axi_ap_done` signal is asserted.\n- **Writing Behavior:**\n  - Writing a new value updates the countdown value, even while the counter is running.\n\n#### 3. **Elapsed Time Register (`slv_reg_t`):**\n- **Purpose:**\n  - Tracks the number of clock cycles elapsed after the countdown reaches `0`.\n- **Behavior:**\n  - Increments by `1` every clock cycle when the counter is finished (`slv_reg_v == 0`).\n- **Reset Behavior:**\n  - Automatically resets to `0` whenever the control register (`slv_reg_ctl`) is written.\n\n#### 4. **Interrupt Mechanism:**\n- **Interrupt Mask Register (`slv_reg_irq_mask`):**\n  - Enables or disables interrupt generation.\n  - Interrupts are enabled when `slv_reg_irq_mask[0]` is set to `1`.\n- **Interrupt Threshold Register (`slv_reg_irq_thresh`):**\n  - Defines the countdown value at which the interrupt is triggered.\n- **IRQ Signal (`irq`):**\n  - Asserted when the countdown value (`slv_reg_v`) matches the interrupt threshold (`slv_reg_irq_thresh`) and interrupts are enabled.\n  - Automatically cleared when:\n    - The countdown stops.\n    - The threshold condition is no longer met.\n    - The reset signal (`axi_aresetn`) is asserted.\n\n#### 5. **Write Response (`axi_bresp`):**\n- **Purpose:**\n  - Indicates the success or failure of a write transaction.\n- **Conditions:**\n  - **`2'b00` (OKAY):**\n    - The write operation completed successfully.\n    - Generated when the write address and data handshake (`axi_awvalid`, `axi_wvalid`) are completed and processed correctly.\n  - **`2'b10` (SLVERR - Slave Error):**\n    - The write operation failed due to invalid conditions, such as accessing an unsupported address.\n    - Generated when the address is outside the implemented range or the operation is otherwise invalid.\n\n#### 6. **Read Response (`axi_rresp`):**\n- **Purpose:**\n  - Indicates the success or failure of a read transaction.\n- **Conditions:**\n  - **`2'b00` (OKAY):**\n    - The read operation completed successfully.\n    - Generated when a valid read address (`axi_arvalid`) is provided, and the requested data is available.\n  - **`2'b10` (SLVERR - Slave Error):**\n    - The read operation failed due to invalid conditions, such as accessing an unsupported address.\n    - Generated when the address is outside the implemented range.\n\n\n---\n\n### Timing and Synchronization\n\n- **Clock:** The module operates on the rising edge of `axi_aclk`.\n- **Reset:** Active-low (`axi_aresetn`). Resets all internal registers and outputs to their default state.\n\n---\n\n### Constraints and Edge Cases\n\n1. **Reset Behavior:**\n   - When reset is asserted, all registers are cleared to zero.\n\n2. **Invalid AXI Operations:**\n   - Writing to undefined or reserved addresses is ignored, and the registers remain unchanged.\n   - Read/write transactions without proper handshaking (valid and ready signals) are ignored to ensure AXI protocol compliance.\n\n3. **Interrupt Handling:**\n   - Interrupts are only generated if `slv_reg_irq_mask` is enabled and the counter value matches the threshold.\n\n---\n\n### Example Operations\n\n#### Write Operation Example\n- **Operation:** Start the counter and set the countdown value.\n  - Write `0x1` to the control register (`slv_reg_ctl`) to start the countdown.\n    - Address: `0x00`\n    - Data: `0x00000001`\n    - **Result:** The countdown starts, and `slv_reg_ctl[0]` is set to `1`.\n\n  - Write `0x00000010` to the countdown value register (`slv_reg_v`).\n    - Address: `0x20`\n    - Data: `0x00000010`\n    - **Result:** The countdown value is set to `16`.\n\n#### Read Operation Example\n- **Operation:** Read the elapsed time and status.\n  - Read from the elapsed time register (`slv_reg_t`).\n    - Address: `0x10`\n    - **Result:** The current elapsed time value is returned.\n\n  - Read the `axi_ap_done` status by accessing the control register.\n    - Address: `0x0C`\n    - **Result:** Returns `1` if the countdown is complete, otherwise `0`.\n\n#### Interrupt Example\n- **Condition:** Set the interrupt threshold and enable interrupts.\n  - Write `0x00000005` to the interrupt threshold register (`slv_reg_irq_thresh`).\n    - Address: `0x28`\n    - Data: `0x00000005`\n    - **Result:** The interrupt threshold is set to `5`.\n\n  - Write `0x00000001` to the interrupt mask register (`slv_reg_irq_mask`) to enable interrupts.\n    - Address: `0x24`\n    - Data: `0x00000001`\n    - **Result:** Interrupts are enabled.\n\n  - **Trigger:** When the countdown value reaches `5`, the `irq` signal is asserted.\n\n---\n\n#### Write Transaction Handshake\n {\n\"signal\": [\n{ \"name\": \"axi_aclk\", \"wave\": \"p.............\" },\n{ \"name\": \"axi_aresetn\", \"wave\": \"01............\" },\n\n{ \"name\": \"axi_awaddr\", \"wave\": \"x.=....=......\", \"data\": [\"0x00\",\"0x20\"] },\n{ \"name\": \"axi_wdata\", \"wave\": \"x.=....=......\", \"data\": [\"0x00000001\",\"0xABCDEF01\"] },\n{ \"name\": \"axi_awvalid\", \"wave\": \"0.1.0..1.0....\", \"data\": [\"Write Addr Valid\"] },\n{ \"name\": \"axi_wvalid\", \"wave\": \"0.1.0..1.0....\", \"data\": [\"Write Data Valid\"] },\n{ \"name\": \"axi_wstrb\", \"wave\": \"x.=...........\", \"data\": [\"0xF\"] },\n{ \"name\": \"axi_awready\", \"wave\": \"0..10...10....\", \"data\": [\"Write Addr Ready\"] },\n\n{ \"name\": \"axi_wready\", \"wave\": \"0..10...10....\", \"data\": [\"Write Data Ready\"] },\n{ \"name\": \"slv_reg_ctl[31:0]\", \"wave\": \"x...=.........\", \"data\": [\"0x00000001\"] },\n{ \"name\": \"slv_reg_v[31:0]\", \"wave\": \"x.=......=====\", \"data\": [\"0x00000000\",\"0xABCDEF01\",\"ABCD EF00\",\"ABCD EEFF\",\"ABCD EEFE\",\"ABCD EEFD\"] },\n\n{ \"name\": \"axi_bvalid\", \"wave\": \"0...10...10...\", \"data\": [\"Write Response Valid\"] },\n{ \"name\": \"axi_bready\", \"wave\": \"0...10...10...\", \"data\": [\"Write Data Ready\"] },\n{ \"name\": \"axi_bresp\", \"wave\": \"x...==...==...\", \"data\": [\"00\",\"10\",\"00\",\"10\"] },\n\n],\n\"head\": {\n\"text\": \"AXI4-Lite Write Transaction Handshake\"\n}\n}\n\n---\n#### Read  Transaction Handshake\n{\n\"signal\": [\n{ \"name\": \"axi_aclk\", \"wave\": \"p.............\" },\n{ \"name\": \"axi_aresetn\", \"wave\": \"1............0\" },\n{ \"name\": \"slv_reg_ctl[31:0]\", \"wave\": \"x=............\", \"data\": [\"0x00000001\"] },\n{ \"name\": \"slv_reg_v[31:0]\", \"wave\": \"x.============\", \"data\": [\"0x00000000\",\"0xABCDEF01\",\"ABCDEF00\",\"ABCDEEFF\",\"ABCDEEFE\",\"ABCDEEFD\",\"ABCDEEFC\",\"ABCDEEFB\",\"ABCDEEFA\",\"ABCDEEF9\",\"ABCDEEF8\",\"ABCDEEF7\"] },\n{ \"name\": \"axi_araddr\", \"wave\": \"x.=....=......\", \"data\": [\"0x00\",\"0x20\"] },\n{ \"name\": \"axi_arvalid\", \"wave\": \"0.1.0..1.0....\", \"data\": [\"Read Addr Valid\"] },\n{ \"name\": \"axi_arready\", \"wave\": \"0..10...10....\", \"data\": [\"Read Addr Ready\"] },\n{ \"name\": \"axi_rready\", \"wave\": \"0.1..0.1..0...\", \"data\": [\"Read Data Ready\"] },\n\n{ \"name\": \"axi_rvalid\", \"wave\": \"0...10...10...\", \"data\": [\"Read Data Valid\"] },\n\n{ \"name\": \"axi_rdata\", \"wave\": \"x...=....=....\", \"data\": [\"0x00000001\",\"ABCDEEFC\"] },\n{ \"name\": \"axi_rresp\", \"wave\": \"x...==...==...\", \"data\": [\"00\",\"10\",\"00\",\"10\"] },\n],\n\"head\": {\n\"text\": \"AXI4-Lite Read Transaction Handshake\"\n}\n}", "context": {}}, "output": {"response": "", "context": {"rtl/precision_counter_axi.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v ", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/precision_counter_axi.sv\nTOPLEVEL        = precision_counter_axi\nMODULE          = test_precision_counter_axi\nPYTHONPATH      = /src\nHASH            = d0878158d85167051ff4db2164e1b6799a524f77", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_precision_counter_axi.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ReadOnly , Timer\n\nimport harness_library as hrs_lb\nimport random\n\n# Function to initialize the DUT\nasync def initialize_dut(dut):\n    dut.axi_awvalid.value = 0\n    dut.axi_wvalid.value = 0\n    dut.axi_arvalid.value = 0\n    dut.axi_bready.value = 0\n    dut.axi_rready.value = 0\n    dut.axi_awaddr.value = 0\n    dut.axi_wdata.value = 0\n    dut.axi_wstrb.value = 0\n    dut.axi_araddr.value = 0\n\n# Function to reset the DUT\nasync def reset_dut(reset_signal, duration_ns=25, active=True):\n    reset_signal.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_signal.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n\n# AXI write transaction helper function\nasync def axi_write(dut, address, data, strb=0xF):\n    dut.axi_awaddr.value = address\n    dut.axi_wdata.value = data\n    dut.axi_awvalid.value = 1\n    dut.axi_wvalid.value = 1\n    dut.axi_wstrb.value = strb\n    await RisingEdge(dut.axi_aclk)\n\n    while not (dut.axi_awready.value and dut.axi_wready.value):\n        await RisingEdge(dut.axi_aclk)\n\n    await RisingEdge(dut.axi_aclk)\n    dut.axi_awvalid.value = 0\n    dut.axi_wvalid.value = 0\n\n    dut.axi_bready.value = 1\n    await RisingEdge(dut.axi_aclk)\n    dut.axi_bready.value = 0\n\n# AXI read transaction helper function\nasync def axi_read(dut, address):\n    dut.axi_araddr.value = address\n    dut.axi_arvalid.value = 1\n    dut.axi_rready.value = 1\n\n    while not dut.axi_arready.value:\n        await RisingEdge(dut.axi_aclk)\n\n    await RisingEdge(dut.axi_aclk)\n    await RisingEdge(dut.axi_aclk)\n\n    dut.axi_arvalid.value = 0\n\n    while not dut.axi_rvalid.value:\n        await RisingEdge(dut.axi_aclk)\n\n    await RisingEdge(dut.axi_aclk)\n    dut.axi_rready.value = 0\n\n# Function to check output values\nasync def check_output(dut, address, expected_value, description):\n    await axi_read(dut, address)\n    assert  dut.axi_rdata.value == expected_value, f\"{description}: Expected {expected_value}, got { dut.axi_rdata.value}\"\n\n# Function to test random countdown values\nasync def test_random_countdown(dut,DATA_WIDTH):\n    for _ in range(10):\n        strb = (1 << (DATA_WIDTH // 8)) - 1\n        random_value = random.randint(0, (1 << DATA_WIDTH) - 1)\n        await axi_write(dut, 0x20, random_value,strb)\n        await check_output(dut, 0x20, random_value-2, f\"Random countdown value {random_value}\")\n\n\n# Function to test IRQ output\nasync def test_irq_output(dut,DATA_WIDTH):\n    strb = (1 << (DATA_WIDTH // 8)) - 1\n    await axi_write(dut, 0x24, 0x1,strb)  # Enable IRQ\n    await RisingEdge(dut.axi_aclk)\n    await axi_write(dut, 0x28, 0x5,strb)  # Write to threshold register\n    await RisingEdge(dut.axi_aclk)\n    await axi_write(dut, 0x20, 0x5,strb)  # Write to countdown value\n    await RisingEdge(dut.axi_aclk)\n    await axi_write(dut, 0x00, 0x1,strb)  # Start the counter\n    await RisingEdge(dut.axi_aclk)\n\n    # Check IRQ output\n    if dut.irq.value:\n        dut._log.info(\"[PASS] IRQ triggered successfully.\")\n    else:\n        dut._log.error(\"[FAIL] IRQ not triggered.\")\n\n# Function to test additional reads\nasync def test_additional_reads(dut):\n    await axi_read(dut, 0x20)  # Read counter value register\n    await RisingEdge(dut.axi_aclk)\n\n    await axi_read(dut, 0x04)  # Read dummy register\n    dut._log.info(\"Reading from dummy register 0x04\")\n    await RisingEdge(dut.axi_aclk)\n\n    await axi_read(dut, 0x08)  # Read another dummy register\n    dut._log.info(\"Reading from dummy register 0x08\")\n    await RisingEdge(dut.axi_aclk)\n\n    await axi_read(dut, 0x50)  # Attempt to read invalid register\n    dut._log.info(\" Invalid register 0x50 read .\")\n    await RisingEdge(dut.axi_aclk)\n\n# Function to test reset behavior\nasync def test_reset_behavior(dut):\n    await axi_write(dut, 0x00, 0x1)  # Start the counter\n    random_value = random.randint(1, 100)\n    await axi_write(dut, 0x20, random_value)  # Set countdown value\n\n    await reset_dut(dut.axi_aresetn)\n\n    # Verify all registers reset to default values\n    await check_output(dut, 0x00, 0x0, \"Control register after reset\")\n    await check_output(dut, 0x20, 0x0, \"Countdown value after reset\")\n    await check_output(dut, 0x10, 0x0, \"Elapsed time register after reset\")\n\n@cocotb.test()\nasync def test_precision_counter_axi(dut):\n    ADDR_WIDTH = int(dut.C_S_AXI_ADDR_WIDTH.value)\n    DATA_WIDTH = int(dut.C_S_AXI_DATA_WIDTH.value)\n    # Start the clock with a 10ns time period (100 MHz clock)\n    cocotb.start_soon(Clock(dut.axi_aclk, 10, units='ns').start())\n\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.axi_aresetn, duration_ns=25, active=True)\n\n    await RisingEdge(dut.axi_aclk) \n\n     # Test case 1: Write to the control register and verify\n    strb = (1 << (DATA_WIDTH // 8)) - 1\n    await axi_write(dut, 0x00, 0x1,strb)  # Start the counter\n    await check_output(dut, 0x00, 0x1, \"Control register value mismatch\")\n    await RisingEdge(dut.axi_aclk) \n\n    # Test case 2: Set countdown value and verify\n    random_value = random.randint(0, (1 << DATA_WIDTH) - 1)\n    await axi_write(dut, 0x20, random_value,strb)  # Set countdown value to 100\n    await check_output(dut, 0x20, (random_value-2), \"Countdown value mismatch\")\n    await RisingEdge(dut.axi_aclk) \n\n    # Test case 3: Verify interrupt mask functionality\n    random_value = random.randint(0, (1 << DATA_WIDTH) - 1)\n    await axi_write(dut, 0x24, random_value,strb)  # Enable interrupt\n    await check_output(dut, 0x24, random_value, \"Interrupt mask mismatch\")\n    \n    # Test case 4: Verify Write to address 0x28\n    random_value = random.randint(0, (1 << DATA_WIDTH) - 1)\n    await axi_write(dut, 0x28, random_value,strb)\n    await check_output(dut, 0x28, random_value, f\"Write to address 0x28 with value {random_value}\")\n\n    # Test case 4: Countdown functionality and interrupt generation\n    for i in range(10):\n        await RisingEdge(dut.axi_aclk)\n\n    await check_output(dut, 0x10, 6, \"Elapsed time mismatch\")\n    # Test case 5: Additional register reads\n    await test_additional_reads(dut)\n\n    # Test case 6: IRQ output checking\n    await test_irq_output(dut,DATA_WIDTH)\n\n    # Corner case 2: Test random countdown values\n    await test_random_countdown(dut,DATA_WIDTH)\n\n    # Corner case 3: Test reset behavior\n    await test_reset_behavior(dut)\n\n    dut._log.info(\"All test cases, including corner cases, passed.\")   ", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(C_S_AXI_ADDR_WIDTH : int = 8 ,C_S_AXI_DATA_WIDTH: int= 32 ):\n\n    parameter = {\n        \"C_S_AXI_ADDR_WIDTH\": C_S_AXI_ADDR_WIDTH,\n        \"C_S_AXI_DATA_WIDTH\": C_S_AXI_DATA_WIDTH\n    }\n    print(f\"[DEBUG] Parameters: {parameter}\") \n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n\n@pytest.mark.parametrize(\"test\", range(1))\n@pytest.mark.parametrize(\"C_S_AXI_ADDR_WIDTH\", [8,16,32])\n@pytest.mark.parametrize(\"C_S_AXI_DATA_WIDTH\", [32,64,48])\ndef test_axi_reg(test,C_S_AXI_ADDR_WIDTH,C_S_AXI_DATA_WIDTH):\n        runner(C_S_AXI_DATA_WIDTH = C_S_AXI_DATA_WIDTH ,C_S_AXI_ADDR_WIDTH = C_S_AXI_ADDR_WIDTH )"}}}
{"id": "cvdp_copilot_axis_joiner_0001", "categories": ["cid003", "medium"], "input": {"prompt": "\n\nDesign a **SystemVerilog RTL module** named `axis_joiner` that merges multiple AXI Stream (AXIS) inputs into a single AXIS output. This module should allow seamless data transfer from three independent input streams (`s_axis`) to a single output stream (`m_axis`).  \n\nThe design should incorporate the following key features:  \n\n### **1. AXI Stream Interfaces**  \n#### **Input Ports and output ports**  \n- The module receives data from **three independent AXI Stream interfaces** (`s_axis_tdata_1`, `s_axis_tdata_2`, `s_axis_tdata_3`).  \n- Each input stream includes the standard **AXI Stream handshake signals**:  \n  - `tdata` (data bus)  \n  - `tvalid` (data valid indicator)  \n  - `tready` (ready signal for backpressure handling)  \n  - `tlast` (indicating the last transfer of a packet)  \n\n#### **Output Port:**  \n- A **single merged AXI Stream output** (`m_axis`) that transmits data from one of the three input streams at any given time.  \n- The output interface follows the **AXI Stream protocol**, including the standard signals:  \n  - `tdata`, `tvalid`, `tready`, `tlast`, and `tuser`.  \n\nPort Name | Direction | Width | Description\n-- | -- | -- | --\nclk | Input | 1 bit | System clock signal.\nrst | Input | 1 bit | Asynchronous active-high reset.\ns_axis_tdata_1 | Input | 8-bit | Data from AXI Stream 1.\ns_axis_tvalid_1 | Input | 1 bit | Valid signal for AXIS 1.\ns_axis_tready_1 | Output | 1 bit | Ready signal for AXIS 1.\ns_axis_tlast_1 | Input | 1 bit | Last data word indicator for AXIS 1.\ns_axis_tdata_2 | Input | 8-bit  | Data from AXI Stream 2.\ns_axis_tvalid_2 | Input | 1 bit | Valid signal for AXIS 2.\ns_axis_tready_2 | Output | 1 bit | Ready signal for AXIS 2.\ns_axis_tlast_2 | Input | 1 bit | Last data word indicator for AXIS 2.\ns_axis_tdata_3 | Input | 8-bit  | Data from AXI Stream 3.\ns_axis_tvalid_3 | Input | 1 bit | Valid signal for AXIS 3.\ns_axis_tready_3 | Output | 1 bit | Ready signal for AXIS 3.\ns_axis_tlast_3 | Input | 1 bit | Last data word indicator for AXIS 3.\nm_axis_tdata | Output | 8-bit  | Merged output data.\nm_axis_tvalid | Output | 1 bit | Valid signal for merged stream.\nm_axis_tready | Input | 1 bit | Ready signal for merged stream.\nm_axis_tlast | Output | 1 bit | Last data word indicator for output.\nm_axis_tuser | Output | 2-bit  | Identifies source of output data with TAG_ID.\nbusy | Output | 1 bit | Indicates module is processing data.\n\n\n### **2. Arbitration and Control Logic**  \nThe module should operate based on a simple round-robin arbitration scheme, prioritizing valid input streams.\n- The module uses a **Finite State Machine (FSM)** to control the selection of input streams.  \n- The FSM operates in the following states:  \n  - `STATE_IDLE`: Waits for a valid input stream.  \n  - `STATE_1`: Transfers data from `s_axis_tdata_1`.  \n  - `STATE_2`: Transfers data from `s_axis_tdata_2`.  \n  - `STATE_3`: Transfers data from `s_axis_tdata_3`.  \n- The selection priority is determined as follows:  \n  1. If `s_axis_tvalid_1` is asserted, the FSM transitions to `STATE_1`.  \n  2. If `s_axis_tvalid_2` is asserted and `s_axis_tvalid_1` is not available, the FSM transitions to `STATE_2`.  \n  3. If `s_axis_tvalid_3` is asserted and both `s_axis_tvalid_1` and `s_axis_tvalid_2` are unavailable, the FSM transitions to `STATE_3`.  \n- Once the selected input stream completes its packet (`tlast` asserted), the FSM returns to `STATE_IDLE` and waits for the next available stream.  \n\n### **3. Data Buffering and Synchronization**  \n- If `m_axis_tready` is deasserted while transferring data, the module should **temporarily store the current data** in internal registers.  \n- Buffered data should be output once `m_axis_tready` is reasserted to maintain **seamless and lossless data transfer**.  \n- The `temp` flag ensures that data is retained when output is stalled.  \n\n### **4. Signal Assignments and Muxing**  \n- A multiplexer (`MUX`) selects the appropriate input data (`tdata`, `tvalid`, `tlast`, `tuser`) based on the current FSM state.  \n- The `tuser` field is assigned a unique tag (`TAG_ID_1`, `TAG_ID_2`, `TAG_ID_3`) to indicate the originating stream.  \n    `TAG_ID_1`: TAG_ID for AXI stream input 1 is 0x1.\n    `TAG_ID_2`: TAG_ID for AXI stream input 2 is 0x2.\n    `TAG_ID_3`: TAG_ID for AXI stream input 3 is 0x3.\n- `tready` signals are managed based on the FSM state, ensuring that only the active input stream is acknowledged.  \n\n\n### **5. Reset Behavior**  \n- The design should include an **asynchronous reset (`rst`)** that properly initializes all state variables and output signals.  \n\n### **6. Status Signals**  \n- A `busy` output signal should indicate when the module is actively processing data from any input stream.  \n\n\n\n\n\n\n\n\n", "context": {}}, "output": {"response": "", "context": {"rtl/axis_joiner.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py\n\n", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/axis_joiner.sv \nTOPLEVEL        = axis_joiner\nMODULE          = test_axis_joiner\nPYTHONPATH      = /src\nHASH            = eaef2a5732f3a70708e4bc7fcee6182810470f16\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(rst_n, dut):\n    # Restart Interface\n    await FallingEdge(dut.clk)\n    rst_n.value = 0\n    await FallingEdge(dut.clk)\n    rst_n.value = 1\n    await FallingEdge(dut.clk)\n    rst_n._log.debug(\"Reset complete\")\n\nasync def enable_dut(enable, duration_ns = 10):\n    # Restart Interface\n    enable.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    enable.value = 1\n    await Timer(duration_ns, units='ns')\n    enable._log.debug(\"enable complete\")\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def calculate_moving_average(data_queue, current_sum, new_data, window):\n    if len(data_queue) < window:\n        data_queue.append(new_data)\n        current_sum += new_data\n    else:\n        oldest_data = data_queue.pop(0)\n        current_sum += new_data - oldest_data\n        data_queue.append(new_data)\n\n    expected_avg = current_sum // window\n    \n    return expected_avg, current_sum\n\nasync def int_to_unsigned_binary(value, bit_width):\n mask = (1 << bit_width) - 1\n unsigned_value = value & mask\n return f\"{unsigned_value:0{bit_width}b}\"\n\n", "src/test_axis_joiner.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport time\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_axis_joiner(dut):\n    # Seed the random number generator with the current time or another unique value\n    random.seed(time.time())\n    # Start clock\n    cocotb.start_soon(Clock(dut.clk, 5, units='ns').start())\n    \n    await hrs_lb.dut_init(dut)\n    \n\n\n    await FallingEdge(dut.clk)\n    dut.rst.value = 0\n    await FallingEdge(dut.clk)\n    dut.rst.value = 1\n    await FallingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n    assert dut.m_axis_tdata.value == 0, f\"[ERROR] m_axis_tdata value is : {dut.m_axis_tdata.value}\"\n    print(f'reset successful ')\n\n    dut.m_axis_tready.value = 1\n \n    \n    await FallingEdge(dut.clk)\n    dut.s_axis_tdata_1.value = 0xff\n    dut.s_axis_tvalid_1.value = 1\n    dut.s_axis_tlast_1.value = 0\n    await FallingEdge(dut.clk)\n    dut.s_axis_tdata_1.value = 0xf0\n    dut.s_axis_tvalid_1.value = 1\n    dut.s_axis_tlast_1.value = 0\n    assert dut.m_axis_tdata.value == 0xff, f\"[ERROR] m_axis_tdata value is : {dut.m_axis_tdata.value}\"\n    assert dut.m_axis_tvalid.value == 1, f\"[ERROR] m_axis_tvalid value is : {dut.m_axis_tvalid.value}\"\n    assert dut.m_axis_tlast.value == 0, f\"[ERROR] m_axis_tlast value is : {dut.m_axis_tlast.value}\"\n    assert dut.m_axis_tuser.value == 0x1, f\"[ERROR] m_axis_tuser value is : {dut.m_axis_tuser.value}\"\n    \n\n    await FallingEdge(dut.clk)\n    dut.s_axis_tdata_1.value = 0xfa\n    dut.s_axis_tvalid_1.value = 1\n    dut.s_axis_tlast_1.value = 1\n    assert dut.m_axis_tdata.value == 0xf0, f\"[ERROR] m_axis_tdata value is : {dut.m_axis_tdata.value}\"\n    assert dut.m_axis_tvalid.value == 1, f\"[ERROR] m_axis_tvalid value is : {dut.m_axis_tvalid.value}\"\n    assert dut.m_axis_tlast.value == 0, f\"[ERROR] m_axis_tlast value is : {dut.m_axis_tlast.value}\"\n    assert dut.m_axis_tuser.value == 0x1, f\"[ERROR] m_axis_tuser value is : {dut.m_axis_tuser.value}\"\n    await RisingEdge(dut.clk)\n    assert dut.m_axis_tdata.value == 0xfa, f\"[ERROR] m_axis_tdata value is : {dut.m_axis_tdata.value}\"\n    assert dut.m_axis_tvalid.value == 1, f\"[ERROR] m_axis_tvalid value is : {dut.m_axis_tvalid.value}\"\n    assert dut.m_axis_tlast.value == 1, f\"[ERROR] m_axis_tlast value is : {dut.m_axis_tlast.value}\"\n    assert dut.m_axis_tuser.value == 0x1, f\"[ERROR] m_axis_tuser value is : {dut.m_axis_tuser.value}\"\n\n    print(f'successfully received data from stream 1 with correct tag id in m_axis_tuser channel  ')\n\n    await FallingEdge(dut.clk)\n    dut.s_axis_tvalid_1.value = 0\n    await FallingEdge(dut.clk)\n    await FallingEdge(dut.clk)\n    \n    await FallingEdge(dut.clk)\n    dut.s_axis_tdata_2.value = 0xff\n    dut.s_axis_tvalid_2.value = 1\n    dut.s_axis_tlast_2.value = 0\n    await FallingEdge(dut.clk)\n    dut.s_axis_tdata_2.value = 0xf0\n    dut.s_axis_tvalid_2.value = 1\n    dut.s_axis_tlast_2.value = 0\n    assert dut.m_axis_tdata.value == 0xff, f\"[ERROR] m_axis_tdata value is : {dut.m_axis_tdata.value}\"\n    assert dut.m_axis_tvalid.value == 1, f\"[ERROR] m_axis_tvalid value is : {dut.m_axis_tvalid.value}\"\n    assert dut.m_axis_tlast.value == 0, f\"[ERROR] m_axis_tlast value is : {dut.m_axis_tlast.value}\"\n    assert dut.m_axis_tuser.value == 0x2, f\"[ERROR] m_axis_tuser value is : {dut.m_axis_tuser.value}\"\n\n    await FallingEdge(dut.clk)\n    dut.s_axis_tdata_2.value = 0xfa\n    dut.s_axis_tvalid_2.value = 1\n    dut.s_axis_tlast_2.value = 1\n    assert dut.m_axis_tdata.value == 0xf0, f\"[ERROR] m_axis_tdata value is : {dut.m_axis_tdata.value}\"\n    assert dut.m_axis_tvalid.value == 1, f\"[ERROR] m_axis_tvalid value is : {dut.m_axis_tvalid.value}\"\n    assert dut.m_axis_tlast.value == 0, f\"[ERROR] m_axis_tlast value is : {dut.m_axis_tlast.value}\"\n    assert dut.m_axis_tuser.value == 0x2, f\"[ERROR] m_axis_tuser value is : {dut.m_axis_tuser.value}\"\n    await RisingEdge(dut.clk)\n    assert dut.m_axis_tdata.value == 0xfa, f\"[ERROR] m_axis_tdata value is : {dut.m_axis_tdata.value}\"\n    assert dut.m_axis_tvalid.value == 1, f\"[ERROR] m_axis_tvalid value is : {dut.m_axis_tvalid.value}\"\n    assert dut.m_axis_tlast.value == 1, f\"[ERROR] m_axis_tlast value is : {dut.m_axis_tlast.value}\"\n    assert dut.m_axis_tuser.value == 0x2, f\"[ERROR] m_axis_tuser value is : {dut.m_axis_tuser.value}\"\n\n    print(f'successfully received data from stream 2 with correct tag id in m_axis_tuser channel  ')\n\n    await FallingEdge(dut.clk)\n    dut.s_axis_tvalid_2.value = 0\n    await FallingEdge(dut.clk)\n    await FallingEdge(dut.clk)\n\n    await FallingEdge(dut.clk)\n    dut.s_axis_tdata_3.value = 0xff\n    dut.s_axis_tvalid_3.value = 1\n    dut.s_axis_tlast_3.value = 0\n    await FallingEdge(dut.clk)\n    dut.s_axis_tdata_3.value = 0xf0\n    dut.s_axis_tvalid_3.value = 1\n    dut.s_axis_tlast_3.value = 0\n    assert dut.m_axis_tdata.value == 0xff, f\"[ERROR] m_axis_tdata value is : {dut.m_axis_tdata.value}\"\n    assert dut.m_axis_tvalid.value == 1, f\"[ERROR] m_axis_tvalid value is : {dut.m_axis_tvalid.value}\"\n    assert dut.m_axis_tlast.value == 0, f\"[ERROR] m_axis_tlast value is : {dut.m_axis_tlast.value}\"\n    assert dut.m_axis_tuser.value == 0x3, f\"[ERROR] m_axis_tuser value is : {dut.m_axis_tuser.value}\"\n\n    await FallingEdge(dut.clk)\n    dut.s_axis_tdata_3.value = 0xfa\n    dut.s_axis_tvalid_3.value = 1\n    dut.s_axis_tlast_3.value = 1\n    assert dut.m_axis_tdata.value == 0xf0, f\"[ERROR] m_axis_tdata value is : {dut.m_axis_tdata.value}\"\n    assert dut.m_axis_tvalid.value == 1, f\"[ERROR] m_axis_tvalid value is : {dut.m_axis_tvalid.value}\"\n    assert dut.m_axis_tlast.value == 0, f\"[ERROR] m_axis_tlast value is : {dut.m_axis_tlast.value}\"\n    assert dut.m_axis_tuser.value == 0x3, f\"[ERROR] m_axis_tuser value is : {dut.m_axis_tuser.value}\"\n    await RisingEdge(dut.clk)\n    assert dut.m_axis_tdata.value == 0xfa, f\"[ERROR] m_axis_tdata value is : {dut.m_axis_tdata.value}\"\n    assert dut.m_axis_tvalid.value == 1, f\"[ERROR] m_axis_tvalid value is : {dut.m_axis_tvalid.value}\"\n    assert dut.m_axis_tlast.value == 1, f\"[ERROR] m_axis_tlast value is : {dut.m_axis_tlast.value}\"\n    assert dut.m_axis_tuser.value == 0x3, f\"[ERROR] m_axis_tuser value is : {dut.m_axis_tuser.value}\"\n\n    print(f'successfully received data from stream 3 with correct tag id in m_axis_tuser channel  ')\n\n   \n    print(f' tested successfully')\n    ", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=False,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module)\n\n# random test\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_axis_joiner(test):\n    runner()"}}}
{"id": "cvdp_copilot_barrel_shifter_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design an **8-bit barrel shifter** which can shift the bits of an 8-bit input either to the left or to the right based on a control signal. This shift can range from 0 to 7 bits, as specified by another control signal. The operation must complete in **one clock cycle**. The detailed design specification for the **8-bit barrel shifter** is given below :\n\n## Design Specification:\n\nA **barrel shifter** is a digital circuit that shifts a data word by a specified number of bits in one clock cycle. It is commonly used in digital systems like microprocessors to perform rapid shifts of binary numbers, which is useful in operations such as multiplication, division, and data manipulation.\n\n### Module Name:\n`barrel_shifter_8bit`\n\n### Key Considerations:\nThis design should be a **combinational logic**. The output must change immediately based on the input and control signals\n\n### Interface:\n\n#### Inputs:\n- **`data_in`** (8-bits, [7:0]): The 8-bit input data. This will be shifted by a number of bits based on the other control signals.\n- **`shift_bits`** (3-bits, [2:0]): Determines how many bits to shift the input. This value can range from `3'b000` (no shift) to `3'b111` (7-bit shift).\n- **`left_right`** (1-bit): Decides the direction of the shift.\n   - `left_right = 1`: Shift left.\n   - `left_right = 0`: Shift right.\n\n#### Output:\n- **`data_out`** (8-bits, [7:0]): The result after shifting the input. The output can range from 8'b00000000 to 8'b11111111.\n\n### Behavior and Data Flow:\nThe input data (`data_in`) undergoes a shift operation, either to the left or right, as determined by the `shift_bits` value and the direction indicated by `left_right`. When `data_in` shifts right by the number specified in `shift_bits`, zeros are inserted into the Most Significant Bit (MSB) positions, equal to the value of `shift_bits`. Conversely, when `data_in` shifts left by the `shift_bits` value, zeros are inserted into the Least Significant Bit (LSB) positions, also corresponding in number to `shift_bits`.\n\n### Example Operations:\n\n#### Left Shift Example:\n- `data_in` = 8'b11001100, `shift_bits` = 3'b100, `left_right` = 1  \n- `data_out` = 8'b11001100 << 4 = 8'b11000000  \n\n#### Right Shift Example:\n- `data_in` = 8'b11001100, `shift_bits` = 3'b100, `left_right` = 0  \n- `data_out` = 8'b11001100 >> 4 = 8'b00001100  ", "context": {}}, "output": {"response": "", "context": {"rtl/barrel_shifter_8bit.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/barrel_shifter_8bit.sv\nTOPLEVEL        = barrel_shifter_8bit\nMODULE          = test_barrel_shifter\nPYTHONPATH      = /src\nHASH            = eff4f10b22d739db6a0f7ccddae23d2d08162479", "src/test_barrel_shifter.py": "import cocotb\nimport os\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer, Join\nimport random\n\n# ----------------------------------------\n# - Tests\n# ----------------------------------------\n\n@cocotb.test()\nasync def test_barrel_1(dut):\n      \n    dut.data_in.value = int((1.0 - random.random()) * 2 ** 8);   \n    dut.shift_bits.value = 0b011    \n    dut.left_right.value = 0b1;\n    \n    await Timer(10, units = \"ns\")\n    print(\"data_in \",str(dut.data_in.value))\n    print(\"shift_bits \",str(dut.shift_bits.value))\n    print(\"left_right\",str(dut.left_right.value))\n    print(\"data_out \",str(dut.data_out.value))\n    \n    shift_result = (int(dut.data_in.value) << int(dut.shift_bits.value)) & 0xFF\n    print((shift_result))\n    if (dut.data_out.value == shift_result):\n        print(\"Left shift process is successful\")\n    assert dut.data_out.value == shift_result, f\"Computed and DUT outputs of barrel shifter are not correct\"\n \n@cocotb.test()\nasync def test_barrel_2(dut):\n      \n    # Assert seed and wait\n    dut.data_in.value = int((1.0 - random.random()) * 2 ** 8);\n    dut.shift_bits.value = 0b111    \n    dut.left_right.value = 0b0;        \n    \n    await Timer(10, units = \"ns\")\n    print(\"data_in \",str(dut.data_in.value))\n    print(\"shift_bits \",str(dut.shift_bits.value))\n    print(\"left_right\",str(dut.left_right.value))\n    print(\"data_out \",str(dut.data_out.value))\n    shift_result = (int(dut.data_in.value) >> int(dut.shift_bits.value)) & 0xFF\n    print((shift_result))\n    if (dut.data_out.value == shift_result):\n        print(\"Right shift process is successful\");\n    assert dut.data_out.value == shift_result, f\"Computed and DUT outputs of barrel shifter are not correct\"\n \n\n@cocotb.test()\nasync def test_barrel_3(dut):\n      \n    # Assert seed and wait\n    dut.data_in.value = int((1.0 - random.random()) * 2 ** 8);\n    dut.shift_bits.value = 0b000\n    dut.left_right.value = 0b1;\n\n    await Timer(10, units = \"ns\")\n    print(\"data_in \",str(dut.data_in.value))\n    print(\"shift_bits \",str(dut.shift_bits.value))\n    print(\"left_right\",str(dut.left_right.value))\n    print(\"data_out \",str(dut.data_out.value))\n    shift_result = (int(dut.data_in.value) << int(dut.shift_bits.value)) & 0xFF\n    print((shift_result))\n    if (dut.data_out.value == shift_result):\n        print(\"Left shift process is successful\")\n    assert dut.data_out.value == shift_result, f\"Computed and DUT outputs of barrel shifter are not correct\"\n\n\n\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport re\nimport logging\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_bcd_counter_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design a System Verilog module named `bcd_counter` that implements a 24-hour clock using Binary-Coded Decimal (BCD) counters. The clock should display hours, minutes, and seconds in a 24-hour format (`00:00:00` to `23:59:59`) and reset automatically.\n\n## Design Specifications\n\n**Module Name**:  \n`bcd_counter`\n\n### Inputs:\n- `clk`: Clock input signal for synchronizing the counters.\n- `rst`: Active-high reset signal that resets all counters to `00:00:00` when asserted.\n\n### Outputs:\n- `ms_hr` (4-bit) \u2014 Most significant digit of the hour counter, representing the tens place.\n- `ls_hr` (4-bit) \u2014 Least significant digit of the hour counter, representing the units place.\n- `ms_min` (4-bit) \u2014 Most significant digit of the minute counter, representing the tens place.\n- `ls_min` (4-bit) \u2014 Least significant digit of the minute counter, representing the units place.\n- `ms_sec` (4-bit) \u2014 Most significant digit of the second counter, representing the tens place.\n- `ls_sec` (4-bit) \u2014 Least significant digit of the second counter, representing the units place.\n\n### Functional Requirements:\n1. The module operates as a 24-hour clock, displaying hours in a 24-hour format from `00:00:00` to `23:59:59`.\n2. When `rst` is high, all outputs (`ms_hr`, `ls_hr`, `ms_min`, `ls_min`, `ms_sec`, `ls_sec`) reset to `0`.\n3. On each positive edge of `clk`, increment the seconds counter:\n   - Increment `ls_sec` until it reaches 9. On reaching 9, reset `ls_sec` to `0` and increment `ms_sec`.\n   - Increment `ms_sec` until it reaches 5. When `ms_sec` reaches 5 and `ls_sec` reaches 9, reset both to `0` and increment `ls_min`.\n4. Apply similar logic for `ms_min`, `ls_min`, `ms_hr`, and `ls_hr`, ensuring each counter resets appropriately at its upper limit for hours, minutes, or seconds.\n5. The hour counter resets to `00:00:00` after reaching `23:59:59`.\n\n### Edge Cases:\n- Ensure the counter resets exactly at 24 hours (`23:59:59` to `00:00:00`) to simulate a 24-hour clock format.\n", "context": {}}, "output": {"response": "", "context": {"rtl/bcd_counter.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v ", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/bcd_counter.sv\nTOPLEVEL        = bcd_counter\nMODULE          = test_bcd_counter\nPYTHONPATH      = /src\nHASH            = bdce2f281c00b2cbdd50f99dab1e9f0a5f1574c7", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 2, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_bcd_counter.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb  \n\n@cocotb.test()\nasync def test_bcd_counter(dut):\n    \"\"\"\n    Test the BCD counter simulating a 24-hour clock with a 1 Hz frequency.\n    Ensures that the counter correctly handles the transition through midnight.\n    \"\"\"\n\n    # Start a 1 Hz clock with a 1 second period (1,000,000,000 nanoseconds)\n    clock = Clock(dut.clk, 1_000_000_000, units='ns')\n    cocotb.start_soon(clock.start())\n\n    # Apply reset using a custom function from the harness library\n    # Reset is active low and lasts for 500,000,000 ns (500 seconds)\n    await hrs_lb.reset_dut(dut.rst, duration_ns=500000000, active=False)\n\n    # Wait for the first rising edge of the clock after reset\n    await RisingEdge(dut.clk)\n\n    # Function to simulate the passage of time based on hours, minutes, and seconds\n    async def pass_time(hours, minutes, seconds):\n        total_seconds = hours * 3600 + minutes * 60 + seconds\n        # Advance the clock by one rising edge per second for the total number of seconds\n        for _ in range(total_seconds):\n            await RisingEdge(dut.clk)\n\n    # Simulate the time until one second before midnight\n    await pass_time(23, 59, 59)\n\n    # Await the rising edge that represents the passing of the final second of the day\n    await RisingEdge(dut.clk)\n\n    # Output the state of the clock at midnight (expected to be reset to 00:00:00)\n    print(f\"Midnight transition: Hours = {dut.ms_hr.value}{dut.ls_hr.value}, \" + \\\n          f\"Minutes = {dut.ms_min.value}{dut.ls_min.value}, Seconds = {dut.ms_sec.value}{dut.ls_sec.value}\")\n\n    # Verify that the counter has reset to 00:00:00\n    assert int(dut.ms_hr) == 0 and int(dut.ls_hr) == 0, \"24-hour reset failed\"\n    assert int(dut.ms_min) == 0 and int(dut.ls_min) == 0, \"24-hour reset failed\"\n    assert int(dut.ms_sec) == 0 and int(dut.ls_sec) == 0, \"24-hour reset failed\"\n\n    # Pass some more time to ensure stability and correctness after the midnight reset\n    await pass_time(10, 10, 10)  # Simulate additional time after midnight\n\n    # Print the new time after additional 10 hours, 10 minutes, and 10 seconds\n    print(f\"Post-midnight check: Hours = {dut.ms_hr.value}{dut.ls_hr.value}, \" + \\\n          f\"Minutes = {dut.ms_min.value}{dut.ls_min.value}, Seconds = {dut.ms_sec.value}{dut.ls_sec.value}\")\n\n    # Assert the correctness of time after 10 hours, 10 minutes, and 10 seconds\n    assert int(dut.ms_hr) == 1 and int(dut.ls_hr) == 0, \"Counter incorrect for hours after reset\"\n    assert int(dut.ms_min) == 1 and int(dut.ls_min) == 0, \"Counter incorrect for minutes after reset\"\n    assert int(dut.ms_sec) == 1 and int(dut.ls_sec) == 0, \"Counter incorrect for seconds after reset\"\n\n\n\n\n\n\n\n\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(plusargs=[], parameter={}):\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs)\n\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_areg_param(test):\n        runner()"}}}
{"id": "cvdp_copilot_bcd_to_excess_3_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design a **BCD to Excess-3 Code Converter** that translates a 4-bit Binary-Coded Decimal (BCD) input into a corresponding 4-bit Excess-3 output code. The module should identify invalid BCD inputs and assert an error flag when they occur. The converter must operate combinationally, updating the output immediately upon any change in the input.\n\n## Design Specification\n\n**Module Name**:  \n`bcd_to_excess_3`\n\n### Key Considerations\n- The converter accepts a 4-bit BCD input and provides a 4-bit Excess-3 output.\n- When the BCD input is invalid (values outside `0` to `9`), the module should set the output to `0` and assert an `error` flag.\n- The conversion and error-checking operations are combinational and do not depend on a clock signal.\n  \n### Interface\n\n**Inputs:**\n- `bcd` (4 bits, `[3:0]`): 4-bit BCD input, representing a decimal digit from `0` to `9`.\n\n**Outputs:**\n- `excess3` (4 bits, `[3:0]`): 4-bit Excess-3 output code, representing the decimal value of `BCD + 3`.\n- `error` (1 bit): A flag that is asserted (`1`) when the `bcd` input is outside the valid range (`10` to `15`), indicating an invalid input.\n\n### Functional Description\n\n- The module converts a 4-bit BCD input to an Excess-3 output by adding `3` to the decimal value represented by the BCD input. \n- For invalid BCD values (`10` to `15`), the output `excess3` should default to `0`, and the `error` flag should be set to `1` to indicate invalid input.\n\n### Edge Cases\n\n- **Invalid Input**: If the `bcd` input is any binary value representing `10` to `15`, the module should set `excess3` to `0` and assert `error`.\n- **Valid Range Handling**: For BCD inputs within the valid range (`0` to `9`), the `error` flag should be cleared (`0`), and `excess3` should provide the correct Excess-3 code.", "context": {}}, "output": {"response": "", "context": {"rtl/bcd_to_excess_3.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v ", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/bcd_to_excess_3.sv\nTOPLEVEL        = bcd_to_excess_3\nMODULE          = test_bcd_to_excess_3\nPYTHONPATH      = /src\nHASH            = 459b72bbc0aa0c41acc5d3dbf73aca69e48fb713", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_bcd_to_excess_3.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\n@cocotb.test()\nasync def bcd_to_excess_3(dut):\n    \"\"\" Test BCD to Excess-3 conversion including error flag assertions. \"\"\"\n   \n    # Initialize the DUT signals (e.g., reset all values to default 0)\n    await hrs_lb.dut_init(dut)\n   \n    # Define expected outputs for valid BCD inputs\n    expected_excess3 = {\n        0: 3,  1: 4,  2: 5,  3: 6,\n        4: 7,  5: 8,  6: 9,  7: 10,\n        8: 11, 9: 12\n    }\n   \n    # Test the BCD to Excess-3 conversion for valid inputs\n    for bcd_value in range(10):  # Loop from 0 to 9\n        dut.bcd.value = bcd_value  # Apply BCD value\n        await Timer(10, units='ns')  # Wait for 10 ns\n        expected_value = expected_excess3[bcd_value]\n        assert dut.excess3.value == expected_value, f\"Error: BCD {bcd_value} should convert to {expected_value}, got {dut.excess3.value}\"\n        assert dut.error.value == 0, f\"Error flag should be 0 for valid input {bcd_value}\"\n        print(f\"Performing bcd to excess_3 operation: bcd = {bcd_value}, excess3 = {dut.excess3.value}\")\n\n    # Test invalid BCD inputs\n    for bcd_value in range(10, 12):  # Loop from 10 to 11\n        dut.bcd.value = bcd_value  # Apply BCD value\n        await Timer(10, units='ns')  # Wait for 10 ns\n        assert dut.error.value == 1, f\"Error flag should be 1 for invalid input {bcd_value}\"\n        print(f\"Testing invalid input: bcd = {bcd_value}, error = {dut.error.value}\")\n\n    # Wait for a final 10 ns period before ending the test\n    await Timer(10, units='ns')\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(plusargs=[], parameter={}):\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs)\n\n\n@pytest.mark.parametrize(\"test\", range(2))\ndef test_areg_param(test):\n        runner()"}}}
{"id": "cvdp_copilot_binary_to_one_hot_decoder_0001", "categories": ["cid003", "easy"], "input": {"prompt": "## Problem Description\nDesign a parameterized binary to one-hot decoder module named `binary_to_one_hot_decoder` in Verilog that converts a binary-encoded input signal into a one-hot encoded output signal. This module will use two parameters, `BINARY_WIDTH` and `OUTPUT_WIDTH`, to configure the width of the binary input and the one-hot encoded output, respectively.\n\n## Module Parameters\n1. **`BINARY_WIDTH`**: Specifies the bit width of the binary input `binary_in`. This parameter determines the maximum binary value that can be decoded. Default `BINARY_WIDTH=5`.\n2. **`OUTPUT_WIDTH`**: Defines the width of the output `one_hot_out`, which should have `2<sup>BINARY_WIDTH</sup>` bits if fully utilized. However, `OUTPUT_WIDTH` can be set independently to limit the number of one-hot output bits.`OUTPUT_WIDTH=32`\n\n## Inputs and Outputs\n- **Input**: `binary_in` (`BINARY_WIDTH` bits) \u2014 Binary input signal.\n  - Represents a binary-encoded value up to `2<sup>BINARY_WIDTH</sup> - 1`.\n  - Example: For `BINARY_WIDTH = 5`, `binary_in` can range from `5'd0` to `5'd31`.\n\n- **Output**: `one_hot_out` (`OUTPUT_WIDTH` bits) \u2014 One-hot encoded output signal.\n  - A one-hot encoded output where only the bit at index `binary_in` is set to `1`, with all other bits set to `0`.\n  - Example: If `binary_in = 5'd3` and `OUTPUT_WIDTH = 32`, `one_hot_out` should output `00000000000000000000000000001000`.\n\n## Behavioral Definition\n- This is achieved using a combinational logic\n  \n- **Example**: With `binary_in = 3'd2` and `OUTPUT_WIDTH = 8`, the output `one_hot_out` should be `00000100`.\n\n## Constraints and Edge Cases\n1. **Parameter Constraints**: Ensure that `BINARY_WIDTH` and `OUTPUT_WIDTH` are set such that `OUTPUT_WIDTH` is large enough to represent all values up to `2<sup>BINARY_WIDTH</sup> - 1`.\n2. **Out-of-Range Handling**: If `binary_in` is greater than or equal to `OUTPUT_WIDTH`, the module should output `0` for `one_hot_out`\n\n## Timing and Synchronization\n- This is a purely combinational module without a clock or reset.\n\n## Test Cases\n1. **Basic Decoding**: For each binary input, verify that only the corresponding bit in `one_hot_out` is high.\n2. **Boundary Conditions**: Test minimum (`binary_in = 0`) and maximum values (`binary_in = 2<sup>BINARY_WIDTH</sup> - 1`).\n3. **Out-of-Range Handling**: Confirm that if `binary_in` exceeds the range of `OUTPUT_WIDTH`, `one_hot_out` outputs `0` (if specified).", "context": {}}, "output": {"response": "", "context": {"rtl/binary_to_one_hot_decoder.v": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/binary_to_one_hot_decoder.v\nTOPLEVEL        = binary_to_one_hot_decoder\nMODULE          = test_binary_to_one_hot_decoder\nPYTHONPATH      = /src\nHASH            = 1-implement-a-parameterized-binary-to-one-hot-decoder", "src/test_binary_to_one_hot_decoder.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\n\n\n@cocotb.test()\nasync def test_binary_to_one_hot_decoder(dut):  # dut will be the object for RTL top.\n   \n\n    dut.binary_in.value = 0\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==1, f\"output should not be {dut.one_hot_out.value}\"\n    \n    dut.binary_in.value = 1\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==2, f\"output should not be {dut.one_hot_out.value}\"\n\n    dut.binary_in.value = 2\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==4, f\"output should not be {dut.one_hot_out.value}\"\n\n    dut.binary_in.value = 3\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==8, f\"output should not be {dut.one_hot_out.value}\"\n\n    dut.binary_in.value = 4\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==16, f\"output should not be {dut.one_hot_out.value}\"\n\n    dut.binary_in.value = 5\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==32, f\"output should not be {dut.one_hot_out.value}\"\n\n    dut.binary_in.value = 6\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==64, f\"output should not be {dut.one_hot_out.value}\"\n\n    dut.binary_in.value = 7\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==128, f\"output should not be {dut.one_hot_out.value}\"\n\n    dut.binary_in.value = 8\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==256, f\"output should not be {dut.one_hot_out.value}\"\n\n    dut.binary_in.value = 9\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==512, f\"output should not be {dut.one_hot_out.value}\"\n\n    dut.binary_in.value = 10\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==1024, f\"output should not be {dut.one_hot_out.value}\"\n    \n    dut.binary_in.value = 11\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==2048, f\"output should not be {dut.one_hot_out.value}\"\n\n    dut.binary_in.value = 12\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==4096, f\"output should not be {dut.one_hot_out.value}\"\n\n    dut.binary_in.value = 13\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==8192, f\"output should not be {dut.one_hot_out.value}\"\n\n    dut.binary_in.value = 14\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==16384, f\"output should not be {dut.one_hot_out.value}\"\n\n    dut.binary_in.value = 15\n    await Timer(100, units='ps')\n    assert dut.one_hot_out.value==32768, f\"output should not be {dut.one_hot_out.value}\"\n\n\n\n\n\n    \n    ", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_caesar_cipher_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design the System Verilog module `caesar_cipher` to implement a Caesar cipher for character encryption. The module should take an 8-bit ASCII character as input and produce a new character based on a 4-bit key value. The module should handle both uppercase (A-Z) and lowercase (a-z) letters while leaving non-alphabetic characters unchanged.\n\n### Interface\n\n#### Inputs:\n\n- **input_char ([7:0], 8-bit)**: The ASCII character to be shifted. It should be within the range of standard ASCII values.\n- **key ([3:0], 4-bit)**: The shift key. A 4-bit value (0-15) determines the shift applied to alphabetic characters.\n\n#### Output:\n\n- **output_char ([7:0], 8-bit)**: The resulting ASCII character after applying the Caesar cipher shift, respecting character casing. Non-alphabetic characters remain unchanged.\n\n## Design Specification:\n\n- **Uppercase Letters**: If the input is an uppercase letter ('A'-'Z'), the character should be modified within the uppercase range.\n- **Lowercase Letters**: If the input is a lowercase letter ('a'-'z'), the character should be modified within the lowercase range.\n- **Non-alphabetic Characters**: Characters that are not within 'A'-'Z' or 'a'-'z' should remain unchanged in the output.\n- **Modulo Operation**: The shifting must wrap around within the alphabet using modulo 26, ensuring characters like 'Z' roll back to 'A' and 'z' to 'a' when shifted.\n- Design should follow combinational logic\n\n### Simplified Algorithm:\n\n1. **Check** if `input_char` is an uppercase letter (A-Z):\n   - Shift the character by `key` positions within the range A-Z.\n2. **Check** if `input_char` is a lowercase letter (a-z):\n   - Shift the character by `key` positions within the range a-z.\n3. **If not alphabetic**, leave `input_char` unchanged.\n\n### Example Computations:\n\n#### Example 1:\n\nAssume `input_char` = 'h' (`01101000`) and `key` = 3 (`0011`).\n\n1. **Lowercase Handling**:\n   - Calculate the shifted position: ((`h` - 'a' + 3) % 26) + 'a'\n   - Result: `k` (`01101011`).\n2. **Final Output**:\n   - The final shifted character for `input_char` 'h' with `key` 3 is 'k'.\n   \n#### Example 2:\n\nAssume `input_char` = 'y' (`01111001`) and `key` = 8 (`1000`).\n\n1. **Lowercase Handling**:\n   - Calculate the shifted position: ((`y` - 'a' + 8) % 26) + 'a'\n   - Result: `g` (`01100111`).\n2. **Final Output**:\n   - The final shifted character for `input_char` 'y' with `key` 8 is 'g'.", "context": {}}, "output": {"response": "", "context": {"rtl/caesar_cipher.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/caesar_cipher.sv\nTOPLEVEL        = caesar_cipher\nMODULE          = test_caesar_cipher\nPYTHONPATH      = /src\nHASH            = 1-design-rtl-for-caesar-cipher-character-shifter-using-shift-key", "src/test_caesar_cipher.py": "import cocotb\nfrom cocotb.triggers import Timer\nimport random\nimport string\n\n# Helper function to compute expected Caesar cipher result\ndef caesar_shift(text, shift):\n    result = \"\"\n    for char in text:\n        if 'A' <= char <= 'Z':\n            result += chr(((ord(char) - ord('A') + shift) % 26) + ord('A'))\n        elif 'a' <= char <= 'z':\n            result += chr(((ord(char) - ord('a') + shift) % 26) + ord('a'))\n        else:\n            result += char  # Non-alphabetic characters remain unchanged\n    return result\n\n@cocotb.test()\nasync def test_predefined_cases(dut):\n    \"\"\"Test caesar_cipher with predefined cases\"\"\"\n    # Verify that all signals are available in the DUT\n    assert hasattr(dut, \"key\"), \"DUT does not have a 'key' input.\"\n    assert hasattr(dut, \"input_char\"), \"DUT does not have an 'input_char' input.\"\n    assert hasattr(dut, \"output_char\"), \"DUT does not have an 'output_char' output.\"\n\n    predefined_cases = [\n        {\"text\": \"hello\", \"key\": 3, \"expected\": caesar_shift(\"hello\", 3)},\n        {\"text\": \"WORLD\", \"key\": 4, \"expected\": caesar_shift(\"WORLD\", 4)},\n        {\"text\": \"Caesar\", \"key\": 5, \"expected\": caesar_shift(\"Caesar\", 5)},\n        {\"text\": \"Python3!\", \"key\": 2, \"expected\": caesar_shift(\"Python3!\", 2)},\n        {\"text\": \"EdgeCaseZ\", \"key\": 1, \"expected\": caesar_shift(\"EdgeCaseZ\", 1)},\n    ]\n\n    for case in predefined_cases:\n        text = case[\"text\"]\n        key = case[\"key\"]\n        expected = case[\"expected\"]\n\n        dut._log.info(f\"Testing Caesar cipher with input '{text}', key = {key}\")\n        dut.key.value = key  # Assign key to DUT port\n\n        output = \"\"\n        for char in text:\n            dut.input_char.value = ord(char)  # Send each character as ASCII value\n            await Timer(1, units=\"ns\")\n            output += chr(dut.output_char.value.to_unsigned())  # Collect each output char\n\n        assert output == expected, f\"Failed for input '{text}' with key {key}: expected '{expected}', got '{output}'\"\n        dut._log.info(f\"Passed for input '{text}' with key {key}: output '{output}'\")\n\n@cocotb.test()\nasync def test_boundary_conditions(dut):\n    \"\"\"Test caesar_cipher with boundary conditions\"\"\"\n    assert hasattr(dut, \"key\"), \"DUT does not have a 'key' input.\"\n    assert hasattr(dut, \"input_char\"), \"DUT does not have an 'input_char' input.\"\n    assert hasattr(dut, \"output_char\"), \"DUT does not have an 'output_char' output.\"\n\n    boundary_cases = [\n        {\"text\": \"Z\", \"key\": 1, \"expected\": caesar_shift(\"Z\", 1)},   # Wrap-around Z to A\n        {\"text\": \"z\", \"key\": 1, \"expected\": caesar_shift(\"z\", 1)},   # Wrap-around z to a\n        {\"text\": \"A\", \"key\": 15, \"expected\": caesar_shift(\"A\", 15)}, # Adjusted key within range\n        {\"text\": \"a\", \"key\": 15, \"expected\": caesar_shift(\"a\", 15)}, # Adjusted key within range\n    ]\n\n    for case in boundary_cases:\n        text = case[\"text\"]\n        key = case[\"key\"]\n        expected = case[\"expected\"]\n\n        dut._log.info(f\"Testing boundary condition with input '{text}', key = {key}\")\n        dut.key.value = key\n\n        output = \"\"\n        for char in text:\n            dut.input_char.value = ord(char)\n            await Timer(1, units=\"ns\")\n            output += chr(dut.output_char.value.to_unsigned())\n\n        assert output == expected, f\"Failed for input '{text}' with key {key}: expected '{expected}', got '{output}'\"\n        dut._log.info(f\"Passed boundary condition test for input '{text}' with key {key}: output '{output}'\")\n\n\n@cocotb.test()\nasync def test_random_cases(dut):\n    \"\"\"Test caesar_cipher with random inputs and keys\"\"\"\n    assert hasattr(dut, \"key\"), \"DUT does not have a 'key' input.\"\n    assert hasattr(dut, \"input_char\"), \"DUT does not have an 'input_char' input.\"\n    assert hasattr(dut, \"output_char\"), \"DUT does not have an 'output_char' output.\"\n\n    for _ in range(5):\n        random_text = ''.join(random.choice(string.ascii_letters) for _ in range(8))  # Random 8-letter text\n        random_key = random.randint(0, 15)  # Random key in the 4-bit range\n        expected = caesar_shift(random_text, random_key)\n\n        dut._log.info(f\"Testing random input '{random_text}', key = {random_key}\")\n        dut.key.value = random_key\n\n        output = \"\"\n        for char in random_text:\n            dut.input_char.value = ord(char)\n            await Timer(1, units=\"ns\")\n            output += chr(dut.output_char.value.to_unsigned())\n\n        assert output == expected, f\"Random test failed for input '{random_text}' with key {random_key}: expected '{expected}', got '{output}'\"\n        dut._log.info(f\"Random test passed for input '{random_text}' with key {random_key}: output '{output}'\")\n\n@cocotb.test()\nasync def test_with_numbers_and_symbols(dut):\n    \"\"\"Test caesar_cipher with numbers and symbols to ensure they remain unchanged\"\"\"\n    assert hasattr(dut, \"key\"), \"DUT does not have a 'key' input.\"\n    assert hasattr(dut, \"input_char\"), \"DUT does not have an 'input_char' input.\"\n    assert hasattr(dut, \"output_char\"), \"DUT does not have an 'output_char' output.\"\n\n    # Define a test case with numbers and symbols\n    text = \"Hello123!@#World\"\n    key = 3\n    expected = caesar_shift(text, key)  # Expected result with only alphabetic chars shifted\n\n    dut._log.info(f\"Testing Caesar cipher with input '{text}', key = {key} (includes numbers and symbols)\")\n    dut.key.value = key  # Assign key to DUT port\n\n    output = \"\"\n    for char in text:\n        dut.input_char.value = ord(char)  # Send each character as ASCII value\n        await Timer(1, units=\"ns\")\n        output += chr(dut.output_char.value.to_unsigned())  # Collect each output char\n\n    assert output == expected, f\"Failed for input '{text}' with key {key}: expected '{expected}', got '{output}'\"\n    dut._log.info(f\"Passed for input '{text}' with key {key}: output '{output}'\")\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport re\nimport logging\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_car_parking_management_0001", "categories": ["cid003", "medium"], "input": {"prompt": "# Car Parking Management System\n\nDesign a **Car Parking Management System** that efficiently manages vehicle entry and exit, tracks parking space availability, and displays the current status using LEDs and 7-segment displays. The system uses an FSM to handle state transitions for parking operations, ensuring robust and synchronized functionality.\n\n## Design Specification\n\n### **Module Name:**  \n`car_parking_system`\n\n## Key Considerations:\n- The system manages the entry and exit of vehicles in a controlled manner.\n- Dynamically tracks the number of available parking spaces.\n- Tracks the total number of cars present in the parking lot.\n- Displays parking availability using:\n  - **LED Indicators**: Indicate whether parking is full or available.\n  - **7-Segment Displays**: Show the number of remaining spaces and the number of cars currently parked in real time.\n  - **System is designed to support and display a 2-digit number** for total spaces (up to 99) on the 7-segment display.\n  - **Segment Mapping**: The 7-segment display uses a binary format where the most significant bit (MSB) represents segment A, and the least significant bit (LSB) represents segment G.\n\n## **Parameters**\n- `TOTAL_SPACES` *(Default = 12)*: Specifies the total number of parking spaces available.\n\n## **Inputs:**\n- `clk`: Clock signal driving the FSM transitions, operating at a 50:50 duty cycle. clk operating frequency is 100Mhz (10ns)\n- `reset`: Active-high asynchronous reset signal to initialize or reset the system.\n- `vehicle_entry_sensor`: Active-high input signal indicating a vehicle attempting to enter the parking lot.\n- `vehicle_exit_sensor`: Active-high input signal indicating a vehicle exiting the parking lot.\n\n## **Outputs:**\n- `available_spaces` *(log2(TOTAL_SPACES)-bits, [log2(TOTAL_SPACES)-1:0])*: Indicates the number of available parking spaces.\n- `count_car` *(log2(TOTAL_SPACES)-bits, [log2(TOTAL_SPACES)-1:0])*: Indicates the number of cars in the parking lot.\n- `led_status`: LED indicator where `1` indicates parking availability, and `0` indicates parking is full.\n- `seven_seg_display_available_tens`[6:0]: Encodes the number of available spaces for the tens digit of display on a 7-segment module.\n- `seven_seg_display_available_units`[6:0]: Encodes the number of available spaces for the units digit of display on a 7-segment module.\n- `seven_seg_display_count_tens`[6:0]: Encodes the number of cars present for the tens of display on a 7-segment module.\n- `seven_seg_display_count_units`[6:0]: Encodes the number of cars present for the units of display on a 7-segment module.\n\n## **FSM States:**\n1. **`Idle`**: No vehicles are detected; the system waits for a sensor trigger.\n2. **`Entry Processing`**: A vehicle is entering; decrement the available space count and increment the car count.\n3. **`Exit Processing`**: A vehicle is exiting; increment the available space count and decrement the car count.\n4. **`Full`**: Parking is full; entry is denied.\n\n## **Edge Cases:**\n1. **Reset Condition**: When `reset` is asserted, the system resets to its initial state where all spaces are available, and no cars are present.\n2. **Parking Full**: When all spaces are occupied, the system denies entry to vehicles and lights the \"full\" indicator.\n\n## Example Operation:\n\n\n| Clock Cycles | Reset | vehicle_entry_sensor | vehicle_exit_sensor | available_spaces | count_car | led_status | seven_seg_display_available_tens | seven_seg_display_available_units | seven_seg_display_count_tens | seven_seg_display_count_units |  \n|--------------|-------|----------------------|---------------------|------------------|-----------|------------|----------------------------------|-----------------------------------|-----------------------------|------------------------------|  \n| 1            | 1\u2019b0  | 1'b0                | 1'b0               | 12               | 0         | 1          | `1`                              | `2`                              | `0`                         | `0`                          |  \n| 2            | 1\u2019b0  | 1'b1                | 1'b0               | 11               | 1         | 1          | `1`                              | `1`                              | `0`                         | `1`                          |  \n| 3            | 1\u2019b0  | 1'b0                | 1'b1               | 12               | 0         | 1          | `1`                              | `2`                              | `0`                         | `0`                          |  \n| 4            | 1\u2019b0  | 1'b1                | 1'b0               | 0                | 12        | 0          | `0`                              | `0`                              | `1`                         | `2`                          |  \n", "context": {}}, "output": {"response": "", "context": {"rtl/car_parking_system.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest --log-cli-level=INFO -o cache_dir=/code/rundir/.cache -sv /src/test_runner.py\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nWAVE            = 1\nVERILOG_SOURCES = /code/rtl/car_parking_system.sv\nTOPLEVEL        = car_parking_system\nMODULE          = car_parking_control\nPYTHONPATH      = /src\nHASH            = 1-rtl-implementation-for-car-parking", "src/car_parking_control.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer, FallingEdge\n\n\nTOTAL_SPACES = int(cocotb.plusargs.get(\"TOTAL_SPACES\", 12))\n\n# Helper function to reset DUT\nasync def reset_dut(dut, duration_ns=20):\n    \"\"\"Reset DUT\"\"\"\n    dut.reset.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\n# Helper function to trigger vehicle entry\nasync def trigger_entry(dut):\n    \"\"\"Simulate vehicle entry\"\"\"\n    dut.vehicle_entry_sensor.value = 1\n    #await RisingEdge(dut.clk)\n    await Timer(10, units=\"ns\")\n    dut.vehicle_entry_sensor.value = 0\n\n# Helper function to trigger vehicle exit\nasync def trigger_exit(dut):\n    \"\"\"Simulate vehicle exit\"\"\"\n    dut.vehicle_exit_sensor.value = 1\n    await Timer(10, units=\"ns\")\n    #await RisingEdge(dut.clk)\n    dut.vehicle_exit_sensor.value = 0\n\ndef seven_segment_encoding(digit):\n    \"\"\"Returns the seven-segment encoding for a given digit (0-9)\"\"\"\n    encoding_map = {\n        0: 0b1111110,\n        1: 0b0110000,\n        2: 0b1101101,\n        3: 0b1111001,\n        4: 0b0110011,\n        5: 0b1011011,\n        6: 0b1011111,\n        7: 0b1110000,\n        8: 0b1111111,\n        9: 0b1111011,\n    }\n    return encoding_map.get(digit, 0b0000000)  # Default to blank display\n\nasync def validate_seven_segment(dut, available_spaces, count_car):\n    \"\"\"\n    Validate seven-segment display outputs for available spaces and count car.\n    \"\"\"\n    # Calculate tens and units for available spaces\n    available_tens = available_spaces // 10\n    available_units = available_spaces % 10\n\n    # Calculate tens and units for count car\n    count_tens = count_car // 10\n    count_units = count_car % 10\n\n    # Validate seven-segment display for available spaces\n    assert int(dut.seven_seg_display_available_tens.value) == seven_segment_encoding(available_tens), \\\n        f\"Available Spaces Tens Mismatch: Expected {bin(seven_segment_encoding(available_tens))}, Got {bin(int(dut.seven_seg_display_available_tens.value))}\"\n    assert int(dut.seven_seg_display_available_units.value) == seven_segment_encoding(available_units), \\\n        f\"Available Spaces Units Mismatch: Expected {bin(seven_segment_encoding(available_units))}, Got {bin(int(dut.seven_seg_display_available_units.value))}\"\n\n    # Validate seven-segment display for count car\n    assert int(dut.seven_seg_display_count_tens.value) == seven_segment_encoding(count_tens), \\\n        f\"Count Car Tens Mismatch: Expected {bin(seven_segment_encoding(count_tens))}, Got {bin(int(dut.seven_seg_display_count_tens.value))}\"\n    assert int(dut.seven_seg_display_count_units.value) == seven_segment_encoding(count_units), \\\n        f\"Count Car Units Mismatch: Expected {bin(seven_segment_encoding(count_units))}, Got {bin(int(dut.seven_seg_display_count_units.value))}\"\n\n    dut._log.info(\"Seven-segment display validated successfully\")\n\n# Test case 1: Basic entry\nasync def test_case_1(dut):\n    \"\"\"Test case 1: Single vehicle entry\"\"\"\n\n    dut._log.info(\"Simulating single vehicle entry\")\n    await trigger_entry(dut)\n\n    # Wait for state to update\n    await Timer(30, units=\"ns\")\n    assert dut.count_car.value == 1, \"Count car did not increment as expected\"\n    assert dut.available_spaces.value == (TOTAL_SPACES - 1), \"Available spaces did not decrement as expected\"\n\n    # Validate seven-segment display\n    await validate_seven_segment(dut, available_spaces=(TOTAL_SPACES - 1), count_car=1)\n\n    #print(hex(int(dut.seven_seg_display_available_tens.value)))\n    # Check seven-segment display\n    #check_seven_segment(dut, available_spaces=(TOTAL_SPACES - 1), count_car=1)\n\n# Test case 2: Basic exit\nasync def test_case_2(dut):\n    \"\"\"Test case 2: Single vehicle exit\"\"\"\n\n    dut._log.info(\"Simulating single vehicle exit\")\n    await trigger_exit(dut)\n\n    # Wait for state to update\n    await Timer(20, units=\"ns\")\n    assert dut.count_car.value == 0, \"Count car did not decrement as expected\"\n    assert dut.available_spaces.value == TOTAL_SPACES, \"Available spaces did not increment as expected\"\n\n    # Validate seven-segment display\n    await validate_seven_segment(dut, available_spaces=TOTAL_SPACES, count_car=0)\n\n\n# Test case 3: Parking full\nasync def test_case_3(dut):\n    \"\"\"Test case 3: Simulate parking full\"\"\"\n\n    dut._log.info(\"Simulating parking full scenario\")\n    for _ in range(TOTAL_SPACES):\n        await trigger_entry(dut)\n        await Timer(20, units=\"ns\")\n        \n    # Wait for state to update\n    assert dut.led_status.value == 0, \"LED status did not indicate parking full\"\n    assert dut.available_spaces.value == 0, \"Available spaces did not reach 0\"\n    assert dut.count_car.value == TOTAL_SPACES, \"Car count did not reach total spaces\"\n\n    # Attempt another entry\n    await trigger_entry(dut)\n    await Timer(20, units=\"ns\")\n    assert dut.count_car.value == TOTAL_SPACES, \"Car count should not exceed total spaces\"\n\n    # Validate seven-segment display\n    await validate_seven_segment(dut, available_spaces=0, count_car=TOTAL_SPACES)\n\n# Test case 4: Reset operation\nasync def test_case_4(dut):\n    \"\"\"Test case 4: Reset during operation\"\"\"\n\n    dut._log.info(\"Simulating reset during operation\")\n    await trigger_entry(dut)\n    await Timer(20, units=\"ns\")\n    await reset_dut(dut)\n\n    # Validate reset state\n    assert dut.count_car.value == 0, \"Count car did not reset to 0\"\n    assert dut.available_spaces.value == TOTAL_SPACES, \"Available spaces did not reset to total\"\n\n@cocotb.test()\nasync def test_car_parking_system(dut):\n    \"\"\"Main test function for Car Parking System\"\"\"\n\n    # Start clock\n    clock = Clock(dut.clk, 10, units=\"ns\")  # 100 MHz clock\n    cocotb.start_soon(clock.start())\n\n    # Initialize signals\n    dut.reset.value = 1\n    dut.vehicle_exit_sensor.value = 0\n    dut.vehicle_entry_sensor.value = 0\n\n    # Apply reset\n    await reset_dut(dut, duration_ns=30)\n    await Timer(40, units=\"ns\")\n    await reset_dut(dut, duration_ns=30)\n    await Timer(40, units=\"ns\")\n\n    await FallingEdge(dut.clk)\n    \n\n    # Run test cases\n    await test_case_1(dut)\n    await Timer(10, units=\"ns\")\n    await test_case_2(dut)\n    await Timer(10, units=\"ns\")\n    await test_case_3(dut)\n    await Timer(10, units=\"ns\")\n    await test_case_4(dut)\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\nimport re\nimport logging\n\n# List from Files\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n# Language of Top Level File\ntoplevel_lang = os.getenv(\"TOPLEVEL_LANG\")\nsim = os.getenv(\"SIM\", \"icarus\")\ntoplevel = os.getenv(\"TOPLEVEL\")\nmodule = os.getenv(\"MODULE\")\n\ndef test_runner(TOTAL_SPACES: int = 9):\n    \"\"\"\n    Test Runner for Car Parking System\n    \"\"\"\n\n    # Parameterize the test\n    parameter_defines = {\n        \"TOTAL_SPACES\": TOTAL_SPACES,\n    }\n    print(f\"Running simulation with TOTAL_SPACES={TOTAL_SPACES}\")\n    \n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameter_defines,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n        defines={\"SIMULATION\": None}\n    )\n\n    plusargs = [f\"+TOTAL_SPACES={TOTAL_SPACES}\"]\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True, plusargs=plusargs)\n\n@pytest.mark.parametrize(\"TOTAL_SPACES\", [14, 12, 9])\ndef test_car_parking_system(TOTAL_SPACES):\n    \"\"\"Parameterized test for Car Parking System\"\"\"\n\n    print(f\"Test Runner: TOTAL_SPACES={TOTAL_SPACES}\")\n    test_runner(TOTAL_SPACES=TOTAL_SPACES)\n"}}}
{"id": "cvdp_copilot_cascaded_adder_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Develop a System Verilog module that implements a cascaded adder. This module named `cascaded_adder` performs the summation of multiple input data elements, synchronized to the clock, and supports asynchronous reset functionality. The input data is received as a flattened 1D vector, and the output provides the cumulative sum of all the input elements.\n\n## Parameters:\n - **`IN_DATA_WIDTH` (default = 16):** Specifies the bit-width of each individual input data element.\n - **`IN_DATA_NS` (default = 4):** Defines the number of input data elements to be summed.\n\n## Input Ports:\n- `clk`: Clock signal. The design registers are triggered on its positive edge.\n- `rst_n`: An active-low asynchronous reset signal. When low, the module is held in a reset state, and both `o_valid` and `o_data` are driven low.\n- `i_valid`: An active-high input signal that indicates the availability of valid data for processing. It is assumed to be synchronous to the positive edge of `clk` signal.\n- `i_data` [`IN_DATA_WIDTH` * `IN_DATA_NS` - 1 : 0]: Input data provided as a flattened 1D vector. This vector contains `IN_DATA_NS` elements, each `IN_DATA_WIDTH` bits wide. It is assumed to be synchronous to the positive edge of `clk` signal.\n\n## Output Ports:\n- `o_valid`: Active-high signal indicating that the output sum has been computed and is ready to be read. It is driven on the rising edge of the `clk`\n- `o_data` [(`IN_DATA_WIDTH` + $clog2(`IN_DATA_NS`)) - 1 : 0]: Output data representing the cumulative sum of all input elements. The output width is designed to accommodate the full sum **without overflow**. It is driven on the rising edge of the `clk`\n\n## Functional Description:\n\n### Input Data Structure:\n- The input data is a flattened 1D vector `i_data` with a total width of `IN_DATA_WIDTH` * `IN_DATA_NS`. \n- For instance, with `IN_DATA_NS` = 4 and `IN_DATA_WIDTH` = 16, the 64-bit wide `i_data` contains four 16-bit elements.\n- The input data is latched when i_valid is asserted, synchronized to the positive edge of the clock.\n\n### Cascaded Addition Process:\n- The summation is performed on the registered data in a cascaded manner using combinational logic, where each element is progressively added in sequence to the accumulated total.\n- Each stage adds the next element in the sequence to the cumulative result of the previous stages, ultimately producing the final sum.\n- The design includes an output register that latches the cumulative result at the positive edge of the clock.\n\n---\n```mermaid\ngraph LR;\n    A1((0)) --> B1(('+'))\n    A2((1)) --> B1\n    B1 --> B2(('+'))\n    A3((2)) --> B2\n    B2 --> B3\n    A4((3)) --> B3(('+'))\n    B3 --> Result[Result]\n```\n----\n\n### Latency:\nThe module introduces a total latency of two clock cycles. One cycle is added for registering the input data, and another for registering the output sum.", "context": {}}, "output": {"response": "", "context": {"rtl/cascaded_adder.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\r\nWAVE            = True\r\nTOPLEVEL_LANG   = verilog\r\nVERILOG_SOURCES = /code/rtl/cascaded_adder.sv\r\nTOPLEVEL        = cascaded_adder\r\nMODULE          = test_cascaded_adder\r\nPYTHONPATH      = /src\r\nHASH            = 79caf4385f9cc9090fab54358c17f1ac53f16af7\r\n", "src/harness_library.py": "import cocotb\r\nfrom cocotb.triggers import  Timer, RisingEdge, FallingEdge, Edge, ReadOnly\r\nfrom cocotb.clock import Clock\r\nfrom enum import Enum\r\nimport random\r\n\r\n\r\nasync def dut_init(dut):\r\n    # iterate all the input signals and initialize with 0\r\n    for signal in dut:\r\n        if signal._type == \"GPI_NET\":\r\n            signal.value = 0\r\n\r\ndef random_stim_generator(IN_DATA_NS, IN_DATA_WIDTH, StimType):\r\n    golden_output = 0 \r\n    input_1d = 0 \r\n    for _ in range (IN_DATA_NS):\r\n        if StimType == \"RANDOM\":\r\n            random_value = random.randint(0, (1 << IN_DATA_WIDTH) - 1)\r\n        elif StimType == \"DIRECT_MAX\":\r\n            random_value = (1 << IN_DATA_WIDTH) - 1\r\n        elif StimType == \"DIRECT_MIN\":\r\n            random_value = 0    \r\n        golden_output = golden_output + random_value \r\n        input_1d = (input_1d << IN_DATA_WIDTH) | random_value\r\n    \r\n    return (input_1d, golden_output)", "src/test_cascaded_adder.py": "import cocotb\r\nfrom cocotb.triggers import  Timer, RisingEdge, ReadOnly, FallingEdge\r\nfrom cocotb.clock import Clock\r\nimport harness_library as util\r\nimport random\r\n\r\n@cocotb.test()\r\nasync def cascaded_adder(dut):\r\n    # Generate two random period clock signals\r\n    clock_period_ns = 10  # For example, 10ns clock period\r\n    cocotb.start_soon(Clock(dut.clk, clock_period_ns, units='ns').start())\r\n    dut._log.info(f\"DUT_CLK STARTED\")\r\n    await util.dut_init(dut)\r\n    # DUT RESET \r\n    dut.rst_n.value = 1\r\n    await Timer(5, units=\"ns\")\r\n\r\n    dut.rst_n.value = 0 \r\n    await ReadOnly()\r\n    # for async reset, right after reset assertion design should be held in reset\r\n    assert dut.o_valid.value == 0, f\"Valid output should be driven low\"\r\n    assert dut.o_data.value == 0 , f\"Output should be driven low\"  \r\n    await Timer(30, units=\"ns\")\r\n    dut.rst_n.value = 1\r\n    dut._log.info(f\"DUT IS OUT OF RESET\") \r\n    \r\n    IN_DATA_WIDTH = int(dut.IN_DATA_WIDTH.value)\r\n    IN_DATA_NS = int(dut.IN_DATA_NS.value)\r\n    \r\n    ## Direct test for overflow\r\n    for i in range(5):\r\n        stimulus= util.random_stim_generator(IN_DATA_NS, IN_DATA_WIDTH, \"DIRECT_MAX\")\r\n        input_data = stimulus[0]\r\n        golden_output = stimulus[1]\r\n        await RisingEdge(dut.clk)\r\n        dut.i_data.value = input_data\r\n        dut.i_valid.value = 1\r\n        await RisingEdge(dut.clk)\r\n        dut.i_valid.value = 0\r\n\r\n        latency = 0\r\n        while (dut.o_valid.value != 1):\r\n            await RisingEdge(dut.clk)\r\n            latency = latency + 1\r\n\r\n        assert latency == 2, f\"Valid output should have latency of 2 clk cycles\"\r\n        assert dut.o_data.value == golden_output , f\"Output doesn't match golden output: dut_output {hex(dut.o_data.value)}, Expected output {hex(golden_output)}\"  \r\n  \r\n\r\n    for i in range(50):\r\n        stimulus= util.random_stim_generator(IN_DATA_NS, IN_DATA_WIDTH, \"RANDOM\")\r\n        input_data = stimulus[0]\r\n        golden_output = stimulus[1]\r\n        await RisingEdge(dut.clk)\r\n        dut.i_data.value = input_data\r\n        dut.i_valid.value = 1 \r\n        await RisingEdge(dut.clk)\r\n        dut.i_valid.value = 0 \r\n        \r\n        latency = 0 \r\n        while (dut.o_valid.value != 1):\r\n            await RisingEdge(dut.clk)\r\n            latency = latency + 1\r\n       \r\n        assert latency == 2, f\"Valid output should have latency of 2 clk cycles\"\r\n        assert dut.o_data.value == golden_output , f\"Output doesn't match golden output: dut_output {hex(dut.o_data.value)}, Expected output {hex(golden_output)}\"  \r\n\r\n## Direct test for valid streaming \r\n    outputs_list = []        \r\n    for i in range(50):\r\n        # first two cycles only append\r\n        if i <2 :\r\n            stimulus= util.random_stim_generator(IN_DATA_NS, IN_DATA_WIDTH, \"RANDOM\")\r\n            input_data = stimulus[0]\r\n            golden_output = stimulus[1]\r\n            outputs_list.append(golden_output)\r\n            await RisingEdge(dut.clk)\r\n            await RisingEdge(dut.clk)\r\n            dut.i_data.value = input_data\r\n            dut.i_valid.value = 1  \r\n            assert dut.o_valid.value == 0, \"During initial 2 cycles, o_valid should be zero\"\r\n        else: # append and pop \r\n            stimulus= util.random_stim_generator(IN_DATA_NS, IN_DATA_WIDTH, \"RANDOM\")\r\n            input_data = stimulus[0]\r\n            golden_output = stimulus[1]\r\n            outputs_list.append(golden_output)\r\n            await RisingEdge(dut.clk)\r\n            await RisingEdge(dut.clk)\r\n            dut.i_data.value = input_data\r\n            dut.i_valid.value = 1\r\n            expected_result =  outputs_list.pop(0)\r\n            dut_output = int (dut.o_data.value)\r\n            \r\n            await ReadOnly()\r\n            assert dut.o_valid.value == 1, f\"Valid output should have latency of 2 clk cycles\"\r\n            assert dut_output == expected_result , f\"Output doesn't match golden output: dut_output {hex(dut_output)}, Expected output {hex(expected_result)}\"\r\n    await FallingEdge(dut.clk)\r\n    dut.rst_n.value = 0\r\n    await ReadOnly()\r\n    assert dut.o_valid.value == 0, \"During reset, o_valid should be zero\"\r\n    assert dut.o_data.value == 0, \"During reset, o_data should be zero\"\r\n    await RisingEdge(dut.clk)\r\n    await RisingEdge(dut.clk)\r\n", "src/test_runner.py": "import os\r\nfrom cocotb_tools.runner import get_runner\r\nimport random\r\nimport pytest\r\n\r\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\r\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\r\nsim             = os.getenv(\"SIM\", \"icarus\")\r\ntoplevel        = os.getenv(\"TOPLEVEL\")\r\nmodule          = os.getenv(\"MODULE\")\r\nwave            = bool(os.getenv(\"WAVE\"))\r\n\r\ndef runner(IN_DATA_NS, IN_DATA_WIDTH):\r\n    runner = get_runner(sim)\r\n    runner.build(\r\n        sources=verilog_sources,\r\n        hdl_toplevel=toplevel,\r\n        parameters= {'IN_DATA_NS': IN_DATA_NS , 'IN_DATA_WIDTH': IN_DATA_WIDTH },\r\n        always=True,\r\n        clean=True,\r\n        waves=wave,\r\n        verbose=False,\r\n        timescale=(\"1ns\", \"1ns\"),\r\n        log_file=\"sim.log\")\r\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\r\n\r\ntest_param = [(random.randint(1, 500), random.randint(1, 500)) for _ in range(5)]\r\n\r\n# random test\r\n@pytest.mark.parametrize(\"IN_DATA_NS ,IN_DATA_WIDTH\", test_param )\r\n\r\n# random test\r\ndef test_tree_adder(IN_DATA_NS, IN_DATA_WIDTH):\r\n    print(f'Running with: IN_DATA_NS = {IN_DATA_NS}, IN_DATA_WIDTH = {IN_DATA_WIDTH}')\r\n    runner(IN_DATA_NS, IN_DATA_WIDTH)"}}}
{"id": "cvdp_copilot_clock_divider_0003", "categories": ["cid003", "easy"], "input": {"prompt": "Could you please implement a clock divider RTL module using SystemVerilog that divides an input clock by a factor of 2,4 or 8? The module `clock_divider` should take an input clock (`clk`) and generate an output clock (`clk_out`) with a reduced frequency based on a selection input (`sel`).\n\n### Requirements:\n\n**Inputs:**\n- `clk`: The primary clock input that needs to be divided.  The module operates on the rising edge of this clock .\n- `rst_n`: An active-low asynchronous reset signal. \n- `[1:0] sel`: A 2-bit signal that determines the clock division factor, determining whether the input clock will be divided by 2, 4, or 8.\n\n**Output:**\n- `clk_out`: The divided clock signal output.\n\n### Functionality:\n1. **Clock Division:**\n- The output clock frequency should change based on the `sel` input:\n  - `sel = 2'b00`: Divide by 2.\n  - `sel = 2'b01`: Divide by 4.\n  - `sel = 2'b10`: Divide by 8.\n\n2. **Reset Behavior:**\n- When `rst_n` is asserted,`clk_out` should be zero.\n- After `rst_n` is de-asserted, the design will output the divided clock based on the `sel`.\n\n3. **Edge Cases**:\n- **Out-of-range `sel`**: If `sel` takes any value other than `2'b00`, `2'b01`, or `2'b10`, the output `clk_out` should be held at 0 until a valid `sel` is applied.\n\n4. **Assumptions on `sel`:**\n- The `sel` signal is expected to remain stable during normal operation. Assume that the `sel` value is always provided synchronized with reset (`rst_n`).", "context": {}}, "output": {"response": "", "context": {"rtl/clock_divider.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  3-:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v   \n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/clock_divider.sv \nTOPLEVEL        = clock_divider\nMODULE          = test_clk_div\nPYTHONPATH      = /src\nHASH            = 7cdb7353cf4de1daf3539465e9f2d2559bb1b32a\n", "src/harness_library.py": "from cocotb.triggers import RisingEdge\nfrom cocotb.sim_time_utils import get_sim_time\nimport random\n\n# Reset the DUT\nasync def reset_dut(dut):\n    dut.rst_n.value = 0\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    dut.rst_n.value = 1\n    await RisingEdge(dut.clk)\n    dut.rst_n._log.debug(\"Reset complete\")\n\n# Measure period of clk_out \nasync def measure_clk_period(clk_out, clock, expected_period):\n    # Wait for the first rising edge \n    await RisingEdge(clk_out)\n    start_time = get_sim_time('ns')\n\n    # Wait for the next rising edge \n    await RisingEdge(clk_out)\n    end_time = get_sim_time('ns')\n\n    # Calculating the period\n    clk_out_period = end_time - start_time\n    clk_out._log.debug(f\"Measured clk_out period: {clk_out_period} ns\")\n\n    assert clk_out_period == expected_period, f\"Error: clk_out period {clk_out_period} ns does not match expected {expected_period} ns\"\n\n    return clk_out_period", "src/test_clk_div.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_clock_divider(dut):\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n    # Reset the DUT\n    await hrs_lb.reset_dut(dut)\n    dut._log.info(\"Reset initialized, ready for sequential sel value tests.\")\n    \n    # Perform test for each `sel` value sequentially\n    for sel_value in range(3):  # sel = 0, 1, 2\n        # Apply select value\n        dut.sel.value = sel_value\n        dut._log.info(f\"Applying sel = {sel_value}\")\n\n        # Synchronize with clock and stabilize\n        for _ in range(16):\n            await RisingEdge(dut.clk)\n\n        # Check clock behavior after applying `sel`\n        div_factor = 2 ** (sel_value + 1)\n        expected_period = div_factor * 10  # Adjust period according to the divider\n        clk_out_period = await hrs_lb.measure_clk_period(dut.clk_out, dut.clk, expected_period)\n        dut._log.info(f\"Test passed for sel = {sel_value}, clk_out is clk/{div_factor}\")\n\n        # Now reset the DUT before moving to the next `sel` value\n        dut._log.info(f\"Asserting reset before changing sel from {sel_value}\")\n        dut.rst_n.value = 0  # Assert reset\n\n        # Synchronize with clock\n        for _ in range(2):  # Holding reset\n            await RisingEdge(dut.clk)\n\n        # Deassert reset\n        dut.rst_n.value = 1\n        dut._log.info(f\"Reset deasserted, moving to next sel value after {sel_value}\")\n\n    # Test for sel = 3 (default case)\n    dut.sel.value = 3\n    for _ in range(4):\n        await RisingEdge(dut.clk)\n\n    # Check if clk_out is 0 when sel = 3\n    assert dut.clk_out.value == 0, \"Error: clk_out is not 0 when sel = 3\"\n    dut._log.info(\"Test passed for sel = 3: clk_out = 0\")\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\nimport pickle\n\n# Gather environment variables for simulation settings\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\n# Parametrized test to run the simulation\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_clock_divider_run(test):\n    # os.rmdir(\"sim_build\")\n    # os.remove(\"./sim_build/sim.vvp\")    \n    # Get the simulator runner for the specified simulator (e.g., icarus)\n    runner = get_runner(sim)\n    \n    # Build the simulation environment\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        clean=True,              # Clean previous builds\n        # verbose=True,            \n        timescale=(\"1ns\", \"1ns\"), # Set timescale\n        log_file=\"sim.log\"        # Log the output of the simulation\n    )\n    \n    # Run the test module\n    runner.test(hdl_toplevel=toplevel, test_module=module)\n\n# Uncomment the following line if you want to run the test directly (for standalone execution)\n# if __name__ == \"__main__\":\n#     test_clock_divider_run()\n"}}}
{"id": "cvdp_copilot_comparator_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Create a fully parameterized SystemVerilog module for a comparator that can operate in two modes: \"signed mode\" and \"magnitude mode.\" The module should compare two signed integers of parameterized bit width and output signals to indicate whether one input is greater than, less than, or equal to the other. The design should be a purely combinational circuit and include an enabled input that activates the comparison.\n\n### Specifications\n\n1. **Module Name:** `signed_unsigned_comparator`\n2. **Parameterization:**\n   - `WIDTH`: Defines the bit-width of the inputs (default value: 5).\n3. **Inputs and Outputs:**\n\n| Signal      | Direction | Bit Width     | Active State | Description                                                                                          |\n|-------------|-----------|---------------|--------------|------------------------------------------------------------------------------------------------------|\n| `i_A`       | Input     | `WIDTH`       | N/A          | `WIDTH`-bit integer input value, to be compared with `i_B`.                                          |\n| `i_B`       | Input     | `WIDTH`       | N/A          | `WIDTH`-bit integer input value, to be compared with `i_A`.                                          |\n| `i_enable`  | Input     | 1             | High         | Enable signal for comparison. When low, all outputs (`o_greater`, `o_less`, `o_equal`) are inactive. |\n| `i_mode`    | Input     | 1             | High         | Mode selection signal: high for \"signed mode,\" low for \"magnitude mode\".                             |\n| `o_greater` | Output    | 1             | High         | Output signal indicating `i_A` > `i_B`. Active when `i_enable` is high and `i_A` is greater than `i_B`. |\n| `o_less`    | Output    | 1             | High         | Output signal indicating `i_A` < `i_B`. Active when `i_enable` is high and `i_A` is less than `i_B`.   |\n| `o_equal`   | Output    | 1             | High         | Output signal indicating `i_A` == `i_B`. Active when `i_enable` is high and `i_A` equals `i_B`.        |\n\n### Behavioral Requirements\n\n- The module should support two comparison modes:\n  - **Signed Mode:** If `i_mode` is high, the comparison interprets `i_A` and `i_B` as signed integers, where the most significant bit (MSB) represents the sign (1 for negative, 0 for positive).\n  - **Magnitude Mode:** If `i_mode` is low, the comparison ignores the sign bit and treats both inputs as unsigned magnitudes.\n  \n- When `i_enable` is high, the module should perform the comparison according to the selected mode:\n  - If `i_A` > `i_B`, `o_greater` should be high, and `o_less` and `o_equal` should be low.\n  - If `i_A` < `i_B`, `o_less` should be high, and `o_greater` and `o_equal` should be low.\n  - If `i_A` == `i_B`, `o_equal` should be high, and `o_greater` and `o_less` should be low.\n  \n- When `i_enable` is low, all outputs (`o_greater`, `o_less`, `o_equal`) should be set to low, regardless of the comparison mode or inputs.\n\n### Constraints and Edge Cases\n\n- Ensure the module correctly handles edge cases for maximum positive and maximum negative values in signed mode, as well as for the largest and smallest possible magnitudes in magnitude mode.\n- The design should fully handle the `i_enable` signal, keeping outputs low when disabled.\n- Ensure that parameterization for `WIDTH` is respected throughout the design, allowing easy modification of input bit-width without further changes to the logic.\n\n### Additional Notes\n\n- Follow purely combinational design requirements\u2014no sequential elements.\n- Ensure the module is synthesizable and uses industry-standard terminology throughout the code and documentation.\n", "context": {}}, "output": {"response": "", "context": {"rtl/signed_comparator.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/signed_comparator.sv\nTOPLEVEL        = signed_unsigned_comparator\nMODULE          = test_signed_comparator\nPYTHONPATH      = /src\nHASH            = 1-design-a-5-bit-signed-comparator", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()", "src/test_signed_comparator.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\n\n\n@cocotb.test()\nasync def test_signed_comparator(dut):  # dut will be the object for RTL top.\n   \n\n    #magnitude mode\n\n    dut.i_A.value = 0\n    dut.i_B.value = 0\n    dut.i_enable.value = 0\n    dut.i_mode.value = 0\n    await Timer(100, units='ps')\n    assert dut.o_greater.value==0, f\"output should not be {dut.o_greater.value}\"\n    assert dut.o_less.value==0, f\"output should not be {dut.o_less.value}\"\n    assert dut.o_equal.value==0, f\"output should not be {dut.o_equal.value}\"\n\n    dut.i_A.value = 5\n    dut.i_B.value = 3\n    dut.i_enable.value = 1\n    await Timer(100, units='ps')\n    assert dut.o_greater.value==1, f\"output should not be {dut.o_greater.value}\"\n    assert dut.o_less.value==0, f\"output should not be {dut.o_less.value}\"\n    assert dut.o_equal.value==0, f\"output should not be {dut.o_equal.value}\"\n\n    await Timer(100, units='ps')\n    dut.i_enable.value = 0\n    await Timer(300, units='ns')\n    dut.i_A.value = 3\n    dut.i_B.value = 5\n    dut.i_enable.value = 1\n    await Timer(100, units='ps')\n    assert dut.o_greater.value==0, f\"output should not be {dut.o_greater.value}\"\n    assert dut.o_less.value==1, f\"output should not be {dut.o_less.value}\"\n    assert dut.o_equal.value==0, f\"output should not be {dut.o_equal.value}\"\n\n    await Timer(100, units='ps')\n    dut.i_enable.value = 0\n    await Timer(300, units='ns')\n    dut.i_A.value = 5\n    dut.i_B.value = 5\n    dut.i_enable.value = 1\n    await Timer(100, units='ps')\n    assert dut.o_greater.value==0, f\"output should not be {dut.o_greater.value}\"\n    assert dut.o_less.value==0, f\"output should not be {dut.o_less.value}\"\n    assert dut.o_equal.value==1, f\"output should not be {dut.o_equal.value}\"\n\n    #signed mode_________________________\n    await Timer(100, units='ps')\n    dut.i_enable.value = 0\n    dut.i_mode.value = 1\n\n    dut.i_A.value = -3\n    dut.i_B.value = -5\n    dut.i_enable.value = 1\n    await Timer(100, units='ps')\n    assert dut.o_greater.value==1, f\"output should not be {dut.o_greater.value}\"\n    assert dut.o_less.value==0, f\"output should not be {dut.o_less.value}\"\n    assert dut.o_equal.value==0, f\"output should not be {dut.o_equal.value}\"\n\n    await Timer(100, units='ps')\n    dut.i_enable.value = 0\n    await Timer(300, units='ns')\n    dut.i_A.value = -5\n    dut.i_B.value = -3\n    dut.i_enable.value = 1\n    await Timer(100, units='ps')\n    assert dut.o_greater.value==0, f\"output should not be {dut.o_greater.value}\"\n    assert dut.o_less.value==1, f\"output should not be {dut.o_less.value}\"\n    assert dut.o_equal.value==0, f\"output should not be {dut.o_equal.value}\"\n\n    await Timer(100, units='ps')\n    dut.i_enable.value = 0\n    await Timer(300, units='ns')\n    dut.i_A.value = -5\n    dut.i_B.value = -5\n    dut.i_enable.value = 1\n    await Timer(100, units='ps')\n    assert dut.o_greater.value==0, f\"output should not be {dut.o_greater.value}\"\n    assert dut.o_less.value==0, f\"output should not be {dut.o_less.value}\"\n    assert dut.o_equal.value==1, f\"output should not be {dut.o_equal.value}\"\n\n\n    #___________________\n    await Timer(100, units='ps')\n    dut.i_enable.value = 0\n\n    dut.i_A.value = 5\n    dut.i_B.value = 3\n    dut.i_enable.value = 1\n    await Timer(100, units='ps')\n    assert dut.o_greater.value==1, f\"output should not be {dut.o_greater.value}\"\n    assert dut.o_less.value==0, f\"output should not be {dut.o_less.value}\"\n    assert dut.o_equal.value==0, f\"output should not be {dut.o_equal.value}\"\n\n    await Timer(100, units='ps')\n    dut.i_enable.value = 0\n    await Timer(300, units='ns')\n    dut.i_A.value = 3\n    dut.i_B.value = 5\n    dut.i_enable.value = 1\n    await Timer(100, units='ps')\n    assert dut.o_greater.value==0, f\"output should not be {dut.o_greater.value}\"\n    assert dut.o_less.value==1, f\"output should not be {dut.o_less.value}\"\n    assert dut.o_equal.value==0, f\"output should not be {dut.o_equal.value}\"\n\n    await Timer(100, units='ps')\n    dut.i_enable.value = 0\n    await Timer(300, units='ns')\n    dut.i_A.value = 5\n    dut.i_B.value = 5\n    dut.i_enable.value = 1\n    await Timer(100, units='ps')\n    assert dut.o_greater.value==0, f\"output should not be {dut.o_greater.value}\"\n    assert dut.o_less.value==0, f\"output should not be {dut.o_less.value}\"\n    assert dut.o_equal.value==1, f\"output should not be {dut.o_equal.value}\"\n\n\n\n    \n    "}}}
{"id": "cvdp_copilot_complex_multiplier_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Write System Verilog RTL for complex number multiplier. The design should have an asynchronous active low reset and the latency of the design should be one cycle.\nPort List:\n`clk`:  1 bit input to the design. This is the Clock signal for the design\n`arst_n`: 1 bit input to the design. This is asynchronous active-low reset for the design. \n`a_real`: 16 bit input to the design. This is the real part of first complex number\n`a_imag`: 16 bit input to the design. This is the imaginary part of first complex number\n`b_real`: 16 bit input to the design. This is the real part of second complex number\n`b_imag`: 16 bit input to the design. This is the imaginary part of second complex number\n`result_real`: 32 bit output from the design. This is the real part of the result\n`result_imag`: 32 bit output from the design. This is the imaginary part of the result\n\ncomplex multiplier\n\nA complex multiplier is a digital system that multiplies two complex numbers. Given two complex numbers in the form  (a+bj) and (c+dj), where a, b, c and d are real numbers and j is the imaginary unit, the multiplication follows this formula:\n\n    (a+bj)\u00d7(c+dj)=(ac\u2212bd)+(ad+bc)j\n\nAlgorithm: \nReal Part Calculation: The real part of the result is computed by multiplying the real components of the two complex numbers and subtracting the product of their imaginary components:\n\n    Real_Result=(a\u00d7c)\u2212(b\u00d7d)\n\nImaginary Part Calculation: The imaginary part is calculated by multiplying the real part of one number by the imaginary part of the other, then summing these results:\n\n    Imaginary_Result=(a\u00d7d)+(b\u00d7c)\n\nThe algorithm efficiently computes both real and imaginary parts using simple multiplications and additions, and these results are often stored for output in the next clock cycle.", "context": {}}, "output": {"response": "", "context": {"rtl/complex_multiplier.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\r\n\r\n  01-new-tb:\r\n    image: __OSS_SIM_IMAGE__\r\n    volumes:\r\n      - ./src/:/src/:ro\r\n    env_file    : ./src/.env\r\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -sv", "src/.env": "SIM             = icarus\r\nTOPLEVEL_LANG   = verilog\r\nVERILOG_SOURCES = /code/rtl/complex_multiplier.sv\r\nTOPLEVEL        = complex_multiplier\r\nMODULE          = test_complex_multiplier\r\nPYTHONPATH      = /src\r\nHASH            = 1-rtl-design-for-complex-multiplier", "src/test_complex_multiplier.py": "import cocotb\r\nfrom cocotb.clock import Clock\r\nfrom cocotb.triggers import RisingEdge\r\nfrom cocotb.triggers import FallingEdge\r\nimport random\r\n\r\ndef reference_complex_multiplier(a_real, a_imag, b_real, b_imag):\r\n    result_real = (a_real * b_real) - (a_imag * b_imag)\r\n    result_imag = (a_real * b_imag) + (a_imag * b_real)\r\n    return result_real, result_imag\r\n\r\nasync def initialize_dut(dut):\r\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\r\n    dut.arst_n.value = 0\r\n    await RisingEdge(dut.clk)\r\n    dut.arst_n.value = 1\r\n    await RisingEdge(dut.clk)\r\n\r\n@cocotb.test()\r\nasync def test_complex_multiplier(dut):\r\n    await initialize_dut(dut)\r\n    match = 0\r\n    mismatch = 0\r\n\r\n    NUM_TESTS = 1000\r\n    # MIN_INPUT_VAL = 1\r\n    MAX_INPUT_VAL = 0xFF\r\n\r\n    for i in range(NUM_TESTS+1): # The result of Nth test is available in N+1 cycle.\r\n        \r\n        a_real = random.randint(-MAX_INPUT_VAL, MAX_INPUT_VAL)\r\n        a_imag = random.randint(-MAX_INPUT_VAL, MAX_INPUT_VAL)\r\n        b_real = random.randint(-MAX_INPUT_VAL, MAX_INPUT_VAL)\r\n        b_imag = random.randint(-MAX_INPUT_VAL, MAX_INPUT_VAL)\r\n\r\n        dut.a_real.value = a_real\r\n        dut.a_imag.value = a_imag\r\n        dut.b_real.value = b_real\r\n        dut.b_imag.value = b_imag\r\n\r\n        expected_real, expected_imag = reference_complex_multiplier(a_real, a_imag, b_real, b_imag)\r\n\r\n        await RisingEdge(dut.clk)\r\n        a_real = random.randint(-MAX_INPUT_VAL, MAX_INPUT_VAL)\r\n        a_imag = random.randint(-MAX_INPUT_VAL, MAX_INPUT_VAL)\r\n        b_real = random.randint(-MAX_INPUT_VAL, MAX_INPUT_VAL)\r\n        b_imag = random.randint(-MAX_INPUT_VAL, MAX_INPUT_VAL)\r\n\r\n        dut.a_real.value = a_real\r\n        dut.a_imag.value = a_imag\r\n        dut.b_real.value = b_real\r\n        dut.b_imag.value = b_imag\r\n        await RisingEdge(dut.clk)\r\n\r\n\r\n        actual_real = dut.result_real.value.signed_integer\r\n        actual_imag = dut.result_imag.value.signed_integer\r\n\r\n        if ((actual_real == expected_real) and (actual_imag == expected_imag)):\r\n            print(f\"Test {i} Passed: result = ({actual_real} + {actual_imag}j) matches reference ({expected_real} + {expected_imag}j)\")\r\n            match = match+1\r\n        else:\r\n            print(f\"Test {i} Failed: result = ({actual_real} + {actual_imag}j) matches reference ({expected_real} + {expected_imag}j)\")\r\n            mismatch = mismatch+1\r\n\r\n    if (mismatch==0):\r\n        print(f\"All {NUM_TESTS} test cases PASSED successfully.\")\r\n    else: \r\n        print(f\"Matched: {match} , Mismatched {mismatch} - TEST FAILED.\")\r\n", "src/test_runner.py": "import os\r\nfrom cocotb_tools.runner import get_runner\r\nimport pytest\r\nimport pickle\r\nimport random\r\n\r\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\r\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\r\nsim             = os.getenv(\"SIM\", \"icarus\")\r\ntoplevel        = os.getenv(\"TOPLEVEL\")\r\nmodule          = os.getenv(\"MODULE\")\r\n@pytest.mark.tb\r\ndef test_palindrome_detect():\r\n    runner = get_runner(sim)\r\n    runner.build(\r\n        sources=verilog_sources,\r\n        hdl_toplevel=toplevel,\r\n        # Arguments\r\n        always=True,\r\n        clean=True,\r\n        # parameters=parameter,\r\n        waves=True,\r\n        verbose=True,\r\n        timescale=(\"1ns\", \"1ns\"),\r\n        log_file=\"sim.log\")\r\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)"}}}
{"id": "cvdp_copilot_concatenate_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design a Verilog module named `enhanced_fsm_signal_processor` that uses a finite state machine (FSM) to manage signal processing operations, handle fault conditions, and report the FSM's current status.  \n\n### **Inputs**  \n- `i_clk`: Clock signal for sequential operation.  \n- `i_rst_n`: Active-low reset signal that resets the FSM and clears outputs.  \n- `i_enable`(1 bit): Enable signal to start processing; when low, the FSM remains in IDLE.  \n- `i_clear`(1 bit): Signal to clear outputs and reset the fault state.  \n- `i_ack`(1 bit): Acknowledgment signal to transition the FSM from READY to IDLE after processing is complete. It will be a pulse of 1 clock cycle. \n- `i_fault`(1 bit): Signal indicating a fault condition during operation.  \n- `i_vector_1`: 5-bit input vector.  \n- `i_vector_2`: 5-bit input vector.  \n- `i_vector_3`: 5-bit input vector.  \n- `i_vector_4`: 5-bit input vector.  \n- `i_vector_5`: 5-bit input vector.  \n- `i_vector_6`: 5-bit input vector.  \n\n### **Outputs**  \n- `o_ready`(1 bit): Signal that indicates when outputs are valid and processing is complete. Default 0.\n- `o_error`(1 bit): Signal that asserts when a fault condition is detected. Default 0.\n- `o_fsm_status`(2 bits): Current FSM state, encoded as a 2-bit signal, representing one of the FSM states: IDLE(00), PROCESS(01), READY(10), or FAULT(11). Default is IDLE.\n- `o_vector_1`: 8-bit output vector. Default 0.\n- `o_vector_2`: 8-bit output vector. Default 0.\n- `o_vector_3`: 8-bit output vector. Default 0.\n- `o_vector_4`: 8-bit output vector. Default 0.\n\n---\n\n## **FSM States and Functionality**  \n\n### **States**  \n1. **IDLE**:  \n   - Default state. \n   - FSM waits for `i_enable` to assert high to transition to PROCESS. \n   - If `i_fault` is detected, FSM transitions to FAULT.  \n\n2. **PROCESS**:  \n   - Concatenates six 5-bit input vectors into a single 30-bit bus, appends two `1` bits at the LSB to form a 32-bit bus, and splits it into four 8-bit output vectors.  \n   - `o_vector_1` to `o_vector_4` maps from MSB to LSB of concatenation bus.\n   - If `i_fault` is detected during this state, FSM transitions to FAULT.  \n\n3. **READY**:  \n   - Indicates processing is complete by asserting `o_ready`.  \n   - FSM waits for `i_ack` to transition back to IDLE.  \n   - If `i_fault` is detected, FSM transitions to FAULT.  \n\n4. **FAULT**:  \n   - Asserts `o_error` to indicate a fault condition.  \n   - Outputs are set to default.\n   - FSM transitions to IDLE only when `i_clear` is asserted and `i_fault` is deasserted.\n\n---\n\n## **Operational Rules**  \n- The FSM must progress through states sequentially, synchronized to `i_clk`.  \n- When `i_rst_n` is low, FSM resets to IDLE, clears outputs, and resets the fault state.  \n- When in FAULT, the `i_clear` signal must clear the fault condition and reset the FSM to IDLE.  \n- Outputs (`o_vector_1`, `o_vector_2`, `o_vector_3`, `o_vector_4`) must strictly adhere to the concatenation and splitting logic specified.  \n- Fault handling (`o_error` and FAULT state) must take precedence over other operations.  \n- All the outputs are synchronous to `i_clk`.\n- `i_fault` always take precedence over any other input except `i_clk` and `i_rst_n`.\n- All the input are synchronous to `i_clk`.\n\n", "context": {}}, "output": {"response": "", "context": {"rtl/enhanced_fsm_signal_processor.v": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/enhanced_fsm_signal_processor.v\nTOPLEVEL        = enhanced_fsm_signal_processor\nMODULE          = test_enhanced_fsm_signal_processor\nPYTHONPATH      = /src\nHASH            = 1-rtl-design", "src/test_enhanced_fsm_signal_processor.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\n\ndef assert_equal(actual, expected, msg=\"\"):\n    \"\"\"Custom assertion with message.\"\"\"\n    assert actual == expected, f\"{msg}: Expected {expected}, but got {actual}\"\n\n@cocotb.test()\nasync def test_enhanced_fsm_signal_processor(dut):\n    # Setup clock: 10 ns period (100 MHz)\n    clock = Clock(dut.i_clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Initialize all inputs\n    dut.i_rst_n.value = 0\n    dut.i_enable.value = 0\n    dut.i_clear.value = 0\n    dut.i_ack.value = 0\n    dut.i_fault.value = 0\n    dut.i_vector_1.value = 0\n    dut.i_vector_2.value = 0\n    dut.i_vector_3.value = 0\n    dut.i_vector_4.value = 0\n    dut.i_vector_5.value = 0\n    dut.i_vector_6.value = 0\n\n    # Apply asynchronous reset\n    await Timer(20, units=\"ns\")  # Hold reset for 20 ns\n    dut.i_rst_n.value = 1\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n\n    # Check initial state after reset\n    assert_equal(dut.o_fsm_status.value, 0b00, \"FSM should be in IDLE after reset\")\n    assert_equal(dut.o_ready.value, 0, \"o_ready should be 0 in IDLE\")\n    assert_equal(dut.o_error.value, 0, \"o_error should be 0 in IDLE\")\n\n    # Test IDLE to PROCESS transition\n    dut.i_enable.value = 1\n    dut.i_vector_1.value = 0b00001\n    dut.i_vector_2.value = 0b00010\n    dut.i_vector_3.value = 0b00100\n    dut.i_vector_4.value = 0b01000\n    dut.i_vector_5.value = 0b10000\n    dut.i_vector_6.value = 0b11111\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_fsm_status.value, 0b01, \"FSM should transition to PROCESS on i_enable\")\n\n    # Test vector processing in PROCESS state\n    \n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_vector_1.value, 0b00001000, \"o_vector_1 should match MSB of concatenation\")\n    assert_equal(dut.o_vector_2.value, 0b10001000, \"o_vector_2 should match second MSB segment\")\n    assert_equal(dut.o_vector_3.value, 0b10001000, \"o_vector_3 should match third MSB segment\")\n    assert_equal(dut.o_vector_4.value, 0b01111111, \"o_vector_4 should match LSB segment\")\n\n    assert_equal(dut.o_fsm_status.value, 0b10, \"FSM should transition to READY after processing\")\n    assert_equal(dut.o_ready.value, 1, \"o_ready should be 1 in READY state\")\n\n    # Test READY to IDLE transition\n    dut.i_ack.value = 1\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    dut.i_ack.value = 0\n    assert_equal(dut.o_fsm_status.value, 0b00, \"FSM should transition to IDLE on i_ack\")\n    assert_equal(dut.o_ready.value, 0, \"o_ready should be 0 in IDLE\")\n\n    # Test fault condition from IDLE\n    dut.i_fault.value = 1\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_fsm_status.value, 0b11, \"FSM should transition to FAULT on i_fault\")\n    assert_equal(dut.o_error.value, 1, \"o_error should be 1 in FAULT state\")\n\n    # Test clearing fault condition\n    dut.i_clear.value = 1\n    dut.i_fault.value = 0\n    dut.i_enable.value = 0\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    dut.i_clear.value = 0\n    assert_equal(dut.o_fsm_status.value, 0b00, \"FSM should transition to IDLE after clearing fault\")\n    assert_equal(dut.o_error.value, 0, \"o_error should be 0 after fault is cleared\")\n\n    # Test fault during PROCESS\n    dut.i_enable.value = 1\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_fsm_status.value, 0b01, \"FSM should transition to PROCESS on i_enable\")\n    dut.i_fault.value = 1\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_fsm_status.value, 0b11, \"FSM should transition to FAULT on i_fault in PROCESS\")\n\n    # Test all outputs reset in FAULT\n    assert_equal(dut.o_vector_1.value, 0, \"o_vector_1 should reset in FAULT\")\n    assert_equal(dut.o_vector_2.value, 0, \"o_vector_2 should reset in FAULT\")\n    assert_equal(dut.o_vector_3.value, 0, \"o_vector_3 should reset in FAULT\")\n    assert_equal(dut.o_vector_4.value, 0, \"o_vector_4 should reset in FAULT\")\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_configurable_digital_low_pass_filter_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Implement a complete SystemVerilog module for a low-pass filter, referred to as the `low_pass_filter` module. The module should process incoming data streams using configurable coefficients and output the filtered result. The filter performs convolution on input data using a finite impulse response (FIR) structure, with the following specifications:\n\n---\n\n## Parameters\n\n| **Parameter**   | **Description**                          | **Default Value** | **Constraint**                                  |\n|------------------|------------------------------------------|--------------------|------------------------------------------------|\n| `DATA_WIDTH`    | Bit-width of the input data              | 16                 | Minimum: 2                                    |\n| `COEFF_WIDTH`   | Bit-width of the filter coefficients      | 16                 | Minimum: 2                                     |\n| `NUM_TAPS`      | Number of filter taps (convolution size) | 8                  | Minimum: 2                      |\n| `NBW_MULT`      | Bit-width of intermediate multiplication results | 32 | Calculated as `NBW_MULT = DATA_WIDTH + COEFF_WIDTH`. This parameter should not be configured externally since it is derived internally based on the values of `DATA_WIDTH` and `COEFF_WIDTH`. |\n\n---\n\n## Inputs and Outputs\n\n### Inputs\n\n| **Port**      | **Size**                            | **Description**                                                | **Constraint**              |\n|---------------|-------------------------------------|----------------------------------------------------------------|-----------------------------|\n| `clk`         | 1 bit                              | Clock signal, active on the rising edge                        | None                        |\n| `reset`       | 1 bit                              | Synchronous reset, active high                                | None                        |\n| `data_in`     | `DATA_WIDTH * NUM_TAPS` bits       | Packed input data (NUM_TAPS samples of integer signed values, each of width DATA_WIDTH) | None |\n| `valid_in`    | 1 bit                              | Validity flag for input data                                   | None                        |\n| `coeffs`      | `COEFF_WIDTH * NUM_TAPS` bits      | Packed coefficients (NUM_TAPS integer signed values, each of width COEFF_WIDTH) | None |\n\n### Outputs\n\n| **Port**      | **Size**                            | **Description**                                                | **Constraint**              |\n|---------------|-------------------------------------|----------------------------------------------------------------|-----------------------------|\n| `data_out`    | `(NBW_MULT + $clog2(NUM_TAPS))` bits | Filtered output data (integer signed value resulting from the sum of multiplied taps) | None |\n| `valid_out`   | 1 bit                              | Validity flag for output data                                  | None                        |\n\n---\n\n### Example of Usage\n\n#### Parameters\n- `NUM_TAPS = 8`\n- `DATA_WIDTH = 6`\n- `COEF_WIDTH = 4`\n\n#### Inputs\n- `data_in = {6'b001100, 6'b110011, 6'b101010, 6'b010101, 6'b111000, 6'b000111, 6'b100100, 6'b011011}`  \n- `coeffs = {4'b1100, 4'b1010, 4'b0110, 4'b1111, 4'b0001, 4'b0011, 4'b1001, 4'b0100}`  \n\n## Behavioral Description\n\n### Internal Signal Breakdown\n\n1. **2D Internal Representation** (Sequential and Combinational Logic):\n   - Before any processing, the input data (`data_in`) and coefficients (`coeffs`) are registered once and stored in flip-flops. This ensures that the input data is stable and synchronized with the computation pipeline.\n   - After being registered, the packed 1D input streams are converted into multidimensional (2D) arrays. This conversion is done using combinational logic to enable efficient parallel computation, such as element-wise multiplication and summation across the taps.\n   \n   1.1 **Valid Signal Requirement**:\n   - The `valid_in` signal must be high (`1`) to ensure the input data (`data_in`) and coefficients (`coeffs`) are correctly registered into their respective internal arrays.\n   - If `valid_in` is de-asserted (`0`), the input data and coefficients are not updated, and the module continues processing using the previously registered values.\n   - This ensures that the filter maintains consistent operation even if new valid data is temporarily unavailable, avoiding interruptions or invalid outputs.\n   - **Reset Behavior**: When the `reset` signal is active (`1`), the internal registers that store the input data and coefficients are cleared to zero. This guarantees a known initial state and prevents invalid computations when the module is restarted.\n\n2. **Element-wise Multiplication** (Combinational Logic):\n   - Perform element-wise multiplication between the converted data and coefficients arrays, following the principles of convolution.\n   - **Note**: The coefficients should be applied in reverse order relative to the input data. This means that the first data value is multiplied by the last coefficient, the second data value by the second-to-last coefficient, and so on.\n\n3. **Summation** (Combinational Logic):  \n   - The intermediate multiplication results are accumulated using a combinational adder tree to compute the final result.  \n\n4. **Edge Case Handling**:\n   - **Maximum Values**:\n     - When both `data_in` and `coeffs` are at their maximum values, the module must ensure that there is no overflow during intermediate computations or in the final result.\n     - To handle this:\n       4.1. **Intermediate Multiplication**:\n          - The size of `NBW_MULT` is defined as `DATA_WIDTH + COEFF_WIDTH`.\n       4.2. **Final Summation**:\n          - The summation result is accommodated in the final output width, calculated as `(NBW_MULT + $clog2(NUM_TAPS))`.\n          - This ensures the result fits within the defined output width, avoiding overflow.\n          \n   - **Zero Values**:\n     - When both `data_in` and `coeffs` are all zeros, the output will naturally be zero, as all intermediate multiplication and summation results will yield `0`. This behavior is inherent to the convolution operation.\n\n   - **Note on `$clog2` Usage**:\n     - The `$clog2` function in SystemVerilog must be used to calculate the number of bits required for the output width. This ensures accurate computation of the ceiling of the base-2 logarithm for the number of filter taps (`NUM_TAPS`).\n     - The output width is calculated as `(NBW_MULT + $clog2(NUM_TAPS))`, where:\n       - `NBW_MULT = DATA_WIDTH + COEFF_WIDTH`\n       - `$clog2(NUM_TAPS)` accounts for the summation of up to `NUM_TAPS` elements.\n\n5. **Output Signals**\n\n   - **Sequential Signal (`valid_out`)**:\n     - The `valid_out` signal is sequential and is derived by registering the `valid_in` signal. This introduces a latency of one clock cycle, ensuring proper synchronization with the computation pipeline.\n\n   - **Combinational Signal (`data_out`)**:\n     - The `data_out` signal is combinational and represents the result of the convolution operation performed on the input data and coefficients.\n     - Despite being combinational, `data_out` effectively has a latency of one clock cycle because it is registered once before being output, ensuring both `data_out` and `valid_out` are synchronized.\n\n\n---\n\n### Reset and Latency\n\n- **Reset Behavior**:\n  - When `reset` is high, the output validity signal (`valid_out`) is cleared.\n\n- **Pipeline Latency**:  \n  - The input-to-output latency is fixed at 1 clock cycle.", "context": {}}, "output": {"response": "", "context": {"rtl/low_pass_filter.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : /bin/sh -c \"pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -s\"", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/low_pass_filter.sv\nTOPLEVEL        = low_pass_filter\nMODULE          = test_low_pass_filter\nPYTHONPATH      = /src\nHASH            = 1-create-rtl-of-low-pass-filter", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# Reset the DUT (design under test)\nasync def reset_dut(reset_n, duration_ns=10):\n    reset_n.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")   ", "src/test_low_pass_filter.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport harness_library as hrs_lb\nimport random\n\n# ----------------------------------------\n# - Test Low Pass Filter\n# ----------------------------------------\n\n@cocotb.test()\nasync def test_low_pass_filter(dut):\n    \"\"\"Test the Low Pass Filter module with edge cases and random data.\"\"\"\n\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Debug mode\n    debug = 0\n\n    # Retrieve parameters from the DUT\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n    COEFF_WIDTH = int(dut.COEFF_WIDTH.value)\n    NUM_TAPS = int(dut.NUM_TAPS.value)\n\n    # Initialize DUT\n    await hrs_lb.dut_init(dut)\n\n    # Apply reset and enable\n    await hrs_lb.reset_dut(dut.reset)\n\n    # Calculate min and max values for data and coefficients\n    data_min = int(-2**DATA_WIDTH / 2)\n    data_max = int((2**DATA_WIDTH / 2) - 1)\n    coeff_min = int(-2**COEFF_WIDTH / 2)\n    coeff_max = int((2**COEFF_WIDTH / 2) - 1)\n\n    # Number of random test iterations\n    num_random_iterations = 98  # Adjust to complement explicit cases for 100 total tests\n\n    # Explicit test cases to ensure edge coverage\n    test_cases = [\n        ([0] * NUM_TAPS, [0] * NUM_TAPS),  # All zeros\n        ([data_max] * NUM_TAPS, [coeff_max] * NUM_TAPS),  # All maximum values\n        ([data_min] * NUM_TAPS, [coeff_min] * NUM_TAPS),  # All minimum values\n    ]\n\n    # Add random test cases\n    for _ in range(num_random_iterations):\n        data_in = [random.randint(data_min, data_max) for _ in range(NUM_TAPS)]\n        coeffs = [random.randint(coeff_min, coeff_max) for _ in range(NUM_TAPS)]\n        test_cases.append((data_in, coeffs))\n\n    # Iterate through all test cases\n    for test_num, (data_in, coeffs) in enumerate(test_cases):\n        #cocotb.log.info(f\"[INFO] Test Case {test_num + 1}\")\n\n        # Flatten input data and coefficients into a single concatenated value\n        data_in_concat = int(''.join(format(x & ((1 << DATA_WIDTH) - 1), f'0{DATA_WIDTH}b') for x in data_in), 2)\n        coeffs_concat = int(''.join(format(x & ((1 << COEFF_WIDTH) - 1), f'0{COEFF_WIDTH}b') for x in coeffs), 2)\n\n        valid_in = 1 if test_num < 3 else random.randint(0, 1)  # Valid always high for edge cases\n\n        # Apply inputs to the DUT\n        dut.data_in.value = data_in_concat\n        dut.coeffs.value = coeffs_concat\n        dut.valid_in.value = valid_in\n\n        for _ in range(2):  # Wait for computation to propagate\n            await RisingEdge(dut.clk)\n\n        if valid_in:\n            # Calculate expected output\n            expected_output = sum(d * c for d, c in zip(data_in, coeffs[::-1]))\n\n            # Read the output from the DUT\n            data_out = dut.data_out.value.to_signed()\n\n            # Assertions\n            assert data_out == expected_output, f\"Test {test_num + 1}: Output mismatch: {data_out} != {expected_output}\"\n            assert dut.valid_out.value == valid_in, f\"Test {test_num + 1}: Valid mismatch: {dut.valid_out.value} != {valid_in}\"\n\n            # Debug logging\n            if debug:\n                cocotb.log.info(f\"[DEBUG] Test {test_num + 1}\")\n                cocotb.log.info(f\"[DEBUG] Data_in = {data_in}\")\n                cocotb.log.info(f\"[DEBUG] Coeffs = {coeffs}\")\n                cocotb.log.info(f\"[DEBUG] Data_out = {data_out}, Expected = {expected_output}\")\n                cocotb.log.info(f\"[DEBUG] Valid_out = {dut.valid_out.value}, Valid_in = {valid_in}\")\n\n        # Deactivate valid_in for the next iteration\n        dut.valid_in.value = 0\n\n    cocotb.log.info(f\"All {len(test_cases)} tests passed successfully.\")\n", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(DATA_WIDTH: int = 16, COEFF_WIDTH: int = 16, NUM_TAPS: int = 8):\n    # Simulation parameters\n    parameter = {\n        \"DATA_WIDTH\": DATA_WIDTH,\n        \"COEFF_WIDTH\": COEFF_WIDTH,\n        \"NUM_TAPS\": NUM_TAPS\n    }\n\n    # Debug information\n    print(f\"[DEBUG] Running simulation with DATA_WIDTH={DATA_WIDTH}\")\n    print(f\"[DEBUG] Running simulation with COEFF_WIDTH={COEFF_WIDTH}\")\n    print(f\"[DEBUG] Running simulation with NUM_TAPS={NUM_TAPS}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Generate minimum, default and more random sizes\nrandom_data_width  = [2] + [16] + [random.randint(8, 32) for _ in range(2)]\nrandom_coeff_width = [2] + [16] + [random.randint(8, 32) for _ in range(2)]\nrandom_num_taps    = [2] + [8]  + [random.randint(4, 16) for _ in range(2)]\n\n# Parametrize test for different random data sizes\n@pytest.mark.parametrize(\"DATA_WIDTH\", random_data_width)\n@pytest.mark.parametrize(\"COEFF_WIDTH\", random_coeff_width)\n@pytest.mark.parametrize(\"NUM_TAPS\", random_num_taps)\n@pytest.mark.parametrize(\"test\", range(2))\ndef test_data(DATA_WIDTH, COEFF_WIDTH, NUM_TAPS, test):\n    # Run the simulation with specified parameters\n    runner(DATA_WIDTH=DATA_WIDTH, COEFF_WIDTH=COEFF_WIDTH, NUM_TAPS=NUM_TAPS)"}}}
{"id": "cvdp_copilot_configurable_digital_low_pass_filter_0004", "categories": ["cid003", "medium"], "input": {"prompt": "Implement a complete SystemVerilog `advanced_decimator_with_adaptive_peak_detection` module that performs data decimation and peak detection. The module should process input samples, reduce the dataset based on a configurable decimation factor, and identify the peak value among the decimated samples. The implementation should be parameterizable.\n\n---\n\n## Module Specification\n\n### Parameters\n\n| **Parameter**   | **Description**                          | **Default Value** | **Constraints**                                  |\n|-----------------|------------------------------------------|--------------------|-------------------------------------------------|\n| `N`             | Total number of input samples            | 8                  | Minimum: Any positive integer greater than 1    |\n| `DATA_WIDTH`    | Bit-width of each sample                 | 16                 | Minimum: Any positive integer greater than 1    |\n| `DEC_FACTOR`    | Decimation factor                        | 4                  | Must be a integer divisor of `N`                |\n\n---\n\n### Inputs and Outputs\n\n#### Inputs\n\n| **Port**      | **Size**                           | **Description**                                                | **Constraints**             |\n|---------------|------------------------------------|----------------------------------------------------------------|-----------------------------|\n| `clk`         | 1 bit                              | Clock signal, active on the rising edge                        | None                        |\n| `reset`       | 1 bit                              | Asynchronous reset, active high                                | None                        |\n| `valid_in`    | 1 bit                              | Input validation signal indicating valid data                  | None                        |\n| `data_in`     | `DATA_WIDTH * N` bits              | Packed input data (N samples of integer signed values)         | None                        |\n\n#### Outputs\n\n| **Port**      | **Size**                             | **Description**                                                                                 |\n|---------------|--------------------------------------|-------------------------------------------------------------------------------------------------|\n| `valid_out`   | 1 bit                                | Output validation signal, indicating valid decimated data                                       |\n| `data_out`    | `DATA_WIDTH * (N / DEC_FACTOR)` bits | Packed decimated output data, containing `(N / DEC_FACTOR)` samples, each of size `DATA_WIDTH`  |\n| `peak_value`  | `DATA_WIDTH` bits                    | Peak value among the decimated samples, with a size of `DATA_WIDTH`                             |\n\n---\n\n### Example of Usage\n\n#### Parameters\n- `N = 8`\n- `DATA_WIDTH = 16`\n- `DEC_FACTOR = 4`\n\n#### Inputs\n- `data_in = {16'd10, 16'd20, 16'd30, 16'd40, 16'd50, 16'd60, 16'd70, 16'd80}`\n- `valid_in = 1`\n\n#### Outputs\n- `data_out = {16'd10, 16'd50}`\n- `peak_value = 16'd50`\n- `valid_out = 1`\n\n---\n\n## Module Behavior\n\n1. **Input Data Registering**:\n   - The input samples are registered on the rising edge of the clock. When `reset` is active, the register value is cleared to zero.\n\n2. **Input Unpacking**:\n   - Combinational logic is used to unpack the packed input data bus into individual samples for processing.\n\n3. **Decimation**\n- The decimation process iterates through the input data, selecting one sample for every `DEC_FACTOR` samples.\n- A combinational loop calculates the position of each selected sample and places it into the decimated dataset.\n- The resulting decimated dataset contains `N / DEC_FACTOR` samples, each spaced by `DEC_FACTOR` positions from the original dataset.\n\n4. **Peak Detection**\n- This block uses combinational logic to identify the maximum value among the decimated data samples.\n- The process starts by initializing the peak value with the first sample from the decimated data.\n- It then iterates through all remaining decimated samples, comparing each with the current peak value.\n- If a sample is larger than the current peak value, the peak is updated to this new value.\n- After processing all samples, the peak value (`output peak_value`) represents the maximum data point among the decimated samples.\n\n5. **Output Packing**:\n   - The decimated samples are combined into a packed data bus (`output data_out`) using combinational logic.\n\n6. **Validation Control**:\n   - Sequential logic generates the `output valid_out` signal based on the `input valid_in` signal. When the reset is active, the validation signal is cleared.\n\n---\n## Pipeline Latency:\n\n- The input-to-output latency is fixed at 1 clock cycle.", "context": {}}, "output": {"response": "", "context": {"rtl/decimator_and_peak_detector.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : /bin/sh -c \"pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -s\"", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/decimator_and_peak_detector.sv\nTOPLEVEL        = advanced_decimator_with_adaptive_peak_detection\nMODULE          = test_advanced_decimator_with_adaptive_peak_detection\nPYTHONPATH      = /src\nHASH            = 4-create-an-rtl-of-decimator-with-peak-detector", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# Reset the DUT (design under test)\nasync def reset_dut(reset_n, duration_ns=10):\n    reset_n.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")   \n\nasync def extract_signed(signal, width, total_elements):\n         signed_values = []\n         for i in reversed(range(total_elements)):\n             # Extract the unsigned value\n             unsigned_value = (signal.value.to_signed() >> (width * i)) & ((1 << width) - 1)\n             # Convert to signed\n             signed_value = unsigned_value - (1 << width) if unsigned_value & (1 << (width - 1)) else unsigned_value\n             signed_values.append(signed_value)\n         return signed_values\n\nasync def pack_signal(values, width):\n    packed_signal = 0\n    for i, value in enumerate(reversed(values)):\n        # Convert the signed value to unsigned representation\n        unsigned_value = value & ((1 << width) - 1)\n        # Shift and combine into the packed signal\n        packed_signal |= (unsigned_value << (i * width))\n    return packed_signal    ", "src/test_advanced_decimator_with_adaptive_peak_detection.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport harness_library as hrs_lb\nimport random\n\n# ----------------------------------------\n# - Test Advanced Decimator with Adaptive Peak Detection\n# ----------------------------------------\n\n@cocotb.test()\nasync def test_advanced_decimator_with_adaptive_peak_detection_0(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Debug mode\n    debug = 0\n\n    # Retrieve parameters from the DUT\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n    DEC_FACTOR = int(dut.DEC_FACTOR.value)\n    N = int(dut.N.value)\n\n    # Initialize DUT\n    await hrs_lb.dut_init(dut)\n\n    # Apply reset\n    await hrs_lb.reset_dut(dut.reset)\n\n    # Test parameters\n    num_samples = 10  # Number of sets of input data to test\n    max_value = (1 << (DATA_WIDTH - 1)) - 1  # Max positive value for signed DATA_WIDTH\n    min_value = -(1 << (DATA_WIDTH - 1))    # Min negative value for signed DATA_WIDTH\n\n    for test_case in range(num_samples):\n        # Generate random input values for the decimator\n        input_values = [random.randint(min_value, max_value) for _ in range(N)]\n        packed_signal = await hrs_lb.pack_signal(input_values, DATA_WIDTH)\n        \n        dec_model = []\n        input_values = input_values[::-1]\n        for i in range(N // DEC_FACTOR):\n            dec_model.append(input_values[i * DEC_FACTOR])\n        dec_model = dec_model[::-1]\n        peak_model = max(dec_model)\n\n        valid_in = random.randint(0,1)\n        # Apply input to DUT\n        dut.data_in.value = packed_signal\n        dut.valid_in.value = valid_in\n\n        if debug:\n            cocotb.log.info(f\"[DEBUG] Test Case {test_case + 1}\")\n            cocotb.log.info(f\"[DEBUG] Input Values: {input_values}\")\n            cocotb.log.info(f\"[DEBUG] Packed Signal: {packed_signal:#0{N * DATA_WIDTH // 4 + 2}x}\")\n            \n\n        # Wait for one clock cycle\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n\n        # Retrieve outputs\n        output_data = await hrs_lb.extract_signed(dut.data_out, DATA_WIDTH, N//DEC_FACTOR)\n        peak_value = dut.peak_value.value.to_signed()\n\n        # Debug output\n        if debug:\n            for i in range(N):\n               cocotb.log.info(f\"[DEBUG] In data 2D: {dut.data_vec_in.value[i].to_signed()}\")\n            cocotb.log.info(f\"[DEBUG] Output Data: {output_data}\")\n            cocotb.log.info(f\"[DEBUG] Model Data: {dec_model}\")\n            cocotb.log.info(f\"[DEBUG] Peak Value: {peak_value}\")\n            cocotb.log.info(f\"[DEBUG] Model Peak: {peak_model}\")\n\n        # Assertions (replace with specific checks for your DUT logic)\n        assert dut.valid_out.value == valid_in, f\"[ERROR] DUT did not assert valid_out on Test Case {test_case + 1}\"\n        if valid_in == 1:\n          assert output_data == dec_model, f\"[ERROR] DUT output data does not match model output data on Test Case {test_case + 1}\"\n          assert peak_value == peak_model, f\"[ERROR] DUT peak value does not match model peak value on Test Case {test_case + 1}\"\n            ", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(N: int = 8, DATA_WIDTH: int = 16, DEC_FACTOR: int = 4):\n    # Simulation parameters\n    parameter = {\n        \"N\": N,\n        \"DATA_WIDTH\": DATA_WIDTH,\n        \"DEC_FACTOR\": DEC_FACTOR\n    }\n\n    # Debug information\n    print(f\"[DEBUG] Running simulation with N={N}\")\n    print(f\"[DEBUG] Running simulation with DATA_WIDTH={DATA_WIDTH}\")\n    print(f\"[DEBUG] Running simulation with DEC_FACTOR={DEC_FACTOR}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Generate random valid parameters\nrandom_n          = [8]  + [4, 8, random.randint(4, 32)]\nrandom_data_width = [16] + [8, 16, random.randint(8, 32)]\n\ndef generate_valid_dec_factors(n):\n    \"\"\"Generate a list of valid DEC_FACTOR values that divide N.\"\"\"\n    return [i for i in range(1, n + 1) if n % i == 0]\n\n# Parametrize test for different random sizes\n@pytest.mark.parametrize(\"N\", random_n)\n@pytest.mark.parametrize(\"DATA_WIDTH\", random_data_width)\n@pytest.mark.parametrize(\"test\", range(2))\ndef test_data(N, DATA_WIDTH, test):\n    # Generate valid DEC_FACTOR values dynamically\n    valid_dec_factors = generate_valid_dec_factors(N)\n    # Randomly select a DEC_FACTOR from the valid options\n    DEC_FACTOR = random.choice(valid_dec_factors)\n\n    # Debug information\n    print(f\"[DEBUG] Selected DEC_FACTOR={DEC_FACTOR} for N={N}\")\n\n    # Run the simulation with specified parameters\n    runner(N=N, DATA_WIDTH=DATA_WIDTH, DEC_FACTOR=DEC_FACTOR)\n"}}}
{"id": "cvdp_copilot_configurable_digital_low_pass_filter_0014", "categories": ["cid003", "easy"], "input": {"prompt": "Implement a complete SystemVerilog module for `fsm_linear_reg` module, a finite state machine (FSM) for linear regression computations. It processes input data using configurable weights and biases to produce filtered results. The FSM operates in three states: `IDLE`, `COMPUTE`, and `DONE`. When triggered by a start signal, the module computes and outputs the filtered results, signaling completion with a `done` flag.\n\n---\n\n## Parameters\n\n| **Parameter**    | **Description**                          | **Default Value** | **Constraint**          |\n|------------------|------------------------------------------|-------------------|-------------------------|\n| `DATA_WIDTH`     | Bit-width of the input data              | 16                | Minimum: 2              |\n\n---\n\n## Inputs and Outputs\n\n### Inputs\n\n| **Port**      | **Size**            | **Description**                                      | **Constraint**                                |\n|---------------|---------------------|------------------------------------------------------|-----------------------------------------------|\n| `clk`         | 1 bit               | Clock signal, active on the rising edge              | None                                          |\n| `reset`       | 1 bit               | Asynchronous reset, active high                      | None                                          |\n| `start`       | 1 bit               | Start signal to initiate computation                 | None                                          |\n| `x_in`        | `DATA_WIDTH` bits   | Input data (integer signed)                          | Range: -2**DATA_WIDTH to 2**DATA_WIDTH - 1    |\n| `w_in`        | `DATA_WIDTH` bits   | Trained weight for linear regression (integer signed)| Range: -2**DATA_WIDTH to 2**DATA_WIDTH - 1    |\n| `b_in`        | `DATA_WIDTH` bits   | Trained bias for linear regression (integer signed)  | Range: -2**DATA_WIDTH to 2**DATA_WIDTH - 1    |\n\n### Outputs\n\n| **Port**      | **Size**            | **Description**                                                   | **Constraint**                                                   |\n|---------------|---------------------|-------------------------------------------------------------------|------------------------------------------------------------------|\n| `result1`     | `2*DATA_WIDTH` bits | Output result of the weighted sum calculation (integer signed)    | Size accommodates the product of two `DATA_WIDTH`-sized signals. |\n| `result2`     | `DATA_WIDTH+1` bits | Output result of bias-adjusted input calculation (integer signed) | Size accommodates the sum of two `DATA_WIDTH`-sized signals.     |\n| `done`        | 1 bit               | Completion signal                                                 |  High for 1 clock cycle                                          |\n---\n\n## Behavioral Description\n\nThe FSM operates in three states: **`IDLE`**, **`COMPUTE`**, and **`DONE`**.\n\n- **IDLE**:  \n  - Waits for `start` signal.  \n  - Outputs are held at zero.\n\n- **COMPUTE**:  \n  - Computes results using combinational logic:  \n    - **`result1`** = `w_in * x_in >>> 1`  \n       - The size of **result1** is calculated to prevent overflow during multiplication when the inputs have maximum or minimum values.\n    - **`result2`** = `b_in + (x_in >>> 2)`  \n       - The size of **result2** is calculated to prevent overflow during the sum when the inputs have maximum or minimum values.\n  - Updates the output registers.  \n  - Transitions to `DONE` upon completion.\n\n- **DONE**:  \n  - Asserts `done` signal for 1 clock cycle.  \n     - Even if the `start` input is always `1`, the `done` output will only be `1` for one cycle during the state transitions from `IDLE` to `COMPUTE` and from `COMPUTE` to `DONE`.\n  - Returns to `IDLE` state to await the next `start`.\n\n- **Default**:\n   -  If, for any reason, there is a failure in the state transition and the next state becomes invalid, the FSM must return to the `IDLE` state.\n\n---\n\n## Reset and Latency\n\n- **Reset**:  \n  - When `reset` is high, all outputs (`result1`, `result2`, `done`) are reset to zero.  \n  - FSM returns to `IDLE`.\n\n- **Latency**:  \n  - Fixed latency: 2 clock cycles from `start` asserted to changes in `result1`  and `result2`.\n  - Fixed latency: 3 clock cycles from `start` asserted to assertion of `done`.\n\n---", "context": {}}, "output": {"response": "", "context": {"rtl/fsm_linear_reg.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : /bin/sh -c \"pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -s\"", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/fsm_linear_reg.sv\nTOPLEVEL        = fsm_linear_reg\nMODULE          = test_fsm\nPYTHONPATH      = /src\nHASH            = 14-create-an-rtl-of-fsm-to-linear-regression", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# Reset the DUT (design under test)\nasync def reset_dut(reset_n, duration_ns=10):\n    reset_n.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")   \n\nclass FSMLinearReg:\n    \"\"\"\n    A Python implementation of FSM logic that mimics the behavior of fsm_linear_reg module.\n    \"\"\"\n\n    # FSM States\n    IDLE = 0\n    COMPUTE = 1\n    DONE = 2\n\n    def __init__(self, data_width=16):\n        self.DATA_WIDTH = data_width\n        self.reset()\n\n    def reset(self):\n        \"\"\"\n        Resets the FSM to the IDLE state and clears all outputs and registers.\n        \"\"\"\n        self.current_state = self.IDLE\n        self.result1 = 0       # Output for combinational logic 1\n        self.result2 = 0       # Output for combinational logic 2\n        self.done = 0          # Completion flag\n        self.compute1 = 0      # Internal signal for logic 1\n        self.compute2 = 0      # Internal signal for logic 2\n        self.output_buffer = {  # Buffer to introduce delay\n            \"result1\": 0,\n            \"result2\": 0,\n            \"done\": 0\n        }\n\n    def next_state_logic(self, start):\n        \"\"\"\n        Determines the next state based on the current state and start signal.\n        \"\"\"\n        if self.current_state == self.IDLE:\n            self.next_state = self.COMPUTE if start else self.IDLE\n        elif self.current_state == self.COMPUTE:\n            self.next_state = self.DONE\n        elif self.current_state == self.DONE:\n            self.next_state = self.IDLE\n        else:\n            self.next_state = self.IDLE\n\n    def combinational_logic(self, x_in, w_in, b_in):\n        \"\"\"\n        Perform the two combinational logic operations.\n        Logic 1: (w_in * x_in) >> 1\n        Logic 2: b_in + (x_in >> 2)\n        \"\"\"\n        self.compute1 = (w_in * x_in) >> 1  # Weighted sum shifted right by 1\n        self.compute2 = b_in + (x_in >> 2)  # Add bias to input shifted right by 2\n\n    def fsm_output_logic(self):\n        \"\"\"\n        Updates outputs based on the current state and introduces delay in outputs.\n        \"\"\"\n        # Update outputs with a cycle of delay using the buffer\n        self.result1 = self.output_buffer[\"result1\"]\n        self.result2 = self.output_buffer[\"result2\"]\n        self.done = self.output_buffer[\"done\"]\n\n        if self.current_state == self.COMPUTE:\n            self.output_buffer[\"result1\"] = self.compute1\n            self.output_buffer[\"result2\"] = self.compute2\n            self.output_buffer[\"done\"] = 0\n        elif self.current_state == self.DONE:\n            self.output_buffer[\"done\"] = 1\n        else:\n            self.output_buffer[\"result1\"] = 0\n            self.output_buffer[\"result2\"] = 0\n            self.output_buffer[\"done\"] = 0\n\n    def step(self, start, x_in, w_in, b_in):\n        \"\"\"\n        Simulate one clock cycle of the FSM.\n        \"\"\"\n        # Determine the next state\n        self.next_state_logic(start)\n\n        # Combinational logic\n        #if self.current_state == self.COMPUTE:\n        self.combinational_logic(x_in, w_in, b_in)\n\n        # Update outputs\n        self.fsm_output_logic()\n\n        # Move to the next state\n        self.current_state = self.next_state\n\n    def print_outputs(self):\n        \"\"\"\n        Returns the outputs of the FSM after the delay cycle.\n        \"\"\"\n        return {\n            \"result1\": self.result1,\n            \"result2\": self.result2,\n            \"done\": self.done\n        }\n    def get_outputs(self):\n      return [self.result1,self.result2,self.done]\n\n", "src/test_fsm.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport harness_library as hrs_lb\nimport random\n\n# ----------------------------------------\n# - Test FSM Linear Regression\n# ----------------------------------------\n\n@cocotb.test()\nasync def test_fsm_linear_reg(dut):\n    \"\"\"Test the FSM Linear Regression module with edge cases and random data.\"\"\"\n\n    # Start clock\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Debug mode\n    debug = 0\n\n    # Retrieve parameters from the DUT\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n    model = hrs_lb.FSMLinearReg(DATA_WIDTH)\n    # Initialize DUT\n    await hrs_lb.dut_init(dut)\n\n    # Apply reset\n    await hrs_lb.reset_dut(dut.reset)\n    model.reset()\n    await RisingEdge(dut.clk)\n\n    # Calculate min and max values for input data\n    data_min = int(-2**(DATA_WIDTH - 1))  # Minimum signed value\n    data_max = int((2**(DATA_WIDTH - 1)) - 1)  # Maximum signed value\n    #random.seed(10)\n\n    # Simulation configurations\n    num_random_iterations = 10\n\n\n    # ----------------------------------------\n    # Test 1: Min and Max values for inputs\n    # ----------------------------------------\n    edge_case_inputs = [\n        (data_min, data_min, data_min),  # All inputs at minimum\n        (data_max, data_max, data_max),  # All inputs at maximum\n        (data_min, data_max, data_min),  # Mixed min and max\n        (data_max, data_min, data_max)   # Mixed max and min\n    ]\n\n    # Generate random test cases and append to edge cases\n    for _ in range(num_random_iterations):\n        random_x = random.randint(data_min, data_max)\n        random_w = random.randint(data_min, data_max)\n        random_b = random.randint(data_min, data_max)\n        edge_case_inputs.append((random_x, random_w, random_b))\n\n    reset_cycle = random.randint(0, len(edge_case_inputs) - 2)\n    cocotb.log.warning(f'Reset will be applied at cycle = {reset_cycle+1}')\n\n    # Run all test cases (edge cases + random cases)\n    for i, (x_in_val, w_in_val, b_in_val) in enumerate(edge_case_inputs):\n        start_signal = random.randint(0,1)\n        \n        # Apply stimulus to DUT\n        dut.start.value = start_signal\n        dut.x_in.value = x_in_val\n        dut.w_in.value = w_in_val\n        dut.b_in.value = b_in_val        \n        if i == reset_cycle:\n            cocotb.log.info(f\"[INFO] Applying reset at cycle {i+1}\")\n            await hrs_lb.reset_dut(dut.reset)\n            result1 = dut.result1.value.to_signed()\n            result2 = dut.result2.value.to_signed()\n            done    = dut.done.value.to_unsigned()\n            model_res = model.print_outputs()\n            model_out = model.get_outputs()\n    \n            # Log the DUT outputs\n            if debug:\n               cocotb.log.info(f\"  result1 = {result1}\")\n               cocotb.log.info(f\"  result2 = {result2}\")\n               cocotb.log.info(f\"  done    = {done}\")            \n            model.reset()\n            await RisingEdge(dut.clk)\n            model.step(start=start_signal, x_in=x_in_val, w_in=w_in_val, b_in=b_in_val)\n            model.step(start=start_signal, x_in=x_in_val, w_in=w_in_val, b_in=b_in_val)\n\n\n        model.step(start=start_signal, x_in=x_in_val, w_in=w_in_val, b_in=b_in_val)\n\n        # Log the applied inputs\n        if debug:\n            cocotb.log.info(f\"[INFO] Test Case {i+1}\")\n            cocotb.log.info(f\"  x_in   = {x_in_val}\")\n            cocotb.log.info(f\"  w_in   = {w_in_val}\")\n            cocotb.log.info(f\"  b_in   = {b_in_val}\")\n            cocotb.log.info(f\"  start  = {start_signal}\")\n            cocotb.log.info(f\"   STATE = {dut.next_state.value.to_unsigned()}\")\n            cocotb.log.info(f\"   STATE = {dut.current_state.value.to_unsigned()}\")\n\n        # Wait for one clock cycle\n        await RisingEdge(dut.clk)\n\n        # Read outputs\n        result1 = dut.result1.value.to_signed()\n        result2 = dut.result2.value.to_signed()\n        done    = dut.done.value.to_unsigned()\n        model_res = model.print_outputs()\n        model_out = model.get_outputs()\n\n        # Log the DUT outputs\n        if debug:\n            cocotb.log.info(f\"  result1 = {result1}\")\n            cocotb.log.info(f\"  result2 = {result2}\")\n            cocotb.log.info(f\"  done    = {done}\")\n            cocotb.log.info(f\"MODEL = {model_res} \")\n\n        assert result1 == model_out[0]\n        assert result2 == model_out[1]\n        assert done    == model_out[2]\n", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(DATA_WIDTH: int = 16):\n    # Simulation parameters\n    parameter = {\n        \"DATA_WIDTH\": DATA_WIDTH\n    }\n\n    # Debug information\n    print(f\"[DEBUG] Running simulation with DATA_WIDTH={DATA_WIDTH}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    # Configure and run the simulation\n    sim_runner = get_runner(sim)\n    sim_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    # Run the test\n    sim_runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Generate minimum, default, and random sizes for DATA_WIDTH\nrandom_data_width = [2] + [16] + [random.randint(8, 16) for _ in range(5)]\n\n# Parametrize test for different DATA_WIDTH values\n@pytest.mark.parametrize(\"DATA_WIDTH\", random_data_width)\n@pytest.mark.parametrize(\"test\", range(5))\ndef test_data(DATA_WIDTH, test):\n    # Run the simulation with specified DATA_WIDTH\n    runner(DATA_WIDTH=DATA_WIDTH)"}}}
{"id": "cvdp_copilot_convolutional_encoder_0001", "categories": ["cid003", "easy"], "input": {"prompt": "I need to implement a fixed constraint k=3 and a generator polynomial convolutional encoder in Verilog for a digital communication system. The encoder should have a constraint length k=3 and use two generator polynomials: \\( g_1(x) = x^2 + x + 1 \\) and \\( g_2(x) = x^2 + 1 \\). The encoder needs to take a serial input data stream and produce a 2-bit encoded output for each input bit.\n\nThe constraint length (K) is fixed at 3, which means the encoder uses the current input bit and the previous 2 bits (held in a 2-bit shift register) to generate the encoded outputs.\n\nThe generator polynomial g1 is \"111\", which corresponds to ( g_1(x) = x^2 + x + 1 ). This polynomial is used to generate the first encoded bit (encoded_bit1). The generator polynomial g2 is \"101\", which corresponds to ( g_2(x) = x^2 + 1 ). This polynomial is used to generate the second encoded bit (encoded_bit2).\n\nThe inputs to the module are:\n\n1. clk: The clock signal used to synchronize the operations of the module.\n2. rst: An asynchronous reset signal, active high. When asserted, it resets the shift register and the encoded output bits.\n3. data_in: A single-bit input signal representing the incoming data stream to be encoded.\n\nThe outputs of the module are:\n\n1. encoded_bit1: The first encoded output bit, generated using the generator polynomial g1.\n2. encoded_bit2: The second encoded output bit, generated using the generator polynomial g2.", "context": {}}, "output": {"response": "", "context": {"rtl/convolutional_encoder.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/convolutional_encoder.sv\nTOPLEVEL        = convolutional_encoder\nMODULE          = test_convolutional_encoder\nPYTHONPATH      = /src\nHASH            = a9d853a00965d16076c3c5df2a40f827feb25555", "src/test_convolutional_encoder.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n# Helper function to calculate expected encoded bits based on generator polynomials\ndef expected_bits(data_in, shift_reg):\n    g1 = data_in ^ shift_reg[0] ^ shift_reg[1]  # Generator g1 = 111\n    g2 = data_in ^ shift_reg[1]                 # Generator g2 = 101\n    return g1, g2\n\n@cocotb.test()\nasync def test_reset(dut):\n    \"\"\"Test reset functionality.\"\"\"\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())  # Start the clock\n\n    # Apply reset\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)  # Wait for a few clock cycles\n    dut.rst.value = 0\n\n    # Check if the shift register and encoded bits are properly reset\n    assert dut.shift_reg.value == 0, f\"Shift register is not reset properly: {dut.shift_reg.value}\"\n    assert dut.encoded_bit1.value == 0, f\"Encoded bit1 is not reset properly: {dut.encoded_bit1.value}\"\n    assert dut.encoded_bit2.value == 0, f\"Encoded bit2 is not reset properly: {dut.encoded_bit2.value}\"\n\n@cocotb.test()\nasync def test_convolutional_encoding(dut):\n    \"\"\"Test the convolutional encoding logic for a sequence of data.\"\"\"\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())  # Start the clock\n\n    # Reset the DUT\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n\n    # Initialize shift register\n    shift_reg = [0, 0]  # Initial state of the shift register (2-bit for K-1)\n\n    # Apply a sequence of data and check the encoded output\n    test_data = [1, 0, 1, 1, 0, 0]  # Test input sequence\n    for i, bit_in in enumerate(test_data):\n        dut.data_in.value = bit_in\n\n        # Wait for a clock edge and then a short delay to allow signal propagation\n        await RisingEdge(dut.clk)\n        await Timer(2, units=\"ns\")  # Small delay to ensure signals stabilize\n\n        # Calculate the expected encoded bits\n        expected_bit1, expected_bit2 = expected_bits(bit_in, shift_reg)\n\n        # Debug print for shift register and expected vs actual encoded bits\n        print(f\"Cycle {i + 1}: Input bit: {bit_in}, Shift register: {shift_reg}\")\n        print(f\"Expected encoded bits: bit1={expected_bit1}, bit2={expected_bit2}\")\n        print(f\"Actual encoded bits: bit1={int(dut.encoded_bit1.value)}, bit2={int(dut.encoded_bit2.value)}\")\n\n        # Check the encoded bits after allowing for signal stabilization\n        assert dut.encoded_bit1.value == expected_bit1, f\"Encoded bit1 mismatch at cycle {i + 1}: got {dut.encoded_bit1.value}, expected {expected_bit1}\"\n        assert dut.encoded_bit2.value == expected_bit2, f\"Encoded bit2 mismatch at cycle {i + 1}: got {dut.encoded_bit2.value}, expected {expected_bit2}\"\n\n        # Update the shift register (LIFO shift)\n        shift_reg = [bit_in] + shift_reg[:-1]\n\n@cocotb.test()\nasync def test_random_data(dut):\n    \"\"\"Test convolutional encoding with random input data.\"\"\"\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())  # Start the clock\n\n    # Reset the DUT\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n\n    # Initialize shift register\n    shift_reg = [0, 0]  # Initial state of the shift register\n\n    # Apply a random sequence of data and check the encoded output\n    for i in range(10):\n        bit_in = random.randint(0, 1)\n        dut.data_in.value = bit_in\n\n        # Wait for a clock edge and then a short delay to allow signal propagation\n        await RisingEdge(dut.clk)\n        await Timer(2, units=\"ns\")  # Small delay to ensure signals stabilize\n\n        # Calculate the expected encoded bits\n        expected_bit1, expected_bit2 = expected_bits(bit_in, shift_reg)\n\n        # Debug print for shift register and expected vs actual encoded bits\n        print(f\"Cycle {i + 1}: Input bit: {bit_in}, Shift register: {shift_reg}\")\n        print(f\"Expected encoded bits: bit1={expected_bit1}, bit2={expected_bit2}\")\n        print(f\"Actual encoded bits: bit1={int(dut.encoded_bit1.value)}, bit2={int(dut.encoded_bit2.value)}\")\n\n        # Check the encoded bits after allowing for signal stabilization\n        assert dut.encoded_bit1.value == expected_bit1, f\"Encoded bit1 mismatch at cycle {i + 1}: got {dut.encoded_bit1.value}, expected {expected_bit1}\"\n        assert dut.encoded_bit2.value == expected_bit2, f\"Encoded bit2 mismatch at cycle {i + 1}: got {dut.encoded_bit2.value}, expected {expected_bit2}\"\n\n        # Update the shift register\n        shift_reg = [bit_in] + shift_reg[:-1]\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport re\nimport logging\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_data_bus_controller_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Write the RTL design for a data bus controller using System Verilog. Here are the design specifications.\n-  There will be two master interfaces (m0 and m1) which can send transaction independently regardless of each other. Both interfaces use ready-valid handshake mechanism. \n- There will be only one slave to accept these transactions. This should also follow the ready-valid handshake mechanism. \n- If both masters drive transaction at different clock cycles, then design should drive them to slave interface first come, first served basis. \n- The ready signal for master should be dependent on slave's ready. Slave's ready signal should be transferred to masters's ready signal.\n- If both masters drives at the same cycle, then design should use a parameter named 'AFINITY' value to decide whose transaction will be sent to the slave and whose will be ignored.\n  - The parameter AFINITY can only have value 0 and 1\n  - if the value of AFINITY is 0 at that particular cycle, the transaction of m0 should be driven to the slave and m1 will be ignored.\n  - if the value of AFINITY is 1 at that particular cycle, the transaction of m1 should be driven to the slave and m0 will be ignored.\n- Latency of the design should be one cycle.\n Here is the signal description of the interface.\n\n### Global Signals\n\n| Signal Name | Width  | Direction | Description                                                  | \n|-------------|--------|-----------|--------------------------------------------------------------|\n| clk         | 1 bit  | input     | System clock                                                 |\n| rst_n       | 1 bit  | input     | Asynchronous active low reset                                |\n\n### Master_0 interface (m0):\n\n| Signal Name | Width  | Direction | Description                                                  | \n|-------------|--------|-----------|--------------------------------------------------------------|\n| m0_ready    | 1 bit  | output    | Indicates that the design is ready to accept the transaction |\n| m0_valid    | 1 bit  | input     | Indicates that this transaction is a valid transaction       |\n| m0_data     | 32 bit | input     | Data to be transferred                                       |\n\n### Master_1 interface (m1):\n\n| Signal Name | Width  | Direction | Description                                                  |\n|-------------|--------|-----------|--------------------------------------------------------------|\n| m1_ready   | 1 bit  | output    | Indicates that the design is ready to accept the transaction |\n| m1_valid    | 1 bit  | input     | Indicates that this transaction is a valid transaction       |\n| m1_data     | 32 bit | input     | Data to be transferred                                       |\n\n### Slave interface :\n\n| Signal Name | Width  | Direction | Description                                                  |\n|-------------|--------|-----------|--------------------------------------------------------------|\n| s_ready     | 1 bit  | input     | Indicates that the slave is ready to accept the transaction  |\n| s_valid     | 1 bit  | output    | Indicates that this transaction is a valid transaction       |\n| s_data      | 32 bit | output    | Data to be transferred                                       |\n\nHere is the module definition in System Verilog\n```SystemVerilog\nmodule data_bus_controller #(\n  parameter AFINITY = 0\n  )(\n  input         clk      ,\n  input         rst_n    ,\n\n  output        m0_read  ,\n  input         m0_valid ,\n  input [31:0]  m0_data  ,\n\n  output        m1_read  ,\n  input         m1_valid ,\n  input [31:0]  m1_data  ,\n\n  input         s_read   ,\n  output        s_valid  ,\n  output [31:0] s_data \n);\n```\n ### Conceptual Diagram\n```mermaid\ngraph LR;\n    M0--data-->S;\n    M0--valid-->S;\n    S--ready-->M0;\n    M1--data-->S;\n    M1--valid-->S;\n    S--ready-->M1;\n```\n### Ready-Valid Handshake Protocol\nThe ready-valid handshake mechanism is a commonly used protocol in digital designs for managing data transfer between modules in a synchronized and reliable manner. In this protocol, two signals\u2014valid and ready\u2014coordinate the data transfer. The valid signal, asserted by the sender, indicates that the data is ready to be transmitted. The ready signal, asserted by the receiver, indicates that it is prepared to accept the data. A successful handshake occurs when both valid and ready are high in the same clock cycle, enabling the data transfer. This mechanism ensures data is transferred only when both modules are synchronized, improving timing predictability and flow control in digital systems.", "context": {}}, "output": {"response": "", "context": {"rtl/data_bus_controller.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\r\n\r\n  01-new-tb:\r\n    image: __OSS_SIM_IMAGE__\r\n    volumes:\r\n      - ./src/:/src/:ro\r\n    env_file    : ./src/.env\r\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -sv", "src/.env": "SIM             = icarus\r\nTOPLEVEL_LANG   = verilog\r\nVERILOG_SOURCES = /code/rtl/data_bus_controller.sv\r\nTOPLEVEL        = data_bus_controller\r\nMODULE          = test_data_bus_controller\r\nPYTHONPATH      = /src\r\nHASH            = 1-rtl-design-for-data-bus-controller", "src/test_data_bus_controller.py": "import cocotb\r\nfrom cocotb.clock import Clock\r\nfrom cocotb.triggers import RisingEdge, FallingEdge\r\nfrom cocotb.regression import TestFactory\r\nimport random\r\n\r\n# Constants for the affinity parameter\r\nAFINITY_0 = 0\r\n\r\nasync def reset_dut(dut):\r\n    dut.rst_n.value = 0\r\n    await RisingEdge(dut.clk)\r\n    await RisingEdge(dut.clk)\r\n    dut.rst_n.value = 1\r\n    await RisingEdge(dut.clk)\r\n\r\nasync def drive_master_transaction(dut, master, valid, data):\r\n    \"\"\"Drives a transaction on the specified master interface.\"\"\"\r\n    if master == 0:\r\n        dut.m0_valid.value = valid\r\n        dut.m0_data.value = data\r\n    elif master == 1:\r\n        dut.m1_valid.value = valid\r\n        dut.m1_data.value = data\r\n    await RisingEdge(dut.clk)\r\n    await RisingEdge(dut.clk)\r\n\r\nasync def drive_both_master_transaction(dut, valid, data0, data1):\r\n    \"\"\"Drives a transaction on the specified master interface.\"\"\"\r\n    dut.m0_valid.value = valid\r\n    dut.m0_data.value = data0\r\n    dut.m1_valid.value = valid\r\n    dut.m1_data.value = data1\r\n    await RisingEdge(dut.clk)\r\n    await RisingEdge(dut.clk)\r\n\r\nasync def release_master(dut, master):\r\n    \"\"\"Releases the transaction on the specified master interface.\"\"\"\r\n    if master == 0:\r\n        dut.m0_valid.value = 0\r\n    elif master == 1:\r\n        dut.m1_valid.value = 0\r\n    await RisingEdge(dut.clk)\r\n\r\nasync def monitor_slave_transaction(dut, expected_data):\r\n    \"\"\"Monitors and checks if the transaction on the slave interface is as expected.\"\"\"\r\n    await FallingEdge(dut.clk)\r\n    if dut.s_valid.value and dut.s_ready.value:\r\n        assert dut.s_data.value == expected_data, f\"Expected data {hex(expected_data)}, but got {hex(int(dut.s_data.value))}\"\r\n        cocotb.log.info(f\"Transaction successful: Received data {dut.s_data.value}\")\r\n\r\nasync def test_transaction(dut, affinity):\r\n    NUM_TEST = 1000\r\n    \"\"\"Main test coroutine that applies different transaction scenarios to the DUT.\"\"\"\r\n    # AFINITY = dut.AFINITY.value  # Set the affinity parameter\r\n    for x in range(NUM_TEST):\r\n        AFINITY_TEST = random.choice([True, False])\r\n        if AFINITY_TEST == True:\r\n            print(\"AFINITY_TEST\")\r\n            data0      = random.randint(0,0xFFFF_FFFF)\r\n            data1      = random.randint(0,0xFFFF_FFFF)\r\n            dut.s_ready.value = 1\r\n            await drive_both_master_transaction(dut, 1, data0=data0, data1=data1)\r\n\r\n            if affinity == AFINITY_0:\r\n                await monitor_slave_transaction(dut, expected_data=data0)\r\n            else:\r\n                await monitor_slave_transaction(dut, expected_data=data1)\r\n            await release_master(dut, 0)\r\n            await release_master(dut, 1)\r\n\r\n        else:\r\n            master_num = random.randint(0, 1) \r\n            data       = random.randint(0,0xFFFF_FFFF)\r\n            # master_num = 0\r\n            dut.s_ready.value = 1\r\n            await drive_master_transaction(dut, master_num, valid=1, data=data)\r\n            await monitor_slave_transaction(dut, expected_data=data)\r\n            await release_master(dut, master_num)\r\n\r\n@cocotb.test()\r\nasync def test_data_bus_controller(dut):\r\n    AFINITY = dut.AFINITY.value\r\n    # Generate the clock\r\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\r\n    await reset_dut(dut)\r\n\r\n    # Run the test with AFINITY set to 0\r\n    dut._log.info(\"Testing with Random AFINITY\")\r\n    await test_transaction(dut, AFINITY)", "src/test_runner.py": "import os\r\nfrom cocotb_tools.runner import get_runner\r\nimport pytest\r\nimport pickle\r\nimport random\r\n\r\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\r\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\r\nsim             = os.getenv(\"SIM\", \"icarus\")\r\ntoplevel        = os.getenv(\"TOPLEVEL\")\r\nmodule          = os.getenv(\"MODULE\")\r\n@pytest.mark.tb\r\ndef test_data_bus_controller():\r\n    parameter = {\"AFINITY\": random.randint(0, 1)}\r\n    runner = get_runner(sim)\r\n    runner.build(\r\n        sources=verilog_sources,\r\n        hdl_toplevel=toplevel,\r\n        # Arguments\r\n        always=True,\r\n        clean=True,\r\n        parameters=parameter,\r\n        waves=True,\r\n        verbose=True,\r\n        timescale=(\"1ns\", \"1ns\"),\r\n        log_file=\"sim.log\")\r\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)"}}}
{"id": "cvdp_copilot_data_width_converter_0003", "categories": ["cid003", "easy"], "input": {"prompt": "Design a **data width converter** that concatenates four 32-bit input data samples into a single 128-bit output. The module should only generate a valid output after receiving four consecutive valid inputs, as indicated by a control signal. The design must ensure efficient data aggregation and handle edge cases such as reset conditions and incomplete input sequences. The detailed design specification for the 32-to-128-bit data width converter is given below:\n\n## Design Specification:\n\n**Module Name:**  \n`data_width_converter`\n\n### Key Considerations:\n- The design should handle sequential 32-bit data inputs and combine them into a single 128-bit output.\n- The module operates on the positive edge of the clock signal.\n- The output should be generated once four valid 32-bit inputs have been received.\n- The output must be flagged as valid with the `o_data_out_valid` signal.\n- The system should reset when the `reset` signal is asserted, clearing any internal states.\n\n### Interface:\n\n**Inputs:**\n- `clk`:  Data operations will be performed during positive edge of this clock. The clock operates at 50:50 dutycycle.\n- `reset`: Asynchronous Active-high reset signal to initialize the system.\n- `data_in` (32bits,[31:0]): 32-bit data input to be concatenated into the output.\n- `data_valid`: A signal indicating whether the current `data_in` is valid.\n\n**Outputs:**\n- `o_data_out` (128-bits,[127:0]): 128-bit concatenated data output, generated after four valid 32-bit inputs.\n- `o_data_out_valid`: A signal indicating that the output data is valid.\n\n### Edge Cases:\n- **Reset Condition:** When `reset` is asserted, all internal states and buffers should be cleared, and no output should be produced until valid inputs are received.\n- **Incomplete Data:** If fewer than four valid inputs are received before `reset` is asserted, no output is generated, and the system waits for further valid inputs.\n- **Continuous Operation:** After producing a valid 128-bit output, the system will reset its internal counters and buffers to prepare for the next set of four 32-bit inputs.\n\n### Example Operation:\n\n**Concatenation Example:**  \n    \nClock cycles | Reset | data_in| data_valid \n-- | -- | -- | -- \n1 | 1\u2019b1 | 32'hA1B2C3D4 | 1\u2019b1\n2 | 1\u2019b1 | 32'h55667788 | 1\u2019b1 \n3 | 1\u2019b1 | 32'h11223344 | 1\u2019b1 \n4 | 1\u2019b1 | 32'h99AABBCC | 1\u2019b1 \n\n- Output:\n    - `o_data_out = 128'hA1B2C3D4_55667788_11223344_99AABBCC`\n    - `o_data_out_valid = 1` (for one clock cycle)", "context": {}}, "output": {"response": "", "context": {"rtl/data_width_converter.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest --log-cli-level=INFO -o cache_dir=/code/rundir/.cache -sv /src/test_runner.py\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nWAVE            = 1\nVERILOG_SOURCES = /code/rtl/data_width_converter.sv\nTOPLEVEL        = data_width_converter\nMODULE          = DW_convertor\nPYTHONPATH      = /src\nHASH            = 2a055442560c90d2c219162ed58a1d324e47d73d", "src/DW_convertor.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\n\n# Helper function to generate reset signal\nasync def reset_dut(dut, duration_ns):\n    dut.reset.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\n# Helper function to send data to DUT\nasync def send_data(dut, data, valid):\n    dut.data_in.value = data\n    dut.data_valid.value = valid\n    await RisingEdge(dut.clk)\n\n# Helper function to calculate the expected concatenated output\ndef concatenate_data(test_data):\n    expected_output = 0\n    for i in range(len(test_data)):\n        expected_output = (expected_output << 32) | test_data[i]\n    return expected_output\n\n# Test case 1: Send the first set of data and check the output\nasync def test_case_1(dut):\n    \"\"\" Test case 1: Send 4 consecutive valid 32-bit data words \"\"\"\n\n    # Test data to be fed into the DUT (32-bit data)\n    test_data = [0x12345678, 0x9ABCDEF0, 0x0FEDCBA9, 0x87654321]\n\n    # Expected output (concatenation of the input data in order)\n    expected_output = concatenate_data(test_data)\n\n    # Apply the input data and check output\n    for i in range(4):\n        dut._log.info(f\"Sending data {hex(test_data[i])}\")\n        await send_data(dut, test_data[i], 1)  # Send valid data\n        await Timer(10, units=\"ns\")\n\n    \n\n    # Check if the output matches the expected concatenation\n    dut._log.info(f\"Expected output: {hex(expected_output)}\")\n   \n\n    assert dut.o_data_out.value == expected_output, f\"Output mismatch: Expected {hex(expected_output)}, got {hex(dut.o_data_out.value)}\"\n\n    dut._log.info(\"Test case 1 completed successfully\")\n\n\n# Test case 2: Send another set of data and check the output\nasync def test_case_2(dut):\n    \"\"\" Test case 2: Send another set of 4 consecutive valid 32-bit data words \"\"\"\n\n    # New test data to be fed into the DUT (32-bit data)\n    test_data = [0xDEADBEEF, 0xCAFEBABE, 0xBAADF00D, 0xFACEFEED]\n\n    # Expected output (concatenation of the input data in order)\n    expected_output = concatenate_data(test_data)\n\n    # Apply the input data and check output\n    for i in range(4):\n        dut._log.info(f\"Sending data {hex(test_data[i])}\")\n        await send_data(dut, test_data[i], 1)  # Send valid data\n        await Timer(10, units=\"ns\")\n\n \n\n    # Check if the output matches the expected concatenation\n    dut._log.info(f\"Expected output: {hex(expected_output)}\")\n   \n\n    assert dut.o_data_out.value == expected_output, f\"Output mismatch: Expected {hex(expected_output)}, got {hex(dut.o_data_out.value)}\"\n\n    dut._log.info(\"Test case 2 completed successfully\")\n\nasync def test_case_3(dut):\n    \"\"\" Test case 2: Send another set of 4 consecutive valid 32-bit data words \"\"\"\n\n    # New test data to be fed into the DUT (32-bit data)\n    test_data = [0x11111111, 0x22222222, 0x33333333, 0x44444444]\n\n    # Expected output (concatenation of the input data in order)\n    expected_output = concatenate_data(test_data)\n\n    # Apply the input data and check output\n    for i in range(4):\n        dut._log.info(f\"Sending data {hex(test_data[i])}\")\n        await send_data(dut, test_data[i], 1)  # Send valid data\n        await Timer(10, units=\"ns\")\n\n \n\n    # Check if the output matches the expected concatenation\n    dut._log.info(f\"Expected output: {hex(expected_output)}\")\n   \n\n    assert dut.o_data_out.value == expected_output, f\"Output mismatch: Expected {hex(expected_output)}, got {hex(dut.o_data_out.value)}\"\n\n    dut._log.info(\"Test case 2 completed successfully\")\n# Main test function with both test cases\n@cocotb.test()\nasync def test_data_width_converter(dut):\n    \"\"\" Test data_width_converter with multiple test cases \"\"\"\n\n    # Start clock with a period of 10 ns (100 MHz)\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Apply reset\n    await reset_dut(dut, 20)\n\n    # Run test case 1\n    await test_case_1(dut)\n\n    # Apply reset before running the second test case\n    #await reset_dut(dut, 20)\n@cocotb.test()\nasync def test_data_width_converter(dut):\n    \"\"\" Test data_width_converter with multiple test cases \"\"\"\n\n    # Start clock with a period of 10 ns (100 MHz)\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n\n\n   \n    # Run test case 2\n    await test_case_2(dut)\n@cocotb.test()\nasync def test_data_width_converter(dut):\n    \"\"\" Test data_width_converter with multiple test cases \"\"\"\n\n    # Start clock with a period of 10 ns (100 MHz)\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n\n\n    # Run test case 1\n    await test_case_3(dut)", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_dbi_0001", "categories": ["cid003", "medium"], "input": {"prompt": "A **Data Bus Inversion (DBI) encoder** is a digital circuit used to reduce power consumption and electromagnetic interference (EMI) in high-speed digital buses. DBI encodes a group of data bits using an additional bit called a control bit, which indicates whether the current data bits should be transmitted over the bus as they are or in an inverted form.\n\nFor example, in the case of a DBI encoder that processes a group of 40 data bits, the 40-bit data is divided into two 20-bit groups, and each 20-bit group is converted into a 21-bit codeword. If the number of bit toggles between the previous codeword and the current data in each 20-bit group exceeds 10, the control bit is set to 1, and the data bits are encoded in inverted form. Otherwise, the control bit is set to 0, and the data bits are transmitted unchanged.\n\n## Design Specification of `dbi_enc` module:\n\n### Interface:\n\n#### Inputs:\n- **`data_in`** (40-bits, [39:0]): Data input before DBI logic, that is data input that needed to be encoded.\n- **`clk`** (1-bit): Clock signal associated with the input data.\n- **`rst_n`**: An active-low asynchronous reset signal. When asserted, this signal resets the internal flip-flops, forcing the output to a known state that is `data_out` to 40'h00_0000_0000 and `dbi_cntrl` to 2'b00.\n#### Output:\n- **`data_out`** (40-bits, [39:0]): Data input after DBI logic.\n- **`dbi_cntrl`** (2-bits, [1:0]): The output signal synchronized to the destination clock domain.\n\n### Description of DBI Encoder Functionality:\n\n**Splitting Incoming Data `data_in`:**\nThe DBI Encoder splits the 40-bit `data_in` into two 20-bit groups:\n- Group-1: The 20 most significant bits (MSBs).\n- Group-0: The 20 least significant bits (LSBs).\n\n**Comparison with Previous Data:**\nEach 20-bit group is compared with its corresponding previous 20-bit group.\n- If this is the first operation after a system reset or initialization, the groups are compared with 20-bits of zeroes.\n- Each bit in the current group is compared with the corresponding bit in the previous group to check whether they match or differ.\n\n**Control Signal (`dbi_cntrl`) Behavior:**\n- If more than 10 bits differ between the current and previous data in Group-1, `dbi_cntrl[1]` is set to high (1); otherwise, it is set to low (0).\n- Similarly, if more than 10 bits differ in Group-0, `dbi_cntrl[0]` is set to high (1); otherwise, it is set to low (0).\n\n**Generating `data_out`:**\nThe `data_out` signal is generated based on the values of `dbi_cntrl`:\n- If `dbi_cntrl[1]` is high, the inverted version of Group-1 (MSBs) is assigned to `data_out[39:20]`.\n- If `dbi_cntrl[0]` is high, the inverted version of Group-0 (LSBs) is assigned to `data_out[19:0]`.\n- If neither control signal is high, the respective groups are passed through without inversion.\n\n**Updating Previous Data:**\n- For the next operation, the 40-bit `data_out` from the current cycle is stored as the \"previous data\" for comparison.\n\n**Reset Behavior (nrst):**\n- When the` rst_n` signal is de-asserted (active low):\n- All flip-flops in the encoder are reset to a known state (typically logic low).\n- The `data_out` signal is held at a known value (e.g., all zeroes) while the reset is active.\n### Summary:\nThe DBI Encoder ensures that data is dynamically inverted for each group based on the bitwise differences between consecutive operations, optimizing the data encoding for transmission. The `dbi_cntrl` signals dictate whether the data groups are inverted, ensuring flexibility. Reset functionality ensures stable behavior during system initialization.\n\n", "context": {}}, "output": {"response": "", "context": {"rtl/dbi_enc.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py\n\n", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/dbi_enc.sv \nTOPLEVEL        = dbi_enc\nMODULE          = test_dbi_encoder\nPYTHONPATH      = /src\nHASH            = f934aee69ae2f90fa004a1feef1da7307479bc2b", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(rst_n, dut):\n    # Restart Interface\n    await FallingEdge(dut.clk)\n    rst_n.value = 0\n    await FallingEdge(dut.clk)\n    rst_n.value = 1\n    await FallingEdge(dut.clk)\n    rst_n._log.debug(\"Reset complete\")\n\nasync def enable_dut(enable, duration_ns = 10):\n    # Restart Interface\n    enable.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    enable.value = 1\n    await Timer(duration_ns, units='ns')\n    enable._log.debug(\"enable complete\")\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def calculate_moving_average(data_queue, current_sum, new_data, window):\n    if len(data_queue) < window:\n        data_queue.append(new_data)\n        current_sum += new_data\n    else:\n        oldest_data = data_queue.pop(0)\n        current_sum += new_data - oldest_data\n        data_queue.append(new_data)\n\n    expected_avg = current_sum // window\n    \n    return expected_avg, current_sum\n\nasync def int_to_unsigned_binary(value, bit_width):\n mask = (1 << bit_width) - 1\n unsigned_value = value & mask\n return f\"{unsigned_value:0{bit_width}b}\"\n\n", "src/test_dbi_encoder.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport time\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_dbi_encoder(dut):\n    # Seed the random number generator with the current time or another unique value\n    random.seed(time.time())\n    # Start clock\n    cocotb.start_soon(Clock(dut.clk, 100, units='ns').start())\n    \n    \n    # Initialize DUT\n    #print(f'data_in before initialization = {dut.data_in.value}') ####need to remove\n    await hrs_lb.dut_init(dut) \n    data_in = 0 \n    dut.data_in.value = data_in\n    await FallingEdge(dut.clk)\n    #print(f'data_in after initialization   = {dut.data_in.value}') ####need to remove\n    # Apply reset \n    await hrs_lb.reset_dut(dut.rst_n, dut)\n    print(f'data_out after reset  = {dut.data_out.value}') ####need to remove\n\n\n    await FallingEdge(dut.clk)\n    \n    prev_dat1 = dut.data_out.value[39:20]\n    prev_dat0 = dut.data_out.value[19:0]\n    #print(f'prev data_out after first data  = {(prev_dat1),(prev_dat0)}')\n    data_in = 0xaa_aaaf_ffff\n    dut.data_in.value = data_in\n    start = 20\n    end = 39\n    data_in1 = (data_in >> start) & ((1 << (end - start + 1)) - 1)\n    \n    start = 0\n    end = 19\n    data_in0 = (data_in >> start) & ((1 << (end - start + 1)) - 1)\n    #print(f'data_in after first data  = {bin(data_in1),bin(data_in0)}')\n    \n    xor_result0 = prev_dat0.integer ^ data_in0\n    xor_result1 = prev_dat1.integer ^ data_in1\n\n    count_ones0 = bin(xor_result0).count('1')\n    count_ones1 = bin(xor_result1).count('1')\n\n    print(f'count  = {count_ones0,count_ones1}')\n\n\n    if count_ones0 > 10:  # If the value is greater than 10 \n        cntrl0 = 1\n        out_data0 = ~data_in0\n    else:\n        cntrl0 = 0\n        out_data0 = data_in0\n\n    if count_ones1 > 10:  # If the value is greater than 10 \n        cntrl1 = 1\n        out_data1 = ~data_in1\n    else:\n        cntrl1 = 0\n        out_data1 = data_in1\n\n    print(f'control outdata = {cntrl1,cntrl0}')\n    #print(f'expected outdata = {bin(out_data1),bin(out_data0)}')\n\n    exp_out_data1 = bin(out_data1)[-20:]\n    exp_out_data0 = bin(out_data0)[-20:]\n\n\n    #print(f'expected outdata = {exp_out_data1,exp_out_data0}')\n    \n    await FallingEdge(dut.clk)\n    ##data_out = dut.data_out.value\n    pres_dat1 = dut.data_out.value[39:20].binstr\n    pres_dat0 = dut.data_out.value[19:0].binstr\n    print(f'dut  outdata = {pres_dat1,pres_dat0}')\n    print(f'expected  outdata = {exp_out_data1,exp_out_data0}')\n\n    if pres_dat1 == exp_out_data1 and pres_dat0 == exp_out_data0 :  # If the value is greater than 10 \n         print(\"[INFO] Test 'test_dbi_encoder' completed successfully.\")\n    else:\n        print(\"[INFO] Test 'test_dbi_encoder' failed.\")\n    ", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=False,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module)\n\n# random test\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_dbi_encoder(test):\n    runner()"}}}
{"id": "cvdp_copilot_decode_firstbit_0001", "categories": ["cid003", "medium"], "input": {"prompt": "The first-bit decoder RTL module implements a decoder logic that returns the index of the lowest bit set in a vector. It decodes the first set bit in a parameterized input data vector (`In_Data`). It uses pipelined stages to distribute the processing load, with the number of pipeline registers determined by the parameter `PlRegs_g`. The goal is to locate the first set bit in the input data and propagate the result through the pipeline stages while maintaining output validity.\n\n---\nDesign and implement an RTL design for this first-bit decoder module with the following design specifications :\n\n### **Design Specifications:**\n\n1. **Pipeline Architecture:**\n   - The input data vector (`In_Data`) is processed across multiple pipeline stages. Each stage is responsible for passing the intermediate result (i.e., the first set bit) through the pipeline until it reaches the output.\n   - The pipeline depth is controlled by `PlRegs_g`. As `PlRegs_g` increases, more stages are introduced, which increases the number of clock cycles (latency) required for the valid signal (`Out_Valid`) to propagate from input to output.\n\n2. **Parameterization and Scalability:**\n   - The design must efficiently scale with varying input widths (`InWidth_g`). The module supports input widths that are not powers of two, handling them without unnecessary resource utilization.\n   - To handle non-power-of-two input widths, the input vector is padded internally to the nearest power of two, ensuring accurate processing.\n   \n3. **Input and Output Specifications:**\n   - **Input Handling:** If `InReg_g` is enabled (`InReg_g = 1`), the input data (`In_Data`) and its validity signal (`In_Valid`) are registered on the rising clock edge. Otherwise, the input is passed directly to the logic.\n   - **Output Behavior:** If `OutReg_g` is enabled (`OutReg_g = 1`), the outputs (`Out_FirstBit`, `Out_Found`, and `Out_Valid`) are registered before being sent out. These outputs indicate the position of the first set bit, the presence of any set bit, and the validity of the output, respectively.\n\n4. **Latency and Pipeline Depth:**\n   - The parameter `PlRegs_g` determines the pipeline depth, introducing additional clock cycles to propagate valid signals. The design should ensure that as `PlRegs_g` increases, the number of clock cycles required to produce valid output also increases.\n   The module's total latency is affected by the depth of the pipeline. For example, when `PlRegs_g = 0`, the detection happens in one cycle, whereas `PlRegs_g = 1` splits the detection across two stages, requiring two cycles.\n\n5. **Edge Case Handling:**\n   - If `In_Data` contains no set bits (i.e., all zeros), the output `Out_Found` should be `0`, and `Out_FirstBit` should be reset to `0`.\n   - For inputs containing a single set bit, the module should correctly detect and output the position of that bit.\n\n---\n\n### **Parameters:**\n\n| Name      | Default | Description                                                  |\n|-----------|---------|--------------------------------------------------------------|\n| InWidth_g | 32      | Width of the input data vector                                |\n| InReg_g   | 1       | Enables input register for latching data                      |\n| OutReg_g  | 1       | Enables output register for latching results                  |\n| PlRegs_g  | 1       | Number of pipeline registers for first-bit decoding logic. The value of `PlRegs_g` controls the number of stages |\n\n### **Interfaces:**\n\n#### Control Signals:\n\n| Name | In/Out | Length | Description                                   |\n| :--- | :----- | :----- | :-------------------------------------------- |\n| Clk  | in     | 1      | Clock signal (rising edge)                    |\n| Rst  | in     | 1      | Reset signal (high-active, asynchronous)       |\n\n#### Input Data:\n\n| Name     | In/Out | Length       | Description                                  |\n| :------- | :----- | :----------- | :------------------------------------------- |\n| In_Data  | in     | `InWidth_g`  | Input data vector                            |\n| In_Valid | in     | 1            | Valid indication for `In_Data`               |\n\n#### Output Data:\n\n| Name         | In/Out | Length                  | Description                                                  |\n| :----------- | :----- | :---------------------- | :----------------------------------------------------------- |\n| Out_FirstBit | out    | $clog2(`InWidth_g`)      | Index of the lowest set bit in `In_Data`                      |\n| Out_Found    | out    | 1                       | Set to '1' if any bit in `In_Data` was set                    |\n| Out_Valid    | out    | 1                       | Indicates valid data on `Out_FirstBit` and `Out_Found`        |\n\n---\n\n### **Behavioral Definition:**\n\n- **Reset Behavior:** The reset signal (`Rst`) is asynchronous and active-high. On reset, the internal pipeline registers and output signals are set to zero.\n- **Clocking:** The module operates on the rising edge of the clock (`Clk`), and all sequential elements must be synchronized with this clock.\n\n---\n\n### **Example:**\n\n1. **Input Data:** `In_Data = 32'h0000_0080`, `In_Valid = 1'b1`\n   - Expected Output: `Out_FirstBit = 7`, `Out_Found = 1`, `Out_Valid = 1`\n\n2. **Reset:** Upon asserting the reset (`Rst = 1`), the outputs should reset to `Out_FirstBit = 0`, `Out_Found = 0`, and `Out_Valid = 0`.\n\n---\n\n### **Constraints:**\n\nThe parameter `PlRegs_g` should remain within a reasonable range based on the input width (`InWidth_g`) to ensure efficient performance and avoid excessive pipeline depth. A suitable range for `PlRegs_g` is:\n\n```\n0 <= PlRegs_g <= (BinBits_c / 2) - 1\n```\n\nwhere `BinBits_c = $clog2(InWidth_g)` represents the number of bits required to encode the index of the first set bit.\n\nFor example:\n- If `InWidth_g = 32`, then `BinBits_c = 5`, and the valid range for `PlRegs_g` is 0 to 1.\n- This ensures that the number of pipeline stages is balanced, avoiding unnecessary delays while distributing the decoding logic efficiently across multiple cycles.\n\n---", "context": {}}, "output": {"response": "", "context": {"rtl/cvdp_copilot_decode_firstbit.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cvdp_copilot_decode_firstbit.sv \nTOPLEVEL        = cvdp_copilot_decode_firstbit\nMODULE          = test_decode_firstbit\nPYTHONPATH      = /src\nHASH            = 1-first-bit-decoder-logic-rtl-code", "src/test_decode_firstbit.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.result import TestFailure\nimport random\n\n@cocotb.test()\nasync def test_decode_firstbit(dut):\n    \"\"\"Testbench for olo_base_decode_firstbit module.\"\"\"\n\n    # Parameters\n    CLK_PERIOD = 10  # Clock period in nanoseconds\n\n    # Create a clock on dut.Clk\n    cocotb.start_soon(Clock(dut.Clk, CLK_PERIOD, units='ns').start())\n\n    # Initialize inputs\n    dut.Rst.value = 1\n    dut.In_Data.value = 0\n    dut.In_Valid.value = 0\n\n    # Wait for a few clock cycles\n    await Timer(CLK_PERIOD * 5, units='ns')\n    dut.Rst.value = 0\n\n    # Define test vectors\n    test_vectors = [\n        0x00000000,  # No bits set\n        0x00000001,  # First bit set\n        0x00000002,  # Second bit set\n        0x80000000,  # Last bit set\n        0x00010000,  # Middle bit set\n        0xFFFFFFFF,  # All bits set\n        0xFFFFFFFE,  # All but first bit set\n        0x7FFFFFFF,  # All but last bit set\n        0x00008000,  # Random bit set\n        0x00000008,  # Another random bit set\n        0xAAAAAAAA,  # Alternating bits starting with '1'\n        0x55555555,  # Alternating bits starting with '0'\n        0x0000FFFF,  # Lower half bits set\n        0xFFFF0000,  # Upper half bits set\n        0x00000010,  # Single bit set at position 4\n        0x00020000,  # Single bit set at position 17\n        0x00000004,  # Single bit set at position 2\n        0x40000000,  # Single bit set at position 30\n        0x00800000,  # Single bit set at position 23\n        0x00400000,  # Single bit set at position 22\n        0x00000400,  # Single bit set at position 10\n    ]\n\n    # Apply predefined test vectors\n    for data_in in test_vectors:\n        await apply_test_vector(dut, data_in, CLK_PERIOD)\n\n    # Apply random test vectors\n    for _ in range(20):  # Increased from 10 to 20 random tests\n        random_data = random.getrandbits(len(dut.In_Data))\n        await apply_test_vector(dut, random_data, CLK_PERIOD)\n\nasync def apply_test_vector(dut, data_in, CLK_PERIOD):\n    \"\"\"Apply a single test vector to the DUT.\"\"\"\n\n    # Apply input data and valid signal\n    dut.In_Data.value = data_in\n    dut.In_Valid.value = 1\n\n    await RisingEdge(dut.Clk)\n    dut.In_Valid.value = 0\n\n    # Wait for the output to become valid\n    while True:\n        await RisingEdge(dut.Clk)\n        if dut.Out_Valid.value:\n            break\n\n    # Read output values\n    out_firstbit = dut.Out_FirstBit.value.integer\n    out_found = dut.Out_Found.value.integer\n\n    # Calculate expected results\n    expected_index = find_first_set_bit(data_in)\n    expected_found = 1 if expected_index != -1 else 0\n\n    # Compare DUT output with expected values\n    if out_found != expected_found:\n        dut._log.error(f\"Out_Found mismatch: Input={hex(data_in)}, Expected {expected_found}, Got {out_found}\")\n        raise TestFailure(\"Out_Found signal mismatch\")\n\n    if expected_found:\n        if out_firstbit != expected_index:\n            dut._log.error(f\"Out_FirstBit mismatch: Input={hex(data_in)}, Expected Index={expected_index}, Got {out_firstbit}\")\n            raise TestFailure(\"Out_FirstBit signal mismatch\")\n        else:\n            dut._log.info(f\"PASS: Input={hex(data_in)}, Expected Index={expected_index}, Output Index={out_firstbit}\")\n    else:\n        dut._log.info(f\"PASS: Input={hex(data_in)}, No bits set as expected\")\n\ndef find_first_set_bit(data_in):\n    \"\"\"Find the index of the first set bit in data_in.\"\"\"\n    for idx in range(data_in.bit_length()):\n        if (data_in >> idx) & 1:\n            return idx\n    return -1  # Return -1 if no bits are set\n\n# Pytest wrapper\nimport os\nfrom cocotb.runner import get_runner\nimport pytest\nimport pickle\n\n\n@pytest.mark.parametrize(\"in_width_g\", [8, 16, 32])\n@pytest.mark.parametrize(\"output_format_g\", [0, 1])\ndef test_decode_firstbit(in_width_g, output_format_g):\n    \"\"\"Pytest wrapper to run the cocotb test with different parameters.\"\"\"\n\n    dut_path = os.path.abspath(\"cvdp_copilot_decode_firstbit.v\")\n    \n    # Define the module name (this file without extension)\n    module_name = os.path.splitext(os.path.basename(__file__))[0]\n    \n    sim_build = os.path.abspath(f\"sim_build_{in_width_g}_{output_format_g}\")\n    \n    parameters = {}\n    parameters['InWidth_g'] = in_width_g\n    parameters['OutputFormat_g'] = output_format_g\n\n    # Convert parameters to dictionary required by cocotb-test\n    extra_env = {f'PARAM_{k}': str(v) for k, v in parameters.items()}\n\n    runner = get_runner(sim)\n    runner.build(\n        verilog_sources=[dut_path],\n        toplevel=\"cvdp_copilot_decode_firstbit\",\n        module=module_name,  # Name of the Python test module (without .py)\n        parameters=parameters,\n        sim_build=sim_build,\n        extra_env=extra_env,\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom cocotb.runner import get_runner\nimport pytest\nimport pickle\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\n@pytest.mark.tb\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\n#if __name__ == \"__main__\":\n#    test_runner()"}}}
{"id": "cvdp_copilot_digital_dice_roller_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design a Digital Dice Roller that controls rolling of a 6-sided die. This module will have a counter which counts between 1 and 6 during every positive edge of the clock when the button input is HIGH and outputs the dice value when the button becomes LOW. \n\n### Project Specifications\n\n**Input Signals:**\n\n- `clk`: System clock signal to synchronize the FSM transitions and counter.\n- `reset_n`: Asynchronous active LOW reset. Keeps the `dice_value` at 000 when LOW.\n- `button`(1-bit) : A control signal representing a button press. When button is HIGH, the FSM will cycle through dice \nvalues from 1 to 6. When button is LOW, the FSM will stop counting the value. The last value when button was HIGH will be the output of dice\n\n**Output Signal:**\n\n- `dice_value[2:0]`(3-bit): A 3-bit output representing the dice result, with valid values from 1 to 6.\n\n**Functional Requirements:**\n\n  - The Finite State Machine (FSM) has to operate between IDLE and ROLLING states\n  - The design should start the FSM in an `IDLE` state, where `dice_value` remains constant.\n  - When `button` is pressed at HIGH, the FSM transitions to a `ROLLING` state, where it cycles through values from 1 to 6 through an internal 3-bit register `counter`.\n  - When the `button` is released at LOW, the FSM returns back to the `IDLE` state, displaying the last dice value shown in `ROLLING`.\n  - The design should ensure that the output value always remains within the 1 to 6 range.\n\n### Example operation\n\n```waveform\n{\n    \"signal\": [\n        { \"name\": \"clk\", \"wave\": \"p............\" },\n        { \"name\": \"reset_n\", \"wave\": \"0..1.........\" },\n        { \"name\": \"button\", \"wave\": \"0...1....0...\", \"data\": [ \"head\", \"body\", \"tail\" ] },\n        { \"name\": \"counter\", \"wave\": \"...1234560...\",\"data\":[1,2,3,4,5,6] },\n        { \"name\": \"dice_value\", \"wave\": \"0........5..\",\"data\":[5] }\n    ]\n}\n```", "context": {}}, "output": {"response": "", "context": {"rtl/digital_dice_roller.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest --log-cli-level=INFO -o cache_dir=/code/rundir/.cache -sv /src/test_runner.py\n    # command     : python3 /src/test_runner.py\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nWAVE            = 1\nVERILOG_SOURCES = /code/rtl/digital_dice_roller.sv\nTOPLEVEL        = digital_dice_roller\nMODULE          = test_dice_roller\nPYTHONPATH      = /src\nHASH            = 0f7cefc9b976ab5cf67b510c3a12f648c068e236", "src/test_dice_roller.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nimport random\n\nasync def reset_dut(dut):\n    \"\"\"Assert the active-low reset signal and release it.\"\"\"\n    dut.reset.value = 0  # Assert reset (active-low)\n    await Timer(20, units=\"ns\")  # Hold reset for 20ns\n    dut.reset.value = 1  # Release reset\n    await Timer(10, units=\"ns\")  # Wait for reset release\n\nasync def dice_roll_test(dut):\n    \"\"\"Parameterized test for the digital dice roller using DICE_MAX from the RTL design.\"\"\"\n\n    # Get the maximum dice value directly from the design\n    DICE_MAX = int(dut.DICE_MAX.value)\n\n    # Initialize signals\n    dut.button.value = 0\n    await reset_dut(dut)  # Apply reset at the beginning\n\n    # Test case 1: Normal operation - Button press and release to roll dice\n    press_duration = 10  # Duration in mili seconds\n    dut._log.info(f\"Test Case 1: long Button press, press duration = {press_duration} ms\")\n    dut.button.value = 1  # Press the button to start rolling\n    await Timer(press_duration, units=\"ms\")  # Hold the button for 10 mili seconds to simulate rolling\n\n    dut.button.value = 0  # Release the button to stop rolling\n    await Timer(50, units=\"ns\")  # Wait for dice to stop\n\n    # Check if dice_value is within valid range\n    dice_value = int(dut.dice_value.value)\n    assert 1 <= dice_value <= DICE_MAX, f\"FAIL: Dice stopped at invalid value: {dice_value}\"\n    dut._log.info(f\"PASS: Dice stopped at valid value: {dice_value} after {press_duration} ms press\")\n\n    # Test case 2: Short button press\n    press_duration = 10  # Duration in microseconds\n    dut._log.info(f\"Test Case 2: Short button press, press duration = {press_duration} us\")\n    dut.button.value = 1  # Press the button to start rolling\n    await Timer(press_duration, units=\"us\")  # Hold the button for a short time\n\n    dut.button.value = 0  # Release the button to stop rolling\n    await Timer(50, units=\"ns\")  # Wait for dice to stop\n\n    # Check if dice_value is within valid range\n    dice_value = int(dut.dice_value.value)\n    assert 1 <= dice_value <= DICE_MAX, f\"FAIL: Dice stopped at invalid value: {dice_value}\"\n    dut._log.info(f\"PASS: Dice stopped at valid value: {dice_value} after {press_duration} us press\")\n\n    # Test case 3: Long button press\n    press_duration = 200  # Duration in ns\n    dut._log.info(f\"Test Case 3: Long button press, press duration = {press_duration} ns\")\n    dut.button.value = 1  # Press the button to start rolling\n    await Timer(press_duration, units=\"ns\")  # Hold the button for a long time\n\n    dut.button.value = 0  # Release the button to stop rolling\n    await Timer(50, units=\"ns\")  # Wait for dice to stop\n\n    # Check if dice_value is within valid range\n    dice_value = int(dut.dice_value.value)\n    assert 1 <= dice_value <= DICE_MAX, f\"FAIL: Dice stopped at invalid value: {dice_value}\"\n    dut._log.info(f\"PASS: Dice stopped at valid value: {dice_value} after {press_duration} ns press\")\n\n    # Test case 4: Random button press durations\n    for i in range(5):\n        press_duration = random.randint(50, 150)  # Random press duration between 50ns and 150ns\n        dut._log.info(f\"Test Case 4.{i+1}: Random button press, press duration = {press_duration} ns\")\n\n        dut.button.value = 1  # Press the button to start rolling\n        await Timer(press_duration, units=\"ns\")  # Hold the button for a random duration\n\n        dut.button.value = 0  # Release the button to stop rolling\n        await Timer(50, units=\"ns\")  # Wait for dice to stop\n\n        # Check if dice_value is within valid range\n        dice_value = int(dut.dice_value.value)\n        assert 1 <= dice_value <= DICE_MAX, f\"FAIL: Dice stopped at invalid value: {dice_value}\"\n        dut._log.info(f\"PASS: Dice stopped at valid value: {dice_value} after {press_duration} ns press\")\n\n@cocotb.test()\nasync def test_dice_roller(dut):\n    \"\"\"Main test for the digital dice roller, using parameterized DICE_MAX from RTL design.\"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await dice_roll_test(dut)\n\n@cocotb.test()\nasync def test_reset_functionality(dut):\n    \"\"\"Test the reset functionality of the dice roller.\"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    \n    # Reset the DUT and check if it resets correctly\n    dut._log.info(\"Test Case 5: Reset functionality\")\n    await reset_dut(dut)\n\n    # Check that dice_value is reset to 1 after reset\n    dice_value = int(dut.dice_value.value)\n    assert dice_value == 1, f\"FAIL: Dice value did not reset correctly, found: {dice_value}\"\n    dut._log.info(\"PASS: Dice value reset correctly to 1 after reset\")\n\n    # Test reset during rolling\n    dut._log.info(\"Test Case 6: Asserting reset during rolling\")\n    dut.button.value = 1  # Press button to start rolling\n    await Timer(50, units=\"ns\")  # Start rolling\n\n    dut.reset.value = 0  # Assert reset (active-low) during roll\n    await Timer(20, units=\"ns\")  # Hold reset for 20ns\n    dut.reset.value = 1  # Release reset\n\n    # Check that dice_value is reset to 1 after reset\n    dice_value = int(dut.dice_value.value)\n    assert dice_value == 1, f\"FAIL: Dice value did not reset correctly during rolling, found: {dice_value}\"\n    dut._log.info(\"PASS: Dice value reset correctly to 1 during rolling after reset\")\n\n@cocotb.test()\nasync def test_hold_reset_low(dut):\n    \"\"\"Test holding reset low to verify dice_value stays reset.\"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Hold reset low\n    dut.reset.value = 0  # Assert reset (active-low)\n    dut._log.info(\"Test Case 7: Holding reset low to verify dice_value stays reset\")\n\n    # Wait for a period to verify dice_value remains reset\n    await Timer(100, units=\"ns\")  # Hold reset for 100ns\n\n    # Check that dice_value remains at 1 while reset is low\n    dice_value = int(dut.dice_value.value)\n    assert dice_value == 1, f\"FAIL: Dice value did not remain reset, found: {dice_value}\"\n    dut._log.info(\"PASS: Dice value remained at 1 while reset was held low\")\n\n    # Release reset\n    dut.reset.value = 1\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_digital_stopwatch_0001", "categories": ["cid003", "easy"], "input": {"prompt": "# Digital Stopwatch Design\n\nDesign a digital stopwatch module using SystemVerilog that is capable of counting hours, minutes, and seconds, and allow users to start, stop, and reset the stopwatch as needed. \n\n## Interface:\n\n### Module Name:\n- The module must be named `dig_stopwatch`.\n\n### Parameters:\n- **CLK_FREQ**: Defines the input clock frequency in Hz with a default value of 50,000,000 Hz. This frequency should be an integer frequency in Hz greater than the minimum value of 1 Hz.\n\n### Inputs:\n- `clk`: Clock signal of the digital stopwatch for 1Hz pulse generation\n- `reset`: Asynchronous active-high reset signal.\n- `start_stop`: Start/stop control that controls if the stopwatch is running or paused. \n\n### Outputs:\n- `[5:0] seconds`: 6-bit counter for seconds (0-59).\n- `[5:0] minutes`: 6-bit counter for minutes (0-59).\n- `hour`: Represents a one-bit signal that updates to 1 when one hour has passed.\n## Requirements:\n\n### Internal Clock Divider and Timing Behavior:\n- The design uses an internal clock divider to count cycles of the input clock (clk) based on the specified frequency (CLK_FREQ). - This divider produces a single pulse each time one full second has elapsed that will update the seconds, minutes, and hour counters, with updates occurring on the rising edge of this pulse.\n- Note: This module does not generate a continuous 1 Hz clock signal. Instead, it produces a single pulse, lasting one period of the input clock, once every second to indicate that one second has passed.\n\n### Stopwatch Operation:\n\n#### Control Signals:\n- The module must include an asynchronous active-high `reset` input to reset the stopwatch, bringing all counters to zero, thereby resetting the stopwatch to 0 seconds, 0 minutes, and 0 hours when asserted high.\n-  The start_stop input should control the stopwatch's run/pause state, where a high signal starts it, and a low signal pauses it without affecting the counters.\n    - When start_stop is high, the stopwatch runs, starting from the paused time if it was previously stopped.\n    - When start_stop is low, the stopwatch pauses, holding the current values of seconds, minutes, and hours.   \n\n#### Behavioral Definitions:\n- The stopwatch will count seconds, minutes, and hour sequentially at the posedge of the generated one-second pulse.\n  - Seconds increment from 0 to 59, then reset to 0 and increment minutes.\n  - Minutes increment from 0 to 59, then reset to 0 and increment hour.\n  - The hour signal is a single bit that sets to 1 after reaching one hour.\n- **Note**: The stopwatch will not count beyond one hour but can reset and restart from zero if reset occurs.\n\n### Edge Cases and Special Handling:\n- When the hour signal is set to 1, the stopwatch will hold its value at 1 hour, 0 minutes, and 0 seconds until the design is reset.\n- If the stopwatch is paused mid-second, mid-minute, or mid-hour, it holds the current values of seconds, minutes, and hour, along with any partial progress within the ongoing count of input clock cycles. When start_stop is asserted high again, the stopwatch resumes counting from the exact point where it was paused.\n\n### Assumptions and Limitations:\n- Assume that the input frequency (CLK_FREQ) is set correctly within given constraints, for the design to generate a valid one-second pulse; invalid scenarios due to incorrect CLK_FREQ settings need not be handled.", "context": {}}, "output": {"response": "", "context": {"rtl/dig_stopwatch.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v \n", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/dig_stopwatch.sv\nTOPLEVEL        = dig_stopwatch\nMODULE          = test_dig_stopwatch\nPYTHONPATH      = /src\nHASH            = 5170dff0cad120a6e068c5af5bcc73e9ceb27085\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_dig_stopwatch.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge,FallingEdge, Timer\nimport random\n\nimport harness_library as hrs_lb\n\nasync def wait_for_seconds(dut, num_seconds):\n    # Wait for a specified number of seconds.\n    for _ in range(num_seconds):\n        await RisingEdge(dut.one_sec_pulse)\n        print(f\"Current Time - Hours: {int(dut.hour.value)}, Minutes: {int(dut.minutes.value)}, Seconds: {int(dut.seconds.value)}\")\n\nasync def check_rollover_conditions(dut, num_seconds):\n    # Check the rollover of seconds, minutes, and hours.\n    for _ in range(num_seconds):\n        await RisingEdge(dut.one_sec_pulse)\n        print(f\"Rollover Current Time - Hour: {int(dut.hour.value)}, Minutes: {int(dut.minutes.value)}, Seconds: {int(dut.seconds.value)}\")\n\n        # Check for seconds rollover\n        if int(dut.seconds.value) == 59 and int(dut.minutes.value) < 59:\n            await RisingEdge(dut.clk)\n            assert int(dut.seconds.value) == 0, \"Error: Seconds did not reset to 0 after reaching 59.\"\n            assert int(dut.minutes.value) > 0, \"Error: Minutes did not increment after seconds rollover.\"\n\n        # Check for minutes rollover\n        if int(dut.minutes.value) == 59 and int(dut.seconds.value) == 59:\n            await RisingEdge(dut.clk)\n            assert int(dut.seconds.value) == 0, \"Error: Seconds did not reset to 0 after reaching 59.\"\n            assert int(dut.minutes.value) == 0, \"Error: Minutes did not reset to 0 after reaching 59.\"\n            assert int(dut.hour.value) == 1, \"Error: Hour did not increment after minutes rollover.\"\n\n        # Check for hours rollover from max value back to zero\n        if int(dut.hour.value) == 1 and int(dut.minutes.value) == 0 and int(dut.seconds.value) == 0 and dut.start_stop.value:\n            await RisingEdge(dut.clk)\n            assert int(dut.hour.value) == 1, \"Error: Hour did not reset to 0 after reaching 1.\"\n            assert int(dut.minutes.value) == 0 and int(dut.seconds.value) == 0, \"Minutes and seconds did not reset to 0 at hour rollover.\"\n\nasync def check_pause_and_resume(dut):\n    # Test that the stopwatch pauses and resumes correctly.\n    dut.start_stop.value = 1\n    await wait_for_seconds(dut, 10)\n    \n    # Pause the stopwatch\n    dut.start_stop.value = 0\n    await RisingEdge(dut.clk)\n    \n    paused_seconds = int(dut.seconds.value)\n    for _ in range(20):\n        await RisingEdge(dut.clk)\n    \n    \n    # Wait to ensure the stopwatch remains paused\n    await RisingEdge(dut.clk)  # Instead of Timer, ensure clock cycle sync\n    assert int(dut.seconds.value) == paused_seconds, \"Error: Stopwatch did not pause correctly.\"\n\n    # Resume the stopwatch and check it continues counting from the same value\n    dut.start_stop.value = 1\n    await wait_for_seconds(dut, 20)\n    assert int(dut.seconds.value) == paused_seconds + 19, \"Error: Stopwatch did not resume correctly.\"\n\nasync def pause_at_random_second(dut):\n    dut.start_stop.value = 1\n    tb_counter = 0  \n    clk_freq = int(dut.CLK_FREQ.value)\n    counter_max = clk_freq - 1 \n\n    # Generate a random number of clock cycles to count before pausing\n    random_pause_duration = random.randint(1, counter_max - 1)\n\n    # Run until reaching the random_pause_duration and keep track with tb_counter\n    for _ in range(random_pause_duration):\n        await RisingEdge(dut.clk)\n        tb_counter += 1\n\n    # Pause the stopwatch\n    dut.start_stop.value = 0\n    await RisingEdge(dut.clk)\n    paused_seconds = int(dut.seconds.value)\n\n    # Ensure the stopwatch remains paused by monitoring tb_counter and checking the seconds in the DUT\n    for _ in range(100):\n        await RisingEdge(dut.clk)\n        assert int(dut.seconds.value) == paused_seconds, \"Error: Stopwatch did not remain paused as expected.\"\n\n    # Resume the stopwatch and continue tracking\n    await RisingEdge(dut.clk)\n    dut.start_stop.value = 1\n\n    remaining_ticks = counter_max - tb_counter  # Calculate the remaining ticks to reach one second\n    for _ in range((remaining_ticks + 1)):\n         await RisingEdge(dut.clk)\n\n    # Verify stopwatch has advanced after the remaining ticks complete\n    await RisingEdge(dut.clk)\n    assert int(dut.seconds.value) == paused_seconds + 1, f\"Stopwatch did not resume correctly from paused second. Expected: {paused_seconds + 1}, Got: {dut.seconds.value}\"\n\nasync def pause_at_random_minute(dut):\n\n    dut.start_stop.value = 1\n    await wait_for_seconds(dut, 50)\n\n    # Pause the stopwatch\n    dut.start_stop.value = 0\n    await RisingEdge(dut.clk)\n    paused_minutes = 0\n\n    # Ensure the stopwatch remains paused\n    for _ in range(3600):\n        await RisingEdge(dut.clk)\n        assert int(dut.minutes.value) == paused_minutes, \"Error: Stopwatch did not remain paused as expected.\"\n\n    # Resume the stopwatch and allow remaining ticks to complete a full minutes\n    dut.start_stop.value = 1\n    await wait_for_seconds(dut, 10)\n\n    # Confirm the stopwatch has moved to the next minute after resuming\n    await RisingEdge(dut.clk)\n    expected_minutes = paused_minutes + 1\n    assert int(dut.minutes.value) == expected_minutes, f\"Stopwatch did not resume correctly from paused minute. Expected: {expected_minutes}, Got: {dut.minutes.value}\"\n\n@cocotb.test()\nasync def test_dig_stopwatch(dut):\n    clk_freq = int(dut.CLK_FREQ.value)\n\n    PERIOD = int(1_000_000_000 / clk_freq)  # Calculate clock period in ns\n    cocotb.start_soon(Clock(dut.clk, PERIOD // 2, units='ns').start())\n    \n    await hrs_lb.dut_init(dut)\n    await hrs_lb.reset_dut(dut.reset, duration_ns=PERIOD, active=False)\n\n    assert dut.seconds.value == 0, f\"Initial seconds is not 0! Got: {dut.seconds.value}\"\n    assert dut.minutes.value == 0, f\"Initial minutes is not 0! Got: {dut.minutes.value}\"\n    assert dut.hour.value == 0, f\"Initial hours is not 0! Got: {dut.hour.value}\"\n\n    await RisingEdge(dut.clk)\n\n    # Start the stopwatch\n    dut.start_stop.value = 1\n    await RisingEdge(dut.clk)\n\n    initial_seconds = int(dut.seconds.value)\n    await wait_for_seconds(dut, 10)\n    assert int(dut.seconds.value) == initial_seconds + 9, f\"Seconds did not increment correctly. Current seconds: {dut.seconds.value}\"\n\n    # Stop the stopwatch  \n    dut.start_stop.value = 0\n    await RisingEdge(dut.clk)\n    stopped_seconds = int(dut.seconds.value)\n\n    await RisingEdge(dut.clk)\n    assert int(dut.seconds.value) == stopped_seconds, \"Stopwatch did not stop as expected.\"\n\n    # Start the stopwatch again\n    dut.start_stop.value = 1\n    await RisingEdge(dut.clk)\n\n    await check_pause_and_resume(dut)\n\n    await check_rollover_conditions(dut, 3600)  # Testing rollovers for 1 hour\n    \n    dut.start_stop.value = 0\n\n    dut.reset.value = 1\n    await RisingEdge(dut.clk)\n\n    assert dut.seconds.value == 0, f\"Reset failed for seconds! Got: {dut.seconds.value}\"\n    assert dut.minutes.value == 0, f\"Reset failed for minutes! Got: {dut.minutes.value}\"\n    assert dut.hour.value == 0, f\"Reset failed for hours! Got: {dut.hour.value}\"\n    await RisingEdge(dut.clk)\n\n    dut.reset.value = 0\n    await pause_at_random_second(dut)\n    await RisingEdge(dut.clk)\n\n    dut.reset.value = 1\n    await RisingEdge(dut.clk)\n    dut.reset.value = 0\n\n    await pause_at_random_minute(dut)\n    await RisingEdge(dut.clk)\n    \n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(CLK_FREQ: int = 200):\n    parameter = {\"CLK_FREQ\": CLK_FREQ}\n    print(f\"[DEBUG] Parameters: {parameter}\")     \n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n\n@pytest.mark.parametrize(\"test\", range(1))\n@pytest.mark.parametrize(\"CLK_FREQ\", [3,50,63])\ndef test_dig_stop(CLK_FREQ, test):\n    runner(CLK_FREQ=CLK_FREQ)\n    \n"}}}
{"id": "cvdp_copilot_edge_detector_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design a System Verilog module named \"`sync_pos_neg_edge_detector` that detects both positive and negative edges on a glitch-free and debounced input signal. The module should output a signal indicating the detection of a positive or negative edge. Each detection signal should be asserted for **one clock cycle** when an edge is detected. The module should also incorporate asynchronous reset functionality.\n\n## Input/Output Specifications\n\n### Inputs:\n- `i_clk`: Clock signal (active on rising edge).\n- `i_rstb`: Asynchronous reset signal (active low).\n- `i_detection_signal`: Glitch-free, debounced signal whose edges are to be detected.\n\n### Outputs:\n- `o_positive_edge_detected`: Asserted for one clock cycle when a positive edge is detected on `i_detection_signal`.\n- `o_negative_edge_detected`: Asserted for one clock cycle when a negative edge is detected on `i_detection_signal`.\n\n## Behavioral Definition\n- When the module detects a **positive edge** (rising transition) on `i_detection_signal`, the output `o_positive_edge_detected` should be asserted high for **one clock cycle**.\n- When the module detects a **negative edge** (falling transition) on `i_detection_signal`, the output `o_negative_edge_detected` should be asserted high for **one clock cycle**.\n- The design assumes that `i_detection_signal` is **glitch-free and debounced**, so no additional debouncing logic is required.\n\n## Reset Behavior\n- When the asynchronous reset (`i_rstb`) is active (low), all outputs (`o_positive_edge_detected` and `o_negative_edge_detected`) should be reset to `0`, and internal state should be cleared.\n- When the reset is de-asserted, normal edge detection should resume.", "context": {}}, "output": {"response": "", "context": {"rtl/sync_pos_neg_edge_detector.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sync_pos_neg_edge_detector.sv\nTOPLEVEL        = sync_pos_neg_edge_detector\nMODULE          = test_sync_pos_neg_edge_detector\nPYTHONPATH      = /src\nHASH            = 1-rtl-for-positive-and-negative-edge-detector-with-glitch-free-input-signals", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()", "src/test_sync_pos_neg_edge_detector.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\n\nasync def reset_dut(dut):\n    \"\"\"Reset the DUT\"\"\"\n    dut.i_rstb.value =0\n    dut.i_detection_signal.value =0\n\n    await FallingEdge(dut.i_clk)\n    dut.i_rstb.value = 1\n    await RisingEdge(dut.i_clk)\n\n# async def edge(dut, initial_value, final_value):\n#     \"\"\"EDGE CREATION\"\"\"\n#     dut.i_detection_signal.value = initial_value\n#     await RisingEdge(dut.i_clk)\n#     dut.i_detection_signal.value = final_value\n\n\n@cocotb.test()\nasync def test_sync_pos_neg_edge_detector(dut):  # dut will be the object for RTL top.\n    # Generate clock\n    cocotb.start_soon(Clock(dut.i_clk, 10, units='ns').start())  # timeperiod= 10ns\n    # Reset the DUT\n    await reset_dut(dut)\n\n    \n    await RisingEdge(dut.i_clk)\n    dut.i_detection_signal.value = 1\n    await RisingEdge(dut.i_clk)\n    await FallingEdge(dut.i_clk)\n    assert dut.o_positive_edge_detected.value==1, f\"output should be 1 not {dut.o_positive_edge_detected.value}\"\n    await RisingEdge(dut.i_clk)\n    dut.i_detection_signal.value = 0\n    await FallingEdge(dut.i_clk)\n    assert dut.o_positive_edge_detected.value==0, f\"output should be 1 not {dut.o_positive_edge_detected.value}\"\n    await FallingEdge(dut.i_clk)\n    assert dut.o_negative_edge_detected.value==1, f\"output should be 1 not {dut.o_negative_edge_detected.value}\"\n    await FallingEdge(dut.i_clk)\n    assert dut.o_negative_edge_detected.value==0, f\"output should be 0 not {dut.o_negative_edge_detected.value}\"\n\n\n   "}}}
{"id": "cvdp_copilot_ethernet_packet_parser_0001", "categories": ["cid003", "medium"], "input": {"prompt": "**Design a Verilog module to extract specific bytes from a data stream in digital logic. The module interfaces with a simple bus protocol commonly used in FPGA designs. The objective is to extract exactly 2 bytes from a specific beat (the 2nd beat in a burst) of the data stream and output them based on the defined protocol signals. Each data transfer, or beat, sends 32-bit chunks (4 bytes) of data in each cycle.**\n\n### Module Interface:\n\n#### Inputs:\n1. **`clk` (Clock Signal):**  \n   - The module operates synchronously with this clock signal.\n  \n2. **`rst` (Reset Signal):**  \n   - A high-level signal that resets the module, returning it to an idle state and clearing internal state variables.\n\n3. **Protocol Signals from Transmitter:**\n   - **`vld` (1-bit Valid Signal):**  \n     - Indicates that the current data on the bus is valid for processing.\n   - **`sof` (1-bit Start-of-Frame Signal):**  \n     - Asserts at the start of a new packet, initializing the extraction process.\n   - **`data` (32-bit Data Signal):**  \n     - Carries 32 bits of data per cycle, with each beat containing exactly 4 valid bytes.\n   - **`eof` (1-bit End-of-Frame Signal):**  \n     - Marks the end of the current data burst, signaling the module to return to an idle state after completing the extraction.\n\n#### Outputs:\n1. **Protocol Signal to Transmitter:**\n   - **`ack` (1-bit Acknowledge Signal):**  \n     - Fixed as `1`, indicating the receiver always accepts valid data without delay.\n\n2. **Field Extraction Outputs:**\n   - **`field` (16-bit Output):**  \n     - Contains the 2 extracted bytes from the 2nd beat of the burst, specifically the most significant two bytes of the `data` signal (`data[31:16]`).\n   - **`field_vld` (1-bit Field Valid Signal):**  \n     - Signals the validity of the extracted `field`. It is asserted after extracting the 2 bytes from the 2nd beat and cleared once `eof` is asserted.\n\n### Internal Design and Operation:\n\n1. **Beat Counter (`beat_cnt`):**\n   - A 4-bit counter that increments with each valid beat (`vld` asserted). It counts the beats in each burst, ensuring the extraction occurs precisely at the 2nd beat.\n\n2. **Temporary Storage (`temp_extracted_field`):**\n   - A 16-bit register for temporarily storing the extracted bytes. Once the correct beat is reached, the `temp_extracted_field` stores the value of `data[31:16]` from the 2nd beat.\n\n3. **State Machine:**\n   - The module utilizes a 2-bit state machine with four states:\n     - **IDLE (0):**  \n       - Awaits the start of a new packet (`vld` and `sof` asserted together). Initializes internal registers, including clearing the `beat_cnt`, `field`, and `field_vld`.\n     - **EXTRACTING (1):**  \n       - Monitors the beats. At the 2nd beat (`beat_cnt == 1`), the module captures `data[31:16]` into `temp_extracted_field` and prepares to complete extraction.\n     - **DONE (2):**  \n       - Assigns the `temp_extracted_field` to the `field` output and asserts `field_vld`. The `field` output is held steady until `eof` is received, indicating burst completion.\n     - **FAIL_FINAL (3):**  \n       - Clears `field_vld` and resets to IDLE upon detecting `eof`, preparing for the next burst.\n\n### Protocol Compliance:\n\n- The module initiates byte extraction when a new burst begins (`sof` asserted).\n- The beat counter (`beat_cnt`) increments for each beat, tracking the position within the burst.\n- Upon reaching the 2nd beat, it extracts the 2 most significant bytes (`data[31:16]`) and outputs them on `field` once `DONE` is entered.\n- The `ack` signal remains constantly high (`1`), as the receiver does not apply backpressure to the transmitter.\n- At the end of the burst (signaled by `eof`), `field_vld` is cleared, and the state returns to `IDLE`.\n", "context": {}}, "output": {"response": "", "context": {"rtl/ethernet_parser.v": ""}}, "harness": {"files": {"Dockerfile.txt": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n  test:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src\n    working_dir: /code/rundir/\n    env_file:\n      - ./src/.env\n    command: pytest -sv -o cache_dir=/code/rundir/.cache /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ethernet_parser.v\nTOPLEVEL        = field_extract\nMODULE          = tb\nPYTHONPATH      = /src\nHASH            = 1-ethernet-parser-verilog-code", "src/tb.py": "import cocotb\nfrom cocotb.triggers import Timer, RisingEdge\n\n@cocotb.test()\nasync def test_field_extract(dut):\n    dut.rst.value = 1\n    dut.clk.value = 0\n    await Timer(10, units=\"ns\")\n    dut.rst.value = 0\n    \n    async def clk_cycle():\n        dut.clk.value = 1\n        await Timer(5, units=\"ns\")\n        dut.clk.value = 0\n        await Timer(5, units=\"ns\")\n\n    dut.vld.value = 0\n    dut.sof.value = 0\n    dut.eof.value = 0\n    dut.data.value = 0\n    await clk_cycle()\n    \n    passed_cases = []\n\n    # Start of frame with valid data\n    dut.vld.value = 1\n    dut.sof.value = 1\n    await clk_cycle()\n    \n    # First beat of data\n    dut.sof.value = 0\n    dut.data.value = 0xAAAA5555\n    await clk_cycle()\n    \n    # Second beat where extraction should occur\n    dut.data.value = 0x1234ABCD\n    await clk_cycle()\n    \n    await clk_cycle()\n    extracted_field = dut.field.value.integer\n    field_valid = dut.field_vld.value.integer\n    print(f\"Extracted field: {hex(extracted_field)}, Field valid: {field_valid}\")\n    \n    try:\n        assert extracted_field == 0x1234, f\"Expected field=0x1234, Got={hex(extracted_field)}\"\n        assert field_valid == 1, f\"Expected field_vld=1, Got={field_valid}\"\n        passed_cases.append(\"Field Extraction Test\")\n    except AssertionError as e:\n        print(f\"Field Extraction Test failed: {e}\")\n    \n    # End of frame\n    dut.eof.value = 1\n    await clk_cycle()\n    \n    try:\n        assert dut.field_vld.value == 0, f\"Expected field_vld=0 after EOF, Got={dut.field_vld.value}\"\n        passed_cases.append(\"End of Frame Test\")\n    except AssertionError as e:\n        print(f\"End of Frame Test failed: {e}\")\n\n    dut.eof.value = 0\n    dut.vld.value = 0\n    await clk_cycle()\n    \n    print(f\"All test cases passed: {passed_cases}\")\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom cocotb_tools.runner import get_runner\nimport pytest\nimport pickle\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\n@pytest.mark.tb\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n   test_runner()"}}}
{"id": "cvdp_copilot_events_to_apb_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design a SystemVerilog `apb_controller` module for handling event-based write transactions with an Advanced Peripheral Bus (APB) interface. The module should control APB signals for write operations triggered by external input signals along with a unique address and a data input, ensuring adherence to the APB protocol. Additionally, the design should include a timeout mechanism to prevent indefinite stalling if the peripheral does not respond within a specified period. This design should only support write operations and not read transactions.\n\n### APB Protocol Overview\n\nThe Advanced Peripheral Bus (APB) is a simple, low-latency bus protocol often used to connect peripheral devices in a system. APB operates with a structured two-phase transaction sequence, consisting of a **SETUP** phase and an **ACCESS** phase. This controller is designed to support **write transactions only**, ensuring a straightforward approach to interfacing with peripherals on the APB.\n\n### Design Requirements\n\n- Event-Based Transactions:\n    - The controller must handle three independent events: A, B, and C.\n    - Each event includes a 32-bit address and 32-bit data for APB write transactions.\n   -  Events are triggered by respective select_*_i signals (`select_a_i`, `select_b_i`, `select_c_i`).\n\n#### Transaction Flow and Timing\n\nThe transactions follow a three-state flow:\n1. **IDLE State**:\n     - When any event select signal is asserted, the controller captures the corresponding address and data into internal signals.\n     - If multiple select signals are asserted simultaneously, the controller prioritizes them as `select_a_i` (highest priority), followed by `select_b_i`, and then `select_c_i` (lowest priority).\n     - The `IDLE` phase lasts for one clock cycle.\n     - The default state is **IDLE** state, which it enters after a reset and remains in when no transactions are active   \n\n2. **SETUP Phase**:\n   - After the `IDLE` phase, the controller transitions to the `SETUP` phase.\n   - in the `SETUP` phase the controller asserts `apb_psel_o`, and `apb_pwrite_o` and set up `apb_paddr_o` and `apb_pwdata_o` with the selected address and data.\n   - In this phase, `apb_penable_o` remains deasserted.\n   - The `SETUP` phase lasts for one clock cycle.\n\n3. **ACCESS Phase**:\n   - After the `SETUP` phase, the controller transitions to the `ACCESS` phase.\n   - In `ACCESS`, `apb_penable_o` is asserted high to signal that the data transfer is in progress.\n   - The controller remains in this phase, waiting for `apb_pready_i` from the peripheral to be asserted high.\n   - In `ACCESS` phase, the signals `apb_psel_o`, `apb_pwrite_o`, `apb_paddr_o`, and `apb_pwdata_o` must remain stable.\n   - **Write Transfer with Wait**: If `apb_pready_i` is delayed, the controller stays in `ACCESS` until `apb_pready_i` goes high.\n   - **Write Transfer without Wait**: If  `apb_pready_i` goes high in the same clock cycle that the controller enters the `ACCESS` phase, the controller completes the transaction within the same cycle.\n\n   - **Timeout Mechanism**:\n      - While in the `ACCESS` phase, a 4-bit timeout counter increments each clock cycle if `apb_pready_i` remains low.\n      - If `apb_pready_i` is not asserted within 15 cycles after entering `ACCESS` state, the timeout counter resets the controller to the `IDLE` state and sets all outputs to 0 at the next positive edge, effectively aborting the transaction and preventing indefinite stalling.\n      - The timeout counter resets to zero after a successful transaction or when the controller returns to the `IDLE` state.\n\n   - **Return to IDLE**:\n      - After a successful transaction (when `apb_pready_i` is asserted), the controller returns to the `IDLE` state, with both `apb_psel_o` and `apb_penable_o` getting deasserted.\n      - A new transaction can only start when a select signal (`select_a_i`, `select_b_i`, or `select_c_i`) is asserted and both `apb_psel_o` and `apb_penable_o` are low, ensuring only one transaction occurs at a time.\n\n#### **Total Latency for the Transaction**\n- **Minimum Latency**: From the triggering of an event, the minimum number of clock cycles required to complete a transaction and return to `IDLE` without wait states (`apb_pready_i` is asserted immediately) is **3 cycles**:\n  - **SETUP State**: 1 cycle.\n  - **ACCESS State**: 1 cycle.\n  - **Transition to IDLE**: 1 cycle to de-assert signals and return to `IDLE`.\n- **Additional Latency**: If `apb_pready_i` is delayed, additional cycles are spent in the `ACCESS` state until the peripheral is ready or a timeout occurs.\n\n#### Inputs:\n- **`clk`**: Clock signal, active on the rising edge.\n- **`reset_n`**: Active-low asynchronous reset signal that resets the controller to the `IDLE` state, clears the timeout counter, and sets all registers and outputs to 0.\n- **`select_a_i`**: Active-high control signal to initiate a transaction for Event A.\n- **`select_b_i`**: Active-high control signal to initiate a transaction for Event B.\n- **`select_c_i`**: Active-high control signal to initiate a transaction for Event C.\n- **`addr_a_i [31:0]`**: Address input for Event A.\n- **`data_a_i [31:0]`**: Data input for Event A.\n- **`addr_b_i [31:0]`**: Address input for Event B.\n- **`data_b_i [31:0]`**: Data input for Event B.\n- **`addr_c_i [31:0]`**: Address input for Event C.\n- **`data_c_i [31:0]`**: Data input for Event C.\n- **`apb_pready_i`**:  Ready signal from the peripheral, active high. It indicates when the peripheral is ready to complete the transaction. The controller checks this signal in the `ACCESS` phase to determine transaction completion.\n\n#### Outputs:\n- **`apb_psel_o`**: An active-high signal, asserted during `SETUP`, to select the peripheral for an APB transaction.\n- **`apb_penable_o`**: An active-high signal, asserted during the `ACCESS` phase, indicating the transaction is in progress.\n- **`apb_pwrite_o`**: An active-high signal indicating a write operation, asserted during the `SETUP` and maintained in the `ACCESS` phase.\n- **`apb_paddr_o [31:0]`**: 32-bit address output for the transaction, determined by the selected event's address input (`addr_a_i`, `addr_b_i`, or `addr_c_i`). Defaults to 0 in the `IDLE` state.\n- **`apb_pwdata_o [31:0]`**: 32-bit data output for the write operation, based on the selected event's data input (`data_a_i`, `data_b_i`, or `data_c_i`). Defaults to 0 in the `IDLE` state.\n\n### Constraints:\n- Assume that event signals `select_a_i`, `select_b_i`, and `select_c_i` are pulse signals high for one clock cycle and are synchronous to the clock. \n- Assume that input data and addresses will be stable inputs when the events are triggered.\n- If multiple events are triggered simultaneously, only the highest-priority event will be processed, and the rest will be discarded.\n- Assume that a new event will be triggered only when the controller is in an `IDLE` state after the de-assertion of both `apb_psel_o` and `apb_penable_o` for the previous transaction.", "context": {}}, "output": {"response": "", "context": {"rtl/apb_controller.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v   ", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/apb_controller.sv\nTOPLEVEL        = apb_controller\nMODULE          = test_apb_controller\nPYTHONPATH      = /src\nHASH            = 7d9b2111755896b5c9386246d2c42ff853051241\n", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import Timer, RisingEdge, FallingEdge\nimport random\n\nasync def async_reset_dut(dut):\n\n    dut.reset_n.value = 1\n    await FallingEdge(dut.clk)\n    dut.reset_n.value = 0\n    await Timer(2, units=\"ns\")  # Small delay\n    assert dut.apb_psel_o.value == 0, \"APB select should be 0 at a reset\"\n    assert dut.apb_penable_o.value == 0, \"APB enable should be 0 at a reset\" \n    assert dut.apb_pwrite_o.value == 0, \"APB write signal should be 0 at a reset\" \n    assert dut.apb_paddr_o.value == 0, f\"APB address should be 0 at a reset\"\n    assert dut.apb_pwdata_o.value == 0, f\"APB data should be 0 at a reset\"  \n    await RisingEdge(dut.clk)\n    dut.reset_n.value = 1\n    await RisingEdge(dut.clk)\n\nasync def run_apb_test_with_delay(dut, select_signal, expected_addr, expected_data):\n\n    # Apply stimulus for the selected signal\n    select_signal.value = 1\n    dut.apb_pready_i.value = 0  # Initially APB is not ready\n\n    # Wait for a few clock cycles to simulate state transitions\n    await RisingEdge(dut.clk)\n    select_signal.value = 0 \n\n    # latency count\n    latency_sel = 0\n    while (dut.apb_psel_o.value == 0) and (dut.apb_pwrite_o.value == 0):\n        await RisingEdge(dut.clk)\n        latency_sel += 1\n\n    # SETUP state checks\n    assert latency_sel == 1, f\"Latency from `apb_psel_o` should be 1 cycle, but got {latency_sel}\"    \n    assert dut.apb_psel_o.value == 1, \"APB select signal should be high in SETUP state\"\n    assert dut.apb_penable_o.value == 0, \"APB enable signal should be deasserted in ACCESS state\"\n    assert dut.apb_pwrite_o.value == 1, \"APB write signal should be high in SETUP state\"\n    assert dut.apb_paddr_o.value == expected_addr, f\"APB address should be {hex(expected_addr)} in SETUP state\"\n    assert dut.apb_pwdata_o.value == expected_data, f\"APB data should be {hex(expected_data)} in SETUP state\"\n \n    # latency count\n    latency_enable = 0\n    while dut.apb_penable_o.value == 0:\n        await RisingEdge(dut.clk)\n        latency_enable += 1\n\n    # ACCESS state checks\n    # Validate that `apb_penable_o` is asserted exactly 1 clock cycle after `apb_psel_o`\n    await RisingEdge(dut.clk)\n    assert latency_enable == 1, f\"Latency from `apb_psel_o` to `apb_penable_o` should be 1 cycle, but got {latency_enable}\"\n    assert dut.apb_penable_o.value == 1, \"APB enable signal should be high in ACCESS state\"\n    assert dut.apb_psel_o.value == 1, \"APB select signal should be stable in ACCESS state\"\n    assert dut.apb_pwrite_o.value == 1, \"APB write signal should be stable in ACCESS state\"\n    assert dut.apb_paddr_o.value == expected_addr, f\"APB address should be {hex(expected_addr)} in ACCESS state\"\n    assert dut.apb_pwdata_o.value == expected_data, f\"APB data should be {hex(expected_data)} in ACCESS state\"\n    \n    # Simulate some delay before APB becomes ready\n    delay_cycles = random.randint(2, 5)\n    for _ in range(delay_cycles):\n        await RisingEdge(dut.clk)\n    \n    # Simulate APB becoming ready\n    dut.apb_pready_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.apb_pready_i.value = 0  # Deasserting ready\n\n    latency_rdy = 0\n    while dut.apb_penable_o.value == 1:\n        await RisingEdge(dut.clk)\n        latency_rdy += 1  \n\n    # Check if APB signals are deasserted after the transaction\n    assert latency_rdy == 1, f\"Latency from `apb_pready_i` to `apb_sel_o` and `apb_penable_o` should be 1 cycle, but got {latency_rdy}\"\n    assert dut.apb_psel_o.value == 0, \"APB select should be deasserted after ACCESS\"\n    assert dut.apb_penable_o.value == 0, \"APB enable should be deasserted after ACCESS\" \n    assert dut.apb_pwrite_o.value == 0, \"APB write signal should be deasserted after ACCESS state\" \n    assert dut.apb_paddr_o.value == 0, f\"APB address should be 0 after ACCESS\"\n    assert dut.apb_pwdata_o.value == 0, f\"APB data should be 0 after ACCESS\"     \n\nasync def run_apb_test_without_delay(dut, select_signal, expected_addr, expected_data):\n\n    # Apply stimulus for the selected signal\n    select_signal.value = 1\n    dut.apb_pready_i.value = 0  # Initially APB is not ready\n\n    # Wait for a 1 clock cycles to simulate state transitions\n    await RisingEdge(dut.clk)\n    select_signal.value = 0 \n\n    # latency count\n    latency_sel = 0\n    while (dut.apb_psel_o.value == 0) and (dut.apb_pwrite_o.value == 0):\n        await RisingEdge(dut.clk)\n        latency_sel += 1\n    dut.apb_pready_i.value = 1  # Asserting ready signal\n    # SETUP state checks\n    assert latency_sel == 1, f\"Latency from `apb_psel_o` should be 1 cycle, but got {latency_sel}\"    \n    assert dut.apb_psel_o.value == 1, \"APB select signal should be high in SETUP state\"\n    assert dut.apb_penable_o.value == 0, \"APB enable signal should be deasserted in ACCESS state\"\n    assert dut.apb_pwrite_o.value == 1, \"APB write signal should be high in SETUP state\"\n    assert dut.apb_paddr_o.value == expected_addr, f\"APB address should be {hex(expected_addr)} in SETUP state\"\n    assert dut.apb_pwdata_o.value == expected_data, f\"APB data should be {hex(expected_data)} in SETUP state\"       \n\n    # ACCESS state checks\n    await RisingEdge(dut.clk)\n    assert dut.apb_psel_o.value == 1, \"APB select signal should be asserted in ACCESS state\"\n    assert dut.apb_penable_o.value == 1, \"APB enable signal should be asserted in ACCESS state\"\n    assert dut.apb_pwrite_o.value == 1, \"APB write signal should be high in SETUP state\"\n    assert dut.apb_paddr_o.value == expected_addr, f\"APB address should be {hex(expected_addr)} in SETUP state\"\n    assert dut.apb_pwdata_o.value == expected_data, f\"APB data should be {hex(expected_data)} in SETUP state\"       \n\n    \n    dut.apb_pready_i.value = 0  # Deasserting ready signal\n    latency_rdy = 0\n    while dut.apb_penable_o.value == 1:\n        await RisingEdge(dut.clk)\n        latency_rdy += 1 \n\n    # Check if APB signals are deasserted after the transaction\n    assert latency_rdy == 1, f\"Latency from `apb_pready_i` to `apb_sel_o` and `apb_penable_o` should be 1 cycle, but got {latency_rdy}\"\n    assert dut.apb_psel_o.value == 0, \"APB select should be deasserted after ACCESS\"\n    assert dut.apb_penable_o.value == 0, \"APB enable should be deasserted after ACCESS\" \n    assert dut.apb_pwrite_o.value == 0, \"APB write signal should be deasserted after ACCESS state\"   \n    assert dut.apb_paddr_o.value == 0, f\"APB address should be 0 after ACCESS\"\n    assert dut.apb_pwdata_o.value == 0, f\"APB data should be 0 after ACCESS\" \n\nasync def test_timeout(dut, select_signal, expected_addr, expected_data):\n\n    # Apply stimulus for the selected signal\n    select_signal.value = 1\n    dut.apb_pready_i.value = 0  # Initially APB is not ready\n\n    # Wait for a few clock cycles to simulate state transitions\n    await RisingEdge(dut.clk)\n    select_signal.value = 0 \n\n    # latency count\n    latency_sel = 0\n    while (dut.apb_psel_o.value == 0) and (dut.apb_pwrite_o.value == 0):\n        await RisingEdge(dut.clk)\n        latency_sel += 1\n\n    # SETUP state checks\n    assert latency_sel == 1, f\"Latency from `apb_psel_o` should be 1 cycle, but got {latency_sel}\"    \n    assert dut.apb_psel_o.value == 1, \"APB select signal should be high in SETUP state\"\n    assert dut.apb_penable_o.value == 0, \"APB enable signal should be deasserted in ACCESS state\"\n    assert dut.apb_pwrite_o.value == 1, \"APB write signal should be high in SETUP state\"\n    assert dut.apb_paddr_o.value == expected_addr, f\"APB address should be {hex(expected_addr)} in SETUP state\"\n    assert dut.apb_pwdata_o.value == expected_data, f\"APB data should be {hex(expected_data)} in SETUP state\"\n \n    # latency count\n    latency_enable = 0\n    while dut.apb_penable_o.value == 0:\n        await RisingEdge(dut.clk)\n        latency_enable += 1\n\n    # ACCESS state checks\n    # Validate that `apb_penable_o` is asserted exactly 1 clock cycle after `apb_psel_o`\n    await RisingEdge(dut.clk)\n    assert latency_enable == 1, f\"Latency from `apb_psel_o` to `apb_penable_o` should be 1 cycle, but got {latency_enable}\"\n    assert dut.apb_penable_o.value == 1, \"APB enable signal should be high in ACCESS state\"\n    assert dut.apb_psel_o.value == 1, \"APB select signal should be stable in ACCESS state\"\n    assert dut.apb_pwrite_o.value == 1, \"APB write signal should be stable in ACCESS state\"\n    assert dut.apb_paddr_o.value == expected_addr, f\"APB address should be {hex(expected_addr)} in ACCESS state\"\n    assert dut.apb_pwdata_o.value == expected_data, f\"APB data should be {hex(expected_data)} in ACCESS state\"\n    \n    # Wait for the timeout period \n    latency_disable = 0\n    while dut.apb_penable_o.value == 1:\n        await RisingEdge(dut.clk)\n        latency_disable += 1\n\n    # Check if the controller has returned to IDLE after timeout\n    assert latency_disable == 15, f\"Design should return to IDLE after 15 cycles, but it happened after {latency_disable} cycles\"\n    assert dut.apb_psel_o.value == 0, \"APB select should be deasserted after ACCESS\"\n    assert dut.apb_penable_o.value == 0, \"APB enable should be deasserted after ACCESS\" \n    assert dut.apb_pwrite_o.value == 0, \"APB write signal should be deasserted after ACCESS state\"   \n    assert dut.apb_paddr_o.value == 0, f\"APB address should be 0 after ACCESS\"\n    assert dut.apb_pwdata_o.value == 0, f\"APB data should be 0 after ACCESS\" \n\nasync def check_priority(dut, select_signals, expected_addr, expected_data, description):\n    await RisingEdge(dut.clk)\n    # Apply select signals simultaneously\n    for signal in select_signals:\n        signal.value = 1\n\n    # Wait for one clock cycle to propagate select signals\n    await RisingEdge(dut.clk)\n\n    # Deassert all select signals\n    for signal in select_signals:\n        signal.value = 0\n\n    while (dut.apb_psel_o.value == 0) and (dut.apb_pwrite_o.value == 0):\n        await RisingEdge(dut.clk)\n\n    dut.apb_pready_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.apb_pready_i.value = 0\n    # Verify the selected address and data\n    assert dut.apb_paddr_o.value == expected_addr, (\n        f\"{description}: Expected address {hex(expected_addr)}, \"\n        f\"but got {hex(dut.apb_paddr_o.value.to_unsigned())}\"\n    )\n    assert dut.apb_pwdata_o.value == expected_data, (\n        f\"{description}: Expected data {hex(expected_data)}, \"\n        f\"but got {hex(dut.apb_pwdata_o.value.to_unsigned())}\"\n    )\n    await RisingEdge(dut.clk)\n", "src/test_apb_controller.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_apb_controller_with_delay(dut):\n\n    # Create a clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Apply reset and check values after reset\n    await hrs_lb.async_reset_dut(dut)\n\n    # Read the number of iterations from the environment variable, default to 5\n    num_iterations = 5\n\n    # Perform selections for the specified number of iterations\n    for _ in range(num_iterations):\n\n        # Randomize addresses and data for events A, B, and C\n        dut.addr_a_i.value = random.randint(0x10000000, 0x1FFFFFFF)\n        dut.data_a_i.value = random.randint(0, 0xFFFFFFFF)\n\n        dut.addr_b_i.value = random.randint(0x20000000, 0x2FFFFFFF)\n        dut.data_b_i.value = random.randint(0, 0xFFFFFFFF)\n\n        dut.addr_c_i.value = random.randint(0x30000000, 0x3FFFFFFF)\n        dut.data_c_i.value = random.randint(0, 0xFFFFFFFF)\n\n        # Add a small delay to allow values to propagate\n        await Timer(1, units=\"ns\")\n\n        # Define select signals and addresses/data\n        select_signals = [\n            (dut.select_a_i, dut.addr_a_i.value.to_unsigned(), dut.data_a_i.value.to_unsigned()),\n            (dut.select_b_i, dut.addr_b_i.value.to_unsigned(), dut.data_b_i.value.to_unsigned()),\n            (dut.select_c_i, dut.addr_c_i.value.to_unsigned(), dut.data_c_i.value.to_unsigned())\n        ]\n\n        # Randomly choose a select signal along with corresponding address and data\n        select_signal, expected_addr, expected_data = random.choice(select_signals)\n\n        # Run the APB transaction with the selected signal and expected values\n        await hrs_lb.run_apb_test_with_delay(dut, select_signal, expected_addr, expected_data)\n\n@cocotb.test()\nasync def test_apb_controller_without_delay(dut):\n\n    # Create a clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Apply reset and check values after reset\n    await hrs_lb.async_reset_dut(dut)\n\n    # Read the number of iterations from the environment variable, default to 5\n    num_iterations = 4\n\n    # Perform selections for the specified number of iterations\n    for _ in range(num_iterations):\n\n        # Randomize addresses and data for events A, B, and C\n        dut.addr_a_i.value = random.randint(0x10000000, 0x1FFFFFFF)\n        dut.data_a_i.value = random.randint(0, 0xFFFFFFFF)\n\n        dut.addr_b_i.value = random.randint(0x20000000, 0x2FFFFFFF)\n        dut.data_b_i.value = random.randint(0, 0xFFFFFFFF)\n\n        dut.addr_c_i.value = random.randint(0x30000000, 0x3FFFFFFF)\n        dut.data_c_i.value = random.randint(0, 0xFFFFFFFF)\n\n        # Add a small delay to allow values to propagate\n        await Timer(1, units=\"ns\")\n\n        # Define select signals and addresses/data\n        select_signals = [\n            (dut.select_a_i, dut.addr_a_i.value.to_unsigned(), dut.data_a_i.value.to_unsigned()),\n            (dut.select_b_i, dut.addr_b_i.value.to_unsigned(), dut.data_b_i.value.to_unsigned()),\n            (dut.select_c_i, dut.addr_c_i.value.to_unsigned(), dut.data_c_i.value.to_unsigned())\n        ]\n\n        # Randomly choose a select signal along with corresponding address and data\n        select_signal, expected_addr, expected_data = random.choice(select_signals)\n\n        # Run the APB transaction with the selected signal and expected values\n        await hrs_lb.run_apb_test_without_delay(dut, select_signal, expected_addr, expected_data)        \n@cocotb.test()\nasync def test_apb_controller_with_timeout(dut):\n\n    # Create a clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Apply reset and check values after reset\n    await hrs_lb.async_reset_dut(dut)\n\n    # Read the number of iterations from the environment variable, default to 5\n    num_iterations = 1\n\n    # Perform selections for the specified number of iterations\n    for _ in range(num_iterations):\n\n        # Randomize addresses and data for events A, B, and C\n        dut.addr_a_i.value = random.randint(0x10000000, 0x1FFFFFFF)\n        dut.data_a_i.value = random.randint(0, 0xFFFFFFFF)\n\n        dut.addr_b_i.value = random.randint(0x20000000, 0x2FFFFFFF)\n        dut.data_b_i.value = random.randint(0, 0xFFFFFFFF)\n\n        dut.addr_c_i.value = random.randint(0x30000000, 0x3FFFFFFF)\n        dut.data_c_i.value = random.randint(0, 0xFFFFFFFF)\n\n        # Add a small delay to allow values to propagate\n        await Timer(1, units=\"ns\")\n\n        # Define select signals and addresses/data\n        select_signals = [\n            (dut.select_a_i, dut.addr_a_i.value.to_unsigned(), dut.data_a_i.value.to_unsigned()),\n            (dut.select_b_i, dut.addr_b_i.value.to_unsigned(), dut.data_b_i.value.to_unsigned()),\n            (dut.select_c_i, dut.addr_c_i.value.to_unsigned(), dut.data_c_i.value.to_unsigned())\n        ]\n\n        # Randomly choose a select signal along with corresponding address and data\n        select_signal, expected_addr, expected_data = random.choice(select_signals)\n\n        # Run the APB transaction with the selected signal and expected values\n        await hrs_lb.test_timeout(dut, select_signal, expected_addr, expected_data) \n\n\n@cocotb.test()\nasync def test_apb_controller_priority_all_events(dut):\n    \"\"\"\n    Test the priority handling of the APB controller for simultaneous events A, B, and C.\n    \"\"\"\n\n    # Create a clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Apply reset and check values after reset\n    await hrs_lb.async_reset_dut(dut)\n\n    # Set randomized addresses and data for events A, B, and C\n    dut.addr_a_i.value = random.randint(0x10000000, 0x1FFFFFFF)\n    dut.data_a_i.value = random.randint(0, 0xFFFFFFFF)\n    dut.addr_b_i.value = random.randint(0x20000000, 0x2FFFFFFF)\n    dut.data_b_i.value = random.randint(0, 0xFFFFFFFF)\n    dut.addr_c_i.value = random.randint(0x30000000, 0x3FFFFFFF)\n    dut.data_c_i.value = random.randint(0, 0xFFFFFFFF)\n    # Add a small delay to allow values to propagate\n    await Timer(1, units=\"ns\")\n\n    # Check priority for Event A\n    await hrs_lb.check_priority(\n        dut,\n        [dut.select_a_i, dut.select_b_i, dut.select_c_i],\n        dut.addr_a_i.value.to_unsigned(),\n        dut.data_a_i.value.to_unsigned(),\n        \"Event A Priority Test\"\n    )\n\n    # Check priority for Event B (disable Event A)\n    await hrs_lb.check_priority(\n        dut,\n        [dut.select_b_i, dut.select_c_i],\n        dut.addr_b_i.value.to_unsigned(),\n        dut.data_b_i.value.to_unsigned(),\n        \"Event B Priority Test\"\n    )\n\n    # Check priority for Event C (disable Events A and B)\n    await hrs_lb.check_priority(\n        dut,\n        [dut.select_c_i],\n        dut.addr_c_i.value.to_unsigned(),\n        dut.data_c_i.value.to_unsigned(),\n        \"Event C Priority Test\"\n    )\n", "src/test_runner.py": "import cocotb\nimport os\nimport pytest\nimport random\nfrom cocotb_tools.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    \n    num_iterations = os.getenv(\"NUM_ITERATIONS\", 5)\n    os.environ[\"NUM_ITERATIONS\"] = str(num_iterations)\n\n    # Configure runner\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n\n    for i in range(num_iterations):\n        runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\ndef test_apb():\n    # Run the simulation\n    runner()   \n"}}}
{"id": "cvdp_copilot_factorial_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Write a System Verilog RTL for Factorial computation.  The design should take a number as input and computes factorial on it and return its factorial. Here are some design specifications and port list signals description. \n\n1- `clk` (Input): This is a single bit input to the design. The design runs on this clock. \n2- `arst_n`  (Input): Asynchronous Active low reset signal for the design.\n3- `num_in` (Input): 5 bit input number who's factorial to be calculated.  The input can range from 0 to 31.\n4- `start`  (input): This signal indicates that design should start calculating factorial on the provided input. This should be driven along with `num_in` for one clock cycle when busy is not asserted.\n5- `busy` (output) : This signal indicates that design is busy in calculating the factorial for the provided input. During this signal asserted, design should not accept any new input to process. Design should de-assert it when done is asserted. \n6- `fact` (Outputs): A 64-bit output that holds the factorial of the input number. This result is updated in the next clock cycle after the input is provided.\n7- `done` (output) : This signal indicates that the factorial is calculated the on previous input and now design is ready to accept new input. This should be asserted for one cycle and along with `fact` output. \nTo achieve these feature, implement an FSM which will handle the entire factorial computation flow. The FSM should consist of three states i.e. IDLE, BUSY and DONE. Design will accept the input at IDLE state and then will move to BUSY state, asserting busy signal high. At BUSY state, the factorial computation will be done. Design should stay at BUSY state until the computation is completed. Once all the iterations for factorial calculations are done, then design should move to DONE state, de-asserting the busy signal and asserting the done signal for one cycle. \nOne of the major feature of the design is that it should take as many cycles to compute the factorial as the input value is. For example, if design get input to calculate factorial for 5, it will take 5 cycles to compute the factorial and finally drive it to output signal. \n\nFactorial Overview:\nA factorial, denoted by n!, is the product of all positive integers from 1 to n. It\u2019s a mathematical function that grows very quickly as n increases. The factorial of 0 is defined as 1, and for any positive integer n, the factorial is calculated as:\n\n    n!=nx(n\u22121)x(n\u22122)x\u22efx1\n\nFor example:\n\n    4!=4x3x2x1=24\n    5!=5x4x3x2x1=120\n\nFactorials are commonly used in permutations, combinations, and probability theory.", "context": {}}, "output": {"response": "", "context": {"rtl/factorial.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\r\n\r\n  01-new-tb:\r\n    image: __OSS_SIM_IMAGE__\r\n    volumes:\r\n      - ./src/:/src/:ro\r\n    env_file    : ./src/.env\r\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -sv", "src/.env": "SIM             = icarus\r\nTOPLEVEL_LANG   = verilog\r\nVERILOG_SOURCES = /code/rtl/factorial.sv\r\nTOPLEVEL        = factorial\r\nMODULE          = test_factorial\r\nPYTHONPATH      = /src\r\nHASH            = 1-rtl-design-for-factorial", "src/test_factorial.py": "import cocotb\r\nfrom cocotb.clock import Clock\r\nfrom cocotb.triggers import RisingEdge\r\nfrom cocotb.triggers import FallingEdge\r\nfrom cocotb.regression import TestFactory\r\nimport random\r\n\r\n\r\n# Function to calculate the expected factorial value\r\ndef reference_factorial(num):\r\n  if num == 0 or num == 1:\r\n    return 1\r\n  fact = 1\r\n  for i in range(2, num + 1):\r\n    fact *= i\r\n  return fact\r\n\r\nasync def initialize_dut(dut):\r\n  cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\r\n  dut.arst_n.value = 0\r\n  # dut.num_in.value = 0\r\n  await RisingEdge(dut.clk)\r\n  dut.arst_n.value = 1\r\n  await RisingEdge(dut.clk)\r\n\r\n@cocotb.test()\r\nasync def test_factorial(dut):\r\n  match = 0\r\n  mismatch = 0\r\n  await initialize_dut(dut)\r\n  \r\n  # Randomize the number of test cases\r\n  NUM_TESTS = 100  # Max number of tests to run\r\n  test_count = 0   # Number of random test casesi\r\n  # for i in range(NUM_TESTS+1):\r\n  while (test_count<NUM_TESTS):\r\n    # Randomize input value (8-bit input)\r\n    random_input = random.randint(0, 15)  # Limiting to 12 due to large factorial values\r\n    \r\n    # Apply input to DUT\r\n    if (dut.busy.value!=1 and dut.start.value!=1):\r\n      dut.num_in.value = random_input\r\n      dut.start.value  = 1\r\n      expected_fact = reference_factorial(random_input)\r\n    else:\r\n      dut.num_in.value = 0\r\n      dut.start.value  = 0\r\n\r\n    await RisingEdge(dut.clk)\r\n    \r\n    # Get the DUT result\r\n    if (dut.done.value==1):\r\n      actual_fact = dut.fact.value\r\n    \r\n      if (actual_fact == expected_fact):\r\n        print(f\"Test {test_count} Passed: result = {int(actual_fact)} matches reference {expected_fact}\")\r\n        match = match+1\r\n      else:\r\n        print(f\"Test {test_count} Failed: result = {int(actual_fact)} do not matches reference {expected_fact}\")\r\n        mismatch = mismatch+1\r\n      test_count = test_count+1\r\n\r\n  if (mismatch==0):\r\n    print(f\"All {NUM_TESTS} test cases PASSED successfully.\")\r\n  else: \r\n    print(f\"Matched: {match} , Mismatched {mismatch} - TEST FAILED.\")\r\n", "src/test_runner.py": "import os\r\nfrom cocotb_tools.runner import get_runner\r\nimport pytest\r\nimport pickle\r\nimport random\r\n\r\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\r\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\r\nsim             = os.getenv(\"SIM\", \"icarus\")\r\ntoplevel        = os.getenv(\"TOPLEVEL\")\r\nmodule          = os.getenv(\"MODULE\")\r\n@pytest.mark.tb\r\ndef test_factorial():\r\n    runner = get_runner(sim)\r\n    runner.build(\r\n        sources=verilog_sources,\r\n        hdl_toplevel=toplevel,\r\n        # Arguments\r\n        always=True,\r\n        clean=True,\r\n        waves=True,\r\n        verbose=True,\r\n        timescale=(\"1ns\", \"1ns\"),\r\n        log_file=\"sim.log\")\r\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)"}}}
{"id": "cvdp_copilot_fibonacci_series_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design a 32-bit Fibonacci series generator that updates the value at each clock cycle. The generator will compute the next Fibonacci number based on the sum of the two preceding numbers and store them in registers.\n\n## Design Specification:\n\nThe fibonacci_series module generates a 32-bit Fibonacci sequence, starting from F(0) = 0 and F(1) = 1. Each Fibonacci number is computed by summing the two preceding values, updating at every rising edge of the clock. When the sum of the next Fibonacci number exceeds 32 bits, the module detects overflow and sets the `overflow_flag` after one clock cycle to propagate the last Fibonacci number to the output, after which it automatically restarts the sequence from F(0) and F(1).\n\n### Module Name\nThe module is named `fibonacci_series`, accurately describing its function of generating Fibonacci numbers while handling overflow.\n\n### Key Considerations\n\n**Sequential Fibonacci Calculation**: Each Fibonacci number is generated by summing two previous numbers, stored in `RegA` (F(n-2)) and `RegB` (F(n-1)).\n\n**Synchronous Operation**: All calculations and updates are synchronized with the positive edge of the clock (`clk`).\n\n**Overflow Detection and Sequence Reset**: The module detects overflow when a computed Fibonacci number exceeds 32 bits. If overflow is detected, the `overflow_flag` is set on the next clock cycle to propagate the final Fibonacci number to the output, and the sequence restarts from its initial values, F(0) and F(1).\n\n## Interface\n\n### Inputs:\n\n- `clk`: The clock signal to synchronize Fibonacci generation, initiating a new calculation on each rising edge.\n\n- `rst`: An active-high reset signal. When asserted, it resets the sequence to F(0) = 0 and F(1) = 1, clearing the `overflow_flag`.\n\n### Outputs:\n\n- `fib_out`: A 32-bit output that holds the current Fibonacci number, updated at each clock cycle.\n\n- `overflow_flag`: A signal that is set high one cycle after overflow is detected. It remains high until reset or until the sequence automatically restarts after overflow.\n\n## Behavior and Data Flow\n\n### Reset Behavior (rst = 1):\n\nWhen `rst` is asserted: \n\n- `RegA` is initialized to 0 (F(0)), and `RegB` is initialized to 1 (F(1)).\n- `fib_out` is set to 0, representing F(0).\n- `overflow_flag` is cleared to 0, indicating no overflow.\n\n### Fibonacci Sequence Generation (rst = 0):\n\nWith `rst` low, Fibonacci sequence generation proceeds.\n\nOn each rising clock edge:\n\n- **Next Fibonacci Calculation**: `next_fib` = `RegA` + `RegB`\n\n- **Overflow Detection**: If `next_fib` exceeds 32 bits (`next_fib[32]` == 1), `overflow_flag` is set to 1.\n\n- **Register Updates**: If `next_fib` exceeds 32 bits (`next_fib[32]` == 1), `overflow_detected` is set to 1, indicating overflow. On the following clock cycle, this triggers a reset and sets the `overflow_flag`.\n\n- **Output Update**: `fib_out` is updated with the current value in `RegB`.\n\n## Example Operations\n\n**Initial State** (after reset):\n`RegA` = 0, `RegB` = 1, `fib_out` = 0, `overflow_flag` = 0\n\n**Clock Cycle 1**:\nF(2) = 1 + 0 = 1\n\nAfter the clock edge, `RegA` = 1, `RegB` = 1, `fib_out` = 1, `overflow_flag` = 0\n\n**Clock Cycle 2**:\nF(3) = 1 + 1 = 2\n\nAfter the clock edge, `RegA` = 1, `RegB` = 2, `fib_out` = 2, `overflow_flag` = 0\n\n**Overflow Condition**:\n\nWhen `next_fib[32]` is set, `overflow_detected` is set to 1, and `RegB` final Fibonacci value is assigned to `fib_out`. On the next clock cycle, `overflow_flag` is set to 1, `fib_out` resets to 0, and the sequence restarts with `RegA` = 0 and `RegB` = 1.", "context": {}}, "output": {"response": "", "context": {"rtl/fibonacci_series.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  auto:\n    image: __OSS_SIM_IMAGE__\n    env_file    : ./src/.env\n    volumes:\n      - ./src:/src/:ro\n    command     : >\n      sh -c \"pip install aes && pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\"\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/fibonacci_series.sv\nTOPLEVEL        = fibonacci_series\nMODULE          = test_fibonacci_series\nPYTHONPATH      = /src\nHASH            = 1-rtl-design-for-32-bit-fibonacci-series", "src/test_fibonacci_series.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\n\n# Utility function to calculate the next Fibonacci number in Python\ndef next_fibonacci(a, b):\n    return a + b\n\n# Function to continuously calculate the Fibonacci series up to overflow\nasync def calculate_fibonacci(dut):\n    a, b = 0, 1\n    while True:\n        # Capture the DUT output\n        dut_output = int(dut.fib_out.value)\n        \n        # Check if overflow flag is set in DUT\n        if dut.overflow_flag.value == 1:\n            dut._log.info(\"Overflow detected. Fibonacci sequence will reset.\")\n            break\n        \n        # Assert to ensure DUT output matches the expected value\n        assert dut_output == a, f\"Expected {a}, but got {dut_output} from DUT.\"\n        dut._log.info(f\"DUT Fibonacci Output = {dut_output}, Expected = {a}\")\n        \n        # Advance the expected Fibonacci numbers\n        a, b = b, next_fibonacci(a, b)\n        \n        # Wait for the next clock cycle\n        await RisingEdge(dut.clk)\n\n# Function to apply reset to DUT\nasync def apply_reset(dut, duration=2):\n    dut.rst.value = 1  # Assert reset\n    await Timer(duration, units=\"ns\")  # Hold reset for the specified duration\n    dut.rst.value = 0  # Deassert reset\n    await RisingEdge(dut.clk)  # Synchronize with clock edge after reset\n    dut._log.info(\"Reset applied to DUT.\")\n\n# Test to verify Fibonacci sequence restarts after reset\n@cocotb.test()\nasync def test_reset_scenario(dut):\n    \"\"\" Test case to cover the scenario where the sequence is interrupted by reset. \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())  # Start clock with 10ns period\n\n    # Apply initial reset to start the module\n    await apply_reset(dut)\n\n    # Run the Fibonacci sequence for a few cycles, then apply reset\n    await calculate_fibonacci(dut)  # Run sequence until reset or overflow\n    dut._log.info(\"Sequence running; applying reset to interrupt it.\")\n    \n    # Apply reset during the sequence generation\n    await apply_reset(dut)\n\n    # After reset, check that the sequence starts from F(0) = 0\n    await calculate_fibonacci(dut)\n\n# Test to verify overflow scenario and reset handling after overflow\n@cocotb.test()\nasync def test_overflow_and_reset(dut):\n    \"\"\" Test case to cover overflow scenario and reset after overflow. \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())  # Start clock with 10ns period\n\n    # Apply initial reset to start the module\n    await apply_reset(dut)\n\n    # Run the Fibonacci sequence until overflow is detected\n    await calculate_fibonacci(dut)\n\n    # Apply reset after overflow has occurred\n    dut._log.info(\"Applying reset after overflow.\")\n    await apply_reset(dut)\n\n    # Verify that the sequence restarts from F(0) = 0 after reset\n    await calculate_fibonacci(dut)", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport re\nimport logging\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_fifo_async_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Create an asynchronous FIFO module with configurable depth and data width. The FIFO should support asynchronous and simultaneous writes and reads between different clock domains. The module should have parameters for setting the depth and data width, along with outputs to indicate full and empty status.\n\nThe module should have the following interface:\n\n**Parameters**\n\n- `DATA_WIDTH`: the width of the data bus\n- `DEPTH`: the number of data elements that can be stored in the FIFO\n\n**Inputs**\n\n- `w_clk`: clock signal for write data operations\n- `w_rst`: reset signal to reset the write pointer\n- `w_inc`: enable signal for write data operations\n- `w_data`: input containing the data to be stored into the FIFO\n- `r_clk`: clock signal for read data operations\n- `r_rst`: reset signal to reset the read pointer\n- `r_inc`: enable signal for read data operations\n\n**Outputs**\n\n- `w_full`: output flag indicating that the FIFO is full\n- `r_empty`: output flag indicating that the FIFO is empty\n- `r_data`: output containing the data read from the FIFO\n\n**Behavior**\n\nIt is also important to implement an appropriate synchronization mechanism to handle metastability issues. To achieve this, implement write and read pointers using Gray counters to track the write/read positions in the FIFO. To determine if the FIFO is empty or full, use pointers with one extra bit to track overflow and compare both pointers. The empty and full flags should be asserted as follows:\n\n- **Empty flag**: If the write and read pointers have exactly the same value, the `empty` flag should be asserted.\n- **Full flag**: If the most significant bit (MSB) of the write and read pointers is different but all other bits are the same, the `full` flag should be asserted. This indicates that the write pointer has made a complete cycle and reached the same position as the read pointer, causing an overflow.\n\nSince the read and write clocks are in different domains, it is necessary to synchronize the clock domains to compare the pointers. To do this, use cross-clock synchronizers, consisting of two registers in series, to pass the read pointer from the read clock domain to the write clock domain and the write pointer from the write clock domain to the read clock domain.", "context": {}}, "output": {"response": "", "context": {"rtl/fifo_async.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n  test:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src\n    working_dir: /code/rundir/\n    env_file:\n      - ./src/.env\n    command: pytest -sv -o cache_dir=/code/rundir/.cache /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/fifo_async.sv\nTOPLEVEL        = fifo_async\nMODULE          = tb\nPYTHONPATH      = /src\nHASH            = 1-rtl-implementation", "src/tb.py": "import random\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import Timer, RisingEdge, FallingEdge\n    \n# Global Queue\nq = []\n\nasync def configure_clocks(dut, w_period, r_period):\n\n    # Reset the Clock Configuration\n    dut.w_clk.value = 0\n    dut.r_clk.value = 0\n    await Timer(10, units=\"ns\")\n    \n    # Start the clock\n    w_clk = cocotb.start_soon(Clock(dut.w_clk, w_period, units='ns').start())\n    r_clk = cocotb.start_soon(Clock(dut.r_clk, r_period, units='ns').start())\n\n    dut._log.info(\"Clocks initialized.\")\n    return (w_clk, r_clk)\n\nasync def configure_resets(dut):\n\n    # Reset input interface\n    dut.w_rst.value  = 1\n    dut.r_rst.value  = 1\n    dut.w_inc.value  = 0\n    dut.r_inc.value  = 0\n    dut.w_data.value = 0\n\n    # Reset the DUT\n    await Timer(100, units=\"ns\")\n    dut.w_rst.value = 0\n    dut.r_rst.value = 0\n    dut._log.info(\"Resets initialized, ready for sequential value tests.\")\n\nasync def write_data(dut, w_data):\n\n    try:\n        await FallingEdge(dut.w_clk)\n        dut.w_data.value = w_data\n        dut.w_inc.value  = 1\n        await FallingEdge(dut.w_clk)\n    finally:\n        dut._log.info(f\"Wrote {hex(w_data)} in w_data bus.\")\n        dut.w_inc.value  = 0\n\ndef read_data(dut, expected_data):\n\n    assert dut.r_data.value  == expected_data, \"Wrong domain transitioning\"\n    dut._log.info(f\"Successfully read {hex(expected_data)} and prepared the next read.\")\n\n# ----------------------------------------\n# - Random Test infrastructure\n# ----------------------------------------\n\nasync def w_test(dut, tests):\n\n    dut._log.info(\"Starting w_test thread...\")\n    \n    try:\n        width = 2 ** int(dut.DATA_WIDTH.value)\n    \n        for _ in range(tests):\n            w_data = random.randint(0, width - 1)\n    \n            # Asynchronous start write_func\n            if dut.w_full.value == 0:\n                await write_data(dut, w_data)\n                q.append(w_data)\n    \n            else:\n                dut._log.info(f\"FIFO is full, skipping new data write.\")\n                await FallingEdge(dut.w_clk)\n    finally:\n        dut._log.info(\"Finished to execute w_test thread.\")\n\nasync def r_test(dut, tests):\n\n    dut._log.info(\"Starting r_test thread...\")\n    \n    try:\n        len_q = int(dut.DEPTH.value)\n    \n        for _ in range(tests):\n    \n            # Check if contains data to be checked\n            if len(q) > 0 and (dut.r_empty.value == 0):\n    \n                r_data = int(q.pop(0))\n                read_data(dut, r_data)\n                dut.r_inc.value = 1\n    \n            else:\n                dut._log.info(f\"Detected empty FIFO, skipping new data read.\")\n                dut.r_inc.value = 0\n    \n            # Synchronize with falling edge\n            await FallingEdge(dut.r_clk)\n    \n    finally:\n        dut._log.info(\"Finished to execute r_test thread.\")\n        \n# ----------------------------------------\n# - Basic Test\n# ----------------------------------------\n\n@cocotb.test()\nasync def test_empty(dut):\n\n    w_clk = random.randint(10, 20)\n    r_clk = random.randint(10, 20)\n\n    # Configure clocks and resets\n    (w_clk, r_clk) = await configure_clocks(dut, w_clk, r_clk)\n    await configure_resets(dut)\n\n    len_q = random.randint(2, int(dut.DEPTH.value))\n    width = 2 ** int(dut.DATA_WIDTH.value)\n    dut._log.info(f\"Test Empty Started, executing {len_q} read and writes.\")\n\n    assert dut.w_full.value == 0,  \"FIFO should not be full. Test just started, no data was driven.\"\n    assert dut.r_empty.value == 1, \"FIFO should be empty. Test just started, no data was driven.\"\n\n    # Synchronize with write clock\n    await FallingEdge(dut.w_clk)\n    \n    try:\n\n        for _ in range(len_q):\n            w_data = random.randint(0, width - 1)\n            \n            dut.w_inc.value  = 1\n            dut.w_data.value = w_data\n            await FallingEdge(dut.w_clk)\n\n    finally:\n        dut._log.info(\"Finished to write data in FIFO.\")\n\n    # Stop driving new data\n    dut.w_inc.value = 0\n\n    # Synchronize with read clock\n    await FallingEdge(dut.r_clk)\n    await FallingEdge(dut.r_clk)\n    await FallingEdge(dut.r_clk)\n    \n    try:\n        for _ in range(len_q):\n            dut.r_inc.value = 1\n            await FallingEdge(dut.r_clk)\n\n    finally:\n        dut._log.info(\"Finished to read data from FIFO.\")\n    \n    # Stop requesting new data\n    dut.r_inc.value = 0\n    dut.w_inc.value = 0\n    \n    # Fifo should be empty\n    await FallingEdge(dut.r_clk)\n    await FallingEdge(dut.r_clk)\n    \n    assert dut.r_empty.value == 1, \"All datas has already been retrieved. FIFO should be empty.\"\n\n    w_clk.kill()\n    r_clk.kill()\n    \n@cocotb.test()\nasync def test_basic(dut):\n\n    w_clk = random.randint(10, 20)\n    r_clk = random.randint(10, 20)\n    \n    # Configure clocks and resets\n    (w_clk, r_clk) = await configure_clocks(dut, w_clk, r_clk)\n    await configure_resets(dut)\n\n    # Asynchronous start write_func\n    # cocotb.start_soon(write_data(dut, 0xDEADBEAF))\n    await write_data(dut, 0xDEADBEAF)\n\n    # Wait clock transitioning\n    for _ in range(2):\n        await FallingEdge(dut.r_clk)\n\n    await FallingEdge(dut.r_clk)\n    read_data(dut, 0xDEADBEAF)\n\n    w_clk.kill()\n    r_clk.kill()\n\n@cocotb.test()\nasync def test_full(dut):\n\n    w_clk = random.randint(10, 20)\n    r_clk = random.randint(10, 20)\n\n    # Configure clocks and resets\n    (w_clk, r_clk) = await configure_clocks(dut, w_clk, r_clk)\n    await configure_resets(dut)\n\n    len_q = int(dut.DEPTH.value)\n    width = 2 ** int(dut.DATA_WIDTH.value)\n\n    assert dut.w_full.value == 0,  \"FIFO should not be full. Test just started, no data was driven.\"\n    assert dut.r_empty.value == 1, \"FIFO should be empty. Test just started, no data was driven.\"\n\n    # Synchronize with write clock\n    await FallingEdge(dut.w_clk)\n\n    try:\n        for _ in range(len_q):\n            w_data = random.randint(0, width - 1)\n            \n            dut.w_inc.value  = 1\n            dut.w_data.value = w_data\n            await FallingEdge(dut.w_clk)\n\n    finally:\n        dut._log.info(\"Finished to write data into FIFO\")\n\n    # FIFO should be full\n    await FallingEdge(dut.w_clk)\n    assert dut.w_full.value == 1, \"FIFO should be full with this amount of data.\"\n\n    w_clk.kill()\n    r_clk.kill()\n\n@cocotb.test()\nasync def test_random(dut):\n\n    w_clk = random.randint(10, 20)\n    r_clk = random.randint(10, 20)\n\n    # Configure clocks and resets\n    (w_clk, r_clk) = await configure_clocks(dut, w_clk, r_clk)\n    await configure_resets(dut)\n\n    w_task = cocotb.start_soon(w_test(dut, 100))\n    r_task = cocotb.start_soon(r_test(dut, 100))\n\n    # Write domain finishes the test.\n    for _ in range(100):\n        await FallingEdge(dut.w_clk)\n\n    # Succesfully ends the test\n    r_task.kill()\n    w_task.kill()\n    \n    w_clk.kill()\n    r_clk.kill()\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom cocotb_tools.runner import get_runner\nimport pytest\nimport pickle\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\n@pytest.mark.tb\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"))\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\nif __name__ == \"__main__\":\n   test_runner()"}}}
{"id": "cvdp_copilot_filo_0005", "categories": ["cid003", "medium"], "input": {"prompt": "Develop the RTL design of First In Last Out (FILO) with the module name `FILO_RTL`. The design `FILO_RTL` has to support various data widths and buffer depths. The FILO should ensure correct data management for push and pop operations while handling edge cases such as feedthrough scenarios. The design must guarantee correct buffer behavior when pushing data into the FILO and popping the data out of it. The FILO buffer stores input data in a stack-like structure, where the most recently pushed data is the first to be popped. \n\n# FILO Design Specification\n\nThe `FILO` (First-In-Last-Out) buffer module stores the input data of configurable widths and manages them in a stack-like manner. The design ensures that data can be pushed into the buffer and popped from it while maintaining control signals for empty and full status.\n\n## Parameters:\n- **`DATA_WIDTH`**: Width of the input data to be pushed into the FILO buffer. Default value is 8 bits.\n- **`FILO_DEPTH`**: Maximum number of elements the FILO buffer can hold. Default value is 16.\n\n## Interface:\n\n### Inputs:\n- **`clk (1-bit)`**: Data operations (push/pop) will be performed on the rising edge of this clock. The clock operates at a 50:50 duty cycle.\n- **`reset (1-bit)`**: Asynchronous active-HIGH reset signal to initialize the FILO system. The output `full` will be LOW and `empty` will be HIGH when the `reset` input is HIGH\n- **`push (1-bit)`**: Control signal to push data into the FILO buffer. Data is only pushed when the buffer is not full.\n- **`pop (1-bit)`**: Control signal to pop data from the FILO buffer. Data is only popped when the buffer is not empty.\n- **`data_in` (`DATA_WIDTH` bits, [DATA_WIDTH - 1:0])**: The input data word to be stored in the FILO. The width of this input can vary based on the `DATA_WIDTH` parameter.\n\n### Outputs:\n- **`data_out`** (`DATA_WIDTH` bits, [DATA_WIDTH - 1:0]): The data popped from the top of the FILO. The width of this output matches the input data width.\n- **`full (1-bit)`**: Status signal indicating whether the FILO buffer is full. Asserted HIGH when the FILO contains the maximum number of elements (`FILO_DEPTH`).\n- **`empty (1-bit)`**: Status signal indicating whether the FILO buffer is empty. Asserted HIGH when no elements are present in the FILO.\n\n## Behavior and Operation:\nThe FILO buffer functions as a stack where the last element pushed into the buffer is the first one to be popped. The FILO buffer's state (full/empty) is updated based on the `push` and `pop` operations.\n\n### Reset Behavior:\n- When the **`reset`** signal is asserted, the buffer is cleared:\n  - The internal stack pointer (`top`) is reset to 0.\n  - The **`empty`** signal is asserted (`empty = 1`), indicating the buffer is empty.\n  - The **`full`** signal is deasserted (`full = 0`).\n\n### Push Operation:\n- When the **`push`** signal is asserted and the buffer is **not full**, the following occur:\n  - The data from `data_in` is stored at the current position indicated by the `top` pointer.\n  - The `top` pointer is incremented to point to the next empty position.\n  - If the `top` pointer reaches the `FILO_DEPTH`, the **full** signal is asserted (`full = 1`), indicating the buffer is full.\n  - The **`empty`** signal is deasserted (`empty = 0`), indicating the buffer contains data.\n\n### Pop Operation:\n- When the **`pop`** signal is asserted and the buffer is **not empty**, the following occur:\n  - The `top` pointer is decremented to point to the previous data in the buffer.\n  - The data at the new `top` position is assigned to `data_out` and output.\n  - If the `top` pointer reaches 0, the **empty** signal is asserted (`empty = 1`), indicating the buffer is empty.\n  - The **`full`** signal is deasserted (`full = 0`), indicating space is available in the buffer.\n\n## Edge Cases:\n**`Feedthrough`**: If the **`FILO`** is empty, and both **`push`** and **`pop`** signals are asserted HIGH in the same positive edge of the `clk`, the input data (`data_in`) is immediately passed through to the output (`data_out`) without being stored in the memory, ensuring minimal latency for this case.\n\n## Example Operation:\nAssuming `DATA_WIDTH = 8` and `FILO_DEPTH = 8`:\n\n| Clock Cycle | Reset | Push | Pop | Data_in      | Data_out     | Full | Empty |\n|-------------|-------|------|-----|--------------|--------------|------|-------|\n| 1           | 1     | 0    | 0   | 8'h00 | 8'hXX | 0    | 1     |\n| 2           | 0     | 1    | 0   | 8'hA1 | 8'hXX | 0    | 0     |\n| 3           | 0     | 1    | 0   | 8'hA2 | 8'hXX | 0    | 0     |\n| 4           | 0     | 1    | 0   | 8'hA3 | 8'hXX | 0    | 0     |\n| 5           | 0     | 1    | 0   | 8'hA4 | 8'hXX | 0    | 0     |\n| 6           | 0     | 1    | 0   | 8'hA5 | 8'hXX | 0    | 0     |\n| 7           | 0     | 1    | 0   | 8'hA6 | 8'hXX | 0    | 0     |\n| 8           | 0     | 1    | 0   | 8'hA7 | 8'hXX | 0    | 0     |\n| 9           | 0     | 1    | 0   | 8'hA8 | 8'hXX | 1    | 0     |\n| 10           | 0     | 0    | 1   | 8'hXX | 8'hA8 | 0    | 0     |\n| 11         | 0     | 0    | 1   | 8'hXX | 8'hA7 | 0    | 0     |\n| 12           | 0     | 0    | 1   | 8'hXX | 8'hA6 | 0    | 0     |\n| 13           | 0     | 0    | 1   | 8'hXX | 8'hA5 | 0    | 0     |\n| 14           | 0     | 0    | 1   | 8'hXX | 8'hA4 | 0    | 0     |\n| 15           | 0     | 0    | 1   | 8'hXX | 8'hA3 | 0    | 0     |\n| 16           | 0     | 0    | 1   | 8'hXX | 8'hA2 | 0    | 0     |\n| 17           | 0     | 0    | 1   | 8'hXX | 8'hA1 | 0    | 1    |\n| 18           | 0     | 1    | 1   | 8'hD1 | 8'hD1 | 0    | 1     |\n\nIn this example, the `FILO` buffer handles data push and pop operations with the correct sequence, including the feedthrough case (when both push and pop occur simultaneously).\n", "context": {}}, "output": {"response": "", "context": {"rtl/FILO_RTL.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    # working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest --log-cli-level=INFO -o cache_dir=/code/rundir/.cache -sv /src/test_runner.py\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nWAVE            = 1\nVERILOG_SOURCES = /code/rtl/FILO_RTL.sv\nTOPLEVEL        = FILO_RTL\nMODULE          = test_filo\nPYTHONPATH      = /src\nHASH            = 5-rtl-design-modification-for-first-in-last-outfilo-1\n", "src/test_filo.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\nasync def clock_gen(dut):\n    while True:\n        dut.clk.value = 0\n        await Timer(5, units='ns')\n        dut.clk.value = 1\n        await Timer(5, units='ns')\n\nasync def apply_reset(dut, push_count, filo_depth):\n    dut.reset.value = 1\n    await Timer(20, units='ns')\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\n    push_count[0] = 0\n    is_full = int(push_count[0] == filo_depth) \n    is_empty = int(push_count[0] == 0)        \n    dut._log.info(f\"Reset applied. Full: {is_full}, Empty: {is_empty}\")\n\n\nasync def push_data(dut, pushed_values, push_count, filo_depth, data_width):\n    if push_count[0] == filo_depth:\n        dut._log.info(\"Cannot push, FILO is full (calculated).\")\n        assert False, \"Trying to push when FILO is full (calculated).\"\n    else:\n        value = random.randint(0, (1 << data_width) - 1)\n        dut.push.value = 1\n        dut.data_in.value = value\n        await RisingEdge(dut.clk)\n        dut.push.value = 0\n        await Timer(20, units='ns')  \n\n        pushed_values.append(value)  \n        push_count[0] += 1  \n\n        is_full = int(push_count[0] == filo_depth) \n        is_empty = int(push_count[0] == 0)        \n        dut._log.info(f\"Pushed value: {hex(value)}, Push Count: {push_count[0]}, Full: {is_full}, Empty: {is_empty}\")\n\nasync def pop_data(dut, expected_value, push_count, filo_depth, data_width):\n    if push_count[0] == 0:\n        dut._log.info(\"Cannot pop, FILO is empty (calculated).\")\n        assert False, \"Trying to pop when FILO is empty (calculated).\"\n    else:\n        dut.pop.value = 1\n        await RisingEdge(dut.clk)\n        dut_pop_value = expected_value\n        dut.pop.value = 0\n        await Timer(20, units='ns')\n\n        popped_value = int(dut.data_out.value) & ((1 << data_width) - 1)\n        push_count[0] -= 1 \n\n        is_full = int(push_count[0] == filo_depth)\n        is_empty = int(push_count[0] == 0)        \n        dut._log.info(f\"Popped value: {hex(dut_pop_value)}, Push Count: {push_count[0]}, Full: {is_full}, Empty: {is_empty}\")\n        assert dut_pop_value == expected_value, f\"Expected {hex(expected_value)}, but got {hex(dut_pop_value)}\"\n\n@cocotb.test()\nasync def test_filo(dut):\n    \"\"\" Test FILO_RTL behavior with manual full and empty conditions using push count \"\"\"\n\n    data_width = int(dut.DATA_WIDTH.value)\n    filo_depth = int(dut.FILO_DEPTH.value)\n\n    dut._log.info(f\"Test started with parameters: DATA_WIDTH={data_width}, FILO_DEPTH={filo_depth}\")\n\n    cocotb.start_soon(clock_gen(dut))\n\n    dut.push.value = 0\n    dut.pop.value = 0\n    dut.data_in.value = 0\n    dut.reset.value = 0\n    push_count = [0] \n\n\n    dut._log.info(\"Starting Initial Reset...\")\n    await apply_reset(dut, push_count, filo_depth)\n    await RisingEdge(dut.clk)\n\n    assert push_count[0] == 0, \"Push count should be 0 after reset\"\n\n    pushed_values = []\n\n\n    dut._log.info(f\"Starting Push Test with random data width {data_width} and FILO depth {filo_depth}...\")\n    for _ in range(filo_depth):\n        await push_data(dut, pushed_values, push_count, filo_depth, data_width) \n\n    dut._log.info(\"Starting Pop Test...\")\n    while pushed_values:\n        expected_value = pushed_values.pop()  \n        await pop_data(dut, expected_value, push_count, filo_depth, data_width)\n\n  \n    dut._log.info(\"Starting Feedthrough Test...\")\n    if push_count[0] == 0:\n        feedthrough_value = random.randint(0, (1 << data_width) - 1)\n        dut.push.value = 1\n        dut.pop.value = 1\n        dut.data_in.value = feedthrough_value \n        dut_popped_value =  feedthrough_value\n        dut._log.info(f\"Feedthrough pushed value: {hex(feedthrough_value)}\")\n        await RisingEdge(dut.clk)\n        await Timer(10, units='ns')  \n        popped_value = int(dut.data_out.value) & ((1 << data_width) - 1)\n        dut._log.info(f\"Feedthrough popped value: {hex(dut_popped_value)}\")\n        assert dut_popped_value == feedthrough_value, f\"Feedthrough test failed, expected {hex(feedthrough_value)}\"\n        dut.push.value = 0\n        dut.pop.value = 0\n        dut._log.info(\"Feedthrough Test Passed.\")\n    else:\n        assert False, \"Error: FILO is not empty before feedthrough test.\"\n\n    # Final check\n    await RisingEdge(dut.clk)\n    dut._log.info(f\"All tests passed.\")\n", "src/test_runner.py": "\nimport os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner(DATA_WIDTH: int=8, FILO_DEPTH: int=8 ):\n    parameter = {\"DATA_WIDTH\":DATA_WIDTH, \"FILO_DEPTH\":FILO_DEPTH}\n    \n    # Debug information\n    print(f\"[DEBUG] Running simulation with DATA_WIDTH={DATA_WIDTH}, FILO_DEPTH={FILO_DEPTH}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n    \n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        parameters=parameter,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)   \n\n# Parametrize test for different WIDTH and WINDOW_SIZE\n@pytest.mark.parametrize(\"DATA_WIDTH\", [10,12])\n@pytest.mark.parametrize(\"FILO_DEPTH\", [12,16])\n\n#@pytest.mark.parametrize(\"test\", range(1))\ndef test_filo(DATA_WIDTH, FILO_DEPTH):\n    # Run the simulation with specified parameters\n    test_runner(DATA_WIDTH=DATA_WIDTH, FILO_DEPTH=FILO_DEPTH)\n"}}}
{"id": "cvdp_copilot_fsm_seq_detector_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design a **Finite State Machine (FSM)** sequence detector in System Verilog that detects the specific 8-bit sequence **`10110001`** from a continuous serial input. When the sequence is detected, the FSM should output a high signal for one clock cycle.\n\n### Specification\n\n#### Inputs\n- `clk_in (1-bit)` - Input clock signal with 50% duty cycle to operate the design at the rising edge\n- `rst_in (1-bit)` - Asynchronous active-high reset signal. When asserted high, the FSM resets to the initial state `S0`.\n- `seq_in (1-bit)` - Serial input signal to provide a continuous stream of bits (`0` or `1`).\n\n#### Output\n- `seq_detected (1-bit)` - This signal is asserted HIGH for one clock cycle when the sequence `10110001` is detected otherwise remains at LOW\n\n#### FSM Design Requirements\n\n1. **State Definitions:**\n   - Implement **eight states** (`S0` to `S7`) to represent each step in detecting the sequence.\n   - **State Encoding**: Use a 3-bit state representation (`logic [2:0]`).\n\n2. **Output Behavior:**\n   - The output `seq_detected` should be **registered** and synchronized with `clk_in` to avoid glitches.\n   - It should be asserted **only once** per detected sequence, for **one clock cycle** immediately after the last bit is received.\n\n3. **Input Constraints:**\n   - **`seq_in`** is always a valid binary input (`0` or `1`).\n   - No special handling is required for invalid inputs.\n\n4. **Sequence Overlaps:**\n   - The FSM must handle overlapping sequences. For example, if `seq_in` contains `101100010110001`, the FSM should detect the sequence twice.\n\n5. **Boundary Conditions:**\n   - The FSM should correctly handle the sequence detection regardless of where it starts in the input stream.\n   - There are no underflow or overflow conditions to consider.\n\n6. **Timing Requirements:**\n   - **State Transitions:** Occur on the rising edge of `clk_in`.\n   - **Output Assertion:** `seq_detected` is asserted high on the rising edge of `clk_in` following the detection of the complete sequence.\n\n---\n\n**Implementation Details:**\n\n- **Data Types:**\n  - Use `bit` for the clock input `clk_in` for precise edge detection.\n  - Use `logic` for other inputs and outputs.\n\n- **State Representation:**\n  - Define an enumerated type `state_t` for states `S0` to `S7` using `logic [2:0]`.\n\n- **State Register:**\n  - Implement a sequential always block triggered on `posedge clk_in` or `posedge rst_in` for state transitions.\n\n- **Next State Logic:**\n  - Use a combinational always block (`always_comb`) to determine `next_state` based on `cur_state` and `seq_in`.\n\n- **Output Logic:**\n  - Compute `seq_detected_w` in the combinational block.\n  - Register `seq_detected` in a sequential always block to synchronize it with `clk_in`.\n\n- **Reset Behavior:**\n  - On assertion of `rst_in`, the FSM should immediately reset to `S0` and `seq_detected` should be cleared to `0`.\n\n---", "context": {}}, "output": {"response": "", "context": {"rtl/fsm_seq_detector.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v -s\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/fsm_seq_detector.sv \nTOPLEVEL        = fsm_seq_detector\nMODULE          = test_fsm_seq_det\nPYTHONPATH      = /src\nHASH            = 11e39d5db04b149cfe6cd88ee4a8c5d35f0bc88f\n", "src/test_fsm_seq_det.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport test_runner\nimport json\nimport os\n\n\nasync def init_dut(dut):\n    dut.rst_in.value     = 1\n    dut.seq_in.value    = 0\n\n    await RisingEdge(dut.clk_in)\n\n\n\n@cocotb.test()\nasync def test_basic(dut):\n    cocotb.start_soon(Clock(dut.clk_in, 10, units='ns').start())\n    await init_dut(dut)\n\n    # Retrieve test_sequence and expected_output from environment variables\n    test_sequence = json.loads(os.getenv(\"TEST_SEQUENCE\"))\n    expected_output = json.loads(os.getenv(\"EXPECTED_OUTPUT\"))\n\n    # ----------------------------------------\n    # - Check No Operation\n    # ----------------------------------------\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)  # Wait until 2 clocks to de-assert reset\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)  \n\n    # Apply the test sequence with seq_in updated for only one clock cycle\n    for i in range(len(test_sequence)):\n        await RisingEdge(dut.clk_in)\n        dut.seq_in.value = test_sequence[i]\n        dut._log.info(f\"Input: {dut.seq_in.value}, Decoded Output: {dut.seq_detected.value}, test_sequence: {test_sequence[i]}\")\n        await FallingEdge(dut.clk_in)\n        assert dut.seq_detected.value == expected_output[i], f\"Error at step {i}\"\n", "src/test_runner.py": "import os\nimport json\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef runner(test_sequence=None, expected_output=None):\n    runner = get_runner(sim)\n\n    # Set environment variables for test_sequence and expected_output\n    os.environ[\"TEST_SEQUENCE\"] = json.dumps(test_sequence)\n    os.environ[\"EXPECTED_OUTPUT\"] = json.dumps(expected_output)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Test: Detection of the Sequence at the Start\ndef test_detection_at_start():\n    test_sequence = [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1]  # Sequence at the start\n    expected_output = [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]  # Detected at position 9\n    runner(test_sequence=test_sequence, expected_output=expected_output)\n\n# Test: Detection of the Sequence at the End\ndef test_detection_at_end():\n    test_sequence = [0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1]  # Sequence at the end\n    expected_output = [0] * 10 + [0, 0, 0, 1]  # Detected at the last position\n    runner(test_sequence=test_sequence, expected_output=expected_output)\n\n# Test: Multiple Occurrences of the Sequence\ndef test_multiple_occurrences():\n    test_sequence = [1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1]\n    expected_output = [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1]  # Two detections\n    runner(test_sequence=test_sequence, expected_output=expected_output)\n\n# Test: Sequence with Noise Before and After\ndef test_noise_before_after():\n    test_sequence = [0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0]  # Noise before and after\n    expected_output = [0] * 13 + [0, 1, 0]  # Detection happens at index 14 (1-clock delay)\n    runner(test_sequence=test_sequence, expected_output=expected_output)\n\n# Test: Sequence with Overlapping 2 sequences\ndef test_seq_overlapping():\n    test_sequence = [1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0]  # Overlapping case\n    expected_output = [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0]  # Two detections\n    runner(test_sequence=test_sequence, expected_output=expected_output)\n"}}}
{"id": "cvdp_copilot_gcd_0001", "categories": ["cid003", "easy"], "input": {"prompt": "The **Greatest Common Divisor (GCD)**, also known as the Greatest Common Factor (GCF) or Highest Common Factor (HCF), is the largest positive integer that divides two or more integers without leaving a remainder.\n\nCreate an RTL design with SystemVerilog, consisting of modules **gcd_top**, **gcd_controlpath** and **gcd_datapath** that computes the GCD of two inputs `A` and `B` using the Euclidean algorithm. \nThe Euclidean algorithm calculates the GCD by iteratively replacing the larger of two numbers with the difference between the two numbers. This process is repeated, reducing the larger number each time, until the two numbers become equal. At this point, the value of either number is the GCD of the original inputs. The module should be designed with a finite state machine (FSM) to control the computation and a datapath to perform arithmetic operations. The result of the computation is output as soon as the calculation completes, along with a signal indicating completion. The detailed design specification is given below :\n\n### **Design Specification** :\n---\n### **Functional Requirements**:\n\n- **Computation**: \n  - The complete design computes the GCD of two unsigned integers `A` and `B` using Euclidean algorithm.\n\n- **Integration**:\n   - The top-level module `gcd_top` should instantiate the control path and datapath modules `gcd_controlpath` and `gcd_datapath` and connect the signals.\n   - The `go` signal should initiate the computation, and the result should be available at the `OUT` output when `done` is set to active high.\n \n- **Control Path Design**:\n   - Use a finite state machine (FSM) to control the computation flow. It should manage the `done` signal and determine when to perform subtractions based on the results of the comparisons (`A == B` or `A > B`).\n \n- **Datapath Design**:\n   - The datapath should handle the arithmetic operations (subtraction and comparison) and provide the final result `OUT`.\n   - It should store intermediate values of `A` and `B` and send comparison results to the control path. \n\n---\n\n### **RTL Module Requirements**:\n\n\n### **1. GCD Control Path Module (`gcd_controlpath`)**:\n\nThe control path handles the state transitions of the GCD computation process using a finite state machine (FSM).\n\n- **Parameters**:\n\n     - `WIDTH` (Default 4, must be greater than 0): Bit-width of `A`, `B` and `OUT `.\n     \n- **Inputs**:\n  - `clk`: Clock signal. The design should be synchronized to the positive edge of this clock signal.\n  - `rst`: Active high Synchronous reset signal.\n  - `go`: Start signal for GCD computation. Active high.\n  - `equal`: Signal from the datapath indicating that `A == B`. Active high.\n  - `greater_than`: Signal from the datapath indicating `A > B`. Active high.\n\n- **Outputs**:\n  - `controlpath_state [1:0]`: Current FSM state sent to the datapath to control its operations.\n  - `done`: Signal indicating that the computation is complete (`A == B`). Active high.\n\n- **FSM States**:\n  - **S0 (IDLE)**: Wait for `go` to be set to high. No operation until `go` is received.\n  - **S1 (DONE)**:Set  `done` to high when `A == B`. Return to `S0` after output is provided.\n  - **S2 (A > B)**: Control the datapath to subtract `B` from `A`.\n  - **S3 (B > A)**: Control the datapath to subtract `A` from `B`.\n  - **Default**: Transition to S0 state, without performing any computation.\n\n- **Behavior**:\n  - Output `controlpath_state` signal to communicate the current FSM state to the datapath, instructing it which operation to perform.\n  - The `done` signal is set to active high for one clock cycle to indicate the completion of the operation when the `equal` signal from the datapath is received.\n  - Both output signals should be synchronized to the positive edge of the clock.\n\n### **2. GCD Datapath Module (`gcd_datapath`)**:\n\nThe datapath performs the arithmetic operations required by the Euclidean algorithm, such as comparing `A` and `B` and updating their values.\n\n- **Parameters**:\n\n     - `WIDTH` (Default 4, must be greater than 0): Bit-width of `A`, `B` and `OUT `.\n     \n- **Inputs**:\n  - `clk`: Clock signal. The design should be synchronized to the positive edge of this clock signal.\n  - `rst`: Active high Synchronous reset signal.\n  - `A [WIDTH-1:0]`: input value A (unsigned and non-zero).\n  - `B [WIDTH-1:0]`: input value B (unsigned and non-zero).\n  - `controlpath_state [1:0]`: The current state of the control path FSM.\n\n- **Outputs**:\n  - `OUT [WIDTH-1:0]`: output holding the GCD value (unsigned). The value of `OUT` is updated every time the `done` signal is asserted. \n  - `equal`: Signal indicating that `A == B`. Active high.\n  - `greater_than`: Signal indicating that `A > B`. Active high.\n\n- **Behavior**:\n  - Latches the input values `A` and `B` into internal registers `A_ff` and `B_ff`, for manipulation when the control path initiates a new computation.\n  - The `equal` and `greater_than` signals are generated using combinational logic based on the values of `A` and `B` in the `S0` state and the values of `A_ff` and `B_ff` in all other states by continuously comparing the values of `A_ff` and `B_ff` as directed by the controlpath_state signals. These 2 signals are sent back to the control path to guide state transitions.\n  - Based on control signals, at each clock cycle repeatedly subtracts the smaller value from the larger until `A_ff` and `B_ff` are equal.\n  - Based on control path signals, the GCD result is assigned to `OUT` at the positive edge of the clock when the computation is complete.\n\n### **3. GCD Top Module (`gcd_top`)**:\n\nThe top-level module integrates the control path and datapath modules. It receives the inputs, manages the computation process, and outputs the GCD.\n\n- **Parameters**:\n\n     - `WIDTH` (Default 4, must be greater than 0): Bit-width of `A`, `B` and `OUT `.\n\n- **Inputs**:\n  - `clk`: Clock signal. The design should be synchronized to the positive edge of this clock signal..\n  - `rst`: Active high synchronous reset signal.\n  - `A [WIDTH-1:0]`: input value A (unsigned and non-zero). \n  - `B [WIDTH-1:0]`: input value B (unsigned and non-zero).\n  - `go`: Start signal to initiate GCD calculation. Active high.\n\n- **Outputs**:\n  - `OUT [WIDTH-1:0]`: output for the calculated GCD (unsigned) from `gcd_datapath`.\n  - `done`: Signal that indicates when the computation is complete from `gcd_controlpath`. \n\n### **Design Constraints**:\n\n- **Input Constraints**:\n  - Inputs `A` and `B` must be stable and valid before setting the `go` signal to active high.\n  - Both `A` and `B` are unsigned integers (range 1 to 2<sup>`WIDTH`</sup>-1). The GCD module only supports this range for computation.\n  - `clk` must be a stable clock signal, and `rst` must be used to reset internal registers, FSM states and outputs to the initial state.\n  - Assume that `go` is high for 1 clock cycle for every new input `A` and `B`. The `go` for a new input will be provided only from the next cycle following the assertion of `done` signal to high, indicating that the computation for the previous inputs is complete.\n\n- **Output Constraints**:\n  - The `OUT` signal is valid and updated only along with assertion of `done` to high. Otherwise, it holds the previously computed GCD value. The `OUT` signal is reset to 0 when `rst` is active high.\n  - The `done` signal goes high for 1 clock cycle to indicate completion of computation. The `done` signal goes low when `rst` is active high.\n\n- **Latency and Timing**:\n   - The design can have different latencies for different inputs. The best case occurs when `A == B` from the start (2 cycles), and the worst case occurs when A = 1 and B =  2 <sup>WIDTH</sup>-1  ( 2<sup>WIDTH</sup>+1 cycles).\n   \n- **Example operation**:\n  - For `WIDTH`=16:  Inputs are `A`=4, `B`=2, `go` asserted high for 1 cycle\n  - `OUT`=2 and `done`=1(for 1 clock cycle) ", "context": {}}, "output": {"response": "", "context": {"rtl/gcd_top.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n\n", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/gcd_top.sv\nTOPLEVEL        = gcd_top\nMODULE          = test_gcd_top\nPYTHONPATH      = /src\nHASH            = 1-rtl-design-for-greatest-common-divisor-gcd-computation", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\n", "src/test_gcd_top.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nfrom cocotb.regression import TestFactory\nimport random\n\n# Function to calculate GCD in software for comparison\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\n# Coroutine to reset the DUT\nasync def reset_dut(dut):\n    dut.rst.value = 1\n    dut.go.value  = 0\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    assert dut.OUT.value == 0, f\"Reset Test failed OUT Expected 0, got {int(dut.OUT.value)}\"\n    assert dut.done.value == 0, f\"Reset Test failed done Expected 0, got {int(dut.done.value)}\"\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n    assert dut.OUT.value == 0, f\"Reset Test failed OUT Expected 0, got {int(dut.OUT.value)}\"\n    assert dut.done.value == 0, f\"Reset Test failed done Expected 0, got {int(dut.done.value)}\"\n\n# Main GCD test coroutine\n@cocotb.test()\nasync def gcd_test(dut):\n    \"\"\" Test GCD calculation for different combinations of A and B \"\"\"\n    \n    # Start the clock with 10ns period\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    width  = int(dut.WIDTH.value)\n    max = (1 << width) - 1\n    # Reset the DUT\n    await reset_dut(dut)\n    \n    # Define test cases for non-zero, positive numbers\n    test_cases = [\n        (1, 1),    # GCD(1, 1) = 1\n        (4, 2),    # GCD(4, 2) = 2\n        (6, 3),    # GCD(6, 3) = 3\n        (15, 5),   # GCD(15, 5) = 5\n        (8, 4),    # GCD(8, 4) = 4\n        (9, 6),    # GCD(9, 6) = 3\n        (12, 8),   # GCD(12, 8) = 4\n        (14, 7),   # GCD(14, 7) = 7\n        (max, 1),   # (worst case for WIDTH )\n        (max, max)  # (best case for WIDTH )\n    ]\n    \n    # Test all pre-defined test cases\n    for A, B in test_cases:\n        # Apply inputs\n        dut.A.value  = A\n        dut.B.value  = B\n        dut.go.value = 1\n        latency      = 0\n        \n        # Wait for the `done` signal\n        await RisingEdge(dut.clk)\n        # Release go signal\n        dut.go.value = 0\n        await RisingEdge(dut.clk)\n        latency      = latency + 1\n        while (dut.done.value == 0):\n            await RisingEdge(dut.clk)\n            latency      = latency + 1\n        \n        # Compare the result with expected GCD\n        expected_gcd = gcd(A, B)\n        assert dut.OUT.value == expected_gcd, f\"Test failed with A={A}, B={B}. Expected {expected_gcd}, got {int(dut.OUT.value)}\"\n        if((A==2**width-1) & (B==1)):\n            assert latency == 2**width+1,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        elif((A==1) & (B==2**width-1)):\n            assert latency == 2**width+1,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        elif((A==B)):\n            assert latency == 2,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        await RisingEdge(dut.clk)\n        assert dut.done.value == 0, f\"Done should be high for only 1 clk cycle expected 0, got {int(dut.done.value)}\"\n        latency = 0\n    # Reset the DUT\n    await reset_dut(dut)\n        \n# Additional stress test with random values for A and B\n@cocotb.test()\nasync def gcd_stress_test(dut):\n    \"\"\" Stress test GCD calculation with random non-zero, positive values \"\"\"\n    \n    # Start the clock with 10ns period\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    latency      = 0\n    \n    # Reset the DUT\n    await reset_dut(dut)\n    \n    width  = int(dut.WIDTH.value)\n    \n    # Run random test cases\n    for _ in range(100):\n        A = random.randint(1, 2**width-1)  # A is positive number\n        B = random.randint(1, 2**width-1)  # B is positive number\n        latency = 0\n\n        # Apply inputs\n        dut.A.value  = A\n        dut.B.value  = B\n        dut.go.value = 1\n        \n        # Wait for the `done` signal\n        await RisingEdge(dut.clk)\n        # Release go signal\n        dut.go.value = 0\n        while (dut.done.value == 0):\n            await RisingEdge(dut.clk)\n            latency      = latency + 1\n        \n        # Compare the result with expected GCD\n        expected_gcd = gcd(A, B)\n        assert dut.OUT.value == expected_gcd, f\"Test failed with A={A}, B={B}. Expected {expected_gcd}, got {int(dut.OUT.value)}\"\n        if((A==2**width-1) & (B==1)):\n            assert latency == 2**width+1,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        elif((A==1) & (B==2**width-1)):\n            assert latency == 2**width+1,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        elif((A==B)):\n            assert latency == 2,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        \n        await RisingEdge(dut.clk)\n        assert dut.done.value == 0, f\"Done should be high for only 1 clk cycle expected 0, got {int(dut.done.value)}\"\n        latency = 0\n    \n    # Reset the DUT\n    await reset_dut(dut)", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner(WIDTH: int=5):\n    \n    parameter = {\"WIDTH\":WIDTH}\n    # Debug information\n    print(f\"[DEBUG] Running simulation with WIDTH={WIDTH}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        parameters=parameter,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Parametrize test for different WIDTH and SIGNED_EN\n@pytest.mark.parametrize(\"WIDTH\", [4,6,8,16])\n\ndef test_gcd(WIDTH):\n    # Run the simulation with specified parameters\n    test_runner(WIDTH=WIDTH)"}}}
{"id": "cvdp_copilot_gf_multiplier_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design the System Verilog module `gf_multiplier` for a 4-bit Galois Field Multiplier (GF(2<sup>4</sup>)) by utilizing the irreducible polynomial **x<sup>4</sup> + x + 1**. The multiplication should be operated between two 4-bit values to result in a 4-bit product output.\n\n### Interface\n\n#### Inputs:\n\n- **A ([3:0], 4-bit)**: The multiplicand. It should contain a 4-bit value between 0000 and 1111.\n- **B ([3:0], 4-bit)**: The multiplier. It should contain a 4-bit value between 0000 and 1111.\n\n#### Output:\n\n- **result ([3:0], 4-bit)**: The product of the two input values using the GF multiplication algorithm.\n\n## Design Specification:\n\n- This design has to ensure that any overflow occurring during the multiplication process is reduced by the irreducible polynomial, ensuring the result remains within 4 bits.\n- The design should follow combinational logic and produce the multiplication output whenever the input changes\n- **Registers**: A set of 4-bit internal registers are to be used to hold the multiplicand and the intermediate result.\n- **Polynomial Reduction**: The irreducible polynomial **x<sup>4</sup> + x + 1** (represented as `5'b10011`) has to be used for polynomial reduction in case of overflow during the multiplication process.\n- For each bit of the multiplier, the multiplicand has to be conditionally XORed with the result and shifted to left by one bit. If overflow occurs, polynomial reduction is performed using the irreducible polynomial.\n\nThe algorithm of the GF multiplier to be followed in the RTL design is given below:\n\n### Algorithm:\n\n```\n1. Initialize `result` = 0\n2. Set multiplicand = `A`\n3. For each bit (i) of the multiplier `B` (from LSB to MSB):\n   - If the bit (i) of `B` is 1, `result` = `result` XOR multiplicand\n      - Shift multiplicand to the left by 1 bit\n      - If the MSB of the multiplicand is 1 after shifting, perform polynomial reduction:\n         multiplicand = multiplicand XOR binary representation of irreducible polynomial (5'b10011)\n   - else if the bit (i) of B is 0, result remains the same as `result` = `result` XOR 0\n     - Shift multiplicand to the left by 1 bit\n     - If the MSB of the multiplicand is 1 after shifting, perform polynomial reduction:\n         multiplicand = multiplicand XOR binary representation of irreducible polynomial (5'b10011)\n4. Return the final result\n```\n\n### Example computation:\n\nAssume A = 3 (`0011`) and B = 7 (`0111`)\n\n1. **Initialization**:\n   - `A` = 3 (`0011`)\n   - `B` = 7 (`0111`)\n   - `result` = 0\n2. **Iteration 1** (Multiplier's LSB is 1, index B[0]):\n   - `result` = 0 XOR `0011` = `0011`\n   - Shift multiplicand: `0011` << 1 = `0110` (No polynomial reduction as MSB is 0)\n3. **Iteration 2** (Next bit is 1, index B[1]):\n   - `result` = `0011` XOR `0110` = `0101`\n   - Shift multiplicand: `0110` << 1 = `1100` (No polynomial reduction as MSB is 0)\n4. **Iteration 3** (Next bit is 1, index B[2]):\n   - `result` = `0101` XOR `1100` = `1001`\n   - Shift multiplicand: `1100` << 1 = `11000` (Perform polynomial reduction as MSB is 1)\n   - Polynomial reduction: `11000` XOR `10011` = `01011` (Multiplicand becomes `1011`)\n5. **Iteration 4** (Next bit is 0, index B[3]):\n   - `result` = `1001` XOR 0 = `1001`\n6. **Final Step**:\n   - The final result of GF multiplication after all iterations is `1001`, which is 9 in decimal.", "context": {}}, "output": {"response": "", "context": {"rtl/gf_multiplier.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/gf_multiplier.sv\nTOPLEVEL        = gf_multiplier\nMODULE          = test_gf_mult\nPYTHONPATH      = /src\nHASH            = 1-design-rtl-for-4-bit-galois-field-multiplier-using-irreducible-polynomial", "src/test_gf_mult.py": "import cocotb\nfrom cocotb.triggers import Timer\nimport random\n\n# Function to perform GF(2^4) multiplication with polynomial reduction\ndef gf_mult(a, b):\n    irreducible_poly = 0b10011  # x^4 + x + 1 (10011 in binary)\n    result = 0\n\n    print(f\"Calculating GF(2^4) multiplication for A = {a:04b}, B = {b:04b}\")\n    \n    # Perform multiplication using shift-and-add method\n    for i in range(4):  # 4-bit multiplication\n        if (b >> i) & 1:\n            result ^= a << i  # Add shifted multiplicand\n            print(f\"  - Bit {i} of B is 1: result = result XOR (A << {i}) = {result:08b}\")\n\n    # Perform polynomial reduction if the result exceeds 4 bits\n    print(f\"  Before reduction: result = {result:08b}\")\n    for i in range(7, 3, -1):  # Start checking from bit 7 down to bit 4\n        if result & (1 << i):  # If the bit is set\n            result ^= irreducible_poly << (i - 4)  # XOR with irreducible polynomial\n            print(f\"  - Bit {i} of result is 1: result = result XOR (irreducible_poly << {i - 4}) = {result:08b}\")\n\n    final_result = result & 0b1111  # Return the final result (4 bits)\n    print(f\"  Final reduced result: {final_result:04b}\\n\")\n    return final_result\n\n# Test for GF(2^4) multiplier with known vectors\n@cocotb.test()\nasync def gf_multiplier_basic_test(dut):\n    \"\"\"Test the GF multiplier with known test vectors\"\"\"\n    \n    # Test vector: A = 3 (0011), B = 1 (0001)\n    A = 3\n    B = 1\n    expected_result = gf_mult(A, B)\n    dut.A.value = A\n    dut.B.value = B\n    await Timer(1, units='ns')  # Small delay to allow propagation\n\n    actual_result = dut.result.value\n    cocotb.log.info(f\"Basic Test: A = {A}, B = {B}, Expected = {expected_result}, Actual = {actual_result}\")\n    assert actual_result == expected_result, f\"Test failed: {A} * {B} = {actual_result}, expected {expected_result}\"\n\n    # Test vector: A = 3 (0011), B = 7 (0111)\n    A = 3\n    B = 7\n    expected_result = gf_mult(A, B)\n    dut.A.value = A\n    dut.B.value = B\n    await Timer(1, units='ns')\n\n    actual_result = dut.result.value\n    cocotb.log.info(f\"Basic Test: A = {A}, B = {B}, Expected = {expected_result}, Actual = {actual_result}\")\n    assert actual_result == expected_result, f\"Test failed: {A} * {B} = {actual_result}, expected {expected_result}\"\n\n    # Test vector: A = 15 (1111), B = 15 (1111)\n    A = 15\n    B = 15\n    expected_result = gf_mult(A, B)\n    dut.A.value = A\n    dut.B.value = B\n    await Timer(1, units='ns')\n\n    actual_result = dut.result.value\n    cocotb.log.info(f\"Basic Test: A = {A}, B = {B}, Expected = {expected_result}, Actual = {actual_result}\")\n    assert actual_result == expected_result, f\"Test failed: {A} * {B} = {actual_result}, expected {expected_result}\"\n\n@cocotb.test()\nasync def gf_multiplier_random_test(dut):\n    \"\"\"Test the GF multiplier with random values\"\"\"\n    \n    # Perform 20 random tests\n    for i in range(20):\n        A = random.randint(0, 15)  # Random 4-bit value\n        B = random.randint(0, 15)  # Random 4-bit value\n        print(f\"Random Test {i + 1}: A = {A:04b}, B = {B:04b}\")\n        expected_result = gf_mult(A, B)  # Use the GF multiplication logic\n\n        dut.A.value = A\n        dut.B.value = B\n\n        await Timer(1, units='ns')  # Allow propagation delay\n\n        actual_result = dut.result.value\n        cocotb.log.info(f\"Random Test {i + 1}: A = {A}, B = {B}, Expected = {expected_result}, Actual = {actual_result}\")\n        assert actual_result == expected_result, f\"Random test failed: {A} * {B} = {actual_result}, expected {expected_result}\"\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport re\nimport logging\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_hamming_code_tx_and_rx_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design a transmitter module **Module Name: hamming_code_tx_for_4bit** using SystemVerilog that encodes 4-bit input data (data_in) into an 8-bit output (data_out) using Hamming code principles for error detection. Hamming code helps generate parity bits, which are combined with the original data to detect and correct single-bit errors.\n\nThe relationship between number of data bits (m) and number of parity bits (p) follows the formula:\nFORMULA: 2<sup>p</sup> \u2265 (p + m) + 1\n\nFor 4 data bits, 3 parity bits are required, resulting in a total of 7 bits (3 parity + 4 data). An extra redundant bit is added to pad the output 8 bits. \n\nAdditional Information: On the receiver side, if p is a 3-bit value, we have three syndrome bits (c3, c2, c1) calculated based on transmitted data and parity bits, to identify the position of the error bit within a total of 7 bits (3 parity bits + 4 data bits). Adding an extra redundant bit as the least significant bit in the transmitter keeps the actual 7 bits used in Hamming error detection separate (`data_out[7:1]`), simplifying the error location process where the 3 syndrome bits (c3, c2, c1) directly map to these 7 bits.\n\nThe parity bits are calculated using XOR operations to ensure \"even parity,\" which guarantees that the number of 1s in specified bit groups is even. They are placed at specific positions to ensure each bit position in the data can be checked for single-bit errors. These parity bit positions correspond to powers of 2 in the output structure (positions 1, 2, and 4 in this 8-bit layout), allowing for targeted error detection.\n\nDesign the module that generates these parity bits and outputs the final 8-bit encoded signal for transmission.\n\n### 1 Input/Output Specifications:\n\n1. Input:\n     `data_in[3:0]`: A 4-bit input signal representing the original data to be transmitted.\n3. Output:\n     `data_out[7:0]`: An 8-bit output signal representing the encoded data.\n\n### 2 Behavioral Definition:\n\nThe module should encode the data based on the following steps:\n\n1. `data_out[0]`: This bit is fixed to 0 as a redundant bit.\n2. `data_out[1]`: This is a parity bit, calculated using the XOR operation to ensure even parity of the input bits (`data_in`) at positions 0, 1, and 3 of data_in.\n3. `data_out[2]`: Another parity bit, calculated using XOR for even parity, but this time based on input bits (`data_in`) at positions 0, 2, and 3 of data_in.\n4. `data_out[4]`: A third parity bit, also using XOR for even parity, calculated based on input bits (`data_in`) at positions 1, 2, and 3 of data_in.\n5. `data_out[3]`, `data_out[5]`, `data_out[6]`, `data_out[7]`: These are assigned `data_in[0]`, `data_in[1]`, `data_in[2]`, `data_in[3]` respectively, preserving the order of the input data.\n\n### 3 Timing and Synchronization:\nThis design is purely combinational. The output must be immediately updated with a change in the input.\n\n### 4 Edge Cases:\nAssume that data_in will always be a valid 4-bit signal of 1s and 0s (including all zero input). Therefore, there is no need to handle invalid input cases explicitly.", "context": {}}, "output": {"response": "", "context": {"rtl/hamming_code_tx_for_4bit.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/hamming_code_tx_for_4bit.sv\nTOPLEVEL        = hamming_code_tx_for_4bit\nMODULE          = tx_test\nPYTHONPATH      = /src\nHASH            = 9caf948426ac559ff2bb461e36f57caf30c6cb19\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        #parameters= {'REVERSE': REVERSE },\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=False,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n# random test\n@pytest.mark.parametrize(\"test\", range(1))\ndef test(test):\n    runner()\n    \n", "src/tx_test.py": "import asyncio \nimport random\nimport cocotb\nfrom cocotb.triggers import Timer\n\ndef calculate_data_out(data_in):\n    # Convert data_in from string to binary list\n    temp = [int(bit) for bit in data_in]\n    \n    # Initialize data_out as a list with default values\n    data_out = [0] * 8\n    data_out[7] = 0\n    data_out[6] = temp[3] ^ temp[2] ^ temp[0]\n    data_out[5] = temp[3] ^ temp[1] ^ temp[0]\n    data_out[4] = temp[3]\n    data_out[3] = temp[2] ^ temp[1] ^ temp[0]\n    data_out[2] = temp[2]\n    data_out[1] = temp[1]\n    data_out[0] = temp[0]\n    \n    return data_out\n\n@cocotb.test()\nasync def tx_test(dut): \n    # Corner cases\n    corner_cases = [\"0000\", \"1111\", \"1010\", \"0101\"]\n\n    for data_in in corner_cases:\n        dut.data_in.value = int(data_in, 2)\n        expected_data_out = calculate_data_out(data_in)\n\n        await Timer(5, units=\"ns\")\n\n        expected_data_out_int = int(''.join(map(str, expected_data_out)), 2)\n        actual_data_out_int = int(dut.data_out.value)\n\n        # Assert to check if the output matches the expected result\n        assert actual_data_out_int == expected_data_out_int, f\"Corner Case - data_in={data_in}: expected={expected_data_out_int} got={actual_data_out_int}\"\n\n        dut._log.info(f'PASS: Corner Case - data_in={data_in} expected_data_out={expected_data_out} actual_data_out={dut.data_out.value}')\n\n    # Randomized tests\n    for _ in range(10):\n        data_in = ''.join(str(random.randint(0, 1)) for _ in range(4))\n        \n        dut.data_in.value = int(data_in, 2)\n        expected_data_out = calculate_data_out(data_in)\n\n        await Timer(5, units=\"ns\")\n\n        expected_data_out_int = int(''.join(map(str, expected_data_out)), 2)\n        actual_data_out_int = int(dut.data_out.value)\n\n        # Assert to check if the output matches the expected result\n        assert actual_data_out_int == expected_data_out_int, f\"Random Test - data_in={data_in}: expected={expected_data_out_int} got={actual_data_out_int}\"\n\n        dut._log.info(f'PASS: Random Test - data_in={data_in} expected_data_out={expected_data_out} actual_data_out={dut.data_out.value}')\n            \n"}}}
{"id": "cvdp_copilot_hamming_code_tx_and_rx_0003", "categories": ["cid003", "easy"], "input": {"prompt": "Design a SystemVerilog module named `hamming_code_receiver` that decodes an 8-bit input signal and detects single-bit errors using Hamming code principles. The receiver performs \"even parity checks\" to identify any single-bit errors in `data_in` and provides corrected 4-bit data to output port `data_out[3:0]` \n\n### 1. Inputs\n- **`data_in[7:0]`**:  8-bit input signal containing 4 data bits, 3 parity bits, and 1 redundant bit\n\n### 2. Outputs\n- **`data_out[3:0]`**: An 4-bit output signal containing the corrected data if an error is detected. If no error is detected, this output will mirror the data bits in the the input (`data_in`).\n\n### 3. Explanation of Data Structure\n\nThe transmitted data includes 4 data bits and 3 parity bits, organized within `data_in[7:1]`. An extra redundant bit at `data_in[0]` extends the input to 8 bits, separating the 7 bits used in Hamming code error detection (`data_in[7:1]`) from the redundant bit. This organization allows the receiver to calculate three syndrome bits {`c1, c2, c3`}, which directly indicate the position of any error among the 7 significant bits in `data_in[7:1]`.\n\n### 4. Behavioral Definition \nThe receiver\u2019s task is to decode this 7-bit data (`data_in[7:1]`), and detect errors using the even parity error detection (by performing XOR on specific data and parity bits of `data_in` as explained below).\n\n- **Parity bits** are placed at positions that are **powers of 2** in `data_in`:\n  - 2<sup>0</sup> = 1, 2<sup>1</sup> = 2, 2<sup>2</sup> = 4\n- **Data bits** are placed **sequentially** at positions that are **Non powers of 2** in `data_in`,  as given below.\n\n| Position  | Index | Type      \n|-----------|-------|-----------|\n| 000       | 0     | Redundant |\n| 001       | 1     | Parity bit 1  |\n| 010       | 2     | Parity bit 2  |\n| 011       | 3     | Data bit 1    |\n| 100       | 4     | Parity bit 3  |\n| 101       | 5     | Data bit 2   |\n| 110       | 6     | Data bit 3   |\n| 111       | 7     | Data bit 4   |\n\n4.1 **Even Parity Error Detection Logic:**\n\nSince there are 3 parity bits, the **even parity error detector logic** produces 3-bits `{c1, c2, c3}`. \n\n#### c3:\n- Check all positions in `data_in` where the binary index has a 1 in the least significant bit (LSB) position (00**1**, 01**1**, 10**1**, 11**1**)\n- **Even Parity Check**: XOR of bits `data_in[1]`, `data_in[3]`, `data_in[5]`, and `data_in[7]`.\n#### c2:\n- Check all positions in `data_in` where the binary index has a 1 in the Second LSB position (0**1**0, 0**1**1, 1**1**0, 1**1**1)\n- **Even Parity Check**: XOR of bits `data_in[2]`, `data_in[3]`, `data_in[6]`, and `data_in[7]` .\n#### c1:\n- Check all positions in `data_in` where the binary index has 1 in the most significant MSB position (**1**00, **1**01, **1**10, **1**11)\n- **Even Parity Check**: XOR of bits `data_in[4]`, `data_in[5]`, `data_in[6]`, and `data_in[7]` .\n\n#### Error Indication by {c1, c2, c3}:\n- Result of **1** in any of the bits: Indicates an error (odd number of 1s).\n- Result of **0** in any of the bits: No error (even number of 1s).\n\n4.2 **Error Detection and Correction:**\n- By combining the three error detection bits `(c1, c2, c3)`, the exact location of the erroneous bit in `data_in` can be identified.\n- If an error is detected, the bit at the position indicated by `{c1, c2, c3}` is corrected.\n- This operation will correct both data and parity bits. (The redundant bit is not corrected, nor is it part of `data_out`)\n- If no error is detected, the data is passed through unchanged.\n\n- **Case 1:** If `{c1, c2, c3} == 3'b000`, it points to position 0 of `data_in`, which is `data_in[0]`, the extra redundant bit. This means no error in data or parity bits in `data_in`, as indicated by the extra bit's position.\n- **Case 2:** If `{c1, c2, c3} != 3'b000`, example: `{c1, c2, c3} == 3'b001`, it points to position **1** of `data_in`, making `data_in[1]` the error bit. In this case, the error bit must be **inverted** to correct the input.\n\n4.3 **Output assignment:**\n- After error correction, fetch the **data bits** from the decoded input, which holds the corrected data, and assign those **data bits** to the output port `data_out`. (`data_out` will contain corrected data bits at positions 7,6,5, and 3)\n\n### 4. Timing and Synchronization\n- This design is combinational and output should be immediately updated with a change in the input.\n\n### 5. Constraints\n- The design assumes that input data will contain only single-bit errors.", "context": {}}, "output": {"response": "", "context": {"rtl/hamming_code_receiver.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/hamming_code_receiver.sv\nTOPLEVEL        = hamming_code_receiver\nMODULE          = test_hamming_code_receiver\nPYTHONPATH      = /src\nHASH            = c35e77e3ea4e4bd02dc6b4798b0cf2ecf2bbd09e\n", "src/test_hamming_code_receiver.py": "import cocotb\nfrom cocotb.triggers import Timer\nimport random\n\n# Define the Hamming Code transmitter function in Python\ndef hamming_code_tx(data_in):\n    \"\"\"Hamming code transmission function for 4-bit input data.\"\"\"\n    data_out = [0] * 8\n    data_out[7] = 0  # Assuming the parity bit for the whole message is zero for now\n    data_out[6] = data_in[3] ^ data_in[2] ^ data_in[0]\n    data_out[5] = data_in[3] ^ data_in[1] ^ data_in[0]\n    data_out[4] = data_in[3]\n    data_out[3] = data_in[2] ^ data_in[1] ^ data_in[0]\n    data_out[2] = data_in[2]\n    data_out[1] = data_in[1]\n    data_out[0] = data_in[0]\n    \n    return data_out\n\n@cocotb.test()\nasync def test_hamming_code_receiver(dut):\n    \"\"\"Cocotb testbench for the Hamming code receiver, including corner cases and randomized data input.\"\"\"\n    \n    # Define specific corner cases\n    corner_cases = [\n        0b0000,  # All zeros\n        0b1111,  # All ones\n        0b0001,  # Single bit set\n        0b0010,  # Single bit set\n        0b0100,  # Single bit set\n        0b1000,  # Single bit set\n        0b1100,  # Multiple bits set\n        0b1010,  # Alternating bits\n    ]\n\n    # Test each corner case\n    for i, data_in in enumerate(corner_cases, start=1):\n        # Generate transmitted data using Hamming code\n        data_out = hamming_code_tx([int(x) for x in f\"{data_in:04b}\"])\n\n        await Timer(10, units=\"ns\")\n\n        # Modify one bit randomly in the transmitted data\n        modified_data = list(data_out)  # Make a copy of data_out\n        bit_to_flip = random.randint(0, 7)\n        modified_data[bit_to_flip] = 1 - modified_data[bit_to_flip]\n        \n        # Send modified data to the receiver\n        dut.data_in.value = int(\"\".join(map(str, modified_data)), 2)\n        await Timer(10, units=\"ns\")\n\n        # Capture receiver outputs\n        correct_data = dut.data_out.value.to_unsigned()\n\n        # Debug Logging Before Assertion\n        dut._log.info(f\"Test {i} - Modified Data: {''.join(map(str, modified_data))}, Bit to Flip: {bit_to_flip}\")\n        #dut._log.info(f\"Test {i} - Correct Data: {correct_data:08b} ({correct_data}), Expected Data: {''.join(map(str, data_out[:7]))}\")\n\n        # Determine expected result based on the bit flipped\n        # Standard comparison when bit_to_flip is not 7\n        expected_data = int(\"\".join(map(str, data_out)), 2)\n        assert correct_data == data_in, f\"Corner Case Test {i}: Corrected data does not match expected: {correct_data:04b} != {data_in:04b}\"\n        \n        dut._log.info(f\"Corner Case Test {i} - Original data: {data_in:04b}, Transmitted: {''.join(map(str, data_out))}, Modified: {''.join(map(str, modified_data))}, Corrected data: {correct_data:04b}\")\n        dut._log.info(\"-\" * 40)\n\n    # Randomized testing for 10 iterations\n    for i in range(10):\n        data_in = random.randint(0, 15)  # Generate random 4-bit data\n        data_out = hamming_code_tx([int(x) for x in f\"{data_in:04b}\"])\n\n        await Timer(10, units=\"ns\")\n\n        # Modify one bit randomly in the transmitted data\n        modified_data = list(data_out)\n        bit_to_flip = random.randint(0, 7)\n        modified_data[bit_to_flip] = 1 - modified_data[bit_to_flip]\n        \n        # Send modified data to the receiver\n        dut.data_in.value = int(\"\".join(map(str, modified_data)), 2)\n        await Timer(10, units=\"ns\")\n\n        # Capture receiver outputs\n        correct_data = dut.data_out.value.to_unsigned()\n\n        # Debug Logging Before Assertion\n        dut._log.info(f\"Random Test {i+1} - Modified Data: {''.join(map(str, modified_data))}, Bit to Flip: {bit_to_flip}\")\n        #dut._log.info(f\"Random Test {i+1} - Correct Data: {correct_data:08b} ({correct_data}), Expected Data: {''.join(map(str, data_out[:7]))}\")\n\n        expected_data = int(\"\".join(map(str, data_out)), 2)\n        assert correct_data == data_in, f\"Random Test {i+1}: Corrected data does not match expected: {correct_data:04b} != {data_in:04b}\"\n\n        \n        dut._log.info(f\"Random Test {i+1} - Original data: {data_in:04b}, Transmitted: {''.join(map(str, data_out))}, Modified: {''.join(map(str, modified_data))}, Corrected data: {correct_data:04b}\")\n        dut._log.info(\"-\" * 40)\n    \n    \n    \n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        #parameters= {'REVERSE': REVERSE },\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=False,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n# random test\n@pytest.mark.parametrize(\"test\", range(1))\ndef test(test):\n    runner()\n    \n"}}}
{"id": "cvdp_copilot_hebbian_rule_0017", "categories": ["cid003", "medium"], "input": {"prompt": "Design a SystemVerilog RTL module `hebbian_rule` that implements a Moore Finite State Machine (FSM) to train a Hebbian learning model. The module takes signed 4-bit inputs (`a` and `b`), a 2-bit gate selector, and control signals for starting the FSM and resetting the system. It sequentially performs training steps such as weight initialization, target selection, weight/bias updates, and convergence checks using the Hebbian learning rule. The module outputs the updated weights (`w1` and `w2`), bias, and the FSM's current state and next state. The system uses a gate selection module to determine the target outputs based on logical gate operations for training.\n\n## Design Specifications:\n- Hebbian rule is a type of unsupervised neural network learning algorithm\n\n## Abstract Algorithm:\n- The hebbian or hebb rule works based on the following algorithm\n\n-  **Step 1**: Initialize all the weights and bias to zero.\n                                  w<sub>I</sub> = 0 for i = 1 to n , n is the number of input vectors\n\n- **Step 2**: For each input training vector and target output pair, do the following:\n\n    - **Step 2a**: Set activation for input units\n                         x<sub>i</sub>=s<sub>i</sub>, x is a register to store the input vector, where x is a register to store the input vector\n\n    -  **Step 2b**: Set activation for output unit\n                            y = t, where t is the target vector and y is the output vector\n\n    -  **Step 2c**: Adjust the weights and bias\n                         w<sub>i</sub>(new) = w<sub>i</sub>(old) + delta_w\n                         bias(new) = bias(old) + delta_b\n                          Where:\n                            delta_w = x<sub>I</sub> * t\n                            delta_b = t\n                   \n## Inputs and Outputs:\n## Inputs:\n- `clk` (1-bit): Posedge Clock signal.\n- `rst` (1-bit): Asynchronous Negedge Reset signal. When asserted LOW , the FSM is initialized to State_0 and iteration counter is initialized to 0.\n- `start `(1-bit): Active HIGH Signal to initiate the FSM.\n- `a`, `b` (4-bit each, [3:0],signed): Bipolar input signals [-1 ,1]. Only -1 and 1 have to be considered as valid inputs\n- `gate_select` (2-bit,[1:0]): Selector to specify the target for a given gate\n## Outputs:\n- `w1`, `w2` (4-bit each,[3:0], signed): Trained weights for the inputs.\n- `bias` (4-bit, signed,[3:0]): Trained bias value.\n- `present_state`, `next_state` (4-bit each,[3:0]): Current and next states of the Training FSM.\n\n## Learning Logic:\n- Weights (w1, w2) and bias are updated incrementally based on the input values and a computed error:\n    delta_w1 = x1 * target\n    delta_w2 = x2 * target\n    delta_b = target \n    w1 = w1 + delta_w1\n    w2 = w2 + delta_w2\n    bias = bias + delta_b\n\n- Target values are determined using a `gate_target` submodule based on `gate_select`:\n  - gate_select = 2'b00: AND gate behavior.\n  - gate_select = 2'b01: OR gate behavior.\n  - gate_select = 2'b10: NAND gate behavior.\n  - gate_select = 2'b11: NOR gate behavior.\n\n## FSM Design:\nThere are totally 11 states handled by Moore FSM.\n- State_0: Reset state.\n- State_1: Capture inputs.\n- State_2-State_6: Assign targets based on the selected gate.\n- State_7: Compute deltas for weights and bias.\n- State_8: Update weights and bias.\n- State_9: Loop through training iterations.\n- State_10: Return to the initial state.\n\n## Functional Requirements:\n- Weight adjustment must follow the Hebbian learning rule.\n- The FSM must support multiple training iterations for every possible input combination of a two-input logic gate.\n- Outputs (`w1`, `w2`, `bias`) should reflect trained values at the end of the process.\n\n## Testbench:\n- Validate learning for all gates (`gate_select` = 2'b00 to 2'b11).\n- Test with various input combinations (`a`, `b`) to observe weight and bias updates.\n- Ensure the FSM transitions and outputs align with the design.\n\n## Example Calculation:\nLet us take the AND gate for explaining the working of the module.\nLet the 4-bit inputs be : `a = 4'b0001` and `b = 4'b0001`.\nThe target expected for this input combination is `4'b0001`.\n\n## Algorithmic Explanation :\n-  1. Initialize the weights and bias registers to 0\n            `w1 = 4'b0000` , `w2 = 4'b0000` , `bias = 4'b0000`;\n-  2. Capture the inputs `a` and `b` into two internal registers namely x1 and x2.\n            `x1 = 4'b0001` (Holds the contents of operand `a`)\n            `x2 = 4'b0001` (Holds the contents of operand `b`)\n-  3. Select the target required for the given input combination \n          ` t1 = 4'b0001`\n-  4. Calculate the incremental values of w1(`delta_w1`), w2(`delta_w2`), b(`delta_b`)\n            `delta_w1 = x1 * t = 4'b0001 * 4'b0001 = 4'b0001`\n            `delta_w2 = x2 * t = 4'b0001 * 4'b0001 = 4'b0001`\n            `delta_b  = t = 4'b0001`\n-  5. Calculate the values of w1 , w2 , bias\n            `w1   = w1 + delta_w1  = 4'b0000 + 4'b0001 = 4'b0001`; (1 in decimal)\n            `w2   = w2 + delta_w2  = 4'b0000 + 4'b0001 = 4'b0001`; (1 in decimal)\n            `bias = bias + delta_b = 4'b0000 + 4'b1111 = 4'b0001`; (1 in decimal)\n\nExample Waveform:\n```wavedrom\n{\n  \"signal\": [\n    {\"name\": \"clk\", \"wave\": \"p................\"},\n    {\"name\": \"rst\", \"wave\": \"0...1............\", \"data\": []},\n    {\"name\": \"a[3:0]\", \"wave\": \"0...3444.........\", \"data\": [\"4'd1\",\"4'd1\",\"-4'd1\",\"-4'd1\"]},\n    {\"name\": \"b[3:0]\", \"wave\": \"0...3444.........\", \"data\": [\"4'd1\",\"-4'd1\",\"4'd1\",\"-4'd1\"]},\n    {\"name\": \"gate_select[1:0]\", \"wave\": \"x...3............\", \"data\": [\"2'b00\"]},\n    {\"name\": \"w1[3:0]\", \"wave\": \"0...4444.........\", \"data\": [\"4'd1\",\"4'd0\",\"4'd1\",\"4'd2\"]},\n    {\"name\": \"w2[3:0]\", \"wave\": \"0...4444.........\", \"data\": [\"4'd1\",\"4'd2\",\"4'd1\",\"4'd2\"]},\n    {\"name\": \"bias[3:0]\", \"wave\": \"0...4444.........\", \"data\": [\"4'd1\",\"4'd0\",\"-4'd1\",\"-4'd2\"]},\n    {\"name\": \"present_state[3:0]\", \"wave\": \"0...3333.........\", \"data\": [\"4'd0..49\",\"4'd0..4'd9\",\"4'd0..4'd9\",\"4'd0..4'd10\"]}\n    ],\n  \"config\": {\"hscale\": 3}\n}\n```", "context": {}}, "output": {"response": "", "context": {"rtl/hebb_gates.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir  \n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/hebb_gates.sv\nTOPLEVEL        = hebb_gates\nMODULE          = test_hebb_gates\nPYTHONPATH      = /src\nHASH            = 17-hebbian_rule_rtl_design_generation_issue\n", "src/test_hebb_gates.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n@cocotb.test()\nasync def test_hebb_gates(dut):\n    \"\"\"Test the hebb_gates module with different gate selections and inputs.\"\"\"\n\n    # Create a 10ns clock\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Reset logic\n    dut.rst.value = 0\n    await Timer(10, units=\"ns\")\n    dut.rst.value = 1\n\n    # Initialize inputs\n    dut.start.value = 0\n    dut.a.value = 0\n    dut.b.value = 0\n    dut.gate_select.value = 0\n\n    await RisingEdge(dut.rst)\n    await Timer(10, units=\"ns\")\n\n    # Helper function for applying stimulus and logging outputs\n    async def apply_stimulus(a, b, gate_select, duration):\n        dut.a.value = a\n        dut.b.value = b\n        dut.gate_select.value = gate_select\n        await Timer(duration, units=\"ns\")\n        cocotb.log.info(f\"gate_select={gate_select}, a={a}, b={b}, w1={dut.w1.value.to_signed()}, w2={dut.w2.value.to_signed()}, bias={dut.bias.value.to_signed()}, state={bin(dut.present_state.value.to_unsigned())}\")\n\n    # Test AND gate targets (gate_select = 2'b00)\n    dut.gate_select.value = 0b00\n    dut.start.value = 1\n    cocotb.log.info(\"Start of AND gate Training\")\n\n    await apply_stimulus(1, 1, 0b00, 60)\n    await apply_stimulus(1, -1, 0b00, 60)\n    await apply_stimulus(-1, 1, 0b00, 60)\n    await apply_stimulus(-1, -1, 0b00, 70)\n    assert dut.w1.value.to_signed() == 2, f\"Expected w1=1, but got {dut.w1.value.to_signed()}\"\n    assert dut.w2.value.to_signed() == 2, f\"Expected w2=1, but got {dut.w2.value.to_signed()}\"\n    assert dut.bias.value.to_signed() == -2, f\"Expected bias=-1, but got {dut.bias.value.to_signed()}\"\n    cocotb.log.info(\"End of AND gate Training\")\n\n    # Test OR gate targets (gate_select = 2'b01)\n    dut.gate_select.value = 0b01\n    cocotb.log.info(\"Start of OR gate Training\")\n\n    await apply_stimulus(1, 1, 0b01, 70)\n    await apply_stimulus(-1, 1, 0b01, 60)\n    await apply_stimulus(1, -1, 0b01, 60)\n    await apply_stimulus(-1, -1, 0b01, 70)\n    assert dut.w1.value.to_signed() == 2, f\"Expected w1=1, but got {dut.w1.value.to_signed()}\"\n    assert dut.w2.value.to_signed() == 2, f\"Expected w2=1, but got {dut.w2.value.to_signed()}\"\n    assert dut.bias.value.to_signed() == 2, f\"Expected bias=-1, but got {dut.bias.value.to_signed()}\"\n    cocotb.log.info(\"End of OR gate Training\")\n\n    # Test NAND gate targets (gate_select = 2'b10)\n    dut.gate_select.value = 0b10\n    cocotb.log.info(\"Start of NAND gate Training\")\n\n    await apply_stimulus(-1, -1, 0b10, 70)\n    await apply_stimulus(-1, 1, 0b10, 60)\n    await apply_stimulus(1, -1, 0b10, 60)\n    await apply_stimulus(1, 1, 0b10, 70)\n    assert dut.w1.value.to_signed() == -2, f\"Expected w1=1, but got {dut.w1.value.to_signed()}\"\n    assert dut.w2.value.to_signed() == -2, f\"Expected w2=1, but got {dut.w2.value.to_signed()}\"\n    assert dut.bias.value.to_signed() == 2, f\"Expected bias=-1, but got {dut.bias.value.to_signed()}\"\n    cocotb.log.info(\"End of NAND gate Training\")\n\n    # Test NOR gate targets (gate_select = 2'b11)\n    dut.gate_select.value = 0b11\n    cocotb.log.info(\"Start of NOR gate Training\")\n\n    await apply_stimulus(-1, -1, 0b11, 70)\n    await apply_stimulus(-1, 1, 0b11, 60)\n    await apply_stimulus(1, -1, 0b11, 60)\n    await apply_stimulus(1, 1, 0b11, 70)\n    assert dut.w1.value.to_signed() == -2, f\"Expected w1=1, but got {dut.w1.value.to_signed()}\"\n    assert dut.w2.value.to_signed() == -2, f\"Expected w2=1, but got {dut.w2.value.to_signed()}\"\n    assert dut.bias.value.to_signed() == -2, f\"Expected bias=-1, but got {dut.bias.value.to_signed()}\"\n    cocotb.log.info(\"End of NOR gate Training\")\n\n    # Randomized test cases\n    num_random_cases = 10  # Number of random test cases\n    for i in range(num_random_cases):\n        random_gate_select = random.randint(0, 3)  # Randomly select gate (0b00 to 0b11)\n        random_inputs = [(random.choice([-1, 1]), random.choice([-1, 1])) for _ in range(4)]\n\n        dut.gate_select.value = random_gate_select\n        dut.start.value = 1\n        cocotb.log.info(f\"Start of Random Test Case {i+1} for gate_select={bin(random_gate_select)}\")\n\n        for a, b in random_inputs:\n            await apply_stimulus(a, b, random_gate_select, 65)\n        cocotb.log.info(f\"End of Random Test Case {i+1} for gate_select={bin(random_gate_select)}\")\n    # Stop the test\n    dut.start.value = 0\n    cocotb.log.info(\"Test Completed\")\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\n# Fetch environment variables for simulation setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang = os.getenv(\"TOPLEVEL_LANG\", \"verilog\")\nsim = os.getenv(\"SIM\", \"icarus\")\ntoplevel = os.getenv(\"TOPLEVEL\", \"hebb_gates\")\nmodule = os.getenv(\"MODULE\", \"test_hebb_gates\")\nwave = os.getenv(\"WAVE\", \"0\")\n\n# Function to configure and run the simulation\ndef runner():\n    \"\"\"Runs the simulation for the microcode sequencer.\"\"\"\n    # Get the simulation runner\n    simulation_runner = get_runner(sim)\n\n    # Build the simulation environment\n    simulation_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,         # Always rebuild\n        clean=True,          # Clean previous build files\n        waves=True ,   # Enable waveform generation if WAVE=1\n        verbose=True,        # Verbose build and simulation output\n        timescale=(\"1ns\", \"1ns\"),  # Set the timescale for simulation\n        log_file=\"build.log\"      # Log file for the build process\n    )\n\n    # Run the testbench\n    simulation_runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True    # Enable waveform dump if WAVE=1\n    )\n\n# Pytest function to run the simulation\n##@pytest.mark.simulation\ndef test_hebb_gates():\n    \"\"\"Pytest function to execute the hebbian learning testbench.\"\"\"\n    print(\"Running hebbian learning testbench...\")\n    runner()\n\n"}}}
{"id": "cvdp_copilot_hill_cipher_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design an RTL module that implements the Hill cipher encryption algorithm with the following specifications:\n\n- **Block Size**: 3 letters (each letter represented by 5 bits).\n- **Key Matrix**: 3x3 matrix (each element represented by 5 bits).\n- **Modular Arithmetic**: All operations are based on modulo 26.\n\nThe Hill cipher is a classical symmetric encryption algorithm based on linear algebra. It operates on blocks of plaintext and uses matrix multiplication to produce ciphertext.\n\n### 1.1. Basic Concepts\n\n- **Plaintext**: The original message to be encrypted.\n- **Ciphertext**: The encrypted message.\n- **Block Size**: The number of letters processed at a time. The design has to use a block size of **3**.\n- **Key Matrix**: A square matrix used for encryption. For a block size of 3, the key matrix is a 3x3 matrix.\n- **Modular Arithmetic**: All calculations are performed on modulo 26, corresponding to the 26 letters of the English alphabet.\n\n### 1.2. Encryption Process\n\n1. **Convert Letters to Numbers**: Map each letter to a number (e.g., A=0, B=1, ..., Z=25).\n2. **Form Plaintext Vector**: Group the plaintext into blocks of 3 letters and represent them as column vectors.\n3. **Matrix Multiplication**: Multiply the key matrix by the plaintext vector.\n4. **Modulo Operation**: Apply modulo 26 to each element of the resulting vector.\n5. **Convert Numbers to Letters**: Map the resulting numbers back to letters to obtain the ciphertext.\n\n---\n\n## 2. Module Specifications\n\n### 2.1. Port Definitions\n\n#### 1. Clock and Reset\n\n- **`clk`**: Clock signal for synchronous operation. \n- **`reset`**: Asynchronous reset signal to initialize the module. Set the output `ciphertext` to 0 when the `reset` is HIGH.\n\n#### 2. Control Signals\n\n- **`start`**: A logic HIGH in this input initiates the encryption process.\n\n#### 3. Data Inputs\n\n- **`plaintext`**: 15-bit input representing 3 plaintext letters.\n  - Each letter is represented by 5 bits.\n  - Bit mapping:\n    - `plaintext[14:10]`: First letter.\n    -  `plaintext[9:5]`: Second letter.\n    - `plaintext[4:0]`: Third letter.\n\n- **`key`**: 45-bit input representing the 3x3 key matrix.\n  - Each element is represented by 5 bits.\n  - key value should vary from 00000 to 11001.\n  - Element mapping:\n    - `key[44:40]`: K <sub>00</sub>\n    - `key[39:35]`:  K <sub>01</sub>\n    - `key[34:30]`:  K <sub>02</sub>\n    - `key[29:25]`:  K <sub>10</sub>\n    - `key[24:20]`:  K <sub>11</sub>\n    - `key[19:15]`:  K <sub>12</sub>\n    - `key[14:10]`:  K <sub>20</sub>\n    - `key[9:5]`: K <sub>21</sub>\n    - `key[4:0]`:  K <sub>22</sub>\n\n#### 4. Data Output\n\n- **`ciphertext`**: 15-bit output representing the encrypted 3 letters.\n  - Bit mapping follows the same pattern as `plaintext`.\n- **`done`**: A HIGH in this output signal indicates that the encryption process is complete.\n\n### 2.2. Functional Requirements\n\n- **Finite State Machine (FSM)**: Implement an FSM to manage the encryption process.\n- **Matrix Multiplication**: Compute the ciphertext vector \\( C \\) as:\n\n C<sub>i</sub> = $$\\left( \\sum_{j=0}^2 K_{ij} \\right) \\times \\left( P_j \\right)$$ mod26\n  Where:\n\n  - C<sub>i</sub> : i<sup>th</sup> element of the ciphertext vector.\n  - K<sub>ij</sub>: Element of the key matrix at row \\( i \\), column \\( j \\).\n  - P<sub>j</sub>:  j<sup>th</sup> element of the plaintext vector.\n\n- **Modular Arithmetic**: Implement the modulo 26 operation.\n- **Synchronous Operation**: All operations should be synchronized with the rising edge of the clock (`clk`).\n- **Latency**: The design will have a latency of three clock cycles to produce the ciphertext after applying logic HIGH to `start`\n\n---\n\n\n## 3.  **Example**\n\n#### **Input**\n\n-  **Plaintext Block**: `\"CAT\"` \u2192 `[2, 0, 19]^T`\n  - Binary Representation:\n    - C = `00010`, A = `00000`, T = `10011`\n    - **Combined 15-bit input**: `00010_00000_10011`\n- **Key Matrix**:\n\n```math\n\\begin{bmatrix}3 & 10 & 20 \\\\ 1 & 9 & 15 \\\\ 8 & 7 & 17 \\end{bmatrix}\n```\n\n#### **Encryption Process**\n\n**Ciphertext = (Key Matrix \u00d7 Plaintext Vector) mod 26**\n\n1. Perform the matrix multiplication:\n\nC\u2080 = (3 * 2 + 10 * 0 + 20 * 19) mod 26  \n   = (6 + 0 + 380) mod 26  \n   = 22  \n\nC\u2081 = (1 * 2 + 9 * 0 + 15 * 19) mod 26  \n   = (2 + 0 + 285) mod 26  \n   = 1  \n\nC\u2082 = (8 * 2 + 7 * 0 + 17 * 19) mod 26  \n   = (16 + 0 + 323) mod 26  \n   = 1  \n\n2. **Ciphertext Vector**:\n\n```math\n\\begin{bmatrix}22 \\\\ 1 \\\\ 1\\end{bmatrix}\n```\n\n3. **Mapping Numbers to Letters**:\n   - 22 \u2192 U  \n   - 1 \u2192 B  \n   - 1 \u2192 B  \n\n   **Ciphertext Block**: `\"UBB\"`\n\n#### **Output**\n\n- **Ciphertext**: `\"UBB\"`\n- **Binary Representation**:\n  - U = `10110`, B = `00001`, B = `00001`\n  - **Combined 15-bit output**: `10110_00001_00001`\n", "context": {}}, "output": {"response": "", "context": {"rtl/hill_cipher.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\nRUN pip install cocotb-bus", "docker-compose.yml": "services:\n\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/hill_cipher.sv\nTOPLEVEL        = hill_cipher\nMODULE          = test_hill_cipher\nPYTHONPATH      = /src\nHASH            = 1-rtl", "src/test_hill_cipher.py": "# Filename: test_hill_cipher.py\n\nimport cocotb\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\ndef mod26(value):\n    \"\"\"Modulo 26 operation.\"\"\"\n    return value % 26\n\ndef mod64(value):\n    \"\"\"Modulo 32 operation.\"\"\"\n    return value % 64\n\n@cocotb.test()\nasync def hill_cipher_test(dut):\n    \"\"\"Test the hill_cipher module with various inputs to cover all corner cases.\"\"\"\n\n    # Generate clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Reset the DUT\n    dut.reset.value = 1\n    dut.start.value = 0\n    dut.plaintext.value = 0\n    dut.key.value = 0\n    await RisingEdge(dut.clk)\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\n    # Define test cases with categories\n    test_cases = [\n        # Normal case\n        {\n            'category': 'Normal Case',\n            'plaintext': 0b000010000100001,  # 'A', 'B', 'C' (assuming 'A' = 0, 'B' = 1, etc.)\n            'key': 0b000010000100001000010000100001000010000100001,\n            'expected_ciphertext': None  # Will compute below\n        },\n        # Maximum values\n        {\n            'category': 'Maximum Values',\n            'plaintext': 0b110101101011010,  # Max plaintext `Z`, `Z`, `Z`\n            'key': 0b111111111111111111111111111111111111111111111,\n            'expected_ciphertext': None\n        },\n        # Minimum values\n        {\n            'category': 'Minimum Values',\n            'plaintext': 0b000000000000000,\n            'key': 0b000000000000000000000000000000000000000000000,\n            'expected_ciphertext': None\n        },\n        # Edge case for modulo operation\n        {\n            'category': 'Edge Case: Modulo Operation',\n            'plaintext': 0b001100011000110,  # 12, 12, 12\n            'key': 0b001100011000110001100011000110001100011000110,  # 12s\n            'expected_ciphertext': None\n        },\n        # Random values\n        {\n            'category': 'Random Case',\n            'plaintext':  int(f\"{random.randint(0, 0x19)}{random.randint(0, 0x19)}\"),\n            'key': random.randint(0, 0x1FFFFFFFFFF),\n            'expected_ciphertext': None\n        },\n        # Another random case\n        {\n            'category': 'Random Case',\n            'plaintext': int(f\"{random.randint(0, 0x19)}{random.randint(0, 0x19)}\"),\n            'key': random.randint(0, 0x1FFFFFFFFFF),\n            'expected_ciphertext': None\n        },\n    ]\n\n    # Helper function to split bits into 5-bit chunks\n    def split_bits(value, num_chunks, chunk_size):\n        chunks = []\n        for i in range(num_chunks):\n            chunks.append((value >> ((num_chunks - 1 - i) * chunk_size)) & ((1 << chunk_size) - 1))\n        return chunks\n\n    # Run test cases\n    for idx, case in enumerate(test_cases):\n        dut._log.info(f\"Running Test Case {idx+1}: {case['category']}\")\n\n        # Apply inputs\n        dut.plaintext.value = case['plaintext']\n        dut.key.value = case['key']\n        await FallingEdge(dut.clk)\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        # Wait for done signal\n        while dut.done.value != 1:\n            await RisingEdge(dut.clk)\n\n        # Display input values in logs\n        dut._log.info(f\"Test Case {idx+1} Inputs:\")\n        dut._log.info(f\"  Category: {case['category']}\")\n        dut._log.info(f\"  Plaintext (binary): {bin(case['plaintext'])}\")\n        dut._log.info(f\"  Plaintext (decimal): {int(case['plaintext'])}\")\n        dut._log.info(f\"  Key (binary): {bin(case['key'])}\")\n        dut._log.info(f\"  Key (decimal): {int(case['key'])}\")\n\n        # Compute expected ciphertext in Python\n        P = split_bits(int(case['plaintext']), 3, 5)  # [P0, P1, P2]\n        K = split_bits(int(case['key']), 9, 5)        # [K00, K01, ..., K22]\n\n        # Reshape K into 3x3 matrix\n        K_matrix = [K[0:3], K[3:6], K[6:9]]\n\n        # Matrix multiplication\n        C = []\n        for i in range(3):\n            temp = 0\n            for j in range(3):\n                temp += mod26(K_matrix[i][j] * P[j])\n            temp = mod64(temp)\n            C.append(mod26(temp))\n\n        # Expected ciphertext\n        expected_ciphertext = (C[0] << 10) | (C[1] << 5) | C[2]\n\n        # Display expected ciphertext\n        dut._log.info(f\"  Expected Ciphertext (binary): {bin(expected_ciphertext)}\")\n        dut._log.info(f\"  Expected Ciphertext (decimal): {expected_ciphertext}\")\n\n        # Check the output\n        actual_ciphertext = int(dut.ciphertext.value)\n        dut._log.info(f\"  Actual Ciphertext (binary): {bin(actual_ciphertext)}\")\n        dut._log.info(f\"  Actual Ciphertext (decimal): {actual_ciphertext}\")\n\n        assert actual_ciphertext == expected_ciphertext, (\n            f\"Test Case {idx+1} ({case['category']}) failed: \"\n            f\"Expected {expected_ciphertext}, got {actual_ciphertext}\"\n        )\n\n        # Reset the DUT between test cases\n        dut.reset.value = 1\n        await RisingEdge(dut.clk)\n        dut.reset.value = 0\n        await RisingEdge(dut.clk)\n\n    dut._log.info(\"All test cases passed!\")\n\n\n@cocotb.test()\nasync def hill_cipher_clock_latency_test(dut):\n    \"\"\"Test the clock latency from start signal to done signal.\"\"\"\n\n    # Generate clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Reset the DUT\n    dut.reset.value = 1\n    await RisingEdge(dut.clk)\n    dut.reset.value = 0\n\n    # Apply a simple input\n    dut.plaintext.value = 0b000010000100001  # Example plaintext\n    dut.key.value = 0b000010000100001000010000100001000010000100001  # Example key\n\n    # Assert start signal and measure latency\n    await FallingEdge(dut.clk)\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    latency = 0\n    while dut.done.value != 1:\n        await RisingEdge(dut.clk)\n        latency += 1\n\n    # Log the latency\n    dut._log.info(f\"Clock Latency: {latency} clock cycles\")\n    assert latency == 3, \"Clock latency should be equal to 3.\"\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb.runner import get_runner\nimport re\nimport logging\nimport pytest\nimport random\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner( ):\n    \n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)   \n\ndef test_hill_cipher():\n    # Run the simulation\n    test_runner()\n"}}}
{"id": "cvdp_copilot_load_store_unit_0001", "categories": ["cid003", "medium"], "input": {"prompt": "# **Design a Load Store Unit**\n\nIn a classic five-stage pipelined processor, the five pipeline stages are:\n\n1. **Instruction Fetch (IF):** The next instruction is fetched from the instruction cache.\n2. **Instruction Decode (ID):** The instruction is decoded, and registers are fetched from the register file.\n3. **Execute (EX):** The ALU operates on the operands from the register file.\n4. **Memory Access (MA):** Accesses the processor's data cache. Data cache latency depends on whether it's a hit or miss.\n5. **Writeback (WB):** Writes ALU results or data cache values back to the register file.\n\nDevelop a SystemVerilog RTL module named `load_store_unit` for a Load Store Unit (LSU) that manages load and store operations, serving as a memory access stage, interfacing between the execute stage and the data-cache memory. The module reads from and writes to a 32-bit, byte-addressable memory, where each address corresponds to a single byte. It supports accesses of varying sizes: byte (1 byte), halfword (2 bytes), and word (4 bytes). \n\n---\n\n## **Ports**\n\n### **Clock and Reset**\n| **Signal** | **Direction** | **Width** | **Description**                                                                     |\n|------------|---------------|-----------|-------------------------------------------------------------------------------------|\n| `clk`      | Input         | 1-bit     | System clock signal. The design is synchronized to the positive edge of this clock. |\n| `rst_n`    | Input         | 1-bit     | Active-low asynchronous reset signal.                                               |\n\n### **Data-Cache Interface**\n| **Signal**               | **Direction** | **Width**  | **Description**                                                                 |\n|--------------------------|---------------|------------|---------------------------------------------------------------------------------|\n| `dmem_req_o`             | Output        | 1-bit      | Active-high signal indicating a load/store transaction request to data-cache.   |\n| `dmem_gnt_i`             | Input         | 1-bit      | Active-high grant signal from memory, indicating acceptance of the transaction. |\n| `dmem_req_addr_o[31:0]`  | Output        | 32-bit     | Memory address for the transaction.                                             |\n| `dmem_req_we_o`          | Output        | 1-bit      | Active-high write enable indicating it's a write request.                       |\n| `dmem_req_be_o[3:0]`     | Output        | 4-bit      | Byte enable signals for memory transactions.                                    |\n| `dmem_req_wdata_o[31:0]` | Output        | 32-bit     | Data to write to memory.                                                        |\n| `dmem_rvalid_i`          | Input         | 1-bit      | Active-high signal indicating that the data read from memory is valid.          |\n| `dmem_rsp_rdata_i[31:0]` | Input         | 32-bit     | Data read from memory.                                                          |\n\n### **Execution Stage Interface**\n| **Signal**                 | **Direction** | **Width**  | **Description**                                                                       |\n|----------------------------|---------------|------------|---------------------------------------------------------------------------------------|\n| `ex_if_req_i`              | Input         | 1-bit      | Active-high data request signal from the EX stage.                                    |\n| `ex_if_we_i`               | Input         | 1-bit      | Active-high write enable signal from the EX stage. Asserted along with `ex_if_req_i`. |\n| `ex_if_type_i[1:0]`        | Input         | 2-bit      | Data type: word (`0'b10`), half-word (`0'b01`), or byte (`0'b00`).                    |\n| `ex_if_wdata_i[31:0]`      | Input         | 32-bit     | Data to write to memory from the EX stage.                                            |\n| `ex_if_addr_base_i[31:0]`  | Input         | 32-bit     | Base address for the transaction.                                                     |\n| `ex_if_addr_offset_i[31:0]`| Input         | 32-bit     | Offset for the transaction address.                                                   |\n| `ex_if_ready_o`            | Output        | 1-bit      | Active-high signal indicating that the LSU is ready to handle new requests.           |\n\n### **Writeback Interface**\n| **Signal**               | **Direction** | **Width**  | **Description**                                            |\n|--------------------------|---------------|------------|------------------------------------------------------------|\n| `wb_if_rdata_o[31:0]`    | Output        | 32-bit     | Data read from memory.                                     |\n| `wb_if_rvalid_o`         | Output        | 1-bit      | Active-high signal indicating that the data read is valid. |\n\n---\n\n## **Module Behavior:**\n\n### **On Reset (`rst_n = 0`):**\n- Clears all pending requests and responses.\n- Resets all outputs to their default states:\n  - The execution stage interface is signaled as ready for new requests (`ex_if_ready_o` is asserted).\n  - No requests are sent to the data memory (`dmem_req_o` and `dmem_req_we_o` are deasserted and `dmem_req_addr_o`,  `dmem_req_be_o`, and `dmem_req_wdata_o` are cleared to zero.)\n  - No valid data is provided to the writeback stage (`wb_if_rvalid_o` is deasserted and `wb_if_rdata_o` is cleared to zero ).\n\n---\n\n### **Transaction address and byte enable:**\n- The transaction address is calculated **combinationally** as the sum of `ex_if_addr_base_i` and `ex_if_addr_offset_i`.\n- The data type (word, half-word, byte) determines the byte enable signals and the number of bytes to access:\n  - For byte access (`ex_if_type_i = 0x0`), the corresponding single byte is enabled in the byte enable mask based on the effective address's least significant bits two bits (LSBs).\n  - For halfword access (`ex_if_type_i = 0x1`), two consecutive bytes are enabled in the byte enable mask. The effective address must be aligned to 2 bytes (LSBs = 0b00 or 0b10) otherwise it's a misaligned access. LSBs = 0b00 selects the first two (least significant ) bytes, and 0b10 selects the last two (most significant) bytes.\n  - For word access (`ex_if_type_i = 0x2`), all four bytes are enabled. The effective address must be aligned to 4 bytes (LSBs = 0b00) otherwise it's a misaligned access.\n  - Any other value for `ex_if_type_i`  and unaligned effective addresses are considered as misaligned access and discarded\n---\n\n### **Processing execute stage request (`ex_if_req_i = 1`):**\n`ex_if_req_i = 1` will only be asserted when `ex_if_ready_o` is high. The module accepts the request if `ex_if_ready_o` and `ex_if_req_i = 1` are asserted and the access address is aligned. For accepted requests, the LSU initiates a request to the data cache and deasserts `ex_if_ready_o` to indicate that it is handling an outstanding transaction with a **one-cycle latency** after the execute unit request is received.\nNote: If both `ex_if_req_i` and `ex_if_we_i` are asserted it indicates a store transaction, if only `ex_if_req_i` is asserted it indicates a load transaction. \n\nThe protocol used to communicate with data cache memory works as follows:\n- The LSU provides a valid transaction address on `dmem_req_addr_o`, the control information on `dmem_req_we_o`, `dmem_req_be_o` (as well as write data on `dmem_req_wdata_o` in case of a store) and sets `dmem_req_o` high. These signals are updated at the next positive edge of the clock after the triggering load/store request.\n- The memory sets `dmem_gnt_i` high as soon as it is ready to serve the request. This may happen at any time after the request is sent. \n- After a request has been granted:\n    - The LSU deasserts `dmem_req_o` and `dmem_req_we_o` at the next positive edge of the clock.  `dmem_req_addr_o`,`dmem_req_be_o` , and  `dmem_req_wdata_o` are also cleared to 0.\n    - For store transactions, when`dmem_req_we_o = 1'b1` and `dmem_gnt_i=1`: the memory is assumed to already have processed and completed the transaction.\n    - For load transaction, After granting a request, the memory answers with a `dmem_rvalid_i` set high if `dmem_rsp_rdata_i` is valid for **one clock cycle**. This may happen one or more cycles after the request has been granted.\n\nThe following diagram shows an example timing diagram of the protocol for a store then a load transactions.\n\n\n```wavedrom\n{\n  \"signal\": [\n    { \"name\": \"clk\", \"wave\": \"p.............\" },\n    { \"name\": \"rst_n\", \"wave\": \"0.............\" },\n    { \"name\": \"dmem_req_o\", \"wave\": \"0.1...0.1..0..\", \"data\": [\"Request\"] },\n    { \"name\": \"dmem_req_addr_o\", \"wave\": \"x.3...x.3..x..\", \"data\": [\"0x0004\", \"0x0004\"] },\n    { \"name\": \"dmem_req_we_o\", \"wave\": \"0.1...0.......\", \"data\": [\"Write\"] },\n    { \"name\": \"dmem_req_be_o\", \"wave\": \"x.3...x.3..x..\", \"data\": [\"0xF\",\"0x1\"] },\n    { \"name\": \"dmem_req_wdata_o\", \"wave\": \"x.3...x.......\", \"data\": [\"0xDEADBEEF\"] },\n    { \"name\": \"dmem_gnt_i\", \"wave\": \"0....10...10..\", \"data\": [\"Grant\"] },\n    { \"name\": \"dmem_rvalid_i\", \"wave\": \"0...........10\", \"data\": [\"Valid\"] },\n    { \"name\": \"dmem_rsp_rdata_i\", \"wave\": \"x...........3x\", \"data\": [\"0xEF\"] }\n  ]\n}\n\n```\n\nAfter the transaction is completed, (`dmem_gnt_i = 1` for store and `dmem_rvalid_i = 1` for load) the module reasserts `ex_if_ready_o`, signaling readiness to handle new requests with a **one-cycle latency**.\n\n---\n\n### **Response to Writeback Stage:**\n- For Load Transactions:\n  - After the data memory transaction is completed (`dmem_rvalid_i = 1`), the load/store unit asserts `wb_if_rvalid_o` and updates `wb_if_rdata_o` with the read data from `dmem_rsp_rdata_i`.\n  - The response is provided to the writeback stage with a **one-cycle latency** after the data memory response is received.\n  - The read data validity (`wb_if_rvalid_o`) will remain active on writeback bus for **just one cycle** as `dmem_rvalid_i` is high for one cycle.  `wb_if_rdata_o` value will be maintained until the update from next load instruction.", "context": {}}, "output": {"response": "", "context": {"rtl/load_store_unit.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n\n", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/load_store_unit.sv\nTOPLEVEL        = load_store_unit\nMODULE          = test_load_store_unit\nPYTHONPATH      = /src\nHASH            = \"feature/issue_1\"\n", "src/harness_library.py": "\nimport cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, ReadOnly, NextTimeStep, Timer\nimport random\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def reset_dut(reset, duration_ns = 10):\n    # Restart Interface\n    reset.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    reset.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    reset.value = 1\n    await Timer(duration_ns, units='ns')\n    reset._log.debug(\"Reset complete\")\n\n\n\nclass DataMemory:\n    def __init__(self):\n        self.mem_array = [0] * (2**8)  # 32-bit memory addresses\n\n    # Value tuple is a tuple (addr, we, be, wdata)\n    def write_addr(self, value):\n        \"\"\"\n        Perform a memory write operation considering the byte enable (BE).\n        \"\"\"\n        addr, we, be, wdata = value\n\n        if we:  # Write enable is asserted\n            current_word = self.mem_array[addr]\n            for byte_index in range(4):\n                if be & (1 << byte_index):  \n                    current_word &= ~(0xFF << (byte_index * 8))\n                    current_word |= (wdata & (0xFF << (byte_index * 8)))\n\n            self.mem_array[addr] = current_word\n\n    def read_addr(self, value):\n        \"\"\"\n        Perform a memory read operation considering the byte enable (BE).\n        \"\"\"\n        addr, _, be, _ = value\n\n        \n        current_word = self.mem_array[addr]\n\n        \n        read_data = 0\n        for byte_index in range(4):\n            if be & (1 << byte_index):  \n                read_data |= (current_word & (0xFF << (byte_index * 8)))\n\n        return read_data\n\nclass ExReqDriver:\n    def __init__(self, dut, name, clk, sb_callback):\n        \"\"\"\n        Initialize the InputDriver.\n        :param dut: The DUT instance.\n        :param name: The name of the bus signals (e.g., 'input_bus').\n        :param clk: Clock signal for synchronization.\n        :param sb_callback: Callback function to handle data/address events.\n        \"\"\"\n        self.dut = dut\n        self.clk = clk\n        self.callback = sb_callback\n\n        # Initialize bus signals\n        self.bus = {\n            \"req_i\"         : getattr(dut, f\"{name}_req_i\"),\n            \"we_i\"          : getattr(dut, f\"{name}_we_i\"),\n            \"type_i\"        : getattr(dut, f\"{name}_type_i\"),\n            \"wdata_i\"       : getattr(dut, f\"{name}_wdata_i\"),\n            \"addr_base_i\"   : getattr(dut, f\"{name}_addr_base_i\"),\n            \"addr_offset_i\" : getattr(dut, f\"{name}_addr_offset_i\"),\n            \"ready_o\"       : getattr(dut, f\"{name}_ready_o\"),    \n        }\n\n        # Reset bus values\n        self.bus[\"req_i\"].value = 0\n\n    async def write_req(self, value):\n        \"\"\"\n        Send a value over the bus.\n        :param value: A tuple (type, wdata, base_addr, off_addr) to send on the bus.\n        \"\"\"\n        # Random delay before request\n        for _ in range(random.randint(1, 20)):\n            await RisingEdge(self.clk)\n\n        # Wait until ready signal is asserted\n        # PROMPT: \" ex_if_req_i Should only be asserted if the module is ready\"\n        while self.bus[\"ready_o\"].value != 1:\n            await RisingEdge(self.clk)\n\n        # Drive the bus\n        # PROMPT:\n        # The module will register the calculated \n        # address, write data (if applicable), and control signals (e.g., write enable, byte enable) to signal a data memory request.\n        self.bus[\"req_i\"].value = 1\n        self.bus[\"we_i\"].value = 1\n        self.bus[\"type_i\"].value = value[0]\n        self.bus[\"wdata_i\"].value = value[1]\n        self.bus[\"addr_base_i\"].value = value[2]\n        self.bus[\"addr_offset_i\"].value = value[3]\n\n\n        # Allow ReadOnly phase and trigger the callback\n        await ReadOnly()\n        self.callback(self.dut, int(self.bus[\"type_i\"].value), int(self.bus[\"wdata_i\"].value), int(self.bus[\"addr_base_i\"].value), int(self.bus[\"addr_offset_i\"].value))\n\n        # Hold the enable signal for one clock cycle\n        await RisingEdge(self.clk)\n        self.bus[\"req_i\"].value = 0\n        self.bus[\"we_i\"].value = 0\n\n        # The request is forwarded to dmem IFF it's aligned\n        type = value[0] \n        address = (value[2]+ value[3])\n        if type == 0x0:\n            trans_size = 1\n        elif type == 0x1:\n            trans_size = 2\n        elif type == 0x2:\n            trans_size = 4\n        aligned =  (address % trans_size) == 0\n\n        # Add a delay to simulate bus deactivation\n        await NextTimeStep()\n        dut_req = int(self.dut.dmem_req_o.value)\n        dut_address = int(self.dut.dmem_req_addr_o.value)\n        dut_we = int(self.dut.dmem_req_we_o.value)\n        dut_be = int(self.dut.dmem_req_be_o.value)\n        dut_wdata = int(self.dut.dmem_req_wdata_o.value)\n        # DMEM REQUEST IS FORWARDED\n        if aligned:\n            assert dut_req == 1, f\"Dmem request should be asserted\"\n            assert dut_address == address, f\"Dmem address mismatch: Expected:{address}, Got:{dut_address}\"\n            assert dut_we == 1, f\"Dmem we mismatch: Expected: 1, Got:{dut_we}\"\n            assert dut_wdata == value[1], f\"Dmem address mismatch: Expected:{value[1]}, Got:{dut_wdata}\"\n            # PROMPT: `ex_if_ready_o` is deasserted sequentially indicating an outstanding access.\n            assert self.bus[\"ready_o\"].value == 0, f\"ready should deasserted sequentially\"\n        else:\n            assert dut_req == 0, f\"Dmem request should be deasserted\"\n\n    async def read_req(self, value):\n        \"\"\"\n        Send a value over the bus.\n        :param value: A tuple (type, wdata, base_addr, off_addr) to send on the bus.\n        \"\"\"\n        # Random delay before sending data\n        #PROMPT: \" ex_if_req_i Should only be asserted if the module is ready\"\n        for _ in range(random.randint(1, 20)):\n            await RisingEdge(self.clk)\n\n        # Wait until ready signal is asserted\n        # PROMPT: \" ex_if_req_i Should only be asserted if the module is ready\"\n        while self.bus[\"ready_o\"].value != 1:\n            await RisingEdge(self.clk)\n\n        # Drive the bus\n        # PROMPT:\n        # The module will register the calculated \n        # address, write data (if applicable), and control signals (e.g., write enable, byte enable) to signal a data memory request.\n        self.bus[\"req_i\"].value = 1\n        self.bus[\"we_i\"].value = 0\n        self.bus[\"type_i\"].value = value[0]\n        self.bus[\"wdata_i\"].value = 0\n        self.bus[\"addr_base_i\"].value = value[2]\n        self.bus[\"addr_offset_i\"].value = value[3]\n\n\n        # Allow ReadOnly phase and trigger the callback\n        await ReadOnly()\n        self.callback(self.dut, int(self.bus[\"type_i\"].value), int(self.bus[\"wdata_i\"].value), int(self.bus[\"addr_base_i\"].value), int(self.bus[\"addr_offset_i\"].value))\n\n        # Hold the enable signal for one clock cycle\n        await RisingEdge(self.clk)\n        self.bus[\"req_i\"].value = 0\n\n        # The request is forwarded to dmem IFF it's aligned\n        type = value[0] \n        address = (value[2]+ value[3])\n        if type == 0x0:\n            trans_size = 1\n        elif type == 0x1:\n            trans_size = 2\n        elif type == 0x2:\n            trans_size = 4\n        aligned =  (address % trans_size) == 0\n\n        # Add a delay to simulate bus deactivation\n        await NextTimeStep()\n        dut_req = int(self.dut.dmem_req_o.value)\n        dut_address = int(self.dut.dmem_req_addr_o.value)\n        dut_we = int(self.dut.dmem_req_we_o.value)\n        dut_be = int(self.dut.dmem_req_be_o.value)\n        if aligned:\n            assert dut_req == 1, f\"Dmem request should be asserted\"\n            assert dut_address == address, f\"Dmem address mismatch: Expected:{address}, Got:{dut_address}\"\n            assert dut_we == 0, f\"Dmem we mismatch: Expected: 1, Got:{dut_we}\"\n            # PROMPT: `ex_if_ready_o` is deasserted sequentially indicating an outstanding access.\n            assert self.bus[\"ready_o\"].value == 0, f\"ready should deasserted sequentially\"\n        else:\n            assert dut_req == 0, f\"Dmem request should be deasserted\"\n\n\n\nclass dmemIFDriver:\n    def __init__(self, dut, name, clk):\n        \"\"\"\n        Initialize the InputDriver.\n        :param dut: The DUT instance.\n        :param name: The name of the bus signals (e.g., 'input_bus').\n        :param clk: Clock signal for synchronization.\n        \"\"\"\n        self.dut = dut\n        self.clk = clk\n        # Initialize bus signals\n        self.bus = {\n            \"req_o\"        : getattr(dut, f\"{name}_req_o\"),\n            \"req_addr_o\"   : getattr(dut, f\"{name}_req_addr_o\"),\n            \"req_we_o\"     : getattr(dut, f\"{name}_req_we_o\"),\n            \"req_be_o\"     : getattr(dut, f\"{name}_req_be_o\"),\n            \"req_wdata_o\"  : getattr(dut, f\"{name}_req_wdata_o\"),\n            \"rsp_rdata_i\"  : getattr(dut, f\"{name}_rsp_rdata_i\"),\n            \"rvalid_i\"     : getattr(dut, f\"{name}_rvalid_i\"),\n            \"gnt_i\"        : getattr(dut, f\"{name}_gnt_i\"),    \n        }\n\n        # Reset bus values\n        self.bus[\"rvalid_i\"].value = 0\n        self.bus[\"rsp_rdata_i\"].value = 0\n        self.bus[\"gnt_i\"].value = 0\n        self.dmem_model = DataMemory()\n        cocotb.start_soon(self._listening())\n\n\n    async def _listening(self):\n        while True:\n            while self.bus[\"req_o\"].value != 1:\n                await RisingEdge(self.clk)\n            addr = int(self.bus[\"req_addr_o\"].value)\n            we = int(self.bus[\"req_we_o\"].value)\n            be = int(self.bus[\"req_be_o\"].value)\n            wdata = int(self.bus[\"req_wdata_o\"].value)\n            Req_vector = (addr, we, be, wdata)\n            await self._process_req(Req_vector)\n            \n          \n    async def _process_req(self, value):\n        \"\"\"\n        Send a value over the bus.\n        :param value: A tuple (addr, we, be, wdata) to send on the bus.\n        \"\"\"\n        wb_check = False\n        # Wait random time to gnt the request \n        for _ in range(random.randint(1, 5)):\n            await RisingEdge(self.clk)\n        self.bus[\"gnt_i\"].value = 1\n        await RisingEdge(self.clk)\n        self.bus[\"gnt_i\"].value = 0\n        await ReadOnly()\n        #PROMPT: `dmem_req_o` is cleared sequentially after data memory accepts the request.\n        assert int(self.dut.dmem_req_o.value) ==0, f'dmem_req_o must be deasserted'\n        if value[1] == 1: #Write req\n            self.dmem_model.write_addr(value)\n        else: #Read req\n           # Read from mem model\n           rdata = self.dmem_model.read_addr(value)\n           wb_check = True \n           for _ in range(random.randint(1, 5)):\n               await RisingEdge(self.clk) \n           self.bus[\"rvalid_i\"].value = 1\n           self.bus[\"rsp_rdata_i\"].value = rdata \n           await RisingEdge(self.clk)\n           self.bus[\"rvalid_i\"].value = 0\n           self.bus[\"rsp_rdata_i\"].value = 0\n\n        # Allow ReadOnly phase and trigger the callback\n        await ReadOnly()\n        #PROMPT: The module clears the busy state, asserting `ex_if_ready_o`, allowing the execute stage to issue new requests.\n        assert int(self.dut.ex_if_ready_o.value) ==1, f'dmem_req_o must be asserted'\n        #PROMPT:\n        # The data from DMEM is captured and forwarded to the writeback stage, sequentially.\n        #       `wb_if_rvalid_o` is asserted  and  `wb_if_rdata_o` is written with dmem read data, **For one cycle**.\n        if wb_check:\n            assert int(self.dut.wb_if_rvalid_o.value) == 1 , f'WB SHOULD HAVE VALID DATA ON DMEM RDATA RSP'\n            assert int(self.dut.wb_if_rdata_o.value) == rdata , f'WB DATA MISMATCH' \n            # NOTE: That value correctness depends on memory model(not RTL). Here We just verfying data is passed correctly to WB stage \n\n        # Hold the enable signal for one clock cycle\n        await RisingEdge(self.clk)\n\n        # Add a delay to simulate bus deactivation\n        await NextTimeStep()\n\n    \n    \n     \n        \n    ", "src/test_load_store_unit.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport time\nimport harness_library as hrs_lb\nfrom harness_library import ExReqDriver, dmemIFDriver\n\n# Place holder for coverage\n\ndef execute_sb_fn(dut,type_i, wdata, addr_base, addr_offset):\n   pass\n   #dut._log.info(f\"Execute unit request -- type:{hex(type_i)}, write_data = {hex(wdata)}, addr: {hex(addr_base + addr_offset)}\")\n\n@cocotb.test()\nasync def test_load_store_unit(dut): \n   # Start clock\n   dut_clock_period = random.randint(2, 20) # starting from 2, t high must be integer! \n   print(f\"Clk period is {dut_clock_period}\")\n   DUT_CLK = Clock(dut.clk, dut_clock_period, 'ns')\n   await cocotb.start(DUT_CLK.start())\n   dut.clk._log.info(f\"clk STARTED\")\n\n   await hrs_lb.dut_init(dut)\n\n   # Apply reset \n   await hrs_lb.reset_dut(dut.rst_n, dut_clock_period)\n\n   for i in range(2):\n      await RisingEdge(dut.clk)\n\n   # Ensure  outputs reset value \n\n   # The Execution Stage Interface is signaled as ready for new requests.\n   assert dut.ex_if_ready_o.value == 1, f\"The Execution Stage Interface should be signaled as ready for new requests (ex_if_ready_o = 0x1): {dut.ex_if_ready_o.value}\"\n   \n   # No requests are sent to data memory.\n   assert dut.dmem_req_o.value == 0, f\"\u064fShould be No requests are sent to data memory (dmem_req_o = 0x0). {dut.dmem_req_o.value}\"\n   \n   # No valid data is provided to the writeback stage.\n   assert dut.wb_if_rvalid_o.value == 0, f\"Should be No valid data  provided to the writeback stage (wb_if_rvalid_o = 0x0). {dut.wb_if_rvalid_o.value}\"\n\n   \n   await FallingEdge(dut.clk)\n   \n   dmemIFDriver(dut,'dmem', dut.clk)\n   execute_if_driver = ExReqDriver(dut,'ex_if',dut.clk,execute_sb_fn)\n\n   for i in range(500):\n      wdata = random.randint(0, 2**32) # 32 bit word data\n      addr_base = random.randint(0,2**6)\n      addr_off = random.randint(0,2**6) # Limiting address space to 7 bit (MemoryModel representation limit)\n      type = random.randint(0,2) # TYPE: can be 0x0, 0x1, 0x2\n      Test_Vec = (type, wdata, addr_base, addr_off)\n      # Drive Write operation\n      await execute_if_driver.write_req(Test_Vec)\n      \n      # Read the written value\n      await execute_if_driver.read_req(Test_Vec)\n\n    \n\n\n\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\nimport random\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=False,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\ndef test_allocator():\n    runner()\n"}}}
{"id": "cvdp_copilot_matrix_multiplier_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design and implement a parameterized matrix multiplier using System Verilog. The matrix multiplier should take two input matrices with configurable dimensions and output the result of their multiplication. The design should support any matrix sizes as long as the dimensions are compatible for matrix multiplication (i.e., the number of columns in matrix A matches the number of rows in matrix B). The module should operate as a combinational logic block, updating the output immediately based on changes in the input.\n\n---\n\n### Specifications for module `matrix_multiplier`:\n\n#### Inputs:\n- **matrix_a[ (ROW_A x COL_A x INPUT_DATA_WIDTH) -1 : 0]**: The first input matrix with dimensions `[ROW_A x COL_A x INPUT_DATA_WIDTH]`, where `ROW_A` represents the number of rows,  `COL_A` represents the number of columns and `INPUT_DATA_WIDTH` represents the bit-width of each unsigned input element in the matrix.\n- **matrix_b[ (ROW_B x COL_B x INPUT_DATA_WIDTH) -1 : 0]**: The second input matrix with dimensions `[ROW_B x COL_B x INPUT_DATA_WIDTH]`, where `ROW_B` represents the number of rows,  `COL_B` represents the number of columns and `INPUT_DATA_WIDTH` represents the bit-width of each unsigned input element in the matrix.\n\n#### Output:\n- **matrix_c[(ROW_A x COL_B x OUTPUT_DATA_WIDTH) -1 : 0]**: The resulting matrix with dimensions `[ROW_A x COL_B x OUTPUT_DATA_WIDTH]`, containing the result of the multiplication of `matrix_a` and `matrix_b`. The elements of this matrix are unsigned values.\n\n### Parameters:\n\n- `ROW_A`: Number of rows in `matrix_a`. Default value 4.\n- `COL_A`: Number of columns in `matrix_a`. Default value 4.\n- `ROW_B`: Number of rows in `matrix_b` (It must be equal to number of columns in `matrix_a`). Default value 4.\n- `COL_B`: Number of columns in `matrix_b`. Default value 4.\n- `INPUT_DATA_WIDTH`: The bit-width of each unsigned element in the input matrices. Default value 8.\n- `OUTPUT_DATA_WIDTH`: The bit-width of each unsigned element in the output matrix, should be calculated to handle potential overflow from multiplication.\n\n### Additional Details:\n\n- Ensure that the design supports only unsigned inputs and any parameterized sizes for the matrices, so it can be scaled easily for different applications, including **non-square matrices** (e.g., 2x3, 4x5, or 3x2 matrices).\n- The design should handle all input combinations, including cases where one or both matrices contain zero-valued elements.\n- The output matrix should be updated immediately whenever there is a change in the input matrices.\n- Internal arrays and output must have a sufficient bit-width to avoid potential overflow\n\n### Example of Matrix Flattening:\n\nSuppose you have two input matrices A and B to multiply:\n\n- **Matrix A (2x3)**:\n\n```text\n| a11  a12  a13 |\n| a21  a22  a23 |\n```\n\n- **Matrix B (3x2)**:\n\n```text\n| b11  b12 |\n| b21  b22 |\n| b31  b32 |\n```\n\nThe resulting output matrix from the multiplication of the above matrices would be:\n\n- **Matrix C (2x2)**:\n\n```text\n| c11  c12 |\n| c21  c22 |\n```\n\nThe flattened representation of these matrices will be as follows:\n\n- **Flattened Matrix A (2x3)**:\n\n```text\nmatrix_a = {a23, a22, a21, a13, a12, a11}\n```\n\n- **Flattened Matrix B (3x2)**:\n\n```text\nmatrix_b = {b32, b31, b22, b21, b12, b11}\n```\n\n- **Flattened Matrix C (2x2)**:\n\n```text\nmatrix_c = {c22, c21, c12, c11}\n```\n", "context": {}}, "output": {"response": "", "context": {"rtl/matrix_multiplier.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n  auto:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/matrix_multiplier.sv\nTOPLEVEL        = matrix_multiplier\nMODULE          = test_matrix_multiplier\nPYTHONPATH      = /src\nHASH            = a9942c043d60293cb26718227d561f1022f9e47f\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nimport os\n\nasync def reset_dut(reset_n, duration_ns=10):\n  \"\"\"\n  Reset the DUT by setting the reset signal low for a specified duration\n  and then setting it high again.\n  \n  Args:\n    reset_n: The reset signal (active low).\n    duration_ns: The time in nanoseconds for which the reset signal is held low.\n  \"\"\"\n  reset_n.value = 0  # Set reset to active low\n  await Timer(duration_ns, units=\"ns\")  # Wait for the specified duration\n  reset_n.value = 1  # Deactivate reset (set it high)\n  await Timer(duration_ns, units='ns')  # Wait for the reset to stabilize\n  reset_n._log.debug(\"Reset complete\")\n\n# Function to initialize DUT inputs to 0\nasync def dut_init(dut):\n  \"\"\"\n  Initialize all input signals of the DUT to 0.\n  \n  Args:\n    dut: The Design Under Test.\n  \"\"\"\n  for signal in dut:\n    if signal._type == \"GPI_NET\":  # Only reset input signals (GPI_NET)\n      signal.value = 0\n\n# Save VCD waveform files after the test is run\ndef save_vcd(wave: bool, toplevel: str, new_name: str):\n  \"\"\"\n  Save the VCD (waveform) file if waveform generation is enabled.\n  \n  Args:\n    wave: Boolean flag to indicate whether to save waveforms.\n    toplevel: The top-level module name.\n    new_name: The new name for the saved VCD file.\n  \"\"\"\n  if wave:\n    os.makedirs(\"vcd\", exist_ok=True)  # Create the vcd folder if it doesn't exist\n    os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')  # Rename and move the VCD file\n    print(f\"FST info: Moved /code/rundir/sim_build/{toplevel}.fst to /code/rundir/vcd/{new_name}.fst\")\n\n# Helper function to convert a 2D matrix into a flattened integer\ndef convert_2d_to_flat(array_2d, width):\n  \"\"\"\n  Convert a 2D matrix into a flattened integer for passing as a plusarg to the simulator.\n  \n  Args:\n    array_2d: The 2D matrix (list of lists).\n    width: The bit-width of each element.\n      \n  Returns:\n    An integer representing the flattened matrix.\n  \"\"\"\n  flat_var = []\n  for row in array_2d:\n    for element in row:\n      flat_var.append(element)\n\n  result = 0\n  for i, value in enumerate(flat_var):\n    result |= (value << (i * width))  # Shift and OR to pack the bits\n  return result\n\n# Helper function to multiply two matrices (reference implementation)\ndef matrix_multiply(a, b):\n  \"\"\"\n  Multiply two 2D matrices and return the result.\n  \n  Args:\n    a: The first matrix.\n    b: The second matrix.\n  \n  Returns:\n    The resulting matrix after multiplication.\n  \"\"\"\n  assert len(a[0]) == len(b), \"Matrix dimensions are incompatible for multiplication\"  # Ensure correct dimensions\n  result = [[0 for _ in range(len(b[0]))] for _ in range(len(a))]\n  for i in range(len(a)):\n    for j in range(len(b[0])):\n      for k in range(len(b)):\n        result[i][j] += a[i][k] * b[k][j]  # Element-wise multiplication and summation\n  return result\n\n# Helper function to convert a flattened integer back into a 2D matrix\ndef convert_flat_to_2d(flat_var, rows, cols, width):\n  \"\"\"\n  Convert a flattened integer back into a 2D matrix.\n  \n  Args:\n    flat_var: The flattened integer representing the matrix.\n    rows: The number of rows in the matrix.\n    cols: The number of columns in the matrix.\n    width: The bit-width of each element.\n      \n  Returns:\n    A 2D list (matrix) reconstructed from the flattened integer.\n  \"\"\"\n  array_2d = []\n  for i in range(rows):\n    row = []\n    for j in range(cols):\n      row.append((flat_var >> (width * (i * cols + j))) & ((1 << width) - 1))  # Extract bits for each element\n    array_2d.append(row)\n  return array_2d\n\n# Helper function to print a matrix in a readable format\ndef print_matrix(name, matrix):\n  \"\"\"\n  Print the contents of a matrix with a label.\n  \n  Args:\n    name: The label for the matrix.\n    matrix: The 2D matrix to print.\n  \"\"\"\n  print(f\"Matrix {name}:\")\n  for row in matrix:\n    print(row)\n  print()\n\n# Helper function to populate a matrix with random values\ndef populate_matrix(rows, cols, width):\n  \"\"\"\n  Populate a 2D matrix with random integer values.\n  \n  Args:\n    rows: Number of rows in the matrix.\n    cols: Number of columns in the matrix.\n    width: The bit-width of each element (values will be within this bit range).\n      \n  Returns:\n    A randomly populated 2D matrix.\n  \"\"\"\n  matrix = []\n  for i in range(rows):\n    row = []\n    for j in range(cols):\n      row.append(random.randint(0, (2**width)-1))  # Generate random numbers within bit-width\n    matrix.append(row)\n  return matrix\n", "src/test_matrix_multiplier.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport harness_library as hrs_lb\n\n# ----------------------------------------\n# - Matrix Multiplication Test\n# ----------------------------------------\n\n@cocotb.test()\nasync def verify_matrix_multiplication(dut):\n  \"\"\"Verify matrix multiplication outputs\"\"\"\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply a small delay\n  await Timer(2, units='ns')\n\n  # Retrieve the rows and columns for matrices\n  rows_a = int(dut.ROW_A.value)\n  cols_a = int(dut.COL_A.value)\n  rows_b = int(dut.ROW_B.value)\n  cols_b = int(dut.COL_B.value)\n  output_width = int(dut.OUTPUT_DATA_WIDTH.value)\n\n  input_width = int(dut.INPUT_DATA_WIDTH.value)\n  input_provided = int(cocotb.plusargs[\"input_provided\"]) # Get the input_provided flag from plusargs\n  if input_provided == 1:\n    num_inputs = 1 # Single input set provided\n  else:\n    num_inputs = 10 # Multiple input sets generated dynamically\n\n  # Print matrix dimensions for debugging\n  print(f\"ROW_A: {rows_a}, COL_A: {cols_a}\")\n  print(f\"ROW_B: {rows_b}, COL_B: {cols_b}\")\n  print(f\"INPUT_DATA_WIDTH: {input_width}\")\n\n  for i in range(num_inputs):\n\n    if input_provided == 1:\n      # Retrieve matrix_a and matrix_b from plusargs (static input)\n      matrix_a_flat = int(cocotb.plusargs[\"matrix_a\"])\n      matrix_b_flat = int(cocotb.plusargs[\"matrix_b\"])\n\n      # Convert the flattened matrices back to 2D\n      matrix_a = hrs_lb.convert_flat_to_2d(matrix_a_flat, rows_a, cols_a, input_width)\n      matrix_b = hrs_lb.convert_flat_to_2d(matrix_b_flat, rows_b, cols_b, input_width)\n    else:\n      # Dynamically generate matrices (input_provided=0)\n      matrix_a = hrs_lb.populate_matrix(rows_a, cols_a, input_width)\n      matrix_b = hrs_lb.populate_matrix(rows_b, cols_b, input_width)\n      \n      # Flatten matrices to pass to the DUT\n      matrix_a_flat = hrs_lb.convert_2d_to_flat(matrix_a, input_width)\n      matrix_b_flat = hrs_lb.convert_2d_to_flat(matrix_b, input_width)\n\n    # Assign the flattened matrices to DUT inputs\n    dut.matrix_a.value = matrix_a_flat\n    dut.matrix_b.value = matrix_b_flat\n\n    # Compute the expected result using the reference implementation\n    expected_matrix_c = hrs_lb.matrix_multiply(matrix_a, matrix_b)\n\n    # Apply a small delay for DUT to compute the result\n    await Timer(2, units='ns')\n\n    # Read and convert the output matrix from the DUT\n    matrix_c_flat = int(dut.matrix_c.value)\n    matrix_c = hrs_lb.convert_flat_to_2d(matrix_c_flat, rows_a, cols_b, output_width)\n\n    print(f\"Test {i+1} passed\")\n\n    # Verify if the output matches the expected result\n    assert matrix_c == expected_matrix_c, f\"Test {i+1}: Matrix C does not match the expected result: {matrix_c} != {expected_matrix_c}\"\n\n    # Apply a small delay (for any final signal propagation)\n    await Timer(2, units='ns')\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport random\nimport pytest\nfrom datetime import datetime  # Import datetime for timestamp\nimport harness_library as hrs_lb\n\n# Fetch environment variables\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n# The main runner function to trigger matrix multiplication tests\n# This function prepares the simulation environment, sets parameters, and runs the test\ndef runner(ROW_A: int=4, COL_A: int=4, ROW_B: int=4, COL_B: int=4, INPUT_DATA_WIDTH: int=8,matrix_a: int=0, matrix_b: int=0, input_provided: int=0):\n  # Define simulation parameters\n  parameter = {\n    \"ROW_A\": ROW_A,\n    \"COL_A\": COL_A,\n    \"ROW_B\": ROW_B,\n    \"COL_B\": COL_B,\n    \"INPUT_DATA_WIDTH\": INPUT_DATA_WIDTH,\n  }\n\n  # Prepare plusargs, which are passed to the DUT\n  plusargs = [\n    f'+input_provided={input_provided}',\n    f'+matrix_a={hrs_lb.convert_2d_to_flat(matrix_a, INPUT_DATA_WIDTH)}',\n    f'+matrix_b={hrs_lb.convert_2d_to_flat(matrix_b, INPUT_DATA_WIDTH)}'\n  ]\n\n  # Set up the runner for the simulator\n  runner = get_runner(sim)\n  runner.build(\n    sources=verilog_sources,\n    hdl_toplevel=toplevel,\n    # Arguments\n    parameters=parameter,\n    always=True,\n    clean=True,\n    waves=wave,\n    verbose=True,\n    timescale=(\"1ns\", \"1ns\"),\n    log_file=\"sim.log\")\n  runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs)\n\n  # Save the VCD (waveform) after running the test with a unique timestamp\n  timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")  # Unique timestamp\n  test_name = f\"{toplevel}_ROW_A_{ROW_A}_COL_A_{COL_A}_ROW_B_{ROW_B}_COL_B_{COL_B}_WIDTH_{INPUT_DATA_WIDTH}_{timestamp}\"\n  # hrs_lb.save_vcd(wave, toplevel, test_name)\n\n\n# Basic Matrix Multiplication Tests (static values)\n# Parametrized tests for static matrix multiplication cases\n@pytest.mark.parametrize(\"ROW_A, COL_A, ROW_B, COL_B, INPUT_DATA_WIDTH, matrix_a, matrix_b\", [\n  # Basic 2x2 test\n  (2, 2, 2, 2, 8, [[1,  2], [ 3,  4]], [[ 5,  6], [ 7,  8]]),\n  (2, 2, 2, 2, 8, [[9, 10], [11, 12]], [[13, 14], [15, 16]]),\n  (2, 2, 2, 2, 8, [[0,  0], [ 1,  1]], [[ 1,  1], [ 1,  1]]),\n  # Basic 3x3 test\n  (3, 3, 3, 3, 8, [[1, 2, 3], [4, 5, 6], [7, 8,  9]], [[9, 8,  7], [ 6, 5, 4], [3, 2, 1]]),\n  (3, 3, 3, 3, 8, [[2, 3, 4], [5, 6, 7], [8, 9, 10]], [[1, 2,  3], [ 4, 5, 6], [7, 8, 9]]),\n  (3, 3, 3, 3, 8, [[0, 1, 1], [1, 0, 0], [1, 1,  1]], [[7, 5, 14], [14, 2, 2], [3, 3, 3]]),\n  # Basic 4x4 test\n  (4, 4, 4, 4, 8, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]], [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]),\n  (4, 4, 4, 4, 8, [[1, 0, 0, 1], [0, 1, 1, 0], [1,  0,  1,  1], [ 1,  1,  1, 1]], [[1, 1, 1, 1], [1, 0, 1, 1], [0, 1, 0, 1], [1, 1, 0, 0]]),\n  (4, 4, 4, 4, 8, [[2, 2, 2, 2], [2, 2, 2, 2], [2,  2,  2,  2], [ 2,  2,  2, 2]], [[3, 3, 3, 3], [3, 3, 3, 3], [3, 3, 3, 3], [3, 3, 3, 3]]),\n  # Identity Matrix test\n  (2, 2, 2, 2, 8, [[1,  2], [ 3,  4]], [[ 1,  0], [ 0,  1]]),\n  (3, 3, 3, 3, 8, [[1, 2, 3], [4, 5, 6], [7, 8,  9]], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n  (4, 4, 4, 4, 8, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]], [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]),\n  # Zero Matrix test\n  (2, 2, 2, 2, 8, [[1, 2], [3, 4]], [[0, 0], [0, 0]]),\n  (3, 3, 3, 3, 8, [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]]),\n  (4, 4, 4, 4, 8, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]], [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]),\n  # Max Value Overflow test\n  (2, 2, 2, 2, 4, [[15, 15], [15, 15]], [[15, 15], [15, 15]]),\n  (2, 2, 2, 2, 8, [[255, 255], [255, 255]], [[255, 255], [255, 255]]),\n  (2, 2, 2, 2, 16, [[65535, 65535], [65535, 65535]], [[65535, 65535], [65535, 65535]]),\n  # Single Element test\n  (1, 1, 1, 1, 8, [[  5]], [[ 10]]),\n  (1, 1, 1, 1, 8, [[255]], [[  1]]),\n  (1, 1, 1, 1, 8, [[  1]], [[255]]),\n  # Non-square test\n  (2, 3, 3, 2, 8, [[2, 4, 6], [1, 3, 5]], [[7, 8], [9, 10], [11, 12]]),\n  (3, 4, 4, 2, 8, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], [[1, 2], [3, 4], [5, 6], [7, 8]]),\n  (4, 3, 3, 5, 8, [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]], [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]),\n])\ndef test_matrix_multiplication(ROW_A, COL_A, ROW_B, COL_B, INPUT_DATA_WIDTH, matrix_a, matrix_b):\n  # Run the test with input_provided=1, meaning static input matrices are passed\n  runner(ROW_A=ROW_A, COL_A=COL_A, ROW_B=ROW_B, COL_B=COL_B, INPUT_DATA_WIDTH=INPUT_DATA_WIDTH, matrix_a=matrix_a, matrix_b=matrix_b, input_provided=1)\n\n\n# Random Matrix Multiplication Tests\n# Generate random matrix dimensions and values, and run the test\n@pytest.mark.parametrize(\"random_test\", range(10))\ndef test_random_matrix_multiplication(random_test):\n  # Generate random dimensions for the matrices\n  ROW_A = random.randint(1, 8)\n  COL_A = random.randint(1, 8)\n  ROW_B = COL_A  # To make matrix multiplication valid\n  COL_B = random.randint(1, 8)\n  INPUT_DATA_WIDTH = random.randint(1, 16)\n\n  # Populate the matrices with random values\n  matrix_a = hrs_lb.populate_matrix(ROW_A, COL_A, INPUT_DATA_WIDTH)\n  matrix_b = hrs_lb.populate_matrix(ROW_B, COL_B, INPUT_DATA_WIDTH)\n\n  # Run the test with input_provided=1, meaning input matrices are passed  \n  runner(ROW_A=ROW_A, COL_A=COL_A, ROW_B=ROW_B, COL_B=COL_B, INPUT_DATA_WIDTH=INPUT_DATA_WIDTH, matrix_a=matrix_a, matrix_b=matrix_b, input_provided=1)\n\n# Input Stream Matrix Multiplication Tests (Test with multiple set of inputs)\n# These tests will run with input_provided=0, meaning matrices are generated on the fly\n@pytest.mark.parametrize(\"ROW_A, COL_A, ROW_B, COL_B, INPUT_DATA_WIDTH\", [\n  # Basic 2x2 test without inputs\n  (2, 2, 2, 2, 8),\n  # Basic 3x3 test without inputs\n  (3, 3, 3, 3, 8),\n])\ndef test_matrix_multiplication_without_inputs(ROW_A, COL_A, ROW_B, COL_B, INPUT_DATA_WIDTH):\n  # Run the test with input_provided=0, meaning matrices will be generated dynamically\n  runner(ROW_A=ROW_A, COL_A=COL_A, ROW_B=ROW_B, COL_B=COL_B, INPUT_DATA_WIDTH=INPUT_DATA_WIDTH, matrix_a=[], matrix_b=[], input_provided=0)"}}}
{"id": "cvdp_copilot_microcode_sequencer_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design a SystemVerilog RTL module `microcode_sequencer` that takes a 5-bit instruction as input and generates a 4-bit address for the control store as output. The module decodes the instruction using combinational logic and computes the corresponding control store address based on predefined mappings. This address is an index to access control store entries in an external module, enabling precise microcode execution sequencing. The design ensures low-latency decoding and compatibility with a microcoded architecture.\n\n## Design Specification :\nThe `microcode_sequencer` RTL module manages the execution of instructions, stack operations, and control signals for a microcoded system. It combines inputs like condition codes, instructions, and data inputs, and enables the generation of outputs for data, stack status, and control signals. The module integrates submodules for stack management, program counter control, instruction decoding, and arithmetic operations.\n\n## Interface:\n### Inputs:\n- `clk`(1-bit): The positive edge-triggered clock  signal required for the sequential components.\n- `c_n_in`(1-bit): Carry-in signal for the ripple carry adder.\n- `c_inc_in`(1-bit): Carry-in for the program counter incrementer.\n- `r_en`(1-bit): ACTIVE LOW auxiliary register enable signal.\n- `cc`(1-bit): ACTIVE LOW condition code input for instruction decoding.\n- `ien`(1-bit): ACTIVE LOW instruction enable signal.\n- `d_in`(4-bit , [3:0]): A 4-bit data input bus.\n- `instr_in`(5-bit, [4:0]): A 5-bit opcode representing the instruction.\n- `oen`(1-bit): ACTIVE LOW output enable for the data output path.\n\n### Outputs:\n- `d_out`(4-bit,[3:0]): A 4-bit address output bus.\n- `c_n_out`(1-bit): Carry-out signal from the ripple carry adder. LOGIC HIGH in this signal indicates the presence of carry.\n- `c_inc_out`(1-bit): Carry-out signal from the program counter incremented. LOGIC HIGH in this signal indicates the presence of carry.\n- `full`(1-bit): ACTIVE HIGH signal indicates if the Last In First Out (LIFO) stack is full.\n- `empty`(1-bit): ACTIVE HIGH signal indicates if the LIFO stack is empty.\n\n## Submodule Overview:\n### 1. Stack Management:\n#### LIFO Stack: (`lifo_stack`)\n- Implements stack operations using submodules for pointer management(`stack_pointer` submodule), memory storage(`stack_ram` submodule), and data selection(`stack_data_mux` submodule).\n- Handles push and pop operations based on decoded instructions.\n- Provides stack full and empty flags for status monitoring.\n\n## Interface\n  ##### Inputs\n  - `clk`(1-bit):  The positive edge-triggered clock signal for controlling reset , incrementing , decrementing of `stack_pointer` and read, write of `stack_ram` locations.\n  - `stack_data1_in`(4-bit,[3:0]) : Data coming from the data bus input port `d_in`.\n  - `stack_data2_in`(4-bit,[3:0]) : Data coming from the program counter\n  - `stack_reset`(1-bit): Control signal coming from the instruction decoder to initialize the stack pointer register to 5'b00000.\n  - `stack_push`(1-bit): Used in combination with `full_o` output signal to increment the stack pointer by 1.\n  - `stack_pop`(1-bit): Used in conjunction with `empty_o` output signal to decrement the stack pointer by 1.\n  - `stack_mux_sel`(1-bit): ACTIVE HIGH control signal coming from the instruction decoder to select one of the two data available at the input of `stack_mux` submodule.\n  - `stack_we`(1-bit): Control signal coming from the instruction decoder to write the selected data coming out from the `stack_mux_select` submodule into the `stack_ram` submodule given by the address provided by the `stack_pointer` submodule.\n  - `stack_re`(1-bit): Control signal coming from the instruction decoder to read the data from the selected address of the `stack_ram` submodule.\n  ##### Outputs :\n  - `stack_data_out` (4-bit,[3:0]) - The 4-bit data that is read from a stack location.\n  - `full_o` - Indicates whether the `stack_pointer` has reached the highest location of `stack_ram` submodule(i.e. Location number 16).\n  - `empty_o` - Indicates whether the `stack_pointer` has reached the lowest location of `stack_ram` submodule(i.e. Location number 0).\n  \n##### Submodules:\n- `stack_pointer`: Maintains the current stack address with full and empty detection.\n    ##### Interface\n    ##### Inputs :\n    - `clk`(1-bit):The positive edge-triggered clock signal to control reset, increment and decrement of 5-bit `stack_pointer` register.\n    - `rst`(1-bit) :  ACTIVE HIGH control signal that is coming out from the `instruction_decoder` module to initialize the `stack_pointer` register to 5'b00000.\n    - `push`(1-bit) : ACTIVE HIGH signal used in combination with `full` output signal to increment the stack pointer register by 1.\n    - `pop`(1-bit) : ACTIVE HIGH signal used in conjunction with `empty` output signal to decrement the stack pointer register by 1.\n   ##### Outputs :\n    - `stack_addr`(5-bit,[4:0]) : Value generated by the `stack_pointer` register to address a `stack_ram` location.\n    - `full`(1-bit) : ACTIVE HIGH signal indicates whether the `stack_pointer` has reached the highest location of `stack_ram` submodule(i.e. Location number 16). This condition is checked combinationally through continuous assignment statement.\n    - `empty`(1-bit): ACTIVE HIGH indicates whether the `stack_pointer` has reached the lowest location of `stack_ram` submodule(i.e. Location number 0). This condition is checked combinationally through continuous assignment statement.\n    \n- `stack_ram`: Stores 4-bit data words for stack operations.\n   ##### Interface\n   ##### Inputs :\n   - `clk`(1-bit) : The positive edge-triggered clock signal to control the read and write of `stack_ram` locations.\n   - `stack_addr`(5-bit,[4:0]) : 5-bit data coming from the `stack_pointer` submodule\n   - `stack_data_in`(4-bit,[3:0]) : 4-bit data coming from the `stack_data_mux` submodule.\n   - `stack_we`(1-bit) :  ACTIVE HIGH Write Enable control signal that is coming out from the `instruction_decoder` module to write the data coming out from`stack_data_mux` submodule into the location generated by `stack_pointer` submodule.\n   - `stack_re`(1-bit) :  ACTIVE HIGH Read Enable control signal that is coming out from the `instruction_decoder` module to read the data from `stack_ram` location that is provided by `stack_pointer` submodule\n   ##### Outputs :\n   - `stack_data_out` (4-bit,[3:0]) : Data coming out from the `stack_ram` location during a `read` operation\n   \n- `stack_data_mux`: Selects data input for stack operations based on control signals.\n   ##### Interface \n   ##### Inputs :\n   - `data_in`(4-bit,[3:0]): Data coming from the data bus input port `d_in`.\n   - `pc_in`(4-bit,[3:0]): Data coming from the `program_counter` module\n   - `stack_mux_sel`(1-bit):  \n               - `stack_mux_sel` == 1'b1 : `data_in` is selected.\n               - `stack_mux_sel` == 1'b0 : `pc_in` is selected.\n   ##### Output :\n   - `stack_mux_out`(4-bit,[3:0]) : Data selected from one of the two inputs `data_in` or `pc_in`.\n\n### 2. Program Counter (PC) Control:\n#### Program Counter: (`program_counter`)\n- Computes the next PC value using a multiplexer(`pc_mux` submodule) and an incremented(`pc_incrementer` submodule)\n- Supports branching or sequential execution based on decoded signals.\n##### Interface \n##### Inputs :\n- `clk`(1-bit): The positive edge-triggered clock signal to control the transfer the data from input to output of `pc_reg` submodule.\n- `full_adder_data_i`(4-bit,[3:0]) : 4-bit sum coming out of the `full_adder` submodule of `microcode_arithmetic` module.\n- `pc_c_in`(1-bit) : Input carry to control whether the data going into `pc_reg` module should get incremented or not.\n- `inc`(1-bit): ACTIVE HIGH control signal coming from the `instructicon_decoder` module to inhibit or allow the `pc_c_in` to have effect on the program counter increment operation.\n- `pc_mux_sel`(1-bit):  \n              - `pc_mux_sel` == 1'b1 : `full_adder_data` is selected.\n              - `pc_mux_sel` == 1'b0 : `pc_data` is selected.\n##### Outputs :\n- `pc_out`(4-bit,[3:0]) : 4-bit data coming out from the `pc_reg` submodule.\n- `pc_c_out`(1-bit) : Carry output coming out from the `pc_incrementer` submodule.\n\n##### Submodules:\n- `pc_mux`: Selects between the full adder output and the current PC value.\n   ##### Interface\n   ##### Inputs :\n   - `full_adder_data`(4-bit,[3:0]) : 4-bit sum coming out from the `full_adder` submodule of `microcode_arithmetic` submodule.\n   - `pc_data`(4-bit,[3:0]): 4-bit data coming out from the `pc_reg` submodule.\n   - `pc_mux_sel`(1-bit) : \n                 - `pc_mux_sel` == 1'b1 : `full_adder_data` is selected.\n                 - `pc_mux_sel` == 1'b0 : `pc_data` is selected.\n   ##### Output :\n   - `pc_mux_out`(4-bit,[3:0]): 4-bit data selected from the inputs of the `pc_mux` submodule.\n   \n- `pc_incrementer`: Computes the incremented PC value with an optional `carry_in`\n   ##### Interface\n   ##### Inputs :\n   - `pc_c_in` (1-bit): Carry input to the ripple carry adder based `pc_incrementer` submodule.\n   - `inc` (1-bit): If ACTIVE HIGH , `pc_data_in` gets incremented with the value of `pc_c_in` and then goes to `pc_inc_out`. If  ACTIVE LOW , `pc_data_in` goes to `pc_inc_out` without any change.\n   - `pc_data_in`(4-bit,[3:0]) : 4-bit data coming from `pc_mux` submodule\n   ##### Outputs :\n   - `pc_inc_out`(4-bit,[3:0]) : 4-bit data coming out from the `pc_incrementer` submodule.\n   - `pc_c_out` (1-bit) : Carry output of the ripple carry adder based `pc_incrementer` submodule.\n   \n- `pc_reg`: Stores the updated PC value on the positive clock edge.\n   ##### Interface\n   ##### Inputs :\n   - `clk`(1-bit) : The positive edge-triggered clock signal to control the transfer the data from input to output of `pc_reg` submodule.\n   - `pc_data_in`(4-bit,[3:0]) : Data coming from the `pc_incrementer` submodule\n   ##### Output :\n   - `pc_data_out`(4-bit,[3:0]) : Data coming out from the `pc_reg` submodule. \n\n### 3. Arithmetic Operations:\n#### Microcode Arithmetic: (`microcode_arithmetic`)\n- Executes addition microoperation through ripple carry full adder(`full_adder` submodule).\n- Provides flexibility for data selection through multiplexers for A(`a_in` of `full_adder` submodule) and B inputs(`b_in` of `full_adder` submodule).\n\n#### Interface\n##### Inputs :\n- `clk` (1-bit) : The positive edge-triggered clock signal to control the transfer of data from input to output of `aux_reg` submodule.\n- `fa_in`(4-bit,[3:0]) : The 4-bit sum coming out from the ripple carry adder is fed back into the adder through `aux_reg_mux` submodule.\n- `d_in`(4-bit,[3:0]): The 4-bit coming from the `d_in` input port of the `microcode_sequencer` module.\n- `stack_data_in`(4-bit,[3:0]) : The 4-bit data coming out from the `lifo_stack` module and is applied to one of the inputs of `b_mux` submodule.\n- `pc_data_in`(4-bit,[3:0]): The 4-bit data coming out from the `program_counter` module and is applied to one of the inputs of `b_mux` submodule.\n- `reg_en`(1-bit) : Used along with ACTIVE HIGH `rce` signal from `instruction_decoder` module to transfer the data from input to output of `aux_reg` submodule.\n- `oen`(1-bit) : ACTIVE LOW signal coming from the `microcode_sequencer` module.\n- `rce`(1-bit) : Used along with ACTIVE LOW `reg_en` signal from `microcode_sequencer` module to transfer the data from input to output of `aux_reg` submodule.\n- `cen` (1-bit): ACTIVE HIGH control signal from `instruction_decoder` module to allow or inhibit the input carry of the ripple carry `full_adder` submodule which in turn affect the addition microoperation.\n- `a_mux_sel`(2-bit,[1:0]) : Signal to select one of the three inputs of `a_mux` submodule.\n- `b_mux_sel`(2-bit,[1:0]): Signal to select one of the four inputs of `b_mux` submodule.\n- `arith_cin`(1-bit): Carry input coming from the `microcode_sequencer` module.\n- `oe`(1-bit) : ACTIVE HIGH control signal from `instruction_decoder` module that is used along with ACTIVE LOW `oen` signal to control the output of ripple carry `full_adder` module.\n##### Outputs :\n- `arith_cout`(1-bit): Carry output coming out from the ripple carry `full_adder` submodule.\n- `d_out`(4-bit,[3:0]): 4-bit sum coming out from the ripple carry `full_adder` submodule.\n\n##### Submodules:\n- `aux_reg_mux` : Selects one of the two inputs : sum from `full_adder` submodule or `d_in`\n   ##### Interface\n   ##### Inputs :\n   - `reg1_in`(4-bit,[3:0]): 4-bit sum of the ripple carry `full_adder` submodule\n   - `reg2_in`(4-bit,[3:0]): 4-bit data coming from the data bus input port `d_in` from `microcode_sequencer` module\n   - `rsel`(1-bit),`re`(1-bit) : `rsel`(**r**egister **sel**ect) is an ACTIVE HIGH control signal coming from `instruction_decoder` module. `re`(**r**egister **en**able) is the ACTIVE LOW signal coming from the `r_en` of `microcode_sequencer` module. Logical AND of the `rsel` and ~(`re`) signal generates the `aux_reg_mux` select signal.\n              `aux_reg_mux` select signal == 1'b1 : `reg1_in` is selected.\n              `aux_reg_mux` select signal == 1'b0 : `reg2_in` is selected.\n   ##### Output :\n   - `reg_mux_out`(4-bit,[3:0]) : Data coming out from the `aux_reg_\n- `aux_reg` : Transfers the data coming out from the `aux_reg_mux` submodule on the positive edge of clock signal.\n   ##### Interface\n   ##### Inputs :\n   - `clk`(1-bit): The positive edge-triggered clock signal that controls the transfer of data from input to output of `aux_reg` submodule.\n   - `reg_in`(4-bit,[3:0]): Data coming from the `aux_reg_mux` submodule.\n   - `rce`(1-bit),`re`(1-bit): `rce`(**r**egister **c**hip **e**nable) is an ACTIVE HIGH control signal coming from `instruction_decoder` module. `re`(**r**egister **en**able) is the ACTIVE LOW signal coming from the `r_en` of `microcode_sequencer` module. Logical  OR  of `rce` and ~(`re`) generate the enable signal for data transfer from input to output of `aux_reg` submodule.\n   ##### Output :\n   - `reg_out`(4-bit,[3:0]): Data transferred coming out of the `aux_reg` submodule.\n   \n- `a_mux` : Selects data from `full_adder` submodule , `aux_reg` submodule or 4-bit constant , 4'b0000\n   ##### Interface\n   ##### Inputs :\n   - `register_data`(4-bit,[3:0]) : Data coming from `aux_reg` submodule.\n   - `data_in`(4-bit,[3:0]): Data coming from data bus input `d_in`\n   - A 4-bit constant . 4'b0000\n   - `a_mux_sel`(2-bit,[1:0]) : Control signal coming from `instruction_decoder` module to select either `register_data` or `data_in` or 4'b0000.\n           - `a_mux_sel` == 2'b00 : `data_in`  is selected.\n           - `a_mux_sel` == 2'b01 : `register_data` is selected.\n           - `a_mux_sel` == 2'b10 : 4'b0000 is selected.\n   ##### Output :\n   - `a_mux_out`(4-bit,[3:0]): The 4-bit selected data coming out from the multiplexer module.\n\n- `b_mux` : Selects data from `aux_reg` submodule , `program_counter` module , `lifo_stack` module or 4-bit constant, 4'b0000.\n   ##### Interface\n   ##### Inputs :\n   - `register_data`(4-bit,[3:0]): 4-bit data coming from `aux_reg` submodule of the `microcode_arithmetic` module.\n   - `stack_data`(4-bit,[3:0]): 4-bit data coming from `lifo_stack` module.\n   - `pc_data`(4-bit,[3:0]): 4-bit data coming from `program_counter` module\n   - `b_mux_sel`(2-bit,[1:0]): Control signal coming from `instruction_decoder` module to select data coming from `aux_reg` submodule or `program_counter` module or `lifo_stack` module or 4-bit constant, 4'b0000.\n             - `b_mux_sel` == 2'b00 : `pc_data` is selected.\n             - `b_mux_sel` == 2'b01 : `stack_data` is selected.\n             - `b_mux_sel` == 2'b10 : 4'b0000 is selected\n             - `b_mux_sel` == 2'b11 : `register_data` is selected\n   ##### Output :\n   - `b_mux_out`(4-bit,[3:0]): The 4-bit selected data coming out from the multiplexer module.\n\n- `full_adder`: Performs 4-bit ripple-carry addition operation with optional carry-in.\n   ##### Interface\n   ##### Inputs :\n   - `a_in`(4-bit,[3:0]) : 4-bit data coming from the `a_mux` submodule. This is called **A operand** of the `full_adder` submodule\n   - `b_in`(4-bit,[3:0]): 4-bit data coming from the `b_mux` submodule. This is called **B operand** of the `full_adder` submodule\n   - `c_in`(1-bit) : Carry input of the ripple carry `full_adder` submodule.\n   - `cen`(1-bit) : ACTIVE HIGH control signal coming from `instruction_decoder` module , which inhibits or allows `c_in` from affecting the 4-bit sum.\n   ##### Output :\n   - `c_out`(4-bit,[3:0]) : 4-bit sum generated by the `full_adder` submodule.\n\n### 4. Instruction Decoder: (`instruction_decoder`)\n- Decodes the 5-bit instruction opcode and generates control signals for `microcode_arithmetic` , `lifo_stack` `program_counter` and `result_register` modules.\n- Supports conditional execution based on condition code (`cc`) input.\n##### Interface :\n##### Inputs :\n- `instr_in`(5-bit,[4:0]) : A 5-bit opcode \n   Supported opcodes :\n   \n  - `5'b00000 - PRST (Program ReSeT)` - Forces the D output(`d_out`) of the `microcode_sequencer` module to 4'b0000. Loads zero or one into `program_counter` module , depending on the carry input of the `pc_incrementer` submodule of the `program_counter` module and reset  `stack_pointer` submodule of `lifo_stack` module. The contents in locations of `stack_ram` submodule of `lifo_stack` module remains unchanged and the `aux_reg` submodule and `aux_reg_mux` submodules are controlled by `reg_en` input signal of the `microcode_sequencer` module.\n   \n  - `5'b00001 - Fetch PC` - To provide the content of the `program_counter` module at the D output (`d_out) of the `microcode_sequencer` module.\n   \n  - `5'b00010 - Fetch R` - To provide the content of the `aux_reg` submodule of the `microcode_arithmetic` module at the D output (`d_out`) of the `microcode_sequencer_module`.\n   \n  - `5'b00011 - Fetch D` - To provide the content of `d_in` at the D output (`d_out`) of the `microcode_sequencer` module\n\n  - `5'b00100 - Fetch R + D` - To read `d_in` and `aux_reg` contents and provides their sum at the D output (`d_out`) of the `microcode_sequencer` module.\n   \n  - `5b01011 - Push PC` - To write the contents of `program_counter` module onto the `Top of Stack` given by the content of `stack_pointer` submodule of `lifo_stack` module. This operation also causes increment of the `stack_pointer` submodule\n   \n  - `5'b01110 - Pop PC` - To read the contents of  `Top of Stack` given by the content of `stack_pointer` submodule of `lifo_stack`  module and provide it at the D output (`d_out`) of `microcode_sequencer` module.\n\n- `cc_in`(1-bit) - Condition code . Generally maintained at LOGIC LOW for the opcodes to be decoded.\n- `instr_en`(1-bit) - ACTIVE LOW signal to enable the `instruction_decoder` module to generate control signals.\n##### Outputs :\n- `cen`(1-bit) : ACTIVE HIGH control signal that allows carry input of `full_adder` submodule of `microcode_arithmetic` module to have effect on addition operation.\n- `rst`(1-bit): ACTIVE HIGH control signal that resets the `stack_pointer` register of `stack_pointer` submodule of `lifo_stack` module.\n- `oen`(1-bit) : ACTIVE HIGH control signal that enables the output of `full_adder` submodule to be available at D output (`d_out`) of `microcode_sequencer` module.\n- `inc`(1-bit) : ACTIVE HIGH control signal that enables the increment operation of `pc_incrementer` submodule of `program_counter` module by 1.\n- `rsel`(1-bit) : ACTIVE HIGH control signal LOGICALLY ANDed with ACTIVE LOW `reg_en` signal of `microcode_sequencer` to select a value from `aux_reg_mux` submodule of `microcode_arithmetic` module.\n- `rce`(1-bit) : ACTIVE HIGH control signal LOGICALLY ORed with ACTIVE LOW `reg_en` signal of `microcode_sequencer` to transfer the content from input to output of `aux_reg` submodule of `microcode_arithmetic` module.\n- `pc_mux_sel`(1-bit) : ACTIVE HIGH control signal to select one of the two data available at the input of `pc_mux`\n- `a_mux_sel`(2-bit,[1:0]): Control signal coming from `instruction_decoder` module to select data either from `aux_reg` submodule of `microcode_arithmetic` module , `d_in` coming from the `microcode_sequencer` module or 4-bit constant , 4'b0000.\n- `b_mux_sel`(2-bit,[1:0]): Control signal coming from `instruction_decoder` module to select data coming from `aux_reg` submodule or `program_counter` module or `lifo_stack` module or 4-bit constant, 4'b0000.\n- `push`(1-bit) : ACTIVE HIGH control signal used along with `full` signal from `stack_pointer` submodule to increment the `stack_pointer` register of `stack_pointer` submodule of `lifo_stack` module by 1.\n- `pop`(1-bit):ACTIVE HIGH control signal used along with `empty` signal from `stack_pointer` submodule to decrement the `stack_pointer` register of `stack_pointer` submodule of `lifo_stack` module by 1.\n- `src_sel`(1-bit): ACTIVE HIGH control signal  to select one of the two data available at the input of `stack_mux` submodule of `lifo_stack` module.\n- `stack_we`(1-bit) : ACTIVE HIGH Write Enable control signal to write the data coming out from`stack_data_mux` submodule into the location generated by `stack_pointer` submodule.\n- `stack_re`(1-bit): ACTIVE HIGH Read Enable control signal  to read the data from `stack_ram` location that is provided by `stack_pointer` submodule.\n- `out_ce`(1-bit): ACTIVE HIGH control signal to enable the `result_register` module to output the data (`d_out`) from `microcode_arithmetic` module.\n   \n### 5. Result Register: (`result_register`)\n- Captures the output of the arithmetic unit \n- Enables output only when instructed by control signal `out_ce` coming from `instruction_decoder` module.\n##### Interface\n##### Inputs :\n- `clk`(1-bit) : The positive edge-triggered clock signal which controls the data transfer from input to output of `result_register` module\n- `data_in`(4-bit,[3:0]) - Data coming from the D output (`d_out`) of `microcode_arithmetic` module.\n- `out_ce`(1-bit): ACTIVE HIGH control signal coming from `instruction_decoder` module that is synchronous with `clk` signal to transfer data rom input to output of `result_register` module.\n##### Output :\n- `data_out(4-bit,[3:0])` : 4-bit data coming out from the `result_register` module.\n\n## Control Flow and Signal Logic:\n### Instruction Decoding:\n- The instruction decoder interprets the `instr_in` opcode and generates control signals for stack, PC, and arithmetic units.\n- Outputs such as `push`, `pop`, `cen`, `rst`, and multiplexer select (`a_mux_sel`, `b_mux_sel`) are driven by the decoded signals.\n\n### Program Counter:\n- The PC value is updated based on the instruction, either incrementing or branching to a target address.\n- Branching is controlled by the `pc_mux_sel` signal.\n\n### Stack Operations:\n- Stack data is pushed or popped based on the `stack_push` and `stack_pop` signals.\n- The data source is selected via `stack_mux_sel`, either from the PC or from the output of `microcode_arithmetic` module.\n\n### Data Flow:\n- Addition operation is performed using the full adder, with inputs selected by the A(`a_mux` submodule of `microcode_arithmetic` module ) and B multiplexers(`b_mux` submodule of `microcode_arithmetic` module)\n- Results are written to the result register or output via `d_out`.\n\n## Key Assumptions and Constraints :\n- Instruction and Control Flow:\nBased on decoded signals, the module takes a 5-bit instruction opcode (`instr_in`) and determines the appropriate operations for the program counter, stack, and arithmetic unit.\n- Pipeline Integration:\nThis module is designed to function as part of a microcoded pipeline. Based on micro-instructions, it coordinates stack pushes/pops, data flow, and PC updates.\n- Behavior:\nThe module works sequentially, with support of combinational modules such as `full_adder`  , `a_mux` , `b_mux` , `stack_data_mux`  , `pc_mux` submodules. The various submodules of the design are :\n  - `lifo_stack` (Submodules present in this are :  `stack_data_mux` , `stack_pointer` , and `stack_ram`)\n  - `program_counter` (Submodules present in this are : `pc_mux` , `pc_incrementer` , and `pc_reg`)\n  - `microcode_arithmetic` (Submodules present in this are: `aux_reg_mux`, `aux_reg` , `a_mux` , `b_mux` , and `full_adder`) \n  - `instruction_decoder`\n  - `result_register` \n- Operating frequency of this module should be 50MHz. The module won't exhibit  correct behavior if there is any deviation in this operating frequency\n- Operational Latency :\n- The output latency for PUSH and POP instructions will be 2 and 3 clock cycles, respectively. For the remaining instructions, the output will be reflected for the immediate input change without delay.\n\n\n## Example Scenario:\nInstruction: Push PC onto the Stack (`instr_in` = 5'b01011).\n\nThe decoder enables `stack_push` and `stack_we`.\nThe data from the `program_counter` is selected via the multiplexer and written to the stack.\n\nInstruction: Fetch PC (`instr_in` = 5'b00001).\n\nThe decoder enables the multiplexers in the `microcode_arithmetic` module, such that the PC value is routed to the Full Adder Output\n\nInstruction: Fetch Auxiliary Register (`instr_in` = 5'b00010).\n\nThe decoder configures `a_mux_sel` and `b_mux_sel` for desired inputs.\nThe value of the auxiliary register is routed to the `full_adder` output\n\n## Example Waveform :\n```wavedrom\n{\n  \"signal\": [\n    {\"name\": \"clk\", \"wave\": \"p...............\"},\n    {\"name\": \"c_inc_in\", \"wave\": \"01....0.........\", \"data\": []},\n    {\"name\": \"c_inc_out\", \"wave\": \"0...............\", \"data\": []},\n    {\"name\": \"c_n_in\", \"wave\": \"0........1.0....\", \"data\": []},\n    {\"name\": \"c_n_out\", \"wave\": \"0...............\", \"data\": []},\n    {\"name\": \"cc\", \"wave\": \"0...1...........\", \"data\": []},\n    {\"name\": \"d_in[3:0]\", \"wave\": \"x...4..5.6....7.\", \"data\": [\"A\", \"B\", \"3\",\"X\"]},\n    {\"name\": \"d_out[3:0]\", \"wave\": \"34567..8.9.9..99\", \"data\": [\"0\",\"1\",\"2\",\"X\",\"A\",\"B\",\"F\",\"7\",\"6\",\"7\"]},\n    {\"name\": \"empty\", \"wave\": \"1..............0\", \"data\": []},\n    {\"name\": \"full\", \"wave\": \"0...............\", \"data\": []},\n    {\"name\": \"ien\", \"wave\": \"0...............\", \"data\": []},\n    {\"name\": \"instr_in[4:0]\", \"wave\": \"34.5...6.7....8.\", \"data\": [\"00\", \"01\", \"02\", \"03\", \"04\",\"0B\"]},\n    {\"name\": \"oen\", \"wave\": \"0...............\", \"data\": []},\n    {\"name\": \"r_en\", \"wave\": \"0...............\", \"data\": []}\n  ],\n  \"config\": {\"hscale\": 4}\n}\n```", "context": {}}, "output": {"response": "", "context": {"rtl/microcode_sequencer.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir  \n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/microcode_sequencer.sv\nTOPLEVEL        = microcode_sequencer\nMODULE          = test_microcode_sequencer\nPYTHONPATH      = /src\nHASH            = 1-microcode_sequence_rtl_generation_issue-2\n", "src/test_microcode_sequencer.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge , Timer\nimport random\n\n\n@cocotb.test()\nasync def test_microcode_sequencer(dut):\n    \"\"\"Testbench for microcode_sequencer\"\"\"\n\n    # Create a clock with a period of 20 ns (50 MHz)\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Initialize all inputs\n    dut.instr_in.value = 0\n    dut.c_n_in.value = 0\n    dut.c_inc_in.value = 0\n    dut.r_en.value = 0\n    dut.cc.value = 0\n    dut.ien.value = 0\n    dut.d_in.value = 0\n    dut.oen.value = 0\n\n    # Reset DUT\n    dut._log.info(\"Resetting DUT...\")\n    await Timer(3, units=\"ns\")  # Wait for reset to propagate\n    dut._log.info(\"Reset complete.\")\n\n    # Allow signals to settle\n    await Timer(20, units=\"ns\")\n\n    # Utility function to safely read signal values\n    def safe_read(signal):\n        \"\"\"Safely read a signal, handling unknown ('X') values.\"\"\"\n        try:\n            return int(signal.value)\n        except ValueError:\n            dut._log.warning(f\"Signal {signal._name} has an unknown value ('X'). Defaulting to 0.\")\n            return 0\n\n    @cocotb.test()\n    async def test_push_pc_instruction(dut):\n        \"\"\"Testbench for Push PC Instruction\"\"\"\n        dut._log.info(f\"Push_PC_instruction\")\n        # Start a clock with a period of 20 ns\n        cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n        # Initialize inputs\n        dut.instr_in.value = 0\n        dut.c_n_in.value = 0\n        dut.c_inc_in.value = 0\n        dut.r_en.value = 0\n        dut.cc.value = 0\n        dut.ien.value = 0\n        dut.d_in.value = 0\n        dut.oen.value = 0\n\n        # Reset DUT\n        await Timer(9, units=\"ns\")\n\n        # Apply Push PC Instruction inputs\n        dut.instr_in.value = 0b01011\n        dut.c_n_in.value = 0\n        dut.c_inc_in.value = 0\n        dut.r_en.value = 0\n        dut.cc.value = 0\n        dut.ien.value = 0\n        dut.d_in.value = 0\n        dut.oen.value = 0\n\n        # Wait for the DUT to process the inputs\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        \n        # Assertions\n        expected_d_out = 0b01000  # Update based on expected PC value\n        actual_d_out = safe_read(dut.d_out)\n        assert actual_d_out == expected_d_out, f\"Push PC Instruction failed: Expected {expected_d_out}, got {actual_d_out}\"\n\n        dut._log.info(\"Push PC Instruction test passed.\")\n    \n    @cocotb.test()\n    async def test_pop_pc_instruction(dut):\n        \"\"\"Testbench for Pop PC Instruction\"\"\"\n        dut._log.info(f\"Pop_PC_instruction\")\n        # Start a clock with a period of 20 ns\n        cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n        # Initialize inputs\n        dut.instr_in.value = 0\n        dut.c_n_in.value = 0\n        dut.c_inc_in.value = 0\n        dut.r_en.value = 0\n        dut.cc.value = 0\n        dut.ien.value = 0\n        dut.d_in.value = 0\n        dut.oen.value = 0\n\n        # Reset DUT\n        await Timer(15, units=\"ns\")\n\n        # Apply Pop PC Instruction inputs\n        dut.instr_in.value = 0b01110\n        dut.c_n_in.value = 0\n        dut.c_inc_in.value = 0\n        dut.r_en.value = 0\n        dut.cc.value = 0\n        dut.ien.value = 0\n        dut.d_in.value = 0\n        dut.oen.value = 0\n\n        # Wait for the DUT to process the inputs\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        \n        # Assertions\n        expected_d_out = 0b01000  # Update based on expected PC value\n        actual_d_out = safe_read(dut.d_out)\n        assert actual_d_out == expected_d_out, f\"Push PC Instruction failed: Expected {expected_d_out}, got {actual_d_out}\"\n\n        dut._log.info(\"Pop PC Instruction test passed.\")\n\n    # Test Task equivalent\n    async def run_test_case(\n        test_instr,          # Instruction input\n        test_carry_in,       # Carry input\n        test_carry_inc,      # Carry increment input\n        test_reg_en,         # Register enable\n        test_cond_code,      # Condition code\n        test_instr_en,       # Instruction enable\n        test_data_in,        # Data input\n        test_output_en,      # Output enable\n        expected_d_out,      # Expected data output\n        expected_c_n_out,    # Expected carry out (full adder)\n        expected_c_inc_out,  # Expected carry increment out\n        expected_full,       # Expected full condition\n        expected_empty,      # Expected empty condition\n        case_name            # Name of the test case\n    ):\n        # Apply inputs\n        dut.instr_in.value = test_instr\n        dut.c_n_in.value = test_carry_in\n        dut.c_inc_in.value = test_carry_inc\n        dut.r_en.value = test_reg_en\n        dut.cc.value = test_cond_code\n        dut.ien.value = test_instr_en\n        dut.d_in.value = test_data_in\n        dut.oen.value = test_output_en\n\n        # Wait for two clock cycles to allow the DUT to settle\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n\n        # Log inputs, internal signals, and outputs\n        dut._log.info(f\"Running test case: {case_name}\")\n        dut._log.info(f\"Inputs: instr_in = {int(dut.instr_in.value)}, c_n_in = {dut.c_n_in.value}, \"\n                      f\"c_inc_in = {dut.c_inc_in.value}, r_en = {dut.r_en.value}, cc = {dut.cc.value}, \"\n                      f\"ien = {dut.ien.value}, d_in = {int(dut.d_in.value)}, oen = {dut.oen.value}\")\n        dut._log.info(f\"Expected: d_out = {expected_d_out}, c_n_out = {expected_c_n_out}, \"\n                      f\"c_inc_out = {expected_c_inc_out}, full = {expected_full}, empty = {expected_empty}\")\n        dut._log.info(f\"Actual: d_out = {int(dut.d_out.value)}, c_n_out = {dut.c_n_out.value}, \"\n                      f\"c_inc_out = {dut.c_inc_out.value}, full = {dut.full.value}, empty = {dut.empty.value}\")\n\n        # Assertions\n        assert int(dut.d_out.value) == expected_d_out, f\"{case_name} - d_out mismatch\"\n        assert dut.c_n_out.value == expected_c_n_out, f\"{case_name} - c_n_out mismatch\"\n        assert dut.c_inc_out.value == expected_c_inc_out, f\"{case_name} - c_inc_out mismatch\"\n        assert dut.full.value == expected_full, f\"{case_name} - full mismatch\"\n        assert dut.empty.value == expected_empty, f\"{case_name} - empty mismatch\"\n\n    # Run fixed test cases\n    await run_test_case(0b00000, 0, 0, 0, 0, 0, 0b0000, 0, 0b0000, 0, 0, 0, 1, \"Reset Instruction\")\n    await run_test_case(0b00001, 0, 1, 0, 0, 0, 0b0000, 0, 0b0001, 0, 0, 0, 1, \"Fetch PC Instruction 1\")\n    await run_test_case(0b00001, 0, 0, 0, 0, 0, 0b0000, 0, 0b0010, 0, 0, 0, 1, \"Fetch PC Instruction 2\")\n    await run_test_case(0b00010, 0, 1, 0, 0, 0, 0b1010, 0, 0b1010, 0, 0, 0, 1, \"Fetch R Instruction\")\n    await run_test_case(0b00011, 0, 1, 0, 0, 0, 0b1011, 0, 0b1011, 0, 0, 0, 1, \"Fetch D Instruction\")\n    await run_test_case(0b00100, 1, 1, 0, 0, 0, 0b0011, 0, 0b0111, 0, 0, 0, 1, \"Fetch R+D Instruction\")\n    await test_push_pc_instruction(dut)\n    await test_push_pc_instruction(dut) \n    await test_pop_pc_instruction(dut)\n    await test_pop_pc_instruction(dut)\n    # Add randomized test case\n    for i in range(2):  # Run 2 randomized test cases\n        random_instr = 0  # Reset Instruction\n        random_carry_in = 0\n        random_carry_inc = 0\n        random_reg_en = 0\n        random_cond_code = 0\n        random_instr_en = 0\n        random_data_in = random.randint(0, 15)  # Random 4-bit data input\n        random_output_en = 0\n\n        # Determine expected values based on DUT behavior\n        expected_d_out = 0  # Example behavior, adjust as per DUT logic\n        expected_c_n_out = 0  # Adjust based on DUT\n        expected_c_inc_out = 0  # Adjust based on DUT\n        expected_full = 0  # Adjust based on DUT\n        expected_empty = 1  # Adjust based on DUT\n\n        await run_test_case(\n            random_instr,\n            random_carry_in,\n            random_carry_inc,\n            random_reg_en,\n            random_cond_code,\n            random_instr_en,\n            random_data_in,\n            random_output_en,\n            expected_d_out,\n            expected_c_n_out,\n            expected_c_inc_out,\n            expected_full,\n            expected_empty,\n            f\"Random Test Case {i+1}\"\n        )\n\n    dut._log.info(\"All test cases, including randomized tests, completed successfully.\")\n\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\n# Fetch environment variables for simulation setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang = os.getenv(\"TOPLEVEL_LANG\", \"verilog\")\nsim = os.getenv(\"SIM\", \"icarus\")\ntoplevel = os.getenv(\"TOPLEVEL\", \"microcode_sequencer\")\nmodule = os.getenv(\"MODULE\", \"test_microcode_sequencer\")\nwave = os.getenv(\"WAVE\", \"0\")\n\n# Function to configure and run the simulation\ndef runner():\n    \"\"\"Runs the simulation for the microcode sequencer.\"\"\"\n    # Get the simulation runner\n    simulation_runner = get_runner(sim)\n\n    # Build the simulation environment\n    simulation_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,         # Always rebuild\n        clean=True,          # Clean previous build files\n        waves=True ,   # Enable waveform generation if WAVE=1\n        verbose=True,        # Verbose build and simulation output\n        timescale=(\"1ns\", \"1ns\"),  # Set the timescale for simulation\n        log_file=\"build.log\"      # Log file for the build process\n    )\n\n    # Run the testbench\n    simulation_runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True    # Enable waveform dump if WAVE=1\n    )\n\n# Pytest function to run the simulation\n##@pytest.mark.simulation\ndef test_microcode_sequencer():\n    \"\"\"Pytest function to execute the microcode sequencer testbench.\"\"\"\n    print(\"Running microcode sequencer testbench...\")\n    runner()\n\n"}}}
{"id": "cvdp_copilot_morse_code_0001", "categories": ["cid003", "easy"], "input": {"prompt": "The `morse_encoder` Verilog module translates 8-bit ASCII characters (`ascii_in [7:0]`) into Morse code. The output includes a 10-bit Morse code sequence (`morse_out [9:0]`) and a 4-bit length indicator (`morse_length [3:0]`). It employs a `case` statement for direct mapping and defaults to zero for unsupported inputs, ensuring immediate updates through combinational logic for real-time encoding \n\n---\nModule Interface\nInputs:\n\n- ascii_in [7:0]: Receives an 8-bit ASCII value, which specifies a character for Morse code encoding.\n\nOutputs:\n\n- morse_out [9:0]: Delivers the Morse code as a 10-bit binary sequence.\n- morse_length [3:0]: Outputs the length of the Morse code sequence to indicate how many bits in morse_out are valid.\n---\nModule Functionality\nEncoding Logic:\n\n- Morse Code Encoding: Morse code is represented in binary, where a dot (.) is 0 and a dash (-) is 1.\n- Binary Output: The morse_out register outputs the Morse code as a right-aligned binary sequence within a 10-bit field.\n- Sequence Length: The morse_length register indicates the number of valid bits in the morse_out sequence, representing the actual length of the Morse code.\n- Default Handling: If an ASCII input doesn\u2019t match any predefined cases, both morse_out and morse_length are set to zero, indicating no valid Morse code output.\n- Uppercase Only: The implementation explicitly handles uppercase ASCII characters (A to Z and 0 to 9).\n\n---\nASCII character to Morse code mapping :\n\n| ASCII Character | Morse Code | Binary Morse Code | Morse Length |\n|-----------------|------------|-------------------|--------------|\n| A (`0x41`)      | `.-`       | `10'b01`          | 2            |\n| B (`0x42`)      | `-...`     | `10'b1000`        | 4            |\n| C (`0x43`)      | `-.-.`     | `10'b1010`        | 4            |\n| D (`0x44`)      | `-..`      | `10'b100`         | 3            |\n| E (`0x45`)      | `.`        | `10'b0`           | 1            |\n| F (`0x46`)      | `..-.`     | `10'b0010`        | 4            |\n| G (`0x47`)      | `--.`      | `10'b110`         | 3            |\n| H (`0x48`)      | `....`     | `10'b0000`        | 4            |\n| I (`0x49`)      | `..`       | `10'b00`          | 2            |\n| J (`0x4A`)      | `.---`     | `10'b0111`        | 4            |\n| K (`0x4B`)      | `-.-`      | `10'b101`         | 3            |\n| L (`0x4C`)      | `.-..`     | `10'b0100`        | 4            |\n| M (`0x4D`)      | `--`       | `10'b11`          | 2            |\n| N (`0x4E`)      | `-.`       | `10'b10`          | 2            |\n| O (`0x4F`)      | `---`      | `10'b111`         | 3            |\n| P (`0x50`)      | `.--.`     | `10'b0110`        | 4            |\n| Q (`0x51`)      | `--.-`     | `10'b1101`        | 4            |\n| R (`0x52`)      | `.-.`      | `10'b010`         | 3            |\n| S (`0x53`)      | `...`      | `10'b000`         | 3            |\n| T (`0x54`)      | `-`        | `10'b1`           | 1            |\n| U (`0x55`)      | `..-`      | `10'b001`         | 3            |\n| V (`0x56`)      | `...-`     | `10'b0001`        | 4            |\n| W (`0x57`)      | `.--`      | `10'b011`         | 3            |\n| X (`0x58`)      | `-..-`     | `10'b1001`        | 4            |\n| Y (`0x59`)      | `-.--`     | `10'b1011`        | 4            |\n| Z (`0x5A`)      | `--..`     | `10'b1100`        | 4            |\n| 0 (`0x30`)      | `-----`    | `10'b11111`       | 5            |\n| 1 (`0x31`)      | `.----`    | `10'b01111`       | 5            |\n| 2 (`0x32`)      | `..---`    | `10'b00111`       | 5            |\n| 3 (`0x33`)      | `...--`    | `10'b00011`       | 5            |\n| 4 (`0x34`)      | `....-`    | `10'b00001`       | 5            |\n| 5 (`0x35`)      | `.....`    | `10'b00000`       | 5            |\n| 6 (`0x36`)      | `-....`    | `10'b10000`       | 5            |\n| 7 (`0x37`)      | `--...`    | `10'b11000`       | 5            |\n| 8 (`0x38`)      | `---..`    | `10'b11100`       | 5            |\n| 9 (`0x39`)      | `----.`    | `10'b11110`       | 5            |\n\n---\nThe `morse_encoder` module maps ASCII characters to their Morse code equivalents, outputting both the binary Morse sequence and its length.", "context": {}}, "output": {"response": "", "context": {"rtl/morse_encoder.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    #image: __OSS_SIM_IMAGE__\n    image: __OSS_SIM_IMAGE__\n\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/morse_encoder.sv\nTOPLEVEL        = morse_encoder\nMODULE          = test_morse_encoder\nPYTHONPATH      = /src\nHASH            = f2c62dd2c9f6bc45875414d2a1927de0f20015cb\n", "src/test_morse_encoder.py": "import cocotb\nfrom cocotb.triggers import Timer\nimport random\n\n# Dictionary of ASCII characters to expected Morse code (binary) and length\nascii_to_morse = {\n    'A': (0b01, 2),       # .-\n    'B': (0b1000, 4),     # -...\n    'C': (0b1010, 4),     # -.-.\n    'D': (0b100, 3),      # -..\n    'E': (0b0, 1),        # .\n    'F': (0b0010, 4),     # ..-.\n    'G': (0b110, 3),      # --.\n    'H': (0b0000, 4),     # ....\n    'I': (0b00, 2),       # ..\n    'J': (0b0111, 4),     # .---\n    'K': (0b101, 3),      # -.-\n    'L': (0b0100, 4),     # .-..\n    'M': (0b11, 2),       # --\n    'N': (0b10, 2),       # -.\n    'O': (0b111, 3),      # ---\n    'P': (0b0110, 4),     # .--.\n    'Q': (0b1101, 4),     # --.-\n    'R': (0b010, 3),      # .-.\n    'S': (0b000, 3),      # ...\n    'T': (0b1, 1),        # -\n    'U': (0b001, 3),      # ..-\n    'V': (0b0001, 4),     # ...-\n    'W': (0b011, 3),      # .--\n    'X': (0b1001, 4),     # -..-\n    'Y': (0b1011, 4),     # -.--\n    'Z': (0b1100, 4),     # --..\n    '0': (0b11111, 5),    # -----\n    '1': (0b01111, 5),    # .----\n    '2': (0b00111, 5),    # ..---\n    '3': (0b00011, 5),    # ...--\n    '4': (0b00001, 5),    # ....-\n    '5': (0b00000, 5),    # .....\n    '6': (0b10000, 5),    # -....\n    '7': (0b11000, 5),    # --...\n    '8': (0b11100, 5),    # ---..\n    '9': (0b11110, 5),    # ----.\n}\n\n@cocotb.test()\nasync def test_random_ascii_inputs(dut):\n    \"\"\"Test the morse_encoder module with random ASCII inputs.\"\"\"\n    num_tests = 256  # Number of random tests to run\n    ascii_range = (65, 90)  # ASCII range for 'A' to 'Z'\n\n    for _ in range(num_tests):\n        random_ascii = random.randint(*ascii_range)  # Generate a random ASCII value within the range\n        ascii_char = chr(random_ascii)  # Convert ASCII value to character\n\n        # Check if the character is in the predefined Morse code dictionary\n        if ascii_char in ascii_to_morse:\n            expected_morse, expected_length = ascii_to_morse[ascii_char]\n            dut.ascii_in.value = random_ascii\n            await Timer(1, units='ns')\n            assert int(dut.morse_out.value) == expected_morse, f\"Test failed for {ascii_char}: Expected Morse {bin(expected_morse)}, got {bin(int(dut.morse_out.value))}\"\n            assert int(dut.morse_length.value) == expected_length, f\"Test failed for {ascii_char}: Expected length {expected_length}, got {int(dut.morse_length.value)}\"\n        else:\n            print(f\"Skipping {ascii_char}, not in Morse code dictionary.\")\n\n@cocotb.test()\nasync def test_specific_chars(dut):\n    \"\"\"Test specific characters as originally planned.\"\"\"\n    for ascii_char, (expected_morse, expected_length) in ascii_to_morse.items():\n        dut.ascii_in.value = ord(ascii_char)\n        await Timer(1, units='ns')\n        assert int(dut.morse_out.value) == expected_morse, f\"Test failed for {ascii_char}: Expected Morse {bin(expected_morse)}, got {bin(int(dut.morse_out.value))}\"\n        assert int(dut.morse_length.value) == expected_length, f\"Test failed for {ascii_char}: Expected length {expected_length}, got {int(dut.morse_length.value)}\"\n\n@cocotb.test()\nasync def test_random_numeric_inputs(dut):\n    \"\"\"Test the morse_encoder module with random numeric inputs.\"\"\"\n    num_tests = 256  # Number of random tests to run\n    numeric_range = (48, 57)  # ASCII range for '0' to '9'\n\n    for _ in range(num_tests):\n        random_ascii = random.randint(*numeric_range)  # Generate a random ASCII value within the numeric range\n        ascii_char = chr(random_ascii)  # Convert ASCII value to character\n\n        expected_morse, expected_length = ascii_to_morse[ascii_char]\n        dut.ascii_in.value = random_ascii\n        await Timer(1, units='ns')\n        morse_out = int(dut.morse_out.value)\n        morse_length = int(dut.morse_length.value)\n\n        assert morse_out == expected_morse and morse_length == expected_length, \\\n            f\"Test failed for numeric {ascii_char}: Expected Morse {bin(expected_morse)}, got {bin(morse_out)}; Expected length {expected_length}, got {morse_length}\"\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport re\nimport logging\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_moving_average_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design a Verilog module that computes the **moving average** of an incoming **12-bit data stream**. The module should output the integer average of the last 8 input unsigned value samples. It continuously receives 12-bit input samples, stores them in a memory buffer, and outputs the average of the most recent 8 samples, updated on every clock cycle.\n\n## Interface of the Module `moving_average`\n\n### Inputs:\n- **clk**: Clock signal.All operations are synchronized with the rising edge of the clock.\n- **reset**: Synchronous reset, active high.\n- **[11 : 0] data_in**: 12-bit input data.\n\n### Output:\n- **[11 : 0]  data_out**: 12-bit output representing the moving average of the last 8 input samples.\n\n## Specifications:\n1. **Sum Calculation**:\n   - The internal sum register must have a sufficient bit-width to handle the full range of summed values. \n\n2. **Reset Behavior**:\n   - When `reset` is asserted (active high), the output clears to zero. The memory buffer should also be cleared at reset and after reset is de-asserted, the moving average calculation should start fresh.\n \n3. **Edge Conditions**:\n\n   - After the reset is de-asserted, if the number of input samples is less than 8 the output is the sum of the available samples divided by 8.\n  \n## Assumptions:\n- Assume that the input data is unsigned and bounded within 12 bits\n- Assume that valid input data is available to the module when reset is de-asserted and that the design receives a continuous stream of inputs synchronous with the positive edge of the clock.", "context": {}}, "output": {"response": "", "context": {"rtl/moving_average.v": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n\n", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/moving_average.v\nTOPLEVEL        = moving_average\nMODULE          = test_moving_average\nPYTHONPATH      = /src\nHASH            = 799b0b473910c7a1417c1faf587f7acc989b80a0", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset, duration_ns = 10):\n    # Restart Interface\n    reset.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    reset.value = 0\n    await Timer(duration_ns, units='ns')\n    reset._log.debug(\"Reset complete\")\n\nasync def enable_dut(enable, duration_ns = 10):\n    # Restart Interface\n    enable.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    enable.value = 1\n    await Timer(duration_ns, units='ns')\n    enable._log.debug(\"enable complete\")\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def calculate_moving_average(data_queue, current_sum, new_data, window):\n    if len(data_queue) < window:\n        data_queue.append(new_data)\n        current_sum += new_data\n    else:\n        oldest_data = data_queue.pop(0)\n        current_sum += new_data - oldest_data\n        data_queue.append(new_data)\n\n    expected_avg = current_sum // window\n    \n    return expected_avg, current_sum\n\n", "src/test_moving_average.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport time\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_moving_average(dut):\n    \"\"\"Test the functionality of the moving average module.\"\"\"\n    \n    # Start the clock with a 2ns period\n    cocotb.start_soon(Clock(dut.clk, 2, units='ns').start())\n\n    # Define parameters for the data width and the window size\n    width = 12   # Data width is 12 bits\n    window = 8   # The moving average window size is 8\n\n    # Log the test parameters\n    print(f\"[INFO] WIDTH = {width}, WINDOW_SIZE = {window}\")\n    \n    # Initialize the DUT (Design Under Test)\n    await hrs_lb.dut_init(dut)\n\n    # Apply reset \n    await hrs_lb.reset_dut(dut.reset)\n    \n    # Wait for a couple of cycles to stabilize\n    for i in range(2):\n        await RisingEdge(dut.clk)\n    \n    # Ensure all outputs are zero\n    assert dut.data_out.value == 0, f\"[ERROR] data_out is not zero after reset: {dut.data_out.value}\"\n\n    # Initialize variables for tracking the sum of the moving average and input data queue\n    current_sum = 0\n    data_queue = []\n    previous_expected_avg = None  # Variable to hold the previous cycle's expected average\n\n    # Randomize the total number of test cycles (between 20 to 50)\n    cycle_num = random.randint(20, 50)\n    # Determine the cycle at which a reset will be applied (halfway through the total test)\n    reset_cycle = cycle_num // 2\n    print(f\"[INFO] Total cycles = {cycle_num}, Reset will be applied at cycle {reset_cycle}\")\n    \n    # Loop through the cycles and apply random input data to the DUT\n    for cycle in range(cycle_num):\n        # Generate a random input value (based on the defined data width)\n        data_in = random.randint(0, 2**width-1)\n        dut.data_in.value = data_in  # Apply the input value to the DUT\n        await RisingEdge(dut.clk)\n\n        # Apply reset halfway through the test\n        if cycle == reset_cycle:\n            print(f\"[INFO] Applying reset at cycle {cycle}\")\n            # Apply reset to the DUT and reset output\n            #await RisingEdge(dut.clk)\n            dut.reset.value = 1\n            await RisingEdge(dut.clk)\n            await RisingEdge(dut.clk)\n            assert dut.data_out.value == 0, f\"[ERROR] data_out is not zero after reset: {dut.data_out.value}\"\n            # Reset the sum and the data queue\n            current_sum = 0\n            data_queue = []\n            previous_expected_avg = None  # Clear previous average\n            \n            # Wait for 2 cycles after reset to allow stabilization\n            for i in range(2):\n                await RisingEdge(dut.clk)\n            dut.reset.value = 0  # Release reset\n            print(\"[INFO] Starting fresh operation after reset\")\n\n            # Continue applying random inputs and checking output after reset\n            for post_cycle in range(cycle_num - reset_cycle):\n                # Generate new random input after reset\n                data_in = random.randint(0, 2**width-1)\n                dut.data_in.value = data_in\n                await RisingEdge(dut.clk)\n\n                # Calculate the expected moving average using a helper function\n                expected_avg, current_sum = await hrs_lb.calculate_moving_average(\n                    data_queue, current_sum, data_in, window\n                )\n                \n                # Read the DUT output and compare it with the expected average\n                actual_avg = dut.data_out.value.to_unsigned()\n                if previous_expected_avg is not None:\n                    assert actual_avg == previous_expected_avg, \\\n                        f\"[ERROR] Mismatch at post-reset cycle {post_cycle}: Expected {previous_expected_avg}, got {actual_avg}\"\n                    \n                    # Log debugging information for each cycle\n                    dut._log.info(f\"[DEBUG] Post-reset Cycle {post_cycle}/{cycle_num - reset_cycle}: DUT average = {actual_avg}\")\n                    dut._log.info(f\"[DEBUG] Post-reset Cycle {post_cycle}/{cycle_num - reset_cycle}: Testbench average = {previous_expected_avg}\")\n\n                # Update the previous expected average for the next comparison\n                previous_expected_avg = expected_avg\n\n            # Exit after completing post-reset cycles\n            break\n\n        # Calculate the expected moving average for the current cycle\n        expected_avg, current_sum = await hrs_lb.calculate_moving_average(\n            data_queue, current_sum, data_in, window\n        )\n        \n        # Read the DUT output and compare it with the expected average\n        actual_avg = dut.data_out.value.to_unsigned()\n        if previous_expected_avg is not None:\n            assert actual_avg == previous_expected_avg, \\\n                f\"[ERROR] Mismatch at cycle {cycle}: Expected {previous_expected_avg}, got {actual_avg}\"\n            \n            # Log debugging information for each cycle\n            dut._log.info(f\"[DEBUG] Cycle {cycle}/{cycle_num}: DUT average = {actual_avg}\")\n            dut._log.info(f\"[DEBUG] Cycle {cycle}/{cycle_num}: Testbench average = {previous_expected_avg}\")\n\n        # Update the previous expected average\n        previous_expected_avg = expected_avg\n\n    # Wait for a few stabilization cycles before ending the test\n    for i in range(2):\n        await RisingEdge(dut.clk)\n    \n    # Test completed successfully\n    print(\"[INFO] Test 'test_moving_average' completed successfully.\")\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n# random test\n@pytest.mark.parametrize(\"test\", range(5))\ndef test_moving_rndm(test):\n    runner()\n"}}}
{"id": "cvdp_copilot_nbit_swizzling_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design a System Verilog module `nbit_swizzling` that performs selective bit-reversal with `sel` input signal. The module should take a `DATA_WIDTH`-bit wide input and reverse the bits in the following configurations based on a 2-bit selection signal `sel`.\n\n\n##### Interface of Module `nbit_swizzling`\n\n#### Parameter\n- The default value of `DATA_WIDTH` is 64.\n#### Inputs\n- `data_in([DATA_WIDTH-1:0])`: Input data of size `DATA_WIDTH`\n- `sel([1:0])`: 2-bit selection signal \n\n#### Outputs\n- `data_out([DATA_WIDTH-1:0])`: Output data of size `DATA_WIDTH` \n\n#### Specification\n#### 1. Operation\n- When `sel` = 0, reverse the entire input.\n- When `sel` = 1, divide `data_in` into two equal sizes of bit arrays and reverse each half separately.\n- When `sel` = 2, divide `data_in` into four equal sizes of bit arrays and reverse each section individually.\n- When `sel` = 3, divide `data_in` into eight equal sizes of bit arrays and reverse each section individually.\n- In the default case, the output should match the input.\n#### 2. Constraints\n- The `DATA_WIDTH` must be greater than or equal to 16 and multiples of 8.\n- Assume that `data_in` will always handle of 1s and 0s. Therefore, there is no need to handle invalid input cases explicitly.\n- The design must follow combinational logic\n\n#### Example\n\n`DATA_WIDTH`: 16\n\n```wavedrom\n \n{\"signal\": [\n  { \"name\": \"data_in[DATA_WIDTH-1:0]\", \"wave\": \"x.=.=.=.=.=.=.=.=.x\", \"data\": [\"2a5c\",\"2cbe\",\"2df9\",\"32cb\",\"34d0\",\"47f6\",\"410a\",\"2859\"] },\n  { \"name\": \"sel[1:0]\", \"wave\": \"x.=.=.=.=.=.=.=.=.x\", \"data\": [\"0\",\"0\",\"1\",\"1\",\"2\",\"2\",\"3\",\"3\"] },\n  { \"name\": \"data_out[DATA_WIDTH-1:0]\", \"wave\": \"x.=.=.=.=.=.=.=.=.x\", \"data\": [\"3a54\",\"7d34\",\"b49f\",\"4cd3\",\"c2b0\",\"2ef6\",\"8205\",\"14a6\"] },\n{ \"name\": \"DATA_WIDTH\", \"wave\": \"x.=...............x\", \"data\": [\"16\"] }\n],\n\"head\": {\n\"text\": \"Module:: nbit_swizzling, data_in and data_out represented in hex format\"\n}\n}\n\n```", "context": {}}, "output": {"response": "", "context": {"rtl/nbit_swizzling.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v ", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/nbit_swizzling.sv\nTOPLEVEL        = nbit_swizzling\nMODULE          = test_nbit_swizzling\nPYTHONPATH      = /src\nHASH            = b2277a516fd3ebafe3343f7d718e600b7c9ca59e", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n\nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_nbit_swizzling.py": "\nimport cocotb\nfrom cocotb.triggers import Timer\nimport random\n\n# Function to generate random data based on DATA_WIDTH\n\n# Testbench function to test different scenarios\n@cocotb.test()\nasync def test_nbit_sizling(dut):\n    \"\"\" Test the nbit_sizling module \"\"\"\n    data_wd = int(dut.DATA_WIDTH.value)\n    for i in range(20):\n        # Generate random input data and selection signal\n        data_in = random.randint(0,(2**data_wd)-1)\n        sel = random.randint(0,3)  # sel is 2-bit wide, so choose between 0 to 3\n        print(f\"DATA_WIDTH ={data_wd}\")\n        # Apply inputs to the DUT\n        dut.data_in.value = data_in\n        dut.sel.value = sel\n        \n        await Timer(10, units='ns')\n\n        \n        # Run the actual result calculation in Python for comparison\n        expected_data_out = reverse_data(data_in, sel, data_wd)\n        print(f\"Checking operation for sel={sel}:: data_in = {int(dut.data_in.value)},data_in = {(dut.data_in.value)},, expected_data_out = {expected_data_out}, data_out = {int(dut.data_out.value)}\")\n        print(f\"Checking operation in binary for sel={sel}:: data_in_bin = {dut.data_in.value}, expected_data_out = {bin(expected_data_out)}, data_out = {dut.data_out.value}\")\n       \n        # Compare the DUT's output with expected value\n        assert dut.data_out.value == expected_data_out, f\"Test failed with data_in={data_in}, sel={sel}, expected={expected_data_out}, but got={dut.data_out.value}\"\n\n# Helper function to perform the data reversal based on sel\ndef reverse_data(data_in, sel, data_wd):\n    data_in_bits = f'{data_in:0{data_wd}b}'  # Convert input to binary string of size DATA_WIDTH\n    if sel == 0:\n        # Reverse entire data\n        return int(data_in_bits[::-1], 2)\n    elif sel == 1:\n        # Reverse two halves\n        half_width = data_wd // 2\n        first_half = data_in_bits[:half_width][::-1]\n        second_half = data_in_bits[half_width:][::-1]\n        return int(first_half + second_half, 2)\n    elif sel == 2:\n        # Reverse four sets\n        quarter_width = data_wd // 4\n        first_set = data_in_bits[:quarter_width][::-1]\n        second_set = data_in_bits[quarter_width:2*quarter_width][::-1]\n        third_set = data_in_bits[2*quarter_width:3*quarter_width][::-1]\n        fourth_set = data_in_bits[3*quarter_width:][::-1]\n        return int(first_set + second_set + third_set + fourth_set, 2)\n    elif sel == 3:\n        # Reverse eight sets\n        eighth_width = data_wd // 8\n        sets = [data_in_bits[i*eighth_width:(i+1)*eighth_width][::-1] for i in range(8)]\n        return int(''.join(sets), 2)\n    else:\n        return data_in  # Default, just return the input data as-is\n\n\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(DATA_WIDTH: int=0):\n    parameter = {\"DATA_WIDTH\":DATA_WIDTH}\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n\n@pytest.mark.parametrize(\"DATA_WIDTH\", [16,32,40,48,64])\ndef test_nbit_sizling(DATA_WIDTH):\n        runner(DATA_WIDTH = DATA_WIDTH)"}}}
{"id": "cvdp_copilot_packet_controller_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design a packet controller module in `verilog` to handle data reception and transmission. The design must implement a finite state machine (FSM) to process received packets, validate their integrity, compute appropriate responses, and manage transmission. The module should emphasize precise functionality and align with the following specifications.\n\n---\n\n### **Specifications**\n- **Module Name**: `packet_controller`\n\n#### **1. Input/Output Interface**\n- **Inputs**:\n  - `clk`: System clock signal (active on the rising edge).\n  - `rst`: Active-high asynchronous reset.\n  - `rx_valid_i`: Indicates valid incoming data (strobe signal).\n  - `rx_data_8_i [7:0]`: 8-bit data received from the RX interface.\n  - `tx_done_tick_i`: Indicates the successful transmission of a byte.\n- **Outputs**:\n  - `tx_start_o`: High during transmission; low otherwise.\n  - `tx_data_8_o [7:0]`: 8-bit data to transmit.\n\n---\n\n#### **2. FSM Behavior**\n- **States**:\n  - `S_IDLE`: Waits for 8 bytes of data to accumulate in the buffer.\n  - `S_GOT_8_BYTES`: Checks the header and computes the checksum.\n  - `S_RECV_CHECKSUM`: Validates the checksum. If valid, transitions to response building; otherwise, resets to `S_IDLE`.\n  - `S_BUILD_RESPONSE`: Prepares the outgoing response packet.\n  - `S_SEND_FIRST_BYTE`: Initiates the response transmission by sending the first byte.\n  - `S_RESPONSE_READY`: Handles the remaining response transmission.\n  - **Error Handling**: Returns to `S_IDLE` on invalid checksum or unexpected header.\n\n---\n\n#### **3. Functional Details**\n- **Packet Format**:\n  - **Header**: The first 16 bits of the packet must match `16'hBACD` for valid packets.\n  - **Payload**: Two 16-bit integers (`num1`, `num2`), an 8-bit opcode, and an 8-bit checksum.\n  - **Checksum**: The sum of all bytes (modulo 256) must equal zero for valid packets.\n\n- **Outgoing Response**:\n  - Header: Fixed as `16'hABCD`.\n  - Payload: The computed result of `num1` and `num2` based on the opcode:\n    - `opcode = 8'h00`: Addition (`num1 + num2`).\n    - `opcode = 8'h01`: Subtraction (`num1 - num2`).\n    - Other opcodes result in `0`.\n  - Checksum: Calculated to ensure the outgoing packet meets checksum validation.\n\n---\n\n#### **4. Error Handling**\n- Invalid packets (e.g., checksum mismatch, unexpected header) reset the FSM to `S_IDLE`. \n\n---\n\n#### **5. Edge Case Scenarios**\n1. **Invalid Headers**:\n   - Headers other than `16'hBACD` are treated as invalid, causing the FSM to reset to `S_IDLE`.\n2. **Checksum Failures**:\n   - Packets with incorrect checksum are discarded, resetting the FSM to `S_IDLE`.\n3. **Arithmetic Operations**:\n   - Handles addition and subtraction but does not explicitly address signed arithmetic or overflow/underflow scenarios.\n4. **Rapid Consecutive Packets**:\n   - Designed to handle valid packets one at a time without specific provisions for back-to-back packet handling.\n\n---\n\n#### **6. Timing Constraints**\n- **FSM Synchronization**:\n  - State transitions and output updates are synchronized with the system clock.\n- **Transmission Latency**:\n  - Transmission continues until all 5 bytes of the response are sent, synchronized to `tx_done_tick_i`.\n\n---\n\n### **RTL Implementation Requirements**\n1. **FSM Design**:\n   - Implement states (`S_IDLE`, `S_GOT_8_BYTES`, etc.) with appropriate transitions.\n2. **Checksum Logic**:\n   - Validate incoming packets and generate outgoing packet checksums.\n3. **Arithmetic Operations**:\n   - Implement addition and subtraction for `num1` and `num2` based on `opcode`.\n4. **Error Handling**:\n   - Reset FSM to `S_IDLE` for invalid headers or checksum mismatches.\n5. **Timing and Synchronization**:\n   - Ensure all state transitions and signal updates occur on the rising edge of `clk`.\n\n---", "context": {}}, "output": {"response": "", "context": {"rtl/packet_controller.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/packet_controller.sv\nTOPLEVEL        = packet_controller\nMODULE          = test_packet_controller\nPYTHONPATH      = /src\nHASH            = 1-serial-data-packet-controller\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_packet_controller.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n##################################################################\n#  Common Tasks / Utilities\n##################################################################\n\nasync def init_clock(dut):\n    \"\"\"Initialize a 10ns clock on dut.clk.\"\"\"\n    clock = Clock(dut.clk, 10, units='ns')\n    cocotb.start_soon(clock.start())\n\nasync def reset_dut(dut):\n    \"\"\"Apply reset for ~50 ns total.\"\"\"\n    dut.rst.value = 1\n    # Wait ~30 ns\n    await Timer(30, units='ns')\n    dut.rst.value = 0\n    # Additional ~20 ns settle\n    await Timer(20, units='ns')\n\nasync def wait_cycles(dut, n):\n    \"\"\"Wait for n rising edges.\"\"\"\n    for _ in range(n):\n        await RisingEdge(dut.clk)\n\nasync def send_byte(dut, data):\n    \"\"\"Send one byte to the DUT: rx_data_8_i=data for exactly 1 clock.\"\"\"\n    await RisingEdge(dut.clk)\n    dut.rx_data_8_i.value = data\n    dut.rx_valid_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.rx_valid_i.value = 0\n\nasync def do_tx_done(dut):\n    \"\"\"Pulse tx_done_tick_i for one clock cycle.\"\"\"\n    await RisingEdge(dut.clk)\n    dut.tx_done_tick_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.tx_done_tick_i.value = 0\n\nasync def drive_valid_packet(dut, header, num1, num2, opcode):\n    \"\"\"\n    Drive 8 bytes:\n      header[15:8], header[7:0], num1[15:8], num1[7:0],\n      num2[15:8], num2[7:0], opcode, final_cksum\n    ensuring sum mod 256 == 0.\n    Then wait 10 cycles for the DUT to parse.\n    \"\"\"\n    sum_local = ((header >> 8) & 0xFF) + (header & 0xFF) \\\n              + ((num1 >> 8) & 0xFF) + (num1 & 0xFF) \\\n              + ((num2 >> 8) & 0xFF) + (num2 & 0xFF) \\\n              + (opcode & 0xFF)\n    sum_local = sum_local % 256\n    final_cksum = (0 - sum_local) & 0xFF\n\n    await send_byte(dut, (header >> 8) & 0xFF)\n    await send_byte(dut, header & 0xFF)\n    await send_byte(dut, (num1 >> 8) & 0xFF)\n    await send_byte(dut, num1 & 0xFF)\n    await send_byte(dut, (num2 >> 8) & 0xFF)\n    await send_byte(dut, num2 & 0xFF)\n    await send_byte(dut, opcode)\n    await send_byte(dut, final_cksum)\n\n    await wait_cycles(dut, 10)\n\nasync def check_5byte_response(dut, expected_result):\n    \"\"\"\n    Expect 5 bytes: 0xAB, 0xCD, result_hi, result_lo, xmit_cksum.\n    For each byte i2 in 0..4:\n      1) Wait up to 50 cycles for tx_start_o=1.\n      2) Wait 1 cycle => capture tx_data_8_o.\n      3) Pulse do_tx_done(dut).\n      4) Wait 1 extra cycle to allow re-assert of tx_start_o for next byte.\n    \"\"\"\n    rxed = []\n    for i2 in range(5):\n        # Step 1) Wait up to 50 cycles for tx_start_o=1\n        waitcount = 0\n        while (dut.tx_start_o.value == 0) and (waitcount < 50):\n            await RisingEdge(dut.clk)\n            waitcount += 1\n        if dut.tx_start_o.value == 0:\n            print(f\"ERROR: Timed out waiting for tx_start_o on byte {i2}\")\n            assert False, f\"Tx_start_o not asserted for byte {i2}\"\n\n        # Step 2) Wait 1 cycle => read data\n        await RisingEdge(dut.clk)\n        rxed_byte = int(dut.tx_data_8_o.value)\n        rxed.append(rxed_byte)\n\n        # Step 3) do_tx_done => design sees we finished\n        await do_tx_done(dut)\n\n        # Step 4) Wait 1 cycle => let design re-assert tx_start_o if needed\n        await RisingEdge(dut.clk)\n\n    # Check the 5 bytes\n    if rxed[0] != 0xAB:\n        print(f\"ERROR: Expected 0xAB, got 0x{rxed[0]:02X}\")\n        assert False\n    if rxed[1] != 0xCD:\n        print(f\"ERROR: Expected 0xCD, got 0x{rxed[1]:02X}\")\n        assert False\n\n    if rxed[2] != ((expected_result >> 8) & 0xFF):\n        print(f\"ERROR: result_hi mismatch. Exp=0x{(expected_result>>8)&0xFF:02X}, got=0x{rxed[2]:02X}\")\n        assert False\n\n    if rxed[3] != (expected_result & 0xFF):\n        print(f\"ERROR: result_lo mismatch. Exp=0x{expected_result & 0xFF:02X}, got=0x{rxed[3]:02X}\")\n        assert False\n\n    partial_sum = (rxed[0] + rxed[1] + rxed[2] + rxed[3]) & 0xFF\n    exp_cksum = (0 - partial_sum) & 0xFF\n    if rxed[4] != exp_cksum:\n        print(f\"ERROR: xmit_checksum mismatch. Exp=0x{exp_cksum:02X}, got=0x{rxed[4]:02X}\")\n        assert False\n\nasync def check_no_response(dut):\n    \"\"\"Check if we see any tx_start_o for 20 cycles => if yes => error.\"\"\"\n    saw_tx = False\n    for _ in range(20):\n        await RisingEdge(dut.clk)\n        if dut.tx_start_o.value:\n            saw_tx = True\n    if saw_tx:\n        print(\"ERROR: DUT responded despite invalid packet!\")\n        assert False\n\nasync def random_valid_packets(dut, count):\n    \"\"\"Send 'count' random packets => 0xBACD => random num1/num2 => add/sub => check result.\"\"\"\n    for k in range(count):\n        rnd_num1 = random.getrandbits(16)\n        rnd_num2 = random.getrandbits(16)\n        rnd_opcode = 0x00 if (random.randint(0,1) == 0) else 0x01\n        print(f\"Random Packet #{k}: opcode=0x{rnd_opcode:X}, num1={rnd_num1}, num2={rnd_num2}\")\n\n        await drive_valid_packet(dut, 0xBACD, rnd_num1, rnd_num2, rnd_opcode)\n        if rnd_opcode == 0x00:  # add\n            expected = (rnd_num1 + rnd_num2) & 0xFFFF\n        else:                   # sub\n            expected = (rnd_num1 - rnd_num2) & 0xFFFF\n\n        await check_5byte_response(dut, expected)\n\n\n##################################################################\n#  Individual Tests\n##################################################################\n\n@cocotb.test()\nasync def test_add(dut):\n    \"\"\"Test #1: ADD => 16 + 32 = 48 => 0x0030\"\"\"\n    await init_clock(dut)\n    await reset_dut(dut)\n    print(\"Test #1: ADD => 16 + 32 = 48\")\n    await drive_valid_packet(dut, 0xBACD, 16, 32, 0x00)\n    await check_5byte_response(dut, 0x0030)\n    print(\"Test #1 passed.\\n\")\n\n@cocotb.test()\nasync def test_sub(dut):\n    \"\"\"Test #2: SUB => 100 - 75 = 25 => 0x0019\"\"\"\n    await init_clock(dut)\n    await reset_dut(dut)\n    print(\"Test #2: SUB => 100 - 75 = 25\")\n    await drive_valid_packet(dut, 0xBACD, 100, 75, 0x01)\n    await check_5byte_response(dut, 0x0019)\n    print(\"Test #2 passed.\\n\")\n\n@cocotb.test()\nasync def test_unknown_opcode(dut):\n    \"\"\"Test #3: unknown opcode => 0 result.\"\"\"\n    await init_clock(dut)\n    await reset_dut(dut)\n    print(\"Test #3: unknown opcode => result=0\")\n    await drive_valid_packet(dut, 0xBACD, 10, 20, 0xAB)\n    await check_5byte_response(dut, 0x0000)\n    print(\"Test #3 passed.\\n\")\n\n@cocotb.test()\nasync def test_invalid_checksum(dut):\n    \"\"\"Test #4: invalid checksum => no response.\"\"\"\n    await init_clock(dut)\n    await reset_dut(dut)\n    print(\"Test #4: invalid checksum => no response expected\")\n\n    # BA CD 00 10 00 20 00 FF => wait => check no response\n    await send_byte(dut, 0xBA)\n    await send_byte(dut, 0xCD)\n    await send_byte(dut, 0x00)\n    await send_byte(dut, 0x10)\n    await send_byte(dut, 0x00)\n    await send_byte(dut, 0x20)\n    await send_byte(dut, 0x00)\n    await send_byte(dut, 0xFF)\n    await wait_cycles(dut, 10)\n\n    await check_no_response(dut)\n    print(\"Test #4 passed.\\n\")\n\n@cocotb.test()\nasync def test_add_zero(dut):\n    \"\"\"Test #5: ADD => 0 + 0 => 0 result.\"\"\"\n    await init_clock(dut)\n    await reset_dut(dut)\n    print(\"Test #5: ADD => 0 + 0 = 0\")\n    await drive_valid_packet(dut, 0xBACD, 0, 0, 0x00)\n    await check_5byte_response(dut, 0x0000)\n    print(\"Test #5 passed.\\n\")\n\n@cocotb.test()\nasync def test_sub_negative(dut):\n    \"\"\"Test #6: SUB => 50 - 100 => -50 => 0xFFCE (2's complement).\"\"\"\n    await init_clock(dut)\n    await reset_dut(dut)\n    print(\"Test #6: SUB => 50 - 100 => 0xFFCE (assuming wrap).\")\n    await drive_valid_packet(dut, 0xBACD, 50, 100, 0x01)\n    await check_5byte_response(dut, 0xFFCE)\n    print(\"Test #6 passed.\\n\")\n\n@cocotb.test()\nasync def test_add_large(dut):\n    \"\"\"Test #7: ADD => 0x8000 + 0x7FFF => 0xFFFF.\"\"\"\n    await init_clock(dut)\n    await reset_dut(dut)\n    print(\"Test #7: ADD => 0x8000 + 0x7FFF => 0xFFFF\")\n    await drive_valid_packet(dut, 0xBACD, 0x8000, 0x7FFF, 0x00)\n    await check_5byte_response(dut, 0xFFFF)\n    print(\"Test #7 passed.\\n\")\n\n@cocotb.test()\nasync def test_back_to_back(dut):\n    \"\"\"Test #8: Two back-to-back packets => minimal idle time.\"\"\"\n    await init_clock(dut)\n    await reset_dut(dut)\n    print(\"Test #8: Two back-to-back => ADD(5+7=12), SUB(20-15=5)\")\n\n    # 1) 5+7=12 => 0x000C\n    await drive_valid_packet(dut, 0xBACD, 5, 7, 0x00)\n    await check_5byte_response(dut, 0x000C)\n\n    # 2) 20-15=5 => 0x0005\n    await drive_valid_packet(dut, 0xBACD, 20, 15, 0x01)\n    await check_5byte_response(dut, 0x0005)\n    print(\"Test #8 passed.\\n\")\n\n@cocotb.test()\nasync def test_random_pkts(dut):\n    \"\"\"Test #9: Random valid packets => 3 times.\"\"\"\n    await init_clock(dut)\n    await reset_dut(dut)\n    print(\"Test #9: Random Packets => 3 times\")\n    await random_valid_packets(dut, 3)\n    print(\"Test #9 passed.\\n\")\n\n@cocotb.test()\nasync def test_invalid_header(dut):\n    \"\"\"Test #10: Additional invalid header => no response.\"\"\"\n    await init_clock(dut)\n    await reset_dut(dut)\n    print(\"Test #10: Invalid header => no response\")\n\n    # 0xDE, 0xAD, plus 6 more zeros\n    await send_byte(dut, 0xDE)\n    await send_byte(dut, 0xAD)\n    for _ in range(6):\n        await send_byte(dut, 0x00)\n    await wait_cycles(dut, 5)\n\n    await check_no_response(dut)\n    print(\"Test #10 passed.\\n\")\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom cocotb.runner import get_runner\nimport pytest\nimport pickle\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\n@pytest.mark.tb\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\n#if __name__ == \"__main__\":\n#    test_runner()"}}}
{"id": "cvdp_copilot_palindrome_3b_0002", "categories": ["cid003", "easy"], "input": {"prompt": "Design a circuit in SystemVerilog which takes an input stream 'bit_stream' at every clock cycle and assert an output  'palindrome_detetcted' when there is found palindrome in incoming stream. The length of the palindrome should be 3. Your design should be fully synthesizable.\n## Port list:\n### Parameter:\n- N: Determines the width of the Palindrome. For this particular circuit as we are detecting 3bit palindrome so its value should be 3\n\n### Inputs:\n- clk: Clock signal used to synchronize all operations with the rising edge of the clock.\n- reset: Synchronous reset, active High.\n- bit_stream: A single bit input signal which provided a randomized bit stream at every clock cycle.\n\n### Output:\n- palindrome_detected: An output signals which indicates whether the Palindrome is detected in incoming bit stream or not.\n\n## Module Definition:\n```verilog\nmodule palindrome_detect #( \nparameter N=3\n) (\ninput clk,\ninput reset,\ninput bit_stream,\noutput palindrome_detected\n);\n//Your Code\nendmodule\n```", "context": {}}, "output": {"response": "", "context": {"rtl/palindrome_detect.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/palindrome_detect.sv\nTOPLEVEL        = palindrome_detect\nMODULE          = test_palindrome_detect\nPYTHONPATH      = /src\nHASH            = rtl-design-for-palindrome\n", "src/test_palindrome_detect.py": "# Simple tests for an counter module\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nfrom cocotb.triggers import FallingEdge\nimport random\nfrom collections import deque\nfrom cocotb.triggers import Timer\n\nimport threading\nimport urllib.request\n\n@cocotb.test()\nasync def test_palindrome_detect(dut):\n    NUM_TEST = 100\n    # generate a clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    dut.bit_stream.value = 0\n\n    # Reset DUT\n    dut.reset.value = 1\n\n    # reset the module, wait 2 rising edges until we release reset\n    for _ in range(5):\n        await RisingEdge(dut.clk)\n    dut.reset.value = 0\n    \n    bit_stream_list = deque(3*[0], 3)\n    for n in range(NUM_TEST):\n        bit = random.randint(0, 1)\n        dut.bit_stream.value = bit\n        print(\"generated bit: \"+str(bit))\n        if (n>=4):\n            print(\"palindrome\",dut.palindrome_detected.value)\n            await FallingEdge(dut.clk)\n            assert dut.palindrome_detected.value == expected_palind(bit_stream_list), \"palindrome result is incorrect: %s != %s\" % (str(dut.palindrome_detected.value), expected_palind(bit_stream_list))\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        bit_stream_list.append(bit)\n        bit_stream_list.append(bit)\n        print(\"bit stream as input: \",bit_stream_list)\n    \ndef expected_palind (expected_out):\n    if (expected_out[0]==expected_out[2]):\n        expected_palindrome = 1\n    else:\n        expected_palindrome = 0\n    return expected_palindrome\n", "src/test_runner.py": "import os\r\n# from cocotb.runner import get_runner\r\nfrom cocotb_tools.runner import get_runner\r\nimport pytest\r\nimport pickle\r\n\r\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\r\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\r\nsim             = os.getenv(\"SIM\", \"icarus\")\r\ntoplevel        = os.getenv(\"TOPLEVEL\")\r\nmodule          = os.getenv(\"MODULE\")\r\n\r\n@pytest.mark.tb\r\ndef test_palindrome_detect():\r\n    # os.rmdir(\"sim_build\")\r\n    # os.remove(\"./sim_build/sim.vvp\")\r\n    runner = get_runner(sim)\r\n    runner.build(\r\n        sources=verilog_sources,\r\n        hdl_toplevel=toplevel,\r\n        # Arguments\r\n        always=True,\r\n        clean=True,\r\n        waves=True,\r\n        verbose=True,\r\n        timescale=(\"1ns\", \"1ns\"),\r\n        log_file=\"sim.log\")\r\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)"}}}
{"id": "cvdp_copilot_perceptron_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design a SystemVerilog RTL module `perceptron_gates` that implements a microcoded controller to train a perceptron model. The module takes signed 4-bit inputs (x1 and x2), a 4-bit threshold, a 1-bit learning rate, and a 2-bit gate selector to determine the target output based on logical gate operations. It uses a microcode ROM to sequentially execute actions like weight initialization, output computation, target selection, weight/bias updates, and convergence checks. The module outputs the updated weights, bias, perceptron response (y), and a stop signal when training converges.\n\n## Design Specification:\nThe `perceptron_gates` module handles weight initialization, computation of perceptron outputs, target selection based on input indexes, and weight and bias updates. It features a microcoded approach for defining operational states, ensuring flexibility and reusability for perceptron-based learning tasks.\n\n## Interface\n## Inputs\n- `clk` (1-bit): Positive edge-triggered clock signal for calculating the microcode ROM address.\n- `rst_n` (1-bit): Negative edge-triggered reset signal. When ACTIVE LOW, `present_addr` is initialized to `4'd0`.\n- `x1`, `x2` (4-bit,[3:0], signed): Perceptron inputs. Can take only Bipolar values [`4'd1`,`-4'd1`]\n- `learning_rate` (1-bit): Learning rate for weight and bias updates.\n- `threshold` (4-bit,[3:0], signed): Threshold value for response calculation.\n- `gate_select` (2-bit,[1:0]): Specifies the gate type for determining target outputs.\n\n## Outputs\n- `percep_w1`, `percep_w2` (4-bit, [3:0], signed): Current weights of the perception. Can take Bipolar Values [`4'd1`,`-4'd1`]\n- `percep_bias` (4-bit,[3:0], signed): Current bias of the perception.Can take Bipolar Values [`4'd1`,`-4'd1`]\n- `present_addr` (4-bit,[3:0]): Current microcode ROM address.\n- `stop` (1-bit): Indicates the end of training.\n- `input_index` (3-bit,[2:0]): Tracks the current target value selected during an iteration. Can take values from 3'd0 to 3'd3.\n- `y_in` (4-bit,[3:0] signed): Computed perception output. Can take Bipolar values [`4'd1`,`-4'd1`]\n- `y` (4-bit, [3:0], signed): Perceptron output after applying the threshold.Can take three different values [`4'd1`,`4'd0`,`-4'd1`]\n- `prev_percep_wt_1`, `prev_percep_wt_2`, `prev_percep_bias` (4-bit, [3:0], signed): Weights and Bias during a previous iteration. Can take Bipolar values [`4'd1`, `-4'd1`]\n\n## Submodule Overview\n### 1. Gate Target (`gate_target`)\nGenerates target outputs (`t1`, `t2`, `t3`, `t4`) based on the selected gate type.\n- Inputs: `gate_select` (2-bit,[1:0]).\n- Outputs : `o_1`, `o_2`, `o_3`, `o_4` (4-bit, [3:0],signed).\n- Gates implemented: AND, OR, NAND, and NOR gates.\n   - `gate_select`:\n         - `2'b00` : AND Gate    ; target values : (`4'd1`,`-4'd1`,`-4'd1`,`-4'd1`)\n         - `2'b01` : OR Gate      ; target values : (`4'd1`, `4'd1`, `4'd1`,`-4'd1`)\n         - `2'b10` : NAND Gate ; target values : (`4'd1`, `4'd1`, `4'd1`,`-4'd1`) \n         - `2'b11` : NOR Gate   ;  target values : (`4'd1`, `-4'd1`, `-4'd1`,`-4'd1`) \n         \n### 2. Microcode ROM\n- Defines a sequence of 6 micro-instructions, specifying actions such as weight initialization, output computation, target selection, and weight/bias updates.\n\n## Algorithm Steps for Perceptron Learning\n- Initialization: All weights, biases, and counters are set to zero.\n- Compute Output: Compute `y_in` = `bias` + (`x1` * `w1`) + (`x2` * `w2`) and compare with the threshold to determine `y`.\n- Select Target: Based on `gate_select` and` input_index`, pick the desired target value\n- Update Weights and Bias: Adjust weights and bias  based on the condition (`y` != `target`)\n  -  If the condition is satisfied\n        - `wt1_update` = `learning_rate` * `x1` * `target`\n        - `wt2_update` = `learning_rate` * `x2` * `target`\n        - `bias_update` = `learning_rate` * `target`\n   - If the condition is not satisfied\n        - `wt1_update` = 0\n        - `wt2_update` = 0\n        - `bias_update` = 0\n  - The value of current weights and bias is calculated as follows :\n       - `percep_wt1` = `percep_w1` + `wt1_update`\n       - `percep_wt2` = `percep_wt2` + `wt2_update`\n       - `percep_bias` = `percep_bias` + `bias_update`\n- Check if the `wt1_update`, `wt2_update` , and `bias_update` values are equal to their previous iteration values. If the condition is satisfied, stop the learning. Otherwise assign the `wt1_update`, `wt2_update`, and `bias_update` values to their previous iteration values and continue learning.\n                                                 \n## Control Flow\n### Microcoded Actions\n- Action 0: Initialize weights and bias to zero.\n- Action 1: Compute `y_in` (weighted sum + bias) and `y` (thresholded output).\n- Action 2: Select target value based on `input_index `and `gate type`.\n- Action 3: Update weights and bias if the perceptron output differs from the target.\n- Action 4: Compare current and previous weights and bias to determine convergence.\n- Action 5: Finalize updates and prepare for the next epoch.\n**An epoch is the time taken to train the perceptron for a given combination of four input values**\n\n## Key Features\n- Microcoded Sequencing: Flexible execution of training steps using `microcode ROM`.\n- Dynamic Target Selection: Allows gate-based logic outputs for versatile applications.\n- Sequential Updates: Tracks and applies weight changes across iterations.\n- Convergence Monitoring: Halts training when weights stabilize.\n\n## Example Scenario\n - Let us take training of AND gate for explaining the scenario\n - The inputs (`x1` and `x2`) are strictly applied in the following order : (`1`,`1`) , (`1`,`-1`) , (`-1`,`1`) , (`-1`,`-1`).\n - The learning rate is fixed to be 1. The threshold value is fixed to be 0.\n\n \n### First Epoch\n- For Input (1,1) :\n     Out - 0  \n     Target - 1\n     Weight and Bias Changes - (1,1,1)\n     Weights and Bias - (1,1,1)\n\n- For Input (1,-1)\n     Out - 1  \n     Target - -1\n     Weight and Bias Changes - (-1,1,-1)\n     Weights and Bias - (0,2,0)\n\n- For Input (-1,1)\n     Out - 1  \n     Target - -1\n     Weight and Bias Changes - (1,-1,-1)\n     Weights and Bias - (1,1,-1)\n\n- For Input (-1,-1)\n     Out - -1  \n     Target - -1\n     Weight and Bias Changes - (0,0,0)\n     Weights and Bias - (1,1,-1)\n\n### Second Epoch\n- For Input (1,1)\n     Out -  1  \n     Target - 1\n     Weight and Bias Changes - (0,0,0)\n     Weights and Bias - (1,1,-1)\n\n- For Input (1,-1)\n     Out - -1  \n     Target - -1\n     Weight and Bias Changes - (0,0,0)\n     Weights and Bias - (1,1,-1)\n\n- For Input (-1,1)\n     Out - -1  \n     Target - -1\n     Weight and Bias Changes - (0,0,0)\n     Weights and Bias - (1,1,-1)\n\n- For Input (-1,-1)\n     Out - -1  \n     Target - -1\n     Weight and Bias Changes - (0,0,0)\n     Weights and Bias - (1,1,-1)\n\n\n### Legends :\n-  **Input  -   x1, x2**\n- **Weight Changes - wt1_update, wt2_update, bias_update**\n- **Weights  -  pecep_w1, percep_w2, percep_b** \n\n**Since all the `wt1_update` and `wt2_updates` are 0 in Second epoch , the `perceptron_module` got fully trained after First Epoch. Hence the training is stopped**\n\nExample Waveform :\n```wavedrom\n   {\n  \"signal\": [\n    {\"name\": \"clk\", \"wave\": \"p...............\"},\n    {\"name\": \"rst\", \"wave\": \"0...1...........\", \"data\": []},\n    {\"name\": \"x1[3:0]\", \"wave\": \"0...3444..4444..\", \"data\": [\"4'd1\",\"4'd1\",\"-4'd1\",\"-4'd1\",\"4'd1\",\"4'd1\",\"-4'd1\",\"-4'd1\"]},\n    {\"name\": \"x2[3:0]\", \"wave\": \"0...3444..4444..\", \"data\": [\"4'd1\",\"-4'd1\",\"4'd1\",\"-4'd1\",\"4'd1\",\"-4'd1\",\"4'd1\",\"-4'd1\"]},\n    {\"name\": \"gate_select[1:0]\", \"wave\": \"x...3...........\", \"data\": [\"2'b00\"]},\n    {\"name\": \"percep_w1[3:0]\", \"wave\": \"0...3444..4444..\", \"data\": [\"4'd1\",\"4'd0\",\"4'd1\",\"4'd1\",\"4'd1\",\"4'd1\",\"4'd1\",\"4'd1\"]},\n    {\"name\": \"percep_w2[3:0]\", \"wave\": \"0...3444..4444..\", \"data\": [\"4'd1\",\"4'd2\",\"4'd1\",\"4'd1\",\"4'd1\",\"4'd1\",\"4'd1\",\"4'd1\"]},\n    {\"name\": \"percep_bias[3:0]\", \"wave\": \"0...3444..4444..\", \"data\": [\"4'd1\",\"4'd0\",\"-4'd1\",\"-4'd1\",\"-4'd1\",\"-4'd1\",\"-4'd1\",\"-4'd1\"]},\n    {\"name\": \"present_addr[3:0]\", \"wave\": \"0...3333..3333..\", \"data\": [\"4'd5\",\"4'd5\",\"4'd5\",\"4'd5\",\"4'd5\",\"4'd5\",\"4'd5\",\"4'd5\"]},\n    {\"name\": \"stop\", \"wave\": \"0............1..\", \"data\": []},\n    {\"name\": \"input_index[2:0]\", \"wave\": \"0...3444..4444..\", \"data\": [\"3'd0\",\"3'd1\",\"3'd2\",\"3'd3\",\"3'd0\",\"3'd1\",\"3'd2\",\"3'd3\"]},\n    {\"name\": \"prev_percep_wt_1[3:0]\", \"wave\": \"0...3444..4444..\", \"data\": [\"4'd1\",\"-4'd1\",\"4'd1\",\"4'd0\",\"4'd0\",\"4'd0\",\"4'd0\",\"4'd0\"]},\n    {\"name\": \"prev_percep_wt_2[3:0]\", \"wave\": \"0...3444..4444..\", \"data\": [\"4'd1\",\"4'd1\",\"-4'd1\",\"4'd0\",\"4'd0\",\"4'd0\",\"4'd0\",\"4'd0\",\"4'd0\"]},\n    {\"name\": \"prev_percep_bias[3:0]\", \"wave\": \"0...3444..4444..\", \"data\": [\"4'd1\",\"-4'd1\",\"-4'd1\",\"4'd0\",\"4'd0\",\"4'd0\",\"4'd0\",\"4'd0\",\"4'd0\"]}\n    ],\n  \"config\": {\"hscale\": 5}\n   }\n ```\n ", "context": {}}, "output": {"response": "", "context": {"rtl/perceptron_gates.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir  \n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/perceptron_gates.sv\nTOPLEVEL        = perceptron_gates\nMODULE          = test_perceptron_gates\nPYTHONPATH      = /src\nHASH            = 1-perceptron_rtl_module_generation_issue\n", "src/test_perceptron_gates.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n@cocotb.test()\nasync def test_perceptron_gates(dut):\n    \"\"\"Testbench for the perceptron_gates module using Cocotb.\"\"\"\n\n    # Create a 10ns clock\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Reset logic\n    dut.rst_n.value = 0\n    await Timer(10, units=\"ns\")\n    dut.rst_n.value = 1\n\n    # Initialize inputs\n    dut.x1.value = 0\n    dut.x2.value = 0\n    dut.learning_rate.value = 1\n    dut.threshold.value = 0\n    dut.gate_select.value = 0\n\n    await RisingEdge(dut.rst_n)\n    await Timer(10, units=\"ns\")\n\n    # Helper function for applying stimulus and logging outputs\n    async def apply_stimulus(x1, x2, gate_select, duration):\n        dut.x1.value = x1\n        dut.x2.value = x2\n        dut.gate_select.value = gate_select\n        await Timer(duration, units=\"ns\")\n        cocotb.log.info(f\"gate_select={gate_select}, x1={x1}, x2={x2}, percep_w1={dut.percep_w1.value.to_signed()}, percep_w2={dut.percep_w2.value.to_signed()}, percep_bias={dut.percep_bias.value.to_signed()}, present_addr={bin(dut.present_addr.value.to_unsigned())}, stop={bin(dut.stop.value.to_unsigned())}, input_index={bin(dut.input_index.value.to_unsigned())}, y_in={dut.y_in.value.to_signed()}, y={dut.y.value.to_signed()}, prev_percep_wt_1={dut.prev_percep_wt_1.value.to_signed()}, prev_percep_wt_2={dut.prev_percep_wt_2.value.to_signed()}, prev_percep_bias={dut.prev_percep_bias.value.to_signed()}\")\n\n    # Test AND gate targets (gate_select = 2'b00)\n    dut.gate_select.value = 0b00\n    cocotb.log.info(\"Start of AND gate Training\")\n    await apply_stimulus(1, 1, 0b00, 100)\n    await apply_stimulus(1, -1, 0b00, 80)\n    await apply_stimulus(-1, 1, 0b00, 90)\n    await Timer(25, units=\"ns\")\n    await apply_stimulus(-1, -1, 0b00, 95)\n    await apply_stimulus(1, 1, 0b00, 25)\n    await apply_stimulus(1, -1, 0b00, 30)\n    await apply_stimulus(-1, 1, 0b00, 30)\n    await apply_stimulus(-1, -1, 0b00, 90)\n    await Timer(30, units=\"ns\")\n    cocotb.log.info(\"End of AND gate Training\")\n\n    # Test OR gate targets (gate_select = 2'b01)\n    dut.gate_select.value = 0b01\n    cocotb.log.info(\"Start of OR gate Training\")\n    await apply_stimulus(1, 1, 0b01, 95)\n    await Timer(30, units=\"ns\")\n    await apply_stimulus(-1, 1, 0b01, 65)\n    await apply_stimulus(1, -1, 0b01, 30)\n    await apply_stimulus(-1, -1, 0b01, 60)\n    cocotb.log.info(\"End of OR gate Training\")\n\n    # Test NAND gate targets (gate_select = 2'b10)\n    dut.gate_select.value = 0b10\n    cocotb.log.info(\"Start of NAND gate Training\")\n    await apply_stimulus(-1, -1, 0b10, 115)\n    await Timer(30, units=\"ns\")\n    await apply_stimulus(-1, 1, 0b10, 80)\n    await Timer(30, units=\"ns\")\n    await apply_stimulus(1, -1, 0b10, 65)\n    await Timer(10, units=\"ns\")\n    await apply_stimulus(1, 1, 0b10, 70)\n    cocotb.log.info(\"End of NAND gate Training\")\n\n    # Test NOR gate targets (gate_select = 2'b11)\n    dut.gate_select.value = 0b11\n    cocotb.log.info(\"Start of NOR gate Training\")\n    await apply_stimulus(-1, -1, 0b11, 410)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(-1, 1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(1, -1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(1, 1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(-1, -1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(-1, 1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(1, -1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(1, 1, 0b11, 70)\n    cocotb.log.info(\"End of NOR gate Training\")\n\n    # Randomized test cases\n    num_random_cases = 10  # Number of random test cases\n    for i in range(num_random_cases):\n        random_gate_select = random.randint(0, 3)  # Randomly select gate (0b00 to 0b11)\n        random_inputs = [(random.choice([-1, 1]), random.choice([-1, 1])) for _ in range(4)]\n\n        dut.gate_select.value = random_gate_select\n        cocotb.log.info(f\"Start of Random Test Case {i+1} for gate_select={bin(random_gate_select)}\")\n\n        for x1, x2 in random_inputs:\n            await apply_stimulus(x1, x2, random_gate_select, 100)\n        cocotb.log.info(f\"End of Random Test Case {i+1} for gate_select={bin(random_gate_select)}\")\n\n    # Stop the test\n    cocotb.log.info(\"Test Completed\")\n\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\n# Fetch environment variables for simulation setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang = os.getenv(\"TOPLEVEL_LANG\", \"verilog\")\nsim = os.getenv(\"SIM\", \"icarus\")\ntoplevel = os.getenv(\"TOPLEVEL\", \"perceptron_gates\")\nmodule = os.getenv(\"MODULE\", \"test_perceptron_gates\")\nwave = os.getenv(\"WAVE\", \"0\")\n\n# Function to configure and run the simulation\ndef runner():\n    \"\"\"Runs the simulation for the perceptron gates.\"\"\"\n    # Get the simulation runner\n    simulation_runner = get_runner(sim)\n\n    # Build the simulation environment\n    simulation_runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,         # Always rebuild\n        clean=True,          # Clean previous build files\n        waves=True ,   # Enable waveform generation if WAVE=1\n        verbose=True,        # Verbose build and simulation output\n        timescale=(\"1ns\", \"1ns\"),  # Set the timescale for simulation\n        log_file=\"build.log\"      # Log file for the build process\n    )\n\n    # Run the testbench\n    simulation_runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True    # Enable waveform dump if WAVE=1\n    )\n\n# Pytest function to run the simulation\n##@pytest.mark.simulation\ndef test_perceptron_gates():\n    \"\"\"Pytest function to execute the perceptron learning testbench.\"\"\"\n    print(\"Running perceptron learning testbench...\")\n    runner()\n\n"}}}
{"id": "cvdp_copilot_perf_counters_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Based on the requirements below, design a performance counter module that counts events triggered by a CPU and has a software-controlled reset.\n\n**Requirements**:\n- The counter will increment when a trigger event from the CPU pipeline (`cpu_trig_i`) is received.\n- The counter's value should only be readable via a software request (`sw_req_i`). If there is no read request, the output should remain zero.\n- Once the software reads the value, the counter resets to zero in the next cycle.\n- The counter and the software read are independent and have no protocol dependencies.\n- The counter width should be parameterizable.\n- Use positive edge-triggered flip-flops with an asynchronous reset.\n\n**Interface Definition**:\n- `clk`: Clock signal (input).\n- `reset`: Active-high reset signal (input).\n- `sw_req_i`: Software request signal (input).\n- `cpu_trig_i`: CPU trigger signal (input).\n- `p_count_o [CNT_W-1:0]`: Performance counter output (output).\n\n**Behavior**:\n- On reset, the counter value is set to zero.\n- The counter starts incrementing when `cpu_trig_i` is active, but the value is only output on `p_count_o` when a software read (`sw_req_i`) occurs.\n- After the software reads the counter, it resets to zero on the next cycle.\n\n```\n{\n    \"signal\": [\n        { \"name\": \"clk\", \"wave\": \"p........\" },\n        { \"name\": \"reset\", \"wave\": \"10.......\" },\n        { \"name\": \"sw_req_i\", \"wave\": \"0...10...\" },\n        { \"name\": \"cpu_trig_i\", \"wave\": \"0.1.0.1..\" },\n        { \"name\": \"count_q\", \"wave\": \"0123..567\", \"data\": [ \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\" ] },\n        { \"name\": \"p_count_o\", \"wave\": \"2...22...\", \"data\": [ \"0\", \"1\", \"0\", \"3\", \"4\", \"5\", \"6\" ] }\n    ]\n}\n```\n\n**Boundary Conditions:**\n- The counter should handle overflow correctly based on its parameterized width (`CNT_W`).\n\nProvide a parameterizable Verilog module that meets these requirements. Ensure all timing and synchronization aspects, such as clock and reset behavior, are clearly handled.", "context": {}}, "output": {"response": "", "context": {"rtl/cvdp_copilot_perf_counters.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cvdp_copilot_perf_counters.sv\nTOPLEVEL        = cvdp_copilot_perf_counters\nMODULE          = test_perf_counters\nPYTHONPATH      = /src\nHASH            = 1-performance-counter-rtl-design", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_perf_counters.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport time\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_perf_counters(dut):\n        # Parameters\n    CLK_PERIOD = 10  # Clock period in nanoseconds\n\n    # Create a clock on dut.Clk\n    cocotb.start_soon(Clock(dut.clk, CLK_PERIOD, units='ns').start())\n    \n\t# Initialize the DUT signals to default values (usually zero)\n    await hrs_lb.dut_init(dut)\n\n    # Apply an asynchronous reset to the DUT; reset is active high\n    await hrs_lb.reset_dut(dut.reset, duration_ns=25, active=True)\n    # Test sequence variables\n    NUM_CYCLES = 50  # Number of clock cycles to test\n    count_values = []\n\n    # Start simulation\n    dut.sw_req_i.value = 0  # Initial values\n    dut.cpu_trig_i.value = 0\n\n    await RisingEdge(dut.clk)  # Synchronize at rising edge of clock\n\n    # Step 1: Test normal counting when sw_req_i is 0 and cpu_trig_i toggles\n    for cycle in range(NUM_CYCLES):\n        # Randomly toggle the cpu_trig_i\n        dut.cpu_trig_i.value = random.randint(0, 1)\n        await RisingEdge(dut.clk)  # Wait for the clock edge\n\n        # Log and check count value\n        count_values.append(int(dut.p_count_o.value))\n        dut._log.info(f\"Cycle: {cycle}, CPU Trigger: {dut.cpu_trig_i.value}, Counter Output: {dut.p_count_o.value}\")\n\n    # Step 2: Assert `sw_req_i` and check if the count resets to cpu_trig_i value\n    dut.sw_req_i.value = 1  # Assert software request\n    dut.cpu_trig_i.value = 1  # Set a value for cpu_trig_i\n\n    await RisingEdge(dut.clk)  # Wait for the clock edge\n    await Timer(CLK_PERIOD, units='ns')  # Allow enough time for change\n\n    # Verify that the counter resets to the value of cpu_trig_i\n    assert dut.p_count_o.value == 1, f\"Error: Counter value {dut.p_count_o.value}, expected 1 when sw_req_i is asserted\"\n\n    dut._log.info(f\"After sw_req_i assert, Counter Output: {dut.p_count_o.value}\")\n\n    # Step 3: Deassert `sw_req_i` and allow normal counting to resume\n    dut.sw_req_i.value = 0  # Deassert software request\n    for cycle in range(NUM_CYCLES):\n        # Randomly toggle the cpu_trig_i\n        dut.cpu_trig_i.value = random.randint(0, 1)\n        await RisingEdge(dut.clk)  # Wait for the clock edge\n\n        # Log and check count value\n        dut._log.info(f\"Cycle: {cycle}, CPU Trigger: {dut.cpu_trig_i.value}, Counter Output: {dut.p_count_o.value}\")\n        count_values.append(int(dut.p_count_o.value))\n\n    # Step 4: Reset and verify count is back to 0\n    await hrs_lb.reset_dut(dut.reset, duration_ns=25, active=True)\n    await RisingEdge(dut.clk)\n    assert dut.p_count_o.value == 0, f\"Error: Counter value {dut.p_count_o.value}, expected 0 after reset\"\n    dut._log.info(f\"After reset, Counter Output: {dut.p_count_o.value}\")  \n\n@cocotb.test()\nasync def test_perf_counters_overflow(dut):\n    # Parameters\n    CLK_PERIOD = 10  # Clock period in nanoseconds\n    CNT_W = len(dut.p_count_o)  # Get the width of the counter\n    MAX_COUNT = (1 << CNT_W) - 1  # Maximum value the counter can hold based on CNT_W\n    print(f\"MAX_COUNT = {MAX_COUNT}\")\n    # Create a clock on dut.clk\n    cocotb.start_soon(Clock(dut.clk, CLK_PERIOD, units='ns').start())\n\n    # Initialize the DUT signals to default values (usually zero)\n    await hrs_lb.dut_init(dut)\n\n    # Apply an asynchronous reset to the DUT; reset is active high\n    await hrs_lb.reset_dut(dut.reset, duration_ns=25, active=True)\n\n    # Start simulation\n    dut.sw_req_i.value = 0  # Allow normal counting\n    dut.cpu_trig_i.value = 1  # Trigger the counter on every cycle\n\n    await RisingEdge(dut.clk)  # Synchronize at rising edge of clock\n\n    # Step 1: Drive the counter up to its maximum value (MAX_COUNT)\n    for _ in range(MAX_COUNT):\n        await RisingEdge(dut.clk)  # Increment the counter\n        dut._log.info(f\"Current Counter Value: {int(dut.p_count_o.value)}\")\n\n    # Step 2: Verify that the next clock cycle causes an overflow (wraparound)\n    await RisingEdge(dut.clk)  # One more cycle should cause the overflow\n    assert int(dut.p_count_o.value) == 0, f\"Error: Counter value {int(dut.p_count_o.value)}, expected 0 after overflow\"\n\n    dut._log.info(f\"After overflow, Counter Output: {int(dut.p_count_o.value)}\")\n\n    # Step 3: Continue counting to ensure correct behavior after overflow\n    #for i in range(5):\n    i=0\n    dut.sw_req_i.value = 1  # Assert software request\n    await RisingEdge(dut.clk)\n    dut.sw_req_i.value = 0  # Deassert software request        \n    expected_value = i + 1\n    assert int(dut.p_count_o.value) == expected_value, f\"Error: Counter value {int(dut.p_count_o.value)}, expected {expected_value} after overflow\"\n    dut._log.info(f\"Cycle {i+1} after overflow, Counter Output: {int(dut.p_count_o.value)}\")\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom cocotb.runner import get_runner\nimport pytest\nimport pickle\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\n@pytest.mark.tb\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\n#if __name__ == \"__main__\":\n#    test_runner()"}}}
{"id": "cvdp_copilot_perfect_squares_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Develop a SystemVerilog module called `perfect_squares_generator` that outputs a sequence of perfect squares based on an initial reset state. This module should meet the following specifications:\n\n### **Module Specifications**\n\n1. **Sequential Square Generation:**\n   - On each positive clock edge, the module outputs the next perfect square, beginning from 1.\n   - The sequence of perfect squares is represented on the `sqr_o` output, progressing as 1, 4, 9, 16, etc., with each square calculated using incremental steps.\n\n2. **Inputs and Outputs:**\n   - **Inputs:**\n     - `clk`: 1-bit clock input, active on the positive edge.\n     - `reset`: 1-bit asynchronous, active-high reset input. On activation, the module resets and begins the sequence anew.\n   - **Outputs:**\n     - `sqr_o [31:0]`: 32-bit output for the current perfect square.\n\n3. **Internal Operation and Edge Case Handling:**\n   - The module uses an internal counter to maintain a sequence of base numbers for calculating squares. \n   - **Overflow Protection**: If `sqr_o` exceeds the 32-bit maximum (`32'hFFFFFFFF`), it saturates at this maximum value, preventing any overflow in the output.\n\n4. **Reset Behavior:**\n   - When `reset` is high, the module initializes to produce the first square (1) on the following clock edge. The sequence then continues with each positive clock edge.\n\n### **Example Output Sequence:**\nAfter an active-high reset, `sqr_o` will output the next perfect square on each positive clock edge:\n   - After reset: `sqr_o` = 1\n   - First clock cycle: `sqr_o` = 4\n   - Second clock cycle: `sqr_o` = 9\n   - Third clock cycle: `sqr_o` = 16", "context": {}}, "output": {"response": "", "context": {"rtl/perfect_squares_generator.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __OSS_SIM_IMAGE__\n\n# ----------------------------------------\n# - Install dependencies\n# ----------------------------------------\n\nRUN pip3 install cocotb_bus", "docker-compose.yml": "services:\n  direct:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/perfect_squares_generator.sv\nTOPLEVEL        = perfect_squares_generator\nMODULE          = test_perfect_squares_generator\nPYTHONPATH      = /src\nHASH            = 1-perfect-squares-generator-design\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_perfect_squares_generator.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_perfect_squares_generator(dut):\n    \"\"\"Cocotb test for perfect squares generator\"\"\"\n\n    # Initialize variables\n    error_count = 0\n    cycle_count = 0\n    n = 2\n    expected_sqr = n * n\n    max_cycle_count = 100000\n    CLK_PERIOD = 10  # Clock period in nanoseconds\n    # Create a clock on dut.Clk\n    cocotb.start_soon(Clock(dut.clk, CLK_PERIOD, units='ns').start())\n    \n\t# Initialize the DUT signals to default values (usually zero)\n    await hrs_lb.dut_init(dut)\n\n    # Apply an asynchronous reset to the DUT; reset is active high\n    await hrs_lb.reset_dut(dut.reset, duration_ns=25, active=True)\n\n    # Open a log file\n    fd = open(\"perfect_squares_output.txt\", \"w\")\n\n    # Run simulation loop\n    while cycle_count < max_cycle_count:\n        await RisingEdge(dut.clk)\n        cycle_count += 1\n\n        # Capture and verify output\n        actual_sqr_o = int(dut.sqr_o.value)\n        \n        if dut.reset.value:\n            # Reset condition: reset n and expected square\n            n = 2\n            expected_sqr = n * n\n        else:\n            # Handle expected_sqr overflow\n            if expected_sqr > 0xFFFFFFFF:\n                expected_sqr = 0xFFFFFFFF  # Saturate expected square value\n\n            # Check output against expected value\n            if actual_sqr_o != (expected_sqr & 0xFFFFFFFF):\n                if actual_sqr_o == 0xFFFFFFFF and expected_sqr == 0xFFFFFFFF:\n                    fd.write(f\"Cycle {cycle_count}: Output saturated at 0xFFFFFFFF due to overflow.\\n\")\n                else:\n                    fd.write(f\"Cycle {cycle_count}: ERROR - Expected sqr_o = {expected_sqr & 0xFFFFFFFF:X}, \"\n                             f\"but got {actual_sqr_o:X}\\n\")\n                    error_count += 1\n            else:\n                fd.write(f\"Cycle {cycle_count}: sqr_o = {actual_sqr_o:X} (Correct)\\n\")\n\n            # Update n and compute the next expected square\n            n += 1\n            expected_sqr = n * n\n\n        # Check for saturation to end simulation early\n        if actual_sqr_o == 0xFFFFFFFF and expected_sqr == 0xFFFFFFFF:\n            fd.write(f\"Cycle {cycle_count}: Output has saturated. Ending simulation.\\n\")\n            break\n\n    # Final pass/fail report\n    if error_count == 0:\n        fd.write(\"TEST PASSED: No errors detected.\\n\")\n    else:\n        fd.write(f\"TEST FAILED: {error_count} error(s) detected.\\n\")\n\n    # Close the log file\n    fd.close()\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom cocotb.runner import get_runner\nimport pytest\nimport pickle\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\n@pytest.mark.tb\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\n#if __name__ == \"__main__\":\n#    test_runner()"}}}
{"id": "cvdp_copilot_piso_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design RTL for generating 8-bit data continuously in an incremental manner through a Parallel In Serial Out (PISO) shift register. This module has to generate 1-bit during every clock cycle and to complete the generation of a new 8-bit value at the end of every 8 clock cycles. Could you ensure the patterns are generated in MSB to LSB order? For example, the first 8-bit pattern generated will be 8'b0000_0001, in which the first clock has to create '0' and the eighth clock will produce '1' as output. The pattern generation has to be controlled by a clock and asynchronous active LOW reset. The RTL module `piso_8bit` must have the following design consideration and interface.\n\n## Design considerations\n- One-bit serial data has to be generated during every clock cycle based on the value of 8-bit internal register `tmp`\n- The value of `tmp` has to be initialized to a value 0000_0001 when the reset is at active LOW and it gets incremented by 1 after every eight clock cycles when the reset is at HIGH\n- When all the eight bits of `tmp` value 1111_1111 have been transmitted, it gets incremented by 1 to have a value of 0000_0000 and the shifting process continues\n\n## Interface\n\n### Inputs:\n\u2022\t`clk (1-bit)` : This is a single-bit input clock. It is required for the operation of a shift register as the data movement is controlled at the positive edge of this clock. The clock normally operates at a 50:50 duty cycle. \n\u2022\t`rst (1-bit)`: This input is a control signal that resets the internal register value to zero and the shift register operation. This is an asynchronous active LOW reset, which when maintaining active LOW, keeps the `serial_out` data at logic LOW.\n\n### Output:\n\u2022\t`serial_out (1-bit)`: This signal represents the output of the PISO shift register. When the reset is at logic HIGH, a new value is asserted at this output during every positive edge of the clock cycle. The value at `serial_out` is controlled by the contents of the internal 8-bit register which keeps changing every 8th clock cycle. \n", "context": {}}, "output": {"response": "", "context": {"rtl/piso_8bit.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/piso_8bit.sv\nTOPLEVEL        = piso_8bit\nMODULE          = test_piso\nPYTHONPATH      = /src\nHASH            = 1-design-rtl-for-generating-8-bit-incremental-pattern-through-piso", "src/test_piso.py": "import cocotb\nimport os\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer, Join\nimport random\n\n# ----------------------------------------\n# - Tests\n# ----------------------------------------\n\n@cocotb.test()\nasync def test_piso_1(dut):\n\n    # Start clock thread\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    data_1 = list()\n    data_2 = list()\n    data_3 = list()\n    for i in range(32):\n        await RisingEdge(dut.clk)\n        if (i < 8):\n            data_1.append(int(dut.serial_out.value))\n            print(\"Serial out \",dut.serial_out.value)\n        if (i >= 8 and i < 16):\n            data_2.append(int(dut.serial_out.value))\n            print(\"Serial out \",dut.serial_out.value)\n        if (i >= 24 and i < 32):\n            data_3.append(int(dut.serial_out.value))\n            print(\"Serial out \",dut.serial_out.value)\n    print(data_1)\n    assert data_1 == [0,0,0,0,0,0,0,1], f\"Serial data sequence is not correct\"\n\n    print(data_2)\n    assert data_2 == [0,0,0,0,0,0,1,0], f\"Serial data sequence is not correct\"\n\n    print(data_3)\n    assert data_3 == [0,0,0,0,0,1,0,0], f\"Serial data sequence is not correct\"\n\n\n@cocotb.test()\nasync def test_piso_2(dut):\n\n    # Start clock thread\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n    dut.rst.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 1\n    data = list()\n    for i in range(16):\n        await RisingEdge(dut.clk)\n        if (i >= 8 and i < 16):\n            data.append(int(dut.serial_out.value))\n            print(\"Serial out \",i,dut.serial_out.value)\n    print(data)\n    assert data == [0,0,0,0,0,0,1,0], f\"Serial data sequence is not correct\"\n\n\n@cocotb.test()\nasync def test_piso_3(dut):\n\n    # Start clock thread\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n    dut.rst.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 1\n    data = list()\n    for i in range(32):\n        await RisingEdge(dut.clk)\n        if (i > 23 and i < 32):\n            data.append(int(dut.serial_out.value))\n            print(\"Serial out \",dut.serial_out.value)\n        \n    print(data)\n    assert data == [0,0,0,0,0,1,0,0], f\"Serial data sequence is not correct\"\n\n\n@cocotb.test()\nasync def test_piso_4(dut):\n    #print(\"stimulus script : register_size test_piso_2\",int(dut.register_size.value))\n    # Start clock thread\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n    dut.rst.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 1\n    data = list()\n    data_1 = list()\n    data_2 = list()\n    for i in range(2057):\n        await RisingEdge(dut.clk)\n        if (i < 8): #checking the first sequence 0000_0001 after 8 clock cycles\n            data.append(int(dut.serial_out.value))\n            print(\"Serial out \",i,dut.serial_out.value)\n        if (i >= 2040 and i < 2048): #checking the sequence 0000_0000 after rollout\n            data_1.append(int(dut.serial_out.value))\n            print(\"Serial out \",i,dut.serial_out.value)\n        if (i >= 2048 and i < 2056): #checking the sequence 0000_0001 after rollout\n            data_2.append(int(dut.serial_out.value))\n            print(\"Serial out \",i,dut.serial_out.value)\n    print(\"Initial 8-bit sequence\",data)\n    print(\"First 8-bit sequence 0000_0000 after rollout\",data_1)\n    print(\"Second 8-bit sequence 0000_0001 after rollout\",data_2)\n    tmp = [0] * 30\n    tmp_1 = tmp.extend([1,0])\n    assert data_1 == [0,0,0,0,0,0,0,0], f\"Sequences are not same. Rollout is not happening properly\"\n    assert data == data_2, f\"Sequences are not same. Rollout is not happening properly\"\n\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport re\nimport logging\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_prbs_gen_0003", "categories": ["cid003", "medium"], "input": {"prompt": "Create a SystemVerilog module named `cvdp_prbs_gen` that functions as both a PRBS (Pseudo-Random Binary Sequence) generator and checker. The module should be parameterizable and capable of operating in two modes:\n\n- **Generator Mode (`CHECK_MODE = 0`):** Generates a PRBS pattern using a Linear Feedback Shift Register (LFSR) structure.\n- **Checker Mode (`CHECK_MODE = 1`):** Loads incoming data into PRBS registers and compares it with a locally generated PRBS pattern to detect errors.\n\n A LFSR is a sequential circuit used to generate a sequence of bits based on linear feedback logic. It consists of a series of flip-flops connected in a shift register configuration, where the input of the first flip-flop is driven by a linear function (typically XOR or XNOR) of selected outputs (taps) of the shift register. \n \n A PRBS is a deterministic sequence of binary values that exhibits properties similar to a random sequence. By configuring the LFSR with appropriate feedback taps, the PRBS generator produces a maximal-length sequence that cycles through all possible non-zero states before repeating, ensuring comprehensive test coverage.\n\n**Additional Specifications:**\n\n- **Polynomial Details:**\n  - The PRBS generation should be based on a configurable polynomial defined by the parameters.\n  - The polynomial length and taps are defined by `POLY_LENGTH` and `POLY_TAP`, representing the positions in the shift register that are XORed together. The XORed bit is set as the most significant bit (msb) of the PRBS for the next stage calculation.\n  - **Example Polynomial:**\n    - For a 31-bit PRBS: \\( x^{31} + x^{3} + 1 \\), where taps are at positions 31 (POLY_LENGTH) and 3(POLY_TAP).\n\n- **Seed Details:**\n  - The PRBS registers initialize to all ones on reset.\n\n**Module Parameters:**\n\n- `CHECK_MODE` (default: 0)\n  - **Type:** Integer parameter\n  - **Description:** Mode selection. `0` for generator mode, `1` for checker mode.\n- `POLY_LENGTH` (default: 31)\n  - **Type:** Integer parameter\n  - **Description:** Length of the polynomial (number of shift register stages in the LFSR).\n- `POLY_TAP` (default: 3)\n  - **Type:** Integer parameter or array\n  - **Description:** Positions of the tap in the shift register that is XORed with bit at `POLY_LENGTH` to generate the feedback bit.\n- `WIDTH` (default: 16)\n  - **Type:** Integer parameter\n  - **Description:** Bit width of the `data_in` and `data_out` buses.\n\n**Module Interface:**\n\n- **Inputs:**\n  - `clk`\n    - **Width:** 1 bit\n    - **Description:** Clock input signal. All operations are synchronized on the **rising edge**.\n  - `rst`\n    - **Width:** 1 bit\n    - **Active High**\n    - **Description:** Synchronous reset signal. When asserted high, resets internal states and outputs to their initial values.\n  - `data_in [WIDTH-1]`\n    - **Description:** Input data bus. In checker mode, it receives data to be compared with the PRBS pattern. In generator mode, it is tied to 0.\n\n- **Outputs:**\n  - `data_out [WIDTH-1]`\n    - **Description:**\n      - **Generator Mode:** Outputs the generated PRBS pattern.\n      - **Checker Mode:** Outputs the result of the error checking. A non-zero value indicates a discrepancy between `data_in` and the expected PRBS pattern.\n\n**Behavioral Description:**\n\n- **Reset Behavior:**\n  -  If `rst` is asserted high:\n    - The PRBS shift registers are initialized to all ones (`1`).\n    - `data_out` is set to all ones (`1`).\n- **Generator Mode (`CHECK_MODE = 0`):**\n  - Implements an LFSR to generate the PRBS pattern.\n  - For each bit position `i` (from `0` to `WIDTH-1`):\n    - Calculates the XOR of the bits at positions `POLY_TAP` and `POLY_LENGTH` of the current PRBS register.\n\t- In generator mode, the data_in is expected to be set to all 0.\n    - Updates the PRBS register by shifting right and inserting the XORed bit at the most significant bit (MSB).\n- **Checker Mode (`CHECK_MODE = 1`):**\n  - For each bit position `i` (from `0` to `WIDTH-1`):\n    - Generates the expected PRBS bit as in generator mode.\n    - Compares the input bit and generated bit by XORing `data_in[i]` with internally generated PRBS.\n\n**Timing and Synchronization:**\n\n- **Latency Considerations:**\n  - The module updates outputs every clock cycle when enabled.\n  - There is a one-clock-cycle latency from input to output due to synchronous operation.\n\n**Constraints and Edge Cases:**\n\n- **Parameter Constraints:**\n  - `POLY_LENGTH` must be greater than or equal to the tap position specified in `POLY_TAP`.\n  - `POLY_TAP` must be a positive integer.\n  - `WIDTH` must be a positive integer.\n- **Error Detection:**\n  - In checker mode, any non-zero value on `data_out` indicates an error between `data_in` and the expected PRBS pattern.\n  \n** Assumptions:**\n- In Generator mode, the PRBS data will be generated at every clock cycle after the reset is deasserted.\n- In Checker mode, data_in should be available and updated at every clock cycle as soon as the reset is deasserted.\n\n**Summary:**\n\nDesign a configurable PRBS generator and checker module in SystemVerilog, adhering to the specifications above. The module should efficiently handle PRBS generation and error checking based on the selected mode and \nLFSR configuration, while being flexible enough to accommodate various polynomial lengths, taps, and data widths. Ensure that the design is robust, well-documented, and thoroughly tested.", "context": {}}, "output": {"response": "", "context": {"rtl/cvdp_prbs_gen.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n\n", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cvdp_prbs_gen.sv\nTOPLEVEL        = cvdp_prbs_gen\nMODULE          = test_prbs_gen\nPYTHONPATH      = /src\nHASH            = 1a6c4d08f6dc2ada6cc3c565ff357389d2cf163e\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset, duration_ns = 10):\n    # Restart Interface\n    reset.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    reset.value = 0\n    await Timer(duration_ns, units='ns')\n    reset._log.debug(\"Reset complete\")\n\nasync def enable_dut(enable, duration_ns = 10):\n    # Restart Interface\n    enable.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    enable.value = 1\n    await Timer(duration_ns, units='ns')\n    enable._log.debug(\"enable complete\")\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def calculate_moving_average(data_queue, current_sum, new_data, window):\n    if len(data_queue) < window:\n        data_queue.append(new_data)\n        current_sum += new_data\n    else:\n        oldest_data = data_queue.pop(0)\n        current_sum += new_data - oldest_data\n        data_queue.append(new_data)\n\n    expected_avg = current_sum // window\n    \n    return expected_avg, current_sum\n\n", "src/test_prbs_gen.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, ClockCycles\nfrom cocotb.clock import Clock\n\n# Helper function to generate expected PRBS sequence\ndef generate_prbs(seed, poly_length, poly_tap, width, num_cycles):\n    prbs_reg = [int(x) for x in f'{seed:0{poly_length}b}']\n    prbs_out = []\n\n    for _ in range(num_cycles):\n        prbs_xor_a = []\n        prbs = [prbs_reg]  # Initialize prbs[0] with the current PRBS register\n\n        # Loop through each bit of the output width\n        for i in range(width):\n            # Perform XOR operation between specified tap and last stage of PRBS\n            xor_a = prbs[i][poly_tap - 1] ^ prbs[i][poly_length - 1]\n            prbs_xor_a.append(xor_a)\n\n            # Shift the LFSR and insert the new XOR result to generate next state\n            prbs_next = [xor_a] + prbs[i][0:poly_length - 1]\n            prbs.append(prbs_next)\n\n        # Collect the XOR result as the output for this cycle\n        prbs_out.append(int(''.join(map(str, prbs_xor_a[::-1])), 2))\n\n        # Update the PRBS register with the last stage (prbs[width])\n        prbs_reg = prbs[width]\n\n    return prbs_out\n\n# Testbench for PRBS Generator and Checker\n@cocotb.test()\nasync def test_prbs_gen(dut):\n    # Initialize and start the clock signal with a 10 ns period\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Test Parameters\n    #width       = int(dut.WIDTH.value)\n    check_mode  = int(dut.CHECK_MODE.value)  # Select mode: generator or checker\n    poly_length = int(dut.POLY_LENGTH.value)  # Length of the polynomial\n    poly_tap    = int(dut.POLY_TAP.value)     # Tap position in the polynomial\n    width       = int(dut.WIDTH.value)        # Width of the PRBS output\n    num_cycles  = 100  # Number of cycles to run the test\n    #print (\"Parameters: CHECK_MODE: \" ,check_mode, \", POLY_LENGTH: \" ,poly_length, \", POLY_TAP: \" ,poly_tap, \", WIDTH: \",width)\n\n    # Seed value for PRBS generation (all bits set to 1 initially)\n    seed = int('1' * poly_length, 2)\n\n    if check_mode == 0:  # Generator mode\n        # Reset the DUT (Device Under Test)\n        dut.rst.value = 1\n        dut.data_in.value = 0  # Initialize data_in to 0\n        await ClockCycles(dut.clk, 5)  # Wait for 5 clock cycles\n\n        # When rst is high, set expected PRBS output to all 1's\n        expected_prbs = [int('1' * width, 2)]\n\n        # Check the PRBS output during reset\n        await RisingEdge(dut.clk)  # Wait for a rising edge of the clock\n        prbs_out = dut.data_out.value.to_unsigned()  # Capture the output from the DUT\n        assert prbs_out == expected_prbs[0], f\"During reset: Expected {expected_prbs[0]:0{width}b}, Got {prbs_out:0{width}b}\"\n\n        # Release the reset and enable PRBS generation\n        dut.rst.value = 0  # Release reset\n\n        # Generate expected PRBS sequence after reset is released\n        expected_prbs = generate_prbs(seed, poly_length, poly_tap, width, num_cycles)\n\n        await RisingEdge(dut.clk)  # Wait for a rising edge of the clock so that the reset is driven low\n\n        # Check the PRBS output after reset is released\n        for cycle in range(num_cycles):\n            await RisingEdge(dut.clk)  # Wait for each clock cycle\n\n            # Extract the generated PRBS output from the DUT\n            prbs_out = dut.data_out.value.to_unsigned()\n\n            # Compare the DUT output with the expected PRBS sequence\n            assert prbs_out == expected_prbs[cycle], f\"Mismatch at cycle {cycle}: Expected {expected_prbs[cycle]:0{width}b}, Got {prbs_out:0{width}b}\"\n\n    elif check_mode == 1:  # Checker mode\n        # Reset the DUT (Device Under Test)\n        dut.rst.value = 1\n        dut.data_in.value = 0  # Initialize data_in to 0\n        await ClockCycles(dut.clk, 5)  # Wait for 5 clock cycles\n\n        # Release the reset and enable PRBS checking\n        dut.rst.value = 0  # Release reset\n\n        # Generate expected PRBS sequence to feed into data_in\n        prbs_sequence = generate_prbs(seed, poly_length, poly_tap, width, num_cycles)\n\n        # Initialize error flag\n        error_flag = 0\n\n        # Wait for a rising edge of the clock to ensure reset is low\n        #await RisingEdge(dut.clk)\n\n        # Send the PRBS sequence to the DUT via data_in\n        for cycle in range(num_cycles):\n            # Apply PRBS data_in\n            dut.data_in.value = prbs_sequence[cycle]\n\n            # Wait for a clock cycle\n            await RisingEdge(dut.clk)\n\n            # Read the error flag from data_out (assuming data_out is the error indicator)\n            error_flag = dut.data_out.value.to_unsigned()\n\n            if(cycle>0):\n            # Check that error_flag is 0 (no error)\n                assert error_flag == 0, f\"No error expected, but error detected at cycle {cycle}\"\n\n        # Introduce an error in the data_in\n        error_cycle = num_cycles // 2  # Introduce error at the middle of the sequence\n        dut.data_in.value = prbs_sequence[error_cycle] ^ 0x1  # Flip one bit to introduce error\n\n        # Wait for a clock cycle\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n\n        # Read the error flag after introducing the error\n        error_flag = dut.data_out.value.to_unsigned()\n\n        # Check that error_flag is 1 (error detected)\n        assert error_flag >0, f\"Error expected, but no error detected at cycle {error_cycle}\"\n", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(CHECK_MODE: int=0 , POLY_LENGTH: int=0, POLY_TAP: int=0, WIDTH: int=0):\n    parameter = {\"CHECK_MODE\":CHECK_MODE, \"POLY_LENGTH\":POLY_LENGTH, \"POLY_TAP\":POLY_TAP, \"WIDTH\":WIDTH }\n    # Debug information\n    print(f\"[DEBUG] Running simulation with CHECK_MODE={CHECK_MODE}, POLY_LENGTH={POLY_LENGTH}, POLY_TAP={POLY_TAP}, WIDTH={WIDTH}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n    \n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        parameters=parameter,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n# Parametrize test for different parameters\n@pytest.mark.parametrize(\"CHECK_MODE\", [0,1])\n@pytest.mark.parametrize(\"POLY_LENGTH\", [7,23,31])\n@pytest.mark.parametrize(\"POLY_TAP\", [1,3,5])\n@pytest.mark.parametrize(\"WIDTH\", [8,16,32])\ndef test_prbs(CHECK_MODE, POLY_LENGTH, POLY_TAP, WIDTH):\n    # Run the simulation with specified parameters\n    runner(CHECK_MODE=CHECK_MODE, POLY_LENGTH=POLY_LENGTH, POLY_TAP=POLY_TAP, WIDTH=WIDTH)\n"}}}
{"id": "cvdp_copilot_restoring_division_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design a System Verilog module that performs division using the restoring division algorithm. The restoring division algorithm is a method used for binary division in computer architecture. It involves repeatedly subtracting the divisor from the dividend and restoring the partial remainder if the result is negative. The module efficiently handles division between two unsigned integers (dividend and divisor) and provides outputs for both quotient and remainder. The design supports varying input widths specified by the WIDTH parameter.\n\n\n### Interface: `restoring_division`\n\n### Parameter:\n- `WIDTH` (default value = 6): Defines the bit-width of the dividend and divisor.\n\n### Inputs:\n- `clk`: Clock signal. All operations are synchronized with the rising edge of the clock.\n- `rst`: Reset signal (active-low asynchronous reset).\n- `start`: Start signal (active-high) to initiate the division process.\n- `[WIDTH-1:0] dividend`: The dividend input, `WIDTH` bits wide.\n- `[WIDTH-1:0] divisor`: The divisor input, `WIDTH` bits wide.\n\n### Outputs:\n- `[WIDTH-1:0] quotient`: The quotient of the division process;  `WIDTH` bits wide.\n- `[WIDTH-1:0] remainder`: The remainder of the division process, `WIDTH` bits wide.\n- `valid`: Valid signal (active-high) indicating the completion of the division operation.\n\n---\n\n## Specifications\n\n### Control Logic:\nThe module processes a new pair of dividend and divisor inputs in each division cycle. New inputs can be supplied along with `start` signal only when the previous outputs have been provided, indicated by the `valid` going high for one clock cycles.\n\n### Division Process:\n\n#### Initialization:\nAt the start of the division process:\n- The dividend is registered internally.\n- The remainder is initialized to zero.\n\n#### Shift and Subtract:\n1. At each iteration, the remainder is shifted left by one bit, and the next MSB of the dividend is appended to the remainder.\n2. The divisor is subtracted from the remainder to check if it can fit.\n   - If the most significant bit (MSB) of the subtraction result is 0, the quotient bit for this step is set to 1, and the result of the subtraction is kept as the new remainder.\n   - If the most significant bit (MSB) of the subtraction result is 1, the quotient bit for this step is set to 0, and the original remainder is restored by discarding the quotient bit.\n\n#### Completion:\nThe division process must finish within `WIDTH` clock cycles if `WIDTH` is a power of 2 (2^n) to ensuring all data is processed; otherwise (if WIDTH is not a power of 2), it will take `WIDTH+1` clock cycles.\n\n### Reset Behavior:\nWhen `rst` is asserted (active-low asynchronous reset), the outputs clear to zero.\n\n### Output Validity:\nThe correctness of the quotient and remainder is guaranteed for all valid inputs within the specified bit-width. \n\n---\n\n## Edge Conditions:\n- The dividend must be strictly greater than or equal to the divisor.\n- Both dividend and divisor must be non-zero.\n\n---\n\n## Example\n**Parameters**:\n- WIDTH = 3\n\n- Dividend = 3'd7 (binary: 111)\n\n- Divisor = 3'd5 (binary: 101)\n\n**Initialization**:\n\n- Remainder = 000 (set to 0 initially)\n\n- Dividend = 111\n\n- Quotient is initially unknown and will be calculated over 3 iterations.\n\n- The division starts from the MSB of the dividend.\n\n**Iteration 1**:\n- Shift remainder left, append MSB of dividend (1):  \n  - Remainder = 001  \n  - Subtract 101: result is negative.  \n  - Quotient = 0-- (set bit to 0).\n\n**Iteration 2**:\n- Shift remainder left, append next dividend bit (1):  \n  - Remainder = 0011  \n  - Subtract 101: result is negative.  \n  - Quotient = 00- (set bit to 0).\n\n**Iteration 3**:\n- Shift remainder left, append final dividend bit (1):  \n  - Remainder = 0111  \n  - Subtract 101: result is positive.  \n  - Remainder = 0010  \n  - Quotient = 001 (set bit to 1).\n\n**Final Output**:\n- Quotient = 3'd1 (binary: 001)\n- Remainder = 3'd2 (binary: 010)", "context": {}}, "output": {"response": "", "context": {"rtl/restore_division.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v\n", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/restore_division.sv\nTOPLEVEL        = restoring_division\nMODULE          = test_restoring_division\nPYTHONPATH      = /src\nHASH            = 3c3a009e2d1487e4f5f689276b2fb62ebd55d238", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_restoring_division.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport time\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_restoring_division(dut):\n    # Retrieve the width of the data from the DUT's WIDTH parameter\n    data_wd = int(dut.WIDTH.value)\n    print(f\"data_wd = {data_wd}\")\n    # Start the clock with a 10 nanosecond period\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n    \n    # Initialize the DUT signals to default values (usually zero)\n    await hrs_lb.dut_init(dut)\n\n    # Apply an asynchronous reset to the DUT; reset is active low\n    await hrs_lb.reset_dut(dut.rst, duration_ns=25, active=False)\n\n    # Determine a random number of test cycles between 20 to 50\n    cycle_num = random.randint(20, 50)\n    # Schedule a reset at the midpoint of the test cycles\n    reset_cycle = cycle_num // 2\n    print(f\"[INFO] Total cycles = {cycle_num}, Reset will be applied at cycle {reset_cycle}\")\n    \n    # Execute a loop through the predetermined number of cycles\n    for cycle in range(cycle_num):\n        # Apply reset halfway through the test\n        if cycle == reset_cycle:\n            # Assert the reset signal (active low)\n            dut.rst.value = 0\n            # Wait for two clock cycles while the reset is active\n            await RisingEdge(dut.clk)\n            await RisingEdge(dut.clk)\n            # Check if the outputs are correctly reset to zero\n            assert dut.quotient.value == 0, f\"[ERROR] quotient is not zero after reset: {dut.quotient.value}\"\n            assert dut.remainder.value == 0, f\"[ERROR] remainder is not zero after reset: {dut.remainder.value}\"\n            assert dut.valid.value == 0, f\"[ERROR] valid is not zero after reset: {dut.valid.value}\"\n            # Wait for 2 more cycles to allow the DUT to stabilize after reset\n            for i in range(2):\n                await RisingEdge(dut.clk)\n            # Deactivate the reset signal\n            dut.rst.value = 1\n            print(\"[INFO] Reset applied to the DUT\")\n\n        # Generate random values for dividend and divisor within specified ranges\n        wdata1 = random.randint(data_wd, (2**data_wd)-1)  # Dividend should be between WIDTH and 2^WIDTH - 1\n        wdata2 = random.randint(1, data_wd)               # Divisor should be between 1 and WIDTH - 1\n        \n        # Write generated values to the DUT\n        dut.dividend.value = wdata1\n        dut.divisor.value = wdata2\n        print(f\"Performing write operation: dividend = {wdata1}, divisor = {wdata2}\")\n        \n        # Start the division operation\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        # Ensure the start signal is only high for one clock cycle\n        dut.start.value = 0\n\n        # Wait for the division process to complete, indicated by the 'valid' signal\n        #await RisingEdge(dut.valid)\n       #Explicit Check for valid: Ensure valid asserts after WIDTH cycles\n        for _ in range(data_wd):\n            await RisingEdge(dut.clk)\n            assert dut.valid.value == 0, \"ERROR: Valid asserted prematurely\"\n        \n        # Check for valid to assert indicating division complete\n        await RisingEdge(dut.valid)\n        assert dut.valid.value == 1, \"ERROR: Valid did not assert as expected\" \n        # Read the results from the DUT after the division is complete\n        await RisingEdge(dut.clk)\n        out_q = int(dut.quotient.value)\n        out_r = int(dut.remainder.value)\n        print(f\"Read operation: quotient = {out_q}, remainder = {out_r}\")\n         \n        # Checker: Validate quotient and remainder against expected values calculated by Python\n        expected_q = wdata1 // wdata2\n        expected_r = wdata1 % wdata2\n           \n        assert out_q == expected_q, f\"ERROR: Quotient mismatch! Expected: {expected_q}, Got: {out_q}\"\n        assert out_r == expected_r, f\"ERROR: Remainder mismatch! Expected: {expected_r}, Got: {out_r}\"\n \n\t# Ensure valid remains high for only one cycle\n        await RisingEdge(dut.clk)\n        assert dut.valid.value == 0, \"ERROR: Valid did not deassert as expected\"\n\n        print(f\"Check Passed: quotient = {out_q}, remainder = {out_r}\")", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(WIDTH: int=0):\n    parameter = {\"WIDTH\":WIDTH}\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n\n@pytest.mark.parametrize(\"test\", range(2))\n@pytest.mark.parametrize(\"WIDTH\", [3,4,6,9,15])\ndef test_areg_param(test,WIDTH):\n        runner(WIDTH = WIDTH)\n    \n"}}}
{"id": "cvdp_copilot_reverse_bits_0001", "categories": ["cid003", "easy"], "input": {"prompt": "## Problem Description\nDesign a Verilog module named `reverse_bits` to reverse the bits of a 32-bit unsigned input number. The module should take a 32-bit input bus and produce a 32-bit output bus where the input bits are reversed. For example, if the input is `32'b00000000000000000000000000000001` (decimal 1), the output should be `32'b10000000000000000000000000000000`.\n\n## Specifications\n\n### Inputs\n- **`input [31:0] num_in`**: The 32-bit unsigned number to be reversed.\n\n### Outputs\n- **`output [31:0] num_out`**: The bit-reversed 32-bit number.\n\n## Behavioral Description\nThe module should process the input `num_in` such that:\n- The least significant bit (LSB) of `num_in` becomes the most significant bit (MSB) of `num_out`.\n- The second least significant bit of `num_in` becomes the second most significant bit of `num_out`, and so on.\n\n### Constraints and Edge Cases\n- Ensure that all input bits are reversed correctly without errors.\n- Special cases to test include:\n  - **All bits set to `1`**: `32'b11111111111111111111111111111111`.\n  - **All bits set to `0`**: `32'b00000000000000000000000000000000`.\n  - **Alternating pattern**: `32'b10101010101010101010101010101010`.\n- Undefined or high-impedance inputs (`x` or `z`) are not considered valid and will not be given as input.\n\n## Implementation Guidelines\n- The module must be implemented in synthesizable Verilog.\n- The solution should be combinational and free of clocked elements and resets.\n- Clear comments and intuitive naming conventions should enhance readability and maintainability.", "context": {}}, "output": {"response": "", "context": {"rtl/reverse_bits.v": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/reverse_bits.v\nTOPLEVEL        = reverse_bits\nMODULE          = test_reverse_bits\nPYTHONPATH      = /src\nHASH            = 1-reverse-bits-of-a-32-bit-unsigned-number", "src/test_reverse_bits.py": "import cocotb\nfrom cocotb.triggers import Timer\n\n\n@cocotb.test()\nasync def test_reverse_bits(dut):  # dut refers to the Device Under Test (reverse_bits)\n    \"\"\"\n    Test the reverse_bits module with various test cases.\n    \"\"\"\n\n    async def run_test_case(input_val, expected_output):\n        \"\"\"Helper function to apply input, wait, and verify output.\"\"\"\n        dut.num_in.value = input_val\n        await Timer(100, units='ps')  # Wait for outputs to stabilize\n        assert dut.num_out.value == expected_output, (\n            f\"Test failed for input {input_val:#010x}. \"\n            f\"Expected output: {expected_output:#010x}, \"\n            f\"Got: {dut.num_out.value:#010x}\"\n        )\n\n    # Test Case 1: All zeros\n    await run_test_case(0x00000000, 0x00000000)\n\n    # Test Case 2: All ones\n    await run_test_case(0xFFFFFFFF, 0xFFFFFFFF)\n\n    # Test Case 3: Single bit set at LSB\n    await run_test_case(0x00000001, 0x80000000)\n\n    # Test Case 4: Single bit set at MSB\n    await run_test_case(0x80000000, 0x00000001)\n\n    # Test Case 5: Alternating pattern (0xAAAAAAAA)\n    await run_test_case(0xAAAAAAAA, 0x55555555)\n\n    # Test Case 6: Alternating pattern (0x55555555)\n    await run_test_case(0x55555555, 0xAAAAAAAA)\n\n    # Test Case 7: Incrementing bits (0x12345678)\n    await run_test_case(0x12345678, int('{:032b}'.format(0x12345678)[::-1], 2))\n\n    # Test Case 8: Decrementing bits (0x87654321)\n    await run_test_case(0x87654321, int('{:032b}'.format(0x87654321)[::-1], 2))\n\n    # Test Case 9: Edge case with one zero surrounded by ones\n    await run_test_case(0xFFFFFFFE, 0x7FFFFFFF)\n\n    # Test Case 10: Edge case with one one surrounded by zeros\n    await run_test_case(0x00000010, 0x08000000)\n\n    # Test Case 11: Random value (0xCAFEBABE)\n    await run_test_case(0xCAFEBABE, int('{:032b}'.format(0xCAFEBABE)[::-1], 2))\n\n    # Test Case 12: Random value (0xDEADBEEF)\n    await run_test_case(0xDEADBEEF, int('{:032b}'.format(0xDEADBEEF)[::-1], 2))\n\n    # Test Case 13: Symmetrical value (0x0F0F0F0F)\n    await run_test_case(0x0F0F0F0F, 0xF0F0F0F0)\n\n    # Test Case 14: Symmetrical value (0xF0F0F0F0)\n    await run_test_case(0xF0F0F0F0, 0x0F0F0F0F)\n\n    # Test Case 15: Middle bit set\n    await run_test_case(0x08000000, 0x00000010)\n\n    cocotb.log.info(\"All test cases passed successfully!\")\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_secure_read_write_bus_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design a **parameterized read/write bus** in Verilog that ensures secure access through an **8-bit configurable key**. This module named `secure_read_write_bus_interface` will support both read and write operations, with authorization based on a comparison between the input key and an internal parameterized key.\n\n## Functional Requirements\n1. **Read and Write Operations**:\n   - The bus performs read or write actions based on an enable signal.\n   - Access is authorized only if the provided key matches an internal key, with errors flagged otherwise.\n\n## Input/Output Specifications\n\n### Inputs\n- `i_addr` (`p_addr_width bit`): Specifies the target address for read or write operations.\n- `i_data_in` (`p_data_width` bit): Data to be written during a write operation.\n- `i_key_in` (`8-bit`): Key provided by the initiator for operation authorization.\n- `i_read_write_enable` (`1-bit`): Specifies the requested operation; `1` for read, `0` for write.\n- `i_capture_pulse` (`1-bit`): Qualifies input capture for `i_addr`, `i_data_in`, `i_key_in`, and `i_read_write_enable`.\n- `i_reset_bar` (`1-bit`): Asynchronous, active-low reset to initialize internal states and registers.\n\n### Outputs\n- `o_data_out` (`p_data_width` bit): Data output during a read operation, valid only if the input key matches the internal key.\n- `o_error` (`1-bit`): Asserted if the input key is incorrect and dessert if input key is correct.\n\n## Behavioral Requirements\n\n### Write Operation\n- If `i_read_write_enable` is **0**, the bus interprets the operation as a write request.\n- At the rising edge of `i_capture_pulse`:\n  - If `i_key_in` matches the internal 8-bit configurable key, `i_data_in` is written to the address specified by `i_addr`.\n  - If `i_key_in` does not match the internal key:\n    - `o_error` is set to **1**.\n    - `o_data_out` is set to **0** (default).\n\n### Read Operation\n- If `i_read_write_enable` is **1**, the bus interprets the operation as a read request.\n- At the rising edge of `i_capture_pulse`:\n  - If `i_key_in` matches the internal key, data from address `i_addr` is output on `o_data_out`, and `o_error` is **0**.\n  - If `i_key_in` does not match:\n    - `o_error` is set to **1**.\n    - `o_data_out` remains **0**.\n\n## Parameterization Requirements\n- `p_configurable_key`: Internal 8-bit key, default value `8'hAA`.\n- `p_data_width`: Configurable data width, default is **8 bits**.\n- `p_addr_width`: Configurable address width, default is **8 bits**.\n\n## Additional Requirements\n1. **Edge Case Handling**:\n   - `i_reset_bar` reset signal should clear all internal registers and outputs when asserted low.\n   - Ensure that outputs default to `0` upon reset or when unauthorized access occurs.\n2. **Clocking and Timing**:\n   - Operations are gated by the positive edge of `i_capture_pulse` for both read and write actions.\n   - Timing for signal latching and error assertions should align with rising edges of `i_capture_pulse`.\n\n## Assumptions\n  - Assume all the inputs are synchronous to the `i_capture_pulse`", "context": {}}, "output": {"response": "", "context": {"rtl/secure_read_write_bus_interface.v": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/secure_read_write_bus_interface.v\nTOPLEVEL        = secure_read_write_bus_interface \nMODULE          = test_secure_read_write_bus_interface\nPYTHONPATH      = /src\nHASH            = 1-address-secured-read-and-write-bus", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()", "src/test_secure_read_write_bus_interface.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\n\nasync def reset_dut(dut):\n    \"\"\"Reset the DUT\"\"\"\n    dut.i_reset_bar.value =0\n    dut.i_addr.value =0\n    dut.i_data_in.value =0\n    dut.i_key_in.value =0\n    dut.i_read_write_enable.value =0\n    dut.i_capture_pulse.value =0\n\n    await FallingEdge(dut.i_capture_pulse)\n    dut.i_reset_bar.value = 1\n    await RisingEdge(dut.i_capture_pulse)\n\n\n@cocotb.test()\nasync def test_secure_read_write_bus_interface(dut):  # dut will be the object for RTL top.\n   \n\n    cocotb.start_soon(Clock(dut.i_capture_pulse, 10, units='ns').start())  # timeperiod= 10ns\n    # Reset the DUT\n    await reset_dut(dut)\n\n    \n    await FallingEdge(dut.i_capture_pulse)  #writing addr 1 with data 1, with correct key.\n    dut.i_addr.value =1\n    dut.i_data_in.value =1\n    dut.i_key_in.value =170\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #writing addr 2 with data 2, with correct key.\n    assert dut.o_error.value==0, f\"output should not be {dut.o_error.value}\"\n    assert dut.o_data_out.value==0, f\"output should not be {dut.o_data_out.value}\"\n    dut.i_addr.value =2\n    dut.i_data_in.value =2\n    dut.i_key_in.value =170\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #reading addr 1 with correct key.\n    assert dut.o_error.value==0, f\"output should not be {dut.o_error.value}\"\n    assert dut.o_data_out.value==0, f\"output should not be {dut.o_data_out.value}\"\n    dut.i_addr.value =1\n    dut.i_data_in.value =0\n    dut.i_key_in.value =170\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion of addr 1.reading addr 2 with correct key.\n    assert dut.o_data_out.value==1, f\"output should not be {dut.o_data_out.value}\"\n    assert dut.o_error.value==0, f\"output should not be {dut.o_error.value}\"\n    dut.i_addr.value =2\n    dut.i_data_in.value =0\n    dut.i_key_in.value =170\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion of addr 2.reading addr 2 with incorrect key.\n    assert dut.o_data_out.value==2, f\"output should not be {dut.o_data_out.value}\"\n    assert dut.o_error.value==0, f\"output should not be {dut.o_error.value}\"\n    dut.i_addr.value =2\n    dut.i_data_in.value =0\n    dut.i_key_in.value =172\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion of addr 2. #writing addr 1 with data 4, with incorrect key.\n    assert dut.o_data_out.value==0, f\"output should not be {dut.o_data_out.value}\"\n    assert dut.o_error.value==1, f\"output should not be {dut.o_error.value}\"\n    dut.i_addr.value =1\n    dut.i_data_in.value =4\n    dut.i_key_in.value =173\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #reading add 1, with correct key.\n    assert dut.o_data_out.value==0, f\"output should not be {dut.o_data_out.value}\"\n    assert dut.o_error.value==1, f\"output should not be {dut.o_error.value}\"\n    dut.i_addr.value =1\n    dut.i_data_in.value =0\n    dut.i_key_in.value =170\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion of addr 1. data should not change.reading addr 2 with correct key.\n    assert dut.o_data_out.value==1, f\"output should not be {dut.o_data_out.value}\"\n    assert dut.o_error.value==0, f\"output should not be {dut.o_error.value}\""}}}
{"id": "cvdp_copilot_secure_read_write_register_bank_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design a parameterized register bank module with secure access control in Verilog. The module named `secure_read_write_register_bank` should allow read and write operations only after unlocking, which requires specific values written to the first two addresses in sequence. Once unlocked, the register bank operates as specified below.\n\n## Parameter\n1.  **p_address_width**: The address width parameter with default value of 8 bits. It will be used to create the addressable space of register bank module.\n2.  **p_data_width**: The data width parameter with default value of 8 bits.\n3. **p_unlock_code_0**: The unlock code to be written at address zero. The default value is 0xAB.\n4. **p_unlock_code_1**: The unlock code to be written at address one. The default value is 0xCD.\n\n\n## Inputs\n1. **i_addr**: `p_addr_width`-bit input. Specifies the target address for read or write operations.\n2. **i_data_in**: `p_data_width`-bit input. Data input to be written to the register bank during a write operation.\n3. **i_read_write_enable**: 1-bit input control signal. Determines the operation type:\n   - `0`: Write operation.\n   - `1`: Read operation.\n4. **i_capture_pulse**: 1-bit capture pulse signal. Triggers the read or write operation on positive edge of this signal. It will act as clock for register bank.\n5.  **i_rst_n**: 1-bit asynchronous active low reset, to reset the unlock state machine\n\n## Outputs\n1. **o_data_out**: `p_data_width`-bit output. Data output bus that reflects the value read from the register bank during a read operation.\n\n## Functional Requirements\n\n### 1. Write Operation\n   - If **i_read_write_enable** is `0`, the module interprets this as a write operation.\n   - On the **rising edge** of **i_capture_pulse**, the value of **i_data_in** is written to the register at the address specified by **i_addr**.\n   - **o_data_out** should output `0` during write operations as a default state.\n\n### 2. Read Operation\n   - If **i_read_write_enable** is `1`, the module interprets this as a read operation.\n   - On the **rising edge** of **i_capture_pulse**, **o_data_out** outputs the data stored at the address specified by **i_addr**.\n   - **o_data_out** only reflects the read data during read operations.\n\n## Security Access Requirements\n1. **Unlocking Mechanism**:\n   - **To unlock the register bank**, two sequential operations must be completed:\n     - First, the specific **parameterized unlock code** (matching **p_data_width**) must be written to address `0`.\n     - Then, a specific **parameterized trigger code** must be written to address `1`.\n   - If both conditions are met, the register bank unlocks, enabling access to read and write for all addresses.\n   - If, at any positive edge of i_capture_pulse, values are written to address 0 or 1 does not equal to given parameterized unlock code, the register bank will reset, resulting in lock of register bank. User needs to unlock the register bank once again.\n   - If the unlock sequence is incomplete, access to other addresses will remain restricted as follows:\n     - **Read Operation**: Outputs `0` on **o_data_out**.\n     - **Write Operation**: Prevents writing to any address except `0` and `1`.\n   - When i_rst_n goes low, then this unlocking mechanism resets and user needs to unlock the register bank once again.\n\n2. **Restricted Access Addresses**:\n   - Addresses `0` and `1` are write-only and cannot be read.\n   - Other addresses remain inaccessible for both read and write until the unlock sequence is completed.\n\n## Constraints and Edge Cases\n- Ensure that addresses `0` and `1` cannot be read.\n- Any read or write attempt on other addresses before unlocking should default **o_data_out** to `0` and prevent writing, respectively.\n- The writing of address `0` and address `1` should be concurrent, else register bank should be locked.\n\n## Verification and Test Cases\n1. **Write Operation Test**: Verify that data can be written only after the register bank is unlocked.\n2. **Read Operation Test**: Confirm that data is output only on successful read operations.\n3. **Unlock Sequence Test**: Test various sequences to confirm that only the correct sequence unlocks the register bank.\n6. **Access Restriction Test**: Ensure that all addresses except `0` and `1` remain inaccessible until unlocked.", "context": {}}, "output": {"response": "", "context": {"rtl/secure_read_write_register_bank.v": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/secure_read_write_register_bank.v\nTOPLEVEL        = secure_read_write_register_bank \nMODULE          = test_secure_read_write_register_bank\nPYTHONPATH      = /src\nHASH            = 1-design-a-parameterized-register-bank-module-with-secure-access", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()", "src/test_secure_read_write_register_bank.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\n\nasync def reset_dut(dut):\n    \"\"\"Reset the DUT\"\"\"\n    dut.i_rst_n.value =0\n    dut.i_addr.value =0\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =0\n    dut.i_capture_pulse.value =0\n\n    await FallingEdge(dut.i_capture_pulse)\n    dut.i_rst_n.value = 1\n    await RisingEdge(dut.i_capture_pulse)\n\n\n@cocotb.test()\nasync def test_secure_read_write_register_bank(dut):  # dut will be the object for RTL top.\n   \n\n    cocotb.start_soon(Clock(dut.i_capture_pulse, 10, units='ns').start())  # timeperiod= 10ns\n    # Reset the DUT\n    await reset_dut(dut)\n\n    \n    await FallingEdge(dut.i_capture_pulse)  #stage one unlock\n    dut.i_addr.value =0\n    dut.i_data_in.value =171\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #stage two unlock\n    dut.i_addr.value =1\n    dut.i_data_in.value =205\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #unlocked, at address 2, data 2 witten\n    dut.i_addr.value =2\n    dut.i_data_in.value =2\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) # at address 3, data 3 witte\n    dut.i_addr.value =3\n    dut.i_data_in.value =3\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #read at address 2\n    dut.i_addr.value =2\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion at address 2, and read at address 3\n    assert dut.o_data_out.value==2, f\"output should not be {dut.o_data_out.value}\"\n    dut.i_addr.value =3\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion at address 3, and locks the bank\n    assert dut.o_data_out.value==3, f\"output should not be {dut.o_data_out.value}\"\n    dut.i_addr.value =0\n    dut.i_data_in.value =170\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #locked, reading at address 2. \n    dut.i_addr.value =2\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion at address 2 locked, and read at address 3\n    assert dut.o_data_out.value==0, f\"output should not be {dut.o_data_out.value}\"\n    dut.i_addr.value =3\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion at address 3 locked, and step 1 of unlock\n    assert dut.o_data_out.value==0, f\"output should not be {dut.o_data_out.value}\"\n    dut.i_addr.value =0\n    dut.i_data_in.value =171\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #read at address 2, locked\n    dut.i_addr.value =2\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion at address 2 locked, and read at address 3\n    assert dut.o_data_out.value==0, f\"output should not be {dut.o_data_out.value}\"\n    dut.i_addr.value =3\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion at address 3 locked, and step 2 of unlock\n    assert dut.o_data_out.value==0, f\"output should not be {dut.o_data_out.value}\"\n    dut.i_addr.value =1\n    dut.i_data_in.value =205\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) # read address 2, locked. unlock series broken.\n    dut.i_addr.value =2\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion at address 2 locked, and read at address 3\n    assert dut.o_data_out.value==0, f\"output should not be {dut.o_data_out.value}\"\n    dut.i_addr.value =3\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion at address 3 locked, and step 2 of unlock\n    assert dut.o_data_out.value==0, f\"output should not be {dut.o_data_out.value}\"\n    dut.i_addr.value =0\n    dut.i_data_in.value =171\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #stage two unlock\n    dut.i_addr.value =1\n    dut.i_data_in.value =205\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #unlocked, read at address 2.\n    dut.i_addr.value =2\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion at address 2, and read at address 0\n    assert dut.o_data_out.value==2, f\"output should not be {dut.o_data_out.value}\"\n    dut.i_addr.value =0\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion at address 0, and read at address 1\n    assert dut.o_data_out.value==0, f\"output should not be {dut.o_data_out.value}\"\n    dut.i_addr.value =1\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion at address 1, and incorrect unlock 1\n    assert dut.o_data_out.value==0, f\"output should not be {dut.o_data_out.value}\"\n    dut.i_addr.value =0\n    dut.i_data_in.value =170\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #in correct stage two unlock\n    dut.i_addr.value =1\n    dut.i_data_in.value =200\n    dut.i_read_write_enable.value =0\n    await FallingEdge(dut.i_capture_pulse) #locked, read at address 2.\n    dut.i_addr.value =2\n    dut.i_data_in.value =0\n    dut.i_read_write_enable.value =1\n    await FallingEdge(dut.i_capture_pulse) #assertion at address 2\n    assert dut.o_data_out.value==0, f\"output should not be {dut.o_data_out.value}\"\n    "}}}
{"id": "cvdp_copilot_sequencial_binary_to_one_hot_decoder_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design a parameterized binary-to-one-hot decoder module named `binary_to_one_hot_decoder_sequencial` in Verilog. This module will convert a binary-encoded input signal into a one-hot encoded output signal using **sequential logic**, synchronized with a clock. The design must include two parameters: `BINARY_WIDTH` and `OUTPUT_WIDTH`, to configure the width of the binary input and the one-hot encoded output, respectively.\n\n## Module Parameters  \n1. **`BINARY_WIDTH`**: Specifies the bit width of the binary input `i_binary_in`. This parameter determines the maximum binary value that can be decoded. Default: `BINARY_WIDTH=5`.  \n2. **`OUTPUT_WIDTH`**: Defines the width of the output `o_one_hot_out`, which should have `2^BINARY_WIDTH` bits if fully utilized. However, `OUTPUT_WIDTH` can be set independently to limit the number of one-hot output bits. Default: `OUTPUT_WIDTH=32`.\n\n## Inputs and Outputs  \n- **Inputs**:  \n  - `i_binary_in` (`BINARY_WIDTH` bits) \u2014 Binary input signal.  \n    - Represents a binary-encoded value up to `2^BINARY_WIDTH - 1`.  \n    - Example: For `BINARY_WIDTH = 5`, `i_binary_in` can range from `5'd0` to `5'd31`.  \n    - The input is sampled on the rising edge of `i_clk`.  \n  - `i_clk` (`1-bit`) \u2014 Clock signal (active on the rising edge).  \n  - `i_rstb` (`1-bit`)\u2014 Asynchronous reset signal (active low).\n\n- **Output**:  \n  - `o_one_hot_out` (`OUTPUT_WIDTH` bits) \u2014 One-hot encoded output signal from a sequential register of `OUTPUT_WIDTH` bits to hold state.  \n    - A one-hot encoded output where only the bit at index `i_binary_in` is set to `1`, with all other bits set to `0`.  \n    - Example: If `i_binary_in = 5'd3` and `OUTPUT_WIDTH = 32`, `o_one_hot_out` should output `00000000000000000000000000001000` on the next rising edge of `i_clk`.  \n\n## Behavioral Definition  \n- The module samples the input `i_binary_in` on the rising edge of `i_clk`.  \n- The output `o_one_hot_out` is updated on the same rising edge of `i_clk`.  \n- When `i_rstb` is asserted low, `o_one_hot_out` should asynchronously reset to all zeros.  \n\n### Illustrative Example  \nWith `i_binary_in = 3'd2`, `OUTPUT_WIDTH = 8`, and `i_clk` toggling:  \n- On the rising edge of `i_clk`, `i_binary_in` is sampled.  \n- On the same edge of `i_clk`, `o_one_hot_out` updates to `00000100`.  \n- If `i_rstb` is low at any time, `o_one_hot_out` is asynchronously reset to `00000000`.\n\n## Constraints and Edge Cases  \n1. **Parameter Constraints**:  \n   - Ensure that `BINARY_WIDTH` and `OUTPUT_WIDTH` are set such that `OUTPUT_WIDTH` is large enough to represent all values up to `2^BINARY_WIDTH - 1`.  \n   - Ensure i_binary_in is always less than 2^BINARY_WIDTH, as determined by the BINARY_WIDTH parameter. Inputs violating this constraint are considered invalid.  \n2. **Reset Behavior**: Confirm that when `i_rstb` is asserted low, the output `o_one_hot_out` resets to all zeros.  \n\n ", "context": {}}, "output": {"response": "", "context": {"rtl/binary_to_one_hot_decoder_sequential.v": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/binary_to_one_hot_decoder_sequential.v\nTOPLEVEL        = binary_to_one_hot_decoder_sequential\nMODULE          = test_binary_to_one_hot_decoder_sequential\nPYTHONPATH      = /src\nHASH            = 1-sequencial_binary_to_one_hot_decoder", "src/test_binary_to_one_hot_decoder_sequential.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\n\nasync def reset_dut(dut):\n    \"\"\"Reset the DUT\"\"\"\n    dut.i_rstb.value =0\n    dut.i_binary_in.value =0\n\n    await FallingEdge(dut.i_clk)\n    dut.i_rstb.value = 1\n    await RisingEdge(dut.i_clk)\n\n@cocotb.test()\nasync def test_binary_to_one_hot_decoder_sequential(dut):  # dut will be the object for RTL top.\n   # Generate clock\n    cocotb.start_soon(Clock(dut.i_clk, 10, units='ns').start())  # timeperiod= 10ns\n    # Reset the DUT\n    await reset_dut(dut)\n\n    \n    await FallingEdge(dut.i_clk)\n    dut.i_binary_in.value = 0\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==1, f\"output should not be {dut.o_one_hot_out.value}\"\n\n    dut.i_binary_in.value = 1\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==2, f\"output should not be {dut.o_one_hot_out.value}\"\n\n    dut.i_binary_in.value = 2\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==4, f\"output should not be {dut.o_one_hot_out.value}\"\n\n    dut.i_binary_in.value = 3\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==8, f\"output should not be {dut.o_one_hot_out.value}\"\n\n    dut.i_binary_in.value = 4\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==16, f\"output should not be {dut.o_one_hot_out.value}\"\n\n    dut.i_binary_in.value = 5\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==32, f\"output should not be {dut.o_one_hot_out.value}\"\n\n    dut.i_binary_in.value = 6\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==64, f\"output should not be {dut.o_one_hot_out.value}\"\n\n    dut.i_binary_in.value = 7\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==128, f\"output should not be {dut.o_one_hot_out.value}\"\n\n    dut.i_binary_in.value = 8\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==256, f\"output should not be {dut.o_one_hot_out.value}\"\n\n    dut.i_binary_in.value = 9\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==512, f\"output should not be {dut.o_one_hot_out.value}\"\n\n    dut.i_binary_in.value = 10\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==1024, f\"output should not be {dut.o_one_hot_out.value}\"\n    \n    dut.i_binary_in.value = 11\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==2048, f\"output should not be {dut.o_one_hot_out.value}\"\n\n    dut.i_binary_in.value = 12\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==4096, f\"output should not be {dut.o_one_hot_out.value}\"\n\n    dut.i_binary_in.value = 13\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==8192, f\"output should not be {dut.o_one_hot_out.value}\"\n\n    dut.i_binary_in.value = 14\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==16384, f\"output should not be {dut.o_one_hot_out.value}\"\n\n    dut.i_binary_in.value = 15\n    await FallingEdge(dut.i_clk)\n    assert dut.o_one_hot_out.value==32768, f\"output should not be {dut.o_one_hot_out.value}\"\n\n\n\n\n\n    \n    ", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_serial_in_parallel_out_0004", "categories": ["cid003", "easy"], "input": {"prompt": "Design an **8-bit Serial In Parallel Out (SIPO) shift register** that captures one bit of serial data on each rising edge of the clock signal and shifts this data into an 8-bit parallel output register. The design specification for the **8-bit SIPO shift register** is outlined below:\n\n## Design Specification:\n\nA **Serial In Parallel Out (SIPO) Shift Register** is a digital circuit that accepts a serial bitstream as input and outputs the data in parallel form after a series of clock cycles. It is often used in communication systems to convert data from a serial format (bit-by-bit) into a parallel format (multiple bits at once), which is useful for interfacing with parallel buses, memory systems, or storing data in registers.\n\n### Module Name:\n`serial_in_parallel_out_8bit`\n\n### Edge Cases:\n- **Initial State**: The initial content of the `parallel_out` register can be all x (unknown logic level), assuming no serial data has been shifted in yet. The system should handle this cleanly and shift in new data from the serial input as soon as clock pulses are received.\n- **Continuous Data Stream**: After the initial 8 clock cycles, new data from the serial input will continue to overwrite the oldest bits in the `parallel_out` register. The most significant bit (MSB) will be shifted out, and new data will shift in from the LSB.\n\n### Example Operations:\n\n#### Example 1: Serial Input Sequence (First 8 Bits)\n- **Serial Input Sequence**: `1, 0, 1, 1, 0, 0, 1, 0`\n- **Initial `parallel_out`**: `00000000`\n- **Clock Cycles**:\n  - After the first clock cycle: `parallel_out = 8'b00000001` (serial_in = 1)\n  - After the second clock cycle: `parallel_out = 8'b00000010` (serial_in = 0)\n  - After the third clock cycle: `parallel_out = 8'b00000101` (serial_in = 1)\n  - After the fourth clock cycle: `parallel_out = 8'b00001011` (serial_in = 1)\n  - After the fifth clock cycle: `parallel_out = 8'b00010110` (serial_in = 0)\n  - After the sixth clock cycle: `parallel_out = 8'b00101100` (serial_in = 0)\n  - After the seventh clock cycle: `parallel_out = 8'b01011001` (serial_in = 1)\n  - After the eighth clock cycle: `parallel_out = 8'b10110010` (serial_in = 0)\n\nAt the end of this 8-bit sequence, the `parallel_out` register will hold the value `10110010`.", "context": {"docs/Documentation.md": "# 8-bit Shift-Left Register with Positive-Edge Clock, Serial In, and Parallel Out #\n\nThis document describes the design and functionality of an 8-bit shift-left register implemented in Verilog. The module takes a serial input and provides a parallel output, shifting its contents left on each positive edge of the clock signal.\n\n## SIPO (Serial In, and Parallel Out) Specification ##\n\nInputs\n- **clock**: The clock signal that triggers the shift operation on its positive edge.\n- **serial_in**: The serial input bit to be shifted into the register.\n\nOutput\n- **parallel_out [7:0]**: An 8-bit parallel output representing the current state of the register.\n\n## Signals Table for 8-bit Shift-Left Register ##\n\n| **Signal Name** | **Direction** | **Width** | **Description**                         |\n|-----------------|---------------|-----------|-----------------------------------------|\n| clock           | Input         | 1 bit     | Clock signal that triggers the shift operation on its positive edge. |\n| serial_in       | Input         | 1 bit     | Serial input bit to be shifted into the register. |\n| parallel_out    | Output        | 8 bits    | 8-bit parallel output representing the current state of the register. |\n\n## SIPO (Serial In, and Parallel Out) Specification Description ##\n- **Clock Signal (`clock`)**: The register shifts its contents on the rising edge of this signal. The shift operation only occurs during the transition from low to high of the clock signal.\n- **Serial Input (`serial_in`)**: This single-bit input is shifted into the least significant bit (LSB) of the register on each clock pulse.\n- **Parallel Output (`parallel_out`)**: This is an 8-bit wide output that holds the current value of the register. It updates on each positive clock edge to reflect the shifted contents.\n\n## SIPO (Serial In, and Parallel Out) Functional Overview ##\n- On every positive edge of the clock signal, the register's contents are shifted one position to the left.\n- The bit in `serial_in` is placed in the least significant bit position (`parallel_out[0]`).\n- The most significant bit (`parallel_out[7]`) is discarded during the shift operation.\n- The new value of the register is available at the parallel output (`parallel_out`).\n\n"}}, "output": {"response": "", "context": {"rtl/serial_in_parallel_out_8bit.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/serial_in_parallel_out_8bit.sv\nTOPLEVEL        = serial_in_parallel_out_8bit\nMODULE          = test_sipo\nPYTHONPATH      = /src\nHASH            = 6846edfd8f186c108123d110f845f9191eb5ff22", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport re\nimport logging\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()", "src/test_sipo.py": "import cocotb\nimport os\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer, Join\nimport random\n\n# ----------------------------------------\n# - Tests\n# ----------------------------------------\n\n##Test 1 with a randomly generated 8-bit value\n@cocotb.test()\nasync def test_sipo_1(dut):\n    \n    # Start clock thread\n    cocotb.start_soon(Clock(dut.clock, 10, units='ns').start())\n\n    # Generate 8-bit data to be sent serially to SIPO shift register\n    reg_data = int((1.0 - random.random()) * 2 ** 8);\n    print(\"reg_data_1 \",bin(reg_data))\n    \n    for i in range(8):\n       \n        dut.serial_in.value = ((reg_data << i) & 0x80 ) >> 7\n        await FallingEdge(dut.clock)\n        \n        print(\"Bit \",i,\" \",dut.serial_in.value)\n        \n    print(\"The parallel out data is \", dut.parallel_out.value)\n    assert reg_data == int(dut.parallel_out.value), f\"The 8-bit register output doesn't match with the expected value\"\n\n\n##Test 2 with a fixed 8-bit value\n@cocotb.test()\nasync def test_sipo_2(dut):\n    \n    # Start clock thread\n    cocotb.start_soon(Clock(dut.clock, 10, units='ns').start())\n\n    # 8-bit data to be sent serially to SIPO shift register\n    reg_data = int(100)\n    print(\"reg_data_2 \",bin(reg_data))\n    \n    for i in range(8):\n        \n        dut.serial_in.value = ((reg_data << i) & 0x80 ) >> 7\n        await FallingEdge(dut.clock)\n        print(\"Bit \",i,\" \",dut.serial_in.value)\n        \n    print(\"The parallel out data is \", dut.parallel_out.value)\n    assert reg_data == int(dut.parallel_out.value), f\"The 8-bit register output doesn't match with the expected value\"\n\n\n##Test 3 with a randomly generated 8-bit value    \n@cocotb.test()\nasync def test_sipo_3(dut):\n    \n    # Start clock thread\n    cocotb.start_soon(Clock(dut.clock, 10, units='ns').start())\n\n    # Generate 8-bit data to be sent serially to SIPO shift register\n    reg_data = int((1.0 - random.random()) * 2 ** 8);\n    print(\"reg_data_3 \",bin(reg_data))\n    \n    for i in range(8):\n        \n        dut.serial_in.value = ((reg_data << i) & 0x80 ) >> 7\n        await FallingEdge(dut.clock)\n        print(\"Bit \",i,\" \",dut.serial_in.value)\n        \n    print(\"The parallel out data is \", dut.parallel_out.value)\n    assert reg_data == int(dut.parallel_out.value), f\"The 8-bit register output doesn't match with the expected value\"\n"}}}
{"id": "cvdp_copilot_set_bit_calculator_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design a **Set Bit Calculator** module in verilog that counts the number of `1` bits (set bits) in a bitstream received at the positive edge of a clock signal (`i_clk`) when the `i_ready` signal is asserted. The output count (`o_set_bit_count`) will be updated until the `i_ready` signal deasserts, at which point the output reflects the total count of `1` bits received. The count resets to `0` when the `i_ready` signal asserts again or an asynchronous active-low `i_rst_n` signal is triggered.\n\n## Parameters\n- `p_max_set_bit_count_width` (default = 8): The maximum bit-width of `o_set_bit_count`. This limits the count value to `2^p_max_set_bit_count_width - 1`.\n\n## Input/Output Specifications\n### Inputs:\n- `i_bit_in` (1 bit): The single-bit stream input.\n- `i_clk` (1 bit): Clock signal for synchronization.\n- `i_ready` (1 bit): Synchronous signal that enables bit counting when asserted (`1`).\n- `i_rst_n` (1 bit): Active-low asynchronous reset signal.\n\n### Outputs:\n- `o_set_bit_count` (`p_max_set_bit_count_width` bits): Total count of `1` bits received in the bitstream since the last reset or `i_ready` assertion. If the count exceeds the maximum value (`2^p_max_set_bit_count_width - 1`), it saturates.\n\n## Assumptions and Constraints\n1. The bit count updates only when `i_ready` is high and `i_bit_in` is sampled on the rising edge of `i_clk`.\n2. The count halts and retains its value when `i_ready` deasserts.\n3. The count resets to `0` when:\n   - `i_rst_n` is asserted low (asynchronous reset).\n   - `i_ready` asserts again after being deasserted.\n4. It saturates at this maximum value if the count exceeds `2^p_max_set_bit_count_width - 1`.\n5. The 1st bit after `i_ready` goes high will be ignored for set bit calculation.\n\n## Behavioral Definitions\n1. When `i_rst_n` is low, the `o_set_bit_count` must asynchronously reset to `0`.  \n2. On the positive edge of `i_clk`, if `i_ready` is high, `o_set_bit_count` increments by 1 for each `i_bit_in` that is `1`, up to the saturation limit.  \n3. When `i_ready` transitions from low to high, the `o_set_bit_count` resets to `0`.  \n\n## Timing and Synchronization\n1. `i_ready` is synchronous to `i_clk`.  \n2. `i_rst_n` is asynchronous and active-low.  \n3. Counting occurs on the rising edge of `i_clk` when `i_ready` is high.  \n\n## Task Requirements\n1. Define a Verilog module named `SetBitStreamCalculator`.  \n2. Implement the behavior described using sequential logic.  \n3. Include:\n   - Handling of the asynchronous reset.\n   - Proper synchronization for `i_ready`.\n   - Saturation logic for `o_set_bit_count` based on `p_max_set_bit_count_width`.\n4. Provide a testbench to validate:\n   - Reset functionality (`i_rst_n`).\n   - Behavior during `i_ready` assertion and deassertion.\n   - Correct counting of `1` bits in the input stream.\n\n## Example Scenarios\n### Scenario 1: Counting set bits with default `p_max_set_bit_count_width = 8`\n**Inputs:**  \n- `i_clk = 50 MHz`, `i_ready = 1`, `i_rst_n = 1`, `i_bit_in` transitions: `1, 0, 1, 1` (sampled on `i_clk`).  \n**Output:**  \n- `o_set_bit_count = 3` after the last bit.\n\n### Scenario 2: Reset Behavior  \n**Inputs:**  \n- `i_rst_n` transitions low while counting.  \n**Output:**  \n- `o_set_bit_count` resets to `0` immediately.\n\n### Scenario 3: Saturation at maximum count  \n**Inputs:**  \n- `p_max_set_bit_count_width = 4` (maximum value = 15).  \n- `i_clk = 50 MHz`, `i_ready = 1`, `i_rst_n = 1`, `i_bit_in` transitions: `16 consecutive 1's`.  \n**Output:**  \n- `o_set_bit_count = 15` (saturation).\n\n## Testbench Considerations\n- Test combinations of `i_bit_in` and `i_ready` signal behavior:\n  - `i_ready` deasserted in the middle of counting.\n  - Multiple transitions of `i_rst_n` during operation.\n- Verify `o_set_bit_count` updates correctly with `i_bit_in` sampled on `i_clk`.\n- Test for saturation when `o_set_bit_count` reaches the maximum value defined by `p_max_set_bit_count_width`.", "context": {}}, "output": {"response": "", "context": {"rtl/SetBitStreamCalculator.v": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/SetBitStreamCalculator.v\nTOPLEVEL        = SetBitStreamCalculator \nMODULE          = test_SetBitStreamCalculator\nPYTHONPATH      = /src\nHASH            = 1-set-bit-calculator-streaming-bit-input", "src/test_SetBitStreamCalculator.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\n\nasync def reset_dut(dut):\n    \"\"\"Reset the DUT\"\"\"\n    dut.i_rst_n.value =0\n    dut.i_ready.value =0\n    dut.i_bit_in.value =0\n\n    await FallingEdge(dut.i_clk)\n    dut.i_rst_n.value = 1\n    await RisingEdge(dut.i_clk)\n\n\n@cocotb.test()\nasync def test_unique_number_identifier(dut):  # dut will be the object for RTL top.\n   \n\n    cocotb.start_soon(Clock(dut.i_clk, 10, units='ns').start())  # timeperiod= 10ns\n    # Reset the DUT\n    await reset_dut(dut)\n\n    \n    await FallingEdge(dut.i_clk)\n    dut.i_ready.value = 1\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    dut.i_ready.value = 0\n    await FallingEdge(dut.i_clk)\n    assert dut.o_set_bit_count.value==8, f\"output should not be {dut.o_set_bit_count.value}\"\n    await FallingEdge(dut.i_clk)\n    assert dut.o_set_bit_count.value==8, f\"output should not be {dut.o_set_bit_count.value}\"\n    await FallingEdge(dut.i_clk)\n    assert dut.o_set_bit_count.value==8, f\"output should not be {dut.o_set_bit_count.value}\"\n    await FallingEdge(dut.i_clk)\n    assert dut.o_set_bit_count.value==8, f\"output should not be {dut.o_set_bit_count.value}\"\n    await FallingEdge(dut.i_clk)\n    assert dut.o_set_bit_count.value==8, f\"output should not be {dut.o_set_bit_count.value}\"\n    await FallingEdge(dut.i_clk)\n    dut.i_ready.value = 1\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 1\n    await FallingEdge(dut.i_clk)\n    dut.i_bit_in.value = 0\n    dut.i_ready.value = 0\n    await FallingEdge(dut.i_clk)\n    assert dut.o_set_bit_count.value==8, f\"output should not be {dut.o_set_bit_count.value}\"\n    await FallingEdge(dut.i_clk)\n    assert dut.o_set_bit_count.value==8, f\"output should not be {dut.o_set_bit_count.value}\"\n    await FallingEdge(dut.i_clk)\n    assert dut.o_set_bit_count.value==8, f\"output should not be {dut.o_set_bit_count.value}\"\n    await FallingEdge(dut.i_clk)\n    assert dut.o_set_bit_count.value==8, f\"output should not be {dut.o_set_bit_count.value}\"\n    await FallingEdge(dut.i_clk)\n    assert dut.o_set_bit_count.value==8, f\"output should not be {dut.o_set_bit_count.value}\"\n    await FallingEdge(dut.i_clk)\n    dut.i_ready.value = 1\n    dut.i_bit_in.value = 1\n    for i in range(260):\n        await FallingEdge(dut.i_clk)\n    assert dut.o_set_bit_count.value==255, f\"output should not be {dut.o_set_bit_count.value}\"\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()"}}}
{"id": "cvdp_copilot_sorter_0001", "categories": ["cid003", "easy"], "input": {"prompt": "Design an RTL module named `sorting_engine` in SystemVerilog that receives an array of unsigned integers as input, sorts them using the bubble sort algorithm, and then provides the sorted array as output. The module should be driven by a clock, have a reset mechanism, and provide a control signal to indicate when sorting is complete. Sorting should arrange the elements of the array in ascending order, such that the smallest element is at index 0 and the largest element is at index N\u22121.\n\nBubble sort is a straightforward sorting algorithm that works by repeatedly comparing adjacent elements in an array and swapping them if they are out of order. Through multiple passes over the array, larger values \"bubble\" up toward the end of the array, while smaller values move toward the beginning. Eventually, after enough passes, the entire array becomes sorted. For this implementation perform (N)*(N-1) passes to sort the array of N elements. \n\n**Parameters**\n- `N`  (Default is 8, Greater than 0): Number of elements to sort\n- `WIDTH`(Default is 8, Greater than 0): Bit-width of each input element\n\n**Port List**\n| Port Name               | Direction | Width          | Description                                                                                                                                                                                                                                                              |\n|-------------------------|-----------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `clk`                   | input     | 1 bit          | Main clock input. All operations occur on the rising edge of this signal.                                                                                                                                                                                                |\n| `rst`                   | input     | 1 bit          | Active high, asynchronous reset. When asserted, resets the internal state machine and registers to their initial states.                                                                                                                                                 |\n| `start`                 | input     | 1 bit          | Active high, pulse start signal to indicate that the input data is valid and that sorting should begin on the next clock cycle.                                                                                                                                          |\n| `[N*WIDTH-1:0] in_data` | input     | N * WIDTH bits | Input data bus containing the entire unsorted array. Each element has WIDTH bits, and there are N elements.                                                                                                                                                              |\n| `done`                  | output    | 1 bit          | Active high pulse, asserted for 1 clock cycle when the sorting is complete, indicating that `out_data` is now valid and stable. It will be set to 0 in case of a reset.                                                                                                  |\n| `[N*WIDTH-1:0] out_data`| output    | N * WIDTH bits | Output data bus containing the sorted array. This is to be left uninitialized at reset and updated only when sorting a valid input is complete. Valid once `done` is asserted, and maintains previous values until the update from the next sorting operation completes. |\n\nCreate the design using a state machine with `IDLE`, `SORTING`, and `DONE` states. The FSM transitions from `IDLE` to `SORTING` when the start signal is asserted, cycles through the comparisons and swaps, and eventually moves to `DONE` when sorting is complete.\n\n- **Latency and Timing**: Each comparison and potential swap will take one clock cycle. Bubble sort in hardware will, by default, consume multiple cycles, as it effectively simulates the step-by-step iterative nature of the algorithm. Ensure that the design handles the expected cycle counts. The done signal should be asserted only after the last pass is complete. Latency should be equal to (N)*(N-1)+2 for an array with `N` elements.\n  \n- **Output**: Once the sorting finishes, present the sorted array at the output port. This involves placing the sorted values back onto an output bus.\n\n- Assume that all the numbers will be non negative integers.", "context": {}}, "output": {"response": "", "context": {"rtl/sorting_engine.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n\n", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sorting_engine.sv\nTOPLEVEL        = sorting_engine\nMODULE          = test_sorting_engine\nPYTHONPATH      = /src\nHASH            = 1-bubble-sort-rtl", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner(WIDTH: int=5,N: int=4):\n    \n    parameter = {\"WIDTH\":WIDTH, \"N\":N}\n    # Debug information\n    print(f\"[DEBUG] Running simulation with WIDTH={WIDTH}, N={N}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        parameters=parameter,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n# Parametrize test for different WIDTH and SIGNED_EN\n@pytest.mark.parametrize(\"WIDTH\", [4,8,12,16])\n@pytest.mark.parametrize(\"N\", [4,8,12,16])\n\ndef test_gcd(WIDTH,N):\n    # Run the simulation with specified parameters\n    test_runner(WIDTH=WIDTH,N=N)", "src/test_sorting_engine.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n@cocotb.test()\nasync def test_sorter_dynamic_latency(dut):\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n    clk_period = 10  # ns\n    random.seed(0)  # For reproducibility\n\n    async def clock():\n        while True:\n            dut.clk.value = 0\n            await Timer(clk_period/2, units='ns')\n            dut.clk.value = 1\n            await Timer(clk_period/2, units='ns')\n\n    cocotb.start_soon(clock())\n\n    await reset_dut(dut, 5)\n    dut.start.value = 0\n\n    async def run_test_case(name, input_array):\n        cocotb.log.info(f\"Running Test: {name}\")\n        packed_input = 0\n        for idx, val in enumerate(input_array):\n            packed_input |= (val << (idx * WIDTH))\n        dut.in_data.value = packed_input\n\n        expected_steps = simulate_bubble_sort_steps(input_array, no_early_termination=True) + 2\n\n        await RisingEdge(dut.clk)\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        cycle_count = 0\n        while True:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n            if dut.done.value == 1:\n                break\n\n        out_data_val = int(dut.out_data.value)\n        output_array = [ (out_data_val >> (i * WIDTH)) & ((1 << WIDTH) - 1) for i in range(N)]\n        expected_output = sorted(input_array)\n\n        assert output_array == expected_output, f\"[{name}] Output incorrect. Got: {output_array}, Expected: {expected_output}\"\n        assert cycle_count == expected_steps, f\"[{name}] Latency mismatch. Got {cycle_count}, Expected {expected_steps}\"\n        cocotb.log.info(f\"Test {name} passed.\")\n\n    # Corner Cases\n    if N == 1:\n        await run_test_case(\"Single Element\", [10])\n\n    await run_test_case(\"Already Sorted\", list(range(N)))\n    await run_test_case(\"Reverse Sorted\", list(range(N-1, -1, -1)))\n    await run_test_case(\"All Duplicates\", [5]*N)\n    await run_test_case(\"All Max Values\", [(1 << WIDTH) - 1]*N)\n    await run_test_case(\"All Min Values\", [0]*N)\n    # Mixed min/max pattern\n    await run_test_case(\"Min-Max Alternating\", [0 if i % 2 == 0 else (1 << WIDTH)-1 for i in range(N)])\n\n    # Partial sorted (first half sorted, second half random)\n    half_sorted = list(range(N//2)) + [random.randint(0, (1 << WIDTH)-1) for _ in range(N - N//2)]\n    await run_test_case(\"Half Sorted\", half_sorted)\n\n    # Stress Testing with multiple random arrays\n    # Increase the count for more thorough stress tests\n    stress_test_count = 20\n    for idx in range(stress_test_count):\n        arr = [random.randint(0, (1 << WIDTH)-1) for _ in range(N)]\n        await run_test_case(f\"Random {idx}\", arr)\n\n    cocotb.log.info(\"All tests completed successfully!\")\n\n\ndef simulate_bubble_sort_steps(arr, no_early_termination=False):\n    N = len(arr)\n    # Given the DUT does no early termination, it always does (N-1)*(N-1) steps.\n    # If no_early_termination is True, ignore input and return full passes.\n    if no_early_termination:\n        return (N)*(N-1)\n\n    # If we were to consider early termination logic, it would go here.\n    return (N)*(N-1)\n\n\nasync def reset_dut(dut, duration):\n    dut.rst.value = 1\n    for _ in range(duration):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n"}}}
{"id": "cvdp_copilot_static_branch_predict_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Develop a SystemVerilog RTL module `static_branch_predict` that takes a 32-bit branch or jump RISC-V instruction as input and predicts whether that branch will occur based on the conditions indicated in the instruction. The design must be based on RISC-V Instruction Set Architecture (ISA).\n\n## Design Specification:\nThe `static_branch_predict` module takes in a 32-bit RV32I (RISC V 32-bit base Integer ISA) conditional branch and unconditional jump instructions as input. This module generally exists as part of the Instruction Fetch Stage of a pipelined processor. The branch and jump instruction can be either from the RV32I Instruction Set or from the RV32C Instruction Set. The branch and jump instructions as part of the RV32I Instruction Set are 32-bit in width, whereas those belonging to the RV32C Instruction Set are 16-bit in width. The 16-bit RV32C branch and jump instructions are converted into an equivalent 32-bit RV32I instruction using a specialized circuit called Instruction Decompresser before being applied to this module. For the module to recognize the 32-bit equivalent of the 16-bit branch and jump instructions, the inputs are properly formatted into a 32-bit value and applied. The Instruction Decompresser is not instantiated into the branch predictor module. Based on the instruction's offset in the case of the branch instruction and based on instruction in the case of a jump instruction, the branch predictor outputs two signals (i) a 1-bit signal to indicate whether the branching will occur for a given instruction or not (ii) If branching occurs, to which 32-bit address it has to get branched.\n\n## Key Assumptions and Constraints:\n- Only uncompressed 32-bit instructions are applied as input to this module.\n- The module operates in a purely combinational manner without requiring any state elements such as registers.\n- The Instruction Decompressor is outside the scope of this module, and the equivalent 32-bit uncompressed instruction is \n  given as input.\n\n### Introduction to RISC V:\nRISC-V is a royalty-free open-source instruction set architecture, which anyone can utilize to implement a processor microarchitecture (i.e. processor hardware). The RISC-V ISA consists of three variants of Integer ISA namely RV32I (32-bit instructions to handle 32-bit data), RV64I (32-bit instructions to handle 64-bit data), and RV128I (32-bit instructions to handle 128-bit data). In addition to these, there are 14 extensions. One of the extensions that will be considered in this module is RV32C (16-bit ISA called Compressed RISC-V ISA)\n\n## RV32I Branch and Jump Instructions\nThe RISC-V RV32I instruction set includes both unconditional jump and conditional branch instructions. Below, we describe the encodings and behaviors for these types of instructions.\n### Unconditional Jump Instructions(JAL and JALR)\n`JAL` (Jump and Link instruction):\n    -  Branches to an address obtained by adding the 32-bit program counter (pc) to a sign-extended 20-bit offset encoded in the instruction.\n    -  Returns to resume execution from the address stored in the 32-bit link register (x1 or x5) after completing the branched subroutine. A link register (also called a return address register) is the one that holds the address from where the processor has to resume its execution after returning from a subroutine. \nInstruction Encoding:\n\n\n| 31          | 30 - 21           | 20              | 19 : 12       | 11:7 | 6 - 0  |\n| :---------  | :------------------| :------------- | :-------------- | :----- |--------\n|imm[20]   | imm[10:1]      | imm[11]     |imm[19:12]  | rd     |7'h6F  |\n            \nAssembler syntax for JAL instruction :  jal  rd ,  imm[20:1]\n           \nTarget Address  calculated for this instruction : \n\nrd <--- pc + {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 };\n\nwhere {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 } - 32-bit sign extended offset or immediate. \nHere, `rd` is a 5-bit number to identify the 32-bit destination register; `pc` - 32-bit program counter.\n  \n`JALR` (Jump and Link Register instruction): \n - Branches to an address obtained by adding the 32-bit program counter to a sign-extended 12-bit offset present in a register specified in the instruction.\n\nThe instruction encoding for 32-bit uncompressed JALR instruction \n \n| 31 - 20     | 19 - 15  | 14 - 12 | 11 - 7  | 6 - 0  |\n| :---------  | :------- | :------ | :------ | :----- |\n| imm[11:0]   | rs1      | 000     | rd      | 7'h67  |\n             \n            \nAssembler syntax for JAL instruction:  jalr  rd,  rs1, imm[11:0]  \n\nTarget address calculated for this instruction : \nrd <-pc + {{20{instr[31]}}, instr[31:20]} + rs1\n                           \nwhere \n {{20{instr[31]}}, instr[31:20]} + rs1 - 32-bit sign extended offset or immediate                          \nHere `rd` is the 5-bit number to identify a 32-bit destination register; `rs1` is the 5-bit number to identify the 32-bit source register; `pc` - 32-bit program counter\n                           \n### Conditional Branch Instructions (BXXX) :\n  - Takes in two operands (rs1 and rs2), compares them, and branches based on the comparison result.\n  - The target address is obtained by adding the pc to a sign-extended 12-bit offset encoded in the instruction.\n\n The instruction encoding for the 32-bit uncompressed Branch instruction\n \n | 31        | 30 - 25   | 24 - 20  | 19 - 15  | 14 - 12 | 11 - 8   | 7       | 6 - 0  |\n| :-------- | :-------- | :------- | :------- | :------ | :------- | :------ | :----- |\n| imm[12]   | imm[10:5] | rs2      | rs1      | func3   | imm[4:1] | imm[11] | 7'h63  |\n     \n          \nAssembler syntax for Branch instruction:  bxxx rs1, rs2, offset\n        \nHere `rs1` and `rs2`  are the 5-bit numbers to identify the 32-bit source registers which will be used for comparison\n        \nTarget address calculated for this instruction : \npc + { {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 };\n\nwhere,\n{ {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 } - 32-bit sign extended offset or immediate; `pc` - 32-bit program counter\n\nThe different types of branch instruction :\n- beq    rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b000)\n- bne    rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b001)\n- blt      rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b100)\n- bltu    rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b110)\n- bge    rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b101)\n- bgeu  rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b111)\n                               \n ## RV32C Branch and Jump Instructions :\n The RV32C compressed instructions are 16-bit wide, but before applying them to this module, they are converted to their equivalent 32-bit uncompressed form using an external decompressor circuit. The following sections describe how these instructions are handled.\n \n   \n ### C.J / C.JAL Instructions: \n  - Equivalent to the RV32I JAL instruction, with different function codes.\n    \nThe instruction encoding for the 16-bit compressed jump instruction is given below:\n\n| 15 - 13  | 12 - 2                  | 1 - 0 |\n| :------- | :---------------------: | :---- |\n| func3    | imm[11:1]               | 01    |\n               \n  \nAssembler syntax for C.J  instruction:   c.j offset[11:1]\nAssembler syntax for C.JAL instruction:  c.jal offset [11:1]\n             \n`func3` is a 3-bit code that differentiates between C.J and C.JAL instruction.\nThe 3-bit function code for C.J is 101 and C.JAL is 001.\n  \nIts equivalent 32-bit uncompressed instruction encoding is given by :\n \n| 31          | 30          | 29 - 28      | 27          | 26          | 25          | 24          | 23 - 21     | 20 - 12           | 11 - 8  | 7            | 6 - 0  |\n| :---------- | :---------- | :----------- | :---------- | :---------- | :---------- | :---------- | :---------- | :---------------- | :------ | :---------- | :----- |\n| instr_c[12] | instr_c[8]  | instr_c[10:9]| instr_c[6]  | instr_c[7]  | instr_c[2]  | instr_c[11] | instr_c[5:3]| {9{instr_c[12]}}  | 4'b0000 | ~instr_c[15]| 7'h6F  |\n              \n   \n   Only C.J and C.JAL instructions are supported by this module.\n   \n   Other Compressed Jump Instructions that RV32C supports are C.JR and C.JALR, but these are not being tested by the module.\n   \n### C.BEQZ / C.BNEZ Instructions:\n\nEquivalent to the RV32I BXXX instructions but check whether the content of the specified register(rs1') is zero or not.\n                                               \nThe instruction encoding for the 16-bit compressed branch instruction is given below:\n\n| 15 - 13 | 12 - 10  | 9 - 7   | 6 - 3   | 2      | 1 - 0 |\n| :------ | :------- | :------ | :------ | :----- | :---- |\n| func3   | imm[8:6] | rs1'    | imm[4:1]| imm[5] | 01    |\n\n- func3 is a 3-bit code that differentiates between C.BEQZ and C.BNEZ instruction\n- The 3-bit function code for Compressed Branch EQual Zero (C.BEQZ) is 110 and that of Compressed Branch Not \n   Equal Zero (C.BNEZ) is 111\n \n Assembler syntax for C.BEQZ instruction:  c.beqz rs1' , offset[8:1]\n Assembler syntax for C.BNEZ instruction:  c.bnez rs1', offset[8:1]\n          \n Its equivalent 32-bit uncompressed instruction encoding is given by :\n      | 31 - 28         | 27 - 26       | 25            | 24 - 20     | 19 - 18     | 17 - 15     | 14 - 13     | 12            | 11 - 10       | 9 - 8       | 7            | 6 - 0  |\n| :-------------- | :------------ | :------------ | :---------- | :---------- | :---------- | :---------- | :------------ | :------------ | :---------- | :---------- | :----- |\n| {4{instr_c[12]}}| instr_c[6:5]  | instr_c[2]    | 5'b00000    | 2'b01       | instr_c[9:7]| 2'b00       | instr_c[13]   | instr_c[11:10]| instr_c[4:3]| instr_c[12] | 7'h63  |\n\n\n### Only Supported Instructions\n- The following instructions are supported by this module:\n\n  - Uncompressed Instructions: JAL, JALR, BXXX.\n  - Compressed Instructions: C.J, C.JAL, C.BEQZ, C.BNEZ.\n  - For all other instructions, fetch_valid_i will be 0, indicating that they will not be predicted as taken.\n\n\n \n### Concept of Sign Extension of Immediate(or Offset) in the RISC V Control Transfer Instruction :\n\nSign extension refers to identifying the sign bit of an operand and replicating it at the higher significant positions to increase the operand width to the desired value.\nIllustration :\nSuppose there is 8-bit data, data[7:0], say 8'b0110_1110. Suppose this has to be stored in a 32-bit register rd.\n\n| Bit Position    | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |\n| :-------------: |:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n| Bit Value       | 0  | 1  | 1  | 0  | 1  | 1  | 1  | 0  |\n\n                \nHere the bit at position 7 is called sign-bit; Since it is 0, it indicates that it is a positive value. Hence, will be replicated in the higher 24-bit positions (i.e. from bit position 8 to bit position 31) to form a 32-bit value. This is represented in shorthand as\n                                                      rd <---  {{24{0}} , data_i[7:0]};\n                                                      \n### Static Branch Prediction Algorithm :\n### For Branch Instruction:\n- Immediate Extraction:\n    Extract the immediate value from the branch instruction.\n- Sign Extension:\n    Sign extend the immediate to 32 bits.\n- Prediction Logic and Target Address Calculation:\n   If the sign bit of the immediate is 1, the branch is predicted to be taken.\n   Otherwise, it is predicted as not taken.\n   The 32-bit program counter is added to the sign-extended offset or sign-extended immediate to form the target address\n\n### For Jump Instruction:\n- Immediate Extraction:\n   Extract the immediate value from the jump instruction.\n- Sign Extension:\n  Sign extend the immediate to 32 bits.\n- Prediction Logic and Target Address Calculation:\n   Always predict jumps (JAL, JALR, C.J, C.JAL) as taken.\n   The 32-bit program counter is added to the sign-extended offset or sign-extended immediate to form the target address\n\n## What do the words `taken` and `not-taken` signify in case of branch prediction :\n- Taken: The branch will occur, and execution will continue at the target address.   \n- Not-Taken: The branch will not occur, and execution continues sequentially.\n           \n### Interface :\n\n#### Inputs:\n- `fetch_rdata_i` ([31:0], 32-bit): The fetched instruction data from the instruction memory or pipeline.\n- `fetch_pc_i` ([31:0], 32-bit): Program counter (PC) value of the fetched instruction.\n- `fetch_valid_i` (1-bit): Active HIGH Indicates the validity of the fetched instruction.\n\n#### Outputs:\n- `predict_branch_taken_o` (1-bit): Active HIGH indicates whether the branch or jump is predicted as taken.\n- `predict_branch_pc_o` ([31:0], 32-bit): Predicted target address for a taken branch or jump instruction\n                        \n### Internal registers and parameters:\n\n#### Localparams :\n -  OPCODE_BRANCH = 7'h63\n -  OPCODE_JAL          = 7'h6F;\n -  OPCODE_JALR       = 7'h67;\n\n#### Immediate:\n- `imm_j_type` ([31:0], 32-bit): Immediate for uncompressed jump (JAL) instructions, sign-extended.\n- `imm_b_type` ([31:0], 32-bit): Immediate for uncompressed branch instructions, sign-extended.\n- `imm_cj_type` ([31:0], 32-bit): Immediate for compressed jump instructions, sign-extended.\n- `imm_cb_type` ([31:0], 32-bit): Immediate for compressed branch instructions, sign-extended.\n- `branch_imm` ([31:0], 32-bit): One of the immediate values: `imm_j_type` or `imm_b_type` or `imm_cj_type` or `imm_cb_type`.\n\n### Signals and Logic :\n#### Control Signals:\n- `instr` ([31:0], 32-bit): Alias for the input `fetch_rdata_i` to simplify the code.\n- `instr_j`, `instr_b`, `instr_cj`, `instr_cb` (1-bit each): Signals to identify specific branch or jump types in compressed and uncompressed formats.\n- `instr_b_taken` (1-bit): Indicates whether an uncompressed or compressed branch offset is negative, implying that the branch is taken.\n\n#### Combinational Logic\n- `Immediate Extraction`: The immediate branches and jumps are extracted from the instruction, with an appropriate sign extension based on the instruction type.\n- `Instruction Type Decoding`: Decodes whether the instruction is an uncompressed branch (instr_b), uncompressed jump (instr_j), compressed branch (instr_cb), or compressed jump (instr_cj) based on opcode and bit patterns.\n- `Target Address Calculation`: Determines the branch offset and computes the target PC for the predicted branch or jump.\n\n#### Branch Prediction:\n\n-  `Uncompressed Branch/Jump Detection`: Detection of uncompressed instructions (JAL, JALR, BXXX) uses opcode\n   matching to identify the instruction type.\n\n- `Compressed Branch/Jump Detection`: Compressed branch/jump instructions (C.J, C.JAL, C.BEQZ, C.BNEZ) are provided\n  in their 32-bit uncompressed form. This module directly uses opcodes and fields from the uncompressed equivalent\n  to determine the offset and perform the prediction.\n  \n- `Offset-Based Prediction`:Branches are predicted as taken if the offset is negative. This predictions are assigned to \n   the signal `instr_b_taken`.\n\n\n#### Branch or Jump Prediction:\n\n- For jumps (`instr_j`, `instr_cj`), the module always predicts the instruction as taken.\n- For branches, the module uses the `instr_b_taken` signal to decide.\n\n#### Output Prediction Logic:\n\n- `predict_branch_taken_o` is asserted(active-high) if the instruction is predicted to be taken.\n- `predict_branch_pc_o` is calculated by adding `fetch_pc_i` to `branch_imm`, giving the predicted target address.\n\n### Example Calculation to Illustrate Static Branch Prediction\nAssume fetch_rdata_i = 32'h8C218363 (a 32-bit BEQ instruction with a negative offset) and fetch_pc_i = 32'h00001000.\nWe proceed as per the algorithm defined .\n\n- Immediate Extraction\n\n    The 12-bit immediate or 12-bit offset extracted from the instruction is `12'b1000_0110_0011`\n    \n- Sign Extension :\n\n  `imm_b_type` = {{19{fetch_rdata_i[12]}}, fetch_rdata_i[12:1], 1'b0} = 32'hFFFFF0C6.\n         \n- Prediction Logic and Target Address Calculation\n\n  Since imm_b_type[31] = 1, predict the branch as taken.\n  Target address (predict_branch_pc_o) is fetch_pc_i + imm_b_type = 32'h0000_1000 + 32'hFFFF_F0C6 = 32'h0000_00C6.\n\n### Summary of Branch and Jump Instruction Handling\n- All RV32C instructions are converted into their uncompressed form before being processed by this module.\n- Jumps (`JAL`, `JALR`, `C.J`, `C.JAL`) are always predicted as taken, whereas conditional branches are predicted based on their offset sign.\n- Immediate values are sign-extended to 32 bits to determine the target address.\n  \nExample Waveform :\n\n```wavedrom\n{\n  \"signal\": [\n    {\"name\": \"fetch_pc_i\", \"wave\": \"0..1..4..4..4..\", \"data\": [\"00001000\", \"00002000\", \"00001000\"]},\n    {\"name\": \"fetch_rdata_i\", \"wave\": \"0..1..4..4..4..\", \"data\": [\"8C218363\", \"6C2183E3\", \"FE000E63\"]},\n    {\"name\": \"fetch_valid_i\", \"wave\": \"0..1...........\", \"data\": [\"1\", \"1\", \"1\", \"1\"]},\n    {\"name\": \"register_addr_i\", \"wave\": \"0..............\", \"data\": [\"0000000\"]},\n    {\"name\": \"predict_branch_pc_o\", \"wave\": \"0..1..4..4..4..\", \"data\": [\"00001484\", \"00001EC6\", \"000007FC\"]},\n    {\"name\": \"predict_branch_taken_o\", \"wave\": \"0.....1..0.....\", \"data\": [\"1\",\"0\",\"0\"]}\n  ]\n}\n```                        ", "context": {}}, "output": {"response": "", "context": {"rtl/static_branch_predict.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir  \n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/static_branch_predict.sv\nTOPLEVEL        = static_branch_predict\nMODULE          = test_static_branch_predict\nPYTHONPATH      = /src\nHASH            = 1-static_branch_predictor_rtl_generation_issue\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\n# Getting environment variables\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang = os.getenv(\"TOPLEVEL_LANG\")\nsim = os.getenv(\"SIM\", \"icarus\")\ntoplevel = os.getenv(\"TOPLEVEL\")\nmodule = os.getenv(\"MODULE\")\nwave = os.getenv(\"WAVE\")\n\n# Define the runner function for the static branch predictor testbench\ndef test_runner():\n    \"\"\"Runs the simulation for the static branch predictor.\"\"\"\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True if wave == \"1\" else False,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True if wave == \"1\" else False)\n\n# Pytest function to run the testbench\ndef test_static_branch_predict():\n    \"\"\"Pytest function to run static branch predictor simulation.\"\"\"\n    print(\"Running static branch predictor testbench...\")\n\nif __name__ == \"__main__\":\n    test_runner()\n", "src/test_static_branch_predict.py": "import cocotb\nfrom cocotb.triggers import Timer\nfrom random import randint\n\n# Cocotb testbench for static branch predictor module\n@cocotb.test()\nasync def test_static_branch_predict(dut):\n    \"\"\"Test Static Branch Predictor for different branch and jump scenarios.\"\"\"\n\n    # Define the test vectors based on the SystemVerilog run_test_case task\n    test_vectors = [\n        # Format: (test_instr, test_pc, test_register_operand, test_valid, expected_taken, expected_pc, case_name)\n        (0x8C218363, 0x00001000, 0x00000000, 1, 1, 0x000000C6, \"Branch taken, PC offset negative (B-type), [BEQ]\"),\n        (0x6C2183E3, 0x00001000, 0x00000000, 1, 0, 0x00001EC6, \"Branch taken, PC offset positive (B-type), [BEQ]\"),\n        (0x926CF16F, 0x00001000, 0x00000000, 1, 1, 0xFFFD0126, \"Jump taken (J-type) with negative offset, [JAL]\"),\n        (0x126CF16F, 0x00001000, 0x00000000, 1, 1, 0x000D0126, \"Jump taken (J-type) with positive offset, [JAL]\"),\n        (0xF63101E7, 0x00001000, 0x00000000, 1, 1, 0x00000F63, \"Jump taken (JALR) with negative offset, [JALR]\"),\n        (0x763101E7, 0x00001000, 0x00000000, 1, 1, 0x00001763, \"Jump taken (JALR) with positive offset, [JALR]\"),\n        (0x4840006F, 0x00001000, 0x00000000, 1, 1, 0x00001484, \"Compressed Jump taken (J-type) with positive offset, [C.J]\"),\n        (0x484000EF, 0x00001000, 0x00000000, 1, 1, 0x00001484, \"Compressed Jump taken (J-type) with positive offset, [C.JAL]\"),\n        (0x08040A63, 0x00001000, 0x00000000, 1, 0, 0x00001094, \"Compressed Branch Taken, PC offset positive (B-type), [C.BEQZ]\"),\n        (0x00000001, 0x00002000, 0x00000000, 0, 0, 0x00002000, \"Invalid fetch (not valid)\"),\n        (0x00000000, 0x00002000, 0x00000000, 1, 0, 0x00002000, \"No branch or jump\"),\n        (0xFE000E63, 0x00001000, 0x00000000, 1, 1, 0x000007FC, \"Improper Instruction Encoding\")\n    ]\n\n    # Iterate through the test vectors and apply them to the DUT\n    for (test_instr, test_pc, test_register_operand, test_valid, expected_taken, expected_pc, case_name) in test_vectors:\n        # Apply inputs\n        dut.fetch_rdata_i.value = test_instr\n        dut.fetch_pc_i.value = test_pc\n        dut.register_addr_i.value = test_register_operand\n        dut.fetch_valid_i.value = test_valid\n\n        # Wait for the DUT to process the inputs\n        await Timer(10, units=\"ns\")\n\n        # Capture the outputs\n        actual_taken = dut.predict_branch_taken_o.value\n        actual_pc = dut.predict_branch_pc_o.value\n\n        # Log the test case details\n        dut._log.info(f\"Running test case: {case_name}\")\n        dut._log.info(f\"fetch_rdata_i: {test_instr:08X}, fetch_pc_i: {test_pc:08X}, Register Operand: {test_register_operand:08X}, Valid: {test_valid}\")\n        dut._log.info(f\"Expected Taken: {expected_taken}, Actual Taken: {actual_taken}\")\n        dut._log.info(f\"Expected PC: {expected_pc:08X}, Actual PC: {int(actual_pc):08X}\")\n\n        # Assertions to check if outputs match expectations\n        assert actual_taken == expected_taken, f\"{case_name} - Predict Branch Taken Mismatch: Expected {expected_taken}, Got {actual_taken}\"\n        assert int(actual_pc) == expected_pc, f\"{case_name} - Predict Branch PC Mismatch: Expected {expected_pc:08X}, Got {int(actual_pc):08X}\"\n\n        # Wait for a short time before the next test case\n        await Timer(10, units=\"ns\")\n\n    # Additional random test cases\n    num_random_tests = 10  # Number of random tests to generate\n    for i in range(num_random_tests):\n        # Generate random values for instruction, PC, register operand, and valid signal\n        test_instr = randint(0, 0xFFFFFFFF)\n        test_pc = randint(0, 0xFFFFFFFF)\n        test_register_operand = randint(0, 0xFFFFFFFF)\n        test_valid = randint(0, 1)\n\n        # Apply inputs\n        dut.fetch_rdata_i.value = test_instr\n        dut.fetch_pc_i.value = test_pc\n        dut.register_addr_i.value = test_register_operand\n        dut.fetch_valid_i.value = test_valid\n\n        # Wait for the DUT to process the inputs\n        await Timer(10, units=\"ns\")\n\n        # Capture the outputs\n        actual_taken = dut.predict_branch_taken_o.value\n        actual_pc = dut.predict_branch_pc_o.value\n\n        # Log the random test case details\n        dut._log.info(f\"Random Test Case {i + 1}\")\n        dut._log.info(f\"fetch_rdata_i: {test_instr:08X}, fetch_pc_i: {test_pc:08X}, Register Operand: {test_register_operand:08X}, Valid: {test_valid}\")\n        dut._log.info(f\"Predict Branch Taken: {actual_taken}, Predict Branch PC: {actual_pc.to_unsigned():08X}\")\n\n        # Randomized cases do not have specific expected values, so only check for consistency of output types and log results\n        assert actual_taken in [0, 1], f\"Random Test Case {i + 1} - Invalid Predict Branch Taken Output: Got {actual_taken}\"\n        assert isinstance(actual_pc.to_unsigned(), int), f\"Random Test Case {i + 1} - Predict Branch PC Output Not Integer: Got {actual_pc.to_unsigned()}\"\n\n        # Wait for a short time before the next random test case\n        await Timer(10, units=\"ns\")\n"}}}
{"id": "cvdp_copilot_sync_lifo_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design a System Verilog module that implements a **synchronous LIFO (Last-In, First-Out)** memory with configurable data width and depth. The design allows data to be written to and read from the LIFO structure based on specific control signals. \n\n### Interface of the Module `sync_lifo`\n2. **Parameter Definitions**:\n   - `DATA_WIDTH` (default = 8): Specifies the bit-width of the data to be stored in the LIFO.\n   - `ADDR_WIDTH` (default = 3): Specifies the number of address bits, determining the depth of the LIFO. The depth is ( 2^{ADDR_WIDTH} ). \n   \n3. **Input Ports**:\n   - `clock` (1 bit): Clock signal. All operations are synchronized with the rising edge of the clock.\n   - `reset` (1 bit): Synchronous reset, active high.\n   - `write_en` (1 bit): Write enable signal. When asserted high, new data is written into the LIFO if it is not full.\n   - `read_en` (1 bit): Read enable signal. When asserted high, data is read from the LIFO if it is not empty.\n   - `data_in` (DATA_WIDTH bits): The data input that will be written to the LIFO when `write_en` is active.\n\n4. **Output Ports**:\n   - `empty` (1 bit): High when the LIFO is empty, indicating no data is available to be read.\n   - `full` (1 bit): High when the LIFO is full, indicating no more data can be written.\n   - `data_out` (DATA_WIDTH bits): The output data that is read from the LIFO when `read_en` is active.\n\n### Specifications:\n\n1. **Write Operation**: \n\t- On the rising edge of the clock, if `write_en` is high and the LIFO is not full, the `data_in` is written to the memory array. \n\t\n2. **Read Operation**: \n\t- On the rising edge of the clock, if `read_en` is high and the LIFO is not empty, the data from the top of the LIFO (the last written value) should be read and output through `data_out`. \n\t\n3. **Reset Behavior**:\n   \t-  When reset is asserted (active high), the output clears to zero. The memory should also be cleared at reset and after reset is de-asserted, the LIFO write operation should start fresh.\n\n 4. **Edge Cases**:\n   \t-  Overflow: If write_en is asserted while the LIFO is full, no new data will be written, and the contents and pointer remain unchanged.\n   \t-  Underflow: If read_en is asserted while the LIFO is empty, data_out will hold its previous value, and the LIFO pointer and memory remain unchanged.\n### Assumptions:\n-    Assume that the input data is bounded within DATA_WIDTH bits\n\t", "context": {}}, "output": {"response": "", "context": {"rtl/sync_lifo.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v ", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sync_lifo.sv\nTOPLEVEL        = sync_lifo\nMODULE          = test_sync_lifo\nPYTHONPATH      = /src\nHASH            = d95483560b7048f2168dd12aa85e2766718dd3c1", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\nimport math\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(DATA_WIDTH: int=0):\n    ADDR_WIDTH = math.ceil(math.log2(DATA_WIDTH))  # Calculate ADDR_WIDTH based on DATA_WIDTH\n    parameter = {\"DATA_WIDTH\":DATA_WIDTH,\"ADDR_WIDTH\":ADDR_WIDTH}\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave)\n\n\n@pytest.mark.parametrize(\"DATA_WIDTH\", [4,8,16,64,128])\ndef test_areg_param(DATA_WIDTH):\n        runner(DATA_WIDTH = DATA_WIDTH)", "src/test_sync_lifo.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\n\n@cocotb.test()\nasync def lifo_test(dut):\n    \"\"\"\n    Test the basic functionality of the LIFO with continuous write and read enable.\n    The first read has a two-clock cycle delay, and subsequent reads occur on each clock cycle.\n    Also, tests overflow and underflow scenarios.\n    \"\"\"\n\n    # Extract the data width (assumed to be the LIFO depth) from the DUT\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n\n    dut._log.info(f\"ADDR_WIDTH = {int(dut.ADDR_WIDTH.value)}, DATA_WIDTH = {DATA_WIDTH}\")\n\n    # Start the clock with a period of 10ns\n    cocotb.start_soon(Clock(dut.clock, 10, units='ns').start())\n\n    # Initialize the DUT signals (e.g., reset all values to default 0)\n    await hrs_lb.dut_init(dut)\n\n    # Apply reset to the DUT for 25ns, reset is active low\n    await hrs_lb.reset_dut(dut.reset, duration_ns=25, active=False)\n\n    # Create a reference Python stack to model LIFO behavior\n    reference_stack = []\n\n    # Writing data into the LIFO more than its capacity to test overflow behavior\n    await Timer(10, units='ns')  # Wait for the reset to settle\n    dut.write_en.value = 1  # Enable continuous write\n\n    # Loop to write data beyond LIFO depth to check overflow condition\n    for i in range(DATA_WIDTH + 2):  \n        # Generate random data to write into the LIFO\n        data = random.randint(0, 2**DATA_WIDTH-1)\n        await write_lifo(dut, data)  # Perform the write operation\n\n        # Push data into the reference stack if the LIFO is not full\n        if dut.full.value == 0:\n            reference_stack.append(data)\n        else:\n            # If LIFO is full, check if overflow is handled correctly\n            await Timer(10, units='ns')  # Short delay to allow full flag to settle\n            assert dut.full.value == 1, f\"Failed: LIFO should be full on iteration {i}\"\n\n        # Check if the LIFO becomes full after all writes are complete\n        if i >= DATA_WIDTH:\n            await Timer(10, units='ns')  # Extra delay to check overflow properly\n            assert dut.full.value == 1, f\"Failed: Overflow not set when LIFO is full on iteration {i}\"\n            dut._log.info(f\"Overflow occurred on iteration {i} when attempting to write to a full LIFO.\")\n\n    # Disable the write enable after completing the write sequence\n    dut.write_en.value = 0\n\n    # Read operations from the LIFO to test underflow behavior\n    await Timer(10, units='ns')  # Wait for a short period before starting reads\n    dut.read_en.value = 1  # Enable continuous read\n\n    # Loop to read data from LIFO, including underflow test\n    for i in range(DATA_WIDTH + 2):\n        data_out = await read_lifo(dut, first_read=(i == 0))  # Perform the read operation\n\n        # Pop data from the reference stack if the LIFO is not empty\n        if i <= DATA_WIDTH and dut.empty.value == 0:\n            await Timer(10, units='ns')  # Short delay to allow empty flag to settle\n            expected_data = reference_stack.pop()\n            assert int(data_out) == expected_data, f\"Expected {expected_data}, got {int(data_out)}\"\n        else:  # Check if underflow occurs when attempting to read from an empty LIFO\n            assert dut.empty.value == 1, f\"LIFO should be empty after all reads on iteration {i}\"\n\n        # Delay empty check to allow LIFO to update its internal state after reading\n        if i >= DATA_WIDTH:\n            await Timer(20, units='ns')  # Allow extra time for empty flag to assert\n            assert dut.empty.value == 1, f\"Underflow not set when LIFO empty on iteration {i}\"\n            dut._log.info(f\"Underflow occurred on iteration {i} when attempting to read from an empty LIFO.\")\n\n    # Disable the read enable after completing the read sequence\n    dut.read_en.value = 0\n\n\nasync def write_lifo(dut, data):\n    \"\"\"Perform a write operation into the LIFO.\"\"\"\n    # Assign the input data to the LIFO's data_in port\n    dut.data_in.value = data\n    # Wait for one clock cycle to simulate the write operation\n    await RisingEdge(dut.clock)\n    # Log the data that was written to the LIFO\n    dut._log.info(f\"Wrote {data} to LIFO\")\n\n\nasync def read_lifo(dut, first_read=False):\n    \"\"\"Perform a read operation from the LIFO, with a two-clock cycle delay for the first read.\"\"\"\n    if first_read:\n        # Introduce an additional delay before the first read\n        await Timer(10, units='ns')\n        dut._log.info(\"Two-clock cycle delay before first read\")\n    \n    # Capture the output data from the LIFO at the clock edge\n    data_out = dut.data_out.value\n    \n    # Log the data that was read from the LIFO\n    dut._log.info(f\"Read {int(data_out)} from LIFO\")\n    return data_out\n"}}}
{"id": "cvdp_copilot_sync_serial_communication_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Create an RTL design with SystemVerilog, consisting of modules `sync_serial_communication_top`, `tx_block` and `rx_block` for transmitting and receiving data between transmitter and receiver blocks. The module must operate according to the following specifications.\n\nThe design `sync_serial_communication_top` consists of 2 modules:\n- `tx_block` which is responsible for transmitting the data based on the `sel` input\n- `rx_block` which will reconstruct the `data_out` based on the `sel` input\n\n##  RTL Module Requirements:\n### 1.Transmitter block(`tx_block`):\n  Convert parallel data into a serial format based on the `sel` input.\n### Inputs:\n- `clk(1-bit)`: Clock signal that runs at a 50:50 duty cycle. \n- `reset_n(1-bit)`: Active LOW asynchronous reset. When LOW, `serial_out`, `done` and `serial_clk` will maintain zero\n- `data_in ([63:0])`: Input data for the transmitter (TX).\n- `sel ([2:0])`: Controls the data width for the transmitter (TX):\n    - `3'h0`: 0 bits. No transmission happens\n    - `3'h1`: 8 bits. `data_in [7:0]` is the valid data to be transmitted.\n    - `3'h2`: 16 bits. `data_in [15:0]` is the valid data to be transmitted.\n    - `3'h3`: 32 bits. `data_in [31:0]` is the valid data to be transmitted.\n    - `3'h4`: 64 bits. `data_in [63:0]` is the valid data to be transmitted.\n    - Default: 0 bits\n### Outputs:\n- `serial_out(1-bit)`: Output data.\n- `done (1-bit)`: A HIGH on this signal indicates the availability of a stable result; wait for the `done` signal HIGH from the rx_block. The default value is 1'b0\n- `serial_clk`: It is gated when no data is transmitted\n### Behaviour:\n- The transmitter(TX) and receiver (RX) operate synchronously, driven by the same clock signal (`clk`) and reset (`reset_n`).\n- Upon reset (`reset_n`), all internal counters and registers are reset to their initial values.\n- The transmitter (TX) is responsible for serializing 8, 16, 32, or 64-bit data input based on the `sel` signal and produces serial data. \n- During data transfer, a gated clock signal `serial_clk` which operates at the frequency of `clk` has to be transmitted to the receiver (RX) alongside the serial data. When no data is transmitted, it remains at a fixed logic state of either HIGH or LOW\n- The transmitter (TX) generates the serial clock signal `serial_clk` that is used by both the transmitter (TX) and receiver (RX) for synchronized communication to transmit and receive one bit each during the positive edge of the clock\n\n### 2.Receiver block(`rx_block):\nCapture incoming serial data and reconstruct it into the specified parallel data based on the `sel` input.\n### Inputs:\n- `clk(1-bit)`: Clock signal that runs at a 50:50 duty cycle. \n- `reset_n(1-bit)`: Active LOW asynchronous reset. When LOW, the outputs `data_out` and `done` will maintain zero\n- `data_in (1-bit)`: Serial input data.\n- `sel ([2:0])`: Controls the data width for the Receiver(RX):\n    - `3'h0`: 0 bits. No data reception.\n    - `3'h1`: 8 bits\n    - `3'h2`: 16 bits\n    - `3'h3`: 32 bits\n    - `3'h4`: 64 bits\n    - Default: 0 bits\n- `serial_clk(1-bit)`: Clk captures serial data.\n### Outputs:\n- `data_out([63:0])`: Output data from the receiver (RX).\n- `done (1-bit)`: A HIGH in this signal for one clock cycle represents the availability of the stable result of the receiver (RX), default value is 1'b0.\n### Behaviour:\n- Data sampling in the receiver (RX) is valid whenever `serial_clk` is active.\n- The `sel` in the RX module receives the same value of `sel` maintained by the TX module\n- The receiver (RX) receives the serial data from the transmitter (TX) and reconstructs it into a 64-bit parallel output (`data_out`). The `data_out` will have the following data based on the `sel` value\n  - If `sel` is 000, `data_out` = 64'h0\n  - If `sel` is 001, `data_out` = {56'h0,data_in[7:0]}\n  - If `sel` is 010, `data_out` = {48'h0,data_in[15:0]}\n  - If `sel` is 011, `data_out` = {32'h0,data_in[31:0]}\n  - If `sel` is 100, `data_out` = data_in[63:0]\n  - default: 64'h0\n- The `done` signal  High indicates the valid output.\n### 3. Sync_serial_communication_top:\nThe top-level module integrates the `tx_block` and `rx_block` modules. \n### Inputs:\n- `clk(1-bit)`: Clock signal that runs at a 50:50 duty cycle. \n- `reset_n(1-bit)`: Active LOW asynchronous reset.\n- `data_in ([63:0])`: Input data to the transmitter (TX).\n- `sel ([2:0])`: Controls the data width for the transmitter (TX):\n    - `3'h0`: 0 bits\n    - `3'h1`: 8 bits\n    - `3'h2`: 16 bits\n    - `3'h3`: 32 bits\n    - `3'h4`: 64 bits\n    - Default: 0 bits\n### Outputs:\n- `data_out([63:0])`: Output data from the receiver (RX).\n- `done (1-bit)`: A HIGH in this signal for one clock cycle represents the availability of the stable result of the receiver (RX), default value is 1'b0.\n#### Behaviour:\n-#### Transmission: The TX block accepts a 64-bit parallel `data_in`, serializes it, and transmits it via the `serial_out` . It also provides a `serial_clk` for synchronizing the RX block.\n-#### Reception: The `RX block` receives serialized data through `serial_out` and uses `serial_clk` to clock the data. Once reception completes, it outputs a 64-bit data_out and asserts the `done` signal.\n\n#### . Edge cases:\n- The module should ensure that no data is transmitted or received if `sel` is set to any value other than the valid cases (000, 001, 010, 011, 100).\n- The `done` signal is set to LOW during transmission or reception and only goes to HIGH when the operation completes.\n- Changes in the `sel` value during data transfer from transmitter(TX) to receiver (RX) will not be acknowledged and it need not be considered as a valid case.\n- After each transaction, `reset_n` has to be set to active LOW to reset the required internal signals and achieve the correct `data_out` as a new `data_in` is driven\n\n#### Example\n\n````wavedrom\n\n{\"signal\": [\n  {\"name\": \"clk\", \"wave\": \"P.............................................\"},\n  {\"name\": \"reset_n\", \"wave\": \"..nh.............l.nh.....................l.nh.\"},\n  { \"name\": \"sel[2:0]\",  \"wave\": \"x..=...............=.=......................x.\", \"data\": [\"001\",\"000\",\"010\"] },\n  { \"name\": \"data_in[63:0]\",  \"wave\": \"x..=...............==.......................x.\", \"data\": [\"0000000000000074\",\"16'h0\",\"0000000000000081\"] },\n  { \"name\": \"data_out[63:0]\",  \"wave\": \"x..=............==.......................==...x\", \"data\": [\"0000000000000000\",\"74\",\"00000000000000000\",\"81\",\"00000000000000000\"] },\n  { \"name\": \"serial_clk\",  \"wave\": \"L......P.......l........P...............l.....\"},\n    {\"name\": \"done\", \"wave\": \"0...............Hl.......................Hl....\"}\n],\n  \"head\": {\n    \"text\": \"Module:: SYNC_SERIAL_COMMUNICATION, data_in and data_out represented in hex format\"\n  }\n}\n\n``````", "context": {}}, "output": {"response": "", "context": {"rtl/sync_serial_communication_top.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  1-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v ", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sync_serial_communication_top.sv\nTOPLEVEL        = sync_serial_communication_tx_rx\nMODULE          = test_sync_serial_communication\nPYTHONPATH      = /src\nHASH            = 263b2ff470b4b743412034826a0c6bb9e6056510", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n\nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(plusargs=[], parameter={}):\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs)\n\n\n@pytest.mark.parametrize(\"test\", range(20))\ndef test_sync_serial_communication(test):\n        runner()", "src/test_sync_serial_communication.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge,FallingEdge,Timer\nimport harness_library as hrs_lb\nimport random\n\n\nsel_value = [1,2,3,4]\n\n\n# Main test for sync_communication top module\n@cocotb.test()\nasync def test_sync_communication(dut):\n    #data_wd = int(dut.DATA_WIDTH.value)                                    # Get the data width from the DUT (Device Under Test)\n    # Start the clock with a 10ns time period\n\n    sel = random.choice(sel_value)\n\n    if sel == 1:\n        range_value = 8\n        data_in = random.randint(0, 127)\n    elif sel == 2:\n        range_value = 16\n        data_in = random.randint(0,4196)\n    elif sel == 3:\n        range_value = 32\n        data_in = random.randint(0,18192)\n    elif sel == 4:\n        range_value = 64\n        data_in = random.randint(0,154097)\n\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n\n    # Ensure all control signals are low initially before starting the test\n    dut.sel.value = 0\n    dut.data_in.value = 0\n\n    # Main test loop to validate both PISO and SIPO functionality\n    for _ in range(sel):\n        await drive_byte(dut,sel,range_value,data_in)\n        await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n\n        \nasync def drive_byte(dut,sel,range_value,data_in):\n    \"\"\"Drive a byte of data to the DUT\"\"\"\n    await RisingEdge(dut.clk)\n    dut.data_in.value = data_in  # Assign a random byte (0-127)\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}\")\n    for i in range(range_value):\n        dut.sel.value  = sel\n        #dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}\")\n        await RisingEdge(dut.clk)\n    await RisingEdge(dut.done)\n    await RisingEdge(dut.clk)\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}, data_out = {int(dut.data_out.value)}, done = {dut.done.value}\")\n\n    expected_data_out = dut.data_in.value\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, expected_data_out = {int(expected_data_out)}, data_out = {int(dut.data_out.value)}\")\n\n    assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n"}}}
{"id": "cvdp_copilot_thermostat_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design a Sequential Verilog Module named `thermostat` for a Thermostat Controller with an FSM that automatically switches between heating and cooling based on temperature feedback.\n\n## Inputs\n\n1. **6-bit**: `i_temp_feedback[5:0]`  \n   Each bit represents a distinct temperature condition :\n   - `i_temp_feedback[5]` : `i_full_cold`  (1 = too cold)  \n   - `i_temp_feedback[4]` : `i_medium_cold` (1 = medium cold)  \n   - `i_temp_feedback[3]` : `i_low_cold`   (1 = low cold)  \n   - `i_temp_feedback[2]` : `i_low_hot`    (1 = low hot)  \n   - `i_temp_feedback[1]` : `i_medium_hot` (1 = medium hot)  \n   - `i_temp_feedback[0]` : `i_full_hot`   (1 = too hot)  \n\n2. **1-bit**: `i_fan_on`  \n   - User control to turn the fan on manually (`1` = fan on, `0` = fan off).\n\n3. **1-bit**: `i_enable`  \n   - Enables or disables the thermostat.  \n   - When `i_enable = 0`, all thermostat outputs must be forced to `0` regardless of temperature feedback.\n\n4. **1-bit**: `i_fault`  \n   - Signals a fault/error condition.  \n   - When `i_fault = 1`, all outputs must be forced to `0` (overridden), ignoring normal FSM logic.\n\n5. **1-bit**: `i_clr`  \n   - Clears the error state set by `i_fault`. Upon assertion, the thermostat should return to `AMBIENT`.\n6. **Clock/Reset**  \n   - `i_clk`: Clock for sequential logic.\n   - `i_rst`: Asynchronous active-low reset.\n---\n\n## Outputs\n\n1. **Heating Control (1-bit each)**  \n   - `o_heater_full`  \n   - `o_heater_medium`  \n   - `o_heater_low`  \n\n2. **Cooling Control (1-bit each)**  \n   - `o_aircon_full`  \n   - `o_aircon_medium`  \n   - `o_aircon_low`  \n\n3. **Fan Control (1-bit)**  \n   - `o_fan`  \n\n4. **FSM Output State (3-bit)**  \n   - `o_state[2:0]`: Indicates the current FSM state among the seven valid states:\n     - `3'b000` = `HEAT_LOW`\n     - `3'b001` = `HEAT_MED`\n     - `3'b010` = `HEAT_FULL`\n     - `3'b011` = `AMBIENT`\n     - `3'b100` = `COOL_LOW`\n     - `3'b101` = `COOL_MED`\n     - `3'b110` = `COOL_FULL`\n\n---\n\n## Reset/Idle Behavior\n\n- **Asynchronous Reset (`i_rst` active low)**  \n  - When `i_rst` is asserted (`0`), force the FSM to `AMBIENT` and all outputs to `0`.\n- **Idle/Default State**  \n  - `AMBIENT` state when no heating or cooling is required.  \n  - When `i_clr` is asserted (to clear a fault), the FSM should go back to `AMBIENT` on the next rising clock edge if `i_rst` is not active.\n\n---\n\n## Fault Handling\n\n- If `i_fault = 1`, **all outputs** (`o_heater_full`, `o_heater_medium`, `o_heater_low`, `o_aircon_full` , `o_aircon_medium`, `o_aircon_low`, `o_fan`) must be forced to `0`, overriding any state-based or feedback logic.\n- Once a fault is signaled, the thermostat remains forced off until `i_clr` is asserted to clear the fault.  \n  - After clearing the fault (`i_clr = 1`), the controller returns to `AMBIENT` state on the next rising clock edge.\n\n---\n\n## Enable Control\n\n- If `i_enable = 0`, the thermostat is turned off.  \n  - Force **all outputs** to `0` (similar to a disable override).  \n  - Internally, the FSM move to `AMBIENT`.\n\n---\n\n## FSM State Transition Logic\n\nOn each rising edge of `i_clk` (while `i_rst = 1` and no fault override), the FSM evaluates the temperature feedback bits to determine the next state:\n\n1. **Cold Conditions** (highest priority first)\n   - If `i_full_cold = 1`: transition to `HEAT_FULL`.  \n   - Else if `i_medium_cold = 1`: transition to `HEAT_MED`.  \n   - Else if `i_low_cold = 1`: transition to `HEAT_LOW`.\n\n2. **Hot Conditions** (highest priority first)\n   - If `i_full_hot = 1`: transition to `COOL_FULL`.  \n   - Else if `i_medium_hot = 1`: transition to `COOL_MED`.  \n   - Else if `i_low_hot = 1`: transition to `COOL_LOW`.\n\n3. **Ambient Condition**\n   - If none of the cold/hot feedback bits are asserted, transition to `AMBIENT`.\n\n> **Note**: The bits `i_full_cold`, `i_medium_cold`, `i_low_cold` are mutually exclusive with `i_full_hot`, `i_medium_hot`, `i_low_hot`, meaning they will never be asserted at the same time.\n\n---\n\n## Output Logic\n\nThe output will be synchronous to `i_clk`, and should get asynchronously reset.\nGiven the current FSM state **(unless overridden by `i_fault` or disabled by `i_enable`)**:\n\n- **Heating States**  \n  - `HEAT_FULL`  \n    - `o_heater_full = 1`, all other heater/cooler outputs = 0  \n  - `HEAT_MED`  \n    - `o_heater_medium = 1`, all other heater/cooler outputs = 0  \n  - `HEAT_LOW`  \n    - `o_heater_low = 1`, all other heater/cooler outputs = 0  \n\n- **Cooling States**  \n  - `COOL_FULL`  \n    - `o_aircon_full = 1`, all other heater/cooler outputs = 0  \n  - `COOL_MED`  \n    - `o_aircon_medium = 1`, all other heater/cooler outputs = 0  \n  - `COOL_LOW`  \n    - `o_aircon_low = 1`, all other heater/cooler outputs = 0  \n\n- **AMBIENT**  \n  - All heater/aircon outputs = 0  \n\n- **Fan Control** (`o_fan`)  \n  - `o_fan = 1` if any heater or air conditioner output is active in the current state **OR** if `i_fan_on = 1`.  \n  - Otherwise, `o_fan = 0`.\n\n---\n\n## Overriding Conditions Summary\n\n1. **Reset (`i_rst = 0`)**  \n   - Highest-priority override: sets FSM to `AMBIENT`, outputs = 0 immediately (asynchronous).  \n\n2. **Fault (`i_fault = 1`)**  \n   - Next-highest priority: overrides *all outputs* to 0, regardless of state or temperature feedback.\n\n3. **Disable (`i_enable = 0`)**  \n   - Next priority: thermostat outputs forced off (0). The FSM logic may remain in its current state internally, but no heat/cool/fan outputs are driven.\n\n4. **Normal Operation**  \n   - When `i_rst=1`, `i_fault=0`, and `i_enable=1`, the FSM outputs follow the state-based transitions and normal fan logic.\n\n5. **Clearing Fault (`i_clr = 1`)**  \n   - On the next rising clock edge, if `i_fault` is deasserted, the FSM moves to `AMBIENT` and resumes normal functionality.\n", "context": {}}, "output": {"response": "", "context": {"rtl/thermostat.v": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/thermostat.v\nTOPLEVEL        = thermostat\nMODULE          = test_thermostat\nPYTHONPATH      = /src\nHASH            = 1-rtl-code-completion", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\n\ndef test_runner():\n\n    # List from Files\n    verilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\n    \n    # Language of Top Level File\n    toplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\n\n    sim             = os.getenv(\"SIM\", \"icarus\")\n    toplevel        = os.getenv(\"TOPLEVEL\")\n    module          = os.getenv(\"MODULE\")\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\",\n\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n    test_runner()", "src/test_thermostat.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nfrom cocotb.clock import Clock\n\ndef assert_equal(actual, expected, msg=\"\"):\n    \"\"\"Custom assertion with message.\"\"\"\n    assert actual == expected, f\"{msg}: Expected {expected}, but got {actual}\"\n\n@cocotb.test()\nasync def test_thermostat(dut):\n    \"\"\"Testbench for thermostat FSM Verilog module.\"\"\"\n\n    # Setup clock: 10 ns period (100 MHz)\n    clock = Clock(dut.i_clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Initialize all inputs\n    dut.i_temp_feedback.value = 0\n    dut.i_fan_on.value = 0\n    dut.i_enable.value = 0\n    dut.i_fault.value = 0\n    dut.i_clr.value = 0\n    dut.i_rst.value = 1  # Initially deassert reset\n\n    # Apply asynchronous reset\n    dut.i_rst.value = 0\n    await Timer(20, units=\"ns\")  # Hold reset for 20 ns\n    dut.i_rst.value = 1\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)  # Wait for a clock edge\n    await Timer(1, units=\"ns\")\n    # Check initial state after reset\n    assert_equal(dut.o_state.value, 0b011, \"FSM should initialize to AMBIENT state\")\n    assert_equal(dut.o_heater_full.value, 0, \"Heater full output should be 0 after reset\")\n    assert_equal(dut.o_aircon_full.value, 0, \"Aircon full output should be 0 after reset\")\n    assert_equal(dut.o_fan.value, 0, \"Fan output should be 0 after reset\")\n\n    # Enable the thermostat and test state transitions\n    dut.i_enable.value = 1\n    await RisingEdge(dut.i_clk)\n\n    # Test heating states\n    dut.i_temp_feedback.value = 0b100000  # i_full_cold\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b010, \"FSM should transition to HEAT_FULL\")\n    assert_equal(dut.o_heater_full.value, 1, \"Heater full output should be 1 in HEAT_FULL\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b010000  # i_medium_cold\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b001, \"FSM should transition to HEAT_MED\")\n    assert_equal(dut.o_heater_medium.value, 1, \"Heater medium output should be 1 in HEAT_MED\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b001000  # i_low_cold\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b000, \"FSM should transition to HEAT_LOW\")\n    assert_equal(dut.o_heater_low.value, 1, \"Heater low output should be 1 in HEAT_LOW\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    # Test cooling states\n    dut.i_temp_feedback.value = 0b000001  # i_full_hot\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b110, \"FSM should transition to COOL_FULL\")\n    assert_equal(dut.o_aircon_full.value, 1, \"Aircon full output should be 1 in COOL_FULL\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b000010  # i_medium_hot\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b101, \"FSM should transition to COOL_MED\")\n    assert_equal(dut.o_aircon_medium.value, 1, \"Aircon medium output should be 1 in COOL_MED\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b000100  # i_low_hot\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b100, \"FSM should transition to COOL_LOW\")\n    assert_equal(dut.o_aircon_low.value, 1, \"Aircon low output should be 1 in COOL_LOW\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    # Test ambient state\n    dut.i_temp_feedback.value = 0b000000  # No temperature feedback\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b011, \"FSM should transition to AMBIENT\")\n    assert_equal(dut.o_fan.value, 0, \"Fan output should be 0 in AMBIENT\")\n\n    # Test fault handling\n    dut.i_fault.value = 1\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b011, \"FSM should remain in AMBIENT during fault\")\n    assert_equal(dut.o_heater_full.value, 0, \"All outputs should be 0 during fault\")\n    assert_equal(dut.o_aircon_full.value, 0, \"All outputs should be 0 during fault\")\n    assert_equal(dut.o_fan.value, 0, \"All outputs should be 0 during fault\")\n\n    # Clear fault\n    dut.i_fault.value = 0\n    dut.i_clr.value = 1\n    await RisingEdge(dut.i_clk)\n    dut.i_clr.value = 0\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b011, \"FSM should transition back to AMBIENT after fault is cleared\")\n\n    # Test disable functionality\n    dut.i_enable.value = 0\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b011, \"FSM should remain in AMBIENT when disabled\")\n    assert_equal(dut.o_heater_full.value, 0, \"All outputs should be 0 when disabled\")\n    assert_equal(dut.o_aircon_full.value, 0, \"All outputs should be 0 when disabled\")\n    assert_equal(dut.o_fan.value, 0, \"All outputs should be 0 when disabled\")\n\n    # Re-enable and verify transitions again\n    dut.i_enable.value = 1\n    dut.i_temp_feedback.value = 0b100000  # i_full_cold\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b010, \"FSM should transition to HEAT_FULL after re-enabling\")\n    assert_equal(dut.o_heater_full.value, 1, \"Heater full output should be 1 after re-enabling\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    # Test priority when multiple hot inputs are set\n    dut.i_temp_feedback.value = 0b000101  # i_full_hot and i_low_hot\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b110, \"FSM should prioritize COOL_FULL when multiple hot inputs are set\")\n    assert_equal(dut.o_aircon_full.value, 1, \"Aircon full output should be 1 in COOL_FULL\")\n    assert_equal(dut.o_aircon_low.value, 0, \"Aircon low output should be 0 when COOL_FULL is prioritized\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b000110  # i_medium_hot and i_low_hot\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b101, \"FSM should prioritize COOL_MED when multiple hot inputs are set\")\n    assert_equal(dut.o_aircon_medium.value, 1, \"Aircon medium output should be 1 in COOL_MED\")\n    assert_equal(dut.o_aircon_low.value, 0, \"Aircon low output should be 0 when COOL_MED is prioritized\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b000111  # i_full_hot, i_medium_hot, and i_low_hot\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b110, \"FSM should prioritize COOL_FULL over other hot inputs\")\n    assert_equal(dut.o_aircon_full.value, 1, \"Aircon full output should be 1 in COOL_FULL\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    # Test priority when multiple cold inputs are set\n    dut.i_temp_feedback.value = 0b101000  # i_full_cold and i_low_cold\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b010, \"FSM should prioritize HEAT_FULL when multiple cold inputs are set\")\n    assert_equal(dut.o_heater_full.value, 1, \"Heater full output should be 1 in HEAT_FULL\")\n    assert_equal(dut.o_heater_low.value, 0, \"Heater low output should be 0 when HEAT_FULL is prioritized\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b011000  # i_medium_cold and i_low_cold\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b001, \"FSM should prioritize HEAT_MED when multiple cold inputs are set\")\n    assert_equal(dut.o_heater_medium.value, 1, \"Heater medium output should be 1 in HEAT_MED\")\n    assert_equal(dut.o_heater_low.value, 0, \"Heater low output should be 0 when HEAT_MED is prioritized\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n\n    dut.i_temp_feedback.value = 0b111000  # i_full_cold, i_medium_cold, and i_low_cold\n    await RisingEdge(dut.i_clk)\n    await RisingEdge(dut.i_clk)\n    await Timer(1, units=\"ns\")\n    assert_equal(dut.o_state.value, 0b010, \"FSM should prioritize HEAT_FULL over other cold inputs\")\n    assert_equal(dut.o_heater_full.value, 1, \"Heater full output should be 1 in HEAT_FULL\")\n    assert_equal(dut.o_fan.value, 1, \"Fan output should be 1\")\n"}}}
{"id": "cvdp_copilot_ttc_lite_0001", "categories": ["cid003", "medium"], "input": {"prompt": "\nDesign a System Verilog module named `ttc_counter_lite.sv` that implements a lightweight timer/counter. The module is a timer/counter that supports interval mode operation, interrupt generation, and AXI-Lite register-based control and status monitoring.\n\n\n## Design Specifications\n**Module Name**:\n`ttc_counter_lite`\n\n### Inputs:\n1. **`clk`** (1 bit): Clock signal for synchronous operation.\n2. **`reset`** (1 bit): Active-high reset signal to initialize the timer.\n3. **`axi_addr`** (4 bits): Address bus for AXI-Lite read/write operations.\n4. **`axi_wdata`** (32 bits): Data bus for AXI-Lite write operations.\n5. **`axi_write_en`** (1 bit): Write enable signal for AXI-Lite writes.\n6. **`axi_read_en`** (1 bit): Read enable signal for AXI-Lite reads.\n\n### Outputs:\n1. **`axi_rdata`** (32 bits): Data bus for AXI-Lite read operations.\n2. **`interrupt`** (1 bit): Interrupt signal, asserted when the counter matches the configured match value.\n\n---\n\n## Functional Requirements\n\n### Timer Operation:\n1. **Counter Register (`count`):**\n   - Counts up on every clock cycle when the timer is enabled.\n   - Holds the count value at the match value in non-interval mode.\n   - Resets to the reload value upon match in interval mode.\n2. **Match Value Register (`match_value`):**\n   - Configures the counter match value for interrupt generation.\n3. **Reload Value Register (`reload_value`):**\n   - Configures the counter reload value for interval mode.\n\n### Modes of Operation:\n1. **Enable (`enable`):** Enables or disables the timer operation.\n2. **Interval Mode (`interval_mode`):**\n   - When enabled, the counter reloads to the configured reload value on a match event.\n   - When disabled, the counter holds at the match value.\n3. **Interrupt Enable (`interrupt_enable`):**\n   - Enables or disables interrupt generation when the counter matches the match value.\n\n### Write Operations:\n- **Match Value Register:** Configure the counter match value.\n- **Reload Value Register:** Set the counter reload value.\n- **Control Register:** Control timer enable, interval mode, and interrupt enable.\n\n### Read Operations:\n- **Count Register:** Read the current value of the counter.\n- **Match Value Register:** Retrieve the configured match value.\n- **Reload Value Register:** Retrieve the configured reload value.\n- **Control Register:** Read the current state of control bits (enable, interval mode, interrupt enable).\n- **Status Register:** Check the interrupt status and clear the interrupt by writing to this register.\n\n---\n\n## Register Map\n\n| Address         | Register Name       | Width  | Access  | Description                                 |\n|------------------|---------------------|--------|---------|---------------------------------------------|\n| `0x0`           | Count Register      | 32 bits| Read    | Current counter value (lower 16 bits).     |\n| `0x1`           | Match Value Register| 32 bits| Read/Write | Counter match value (lower 16 bits).      |\n| `0x2`           | Reload Value Register| 32 bits| Read/Write | Counter reload value (lower 16 bits).    |\n| `0x3`           | Control Register    | 32 bits| Read/Write | Control bits: Enable, Interval Mode, Interrupt Enable. |\n| `0x4`           | Status Register     | 32 bits| Read/Write | Interrupt status: 1 if interrupt is asserted, 0 otherwise. |\n\n---\n\n### Counter Logic:\n- Increments on every clock cycle when enabled.\n- Reloads to the reload value on a match in interval mode.\n- Stops incrementing and holds at the match value in non-interval mode.\n\n### Match Detection:\n- Compares the counter value to the match value.\n- Sets the `match_flag` when a match occurs.\n\n### Interrupt Generation:\n- Asserts the `interrupt` signal when `match_flag` is set and interrupts are enabled.\n- Clears the `interrupt` signal when the status register is written.\n\n### Reset Behavior:\n- Clears all registers, disables the timer, and resets the counter and interrupt signals.\n\n---\n\n## Assumptions\n\n- The module operates with a single clock domain.\n- Input signals are stable and meet setup/hold timing requirements relative to the clock.\n", "context": {}}, "output": {"response": "", "context": {"rtl/ttc_counter_lite.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v ", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ttc_counter_lite.sv\nTOPLEVEL        = ttc_counter_lite\nMODULE          = test_ttc_counter_lite\nPYTHONPATH      = /src\nHASH            = af8163bef5c1eb352b27114d377f5b72b6ce9db6", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 2, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(plusargs=[], parameter={}):\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs)\n\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_areg_param(test):\n        runner()", "src/test_ttc_counter_lite.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_ttc_counter_lite(dut):\n    \"\"\"\n    Cocotb-based testbench for the ttc_counter_lite module.\n    \"\"\"\n    # Generate clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Initialize the DUT signals (e.g., reset all values to default 0)\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT\n    dut.reset.value = 1\n    await Timer(20, units=\"ns\")\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\n    # Helper function to write to AXI\n    async def axi_write(addr, data):\n        dut.axi_addr.value = addr\n        dut.axi_wdata.value = data\n        dut.axi_write_en.value = 1\n        await RisingEdge(dut.clk)\n        dut.axi_write_en.value = 0\n        await RisingEdge(dut.clk)\n\n    # Helper function to read from AXI\n    async def axi_read(addr):\n        dut.axi_addr.value = addr\n        dut.axi_read_en.value = 1\n        await RisingEdge(dut.clk)\n        dut.axi_read_en.value = 0\n        await RisingEdge(dut.clk)\n        read_value = int(dut.axi_rdata.value)\n        print(f\"[READ] Address: {addr}, Data: {read_value}\")\n        return read_value\n\n    # Write match value\n    await axi_write(0x1, 0x14)  # Set match value to 20\n    assert int(dut.match_value.value) == 0x14, \"[ERROR] Match value not set correctly\"\n    dut._log.info(f\"[CHECK] Match value correctly set: {int(dut.match_value.value)}\")\n\n    # Write reload value\n    await axi_write(0x2, 0xA)  # Set reload value to 10\n    assert int(dut.reload_value.value) == 0xA, \"[ERROR] Reload value not set correctly\"\n    dut._log.info(f\"[CHECK] Reload value correctly set: {int(dut.reload_value.value)}\")\n\n    # Configure control register\n    await axi_write(0x3, 0x7)  # Enable = 1, Interval mode = 1, Interrupt enable = 1\n    assert dut.enable.value == 1, \"[ERROR] Control register enable not set\"\n    assert dut.interval_mode.value == 1, \"[ERROR] Interval mode not set\"\n    assert dut.interrupt_enable.value == 1, \"[ERROR] Interrupt enable not set\"\n    dut._log.info(f\"[CHECK] Control register configured correctly: Enable={dut.enable.value}, Interval Mode={dut.interval_mode.value}, Interrupt Enable={dut.interrupt_enable.value}\")\n\n    # Observe counting\n    await Timer(200, units=\"ns\")\n    count = int(dut.count.value)\n    reload_value = int(dut.reload_value.value)\n    match_value = int(dut.match_value.value)\n    assert reload_value <= count <= match_value, f\"[ERROR] Counter value {count} is out of range [{reload_value}, {match_value}]\"\n    dut._log.info(f\"[CHECK] Counter is running within range: {count}, Reload Value: {reload_value}, Match Value: {match_value}\")\n\n    # Read counter value\n    count_val = await axi_read(0x0)  # Read counter value\n    assert count_val == int(dut.count.value), f\"[ERROR] Counter value mismatch: read {count_val}, expected {int(dut.count.value)}\"\n    dut._log.info(f\"[INFO] Counter value read: {count_val}\")\n\n    # Wait for interrupt\n    await Timer(50, units=\"ns\")\n    assert dut.interrupt.value == 1, \"[ERROR] Interrupt not asserted\"\n    dut._log.info(f\"[CHECK] Interrupt asserted at match: {dut.interrupt.value}\")\n    # Check interrupt status\n    interrupt_status = await axi_read(0x4)\n    assert interrupt_status == dut.interrupt.value, \"[ERROR] Interrupt status mismatch\"\n    dut._log.info(\"[CHECK] Interrupt status matches expected value\")\n\n    # Clear interrupt\n    await axi_write(0x4, 0x0)  # Clear interrupt\n    assert dut.interrupt.value == 0, \"[ERROR] Interrupt not cleared\"\n    dut._log.info(f\"[CHECK] Interrupt cleared successfully: {dut.interrupt.value}\")\n\n    dut._log.info(\"[INFO] Simulation completed\")\n\n"}}}
{"id": "cvdp_copilot_unpacker_one_hot_0001", "categories": ["cid003", "easy"], "input": {"prompt": "**Design a module that implements a flexible unpacking mechanism for converting packed binary data from a source register into a wider destination register. The unpacking process supports various bit-width selections based on a one-hot selector input. The module also handles signed or unsigned data conversion and incorporates size-based behavior for specific cases.**\n\n### Module Description:\n\nThe `unpack_one_hot` module processes packed data stored in a 256-bit source register (`source_reg`) and expands it into a 512-bit destination register (`destination_reg`). The unpacking is controlled by a 3-bit one-hot selector (`one_hot_selector`), a sign control signal (`sign`), and a size control signal (`size`). The module supports unpacking at different granularities, handling both signed and unsigned data. \n\n---\n\n### Input and Output Ports:\n\n#### Inputs:\n1. **`sign` (1 bit)**:\n   - Determines whether the unpacked data should be signed (`1`) or unsigned (`0`).\n2. **`size` (1 bit)**:\n   - Controls the unpacking behavior in certain cases (used when `one_hot_selector` is `3'b100`).\n3. **`one_hot_selector [2:0]` (3 bits)**:\n   - One-hot encoded input determining the unpacking granularity:\n     - `3'b001`: Treat each bit of `source_reg` as an unpacked 8-bit value.\n     - `3'b010`: Treat each 2-bit segment of `source_reg` as an unpacked 8-bit value.\n     - `3'b100`: Enables size-dependent behavior:\n       - If `size` is `1`, treat each 8-bit segment of `source_reg` as an unpacked 16-bit value.\n       - If `size` is `0`, treat each 4-bit segment of `source_reg` as an unpacked 8-bit value.\n4. **`source_reg [255:0]` (256 bits)**:\n   - The packed source register containing the input data to be unpacked.\n\n#### Outputs:\n1. **`destination_reg [511:0]` (512 bits)**:\n   - The destination register holding the unpacked and processed data.\n\n---\n\n### Functional Behavior:\n\n#### 1. **Default Initialization:**\n- The `destination_reg` is initialized to zero at the start of the unpacking process.\n\n#### 2. **Unpacking Control Based on `one_hot_selector`:**\n- **Case `3'b001`:**\n  - Each 1-bit segment of `source_reg` is unpacked into an 8-bit segment of `destination_reg`.\n  - Signed or unsigned extension is applied based on the `sign` input.\n- **Case `3'b010`:**\n  - Each 2-bit segment of `source_reg` is unpacked into an 8-bit segment of `destination_reg`.\n  - Signed or unsigned extension is applied based on the `sign` input.\n- **Case `3'b100`:**\n  - If `size` is `1`:\n    - Each 8-bit segment of `source_reg` is unpacked into a 16-bit segment of `destination_reg`.\n    - Signed or unsigned extension is applied based on the `sign` input.\n  - If `size` is `0`:\n    - Each 4-bit segment of `source_reg` is unpacked into an 8-bit segment of `destination_reg`.\n    - Signed or unsigned extension is applied based on the `sign` input.\n- **Default Case:**\n  - The `source_reg` is directly assigned to `destination_reg` without unpacking.\n\n#### 3. **Loop Operation:**\n- The module uses an `integer` variable (`i`) to iterate through the `source_reg` in chunks defined by the selected granularity, unpacking data into the corresponding segments of `destination_reg`.\n\n---\n\n### Design Features:\n\n1. **Dynamic Granularity Control:**\n   - The unpacking process supports granularities of 1-bit, 2-bit, 4-bit, and 8-bit segments from the packed input.\n2. **Signed and Unsigned Extension:**\n   - The `sign` input ensures flexibility for both signed and unsigned data conversion.\n3. **Size-Dependent Behavior:**\n   - The `size` input adds further control to the unpacking behavior when the one-hot selector is `3'b100`.\n4. **Default Assignment:**\n   - A fallback mechanism assigns the source register directly to the destination register when no valid `one_hot_selector` is provided.\n\n---\n\n### Example Use Cases:\n\n#### Case 1: `one_hot_selector = 3'b001, sign = 1`\n- Each bit of `source_reg` is sign-extended to 8 bits and written to `destination_reg`.\n\n#### Case 2: `one_hot_selector = 3'b010, sign = 0`\n- Each 2-bit segment of `source_reg` is zero-extended to 8 bits and written to `destination_reg`.\n\n#### Case 3: `one_hot_selector = 3'b100, size = 1, sign = 1`\n- Each 8-bit segment of `source_reg` is sign-extended to 16 bits and written to `destination_reg`.\n\n#### Case 4: `one_hot_selector = 3'b100, size = 0, sign = 0`\n- Each 4-bit segment of `source_reg` is zero-extended to 8 bits and written to `destination_reg`.", "context": {}}, "output": {"response": "", "context": {"rtl/unpack_one_hot.v": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n  test:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src\n    working_dir: /code/rundir/\n    env_file:\n      - ./src/.env\n    command: pytest -sv -o cache_dir=/code/rundir/.cache /src/test_runner.py", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/unpack_one_hot.v\nTOPLEVEL        = unpack_one_hot\nMODULE          = tb\nPYTHONPATH      = /src\nHASH            = 1-rtl-for-unpacker-module", "src/tb.py": "import cocotb\nfrom cocotb.triggers import Timer\n\n@cocotb.test()\nasync def test_unpack_one_hot(dut):\n    \"\"\"Cocotb testbench for unpack_one_hot with scoring for test cases\"\"\"\n\n    # Initialize the score\n    total_score = 0\n    max_score = 6  # Total number of test cases provided\n\n    # Test Case 1: One-Hot Selector = 1, sign = 0\n    dut.sign.value = 0\n    dut.size.value = 0\n    dut.one_hot_selector.value = 1\n    dut.source_reg.value = int(\n        \"3fa8c1d7e4926b73f1d4a9872ebc5609f4ac7b01e9d2f34c8a5b0f6789dc1234\", 16\n    )\n    expected = int(\n        \"01000000010001000001000101000101000000000101010100010100000101010100000001000001010100010101000000000001000001000000010100010000\", 16\n    )\n    await Timer(2, units=\"ns\")\n    if dut.destination_reg.value == expected:\n        total_score += 1\n\n    # Test Case 2: One-Hot Selector = 1, sign = 1\n    dut.sign.value = 1\n    dut.size.value = 0\n    dut.one_hot_selector.value = 1\n    dut.source_reg.value = int(\n        \"3fa8c1d7e4926b73f1d4a9872ebc5609f4ac7b01e9d2f34c8a5b0f6789dc1234\", 16\n    )\n    expected = int(\n        \"ff000000ff00ff0000ff00ffff00ffff00000000ffffffff00ffff0000ffffffff000000ff0000ffffff00ffffff0000000000ff0000ff000000ffff00ff0000\", 16\n    )\n    await Timer(2, units=\"ns\")\n    if dut.destination_reg.value == expected:\n        total_score += 1\n\n    # Test Case 3: One-Hot Selector = 2, sign = 0\n    dut.sign.value = 0\n    dut.size.value = 0\n    dut.one_hot_selector.value = 2\n    dut.source_reg.value = int(\n        \"3fa8c1d7e4926b73f1d4a9872ebc5609f4ac7b01e9d2f34c8a5b0f6789dc1234\", 16\n    )\n    expected = int(\n        \"03030100020203000103020300000001030202010301000203030003010003000200020201010203000003030102010302000201030103000001000200030100\", 16\n    )\n    await Timer(2, units=\"ns\")\n    if dut.destination_reg.value == expected:\n        total_score += 1\n\n    # Test Case 4: One-Hot Selector = 2, sign = 1\n    dut.sign.value = 1\n    dut.size.value = 0\n    dut.one_hot_selector.value = 2\n    dut.source_reg.value = int(\n        \"3fa8c1d7e4926b73f1d4a9872ebc5609f4ac7b01e9d2f34c8a5b0f6789dc1234\", 16\n    )\n    expected = int(\n        \"ffff0100fefeff0001fffeff00000001fffefe01ff0100feffff00ff0100ff00fe00fefe0101feff0000ffff01fe01fffe00fe01ff01ff00000100fe00ff0100\", 16\n    )\n    await Timer(2, units=\"ns\")\n    if dut.destination_reg.value == expected:\n        total_score += 1\n\n    # Test Case 5: One-Hot Selector = 4, sign = 0, size = 1\n    dut.sign.value = 0\n    dut.size.value = 1\n    dut.one_hot_selector.value = 4\n    dut.source_reg.value = int(\n        \"3fa8c1d7e4926b73f1d4a9872ebc5609f4ac7b01e9d2f34c8a5b0f6789dc1234\", 16\n    )\n    expected = int(\n        \"003f00a800c100d700e40092006b007300f100d400a90087002e00bc0056000900f400ac007b000100e900d200f3004c008a005b000f0067008900dc00120034\", 16\n    )\n    await Timer(2, units=\"ns\")\n    if dut.destination_reg.value == expected:\n        total_score += 1\n\n    # Test Case 6: One-Hot Selector = 3 (pass-through mode)\n    dut.sign.value = 0\n    dut.size.value = 0\n    dut.one_hot_selector.value = 3\n    dut.source_reg.value = int(\n        \"3fa8c1d7e4926b73f1d4a9872ebc5609f4ac7b01e9d2f34c8a5b0f6789dc1234\", 16\n    )\n    expected = int(\n        \"00000000000000000000000000000000000000000000000000000000000000003fa8c1d7e4926b73f1d4a9872ebc5609f4ac7b01e9d2f34c8a5b0f6789dc1234\", 16\n    )\n    await Timer(2, units=\"ns\")\n    if dut.destination_reg.value == expected:\n        total_score += 1\n\n    # Final Score Check\n    if total_score == max_score:\n        dut._log.info(f\"All tests passed! Total Score: {total_score}/{max_score}\")\n    else:\n        dut._log.error(f\"Some tests failed. Total Score: {total_score}/{max_score}\")\n\n", "src/test_runner.py": "# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n\n# test_runner.py\n\nimport os\nfrom cocotb_tools.runner import get_runner\nimport pytest\nimport pickle\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\n\n@pytest.mark.tb\ndef test_runner():\n\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ps\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n\n\nif __name__ == \"__main__\":\n   test_runner()"}}}
{"id": "cvdp_copilot_vending_machine_0001", "categories": ["cid003", "medium"], "input": {"prompt": "# Vending Machine\n\nDesign a vending machine module using SystemVerilog. The vending machine allows users to select items, insert coins, calculate change, and handle transaction cancellations. It includes error handling for invalid operations and proper validation of coin inputs. The design ensures the machine resets to the idle state upon cancellation or error.\n\n## **Interface**\n\n### **Inputs**\n- **clk:** Clock signal for timing and synchronizing state transitions, operating on the rising edge.\n- **rst:** Asynchronous, active-high reset signal that resets all internal states, outputs, and accumulated values, returning the machine to the `IDLE` state.\n- **item_button:** Signal indicating that the user has pressed the button to initiate item selection (active high). This acts as a toggle signal and should only register on the rising edge.\n- **[2:0]item_selected:** 3-bit input representing the item chosen by the user, with valid values corresponding to the four available items (valid values: `3'b001` to `3'b100`).\n- **[3:0]coin_input:** 4-bit input representing the value of the coin inserted, with valid values of 1, 2, 5, or 10 units.\n- **cancel:** Signal allowing the user to cancel the current transaction before the item is dispensed (active high).\n\n### **Outputs**\n- **dispense_item:** Indicates that the selected item is ready for dispensing after the required amount is met. Active high for one clock cycle when the item is being dispensed.\n- **return_change:** Signals that excess coins are being returned as change. Active high for one clock cycle when change is being returned.\n- **[4:0]item_price:** 5-bit output displaying the price of the currently selected item.\n- **[4:0]change_amount:** 5-bit output representing the amount of change to be returned if excess coins were inserted.\n- **[2:0]dispense_item_id:** 3-bit output indicating the ID of the item being dispensed.\n- **error:** Indicates that an invalid operation has occurred, such as inserting coins without selecting an item or entering invalid coin values. Active high for one clock cycle during an error condition.\n- **return_money:** Indicates that all inserted money should be returned due to cancellation or an error. Active high for one clock cycle when returning money.\n\n## **Requirements**\n\n1. **Basic Transaction Flow**\n   - When the user presses `item_button` in the `IDLE` state, the machine transitions to the `ITEM_SELECTION` state and waits for the item selection.\n   - The user selects an item using `item_selected`. Upon a valid selection, the machine immediately displays the item's price on `item_price`.\n   - The user inserts valid coins through `coin_input`. The machine accumulates the inserted coins and compares the total amount to the selected `item_price`. Only 1, 2, 5, or 10 unit coin values are accepted. Invalid coin inputs trigger an error.\n   - Once the accumulated coins meet or exceed `item_price`, the machine sets `dispense_item` high for one cycle, signaling that the item will be dispensed.\n   - If excess coins were inserted, the machine calculates the change and, in the following clock cycle, sets `return_change` high for one cycle, with the change amount on `change_amount`.\n\n2. **Cancel Transaction Flow**\n   - At any time before the item is dispensed, the user can cancel the transaction by setting `cancel` high.\n   - Upon detecting `cancel`, the machine in the next clock cycle `error` sets to high for one cycle and moves to the `RETURN_MONEY` state.\n   - In the `RETURN_MONEY` state, if the accumulated amount is greater than zero, the machine sets `return_money` high for one cycle to return all accumulated coins.\n   - The machine then resets to the `IDLE` state in the next clock cycle, clearing all outputs and internal registers, ready for a new transaction.\n\n3. **Invalid Item Selection Handling**\n   - If the user selects an invalid item ID (an item without a defined price), the machine immediately triggers the `error` signal for one cycle and moves to the `RETURN_MONEY` state.\n   - In the `RETURN_MONEY` state, any inserted coins are returned, and the machine resets to `IDLE`.\n\n4. **Coin Validation and Error Handling**\n   - Only coin values of 1, 2, 5, and 10 units are accepted.\n   - If any other coin value is provided via `coin_input`, the machine triggers the `error` signal and moves to error handling.\n   - The machine sets `error` high for one cycle, sets `return_money` high in the same cycle to return all inserted coins, and resets to `IDLE`.\n\n5. **Inserting Coins Without Item Selection**\n   - If the user attempts to insert coins without first pressing `item_button` and selecting an item, the machine triggers the `error` signal for one cycle, moves to the `RETURN_MONEY` state, returns any inserted coins, and resets to `IDLE`.\n   - This ensures a structured flow where item selection is required before coin insertion.\n\n6. **Reset During Transaction**\n   - If `rst` is set high during any stage of the transaction, the machine immediately resets to `IDLE`.\n   - All internal states, outputs, and accumulated values are cleared, ready for a new transaction.\n\n7. **Handling Continuous Signals for `item_button` and `cancel`**\n   - `item_button` and `cancel` are treated as toggle signals and should only respond to the rising edge for state transitions.\n   - This prevents the machine from registering continuous signals, which could cause unintended state transitions.\n\n## **State Machine and Control Logic**\n\nThe vending machine operates using a finite state machine (FSM) with the following states:\n\n1. **IDLE State:**\n   - The default state, waiting for the user to initiate a transaction by pressing `item_button`.\n   - If `item_button` is pressed, the machine transitions to `ITEM_SELECTION`.\n   - If coins are inserted without pressing `item_button`, the machine triggers an error, moves to `RETURN_MONEY`, and resets to `IDLE`.\n\n2. **ITEM_SELECTION State:**\n   - The machine waits for a valid item selection.\n   - Upon a valid `item_selected`, the machine displays the price on `item_price` and transitions to `PAYMENT_VALIDATION`.\n   - If `cancel` is pressed or an invalid item is selected, the machine triggers an error, moves to `RETURN_MONEY`, and resets to `IDLE`.\n\n3. **PAYMENT_VALIDATION State:**\n   - Valid coins are accumulated in `coins_accumulated` until the total meets or exceeds the `item_price`.\n   - If the amount is sufficient, the machine transitions to `DISPENSING_ITEM`.\n   - If `cancel` is pressed or an invalid coin is inserted, the machine triggers an error, moves to `RETURN_MONEY`, and resets to `IDLE`.\n\n4. **DISPENSING_ITEM State:**\n   - The machine sets `dispense_item` high for one cycle to dispense the selected item.\n   - If the inserted amount exceeds the `item_price`, the machine calculates the change and transitions to `RETURN_CHANGE`.\n   - If no excess coins remain, the machine resets to `IDLE`.\n\n5. **RETURN_CHANGE State:**\n   - The machine sets `return_change` high for one cycle to return the calculated `change_amount`.\n   - Once the change is returned, the machine resets to `IDLE`.\n\n6. **RETURN_MONEY State:**\n   - The machine sets `return_money` high for one cycle to refund all `coins_accumulated` due to a cancel or error.\n   - After returning the money, the machine resets to `IDLE`, ensuring no transaction lockups.\n   \n## Timing and Synchronization\n\n- Clock: The `clk` signal is assumed to be the rising edge of the clock.\n- Reset: The `reset` signal (`rst`) is active-high and asynchronous, which clears all internal states, outputs, and registers upon assertion.\n- State Transitions: The system uses a finite-state machine (FSM) with the following states: IDLE, ITEM_SELECTION, PAYMENT_VALIDATION, DISPENSING_ITEM, RETURN_CHANGE, and RETURN_MONEY.\n\n## Constraints and Edge Cases\n\n- Valid Coin Inputs: Only coins with values of 1, 2, 5, and 10 units are accepted. If any other values are inserted, an error occurs.\n- Invalid Item Selection: Only item selections within the range 3'b001 to 3'b100 are valid. Selecting an invalid item triggers an error.\n- Cancellation and Return of Money:  If the transaction is canceled or if an error occurs, all inserted coins are returned, and the system transitions back to the IDLE state.", "context": {}}, "output": {"response": "", "context": {"rtl/vending_machine.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v ", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/vending_machine.sv\nTOPLEVEL        = vending_machine\nMODULE          = test_vending_machine\nPYTHONPATH      = /src\nHASH            = b6c86a459bbdb651489db82d2127c8a5d50f3b45\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(plusargs=[], parameter={}):\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs)\n\n\n@pytest.mark.parametrize(\"test\", range(10))\ndef test_vending_machine1(test):\n        runner()\n", "src/test_vending_machine.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ReadOnly , Timer\n\nimport harness_library as hrs_lb\nimport random\n\n# Task to select item\nasync def select_item(dut, item):\n    await RisingEdge(dut.clk)\n    dut.item_button.value = 1   \n    await RisingEdge(dut.clk)\n    dut.item_selected.value = item\n    dut.item_button.value = 0\n    await RisingEdge(dut.clk)\n\n# Task to insert coins\nasync def insert_coins(dut, amount):\n    dut.coin_input.value = amount\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk)\n\n# Task to simulate cancel button press\nasync def cancel_purchase(dut):\n    dut.cancel.value = 1\n    await RisingEdge(dut.clk)\n    dut.cancel.value = 0\n\n# Task to check if the item is dispensed and no errors occurred\nasync def check_dispense(dut, expected_item_id):\n    await RisingEdge(dut.clk)\n    assert dut.dispense_item.value == 1, f\"Expected item to be dispensed!\"\n    await RisingEdge(dut.clk)\n    assert dut.dispense_item_id.value == expected_item_id, f\"Dispensed item ID mismatch, got {dut.dispense_item_id.value}, expected {expected_item_id}\"\n    assert dut.error.value == 0, f\"Error signal should not be high!\"\n    assert dut.return_change.value == 0, \"Change should not be returned change in this clock cycle\"\n    print(f\"Dispense_item_id  - {int(dut.dispense_item_id.value)} , Error - {int(dut.error.value)} \")\n\n# Task to check if the correct change is returned\nasync def check_change(dut, expected_change): \n    if expected_change > 0:\n        await RisingEdge(dut.clk)\n        assert dut.return_change.value == 1, \"Change should be returned\"\n        print(f\"expected_chang amount - {int(expected_change)}\")\n        print(f\"Return change amount - {int(dut.change_amount.value)}\")\n        assert dut.change_amount.value == expected_change, f\"Expected change {expected_change}, but got {dut.change_amount.value}\"\n    else:\n        assert dut.return_change.value == 0, \"No change should be returned\"\n    await RisingEdge(dut.clk)\n    assert dut.return_change.value == 0, \"Change should not be returned after one cycle\"\n    assert dut.change_amount.value == 0, f\"Expected change {0}, but got {dut.change_amount.value}\"\n\n# Task to randomly buy an item with random coins and validate results\nasync def random_purchase(dut):\n    item_id = random.randint(1, 4)\n    item_prices = {1: 5, 2: 10, 3: 15, 4: 20}\n    expected_price = item_prices[item_id]\n    dut._log.info(f\"Randomly selecting item {item_id}, expected price: {expected_price}\")\n\n    await select_item(dut, item_id)\n\n    # Randomly insert coins until we meet or exceed the price\n    total_inserted = 0\n    while total_inserted < expected_price:\n        coin = random.choice([1, 2, 5, 10])  \n        await insert_coins(dut, coin)\n        total_inserted += coin\n        dut._log.info(f\"Inserted coin: {coin}, total so far: {total_inserted}\")\n\n    await check_dispense(dut, item_id)\n    expected_change = total_inserted - expected_price   \n\n    await check_change(dut, expected_change)\n    await Timer(50, units='ns')\n\n# Task to randomly cancel a purchase\nasync def random_cancel_purchase(dut):\n    item_prices = {1: 5, 2: 10, 3: 15, 4: 20}\n    item_id = random.randint(1, 4)\n    expected_price = item_prices[item_id]\n\n    dut._log.info(f\"Randomly selecting item {item_id} with price {expected_price} and canceling the operation\")\n    await select_item(dut, item_id)\n    dut.coin_input.value = 1\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 2\n    await RisingEdge(dut.clk) \n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk)\n    await cancel_purchase(dut)\n    await RisingEdge(dut.clk)\n    assert dut.error.value == 1, \"Error should be high for cancellation\"\n    await RisingEdge(dut.clk)\n    assert dut.return_money.value == 1, \"Expected money to be returned after cancellation\"\n    assert dut.error.value == 0, \"Error should not be high for cancellation after clock\"\n    await RisingEdge(dut.clk)\n    assert dut.return_money.value == 0, \"when cancle Expected money not be returned after clock\"\n    await Timer(50, units='ns')\n\n# Task to simulate invalid item selection\nasync def invalid_item_selection(dut):\n    invalid_item_id = random.choice([0, 6, 5, 7])\n    dut._log.info(f\"Selecting invalid item ID: {invalid_item_id}\")\n    await select_item(dut, invalid_item_id)\n    dut.coin_input.value = 2\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk)\n    assert dut.error.value == 1, \"Error should be high for invalid item selection\"\n    assert dut.dispense_item.value == 0, \"No item should be dispensed\"\n    await insert_coins(dut, 0)\n    assert dut.error.value == 0, \"Error should not be high for invalid item selection after clock\" \n    await Timer(50, units='ns')\n\n# Task to simulate multiple purchases without resetting the machine\nasync def multiple_purchases_without_reset(dut):\n    for _ in range(3):  \n        await random_purchase(dut)\n        await RisingEdge(dut.clk) \n    await Timer(50, units='ns')\n\n# Task to simulate random coin validation\nasync def random_coin_validation(dut):\n    coin = random.choice([1,2,5,7,10]) \n    dut._log.info(f\"Inserting random coin value: {coin}\")\n\n    await select_item(dut, random.randint(1, 4)) \n    await insert_coins(dut, coin)\n    if coin == 7:\n        assert dut.error.value == 1, \"Expected error for invalid coin input\"\n    else:\n        assert dut.error.value == 0, \"Unexpected error for valid coin input\"\n    await insert_coins(dut, 0)\n    await Timer(50, units='ns')\n\nasync def reset_during_transaction(dut):\n    await select_item(dut, 3)\n    await insert_coins(dut, 5)\n    await insert_coins(dut, 0)\n    dut._log.info(\"Resetting the machine during the transaction.\")\n    dut.rst.value = 1\n    dut.item_selected.value = 0\n    await Timer(30, units='ns')\n\n    assert dut.dispense_item.value == 0, \"No item should be dispensed after reset\"\n    assert dut.return_money.value == 0, \"No money should be returned after reset\"\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n    dut._log.info(\"reset_during_transaction: Machine successfully reset during transaction.\")\n    await Timer(50, units='ns')\n\n# Task to simulate inserting coins without selecting an item\nasync def insert_coins_without_selecting_item(dut):\n    cocotb.log.info(\"Simulating coin insertion without selecting an item\")\n    await RisingEdge(dut.clk)\n    dut.item_button.value = 1   \n    dut.item_selected.value = 0\n    await RisingEdge(dut.clk)\n    dut.item_button.value = 0\n    await RisingEdge(dut.clk)\n    await insert_coins(dut, 10)\n\n    assert dut.error.value == 1, \"Error should be raised when inserting coins without selecting an item\"\n    await RisingEdge(dut.clk)  \n    assert dut.error.value == 0, \"Error should  not be raised when inserting coins without selecting an item after a clock\"\n    assert dut.return_money.value == 1, \"Money should be returned when no item is selected\"\n    await insert_coins(dut, 0)\n    await RisingEdge(dut.clk)\n\n\n    assert dut.dispense_item.value == 0, \"No item should be dispensed without item selection\"\n    assert dut.return_money.value == 0, \"Money should not be returned when no item is selected after a clock\"\n    cocotb.log.info(\"Simulating coin insertion without selecting an item: Coins returned when no item is selected.\")\n    await Timer(50, units='ns')\n\n# Task to cancel after selecting an item\nasync def cancel_after_selecting_item(dut):\n    item_id = 2\n    await select_item(dut, item_id)\n    dut._log.info(f\"Selected item {item_id}\")\n\n    dut.cancel.value = 1\n    await RisingEdge(dut.clk)\n    dut.cancel.value = 0\n    await RisingEdge(dut.clk)\n    assert dut.error.value == 1, \"Expected error signal to be set after cancellation\"\n    await RisingEdge(dut.clk)\n\n    await RisingEdge(dut.clk)\n    assert dut.error.value == 0, \"Expected error signal not be set in cancellation after a clock  \"\n    await Timer(50, units='ns')   \n\n\n# Task to insert coins without selecting an item\nasync def insert_coins_without_item_button(dut):\n    coin = 5\n    await RisingEdge(dut.clk) \n    dut.item_selected.value = 0\n    await RisingEdge(dut.clk) \n    dut.coin_input.value = coin\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk) \n    assert dut.error.value == 1, \"Expected error signal to be set when coins are inserted without item selection\"\n    dut._log.info(f\"Inserted coin: {coin} without selecting an item\")\n    await RisingEdge(dut.clk)   \n    assert dut.return_money.value == 1, \"Expected return_money signal to be high when no item selected\"\n    assert dut.error.value == 0, \"Expected error signal not be set when coins are inserted without item selection after a clock\"\n    dut._log.info(\"Coins returned successfully when inserted without item selection.\")\n    await RisingEdge(dut.clk) \n    assert dut.return_money.value == 0, \"Expected return_money signal not be high when no item selected after a clock\"\n    await Timer(50, units='ns')\n\n# Task to insert an invalid coin during payment validation\nasync def insert_invalid_coin_during_payment_validation(dut):\n    item_id = 1\n    await select_item(dut, item_id)\n    dut._log.info(f\"Selected item {item_id}\")\n    await insert_coins(dut, 1)\n    dut.coin_input.value = 3\n    await RisingEdge(dut.clk)   \n    dut.coin_input.value = 0 \n    await RisingEdge(dut.clk) \n    assert dut.return_money.value == 1, \"Expected return_money signal to be high after inserting invalid coin\"\n    assert dut.error.value == 1, \"Expected error signal to be set after inserting invalid coin\"\n    dut._log.info(\"Invalid coin insertion handled successfully.\")\n    await RisingEdge(dut.clk) \n\n    assert dut.return_money.value == 0, \"Expected return_money signal not be high after inserting invalid coin after a clock\"\n    assert dut.error.value == 0, \"Expected error signal not be set after inserting invalid coin after a clock\"\n    await Timer(50, units='ns') \n\n\n@cocotb.test()\nasync def test_vending_machine(dut):\n\n    print(\"start of vending machine\")\n\n    # Start the clock with a 10ns time period (100 MHz clock)\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.rst, duration_ns=25, active=False)\n\n    await RisingEdge(dut.clk) \n\n    await random_purchase(dut)\n\n    await random_cancel_purchase(dut)\n\n    await invalid_item_selection(dut)\n\n    await multiple_purchases_without_reset(dut)\n\n    await random_coin_validation(dut)\n\n    await reset_during_transaction(dut)\n\n    await random_purchase(dut)\n\n    await insert_coins_without_selecting_item(dut)\n\n    await cancel_after_selecting_item(dut)\n\n    await insert_coins_without_item_button(dut)\n\n    await insert_invalid_coin_during_payment_validation(dut)\n"}}}
{"id": "cvdp_copilot_vga_controller_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Develop a System Verilog RTL module `vga_controller` that takes a 25 MHz clock signal, a reset signal, and an 8-bit color input as inputs, and generates the necessary VGA synchronization and color signals to drive a VGA-compatible display. The design should follow the VGA timing protocol for a 640x480 resolution.\n\n### Design Specification :\nThe `vga_controller` module implements a VGA signal generation mechanism to output pixel color data and synchronize signals, controlling the display of pixels on the screen according to the VGA timing standard. The controller should divide each frame into defined intervals and maintain precise horizontal and vertical timing cycles to manage pixel rendering and screen refresh.\n\n###  Interface :\n\n#### Inputs :\n  - `clock`(1-bit): 25 MHz clock signal to control the VGA timings.\n  - `reset`(1-bit): An ACTIVE-HIGH  asynchronous signal to initialize the VGA controller. When HIGH, the module performs the \n  following:\n        -  Initializes the horizontal and vertical FSMs to their ACTIVE state.\n        -  Resets the 10-bit counters (h_counter and v_counter) to zero.\n        -  Sets the 1-bit output signal line_done to LOW.\n  - `color_in`([7:0], 8-bit): Pixel color data in `RRRGGGBB` format, where `color_in` [7:5] represents `red`, `color_in`[4:2] represents `green`, and `color_in`[1:0] represents blue intensities.\n\n#### Outputs :\n  - `hsync`(1-bit): An ACTIVE-HIGH in this signal indicates the occurrence of a horizontal sync pulse.\n  - `vsync`(1-bit): An ACTIVE-HIGH in this signal indicates the occurrence of a vertical sync pulse.\n  - `red`, `green`, `blue` ([7:0],8-bit each):  RGB color signals, used to control pixel color output to the VGA DAC (Digital-to-Analog Converter)\n  - `next_x`, `next_y` ([9:0], 10-bit each): Current pixel coordinates within the active display area\n  - `sync`(1-bit): ACTIVE HIGH Sync signal for VGA; should be held constant at 0.\n  - `clk` (1-bit): VGA clock, directly connected to the input clock.\n  - `blank`(1-bit): ACTIVE HIGH Blank signal. When HIGH, it indicates the occurrence of a blanking interval.\n  \n### Features :\n  - `640x480 Resolution`: Support VGA display timing for a resolution of 640x480. \n  - `Sync Signal Generation`: Generate `hsync` and `vsync` signals appropriately for VGA display synchronization. \n  - `Pixel Position Tracking`: Track the current pixel position in terms of `next_x` and `next_y` for each frame, wrapping to zero outside of the active display area.\n  - `Color Output Control`: Display the color values (red, green, blue) when within the active display region; output zero for blanking periods.\n    \n### VGA Timing Protocol for a 640 x 480 resolution :\n- Step 1: The VGA pixel clock runs at 25 MHz\n- Step 2: Both `hsync` and `vsync` start in active mode (logic level HIGH).\n- Step 3: `hsync` remains HIGH while displaying 640 pixels across one row(640 cycles)\n- Step 4: For each of the 640 clock cycles, the voltages on the `red`, `green`, and `blue` output lines generate an 8-bit value corresponding to their intensities. These intensities are converted into a voltage ranging between 0 and 0.7 V by three separate Digital to Analog Converter (DAC) units provided externally. The DAC implementation is not included in the design.\n- Step 5: After 640 clock cycles, the `red`, `green`, and `blue` output lines are set to 0000_0000 and `hsync` remains HIGH for additional 16-pixel clocks. This period is referred as FRONTPORCH.\n- Step 6: After the 16-pixel clocks, `hsync` is set to logic-level LOW for 96-pixel clocks. This period is referred as HORIZONTAL SYNC PULSE period\n- Step 7: After the 96-pixel clocks `hsync` is set to logic-level HIGH through for 48-pixel clocks. This period is referred as BACKPORCH.\n- Step 8: `hsync` then returns to the start of active mode (step 2, above), and the process is repeated for the next row of pixels. Each row of pixels is a line.\n- Step 9: `vsync` remains in active mode (logic level HIGH) for 480 lines.\n- Step 10: After 480 lines, the voltages on the `red`, `green`, and `blue` output lines are set to 0, and the VSYNC line remains high through its frontporch (10 lines)\n- Step 11: `vsync` is set to logic-level LOW for 2 lines (this is the vertical sync pulse).\n- Step 12: `vsync` is set to logic-level HIGH through its backporch (33 lines).\n- Step 13: `vsync` then returns to the start of active mode (step 2, above), and the process is repeated for the next frame.\n\n### Parameters :\n  #### Horizontal Timing:\n  - `H_ACTIVE`: Number of cycles in the active display period (fixed at 640).\n  - `H_FRONT`: Number of cycles in the front porch period (fixed at 16).\n  - `H_PULSE`: Number of cycles for the horizontal sync pulse (fixed at 96).\n  - `H_BACK`: Number of cycles for the back porch period (fixed at 48)\n  \n  #### Vertical Timing:\n   - `V_ACTIVE`: Number of lines in the active display area (fixed at 480).\n   - `V_FRONT`: Number of lines in the vertical front porch period (fixed at 10).\n   - `V_PULSE`: Number of lines in the vertical sync pulse (fixed at 2).\n   - `V_BACK`: Number of lines in the vertical back porch period (fixed at 33)\n   \n## `1. State Tracking`:\nTwo state machines govern the horizontal and vertical cycles:\nHorizontal State Machine: Transitions through the active, front porch, pulse, and back porch states.\nVertical State Machine: Transitions similarly but advances one line for each completed horizontal frame.\n\n## 2. Counters:\n`h_counter ([9:0], 10-bit)`: Tracks the current pixel position within a horizontal line.\n`v_counter ([9:0], 10-bit)`: Tracks the current line position within a frame.\n\n## `3. Sync Signals`:\n`hsync` and `vsync`: Generated based on the horizontal and vertical state machines, respectively, with sync pulses active during their corresponding pulse periods.\n\n## `4. Color Control Signals`:\nred, green, blue Registers: Hold pixel color data based on color_in during the active display period.\nOutside the active period, these registers are cleared to ensure blanking.\n\n## `Functional Behavior`:\n### `1. Reset Behavior`:\nDuring Reset (reset = 1):\n- 10-bit counters `hcounter` and `vcounter` are set to zero\n- Horizontal FSM is set to the `H_ACTIVE` state and Vertical FSM is set to the `V_ACTIVE` state\n- `line_done` is set to logic LOW.\n\n### `2. Horizontal and Vertical State Machine Operation`:\nThe horizontal state machine increments `h_counter` and transitions between states (active, front porch, sync pulse, back porch) based on predefined timing parameters.\nThe vertical state machine increments `v_counter` and transitions similarly, but only when the horizontal machine signals the end of a line.\n\n### `3. Pixel Position Tracking:`\n`next_x` and `next_y` track the upcoming pixel's coordinates during the active display period. These are reset outside the active region.\n\n### `4. RGB Signal Assignment`:\nActive Period: RGB outputs are derived from `color_in`, scaled to 8 bits.\n -  `red`     = {`color_in[7:5]`, 5'd0};\n -  `green` = {`color_in[4:2]`, 5'd0};\n -  `blue`   = {`color_in[1:0]`, 6'd0};\nBlanking Period: RGB outputs are set to zero.\n\n### `5. Display Control`:\nblank Signal: Combines hsync and vsync to indicate whether the display is in a blanking interval.\nsync Signal: Fixed to LOW in this design.\n\n## Key Notes:\n- All logic is implemented within a single always_ff block, without explicitly separating combinational and sequential logic.\n- State transitions and counter updates are triggered on the positive edge of the clock.\n- The module ensures proper synchronization and blanking for a VGA display with a resolution of 640x480 pixels at 25 MHz clock input.\n \n### `Sample Signal Waveform` :\n```wavedrom\n{\n  \"signal\": [\n    {\"name\": \"clock\", \"wave\": \"p.|.|.|.|.|.|.|.|.\", \"data\": [\"Clock\"]},\n    {\"name\": \"reset\", \"wave\": \"1.0...............\", \"data\": [\"Reset\"]},\n    {\n      \"name\": \"h_counter\",\n      \"wave\": \"3.45678999.9999999\",\n      \"data\": [\n        \"0 (Active Start)\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"...\",\n        \"639 (Active End)\",\n        \"0 (Front Porch Start)\",\n        \"...\",\n        \"15 (Front Porch End)\",\n        \"0 (Sync Pulse Start)\",\n        \"...\",\n        \"95 (Sync Pulse End)\",\n        \"0 (Back Porch Start)\",\n        \"...\",\n        \"47 (Back Porch End)\",\n        \"0 (Active Start)\"\n      ]\n    },\n    {\"name\": \"line_done\", \"wave\": \"3................5\", \"data\": [\"LOW (Start)\", \"HIGH (Back Porch End)\"]},\n    {\"name\": \"hsync\", \"wave\": \"0.1........0..1..0\", \"data\": [\"HIGH (Active)\", \"LOW (Sync Pulse)\"]},\n    {\n      \"name\": \"v_counter\",\n      \"wave\": \"3...............45\",\n      \"data\": [\n        \"0 (Initial)\",\n        \"0 (No Increment )\",\n        \"1 (Row Complete)\"\n      ]\n    },\n    {\"name\": \"vsync\", \"wave\": \"0.................\", \"data\": [\"LOW (Inactive)\", \"LOW (No Sync Pulse)\"]},\n    {\"name\": \"blank\", \"wave\": \"0.................\", \"data\": [\"LOW (Inactive)\", \"LOW (No Sync Pulse)\"]}\n  ],\n  \"foot\": {\n    \"text\": \"This shows the interaction between the Horizontal and Vertical FSMs. The Vertical FSM increments v_counter when the Horizontal FSM signals line_done at the end of a row.\"\n  },\n  \"config\": {\n    \"hscale\": 4\n  }\n}\n```", "context": {}}, "output": {"response": "", "context": {"rtl/vga_controller.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  direct:\n    image: __OSS_SIM_IMAGE__ #__OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    working_dir : /code/rundir  \n    env_file    : ./src/.env\n    command     : pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    # command     : python3 /src/test_runner.py\n", "src/.env": "SIM             = icarus\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/vga_controller.sv\nTOPLEVEL        = vga_controller\nMODULE          = test_vga_controller\nPYTHONPATH      = /src\nHASH            = 1-vga_controller_rtl_generation_issue-1\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb_tools.runner import get_runner\nimport pytest\nimport logging\n\n# Getting environment variables\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang = os.getenv(\"TOPLEVEL_LANG\")\nsim = os.getenv(\"SIM\", \"icarus\")\ntoplevel = os.getenv(\"TOPLEVEL\")\nmodule = os.getenv(\"MODULE\", \"vga_controller_cocotb_testbench\")\nwave = os.getenv(\"WAVE\")\n\n# Define the runner function\ndef runner():\n    \"\"\"Runs the simulation for the VGA driver.\"\"\"\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True if wave == \"1\" else False,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True if wave == \"1\" else False)\n\n# Pytest function to run the testbench\ndef test_vga_driver():\n    \"\"\"Pytest function to invoke the Cocotb test for VGA driver.\"\"\"\n    print(\"Running VGA Driver Cocotb Test...\")\n    runner()\n\n", "src/test_vga_controller.py": "import cocotb\nfrom cocotb.triggers import Timer, RisingEdge\nimport random\nfrom cocotb.result import TestSuccess\n\n# Constants for 640x480 VGA with 25 MHz clock\nCLOCK_PERIOD_NS = 40\nH_ACTIVE_PIXELS = 640\nH_FRONT_PORCH = 16\nH_SYNC_PULSE = 96\nH_BACK_PORCH = 48\n\nV_ACTIVE_LINES = 480\nV_FRONT_PORCH = 10\nV_SYNC_PULSE = 2\nV_BACK_PORCH = 33\n\n@cocotb.test()\nasync def test_vga_controller(dut):\n    \"\"\"VGA Controller Test with Phase Tracking, limited to 1 frame, with input stimulus.\"\"\"\n\n    # Start clock generator\n    cocotb.start_soon(clock_gen(dut, CLOCK_PERIOD_NS))\n\n    # Apply reset\n    dut.reset.value = 1\n    await Timer(100, units=\"ns\")\n    dut.reset.value = 0\n    dut._log.info(\"Reset released\")\n\n    # Initialize counters\n    cycle_count = 0\n    line_count = 0\n\n    # Define input changes\n    color_patterns = [\n        0b11100011,  # Red high, blue high\n        0b00011100,  # Green high\n        0b11111111,  # White color\n        0b00000000   # Black color\n    ]\n\n    # Apply a new color pattern at the start of the frame\n    new_color = random.choice(color_patterns)\n    dut.color_in.value = new_color\n    dut._log.info(f\"Color pattern applied at frame start: {bin(new_color)}\")\n\n    # Track exactly one complete frame\n    while line_count < V_ACTIVE_LINES + V_FRONT_PORCH + V_SYNC_PULSE + V_BACK_PORCH:\n        await RisingEdge(dut.clock)\n\n        # Track Horizontal Phases\n        if cycle_count == 0:\n            dut._log.info(\"Horizontal Phase: Active Region started.\")\n        elif cycle_count == H_ACTIVE_PIXELS:\n            dut._log.info(\"Horizontal Phase: Front Porch started.\")\n        elif cycle_count == H_ACTIVE_PIXELS + H_FRONT_PORCH:\n            dut._log.info(\"Horizontal Phase: Sync Pulse started.\")\n        elif cycle_count == H_ACTIVE_PIXELS + H_FRONT_PORCH + H_SYNC_PULSE:\n            dut._log.info(\"Horizontal Phase: Back Porch started.\")\n\n        # Check for end of horizontal line\n        if cycle_count == H_ACTIVE_PIXELS + H_FRONT_PORCH + H_SYNC_PULSE + H_BACK_PORCH - 1:\n            dut._log.info(\"Horizontal Line completed.\")\n            cycle_count = 0  # Reset cycle count for next line\n            line_count += 1  # Increment line count\n\n            # Track Vertical Phases\n            if line_count == 0:\n                dut._log.info(\"Vertical Phase: Active Region started.\")\n            elif line_count == V_ACTIVE_LINES:\n                dut._log.info(\"Vertical Phase: Front Porch started.\")\n            elif line_count == V_ACTIVE_LINES + V_FRONT_PORCH:\n                dut._log.info(\"Vertical Phase: Sync Pulse started.\")\n            elif line_count == V_ACTIVE_LINES + V_FRONT_PORCH + V_SYNC_PULSE:\n                dut._log.info(\"Vertical Phase: Back Porch started.\")\n\n            # Check for end of frame\n            if line_count == V_ACTIVE_LINES + V_FRONT_PORCH + V_SYNC_PULSE + V_BACK_PORCH:\n                dut._log.info(\"One Vertical Frame completed.\")\n                break  # Stop after one frame\n\n        else:\n            # Increment horizontal cycle count\n            cycle_count += 1\n\n    # End the test successfully after 1 frame\n    raise TestSuccess(\"VGA Controller phase tracking test completed after 1 frame with input stimulus.\")\n\n\nasync def clock_gen(dut, period_ns):\n    \"\"\"Clock generation\"\"\"\n    while True:\n        dut.clock.value = 0\n        await Timer(period_ns / 2, units=\"ns\")\n        dut.clock.value = 1\n        await Timer(period_ns / 2, units=\"ns\")\n\n"}}}
{"id": "cvdp_copilot_wb2ahb_0001", "categories": ["cid003", "medium"], "input": {"prompt": "Design a System Verilog module named `wishbone_to_ahb_bridge`. The module facilitates communication between a Wishbone master and an AHB slave, translating Wishbone protocol signals into corresponding AHB protocol signals. The bridge supports single transfers and provides configurable data width for byte, halfword, and word-level transactions.\n\n## Specifications\n\n### Inputs\n- **Wishbone Ports (from WB Master):**\n  - `clk_i`: Clock signal for Wishbone operations.\n  - `rst_i`: Active-low reset signal to initialize the bridge.\n  - `cyc_i`: Indicates a valid Wishbone transaction cycle.\n  - `stb_i`: Strobe signal for valid data on the Wishbone interface.\n  - `sel_i[3:0]`: Byte enables to select which bytes are active.\n  - `we_i`: Write enable signal.\n  - `addr_i[31:0]`: Address for the Wishbone transaction.\n  - `data_i[31:0]`: Write data from the Wishbone master.\n- **AHB Ports (from AHB Slave):**\n  - `hclk`: Clock signal for AHB operations.\n  - `hreset_n`: Active-low reset signal for the AHB interface.\n  - `hrdata[31:0]`: Read data from the AHB slave.\n  - `hresp[1:0]`: AHB response signal.\n  - `hready`: Indicates when the AHB slave is ready.\n\n### Outputs\n- **Wishbone Outputs:**\n  - `data_o[31:0]`: Read data back to the Wishbone master.\n  - `ack_o`: Acknowledge signal for Wishbone operations.\n- **AHB Outputs:**\n  - `htrans[1:0]`: AHB transaction type.\n  - `hsize[2:0]`: Size of the AHB transfer.\n  - `hburst[2:0]`: Burst type (always single in this design).\n  - `hwrite`: Write enable signal for AHB transactions.\n  - `haddr[31:0]`: Address for the AHB transaction.\n  - `hwdata[31:0]`: Write data to the AHB slave.\n\n## Functional Requirements\n1. **Protocol Translation**:\n   - Translate Wishbone protocol signals to AHB-compliant signals.\n   - Support byte, halfword, and word-level transactions based on `sel_i`.\n\n2. **Address Fixing**:\n   - Derive AHB-compliant addresses from Wishbone addresses using `sel_i`.\n\n3. **Single Transfer Support**:\n   - Only SINGLE AHB transfers (`hburst = 3'b000`) are supported.\n\n4. **Data Handling**:\n   - Perform endian conversion for read and write data between Wishbone and AHB.\n\n5. **Control Signals**:\n   - Use an FSM-like approach to manage transaction phases (`htrans`), including IDLE, NON-SEQUENTIAL, and BUSY states.\n\n6. **Pipeline Management**:\n   - Handle data and address phases for AHB transactions with proper synchronization using `hready`.\n\n## Implementation Details\n- **Endian Conversion**:\n  - Convert between Wishbone's little-endian format and AHB's data handling.\n  - Use `sel_i` to determine active bytes in a transfer.\n\n- **Signal Holding**:\n  - To ensure proper synchronization, hold transaction attributes (address, size, transaction type, etc.) during AHB operations.\n\n- **Reset Behavior**:\n  - Ensure all internal registers are reset to default values when `rst_i` or `hreset_n` is asserted.\n\n- **Latency**:\n  - Ensure proper acknowledgment (`ack_o`) to the Wishbone master only after completing the AHB transaction (`hready` is asserted).\n\n\n## Edge Cases\n1. **Invalid Byte Selection**:\n   - Handle invalid or conflicting `sel_i` values gracefully without causing data corruption.\n\n2. **AHB Slave Busy**:\n   - Test the behavior when the AHB slave asserts `hready` late, stalling the transaction.\n\n3. **Back-to-Back Transactions**:\n   - Ensure correct operation when Wishbone initiates a new transaction immediately after the previous one completes.\n\n", "context": {}}, "output": {"response": "", "context": {"rtl/wishbone_to_ahb_bridge.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/code/rundir/.cache /src/test_runner.py -v   \n    ", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/wishbone_to_ahb_bridge.sv\nTOPLEVEL        = wishbone_to_ahb_bridge\nMODULE          = test_wishbone_to_ahb_bridge\nPYTHONPATH      = /src\nHASH            = a1b57ccf96ae7d8531e7c09ebba4c051993a24de\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 2, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n            ", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(plusargs=[], parameter={}):\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs)\n\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_areg_param(test):\n        runner()\n        ", "src/test_wishbone_to_ahb_bridge.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nimport harness_library as hrs_lb\n@cocotb.test()\nasync def test_wishbone_to_ahb_bridge(dut):\n    \"\"\"Testbench for Wishbone-to-AHB Bridge\"\"\"\n\n    # Clock generation\n    cocotb.start_soon(Clock(dut.clk_i, 10, units=\"ns\").start())\n    cocotb.start_soon(Clock(dut.hclk, 10, units=\"ns\").start())\n\n    # Initialize inputs\n    dut.rst_i.value = 1\n    dut.cyc_i.value = 0\n    dut.stb_i.value = 0\n    dut.sel_i.value = 0b1111\n    dut.we_i.value = 0\n    dut.addr_i.value = 0\n    dut.data_i.value = 0\n    dut.hreset_n.value = 0\n    dut.hrdata.value = 0\n    dut.hresp.value = 0b00\n    dut.hready.value = 1\n\n    # Reset pulse\n    await Timer(20, units=\"ns\")\n    dut.rst_i.value = 0\n    dut.hreset_n.value = 1\n    await Timer(20, units=\"ns\")\n    dut.rst_i.value = 1\n\n    # Test 1: Write operation\n    await RisingEdge(dut.clk_i)\n    dut.cyc_i.value = 1\n    dut.stb_i.value = 1\n    dut.we_i.value = 1\n    dut.addr_i.value = 0x10000000\n    dut.data_i.value = 0xDEADBEEF\n\n    await RisingEdge(dut.hclk)\n    dut.hready.value = 0  # Simulate wait state\n    await RisingEdge(dut.hclk)\n    dut.hready.value = 1  # Simulate transfer completion\n\n    # Check AHB outputs for write\n    assert dut.hwrite.value == 1, f\"ERROR: hwrite should be 1, got {dut.hwrite.value}\"\n    assert dut.haddr.value == 0x10000000, f\"ERROR: haddr should be 0x10000000, got {hex(dut.haddr.value)}\"\n    assert dut.hwdata.value == 0xDEADBEEF, f\"ERROR: hwdata should be 0xDEADBEEF, got {hex(dut.hwdata.value)}\"\n    dut._log.info(f\"[CHECK] AHB outputs for write correctly set: dut.hwdata.value = {int(dut.hwdata.value)}, dut.hwrite.value = {int(dut.hwrite.value)}, dut.haddr.value = {int(dut.haddr.value)}\")\n\n    cocotb.log.info(\"PASS: Write operation successful\")\n\n    await RisingEdge(dut.clk_i)\n    dut.stb_i.value = 0\n    dut.cyc_i.value = 0\n\n    # Test 2: Read operation\n    await RisingEdge(dut.clk_i)\n    dut.cyc_i.value = 1\n    dut.stb_i.value = 1\n    dut.we_i.value = 0\n    dut.addr_i.value = 0x20000000\n    dut.hrdata.value = 0xCAFEBABE  # AHB slave data\n\n    await RisingEdge(dut.hclk)\n    dut.hready.value = 0  # Simulate wait state\n    await RisingEdge(dut.hclk)\n    dut.hready.value = 1  # Simulate transfer completion\n\n    # Check Wishbone outputs for read\n    assert dut.data_o.value == 0xCAFEBABE, f\"ERROR: data_o should be 0xCAFEBABE, got {hex(dut.data_o.value)}\"\n    dut._log.info(f\"[CHECK] Wishbone outputs for read correctly set: dut.data_o.value = {int(dut.data_o.value)}\")\n\n    cocotb.log.info(\"PASS: Read operation successful\")\n\n    await RisingEdge(dut.clk_i)\n    dut.stb_i.value = 0\n    dut.cyc_i.value = 0\n\n    cocotb.log.info(\"Test complete\")\n"}}}
