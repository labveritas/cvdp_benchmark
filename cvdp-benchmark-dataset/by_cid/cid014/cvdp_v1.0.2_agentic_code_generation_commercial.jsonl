{"id": "cvdp_agentic_AES_encryption_decryption_0020", "categories": ["cid014", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a hierarchical AES encryption design with 3 main modules:\n- `aes_enc_top` (top-level interface: key, mode, IV, counter, control),\n- `aes_encrypt` (core round logic and key expansion).\n- `sbox` (byte substitution in the AES rounds).\n\nThese modules are located in the `rtl` directory. Please enhance the design by adding **SystemVerilog Assertions (SVA)** to verify control logic, functional behavior, round sequencing, and mode-dependent correctness.\n\n---\n\n### Assertion Requirements\n\nImplement assertions to cover the following conditions:\n\n1. **Reset Behavior**  \n   On reset (`rst_async_n`), all outputs and internal registers must be cleared.\n\n2. **Ciphertext Update Timing**  \n   `o_ciphertext` must update only when encryption is completed.\n\n3. **Done Signal Validity**  \n   `o_done` must deassert only on new `i_start`.\n\n4. **Key Register Update**  \n   `key_ff` must update only when a valid key update occurs during start.\n\n5. **CTR Counter Control**  \n   `counter_ff` must increment only in CTR mode after encryption.\n\n6. **Encryption Round Progression**  \n   `round_ff` must increment on every valid encryption cycle, and `o_done` must assert when round 14 is reached.\n\n7. **Key Expansion Handling**  \n   When `i_update_key` is asserted, `expanded_key_ff` must load `i_key`.\n\n8. **Initial XOR Logic**  \n   First-round `current_data_ff` values must be the result of a valid XOR between `i_data` and either `i_key` or `expanded_key_ff`..\n\n---\n\n### Expected Behavior\n\nIf any of the above conditions are violated, the assertion must fail and produce an informative error message that clearly identifies the failure scenario and expected behavior.\n\n---\n\n### Notes\n\n- All assertions must use **SystemVerilog Assertions (SVA)** syntax.\n- Only the `rtl` directory files should be modified to implement this.\n\n", "context": {"rtl/aes_enc_top.sv": "module aes_enc_top #(\n    parameter NBW_KEY  = 'd256,\n    parameter NBW_DATA = 'd128,\n    parameter NBW_MODE = 'd3,\n    parameter NBW_CNTR = 'd32\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_reset_counter,\n    input  logic                i_update_iv,\n    input  logic [NBW_DATA-1:0] i_iv,\n    input  logic                i_update_mode,\n    input  logic [NBW_MODE-1:0] i_mode,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    input  logic                i_start,\n    input  logic [NBW_DATA-1:0] i_plaintext,\n    output logic                o_done,\n    output logic [NBW_DATA-1:0] o_ciphertext\n);\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_MODE-1:0] mode_ff;\nlogic [NBW_DATA-1:0] plaintext_ff;\nlogic [NBW_DATA-1:0] iv_ff;\nlogic [NBW_DATA-1:0] iv_nx;\nlogic [NBW_DATA-1:0] ciphertext;\nlogic [NBW_DATA-1:0] enc_in;\nlogic [NBW_DATA-1:0] enc_out;\nlogic                update_key_ff;\nlogic                start_ff;\nlogic                enc_done;\nlogic [NBW_KEY-1:0]  key_ff;\nlogic [NBW_CNTR-1:0] counter_ff;\n\n// Possible operation modes\nlocalparam ECB  = 3'd0;\nlocalparam CBC  = 3'd1;\nlocalparam PCBC = 3'd2;\nlocalparam CFB  = 3'd3;\nlocalparam OFB  = 3'd4;\nlocalparam CTR  = 3'd5;\n\n// Operation modes logic\nalways_comb begin\n    case(mode_ff)\n        ECB: begin\n            enc_in     = plaintext_ff;\n            iv_nx      = iv_ff;\n            ciphertext = enc_out;\n        end\n        CBC: begin\n            enc_in     = plaintext_ff ^ iv_ff;\n            iv_nx      = enc_out;\n            ciphertext = enc_out;\n        end\n        PCBC: begin\n            enc_in     = plaintext_ff ^ iv_ff;\n            iv_nx      = plaintext_ff ^ enc_out;\n            ciphertext = enc_out;\n        end\n        CFB: begin\n            enc_in     = iv_ff;\n            iv_nx      = plaintext_ff ^ enc_out;\n            ciphertext = plaintext_ff ^ enc_out;\n        end\n        OFB: begin\n            enc_in     = iv_ff;\n            iv_nx      = enc_out;\n            ciphertext = plaintext_ff ^ enc_out;\n        end\n        CTR: begin\n            enc_in     = {counter_ff[NBW_CNTR-1:NBW_CNTR/2], iv_ff[NBW_DATA-(NBW_CNTR/2)-1:(NBW_CNTR/2)], counter_ff[NBW_CNTR/2-1:0]};\n            iv_nx      = iv_ff;\n            ciphertext = plaintext_ff ^ enc_out;\n        end\n        default: begin\n            enc_in     = plaintext_ff;\n            iv_nx      = iv_ff;\n            ciphertext = enc_out;\n        end\n    endcase\nend\n\n// Registers\nalways_ff @ (posedge clk) begin : data_regs\n    if(i_start & o_done) begin\n        plaintext_ff <= i_plaintext;\n    end\nend\n\nalways_ff @ (posedge clk or negedge rst_async_n) begin : reset_regs\n    if(!rst_async_n) begin\n        iv_ff        <= 128'd0;\n        mode_ff      <= 3'd0;\n        o_done       <= 1'b1;\n        o_ciphertext <= 128'd0;\n        counter_ff   <= 0;\n    end else begin\n        if(i_update_iv) begin\n            iv_ff <= i_iv;\n        end else begin\n            if(enc_done) begin\n                iv_ff <= iv_nx;\n            end\n        end\n\n        if(i_update_mode) begin\n            mode_ff <= i_mode;\n        end\n\n        if(enc_done) begin\n            o_done <= 1'b1;\n        end else begin\n            if(i_start & o_done) begin\n                o_done <= 1'b0;\n            end\n        end\n\n        if(enc_done) begin\n            o_ciphertext <= ciphertext;\n        end\n\n        if(i_reset_counter) begin\n            counter_ff <= 0;\n        end else if(enc_done & mode_ff == CTR) begin\n            counter_ff <= counter_ff + 1'b1;\n        end\n\n        start_ff <= (i_start & o_done);\n        update_key_ff <= (i_start & i_update_key & o_done);\n        if(i_start & i_update_key & o_done) begin\n            key_ff <= i_key;\n        end\n    end\nend\n\n// Encryption module instantiation\naes_encrypt #(\n    .NBW_KEY (NBW_KEY ),\n    .NBW_DATA(NBW_DATA)\n) uu_aes_encrypt (\n    .clk         (clk          ),\n    .rst_async_n (rst_async_n  ),\n    .i_update_key(update_key_ff),\n    .i_key       (key_ff       ),\n    .i_start     (start_ff     ),\n    .i_data      (enc_in       ),\n    .o_done      (enc_done     ),\n    .o_data      (enc_out      )\n);\n\nendmodule : aes_enc_top", "rtl/aes_encrypt.sv": "module aes_encrypt #(\n    parameter NBW_KEY  = 'd256,\n    parameter NBW_DATA = 'd128\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    input  logic                i_start,\n    input  logic [NBW_DATA-1:0] i_data,\n    output logic                o_done,\n    output logic [NBW_DATA-1:0] o_data\n);\n\n// ----------------------------------------\n// - Internal Parameters\n// ----------------------------------------\nlocalparam NBW_BYTE   = 'd8;\nlocalparam STEPS      = 'd14;\nlocalparam NBW_WORD   = 'd32;\nlocalparam NBW_EX_KEY = 'd1920;\nlocalparam NBW_STEP   = NBW_KEY/2;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_BYTE-1:0]   Rcon   [STEPS/2];\nlogic [NBW_KEY-1:0]    valid_key;\nlogic [NBW_STEP-1:0]   step_key[STEPS];\nlogic [NBW_EX_KEY-1:0] expanded_key_nx;\nlogic [NBW_EX_KEY-1:0] expanded_key_ff;\nlogic [NBW_BYTE-1:0]   current_data_nx[4][4];\nlogic [NBW_BYTE-1:0]   current_data_ff[4][4];\nlogic [NBW_BYTE-1:0]   SubBytes[4][4];\nlogic [NBW_BYTE-1:0]   ShiftRows[4][4];\nlogic [NBW_BYTE-1:0]   xtimes02[4][4];\nlogic [NBW_BYTE-1:0]   xtimes03[4][4];\nlogic [NBW_BYTE-1:0]   MixColumns[4][4];\nlogic [3:0] round_ff;\n\n// ----------------------------------------\n// - Output assignment\n// ----------------------------------------\nalways_ff @ (posedge clk or negedge rst_async_n) begin : done_assignment\n    if(!rst_async_n) begin\n        o_done <= 1'b0;\n    end else begin\n        o_done <= (round_ff == 4'd14);\n    end\nend\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : out_row\n        for(genvar j = 0; j < 4; j++) begin : out_col\n            assign o_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] = current_data_ff[i][j];\n        end\n    end\nendgenerate\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : cypher_regs\n    if(!rst_async_n) begin\n        round_ff <= 4'd0;\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= 8'd0;\n            end\n        end\n    end else begin\n        if(i_start || (round_ff > 4'd0 && round_ff < 4'd14)) begin\n            round_ff <= round_ff + 1'b1;\n        end else begin\n            round_ff <= 4'd0;\n        end\n\n        for(int i = 0; i < 4; i++) begin\n            for(int j = 0; j < 4; j++) begin\n                current_data_ff[i][j] <= current_data_nx[i][j];\n            end\n        end\n    end\nend\n\nalways_comb begin : next_data\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(i_start) begin\n                if(i_update_key) begin\n                    current_data_nx[i][j] = i_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] ^ i_key[NBW_KEY-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                end else begin\n                    current_data_nx[i][j] = i_data[NBW_DATA-(4*j+i)*NBW_BYTE-1-:NBW_BYTE] ^ expanded_key_ff[NBW_EX_KEY-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                end\n            end else begin\n                if(round_ff != 4'd0) begin\n                    if(round_ff != 4'd14) begin\n                        current_data_nx[i][j] = MixColumns[i][j] ^ expanded_key_ff[NBW_EX_KEY-round_ff*NBW_STEP-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                    end else begin\n                        current_data_nx[i][j] = ShiftRows[i][j] ^ expanded_key_ff[NBW_EX_KEY-round_ff*NBW_STEP-(4*j+i)*NBW_BYTE-1-:NBW_BYTE];\n                    end\n                end else begin\n                    current_data_nx[i][j] = current_data_ff[i][j];\n                end\n            end\n        end\n    end\nend\n\ngenerate\n    for(genvar i = 0; i < 4; i++) begin : row\n        for(genvar j = 0; j < 4; j++) begin : col\n            sbox uu_sbox0 (\n                .i_data(current_data_ff[i][j]),\n                .o_data(SubBytes[i][j])\n            );\n        end\n    end\nendgenerate\n\nalways_comb begin : cypher_logic\n    // Shift Rows logic\n    // Line 0: No shift\n    ShiftRows[0][0] = SubBytes[0][0];\n    ShiftRows[0][1] = SubBytes[0][1];\n    ShiftRows[0][2] = SubBytes[0][2];\n    ShiftRows[0][3] = SubBytes[0][3];\n\n    // Line 1: Shift 1 left\n    ShiftRows[1][0] = SubBytes[1][1];\n    ShiftRows[1][1] = SubBytes[1][2];\n    ShiftRows[1][2] = SubBytes[1][3];\n    ShiftRows[1][3] = SubBytes[1][0];\n\n    // Line 2: Shift 2 left\n    ShiftRows[2][0] = SubBytes[2][2];\n    ShiftRows[2][1] = SubBytes[2][3];\n    ShiftRows[2][2] = SubBytes[2][0];\n    ShiftRows[2][3] = SubBytes[2][1];\n\n    // Line 3: Shift 3 left\n    ShiftRows[3][0] = SubBytes[3][3];\n    ShiftRows[3][1] = SubBytes[3][0];\n    ShiftRows[3][2] = SubBytes[3][1];\n    ShiftRows[3][3] = SubBytes[3][2];\n\n    // Mix Columns logic\n    for(int i = 0; i < 4; i++) begin\n        for(int j = 0; j < 4; j++) begin\n            if(ShiftRows[i][j][NBW_BYTE-1]) begin\n                xtimes02[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B;\n                xtimes03[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0} ^ 8'h1B ^ ShiftRows[i][j];\n            end else begin\n                xtimes02[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0};\n                xtimes03[i][j] = {ShiftRows[i][j][NBW_BYTE-2:0], 1'b0} ^ ShiftRows[i][j];\n            end\n        end\n    end\n\n    for(int i = 0; i < 4; i++) begin\n        MixColumns[0][i] = xtimes02[0][i] ^ xtimes03[1][i] ^ ShiftRows[2][i] ^ ShiftRows[3][i];\n        MixColumns[1][i] = xtimes02[1][i] ^ xtimes03[2][i] ^ ShiftRows[3][i] ^ ShiftRows[0][i];\n        MixColumns[2][i] = xtimes02[2][i] ^ xtimes03[3][i] ^ ShiftRows[0][i] ^ ShiftRows[1][i];\n        MixColumns[3][i] = xtimes02[3][i] ^ xtimes03[0][i] ^ ShiftRows[1][i] ^ ShiftRows[2][i];\n    end\nend\n\n// ****************************************\n// - Key Expansion logic\n// ****************************************\n\n// ----------------------------------------\n// - Registers\n// ----------------------------------------\nalways_ff @(posedge clk or negedge rst_async_n) begin : reset_regs\n    if(~rst_async_n) begin\n        expanded_key_ff <= {NBW_EX_KEY{1'b0}};\n    end else begin\n        expanded_key_ff <= expanded_key_nx;\n    end\nend\n\n\n// ----------------------------------------\n// - Operation logic\n// ----------------------------------------\nassign Rcon[0] = 8'h01;\nassign Rcon[1] = 8'h02;\nassign Rcon[2] = 8'h04;\nassign Rcon[3] = 8'h08;\nassign Rcon[4] = 8'h10;\nassign Rcon[5] = 8'h20;\nassign Rcon[6] = 8'h40;\n\ngenerate\n    for(genvar i = 0; i < STEPS; i++) begin : steps\n        if(i%2 == 0) begin\n            logic [NBW_WORD-1:0] RotWord;\n            logic [NBW_WORD-1:0] SubWord;\n            logic [NBW_WORD-1:0] RconXor;\n\n            sbox uu_sbox0 (\n                .i_data(RotWord[NBW_WORD-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox1 (\n                .i_data(RotWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox2 (\n                .i_data(RotWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox3 (\n                .i_data(RotWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            always_comb begin : main_operation\n                RotWord = {expanded_key_ff[NBW_EX_KEY-NBW_KEY-i*NBW_STEP+NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)], expanded_key_ff[NBW_EX_KEY-NBW_KEY-i*NBW_STEP+NBW_WORD-1-:NBW_BYTE]};\n                RconXor = {SubWord[NBW_WORD-1-:NBW_BYTE]^Rcon[i/2], SubWord[NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)]};\n\n                step_key[i][NBW_STEP-1-:NBW_WORD]            = expanded_key_ff[NBW_EX_KEY-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ RconXor;\n                step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD]   = expanded_key_ff[NBW_EX_KEY-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-1-:NBW_WORD];\n                step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD];\n                step_key[i][NBW_STEP-3*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD];\n            end\n        end else begin\n            logic [NBW_WORD-1:0] SubWord;\n\n            sbox uu_sbox0 (\n                .i_data(expanded_key_ff[NBW_EX_KEY-NBW_KEY+NBW_WORD-i*NBW_STEP-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox1 (\n                .i_data(expanded_key_ff[NBW_EX_KEY-NBW_KEY+NBW_WORD-i*NBW_STEP-NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox2 (\n                .i_data(expanded_key_ff[NBW_EX_KEY-NBW_KEY+NBW_WORD-i*NBW_STEP-2*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-2*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            sbox uu_sbox3 (\n                .i_data(expanded_key_ff[NBW_EX_KEY-NBW_KEY+NBW_WORD-i*NBW_STEP-3*NBW_BYTE-1-:NBW_BYTE]),\n                .o_data(SubWord[NBW_WORD-3*NBW_BYTE-1-:NBW_BYTE])\n            );\n\n            always_comb begin : main_operation\n                step_key[i][NBW_STEP-1-:NBW_WORD]            = expanded_key_ff[NBW_EX_KEY-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ SubWord;\n                step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD]   = expanded_key_ff[NBW_EX_KEY-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-1-:NBW_WORD];\n                step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-NBW_WORD-1-:NBW_WORD];\n                step_key[i][NBW_STEP-3*NBW_WORD-1-:NBW_WORD] = expanded_key_ff[NBW_EX_KEY-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][NBW_STEP-2*NBW_WORD-1-:NBW_WORD];\n            end\n        end\n    end\nendgenerate\n\nassign expanded_key_nx = {valid_key   , step_key[0 ], step_key[1 ], step_key[2 ],\n                          step_key[3 ], step_key[4 ], step_key[5 ], step_key[6 ],\n                          step_key[7 ], step_key[8 ], step_key[9 ], step_key[10],\n                          step_key[11], step_key[12]};\n\nalways_comb begin : input_data\n    if (i_update_key) begin\n        valid_key = i_key;\n    end else begin\n        valid_key = expanded_key_ff[NBW_EX_KEY-1-:NBW_KEY];\n    end\nend\n\nendmodule : aes_encrypt", "rtl/sbox.sv": "module sbox (\n    input  logic [7:0] i_data,\n    output logic [7:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        8'h00: o_data = 8'h63;\n        8'h01: o_data = 8'h7C;\n        8'h02: o_data = 8'h77;\n        8'h03: o_data = 8'h7B;\n        8'h04: o_data = 8'hF2;\n        8'h05: o_data = 8'h6B;\n        8'h06: o_data = 8'h6F;\n        8'h07: o_data = 8'hC5;\n        8'h08: o_data = 8'h30;\n        8'h09: o_data = 8'h01;\n        8'h0A: o_data = 8'h67;\n        8'h0B: o_data = 8'h2B;\n        8'h0C: o_data = 8'hFE;\n        8'h0D: o_data = 8'hD7;\n        8'h0E: o_data = 8'hAB;\n        8'h0F: o_data = 8'h76;\n        8'h10: o_data = 8'hCA;\n        8'h11: o_data = 8'h82;\n        8'h12: o_data = 8'hC9;\n        8'h13: o_data = 8'h7D;\n        8'h14: o_data = 8'hFA;\n        8'h15: o_data = 8'h59;\n        8'h16: o_data = 8'h47;\n        8'h17: o_data = 8'hF0;\n        8'h18: o_data = 8'hAD;\n        8'h19: o_data = 8'hD4;\n        8'h1A: o_data = 8'hA2;\n        8'h1B: o_data = 8'hAF;\n        8'h1C: o_data = 8'h9C;\n        8'h1D: o_data = 8'hA4;\n        8'h1E: o_data = 8'h72;\n        8'h1F: o_data = 8'hC0;\n        8'h20: o_data = 8'hB7;\n        8'h21: o_data = 8'hFD;\n        8'h22: o_data = 8'h93;\n        8'h23: o_data = 8'h26;\n        8'h24: o_data = 8'h36;\n        8'h25: o_data = 8'h3F;\n        8'h26: o_data = 8'hF7;\n        8'h27: o_data = 8'hCC;\n        8'h28: o_data = 8'h34;\n        8'h29: o_data = 8'hA5;\n        8'h2A: o_data = 8'hE5;\n        8'h2B: o_data = 8'hF1;\n        8'h2C: o_data = 8'h71;\n        8'h2D: o_data = 8'hD8;\n        8'h2E: o_data = 8'h31;\n        8'h2F: o_data = 8'h15;\n        8'h30: o_data = 8'h04;\n        8'h31: o_data = 8'hC7;\n        8'h32: o_data = 8'h23;\n        8'h33: o_data = 8'hC3;\n        8'h34: o_data = 8'h18;\n        8'h35: o_data = 8'h96;\n        8'h36: o_data = 8'h05;\n        8'h37: o_data = 8'h9A;\n        8'h38: o_data = 8'h07;\n        8'h39: o_data = 8'h12;\n        8'h3A: o_data = 8'h80;\n        8'h3B: o_data = 8'hE2;\n        8'h3C: o_data = 8'hEB;\n        8'h3D: o_data = 8'h27;\n        8'h3E: o_data = 8'hB2;\n        8'h3F: o_data = 8'h75;\n        8'h40: o_data = 8'h09;\n        8'h41: o_data = 8'h83;\n        8'h42: o_data = 8'h2C;\n        8'h43: o_data = 8'h1A;\n        8'h44: o_data = 8'h1B;\n        8'h45: o_data = 8'h6E;\n        8'h46: o_data = 8'h5A;\n        8'h47: o_data = 8'hA0;\n        8'h48: o_data = 8'h52;\n        8'h49: o_data = 8'h3B;\n        8'h4A: o_data = 8'hD6;\n        8'h4B: o_data = 8'hB3;\n        8'h4C: o_data = 8'h29;\n        8'h4D: o_data = 8'hE3;\n        8'h4E: o_data = 8'h2F;\n        8'h4F: o_data = 8'h84;\n        8'h50: o_data = 8'h53;\n        8'h51: o_data = 8'hD1;\n        8'h52: o_data = 8'h00;\n        8'h53: o_data = 8'hED;\n        8'h54: o_data = 8'h20;\n        8'h55: o_data = 8'hFC;\n        8'h56: o_data = 8'hB1;\n        8'h57: o_data = 8'h5B;\n        8'h58: o_data = 8'h6A;\n        8'h59: o_data = 8'hCB;\n        8'h5A: o_data = 8'hBE;\n        8'h5B: o_data = 8'h39;\n        8'h5C: o_data = 8'h4A;\n        8'h5D: o_data = 8'h4C;\n        8'h5E: o_data = 8'h58;\n        8'h5F: o_data = 8'hCF;\n        8'h60: o_data = 8'hD0;\n        8'h61: o_data = 8'hEF;\n        8'h62: o_data = 8'hAA;\n        8'h63: o_data = 8'hFB;\n        8'h64: o_data = 8'h43;\n        8'h65: o_data = 8'h4D;\n        8'h66: o_data = 8'h33;\n        8'h67: o_data = 8'h85;\n        8'h68: o_data = 8'h45;\n        8'h69: o_data = 8'hF9;\n        8'h6A: o_data = 8'h02;\n        8'h6B: o_data = 8'h7F;\n        8'h6C: o_data = 8'h50;\n        8'h6D: o_data = 8'h3C;\n        8'h6E: o_data = 8'h9F;\n        8'h6F: o_data = 8'hA8;\n        8'h70: o_data = 8'h51;\n        8'h71: o_data = 8'hA3;\n        8'h72: o_data = 8'h40;\n        8'h73: o_data = 8'h8F;\n        8'h74: o_data = 8'h92;\n        8'h75: o_data = 8'h9D;\n        8'h76: o_data = 8'h38;\n        8'h77: o_data = 8'hF5;\n        8'h78: o_data = 8'hBC;\n        8'h79: o_data = 8'hB6;\n        8'h7A: o_data = 8'hDA;\n        8'h7B: o_data = 8'h21;\n        8'h7C: o_data = 8'h10;\n        8'h7D: o_data = 8'hFF;\n        8'h7E: o_data = 8'hF3;\n        8'h7F: o_data = 8'hD2;\n        8'h80: o_data = 8'hCD;\n        8'h81: o_data = 8'h0C;\n        8'h82: o_data = 8'h13;\n        8'h83: o_data = 8'hEC;\n        8'h84: o_data = 8'h5F;\n        8'h85: o_data = 8'h97;\n        8'h86: o_data = 8'h44;\n        8'h87: o_data = 8'h17;\n        8'h88: o_data = 8'hC4;\n        8'h89: o_data = 8'hA7;\n        8'h8A: o_data = 8'h7E;\n        8'h8B: o_data = 8'h3D;\n        8'h8C: o_data = 8'h64;\n        8'h8D: o_data = 8'h5D;\n        8'h8E: o_data = 8'h19;\n        8'h8F: o_data = 8'h73;\n        8'h90: o_data = 8'h60;\n        8'h91: o_data = 8'h81;\n        8'h92: o_data = 8'h4F;\n        8'h93: o_data = 8'hDC;\n        8'h94: o_data = 8'h22;\n        8'h95: o_data = 8'h2A;\n        8'h96: o_data = 8'h90;\n        8'h97: o_data = 8'h88;\n        8'h98: o_data = 8'h46;\n        8'h99: o_data = 8'hEE;\n        8'h9A: o_data = 8'hB8;\n        8'h9B: o_data = 8'h14;\n        8'h9C: o_data = 8'hDE;\n        8'h9D: o_data = 8'h5E;\n        8'h9E: o_data = 8'h0B;\n        8'h9F: o_data = 8'hDB;\n        8'hA0: o_data = 8'hE0;\n        8'hA1: o_data = 8'h32;\n        8'hA2: o_data = 8'h3A;\n        8'hA3: o_data = 8'h0A;\n        8'hA4: o_data = 8'h49;\n        8'hA5: o_data = 8'h06;\n        8'hA6: o_data = 8'h24;\n        8'hA7: o_data = 8'h5C;\n        8'hA8: o_data = 8'hC2;\n        8'hA9: o_data = 8'hD3;\n        8'hAA: o_data = 8'hAC;\n        8'hAB: o_data = 8'h62;\n        8'hAC: o_data = 8'h91;\n        8'hAD: o_data = 8'h95;\n        8'hAE: o_data = 8'hE4;\n        8'hAF: o_data = 8'h79;\n        8'hB0: o_data = 8'hE7;\n        8'hB1: o_data = 8'hC8;\n        8'hB2: o_data = 8'h37;\n        8'hB3: o_data = 8'h6D;\n        8'hB4: o_data = 8'h8D;\n        8'hB5: o_data = 8'hD5;\n        8'hB6: o_data = 8'h4E;\n        8'hB7: o_data = 8'hA9;\n        8'hB8: o_data = 8'h6C;\n        8'hB9: o_data = 8'h56;\n        8'hBA: o_data = 8'hF4;\n        8'hBB: o_data = 8'hEA;\n        8'hBC: o_data = 8'h65;\n        8'hBD: o_data = 8'h7A;\n        8'hBE: o_data = 8'hAE;\n        8'hBF: o_data = 8'h08;\n        8'hC0: o_data = 8'hBA;\n        8'hC1: o_data = 8'h78;\n        8'hC2: o_data = 8'h25;\n        8'hC3: o_data = 8'h2E;\n        8'hC4: o_data = 8'h1C;\n        8'hC5: o_data = 8'hA6;\n        8'hC6: o_data = 8'hB4;\n        8'hC7: o_data = 8'hC6;\n        8'hC8: o_data = 8'hE8;\n        8'hC9: o_data = 8'hDD;\n        8'hCA: o_data = 8'h74;\n        8'hCB: o_data = 8'h1F;\n        8'hCC: o_data = 8'h4B;\n        8'hCD: o_data = 8'hBD;\n        8'hCE: o_data = 8'h8B;\n        8'hCF: o_data = 8'h8A;\n        8'hD0: o_data = 8'h70;\n        8'hD1: o_data = 8'h3E;\n        8'hD2: o_data = 8'hB5;\n        8'hD3: o_data = 8'h66;\n        8'hD4: o_data = 8'h48;\n        8'hD5: o_data = 8'h03;\n        8'hD6: o_data = 8'hF6;\n        8'hD7: o_data = 8'h0E;\n        8'hD8: o_data = 8'h61;\n        8'hD9: o_data = 8'h35;\n        8'hDA: o_data = 8'h57;\n        8'hDB: o_data = 8'hB9;\n        8'hDC: o_data = 8'h86;\n        8'hDD: o_data = 8'hC1;\n        8'hDE: o_data = 8'h1D;\n        8'hDF: o_data = 8'h9E;\n        8'hE0: o_data = 8'hE1;\n        8'hE1: o_data = 8'hF8;\n        8'hE2: o_data = 8'h98;\n        8'hE3: o_data = 8'h11;\n        8'hE4: o_data = 8'h69;\n        8'hE5: o_data = 8'hD9;\n        8'hE6: o_data = 8'h8E;\n        8'hE7: o_data = 8'h94;\n        8'hE8: o_data = 8'h9B;\n        8'hE9: o_data = 8'h1E;\n        8'hEA: o_data = 8'h87;\n        8'hEB: o_data = 8'hE9;\n        8'hEC: o_data = 8'hCE;\n        8'hED: o_data = 8'h55;\n        8'hEE: o_data = 8'h28;\n        8'hEF: o_data = 8'hDF;\n        8'hF0: o_data = 8'h8C;\n        8'hF1: o_data = 8'hA1;\n        8'hF2: o_data = 8'h89;\n        8'hF3: o_data = 8'h0D;\n        8'hF4: o_data = 8'hBF;\n        8'hF5: o_data = 8'hE6;\n        8'hF6: o_data = 8'h42;\n        8'hF7: o_data = 8'h68;\n        8'hF8: o_data = 8'h41;\n        8'hF9: o_data = 8'h99;\n        8'hFA: o_data = 8'h2D;\n        8'hFB: o_data = 8'h0F;\n        8'hFC: o_data = 8'hB0;\n        8'hFD: o_data = 8'h54;\n        8'hFE: o_data = 8'hBB;\n        8'hFF: o_data = 8'h16;\n        default: o_data = 8'h00;\n    endcase\nend\n\nendmodule : sbox"}, "patch": {"rtl/aes_enc_top.sv": "", "rtl/aes_encrypt.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/aes_enc_top.sv /code/rtl/aes_encrypt.sv /code/rtl/sbox.sv\nTOPLEVEL        = aes_enc_top\nMODULE          = test_aes_enc_top\nPYTHONPATH      = /src\nHASH            = 20-rtl-assertion-aes-enc-top", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\nimport cocotb\nfrom collections import deque\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n    top = os.getenv(\"TOPLEVEL\")\n    target = float(os.getenv(\"TARGET\", \"100.0\"))  # Default to 100 if not set\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # Parse header\n    column = re.split(r'\\s{2,}', lines[0].strip())\n\n    # Parse lines into a dictionary\n    for line in lines[2:]:\n        if not line.strip():\n            continue\n        info = re.split(r'\\s{2,}', line.strip())\n        raw_name = info[0].strip()\n        clean_name = raw_name.lstrip('|- ').strip()\n        metrics[clean_name] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    # Include top-level and all its submodules (by indentation)\n    relevant_modules = [\n        name for name in metrics\n        if name == top or raw_name.startswith(\"|--\")  # This ensures all submodules get checked\n    ]\n\n    print(\"Checking coverage for modules:\", relevant_modules)\n\n    assert relevant_modules, f\"No metrics found for top module {top}\"\n\n    for module in relevant_modules:\n        m = metrics[module]\n        if \"Overall Average\" in m:\n            assert float(m[\"Overall Average\"]) >= target, f\"{module}: Overall Average below target\"\n        elif \"Assertion\" in m:\n            assert float(m[\"Assertion\"]) >= target, f\"{module}: Assertion below target\"\n        elif \"Toggle\" in m:\n            assert float(m[\"Toggle\"]) >= target, f\"{module}: Toggle coverage below target\"\n        elif \"Block\" in m:\n            assert float(m[\"Block\"]) >= target, f\"{module}: Block coverage below target\"\n        else:\n            assert False, f\"{module}: No recognizable coverage metric found\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\ndef PKCS(data, padding):\n    # Convert int to 16-byte array\n    data_bytes = data.to_bytes(16, byteorder='big')\n\n    # Trim the last `padding` bytes\n    trimmed = data_bytes[:16 - padding]\n\n    # Add padding bytes\n    pad_byte = padding.to_bytes(1, byteorder='big')\n    padded_bytes = trimmed + pad_byte * padding\n\n    # Convert back to integer\n    return int.from_bytes(padded_bytes, byteorder='big')\n\ndef OneAndZeroes(data, padding):\n    data_bytes = data.to_bytes(16, byteorder='big')\n\n    if padding == 0:\n        # No padding needed\n        padded_bytes = data_bytes\n    else:\n        trimmed = data_bytes[:16 - padding]\n        padded_bytes = trimmed + b'\\x80' + b'\\x00' * (padding - 1)\n\n    return int.from_bytes(padded_bytes, byteorder='big')\n\ndef ANSIX923(data, padding):\n    data_bytes = data.to_bytes(16, byteorder='big')\n\n    if padding == 0:\n        padded_bytes = data_bytes\n    else:\n        trimmed = data_bytes[:16 - padding]\n        pad_value = padding.to_bytes(1, byteorder='big')\n        padded_bytes = trimmed + b'\\x00' * (padding - 1) + pad_value\n\n    return int.from_bytes(padded_bytes, byteorder='big')\n\ndef W3C(data, padding, filler_byte=0xAF):\n    data_bytes = data.to_bytes(16, byteorder='big')\n\n    if padding == 0:\n        # No padding needed\n        padded_bytes = data_bytes\n    else:\n        trimmed = data_bytes[:16 - padding]\n        fill = bytes([filler_byte] * (padding - 1)) + bytes([padding])\n        padded_bytes = trimmed + fill\n\n    return int.from_bytes(padded_bytes, byteorder='big')\n\nclass aes_decrypt:\n    RCON = [\n        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36\n    ]\n    \n    SBOX = [\n        # S-box table used in AES\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n    \n    def __init__(self):\n        self.expanded_key = 0\n        self.data_out = 0\n        self.iv = 0\n        self.counter = 0\n        self.inv_s_box = [0] * 256\n        for i, val in enumerate(self.SBOX):\n            self.inv_s_box[val] = i\n    \n    def reset(self):\n        self.expanded_key = 0\n        self.data_out = 0\n        self.iv = 0\n        self.counter = 0\n    \n    def update_key(self, key):\n        key_bytes = key.to_bytes(32, 'big')  # Convert 256-bit key to bytes\n        self.expanded_key = self.expand_key(key_bytes)\n    \n    def expand_key(self, key):\n        words = [list(key[i:i+4]) for i in range(0, 32, 4)]\n        \n        for i in range(8, 60):\n            temp = words[i - 1]\n            \n            if i % 8 == 0:\n                temp = self.sub_word(self.rot_word(temp))\n                temp[0] ^= self.RCON[i // 8 - 1]\n            elif i % 8 == 4:\n                temp = self.sub_word(temp)\n            \n            words.append([words[i - 8][j] ^ temp[j] for j in range(4)])\n        \n        expanded_key_bytes = b''.join(bytes(word) for word in words)\n        return int.from_bytes(expanded_key_bytes, 'big')\n    \n    def sub_word(self, word):\n        return [self.SBOX[b] for b in word]\n    \n    def rot_word(self, word):\n        return word[1:] + word[:1]\n    \n    def gmul(self, a, b):\n        p = 0\n        for _ in range(8):\n            if b & 1:\n                p ^= a\n            hi = a & 0x80\n            a = (a << 1) & 0xFF\n            if hi:\n                a ^= 0x1b\n            b >>= 1\n        return p\n\n    def sub_bytes(self, state):\n        for i in range(16):\n            state[i] = self.SBOX[state[i]]\n\n    def shift_rows(self, state):\n        state[1], state[5], state[9], state[13] = state[5], state[9], state[13], state[1]\n        state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]\n        state[3], state[7], state[11], state[15] = state[15], state[3], state[7], state[11]\n\n    def mix_columns(self, s):\n        for i in range(4):\n            a = s[i*4:(i+1)*4]\n            s[i*4+0] = self.gmul(a[0],2)^self.gmul(a[1],3)^a[2]^a[3]\n            s[i*4+1] = a[0]^self.gmul(a[1],2)^self.gmul(a[2],3)^a[3]\n            s[i*4+2] = a[0]^a[1]^self.gmul(a[2],2)^self.gmul(a[3],3)\n            s[i*4+3] = self.gmul(a[0],3)^a[1]^a[2]^self.gmul(a[3],2)\n\n    def add_round_key(self, state, round_key_words):\n        for col in range(4):\n            word = round_key_words[col]\n            for row in range(4):\n                state[col * 4 + row] ^= (word >> (24 - 8 * row)) & 0xFF\n\n    def get_round_keys(self):\n        expanded_bytes = self.expanded_key.to_bytes(240, 'big')\n        round_keys = []\n        for i in range(0, 240, 16):  # Each round key is 16 bytes (4 words)\n            words = [int.from_bytes(expanded_bytes[i + j*4 : i + (j+1)*4], 'big') for j in range(4)]\n            round_keys.append(words)\n        return round_keys\n\n    def encrypt(self, data):\n        state = [(data >> (8 * (15 - i))) & 0xFF for i in range(16)]\n        round_keys = self.get_round_keys()\n        \n        self.add_round_key(state, round_keys[0])\n\n        for rnd in range(1, 14):\n            self.sub_bytes(state)\n            self.shift_rows(state)\n            self.mix_columns(state)\n            self.add_round_key(state, round_keys[rnd])\n\n        self.sub_bytes(state)\n        self.shift_rows(state)\n        self.add_round_key(state, round_keys[14])\n\n        self.data_out = 0\n        for b in state:\n            self.data_out = (self.data_out << 8) | b\n        \n    def inv_sub_bytes(self, state):\n        for i in range(16):\n            state[i] = self.inv_s_box[state[i]]\n\n    def inv_shift_rows(self, state):\n        state[1], state[5], state[9], state[13] = state[13], state[1], state[5], state[9]\n        state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]\n        state[3], state[7], state[11], state[15] = state[7], state[11], state[15], state[3]\n\n    def inv_mix_columns(self, s):\n        for i in range(4):\n            a = s[i*4:(i+1)*4]\n            s[i*4+0] = self.gmul(a[0],14)^self.gmul(a[1],11)^self.gmul(a[2],13)^self.gmul(a[3],9)\n            s[i*4+1] = self.gmul(a[0],9)^self.gmul(a[1],14)^self.gmul(a[2],11)^self.gmul(a[3],13)\n            s[i*4+2] = self.gmul(a[0],13)^self.gmul(a[1],9)^self.gmul(a[2],14)^self.gmul(a[3],11)\n            s[i*4+3] = self.gmul(a[0],11)^self.gmul(a[1],13)^self.gmul(a[2],9)^self.gmul(a[3],14)\n    \n    def decrypt(self, data):\n        state = [(data >> (8 * (15 - i))) & 0xFF for i in range(16)]\n        round_keys = self.get_round_keys()\n\n        self.add_round_key(state, round_keys[14])\n\n        for rnd in range(13, 0, -1):\n            self.inv_shift_rows(state)\n            self.inv_sub_bytes(state)\n            self.add_round_key(state, round_keys[rnd])\n            self.inv_mix_columns(state)\n\n        self.inv_shift_rows(state)\n        self.inv_sub_bytes(state)\n        self.add_round_key(state, round_keys[0])\n\n        self.data_out = 0\n        for b in state:\n            self.data_out = (self.data_out << 8) | b\n    \n    def MODE(self, data, mode):\n        if mode == 0:\n            self.ECB(data)\n        elif mode == 1:\n            self.CBC(data)\n        elif mode == 2:\n            self.PCBC(data)\n        elif mode == 3:\n            self.CFB(data)\n        elif mode == 4:\n            self.OFB(data)\n        else:\n            self.CTR(data)\n\n    def ECB(self, data):\n        self.decrypt(data)\n    \n    def CBC(self, data):\n        self.decrypt(data)\n        self.data_out = self.data_out ^ self.iv\n        self.iv = data\n    \n    def PCBC(self, data):\n        self.decrypt(data)\n        self.data_out = self.data_out ^ self.iv\n        self.iv = data ^ self.data_out\n    \n    def CFB(self, data):\n        self.encrypt(self.iv)\n        self.data_out = self.data_out ^ data\n        self.iv = data\n    \n    def OFB(self, data):\n        self.encrypt(self.iv)\n        self.iv = self.data_out\n        self.data_out = self.data_out ^ data\n    \n    def CTR(self, data):\n        enc_in = (self.iv & 0x0000FFFFFFFFFFFFFFFFFFFFFFFF0000) + (self.counter & 0x0000FFFF) + ((self.counter & 0xFFFF0000) << 96)\n        self.encrypt(enc_in)\n        if self.counter < 2**32 - 1:\n            self.counter = self.counter + 1\n        else:\n            self.counter = 0\n        \n        self.data_out = self.data_out ^ data\n\nclass aes_encrypt:\n    RCON = [\n        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36\n    ]\n    \n    SBOX = [\n        # S-box table used in AES\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n    \n    def __init__(self):\n        self.expanded_key = 0\n        self.data_out = 0\n        self.iv = 0\n        self.counter = 0\n    \n    def reset(self):\n        self.expanded_key = 0\n        self.data_out = 0\n        self.iv = 0\n        self.counter = 0\n    \n    def update_key(self, key):\n        key_bytes = key.to_bytes(32, 'big')  # Convert 256-bit key to bytes\n        self.expanded_key = self.expand_key(key_bytes)\n    \n    def expand_key(self, key):\n        words = [list(key[i:i+4]) for i in range(0, 32, 4)]\n        \n        for i in range(8, 60):\n            temp = words[i - 1]\n            \n            if i % 8 == 0:\n                temp = self.sub_word(self.rot_word(temp))\n                temp[0] ^= self.RCON[i // 8 - 1]\n            elif i % 8 == 4:\n                temp = self.sub_word(temp)\n            \n            words.append([words[i - 8][j] ^ temp[j] for j in range(4)])\n        \n        expanded_key_bytes = b''.join(bytes(word) for word in words)\n        return int.from_bytes(expanded_key_bytes, 'big')\n    \n    def sub_word(self, word):\n        return [self.SBOX[b] for b in word]\n    \n    def rot_word(self, word):\n        return word[1:] + word[:1]\n    \n    def gmul(self, a, b):\n        p = 0\n        for _ in range(8):\n            if b & 1:\n                p ^= a\n            hi = a & 0x80\n            a = (a << 1) & 0xFF\n            if hi:\n                a ^= 0x1b\n            b >>= 1\n        return p\n\n    def sub_bytes(self, state):\n        for i in range(16):\n            state[i] = self.SBOX[state[i]]\n\n    def shift_rows(self, state):\n        state[1], state[5], state[9], state[13] = state[5], state[9], state[13], state[1]\n        state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]\n        state[3], state[7], state[11], state[15] = state[15], state[3], state[7], state[11]\n\n    def mix_columns(self, s):\n        for i in range(4):\n            a = s[i*4:(i+1)*4]\n            s[i*4+0] = self.gmul(a[0],2)^self.gmul(a[1],3)^a[2]^a[3]\n            s[i*4+1] = a[0]^self.gmul(a[1],2)^self.gmul(a[2],3)^a[3]\n            s[i*4+2] = a[0]^a[1]^self.gmul(a[2],2)^self.gmul(a[3],3)\n            s[i*4+3] = self.gmul(a[0],3)^a[1]^a[2]^self.gmul(a[3],2)\n\n    def add_round_key(self, state, round_key_words):\n        for col in range(4):\n            word = round_key_words[col]\n            for row in range(4):\n                state[col * 4 + row] ^= (word >> (24 - 8 * row)) & 0xFF\n\n    def get_round_keys(self):\n        expanded_bytes = self.expanded_key.to_bytes(240, 'big')\n        round_keys = []\n        for i in range(0, 240, 16):  # Each round key is 16 bytes (4 words)\n            words = [int.from_bytes(expanded_bytes[i + j*4 : i + (j+1)*4], 'big') for j in range(4)]\n            round_keys.append(words)\n        return round_keys\n\n    def encrypt(self, data):\n        state = [(data >> (8 * (15 - i))) & 0xFF for i in range(16)]\n        round_keys = self.get_round_keys()\n        \n        self.add_round_key(state, round_keys[0])\n\n        for rnd in range(1, 14):\n            self.sub_bytes(state)\n            self.shift_rows(state)\n            self.mix_columns(state)\n            self.add_round_key(state, round_keys[rnd])\n\n        self.sub_bytes(state)\n        self.shift_rows(state)\n        self.add_round_key(state, round_keys[14])\n\n        self.data_out = 0\n        for b in state:\n            self.data_out = (self.data_out << 8) | b\n    \n    def MODE(self, data, mode):\n        if mode == 0:\n            self.ECB(data)\n        elif mode == 1:\n            self.CBC(data)\n        elif mode == 2:\n            self.PCBC(data)\n        elif mode == 3:\n            self.CFB(data)\n        elif mode == 4:\n            self.OFB(data)\n        else:\n            self.CTR(data)\n    \n    def ECB(self, data):\n        self.encrypt(data)\n    \n    def CBC(self, data):\n        enc_in = data ^ self.iv\n        self.encrypt(enc_in)\n        self.iv = self.data_out\n    \n    def PCBC(self, data):\n        enc_in = data ^ self.iv\n        self.encrypt(enc_in)\n        self.iv = data ^ self.data_out\n    \n    def CFB(self, data):\n        self.encrypt(self.iv)\n        self.iv = self.data_out ^ data\n        self.data_out = self.iv\n    \n    def OFB(self, data):\n        self.encrypt(self.iv)\n        self.iv = self.data_out\n        self.data_out = self.data_out ^ data\n    \n    def CTR(self, data):\n        enc_in = (self.iv & 0x0000FFFFFFFFFFFFFFFFFFFFFFFF0000) + (self.counter & 0x0000FFFF) + ((self.counter & 0xFFFF0000) << 96)\n        self.encrypt(enc_in)\n        if self.counter < 2**32 - 1:\n            self.counter = self.counter + 1\n        else:\n            self.counter = 0\n        \n        self.data_out = self.data_out ^ data\n", "src/test_aes_enc_top.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_data  = dut.o_ciphertext.value\n\n    model_data = model.data_out\n\n    if debug == 1:\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_ciphertext  = {hex(dut_data)} \\nMODEL o_ciphertext  = {hex(model_data)}\")\n    \n    assert dut_data == model_data,  f\"[ERROR] DUT o_ciphertext does not match model o_ciphertext: {hex(dut_data)} != {hex(model_data)}\"\n\ndef set_inputs(dut, reset_counter, update_iv, update_mode, update_key, mode, iv, plaintext, key, start):\n    dut.i_reset_counter.value = reset_counter\n    dut.i_update_iv.value     = update_iv\n    dut.i_update_mode.value   = update_mode\n    dut.i_update_key.value    = update_key\n    dut.i_mode.value          = mode\n    dut.i_iv.value            = iv\n    dut.i_plaintext.value     = plaintext\n    dut.i_key.value           = key\n    dut.i_start.value         = start\n\n@cocotb.test()\nasync def test_aes_enc_top(dut):\n    \"\"\"Test the aes_enc_top module with edge cases and random data.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    model = hrs_lb.aes_encrypt()\n\n    resets = 2\n    runs = 2\n    mode_runs = 200\n\n    data_min = 0\n    data_max = 2**128 - 1\n\n    key_min = 0\n    key_max = 2**256 - 1\n    \n    await hrs_lb.dut_init(dut)\n\n    for i in range(resets):\n        # Reset DUT\n        # Set all inputs to 0\n        set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n        dut.rst_async_n.value = 0\n        await RisingEdge(dut.clk)\n        dut.rst_async_n.value  = 1\n        await RisingEdge(dut.clk)\n\n        model.reset()\n\n        compare_values(dut, model)\n        # After reset o_done must be 1\n        dut_done = dut.o_done.value\n        assert dut_done == 1,  f\"[ERROR] After reset, DUT o_done must be 1. The harness received o_done = {dut_done}\"\n\n        for j in range(runs):\n            print(f'\\n------ Reset {i}, run {j} ------')\n\n            print(\"ECB mode\")\n            mode      = 0\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.ECB(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CBC mode\")\n            mode      = 1\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.CBC(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"PCBC mode\")\n            mode      = 2\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.PCBC(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CFB mode\")\n            mode      = 3\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.CFB(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n\n            print(\"OFB mode\")\n            mode      = 4\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv  = iv\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.OFB(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            \n            print(\"CTR mode\")\n            mode      = 5\n            iv        = random.randint(data_min, data_max)\n            plaintext = random.randint(data_min, data_max)\n            key       = random.randint(key_min , key_max )\n            \n            model.iv      = iv\n            model.counter = 0\n\n            # Set Counter, IV and mode\n            set_inputs(dut, 1, 1, 1, 0, mode, iv, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n            await RisingEdge(dut.clk)\n            \n            for k in range(mode_runs):\n                # Set key in first run\n                if k == 0:\n                    set_inputs(dut, 0, 0, 0, 1, 0, 0, plaintext, key, 1)\n                    model.update_key(key)\n                else:\n                    set_inputs(dut, 0, 0, 0, 0, 0, 0, plaintext, 0, 1)\n                \n                model.CTR(plaintext)\n                await RisingEdge(dut.clk)\n                set_inputs(dut, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                await RisingEdge(dut.clk)\n                while dut.o_done.value == 0:\n                    await RisingEdge(dut.clk)\n                \n                compare_values(dut, model)\n            ", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb.runner import get_runner\nimport pytest\nimport random\nimport harness_library as hrs_lb\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef call_runner():\n    parameter = {}\n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameter\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n\ndef test_data():\n    # Run the simulation with specified parameters\n    call_runner()\n\n"}}
{"id": "cvdp_agentic_alu_0003", "categories": ["cid014", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have an `alu_core` module available in the `rtl` directory, and its specification is in the `docs` directory. Kindly modify the module by adding SystemVerilog assertions. The assertions should ensure that the module correctly handles valid opcodes (`0` through `7`) and that each arithmetic operation produces a result within the valid signed 32-bit range.\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:\n1. **Opcode Valid Range Check**: Ensure that the input `opcode` is within the range `0\u20137`. If an invalid `opcode` is detected, it should trigger an **error message**.\n2. **Overflow Checks**:  \n   - **Addition/Subtraction**: Verify no overflow occurs for 32-bit signed addition and subtraction.  \n   - **Multiplication**: Verify that the product is within the valid 32-bit signed range.  \n   - **Division**: Verify that division by zero does not occur.\n3. **Result Bounds Check**: Confirm that the final `result` always remains within the valid signed 32-bit range after each operation.\n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.\n", "context": {"docs/alu_core_specification.md": "# ALU Core Specification Document\n\n## Introduction\n\nThe **ALU Core** module implements a simple arithmetic and logic unit supporting basic operations such as addition, subtraction, multiplication, division, and bitwise logic functions. It operates on three signed operands of parameterized width (`DATA_WIDTH`) and determines the operation based on a 4-bit opcode.\n\n---\n\n## Module Interface\n\nThe module is defined as follows:\n\n```verilog\nmodule alu_core #(\n    parameter DATA_WIDTH = 32\n)(\n    input  logic [3:0]                         opcode,\n    input  logic signed [DATA_WIDTH-1:0]       operand1,\n    input  logic signed [DATA_WIDTH-1:0]       operand2,\n    input  logic signed [DATA_WIDTH-1:0]       operand3,\n    output logic signed [DATA_WIDTH-1:0]       result\n);\n```\n\n### Port Description\n\n- **opcode:** 4-bit control signal that determines the operation performed.\n- **operand1, operand2, operand3:** Signed input operands of `DATA_WIDTH` bits each.\n- **result:** Signed output result of `DATA_WIDTH` bits.\n\n---\n\n## Supported Operations\n\nThe module supports the following arithmetic and logical operations based on the `opcode`:\n\n| Opcode | Operation            | Description                                |\n|--------|----------------------|--------------------------------------------|\n| 0x0    | Addition             | `result = operand1 + operand2 + operand3`  |\n| 0x1    | Subtraction          | `result = operand1 - operand2 - operand3`  |\n| 0x2    | Multiplication       | `result = operand1 * operand2 * operand3`  |\n| 0x3    | Division             | `result = operand1 / operand2 / operand3`  |\n| 0x4    | Bitwise AND          | `result = operand1 & operand2 & operand3`  |\n| 0x5    | Bitwise OR           | `result = operand1 | operand2 | operand3`  |\n| 0x6    | Bitwise XOR          | `result = operand1 ^ operand2 ^ operand3`  |\n| Other  | Default (Zero)       | `result = 0`                               |\n\n---\n\n## Internal Architecture\n\nThe **ALU Core** operates as a combinational unit where the computation is determined purely based on input values without any clock-driven state retention. The processing is handled through dedicated functions that perform different arithmetic and logical operations.\n\n1. **Operand Handling:**  \n   - The ALU takes three signed operands as inputs.\n   - These operands are directly fed into the computational logic.\n\n2. **Operation Selection:**  \n   - A 4-bit opcode determines which arithmetic or logical operation will be performed.\n   - The opcode is evaluated using a case structure, mapping each opcode to a specific function.\n\n3. **Computation Execution:**  \n   - For arithmetic operations (addition, subtraction, multiplication, and division), the three operands are processed according to their respective mathematical rules.\n   - For bitwise operations (AND, OR, XOR), the computation is performed at the bit level.\n\n4. **Result Assignment:**  \n   - The computed value is assigned to the result output.\n   - If the opcode does not match any predefined operation, the result defaults to zero.\n\n5. **Considerations:**  \n   - The module does not handle division by zero explicitly, which may result in undefined behavior.\n   - The design does not store any past computation results since it is purely combinational.\n\nBy implementing this approach, the **ALU Core** ensures efficient and immediate computation of results based on the given inputs and control opcode.\n\n---", "rtl/alu_core.sv": "module alu_core #(\n    parameter DATA_WIDTH = 32\n)(\n    input  logic [3:0]                         opcode,\n    input  logic signed [DATA_WIDTH-1:0]       operand1,\n    input  logic signed [DATA_WIDTH-1:0]       operand2,\n    input  logic signed [DATA_WIDTH-1:0]       operand3,\n    output logic signed [DATA_WIDTH-1:0]       result\n);\n\nfunction automatic signed [DATA_WIDTH-1:0] do_add(\n    input signed [DATA_WIDTH-1:0] a,\n    input signed [DATA_WIDTH-1:0] b,\n    input signed [DATA_WIDTH-1:0] c\n);\n    do_add = a + b + c;\nendfunction\n\nfunction automatic signed [DATA_WIDTH-1:0] do_sub(\n    input signed [DATA_WIDTH-1:0] a,\n    input signed [DATA_WIDTH-1:0] b,\n    input signed [DATA_WIDTH-1:0] c\n);\n    do_sub = a - b - c;\nendfunction\n\nfunction automatic signed [DATA_WIDTH-1:0] do_mul(\n    input signed [DATA_WIDTH-1:0] a,\n    input signed [DATA_WIDTH-1:0] b,\n    input signed [DATA_WIDTH-1:0] c\n);\n    do_mul = a * b * c;\nendfunction\n\nfunction automatic signed [DATA_WIDTH-1:0] do_div(\n    input signed [DATA_WIDTH-1:0] a,\n    input signed [DATA_WIDTH-1:0] b,\n    input signed [DATA_WIDTH-1:0] c\n);\n    do_div = a / b / c;\nendfunction\n\nfunction automatic signed [DATA_WIDTH-1:0] do_and(\n    input signed [DATA_WIDTH-1:0] a,\n    input signed [DATA_WIDTH-1:0] b,\n    input signed [DATA_WIDTH-1:0] c\n);\n    do_and = a & b & c;\nendfunction\n\nfunction automatic signed [DATA_WIDTH-1:0] do_or(\n    input signed [DATA_WIDTH-1:0] a,\n    input signed [DATA_WIDTH-1:0] b,\n    input signed [DATA_WIDTH-1:0] c\n);\n    do_or = a | b | c;\nendfunction\n\nfunction automatic signed [DATA_WIDTH-1:0] do_xor(\n    input signed [DATA_WIDTH-1:0] a,\n    input signed [DATA_WIDTH-1:0] b,\n    input signed [DATA_WIDTH-1:0] c\n);\n    do_xor = a ^ b ^ c;\nendfunction\n\nalways_comb begin\n    result = 0;\n    case (opcode)\n        4'h0: result = do_add(operand1, operand2, operand3);\n        4'h1: result = do_sub(operand1, operand2, operand3);\n        4'h2: result = do_mul(operand1, operand2, operand3);\n        4'h3: result = do_div(operand1, operand2, operand3);\n        4'h4: result = do_and(operand1, operand2, operand3);\n        4'h5: result = do_or(operand1, operand2, operand3);\n        4'h6: result = do_xor(operand1, operand2, operand3);\n        default: result = 0;\n    endcase\nend\n\nendmodule"}, "patch": {"rtl/alu_core.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/alu_core.sv\nTOPLEVEL        = alu_core\nMODULE          = test_alu\nPYTHONPATH      = /src\nHASH            = 3-rtl-assertions-in-alu-core\n", "src/test_alu.py": "import cocotb\nfrom cocotb.triggers import Timer\nimport random\n\n# A reference model in Python replicating the ALU logic for verification.\n# This model returns an integer in the 32-bit signed range.\ndef alu_model(opcode, op1, op2, op3):\n    # Wrap values to 32-bit signed\n    op1 = to_32bit_signed(op1)\n    op2 = to_32bit_signed(op2)\n    op3 = to_32bit_signed(op3)\n    \n    if opcode == 0:   # ADD\n        res = op1 + op2 + op3\n    elif opcode == 1: # SUB\n        res = op1 - op2 - op3\n    elif opcode == 2: # MUL\n        res = op1 * op2 * op3\n    elif opcode == 3: # DIV\n        # Simple guard against division by zero\n        if op2 == 0 or op3 == 0:\n            res = 0\n        else:\n            tmp = (op1 / op2) / op3\n            res = int(tmp)\n    elif opcode == 4: # AND\n        res = op1 & op2 & op3\n    elif opcode == 5: # OR\n        res = op1 | op2 | op3\n    elif opcode == 6: # XOR\n        res = op1 ^ op2 ^ op3\n    else:             # default\n        res = 0\n\n    # Wrap final result back to 32-bit signed\n    return to_32bit_signed(res)\n\n# Helper: convert a Python integer into 32-bit signed range\ndef to_32bit_signed(val):\n    val &= 0xFFFFFFFF\n    # Interpret highest bit as sign\n    if val & 0x80000000:\n        return val - 0x100000000\n    return val\n\n# A reusable checker that drives the DUT inputs, waits, and compares the DUT output.\nasync def alu_check(dut, opcode, op1, op2, op3):\n    # Assign inputs\n    dut.opcode.value = opcode\n    dut.operand1.value = op1\n    dut.operand2.value = op2\n    dut.operand3.value = op3\n\n    # Wait a little for combinational propagation (no clock in this design)\n    await Timer(1, units=\"ns\")\n    dut._log.info(f\"TEST Definition: opcode={opcode} op1={op1} op2={op2} op3={op3}\")\n    \n    # Read DUT output as signed\n    got = dut.result.value.signed_integer\n    # Calculate expected result via reference model\n    expected = alu_model(opcode, op1, op2, op3)\n    \n    # Log the test vector and results\n    dut._log.info(f\"TEST Result    : got={got}, expected={expected}\")\n    \n    # Check result\n    assert got == expected, (\n        f\"ERROR for opcode={opcode}, operands=({op1},{op2},{op3}): \"\n        f\"Expected {expected}, got {got}\"\n    )\n\n\n@cocotb.test()\nasync def test_basic(dut):\n    \"\"\"Basic ALU test: small fixed vectors covering each opcode.\"\"\"\n    dut._log.info(\"===== BASIC TEST START =====\")\n    \n    test_vectors = [\n        (0, 10, 20, 30),  # ADD  => 10 + 20 + 30\n        (1, 11, 21, 31),  # SUB  => 11 - 21 - 31\n        (2, 12, 22, 32),  # MUL  => 12 * 22 * 32\n        (3, 13, 23, 33),  # DIV  => 13 / 23 / 33\n        (4, 14, 24, 34),  # AND\n        (5, 15, 25, 35),  # OR\n        (6, 16, 26, 36),  # XOR\n        (7, 17, 27, 37)   # default => 0\n    ]\n    \n    for (opcode, op1, op2, op3) in test_vectors:\n        await alu_check(dut, opcode, op1, op2, op3)\n    \n    dut._log.info(\"===== BASIC TEST END =====\")\n\n\n@cocotb.test()\nasync def test_random(dut):\n    \"\"\"Random ALU test: random opcodes and operands.\"\"\"\n    dut._log.info(\"===== RANDOM TEST START =====\")\n    \n    random_tests = 20  # number of random tests to run\n    for _ in range(random_tests):\n        opcode = random.randint(0, 7)\n\n        # If case of divisions, ensure to not divide by 0\n        if (opcode == 3):\n            op1 = random.randint(-1000, 1000)\n            op2 = random.randint(-1000, 1000)\n            op3 = random.randint(-1000, 1000)\n\n            while (op2 == 0):\n                op2 = random.randint(-1000, 1000)\n\n            while (op3 == 0):\n                op3 = random.randint(-1000, 1000)\n                \n        else:\n            op1 = random.randint(-1000, 1000)\n            op2 = random.randint(-1000, 1000)\n            op3 = random.randint(-1000, 1000)\n        \n        await alu_check(dut, opcode, op1, op2, op3)\n    \n    dut._log.info(\"===== RANDOM TEST END =====\")\n\n\n@cocotb.test()\nasync def test_edgecases(dut):\n    \"\"\"Edge case ALU test: extremes (min/max int), zero, etc.\"\"\"\n    dut._log.info(\"===== EDGE CASE TEST START =====\")\n    \n    # 32-bit signed extremes\n    min_32 = -2**31\n    max_32 =  2**31 - 1\n    \n    edge_vectors = [\n        (0, 0, 0, 0),          # add with zeros\n        (0, max_32, 0, 0),     # add with max\n        (1, 0, max_32, 0),     # subtract with max\n        (2, min_32, 1, 1),     # multiply min boundary\n        (3, max_32, max_32, 1),# large division\n        (4, min_32, max_32, 0),# bitwise AND extremes\n        (5, min_32, max_32, 0),# bitwise OR extremes\n        (6, min_32, max_32, 0) # bitwise XOR extremes\n    ]\n    \n    for (opcode, op1, op2, op3) in edge_vectors:\n        await alu_check(dut, opcode, op1, op2, op3)\n    \n    dut._log.info(\"===== EDGE CASE TEST END =====\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\nDATA_WIDTH = os.getenv(\"DATA_WIDTH\", 32)  # Default to 16 if not provided\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        parameters={\n            \"DATA_WIDTH\": DATA_WIDTH\n                    },\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}
{"id": "cvdp_agentic_axi4lite_to_pcie_config_0005", "categories": ["cid014", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a AXI4Lite to PCIe config module `axi4lite_to_pcie_cfg_bridge.sv` available in the `rtl` directory. Please modify the module by adding SystemVerilog Assertions (SVA) to check its internal functionality comprehensively. The assertions should verify the following conditions:\n\n**awready_assertion** \u2013 \n- Ensures (`awready`) asserts within 2 cycles after (`awvalid`) is asserted.\n\n**wready_assertion** \u2013 \n- Checks that (`wready`) asserts within 2 cycles after (`wvalid`) is asserted.\n\n**bvalid_assertion** \u2013 \n- Verifies that (`bvalid`) asserts within 5 cycles after both (`awvalid and wvalid`) handshake.\n\n**rvalid_assertion** \u2013 \n- Ensures (`rvalid`) asserts within 10 cycles after an (`arvalid and arready`) handshake.\n\n**arready_assertion** \u2013 \n- Checks that (`arready`) asserts within 2 cycles after (`arvalid`) is asserted.\n\n**rvalid_deassertion** \u2013 \n- Ensures (`rvalid`) deasserts within 3 cycles after (`rready`) is asserted.\n\n**bvalid_deassertion** \u2013 \n- Checks that (`bvalid`) deasserts within 3 cycles after (`bready`) is asserted.\n\n**arready_deassertion** \u2013 \n- Ensures (`arready`) deasserts within 5 cycles after (`arvalid and arready`) handshake.\n\nIf any of these conditions are violated during simulation, an appropriate error message should be displayed.\n", "context": {"rtl/axi4lite_to_pcie_cfg_bridge.sv": "`timescale 1ns/1ps\n\nmodule axi4lite_to_pcie_cfg_bridge #(\n    parameter ADDR_WIDTH = 8,\n    parameter DATA_WIDTH = 32  \n)(\n    // AXI4-Lite Interface\n    input  logic        aclk,           \n    input  logic        aresetn,        \n    input  logic [ADDR_WIDTH-1:0] awaddr,         \n    input  logic        awvalid,        \n    output logic        awready,        \n    input  logic [DATA_WIDTH-1:0] wdata,          \n    input  logic [DATA_WIDTH/8-1:0]  wstrb,          \n    input  logic        wvalid,         \n    output logic        wready,         \n    output logic [1:0]  bresp,          \n    output logic        bvalid,         \n    input  logic        bready,         \n\n    \n    // Read Address Channel\n    input  logic [ADDR_WIDTH-1:0] araddr,\n    input  logic        arvalid,\n    output logic        arready,\n    \n    // Read Data Channel\n    output logic [DATA_WIDTH-1:0] rdata,\n    output logic        rvalid,\n    output logic [1:0]  rresp,\n    input  logic        rready,\n\n    // PCIe Configuration Space Interface\n    output logic [ADDR_WIDTH/4-1:0]  pcie_cfg_addr,  \n    output logic [DATA_WIDTH-1:0] pcie_cfg_wdata, \n    output logic        pcie_cfg_wr_en, \n    input  logic [DATA_WIDTH-1:0] pcie_cfg_rdata, \n    output logic        pcie_cfg_rd_en\n);\n\n    // FSM States\n    typedef enum logic [2:0] {\n        IDLE,                // 000\n        WRITE_ADDR_DATA,     // 001\n        PCIE_WRITE,          // 010 \n        SEND_RESPONSE,       // 011 \n        READ_ADDR,           // 100\n        PCIE_READ,           // 101\n        SEND_READ_RESPONSE   // 110\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Internal registers\n    logic [ADDR_WIDTH-1:0] awaddr_reg;  \n    logic [DATA_WIDTH-1:0] wdata_reg;   \n    logic [DATA_WIDTH/8-1:0]  wstrb_reg;   \n    logic [ADDR_WIDTH-1:0] araddr_reg;\n\n    //==========================================\n    // FSM Implementation\n    //==========================================\n\n    // FSM State Transition\n    always_ff @(posedge aclk or negedge aresetn) begin\n        if (!aresetn) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always_comb begin\n        next_state = current_state;\n        case (current_state)\n            IDLE: begin\n                if (awvalid && !arvalid) begin\n                    next_state = WRITE_ADDR_DATA;\n                end \n                else if (arvalid && !awvalid) begin\n                    next_state = READ_ADDR;\n                end\n                else if (awvalid && arvalid) begin\n                    next_state = IDLE;  // Stay in IDLE to prevent illegal transition\n                end\n            end\n\n            WRITE_ADDR_DATA: begin\n                if (awvalid && wvalid && awready && wready) begin\n                    next_state = PCIE_WRITE;\n                end\n            end\n\n            PCIE_WRITE: next_state = SEND_RESPONSE;\n            \n            SEND_RESPONSE: begin\n                if (bready)\n                if (bready)\n                    next_state = IDLE;\n                else\n                    next_state = SEND_RESPONSE;\n            end\n            \n            READ_ADDR: begin\n                if (arvalid) begin\n                    next_state = PCIE_READ;\n                end\n            end\n\n            PCIE_READ: next_state = SEND_READ_RESPONSE;\n            \n            SEND_READ_RESPONSE: begin\n                if (rvalid && rready) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = SEND_READ_RESPONSE;\n                end\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always_ff @(posedge aclk or negedge aresetn) begin\n        if (!aresetn) begin\n            awready <= 1'b0;\n            wready <= 1'b0;\n            bvalid <= 1'b0;\n            bresp <= 2'b00;\n            bresp <= 2'b00;\n            pcie_cfg_wr_en <= 1'b0;\n            pcie_cfg_wdata <= 32'h0;\n            pcie_cfg_addr <= 8'h0;\n            awaddr_reg <= 32'h0;\n            wdata_reg <= 32'h0;\n            wstrb_reg <= 4'h0;\n       \n            arready <= 1'b0;\n            rvalid <= 1'b0;\n            rresp <= 2'b00;\n            rdata <= 32'h0;\n            pcie_cfg_rd_en <= 1'b0;\n            araddr_reg <= 32'h0;\n       \n            arready <= 1'b0;\n            rvalid <= 1'b0;\n            rresp <= 2'b00;\n            rdata <= 32'h0;\n            pcie_cfg_rd_en <= 1'b0;\n            araddr_reg <= 32'h0;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    awready <= 1'b0;\n                    wready <= 1'b0;\n                    bvalid <= 1'b0;  // <- ENSURES CLEAN RESET\n                    pcie_cfg_wr_en <= 1'b0;\n                    arready <= 1'b0;\n                    rvalid <= 1'b0;\n                    pcie_cfg_rd_en <= 1'b0;\n                    arready <= 1'b0;\n                    rvalid <= 1'b0;\n                    pcie_cfg_rd_en <= 1'b0;\n                end\n    \n                WRITE_ADDR_DATA: begin\n                    if (awvalid && !awready) begin\n                        awready <= 1'b1;  \n                    end\n                    if (wvalid && !wready) begin\n                        wready <= 1'b1;    \n                    end\n                end\n                                           \n    \n                PCIE_WRITE: begin\n                    awready <= 1'b0;\n                    wready <= 1'b0;\n                    pcie_cfg_wr_en <= 1'b1;\n                    pcie_cfg_addr <= awaddr_reg[7:0];\n                    pcie_cfg_addr <= awaddr_reg[7:0];\n                    for (int i = 0; i < (DATA_WIDTH/8); i++) begin\n                        pcie_cfg_wdata[(i*8)+:8] <= (wstrb_reg[i]) ? wdata_reg[(i*8)+:8] : pcie_cfg_rdata[(i*8)+:8];\n                    end\n                end\n\n                READ_ADDR: begin\n                    if (arvalid && !arready) begin\n                        arready <= 1'b1;\n                        araddr_reg <= araddr;\n                    end else if (arready) begin\n                        arready <= 1'b0; // Ensure it deasserts after 1 cycle\n                    end\n                end             \n                \n                PCIE_READ: begin\n                    pcie_cfg_rd_en <= 1'b1; \n                end\n    \n                SEND_RESPONSE: begin\n                    pcie_cfg_wr_en <= 1'b0;\n                    bvalid <= 1'b1;\n                    bresp <= 2'b00;\n                \n                    if (bvalid && bready) begin\n                        bvalid <= 1'b0; \n                    end\n                end   \n                \n                SEND_READ_RESPONSE: begin\n                    if (!rvalid && pcie_cfg_rd_en) begin\n                        rvalid <= 1'b1;  \n                        rdata  <= pcie_cfg_rdata;\n                        rresp  <= 2'b00;\n                    end\n                    \n                    if (rvalid && rready) begin\n                        rvalid <= 1'b0;  \n                        pcie_cfg_rd_en <= 1'b0;\n                    end\n                end                \n    \n                default: begin\n                    awready <= 1'b0;\n                    wready <= 1'b0;\n                    bvalid <= 1'b0;\n                    pcie_cfg_wr_en <= 1'b0;\n                    arready <= 1'b0;\n                    rvalid <= 1'b0;\n                    pcie_cfg_rd_en <= 1'b0;\n                end\n            endcase\n        end\n    end\n        \nendmodule"}, "patch": {"rtl/axi4lite_to_pcie_cfg_bridge.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\nRUN pip3 install coverage", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/axi4lite_to_pcie_cfg_bridge.sv\nTOPLEVEL        = axi4lite_to_pcie_cfg_bridge\nMODULE          = test_axil_pcie_cfg\nPYTHONPATH      = /src\nHASH            = 5-write-assertions-for-axi4lite_to_pcie_conf_module", "src/test_axil_pcie_cfg.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nfrom cocotb.result import TestFailure\n\nCLK_PERIOD = 10  # 100 MHz clock period\n\n@cocotb.test()\nasync def axi4lite_test(dut):\n    \"\"\"Test AXI4-Lite to PCIe Configuration Bridge\"\"\"\n    await Timer(1, units='us')  # Increase delay to allow setup\n    # Generate Clock\n    cocotb.start_soon(Clock(dut.aclk, CLK_PERIOD, units=\"ns\").start())\n\n    # Reset sequence\n    dut.aresetn.value = 0\n    dut.awvalid.value = 0\n    dut.wvalid.value = 0\n    dut.bready.value = 0\n    dut.arvalid.value = 0\n    dut.rready.value = 0\n    await Timer(50, units=\"ns\")  # Hold reset\n    dut.aresetn.value = 1\n    await Timer(10, units=\"ns\")  # Wait after reset\n\n    cocotb.log.info(\"Reset complete. Starting AXI4-Lite test.\")\n\n    # ============================================\n    # WRITE TRANSACTION: Check awready and wready\n    # ============================================\n    cocotb.log.info(\"Starting AXI4-Lite write transaction...\")\n\n    dut.awvalid.value = 1\n    dut.awaddr.value = 0x10\n    dut.wvalid.value = 1\n    dut.wdata.value = 0xDEADBEEF\n    dut.wstrb.value = 0xF  # Enable all bytes\n\n    # Wait for `awready` within 5 cycles\n    for _ in range(5):  \n        await RisingEdge(dut.aclk)\n        if dut.awready.value == 1:\n            break\n    else:\n        assert (\"ERROR: awready not asserted within 5 cycles after awvalid\")\n\n    assert dut.wready.value == 1, \"ERROR: wready not asserted after wvalid\"\n\n    # Deassert valid signals\n    dut.awvalid.value = 0\n    dut.wvalid.value = 0\n    await RisingEdge(dut.aclk)\n\n    # Check `bvalid` within 5 cycles\n    for _ in range(5):\n        await RisingEdge(dut.aclk)\n        if dut.bvalid.value == 1:\n            break\n    else:\n        assert (\"ERROR: bvalid not asserted within 5 cycles after wvalid\")\n\n    # Acknowledge response\n    dut.bready.value = 1\n    await RisingEdge(dut.aclk)  # Give RTL time to respond\n    await RisingEdge(dut.aclk)  # Extra cycle to ensure `bvalid` is cleared\n\n    assert dut.bvalid.value == 0, \"ERROR: bvalid not deasserted after bready\"\n\n    dut.bready.value = 0\n    cocotb.log.info(\"Write transaction passed.\")\n\n    # ================================\n    # Assertion: Check bvalid Timing\n    # ================================\n    for cycle in range(10):  \n        await RisingEdge(dut.aclk)\n        if dut.bvalid.value == 1:\n            break\n        else:\n            assert (\"ERROR: bvalid not asserted within 10 cycles after write transaction\")\n\n    # Acknowledge response\n    dut.bready.value = 1\n    await RisingEdge(dut.aclk)\n    await RisingEdge(dut.aclk)  # Extra cycle to ensure bvalid is cleared\n\n    assert dut.bvalid.value == 0, \"ERROR: bvalid not deasserted after bready\"\n    dut.bready.value = 0\n    cocotb.log.info(\"Write transaction passed.\")\n\n    # ============================================\n    # READ TRANSACTION: Check arready and rvalid\n    # ============================================\n    cocotb.log.info(\"Starting AXI4-Lite read transaction...\")\n\n    # Initiate read request\n    dut.arvalid.value = 1\n    dut.araddr.value = 0x10\n\n    await RisingEdge(dut.aclk)\n\n    # Wait for `arready` to assert within 10 cycles\n    for cycle in range(10):\n        await RisingEdge(dut.aclk)\n        cocotb.log.info(f\"Cycle {cycle}: arready = {int(dut.arready.value)}\")\n        if dut.arready.value == 1:\n            break\n        else:\n            assert (\"ERROR: arready not asserted within 10 cycles after arvalid\")\n\n    dut.arvalid.value = 0  # Deassert `arvalid` after `arready` is seen\n\n    # Wait for `rvalid` to assert within 15 cycles\n    for cycle in range(15):  # Extended timeout\n        await RisingEdge(dut.aclk)\n        cocotb.log.info(f\"Cycle {cycle}: rvalid = {int(dut.rvalid.value)}\")\n        if dut.rvalid.value == 1:\n            break\n        else:\n            assert (\"ERROR: rvalid not asserted within 15 cycles after read transaction\")\n\n    # Acknowledge read data\n    dut.rready.value = 1\n    await RisingEdge(dut.aclk)\n\n    # Ensure `rvalid` is deasserted after `rready`\n    for cycle in range(5):  # Wait for up to 5 cycles for `rvalid` to go low\n        await RisingEdge(dut.aclk)\n        if dut.rvalid.value == 0:\n            break\n    else:\n        assert (\"ERROR: rvalid not deasserted after rready\")\n\n    dut.rready.value = 0\n    cocotb.log.info(\"Read transaction passed. Test complete!\")\n\n    @cocotb.test()\n    async def check_arready_assertion(dut):\n        \"\"\"Test that arready asserts within 2 cycles after arvalid\"\"\"\n    \n    dut.arvalid.value = 1  # Set arvalid to initiate a read request\n    await RisingEdge(dut.aclk)\n\n    # Wait up to 2 clock cycles for arready to assert\n    for _ in range(2):\n        await RisingEdge(dut.aclk)\n        if dut.arready.value == 1:\n            break\n    else:\n        raise TestFailure(\"ERROR: arready not asserted within 2 cycles after arvalid\")\n    \n    dut._log.info(\"PASS: arready asserted within 2 cycles after arvalid\")\n\n    @cocotb.test()\n    async def test_rvalid_deassertion(dut):\n        \"\"\"Test if rvalid deasserts after rready is high.\"\"\"\n    \n    # Generate Clock\n    cocotb.start_soon(Clock(dut.aclk, CLK_PERIOD, units=\"ns\").start())\n\n    # Reset sequence\n    dut.aresetn.value = 0\n    dut.awvalid.value = 0\n    dut.wvalid.value = 0\n    dut.bready.value = 0\n    dut.arvalid.value = 0\n    dut.rready.value = 0\n    await Timer(50, units=\"ns\")  # Hold reset\n    dut.aresetn.value = 1\n    await Timer(10, units=\"ns\")  # Wait after reset\n\n    # Initial conditions\n    dut.arvalid.value = 0\n    dut.araddr.value = 0x20  # Example address\n    dut.rready.value = 0\n\n    # Wait for a clock cycle before starting\n    await RisingEdge(dut.aclk)\n\n    # Step 1: Initiate a read transaction\n    dut.arvalid.value = 1\n    await RisingEdge(dut.aclk)\n\n    # Step 2: Wait for `arready` to assert\n    while dut.arready.value == 0:\n        await RisingEdge(dut.aclk)\n\n    dut._log.info(\"arready asserted, read address handshake complete.\")\n\n    # Step 3: Wait for `rvalid` to assert\n    while dut.rvalid.value == 0:\n        await RisingEdge(dut.aclk)\n\n    dut._log.info(\"rvalid asserted, read data available.\")\n\n    # Step 4: Assert `rready` and check if `rvalid` deasserts\n    dut.rready.value = 1\n    await RisingEdge(dut.aclk)  # Wait one cycle\n    await Timer(1, units=\"ns\") \n    if dut.rvalid.value == 0:\n        dut._log.info(\"rvalid correctly deasserted after rready.\")\n    else:\n        dut._log.error(\"\u274c ERROR: rvalid did NOT deassert after rready was asserted.\")\n        assert (\"rvalid did not deassert after rready.\")\n\n    @cocotb.test()\n    async def check_arready_deassertion(dut):\n        \"\"\"Check that arready deasserts within 5 cycles after arvalid handshake\"\"\"\n\n    max_cycles = 1000  # Prevent infinite loops\n    cycles_waited = 0\n\n    await RisingEdge(dut.aclk)  # Wait for the first clock edge\n    \n    while cycles_waited < max_cycles:\n        await RisingEdge(dut.aclk)\n        cycles_waited += 1  # Track how many cycles we waited\n\n        if dut.arvalid.value and dut.arready.value:\n            handshake_time = cocotb.utils.get_sim_time('ns')\n            #dut._log.info(f\"arvalid & arready handshake at {handshake_time} ns\")\n\n            # Check for deassertion within 5 cycles\n            for cycle in range(1, 5):  # 1 to 5 cycles\n                await RisingEdge(dut.aclk)\n                if not dut.arready.value:\n                    dut._log.info(f\"arready deasserted at {cocotb.utils.get_sim_time('ns')} ns (within {cycle} cycles)\")\n                    return  # Test passes\n            assert (\"\u274c ERROR: Timeout! `arvalid` and `arready` handshake never occurred.\")", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}
{"id": "cvdp_agentic_axis_to_uart_0013", "categories": ["cid014", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a hierarchical UART design consisting of three SystemVerilog modules located in the `/code/rtl` directory:\n\n1. **axis_to_uart_tx.sv**  \n   This module converts AXI\u2011Stream data into a serial UART output. It supports configurable clock frequency, bit rate, word size, optional parity (none, odd, or even), and configurable stop bits. It employs a state machine (states: IDLE, START, DATA, PARITY, STOP1, STOP2) that drives the TX line accordingly.\n\n2. **uart_rx_to_axis.sv**  \n   This module converts an incoming UART serial stream into an AXI\u2011Stream data output. It samples the RX line using a synchronizer and implements its state machine (states: IDLE, START, DATA, PARITY, STOP1, STOP2, OUT_RDY). Based on the received data, it also computes a parity error flag.\n\n3. **axis_to_uart.sv (Top-level module)**  \n   This module instantiates the TX and RX blocks, connecting the AXI\u2011Stream interfaces and physical UART signals.\n\n### Assertion Requirements\n\nPlease enhance the design by adding **SystemVerilog Assertions (SVA)** to verify functional correctness and safety across the modules. The assertions should meet the following requirements:\n\n#### For **axis_to_uart_tx.sv**  \n- **Reset and Idle Check:**  \n  Assert that when the FSM is in the IDLE state, the TX output is high (idle level) and that the module asserts tready.\n  \n- **START State Check:**  \n  Assert that one clock cycle after the FSM enters the START state, the TX signal is low (indicating a proper start bit).\n  \n- **DATA State Check:**  \n  While in the DATA state and during the mid\u2011bit period (when the clock counter is not zero), assert that TX equals the current data bit from the shift register.\n  \n- **PARITY State Check:**  \n  In the PARITY state, add an assertion to cover the parity check:  \n  - When parity is disabled (PARITY_BIT == 0), the FSM must never enter the PARITY state.  \n  - When parity is enabled (PARITY_BIT != 0), assert that one cycle after entering the PARITY state, TX equals the computed parity value.\n  \n- **STOP State Check:**  \n  Assert that one cycle after entering either STOP1 or STOP2, TX is high.\n\n#### For **uart_rx_to_axis.sv**  \n- **IDLE and OUT_RDY Validity:**  \n  Assert that when the FSM is in IDLE, tvalid is low; and when in OUT_RDY, tvalid is high.\n  \n- **Parity Checking:**  \n  Once the FSM is in the PARITY state and the bit period is complete (Clk_Count_Done), wait one clock cycle and then verify that the computed parity error flag (Parity_Err) correctly reflects the comparison between the received parity bit and the computed parity for the data.\n  \n- **Output Acknowledgment:**  \n  Assert that in the OUT_RDY state, if the downstream interface asserts tready, then the FSM should transition to IDLE.\n\n#### For the **axis_to_uart.sv** Top Module  \n- **Reset Behavior:**  \n  Assert that during reset (when aresetn is low), the top-level outputs (e.g., TX and the AXI\u2011Stream out interface) remain at their idle values (TX high, out_tvalid low).\n\n### Implementation Notes\n\n- Use SVA syntax to structure your properties, for example using `property ... endproperty` blocks and assertions with `assert property(...) else $error(\"...\")`.\n- For the parity assertion in the TX block, consider splitting the check using conditional implications (or a combination of separate properties) such that:  \n  - If PARITY_BIT is 0 then the assertion passes if the PARITY state is never entered, and  \n  - If PARITY_BIT is nonzero then after one clock cycle in the PARITY state, TX equals Parity_Value.\n- Ensure that the tests (for example, via our cocotb testbench) exercise all states of the FSM so that these assertions achieve 100% coverage.\n- Do not include your complete RTL code in your submission\u2014only the assertion additions should be provided for each module.\n\nPlease generate all the SVA properties for the TX, RX, and top modules according to these requirements.\n", "context": {"rtl/axis_to_uart_tx.sv": "`timescale 1ns / 1ps\n//------------------------------------------------------------------------------\n// Module: axis_to_uart_tx\n// Description: This module converts AXI-Stream data into UART serial output.\n//              It supports configurable clock frequency, bit rate, word size,\n//              optional parity (none, odd, or even), and configurable stop bits.\n//              The design includes a state machine to transmit the start bit,\n//              data bits, optional parity bit, and stop bit(s).\n//------------------------------------------------------------------------------\nmodule axis_to_uart_tx\n#(\n    parameter int CLK_FREQ      = 100,    // Clock frequency in MHz\n    parameter int BIT_RATE      = 115200, // UART bit rate (bits per second)\n    parameter int BIT_PER_WORD  = 8,      // Number of bits in one data word\n    parameter int PARITY_BIT    = 0,      // Parity bit mode: 0-none, 1-odd, 2-even\n    parameter int STOP_BITS_NUM  = 1       // Number of stop bits: 1 or 2\n)\n(\n    // AXI-Stream interface\n    input  logic        aclk,\n    input  logic        aresetn,\n    input  logic [7:0]  tdata,\n    input  logic        tvalid,\n    output logic        tready,\n\n    // UART interface\n    output logic        TX\n);\n\n    //--------------------------------------------------------------------------\n    // State Definitions\n    //--------------------------------------------------------------------------\n    typedef enum logic [2:0] {\n        IDLE,   // Wait for valid data\n        START,  // Transmit start bit (low)\n        DATA,   // Transmit data bits\n        PARITY, // Transmit parity bit (if enabled)\n        STOP1,  // Transmit first stop bit (high)\n        STOP2   // Transmit second stop bit if required\n    } tx_state_t;\n\n    tx_state_t State, Next_State;\n\n    //--------------------------------------------------------------------------\n    // Calculation of clock cycles per bit period\n    // Note: Multiply MHz by 1,000,000 to get Hz.\n    //--------------------------------------------------------------------------\n    localparam int Cycle_per_Period = CLK_FREQ * 1_000_000 / BIT_RATE;\n\n    //--------------------------------------------------------------------------\n    // Internal signals\n    //--------------------------------------------------------------------------\n    // Clock period counter: counts clock cycles for the duration of one UART bit.\n    logic [17:0] Clk_Count;\n    logic        Clk_Count_En, Clk_Count_Done;\n\n    // Data bit counter: counts bits transmitted in DATA state.\n    logic [3:0]  Bit_Count;\n    logic        Bit_Count_Done;\n\n    // Shift register for holding the data byte to be transmitted.\n    logic [BIT_PER_WORD-1:0] Data;\n\n    // Parity bit computed for the data.\n    logic Parity_Value;\n\n    // Combinational output to drive the TX line.\n    logic Uart_Out;\n\n    //--------------------------------------------------------------------------\n    // Load Data from AXI-Stream when valid and ready\n    //--------------------------------------------------------------------------\n    always_ff @(posedge aclk) begin\n        if (!aresetn) begin\n            Data <= '0;\n        end\n        else if (tvalid && tready) begin\n            Data <= tdata;\n        end\n    end\n\n    //--------------------------------------------------------------------------\n    // Parity Bit Computation (combinational)\n    // 0 : No parity\n    // 1 : Odd parity (invert even parity result)\n    // 2 : Even parity\n    //--------------------------------------------------------------------------\n    always_comb begin\n        case(PARITY_BIT)\n            0: Parity_Value = 1'b0;                              // No parity\n            1: Parity_Value = ~(^Data[BIT_PER_WORD-1:0]);        // Odd parity\n            2: Parity_Value =  ^Data[BIT_PER_WORD-1:0];          // Even parity\n            default: Parity_Value = 1'b0;\n        endcase\n    end\n\n    //--------------------------------------------------------------------------\n    // Clock Counter Logic (Bug Fix Applied)\n    // The counter now counts from 0 to (Cycle_per_Period - 1) so that the\n    // Clk_Count_Done signal is correctly asserted.\n    //--------------------------------------------------------------------------\n    always_ff @(posedge aclk) begin\n        if (!aresetn) begin\n            Clk_Count <= '0;\n        end\n        else if (Clk_Count_En) begin\n            if (Clk_Count == (Cycle_per_Period - 1)) begin\n                Clk_Count <= '0;\n            end\n            else begin\n                Clk_Count <= Clk_Count + 1;\n            end\n        end\n        else begin\n            Clk_Count <= '0;\n        end\n    end\n\n    // When Clk_Count reaches (Cycle_per_Period - 1) it indicates one bit period is complete.\n    assign Clk_Count_Done = (Clk_Count == (Cycle_per_Period - 1));\n\n    //--------------------------------------------------------------------------\n    // Data Bit Counter Logic\n    // This counter increments in the DATA state when the clock counter indicates a\n    // complete bit period. When all data bits are transmitted, Bit_Count_Done is asserted.\n    //--------------------------------------------------------------------------\n    always_ff @(posedge aclk) begin\n        if (!aresetn) begin\n            Bit_Count <= '0;\n        end\n        else if (Clk_Count_Done && (State == DATA)) begin\n            if (Bit_Count == (BIT_PER_WORD - 1))\n                Bit_Count <= '0;\n            else\n                Bit_Count <= Bit_Count + 1;\n        end\n    end\n\n    assign Bit_Count_Done = ((Bit_Count == (BIT_PER_WORD - 1)) && Clk_Count_Done);\n\n    //--------------------------------------------------------------------------\n    // UART TX Output Register\n    // TX line is updated based on the combinational Uart_Out value.\n    //--------------------------------------------------------------------------\n    always_ff @(posedge aclk) begin\n        if (!aresetn) begin\n            TX <= 1'b1; // Idle state for UART (line high)\n        end\n        else begin\n            TX <= Uart_Out;\n        end\n    end\n\n    // tready signal is asserted when in IDLE state, meaning the module is ready to\n    // accept new data.\n    assign tready = (State == IDLE);\n\n    //--------------------------------------------------------------------------\n    // State Machine: Current State Register\n    //--------------------------------------------------------------------------\n    always_ff @(posedge aclk) begin\n        if (!aresetn) begin\n            State <= IDLE;\n        end\n        else begin\n            State <= Next_State;\n        end\n    end\n\n    //--------------------------------------------------------------------------\n    // Output Logic: Generate UART output and clock counter enable signal based on state.\n    //--------------------------------------------------------------------------\n    always_comb begin\n        // Default assignments\n        Clk_Count_En = 1'b0;\n        Uart_Out     = 1'b1; // Default line idle (high)\n\n        case(State)\n            IDLE: begin\n                // No transmission; waiting for valid data.\n                Clk_Count_En = 1'b0;\n                Uart_Out     = 1'b1;\n            end\n            START: begin\n                // Transmit start bit (logic low) for one bit period.\n                Clk_Count_En = 1'b1;\n                Uart_Out     = 1'b0;\n            end\n            DATA: begin\n                // Transmit data bits (use the data bit at current Bit_Count)\n                Clk_Count_En = 1'b1;\n                Uart_Out     = Data[Bit_Count];\n            end\n            PARITY: begin\n                // Transmit the computed parity bit.\n                Clk_Count_En = 1'b1;\n                Uart_Out     = Parity_Value;\n            end\n            STOP1,\n            STOP2: begin\n                // Transmit stop bit(s): logic high.\n                Clk_Count_En = 1'b1;\n                Uart_Out     = 1'b1;\n            end\n        endcase\n    end\n\n    //--------------------------------------------------------------------------\n    // Next State Logic\n    //--------------------------------------------------------------------------\n    always_comb begin\n        // Default to remain in current state if no conditions met.\n        Next_State = State;\n        case(State)\n            IDLE: begin\n                // If valid data is available, move to START state.\n                if (tvalid)\n                    Next_State = START;\n            end\n            START: begin\n                // After one bit period of start bit, move to DATA state.\n                if (Clk_Count_Done)\n                    Next_State = DATA;\n            end\n            DATA: begin\n                // Transmit data bits; when the last bit is done, transition out.\n                if (Bit_Count_Done) begin\n                    if (PARITY_BIT != 0)\n                        Next_State = PARITY;\n                    else\n                        Next_State = STOP1;\n                end\n            end\n            PARITY: begin\n                // After parity bit period, move to first stop bit.\n                if (Clk_Count_Done)\n                    Next_State = STOP1;\n            end\n            STOP1: begin\n                // After the first stop bit, if only one stop bit is required, return to IDLE.\n                // Else, move to second stop bit.\n                if (Clk_Count_Done) begin\n                    if (STOP_BITS_NUM == 1)\n                        Next_State = IDLE;\n                    else\n                        Next_State = STOP2;\n                end\n            end\n            STOP2: begin\n                // After second stop bit, return to IDLE.\n                if (Clk_Count_Done)\n                    Next_State = IDLE;\n            end\n        endcase\n    end\n\nendmodule", "rtl/uart_rx_to_axis.sv": "`timescale 1ns / 1ps\nmodule uart_rx_to_axis\n#(\n    parameter CLK_FREQ      = 100,       // Clock frequency in MHz\n    parameter BIT_RATE      = 115200,    // UART bit rate (bits per second)\n    parameter BIT_PER_WORD  = 8,         // Number of bits in one data word\n    parameter PARITY_BIT    = 0,         // Parity bit mode: 0=none, 1=odd, 2=even\n    parameter STOP_BITS_NUM = 1          // Number of stop bits: 1 or 2\n)\n(\n    // AXI-Stream interface\n    input  wire         aclk,      // System clock\n    input  wire         aresetn,   // Active-low reset signal\n    output wire [7:0]   tdata,     // Output data (reconstructed from UART frame)\n    output wire         tuser,     // Indicates a parity error if set (when parity is enabled)\n    output wire         tvalid,    // AXI-Stream valid: asserts when data is ready\n    input  wire         tready,    // AXI-Stream ready: the receiver can accept data\n\n    // UART interface\n    input  wire         RX         // Serial UART input line\n);\n\n    //--------------------------------------------------------------------------\n    // FSM State Encoding\n    //--------------------------------------------------------------------------\n    typedef enum logic [2:0] {\n        IDLE    = 3'b000,\n        START   = 3'b001,\n        DATA    = 3'b010,\n        PARITY  = 3'b011,\n        STOP1   = 3'b100,\n        STOP2   = 3'b101,\n        OUT_RDY = 3'b110\n    } rx_state_t;\n\n    // Current and next state variables for the FSM\n    rx_state_t State, Next_State;\n\n    //--------------------------------------------------------------------------\n    // Compute Clock Cycles per Bit\n    //--------------------------------------------------------------------------\n    localparam integer Cycle_per_Period      = CLK_FREQ * 1000000 / BIT_RATE;\n    localparam integer Cycle_per_Period_Half = Cycle_per_Period / 2;\n\n    //--------------------------------------------------------------------------\n    // Synchronize the RX Input and Detect Falling Edge\n    //--------------------------------------------------------------------------\n    logic [2:0] RX_Sync;      // 3-stage synchronizer for 'RX'\n    logic       RX_Falling;   // Indicates a falling edge on 'RX'\n    always_ff @(posedge aclk) begin\n        if (!aresetn) begin\n            RX_Sync <= 3'b111;  // Initialize to idle high\n        end\n        else begin\n            RX_Sync <= {RX_Sync[1:0], RX};\n        end\n    end\n    assign RX_Falling = RX_Sync[2] & ~RX_Sync[1]; // High->Low transition detection\n\n    //--------------------------------------------------------------------------\n    // Internal Signals for Counting\n    //--------------------------------------------------------------------------\n    logic [17:0] Clk_Count;      // Clock counter for bit timing\n    logic [17:0] Clk_Count_Max;  // The max count we compare with\n    logic        Clk_Count_En;   // Enables counting\n    logic        Clk_Count_Done; // Asserts when Clk_Count == Clk_Count_Max\n\n    logic [3:0]  Bit_Count;      // Counts how many data bits received\n    logic        Bit_Count_Done; // True when we've received all data bits\n\n    //--------------------------------------------------------------------------\n    // Data Shift Register (LSB-first)\n    //--------------------------------------------------------------------------\n    logic [BIT_PER_WORD-1:0] Data_Shift_Reg;\n\n    //--------------------------------------------------------------------------\n    // Parity Error Flag\n    //--------------------------------------------------------------------------\n    logic Parity_Err;\n\n    //--------------------------------------------------------------------------\n    // Clock Counter Logic\n    //--------------------------------------------------------------------------\n    always_ff @(posedge aclk) begin\n        if(!aresetn) begin\n            Clk_Count <= 18'b0;\n        end\n        else if(Clk_Count_En) begin\n            if(Clk_Count == Clk_Count_Max) begin\n                Clk_Count <= 18'b0;\n            end\n            else begin\n                Clk_Count <= Clk_Count + 1'b1;\n            end\n        end\n        else begin\n            Clk_Count <= 18'b0;\n        end\n    end\n    assign Clk_Count_Done = (Clk_Count == Clk_Count_Max);\n\n    //--------------------------------------------------------------------------\n    // Bit Counter for DATA State\n    //--------------------------------------------------------------------------\n    always_ff @(posedge aclk) begin\n        if(!aresetn) begin\n            Bit_Count <= 4'b0;\n        end\n        else if(Clk_Count_Done && (State == DATA)) begin\n            if(Bit_Count == (BIT_PER_WORD - 1))\n                Bit_Count <= 4'b0;\n            else\n                Bit_Count <= Bit_Count + 1'b1;\n        end\n    end\n    assign Bit_Count_Done = ((Bit_Count == (BIT_PER_WORD - 1)) && Clk_Count_Done);\n\n    //--------------------------------------------------------------------------\n    // Data Shift Register\n    //--------------------------------------------------------------------------\n    always_ff @(posedge aclk) begin\n        if (!aresetn) begin\n            Data_Shift_Reg <= {BIT_PER_WORD{1'b0}};\n        end\n        else if (Clk_Count_Done && (State == DATA)) begin\n            // SHIFT RIGHT: The bit from RX_Sync[0] becomes the left side.\n            // If your design or testbench is truly LSB-first, you might SHIFT LEFT.\n            // Make sure testbench matches this approach.\n            Data_Shift_Reg <= {RX_Sync[0], Data_Shift_Reg[BIT_PER_WORD-1:1]};\n        end\n    end\n\n    //--------------------------------------------------------------------------\n    // AXI-Stream Outputs\n    //--------------------------------------------------------------------------\n    assign tdata  = Data_Shift_Reg;\n    assign tuser  = Parity_Err;\n    assign tvalid = (State == OUT_RDY);\n\n    //--------------------------------------------------------------------------\n    // Parity Checking\n    //--------------------------------------------------------------------------\n    always_ff @(posedge aclk) begin\n        if(!aresetn) begin\n            Parity_Err <= 1'b0;\n        end\n        else if(Clk_Count_Done && (State == PARITY)) begin\n            case(PARITY_BIT)\n                0: Parity_Err <= 1'b0;\n                1: Parity_Err <= ( ~(^Data_Shift_Reg) != RX_Sync[0] ); // Odd parity\n                2: Parity_Err <= (  (^Data_Shift_Reg) != RX_Sync[0] ); // Even parity\n                default: Parity_Err <= 1'b0;\n            endcase\n        end\n        else if (State == OUT_RDY && Next_State == IDLE) begin\n            // Optionally clear parity error when going back to IDLE\n            Parity_Err <= 1'b0;\n        end\n    end\n\n    //--------------------------------------------------------------------------\n    // RX FSM: Current State Register\n    //--------------------------------------------------------------------------\n    always_ff @(posedge aclk) begin\n        if(!aresetn) begin\n            State <= IDLE;\n        end\n        else begin\n            State <= Next_State;\n        end\n    end\n\n    //--------------------------------------------------------------------------\n    // Clock Counter Control\n    //--------------------------------------------------------------------------\n    always_comb begin\n        Clk_Count_En  = 1'b0;\n        Clk_Count_Max = Cycle_per_Period;\n\n        case(State)\n            IDLE,\n            OUT_RDY: begin\n                Clk_Count_En  = 1'b0;\n                Clk_Count_Max = Cycle_per_Period;\n            end\n            START: begin\n                Clk_Count_En  = 1'b1;\n                Clk_Count_Max = Cycle_per_Period_Half;  // half bit for center-sampling start\n            end\n            DATA,\n            PARITY,\n            STOP1,\n            STOP2: begin\n                Clk_Count_En  = 1'b1;\n                Clk_Count_Max = Cycle_per_Period;       // full bit for data, parity, stops\n            end\n            default: begin\n                Clk_Count_En  = 1'b0;\n                Clk_Count_Max = Cycle_per_Period;\n            end\n        endcase\n    end\n\n    //--------------------------------------------------------------------------\n    // Next State Logic\n    //--------------------------------------------------------------------------\n    always_comb begin\n        Next_State = State; // Default: remain in current state\n        case(State)\n            IDLE: begin\n                // If the synchronized RX line had a falling edge,\n                // that signals a potential start bit. Move to START state.\n                if(RX_Falling) Next_State = START;\n            end\n\n            START: begin\n                // After half a bit time, we move to the DATA state.\n                // The idea is that this \"center-samples\" the start bit.\n                if(Clk_Count_Done) Next_State = DATA;\n            end\n\n            DATA: begin\n                // Once we\u2019ve received 'BIT_PER_WORD' bits (Bit_Count_Done),\n                // we move to PARITY if it\u2019s enabled, otherwise STOP1.\n                if(Bit_Count_Done) begin\n                    if(PARITY_BIT != 0) Next_State = PARITY;\n                    else                Next_State = STOP1;\n                end\n            end\n\n            PARITY: begin\n                // Sample the parity bit for one bit period,\n                // then proceed to STOP1.\n                if(Clk_Count_Done) Next_State = STOP1;\n            end\n\n            STOP1: begin\n                // Wait for one stop bit. If only one is required, go to OUT_RDY.\n                // If STOP_BITS_NUM=2, proceed to STOP2.\n                if(Clk_Count_Done) begin\n                    if(STOP_BITS_NUM == 1) Next_State = OUT_RDY;\n                    else                   Next_State = STOP2;\n                end\n            end\n\n            STOP2: begin\n                // Same logic for the second stop bit; after that, go to OUT_RDY.\n                if(Clk_Count_Done) Next_State = OUT_RDY;\n            end\n\n            OUT_RDY: begin\n                // tvalid is asserted in this state, presenting the data word on tdata.\n                // We stay here until 'tready' is asserted by the downstream consumer.\n                // Once accepted, we return to IDLE to look for the next frame.\n                if (tready) Next_State = IDLE;\n                else        Next_State = OUT_RDY;\n            end\n\n            default: Next_State = IDLE;\n        endcase\n    end\n\nendmodule", "rtl/axis_to_uart.sv": "`timescale 1ns / 1ps\n\nmodule axis_to_uart\n#(\n    parameter CLK_FREQ      = 100,       // Clock frequency in MHz\n    parameter BIT_RATE      = 115200,    // UART bit rate (bits per second)\n    parameter BIT_PER_WORD  = 8,         // Number of bits in one data word\n    parameter PARITY_BIT    = 0,         // Parity bit: 0-none, 1-odd, 2-even\n    parameter STOP_BITS_NUM = 1          // Number of stop bits: 1 or 2\n)\n(\n    input  logic        aclk,\n    input  logic        aresetn,\n\n    // Input AXI-Stream interface (TX Path)\n    input  logic [7:0]  in_tdata,\n    input  logic        in_tvalid,\n    output logic        in_tready,\n\n    // Output AXI-Stream interface (RX Path)\n    output logic [7:0]  out_tdata,\n    output logic        out_tuser,\n    output logic        out_tvalid,\n    input  logic        out_tready,\n\n    // UART interface (physical pins)\n    input  logic        RX,\n    output logic        TX\n);\n\n    // Instantiate the AXI-Stream to UART TX block\n    axis_to_uart_tx #(\n        .CLK_FREQ     (CLK_FREQ),\n        .BIT_RATE     (BIT_RATE),\n        .BIT_PER_WORD (BIT_PER_WORD),\n        .PARITY_BIT   (PARITY_BIT),\n        .STOP_BITS_NUM(STOP_BITS_NUM)\n    ) TX_Block (\n        // AXI-Stream interface\n        .aclk   (aclk),\n        .aresetn(aresetn),\n        .tdata  (in_tdata),\n        .tvalid (in_tvalid),\n        .tready (in_tready),\n\n        // UART Tx line\n        .TX     (TX)\n    );\n\n    // Instantiate the UART RX to AXI-Stream block\n    uart_rx_to_axis #(\n        .CLK_FREQ     (CLK_FREQ),\n        .BIT_RATE     (BIT_RATE),\n        .BIT_PER_WORD (BIT_PER_WORD),\n        .PARITY_BIT   (PARITY_BIT),\n        .STOP_BITS_NUM(STOP_BITS_NUM)\n    ) RX_Block (\n        // AXI-Stream interface\n        .aclk   (aclk),\n        .aresetn(aresetn),\n        .tdata  (out_tdata),\n        .tuser  (out_tuser),\n        .tvalid (out_tvalid),\n        .tready (out_tready),\n\n        // UART Rx line\n        .RX     (RX)\n    );\n\nendmodule"}, "patch": {"rtl/axis_to_uart.sv": "", "rtl/axis_to_uart_tx.sv": "", "rtl/uart_rx_to_axis.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    environment:\n      - PYTHONPATH=/code/harness/lib\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/axis_to_uart_tx.sv /code/rtl/uart_rx_to_axis.sv /code/rtl/axis_to_uart.sv\nTOPLEVEL        = axis_to_uart\nMODULE          = test_axis_to_uart\nPYTHONPATH      = /src\nHASH            = cb2f22508c1f07a5213150676aa00e31ab9c58eb\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\n\nasync def access_hit(dut, index_a, way_select_a):\n    await FallingEdge(dut.clock)\n    dut.access.value = 1\n    dut.hit.value = 1\n    dut.index.value = index_a\n    dut.way_select.value = way_select_a\n\n    await FallingEdge(dut.clock)\n    print(f\"[DEBUG] way_replace: {dut.way_replace.value}\")\n    dut.access.value = 0\n    dut.hit.value = 0\n\n\nasync def access_miss(dut, index_a, way_select_a):\n    await FallingEdge(dut.clock)\n    dut.access.value = 1\n    dut.hit.value = 0\n    dut.index.value = index_a\n    dut.way_select.value = way_select_a\n\n    await FallingEdge(dut.clock)\n    print(f\"[DEBUG] way_replace: 0b{dut.way_replace.value.integer:04b}\")\n    dut.access.value = 0\n    dut.hit.value = 0\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0", "src/test_axis_to_uart.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n#--------------------------------------------------------------------\n# Local constants (using expected DUT defaults):\n#   CLK_FREQ   = 100 MHz, BIT_RATE = 115200\n#   Bit period = (100e6 / 115200) * CLK_PERIOD_NS  where CLK_PERIOD_NS = 10 ns \n#              \u2248 8680 ns.\n#--------------------------------------------------------------------\nCLK_PERIOD_NS      = 10      # Clock period of 10 ns (100 MHz)\nBIT_PERIOD_NS      = 8680    # Derived bit period based on DUT defaults.\nNUM_FRAMES_TX      = 5       # Number of TX frames to send\nNUM_FRAMES_RX      = 5       # Number of RX frames to send\nRESET_CYCLES       = 5       # Reset duration in clock cycles\nIDLE_WAIT_CYCLES   = 10      # Wait cycles after reset\n\n@cocotb.test()\nasync def test_axis_to_uart(dut):\n    \"\"\"\n    Top-level test flow:\n      1) Reset.\n      2) Enhanced TX-only test: drive AXI input and decode TX output fully.\n      3) Reinitialize and reset.\n      4) Enhanced RX-only test: drive proper UART frames on RX.\n    \"\"\"\n    dut._log.info(\"Starting enhanced cocotb test for 100% assertion coverage.\")\n\n    # Create and start clock\n    clock = Clock(dut.aclk, CLK_PERIOD_NS, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Apply reset\n    dut.aresetn.value   = 0\n    dut.in_tvalid.value = 0\n    dut.in_tdata.value  = 0\n    dut.out_tready.value= 0\n    dut.RX.value        = 1  # UART idle is high\n\n    for _ in range(RESET_CYCLES):\n        await RisingEdge(dut.aclk)\n    dut.aresetn.value = 1\n\n    # Stabilize\n    for _ in range(IDLE_WAIT_CYCLES):\n        await RisingEdge(dut.aclk)\n\n    # --- Enhanced TX-Only Test ---\n    await tx_only_test(dut)\n\n    # Wait between tests\n    for _ in range(IDLE_WAIT_CYCLES):\n        await RisingEdge(dut.aclk)\n\n    # Re-assert reset before RX test\n    dut._log.info(\"Applying second reset before RX-only test\")\n    dut.aresetn.value   = 0\n    dut.in_tvalid.value = 0\n    dut.in_tdata.value  = 0\n    dut.RX.value        = 1\n    dut.out_tready.value= 0\n\n    for _ in range(RESET_CYCLES * 2):\n        await RisingEdge(dut.aclk)\n    dut.aresetn.value = 1\n\n    for _ in range(IDLE_WAIT_CYCLES):\n        await RisingEdge(dut.aclk)\n\n    # --- Enhanced RX-Only Test ---\n    await rx_only_test(dut)\n\n    # Finish test\n    for _ in range(20):\n        await RisingEdge(dut.aclk)\n    dut._log.info(\"All tests completed successfully.\")\n\nasync def tx_only_test(dut):\n    \"\"\"\n    Enhanced TX-only test that correctly handles an optional PARITY bit.\n    \"\"\"\n    dut._log.info(\"=== Enhanced TX-Only Test Start ===\")\n\n    # We can probe the actual PARITY_BIT parameter inside the DUT at runtime\n    # if the simulator supports it. Otherwise, read from an env variable, etc.\n    parity_mode = int(dut.PARITY_BIT)  # 0=no parity, 1=odd, 2=even\n\n    random_frames = [random.randint(0, 255) for _ in range(NUM_FRAMES_TX)]\n    for i, val in enumerate(random_frames):\n        dut._log.info(f\"TX test: Frame {i}, data = 0x{val:02X}\")\n\n    for i, val in enumerate(random_frames):\n        # Wait for tready\n        while not dut.in_tready.value:\n            await RisingEdge(dut.aclk)\n\n        # Drive input and assert valid\n        dut.in_tdata.value  = val\n        dut.in_tvalid.value = 1\n        while not (dut.in_tvalid.value and dut.in_tready.value):\n            await RisingEdge(dut.aclk)\n        # Completed handshake\n        await RisingEdge(dut.aclk)\n        dut.in_tvalid.value = 0\n        dut._log.info(f\"Frame {i}: AXI handshake complete, data = 0x{val:02X}\")\n\n        # --- Wait for TX falling edge (start bit) ---\n        while dut.TX.value != 0:\n            await RisingEdge(dut.aclk)\n        dut._log.info(f\"Frame {i}: Detected falling edge (start bit).\")\n\n        # Check START bit at mid\u2010bit\n        await Timer(BIT_PERIOD_NS / 2, units='ns')\n        if dut.TX.value != 0:\n            dut._log.error(f\"Frame {i}: START bit not low at mid\u2010bit sample (TX = {dut.TX.value}).\")\n        else:\n            dut._log.info(f\"Frame {i}: START bit verified low at mid\u2010bit sample.\")\n\n        # --- Sample DATA bits (LSB first) ---\n        for bit_idx in range(8):\n            await Timer(BIT_PERIOD_NS, units='ns')\n            expected_bit = (val >> bit_idx) & 1\n            actual_bit   = int(dut.TX.value)\n            dut._log.info(f\"Frame {i}: Data bit {bit_idx} expected {expected_bit}, got {actual_bit}\")\n            if actual_bit != expected_bit:\n                dut._log.error(\n                    f\"Frame {i}: Data bit {bit_idx} mismatch: expected {expected_bit}, got {actual_bit}\"\n                )\n\n        # --- If parity is enabled, sample the PARITY bit here ---\n        if parity_mode != 0:\n            await Timer(BIT_PERIOD_NS, units='ns')\n            parity_bit = int(dut.TX.value)\n            dut._log.info(f\"Frame {i}: PARITY bit read as {parity_bit}\")\n            # Optionally, compute the expected parity in Python and compare.\n            # For example:\n            #\n            #   computed = reduce(xor, [(val >> b) & 1 for b in range(8)])\n            #   if parity_mode == 1:  # odd\n            #       expected_parity = 1 - computed\n            #   else:  # parity_mode == 2 => even\n            #       expected_parity = computed\n            #\n            #   if parity_bit != expected_parity:\n            #       dut._log.error(f\"Frame {i}: PARITY bit mismatch: expected {expected_parity}, got {parity_bit}\")\n\n        # --- Finally, check the STOP bit(s) ---\n        # (Assuming 1 stop bit in the code below \u2014 if your module has STOP_BITS_NUM=2, loop twice)\n        await Timer(BIT_PERIOD_NS, units='ns')\n        if dut.TX.value != 1:\n            dut._log.error(f\"Frame {i}: STOP bit not high (TX = {dut.TX.value}).\")\n        else:\n            dut._log.info(f\"Frame {i}: STOP bit verified high.\")\n\n    dut._log.info(\"=== Enhanced TX-Only Test Complete ===\")\n\n\n\nasync def rx_only_test(dut):\n    \"\"\"\n    Enhanced RX-only test:\n      - For each random byte, construct a proper UART frame:\n          * Start bit (low) for BIT_PERIOD_NS.\n          * 8 data bits (LSB-first) for BIT_PERIOD_NS each.\n          * (No parity, as default parity is disabled.)\n          * 1 stop bit (high) for BIT_PERIOD_NS.\n      - After driving the frame on RX, wait for out_tvalid and log the received data.\n    \"\"\"\n    dut._log.info(\"=== Enhanced RX-Only Test Start ===\")\n    random_frames = [random.randint(0, 255) for _ in range(NUM_FRAMES_RX)]\n    for i, val in enumerate(random_frames):\n        dut._log.info(f\"RX test: Frame {i}, data = 0x{val:02X}\")\n\n    for i, val in enumerate(random_frames):\n        await send_uart_frame(dut, val)\n        # Allow time for DUT to process the frame\n        await Timer(BIT_PERIOD_NS, units='ns')\n        # Wait for out_tvalid and capture tdata\n        output_valid = False\n        for _ in range(2000):\n            await RisingEdge(dut.aclk)\n            if dut.out_tvalid.value:\n                out_data = int(dut.out_tdata.value)\n                out_tuser = int(dut.out_tuser.value)\n                dut._log.info(f\"RX test: Frame {i} => out_tvalid high, data = 0x{out_data:02X} (tuser={out_tuser})\")\n                # Pulse out_tready for one cycle to acknowledge\n                dut.out_tready.value = 1\n                await RisingEdge(dut.aclk)\n                dut.out_tready.value = 0\n                output_valid = True\n                break\n        if not output_valid:\n            dut._log.warning(f\"RX test: Frame {i} timed out waiting for out_tvalid.\")\n    dut._log.info(\"=== Enhanced RX-Only Test Complete ===\")\n\n\nasync def send_uart_frame(dut, data):\n    \"\"\"\n    Drive a complete UART frame on RX:\n      - Start bit: drive low for BIT_PERIOD_NS.\n      - Data bits (LSB-first): drive each bit for BIT_PERIOD_NS.\n      - Stop bit: drive high for BIT_PERIOD_NS.\n      (Assumes no parity, one stop bit.)\n    \"\"\"\n    dut._log.info(f\"Sending UART frame for data 0x{data:02X}: START bit\")\n    dut.RX.value = 0\n    await Timer(BIT_PERIOD_NS, units='ns')\n\n    # Data bits: LSB-first\n    for bit_idx in range(8):\n        bit_val = (data >> bit_idx) & 1\n        dut._log.info(f\"Sending UART frame: Data bit {bit_idx} = {bit_val}\")\n        dut.RX.value = bit_val\n        await Timer(BIT_PERIOD_NS, units='ns')\n\n    # Stop bit (high)\n    dut._log.info(\"Sending UART frame: STOP bit (high)\")\n    dut.RX.value = 1\n    await Timer(BIT_PERIOD_NS, units='ns')\n", "src/test_runner.py": "import cocotb\nimport os\nimport harness_library as hrs_lb  # Use hrs_lb instead of cocotb.runner.get_runner\nimport random\nimport pytest\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\", \"verilog\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef run_sim(PARITY_BIT: int = 0, BIT_RATE: int = 115200, STOP_BITS_NUM: int = 1):\n    \"\"\"Configure simulation parameters, build, and run the simulation using hrs_lb.runner.\"\"\"\n    # Set simulation parameters\n    parameters = {\n        \"PARITY_BIT\": PARITY_BIT,\n        \"BIT_RATE\": BIT_RATE,\n        \"STOP_BITS_NUM\": STOP_BITS_NUM\n    }\n\n    print(\"[DEBUG] Running simulation with parameters:\")\n    for k, v in parameters.items():\n        print(f\"  {k} = {v}\")\n\n    # Setup simulation-specific arguments.\n    args = []\n    if sim == \"xcelium\":\n        args = (\"-coverage all\", \"-covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n    # Call the hrs_lb runner; note that we now pass the simulation parameters using the keyword 'parameter'\n    hrs_lb.runner(\n        wave=wave,\n        toplevel=toplevel,\n        module=module,\n        src=verilog_sources,\n        sim=sim,\n        args=args,\n        parameter=parameters  # Changed from 'parameters=parameters' to 'parameter=parameters'\n    )\n\n    # Run coverage reporting\n    hrs_lb.coverage_report(\"assertion\")\n    hrs_lb.covt_report_check()\n\n\n# Define example sets of parameter values\n#parity_values   = [0, 1, 2]         # 0 = no parity, 1 = odd parity, 2 = even parity\n#bit_rate_values = [115200, 57600]\n#stop_bits_list  = [1, 2]\n\nparity_values   = [2]         # 0 = no parity, 1 = odd parity, 2 = even parity\nbit_rate_values = [115200]\nstop_bits_list  = [1]\n\n@pytest.mark.parametrize(\"parity\", parity_values)\n@pytest.mark.parametrize(\"baud\", bit_rate_values)\n@pytest.mark.parametrize(\"stops\", stop_bits_list)\ndef test_axis_to_uart(parity, baud, stops):\n    \"\"\"\n    Pytest test that calls `run_sim()` for different combinations of\n    (PARITY_BIT, BIT_RATE, STOP_BITS_NUM).\n    \"\"\"\n    run_sim(PARITY_BIT=parity, BIT_RATE=baud, STOP_BITS_NUM=stops)\n"}}
{"id": "cvdp_agentic_barrel_shifter_0009", "categories": ["cid014", "easy"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a `barrel_shifter ` module available in the `rtl` directory. Kindly modify the module by adding an `SVA` immediate assertion. The assertion should specifically cover signal validation. This assertion should display error messages when the following condition is violated during simulation.\n\n**Out signal Priority Validation**: \nEnsure that the `data_out ` signals are correctly calculated shift of `data_in` in `left_right` direction for `shift_bits` number of bits and `shift_mode` define the logical or arithmatic. If the result is incorrect, an error message should be displayed.\n\nFollowing should be the interface of the RTL design of Barrel Shift module named `barrel_shifter `.\n## Interface:\n### **Input**:\n`data_in(8-bit,[7:0])`: 8-bit for input data which need be shifted `barrel_shifter` adder.\n`shift_bits(3-bit,[2:0])`: 3-bit for amout of shift `barrel_shifter` adder.\n`shift_mode(1-bit)`: 0 for logical or 1 for arithmetic mode selection bit `barrel_shifter` adder.\n`left_right(1-bit)`: 0 for Right or 1 for Left shift `barrel_shifter` adder.\n\n### **Output**:\n`data_out(8-bit,[7:0])`: 8-bit ouput shift data generated by the `barrel_shifter`.\n\n", "context": {"rtl/barrel_shifter.sv": "module barrel_shifter (\n    input  [7:0] data_in,\n    input  [2:0] shift_bits,\n    input        shift_mode,\n    input        left_right,\n    output reg [7:0] data_out\n);\n\nalways @(*) begin\n    if (shift_mode) begin\n            if (left_right) \n            data_out = data_in << shift_bits; \n        else\n            data_out = $signed(data_in) >>> shift_bits; \n    end else begin\n        if (left_right)\n            data_out = data_in << shift_bits;\n        else\n            data_out = data_in >> shift_bits;\n    end\nend\n\nendmodule", "verif/barrel_shifter_tb.sv": "`timescale 1ns / 1ps\n\nmodule barrel_shifter_tb;\n\n    // Testbench Signals\n    reg [7:0] data_in;           // Input data\n    reg [2:0] shift_bits;        // Number of bits to shift\n    reg left_right;              // Direction of shift: 1 for left, 0 for right\n    wire [7:0] data_out;         // Output data\n\n    // Instantiate the DUT (Device Under Test)\n    barrel_shifter uut (\n        .data_in(data_in),\n        .shift_bits(shift_bits),\n        .left_right(left_right),\n        .data_out(data_out)\n    );\n\n    // Task to calculate expected output for comparison\n    function [7:0] expected_output(input [7:0] data_in, input [2:0] shift_bits, input left_right);\n        begin\n            if (left_right)  // Left shift\n                expected_output = (data_in << shift_bits) & 8'hFF; // Mask to 8 bits\n            else  // Right shift\n                expected_output = (data_in >> shift_bits) & 8'hFF; // Mask to 8 bits\n        end\n    endfunction\n\n    // Test procedure\n    initial begin\n        integer i;  // Loop variable\n        reg [7:0] expected; // Holds the expected output\n\n        // Display header\n        $display(\"Starting Testbench for barrel_shifter_8bit...\");\n        $display(\"--------------------------------------------------\");\n        $display(\"|  Data_in  |  Shift | Left/Right |  Output  | Expected |\");\n        $display(\"--------------------------------------------------\");\n\n        // Apply test cases\n        for (i = 0; i < 100; i = i + 1) begin\n            // Generate random inputs\n            data_in = $random % 256;  // 8-bit random value\n            shift_bits = $random % 8; // 3-bit random value\n            left_right = $random % 2; // Random left/right direction\n\n            // Calculate expected output\n            expected = expected_output(data_in, shift_bits, left_right);\n\n            // Wait for a small delay to simulate propagation\n            #5;\n\n            // Display the results\n            $display(\"| %b |   %0d   |     %0d     | %b | %b |\",\n                data_in, shift_bits, left_right, data_out, expected);\n\n            // Check if the output matches the expected value\n            if (data_out !== expected) begin\n                $display(\"Test failed for data_in=%b, shift_bits=%0d, left_right=%0d. Expected=%b, Got=%b\",\n                    data_in, shift_bits, left_right, expected, data_out);\n                $fatal; // Stop the simulation on failure\n            end\n        end\n\n        // Test passed\n        $display(\"All tests passed!\");\n        $finish;\n    end\nendmodule"}, "patch": {"rtl/barrel_shifter.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/barrel_shifter.sv\nTOPLEVEL        = barrel_shifter\nMODULE          = test_barrel_shifter\nPYTHONPATH      = /src\nHASH            = f0cebdb9a9bf7d13ea261a2384fdaa9d77a3d156", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameter:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_barrel_shifter.py": "import cocotb\nfrom cocotb.triggers import Timer\nimport random\n\ndef verify(data_in, shift_bits, mode, left_right, data_width=8):\n    \"\"\"Helper function to calculate expected output.\"\"\"\n    if mode == 0b00:  # Logical Shift\n        if left_right == 1:\n            expected = (data_in << shift_bits) & ((1 << data_width) - 1)\n        else:\n            expected = (data_in >> shift_bits)\n    elif mode == 0b01:  # Arithmetic Shift\n        if left_right == 1:\n            expected = (data_in << shift_bits) & ((1 << data_width) - 1)\n        else:\n            # Sign-extend the MSB for arithmetic shift\n            sign_bit = data_in >> (data_width - 1) & 1\n            expected = (data_in >> shift_bits) | (\n                ((1 << shift_bits) - 1) << (data_width - shift_bits) if sign_bit else 0\n            )\n\n    return expected\n\n\n# ----------------------------------------\n# - Tests\n# ----------------------------------------\n\n@cocotb.test()\nasync def logic_shift(dut):\n    for i in range(10):\n        data_in = int((1.0 - random.random()) * 2 ** 8)\n        shift_bits = random.randint(0, 7)\n        mode = 0\n        left_right = random.randint(0, 1)\n\n        dut.data_in.value = data_in\n        dut.shift_bits.value = shift_bits\n        dut.left_right.value = left_right\n        dut.shift_mode.value = mode\n\n        await Timer(10, units=\"ns\")\n\n        expected = verify(data_in, shift_bits, mode, left_right)\n\n        if dut.data_out.value == expected:\n            print(\"Logic shift process is successful\")\n        assert dut.data_out.value == expected, f\"Computed and DUT outputs of barrel shifter are not correct {data_in}, {shift_bits}, {mode}, {left_right}, {expected}, {dut.data_out.value}\"\n\n@cocotb.test()\nasync def arithmatic_shift(dut):\n    data_in = 0b01010111\n    dut.data_in.value = data_in\n    for i in range(10):\n        shift_bits = random.randint(0, 7)\n        mode = 1\n        left_right = random.randint(0, 1)\n\n        dut.shift_bits.value = shift_bits\n        dut.left_right.value = left_right\n        dut.shift_mode.value = mode\n\n        await Timer(10, units=\"ns\")\n\n        expected = verify(data_in, shift_bits, mode, left_right)\n\n        if dut.data_out.value == expected:\n            print(\"Arithmatic shift process is successful\")\n        assert dut.data_out.value == expected, f\"Computed and DUT outputs of barrel shifter are not correct {bin(data_in)}, {shift_bits}, {mode}, {left_right}, {expected}, {dut.data_out.value}\"\n        await Timer(11, units=\"ns\")", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        \n        hrs_lb.runner(wave = wave, toplevel = toplevel, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\nif __name__ == \"__main__\":\n    test_runner()"}}
{"id": "cvdp_agentic_bcd_adder_0011", "categories": ["cid014", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"problematic_line_number s/problematic_statement/non_problematic_statement/\" Buggy_RTL_code.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have three RTL files in the `rtl` directory named `bcd_top.sv`, `multi_digit_bcd_add_sub.sv`, and `bcd_adder.sv`. Please modify these modules by adding appropriate and comprehensive SystemVerilog Assertions (SVA) to verify their internal functionality, including clear, descriptive $error messages for debugging. Additionally, provide an implementation for `check_done` in each module. This signal should be used to delay assertion evaluation until the outputs have fully stabilized.\n\n## Common `check_done` description:\n- The `check_done` signal is a control flag used to ensure that assertions are only evaluated after the outputs and internal signals have stabilized following a change. This prevents false error detections during transient states. Implement `check_done` such that it is set to a valid state (e.g., 1'b1) after the relevant outputs have settled, and then use it to conditionally enable all assertions within the module.\n\n## Module : bcd_top.sv\n### Mutual Exclusivity of Comparison Outputs:\n- Assert that exactly one of the outputs (`A_less_B, A_equal_B, A_greater_B`) is asserted at any time.\n\n### Correct Comparison Functionality:\n- When A == B, assert that only A_equal_B is asserted (with `A_less_B and A_greater_B` deasserted).\n- When A < B, assert that only A_less_B is asserted.\n- When A > B, assert that only A_greater_B is asserted.\n\n## Module : multi_digit_bcd_add_sub.sv\n### BCD Digit Validity:\n- For each digit of the input numbers `A` and `B`, and for the computed result, assert that the value does not exceed 9.\n\n## Module : bcd_adder.sv\n### Correction Logic Check:\n- If the binary sum exceeds 9, assert that the carry-out (cout) is asserted.\n- Assert that the final BCD sum is a valid BCD digit (i.e., it is less than or equal to 9).\n\n", "context": {"rtl/bcd_adder.sv": "//module of bcd_adder\nmodule bcd_adder(                \n                 input  [3:0] a,             // 4-bit BCD input\n                 input  [3:0] b,             // 4-bit BCD input\n                 input        cin,           // Carry-in\n                 output [3:0] sum,           // The corrected 4-bit BCD result of the addition\n                 output       cout           // Carry-out to indicate overflow beyond BCD range (i.e., when the result exceeds 9)\n                );\n    \nwire [3:0] binary_sum;         \nwire binary_cout;              \nwire z1, z2;                   \nwire carry;                    \n   \nfour_bit_adder adder1(         \n                      .a(a),            \n                      .b(b),            \n                      .cin(cin),       \n                      .sum(binary_sum), \n                      .cout(binary_cout) \n                     );\n       \nassign z1 = (binary_sum[3] & binary_sum[2]); \nassign z2 = (binary_sum[3] & binary_sum[1]); \nassign cout = (z1 | z2 | binary_cout);        \n\nfour_bit_adder adder2(         \n                      .a(binary_sum),     \n                      .b({1'b0, cout, cout, 1'b0}), \n                      .cin(1'b0),         \n                      .sum(sum),          \n                      .cout(carry)        \n                     );\n\nendmodule     \n", "rtl/bcd_top.sv": "module bcd_top #(parameter N = 4)(\n    input  [4*N-1:0] A,\n    input  [4*N-1:0] B,\n    output           A_less_B,\n    output           A_equal_B,\n    output           A_greater_B\n);\n    // We'll reuse the multi_digit_bcd_add_sub in subtract mode (add_sub=0)\n    // to compute A - B.\n    wire [4*N-1:0] diff;\n    wire           borrow;\n\n    // Subtraction: add_sub = 0\n    multi_digit_bcd_add_sub #(N) subtract_inst (\n        .A           (A),\n        .B           (B),\n        .add_sub     (1'b0),  // 0 => subtract\n        .result      (diff),\n        .carry_borrow(borrow) // In subtract mode, this acts as \"no-borrow\" if ==1\n    );\n\n    // Check if difference is zero\n    // (i.e., if all bits of diff are zero, then A == B)\n    wire is_zero = (diff == {4*N{1'b0}});\n\n    // For BCD subtraction with 9's complement + 1:\n    //   borrow=1 => no borrow actually occurred => A >= B\n    //   borrow=0 => we did \"borrow\" => A < B\n    assign A_less_B    = ~borrow; \n    assign A_equal_B   =  borrow & is_zero;\n    assign A_greater_B =  borrow & ~is_zero;\n\nendmodule", "rtl/multi_digit_bcd_add_sub.sv": "module multi_digit_bcd_add_sub #(parameter N = 4)(\n    input  [4*N-1:0] A,           // N-digit BCD number\n    input  [4*N-1:0] B,           // N-digit BCD number\n    input            add_sub,     // 1 for addition, 0 for subtraction\n    output [4*N-1:0] result,      // Result (sum or difference)\n    output           carry_borrow // Carry-out for addition or Borrow-out for subtraction\n);\n    wire [N:0] carry;          // Carry or borrow chain between digits\n    wire [4*N-1:0] B_comp;     // 9's complement of B for subtraction\n    wire [4*N-1:0] operand_B;  // Actual operand B fed to BCD adders\n\n    // For addition, the initial carry is 0\n    // For subtraction, the initial carry is 1 (because of 9's-complement +1 trick)\n    assign carry[0] = add_sub ? 1'b0 : 1'b1; \n\n    // Generate 9's complement of B for subtraction\n    genvar i;\n    generate\n        for (i = 0; i < N; i = i + 1) begin : COMP_LOOP\n            assign B_comp[4*i+3:4*i] = 4'b1001 - B[4*i+3:4*i];\n        end\n    endgenerate\n\n    assign operand_B = add_sub ? B : B_comp;\n\n    // Instantiate an N-digit chain of BCD adders\n    generate\n        for (i = 0; i < N; i = i + 1) begin : BCD_ADDERS\n            bcd_adder bcd_adder_inst(\n                .a   (A[4*i+3:4*i]),\n                .b   (operand_B[4*i+3:4*i]),\n                .cin (carry[i]),\n                .sum (result[4*i+3:4*i]),\n                .cout(carry[i+1])\n            );\n        end\n    endgenerate\n\n    // The final carry_borrow bit\n    assign carry_borrow = carry[N];\n\nendmodule", "rtl/full_adder.sv": "//module of full_adder\nmodule full_adder(       \n                  input a,     // First Addend input\n                  input b,     // Second Addend input\n                  input cin,   // Carry input\n                  output sum,  // Sum output\n                  output cout  // Carry output\n                );\n                  \n  assign sum = a ^ b ^ cin;                      \n  assign cout = (a & b) | (b & cin) | (a & cin); \n  \nendmodule", "rtl/four_bit_adder.sv": "//module of four_bit_adder\nmodule four_bit_adder(        \n                      input [3:0] a,           // 4-bit input a\n                      input [3:0] b,           // 4-bit input b\n                      input cin,               // Carry input\n                      output [3:0] sum,        // 4-bit sum output\n                      output cout              // Carry output\n                     );\n\n  wire [2:0] carry;         \n\n  genvar i;                 \n\n  generate\n    for (i = 0; i < 4; i = i + 1) begin: adder \n\n      if (i == 0) begin\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(cin),          \n                       .sum(sum[i]),       \n                       .cout(carry[i])     \n                      );\n      end \n      else if (i < 3) begin\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(carry[i-1]),   \n                       .sum(sum[i]),       \n                       .cout(carry[i])     \n                      );\n      end\n      else begin\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(carry[i-1]),   \n                       .sum(sum[i]),       \n                       .cout(cout)         \n                     );\n      end\n    end\n  endgenerate\n\nendmodule   "}, "patch": {"rtl/bcd_adder.sv": "", "rtl/bcd_top.sv": "", "rtl/multi_digit_bcd_add_sub.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/full_adder.sv /code/rtl/four_bit_adder.sv /code/rtl/bcd_adder.sv /code/rtl/multi_digit_bcd_add_sub.sv /code/rtl/bcd_top.sv\nTOPLEVEL        = bcd_top\nMODULE          = test_bcd_adder\nPYTHONPATH      = /src\nHASH            = 27b57201f9fdc2545133e2a92abb0719b1274368\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_bcd_adder.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ReadOnly , Timer\n\nimport harness_library as hrs_lb\nimport random\n\n# Utility: Convert integer to packed BCD (4 bits per digit, little-endian)\ndef int_to_bcd(value, digits):\n    bcd = 0\n    for i in range(digits):\n        bcd |= ((value % 10) & 0xF) << (i * 4)\n        value //= 10\n    return bcd\n\n# Utility: Convert BCD to string for readable log output\ndef bcd_to_str(bcd, digits):\n    s = \"\"\n    for i in reversed(range(digits)):\n        digit = (bcd >> (4 * i)) & 0xF\n        s += chr(digit + ord('0'))\n    return s\n\n@cocotb.test()\nasync def test_bcd_top_compare(dut):\n    \"\"\"\n    Test the bcd_top comparator module with multiple cases.\n    \"\"\"\n\n    N   = int(dut.N.value)\n    max_value = 10 ** N\n\n    total_tests = 0\n    passed_tests = 0\n\n    async def run_test_case(test_num, A_int, B_int, description=\"\"):\n        nonlocal total_tests, passed_tests\n\n        await Timer(5, units='ns') \n        bcd_A = int_to_bcd(A_int, N)\n        bcd_B = int_to_bcd(B_int, N)\n\n        dut.A.value = bcd_A\n        dut.B.value = bcd_B\n\n        await Timer(5, units='ns')  # Allow time for signals to propagate\n\n        # Read DUT outputs\n        A_lt = int(dut.A_less_B.value)\n        A_eq = int(dut.A_equal_B.value)\n        A_gt = int(dut.A_greater_B.value)\n\n        # Expected results\n        exp_lt = int(A_int < B_int)\n        exp_eq = int(A_int == B_int)\n        exp_gt = int(A_int > B_int)\n\n        A_str = bcd_to_str(bcd_A, N)\n        B_str = bcd_to_str(bcd_B, N)\n        \n        dut._log.info(f\"Test {test_num}: {description}\")\n        dut._log.info(f\"Inputs:     A = {A_int} , B = {B_int}\")\n        dut._log.info(f\"Expected:   LT = {exp_lt}, EQ = {exp_eq}, GT = {exp_gt}\")\n        dut._log.info(f\"From DUT:   LT = {A_lt}, EQ = {A_eq}, GT = {A_gt}\")\n        \n        total_tests += 1\n        if A_lt == exp_lt and A_eq == exp_eq and A_gt == exp_gt:\n            passed_tests += 1\n            dut._log.info(f\"[PASS] Test {test_num}: {description}\")\n        else:\n            dut._log.error(\n                f\"[FAIL] Test {test_num}: {description} | A={A_str}, B={B_str} | \"\n                f\"Expected: LT/EQ/GT = {exp_lt}/{exp_eq}/{exp_gt} | \"\n                f\"Got: {A_lt}/{A_eq}/{A_gt}\"\n            )\n\n    # Fixed test cases\n    await run_test_case(1, 0, 0, \"A = 0, B = 0\")\n    await run_test_case(2, 0, 1, \"A < B\")\n    await run_test_case(3, 1, 0, \"A > B\")\n    await run_test_case(4, 1234, 1234, \"A == B (multi-digit)\")\n    await run_test_case(5, 1000, 999, \"A > B (borrow boundary)\")\n    await run_test_case(6, 9999, 0, \"A > B (max vs min)\")\n    await run_test_case(7, 0, 9999, \"A < B (min vs max)\")\n\n    # Random test cases\n    for i in range(8, 38):\n        A_rand = random.randint(0, max_value - 1)\n        B_rand = random.randint(0, max_value - 1)\n        await run_test_case(i, A_rand, B_rand, \"Random compare\")\n\n    # Summary\n    dut._log.info(\"===============================================\")\n    dut._log.info(f\"TOTAL TESTS  : {total_tests}\")\n    dut._log.info(f\"TESTS PASSED : {passed_tests}\")\n    dut._log.info(f\"TESTS FAILED : {total_tests - passed_tests}\")\n    dut._log.info(\"===============================================\")", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}
{"id": "cvdp_agentic_byte_enable_ram_0008", "categories": ["cid014", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"problematic_line_number s/problematic_statement/non_problematic_statement/\" Buggy_RTL_code.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a `custom_byte_enable_ram.sv` module available in the rtl directory. Please modify the module by adding SystemVerilog Assertions (SVA) to check its internal functionality comprehensively. The assertions should verify the following conditions:\n\n**1. No Write Stability on Port A (no_write_stability_A)**:\nVerify that if port A was not enabled in the previous cycle (i.e. `en_a` deasserted), the output data (`data_out_a`) remains unchanged from the previous value stored in the RAM at the address provided by `addr_a`.\n\n**2. No Write Stability on Port B (no_write_stability_B)**:\nCheck that if port B was not enabled in the previous cycle (i.e. `en_b` deasserted), then `data_out_b` remains equal to the previous content of the RAM at `addr_b`.\n\n**3. Same Address Read Consistency (same_addr_read)**:\nEnsure that if both ports were accessing the same memory location in the previous cycle with neither write enabled, the read outputs for both ports are identical\u2014that is, `data_out_a` equals `data_out_b`.\n\n**4. Output Consistency on Port A (output_consistency_A)**:\nAfter a fixed delay (30 cycles), confirm that `data_out_a` exactly reflects the value stored in the RAM at the registered address (`addr_a_reg`).\n\n**5. Output Consistency on Port B (output_consistency_B)**:\nAfter a 30-cycle delay, verify that `data_out_b` equals the RAM contents at `addr_b_reg`.\n\n**6. Simultaneous Write Priority for Port A \u2013 Lower Byte (simul_write_A_byte0_update)**:\nWhen both ports are enabled and accessing the same address, check that if port A\u2019s byte-enable for the lower byte (bit 0) is asserted, then after 15 cycles the RAM\u2019s lower byte (bits [7:0]) is updated to match `data_in_a`\u2019s lower byte. This confirms the priority of port A in simultaneous write scenarios.\n\n**7. Simultaneous Write Priority for Port A \u2013 Second Byte (simul_write_A_byte1_update)**:\nIf port A\u2019s byte-enable for byte 1 (bits [15:8]) is asserted, then after 15 cycles the check corresponding RAM byte should equal `data_in_a`\u2019s bits [15:8].\n\n**8. Single-Port Write Behavior for Port A \u2013 Lower Byte (single_write_A_byte0_update)**:\nWhen only port A is performing a write (i.e. its address differs from port B\u2019s or port B is not enabled), verify that if the byte-enable for the lower byte is active, after 15 cycles the RAM\u2019s lower byte is updated according to `data_in_a`.\n\n**9. Single-Port Write Behavior for Port A \u2013 Second Byte (single_write_A_byte1_update)**:\nSimilarly, in a single-port write condition, if port A\u2019s byte-enable for the second byte (bits [15:8]) is asserted, then after 15 cycles the corresponding RAM byte should match `data_in_a`\u2019s bits [15:8].\n\nIf any of these conditions are violated during simulation, an appropriate error message should be displayed.\n", "context": {"docs/specs.md": "# Custom Byte-Enable RAM Module\n\nThis module implements a dual-port RAM with byte-enable support and pipelining, designed for efficient memory operations in systems such as processors or embedded controllers. It features separate interfaces for two independent ports (Port A and Port B), each capable of partial writes at byte granularity. The design includes collision handling logic for simultaneous writes to the same memory location and registers inputs in a two-stage pipeline to ensure correct data propagation and controlled read latency.\n\n---\n\n## Parameterization\n\n- **XLEN**:\n  - Data width of the memory, typically set to 32 bits.\n\n- **LINES**:\n  - Number of 32-bit words in memory (default: 8192).\n  - Address width derived as $clog2(LINES).\n\nThese parameters allow customization of the memory size and data width at compile time.\n\n---\n\n## Interfaces\n\n### 1. Clock\n- **clk**: Single posedge clock input synchronizing all operations.\n\n### 2. Port A Interface\n- **addr_a [ADDR_WIDTH-1:0]**: Address input for Port A.\n- **en_a**: Enable signal for Port A; triggers write operations.\n- **be_a [XLEN/8-1:0]**: Byte-enable vector controlling byte-level writes.\n- **data_in_a [XLEN-1:0]**: 32-bit data input for Port A.\n- **data_out_a [XLEN-1:0]**: Pipelined 32-bit data output from memory.\n\n### 3. Port B Interface\n- **addr_b [ADDR_WIDTH-1:0]**: Address input for Port B.\n- **en_b**: Enable signal for Port B; triggers write operations.\n- **be_b [XLEN/8-1:0]**: Byte-enable vector controlling byte-level writes.\n- **data_in_b [XLEN-1:0]**: 32-bit data input for Port B.\n- **data_out_b [XLEN-1:0]**: Pipelined 32-bit data output from memory.\n\n---\n\n## Internal Architecture\n\n### 1. Memory Organization\nThe memory array is defined as:\nlogic [XLEN-1:0] ram [LINES-1:0];\nSimplifies synthesis and supports word-level addressing.\n\n### 2. Input Pipelining\n**Stage-1 Registers**:\n- Registers (`addr_a_reg`, `en_a_reg`, `be_a_reg`, `data_in_a_reg`, etc.) capture port inputs on each clock's rising edge, synchronizing subsequent operations.\n\n### 3. Write Collision Handling (Stage-2)\n**Collision Detection**:\n\nif (en_a_reg && en_b_reg && (addr_a_reg == addr_b_reg))\nDetermines simultaneous writes to the same address.\n\n**Byte-Level Arbitration**:\n- If collision occurs, priority is:\n  - **Port A's byte-enable active**: byte written from Port A.\n  - **Port A's byte-enable inactive & Port B's active**: byte written from Port B.\n- Ensures selective byte-level updates with Port A prioritized.\n\n**Independent Writes**:\n- Without collision, each port independently updates enabled bytes.\n\n### 4. Pipelined Read Outputs\n- Data outputs (`data_out_a`, `data_out_b`) reflect data from pipelined addresses, introducing one-cycle latency.\n\n---\n\n## Summary of Functionality\n\n- **Dual-Port Operation**: Supports concurrent operations on two independent ports.\n- **Byte-Enable Write**: Allows partial byte-level word updates via byte-enable mask.\n- **Collision Handling**: Resolves simultaneous write collisions at byte granularity, prioritizing Port A.\n- **Pipelined Operation**: Utilizes a two-stage pipeline (input capture and memory update/read), introducing one-cycle latency.\n- **Initialization**: Memory initialized to zero at startup.\n\nThis `custom_byte_enable_ram` module is flexible and robust, suitable for a variety of high-performance digital system applications requiring dual-port memory access with precise byte-level control.", "rtl/custom_byte_enable_ram.sv": "module custom_byte_enable_ram \n  #(\n    parameter XLEN  = 32,\n    parameter LINES = 8192\n  )\n  (\n    input  logic                     clk,\n    input  logic[$clog2(LINES)-1:0]  addr_a,\n    input  logic                     en_a,\n    input  logic[XLEN/8-1:0]         be_a,\n    input  logic[XLEN-1:0]           data_in_a,\n    output logic[XLEN-1:0]           data_out_a,\n    input  logic[$clog2(LINES)-1:0]  addr_b,\n    input  logic                     en_b,\n    input  logic[XLEN/8-1:0]         be_b,\n    input  logic[XLEN-1:0]           data_in_b,\n    output logic[XLEN-1:0]           data_out_b\n  );\n\n  localparam ADDR_WIDTH = $clog2(LINES);\n\n  logic [XLEN-1:0] ram [LINES-1:0];\n\n  logic [ADDR_WIDTH-1:0] addr_a_reg;\n  logic                  en_a_reg;\n  logic [XLEN/8-1:0]     be_a_reg;\n  logic [XLEN-1:0]       data_in_a_reg;\n\n  logic [ADDR_WIDTH-1:0] addr_b_reg;\n  logic                  en_b_reg;\n  logic [XLEN/8-1:0]     be_b_reg;\n  logic [XLEN-1:0]       data_in_b_reg;\n  \n  initial begin\n    for (int i = 0; i < LINES; i++) begin\n      ram[i] <= '0;\n    end\n  end\n\n  always_ff @(posedge clk) begin\n    addr_a_reg    <= addr_a;\n    en_a_reg      <= en_a;\n    be_a_reg      <= be_a;\n    data_in_a_reg <= data_in_a;\n\n    addr_b_reg    <= addr_b;\n    en_b_reg      <= en_b;\n    be_b_reg      <= be_b;\n    data_in_b_reg <= data_in_b;\n  end\n\n  always_ff @(posedge clk) begin\n    if (en_a_reg && en_b_reg && (addr_a_reg == addr_b_reg)) begin\n      if (be_a_reg[0])\n        ram[addr_a_reg][7:0] <= data_in_a_reg[7:0];\n      else if (be_b_reg[0])\n        ram[addr_a_reg][7:0] <= data_in_b_reg[7:0];\n\n      if (be_a_reg[1])\n        ram[addr_a_reg][15:8] <= data_in_a_reg[15:8];\n      else if (be_b_reg[1])\n        ram[addr_a_reg][15:8] <= data_in_b_reg[15:8];\n\n      if (be_a_reg[2])\n        ram[addr_a_reg][23:16] <= data_in_a_reg[23:16];\n      else if (be_b_reg[2])\n        ram[addr_a_reg][23:16] <= data_in_b_reg[23:16];\n\n      if (be_a_reg[3])\n        ram[addr_a_reg][31:24] <= data_in_a_reg[31:24];\n      else if (be_b_reg[3])\n        ram[addr_a_reg][31:24] <= data_in_b_reg[31:24];\n    end else begin\n      if (en_a_reg) begin\n        if (be_a_reg[0])\n          ram[addr_a_reg][7:0] <= data_in_a_reg[7:0];\n        if (be_a_reg[1])\n          ram[addr_a_reg][15:8] <= data_in_a_reg[15:8];\n        if (be_a_reg[2])\n          ram[addr_a_reg][23:16] <= data_in_a_reg[23:16];\n        if (be_a_reg[3])\n          ram[addr_a_reg][31:24] <= data_in_a_reg[31:24];\n      end\n\n      if (en_b_reg) begin\n        if (be_b_reg[0])\n          ram[addr_b_reg][7:0] <= data_in_b_reg[7:0];\n        if (be_b_reg[1])\n          ram[addr_b_reg][15:8] <= data_in_b_reg[15:8];\n        if (be_b_reg[2])\n          ram[addr_b_reg][23:16] <= data_in_b_reg[23:16];\n        if (be_b_reg[3])\n          ram[addr_b_reg][31:24] <= data_in_b_reg[31:24];\n      end\n    end\n\n    data_out_a <= ram[addr_a_reg];\n    data_out_b <= ram[addr_b_reg];\n  end\n\nendmodule"}, "patch": {"rtl/custom_byte_enable_ram.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/custom_byte_enable_ram.sv\nTOPLEVEL        = custom_byte_enable_ram\nMODULE          = test_custom_byte_enable_ram\nPYTHONPATH      = /src\nHASH            = 8-byte_enable_ram_rtl_assertion_generation\n", "src/test_custom_byte_enable_ram.py": "import cocotb\nfrom cocotb.triggers import Timer\n\n# Define our own helper functions for to_unsigned and to_signed.\ndef to_unsigned(val, nbits):\n    \"\"\"Return the unsigned representation of val as an int with nbits bits.\"\"\"\n    mask = (1 << nbits) - 1\n    return val & mask\n\ndef to_signed(val, nbits):\n    \"\"\"Return the signed representation of val as an int with nbits bits.\"\"\"\n    mask = (1 << nbits) - 1\n    val = val & mask\n    if val & (1 << (nbits - 1)):\n        return val - (1 << nbits)\n    else:\n        return val\n\n# Helper coroutine to simulate clock cycles by toggling the clock sequentially.\nasync def cycle(dut, num_cycles=1):\n    for _ in range(num_cycles):\n        dut.clk.value = to_unsigned(0, 1)\n        await Timer(5, units=\"ns\")\n        dut.clk.value = to_unsigned(1, 1)\n        await Timer(5, units=\"ns\")\n\n@cocotb.test()\nasync def test_custom_byte_enable_ram(dut):\n    # Constants: XLEN is 32, LINES is 8192, so ADDR_WIDTH is 13.\n    ADDR_WIDTH = 13  # since 2^13 = 8192\n\n    # Initialize signals using .value assignments with our to_unsigned helper.\n    dut.addr_a.value = to_unsigned(0, ADDR_WIDTH)\n    dut.addr_b.value = to_unsigned(0, ADDR_WIDTH)\n    dut.en_a.value   = to_unsigned(0, 1)\n    dut.en_b.value   = to_unsigned(0, 1)\n    dut.be_a.value   = to_unsigned(0, 4)\n    dut.be_b.value   = to_unsigned(0, 4)\n    dut.data_in_a.value = to_unsigned(0, 32)\n    dut.data_in_b.value = to_unsigned(0, 32)\n\n    # Wait for a few clock cycles for initialization.\n    await cycle(dut, 2)\n\n    # --------------------------------------------------\n    # Test 1: Write from Port A\n    # Write 0xDEADBEEF to address 0 using full byte-enable.\n    dut.addr_a.value   = to_unsigned(0, ADDR_WIDTH)\n    dut.en_a.value     = to_unsigned(1, 1)\n    dut.be_a.value     = to_unsigned(0b1111, 4)\n    dut.data_in_a.value = to_unsigned(0xDEADBEEF, 32)\n    await cycle(dut, 1)  # Wait one cycle for the pipeline stage update.\n    dut.en_a.value     = to_unsigned(0, 1)\n    await cycle(dut, 3)  # Wait additional cycles for memory update and pipelined read.\n    expected_val = to_unsigned(0xDEADBEEF, 32)\n    actual_val = int(dut.data_out_a.value)\n    dut._log.info(\"Test 1: Port A read at addr 0 = 0x%X (Expected: 0x%X)\" %\n                  (actual_val, expected_val))\n    assert actual_val == expected_val, \"Test 1 failed: expected 0x%X, got 0x%X\" % (expected_val, actual_val)\n\n    # --------------------------------------------------\n    # Test 2: Write from Port B with Partial Byte Enable\n    # Write 0xCAFEBABE to address 1, enabling only the upper 2 bytes.\n    dut.addr_b.value   = to_unsigned(1, ADDR_WIDTH)\n    dut.en_b.value     = to_unsigned(1, 1)\n    dut.be_b.value     = to_unsigned(0b1100, 4)  # Only bytes 2 and 3 will be written.\n    dut.data_in_b.value = to_unsigned(0xCAFEBABE, 32)\n    await cycle(dut, 1)\n    dut.en_b.value     = to_unsigned(0, 1)\n    await cycle(dut, 3)\n    # Expected result: upper 16 bits (0xCAFE) updated; lower 16 bits remain 0.\n    expected_val = to_unsigned(0xCAFE0000, 32)\n    actual_val = int(dut.data_out_b.value)\n    dut._log.info(\"Test 2: Port B read at addr 1 = 0x%X (Expected: 0x%X)\" %\n                  (actual_val, expected_val))\n    assert actual_val == expected_val, \"Test 2 failed: expected 0x%X, got 0x%X\" % (expected_val, actual_val)\n\n    # --------------------------------------------------\n    # Test 3: Simultaneous Write (Collision Handling)\n    # Both ports write to address 2:\n    #   - Port A writes to lower half (byte-enable 0011)\n    #   - Port B writes to upper half (byte-enable 1100)\n    dut.addr_a.value   = to_unsigned(2, ADDR_WIDTH)\n    dut.addr_b.value   = to_unsigned(2, ADDR_WIDTH)\n    dut.en_a.value     = to_unsigned(1, 1)\n    dut.en_b.value     = to_unsigned(1, 1)\n    dut.be_a.value     = to_unsigned(0b0011, 4)  # Write lower two bytes.\n    dut.data_in_a.value = to_unsigned(0x00001234, 32)  # Lower half: 0x1234.\n    dut.be_b.value     = to_unsigned(0b1100, 4)  # Write upper two bytes.\n    dut.data_in_b.value = to_unsigned(0xABCD0000, 32)  # Upper half: 0xABCD.\n    await cycle(dut, 1)\n    dut.en_a.value = to_unsigned(0, 1)\n    dut.en_b.value = to_unsigned(0, 1)\n    await cycle(dut, 3)\n    expected_val = to_unsigned(0xABCD1234, 32)\n    actual_val_a = int(dut.data_out_a.value)\n    actual_val_b = int(dut.data_out_b.value)\n    dut._log.info(\"Test 3: Port A read at addr 2 = 0x%X (Expected: 0x%X)\" %\n                  (actual_val_a, expected_val))\n    dut._log.info(\"Test 3: Port B read at addr 2 = 0x%X (Expected: 0x%X)\" %\n                  (actual_val_b, expected_val))\n    assert actual_val_a == expected_val, \"Test 3 failed on Port A: expected 0x%X, got 0x%X\" % (expected_val, actual_val_a)\n    assert actual_val_b == expected_val, \"Test 3 failed on Port B: expected 0x%X, got 0x%X\" % (expected_val, actual_val_b)\n\n    # --------------------------------------------------\n    # Test 4: Sequential Partial Updates on the Same Address Using Port A\n    # Step 1: Write lower half at address 3.\n    dut.addr_a.value   = to_unsigned(3, ADDR_WIDTH)\n    dut.en_a.value     = to_unsigned(1, 1)\n    dut.be_a.value     = to_unsigned(0b0011, 4)  # Write lower two bytes.\n    dut.data_in_a.value = to_unsigned(0x00001234, 32)  # Lower half: 0x1234.\n    await cycle(dut, 1)\n    dut.en_a.value     = to_unsigned(0, 1)\n    await cycle(dut, 3)\n    # Step 2: Write upper half.\n    dut.addr_a.value   = to_unsigned(3, ADDR_WIDTH)\n    dut.en_a.value     = to_unsigned(1, 1)\n    dut.be_a.value     = to_unsigned(0b1100, 4)  # Write upper two bytes.\n    dut.data_in_a.value = to_unsigned(0xABCD0000, 32)  # Upper half: 0xABCD.\n    await cycle(dut, 1)\n    dut.en_a.value     = to_unsigned(0, 1)\n    await cycle(dut, 3)\n    expected_val = to_unsigned(0xABCD1234, 32)\n    actual_val = int(dut.data_out_a.value)\n    dut._log.info(\"Test 4: Port A read at addr 3 = 0x%X (Expected: 0x%X)\" %\n                  (actual_val, expected_val))\n    assert actual_val == expected_val, \"Test 4 failed: expected 0x%X, got 0x%X\" % (expected_val, actual_val)\n\n    # --------------------------------------------------\n    # Test 5: Independent Writes on Different Addresses Simultaneously\n    # Port A writes 0xAAAAAAAA to address 5.\n    # Port B writes 0x55555555 to address 6.\n    dut.addr_a.value   = to_unsigned(5, ADDR_WIDTH)\n    dut.en_a.value     = to_unsigned(1, 1)\n    dut.be_a.value     = to_unsigned(0b1111, 4)\n    dut.data_in_a.value = to_unsigned(0xAAAAAAAA, 32)\n    dut.addr_b.value   = to_unsigned(6, ADDR_WIDTH)\n    dut.en_b.value     = to_unsigned(1, 1)\n    dut.be_b.value     = to_unsigned(0b1111, 4)\n    dut.data_in_b.value = to_unsigned(0x55555555, 32)\n    await cycle(dut, 1)\n    dut.en_a.value     = to_unsigned(0, 1)\n    dut.en_b.value     = to_unsigned(0, 1)\n    await cycle(dut, 3)\n    expected_val = to_unsigned(0xAAAAAAAA, 32)\n    actual_val = int(dut.data_out_a.value)\n    dut._log.info(\"Test 5: Port A read at addr 5 = 0x%X (Expected: 0x%X)\" %\n                  (actual_val, expected_val))\n    assert actual_val == expected_val, \"Test 5 failed on Port A: expected 0x%X, got 0x%X\" % (expected_val, actual_val)\n\n    expected_val = to_unsigned(0x55555555, 32)\n    actual_val = int(dut.data_out_b.value)\n    dut._log.info(\"Test 5: Port B read at addr 6 = 0x%X (Expected: 0x%X)\" %\n                  (actual_val, expected_val))\n    assert actual_val == expected_val, \"Test 5 failed on Port B: expected 0x%X, got 0x%X\" % (expected_val, actual_val)\n\n    # End simulation after additional cycles.\n    await cycle(dut, 5)\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}
{"id": "cvdp_agentic_caesar_cipher_0005", "categories": ["cid014", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a `caesar_cipher` module available in the `rtl` directory, and its specification is in the `docs` directory. Kindly modify the module by adding SystemVerilog assertions. The assertions should ensure that the Caesar cipher module correctly encrypts and decrypts ASCII characters within expected ranges, handles shifts correctly, and provides valid outputs for both alphabetic and non-alphabetic cases.\n\n## **Assertion Details**  \n1. **Shift Key Range Check**:  \n   - Confirm that the `shift_val` does not exceed 5 bits (i.e., must be `<= 31`).  \n   - If any invalid shift exceeds this range, it should trigger an **error message**.\n\n2. **Alphabetic Character Handling**:  \n   - **Lowercase**: Ensure that when encrypting lowercase characters (`a` to `z`), the output remains within `a\u2013z`.  \n   - **Uppercase**: Ensure that when encrypting uppercase characters (`A` to `Z`), the output remains within `A\u2013Z`.  \n   - **Decryption**: Validate that encrypted alphabetic characters correctly wrap back into the same case range.\n\n3. **Non-Alphabetic Character Handling**:  \n   - In encryption mode, non-alphabetic ASCII characters should have their ASCII value incremented by the shift.  \n   - In decryption mode, these characters should have their ASCII value decremented by the shift.  \n   - If these operations push the character code outside of printable ASCII (`0x00\u20130x7F`), an **error message** should be triggered.\n\n4. **Zero Shift Check**:  \n   - If `shift_val` is zero, encryption or decryption should leave the input unchanged.  \n   - Assert that if `shift_val == 0`, `output_char` remains identical to `input_char`.\n\n## **Expected Behavior**  \n- All assertions must generate an **error message** if their conditions are violated.  \n- Any attempt to encrypt or decrypt characters outside the valid ASCII range (`0x00\u20130x7F`) should cause an assertion to fail with an **error**.\n- Alphabetic characters should remain in their respective alphabetic range after encryption or decryption.\n", "context": {"docs/specification.md": "# Caesar Cipher RTL Module Documentation\n\n## Overview\n\nImplement the `caesar_cipher` module to perform Caesar cipher encryption or decryption on a set of ASCII characters. This RTL design processes characters in parallel, where each character receives an individual shift value through the `key` input. The module supports both uppercase and lowercase letters using wraparound logic, and also handles non-alphabetic characters using arithmetic shifting.\n\nUse this design for hardware-based character transformation, simple encryption demonstrations, or logic design exercises involving modular arithmetic.\n\n---\n\n## Parameters\n\nDefine the following parameters to configure the module's behavior:\n\n- `PHRASE_WIDTH` (Default: 8): Total bit-width of the input phrase. Each character occupies 8 bits.\n- `PHRASE_LEN` (Derived): Number of characters in the phrase, automatically calculated as `PHRASE_WIDTH / 8`.\n\nFor example:\n- If `PHRASE_WIDTH = 8`, then `PHRASE_LEN = 1` \u2192 one character\n- If `PHRASE_WIDTH = 16`, then `PHRASE_LEN = 2` \u2192 two characters\n\n---\n\n## Port Descriptions\n\nAll signals are synchronous and operate combinationally under an `always @(*)` block.\n\n- `input_char`  (Input, Width = `PHRASE_WIDTH`):  \n  Use this to supply the input ASCII phrase. Each character is 8 bits. For example, with `PHRASE_WIDTH = 16`, the input may be `\"ab\"` as `8'h61_62`.\n\n- `key` (Input, Width = `PHRASE_LEN * 5`):  \n  Provide a 5-bit shift value for each 8-bit character in the input. For 2 characters, use 10 bits total: 5 bits per character.\n\n- `decrypt` (Input, Width = 1):  \n  Set to `1'b1` to perform decryption. Set to `1'b0` to perform encryption.\n\n- `output_char` (Output, Width = `PHRASE_WIDTH`):  \n  Get the transformed characters after Caesar cipher logic is applied.\n\n---\n\n## Internal Logic and Flow\n\n1. **Initialize Output**:  \n   Clear `output_char` to avoid latch inference.\n\n2. **Iterate Through Each Character**:  \n   Use a loop with index `idx` to process one character at a time.\n\n3. **Extract Current Character and Shift Value**:  \n   - Get an 8-bit character from `input_char[(idx*8)+:8]`.\n   - Get the corresponding 5-bit `shift_val` from `key[(idx*5)+:5]`.\n\n4. **Encrypt or Decrypt**:  \n   - If `decrypt = 0`: apply Caesar encryption logic.\n     - If character is between `'A'` and `'Z'`: shift within uppercase alphabet (`A` to `Z`) using modular arithmetic:  \n       `(char - 'A' + shift_val) % 26 + 'A'`\n     - If character is between `'a'` and `'z'`: shift within lowercase alphabet:  \n       `(char - 'a' + shift_val) % 26 + 'a'`\n     - For other characters, shift by adding the `shift_val` directly.\n   - If `decrypt = 1`: apply Caesar decryption logic.\n     - Reverse the Caesar cipher using:  \n       `(char - base - shift_val + 26) % 26 + base`\n     - For non-alphabetic characters, subtract the `shift_val` directly.\n\n5. **Reassemble Result**:  \n   Concatenate the processed 8-bit results into `output_char`.\n\n---\n\n## Example\n\nLet\u2019s encrypt and decrypt a 2-character phrase using the Caesar cipher.\n\n### Configuration\n\n- `PHRASE_WIDTH = 16` \u2192 Two characters (`PHRASE_LEN = 2`)\n- `input_char = 8'h61_62` \u2192 This represents `\"ab\"`\n- `key = 10'b00001_00010` \u2192 First shift = 1, second shift = 2\n- `decrypt = 0` \u2192 Encrypt\n\n### Encryption Output\n\n- `'a'` + 1 = `'b'`\n- `'b'` + 2 = `'d'`\n- Result: `output_char = 8'h62_64` \u2192 `\"bd\"`\n\n### Decryption\n\nUse the same `key`, set `decrypt = 1`, and input `\"bd\"`:\n- `'b'` - 1 = `'a'`\n- `'d'` - 2 = `'b'`\n- Result: `output_char = 8'h61_62` \u2192 `\"ab\"`\n\n---\n\n## Bit Width Calculation\n\n- For `PHRASE_WIDTH = N` bits:\n  - Each character = 8 bits \u2192 `PHRASE_LEN = N / 8`\n  - `key` width = `PHRASE_LEN * 5` bits\n  - `output_char` width = `PHRASE_WIDTH`\n\n---\n\n## Implementation Notes\n\n- Use signed types (`reg signed [7:0]`) to safely manipulate ASCII characters.\n- Use `$unsigned()` during decryption to prevent overflow/underflow issues.\n- Modular arithmetic ensures alphabetic characters wrap around correctly.\n\n---", "rtl/caesar_cipher.sv": "module caesar_cipher #(\n    parameter PHRASE_WIDTH = 8,\n    parameter PHRASE_LEN   = PHRASE_WIDTH / 8\n)(\n    input  wire [PHRASE_WIDTH-1:0]             input_char,\n    input  wire [(PHRASE_LEN * 5) - 1:0]       key,\n    input  wire                                decrypt,\n    output reg  [PHRASE_WIDTH-1:0]             output_char\n);\n\n    integer idx;\n    reg [7:0]  curr_char;\n    reg [4:0]  shift_val;\n\n    always @(*) begin\n        // Initialize output\n        output_char = {PHRASE_WIDTH{1'b0}};\n\n        if (PHRASE_LEN > 0) begin\n            for (idx = 0; idx < PHRASE_LEN; idx = idx + 1) begin\n                // Extract the current character and shift key\n                curr_char  = input_char[(idx * 8) +: 8];\n                shift_val  = key[(idx * 5) +: 5];\n\n                if (decrypt) begin\n                    // Decryption logic\n                    if (curr_char >= \"A\" && curr_char <= \"Z\") begin\n                        output_char[(idx * 8) +: 8] \n                            = ((curr_char - \"A\" - shift_val + 26) % 26) + \"A\";\n                    end\n                    else if (curr_char >= \"a\" && curr_char <= \"z\") begin\n                        output_char[(idx * 8) +: 8] \n                            = ((curr_char - \"a\" - shift_val + 26) % 26) + \"a\";\n                    end\n                    else begin\n                        output_char[(idx * 8) +: 8] \n                            = curr_char - shift_val;\n                    end\n                end\n                else begin\n                    // Encryption logic\n                    if (curr_char >= \"A\" && curr_char <= \"Z\") begin\n                        output_char[(idx * 8) +: 8] \n                            = ((curr_char - \"A\" + shift_val) % 26) + \"A\";\n                    end\n                    else if (curr_char >= \"a\" && curr_char <= \"z\") begin\n                        output_char[(idx * 8) +: 8] \n                            = ((curr_char - \"a\" + shift_val) % 26) + \"a\";\n                    end\n                    else begin\n                        output_char[(idx * 8) +: 8] \n                            = curr_char + shift_val;\n                    end\n                end\n            end\n        end\n    end\nendmodule"}, "patch": {"rtl/caesar_cipher.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/caesar_cipher.sv\nTOPLEVEL        = caesar_cipher\nMODULE          = test_caesar_cipher\nPYTHONPATH      = /src\nHASH            = 5-assertion-in-caesar-cipher-rtl\n", "src/test_caesar_cipher.py": "import cocotb\nfrom cocotb.triggers import Timer\nimport random\nimport string\n\n# Helper: Pack an 8-character string into a 64-bit little-endian integer.\ndef pack_string_le(s):\n    # s must be exactly 8 characters.\n    return int.from_bytes(s.encode('ascii'), 'little')\n\n# Helper: Pack a list of eight 5-bit shift values into an integer (little-endian order).\ndef pack_shifts_le(shifts):\n    key_int = 0\n    for i, s in enumerate(shifts):\n        key_int |= (s & 0x1F) << (i * 5)\n    return key_int\n\n# Helper: Unpack a 64-bit integer (little-endian) into an 8-character string.\ndef unpack_string_le(val):\n    return val.to_bytes(8, 'little').decode('ascii', errors='ignore')\n\n@cocotb.test()\nasync def test_basic(dut):\n    \"\"\"\n    BASIC TESTCASE:\n    - Encrypt and then decrypt the fixed string \"HelloZz!\" using a fixed shift = 3.\n    - Uses exactly 8 characters.\n    \"\"\"\n    await Timer(1, units=\"ns\")\n    shift = 3\n    s = \"HelloZz!\"  # exactly 8 characters\n\n    input_int = pack_string_le(s)\n    shifts = [shift] * 8\n    key_int = pack_shifts_le(shifts)\n\n    dut.input_char.value = input_int\n    dut.key.value        = key_int\n    dut.decrypt.value    = 0  # encryption mode\n\n    await Timer(10, units=\"ns\")\n    encrypted_int = dut.output_char.value.integer\n\n    # Now decrypt by feeding the encrypted output back.\n    dut.input_char.value = encrypted_int\n    dut.decrypt.value    = 1\n    await Timer(10, units=\"ns\")\n    decrypted_int = dut.output_char.value.integer\n    decrypted_str = unpack_string_le(decrypted_int)\n\n    assert decrypted_str == s, f\"Basic test failed: got '{decrypted_str}', expected '{s}'\"\n    dut._log.info(f\"PASS (basic): '{s}' correctly decrypted with shift={shift}\")\n\n@cocotb.test()\nasync def test_random(dut):\n    \"\"\"\n    RANDOM TESTCASE:\n    - Generate a random 8-character string.\n    - For each character, choose a random shift from 1 to 25.\n    - Encrypt then decrypt and verify the decrypted string matches the original.\n    \"\"\"\n    await Timer(1, units=\"ns\")\n    num_chars = 8\n    s = ''.join(random.choices(string.ascii_letters, k=num_chars))\n    shifts = [random.randint(1, 25) for _ in range(num_chars)]\n\n    input_int = pack_string_le(s)\n    key_int = pack_shifts_le(shifts)\n\n    dut.input_char.value = input_int\n    dut.key.value        = key_int\n    dut.decrypt.value    = 0  # encryption mode\n\n    await Timer(10, units=\"ns\")\n    encrypted_int = dut.output_char.value.integer\n\n    dut.input_char.value = encrypted_int\n    dut.decrypt.value    = 1\n    await Timer(10, units=\"ns\")\n    decrypted_int = dut.output_char.value.integer\n    decrypted_str = unpack_string_le(decrypted_int)\n\n    assert decrypted_str == s, (\n        f\"Random test failed: original '{s}', decrypted '{decrypted_str}' with shifts {shifts}\"\n    )\n    dut._log.info(f\"PASS (random): '{s}' correctly decrypted with shifts {shifts}\")\n\n@cocotb.test()\nasync def test_shift_zero(dut):\n    \"\"\"\n    EDGE TESTCASE (Shift = 0):\n    - With a shift of 0, encryption should leave the input unchanged.\n    \"\"\"\n    await Timer(1, units=\"ns\")\n    shift = 0\n    s = \"ZeroTest\"  # exactly 8 characters\n\n    input_int = pack_string_le(s)\n    shifts = [shift] * 8\n    key_int = pack_shifts_le(shifts)\n\n    dut.input_char.value = input_int\n    dut.key.value        = key_int\n    dut.decrypt.value    = 0\n\n    await Timer(10, units=\"ns\")\n    out_int = dut.output_char.value.integer\n    out_str = unpack_string_le(out_int)\n\n    assert out_str == s, f\"Shift zero test failed: got '{out_str}', expected '{s}'\"\n    dut._log.info(f\"PASS (shift zero): shift=0 yields '{out_str}'\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\nPHRASE_WIDTH = os.getenv(\"PHRASE_WIDTH\", \"64\")  # Default to 8 bits\nPHRASE_LEN = os.getenv(\"PHRASE_LEN\", str(int(PHRASE_WIDTH) // 8))  # Default to PHRASE_WIDTH / 8\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    # Set parameters in the environment for the testbench to access\n    os.environ[\"PHRASE_WIDTH\"] = PHRASE_WIDTH\n    os.environ[\"PHRASE_LEN\"] = PHRASE_LEN\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        parameters={\n            \"PHRASE_WIDTH\": PHRASE_WIDTH,\n            \"PHRASE_LEN\": PHRASE_LEN\n        },\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}
{"id": "cvdp_agentic_cic_decimator_0004", "categories": ["cid014", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"problematic_line_number s/problematic_statement/non_problematic_statement/\" Buggy_RTL_code.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a CIC decimator module `cic_decimator.sv\" available in the rtl directory. Please modify the module by adding SystemVerilog Assertions (SVA) to check its internal functionality comprehensively. The assertions should verify the following conditions:\n\n**Reset Cycle Register**:\nEnsure that when the reset signal (rst) is asserted ACTIVE HIGH, the cycle counter (`cycle_reg`) is reset to 0.\n\n**Reset Integrator Register 0**:\nVerify that the first integrator register (`int_reg[0]`) is reset to 0 when rst is asserted ACTIVE HIGH.\n\n**Reset Integrator Register 1**:\nVerify that the second integrator register (`int_reg[1]`) is reset to 0 when rst is asserted ACTIVE HIGH.\n\n**Reset Comb Register 0**:\nEnsure that the first comb register (`comb_reg[0]`) is reset to 0 upon `rst` is asserted ACTIVE HIGH .\n\n**Reset Comb Register 1**:\nEnsure that the second comb register (`comb_reg[1]`) is reset to 0 upon `rst` is asserted ACTIVE HIGH.\n\n**Output Valid Signal Constraint**:\nConfirm that the output valid signal (`output_tvalid`) is asserted ACTIVE HIGHonly when the cycle counter (`cycle_reg`) is 0.\n\n**Input Ready Signal Relation**:\nVerify that the input ready signal (`input_tready`) is correctly driven by the condition:\n`input_tready` equals (`output_tready` OR (`cycle_reg \u2260 0`)).\n\n**Cycle Counter Behavior**:\nWhen a valid input transfer occurs (i.e., when both `input_tvalid` and `input_tready` are true), check that the cycle counter increments by 1 if its previous value is less than both (`RMAX - 1`) and (`rate - 1`); otherwise, it should reset to 0.\n\n**Integrator Stage 0 Update**:\nOn the cycle following a valid input transfer, ensure that the first integrator register (`int_reg[0]`) updates to the sum of its previous value and the previous value of `input_tdata`.\n\n**Integrator Stage 1 Update**:\nOn a valid input transfer, verify that the second integrator register (`int_reg[1]`) updates to the sum of its previous value and the previous value of the first integrator (`int_reg[0]`).\n\n**Comb Stage 0 Update**:\nWhen a valid output transfer occurs (i.e., when both `output_tvalid` and `output_tready` are true), verify that the first comb register (`comb_reg[0]`) updates to the difference between the previous value of the last integrator (`int_reg[N-1]`) and the delayed value (e.g., `delay_reg[0]`) within comb stage 0.\n\n**Comb Stage 1 Update**:\nSimilarly, when a valid output transfer occurs, check that the second comb register (`comb_reg[1]`) updates to the difference between the previous value of the first comb register (`comb_reg[0]`) and the delayed value (e.g., `delay_reg[0]`) within comb stage 1.\n\nIf any of these conditions are violated during simulation, an appropriate error message should be displayed.\n", "context": {"docs/specs.md": "# CIC Decimator Module Analysis\n\nThis module implements a Cascaded Integrator-Comb (CIC) decimation filter. CIC filters are widely used in digital signal processing for decimating high-rate input signals without multipliers. The design comprises two main sections: a chain of integrator stages and a chain of comb (differentiator) stages, with decimation control to reduce the effective output rate.\n\n---\n\n## Parameterization\n\n- **WIDTH:** Bit-width of the input data - 16\n- **RMAX:** Maximum decimation factor - 2\n- **M:** Differential delay in the comb section - 1\n- **N:** Number of integrator and comb stages - 2\n- **REG_WIDTH:** Internal register width calculated as: WIDTH + $clog2((RMAX * M)**N)\n\n\nThis ensures that the register width is sufficient to avoid overflow during accumulation.\n\n---\n\n## Interfaces\n\n### Clock and Reset\n\n- **clk:** Clock signal for synchronous operations.\n- **rst:** Active-high reset signal.\n\n### Data and Handshaking\n\n- **Input Side:**\n- `input_tdata` (WIDTH bits): The input sample.\n- `input_tvalid`: Indicates when the input sample is valid.\n- `input_tready`: Asserted when the module is ready to accept a new input sample.\n\n- **Output Side:**\n- `output_tdata` (REG_WIDTH bits): The decimated and filtered output sample.\n- `output_tvalid`: Indicates that the output sample is valid.\n- `output_tready`: Handshake signal from the downstream module indicating readiness to accept data.\n\n### Decimation Rate Control\n\n- **rate:** A control signal (bit-width derived from `RMAX`) that determines the decimation factor by specifying how many input samples to process before producing an output.\n\n---\n\n## Detailed Functionality\n\n### 1. Integrator Section\n\n- **Structure:**  \nThe module uses a generate loop to create `N` integrator stages. Each stage accumulates values from either the input or the previous integrator stage.\n\n- **Operation:**  \n- **Stage 0:** Adds the incoming `input_tdata` to its current accumulated value.\n- **Subsequent Stages (k > 0):** Each stage adds the output from the previous integrator stage to its current accumulated value.\n\n- **Clocking:**  \nThe accumulators update on the positive edge of `clk` when both `input_tready` and `input_tvalid` are asserted.\n\n- **Purpose:**  \nThe integrators sum the incoming samples, a process essential to achieving the low-pass filtering characteristic prior to decimation.\n\n---\n\n### 2. Comb Section\n\n- **Structure:**  \nSimilar to the integrator section, a generate loop creates `N` comb stages. Each stage includes an array of `M` delay registers (`delay_reg`) to implement the required delay.\n\n- **Operation:**  \n- **Input Source:**  \n  - For the first comb stage (`k == 0`), the input is the output from the last integrator stage.\n  - For subsequent stages, the input is the output of the previous comb stage.\n- **Differentiation:**  \n  Each stage computes the difference between the current input (stored in `delay_reg[0]`) and the delayed version (`delay_reg[M-1]`).\n- **Delay Line Update:**  \n  The delay registers shift their values each clock cycle to provide the required delay.\n\n- **Clocking:**  \nComb stages update on the positive edge of `clk` when `output_tready` and `output_tvalid` are asserted.\n\n- **Purpose:**  \nThe comb stages effectively differentiate the integrated signal to remove unwanted low-frequency components, compensating for the droop introduced by the integrators.\n\n---\n\n### 3. Decimation Control\n\n- **Cycle Counter (`cycle_reg`):**  \n- The counter increments with each valid input cycle.\n- It increments until it reaches the smaller of `(RMAX - 1)` or `(rate - 1)`.\n- Once the counter reaches the specified limit, it resets to zero.\n\n- **Impact on Handshaking:**  \n- **Output Validity:**  \n  `output_tvalid` is asserted only when `input_tvalid` is high and the `cycle_reg` is zero (indicating the decimation point).\n- **Input Readiness:**  \n  `input_tready` is driven by `output_tready` or when the cycle counter is not zero, ensuring continuous accumulation in the integrators.\n\n- **Purpose:**  \nThis counter effectively controls the decimation process by determining when an output sample is produced, thereby reducing the output sample rate relative to the input sample rate.\n\n---\n\n## Summary\n\n- **CIC Filter Composition:**  \nThe design features cascaded integrator and comb stages. Integrators sum the incoming samples while comb stages subtract delayed versions of the signal to differentiate it.\n\n- **Decimation Process:**  \nA cycle counter (`cycle_reg`) manages the decimation by ensuring that output samples are generated only after a predetermined number of input samples (defined by the `rate` parameter) have been processed.\n\n- **Parameter Flexibility:**  \nThe module is highly parameterizable (via `WIDTH`, `RMAX`, `M`, and `N`), making it adaptable to a wide range of decimation and filtering applications in digital down-conversion and oversampled signal processing.\n\nThis analysis provides a comprehensive overview of both the architecture and the functionality of the CIC decimator module.", "rtl/cic_decimator.sv": "module cic_decimator #(\n    parameter int WIDTH     = 16,\n    parameter int RMAX      = 2,\n    parameter int M         = 1,\n    parameter int N         = 2,\n    parameter int REG_WIDTH = WIDTH + $clog2((RMAX * M)**N)\n) (\n    input  logic                      clk,\n    input  logic                      rst,\n    input  logic [WIDTH-1:0]          input_tdata,\n    input  logic                      input_tvalid,\n    input  logic                      output_tready,\n    input  logic [$clog2(RMAX+1)-1:0] rate,\n    output logic                      input_tready,\n    output logic [REG_WIDTH-1:0]      output_tdata,\n    output logic                      output_tvalid\n);\n\n    \n    logic [$clog2(RMAX+1)-1:0] cycle_reg;\n    logic [REG_WIDTH-1:0] int_reg [0:N-1];\n    logic [REG_WIDTH-1:0] comb_reg [0:N-1];\n\n    \n    logic [REG_WIDTH-1:0] int_reg_0 = int_reg[0];\n    logic [REG_WIDTH-1:0] int_reg_1 = int_reg[1];\n    logic [REG_WIDTH-1:0] comb_reg_0 = comb_reg[0];\n    logic [REG_WIDTH-1:0] comb_reg_1 = comb_reg[1];\n\n    assign input_tready  = output_tready || (cycle_reg != 0);\n    assign output_tdata  = comb_reg[N-1];\n    assign output_tvalid = input_tvalid && (cycle_reg == 0);\n\n    \n    initial begin\n        cycle_reg = 0;\n        for (int i = 0; i < N; i++) begin\n            int_reg[i]  = 0;\n            comb_reg[i] = 0;\n        end\n    end\n\n    \n    genvar k;\n    generate\n        for (k = 0; k < N; k++) begin : integrator\n            always_ff @(posedge clk) begin\n                if (rst) begin\n                    int_reg[k] <= 0;\n                end else begin\n                    if (input_tready && input_tvalid) begin\n                        if (k == 0) begin\n                            int_reg[k] <= $signed(int_reg[k]) + $signed(input_tdata);\n                        end else begin\n                            int_reg[k] <= $signed(int_reg[k]) + $signed(int_reg[k-1]);\n                        end\n                    end\n                end\n            end\n        end\n    endgenerate\n\n    \n    generate\n        for (k = 0; k < N; k++) begin : comb\n            logic [REG_WIDTH-1:0] delay_reg [0:M-1];\n\n            \n            initial begin\n                for (int i = 0; i < M; i++) begin\n                    delay_reg[i] = 0;\n                end\n            end\n\n            always_ff @(posedge clk) begin\n                if (rst) begin\n                    for (int i = 0; i < M; i++) begin\n                        delay_reg[i] <= 0;\n                    end\n                    comb_reg[k] <= 0;\n                end else begin\n                    if (output_tready && output_tvalid) begin\n                        if (k == 0) begin\n                            delay_reg[0] <= $signed(int_reg[N-1]);\n                            comb_reg[k] <= $signed(int_reg[N-1]) - $signed(delay_reg[M-1]);\n                        end else begin\n                            delay_reg[0] <= $signed(comb_reg[k-1]);\n                            comb_reg[k] <= $signed(comb_reg[k-1]) - $signed(delay_reg[M-1]);\n                        end\n                        for (int i = 0; i < M-1; i++) begin\n                            delay_reg[i+1] <= delay_reg[i];\n                        end\n                    end\n                end\n            end\n        end\n    endgenerate\n\n\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            cycle_reg <= 0;\n        end else begin\n            if (input_tready && input_tvalid) begin\n                if ((cycle_reg < RMAX - 1) && (cycle_reg < rate - 1)) begin\n                    cycle_reg <= cycle_reg + 1;\n                end else begin\n                    cycle_reg <= 0;\n                end\n            end\n        end\n    end\n\nendmodule\n"}, "patch": {"rtl/cic_decimator.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cic_decimator.sv\nTOPLEVEL        = cic_decimator\nMODULE          = test_cic_decimator\nPYTHONPATH      = /src\nHASH            = 4-cic_decimator_rtl_assertion_generation_issue\n", "src/test_cic_decimator.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\n\nasync def monitor(dut):\n    \"\"\"Monitor task to print key signals at every rising edge.\"\"\"\n    while True:\n        await RisingEdge(dut.clk)\n        dut._log.info(\n            \"clk=%s, rst=%s, input_tdata=%s, input_tvalid=%s, input_tready=%s, output_tdata=%s, output_tvalid=%s\",\n            dut.clk.value,\n            dut.rst.value,\n            dut.input_tdata.value,\n            dut.input_tvalid.value,\n            dut.input_tready.value,\n            dut.output_tdata.value,\n            dut.output_tvalid.value\n        )\n\n@cocotb.test()\nasync def test_cic_decimator(dut):\n    \"\"\"Testbench for the cic_decimator DUT.\"\"\"\n    # Start clock generation with a 10 ns period (5 ns high, 5 ns low)\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Start the monitor coroutine to log signal values every rising edge.\n    cocotb.start_soon(monitor(dut))\n\n    # Initialize signals\n    dut.rst.value           = 1\n    dut.input_tdata.value   = 0\n    dut.input_tvalid.value  = 0\n    dut.output_tready.value = 1  # downstream is always ready\n    dut.rate.value          = 1  # start with decimation rate 1\n\n    # Apply reset for 20 ns and then deassert it.\n    await Timer(20, units=\"ns\")\n    dut.rst.value = 0\n\n    # Wait a couple of clock cycles for stabilization.\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n    #---------------------------------------------------------------------------\n    # Test Sequence 1: rate = 1\n    #---------------------------------------------------------------------------\n    dut._log.info(\"--- Test Sequence 1: rate = 1 ---\")\n    for j in range(10):\n        await RisingEdge(dut.clk)\n        dut.input_tdata.value  = j\n        dut.input_tvalid.value = 1\n    # Deassert input_tvalid to simulate an idle period.\n    await RisingEdge(dut.clk)\n    dut.input_tvalid.value = 0\n\n    # Wait a few clock cycles to allow output observation.\n    await Timer(50, units=\"ns\")\n\n    #---------------------------------------------------------------------------\n    # Test Sequence 2: rate = 2\n    #---------------------------------------------------------------------------\n    dut._log.info(\"--- Test Sequence 2: rate = 2 ---\")\n    dut.rate.value = 2\n    for j in range(10):\n        await RisingEdge(dut.clk)\n        dut.input_tdata.value  = j + 100  # offset pattern\n        dut.input_tvalid.value = 1\n    await RisingEdge(dut.clk)\n    dut.input_tvalid.value = 0\n\n    # Allow simulation to run further to capture final outputs.\n    await Timer(100, units=\"ns\")\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}
{"id": "cvdp_agentic_cont_adder_0003", "categories": ["cid014", "easy"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a `continuous_adder` module available in the `rtl` directory, and its specification is in the `docs` directory. Kindly modify the module by adding SystemVerilog assertions. The assertions should ensure that the module correctly implements continuous accumulation and valid flush behavior.\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Flush Behavior:** Ensure that the `flush` signal correctly resets the accumulator register.  \n- **Accumulate Behavior:** Verify that the sum is updated accurately on every valid input cycle, only when `accumulate_enable` is high.  \n- **Threshold Detection (if enabled):** Confirm that the `threshold_reached` logic correctly detects when the current sum exceeds the threshold parameter (if `ENABLE_THRESHOLD` is set).  \n- **Output Registration (if enabled):** Check that the module's outputs are registered (i.e., pass through flip-flops at the output stage) when `REGISTER_OUTPUT` is enabled.\n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** to highlight the incorrect behavior in the continuous accumulator logic.\n", "context": {"docs/continuous_adder_specification.md": "# Continuous Adder Specification Document\n\n## Introduction\n\nThe **Continuous Adder** is a configurable hardware module designed to perform continuous accumulation of incoming data values. The accumulation process can be controlled via enable and flush signals, and an optional threshold feature allows automatic sum validation when a predefined limit is reached. The module also supports optional output registering for synchronous operation.\n\n---\n\n## Functional Overview\n\nThe Continuous Adder operates based on the following key conditions:\n\n1. **Accumulation Logic:**  \n   - Incoming `data_in` is continuously accumulated when `valid_in` and `accumulate_enable` are high.\n   - The accumulated sum is stored in an internal register (`sum_reg`).\n\n2. **Flush Mechanism:**  \n   - When the `flush` signal is asserted, the sum register is reset to zero.\n   - This allows clearing the accumulated sum when needed.\n\n3. **Threshold-Based Output Validation:**  \n   - If `ENABLE_THRESHOLD` is set, the module checks whether `sum_reg` has reached or exceeded the predefined `THRESHOLD`.\n   - When the threshold is met, the output `sum_out` is updated, and `sum_valid` is asserted.\n\n4. **Registering Output (Optional):**  \n   - If `REGISTER_OUTPUT` is enabled, `sum_out` and `sum_valid` are registered synchronously with `clk` and `rst_n`.\n   - If `REGISTER_OUTPUT` is disabled, the outputs are updated combinationally.\n\n---\n\n## Module Interface\n\nThe continuous adder module should be defined as follows:\n\n```verilog\nmodule continuous_adder #(\n    parameter integer DATA_WIDTH       = 32,\n    parameter integer ENABLE_THRESHOLD = 0,\n    parameter integer THRESHOLD        = 16,\n    parameter integer REGISTER_OUTPUT  = 0\n)(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire valid_in,\n    input  wire [DATA_WIDTH-1:0] data_in,\n    input  wire accumulate_enable,\n    input  wire flush,\n    output reg  [DATA_WIDTH-1:0] sum_out,\n    output reg  sum_valid\n);\n```\n\n### Port Description\n\n- **clk:** Clock signal.\n- **rst_n:** Active-low asynchronous reset to reset outputs to zero.\n- **valid_in:** Validity signal for incoming data.\n- **data_in:** Input data value to be accumulated.\n- **accumulate_enable:** Enables accumulation when high.\n- **flush:** Clears the accumulated sum when asserted.\n- **sum_out:** The accumulated sum output.\n- **sum_valid:** Indicates when a valid sum is available.\n\n---\n\n## Internal Architecture\n\nThe internal architecture consists of the following key components:\n\n1. **Sum Register:**  \n   - Stores the accumulated sum.\n   - Updated when `valid_in` and `accumulate_enable` are asserted.\n\n2. **Threshold Handling:**  \n   - If `ENABLE_THRESHOLD` is enabled, the module checks if `sum_reg` has reached `THRESHOLD`.\n   - If the threshold is met, `sum_out` is updated, and `sum_valid` is asserted.\n\n3. **Output Registering (if enabled):**  \n   - If `REGISTER_OUTPUT` is enabled, `sum_out` and `sum_valid` are registered synchronously.\n   - Otherwise, they are updated combinationally.\n\n4. **Flush Control:**  \n   - When `flush` is asserted, `sum_reg` is reset to zero.\n\n---\n\n## Timing and Latency\n\n- The module operates synchronously with `clk` when `REGISTER_OUTPUT` is enabled.\n- When `REGISTER_OUTPUT` is disabled, the output updates immediately.\n- If threshold validation is enabled, the sum output and validation signal update as soon as the threshold is reached.\n\n---\n\n## Configuration Options\n\n- **DATA_WIDTH**: Configurable width of the input data.\n- **ENABLE_THRESHOLD**: Enables or disables threshold-based accumulation.\n- **THRESHOLD**: Defines the value at which the sum is considered complete.\n- **REGISTER_OUTPUT**: Determines whether the output is registered.\n\nThis design ensures efficient continuous accumulation with configurable options for various system requirements.", "rtl/continuous_adder.sv": "`timescale 1ns/1ps\n\nmodule continuous_adder #(\n    parameter integer DATA_WIDTH       = 32,\n    parameter integer ENABLE_THRESHOLD = 0,\n    parameter integer THRESHOLD        = 16,\n    parameter integer REGISTER_OUTPUT  = 0\n)(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire valid_in,\n    input  wire [DATA_WIDTH-1:0] data_in,\n    input  wire accumulate_enable,\n    input  wire flush,\n    output reg  [DATA_WIDTH-1:0] sum_out,\n    output reg  sum_valid\n);\n\nreg [DATA_WIDTH-1:0] sum_reg;\nwire threshold_reached = (ENABLE_THRESHOLD != 0) && (sum_reg >= THRESHOLD);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        sum_reg <= '0;\n    else begin\n        if (flush)\n            sum_reg <= '0;\n        else if (valid_in && accumulate_enable)\n            sum_reg <= sum_reg + data_in;\n    end\nend\n\ngenerate\n    if (REGISTER_OUTPUT != 0) begin\n        always @(posedge clk or negedge rst_n) begin\n            if (!rst_n) begin\n                sum_out   <= '0;\n                sum_valid <= 1'b0;\n            end else begin\n                if (flush || threshold_reached) begin\n                    sum_out   <= sum_reg;\n                    sum_valid <= 1'b1;\n                end else begin\n                    sum_valid <= 1'b0;\n                end\n            end\n        end\n    end else begin\n        always @* begin\n            sum_out   = (flush || threshold_reached) ? sum_reg : sum_out;\n            sum_valid = (flush || threshold_reached) ? 1'b1     : 1'b0;\n        end\n    end\nendgenerate\n\nendmodule", "verif/continuous_adder_tb.sv": "`timescale 1ns/1ps\n\nmodule tb_continuous_adder;\n\nreg clk;\nreg rst_n;\nreg valid_in;\nreg [31:0] data_in;\nreg accumulate_enable;\nreg flush;\nwire [31:0] sum_out;\nwire sum_valid;\n\ncontinuous_adder #(\n    .DATA_WIDTH(32),\n    .ENABLE_THRESHOLD(1),\n    .THRESHOLD(32'h00000010),\n    .REGISTER_OUTPUT(1)\n) dut (\n    .clk(clk),\n    .rst_n(rst_n),\n    .valid_in(valid_in),\n    .data_in(data_in),\n    .accumulate_enable(accumulate_enable),\n    .flush(flush),\n    .sum_out(sum_out),\n    .sum_valid(sum_valid)\n);\n\nalways #5 clk = ~clk;\n\nreg [31:0] expected_sum;\nreg [31:0] expected_sum_delay;\n\ninitial begin\n    clk = 0;\n    rst_n = 0;\n    valid_in = 0;\n    data_in = 0;\n    accumulate_enable = 0;\n    flush = 0;\n    expected_sum = 0;\n    repeat(2) @(posedge clk);\n    rst_n = 1;\n    repeat(2) @(posedge clk);\n\n    valid_in = 1; accumulate_enable = 1; data_in = 4; @(posedge clk);\n    data_in = 8; @(posedge clk);\n    data_in = 5; @(posedge clk);\n    data_in = 7; @(posedge clk);\n    valid_in = 0; accumulate_enable = 0; data_in = 0; @(posedge clk);\n    flush = 1; @(posedge clk); flush = 0; @(posedge clk);\n    $display(\"Time=%0t flush done, sum_out=%h sum_valid=%b\", $time, sum_out, sum_valid);\n\n    valid_in = 1; accumulate_enable = 1; data_in = 8; @(posedge clk);\n    data_in = 10; @(posedge clk);\n    data_in = 1; @(posedge clk);\n    data_in = 5; @(posedge clk);\n    data_in = 5; @(posedge clk);\n    valid_in = 0; accumulate_enable = 0; data_in = 0; @(posedge clk);\n    $display(\"Time=%0t second block done, sum_out=%h sum_valid=%b\", $time, sum_out, sum_valid);\n\n    //integer i;\n    for (int i = 0; i < 10; i = i + 1) begin\n        data_in = $random;\n        valid_in = 1; accumulate_enable = 1; @(posedge clk);\n    end\n    valid_in = 0; data_in = 0; accumulate_enable = 0; @(posedge clk);\n    flush = 1; @(posedge clk); flush = 0; @(posedge clk);\n    $display(\"Time=%0t random block flush, sum_out=%h sum_valid=%b\", $time, sum_out, sum_valid);\n\n    $finish;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        expected_sum <= 0;\n    end else begin\n        if (flush) begin\n            expected_sum <= 0;\n        end else if (valid_in && accumulate_enable) begin\n            expected_sum <= expected_sum + data_in;\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    // Capture expected_sum in a delay register to match the pipeline latency\n    expected_sum_delay <= expected_sum;\n    if (sum_valid) begin\n        if (sum_out !== expected_sum_delay) begin\n            $display(\"Mismatch at %0t: expected=%h got=%h\", $time, expected_sum_delay, sum_out);\n        end else begin\n            $display(\"Match at %0t: sum=%h\", $time, sum_out);\n        end\n    end\nend\n\nendmodule"}, "patch": {"rtl/continuous_adder.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/continuous_adder.sv\nTOPLEVEL        = continuous_adder\nMODULE          = test_continuous_adder\nPYTHONPATH      = /src\nHASH            = 3-rtl-assertion-for-cont-adder\n", "src/test_continuous_adder.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\nasync def reset_dut(dut):\n    dut.clk.value = 0\n    dut.rst_n.value = 0\n    dut.valid_in.value = 0\n    dut.data_in.value = 0\n    dut.accumulate_enable.value = 0\n    dut.flush.value = 0\n    await RisingEdge(dut.clk)\n    dut.rst_n.value = 1\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n@cocotb.test()\nasync def test_basic(dut):\n    \"\"\"Basic scenario: accumulate a few values, then flush.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await reset_dut(dut)\n\n    dut.valid_in.value = 1\n    dut.accumulate_enable.value = 1\n    for val in [4, 8, 5, 7]:\n        dut.data_in.value = val\n        await RisingEdge(dut.clk)\n    dut.valid_in.value = 0\n    dut.accumulate_enable.value = 0\n    await RisingEdge(dut.clk)\n\n    dut.flush.value = 1\n    await RisingEdge(dut.clk)\n    dut.flush.value = 0\n    await RisingEdge(dut.clk)\n\n@cocotb.test()\nasync def test_random(dut):\n    \"\"\"Random scenario: feed random inputs and flush.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await reset_dut(dut)\n\n    for _ in range(5):\n        dut.data_in.value = random.getrandbits(dut.DATA_WIDTH.value)\n        dut.valid_in.value = 1\n        dut.accumulate_enable.value = 1\n        await RisingEdge(dut.clk)\n    dut.valid_in.value = 0\n    dut.accumulate_enable.value = 0\n    await RisingEdge(dut.clk)\n\n    dut.flush.value = 1\n    await RisingEdge(dut.clk)\n    dut.flush.value = 0\n    await RisingEdge(dut.clk)\n\n@cocotb.test()\nasync def test_edge_cases(dut):\n    \"\"\"Edge scenario: feed near-maximum 32-bit values.\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await reset_dut(dut)\n\n    for val in [0xFFFFFF00, 0xFFFFFFFF, 1]:\n        dut.valid_in.value = 1\n        dut.accumulate_enable.value = 1\n        dut.data_in.value = val\n        await RisingEdge(dut.clk)\n    dut.valid_in.value = 0\n    dut.accumulate_enable.value = 0\n    await RisingEdge(dut.clk)\n\n    dut.flush.value = 1\n    await RisingEdge(dut.clk)\n    dut.flush.value = 0\n    await RisingEdge(dut.clk)\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources   = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang     = os.getenv(\"TOPLEVEL_LANG\")\nsim               = os.getenv(\"SIM\", \"icarus\")\ntoplevel          = os.getenv(\"TOPLEVEL\")\nmodule            = os.getenv(\"MODULE\")\nwave              = os.getenv(\"WAVE\")\n\ndata_width        = int(os.getenv(\"DATA_WIDTH\", \"32\"))\nenable_threshold  = int(os.getenv(\"ENABLE_THRESHOLD\", \"0\"))\nthreshold         = int(os.getenv(\"THRESHOLD\", \"16\"))\nregister_output   = int(os.getenv(\"REGISTER_OUTPUT\", \"0\"))\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    parameters = {\n        \"DATA_WIDTH\":        data_width,\n        \"ENABLE_THRESHOLD\":  enable_threshold,\n        \"THRESHOLD\":         threshold,\n        \"REGISTER_OUTPUT\":   register_output\n    }\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\",\n        parameters=parameters\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}
{"id": "cvdp_agentic_crypto_0001", "categories": ["cid014", "medium"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYour task is to modify the existing RTL design based on the provided specifications to improve Quality of Results (QoR) such as timing, area, or power efficiency. Ensure the modifications are verified against the provided testbench and meet the updated specifications.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Develop assertion properties to verify the liveness properties of the FSM in the `rtl/blake2s_core` module. These assertions must ensure that each FSM state is reachable from its expected previous state under valid conditions.\n\nTarget the FSM states held by the `blake2s_ctrl_reg` signal: `{CTRL_IDLE, CTRL_INIT_ROUND, CTRL_G_ROW, CTRL_G_DIAGONAL, CTRL_COMP_DONE, CTRL_FINISH}`.\n\nThe following requirements must be addressed:\n- The properties must be placed in a separate module named `blake2s_core_state_liveness_check`, which instantiates `blake2s_core` as the Device Under Test (DUT).  \n- The properties must directly reference internal DUT signals for verification.\n", "context": {"rtl/blake2s_G.v": "//======================================================================\n//\n// blake2s_G.v\n// -----------\n// Verilog 2001 implementation of the G function in the\n// blake2s hash function core. This is pure combinational logic in a\n// separade module to allow us to build versions  with 1, 2, 4\n// and even 8 parallel compression functions.\n//\n//\n// Author: Joachim Str\u00f6mbergson\n// Copyright (c) 2018, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\nmodule blake2s_G(\n                 input wire [31 : 0]  a,\n                 input wire [31 : 0]  b,\n                 input wire [31 : 0]  c,\n                 input wire [31 : 0]  d,\n                 input wire [31 : 0]  m0,\n                 input wire [31 : 0]  m1,\n\n                 output wire [31 : 0] a_prim,\n                 output wire [31 : 0] b_prim,\n                 output wire [31 : 0] c_prim,\n                 output wire [31 : 0] d_prim\n                );\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg [31 : 0] a1;\n  reg [31 : 0] a2;\n  reg [31 : 0] b1;\n  reg [31 : 0] b2;\n  reg [31 : 0] b3;\n  reg [31 : 0] b4;\n  reg [31 : 0] c1;\n  reg [31 : 0] c2;\n  reg [31 : 0] d1;\n  reg [31 : 0] d2;\n  reg [31 : 0] d3;\n  reg [31 : 0] d4;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports.\n  //----------------------------------------------------------------\n  assign a_prim = a2;\n  assign b_prim = b4;\n  assign c_prim = c2;\n  assign d_prim = d4;\n\n\n  //----------------------------------------------------------------\n  // G_function\n  //----------------------------------------------------------------\n  always @*\n    begin : G_function\n      a1 = a + b + m0;\n\n      d1 = d ^ a1;\n      d2 = {d1[15 : 0], d1[31 : 16]};\n\n      c1 = c + d2;\n\n      b1 = b ^ c1;\n      b2 = {b1[11 : 0], b1[31 : 12]};\n\n      a2 = a1 + b2 + m1;\n\n      d3 = d2 ^ a2;\n      d4 = {d3[7 : 0], d3[31 : 8]};\n\n      c2 = c1 + d4;\n\n      b3 = b2 ^ c2;\n      b4 = {b3[6 : 0], b3[31 : 7]};\n    end // G_function\nendmodule // blake2s_G\n\n//======================================================================\n// EOF blake2s_G.v\n//======================================================================", "rtl/blake2s_core.v": "//======================================================================\n//\n// blake2s_core.v\n// --------------\n// Verilog 2001 implementation of the hash function blake2s.\n// This is the internal core with wide interfaces.\n//\n//\n// Author: Joachim Str\u00f6mbergson\n// Copyright (c) 2018, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\nmodule blake2s_core(\n                    input wire            clk,\n                    input wire            reset_n,\n\n                    input wire            init,\n                    input wire            update,\n                    input wire            finish,\n\n                    input wire [511 : 0]  block,\n                    input wire [6 : 0]    blocklen,\n\n                    output wire [255 : 0] digest,\n                    output wire           ready\n                  );\n\n\n  //----------------------------------------------------------------\n  // Parameter block.\n  // See BLAKE2 paper and RFC 7693 for definition.\n  // Chapter 2.8 in https://blake2.net/blake2.pdf\n  // Section 2.5 in https://tools.ietf.org/html/rfc7693\n  //----------------------------------------------------------------\n  // The digest length in bytes. Minimum: 1, Maximum: 32\n  localparam [7 : 0]  DIGEST_LENGTH   = 8'd32;\n  localparam [7 : 0]  KEY_LENGTH      = 8'd0;\n  localparam [7 : 0]  FANOUT          = 8'd1;\n  localparam [7 : 0]  DEPTH           = 8'd01;\n  localparam [31 : 0] LEAF_LENGTH     = 32'd0;\n  localparam [47 : 0] NODE_OFFSET     = 48'd0;\n  localparam [7 : 0]  NODE_DEPTH      = 8'd0;\n  localparam [7 : 0]  INNER_LENGTH    = 8'd0;\n  localparam [63 : 0] SALT            = 64'h0;\n  localparam [63 : 0] PERSONALIZATION = 64'h0;\n\n  wire [255 : 0] parameter_block = {PERSONALIZATION, SALT, INNER_LENGTH,\n                                    NODE_DEPTH, NODE_OFFSET, LEAF_LENGTH,\n                                    DEPTH, FANOUT, KEY_LENGTH, DIGEST_LENGTH};\n\n\n  //----------------------------------------------------------------\n  // Internal constant definitions.\n  //----------------------------------------------------------------\n  localparam NUM_ROUNDS  = 10;\n  localparam BLOCK_BYTES = 7'd64;\n\n  // G function modes.\n  localparam G_ROW      = 1'h0;\n  localparam G_DIAGONAL = 1'h1;\n\n  // Initial vectors.\n  localparam IV0 = 32'h6a09e667;\n  localparam IV1 = 32'hbb67ae85;\n  localparam IV2 = 32'h3c6ef372;\n  localparam IV3 = 32'ha54ff53a;\n  localparam IV4 = 32'h510e527f;\n  localparam IV5 = 32'h9b05688c;\n  localparam IV6 = 32'h1f83d9ab;\n  localparam IV7 = 32'h5be0cd19;\n\n  // Control FSM state names.\n  localparam CTRL_IDLE       = 3'h0;\n  localparam CTRL_INIT_ROUND = 3'h1;\n  localparam CTRL_G_ROW      = 3'h2;\n  localparam CTRL_G_DIAGONAL = 3'h3;\n  localparam CTRL_COMP_DONE  = 3'h4;\n  localparam CTRL_FINISH     = 3'h5;\n\n\n  //----------------------------------------------------------------\n  // Registers including update variables and write enable.\n  //----------------------------------------------------------------\n  reg [31 : 0] h_reg [0 : 7];\n  reg [31 : 0] h_new [0 : 7];\n  reg          h_we;\n\n  reg [31 : 0] v_reg [0 : 15];\n  reg [31 : 0] v_new [0 : 15];\n  reg          v_we;\n  reg          init_v;\n  reg          update_v;\n\n  reg [3 : 0]  round_ctr_reg;\n  reg [3 : 0]  round_ctr_new;\n  reg          round_ctr_we;\n  reg          round_ctr_inc;\n  reg          round_ctr_rst;\n\n  reg [31 : 0] t0_reg;\n  reg [31 : 0] t0_new;\n  reg          t0_we;\n  reg [31 : 0] t1_reg;\n  reg [31 : 0] t1_new;\n  reg          t1_we;\n  reg          t_ctr_inc;\n  reg          t_ctr_rst;\n\n  reg          last_reg;\n  reg          last_new;\n  reg          last_we;\n\n  reg          ready_reg;\n  reg          ready_new;\n  reg          ready_we;\n\n  reg [2 : 0]  blake2s_ctrl_reg;\n  reg [2 : 0]  blake2s_ctrl_new;\n  reg          blake2s_ctrl_we;\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg init_state;\n  reg update_state;\n  reg load_m;\n  reg G_mode;\n\n  reg  [31 : 0] G0_a;\n  reg  [31 : 0] G0_b;\n  reg  [31 : 0] G0_c;\n  reg  [31 : 0] G0_d;\n  wire [31 : 0] G0_m0;\n  wire [31 : 0] G0_m1;\n  wire [31 : 0] G0_a_prim;\n  wire [31 : 0] G0_b_prim;\n  wire [31 : 0] G0_c_prim;\n  wire [31 : 0] G0_d_prim;\n\n  reg  [31 : 0] G1_a;\n  reg  [31 : 0] G1_b;\n  reg  [31 : 0] G1_c;\n  reg  [31 : 0] G1_d;\n  wire [31 : 0] G1_m0;\n  wire [31 : 0] G1_m1;\n  wire [31 : 0] G1_a_prim;\n  wire [31 : 0] G1_b_prim;\n  wire [31 : 0] G1_c_prim;\n  wire [31 : 0] G1_d_prim;\n\n  reg  [31 : 0] G2_a;\n  reg  [31 : 0] G2_b;\n  reg  [31 : 0] G2_c;\n  reg  [31 : 0] G2_d;\n  wire [31 : 0] G2_m0;\n  wire [31 : 0] G2_m1;\n  wire [31 : 0] G2_a_prim;\n  wire [31 : 0] G2_b_prim;\n  wire [31 : 0] G2_c_prim;\n  wire [31 : 0] G2_d_prim;\n\n  reg  [31 : 0] G3_a;\n  reg  [31 : 0] G3_b;\n  reg  [31 : 0] G3_c;\n  reg  [31 : 0] G3_d;\n  wire [31 : 0] G3_m0;\n  wire [31 : 0] G3_m1;\n  wire [31 : 0] G3_a_prim;\n  wire [31 : 0] G3_b_prim;\n  wire [31 : 0] G3_c_prim;\n  wire [31 : 0] G3_d_prim;\n\n\n  //----------------------------------------------------------------\n  // Module instantations.\n  //----------------------------------------------------------------\n  blake2s_m_select mselect(\n                           .clk(clk),\n                           .reset_n(reset_n),\n                           .load(load_m),\n                           .m(block),\n                           .round(round_ctr_reg),\n                           .mode(G_mode),\n                           .G0_m0(G0_m0),\n                           .G0_m1(G0_m1),\n                           .G1_m0(G1_m0),\n                           .G1_m1(G1_m1),\n                           .G2_m0(G2_m0),\n                           .G2_m1(G2_m1),\n                           .G3_m0(G3_m0),\n                           .G3_m1(G3_m1)\n                          );\n\n\n  blake2s_G G0(\n               .a(G0_a),\n               .b(G0_b),\n               .c(G0_c),\n               .d(G0_d),\n               .m0(G0_m0),\n               .m1(G0_m1),\n               .a_prim(G0_a_prim),\n               .b_prim(G0_b_prim),\n               .c_prim(G0_c_prim),\n               .d_prim(G0_d_prim)\n              );\n\n\n  blake2s_G G1(\n               .a(G1_a),\n               .b(G1_b),\n               .c(G1_c),\n               .d(G1_d),\n               .m0(G1_m0),\n               .m1(G1_m1),\n               .a_prim(G1_a_prim),\n               .b_prim(G1_b_prim),\n               .c_prim(G1_c_prim),\n               .d_prim(G1_d_prim)\n              );\n\n\n  blake2s_G G2(\n               .a(G2_a),\n               .b(G2_b),\n               .c(G2_c),\n               .d(G2_d),\n               .m0(G2_m0),\n               .m1(G2_m1),\n\n               .a_prim(G2_a_prim),\n               .b_prim(G2_b_prim),\n               .c_prim(G2_c_prim),\n               .d_prim(G2_d_prim)\n              );\n\n\n  blake2s_G G3(\n               .a(G3_a),\n               .b(G3_b),\n               .c(G3_c),\n               .d(G3_d),\n               .m0(G3_m0),\n               .m1(G3_m1),\n               .a_prim(G3_a_prim),\n               .b_prim(G3_b_prim),\n               .c_prim(G3_c_prim),\n               .d_prim(G3_d_prim)\n              );\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign digest = {h_reg[0][7 : 0], h_reg[0][15 : 8], h_reg[0][23 : 16], h_reg[0][31 : 24],\n                   h_reg[1][7 : 0], h_reg[1][15 : 8], h_reg[1][23 : 16], h_reg[1][31 : 24],\n                   h_reg[2][7 : 0], h_reg[2][15 : 8], h_reg[2][23 : 16], h_reg[2][31 : 24],\n                   h_reg[3][7 : 0], h_reg[3][15 : 8], h_reg[3][23 : 16], h_reg[3][31 : 24],\n                   h_reg[4][7 : 0], h_reg[4][15 : 8], h_reg[4][23 : 16], h_reg[4][31 : 24],\n                   h_reg[5][7 : 0], h_reg[5][15 : 8], h_reg[5][23 : 16], h_reg[5][31 : 24],\n                   h_reg[6][7 : 0], h_reg[6][15 : 8], h_reg[6][23 : 16], h_reg[6][31 : 24],\n                   h_reg[7][7 : 0], h_reg[7][15 : 8], h_reg[7][23 : 16], h_reg[7][31 : 24]};\n\n  assign ready = ready_reg;\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //----------------------------------------------------------------\n  always @ (posedge clk)\n    begin : reg_update\n      integer i;\n\n      if (!reset_n) begin\n        for (i = 0; i < 8; i = i + 1) begin\n          h_reg[i] <= 32'h0;\n        end\n\n        for (i = 0; i < 16; i = i + 1) begin\n          v_reg[i] <= 32'h0;\n        end\n\n        t0_reg           <= 32'h0;\n        t1_reg           <= 32'h0;\n        last_reg         <= 1'h0;\n        ready_reg        <= 1'h1;\n        round_ctr_reg    <= 4'h0;\n        blake2s_ctrl_reg <= CTRL_IDLE;\n      end\n      else begin\n        if (h_we) begin\n          for (i = 0; i < 8; i = i + 1) begin\n            h_reg[i] <= h_new[i];\n          end\n        end\n\n        if (v_we) begin\n          for (i = 0; i < 16; i = i + 1) begin\n            v_reg[i] <= v_new[i];\n          end\n        end\n\n        if (t0_we) begin\n          t0_reg <= t0_new;\n        end\n\n        if (t1_we) begin\n          t1_reg <= t1_new;\n        end\n\n        if (last_we) begin\n          last_reg <= last_new;\n        end\n\n        if (ready_we) begin\n          ready_reg <= ready_new;\n        end\n\n        if (round_ctr_we) begin\n          round_ctr_reg <= round_ctr_new;\n        end\n\n        if (blake2s_ctrl_we) begin\n          blake2s_ctrl_reg <= blake2s_ctrl_new;\n        end\n      end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // state_logic\n  //\n  // Logic for updating the hash state.\n  //----------------------------------------------------------------\n  always @*\n    begin : state_logic\n      integer i;\n\n      for (i = 0; i < 8; i = i + 1) begin\n        h_new[i] = 32'h0;\n      end\n      h_we   = 1'h0;\n\n      if (init_state) begin\n        h_new[0] = IV0 ^ parameter_block[31  :   0];\n        h_new[1] = IV1 ^ parameter_block[63  :  32];\n        h_new[2] = IV2 ^ parameter_block[95  :  64];\n        h_new[3] = IV3 ^ parameter_block[127 :  96];\n        h_new[4] = IV4 ^ parameter_block[159 : 128];\n        h_new[5] = IV5 ^ parameter_block[191 : 160];\n        h_new[6] = IV6 ^ parameter_block[223 : 192];\n        h_new[7] = IV7 ^ parameter_block[255 : 224];\n        h_we     = 1;\n      end\n\n      if (update_state) begin\n        h_new[0] = h_reg[0] ^ v_reg[0] ^ v_reg[8];\n        h_new[1] = h_reg[1] ^ v_reg[1] ^ v_reg[9];\n        h_new[2] = h_reg[2] ^ v_reg[2] ^ v_reg[10];\n        h_new[3] = h_reg[3] ^ v_reg[3] ^ v_reg[11];\n        h_new[4] = h_reg[4] ^ v_reg[4] ^ v_reg[12];\n        h_new[5] = h_reg[5] ^ v_reg[5] ^ v_reg[13];\n        h_new[6] = h_reg[6] ^ v_reg[6] ^ v_reg[14];\n        h_new[7] = h_reg[7] ^ v_reg[7] ^ v_reg[15];\n        h_we     = 1;\n      end\n    end // state_logic\n\n\n  //----------------------------------------------------------------\n  // compress_logic\n  //----------------------------------------------------------------\n  always @*\n    begin : compress_logic\n      integer i;\n\n      for (i = 0; i < 16; i = i + 1) begin\n        v_new[i] = 32'h0;\n      end\n      v_we = 1'h0;\n\n      G0_a = 32'h0;\n      G0_b = 32'h0;\n      G0_c = 32'h0;\n      G0_d = 32'h0;\n      G1_a = 32'h0;\n      G1_b = 32'h0;\n      G1_c = 32'h0;\n      G1_d = 32'h0;\n      G2_a = 32'h0;\n      G2_b = 32'h0;\n      G2_c = 32'h0;\n      G2_d = 32'h0;\n      G3_a = 32'h0;\n      G3_b = 32'h0;\n      G3_c = 32'h0;\n      G3_d = 32'h0;\n\n      if (init_v)\n        begin\n          v_new[0]  = h_reg[0];\n          v_new[1]  = h_reg[1];\n          v_new[2]  = h_reg[2];\n          v_new[3]  = h_reg[3];\n          v_new[4]  = h_reg[4];\n          v_new[5]  = h_reg[5];\n          v_new[6]  = h_reg[6];\n          v_new[7]  = h_reg[7];\n          v_new[8]  = IV0;\n          v_new[9]  = IV1;\n          v_new[10] = IV2;\n          v_new[11] = IV3;\n          v_new[12] = t0_reg ^ IV4;\n          v_new[13] = t1_reg ^ IV5;\n\n          if (last_reg) begin\n            v_new[14] = ~IV6;\n          end else begin\n            v_new[14] = IV6;\n          end\n\n          v_new[15] = IV7;\n          v_we = 1;\n        end\n\n      if (update_v)\n        begin\n          v_we = 1;\n\n          if (G_mode == G_ROW) begin\n            // Row updates.\n            G0_a      = v_reg[0];\n            G0_b      = v_reg[4];\n            G0_c      = v_reg[8];\n            G0_d      = v_reg[12];\n            v_new[0]  = G0_a_prim;\n            v_new[4]  = G0_b_prim;\n            v_new[8]  = G0_c_prim;\n            v_new[12] = G0_d_prim;\n\n            G1_a      = v_reg[1];\n            G1_b      = v_reg[5];\n            G1_c      = v_reg[9];\n            G1_d      = v_reg[13];\n            v_new[1]  = G1_a_prim;\n            v_new[5]  = G1_b_prim;\n            v_new[9]  = G1_c_prim;\n            v_new[13] = G1_d_prim;\n\n            G2_a      = v_reg[2];\n            G2_b      = v_reg[6];\n            G2_c      = v_reg[10];\n            G2_d      = v_reg[14];\n            v_new[2]  = G2_a_prim;\n            v_new[6]  = G2_b_prim;\n            v_new[10] = G2_c_prim;\n            v_new[14] = G2_d_prim;\n\n            G3_a      = v_reg[3];\n            G3_b      = v_reg[7];\n            G3_c      = v_reg[11];\n            G3_d      = v_reg[15];\n            v_new[3]  = G3_a_prim;\n            v_new[7]  = G3_b_prim;\n            v_new[11] = G3_c_prim;\n            v_new[15] = G3_d_prim;\n          end\n          else begin\n            // Diagonal updates.\n            G0_a      = v_reg[0];\n            G0_b      = v_reg[5];\n            G0_c      = v_reg[10];\n            G0_d      = v_reg[15];\n            v_new[0]  = G0_a_prim;\n            v_new[5]  = G0_b_prim;\n            v_new[10] = G0_c_prim;\n            v_new[15] = G0_d_prim;\n\n            G1_a      = v_reg[1];\n            G1_b      = v_reg[6];\n            G1_c      = v_reg[11];\n            G1_d      = v_reg[12];\n            v_new[1]  = G1_a_prim;\n            v_new[6]  = G1_b_prim;\n            v_new[11] = G1_c_prim;\n            v_new[12] = G1_d_prim;\n\n            G2_a      = v_reg[2];\n            G2_b      = v_reg[7];\n            G2_c      = v_reg[8];\n            G2_d      = v_reg[13];\n            v_new[2]  = G2_a_prim;\n            v_new[7]  = G2_b_prim;\n            v_new[8]  = G2_c_prim;\n            v_new[13] = G2_d_prim;\n\n            G3_a      = v_reg[3];\n            G3_b      = v_reg[4];\n            G3_c      = v_reg[9];\n            G3_d      = v_reg[14];\n            v_new[3]  = G3_a_prim;\n            v_new[4]  = G3_b_prim;\n            v_new[9]  = G3_c_prim;\n            v_new[14] = G3_d_prim;\n          end\n        end // if (update_v)\n    end // compress_logic\n\n\n  //----------------------------------------------------------------\n  // t_ctr\n  // Update logic for the length counter t, a monotonically\n  // increasing counter with reset.\n  //----------------------------------------------------------------\n  always @*\n    begin : t_ctr\n      t0_new = 32'h0;\n      t0_we  = 1'h0;\n      t1_new = 32'h0;\n      t1_we  = 1'h0;\n\n      if (t_ctr_rst) begin\n        t0_new = 32'h0;\n        t0_we  = 1'h1;\n        t1_new = 32'h0;\n        t1_we  = 1'h1;\n      end\n\n      if (t_ctr_inc) begin\n        t0_we = 1'h1;\n\n        if (last_new) begin\n          t0_new = t0_reg + {25'h0, blocklen};\n        end else begin\n          t0_new = t0_reg + {25'h0, BLOCK_BYTES};\n        end\n\n        if (t0_new < t0_reg) begin\n          t1_new = t1_reg + 1'h1;\n          t1_we  = 1'h1;\n        end\n      end\n    end // t_ctr\n\n\n  //----------------------------------------------------------------\n  // round_ctr\n  // Update logic for the round counter, a monotonically\n  // increasing counter with reset.\n  //----------------------------------------------------------------\n  always @*\n    begin : round_ctr\n      round_ctr_new = 4'h0;\n      round_ctr_we  = 1'h0;\n\n      if (round_ctr_rst)\n        begin\n          round_ctr_new = 4'h0;\n          round_ctr_we  = 1'h1;\n        end\n\n      if (round_ctr_inc)\n        begin\n          round_ctr_new = round_ctr_reg + 1'b1;\n          round_ctr_we  = 1'h1;\n        end\n    end // round_ctr\n\n\n  //----------------------------------------------------------------\n  // blake2s_ctrl\n  //----------------------------------------------------------------\n  always @*\n    begin : blake2s_ctrl\n      init_state         = 1'h0;\n      update_state       = 1'h0;\n      init_v             = 1'h0;\n      update_v           = 1'h0;\n      load_m             = 1'h0;\n      G_mode             = G_ROW;\n      round_ctr_inc      = 1'h0;\n      round_ctr_rst      = 1'h0;\n      t_ctr_inc          = 1'h0;\n      t_ctr_rst          = 1'h0;\n      last_new           = 1'h0;\n      last_we            = 1'h0;\n      ready_new          = 1'h0;\n      ready_we           = 1'h0;\n      blake2s_ctrl_new   = CTRL_IDLE;\n      blake2s_ctrl_we    = 1'h0;\n\n\n      case (blake2s_ctrl_reg)\n        CTRL_IDLE: begin\n          if (init) begin\n            last_new         = 1'h0;\n            last_we          = 1'h1;\n            init_state       = 1'h1;\n            t_ctr_rst        = 1'h1;\n            ready_new        = 1'h0;\n            ready_we         = 1'h1;\n            blake2s_ctrl_new = CTRL_FINISH;\n            blake2s_ctrl_we  = 1'h1;\n          end\n\n          if (update) begin\n            if (blocklen == BLOCK_BYTES) begin\n              load_m           = 1'h1;\n              t_ctr_inc        = 1'h1;\n              ready_new        = 1'h0;\n              ready_we         = 1'h1;\n              blake2s_ctrl_new = CTRL_INIT_ROUND;\n              blake2s_ctrl_we  = 1'h1;\n            end\n          end\n\n          if (finish) begin\n            load_m           = 1'h1;\n            t_ctr_inc        = 1'h1;\n            last_new         = 1'h1;\n            last_we          = 1'h1;\n            ready_new        = 1'h0;\n            ready_we         = 1'h1;\n            blake2s_ctrl_new = CTRL_INIT_ROUND;\n            blake2s_ctrl_we  = 1'h1;\n          end\n        end\n\n\n        CTRL_INIT_ROUND: begin\n          init_v           = 1'h1;\n          round_ctr_rst    = 1'h1;\n          blake2s_ctrl_new = CTRL_G_ROW;\n          blake2s_ctrl_we  = 1'h1;\n        end\n\n\n        CTRL_G_ROW: begin\n          G_mode           = G_ROW;\n          update_v         = 1'h1;\n          blake2s_ctrl_new = CTRL_G_DIAGONAL;\n          blake2s_ctrl_we  = 1'h1;\n        end\n\n\n        CTRL_G_DIAGONAL: begin\n          G_mode           = G_DIAGONAL;\n          update_v         = 1'h1;\n          round_ctr_inc    = 1'h1;\n          if (round_ctr_reg == (NUM_ROUNDS - 1)) begin\n            blake2s_ctrl_new = CTRL_COMP_DONE;\n            blake2s_ctrl_we  = 1'h1;\n          end\n          else begin\n            blake2s_ctrl_new = CTRL_G_ROW;\n            blake2s_ctrl_we  = 1'h1;\n          end\n        end\n\n\n        CTRL_COMP_DONE: begin\n          last_new           = 1'h0;\n          last_we            = 1'h1;\n          update_state       = 1'h1;\n          blake2s_ctrl_new   = CTRL_FINISH;\n          blake2s_ctrl_we    = 1'h1;\n        end\n\n\n        CTRL_FINISH: begin\n          ready_new        = 1'h1;\n          ready_we         = 1'h1;\n          blake2s_ctrl_new = CTRL_IDLE;\n          blake2s_ctrl_we  = 1'h1;\n        end\n\n\n        default: begin end\n      endcase // case (blake2s_ctrl_reg)\n    end // blake2s_ctrl\nendmodule // blake2s_core\n\n//======================================================================\n// EOF blake2s_core.v\n//======================================================================", "rtl/blake2s_m_select.v": "//======================================================================\n//\n// blake2s_m_select.v\n// ------------------\n// Verilog 2001 implementation of the message word selection in the\n// blake2 hash function core. Based on the given round and mode, we\n// extract the indices for the eight m words to select.\n// The words are then selected and returned. This is basically a\n// mux based implementation of the permutation table in combination\n// with the actual word selection.\n//\n//\n// Note that we use the mode to signal which indices to select\n// for a given round. This is because we don't do 8 G-functions\n// in a single cycle.\n//\n//\n// Author: Joachim Str\u00f6mbergson\n// Copyright (c) 2018, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\nmodule blake2s_m_select(\n                        input wire           clk,\n                        input wire           reset_n,\n\n                        input wire           load,\n                        input wire [511 : 0] m,\n\n                        input wire [3 : 0]   round,\n                        input wire           mode,\n\n                        output wire [31 : 0] G0_m0,\n                        output wire [31 : 0] G0_m1,\n                        output wire [31 : 0] G1_m0,\n                        output wire [31 : 0] G1_m1,\n                        output wire [31 : 0] G2_m0,\n                        output wire [31 : 0] G2_m1,\n                        output wire [31 : 0] G3_m0,\n                        output wire [31 : 0] G3_m1\n                       );\n\n\n  //----------------------------------------------------------------\n  // regs.\n  //----------------------------------------------------------------\n  reg [31 : 0] m_mem [0 : 15];\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg [3 : 0] i_G0_m0;\n  reg [3 : 0] i_G0_m1;\n  reg [3 : 0] i_G1_m0;\n  reg [3 : 0] i_G1_m1;\n  reg [3 : 0] i_G2_m0;\n  reg [3 : 0] i_G2_m1;\n  reg [3 : 0] i_G3_m0;\n  reg [3 : 0] i_G3_m1;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports.\n  //----------------------------------------------------------------\n  // Eight parallel, muxes that extract the message block words.\n  assign G0_m0 = m_mem[i_G0_m0];\n  assign G0_m1 = m_mem[i_G0_m1];\n  assign G1_m0 = m_mem[i_G1_m0];\n  assign G1_m1 = m_mem[i_G1_m1];\n  assign G2_m0 = m_mem[i_G2_m0];\n  assign G2_m1 = m_mem[i_G2_m1];\n  assign G3_m0 = m_mem[i_G3_m0];\n  assign G3_m1 = m_mem[i_G3_m1];\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //\n  // Update functionality for all registers in the core.\n  // All registers are positive edge triggered with synchronous,\n  // active low reset. All registers have write enable.\n  //----------------------------------------------------------------\n  always @ (posedge clk)\n    begin : reg_update\n      integer i;\n\n      if (!reset_n)\n        begin\n          for (i = 0 ; i < 16 ; i = i + 1)\n            m_mem[i] <= 32'h0;\n        end\n      else\n        begin\n          if (load)\n            begin\n              // Big to little endian conversion during register load.\n              m_mem[00] <= {m[0487 : 0480], m[0495 : 0488], m[0503 : 0496], m[0511 : 0504]};\n              m_mem[01] <= {m[0455 : 0448], m[0463 : 0456], m[0471 : 0464], m[0479 : 0472]};\n              m_mem[02] <= {m[0423 : 0416], m[0431 : 0424], m[0439 : 0432], m[0447 : 0440]};\n              m_mem[03] <= {m[0391 : 0384], m[0399 : 0392], m[0407 : 0400], m[0415 : 0408]};\n              m_mem[04] <= {m[0359 : 0352], m[0367 : 0360], m[0375 : 0368], m[0383 : 0376]};\n              m_mem[05] <= {m[0327 : 0320], m[0335 : 0328], m[0343 : 0336], m[0351 : 0344]};\n              m_mem[06] <= {m[0295 : 0288], m[0303 : 0296], m[0311 : 0304], m[0319 : 0312]};\n              m_mem[07] <= {m[0263 : 0256], m[0271 : 0264], m[0279 : 0272], m[0287 : 0280]};\n              m_mem[08] <= {m[0231 : 0224], m[0239 : 0232], m[0247 : 0240], m[0255 : 0248]};\n              m_mem[09] <= {m[0199 : 0192], m[0207 : 0200], m[0215 : 0208], m[0223 : 0216]};\n              m_mem[10] <= {m[0167 : 0160], m[0175 : 0168], m[0183 : 0176], m[0191 : 0184]};\n              m_mem[11] <= {m[0135 : 0128], m[0143 : 0136], m[0151 : 0144], m[0159 : 0152]};\n              m_mem[12] <= {m[0103 : 0096], m[0111 : 0104], m[0119 : 0112], m[0127 : 0120]};\n              m_mem[13] <= {m[0071 : 0064], m[0079 : 0072], m[0087 : 0080], m[0095 : 0088]};\n              m_mem[14] <= {m[0039 : 0032], m[0047 : 0040], m[0055 : 0048], m[0063 : 0056]};\n              m_mem[15] <= {m[0007 : 0000], m[0015 : 0008], m[0023 : 0016], m[0031 : 0024]};\n            end\n        end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // get_indices\n  //\n  // Get the indices from the permutation table given the\n  // round and the G function mode. This is the SIGMA table.\n  //----------------------------------------------------------------\n  always @*\n    begin : get_indices\n      i_G0_m0 = 4'd0;\n      i_G0_m1 = 4'd0;\n      i_G1_m0 = 4'd0;\n      i_G1_m1 = 4'd0;\n      i_G2_m0 = 4'd0;\n      i_G2_m1 = 4'd0;\n      i_G3_m0 = 4'd0;\n      i_G3_m1 = 4'd0;\n\n      case ({round, mode})\n        0: begin\n          i_G0_m0 = 4'd00;\n          i_G0_m1 = 4'd01;\n          i_G1_m0 = 4'd02;\n          i_G1_m1 = 4'd03;\n          i_G2_m0 = 4'd04;\n          i_G2_m1 = 4'd05;\n          i_G3_m0 = 4'd06;\n          i_G3_m1 = 4'd07;\n        end\n\n        1: begin\n          i_G0_m0 = 4'd08;\n          i_G0_m1 = 4'd09;\n          i_G1_m0 = 4'd10;\n          i_G1_m1 = 4'd11;\n          i_G2_m0 = 4'd12;\n          i_G2_m1 = 4'd13;\n          i_G3_m0 = 4'd14;\n          i_G3_m1 = 4'd15;\n        end\n\n        2: begin\n          i_G0_m0 = 4'd14;\n          i_G0_m1 = 4'd10;\n          i_G1_m0 = 4'd04;\n          i_G1_m1 = 4'd08;\n          i_G2_m0 = 4'd09;\n          i_G2_m1 = 4'd15;\n          i_G3_m0 = 4'd13;\n          i_G3_m1 = 4'd06;\n        end\n\n        3: begin\n          i_G0_m0 = 4'd01;\n          i_G0_m1 = 4'd12;\n          i_G1_m0 = 4'd00;\n          i_G1_m1 = 4'd02;\n          i_G2_m0 = 4'd11;\n          i_G2_m1 = 4'd07;\n          i_G3_m0 = 4'd05;\n          i_G3_m1 = 4'd03;\n        end\n\n        4: begin\n          i_G0_m0 = 4'd11;\n          i_G0_m1 = 4'd08;\n          i_G1_m0 = 4'd12;\n          i_G1_m1 = 4'd00;\n          i_G2_m0 = 4'd05;\n          i_G2_m1 = 4'd02;\n          i_G3_m0 = 4'd15;\n          i_G3_m1 = 4'd13;\n        end\n\n        5: begin\n          i_G0_m0 = 4'd10;\n          i_G0_m1 = 4'd14;\n          i_G1_m0 = 4'd03;\n          i_G1_m1 = 4'd06;\n          i_G2_m0 = 4'd07;\n          i_G2_m1 = 4'd01;\n          i_G3_m0 = 4'd09;\n          i_G3_m1 = 4'd04;\n        end\n\n        6: begin\n          i_G0_m0 = 4'd07;\n          i_G0_m1 = 4'd09;\n          i_G1_m0 = 4'd03;\n          i_G1_m1 = 4'd01;\n          i_G2_m0 = 4'd13;\n          i_G2_m1 = 4'd12;\n          i_G3_m0 = 4'd11;\n          i_G3_m1 = 4'd14;\n        end\n\n        7: begin\n          i_G0_m0 = 4'd02;\n          i_G0_m1 = 4'd06;\n          i_G1_m0 = 4'd05;\n          i_G1_m1 = 4'd10;\n          i_G2_m0 = 4'd04;\n          i_G2_m1 = 4'd00;\n          i_G3_m0 = 4'd15;\n          i_G3_m1 = 4'd08;\n        end\n\n        8: begin\n          i_G0_m0 = 4'd09;\n          i_G0_m1 = 4'd00;\n          i_G1_m0 = 4'd05;\n          i_G1_m1 = 4'd07;\n          i_G2_m0 = 4'd02;\n          i_G2_m1 = 4'd04;\n          i_G3_m0 = 4'd10;\n          i_G3_m1 = 4'd15;\n        end\n\n        9: begin\n          i_G0_m0 = 4'd14;\n          i_G0_m1 = 4'd01;\n          i_G1_m0 = 4'd11;\n          i_G1_m1 = 4'd12;\n          i_G2_m0 = 4'd06;\n          i_G2_m1 = 4'd08;\n          i_G3_m0 = 4'd03;\n          i_G3_m1 = 4'd13;\n        end\n\n        10: begin\n          i_G0_m0 = 4'd02;\n          i_G0_m1 = 4'd12;\n          i_G1_m0 = 4'd06;\n          i_G1_m1 = 4'd10;\n          i_G2_m0 = 4'd00;\n          i_G2_m1 = 4'd11;\n          i_G3_m0 = 4'd08;\n          i_G3_m1 = 4'd03;\n        end\n\n        11: begin\n          i_G0_m0 = 4'd04;\n          i_G0_m1 = 4'd13;\n          i_G1_m0 = 4'd07;\n          i_G1_m1 = 4'd05;\n          i_G2_m0 = 4'd15;\n          i_G2_m1 = 4'd14;\n          i_G3_m0 = 4'd01;\n          i_G3_m1 = 4'd09;\n        end\n\n        12: begin\n          i_G0_m0 = 4'd12;\n          i_G0_m1 = 4'd05;\n          i_G1_m0 = 4'd01;\n          i_G1_m1 = 4'd15;\n          i_G2_m0 = 4'd14;\n          i_G2_m1 = 4'd13;\n          i_G3_m0 = 4'd04;\n          i_G3_m1 = 4'd10;\n        end\n\n        13: begin\n          i_G0_m0 = 4'd00;\n          i_G0_m1 = 4'd07;\n          i_G1_m0 = 4'd06;\n          i_G1_m1 = 4'd03;\n          i_G2_m0 = 4'd09;\n          i_G2_m1 = 4'd02;\n          i_G3_m0 = 4'd08;\n          i_G3_m1 = 4'd11;\n        end\n\n        14: begin\n          i_G0_m0 = 4'd13;\n          i_G0_m1 = 4'd11;\n          i_G1_m0 = 4'd07;\n          i_G1_m1 = 4'd14;\n          i_G2_m0 = 4'd12;\n          i_G2_m1 = 4'd01;\n          i_G3_m0 = 4'd03;\n          i_G3_m1 = 4'd09;\n        end\n\n        15: begin\n          i_G0_m0 = 4'd05;\n          i_G0_m1 = 4'd00;\n          i_G1_m0 = 4'd15;\n          i_G1_m1 = 4'd04;\n          i_G2_m0 = 4'd08;\n          i_G2_m1 = 4'd06;\n          i_G3_m0 = 4'd02;\n          i_G3_m1 = 4'd10;\n        end\n\n        16: begin\n          i_G0_m0 = 4'd06;\n          i_G0_m1 = 4'd15;\n          i_G1_m0 = 4'd14;\n          i_G1_m1 = 4'd09;\n          i_G2_m0 = 4'd11;\n          i_G2_m1 = 4'd03;\n          i_G3_m0 = 4'd00;\n          i_G3_m1 = 4'd08;\n        end\n\n        17: begin\n          i_G0_m0 = 4'd12;\n          i_G0_m1 = 4'd02;\n          i_G1_m0 = 4'd13;\n          i_G1_m1 = 4'd07;\n          i_G2_m0 = 4'd01;\n          i_G2_m1 = 4'd04;\n          i_G3_m0 = 4'd10;\n          i_G3_m1 = 4'd05;\n        end\n\n        18: begin\n          i_G0_m0 = 4'd10;\n          i_G0_m1 = 4'd02;\n          i_G1_m0 = 4'd08;\n          i_G1_m1 = 4'd04;\n          i_G2_m0 = 4'd07;\n          i_G2_m1 = 4'd06;\n          i_G3_m0 = 4'd01;\n          i_G3_m1 = 4'd05;\n        end\n\n        19: begin\n          i_G0_m0 = 4'd15;\n          i_G0_m1 = 4'd11;\n          i_G1_m0 = 4'd09;\n          i_G1_m1 = 4'd14;\n          i_G2_m0 = 4'd03;\n          i_G2_m1 = 4'd12;\n          i_G3_m0 = 4'd13;\n          i_G3_m1 = 4'd00;\n        end\n\n        default: begin end\n      endcase // case ({round, mode})\n    end\n\nendmodule // blake2s_m_select\n\n//======================================================================\n// EOF blake2s_m_select.v\n//======================================================================", "verif/blake2s_core_state_liveness_check.sv": "module blake2s_core_state_liveness_check (\n                    input wire            clk,\n                    input wire            reset_n,\n\n                    input wire            init,\n                    input wire            update,\n                    input wire            finish,\n\n                    input wire [511 : 0]  block,\n                    input wire [6 : 0]    blocklen,\n\n                    output wire [255 : 0] digest,\n                    output wire           ready\n                  );\n\n    blake2s_core dut(\n        .clk(clk),\n        .reset_n(reset_n),\n        .init(init),\n        .update(update),\n        .finish(finish),\n        .block(block),\n        .blocklen(blocklen),\n        .digest(digest),\n        .ready(ready)\n    );\n\nendmodule : blake2s_core_state_liveness_check"}, "patch": {"verif/blake2s_core_state_liveness_check.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    image: verification_image\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n      - ../../rundir:/code/rundir:rw\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/verif/blake2s_core_state_liveness_check.sv /code/rtl/blake2s_m_select.v /code/rtl/blake2s_G.v /code/rtl/blake2s_core.v\nTOPLEVEL        = blake2s_core_state_liveness_check\nMODULE          = test_blake2s_core\nPYTHONPATH      = /src\nHASH            = dcd71f8f6113459a95644e44bd2633ddf324f6d9", "src/coverage.py": "from cocotb.runner import get_runner\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_clear():\n    covt_report_file=\"/code/rundir/coverage.log\"\n    if os.path.isfile(covt_report_file):\n        os.remove(covt_report_file)\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "\nfrom cocotb.binary import BinaryValue\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\n\nCLK_HALF_PERIOD = 1\nCLK_PERIOD = CLK_HALF_PERIOD * 2\nCLK_TIME_UNIT = 'ns'\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def init_sim(dut):\n    dut.reset_n.value = 1\n    dut.init.value = 0\n    dut.update.value = 0\n    dut.finish.value = 0\n    dut.block.value = 0\n    dut.blocklen.value = 0\n\nasync def reset_dut(dut):\n    dut.reset_n.value = 0\n    await Timer(2 * CLK_PERIOD, units=CLK_TIME_UNIT)\n    dut.reset_n.value = 1\n    await Timer(2 * CLK_PERIOD, units=CLK_TIME_UNIT)\n\nasync def wait_ready(dut):\n    while dut.ready.value.integer != 1:\n        await FallingEdge(dut.clk)\n\nasync def one_block_message_test(\n        dut, block_len: BinaryValue, block: BinaryValue, expected: BinaryValue):\n\n    dut.init.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.init.value = 0\n    await wait_ready(dut)\n    await FallingEdge(dut.clk) # Not required\n\n    dut.blocklen.value = block_len\n    dut.block.value = block\n    dut.finish.value = 1\n    await FallingEdge(dut.clk)\n\n    dut.finish.value = 0\n    await wait_ready(dut)\n    await FallingEdge(dut.clk) # Not required\n\n    assert dut.digest.value == expected, \"didn't get the expected digest output\"\n\nasync def multiple_block_message_test(\n        dut, block_lengths: list[BinaryValue], blocks: list[BinaryValue], expected: BinaryValue):\n\n    assert len(block_lengths) == len(blocks), \"argument lists size mismatch\"\n    assert len(blocks) > 0, \"cannot process an empty list\"\n\n    block_index = 0\n    while block_index < len(blocks) - 1:\n        dut.init.value = 1\n        await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n        dut.init.value = 0\n        await wait_ready(dut)\n        await FallingEdge(dut.clk) # Not required\n\n        dut.blocklen.value = block_lengths[block_index]\n        dut.block.value = blocks[block_index]\n        dut.update.value = 1\n        await FallingEdge(dut.clk)\n\n        dut.update.value = 0\n        await wait_ready(dut)\n        await FallingEdge(dut.clk) # Not required\n\n        block_index += 1\n\n    # Final part\n    dut.blocklen.value = block_lengths[block_index]\n    dut.block.value = blocks[block_index]\n    dut.finish.value = 1\n    await FallingEdge(dut.clk)\n\n    dut.finish.value = 0\n    await wait_ready(dut)\n    await FallingEdge(dut.clk) # Not required\n\n    assert dut.digest.value == expected, \"didn't get the expected digest output\"\n", "src/test_blake2s_core.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.binary import BinaryValue\nimport harness_library as hrs_lb\n\n\n@cocotb.test()\nasync def test_dut(dut):\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_dut...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    # Empty message test (Test Case 0):\n    empty_expected_digest = int('69217a3079908094e11121d042354a7c1f55b6482ca1a51e1b250dfd1ed0eef9', 16)\n    empty_block_bin = BinaryValue(0, 512, False)\n    empty_block_len_bin = BinaryValue(0, 7, False)\n    empty_expected_digest_bin = BinaryValue(empty_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, empty_block_len_bin, empty_block_bin, empty_expected_digest_bin)\n\n    # Test Case 1:\n    # tb_block = 512'h00010203_04050607_08090a0b_0c0d0e0f_10111213_14151617_18191a1b_1c1d1e1f_20212223_24252627_28292a2b_2c2d2e2f_30313233_34353637_38393a3b_3c3d3e3f;\n    # tb_blocklen = 7'h40;\n    # dut.digest == 256'h56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e\n    tc1_block = int('000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f', 16)\n    tc1_block_len = int('40', 16)\n    tc1_expected_digest = int('56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e', 16)\n    tc1_block_bin = BinaryValue(tc1_block, 512, False)\n    tc1_block_len_bin = BinaryValue(tc1_block_len, 7, False)\n    tc1_expected_digest_bin = BinaryValue(tc1_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, tc1_block_len_bin, tc1_block_bin, tc1_expected_digest_bin)\n\n    # Test Case 2:\n    # tb_block = 512'h00010203_04050607_08090a0b_0c0d0e0f_10111213_14151617_18191a1b_1c1d1e1f_20212223_24252627_28292a2b_2c2d2e2f_30313233_34353637_38393a3b_3c3d3e3f;\n    # tb_blocklen = 7'h40;\n    # tb_block = {8'h40, {63{8'h00}}};\n    # tb_blocklen = 7'h01;\n    tc2_block0 = int('00010203_04050607_08090a0b_0c0d0e0f_10111213_14151617_18191a1b_1c1d1e1f_20212223_24252627_28292a2b_2c2d2e2f_30313233_34353637_38393a3b_3c3d3e3f'.replace('_',''), 16)\n    tc2_block0_len = int('40', 16)\n    tc2_block1 = int('40' + (63 * '00'), 16)\n    tc2_block1_len = 1\n    tc2_expected_digest = int('1b53ee94aaf34e4b159d48de352c7f0661d0a40edff95a0b1639b4090e974472', 16)\n    tc2_block_bin = [\n        BinaryValue(tc2_block0, 512, False),\n        BinaryValue(tc2_block1, 512, False)\n    ]\n    tc2_block_len_bin = [\n        BinaryValue(tc2_block0_len, 7, False),\n        BinaryValue(tc2_block1_len, 7, False)\n    ]\n    tc2_expected_digest_bin = BinaryValue(tc2_expected_digest, 256, False)\n    await hrs_lb.multiple_block_message_test(dut, tc2_block_len_bin, tc2_block_bin, tc2_expected_digest_bin)\n\n    # Test Case 3:\n    # tb_block = {32'h61626300, {15{32'h0}}};\n    # tb_blocklen = 7'h03;\n    # tb_digest == 256'h508c5e8c327c14e2_e1a72ba34eeb452f_37458b209ed63a29_4d999b4c86675982\n    tc3_block = int('61626300' + (15 * 8 * '0'), 16)\n    tc3_block_len = int('03', 16)\n    tc3_expected_digest = int('508c5e8c327c14e2_e1a72ba34eeb452f_37458b209ed63a29_4d999b4c86675982'.replace('_', ''), 16)\n    tc3_block_bin = BinaryValue(tc3_block, 512, False)\n    tc3_block_len_bin = BinaryValue(tc3_block_len, 7, False)\n    tc3_expected_digest_bin = BinaryValue(tc3_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, tc3_block_len_bin, tc3_block_bin, tc3_expected_digest_bin)\n\n    cocotb.log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nimport pytest\nimport coverage\nimport random\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef call_runner():\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.covt_report_clear()\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter={}\n        )\n        coverage.coverage_report(\"assertion\")\n        coverage.covt_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n    # Run the simulation\n    call_runner()\n"}}
{"id": "cvdp_agentic_crypto_0004", "categories": ["cid014", "hard"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYour task is to modify the existing RTL design based on the provided specifications to improve Quality of Results (QoR) such as timing, area, or power efficiency. Ensure the modifications are verified against the provided testbench and meet the updated specifications.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Develop assertion properties to verify the sanity of the `blake2s_core` module. These assertions must ensure that the module behaves as expected under its intended usage.\n\nThe assertion properties must cover the following behaviors:\n\n1. The module becomes ready after reset.  \n2. The `CTRL_IDLE` state indicates that the module is ready.  \n3. The `init` operation takes two cycles to complete, after which the module is ready again.  \n\nSince we are verifying the expected behavior under the intended usage of the design, use helper assumptions alongside the assertion properties to constrain and validate correct usage patterns:\n\n1. The `init` operation must not be triggered alongside `update` or `finish`.  \n2. An operation is considered ongoing once the module becomes ready and one of `init`, `update`, or `finish` is activated. The module must remain not ready until the operation completes. No new operation may be started while the module is not ready.\n\nThe following implementation requirements must be met:\n\n- The assertion properties must be placed in a separate module named `blake2s_core_reset_and_ready_sanity_check`, which instantiates `blake2s_core` as the Device Under Test (DUT).  \n- The properties must reference internal DUT signals directly for verification.\n", "context": {"rtl/blake2s_G.v": "//======================================================================\n//\n// blake2s_G.v\n// -----------\n// Verilog 2001 implementation of the G function in the\n// blake2s hash function core. This is pure combinational logic in a\n// separade module to allow us to build versions  with 1, 2, 4\n// and even 8 parallel compression functions.\n//\n//\n// Author: Joachim Str\u00f6mbergson\n// Copyright (c) 2018, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\nmodule blake2s_G(\n                 input wire [31 : 0]  a,\n                 input wire [31 : 0]  b,\n                 input wire [31 : 0]  c,\n                 input wire [31 : 0]  d,\n                 input wire [31 : 0]  m0,\n                 input wire [31 : 0]  m1,\n\n                 output wire [31 : 0] a_prim,\n                 output wire [31 : 0] b_prim,\n                 output wire [31 : 0] c_prim,\n                 output wire [31 : 0] d_prim\n                );\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg [31 : 0] a1;\n  reg [31 : 0] a2;\n  reg [31 : 0] b1;\n  reg [31 : 0] b2;\n  reg [31 : 0] b3;\n  reg [31 : 0] b4;\n  reg [31 : 0] c1;\n  reg [31 : 0] c2;\n  reg [31 : 0] d1;\n  reg [31 : 0] d2;\n  reg [31 : 0] d3;\n  reg [31 : 0] d4;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports.\n  //----------------------------------------------------------------\n  assign a_prim = a2;\n  assign b_prim = b4;\n  assign c_prim = c2;\n  assign d_prim = d4;\n\n\n  //----------------------------------------------------------------\n  // G_function\n  //----------------------------------------------------------------\n  always @*\n    begin : G_function\n      a1 = a + b + m0;\n\n      d1 = d ^ a1;\n      d2 = {d1[15 : 0], d1[31 : 16]};\n\n      c1 = c + d2;\n\n      b1 = b ^ c1;\n      b2 = {b1[11 : 0], b1[31 : 12]};\n\n      a2 = a1 + b2 + m1;\n\n      d3 = d2 ^ a2;\n      d4 = {d3[7 : 0], d3[31 : 8]};\n\n      c2 = c1 + d4;\n\n      b3 = b2 ^ c2;\n      b4 = {b3[6 : 0], b3[31 : 7]};\n    end // G_function\nendmodule // blake2s_G\n\n//======================================================================\n// EOF blake2s_G.v\n//======================================================================", "rtl/blake2s_core.v": "//======================================================================\n//\n// blake2s_core.v\n// --------------\n// Verilog 2001 implementation of the hash function blake2s.\n// This is the internal core with wide interfaces.\n//\n//\n// Author: Joachim Str\u00f6mbergson\n// Copyright (c) 2018, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\nmodule blake2s_core(\n                    input wire            clk,\n                    input wire            reset_n,\n\n                    input wire            init,\n                    input wire            update,\n                    input wire            finish,\n\n                    input wire [511 : 0]  block,\n                    input wire [6 : 0]    blocklen,\n\n                    output wire [255 : 0] digest,\n                    output wire           ready\n                  );\n\n\n  //----------------------------------------------------------------\n  // Parameter block.\n  // See BLAKE2 paper and RFC 7693 for definition.\n  // Chapter 2.8 in https://blake2.net/blake2.pdf\n  // Section 2.5 in https://tools.ietf.org/html/rfc7693\n  //----------------------------------------------------------------\n  // The digest length in bytes. Minimum: 1, Maximum: 32\n  localparam [7 : 0]  DIGEST_LENGTH   = 8'd32;\n  localparam [7 : 0]  KEY_LENGTH      = 8'd0;\n  localparam [7 : 0]  FANOUT          = 8'd1;\n  localparam [7 : 0]  DEPTH           = 8'd01;\n  localparam [31 : 0] LEAF_LENGTH     = 32'd0;\n  localparam [47 : 0] NODE_OFFSET     = 48'd0;\n  localparam [7 : 0]  NODE_DEPTH      = 8'd0;\n  localparam [7 : 0]  INNER_LENGTH    = 8'd0;\n  localparam [63 : 0] SALT            = 64'h0;\n  localparam [63 : 0] PERSONALIZATION = 64'h0;\n\n  wire [255 : 0] parameter_block = {PERSONALIZATION, SALT, INNER_LENGTH,\n                                    NODE_DEPTH, NODE_OFFSET, LEAF_LENGTH,\n                                    DEPTH, FANOUT, KEY_LENGTH, DIGEST_LENGTH};\n\n\n  //----------------------------------------------------------------\n  // Internal constant definitions.\n  //----------------------------------------------------------------\n  localparam NUM_ROUNDS  = 10;\n  localparam BLOCK_BYTES = 7'd64;\n\n  // G function modes.\n  localparam G_ROW      = 1'h0;\n  localparam G_DIAGONAL = 1'h1;\n\n  // Initial vectors.\n  localparam IV0 = 32'h6a09e667;\n  localparam IV1 = 32'hbb67ae85;\n  localparam IV2 = 32'h3c6ef372;\n  localparam IV3 = 32'ha54ff53a;\n  localparam IV4 = 32'h510e527f;\n  localparam IV5 = 32'h9b05688c;\n  localparam IV6 = 32'h1f83d9ab;\n  localparam IV7 = 32'h5be0cd19;\n\n  // Control FSM state names.\n  localparam CTRL_IDLE       = 3'h0;\n  localparam CTRL_INIT_ROUND = 3'h1;\n  localparam CTRL_G_ROW      = 3'h2;\n  localparam CTRL_G_DIAGONAL = 3'h3;\n  localparam CTRL_COMP_DONE  = 3'h4;\n  localparam CTRL_FINISH     = 3'h5;\n\n\n  //----------------------------------------------------------------\n  // Registers including update variables and write enable.\n  //----------------------------------------------------------------\n  reg [31 : 0] h_reg [0 : 7];\n  reg [31 : 0] h_new [0 : 7];\n  reg          h_we;\n\n  reg [31 : 0] v_reg [0 : 15];\n  reg [31 : 0] v_new [0 : 15];\n  reg          v_we;\n  reg          init_v;\n  reg          update_v;\n\n  reg [3 : 0]  round_ctr_reg;\n  reg [3 : 0]  round_ctr_new;\n  reg          round_ctr_we;\n  reg          round_ctr_inc;\n  reg          round_ctr_rst;\n\n  reg [31 : 0] t0_reg;\n  reg [31 : 0] t0_new;\n  reg          t0_we;\n  reg [31 : 0] t1_reg;\n  reg [31 : 0] t1_new;\n  reg          t1_we;\n  reg          t_ctr_inc;\n  reg          t_ctr_rst;\n\n  reg          last_reg;\n  reg          last_new;\n  reg          last_we;\n\n  reg          ready_reg;\n  reg          ready_new;\n  reg          ready_we;\n\n  reg [2 : 0]  blake2s_ctrl_reg;\n  reg [2 : 0]  blake2s_ctrl_new;\n  reg          blake2s_ctrl_we;\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg init_state;\n  reg update_state;\n  reg load_m;\n  reg G_mode;\n\n  reg  [31 : 0] G0_a;\n  reg  [31 : 0] G0_b;\n  reg  [31 : 0] G0_c;\n  reg  [31 : 0] G0_d;\n  wire [31 : 0] G0_m0;\n  wire [31 : 0] G0_m1;\n  wire [31 : 0] G0_a_prim;\n  wire [31 : 0] G0_b_prim;\n  wire [31 : 0] G0_c_prim;\n  wire [31 : 0] G0_d_prim;\n\n  reg  [31 : 0] G1_a;\n  reg  [31 : 0] G1_b;\n  reg  [31 : 0] G1_c;\n  reg  [31 : 0] G1_d;\n  wire [31 : 0] G1_m0;\n  wire [31 : 0] G1_m1;\n  wire [31 : 0] G1_a_prim;\n  wire [31 : 0] G1_b_prim;\n  wire [31 : 0] G1_c_prim;\n  wire [31 : 0] G1_d_prim;\n\n  reg  [31 : 0] G2_a;\n  reg  [31 : 0] G2_b;\n  reg  [31 : 0] G2_c;\n  reg  [31 : 0] G2_d;\n  wire [31 : 0] G2_m0;\n  wire [31 : 0] G2_m1;\n  wire [31 : 0] G2_a_prim;\n  wire [31 : 0] G2_b_prim;\n  wire [31 : 0] G2_c_prim;\n  wire [31 : 0] G2_d_prim;\n\n  reg  [31 : 0] G3_a;\n  reg  [31 : 0] G3_b;\n  reg  [31 : 0] G3_c;\n  reg  [31 : 0] G3_d;\n  wire [31 : 0] G3_m0;\n  wire [31 : 0] G3_m1;\n  wire [31 : 0] G3_a_prim;\n  wire [31 : 0] G3_b_prim;\n  wire [31 : 0] G3_c_prim;\n  wire [31 : 0] G3_d_prim;\n\n\n  //----------------------------------------------------------------\n  // Module instantations.\n  //----------------------------------------------------------------\n  blake2s_m_select mselect(\n                           .clk(clk),\n                           .reset_n(reset_n),\n                           .load(load_m),\n                           .m(block),\n                           .round(round_ctr_reg),\n                           .mode(G_mode),\n                           .G0_m0(G0_m0),\n                           .G0_m1(G0_m1),\n                           .G1_m0(G1_m0),\n                           .G1_m1(G1_m1),\n                           .G2_m0(G2_m0),\n                           .G2_m1(G2_m1),\n                           .G3_m0(G3_m0),\n                           .G3_m1(G3_m1)\n                          );\n\n\n  blake2s_G G0(\n               .a(G0_a),\n               .b(G0_b),\n               .c(G0_c),\n               .d(G0_d),\n               .m0(G0_m0),\n               .m1(G0_m1),\n               .a_prim(G0_a_prim),\n               .b_prim(G0_b_prim),\n               .c_prim(G0_c_prim),\n               .d_prim(G0_d_prim)\n              );\n\n\n  blake2s_G G1(\n               .a(G1_a),\n               .b(G1_b),\n               .c(G1_c),\n               .d(G1_d),\n               .m0(G1_m0),\n               .m1(G1_m1),\n               .a_prim(G1_a_prim),\n               .b_prim(G1_b_prim),\n               .c_prim(G1_c_prim),\n               .d_prim(G1_d_prim)\n              );\n\n\n  blake2s_G G2(\n               .a(G2_a),\n               .b(G2_b),\n               .c(G2_c),\n               .d(G2_d),\n               .m0(G2_m0),\n               .m1(G2_m1),\n\n               .a_prim(G2_a_prim),\n               .b_prim(G2_b_prim),\n               .c_prim(G2_c_prim),\n               .d_prim(G2_d_prim)\n              );\n\n\n  blake2s_G G3(\n               .a(G3_a),\n               .b(G3_b),\n               .c(G3_c),\n               .d(G3_d),\n               .m0(G3_m0),\n               .m1(G3_m1),\n               .a_prim(G3_a_prim),\n               .b_prim(G3_b_prim),\n               .c_prim(G3_c_prim),\n               .d_prim(G3_d_prim)\n              );\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign digest = {h_reg[0][7 : 0], h_reg[0][15 : 8], h_reg[0][23 : 16], h_reg[0][31 : 24],\n                   h_reg[1][7 : 0], h_reg[1][15 : 8], h_reg[1][23 : 16], h_reg[1][31 : 24],\n                   h_reg[2][7 : 0], h_reg[2][15 : 8], h_reg[2][23 : 16], h_reg[2][31 : 24],\n                   h_reg[3][7 : 0], h_reg[3][15 : 8], h_reg[3][23 : 16], h_reg[3][31 : 24],\n                   h_reg[4][7 : 0], h_reg[4][15 : 8], h_reg[4][23 : 16], h_reg[4][31 : 24],\n                   h_reg[5][7 : 0], h_reg[5][15 : 8], h_reg[5][23 : 16], h_reg[5][31 : 24],\n                   h_reg[6][7 : 0], h_reg[6][15 : 8], h_reg[6][23 : 16], h_reg[6][31 : 24],\n                   h_reg[7][7 : 0], h_reg[7][15 : 8], h_reg[7][23 : 16], h_reg[7][31 : 24]};\n\n  assign ready = ready_reg;\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //----------------------------------------------------------------\n  always @ (posedge clk)\n    begin : reg_update\n      integer i;\n\n      if (!reset_n) begin\n        for (i = 0; i < 8; i = i + 1) begin\n          h_reg[i] <= 32'h0;\n        end\n\n        for (i = 0; i < 16; i = i + 1) begin\n          v_reg[i] <= 32'h0;\n        end\n\n        t0_reg           <= 32'h0;\n        t1_reg           <= 32'h0;\n        last_reg         <= 1'h0;\n        ready_reg        <= 1'h1;\n        round_ctr_reg    <= 4'h0;\n        blake2s_ctrl_reg <= CTRL_IDLE;\n      end\n      else begin\n        if (h_we) begin\n          for (i = 0; i < 8; i = i + 1) begin\n            h_reg[i] <= h_new[i];\n          end\n        end\n\n        if (v_we) begin\n          for (i = 0; i < 16; i = i + 1) begin\n            v_reg[i] <= v_new[i];\n          end\n        end\n\n        if (t0_we) begin\n          t0_reg <= t0_new;\n        end\n\n        if (t1_we) begin\n          t1_reg <= t1_new;\n        end\n\n        if (last_we) begin\n          last_reg <= last_new;\n        end\n\n        if (ready_we) begin\n          ready_reg <= ready_new;\n        end\n\n        if (round_ctr_we) begin\n          round_ctr_reg <= round_ctr_new;\n        end\n\n        if (blake2s_ctrl_we) begin\n          blake2s_ctrl_reg <= blake2s_ctrl_new;\n        end\n      end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // state_logic\n  //\n  // Logic for updating the hash state.\n  //----------------------------------------------------------------\n  always @*\n    begin : state_logic\n      integer i;\n\n      for (i = 0; i < 8; i = i + 1) begin\n        h_new[i] = 32'h0;\n      end\n      h_we   = 1'h0;\n\n      if (init_state) begin\n        h_new[0] = IV0 ^ parameter_block[31  :   0];\n        h_new[1] = IV1 ^ parameter_block[63  :  32];\n        h_new[2] = IV2 ^ parameter_block[95  :  64];\n        h_new[3] = IV3 ^ parameter_block[127 :  96];\n        h_new[4] = IV4 ^ parameter_block[159 : 128];\n        h_new[5] = IV5 ^ parameter_block[191 : 160];\n        h_new[6] = IV6 ^ parameter_block[223 : 192];\n        h_new[7] = IV7 ^ parameter_block[255 : 224];\n        h_we     = 1;\n      end\n\n      if (update_state) begin\n        h_new[0] = h_reg[0] ^ v_reg[0] ^ v_reg[8];\n        h_new[1] = h_reg[1] ^ v_reg[1] ^ v_reg[9];\n        h_new[2] = h_reg[2] ^ v_reg[2] ^ v_reg[10];\n        h_new[3] = h_reg[3] ^ v_reg[3] ^ v_reg[11];\n        h_new[4] = h_reg[4] ^ v_reg[4] ^ v_reg[12];\n        h_new[5] = h_reg[5] ^ v_reg[5] ^ v_reg[13];\n        h_new[6] = h_reg[6] ^ v_reg[6] ^ v_reg[14];\n        h_new[7] = h_reg[7] ^ v_reg[7] ^ v_reg[15];\n        h_we     = 1;\n      end\n    end // state_logic\n\n\n  //----------------------------------------------------------------\n  // compress_logic\n  //----------------------------------------------------------------\n  always @*\n    begin : compress_logic\n      integer i;\n\n      for (i = 0; i < 16; i = i + 1) begin\n        v_new[i] = 32'h0;\n      end\n      v_we = 1'h0;\n\n      G0_a = 32'h0;\n      G0_b = 32'h0;\n      G0_c = 32'h0;\n      G0_d = 32'h0;\n      G1_a = 32'h0;\n      G1_b = 32'h0;\n      G1_c = 32'h0;\n      G1_d = 32'h0;\n      G2_a = 32'h0;\n      G2_b = 32'h0;\n      G2_c = 32'h0;\n      G2_d = 32'h0;\n      G3_a = 32'h0;\n      G3_b = 32'h0;\n      G3_c = 32'h0;\n      G3_d = 32'h0;\n\n      if (init_v)\n        begin\n          v_new[0]  = h_reg[0];\n          v_new[1]  = h_reg[1];\n          v_new[2]  = h_reg[2];\n          v_new[3]  = h_reg[3];\n          v_new[4]  = h_reg[4];\n          v_new[5]  = h_reg[5];\n          v_new[6]  = h_reg[6];\n          v_new[7]  = h_reg[7];\n          v_new[8]  = IV0;\n          v_new[9]  = IV1;\n          v_new[10] = IV2;\n          v_new[11] = IV3;\n          v_new[12] = t0_reg ^ IV4;\n          v_new[13] = t1_reg ^ IV5;\n\n          if (last_reg) begin\n            v_new[14] = ~IV6;\n          end else begin\n            v_new[14] = IV6;\n          end\n\n          v_new[15] = IV7;\n          v_we = 1;\n        end\n\n      if (update_v)\n        begin\n          v_we = 1;\n\n          if (G_mode == G_ROW) begin\n            // Row updates.\n            G0_a      = v_reg[0];\n            G0_b      = v_reg[4];\n            G0_c      = v_reg[8];\n            G0_d      = v_reg[12];\n            v_new[0]  = G0_a_prim;\n            v_new[4]  = G0_b_prim;\n            v_new[8]  = G0_c_prim;\n            v_new[12] = G0_d_prim;\n\n            G1_a      = v_reg[1];\n            G1_b      = v_reg[5];\n            G1_c      = v_reg[9];\n            G1_d      = v_reg[13];\n            v_new[1]  = G1_a_prim;\n            v_new[5]  = G1_b_prim;\n            v_new[9]  = G1_c_prim;\n            v_new[13] = G1_d_prim;\n\n            G2_a      = v_reg[2];\n            G2_b      = v_reg[6];\n            G2_c      = v_reg[10];\n            G2_d      = v_reg[14];\n            v_new[2]  = G2_a_prim;\n            v_new[6]  = G2_b_prim;\n            v_new[10] = G2_c_prim;\n            v_new[14] = G2_d_prim;\n\n            G3_a      = v_reg[3];\n            G3_b      = v_reg[7];\n            G3_c      = v_reg[11];\n            G3_d      = v_reg[15];\n            v_new[3]  = G3_a_prim;\n            v_new[7]  = G3_b_prim;\n            v_new[11] = G3_c_prim;\n            v_new[15] = G3_d_prim;\n          end\n          else begin\n            // Diagonal updates.\n            G0_a      = v_reg[0];\n            G0_b      = v_reg[5];\n            G0_c      = v_reg[10];\n            G0_d      = v_reg[15];\n            v_new[0]  = G0_a_prim;\n            v_new[5]  = G0_b_prim;\n            v_new[10] = G0_c_prim;\n            v_new[15] = G0_d_prim;\n\n            G1_a      = v_reg[1];\n            G1_b      = v_reg[6];\n            G1_c      = v_reg[11];\n            G1_d      = v_reg[12];\n            v_new[1]  = G1_a_prim;\n            v_new[6]  = G1_b_prim;\n            v_new[11] = G1_c_prim;\n            v_new[12] = G1_d_prim;\n\n            G2_a      = v_reg[2];\n            G2_b      = v_reg[7];\n            G2_c      = v_reg[8];\n            G2_d      = v_reg[13];\n            v_new[2]  = G2_a_prim;\n            v_new[7]  = G2_b_prim;\n            v_new[8]  = G2_c_prim;\n            v_new[13] = G2_d_prim;\n\n            G3_a      = v_reg[3];\n            G3_b      = v_reg[4];\n            G3_c      = v_reg[9];\n            G3_d      = v_reg[14];\n            v_new[3]  = G3_a_prim;\n            v_new[4]  = G3_b_prim;\n            v_new[9]  = G3_c_prim;\n            v_new[14] = G3_d_prim;\n          end\n        end // if (update_v)\n    end // compress_logic\n\n\n  //----------------------------------------------------------------\n  // t_ctr\n  // Update logic for the length counter t, a monotonically\n  // increasing counter with reset.\n  //----------------------------------------------------------------\n  always @*\n    begin : t_ctr\n      t0_new = 32'h0;\n      t0_we  = 1'h0;\n      t1_new = 32'h0;\n      t1_we  = 1'h0;\n\n      if (t_ctr_rst) begin\n        t0_new = 32'h0;\n        t0_we  = 1'h1;\n        t1_new = 32'h0;\n        t1_we  = 1'h1;\n      end\n\n      if (t_ctr_inc) begin\n        t0_we = 1'h1;\n\n        if (last_new) begin\n          t0_new = t0_reg + {25'h0, blocklen};\n        end else begin\n          t0_new = t0_reg + {25'h0, BLOCK_BYTES};\n        end\n\n        if (t0_new < t0_reg) begin\n          t1_new = t1_reg + 1'h1;\n          t1_we  = 1'h1;\n        end\n      end\n    end // t_ctr\n\n\n  //----------------------------------------------------------------\n  // round_ctr\n  // Update logic for the round counter, a monotonically\n  // increasing counter with reset.\n  //----------------------------------------------------------------\n  always @*\n    begin : round_ctr\n      round_ctr_new = 4'h0;\n      round_ctr_we  = 1'h0;\n\n      if (round_ctr_rst)\n        begin\n          round_ctr_new = 4'h0;\n          round_ctr_we  = 1'h1;\n        end\n\n      if (round_ctr_inc)\n        begin\n          round_ctr_new = round_ctr_reg + 1'b1;\n          round_ctr_we  = 1'h1;\n        end\n    end // round_ctr\n\n\n  //----------------------------------------------------------------\n  // blake2s_ctrl\n  //----------------------------------------------------------------\n  always @*\n    begin : blake2s_ctrl\n      init_state         = 1'h0;\n      update_state       = 1'h0;\n      init_v             = 1'h0;\n      update_v           = 1'h0;\n      load_m             = 1'h0;\n      G_mode             = G_ROW;\n      round_ctr_inc      = 1'h0;\n      round_ctr_rst      = 1'h0;\n      t_ctr_inc          = 1'h0;\n      t_ctr_rst          = 1'h0;\n      last_new           = 1'h0;\n      last_we            = 1'h0;\n      ready_new          = 1'h0;\n      ready_we           = 1'h0;\n      blake2s_ctrl_new   = CTRL_IDLE;\n      blake2s_ctrl_we    = 1'h0;\n\n\n      case (blake2s_ctrl_reg)\n        CTRL_IDLE: begin\n          if (init) begin\n            last_new         = 1'h0;\n            last_we          = 1'h1;\n            init_state       = 1'h1;\n            t_ctr_rst        = 1'h1;\n            ready_new        = 1'h0;\n            ready_we         = 1'h1;\n            blake2s_ctrl_new = CTRL_FINISH;\n            blake2s_ctrl_we  = 1'h1;\n          end\n\n          if (update) begin\n            if (blocklen == BLOCK_BYTES) begin\n              load_m           = 1'h1;\n              t_ctr_inc        = 1'h1;\n              ready_new        = 1'h0;\n              ready_we         = 1'h1;\n              blake2s_ctrl_new = CTRL_INIT_ROUND;\n              blake2s_ctrl_we  = 1'h1;\n            end\n          end\n\n          if (finish) begin\n            load_m           = 1'h1;\n            t_ctr_inc        = 1'h1;\n            last_new         = 1'h1;\n            last_we          = 1'h1;\n            ready_new        = 1'h0;\n            ready_we         = 1'h1;\n            blake2s_ctrl_new = CTRL_INIT_ROUND;\n            blake2s_ctrl_we  = 1'h1;\n          end\n        end\n\n\n        CTRL_INIT_ROUND: begin\n          init_v           = 1'h1;\n          round_ctr_rst    = 1'h1;\n          blake2s_ctrl_new = CTRL_G_ROW;\n          blake2s_ctrl_we  = 1'h1;\n        end\n\n\n        CTRL_G_ROW: begin\n          G_mode           = G_ROW;\n          update_v         = 1'h1;\n          blake2s_ctrl_new = CTRL_G_DIAGONAL;\n          blake2s_ctrl_we  = 1'h1;\n        end\n\n\n        CTRL_G_DIAGONAL: begin\n          G_mode           = G_DIAGONAL;\n          update_v         = 1'h1;\n          round_ctr_inc    = 1'h1;\n          if (round_ctr_reg == (NUM_ROUNDS - 1)) begin\n            blake2s_ctrl_new = CTRL_COMP_DONE;\n            blake2s_ctrl_we  = 1'h1;\n          end\n          else begin\n            blake2s_ctrl_new = CTRL_G_ROW;\n            blake2s_ctrl_we  = 1'h1;\n          end\n        end\n\n\n        CTRL_COMP_DONE: begin\n          last_new           = 1'h0;\n          last_we            = 1'h1;\n          update_state       = 1'h1;\n          blake2s_ctrl_new   = CTRL_FINISH;\n          blake2s_ctrl_we    = 1'h1;\n        end\n\n\n        CTRL_FINISH: begin\n          ready_new        = 1'h1;\n          ready_we         = 1'h1;\n          blake2s_ctrl_new = CTRL_IDLE;\n          blake2s_ctrl_we  = 1'h1;\n        end\n\n\n        default: begin end\n      endcase // case (blake2s_ctrl_reg)\n    end // blake2s_ctrl\nendmodule // blake2s_core\n\n//======================================================================\n// EOF blake2s_core.v\n//======================================================================", "rtl/blake2s_m_select.v": "//======================================================================\n//\n// blake2s_m_select.v\n// ------------------\n// Verilog 2001 implementation of the message word selection in the\n// blake2 hash function core. Based on the given round and mode, we\n// extract the indices for the eight m words to select.\n// The words are then selected and returned. This is basically a\n// mux based implementation of the permutation table in combination\n// with the actual word selection.\n//\n//\n// Note that we use the mode to signal which indices to select\n// for a given round. This is because we don't do 8 G-functions\n// in a single cycle.\n//\n//\n// Author: Joachim Str\u00f6mbergson\n// Copyright (c) 2018, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\nmodule blake2s_m_select(\n                        input wire           clk,\n                        input wire           reset_n,\n\n                        input wire           load,\n                        input wire [511 : 0] m,\n\n                        input wire [3 : 0]   round,\n                        input wire           mode,\n\n                        output wire [31 : 0] G0_m0,\n                        output wire [31 : 0] G0_m1,\n                        output wire [31 : 0] G1_m0,\n                        output wire [31 : 0] G1_m1,\n                        output wire [31 : 0] G2_m0,\n                        output wire [31 : 0] G2_m1,\n                        output wire [31 : 0] G3_m0,\n                        output wire [31 : 0] G3_m1\n                       );\n\n\n  //----------------------------------------------------------------\n  // regs.\n  //----------------------------------------------------------------\n  reg [31 : 0] m_mem [0 : 15];\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg [3 : 0] i_G0_m0;\n  reg [3 : 0] i_G0_m1;\n  reg [3 : 0] i_G1_m0;\n  reg [3 : 0] i_G1_m1;\n  reg [3 : 0] i_G2_m0;\n  reg [3 : 0] i_G2_m1;\n  reg [3 : 0] i_G3_m0;\n  reg [3 : 0] i_G3_m1;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports.\n  //----------------------------------------------------------------\n  // Eight parallel, muxes that extract the message block words.\n  assign G0_m0 = m_mem[i_G0_m0];\n  assign G0_m1 = m_mem[i_G0_m1];\n  assign G1_m0 = m_mem[i_G1_m0];\n  assign G1_m1 = m_mem[i_G1_m1];\n  assign G2_m0 = m_mem[i_G2_m0];\n  assign G2_m1 = m_mem[i_G2_m1];\n  assign G3_m0 = m_mem[i_G3_m0];\n  assign G3_m1 = m_mem[i_G3_m1];\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //\n  // Update functionality for all registers in the core.\n  // All registers are positive edge triggered with synchronous,\n  // active low reset. All registers have write enable.\n  //----------------------------------------------------------------\n  always @ (posedge clk)\n    begin : reg_update\n      integer i;\n\n      if (!reset_n)\n        begin\n          for (i = 0 ; i < 16 ; i = i + 1)\n            m_mem[i] <= 32'h0;\n        end\n      else\n        begin\n          if (load)\n            begin\n              // Big to little endian conversion during register load.\n              m_mem[00] <= {m[0487 : 0480], m[0495 : 0488], m[0503 : 0496], m[0511 : 0504]};\n              m_mem[01] <= {m[0455 : 0448], m[0463 : 0456], m[0471 : 0464], m[0479 : 0472]};\n              m_mem[02] <= {m[0423 : 0416], m[0431 : 0424], m[0439 : 0432], m[0447 : 0440]};\n              m_mem[03] <= {m[0391 : 0384], m[0399 : 0392], m[0407 : 0400], m[0415 : 0408]};\n              m_mem[04] <= {m[0359 : 0352], m[0367 : 0360], m[0375 : 0368], m[0383 : 0376]};\n              m_mem[05] <= {m[0327 : 0320], m[0335 : 0328], m[0343 : 0336], m[0351 : 0344]};\n              m_mem[06] <= {m[0295 : 0288], m[0303 : 0296], m[0311 : 0304], m[0319 : 0312]};\n              m_mem[07] <= {m[0263 : 0256], m[0271 : 0264], m[0279 : 0272], m[0287 : 0280]};\n              m_mem[08] <= {m[0231 : 0224], m[0239 : 0232], m[0247 : 0240], m[0255 : 0248]};\n              m_mem[09] <= {m[0199 : 0192], m[0207 : 0200], m[0215 : 0208], m[0223 : 0216]};\n              m_mem[10] <= {m[0167 : 0160], m[0175 : 0168], m[0183 : 0176], m[0191 : 0184]};\n              m_mem[11] <= {m[0135 : 0128], m[0143 : 0136], m[0151 : 0144], m[0159 : 0152]};\n              m_mem[12] <= {m[0103 : 0096], m[0111 : 0104], m[0119 : 0112], m[0127 : 0120]};\n              m_mem[13] <= {m[0071 : 0064], m[0079 : 0072], m[0087 : 0080], m[0095 : 0088]};\n              m_mem[14] <= {m[0039 : 0032], m[0047 : 0040], m[0055 : 0048], m[0063 : 0056]};\n              m_mem[15] <= {m[0007 : 0000], m[0015 : 0008], m[0023 : 0016], m[0031 : 0024]};\n            end\n        end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // get_indices\n  //\n  // Get the indices from the permutation table given the\n  // round and the G function mode. This is the SIGMA table.\n  //----------------------------------------------------------------\n  always @*\n    begin : get_indices\n      i_G0_m0 = 4'd0;\n      i_G0_m1 = 4'd0;\n      i_G1_m0 = 4'd0;\n      i_G1_m1 = 4'd0;\n      i_G2_m0 = 4'd0;\n      i_G2_m1 = 4'd0;\n      i_G3_m0 = 4'd0;\n      i_G3_m1 = 4'd0;\n\n      case ({round, mode})\n        0: begin\n          i_G0_m0 = 4'd00;\n          i_G0_m1 = 4'd01;\n          i_G1_m0 = 4'd02;\n          i_G1_m1 = 4'd03;\n          i_G2_m0 = 4'd04;\n          i_G2_m1 = 4'd05;\n          i_G3_m0 = 4'd06;\n          i_G3_m1 = 4'd07;\n        end\n\n        1: begin\n          i_G0_m0 = 4'd08;\n          i_G0_m1 = 4'd09;\n          i_G1_m0 = 4'd10;\n          i_G1_m1 = 4'd11;\n          i_G2_m0 = 4'd12;\n          i_G2_m1 = 4'd13;\n          i_G3_m0 = 4'd14;\n          i_G3_m1 = 4'd15;\n        end\n\n        2: begin\n          i_G0_m0 = 4'd14;\n          i_G0_m1 = 4'd10;\n          i_G1_m0 = 4'd04;\n          i_G1_m1 = 4'd08;\n          i_G2_m0 = 4'd09;\n          i_G2_m1 = 4'd15;\n          i_G3_m0 = 4'd13;\n          i_G3_m1 = 4'd06;\n        end\n\n        3: begin\n          i_G0_m0 = 4'd01;\n          i_G0_m1 = 4'd12;\n          i_G1_m0 = 4'd00;\n          i_G1_m1 = 4'd02;\n          i_G2_m0 = 4'd11;\n          i_G2_m1 = 4'd07;\n          i_G3_m0 = 4'd05;\n          i_G3_m1 = 4'd03;\n        end\n\n        4: begin\n          i_G0_m0 = 4'd11;\n          i_G0_m1 = 4'd08;\n          i_G1_m0 = 4'd12;\n          i_G1_m1 = 4'd00;\n          i_G2_m0 = 4'd05;\n          i_G2_m1 = 4'd02;\n          i_G3_m0 = 4'd15;\n          i_G3_m1 = 4'd13;\n        end\n\n        5: begin\n          i_G0_m0 = 4'd10;\n          i_G0_m1 = 4'd14;\n          i_G1_m0 = 4'd03;\n          i_G1_m1 = 4'd06;\n          i_G2_m0 = 4'd07;\n          i_G2_m1 = 4'd01;\n          i_G3_m0 = 4'd09;\n          i_G3_m1 = 4'd04;\n        end\n\n        6: begin\n          i_G0_m0 = 4'd07;\n          i_G0_m1 = 4'd09;\n          i_G1_m0 = 4'd03;\n          i_G1_m1 = 4'd01;\n          i_G2_m0 = 4'd13;\n          i_G2_m1 = 4'd12;\n          i_G3_m0 = 4'd11;\n          i_G3_m1 = 4'd14;\n        end\n\n        7: begin\n          i_G0_m0 = 4'd02;\n          i_G0_m1 = 4'd06;\n          i_G1_m0 = 4'd05;\n          i_G1_m1 = 4'd10;\n          i_G2_m0 = 4'd04;\n          i_G2_m1 = 4'd00;\n          i_G3_m0 = 4'd15;\n          i_G3_m1 = 4'd08;\n        end\n\n        8: begin\n          i_G0_m0 = 4'd09;\n          i_G0_m1 = 4'd00;\n          i_G1_m0 = 4'd05;\n          i_G1_m1 = 4'd07;\n          i_G2_m0 = 4'd02;\n          i_G2_m1 = 4'd04;\n          i_G3_m0 = 4'd10;\n          i_G3_m1 = 4'd15;\n        end\n\n        9: begin\n          i_G0_m0 = 4'd14;\n          i_G0_m1 = 4'd01;\n          i_G1_m0 = 4'd11;\n          i_G1_m1 = 4'd12;\n          i_G2_m0 = 4'd06;\n          i_G2_m1 = 4'd08;\n          i_G3_m0 = 4'd03;\n          i_G3_m1 = 4'd13;\n        end\n\n        10: begin\n          i_G0_m0 = 4'd02;\n          i_G0_m1 = 4'd12;\n          i_G1_m0 = 4'd06;\n          i_G1_m1 = 4'd10;\n          i_G2_m0 = 4'd00;\n          i_G2_m1 = 4'd11;\n          i_G3_m0 = 4'd08;\n          i_G3_m1 = 4'd03;\n        end\n\n        11: begin\n          i_G0_m0 = 4'd04;\n          i_G0_m1 = 4'd13;\n          i_G1_m0 = 4'd07;\n          i_G1_m1 = 4'd05;\n          i_G2_m0 = 4'd15;\n          i_G2_m1 = 4'd14;\n          i_G3_m0 = 4'd01;\n          i_G3_m1 = 4'd09;\n        end\n\n        12: begin\n          i_G0_m0 = 4'd12;\n          i_G0_m1 = 4'd05;\n          i_G1_m0 = 4'd01;\n          i_G1_m1 = 4'd15;\n          i_G2_m0 = 4'd14;\n          i_G2_m1 = 4'd13;\n          i_G3_m0 = 4'd04;\n          i_G3_m1 = 4'd10;\n        end\n\n        13: begin\n          i_G0_m0 = 4'd00;\n          i_G0_m1 = 4'd07;\n          i_G1_m0 = 4'd06;\n          i_G1_m1 = 4'd03;\n          i_G2_m0 = 4'd09;\n          i_G2_m1 = 4'd02;\n          i_G3_m0 = 4'd08;\n          i_G3_m1 = 4'd11;\n        end\n\n        14: begin\n          i_G0_m0 = 4'd13;\n          i_G0_m1 = 4'd11;\n          i_G1_m0 = 4'd07;\n          i_G1_m1 = 4'd14;\n          i_G2_m0 = 4'd12;\n          i_G2_m1 = 4'd01;\n          i_G3_m0 = 4'd03;\n          i_G3_m1 = 4'd09;\n        end\n\n        15: begin\n          i_G0_m0 = 4'd05;\n          i_G0_m1 = 4'd00;\n          i_G1_m0 = 4'd15;\n          i_G1_m1 = 4'd04;\n          i_G2_m0 = 4'd08;\n          i_G2_m1 = 4'd06;\n          i_G3_m0 = 4'd02;\n          i_G3_m1 = 4'd10;\n        end\n\n        16: begin\n          i_G0_m0 = 4'd06;\n          i_G0_m1 = 4'd15;\n          i_G1_m0 = 4'd14;\n          i_G1_m1 = 4'd09;\n          i_G2_m0 = 4'd11;\n          i_G2_m1 = 4'd03;\n          i_G3_m0 = 4'd00;\n          i_G3_m1 = 4'd08;\n        end\n\n        17: begin\n          i_G0_m0 = 4'd12;\n          i_G0_m1 = 4'd02;\n          i_G1_m0 = 4'd13;\n          i_G1_m1 = 4'd07;\n          i_G2_m0 = 4'd01;\n          i_G2_m1 = 4'd04;\n          i_G3_m0 = 4'd10;\n          i_G3_m1 = 4'd05;\n        end\n\n        18: begin\n          i_G0_m0 = 4'd10;\n          i_G0_m1 = 4'd02;\n          i_G1_m0 = 4'd08;\n          i_G1_m1 = 4'd04;\n          i_G2_m0 = 4'd07;\n          i_G2_m1 = 4'd06;\n          i_G3_m0 = 4'd01;\n          i_G3_m1 = 4'd05;\n        end\n\n        19: begin\n          i_G0_m0 = 4'd15;\n          i_G0_m1 = 4'd11;\n          i_G1_m0 = 4'd09;\n          i_G1_m1 = 4'd14;\n          i_G2_m0 = 4'd03;\n          i_G2_m1 = 4'd12;\n          i_G3_m0 = 4'd13;\n          i_G3_m1 = 4'd00;\n        end\n\n        default: begin end\n      endcase // case ({round, mode})\n    end\n\nendmodule // blake2s_m_select\n\n//======================================================================\n// EOF blake2s_m_select.v\n//======================================================================", "verif/blake2s_core_reset_and_ready_sanity_check.sv": "module blake2s_core_reset_and_ready_sanity_check (\n                    input wire            clk,\n                    input wire            reset_n,\n\n                    input wire            init,\n                    input wire            update,\n                    input wire            finish,\n\n                    input wire [511 : 0]  block,\n                    input wire [6 : 0]    blocklen,\n\n                    output wire [255 : 0] digest,\n                    output wire           ready\n                  );\n\n    blake2s_core dut(\n        .clk(clk),\n        .reset_n(reset_n),\n        .init(init),\n        .update(update),\n        .finish(finish),\n        .block(block),\n        .blocklen(blocklen),\n        .digest(digest),\n        .ready(ready)\n    );\n\nendmodule : blake2s_core_reset_and_ready_sanity_check"}, "patch": {"verif/blake2s_core_reset_and_ready_sanity_check.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    image: verification_image\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/verif/blake2s_core_reset_and_ready_sanity_check.sv /code/rtl/blake2s_m_select.v /code/rtl/blake2s_G.v /code/rtl/blake2s_core.v\nTOPLEVEL        = blake2s_core_reset_and_ready_sanity_check\nMODULE          = test_blake2s_core\nPYTHONPATH      = /src\nHASH            = de551d4a184289c25a741fb03ced0dadbc989cae\nCOV_SELECTIONS  = reset init_ready\nCOV_THRESHOLDS  = 79.99 99.99", "src/coverage.py": "from cocotb.runner import get_runner\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\", cov_selection:str = \"\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    extra_env: dict = {}\n    if cov_selection:\n        extra_env[\"SELECTION\"] = cov_selection\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\",\n                extra_env=extra_env)\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef coverage_report_clear():\n    report_file=\"/code/rundir/coverage.log\"\n    if os.path.isfile(report_file):\n        os.remove(report_file)\n\ndef coverage_report_check(cov_threshold:float = 100.0):\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    print(f'column: {column}')\n    for line in lines[2:]:\n        match = re.match(r'^(.*?)\\s+(\\d+\\.?\\d*% \\(\\d+/\\d+\\))\\s+(\\d+% \\(\\d+/\\d+/\\d+\\))', line.strip())\n        if match:\n            info = list(match.groups())\n            print(f'info: {info}')\n        else:\n            info = re.split(r'\\s{2,}', line.strip())\n            print(f\"no regular expression match, trying differently: {info}\")\n\n        inst = info[0].lstrip('|-')\n        print(f'inst: {inst}')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= cov_threshold, f\"Didn't achieved the required coverage result (cov_threshold={cov_threshold}).\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "\nfrom cocotb.binary import BinaryValue\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\n\nCLK_HALF_PERIOD = 1\nCLK_PERIOD = CLK_HALF_PERIOD * 2\nCLK_TIME_UNIT = 'ns'\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def init_sim(dut):\n    dut.reset_n.value = 1\n    dut.init.value = 0\n    dut.update.value = 0\n    dut.finish.value = 0\n    dut.block.value = 0\n    dut.blocklen.value = 0\n\nasync def reset_dut(dut):\n    dut.reset_n.value = 0\n    await Timer(2 * CLK_PERIOD, units=CLK_TIME_UNIT)\n    dut.reset_n.value = 1\n    await Timer(2 * CLK_PERIOD, units=CLK_TIME_UNIT)\n\nasync def wait_ready(dut):\n    while dut.ready.value.integer != 1:\n        await FallingEdge(dut.clk)\n\nasync def ready_after_init(dut):\n    dut.init.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.init.value = 0\n    await wait_ready(dut)\n\nasync def one_block_message_test(\n        dut, block_len: BinaryValue, block: BinaryValue, expected: BinaryValue):\n\n    dut.init.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.init.value = 0\n    await wait_ready(dut)\n    # await FallingEdge(dut.clk) # Not required\n\n    dut.blocklen.value = block_len\n    dut.block.value = block\n    dut.finish.value = 1\n    await FallingEdge(dut.clk)\n\n    dut.finish.value = 0\n    await wait_ready(dut)\n    # await FallingEdge(dut.clk) # Not required\n\n    assert dut.digest.value == expected, \"didn't get the expected digest output\"\n\nasync def multiple_block_message_test(\n        dut, block_lengths: list[BinaryValue], blocks: list[BinaryValue], expected: BinaryValue):\n\n    assert len(block_lengths) == len(blocks), \"argument lists size mismatch\"\n    assert len(blocks) > 0, \"cannot process an empty list\"\n\n    block_index = 0\n    while block_index < len(blocks) - 1:\n        dut.init.value = 1\n        await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n        dut.init.value = 0\n        await wait_ready(dut)\n        await FallingEdge(dut.clk) # Not required\n\n        dut.blocklen.value = block_lengths[block_index]\n        dut.block.value = blocks[block_index]\n        dut.update.value = 1\n        await FallingEdge(dut.clk)\n\n        dut.update.value = 0\n        await wait_ready(dut)\n        await FallingEdge(dut.clk) # Not required\n\n        block_index += 1\n\n    # Final part\n    dut.blocklen.value = block_lengths[block_index]\n    dut.block.value = blocks[block_index]\n    dut.finish.value = 1\n    await FallingEdge(dut.clk)\n\n    dut.finish.value = 0\n    await wait_ready(dut)\n    await FallingEdge(dut.clk) # Not required\n\n    assert dut.digest.value == expected, \"didn't get the expected digest output\"\n", "src/test_blake2s_core.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.binary import BinaryValue\nfrom cocotb.triggers import FallingEdge\nimport harness_library as hrs_lb\nimport os\n\n\n@cocotb.test()\nasync def test_assert_reset_result(dut):\n    if os.getenv(\"SELECTION\") != 'reset':\n        return\n\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_assert_ready_after_reset...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    cocotb.log.info(\"All tests passed.\")\n\n@cocotb.test()\nasync def test_get_ready_after_init(dut):\n    if os.getenv(\"SELECTION\") != 'init_ready':\n        return\n\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_get_ready_after_init...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    await hrs_lb.ready_after_init(dut)\n\n    await FallingEdge(dut.clk)\n\n    cocotb.log.info(\"All tests passed.\")\n\n@cocotb.test()\nasync def test_finish_operation_asserts(dut):\n    if os.getenv(\"SELECTION\") != 'finish':\n        return\n\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_finish_operation_asserts...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    # Empty message test (Test Case 0):\n    empty_expected_digest = int('69217a3079908094e11121d042354a7c1f55b6482ca1a51e1b250dfd1ed0eef9', 16)\n    empty_block_bin = BinaryValue(0, 512, False)\n    empty_block_len_bin = BinaryValue(0, 7, False)\n    empty_expected_digest_bin = BinaryValue(empty_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, empty_block_len_bin, empty_block_bin, empty_expected_digest_bin)\n\n    # Test Case 1:\n    # tb_block = 512'h00010203_04050607_08090a0b_0c0d0e0f_10111213_14151617_18191a1b_1c1d1e1f_20212223_24252627_28292a2b_2c2d2e2f_30313233_34353637_38393a3b_3c3d3e3f;\n    # tb_blocklen = 7'h40;\n    # dut.digest == 256'h56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e\n    tc1_block = int('000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f', 16)\n    tc1_block_len = int('40', 16)\n    tc1_expected_digest = int('56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e', 16)\n    tc1_block_bin = BinaryValue(tc1_block, 512, False)\n    tc1_block_len_bin = BinaryValue(tc1_block_len, 7, False)\n    tc1_expected_digest_bin = BinaryValue(tc1_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, tc1_block_len_bin, tc1_block_bin, tc1_expected_digest_bin)\n\n    # # Test Case 2:\n    # # tb_block = 512'h00010203_04050607_08090a0b_0c0d0e0f_10111213_14151617_18191a1b_1c1d1e1f_20212223_24252627_28292a2b_2c2d2e2f_30313233_34353637_38393a3b_3c3d3e3f;\n    # # tb_blocklen = 7'h40;\n    # # tb_block = {8'h40, {63{8'h00}}};\n    # # tb_blocklen = 7'h01;\n    # tc2_block0 = int('00010203_04050607_08090a0b_0c0d0e0f_10111213_14151617_18191a1b_1c1d1e1f_20212223_24252627_28292a2b_2c2d2e2f_30313233_34353637_38393a3b_3c3d3e3f'.replace('_',''), 16)\n    # tc2_block0_len = int('40', 16)\n    # tc2_block1 = int('40' + (63 * '00'), 16)\n    # tc2_block1_len = 1\n    # tc2_expected_digest = int('1b53ee94aaf34e4b159d48de352c7f0661d0a40edff95a0b1639b4090e974472', 16)\n    # tc2_block_bin = [\n    #     BinaryValue(tc2_block0, 512, False),\n    #     BinaryValue(tc2_block1, 512, False)\n    # ]\n    # tc2_block_len_bin = [\n    #     BinaryValue(tc2_block0_len, 7, False),\n    #     BinaryValue(tc2_block1_len, 7, False)\n    # ]\n    # tc2_expected_digest_bin = BinaryValue(tc2_expected_digest, 256, False)\n    # await hrs_lb.multiple_block_message_test(dut, tc2_block_len_bin, tc2_block_bin, tc2_expected_digest_bin)\n\n    # Test Case 3:\n    # tb_block = {32'h61626300, {15{32'h0}}};\n    # tb_blocklen = 7'h03;\n    # tb_digest == 256'h508c5e8c327c14e2_e1a72ba34eeb452f_37458b209ed63a29_4d999b4c86675982\n    tc3_block = int('61626300' + (15 * 8 * '0'), 16)\n    tc3_block_len = int('03', 16)\n    tc3_expected_digest = int('508c5e8c327c14e2_e1a72ba34eeb452f_37458b209ed63a29_4d999b4c86675982'.replace('_', ''), 16)\n    tc3_block_bin = BinaryValue(tc3_block, 512, False)\n    tc3_block_len_bin = BinaryValue(tc3_block_len, 7, False)\n    tc3_expected_digest_bin = BinaryValue(tc3_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, tc3_block_len_bin, tc3_block_bin, tc3_expected_digest_bin)\n\n    cocotb.log.info(\"All tests passed.\")\n\n\n@cocotb.test()\nasync def test_update_operation_asserts(dut):\n    if os.getenv(\"SELECTION\") != 'update':\n        return\n\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_dut...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    # Empty message test (Test Case 0):\n    empty_expected_digest = int('69217a3079908094e11121d042354a7c1f55b6482ca1a51e1b250dfd1ed0eef9', 16)\n    empty_block_bin = BinaryValue(0, 512, False)\n    empty_block_len_bin = BinaryValue(0, 7, False)\n    empty_expected_digest_bin = BinaryValue(empty_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, empty_block_len_bin, empty_block_bin, empty_expected_digest_bin)\n\n    # Test Case 1:\n    # tb_block = 512'h00010203_04050607_08090a0b_0c0d0e0f_10111213_14151617_18191a1b_1c1d1e1f_20212223_24252627_28292a2b_2c2d2e2f_30313233_34353637_38393a3b_3c3d3e3f;\n    # tb_blocklen = 7'h40;\n    # dut.digest == 256'h56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e\n    tc1_block = int('000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f', 16)\n    tc1_block_len = int('40', 16)\n    tc1_expected_digest = int('56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e', 16)\n    tc1_block_bin = BinaryValue(tc1_block, 512, False)\n    tc1_block_len_bin = BinaryValue(tc1_block_len, 7, False)\n    tc1_expected_digest_bin = BinaryValue(tc1_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, tc1_block_len_bin, tc1_block_bin, tc1_expected_digest_bin)\n\n    # Test Case 2:\n    # tb_block = 512'h00010203_04050607_08090a0b_0c0d0e0f_10111213_14151617_18191a1b_1c1d1e1f_20212223_24252627_28292a2b_2c2d2e2f_30313233_34353637_38393a3b_3c3d3e3f;\n    # tb_blocklen = 7'h40;\n    # tb_block = {8'h40, {63{8'h00}}};\n    # tb_blocklen = 7'h01;\n    tc2_block0 = int('00010203_04050607_08090a0b_0c0d0e0f_10111213_14151617_18191a1b_1c1d1e1f_20212223_24252627_28292a2b_2c2d2e2f_30313233_34353637_38393a3b_3c3d3e3f'.replace('_',''), 16)\n    tc2_block0_len = int('40', 16)\n    tc2_block1 = int('40' + (63 * '00'), 16)\n    tc2_block1_len = 1\n    tc2_expected_digest = int('1b53ee94aaf34e4b159d48de352c7f0661d0a40edff95a0b1639b4090e974472', 16)\n    tc2_block_bin = [\n        BinaryValue(tc2_block0, 512, False),\n        BinaryValue(tc2_block1, 512, False)\n    ]\n    tc2_block_len_bin = [\n        BinaryValue(tc2_block0_len, 7, False),\n        BinaryValue(tc2_block1_len, 7, False)\n    ]\n    tc2_expected_digest_bin = BinaryValue(tc2_expected_digest, 256, False)\n    await hrs_lb.multiple_block_message_test(dut, tc2_block_len_bin, tc2_block_bin, tc2_expected_digest_bin)\n\n    # Test Case 3:\n    # tb_block = {32'h61626300, {15{32'h0}}};\n    # tb_blocklen = 7'h03;\n    # tb_digest == 256'h508c5e8c327c14e2_e1a72ba34eeb452f_37458b209ed63a29_4d999b4c86675982\n    tc3_block = int('61626300' + (15 * 8 * '0'), 16)\n    tc3_block_len = int('03', 16)\n    tc3_expected_digest = int('508c5e8c327c14e2_e1a72ba34eeb452f_37458b209ed63a29_4d999b4c86675982'.replace('_', ''), 16)\n    tc3_block_bin = BinaryValue(tc3_block, 512, False)\n    tc3_block_len_bin = BinaryValue(tc3_block_len, 7, False)\n    tc3_expected_digest_bin = BinaryValue(tc3_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, tc3_block_len_bin, tc3_block_bin, tc3_expected_digest_bin)\n\n    cocotb.log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nimport pytest\nimport coverage\nimport random\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\ncov_selections  = os.getenv(\"COV_SELECTIONS\", \"\").split()\ncov_thresholds  = [float(s) for s in os.getenv(\"COV_THRESHOLDS\", \"\").split()]\n\ndef call_runner(cov_selection:tuple[str, float] = None):\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.coverage_report_clear()\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter={},\n            cov_selection=cov_selection[0] if cov_selection else \"\",\n        )\n        coverage.coverage_report(\"assertion\")\n        if cov_selection:\n            print(f'cov_selection[0]: {cov_selection[0]} cov_selection[1]: {cov_selection[1]}')\n            coverage.coverage_report_check(cov_selection[1])\n        else:\n            coverage.coverage_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n\n    if len(cov_selections) == 0:\n        # Run the simulation\n        print(\"Calling runner without arguments\")\n        call_runner()\n        return\n\n    print(\"Identified special coverage selections\")\n\n    assert len(cov_selections) == len(cov_thresholds), \"incompatible coverage selections and thresholds\"\n\n    for selection, threshold in zip(cov_selections, cov_thresholds):\n        print(f\"> Running selection: {selection}, for threshold: {threshold}\")\n        call_runner((selection, threshold))\n\n"}}
{"id": "cvdp_agentic_crypto_0007", "categories": ["cid014", "hard"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYour task is to modify the existing RTL design based on the provided specifications to improve Quality of Results (QoR) such as timing, area, or power efficiency. Ensure the modifications are verified against the provided testbench and meet the updated specifications.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Develop assertion properties to verify the sanity of the `blake2s_core` module. These assertions must ensure that the module behaves as expected under its intended usage.\n\nThe assertion properties must cover the following behaviors:\n\n1. The module must not be set to ready immediately after an `update` operation has started.  \n2. The module must be ready 24 cycles after an `update` operation has started.  \n3. The module must not be set to ready immediately after a `finish` operation has started.  \n4. The module must be ready 24 cycles after a `finish` operation has started.\n\nSince we are verifying the expected behavior under the intended usage of the design, use helper assumptions alongside the assertion properties to constrain and validate correct usage patterns:\n\n1. An operation is considered ongoing once the module becomes ready and one of `init`, `update`, or `finish` is activated. The module must remain not ready until the operation completes. No new operation may be started while the module is not ready.\n\nThe following implementation requirements must be met:\n\n- The assertion properties must be placed in a separate module named `blake2s_core_finish_and_update_sanity_check`, which instantiates `blake2s_core` as the Device Under Test (DUT).  \n- The properties must reference internal DUT signals directly for verification.\n", "context": {"rtl/blake2s_G.v": "//======================================================================\n//\n// blake2s_G.v\n// -----------\n// Verilog 2001 implementation of the G function in the\n// blake2s hash function core. This is pure combinational logic in a\n// separade module to allow us to build versions  with 1, 2, 4\n// and even 8 parallel compression functions.\n//\n//\n// Author: Joachim Str\u00f6mbergson\n// Copyright (c) 2018, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\nmodule blake2s_G(\n                 input wire [31 : 0]  a,\n                 input wire [31 : 0]  b,\n                 input wire [31 : 0]  c,\n                 input wire [31 : 0]  d,\n                 input wire [31 : 0]  m0,\n                 input wire [31 : 0]  m1,\n\n                 output wire [31 : 0] a_prim,\n                 output wire [31 : 0] b_prim,\n                 output wire [31 : 0] c_prim,\n                 output wire [31 : 0] d_prim\n                );\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg [31 : 0] a1;\n  reg [31 : 0] a2;\n  reg [31 : 0] b1;\n  reg [31 : 0] b2;\n  reg [31 : 0] b3;\n  reg [31 : 0] b4;\n  reg [31 : 0] c1;\n  reg [31 : 0] c2;\n  reg [31 : 0] d1;\n  reg [31 : 0] d2;\n  reg [31 : 0] d3;\n  reg [31 : 0] d4;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports.\n  //----------------------------------------------------------------\n  assign a_prim = a2;\n  assign b_prim = b4;\n  assign c_prim = c2;\n  assign d_prim = d4;\n\n\n  //----------------------------------------------------------------\n  // G_function\n  //----------------------------------------------------------------\n  always @*\n    begin : G_function\n      a1 = a + b + m0;\n\n      d1 = d ^ a1;\n      d2 = {d1[15 : 0], d1[31 : 16]};\n\n      c1 = c + d2;\n\n      b1 = b ^ c1;\n      b2 = {b1[11 : 0], b1[31 : 12]};\n\n      a2 = a1 + b2 + m1;\n\n      d3 = d2 ^ a2;\n      d4 = {d3[7 : 0], d3[31 : 8]};\n\n      c2 = c1 + d4;\n\n      b3 = b2 ^ c2;\n      b4 = {b3[6 : 0], b3[31 : 7]};\n    end // G_function\nendmodule // blake2s_G\n\n//======================================================================\n// EOF blake2s_G.v\n//======================================================================", "rtl/blake2s_core.v": "//======================================================================\n//\n// blake2s_core.v\n// --------------\n// Verilog 2001 implementation of the hash function blake2s.\n// This is the internal core with wide interfaces.\n//\n//\n// Author: Joachim Str\u00f6mbergson\n// Copyright (c) 2018, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\nmodule blake2s_core(\n                    input wire            clk,\n                    input wire            reset_n,\n\n                    input wire            init,\n                    input wire            update,\n                    input wire            finish,\n\n                    input wire [511 : 0]  block,\n                    input wire [6 : 0]    blocklen,\n\n                    output wire [255 : 0] digest,\n                    output wire           ready\n                  );\n\n\n  //----------------------------------------------------------------\n  // Parameter block.\n  // See BLAKE2 paper and RFC 7693 for definition.\n  // Chapter 2.8 in https://blake2.net/blake2.pdf\n  // Section 2.5 in https://tools.ietf.org/html/rfc7693\n  //----------------------------------------------------------------\n  // The digest length in bytes. Minimum: 1, Maximum: 32\n  localparam [7 : 0]  DIGEST_LENGTH   = 8'd32;\n  localparam [7 : 0]  KEY_LENGTH      = 8'd0;\n  localparam [7 : 0]  FANOUT          = 8'd1;\n  localparam [7 : 0]  DEPTH           = 8'd01;\n  localparam [31 : 0] LEAF_LENGTH     = 32'd0;\n  localparam [47 : 0] NODE_OFFSET     = 48'd0;\n  localparam [7 : 0]  NODE_DEPTH      = 8'd0;\n  localparam [7 : 0]  INNER_LENGTH    = 8'd0;\n  localparam [63 : 0] SALT            = 64'h0;\n  localparam [63 : 0] PERSONALIZATION = 64'h0;\n\n  wire [255 : 0] parameter_block = {PERSONALIZATION, SALT, INNER_LENGTH,\n                                    NODE_DEPTH, NODE_OFFSET, LEAF_LENGTH,\n                                    DEPTH, FANOUT, KEY_LENGTH, DIGEST_LENGTH};\n\n\n  //----------------------------------------------------------------\n  // Internal constant definitions.\n  //----------------------------------------------------------------\n  localparam NUM_ROUNDS  = 10;\n  localparam BLOCK_BYTES = 7'd64;\n\n  // G function modes.\n  localparam G_ROW      = 1'h0;\n  localparam G_DIAGONAL = 1'h1;\n\n  // Initial vectors.\n  localparam IV0 = 32'h6a09e667;\n  localparam IV1 = 32'hbb67ae85;\n  localparam IV2 = 32'h3c6ef372;\n  localparam IV3 = 32'ha54ff53a;\n  localparam IV4 = 32'h510e527f;\n  localparam IV5 = 32'h9b05688c;\n  localparam IV6 = 32'h1f83d9ab;\n  localparam IV7 = 32'h5be0cd19;\n\n  // Control FSM state names.\n  localparam CTRL_IDLE       = 3'h0;\n  localparam CTRL_INIT_ROUND = 3'h1;\n  localparam CTRL_G_ROW      = 3'h2;\n  localparam CTRL_G_DIAGONAL = 3'h3;\n  localparam CTRL_COMP_DONE  = 3'h4;\n  localparam CTRL_FINISH     = 3'h5;\n\n\n  //----------------------------------------------------------------\n  // Registers including update variables and write enable.\n  //----------------------------------------------------------------\n  reg [31 : 0] h_reg [0 : 7];\n  reg [31 : 0] h_new [0 : 7];\n  reg          h_we;\n\n  reg [31 : 0] v_reg [0 : 15];\n  reg [31 : 0] v_new [0 : 15];\n  reg          v_we;\n  reg          init_v;\n  reg          update_v;\n\n  reg [3 : 0]  round_ctr_reg;\n  reg [3 : 0]  round_ctr_new;\n  reg          round_ctr_we;\n  reg          round_ctr_inc;\n  reg          round_ctr_rst;\n\n  reg [31 : 0] t0_reg;\n  reg [31 : 0] t0_new;\n  reg          t0_we;\n  reg [31 : 0] t1_reg;\n  reg [31 : 0] t1_new;\n  reg          t1_we;\n  reg          t_ctr_inc;\n  reg          t_ctr_rst;\n\n  reg          last_reg;\n  reg          last_new;\n  reg          last_we;\n\n  reg          ready_reg;\n  reg          ready_new;\n  reg          ready_we;\n\n  reg [2 : 0]  blake2s_ctrl_reg;\n  reg [2 : 0]  blake2s_ctrl_new;\n  reg          blake2s_ctrl_we;\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg init_state;\n  reg update_state;\n  reg load_m;\n  reg G_mode;\n\n  reg  [31 : 0] G0_a;\n  reg  [31 : 0] G0_b;\n  reg  [31 : 0] G0_c;\n  reg  [31 : 0] G0_d;\n  wire [31 : 0] G0_m0;\n  wire [31 : 0] G0_m1;\n  wire [31 : 0] G0_a_prim;\n  wire [31 : 0] G0_b_prim;\n  wire [31 : 0] G0_c_prim;\n  wire [31 : 0] G0_d_prim;\n\n  reg  [31 : 0] G1_a;\n  reg  [31 : 0] G1_b;\n  reg  [31 : 0] G1_c;\n  reg  [31 : 0] G1_d;\n  wire [31 : 0] G1_m0;\n  wire [31 : 0] G1_m1;\n  wire [31 : 0] G1_a_prim;\n  wire [31 : 0] G1_b_prim;\n  wire [31 : 0] G1_c_prim;\n  wire [31 : 0] G1_d_prim;\n\n  reg  [31 : 0] G2_a;\n  reg  [31 : 0] G2_b;\n  reg  [31 : 0] G2_c;\n  reg  [31 : 0] G2_d;\n  wire [31 : 0] G2_m0;\n  wire [31 : 0] G2_m1;\n  wire [31 : 0] G2_a_prim;\n  wire [31 : 0] G2_b_prim;\n  wire [31 : 0] G2_c_prim;\n  wire [31 : 0] G2_d_prim;\n\n  reg  [31 : 0] G3_a;\n  reg  [31 : 0] G3_b;\n  reg  [31 : 0] G3_c;\n  reg  [31 : 0] G3_d;\n  wire [31 : 0] G3_m0;\n  wire [31 : 0] G3_m1;\n  wire [31 : 0] G3_a_prim;\n  wire [31 : 0] G3_b_prim;\n  wire [31 : 0] G3_c_prim;\n  wire [31 : 0] G3_d_prim;\n\n\n  //----------------------------------------------------------------\n  // Module instantations.\n  //----------------------------------------------------------------\n  blake2s_m_select mselect(\n                           .clk(clk),\n                           .reset_n(reset_n),\n                           .load(load_m),\n                           .m(block),\n                           .round(round_ctr_reg),\n                           .mode(G_mode),\n                           .G0_m0(G0_m0),\n                           .G0_m1(G0_m1),\n                           .G1_m0(G1_m0),\n                           .G1_m1(G1_m1),\n                           .G2_m0(G2_m0),\n                           .G2_m1(G2_m1),\n                           .G3_m0(G3_m0),\n                           .G3_m1(G3_m1)\n                          );\n\n\n  blake2s_G G0(\n               .a(G0_a),\n               .b(G0_b),\n               .c(G0_c),\n               .d(G0_d),\n               .m0(G0_m0),\n               .m1(G0_m1),\n               .a_prim(G0_a_prim),\n               .b_prim(G0_b_prim),\n               .c_prim(G0_c_prim),\n               .d_prim(G0_d_prim)\n              );\n\n\n  blake2s_G G1(\n               .a(G1_a),\n               .b(G1_b),\n               .c(G1_c),\n               .d(G1_d),\n               .m0(G1_m0),\n               .m1(G1_m1),\n               .a_prim(G1_a_prim),\n               .b_prim(G1_b_prim),\n               .c_prim(G1_c_prim),\n               .d_prim(G1_d_prim)\n              );\n\n\n  blake2s_G G2(\n               .a(G2_a),\n               .b(G2_b),\n               .c(G2_c),\n               .d(G2_d),\n               .m0(G2_m0),\n               .m1(G2_m1),\n\n               .a_prim(G2_a_prim),\n               .b_prim(G2_b_prim),\n               .c_prim(G2_c_prim),\n               .d_prim(G2_d_prim)\n              );\n\n\n  blake2s_G G3(\n               .a(G3_a),\n               .b(G3_b),\n               .c(G3_c),\n               .d(G3_d),\n               .m0(G3_m0),\n               .m1(G3_m1),\n               .a_prim(G3_a_prim),\n               .b_prim(G3_b_prim),\n               .c_prim(G3_c_prim),\n               .d_prim(G3_d_prim)\n              );\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign digest = {h_reg[0][7 : 0], h_reg[0][15 : 8], h_reg[0][23 : 16], h_reg[0][31 : 24],\n                   h_reg[1][7 : 0], h_reg[1][15 : 8], h_reg[1][23 : 16], h_reg[1][31 : 24],\n                   h_reg[2][7 : 0], h_reg[2][15 : 8], h_reg[2][23 : 16], h_reg[2][31 : 24],\n                   h_reg[3][7 : 0], h_reg[3][15 : 8], h_reg[3][23 : 16], h_reg[3][31 : 24],\n                   h_reg[4][7 : 0], h_reg[4][15 : 8], h_reg[4][23 : 16], h_reg[4][31 : 24],\n                   h_reg[5][7 : 0], h_reg[5][15 : 8], h_reg[5][23 : 16], h_reg[5][31 : 24],\n                   h_reg[6][7 : 0], h_reg[6][15 : 8], h_reg[6][23 : 16], h_reg[6][31 : 24],\n                   h_reg[7][7 : 0], h_reg[7][15 : 8], h_reg[7][23 : 16], h_reg[7][31 : 24]};\n\n  assign ready = ready_reg;\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //----------------------------------------------------------------\n  always @ (posedge clk)\n    begin : reg_update\n      integer i;\n\n      if (!reset_n) begin\n        for (i = 0; i < 8; i = i + 1) begin\n          h_reg[i] <= 32'h0;\n        end\n\n        for (i = 0; i < 16; i = i + 1) begin\n          v_reg[i] <= 32'h0;\n        end\n\n        t0_reg           <= 32'h0;\n        t1_reg           <= 32'h0;\n        last_reg         <= 1'h0;\n        ready_reg        <= 1'h1;\n        round_ctr_reg    <= 4'h0;\n        blake2s_ctrl_reg <= CTRL_IDLE;\n      end\n      else begin\n        if (h_we) begin\n          for (i = 0; i < 8; i = i + 1) begin\n            h_reg[i] <= h_new[i];\n          end\n        end\n\n        if (v_we) begin\n          for (i = 0; i < 16; i = i + 1) begin\n            v_reg[i] <= v_new[i];\n          end\n        end\n\n        if (t0_we) begin\n          t0_reg <= t0_new;\n        end\n\n        if (t1_we) begin\n          t1_reg <= t1_new;\n        end\n\n        if (last_we) begin\n          last_reg <= last_new;\n        end\n\n        if (ready_we) begin\n          ready_reg <= ready_new;\n        end\n\n        if (round_ctr_we) begin\n          round_ctr_reg <= round_ctr_new;\n        end\n\n        if (blake2s_ctrl_we) begin\n          blake2s_ctrl_reg <= blake2s_ctrl_new;\n        end\n      end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // state_logic\n  //\n  // Logic for updating the hash state.\n  //----------------------------------------------------------------\n  always @*\n    begin : state_logic\n      integer i;\n\n      for (i = 0; i < 8; i = i + 1) begin\n        h_new[i] = 32'h0;\n      end\n      h_we   = 1'h0;\n\n      if (init_state) begin\n        h_new[0] = IV0 ^ parameter_block[31  :   0];\n        h_new[1] = IV1 ^ parameter_block[63  :  32];\n        h_new[2] = IV2 ^ parameter_block[95  :  64];\n        h_new[3] = IV3 ^ parameter_block[127 :  96];\n        h_new[4] = IV4 ^ parameter_block[159 : 128];\n        h_new[5] = IV5 ^ parameter_block[191 : 160];\n        h_new[6] = IV6 ^ parameter_block[223 : 192];\n        h_new[7] = IV7 ^ parameter_block[255 : 224];\n        h_we     = 1;\n      end\n\n      if (update_state) begin\n        h_new[0] = h_reg[0] ^ v_reg[0] ^ v_reg[8];\n        h_new[1] = h_reg[1] ^ v_reg[1] ^ v_reg[9];\n        h_new[2] = h_reg[2] ^ v_reg[2] ^ v_reg[10];\n        h_new[3] = h_reg[3] ^ v_reg[3] ^ v_reg[11];\n        h_new[4] = h_reg[4] ^ v_reg[4] ^ v_reg[12];\n        h_new[5] = h_reg[5] ^ v_reg[5] ^ v_reg[13];\n        h_new[6] = h_reg[6] ^ v_reg[6] ^ v_reg[14];\n        h_new[7] = h_reg[7] ^ v_reg[7] ^ v_reg[15];\n        h_we     = 1;\n      end\n    end // state_logic\n\n\n  //----------------------------------------------------------------\n  // compress_logic\n  //----------------------------------------------------------------\n  always @*\n    begin : compress_logic\n      integer i;\n\n      for (i = 0; i < 16; i = i + 1) begin\n        v_new[i] = 32'h0;\n      end\n      v_we = 1'h0;\n\n      G0_a = 32'h0;\n      G0_b = 32'h0;\n      G0_c = 32'h0;\n      G0_d = 32'h0;\n      G1_a = 32'h0;\n      G1_b = 32'h0;\n      G1_c = 32'h0;\n      G1_d = 32'h0;\n      G2_a = 32'h0;\n      G2_b = 32'h0;\n      G2_c = 32'h0;\n      G2_d = 32'h0;\n      G3_a = 32'h0;\n      G3_b = 32'h0;\n      G3_c = 32'h0;\n      G3_d = 32'h0;\n\n      if (init_v)\n        begin\n          v_new[0]  = h_reg[0];\n          v_new[1]  = h_reg[1];\n          v_new[2]  = h_reg[2];\n          v_new[3]  = h_reg[3];\n          v_new[4]  = h_reg[4];\n          v_new[5]  = h_reg[5];\n          v_new[6]  = h_reg[6];\n          v_new[7]  = h_reg[7];\n          v_new[8]  = IV0;\n          v_new[9]  = IV1;\n          v_new[10] = IV2;\n          v_new[11] = IV3;\n          v_new[12] = t0_reg ^ IV4;\n          v_new[13] = t1_reg ^ IV5;\n\n          if (last_reg) begin\n            v_new[14] = ~IV6;\n          end else begin\n            v_new[14] = IV6;\n          end\n\n          v_new[15] = IV7;\n          v_we = 1;\n        end\n\n      if (update_v)\n        begin\n          v_we = 1;\n\n          if (G_mode == G_ROW) begin\n            // Row updates.\n            G0_a      = v_reg[0];\n            G0_b      = v_reg[4];\n            G0_c      = v_reg[8];\n            G0_d      = v_reg[12];\n            v_new[0]  = G0_a_prim;\n            v_new[4]  = G0_b_prim;\n            v_new[8]  = G0_c_prim;\n            v_new[12] = G0_d_prim;\n\n            G1_a      = v_reg[1];\n            G1_b      = v_reg[5];\n            G1_c      = v_reg[9];\n            G1_d      = v_reg[13];\n            v_new[1]  = G1_a_prim;\n            v_new[5]  = G1_b_prim;\n            v_new[9]  = G1_c_prim;\n            v_new[13] = G1_d_prim;\n\n            G2_a      = v_reg[2];\n            G2_b      = v_reg[6];\n            G2_c      = v_reg[10];\n            G2_d      = v_reg[14];\n            v_new[2]  = G2_a_prim;\n            v_new[6]  = G2_b_prim;\n            v_new[10] = G2_c_prim;\n            v_new[14] = G2_d_prim;\n\n            G3_a      = v_reg[3];\n            G3_b      = v_reg[7];\n            G3_c      = v_reg[11];\n            G3_d      = v_reg[15];\n            v_new[3]  = G3_a_prim;\n            v_new[7]  = G3_b_prim;\n            v_new[11] = G3_c_prim;\n            v_new[15] = G3_d_prim;\n          end\n          else begin\n            // Diagonal updates.\n            G0_a      = v_reg[0];\n            G0_b      = v_reg[5];\n            G0_c      = v_reg[10];\n            G0_d      = v_reg[15];\n            v_new[0]  = G0_a_prim;\n            v_new[5]  = G0_b_prim;\n            v_new[10] = G0_c_prim;\n            v_new[15] = G0_d_prim;\n\n            G1_a      = v_reg[1];\n            G1_b      = v_reg[6];\n            G1_c      = v_reg[11];\n            G1_d      = v_reg[12];\n            v_new[1]  = G1_a_prim;\n            v_new[6]  = G1_b_prim;\n            v_new[11] = G1_c_prim;\n            v_new[12] = G1_d_prim;\n\n            G2_a      = v_reg[2];\n            G2_b      = v_reg[7];\n            G2_c      = v_reg[8];\n            G2_d      = v_reg[13];\n            v_new[2]  = G2_a_prim;\n            v_new[7]  = G2_b_prim;\n            v_new[8]  = G2_c_prim;\n            v_new[13] = G2_d_prim;\n\n            G3_a      = v_reg[3];\n            G3_b      = v_reg[4];\n            G3_c      = v_reg[9];\n            G3_d      = v_reg[14];\n            v_new[3]  = G3_a_prim;\n            v_new[4]  = G3_b_prim;\n            v_new[9]  = G3_c_prim;\n            v_new[14] = G3_d_prim;\n          end\n        end // if (update_v)\n    end // compress_logic\n\n\n  //----------------------------------------------------------------\n  // t_ctr\n  // Update logic for the length counter t, a monotonically\n  // increasing counter with reset.\n  //----------------------------------------------------------------\n  always @*\n    begin : t_ctr\n      t0_new = 32'h0;\n      t0_we  = 1'h0;\n      t1_new = 32'h0;\n      t1_we  = 1'h0;\n\n      if (t_ctr_rst) begin\n        t0_new = 32'h0;\n        t0_we  = 1'h1;\n        t1_new = 32'h0;\n        t1_we  = 1'h1;\n      end\n\n      if (t_ctr_inc) begin\n        t0_we = 1'h1;\n\n        if (last_new) begin\n          t0_new = t0_reg + {25'h0, blocklen};\n        end else begin\n          t0_new = t0_reg + {25'h0, BLOCK_BYTES};\n        end\n\n        if (t0_new < t0_reg) begin\n          t1_new = t1_reg + 1'h1;\n          t1_we  = 1'h1;\n        end\n      end\n    end // t_ctr\n\n\n  //----------------------------------------------------------------\n  // round_ctr\n  // Update logic for the round counter, a monotonically\n  // increasing counter with reset.\n  //----------------------------------------------------------------\n  always @*\n    begin : round_ctr\n      round_ctr_new = 4'h0;\n      round_ctr_we  = 1'h0;\n\n      if (round_ctr_rst)\n        begin\n          round_ctr_new = 4'h0;\n          round_ctr_we  = 1'h1;\n        end\n\n      if (round_ctr_inc)\n        begin\n          round_ctr_new = round_ctr_reg + 1'b1;\n          round_ctr_we  = 1'h1;\n        end\n    end // round_ctr\n\n\n  //----------------------------------------------------------------\n  // blake2s_ctrl\n  //----------------------------------------------------------------\n  always @*\n    begin : blake2s_ctrl\n      init_state         = 1'h0;\n      update_state       = 1'h0;\n      init_v             = 1'h0;\n      update_v           = 1'h0;\n      load_m             = 1'h0;\n      G_mode             = G_ROW;\n      round_ctr_inc      = 1'h0;\n      round_ctr_rst      = 1'h0;\n      t_ctr_inc          = 1'h0;\n      t_ctr_rst          = 1'h0;\n      last_new           = 1'h0;\n      last_we            = 1'h0;\n      ready_new          = 1'h0;\n      ready_we           = 1'h0;\n      blake2s_ctrl_new   = CTRL_IDLE;\n      blake2s_ctrl_we    = 1'h0;\n\n\n      case (blake2s_ctrl_reg)\n        CTRL_IDLE: begin\n          if (init) begin\n            last_new         = 1'h0;\n            last_we          = 1'h1;\n            init_state       = 1'h1;\n            t_ctr_rst        = 1'h1;\n            ready_new        = 1'h0;\n            ready_we         = 1'h1;\n            blake2s_ctrl_new = CTRL_FINISH;\n            blake2s_ctrl_we  = 1'h1;\n          end\n\n          if (update) begin\n            if (blocklen == BLOCK_BYTES) begin\n              load_m           = 1'h1;\n              t_ctr_inc        = 1'h1;\n              ready_new        = 1'h0;\n              ready_we         = 1'h1;\n              blake2s_ctrl_new = CTRL_INIT_ROUND;\n              blake2s_ctrl_we  = 1'h1;\n            end\n          end\n\n          if (finish) begin\n            load_m           = 1'h1;\n            t_ctr_inc        = 1'h1;\n            last_new         = 1'h1;\n            last_we          = 1'h1;\n            ready_new        = 1'h0;\n            ready_we         = 1'h1;\n            blake2s_ctrl_new = CTRL_INIT_ROUND;\n            blake2s_ctrl_we  = 1'h1;\n          end\n        end\n\n\n        CTRL_INIT_ROUND: begin\n          init_v           = 1'h1;\n          round_ctr_rst    = 1'h1;\n          blake2s_ctrl_new = CTRL_G_ROW;\n          blake2s_ctrl_we  = 1'h1;\n        end\n\n\n        CTRL_G_ROW: begin\n          G_mode           = G_ROW;\n          update_v         = 1'h1;\n          blake2s_ctrl_new = CTRL_G_DIAGONAL;\n          blake2s_ctrl_we  = 1'h1;\n        end\n\n\n        CTRL_G_DIAGONAL: begin\n          G_mode           = G_DIAGONAL;\n          update_v         = 1'h1;\n          round_ctr_inc    = 1'h1;\n          if (round_ctr_reg == (NUM_ROUNDS - 1)) begin\n            blake2s_ctrl_new = CTRL_COMP_DONE;\n            blake2s_ctrl_we  = 1'h1;\n          end\n          else begin\n            blake2s_ctrl_new = CTRL_G_ROW;\n            blake2s_ctrl_we  = 1'h1;\n          end\n        end\n\n\n        CTRL_COMP_DONE: begin\n          last_new           = 1'h0;\n          last_we            = 1'h1;\n          update_state       = 1'h1;\n          blake2s_ctrl_new   = CTRL_FINISH;\n          blake2s_ctrl_we    = 1'h1;\n        end\n\n\n        CTRL_FINISH: begin\n          ready_new        = 1'h1;\n          ready_we         = 1'h1;\n          blake2s_ctrl_new = CTRL_IDLE;\n          blake2s_ctrl_we  = 1'h1;\n        end\n\n\n        default: begin end\n      endcase // case (blake2s_ctrl_reg)\n    end // blake2s_ctrl\nendmodule // blake2s_core\n\n//======================================================================\n// EOF blake2s_core.v\n//======================================================================", "rtl/blake2s_m_select.v": "//======================================================================\n//\n// blake2s_m_select.v\n// ------------------\n// Verilog 2001 implementation of the message word selection in the\n// blake2 hash function core. Based on the given round and mode, we\n// extract the indices for the eight m words to select.\n// The words are then selected and returned. This is basically a\n// mux based implementation of the permutation table in combination\n// with the actual word selection.\n//\n//\n// Note that we use the mode to signal which indices to select\n// for a given round. This is because we don't do 8 G-functions\n// in a single cycle.\n//\n//\n// Author: Joachim Str\u00f6mbergson\n// Copyright (c) 2018, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\nmodule blake2s_m_select(\n                        input wire           clk,\n                        input wire           reset_n,\n\n                        input wire           load,\n                        input wire [511 : 0] m,\n\n                        input wire [3 : 0]   round,\n                        input wire           mode,\n\n                        output wire [31 : 0] G0_m0,\n                        output wire [31 : 0] G0_m1,\n                        output wire [31 : 0] G1_m0,\n                        output wire [31 : 0] G1_m1,\n                        output wire [31 : 0] G2_m0,\n                        output wire [31 : 0] G2_m1,\n                        output wire [31 : 0] G3_m0,\n                        output wire [31 : 0] G3_m1\n                       );\n\n\n  //----------------------------------------------------------------\n  // regs.\n  //----------------------------------------------------------------\n  reg [31 : 0] m_mem [0 : 15];\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg [3 : 0] i_G0_m0;\n  reg [3 : 0] i_G0_m1;\n  reg [3 : 0] i_G1_m0;\n  reg [3 : 0] i_G1_m1;\n  reg [3 : 0] i_G2_m0;\n  reg [3 : 0] i_G2_m1;\n  reg [3 : 0] i_G3_m0;\n  reg [3 : 0] i_G3_m1;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports.\n  //----------------------------------------------------------------\n  // Eight parallel, muxes that extract the message block words.\n  assign G0_m0 = m_mem[i_G0_m0];\n  assign G0_m1 = m_mem[i_G0_m1];\n  assign G1_m0 = m_mem[i_G1_m0];\n  assign G1_m1 = m_mem[i_G1_m1];\n  assign G2_m0 = m_mem[i_G2_m0];\n  assign G2_m1 = m_mem[i_G2_m1];\n  assign G3_m0 = m_mem[i_G3_m0];\n  assign G3_m1 = m_mem[i_G3_m1];\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //\n  // Update functionality for all registers in the core.\n  // All registers are positive edge triggered with synchronous,\n  // active low reset. All registers have write enable.\n  //----------------------------------------------------------------\n  always @ (posedge clk)\n    begin : reg_update\n      integer i;\n\n      if (!reset_n)\n        begin\n          for (i = 0 ; i < 16 ; i = i + 1)\n            m_mem[i] <= 32'h0;\n        end\n      else\n        begin\n          if (load)\n            begin\n              // Big to little endian conversion during register load.\n              m_mem[00] <= {m[0487 : 0480], m[0495 : 0488], m[0503 : 0496], m[0511 : 0504]};\n              m_mem[01] <= {m[0455 : 0448], m[0463 : 0456], m[0471 : 0464], m[0479 : 0472]};\n              m_mem[02] <= {m[0423 : 0416], m[0431 : 0424], m[0439 : 0432], m[0447 : 0440]};\n              m_mem[03] <= {m[0391 : 0384], m[0399 : 0392], m[0407 : 0400], m[0415 : 0408]};\n              m_mem[04] <= {m[0359 : 0352], m[0367 : 0360], m[0375 : 0368], m[0383 : 0376]};\n              m_mem[05] <= {m[0327 : 0320], m[0335 : 0328], m[0343 : 0336], m[0351 : 0344]};\n              m_mem[06] <= {m[0295 : 0288], m[0303 : 0296], m[0311 : 0304], m[0319 : 0312]};\n              m_mem[07] <= {m[0263 : 0256], m[0271 : 0264], m[0279 : 0272], m[0287 : 0280]};\n              m_mem[08] <= {m[0231 : 0224], m[0239 : 0232], m[0247 : 0240], m[0255 : 0248]};\n              m_mem[09] <= {m[0199 : 0192], m[0207 : 0200], m[0215 : 0208], m[0223 : 0216]};\n              m_mem[10] <= {m[0167 : 0160], m[0175 : 0168], m[0183 : 0176], m[0191 : 0184]};\n              m_mem[11] <= {m[0135 : 0128], m[0143 : 0136], m[0151 : 0144], m[0159 : 0152]};\n              m_mem[12] <= {m[0103 : 0096], m[0111 : 0104], m[0119 : 0112], m[0127 : 0120]};\n              m_mem[13] <= {m[0071 : 0064], m[0079 : 0072], m[0087 : 0080], m[0095 : 0088]};\n              m_mem[14] <= {m[0039 : 0032], m[0047 : 0040], m[0055 : 0048], m[0063 : 0056]};\n              m_mem[15] <= {m[0007 : 0000], m[0015 : 0008], m[0023 : 0016], m[0031 : 0024]};\n            end\n        end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // get_indices\n  //\n  // Get the indices from the permutation table given the\n  // round and the G function mode. This is the SIGMA table.\n  //----------------------------------------------------------------\n  always @*\n    begin : get_indices\n      i_G0_m0 = 4'd0;\n      i_G0_m1 = 4'd0;\n      i_G1_m0 = 4'd0;\n      i_G1_m1 = 4'd0;\n      i_G2_m0 = 4'd0;\n      i_G2_m1 = 4'd0;\n      i_G3_m0 = 4'd0;\n      i_G3_m1 = 4'd0;\n\n      case ({round, mode})\n        0: begin\n          i_G0_m0 = 4'd00;\n          i_G0_m1 = 4'd01;\n          i_G1_m0 = 4'd02;\n          i_G1_m1 = 4'd03;\n          i_G2_m0 = 4'd04;\n          i_G2_m1 = 4'd05;\n          i_G3_m0 = 4'd06;\n          i_G3_m1 = 4'd07;\n        end\n\n        1: begin\n          i_G0_m0 = 4'd08;\n          i_G0_m1 = 4'd09;\n          i_G1_m0 = 4'd10;\n          i_G1_m1 = 4'd11;\n          i_G2_m0 = 4'd12;\n          i_G2_m1 = 4'd13;\n          i_G3_m0 = 4'd14;\n          i_G3_m1 = 4'd15;\n        end\n\n        2: begin\n          i_G0_m0 = 4'd14;\n          i_G0_m1 = 4'd10;\n          i_G1_m0 = 4'd04;\n          i_G1_m1 = 4'd08;\n          i_G2_m0 = 4'd09;\n          i_G2_m1 = 4'd15;\n          i_G3_m0 = 4'd13;\n          i_G3_m1 = 4'd06;\n        end\n\n        3: begin\n          i_G0_m0 = 4'd01;\n          i_G0_m1 = 4'd12;\n          i_G1_m0 = 4'd00;\n          i_G1_m1 = 4'd02;\n          i_G2_m0 = 4'd11;\n          i_G2_m1 = 4'd07;\n          i_G3_m0 = 4'd05;\n          i_G3_m1 = 4'd03;\n        end\n\n        4: begin\n          i_G0_m0 = 4'd11;\n          i_G0_m1 = 4'd08;\n          i_G1_m0 = 4'd12;\n          i_G1_m1 = 4'd00;\n          i_G2_m0 = 4'd05;\n          i_G2_m1 = 4'd02;\n          i_G3_m0 = 4'd15;\n          i_G3_m1 = 4'd13;\n        end\n\n        5: begin\n          i_G0_m0 = 4'd10;\n          i_G0_m1 = 4'd14;\n          i_G1_m0 = 4'd03;\n          i_G1_m1 = 4'd06;\n          i_G2_m0 = 4'd07;\n          i_G2_m1 = 4'd01;\n          i_G3_m0 = 4'd09;\n          i_G3_m1 = 4'd04;\n        end\n\n        6: begin\n          i_G0_m0 = 4'd07;\n          i_G0_m1 = 4'd09;\n          i_G1_m0 = 4'd03;\n          i_G1_m1 = 4'd01;\n          i_G2_m0 = 4'd13;\n          i_G2_m1 = 4'd12;\n          i_G3_m0 = 4'd11;\n          i_G3_m1 = 4'd14;\n        end\n\n        7: begin\n          i_G0_m0 = 4'd02;\n          i_G0_m1 = 4'd06;\n          i_G1_m0 = 4'd05;\n          i_G1_m1 = 4'd10;\n          i_G2_m0 = 4'd04;\n          i_G2_m1 = 4'd00;\n          i_G3_m0 = 4'd15;\n          i_G3_m1 = 4'd08;\n        end\n\n        8: begin\n          i_G0_m0 = 4'd09;\n          i_G0_m1 = 4'd00;\n          i_G1_m0 = 4'd05;\n          i_G1_m1 = 4'd07;\n          i_G2_m0 = 4'd02;\n          i_G2_m1 = 4'd04;\n          i_G3_m0 = 4'd10;\n          i_G3_m1 = 4'd15;\n        end\n\n        9: begin\n          i_G0_m0 = 4'd14;\n          i_G0_m1 = 4'd01;\n          i_G1_m0 = 4'd11;\n          i_G1_m1 = 4'd12;\n          i_G2_m0 = 4'd06;\n          i_G2_m1 = 4'd08;\n          i_G3_m0 = 4'd03;\n          i_G3_m1 = 4'd13;\n        end\n\n        10: begin\n          i_G0_m0 = 4'd02;\n          i_G0_m1 = 4'd12;\n          i_G1_m0 = 4'd06;\n          i_G1_m1 = 4'd10;\n          i_G2_m0 = 4'd00;\n          i_G2_m1 = 4'd11;\n          i_G3_m0 = 4'd08;\n          i_G3_m1 = 4'd03;\n        end\n\n        11: begin\n          i_G0_m0 = 4'd04;\n          i_G0_m1 = 4'd13;\n          i_G1_m0 = 4'd07;\n          i_G1_m1 = 4'd05;\n          i_G2_m0 = 4'd15;\n          i_G2_m1 = 4'd14;\n          i_G3_m0 = 4'd01;\n          i_G3_m1 = 4'd09;\n        end\n\n        12: begin\n          i_G0_m0 = 4'd12;\n          i_G0_m1 = 4'd05;\n          i_G1_m0 = 4'd01;\n          i_G1_m1 = 4'd15;\n          i_G2_m0 = 4'd14;\n          i_G2_m1 = 4'd13;\n          i_G3_m0 = 4'd04;\n          i_G3_m1 = 4'd10;\n        end\n\n        13: begin\n          i_G0_m0 = 4'd00;\n          i_G0_m1 = 4'd07;\n          i_G1_m0 = 4'd06;\n          i_G1_m1 = 4'd03;\n          i_G2_m0 = 4'd09;\n          i_G2_m1 = 4'd02;\n          i_G3_m0 = 4'd08;\n          i_G3_m1 = 4'd11;\n        end\n\n        14: begin\n          i_G0_m0 = 4'd13;\n          i_G0_m1 = 4'd11;\n          i_G1_m0 = 4'd07;\n          i_G1_m1 = 4'd14;\n          i_G2_m0 = 4'd12;\n          i_G2_m1 = 4'd01;\n          i_G3_m0 = 4'd03;\n          i_G3_m1 = 4'd09;\n        end\n\n        15: begin\n          i_G0_m0 = 4'd05;\n          i_G0_m1 = 4'd00;\n          i_G1_m0 = 4'd15;\n          i_G1_m1 = 4'd04;\n          i_G2_m0 = 4'd08;\n          i_G2_m1 = 4'd06;\n          i_G3_m0 = 4'd02;\n          i_G3_m1 = 4'd10;\n        end\n\n        16: begin\n          i_G0_m0 = 4'd06;\n          i_G0_m1 = 4'd15;\n          i_G1_m0 = 4'd14;\n          i_G1_m1 = 4'd09;\n          i_G2_m0 = 4'd11;\n          i_G2_m1 = 4'd03;\n          i_G3_m0 = 4'd00;\n          i_G3_m1 = 4'd08;\n        end\n\n        17: begin\n          i_G0_m0 = 4'd12;\n          i_G0_m1 = 4'd02;\n          i_G1_m0 = 4'd13;\n          i_G1_m1 = 4'd07;\n          i_G2_m0 = 4'd01;\n          i_G2_m1 = 4'd04;\n          i_G3_m0 = 4'd10;\n          i_G3_m1 = 4'd05;\n        end\n\n        18: begin\n          i_G0_m0 = 4'd10;\n          i_G0_m1 = 4'd02;\n          i_G1_m0 = 4'd08;\n          i_G1_m1 = 4'd04;\n          i_G2_m0 = 4'd07;\n          i_G2_m1 = 4'd06;\n          i_G3_m0 = 4'd01;\n          i_G3_m1 = 4'd05;\n        end\n\n        19: begin\n          i_G0_m0 = 4'd15;\n          i_G0_m1 = 4'd11;\n          i_G1_m0 = 4'd09;\n          i_G1_m1 = 4'd14;\n          i_G2_m0 = 4'd03;\n          i_G2_m1 = 4'd12;\n          i_G3_m0 = 4'd13;\n          i_G3_m1 = 4'd00;\n        end\n\n        default: begin end\n      endcase // case ({round, mode})\n    end\n\nendmodule // blake2s_m_select\n\n//======================================================================\n// EOF blake2s_m_select.v\n//======================================================================", "verif/blake2s_core_finish_and_update_sanity_check.sv": "module blake2s_core_finish_and_update_sanity_check (\n                    input wire            clk,\n                    input wire            reset_n,\n\n                    input wire            init,\n                    input wire            update,\n                    input wire            finish,\n\n                    input wire [511 : 0]  block,\n                    input wire [6 : 0]    blocklen,\n\n                    output wire [255 : 0] digest,\n                    output wire           ready\n                  );\n\n    blake2s_core dut(\n        .clk(clk),\n        .reset_n(reset_n),\n        .init(init),\n        .update(update),\n        .finish(finish),\n        .block(block),\n        .blocklen(blocklen),\n        .digest(digest),\n        .ready(ready)\n    );\n\nendmodule : blake2s_core_finish_and_update_sanity_check"}, "patch": {"verif/blake2s_core_finish_and_update_sanity_check.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    image: verification_image\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/verif/blake2s_core_finish_and_update_sanity_check.sv /code/rtl/blake2s_m_select.v /code/rtl/blake2s_G.v /code/rtl/blake2s_core.v\nTOPLEVEL        = blake2s_core_finish_and_update_sanity_check\nMODULE          = test_blake2s_core\nPYTHONPATH      = /src\nHASH            = 629755a3459da4560cf05fe559cb47b74e6b993f\nCOV_SELECTIONS  = finish update\nCOV_THRESHOLDS  = 59.99 99.99", "src/coverage.py": "from cocotb.runner import get_runner\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\", cov_selection:str = \"\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    extra_env: dict = {}\n    if cov_selection:\n        extra_env[\"SELECTION\"] = cov_selection\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\",\n                extra_env=extra_env)\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef coverage_report_clear():\n    report_file=\"/code/rundir/coverage.log\"\n    if os.path.isfile(report_file):\n        os.remove(report_file)\n\ndef coverage_report_check(cov_threshold:float = 100.0):\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    print(f'column: {column}')\n    for line in lines[2:]:\n        match = re.match(r'^(.*?)\\s+(\\d+\\.?\\d*% \\(\\d+/\\d+\\))\\s+(\\d+% \\(\\d+/\\d+/\\d+\\))', line.strip())\n        if match:\n            info = list(match.groups())\n            print(f'info: {info}')\n        else:\n            info = re.split(r'\\s{2,}', line.strip())\n            print(f\"no regular expression match, trying differently: {info}\")\n\n        inst = info[0].lstrip('|-')\n        print(f'inst: {inst}')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= cov_threshold, f\"Didn't achieved the required coverage result (cov_threshold={cov_threshold}).\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "\nfrom cocotb.binary import BinaryValue\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\n\nCLK_HALF_PERIOD = 1\nCLK_PERIOD = CLK_HALF_PERIOD * 2\nCLK_TIME_UNIT = 'ns'\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def init_sim(dut):\n    dut.reset_n.value = 1\n    dut.init.value = 0\n    dut.update.value = 0\n    dut.finish.value = 0\n    dut.block.value = 0\n    dut.blocklen.value = 0\n\nasync def reset_dut(dut):\n    dut.reset_n.value = 0\n    await Timer(2 * CLK_PERIOD, units=CLK_TIME_UNIT)\n    dut.reset_n.value = 1\n    await Timer(2 * CLK_PERIOD, units=CLK_TIME_UNIT)\n\nasync def wait_ready(dut):\n    while dut.ready.value.integer != 1:\n        await FallingEdge(dut.clk)\n\nasync def ready_after_init(dut):\n    dut.init.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.init.value = 0\n    await wait_ready(dut)\n\nasync def one_block_message_test(\n        dut, block_len: BinaryValue, block: BinaryValue, expected: BinaryValue):\n\n    dut.init.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.init.value = 0\n    await wait_ready(dut)\n    await FallingEdge(dut.clk) # Not required\n\n    dut.blocklen.value = block_len\n    dut.block.value = block\n    dut.finish.value = 1\n    await FallingEdge(dut.clk)\n\n    dut.finish.value = 0\n    await wait_ready(dut)\n    await FallingEdge(dut.clk) # Not required\n\n    assert dut.digest.value == expected, \"didn't get the expected digest output\"\n\nasync def multiple_block_message_test(\n        dut, block_lengths: list[BinaryValue], blocks: list[BinaryValue], expected: BinaryValue):\n\n    assert len(block_lengths) == len(blocks), \"argument lists size mismatch\"\n    assert len(blocks) > 0, \"cannot process an empty list\"\n\n    block_index = 0\n    while block_index < len(blocks) - 1:\n        dut.init.value = 1\n        await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n        dut.init.value = 0\n        await wait_ready(dut)\n        await FallingEdge(dut.clk) # Not required\n\n        dut.blocklen.value = block_lengths[block_index]\n        dut.block.value = blocks[block_index]\n        dut.update.value = 1\n        await FallingEdge(dut.clk)\n\n        dut.update.value = 0\n        await wait_ready(dut)\n        await FallingEdge(dut.clk) # Not required\n\n        block_index += 1\n\n    # Final part\n    dut.blocklen.value = block_lengths[block_index]\n    dut.block.value = blocks[block_index]\n    dut.finish.value = 1\n    await FallingEdge(dut.clk)\n\n    dut.finish.value = 0\n    await wait_ready(dut)\n    await FallingEdge(dut.clk) # Not required\n\n    assert dut.digest.value == expected, \"didn't get the expected digest output\"\n", "src/test_blake2s_core.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.binary import BinaryValue\nfrom cocotb.triggers import FallingEdge\nimport harness_library as hrs_lb\nimport os\n\n\n@cocotb.test()\nasync def test_assert_reset_result(dut):\n    if os.getenv(\"SELECTION\") != 'reset':\n        return\n\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_assert_ready_after_reset...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    cocotb.log.info(\"All tests passed.\")\n\n@cocotb.test()\nasync def test_get_ready_after_init(dut):\n    if os.getenv(\"SELECTION\") != 'init_ready':\n        return\n\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_get_ready_after_init...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    await hrs_lb.ready_after_init(dut)\n\n    await FallingEdge(dut.clk)\n\n    cocotb.log.info(\"All tests passed.\")\n\n@cocotb.test()\nasync def test_finish_operation_asserts(dut):\n    if os.getenv(\"SELECTION\") != 'finish':\n        return\n\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_finish_operation_asserts...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    # Empty message test (Test Case 0):\n    empty_expected_digest = int('69217a3079908094e11121d042354a7c1f55b6482ca1a51e1b250dfd1ed0eef9', 16)\n    empty_block_bin = BinaryValue(0, 512, False)\n    empty_block_len_bin = BinaryValue(0, 7, False)\n    empty_expected_digest_bin = BinaryValue(empty_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, empty_block_len_bin, empty_block_bin, empty_expected_digest_bin)\n\n    # Test Case 1:\n    # tb_block = 512'h00010203_04050607_08090a0b_0c0d0e0f_10111213_14151617_18191a1b_1c1d1e1f_20212223_24252627_28292a2b_2c2d2e2f_30313233_34353637_38393a3b_3c3d3e3f;\n    # tb_blocklen = 7'h40;\n    # dut.digest == 256'h56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e\n    tc1_block = int('000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f', 16)\n    tc1_block_len = int('40', 16)\n    tc1_expected_digest = int('56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e', 16)\n    tc1_block_bin = BinaryValue(tc1_block, 512, False)\n    tc1_block_len_bin = BinaryValue(tc1_block_len, 7, False)\n    tc1_expected_digest_bin = BinaryValue(tc1_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, tc1_block_len_bin, tc1_block_bin, tc1_expected_digest_bin)\n\n    # Test Case 3:\n    # tb_block = {32'h61626300, {15{32'h0}}};\n    # tb_blocklen = 7'h03;\n    # tb_digest == 256'h508c5e8c327c14e2_e1a72ba34eeb452f_37458b209ed63a29_4d999b4c86675982\n    tc3_block = int('61626300' + (15 * 8 * '0'), 16)\n    tc3_block_len = int('03', 16)\n    tc3_expected_digest = int('508c5e8c327c14e2_e1a72ba34eeb452f_37458b209ed63a29_4d999b4c86675982'.replace('_', ''), 16)\n    tc3_block_bin = BinaryValue(tc3_block, 512, False)\n    tc3_block_len_bin = BinaryValue(tc3_block_len, 7, False)\n    tc3_expected_digest_bin = BinaryValue(tc3_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, tc3_block_len_bin, tc3_block_bin, tc3_expected_digest_bin)\n\n    cocotb.log.info(\"All tests passed.\")\n\n\n@cocotb.test()\nasync def test_update_operation_asserts(dut):\n    if os.getenv(\"SELECTION\") != 'update':\n        return\n\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_dut...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    # Empty message test (Test Case 0):\n    empty_expected_digest = int('69217a3079908094e11121d042354a7c1f55b6482ca1a51e1b250dfd1ed0eef9', 16)\n    empty_block_bin = BinaryValue(0, 512, False)\n    empty_block_len_bin = BinaryValue(0, 7, False)\n    empty_expected_digest_bin = BinaryValue(empty_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, empty_block_len_bin, empty_block_bin, empty_expected_digest_bin)\n\n    # Test Case 1:\n    # tb_block = 512'h00010203_04050607_08090a0b_0c0d0e0f_10111213_14151617_18191a1b_1c1d1e1f_20212223_24252627_28292a2b_2c2d2e2f_30313233_34353637_38393a3b_3c3d3e3f;\n    # tb_blocklen = 7'h40;\n    # dut.digest == 256'h56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e\n    tc1_block = int('000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f', 16)\n    tc1_block_len = int('40', 16)\n    tc1_expected_digest = int('56f34e8b96557e90c1f24b52d0c89d51086acf1b00f634cf1dde9233b8eaaa3e', 16)\n    tc1_block_bin = BinaryValue(tc1_block, 512, False)\n    tc1_block_len_bin = BinaryValue(tc1_block_len, 7, False)\n    tc1_expected_digest_bin = BinaryValue(tc1_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, tc1_block_len_bin, tc1_block_bin, tc1_expected_digest_bin)\n\n    # Test Case 2:\n    # tb_block = 512'h00010203_04050607_08090a0b_0c0d0e0f_10111213_14151617_18191a1b_1c1d1e1f_20212223_24252627_28292a2b_2c2d2e2f_30313233_34353637_38393a3b_3c3d3e3f;\n    # tb_blocklen = 7'h40;\n    # tb_block = {8'h40, {63{8'h00}}};\n    # tb_blocklen = 7'h01;\n    tc2_block0 = int('00010203_04050607_08090a0b_0c0d0e0f_10111213_14151617_18191a1b_1c1d1e1f_20212223_24252627_28292a2b_2c2d2e2f_30313233_34353637_38393a3b_3c3d3e3f'.replace('_',''), 16)\n    tc2_block0_len = int('40', 16)\n    tc2_block1 = int('40' + (63 * '00'), 16)\n    tc2_block1_len = 1\n    tc2_expected_digest = int('1b53ee94aaf34e4b159d48de352c7f0661d0a40edff95a0b1639b4090e974472', 16)\n    tc2_block_bin = [\n        BinaryValue(tc2_block0, 512, False),\n        BinaryValue(tc2_block1, 512, False)\n    ]\n    tc2_block_len_bin = [\n        BinaryValue(tc2_block0_len, 7, False),\n        BinaryValue(tc2_block1_len, 7, False)\n    ]\n    tc2_expected_digest_bin = BinaryValue(tc2_expected_digest, 256, False)\n    await hrs_lb.multiple_block_message_test(dut, tc2_block_len_bin, tc2_block_bin, tc2_expected_digest_bin)\n\n    # Test Case 3:\n    # tb_block = {32'h61626300, {15{32'h0}}};\n    # tb_blocklen = 7'h03;\n    # tb_digest == 256'h508c5e8c327c14e2_e1a72ba34eeb452f_37458b209ed63a29_4d999b4c86675982\n    tc3_block = int('61626300' + (15 * 8 * '0'), 16)\n    tc3_block_len = int('03', 16)\n    tc3_expected_digest = int('508c5e8c327c14e2_e1a72ba34eeb452f_37458b209ed63a29_4d999b4c86675982'.replace('_', ''), 16)\n    tc3_block_bin = BinaryValue(tc3_block, 512, False)\n    tc3_block_len_bin = BinaryValue(tc3_block_len, 7, False)\n    tc3_expected_digest_bin = BinaryValue(tc3_expected_digest, 256, False)\n    await hrs_lb.one_block_message_test(dut, tc3_block_len_bin, tc3_block_bin, tc3_expected_digest_bin)\n\n    cocotb.log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nimport pytest\nimport coverage\nimport random\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\ncov_selections  = os.getenv(\"COV_SELECTIONS\", \"\").split()\ncov_thresholds  = [float(s) for s in os.getenv(\"COV_THRESHOLDS\", \"\").split()]\n\ndef call_runner(cov_selection:tuple[str, float] = None):\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.coverage_report_clear()\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter={},\n            cov_selection=cov_selection[0] if cov_selection else \"\",\n        )\n        coverage.coverage_report(\"assertion\")\n        if cov_selection:\n            print(f'cov_selection[0]: {cov_selection[0]} cov_selection[1]: {cov_selection[1]}')\n            coverage.coverage_report_check(cov_selection[1])\n        else:\n            coverage.coverage_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n\n    if len(cov_selections) == 0:\n        # Run the simulation\n        print(\"Calling runner without arguments\")\n        call_runner()\n        return\n\n    print(\"Identified special coverage selections\")\n\n    assert len(cov_selections) == len(cov_thresholds), \"incompatible coverage selections and thresholds\"\n\n    for selection, threshold in zip(cov_selections, cov_thresholds):\n        print(f\"> Running selection: {selection}, for threshold: {threshold}\")\n        call_runner((selection, threshold))\n\n"}}
{"id": "cvdp_agentic_crypto_0011", "categories": ["cid014", "hard"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYour task is to modify the existing RTL design based on the provided specifications to improve Quality of Results (QoR) such as timing, area, or power efficiency. Ensure the modifications are verified against the provided testbench and meet the updated specifications.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Develop assertion properties to verify the addresses of the `blake2s` module that are **not** readable.\n\n1. **As a first step**, for the predefined addresses:  \n   `{ ADDR_NAME0, ADDR_NAME1, ADDR_VERSION, ADDR_CTRL, ADDR_STATUS, ADDR_BLOCKLEN, ADDR_BLOCK0, ADDR_BLOCK15, ADDR_DIGEST0, ADDR_DIGEST7 }`,  \n   identify which addresses are not readable.\n\n2. **As a second step**, for each **non-readable** address, write an assertion property to verify that:\n   - the address is indeed not readable, and  \n   - the value returned is always the default value for `read_data`.\n\n   If multiple addresses represent a contiguous range of the same type (e.g., `ADDR_BLOCK0` to `ADDR_BLOCK15`), cover them using a single property if feasible.\n\nImplementation requirements:\n- The assertion properties must be placed in a separate module named `blake2s_not_readable_addresses_check`, which instantiates the `blake2s` module as the Device Under Test (DUT).  \n- The properties must reference internal DUT signals directly for verification purposes.\n", "context": {"rtl/blake2s.v": "//======================================================================\n//\n// blake2s.v\n// --------\n// Top level wrapper for the blake2s hash function core providing\n// a simple memory like interface with 32 bit data access.\n//\n//\n// Author: Joachim Str\u00f6mbergson// Copyright (c) 2018, Assured AB\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\nmodule blake2s(\n               input wire           clk,\n               input wire           reset_n,\n\n               input wire           cs,\n               input wire           we,\n\n               input wire  [7 : 0]  address,\n               input wire  [31 : 0] write_data,\n               output wire [31 : 0] read_data\n              );\n\n\n  //----------------------------------------------------------------\n  // Internal constant and parameter definitions.\n  //----------------------------------------------------------------\n  localparam ADDR_NAME0       = 8'h00;\n  localparam ADDR_NAME1       = 8'h01;\n  localparam ADDR_VERSION     = 8'h02;\n\n  localparam ADDR_CTRL        = 8'h08;\n  localparam CTRL_INIT_BIT    = 0;\n  localparam CTRL_UPDATE_BIT  = 1;\n  localparam CTRL_FINISH_BIT  = 2;\n\n  localparam ADDR_STATUS      = 8'h09;\n  localparam STATUS_READY_BIT = 0;\n\n  localparam ADDR_BLOCKLEN    = 8'h0a;\n\n  localparam ADDR_BLOCK0      = 8'h10;\n  localparam ADDR_BLOCK15     = 8'h1f;\n\n  localparam ADDR_DIGEST0     = 8'h40;\n  localparam ADDR_DIGEST7     = 8'h47;\n\n\n  localparam CORE_NAME0   = 32'h626c616b; // \"blak\"\n  localparam CORE_NAME1   = 32'h65327320; // \"e2s \"\n  localparam CORE_VERSION = 32'h302e3830; // \"0.80\"\n\n\n  //----------------------------------------------------------------\n  // Registers including update variables and write enable.\n  //----------------------------------------------------------------\n  reg          init_reg;\n  reg          init_new;\n  reg          update_reg;\n  reg          update_new;\n  reg          finish_reg;\n  reg          finish_new;\n  reg [6 : 0]  blocklen_reg;\n  reg          blocklen_we;\n\n  reg [31 : 0] block_mem [0 : 15];\n  reg          block_mem_we;\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  wire           core_ready;\n  wire [511 : 0] core_block;\n  wire [255 : 0] core_digest;\n\n  reg [31 : 0]   tmp_read_data;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign core_block = {block_mem[0],  block_mem[1],  block_mem[2],  block_mem[3],\n                       block_mem[4],  block_mem[5],  block_mem[6],  block_mem[7],\n                       block_mem[8],  block_mem[9],  block_mem[10], block_mem[11],\n                       block_mem[12], block_mem[13], block_mem[14], block_mem[15]};\n\n  assign read_data = tmp_read_data;\n\n\n  //----------------------------------------------------------------\n  // core instantiation.\n  //----------------------------------------------------------------\n  blake2s_core core(\n                    .clk(clk),\n                    .reset_n(reset_n),\n\n                    .init(init_reg),\n                    .update(update_reg),\n                    .finish(finish_reg),\n\n                    .block(core_block),\n                    .blocklen(blocklen_reg),\n\n                    .digest(core_digest),\n                    .ready(core_ready)\n                   );\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //----------------------------------------------------------------\n  always @ (posedge clk)\n    begin : reg_update\n      integer i;\n\n      if (!reset_n)\n        begin\n          for (i = 0 ; i < 16 ; i = i + 1)\n            block_mem[i] <= 32'h0;\n\n          init_reg     <= 1'h0;\n          update_reg   <= 1'h0;\n          finish_reg   <= 1'h0;\n          blocklen_reg <= 7'h0;\n        end\n      else\n        begin\n          init_reg   <= init_new;\n          update_reg <= update_new;\n          finish_reg <= finish_new;\n\n          if (blocklen_we) begin\n            blocklen_reg <= write_data[6 : 0];\n          end\n\n          if (block_mem_we) begin\n            block_mem[address[3 : 0]] <= write_data;\n          end\n        end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // api\n  // The interface command decoding logic.\n  //----------------------------------------------------------------\n  always @*\n    begin : api\n      init_new      = 1'h0;\n      update_new    = 1'h0;\n      finish_new    = 1'h0;\n      block_mem_we  = 1'h0;\n      blocklen_we   = 1'h0;\n      tmp_read_data = 32'h0;\n\n      if (cs)\n        begin\n          if (we)\n            begin\n              if (address == ADDR_CTRL) begin\n                init_new   = write_data[CTRL_INIT_BIT];\n                update_new = write_data[CTRL_UPDATE_BIT];\n                finish_new = write_data[CTRL_FINISH_BIT];\n              end\n\n              if (address == ADDR_BLOCKLEN) begin\n                blocklen_we = 1;\n              end\n\n              if ((address >= ADDR_BLOCK0) && (address <= ADDR_BLOCK15)) begin\n                block_mem_we = 1;\n              end\n            end\n\n          else\n            begin\n              if (address == ADDR_NAME0) begin\n                tmp_read_data = CORE_NAME0;\n              end\n\n              if (address == ADDR_NAME1) begin\n                tmp_read_data = CORE_NAME1;\n              end\n\n              if (address == ADDR_VERSION) begin\n                tmp_read_data = CORE_VERSION;\n              end\n\n              if (address == ADDR_STATUS) begin\n                tmp_read_data = {31'h0, core_ready};\n              end\n\n              if ((address >= ADDR_DIGEST0) && (address <= ADDR_DIGEST7)) begin\n                tmp_read_data = core_digest[(7 - (address - ADDR_DIGEST0)) * 32 +: 32];\n              end\n            end\n        end\n    end // api\nendmodule // blake2s\n\n//======================================================================\n// EOF blake2s.v\n//======================================================================", "rtl/blake2s_G.v": "//======================================================================\n//\n// blake2s_G.v\n// -----------\n// Verilog 2001 implementation of the G function in the\n// blake2s hash function core. This is pure combinational logic in a\n// separade module to allow us to build versions  with 1, 2, 4\n// and even 8 parallel compression functions.\n//\n//\n// Author: Joachim Str\u00f6mbergson\n// Copyright (c) 2018, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\nmodule blake2s_G(\n                 input wire [31 : 0]  a,\n                 input wire [31 : 0]  b,\n                 input wire [31 : 0]  c,\n                 input wire [31 : 0]  d,\n                 input wire [31 : 0]  m0,\n                 input wire [31 : 0]  m1,\n\n                 output wire [31 : 0] a_prim,\n                 output wire [31 : 0] b_prim,\n                 output wire [31 : 0] c_prim,\n                 output wire [31 : 0] d_prim\n                );\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg [31 : 0] a1;\n  reg [31 : 0] a2;\n  reg [31 : 0] b1;\n  reg [31 : 0] b2;\n  reg [31 : 0] b3;\n  reg [31 : 0] b4;\n  reg [31 : 0] c1;\n  reg [31 : 0] c2;\n  reg [31 : 0] d1;\n  reg [31 : 0] d2;\n  reg [31 : 0] d3;\n  reg [31 : 0] d4;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports.\n  //----------------------------------------------------------------\n  assign a_prim = a2;\n  assign b_prim = b4;\n  assign c_prim = c2;\n  assign d_prim = d4;\n\n\n  //----------------------------------------------------------------\n  // G_function\n  //----------------------------------------------------------------\n  always @*\n    begin : G_function\n      a1 = a + b + m0;\n\n      d1 = d ^ a1;\n      d2 = {d1[15 : 0], d1[31 : 16]};\n\n      c1 = c + d2;\n\n      b1 = b ^ c1;\n      b2 = {b1[11 : 0], b1[31 : 12]};\n\n      a2 = a1 + b2 + m1;\n\n      d3 = d2 ^ a2;\n      d4 = {d3[7 : 0], d3[31 : 8]};\n\n      c2 = c1 + d4;\n\n      b3 = b2 ^ c2;\n      b4 = {b3[6 : 0], b3[31 : 7]};\n    end // G_function\nendmodule // blake2s_G\n\n//======================================================================\n// EOF blake2s_G.v\n//======================================================================", "rtl/blake2s_core.v": "//======================================================================\n//\n// blake2s_core.v\n// --------------\n// Verilog 2001 implementation of the hash function blake2s.\n// This is the internal core with wide interfaces.\n//\n//\n// Author: Joachim Str\u00f6mbergson\n// Copyright (c) 2018, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\nmodule blake2s_core(\n                    input wire            clk,\n                    input wire            reset_n,\n\n                    input wire            init,\n                    input wire            update,\n                    input wire            finish,\n\n                    input wire [511 : 0]  block,\n                    input wire [6 : 0]    blocklen,\n\n                    output wire [255 : 0] digest,\n                    output wire           ready\n                  );\n\n\n  //----------------------------------------------------------------\n  // Parameter block.\n  // See BLAKE2 paper and RFC 7693 for definition.\n  // Chapter 2.8 in https://blake2.net/blake2.pdf\n  // Section 2.5 in https://tools.ietf.org/html/rfc7693\n  //----------------------------------------------------------------\n  // The digest length in bytes. Minimum: 1, Maximum: 32\n  localparam [7 : 0]  DIGEST_LENGTH   = 8'd32;\n  localparam [7 : 0]  KEY_LENGTH      = 8'd0;\n  localparam [7 : 0]  FANOUT          = 8'd1;\n  localparam [7 : 0]  DEPTH           = 8'd01;\n  localparam [31 : 0] LEAF_LENGTH     = 32'd0;\n  localparam [47 : 0] NODE_OFFSET     = 48'd0;\n  localparam [7 : 0]  NODE_DEPTH      = 8'd0;\n  localparam [7 : 0]  INNER_LENGTH    = 8'd0;\n  localparam [63 : 0] SALT            = 64'h0;\n  localparam [63 : 0] PERSONALIZATION = 64'h0;\n\n  wire [255 : 0] parameter_block = {PERSONALIZATION, SALT, INNER_LENGTH,\n                                    NODE_DEPTH, NODE_OFFSET, LEAF_LENGTH,\n                                    DEPTH, FANOUT, KEY_LENGTH, DIGEST_LENGTH};\n\n\n  //----------------------------------------------------------------\n  // Internal constant definitions.\n  //----------------------------------------------------------------\n  localparam NUM_ROUNDS  = 10;\n  localparam BLOCK_BYTES = 7'd64;\n\n  // G function modes.\n  localparam G_ROW      = 1'h0;\n  localparam G_DIAGONAL = 1'h1;\n\n  // Initial vectors.\n  localparam IV0 = 32'h6a09e667;\n  localparam IV1 = 32'hbb67ae85;\n  localparam IV2 = 32'h3c6ef372;\n  localparam IV3 = 32'ha54ff53a;\n  localparam IV4 = 32'h510e527f;\n  localparam IV5 = 32'h9b05688c;\n  localparam IV6 = 32'h1f83d9ab;\n  localparam IV7 = 32'h5be0cd19;\n\n  // Control FSM state names.\n  localparam CTRL_IDLE       = 3'h0;\n  localparam CTRL_INIT_ROUND = 3'h1;\n  localparam CTRL_G_ROW      = 3'h2;\n  localparam CTRL_G_DIAGONAL = 3'h3;\n  localparam CTRL_COMP_DONE  = 3'h4;\n  localparam CTRL_FINISH     = 3'h5;\n\n\n  //----------------------------------------------------------------\n  // Registers including update variables and write enable.\n  //----------------------------------------------------------------\n  reg [31 : 0] h_reg [0 : 7];\n  reg [31 : 0] h_new [0 : 7];\n  reg          h_we;\n\n  reg [31 : 0] v_reg [0 : 15];\n  reg [31 : 0] v_new [0 : 15];\n  reg          v_we;\n  reg          init_v;\n  reg          update_v;\n\n  reg [3 : 0]  round_ctr_reg;\n  reg [3 : 0]  round_ctr_new;\n  reg          round_ctr_we;\n  reg          round_ctr_inc;\n  reg          round_ctr_rst;\n\n  reg [31 : 0] t0_reg;\n  reg [31 : 0] t0_new;\n  reg          t0_we;\n  reg [31 : 0] t1_reg;\n  reg [31 : 0] t1_new;\n  reg          t1_we;\n  reg          t_ctr_inc;\n  reg          t_ctr_rst;\n\n  reg          last_reg;\n  reg          last_new;\n  reg          last_we;\n\n  reg          ready_reg;\n  reg          ready_new;\n  reg          ready_we;\n\n  reg [2 : 0]  blake2s_ctrl_reg;\n  reg [2 : 0]  blake2s_ctrl_new;\n  reg          blake2s_ctrl_we;\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg init_state;\n  reg update_state;\n  reg load_m;\n  reg G_mode;\n\n  reg  [31 : 0] G0_a;\n  reg  [31 : 0] G0_b;\n  reg  [31 : 0] G0_c;\n  reg  [31 : 0] G0_d;\n  wire [31 : 0] G0_m0;\n  wire [31 : 0] G0_m1;\n  wire [31 : 0] G0_a_prim;\n  wire [31 : 0] G0_b_prim;\n  wire [31 : 0] G0_c_prim;\n  wire [31 : 0] G0_d_prim;\n\n  reg  [31 : 0] G1_a;\n  reg  [31 : 0] G1_b;\n  reg  [31 : 0] G1_c;\n  reg  [31 : 0] G1_d;\n  wire [31 : 0] G1_m0;\n  wire [31 : 0] G1_m1;\n  wire [31 : 0] G1_a_prim;\n  wire [31 : 0] G1_b_prim;\n  wire [31 : 0] G1_c_prim;\n  wire [31 : 0] G1_d_prim;\n\n  reg  [31 : 0] G2_a;\n  reg  [31 : 0] G2_b;\n  reg  [31 : 0] G2_c;\n  reg  [31 : 0] G2_d;\n  wire [31 : 0] G2_m0;\n  wire [31 : 0] G2_m1;\n  wire [31 : 0] G2_a_prim;\n  wire [31 : 0] G2_b_prim;\n  wire [31 : 0] G2_c_prim;\n  wire [31 : 0] G2_d_prim;\n\n  reg  [31 : 0] G3_a;\n  reg  [31 : 0] G3_b;\n  reg  [31 : 0] G3_c;\n  reg  [31 : 0] G3_d;\n  wire [31 : 0] G3_m0;\n  wire [31 : 0] G3_m1;\n  wire [31 : 0] G3_a_prim;\n  wire [31 : 0] G3_b_prim;\n  wire [31 : 0] G3_c_prim;\n  wire [31 : 0] G3_d_prim;\n\n\n  //----------------------------------------------------------------\n  // Module instantations.\n  //----------------------------------------------------------------\n  blake2s_m_select mselect(\n                           .clk(clk),\n                           .reset_n(reset_n),\n                           .load(load_m),\n                           .m(block),\n                           .round(round_ctr_reg),\n                           .mode(G_mode),\n                           .G0_m0(G0_m0),\n                           .G0_m1(G0_m1),\n                           .G1_m0(G1_m0),\n                           .G1_m1(G1_m1),\n                           .G2_m0(G2_m0),\n                           .G2_m1(G2_m1),\n                           .G3_m0(G3_m0),\n                           .G3_m1(G3_m1)\n                          );\n\n\n  blake2s_G G0(\n               .a(G0_a),\n               .b(G0_b),\n               .c(G0_c),\n               .d(G0_d),\n               .m0(G0_m0),\n               .m1(G0_m1),\n               .a_prim(G0_a_prim),\n               .b_prim(G0_b_prim),\n               .c_prim(G0_c_prim),\n               .d_prim(G0_d_prim)\n              );\n\n\n  blake2s_G G1(\n               .a(G1_a),\n               .b(G1_b),\n               .c(G1_c),\n               .d(G1_d),\n               .m0(G1_m0),\n               .m1(G1_m1),\n               .a_prim(G1_a_prim),\n               .b_prim(G1_b_prim),\n               .c_prim(G1_c_prim),\n               .d_prim(G1_d_prim)\n              );\n\n\n  blake2s_G G2(\n               .a(G2_a),\n               .b(G2_b),\n               .c(G2_c),\n               .d(G2_d),\n               .m0(G2_m0),\n               .m1(G2_m1),\n\n               .a_prim(G2_a_prim),\n               .b_prim(G2_b_prim),\n               .c_prim(G2_c_prim),\n               .d_prim(G2_d_prim)\n              );\n\n\n  blake2s_G G3(\n               .a(G3_a),\n               .b(G3_b),\n               .c(G3_c),\n               .d(G3_d),\n               .m0(G3_m0),\n               .m1(G3_m1),\n               .a_prim(G3_a_prim),\n               .b_prim(G3_b_prim),\n               .c_prim(G3_c_prim),\n               .d_prim(G3_d_prim)\n              );\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign digest = {h_reg[0][7 : 0], h_reg[0][15 : 8], h_reg[0][23 : 16], h_reg[0][31 : 24],\n                   h_reg[1][7 : 0], h_reg[1][15 : 8], h_reg[1][23 : 16], h_reg[1][31 : 24],\n                   h_reg[2][7 : 0], h_reg[2][15 : 8], h_reg[2][23 : 16], h_reg[2][31 : 24],\n                   h_reg[3][7 : 0], h_reg[3][15 : 8], h_reg[3][23 : 16], h_reg[3][31 : 24],\n                   h_reg[4][7 : 0], h_reg[4][15 : 8], h_reg[4][23 : 16], h_reg[4][31 : 24],\n                   h_reg[5][7 : 0], h_reg[5][15 : 8], h_reg[5][23 : 16], h_reg[5][31 : 24],\n                   h_reg[6][7 : 0], h_reg[6][15 : 8], h_reg[6][23 : 16], h_reg[6][31 : 24],\n                   h_reg[7][7 : 0], h_reg[7][15 : 8], h_reg[7][23 : 16], h_reg[7][31 : 24]};\n\n  assign ready = ready_reg;\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //----------------------------------------------------------------\n  always @ (posedge clk)\n    begin : reg_update\n      integer i;\n\n      if (!reset_n) begin\n        for (i = 0; i < 8; i = i + 1) begin\n          h_reg[i] <= 32'h0;\n        end\n\n        for (i = 0; i < 16; i = i + 1) begin\n          v_reg[i] <= 32'h0;\n        end\n\n        t0_reg           <= 32'h0;\n        t1_reg           <= 32'h0;\n        last_reg         <= 1'h0;\n        ready_reg        <= 1'h1;\n        round_ctr_reg    <= 4'h0;\n        blake2s_ctrl_reg <= CTRL_IDLE;\n      end\n      else begin\n        if (h_we) begin\n          for (i = 0; i < 8; i = i + 1) begin\n            h_reg[i] <= h_new[i];\n          end\n        end\n\n        if (v_we) begin\n          for (i = 0; i < 16; i = i + 1) begin\n            v_reg[i] <= v_new[i];\n          end\n        end\n\n        if (t0_we) begin\n          t0_reg <= t0_new;\n        end\n\n        if (t1_we) begin\n          t1_reg <= t1_new;\n        end\n\n        if (last_we) begin\n          last_reg <= last_new;\n        end\n\n        if (ready_we) begin\n          ready_reg <= ready_new;\n        end\n\n        if (round_ctr_we) begin\n          round_ctr_reg <= round_ctr_new;\n        end\n\n        if (blake2s_ctrl_we) begin\n          blake2s_ctrl_reg <= blake2s_ctrl_new;\n        end\n      end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // state_logic\n  //\n  // Logic for updating the hash state.\n  //----------------------------------------------------------------\n  always @*\n    begin : state_logic\n      integer i;\n\n      for (i = 0; i < 8; i = i + 1) begin\n        h_new[i] = 32'h0;\n      end\n      h_we   = 1'h0;\n\n      if (init_state) begin\n        h_new[0] = IV0 ^ parameter_block[31  :   0];\n        h_new[1] = IV1 ^ parameter_block[63  :  32];\n        h_new[2] = IV2 ^ parameter_block[95  :  64];\n        h_new[3] = IV3 ^ parameter_block[127 :  96];\n        h_new[4] = IV4 ^ parameter_block[159 : 128];\n        h_new[5] = IV5 ^ parameter_block[191 : 160];\n        h_new[6] = IV6 ^ parameter_block[223 : 192];\n        h_new[7] = IV7 ^ parameter_block[255 : 224];\n        h_we     = 1;\n      end\n\n      if (update_state) begin\n        h_new[0] = h_reg[0] ^ v_reg[0] ^ v_reg[8];\n        h_new[1] = h_reg[1] ^ v_reg[1] ^ v_reg[9];\n        h_new[2] = h_reg[2] ^ v_reg[2] ^ v_reg[10];\n        h_new[3] = h_reg[3] ^ v_reg[3] ^ v_reg[11];\n        h_new[4] = h_reg[4] ^ v_reg[4] ^ v_reg[12];\n        h_new[5] = h_reg[5] ^ v_reg[5] ^ v_reg[13];\n        h_new[6] = h_reg[6] ^ v_reg[6] ^ v_reg[14];\n        h_new[7] = h_reg[7] ^ v_reg[7] ^ v_reg[15];\n        h_we     = 1;\n      end\n    end // state_logic\n\n\n  //----------------------------------------------------------------\n  // compress_logic\n  //----------------------------------------------------------------\n  always @*\n    begin : compress_logic\n      integer i;\n\n      for (i = 0; i < 16; i = i + 1) begin\n        v_new[i] = 32'h0;\n      end\n      v_we = 1'h0;\n\n      G0_a = 32'h0;\n      G0_b = 32'h0;\n      G0_c = 32'h0;\n      G0_d = 32'h0;\n      G1_a = 32'h0;\n      G1_b = 32'h0;\n      G1_c = 32'h0;\n      G1_d = 32'h0;\n      G2_a = 32'h0;\n      G2_b = 32'h0;\n      G2_c = 32'h0;\n      G2_d = 32'h0;\n      G3_a = 32'h0;\n      G3_b = 32'h0;\n      G3_c = 32'h0;\n      G3_d = 32'h0;\n\n      if (init_v)\n        begin\n          v_new[0]  = h_reg[0];\n          v_new[1]  = h_reg[1];\n          v_new[2]  = h_reg[2];\n          v_new[3]  = h_reg[3];\n          v_new[4]  = h_reg[4];\n          v_new[5]  = h_reg[5];\n          v_new[6]  = h_reg[6];\n          v_new[7]  = h_reg[7];\n          v_new[8]  = IV0;\n          v_new[9]  = IV1;\n          v_new[10] = IV2;\n          v_new[11] = IV3;\n          v_new[12] = t0_reg ^ IV4;\n          v_new[13] = t1_reg ^ IV5;\n\n          if (last_reg) begin\n            v_new[14] = ~IV6;\n          end else begin\n            v_new[14] = IV6;\n          end\n\n          v_new[15] = IV7;\n          v_we = 1;\n        end\n\n      if (update_v)\n        begin\n          v_we = 1;\n\n          if (G_mode == G_ROW) begin\n            // Row updates.\n            G0_a      = v_reg[0];\n            G0_b      = v_reg[4];\n            G0_c      = v_reg[8];\n            G0_d      = v_reg[12];\n            v_new[0]  = G0_a_prim;\n            v_new[4]  = G0_b_prim;\n            v_new[8]  = G0_c_prim;\n            v_new[12] = G0_d_prim;\n\n            G1_a      = v_reg[1];\n            G1_b      = v_reg[5];\n            G1_c      = v_reg[9];\n            G1_d      = v_reg[13];\n            v_new[1]  = G1_a_prim;\n            v_new[5]  = G1_b_prim;\n            v_new[9]  = G1_c_prim;\n            v_new[13] = G1_d_prim;\n\n            G2_a      = v_reg[2];\n            G2_b      = v_reg[6];\n            G2_c      = v_reg[10];\n            G2_d      = v_reg[14];\n            v_new[2]  = G2_a_prim;\n            v_new[6]  = G2_b_prim;\n            v_new[10] = G2_c_prim;\n            v_new[14] = G2_d_prim;\n\n            G3_a      = v_reg[3];\n            G3_b      = v_reg[7];\n            G3_c      = v_reg[11];\n            G3_d      = v_reg[15];\n            v_new[3]  = G3_a_prim;\n            v_new[7]  = G3_b_prim;\n            v_new[11] = G3_c_prim;\n            v_new[15] = G3_d_prim;\n          end\n          else begin\n            // Diagonal updates.\n            G0_a      = v_reg[0];\n            G0_b      = v_reg[5];\n            G0_c      = v_reg[10];\n            G0_d      = v_reg[15];\n            v_new[0]  = G0_a_prim;\n            v_new[5]  = G0_b_prim;\n            v_new[10] = G0_c_prim;\n            v_new[15] = G0_d_prim;\n\n            G1_a      = v_reg[1];\n            G1_b      = v_reg[6];\n            G1_c      = v_reg[11];\n            G1_d      = v_reg[12];\n            v_new[1]  = G1_a_prim;\n            v_new[6]  = G1_b_prim;\n            v_new[11] = G1_c_prim;\n            v_new[12] = G1_d_prim;\n\n            G2_a      = v_reg[2];\n            G2_b      = v_reg[7];\n            G2_c      = v_reg[8];\n            G2_d      = v_reg[13];\n            v_new[2]  = G2_a_prim;\n            v_new[7]  = G2_b_prim;\n            v_new[8]  = G2_c_prim;\n            v_new[13] = G2_d_prim;\n\n            G3_a      = v_reg[3];\n            G3_b      = v_reg[4];\n            G3_c      = v_reg[9];\n            G3_d      = v_reg[14];\n            v_new[3]  = G3_a_prim;\n            v_new[4]  = G3_b_prim;\n            v_new[9]  = G3_c_prim;\n            v_new[14] = G3_d_prim;\n          end\n        end // if (update_v)\n    end // compress_logic\n\n\n  //----------------------------------------------------------------\n  // t_ctr\n  // Update logic for the length counter t, a monotonically\n  // increasing counter with reset.\n  //----------------------------------------------------------------\n  always @*\n    begin : t_ctr\n      t0_new = 32'h0;\n      t0_we  = 1'h0;\n      t1_new = 32'h0;\n      t1_we  = 1'h0;\n\n      if (t_ctr_rst) begin\n        t0_new = 32'h0;\n        t0_we  = 1'h1;\n        t1_new = 32'h0;\n        t1_we  = 1'h1;\n      end\n\n      if (t_ctr_inc) begin\n        t0_we = 1'h1;\n\n        if (last_new) begin\n          t0_new = t0_reg + {25'h0, blocklen};\n        end else begin\n          t0_new = t0_reg + {25'h0, BLOCK_BYTES};\n        end\n\n        if (t0_new < t0_reg) begin\n          t1_new = t1_reg + 1'h1;\n          t1_we  = 1'h1;\n        end\n      end\n    end // t_ctr\n\n\n  //----------------------------------------------------------------\n  // round_ctr\n  // Update logic for the round counter, a monotonically\n  // increasing counter with reset.\n  //----------------------------------------------------------------\n  always @*\n    begin : round_ctr\n      round_ctr_new = 4'h0;\n      round_ctr_we  = 1'h0;\n\n      if (round_ctr_rst)\n        begin\n          round_ctr_new = 4'h0;\n          round_ctr_we  = 1'h1;\n        end\n\n      if (round_ctr_inc)\n        begin\n          round_ctr_new = round_ctr_reg + 1'b1;\n          round_ctr_we  = 1'h1;\n        end\n    end // round_ctr\n\n\n  //----------------------------------------------------------------\n  // blake2s_ctrl\n  //----------------------------------------------------------------\n  always @*\n    begin : blake2s_ctrl\n      init_state         = 1'h0;\n      update_state       = 1'h0;\n      init_v             = 1'h0;\n      update_v           = 1'h0;\n      load_m             = 1'h0;\n      G_mode             = G_ROW;\n      round_ctr_inc      = 1'h0;\n      round_ctr_rst      = 1'h0;\n      t_ctr_inc          = 1'h0;\n      t_ctr_rst          = 1'h0;\n      last_new           = 1'h0;\n      last_we            = 1'h0;\n      ready_new          = 1'h0;\n      ready_we           = 1'h0;\n      blake2s_ctrl_new   = CTRL_IDLE;\n      blake2s_ctrl_we    = 1'h0;\n\n\n      case (blake2s_ctrl_reg)\n        CTRL_IDLE: begin\n          if (init) begin\n            last_new         = 1'h0;\n            last_we          = 1'h1;\n            init_state       = 1'h1;\n            t_ctr_rst        = 1'h1;\n            ready_new        = 1'h0;\n            ready_we         = 1'h1;\n            blake2s_ctrl_new = CTRL_FINISH;\n            blake2s_ctrl_we  = 1'h1;\n          end\n\n          if (update) begin\n            if (blocklen == BLOCK_BYTES) begin\n              load_m           = 1'h1;\n              t_ctr_inc        = 1'h1;\n              ready_new        = 1'h0;\n              ready_we         = 1'h1;\n              blake2s_ctrl_new = CTRL_INIT_ROUND;\n              blake2s_ctrl_we  = 1'h1;\n            end\n          end\n\n          if (finish) begin\n            load_m           = 1'h1;\n            t_ctr_inc        = 1'h1;\n            last_new         = 1'h1;\n            last_we          = 1'h1;\n            ready_new        = 1'h0;\n            ready_we         = 1'h1;\n            blake2s_ctrl_new = CTRL_INIT_ROUND;\n            blake2s_ctrl_we  = 1'h1;\n          end\n        end\n\n\n        CTRL_INIT_ROUND: begin\n          init_v           = 1'h1;\n          round_ctr_rst    = 1'h1;\n          blake2s_ctrl_new = CTRL_G_ROW;\n          blake2s_ctrl_we  = 1'h1;\n        end\n\n\n        CTRL_G_ROW: begin\n          G_mode           = G_ROW;\n          update_v         = 1'h1;\n          blake2s_ctrl_new = CTRL_G_DIAGONAL;\n          blake2s_ctrl_we  = 1'h1;\n        end\n\n\n        CTRL_G_DIAGONAL: begin\n          G_mode           = G_DIAGONAL;\n          update_v         = 1'h1;\n          round_ctr_inc    = 1'h1;\n          if (round_ctr_reg == (NUM_ROUNDS - 1)) begin\n            blake2s_ctrl_new = CTRL_COMP_DONE;\n            blake2s_ctrl_we  = 1'h1;\n          end\n          else begin\n            blake2s_ctrl_new = CTRL_G_ROW;\n            blake2s_ctrl_we  = 1'h1;\n          end\n        end\n\n\n        CTRL_COMP_DONE: begin\n          last_new           = 1'h0;\n          last_we            = 1'h1;\n          update_state       = 1'h1;\n          blake2s_ctrl_new   = CTRL_FINISH;\n          blake2s_ctrl_we    = 1'h1;\n        end\n\n\n        CTRL_FINISH: begin\n          ready_new        = 1'h1;\n          ready_we         = 1'h1;\n          blake2s_ctrl_new = CTRL_IDLE;\n          blake2s_ctrl_we  = 1'h1;\n        end\n\n\n        default: begin end\n      endcase // case (blake2s_ctrl_reg)\n    end // blake2s_ctrl\nendmodule // blake2s_core\n\n//======================================================================\n// EOF blake2s_core.v\n//======================================================================", "rtl/blake2s_m_select.v": "//======================================================================\n//\n// blake2s_m_select.v\n// ------------------\n// Verilog 2001 implementation of the message word selection in the\n// blake2 hash function core. Based on the given round and mode, we\n// extract the indices for the eight m words to select.\n// The words are then selected and returned. This is basically a\n// mux based implementation of the permutation table in combination\n// with the actual word selection.\n//\n//\n// Note that we use the mode to signal which indices to select\n// for a given round. This is because we don't do 8 G-functions\n// in a single cycle.\n//\n//\n// Author: Joachim Str\u00f6mbergson\n// Copyright (c) 2018, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\nmodule blake2s_m_select(\n                        input wire           clk,\n                        input wire           reset_n,\n\n                        input wire           load,\n                        input wire [511 : 0] m,\n\n                        input wire [3 : 0]   round,\n                        input wire           mode,\n\n                        output wire [31 : 0] G0_m0,\n                        output wire [31 : 0] G0_m1,\n                        output wire [31 : 0] G1_m0,\n                        output wire [31 : 0] G1_m1,\n                        output wire [31 : 0] G2_m0,\n                        output wire [31 : 0] G2_m1,\n                        output wire [31 : 0] G3_m0,\n                        output wire [31 : 0] G3_m1\n                       );\n\n\n  //----------------------------------------------------------------\n  // regs.\n  //----------------------------------------------------------------\n  reg [31 : 0] m_mem [0 : 15];\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg [3 : 0] i_G0_m0;\n  reg [3 : 0] i_G0_m1;\n  reg [3 : 0] i_G1_m0;\n  reg [3 : 0] i_G1_m1;\n  reg [3 : 0] i_G2_m0;\n  reg [3 : 0] i_G2_m1;\n  reg [3 : 0] i_G3_m0;\n  reg [3 : 0] i_G3_m1;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports.\n  //----------------------------------------------------------------\n  // Eight parallel, muxes that extract the message block words.\n  assign G0_m0 = m_mem[i_G0_m0];\n  assign G0_m1 = m_mem[i_G0_m1];\n  assign G1_m0 = m_mem[i_G1_m0];\n  assign G1_m1 = m_mem[i_G1_m1];\n  assign G2_m0 = m_mem[i_G2_m0];\n  assign G2_m1 = m_mem[i_G2_m1];\n  assign G3_m0 = m_mem[i_G3_m0];\n  assign G3_m1 = m_mem[i_G3_m1];\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //\n  // Update functionality for all registers in the core.\n  // All registers are positive edge triggered with synchronous,\n  // active low reset. All registers have write enable.\n  //----------------------------------------------------------------\n  always @ (posedge clk)\n    begin : reg_update\n      integer i;\n\n      if (!reset_n)\n        begin\n          for (i = 0 ; i < 16 ; i = i + 1)\n            m_mem[i] <= 32'h0;\n        end\n      else\n        begin\n          if (load)\n            begin\n              // Big to little endian conversion during register load.\n              m_mem[00] <= {m[0487 : 0480], m[0495 : 0488], m[0503 : 0496], m[0511 : 0504]};\n              m_mem[01] <= {m[0455 : 0448], m[0463 : 0456], m[0471 : 0464], m[0479 : 0472]};\n              m_mem[02] <= {m[0423 : 0416], m[0431 : 0424], m[0439 : 0432], m[0447 : 0440]};\n              m_mem[03] <= {m[0391 : 0384], m[0399 : 0392], m[0407 : 0400], m[0415 : 0408]};\n              m_mem[04] <= {m[0359 : 0352], m[0367 : 0360], m[0375 : 0368], m[0383 : 0376]};\n              m_mem[05] <= {m[0327 : 0320], m[0335 : 0328], m[0343 : 0336], m[0351 : 0344]};\n              m_mem[06] <= {m[0295 : 0288], m[0303 : 0296], m[0311 : 0304], m[0319 : 0312]};\n              m_mem[07] <= {m[0263 : 0256], m[0271 : 0264], m[0279 : 0272], m[0287 : 0280]};\n              m_mem[08] <= {m[0231 : 0224], m[0239 : 0232], m[0247 : 0240], m[0255 : 0248]};\n              m_mem[09] <= {m[0199 : 0192], m[0207 : 0200], m[0215 : 0208], m[0223 : 0216]};\n              m_mem[10] <= {m[0167 : 0160], m[0175 : 0168], m[0183 : 0176], m[0191 : 0184]};\n              m_mem[11] <= {m[0135 : 0128], m[0143 : 0136], m[0151 : 0144], m[0159 : 0152]};\n              m_mem[12] <= {m[0103 : 0096], m[0111 : 0104], m[0119 : 0112], m[0127 : 0120]};\n              m_mem[13] <= {m[0071 : 0064], m[0079 : 0072], m[0087 : 0080], m[0095 : 0088]};\n              m_mem[14] <= {m[0039 : 0032], m[0047 : 0040], m[0055 : 0048], m[0063 : 0056]};\n              m_mem[15] <= {m[0007 : 0000], m[0015 : 0008], m[0023 : 0016], m[0031 : 0024]};\n            end\n        end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // get_indices\n  //\n  // Get the indices from the permutation table given the\n  // round and the G function mode. This is the SIGMA table.\n  //----------------------------------------------------------------\n  always @*\n    begin : get_indices\n      i_G0_m0 = 4'd0;\n      i_G0_m1 = 4'd0;\n      i_G1_m0 = 4'd0;\n      i_G1_m1 = 4'd0;\n      i_G2_m0 = 4'd0;\n      i_G2_m1 = 4'd0;\n      i_G3_m0 = 4'd0;\n      i_G3_m1 = 4'd0;\n\n      case ({round, mode})\n        0: begin\n          i_G0_m0 = 4'd00;\n          i_G0_m1 = 4'd01;\n          i_G1_m0 = 4'd02;\n          i_G1_m1 = 4'd03;\n          i_G2_m0 = 4'd04;\n          i_G2_m1 = 4'd05;\n          i_G3_m0 = 4'd06;\n          i_G3_m1 = 4'd07;\n        end\n\n        1: begin\n          i_G0_m0 = 4'd08;\n          i_G0_m1 = 4'd09;\n          i_G1_m0 = 4'd10;\n          i_G1_m1 = 4'd11;\n          i_G2_m0 = 4'd12;\n          i_G2_m1 = 4'd13;\n          i_G3_m0 = 4'd14;\n          i_G3_m1 = 4'd15;\n        end\n\n        2: begin\n          i_G0_m0 = 4'd14;\n          i_G0_m1 = 4'd10;\n          i_G1_m0 = 4'd04;\n          i_G1_m1 = 4'd08;\n          i_G2_m0 = 4'd09;\n          i_G2_m1 = 4'd15;\n          i_G3_m0 = 4'd13;\n          i_G3_m1 = 4'd06;\n        end\n\n        3: begin\n          i_G0_m0 = 4'd01;\n          i_G0_m1 = 4'd12;\n          i_G1_m0 = 4'd00;\n          i_G1_m1 = 4'd02;\n          i_G2_m0 = 4'd11;\n          i_G2_m1 = 4'd07;\n          i_G3_m0 = 4'd05;\n          i_G3_m1 = 4'd03;\n        end\n\n        4: begin\n          i_G0_m0 = 4'd11;\n          i_G0_m1 = 4'd08;\n          i_G1_m0 = 4'd12;\n          i_G1_m1 = 4'd00;\n          i_G2_m0 = 4'd05;\n          i_G2_m1 = 4'd02;\n          i_G3_m0 = 4'd15;\n          i_G3_m1 = 4'd13;\n        end\n\n        5: begin\n          i_G0_m0 = 4'd10;\n          i_G0_m1 = 4'd14;\n          i_G1_m0 = 4'd03;\n          i_G1_m1 = 4'd06;\n          i_G2_m0 = 4'd07;\n          i_G2_m1 = 4'd01;\n          i_G3_m0 = 4'd09;\n          i_G3_m1 = 4'd04;\n        end\n\n        6: begin\n          i_G0_m0 = 4'd07;\n          i_G0_m1 = 4'd09;\n          i_G1_m0 = 4'd03;\n          i_G1_m1 = 4'd01;\n          i_G2_m0 = 4'd13;\n          i_G2_m1 = 4'd12;\n          i_G3_m0 = 4'd11;\n          i_G3_m1 = 4'd14;\n        end\n\n        7: begin\n          i_G0_m0 = 4'd02;\n          i_G0_m1 = 4'd06;\n          i_G1_m0 = 4'd05;\n          i_G1_m1 = 4'd10;\n          i_G2_m0 = 4'd04;\n          i_G2_m1 = 4'd00;\n          i_G3_m0 = 4'd15;\n          i_G3_m1 = 4'd08;\n        end\n\n        8: begin\n          i_G0_m0 = 4'd09;\n          i_G0_m1 = 4'd00;\n          i_G1_m0 = 4'd05;\n          i_G1_m1 = 4'd07;\n          i_G2_m0 = 4'd02;\n          i_G2_m1 = 4'd04;\n          i_G3_m0 = 4'd10;\n          i_G3_m1 = 4'd15;\n        end\n\n        9: begin\n          i_G0_m0 = 4'd14;\n          i_G0_m1 = 4'd01;\n          i_G1_m0 = 4'd11;\n          i_G1_m1 = 4'd12;\n          i_G2_m0 = 4'd06;\n          i_G2_m1 = 4'd08;\n          i_G3_m0 = 4'd03;\n          i_G3_m1 = 4'd13;\n        end\n\n        10: begin\n          i_G0_m0 = 4'd02;\n          i_G0_m1 = 4'd12;\n          i_G1_m0 = 4'd06;\n          i_G1_m1 = 4'd10;\n          i_G2_m0 = 4'd00;\n          i_G2_m1 = 4'd11;\n          i_G3_m0 = 4'd08;\n          i_G3_m1 = 4'd03;\n        end\n\n        11: begin\n          i_G0_m0 = 4'd04;\n          i_G0_m1 = 4'd13;\n          i_G1_m0 = 4'd07;\n          i_G1_m1 = 4'd05;\n          i_G2_m0 = 4'd15;\n          i_G2_m1 = 4'd14;\n          i_G3_m0 = 4'd01;\n          i_G3_m1 = 4'd09;\n        end\n\n        12: begin\n          i_G0_m0 = 4'd12;\n          i_G0_m1 = 4'd05;\n          i_G1_m0 = 4'd01;\n          i_G1_m1 = 4'd15;\n          i_G2_m0 = 4'd14;\n          i_G2_m1 = 4'd13;\n          i_G3_m0 = 4'd04;\n          i_G3_m1 = 4'd10;\n        end\n\n        13: begin\n          i_G0_m0 = 4'd00;\n          i_G0_m1 = 4'd07;\n          i_G1_m0 = 4'd06;\n          i_G1_m1 = 4'd03;\n          i_G2_m0 = 4'd09;\n          i_G2_m1 = 4'd02;\n          i_G3_m0 = 4'd08;\n          i_G3_m1 = 4'd11;\n        end\n\n        14: begin\n          i_G0_m0 = 4'd13;\n          i_G0_m1 = 4'd11;\n          i_G1_m0 = 4'd07;\n          i_G1_m1 = 4'd14;\n          i_G2_m0 = 4'd12;\n          i_G2_m1 = 4'd01;\n          i_G3_m0 = 4'd03;\n          i_G3_m1 = 4'd09;\n        end\n\n        15: begin\n          i_G0_m0 = 4'd05;\n          i_G0_m1 = 4'd00;\n          i_G1_m0 = 4'd15;\n          i_G1_m1 = 4'd04;\n          i_G2_m0 = 4'd08;\n          i_G2_m1 = 4'd06;\n          i_G3_m0 = 4'd02;\n          i_G3_m1 = 4'd10;\n        end\n\n        16: begin\n          i_G0_m0 = 4'd06;\n          i_G0_m1 = 4'd15;\n          i_G1_m0 = 4'd14;\n          i_G1_m1 = 4'd09;\n          i_G2_m0 = 4'd11;\n          i_G2_m1 = 4'd03;\n          i_G3_m0 = 4'd00;\n          i_G3_m1 = 4'd08;\n        end\n\n        17: begin\n          i_G0_m0 = 4'd12;\n          i_G0_m1 = 4'd02;\n          i_G1_m0 = 4'd13;\n          i_G1_m1 = 4'd07;\n          i_G2_m0 = 4'd01;\n          i_G2_m1 = 4'd04;\n          i_G3_m0 = 4'd10;\n          i_G3_m1 = 4'd05;\n        end\n\n        18: begin\n          i_G0_m0 = 4'd10;\n          i_G0_m1 = 4'd02;\n          i_G1_m0 = 4'd08;\n          i_G1_m1 = 4'd04;\n          i_G2_m0 = 4'd07;\n          i_G2_m1 = 4'd06;\n          i_G3_m0 = 4'd01;\n          i_G3_m1 = 4'd05;\n        end\n\n        19: begin\n          i_G0_m0 = 4'd15;\n          i_G0_m1 = 4'd11;\n          i_G1_m0 = 4'd09;\n          i_G1_m1 = 4'd14;\n          i_G2_m0 = 4'd03;\n          i_G2_m1 = 4'd12;\n          i_G3_m0 = 4'd13;\n          i_G3_m1 = 4'd00;\n        end\n\n        default: begin end\n      endcase // case ({round, mode})\n    end\n\nendmodule // blake2s_m_select\n\n//======================================================================\n// EOF blake2s_m_select.v\n//======================================================================", "verif/blake2s_not_readable_addresses_check.sv": "module blake2s_not_readable_addresses_check(\n               input wire           clk,\n               input wire           reset_n,\n\n               input wire           cs,\n               input wire           we,\n\n               input wire  [7 : 0]  address,\n               input wire  [31 : 0] write_data,\n               output wire [31 : 0] read_data\n              );\n\n    blake2s dut(\n        .clk(clk),\n        .reset_n(reset_n),\n        .cs(cs),\n        .we(we),\n        .address(address),\n        .write_data(write_data),\n        .read_data(read_data)\n    );\n\nendmodule : blake2s_not_readable_addresses_check"}, "patch": {"verif/blake2s_not_readable_addresses_check.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    image: verification_image\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n#      - ../../rundir:/code/rundir:rw\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/verif/blake2s_not_readable_addresses_check.sv /code/rtl/blake2s_m_select.v /code/rtl/blake2s_G.v /code/rtl/blake2s_core.v /code/rtl/blake2s.v\nTOPLEVEL        = blake2s_not_readable_addresses_check\nMODULE          = test_blake2s\nPYTHONPATH      = /src\nHASH            = fe26d6eb7dd05339c450af6a47af77408cea5e7e\nCOV_SELECTIONS  = read_block_address read_block_len_address read_ctrl_address\nCOV_THRESHOLDS  = 33.3 33.3 33.3\n", "src/coverage.py": "from cocotb.runner import get_runner\nimport os\nimport aes\nimport subprocess\nimport re\nfrom typing import Mapping\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\", cov_selection:str = \"\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    extra_env: Mapping[str, str] = {}\n    if cov_selection:\n        extra_env = { \"SELECTION\": cov_selection }\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\",\n                extra_env=extra_env)\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef coverage_report_clear():\n    report_file=\"/code/rundir/coverage.log\"\n    if os.path.isfile(report_file):\n        os.remove(report_file)\n\ndef coverage_report_check(cov_threshold:float = 100.0):\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    print(f'column: {column}')\n    for line in lines[2:]:\n        match = re.match(r'^(.*?)\\s+(\\d+\\.?\\d*% \\(\\d+/\\d+\\))\\s+(\\d+% \\(\\d+/\\d+/\\d+\\))', line.strip())\n        if match:\n            info = list(match.groups())\n            print(f'info: {info}')\n        else:\n            info = re.split(r'\\s{2,}', line.strip())\n            print(f\"no regular expression match, trying differently: {info}\")\n\n        inst = info[0].lstrip('|-')\n        print(f'inst: {inst}')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= cov_threshold, f\"Didn't achieved the required coverage result (cov_threshold={cov_threshold}).\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "\nfrom cocotb.binary import BinaryValue\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\n\nCLK_HALF_PERIOD = 1\nCLK_PERIOD = CLK_HALF_PERIOD * 2\nCLK_TIME_UNIT = 'ns'\n\nADDR_NAME0       = BinaryValue(0, 8, False)\nADDR_NAME1       = BinaryValue(1, 8, False)\nADDR_VERSION     = BinaryValue(2, 8, False)\n\nADDR_CTRL        = BinaryValue(8, 8, False)\nCTRL_INIT_BIT    = 0\nCTRL_UPDATE_BIT  = 1\nCTRL_FINISH_BIT  = 2\n\nADDR_STATUS      = BinaryValue(int('9', 16), 8, False)\nSTATUS_READY_BIT = 0\n\nADDR_BLOCKLEN    = BinaryValue(int('0a', 16), 8, False)\n\nADDR_BLOCK0      = BinaryValue(int('10', 16), 8, False)\nADDR_BLOCK15     = BinaryValue(int('1f', 16), 8, False)\n\nADDR_DIGEST0     = BinaryValue(int('40', 16), 8, False)\nADDR_DIGEST7     = BinaryValue(int('47', 16), 8, False)\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def init_sim(dut):\n    dut.reset_n.value = 1\n    dut.cs.value = 0\n    dut.we.value = 0\n    dut.address.value = 0\n    dut.write_data.value = 0\n\nasync def reset_dut(dut):\n    dut.reset_n.value = 0\n    await Timer(2 * CLK_PERIOD, units=CLK_TIME_UNIT)\n    dut.reset_n.value = 1\n    # await Timer(2 * CLK_PERIOD, units=CLK_TIME_UNIT)\n\nasync def write_word(dut, address: BinaryValue, word: BinaryValue):\n    dut.address.value = address\n    dut.write_data.value = word\n    dut.cs.value = 1\n    dut.we.value = 1\n\n    await Timer(2 * CLK_PERIOD, units=CLK_TIME_UNIT)\n    print(f'written word: {word.value}')\n    dut.cs.value = 0\n    dut.we.value = 0\n\nasync def read_word(dut, address: BinaryValue):\n    dut.address.value = address\n    dut.cs.value = 1\n    dut.we.value = 0\n\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n    dut.cs.value = 0\n    print(f'read word: {dut.read_data.value}')\n    return dut.read_data.value\n\nasync def wait_ready(dut):\n    read_data = await read_word(dut, ADDR_STATUS)\n    while read_data == 0:\n        read_data = await read_word(dut, ADDR_STATUS)\n\nasync def ready_after_init(dut):\n    dut.init.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.init.value = 0\n    await wait_ready(dut)\n\nasync def get_digest(dut):\n    digest = BinaryValue(0, 512, False)\n\n    read_data = await read_word(dut, ADDR_DIGEST0)\n    digest[255: 224] = read_data.integer\n\n    read_data = await read_word(dut, ADDR_DIGEST0 + 1)\n    digest[223: 192] = read_data.integer\n\n    read_data = await read_word(dut, ADDR_DIGEST0 + 2)\n    digest[191: 160] = read_data.integer\n\n    read_data = await read_word(dut, ADDR_DIGEST0 + 3)\n    digest[159: 128] = read_data.integer\n\n    read_data = await read_word(dut, ADDR_DIGEST0 + 4)\n    digest[127: 96] = read_data.integer\n\n    read_data = await read_word(dut, ADDR_DIGEST0 + 5)\n    digest[95: 64] = read_data.integer\n\n    read_data = await read_word(dut, ADDR_DIGEST0 + 6)\n    digest[63: 32] = read_data.integer\n\n    read_data = await read_word(dut, ADDR_DIGEST0 + 7)\n    digest[31: 0] = read_data.integer\n\n    return digest\n\nasync def clean_block(dut):\n    for i in range(0, 16):\n        await write_word(dut, ADDR_BLOCK0 + i, BinaryValue(0, 32, False))\n\ndef ctrl_set(bit_pos: int):\n    bit_set = 1 << bit_pos\n    return BinaryValue(bit_set, 32, False)\n\nasync def test_rfc_7693(dut):\n    await clean_block(dut)\n\n    await write_word(dut, ADDR_CTRL, ctrl_set(CTRL_INIT_BIT))\n    await wait_ready(dut)\n\n    # Set a word for digesting\n    word = BinaryValue(int('61626300', 16), 32, False)\n    await write_word(dut, ADDR_BLOCK0, word)\n\n    # Set the word length in bytes\n    block_len = BinaryValue(3, 32, False)\n    await write_word(dut, ADDR_BLOCKLEN, block_len)\n\n    # Set the dut to perform the finish operation\n    await write_word(dut, ADDR_CTRL, ctrl_set(CTRL_FINISH_BIT))\n    await wait_ready(dut)\n\n    digest_expected = int('508c5e8c327c14e2_e1a72ba34eeb452f_37458b209ed63a29_4d999b4c86675982', 16)\n    digest_computed = await get_digest(dut)\n\n    assert digest_computed == digest_expected, f'Mismatched digest, got {int(digest_computed):08X}'\n", "src/test_blake2s.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.binary import BinaryValue\nfrom cocotb.triggers import FallingEdge\nimport harness_library as hrs_lb\nimport os\nimport inspect\n\n\n@cocotb.test()\nasync def test_read_block_addresses(dut):\n    if os.getenv(\"SELECTION\") != 'read_block_address':\n        return\n\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(f\"Starting {inspect.currentframe().f_code.co_name}...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    for i in range(0, 16):\n        word = await hrs_lb.read_word(dut, hrs_lb.ADDR_BLOCK0 + i)\n        assert word == 0\n\n    cocotb.log.info(\"All tests passed.\")\n\n@cocotb.test()\nasync def test_read_block_len_address(dut):\n    if os.getenv(\"SELECTION\") != 'read_block_len_address':\n        return\n\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(f\"Starting {inspect.currentframe().f_code.co_name}...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    block_len = await hrs_lb.read_word(dut, hrs_lb.ADDR_BLOCKLEN)\n    assert block_len.integer == 0\n\n    cocotb.log.info(\"All tests passed.\")\n\n@cocotb.test()\nasync def test_read_ctrl_address(dut):\n    if os.getenv(\"SELECTION\") != 'read_ctrl_address':\n        return\n\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(f\"Starting {inspect.currentframe().f_code.co_name}...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    ctrl = await hrs_lb.read_word(dut, hrs_lb.ADDR_CTRL)\n    assert ctrl.integer == 0\n\n    cocotb.log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nimport pytest\nimport coverage\nimport random\nimport traceback\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\ncov_selections  = os.getenv(\"COV_SELECTIONS\", \"\").split()\ncov_thresholds  = [float(s) for s in os.getenv(\"COV_THRESHOLDS\", \"\").split()]\n\ndef call_runner(cov_selection:tuple[str, float] = None):\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.coverage_report_clear()\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter={},\n            cov_selection=cov_selection[0] if cov_selection else \"\",\n        )\n        coverage.coverage_report(\"assertion\")\n        if cov_selection:\n            print(f'cov_selection[0]: {cov_selection[0]} cov_selection[1]: {cov_selection[1]}')\n            coverage.coverage_report_check(cov_selection[1])\n        else:\n            coverage.coverage_report_check()\n    except SystemExit:\n        traceback.print_exc()\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n\n    if len(cov_selections) == 0:\n        # Run the simulation\n        print(\"Calling runner without arguments\")\n        call_runner()\n        return\n\n    print(\"Identified special coverage selections\")\n\n    assert len(cov_selections) == len(cov_thresholds), \"incompatible coverage selections and thresholds\"\n\n    for selection, threshold in zip(cov_selections, cov_thresholds):\n        print(f\"> Running selection: {selection}, for threshold: {threshold}\")\n        call_runner((selection, threshold))\n\n"}}
{"id": "cvdp_agentic_csr_using_apb_interface_0010", "categories": ["cid014", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a `csr_apb_interface` module in the `rtl` directory. Kindly modify the module by adding SystemVerilog assertions to ensure it conforms to the APB protocol and internal control register expectations.\n\n\n## Assertion Details\n\nThe assertions should verify the following conditions:\n\n### 1. Reset Behavior\n\nEnsure that on the assertion of the active-low reset (`presetn == 0`), the outputs `pready`, `prdata`, `pslverr`, and internal state variables (e.g., ISR status flags) are reset to their default values.\n\n**Expected Failure Message:**  \n`Assertion Failed: Reset did not clear outputs or status flags.`\n\n### 2. APB Protocol Compliance\n\nEnsure that the APB protocol is respected:\n- `penable` must not be high without `pselx` being high.\n- On any transaction, `pready` must be high before transitioning out of READ or WRITE state.\n\n**Expected Failure Message:**  \n`Assertion Failed: PENABLE high without PSELX.`\n\n### 3. Single FSM State Validity\n\nEnsure that `present_state` is always one-hot or valid among the defined four FSM states: `IDLE`, `SETUP`, `READ_STATE`, and `WRITE_STATE`.\n\n**Expected Failure Message:**  \n`Assertion Failed: FSM in invalid or multiple simultaneous states.`\n\n### 4. Write Protection of ISR Register\n\nEnsure that any write attempt to the `ISR_REG` (Interrupt Status Register), which is read-only, sets `pslverr`.\n\n**Expected Failure Message:**  \n`Assertion Failed: Write to ISR_REG did NOT raise PSLVERR.`\n\n### 5. Read Data Validity\n\nEnsure that during a valid `READ_STATE`, the `prdata` output is not unknown (i.e., not X or Z).\n\n**Expected Failure Message:**  \n`Assertion Failed: Read data is unknown (X or Z) during READ_STATE.`\n\n### 6. Correct Register Readback\n\nDuring reads, ensure the `prdata` value matches what\u2019s expected based on the register mapping:\n- `DATA_REG = {data_reserved, data1, data2}`\n- `CONTROL_REG = {control_reserved, enable, mode}`\n- `INTERRUPT_REG = {interrupt_reserved, overflow_ie, sign_ie, parity_ie, zero_ie}`\n- `ISR_REG = {28'b0, overflow_is, sign_is, parity_is, zero_is}`\n\n**Expected Failure Message:**  \n`Assertion Failed: prdata does not match expected register contents.`\n\n### 7. Reserved Bits Stability\n\nEnsure that reserved bits (e.g., upper bits of `CONTROL_REG` or `INTERRUPT_REG`) retain their previous values if not explicitly written to.\n\n**Expected Failure Message:**  \n`Assertion Failed: Reserved bits overwritten unexpectedly.`\n\n### 8. ISR Reset Behavior\n\nUpon reset, the ISR flags (`overflow_is`, `sign_is`, `parity_is`, `zero_is`) must be cleared.\n\n**Expected Failure Message:**  \n`Assertion Failed: ISR flags not cleared on reset.`\n\n---\n\n##  Expected Behavior on Assertion Failure\n\nIf any of the above assertions fail, the simulation should generate a **clear and descriptive error message**, with enough context to trace the violation quickly during debugging.\n\n\n", "context": {"rtl/csr_apb_interface.sv": "module csr_apb_interface (\n    input                    pclk,              // Clock input for synchronization\n    input                    presetn,           // Active-low asynchronous reset input\n    input [31:0]             paddr,             // APB address bus, 32-bit for register addressing\n    input                    pselx,             // APB peripheral select signal\n    input                    penable,           // APB enable signal for transactions\n    input                    pwrite,            // APB write enable signal\n    input [31:0]             pwdata,            // APB write data bus\n\n    output reg               pready,            // APB ready signal, indicates end of transaction\n    output reg [31:0]        prdata,            // APB read data bus\n    output reg               pslverr,           // APB slave error signal\n\n    output [1:0]             debug_state        // Debug output to monitor state\n);\n\n  \n    localparam DATA_REG       = 32'h10; // Data register\n    localparam CONTROL_REG    = 32'h14; // Control register\n    localparam INTERRUPT_REG  = 32'h18; // Interrupt configuration register\n    localparam ISR_REG        = 32'h1C; // Interrupt status register\n\n    localparam IDLE           = 2'b00; // Idle state\n    localparam SETUP          = 2'b01; // Setup state\n    localparam READ_STATE     = 2'b10; // Read operation state\n    localparam WRITE_STATE    = 2'b11; // Write operation state\n\n    reg [1:0]                 present_state, next_state; \n\n    // Signals for state transitions and outputs\n    reg                       next_pready;\n    reg [31:0]                next_prdata;\n    reg                       next_pslverr;\n\n    // Internal Storage Registers\n    reg [9:0]                 data1, next_data1;\n    reg [9:0]                 data2, next_data2;\n    reg [11:0]                data_reserved, next_data_reserved;\n\n    reg                       enable, next_enable;     \n    reg                       mode, next_mode;         \n    reg [29:0]                control_reserved, next_control_reserved;\n\n    reg                       overflow_ie, next_overflow_ie; \n    reg                       sign_ie, next_sign_ie;\n    reg                       parity_ie, next_parity_ie;\n    reg                       zero_ie, next_zero_ie;\n    reg [27:0]                interrupt_reserved, next_interrupt_reserved;\n\n    reg                       overflow_is, next_overflow_is; \n    reg                       sign_is, next_sign_is;\n    reg                       parity_is, next_parity_is;\n    reg                       zero_is, next_zero_is;\n\n    assign debug_state = present_state;\n    wire write_protected = (paddr == ISR_REG);\n   \n    always @ (*) begin\n        next_pready           = pready;\n        next_prdata           = prdata;\n        next_pslverr          = pslverr;\n\n        next_data1            = data1;\n        next_data2            = data2;\n        next_data_reserved    = data_reserved;\n\n        next_enable           = enable;\n        next_mode             = mode;\n        next_control_reserved = control_reserved;\n\n        next_overflow_ie      = overflow_ie;\n        next_sign_ie          = sign_ie;\n        next_parity_ie        = parity_ie;\n        next_zero_ie          = zero_ie;\n        next_interrupt_reserved = interrupt_reserved;\n\n        next_overflow_is      = overflow_is;\n        next_sign_is          = sign_is;\n        next_parity_is        = parity_is;\n        next_zero_is          = zero_is;\n\n        next_state            = present_state;\n\n        case (present_state)\n            IDLE: begin\n                if (pselx)\n                    next_state = SETUP;\n            end\n\n            SETUP: begin\n                if (penable && pwrite && !write_protected)\n                    next_state = WRITE_STATE;\n                else if (penable && !pwrite)\n                    next_state = READ_STATE;\n                else if (penable && write_protected)\n                    next_pslverr = 1'b1; \n            end\n\n            READ_STATE: begin\n                if (pready) begin\n                    next_state = IDLE;\n                    next_pready = 1'b0;\n                end else begin\n                    next_pready = 1'b1;\n                    case (paddr)\n                        DATA_REG:      next_prdata = {data_reserved, data1, data2};\n                        CONTROL_REG:   next_prdata = {control_reserved, enable, mode};\n                        INTERRUPT_REG: next_prdata = {interrupt_reserved, overflow_ie, sign_ie, parity_ie, zero_ie};\n                        ISR_REG:       next_prdata = {28'b0, overflow_is, sign_is, parity_is, zero_is};\n                        default:       next_pslverr = 1'b1; \n                    endcase\n                end\n            end\n\n            WRITE_STATE: begin\n                if (pready) begin\n                    next_state = IDLE;\n                    next_pready = 1'b0;\n                end else begin\n                    next_pready = 1'b1;\n                    case (paddr)\n                        DATA_REG: begin\n                            next_data1            = pwdata[19:10];\n                            next_data2            = pwdata[9:0];\n                            next_data_reserved    = pwdata[31:20];\n                        end\n                        CONTROL_REG: begin\n                            next_enable           = pwdata[1];\n                            next_mode             = pwdata[0];\n                            next_control_reserved = pwdata[31:2];\n                        end\n                        INTERRUPT_REG: begin\n                            next_overflow_ie      = pwdata[3];\n                            next_sign_ie          = pwdata[2];\n                            next_parity_ie        = pwdata[1];\n                            next_zero_ie          = pwdata[0];\n                            next_interrupt_reserved = pwdata[31:4];\n                          \n                            next_overflow_is      = pwdata[3] ? 1'b0 : overflow_is;\n                            next_sign_is          = pwdata[2] ? 1'b0 : sign_is;\n                            next_parity_is        = pwdata[1] ? 1'b0 : parity_is;\n                            next_zero_is          = pwdata[0] ? 1'b0 : zero_is;\n                        end\n                        default: next_pslverr = 1'b1; \n                    endcase\n                end\n            end\n        endcase\n    end\n\n    always @ (posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            pready               <= 1'b0;\n            prdata               <= 32'h0;\n            pslverr              <= 1'b0;\n            present_state        <= IDLE;\n            data1                <= 10'd0;\n            data2                <= 10'd0;\n            data_reserved        <= 12'd0;\n            enable               <= 1'b0;\n            mode                 <= 1'b0;\n            control_reserved     <= 30'd0;\n            overflow_ie          <= 1'b0;\n            sign_ie              <= 1'b0;\n            parity_ie            <= 1'b0;\n            zero_ie              <= 1'b0;\n            interrupt_reserved   <= 28'd0;\n            overflow_is          <= 1'b0;\n            sign_is              <= 1'b0;\n            parity_is            <= 1'b0;\n            zero_is              <= 1'b0;\n        end else begin\n            present_state        <= next_state;\n            pready               <= next_pready;\n            prdata               <= next_prdata;\n            pslverr              <= next_pslverr;\n            data1                <= next_data1;\n            data2                <= next_data2;\n            data_reserved        <= next_data_reserved;\n            enable               <= next_enable;\n            mode                 <= next_mode;\n            control_reserved     <= next_control_reserved;\n            overflow_ie          <= next_overflow_ie;\n            sign_ie              <= next_sign_ie;\n            parity_ie            <= next_parity_ie;\n            zero_ie              <= next_zero_ie;\n            interrupt_reserved   <= next_interrupt_reserved;\n            overflow_is          <= next_overflow_is;\n            sign_is              <= next_sign_is;\n            parity_is            <= next_parity_is;\n            zero_is              <= next_zero_is;\n        end\n    end\n\nendmodule"}, "patch": {"rtl/csr_apb_interface.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 80\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/csr_apb_interface.sv\nTOPLEVEL        = csr_apb_interface\nMODULE          = test_csr_apb_interface\nPYTHONPATH      = /src\nHASH            = 8a6928a4d10a005c5db06d9602b2cf3640fa38b1\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_csr_apb_interface.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, ClockCycles\nimport harness_library as hrs_lb\nimport random\n\n# Constants for register addresses\nDATA_REG       = 0x10\nCONTROL_REG    = 0x14\nINTERRUPT_REG  = 0x18\nISR_REG        = 0x1C\n\n\nasync def write_register(dut, addr, data):\n    \"\"\"Function to write data to a register.\"\"\"\n    dut.pselx.value = 1\n    dut.pwrite.value = 1\n    dut.pwdata.value = data\n    dut.paddr.value = addr\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 0\n    dut.pselx.value = 0\n    await ClockCycles(dut.pclk, 2)\n\nasync def read_register(dut, addr):\n    \"\"\"Function to read data from a register.\"\"\"\n    dut.pselx.value = 1\n    dut.pwrite.value = 0\n    dut.paddr.value = addr\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 0\n    dut.pselx.value = 0\n    await ClockCycles(dut.pclk, 2)\n    return dut.prdata.value.integer\n\n@cocotb.test()\nasync def test_csr_apb_interface(dut):\n    # Start the clock with a period of 10ns\n    cocotb.start_soon(Clock(dut.pclk, 10, units='ns').start())\n\n    # Initialize the DUT signals\n    await hrs_lb.dut_init(dut)\n\n    # Apply reset to the DUT for 25ns, reset is active low\n    await hrs_lb.reset_dut(dut.presetn, duration_ns=10, active=False)\n\n    # Test Writing and Reading from DATA_REG\n    data_to_write = random.randint(0, 0xFFFFFFFF)\n    await write_register(dut, DATA_REG, data_to_write)\n    data_read_back = await read_register(dut, DATA_REG)\n    assert data_read_back == data_to_write, \"DATA_REG read/write mismatch.\"\n    dut._log.info(f\"Writing and Reading from DATA_REG : data_read_back = {data_read_back}, data_to_write = {data_to_write}\")\n\n    # Test Writing and Reading from CONTROL_REG\n    data_to_write = random.randint(0, 0xFFFFFFFF)\n    await write_register(dut, CONTROL_REG, data_to_write)\n    data_read_back = await read_register(dut, CONTROL_REG)\n    assert data_read_back == data_to_write, \"CONTROL_REG read/write mismatch.\"\n    dut._log.info(f\"Writing and Reading from CONTROL_REG : data_read_back = {data_read_back}, data_to_write = {data_to_write}\")\n\n    # Test Writing and Reading from INTERRUPT_REG\n    data_to_write = random.randint(0, 0xFFFFFFFF)\n    await write_register(dut, INTERRUPT_REG, data_to_write)\n    data_read_back = await read_register(dut, INTERRUPT_REG)\n    assert data_read_back == data_to_write, \"INTERRUPT_REG read/write mismatch.\"\n    dut._log.info(f\"Writing and Reading from INTERRUPT_REG : data_read_back = {data_read_back}, data_to_write = {data_to_write}\")\n    # -------------------------------------\n    # Test Case 5: Write-protected ISR_REG\n    # -------------------------------------\n    dut._log.info(\"Test Case 5: Write-protected ISR_REG\")\n    isr_write_value = 0xDEADBEEF\n    dut.pselx.value = 1\n    dut.pwrite.value = 1\n    dut.pwdata.value = isr_write_value\n    dut.paddr.value = ISR_REG\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 0\n    dut.pselx.value = 0\n    await ClockCycles(dut.pclk, 2)\n\n    # Check for write protection error\n    assert dut.pslverr.value == 1, \"ISR_REG write did not cause an error as expected\"\n    dut._log.info(\"Write to ISR_REG correctly caused error (Write-Protected Register)\")\n\n    # -------------------------------------\n    # Test Case 6: Read ISR_REG\n    # -------------------------------------\n    dut._log.info(\"Test Case 6: Read ISR_REG\")\n    dut.pselx.value = 1\n    dut.pwrite.value = 0\n    dut.paddr.value = ISR_REG\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 1\n    await RisingEdge(dut.pclk)\n    dut.penable.value = 0\n    dut.pselx.value = 0\n    await ClockCycles(dut.pclk, 2)\n\n    # Validate ISR_REG read\n    isr_read_value = dut.prdata.value.integer\n    expected_isr_value = 0  # Assuming ISR_REG initializes to 0\n    assert isr_read_value == expected_isr_value, f\"ISR_REG mismatch: read {isr_read_value}, expected {expected_isr_value}\"\n    dut._log.info(f\"ISR_REG read successful: {isr_read_value}\")\n\n    # End simulation\n    await ClockCycles(dut.pclk, 10)\n    dut._log.info(\"All test cases passed!\")", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}
{"id": "cvdp_agentic_direct_map_cache_0009", "categories": ["cid014", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"problematic_line_number s/problematic_statement/non_problematic_statement/\" Buggy_RTL_code.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a Direct-Mapped Cache RTL module (`direct_map_cache.sv`) in my RTL directory. Please enhance this module by adding SystemVerilog Assertions (SVA) to comprehensively verify its internal functionality. The assertions should verify the following conditions:\n## Reset Behavior for Output Signals:\n\n- When the reset signal (`rst`) is active (active high), all critical output signals\u2014specifically, `hit`, `dirty`, `valid`, and` data_out`\u2014are cleared to zero in the same clock cycle.\n\n## Misaligned Offset Handling:\n\n- Add an assertion to detect misaligned accesses by monitoring the least significant bit of the offset. When this bit indicates misalignment, the assertion should verify that in the next clock cycle the error signal (`error`) is asserted and the hit signal remains inactive.\n\n## Aligned Offset Handling:\n\n - When the offset is correctly aligned, the `error` signal remains de-asserted in the next clock cycle.\n\n## Compare Read Operation \u2013 Hit Detection:\n\n- Compare read operation (where the cache checks the tag for a read), verifies that if the cache line is valid and the input tag matches the stored tag, a cache hit is correctly indicated in the following clock cycle.\n\n## Compare Write Operation \u2013 Hit and Dirty Update:\n\n- Add an assertion for a compare-write operation that checks if the cache line is valid and the input tag matches the stored tag, then the cache should assert a hit and update the corresponding dirty bit in the following clock cycle.\n\n## Direct Access Read Behavior:\n\n- Write an assertion that verifies during a direct access read (non-compare read) that the cache does not erroneously signal a hit in the next clock cycle.\n\n## Direct Access Write Behavior:\n\n- For a direct access write that ensures, while the cache line is updated with new data and the valid bit is set, the cache `hit` signal remains inactive in the following clock cycle.\n\n## Behavior When Module Is Disabled:\n\n- When the module is disabled (i.e., the `enable` signal is LOW), all output signals (`hit, dirty, valid, and data_out`) are cleared in the same clock cycle.\n\n", "context": {"rtl/direct_map_cache.sv": "module direct_map_cache #(\n    parameter CACHE_SIZE = 256,                 // Number of cache lines\n    parameter DATA_WIDTH = 16,                  // Width of data\n    parameter TAG_WIDTH = 5,                    // Width of the tag\n    parameter OFFSET_WIDTH = 3,                 // Width of the offset\n    localparam INDEX_WIDTH = $clog2(CACHE_SIZE) // Width of the index\n) (\n    input wire enable,                          // Enable signal\n    input wire [INDEX_WIDTH-1:0] index,         // Cache index\n    input wire [OFFSET_WIDTH-1:0] offset,       // Byte offset within the cache line\n    input wire comp,                            // Compare operation signal\n    input wire write,                           // Write operation signal\n    input wire [TAG_WIDTH-1:0] tag_in,          // Input tag for comparison and writing\n    input wire [DATA_WIDTH-1:0] data_in,        // Input data to be written\n    input wire valid_in,                        // Valid state for cache line\n    input wire clk,                             // Clock signal\n    input wire rst,                             // Reset signal (active high)\n    output reg hit,                             // Hit indication\n    output reg dirty,                           // Dirty state indication\n    output reg [TAG_WIDTH-1:0] tag_out,         // Output tag of the cache line\n    output reg [DATA_WIDTH-1:0] data_out,       // Output data from the cache line\n    output reg valid,                           // Valid state output\n    output reg error                            // Error indication for invalid accesses\n);\n\n    // Cache line definitions\n    reg [TAG_WIDTH-1:0] tags [CACHE_SIZE-1:0];                       // Tag storage\n    reg [DATA_WIDTH-1:0] data_mem [CACHE_SIZE-1:0][OFFSET_WIDTH:0];  // Data storage\n    reg valid_bits [CACHE_SIZE-1:0];                                 // Valid bits for each line\n    reg dirty_bits [CACHE_SIZE-1:0];                                 // Dirty bits for each line\n    integer i;\n\n    // Sequential logic for cache operations\n    always @(posedge clk) begin\n        if (rst) begin\n            // Initialize cache lines on reset\n            for (i = 0; i < CACHE_SIZE; i = i + 1) begin\n                valid_bits[i] <= 1'b0;                       \n                dirty_bits[i] <= 1'b0;                                      \n            end\n            hit      <= 1'b0;                                    \n            dirty    <= 1'b0;                                                     \n            valid    <= 1'b0;\n            data_out <= {DATA_WIDTH{1'b0}};                                   \n        end \n        else if (enable) begin\n            // Check for LSB alignment error\n            if (offset[0] == 1'b1) begin\n                error <= 1'b1;                               // Set error if LSB of offset is 1\n                hit   <= 1'b0;                                 \n                dirty <= 1'b0;                               \n                valid <= 1'b0;                               \n                data_out <= {DATA_WIDTH{1'b0}};              \n            end \n            else begin\n                error <= 1'b0;                               // Clear error if LSB of offset is 0\n\n                // Compare operation\n                if (comp) begin\n                    // Compare Write (comp = 1, write = 1) \n                    if (write) begin\n                        if ((tags[index] == tag_in) && valid_bits[index]) begin\n                            hit <= 1'b1;\n                            data_mem[index][offset[OFFSET_WIDTH-1:1]] <= data_in; \n                            dirty_bits[index] <= 1'b1;  \n                            valid_bits[index] <= valid_in; \n                            valid    <= 1'b0;                 \n                            dirty    <= 1'b0; \n\n                        end\n                        else begin\n                            hit <= 1'b0;\n                            dirty_bits[index] <= 1'b0;\n                            valid_bits[index] <= valid_in;\n                            tags[index]       <= tag_in;\n                            valid    <= 1'b0;                 \n                            dirty    <= 1'b0;  \n                            data_mem[index][offset[OFFSET_WIDTH-1:1]] <= data_in;              \n                        end\n                    end \n                    else begin // Write\n                        // Compare Read (comp = 1, write = 0)\n                        if ((tags[index] == tag_in) && valid_bits[index]) begin\n                            hit <= 1'b1;\n                            data_out <= data_mem[index][offset[OFFSET_WIDTH-1:1]]; \n                            valid    <= valid_bits[index];                 \n                            dirty    <= dirty_bits[index]; \n                            tag_out  <= tags[index];                \n                        end\n                        else begin\n                            hit <= 1'b0;\n                            tag_out  <= tags[index];\n                            valid <= valid_bits[index];                   \n                            dirty <= dirty_bits[index]; \n                            data_out <= data_mem[index][offset[OFFSET_WIDTH-1:1]];                 \n                        end\n                    end\n                end \n                else begin //compare\n                    if (write) begin\n                        // Access Write (comp = 0, write = 1)\n                        tags[index]       <= tag_in;                       \n                        data_mem[index][offset[OFFSET_WIDTH-1:1]] <= data_in; \n                        valid_bits[index] <= valid_in;               \n                        dirty_bits[index] <= 1'b0;\n                        hit      <= 1'b0;\n                        valid    <= 1'b0;                 \n                        dirty    <= 1'b0;\n\n                    end \n                    else begin\n                        // Access Read (comp = 0, write = 0)\n                        tag_out  <= tags[index];                      \n                        data_out <= data_mem[index][offset[OFFSET_WIDTH-1:1]]; \n                        valid    <= valid_bits[index];                  \n                        dirty    <= dirty_bits[index];\n                        hit      <= 1'b0;\n\n                    end\n                end\n            end \n        end \n        else begin // enable\n            // enable is low\n            for (i = 0; i < CACHE_SIZE; i = i + 1) begin\n                valid_bits[i] <= 1'b0;                           \n                dirty_bits[i] <= 1'b0;                                                  \n            end\n\n            hit      <= 1'b0;                                       \n            dirty    <= 1'b0;                                                         \n            data_out <= {DATA_WIDTH{1'b0}};                    \n            valid    <= 1'b0;                                     \n        end\n    end\n\nendmodule"}, "patch": {"rtl/direct_map_cache.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/direct_map_cache.sv \nTOPLEVEL        = direct_map_cache\nMODULE          = test_direct_map_cache\nPYTHONPATH      = /src\nRANDOM_SEED     = 1742307655\nHASH            = eac9394c989a7a4d56bf5ff0749057704fa0b001\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_direct_map_cache.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nimport random\n\nimport harness_library as hrs_lb\n\n\n\n@cocotb.test()\nasync def test_direct_map_cache(dut):\n    # Global variables for storing the last written cache line address/data\n    stored_index = 0\n    stored_offset = 0\n    stored_tag = 0\n    stored_data = 0\n\n\n    \"\"\"\n    A Cocotb testbench that:\n        1) Resets the DUT\n        2) Write with comp=0 (write_comp0)\n        3) Read with comp=1 (read_comp1) -> expected hit\n        4) Write with comp=1 (write_comp1)\n        5) Read with comp=1 (read_comp1) -> expected hit\n        6) miss_test (random new index -> force a miss)\n        7) Write with comp=1 (write_comp1)\n        8) Read with comp=0 (read_comp0)\n        9) force_offset_error -> sets offset LSB=1 to check error\n    \"\"\"\n    # Extract parameters from the DUT\n    cache_size   = int(dut.CACHE_SIZE.value)\n    data_width   = int(dut.DATA_WIDTH.value)\n    tag_width    = int(dut.TAG_WIDTH.value)\n    offset_width = int(dut.OFFSET_WIDTH.value)\n    index_width  = int(dut.INDEX_WIDTH.value)\n\n    # Log the parameters for debugging\n    dut._log.info(f\"Detected DUT parameters:\")\n    dut._log.info(f\"  CACHE_SIZE   = {cache_size}\")\n    dut._log.info(f\"  DATA_WIDTH   = {data_width}\")\n    dut._log.info(f\"  TAG_WIDTH    = {tag_width}\")\n    dut._log.info(f\"  OFFSET_WIDTH = {offset_width}\")\n    dut._log.info(f\"  INDEX_WIDTH  = {index_width}\")\n    \n    # Start the clock (10 ns period)\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.dut_init(dut)\n\n    # 1) Reset the DUT\n    await reset_dut(dut)\n\n    # 2) Write with comp=0\n    await write_comp0(dut, cache_size, data_width, tag_width, offset_width)\n\n    # 3) Read with comp=1 -> expect a hit\n    await read_comp1(dut)\n\n    # 4) Write with comp=1\n    await write_comp1(dut, cache_size, data_width)\n\n    # 5) Read with comp=1 -> expect a hit\n    await read_comp1(dut)\n\n    # 6) Miss test -> force a miss by using a different index\n    await miss_test(dut, cache_size, tag_width, offset_width)\n\n    # 7) Write with comp=1\n    await write_comp1(dut, cache_size, data_width)\n\n    # 8) Read with comp=0\n    await read_comp0(dut)\n\n    # 9) Force offset error\n    await force_offset_error(dut)\n\n    dut._log.info(\"All test steps completed successfully.\")\n\n\nasync def reset_dut(dut):\n    \"\"\"Reset the DUT for a few clock cycles.\"\"\"\n    dut.rst.value = 1\n    dut.enable.value = 0\n    dut.comp.value = 0\n    dut.write.value = 0\n    dut.index.value = 0\n    dut.offset.value = 0\n    dut.tag_in.value = 0\n    dut.data_in.value = 0\n    dut.valid_in.value = 0\n\n    for _ in range(3):\n        await RisingEdge(dut.clk)\n\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n    dut._log.info(\"[RESET] Completed\")\n\n\nasync def write_comp0(dut, cache_size, data_width, tag_width, offset_width):\n    \"\"\"\n    \"Access Write (comp=0, write=1)\"\n    We'll randomize index, offset (LSB=0), tag, data_in.\n    \"\"\"\n    global stored_index, stored_offset, stored_tag, stored_data\n\n    dut.enable.value = 1\n    dut.comp.value = 0\n    dut.write.value = 1\n    dut.valid_in.value = 1\n\n    # Generate random index, offset, tag, data\n    index_val  = random.randint(0, cache_size - 1)\n    offset_val = random.randint(0, (1 << offset_width) - 1) & ~1  # LSB=0\n    tag_val    = random.randint(0, (1 << tag_width) - 1)\n    data_val   = random.randint(0, (1 << data_width) - 1)\n\n    # Store for later reads\n    stored_index  = index_val\n    stored_offset = offset_val\n    stored_tag    = tag_val\n    stored_data   = data_val\n\n    # Drive signals\n    dut.index.value  = index_val\n    dut.offset.value = offset_val\n    dut.tag_in.value = tag_val\n    dut.data_in.value= data_val\n\n    await RisingEdge(dut.clk)\n    dut._log.info(f\"[WRITE_COMP0] idx={index_val}, off={offset_val}, tag={tag_val:02X}, data={data_val:04X}\")\n\n    # Check that no error is triggered\n    if dut.error.value == 1:\n        dut._log.error(\"**ERROR**: Unexpected 'error' during write_comp0\")\n\n\nasync def read_comp1(dut):\n    \"\"\"\n    \"Compare Read (comp=1, write=0)\"\n    Expect a hit and correct data if reading the last written address.\n    \"\"\"\n    global stored_index, stored_offset, stored_tag, stored_data\n\n    dut.enable.value = 1\n    dut.comp.value = 1\n    dut.write.value = 0\n\n    # Re-apply the same stored info\n    dut.index.value  = stored_index\n    dut.offset.value = stored_offset\n    dut.tag_in.value = stored_tag\n\n    await FallingEdge(dut.clk)\n    await FallingEdge(dut.clk)\n    read_data = int(dut.data_out.value)\n    hit_val   = dut.hit.value\n    valid_val = dut.valid.value\n\n    dut._log.info(f\"[READ_COMP1] idx={stored_index}, off={stored_offset}, \"\n                  f\"tag={stored_tag:02X}, dout={read_data:04X}, valid={valid_val}, hit={hit_val}\")\n\n    # Check for hit and data match\n    if hit_val and valid_val and (read_data == stored_data):\n        dut._log.info(\"  PASS: Read hit and data matched.\")\n    else:\n        dut._log.error(\"  FAIL: Expected a read hit or data mismatch!\")\n\n    # Check no unexpected error\n    if dut.error.value == 1:\n        dut._log.error(\"**ERROR**: Unexpected 'error' during read_comp1\")\n\n\nasync def write_comp1(dut, cache_size, data_width):\n    \"\"\"\n    \"Compare Write (comp=1, write=1)\"\n    If the same index/tag is used, we should see a hit and line become dirty.\n    \"\"\"\n    global stored_index, stored_offset, stored_tag, stored_data\n\n    dut.enable.value = 1\n    dut.comp.value = 1\n    dut.write.value = 1\n    dut.valid_in.value = 1\n\n    # Keep the stored index/tag/offset, change data\n    new_data = random.randint(0, (1 << data_width) - 1)\n    stored_data = new_data\n\n    dut.index.value  = stored_index\n    dut.offset.value = stored_offset\n    dut.tag_in.value = stored_tag\n    dut.data_in.value= new_data\n\n    await FallingEdge(dut.clk)\n    hit_val   = dut.hit.value\n    dirty_val = dut.dirty.value\n    valid_val = dut.valid.value\n\n    dut._log.info(f\"[WRITE_COMP1] idx={stored_index}, off={stored_offset}, \"\n                  f\"tag={stored_tag:02X}, data={new_data:04X}, hit={hit_val}, dirty={dirty_val}, valid={valid_val}\")\n\n    # If it's the same index/tag, we expect a hit\n    if hit_val == 1 and valid_val == 1:\n        # The DUT may set dirty=1 on a compare write to an existing line\n        if dirty_val == 1:\n            dut._log.info(\"  PASS: Compare write hit, line is now dirty as expected.\")\n        else:\n            dut._log.warning(\"  WARNING: Compare write hit but dirty bit not set.\")\n    else:\n        dut._log.info(\"  Miss or newly allocated line (dirty might be 0).\")\n\n    # Check no error\n    if dut.error.value == 1:\n        dut._log.error(\"**ERROR**: Unexpected 'error' during write_comp1\")\n\n\nasync def read_comp0(dut):\n    \"\"\"\n    \"Access Read (comp=0, write=0)\"\n    The given DUT logic typically won't compare tags => we usually expect hit=0.\n    \"\"\"\n    global stored_index, stored_offset, stored_tag\n\n    dut.enable.value = 1\n    dut.comp.value = 0\n    dut.write.value = 0\n\n    dut.index.value  = stored_index\n    dut.offset.value = stored_offset\n    dut.tag_in.value = stored_tag\n\n    await FallingEdge(dut.clk)\n    await FallingEdge(dut.clk)\n    hit_val   = dut.hit.value\n    err_val   = dut.error.value\n    dut._log.info(f\"[READ_COMP0] idx={stored_index}, off={stored_offset}, tag={stored_tag:02X}, hit={hit_val}\")\n\n    if err_val == 1:\n        dut._log.error(\"**ERROR**: Unexpected 'error' during read_comp0\")\n\n\nasync def miss_test(dut, cache_size, tag_width, offset_width):\n    \"\"\"\n    Force a read miss by picking a new index that differs from the stored one.\n    comp=1, write=0 -> read compare -> expect hit=0.\n    \"\"\"\n    global stored_index\n\n    dut.enable.value = 1\n    dut.comp.value = 1\n    dut.write.value = 0\n\n    # Force a different index to guarantee a miss\n    new_index = (stored_index + 1) % cache_size\n    new_offset = random.randint(0, (1 << offset_width) - 1) & ~1\n    new_tag = random.randint(0, (1 << tag_width) - 1)\n\n    dut.index.value  = new_index\n    dut.offset.value = new_offset\n    dut.tag_in.value = new_tag\n\n    await FallingEdge(dut.clk)\n    await FallingEdge(dut.clk)\n    hit_val = dut.hit.value\n\n    dut._log.info(f\"[MISS_TEST] new_idx={new_index}, off={new_offset}, tag={new_tag:02X}, hit={hit_val}\")\n    if hit_val == 0:\n        dut._log.info(\"  PASS: Expected miss, got hit=0.\")\n    else:\n        dut._log.error(\"  FAIL: Unexpected hit=1, expected a miss!\")\n\n    if dut.error.value == 1:\n        dut._log.error(\"**ERROR**: Unexpected 'error' during miss_test\")\n\n\nasync def force_offset_error(dut):\n    \"\"\"\n    Set offset's LSB=1 => should trigger error=1.\n    \"\"\"\n    dut.enable.value = 1\n    dut.comp.value = 0\n    dut.write.value = 0\n\n    # Force offset with LSB=1\n    dut.offset.value = 0b001\n    dut.index.value  = 0\n    dut.tag_in.value = 0\n    dut.data_in.value= 0\n\n    await FallingEdge(dut.clk)\n    await FallingEdge(dut.clk)\n    err_val = dut.error.value\n    dut._log.info(f\"[OFFSET_ERROR_TEST] offset={dut.offset.value}, error={err_val}\")\n\n    if err_val == 1:\n        dut._log.info(\"  PASS: 'error' asserted as expected when offset LSB=1.\")\n    else:\n        dut._log.error(\"  FAIL: 'error' did not assert with offset LSB=1!\")", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}
{"id": "cvdp_agentic_door_lock_0005", "categories": ["cid014", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a `door_lock` module available in the `rtl` directory. Please enhance the module by adding **SystemVerilog Assertions (SVA)** that formally verify internal control logic, password flow, FSM transitions, and safety constraints.\n\n### Assertion Requirements\n\nThe assertions must cover the following behavioral and functional properties:\n\n1. **System Reset Behavior**  \n   Ensure that when `srst` is asserted, the system is initialized correctly:  \n   - FSM must transition to `IDLE`  \n   - `door_unlock` and `lockout` must be deasserted  \n   - `fail_count` should reset to 0  \n   - `entered_password` and `entered_count` must reset to 0\n   - `stored_password` must initialize to 4'd1\n\n2. **Admin Override Behavior**  \n   If the system is in `IDLE` and `admin_override` is asserted (with `admin_set_mode` deasserted), the FSM must transition to `PASSWORD_OK`.\n\n3. **Admin Mode Entry**  \n   FSM must enter `ADMIN_MODE` only when both `admin_override` and `admin_set_mode` are high while in  `IDLE`. \n\n4. **Correct Password Handling**  \n   A matching password (`match == 1`) in the `CHECK_PASS` state must result in a transition to `PASSWORD_OK`.\n\n5. **Failed Attempt Tracking**  \n   In the `PASSWORD_FAIL` state, `fail_count` must increment by one if it is below the `MAX_TRIALS - 1` limit.\n\n6. **Lockout Triggering**  \n   If `fail_count` is equal to `MAX_TRIALS - 1` and in the `PASSWORD_FAIL` state, the FSM must enter `LOCKED_OUT`.\n\n7. **Password Update Restrictions**  \n   `stored_password` should only update during `ADMIN_MODE` and when `new_password_valid` is asserted.\n\n8. **Lockout Persistence**  \n   Once in `LOCKED_OUT`, the FSM must remain in that state unless `admin_override` is asserted.\n\n9. **Confirm Timing**  \n   In `ENTER_PASS`, the `confirm` signal must only be used after all digits have been entered (`entered_count == PASSWORD_LENGTH`), or it should transition to `PASSWORD_FAIL`.\n\n10. **door_unlock State Validity**  \n    The `door_unlock` signal must only be asserted during the `PASSWORD_OK` state.\n\n11. **Input Range Validity**  \n    When `key_valid` is high, `key_input` must always be between `0` and `9`.\n\n12. **door_unlock Pulse Duration**  \n    `door_unlock` should only remain high for **exactly one clock cycle**.\n\n13. **Lockout Exit Timing**  \n    Once in `LOCKED_OUT`, if `admin_override` is asserted, `lockout` must be deasserted exactly two cycles later.\n\n14. **FSM Exit from PASSWORD_OK**  \n    The FSM must transition from `PASSWORD_OK` to `IDLE` unconditionally on the next clock cycle.\n\n### Expected Behavior\n\nIf any of the above properties are violated during simulation or formal verification, an assertion failure must be triggered with a meaningful error message identifying the faulty condition.\n\n### Notes\n\n- All assertions must use **SystemVerilog Assertions (SVA)** syntax.\n- Only the `door_lock` module file should be modified. Do not introduce new files or modules.\n", "context": {"rtl/door_lock.sv": "module door_lock #(\n    parameter PASSWORD_LENGTH = 4, // Number of digits in the password\n    parameter MAX_TRIALS      = 4  // Maximum allowed incorrect attempts\n) (\n    input  logic                         clk               , // Clock signal\n    input  logic                         srst              , // Active High Synchronous Reset\n    input  logic [                  3:0] key_input         , // 4-bit digit input (0-9)\n    input  logic                         key_valid         , // Signal to register a key input\n    input  logic                         confirm           , // Confirm button for password check\n    input  logic                         admin_override    , // Admin override to unlock the door\n    input  logic                         admin_set_mode    , // Admin mode activation for setting password\n    input  logic [PASSWORD_LENGTH*4-1:0] new_password      , // New password input\n    input  logic                         new_password_valid, // Valid signal for new password\n    output logic                         door_unlock       , // Door unlock signal\n    output logic                         lockout             // Lockout due to multiple failed attempts\n);\n\n    // FSM States\n    typedef enum logic [2:0] {\n        IDLE,          // Waiting for input\n        ENTER_PASS,    // Entering password\n        CHECK_PASS,    // Checking password\n        PASSWORD_OK,   // Password is correct\n        PASSWORD_FAIL, // Password is incorrect\n        LOCKED_OUT,    // System locked due to max failed attempts\n        ADMIN_MODE     // Admin sets a new password\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Internal registers\n    logic [    PASSWORD_LENGTH*4-1:0] stored_password ; // Stored password\n    logic [    PASSWORD_LENGTH*4-1:0] entered_password; // Entered password\n    logic [$clog2(PASSWORD_LENGTH):0] entered_count   ; // Number of entered digits\n    logic [     $clog2(MAX_TRIALS):0] fail_count      ; // Track number of failed attempts\n    logic                             match           ; // Password match flag\n\n    // Sequential logic - State transition\n    always_ff @(posedge clk or posedge srst) begin\n        if (srst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Password entry logic\n    always_ff @(posedge clk or posedge srst) begin\n        if (srst) begin\n            entered_password <= 0;\n        end else if (key_valid && entered_count < PASSWORD_LENGTH) begin\n            entered_password <= {entered_password[PASSWORD_LENGTH*4-5:0], key_input};\n        end\n    end\n\n    // Counter for entered digits\n    always_ff @(posedge clk or posedge srst) begin\n        if (srst) begin\n            entered_count <= 0;\n        end else if (key_valid) begin\n            entered_count <= entered_count + 1;\n        end else if (current_state == CHECK_PASS) begin\n            entered_count <= 0; // Reset after confirmation\n        end\n    end\n\n    // Password comparison logic\n    assign match = (entered_password == stored_password);\n\n    // Next state logic\n    always_comb begin\n        next_state = current_state; // Default hold state\n        case (current_state)\n            IDLE : begin\n                if (!admin_set_mode && admin_override)\n                    next_state = PASSWORD_OK; // Admin override unlocks\n                else if (key_valid)\n                    next_state = ENTER_PASS;\n                else if (admin_set_mode && admin_override) // Admin enters password setting mode\n                    next_state = ADMIN_MODE;\n            end\n            ENTER_PASS : begin\n                if (entered_count == PASSWORD_LENGTH && confirm)\n                    next_state = CHECK_PASS;\n                else if (confirm)\n                    next_state = PASSWORD_FAIL;\n\n            end\n            CHECK_PASS : begin\n                if (match)\n                    next_state = PASSWORD_OK; // Password correct\n                else\n                    next_state = PASSWORD_FAIL; // Password incorrect\n            end\n            PASSWORD_OK : begin\n                next_state = IDLE;\n            end\n            PASSWORD_FAIL : begin\n                if (fail_count >= MAX_TRIALS - 1)\n                    next_state = LOCKED_OUT; // Lockout if max trials exceeded\n                else\n                    next_state = IDLE;\n            end\n            LOCKED_OUT : begin\n                if (admin_override)\n                    next_state = PASSWORD_OK; // Admin reset\n            end\n            ADMIN_MODE : begin\n                if (new_password_valid)\n                    next_state = IDLE; // Exit admin mode after password update\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Unlock and lockout logic\n    always_ff @(posedge clk or posedge srst) begin\n        if (srst) begin\n            door_unlock <= 0;\n            lockout     <= 0;\n            fail_count  <= 0;\n        end else begin\n            case (current_state)\n                PASSWORD_OK : begin\n                    door_unlock <= 1;\n                    fail_count <= 0; // Reset failed attempts\n                    lockout    <= 0;\n                end\n                PASSWORD_FAIL : begin\n                    door_unlock <= 0;\n                    fail_count <= fail_count + 1;\n                    lockout    <= (fail_count == MAX_TRIALS-1) ? 1 : 0;\n                end\n                LOCKED_OUT    : begin\n                    lockout    <= 1;\n                    if (admin_override)\n                        fail_count <= 0;\n                end\n                default : begin\n                    door_unlock <= 0;\n                    lockout     <= 0;\n                end\n            endcase\n        end\n    end\n\n    // Password setting logic (only by admin)\n    always_ff @(posedge clk or posedge srst) begin\n        if (srst) begin\n            stored_password <= '0 | 1; // Default password: 0001\n        end else if (current_state == ADMIN_MODE && new_password_valid) begin\n            stored_password <= new_password; // Update password\n        end\n    end\n\nendmodule"}, "patch": {"rtl/door_lock.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/door_lock.sv\nTOPLEVEL        = door_lock\nMODULE          = test_door_lock\nPYTHONPATH      = /src\nHASH            = 5-rtl-assertion-door-lock-1", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0", "src/test_door_lock.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport math\nimport random\n\n\n# Function to initialize DUT inputs to 0\nasync def dut_init(dut):\n  \"\"\"\n  Initialize all input signals of the DUT to 0.\n  \n  Args:\n    dut: The Design Under Test.\n  \"\"\"\n  for signal in dut:\n    if signal._type == \"GPI_NET\":  # Only reset input signals (GPI_NET)\n      signal.value = 0\n\nasync def reset_dut(dut, duration_ns=10):\n    \"\"\"\n    Perform a synchronous reset on the Design Under Test (DUT).\n\n    - Sets the reset signal high for the specified duration.\n    - Ensures all output signals are zero during the reset.\n    - Deactivates the reset signal and stabilizes the DUT.\n\n    Args:\n        dut: The Design Under Test (DUT).\n        duration_ns: The time duration in nanoseconds for which the reset signal will be held high.\n    \"\"\"\n    dut.srst.value = 1  # Activate reset (set to high)\n    await Timer(duration_ns, units=\"ns\")  # Hold reset high for the specified duration\n    await Timer(1, units=\"ns\")\n\n    # Verify that outputs are zero during reset\n    assert dut.door_unlock.value == 0, f\"[ERROR] door_unlock is not zero during reset: {dut.door_unlock.value}\"\n    assert dut.lockout.value == 0, f\"[ERROR] lockout is not zero during reset: {dut.lockout.value}\"\n\n    dut.srst.value = 0  # Deactivate reset (set to low)\n    await Timer(duration_ns, units='ns')  # Wait for the reset to stabilize\n    dut.srst._log.debug(\"Reset complete\")\n\nclass DoorLockChecker:\n  \"\"\"Checker that computes expected behavior based on inputs and FSM rules.\"\"\"\n  def __init__(self, default_password, password_length, max_trials):\n    self.stored_password = default_password\n    self.password_length = password_length\n    self.max_trials = max_trials\n    self.entered_password = []\n    self.fail_count = 0\n    self.locked_out = False\n    self.door_unlock = False\n\n  def reset(self):\n    \"\"\"Resets internal state\"\"\"\n    self.entered_password = []\n    self.fail_count = 0\n    self.locked_out = False\n    self.door_unlock = False\n    self.stored_password = self.default_password\n\n  def process_input(self, key_input, confirm, admin_override, admin_set_mode, new_password, new_password_valid):\n    \"\"\"Computes expected values dynamically based on FSM transitions.\"\"\"\n    \n    if admin_override and admin_set_mode == 0:  \n      self.door_unlock = True\n      self.fail_count = 0\n      self.locked_out = False\n      return\n\n    if self.locked_out:\n      if admin_override:\n        self.locked_out = False  # Reset by admin\n        self.fail_count = 0\n      return\n\n    if admin_set_mode and admin_override:\n      if new_password_valid:\n        self.stored_password = new_password\n      return\n\n    if key_input is not None:\n      if len(self.entered_password) < self.password_length:\n        self.entered_password.append(key_input)\n\n    if confirm:\n        if len(self.entered_password) == self.password_length:\n            if self.entered_password == self.stored_password:\n                self.door_unlock = True\n                self.fail_count = 0\n            else:\n                self.door_unlock = False\n                self.fail_count += 1\n                if self.fail_count >= self.max_trials:\n                    self.locked_out = True\n        else:\n            # Early confirm: treat as failure\n            self.door_unlock = False\n            self.fail_count += 1\n            if self.fail_count >= self.max_trials:\n                self.locked_out = True\n        self.entered_password = []  # Always clear after confirm\n\n\n  def get_expected_outputs(self):\n    \"\"\"Returns expected door unlock and lockout signals.\"\"\"\n    return self.door_unlock, self.locked_out\n\ndef assert_outputs(checker, dut):\n  \"\"\"Helper function to validate expected outputs\"\"\"\n  expected_unlock, expected_lockout = checker.get_expected_outputs()\n  assert dut.door_unlock.value == expected_unlock, f\"Expected door_unlock={expected_unlock}, got {dut.door_unlock.value}\"\n  assert dut.lockout.value == expected_lockout, f\"Expected lockout={expected_lockout}, got {dut.lockout.value}\"\n\nasync def enter_password(checker, dut, password):\n  \"\"\"Enters a password sequence\"\"\"\n  for digit in password:\n    dut.key_input.value = digit\n    dut.key_valid.value = 1\n    await RisingEdge(dut.clk)\n    dut.key_valid.value = 0\n    await RisingEdge(dut.clk)\n    checker.process_input(key_input=digit, confirm=False, admin_override=False, admin_set_mode=False, new_password=None, new_password_valid=False)\n\n  # Confirm password entry\n  dut.confirm.value = 1\n  await RisingEdge(dut.clk)\n  dut.confirm.value = 0\n  await RisingEdge(dut.clk)\n  await RisingEdge(dut.clk)\n  await RisingEdge(dut.clk)\n  checker.process_input(key_input=None, confirm=True, admin_override=False, admin_set_mode=False, new_password=None, new_password_valid=False)\n\n  assert_outputs(checker, dut)\n\nasync def admin_override(checker, dut):\n  dut.admin_override.value = 1\n  await RisingEdge(dut.clk)\n  dut.admin_override.value = 0\n  await RisingEdge(dut.clk)\n  await RisingEdge(dut.clk)\n  checker.process_input(key_input=None, confirm=False, admin_override=True, admin_set_mode=False, new_password=None, new_password_valid=False)\n  assert_outputs(checker, dut)\n\nasync def set_new_password(checker, dut, new_password):\n  dut.admin_set_mode.value = 1\n  dut.admin_override.value = 1\n  await RisingEdge(dut.clk)\n  # Construct the full new password as a packed integer\n  new_password_value = 0\n  for i, digit in enumerate(reversed(new_password)):  # Reverse to correctly align bits\n    new_password_value |= digit << (4 * i)  # Each digit occupies 4 bits\n  dut.new_password.value = new_password_value\n  dut.new_password_valid.value = 1\n  await RisingEdge(dut.clk)\n  dut.new_password_valid.value = 0\n  dut.admin_set_mode.value = 0\n  dut.admin_override.value = 0\n  checker.process_input(key_input=None, confirm=False, admin_override=True, admin_set_mode=True, new_password=new_password, new_password_valid=True)\n\nasync def test_early_confirm(checker, dut, password_length, max_trials):\n    print(f\"Test: Confirm pressed before entering full password\")\n\n    partial_entry = [random.randint(0, 9) for _ in range(password_length - 2)]\n    # Enter fewer digits than PASSWORD_LENGTH\n    for digit in partial_entry:\n        dut.key_input.value = digit\n        dut.key_valid.value = 1\n        await RisingEdge(dut.clk)\n        dut.key_valid.value = 0\n        await RisingEdge(dut.clk)\n        checker.process_input(\n            key_input=digit,\n            confirm=False,\n            admin_override=False,\n            admin_set_mode=False,\n            new_password=None,\n            new_password_valid=False,\n        )\n\n    # Press confirm too early\n    dut.confirm.value = 1\n    await RisingEdge(dut.clk)\n    dut.confirm.value = 0\n    await RisingEdge(dut.clk)\n    checker.process_input(\n        key_input=None,\n        confirm=True,\n        admin_override=False,\n        admin_set_mode=False,\n        new_password=None,\n        new_password_valid=False,\n    )\n    assert_outputs(checker, dut)\n\n    print(f\"System locked out after {max_trials} early confirms\")\n\n\n@cocotb.test()\nasync def test_door_lock(dut):\n\n  # Start the clock with a 10ns period\n  cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n  # Initialize DUT inputs\n  await dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few clock cycles to ensure proper initialization\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve DUT configuration parameters\n  password_length = int(dut.PASSWORD_LENGTH.value)\n  max_trials = int(dut.MAX_TRIALS.value)\n  num_samples = 30\n  default_password = [0x0] * (password_length - 1) + [0x1]\n\n  # Print parameters for debugging\n  print(f\"PASSWORD_LENGTH: {password_length}\")\n  print(f\"MAX_TRIALS: {max_trials}\")\n\n  checker = DoorLockChecker(default_password, password_length, max_trials)\n\n  # Test 1: Enter correct password\n  print(f\"Test 1: Enter correct password\")\n  await RisingEdge(dut.clk)\n  await enter_password(checker, dut, default_password)\n\n  # Test 2: Enter incorrect password\n  print(f\"Test 2: Enter incorrect password\")\n  # Generate an incorrect password of the same length as default_password\n  incorrect_pass = [random.randint(0, 9) for x in default_password]  # Shift each digit by 1 (modulo 10)\n\n  # Ensure incorrect_pass is different from default_password\n  if incorrect_pass == default_password:\n      incorrect_pass[0] = (incorrect_pass[0] + 2) % 10  # Modify the first element if needed\n\n  await enter_password(checker, dut, incorrect_pass)\n\n  # Test 3: Verify lockout\n  print(f\"Test 3: Verify lockout\")\n  # Attempt incorrect passwords multiple times to trigger lockout\n  for _ in range(max_trials-1):\n    # Generate an incorrect password of the same length as default_password\n    incorrect_pass = [random.randint(0, 9) for x in default_password]  # Shift each digit by 1 (modulo 10)\n\n    # Ensure incorrect_pass is different from default_password\n    if incorrect_pass == default_password:\n        incorrect_pass[0] = (incorrect_pass[0] + 2) % 10  # Modify the first element if needed\n\n    await enter_password(checker, dut, incorrect_pass)\n\n  assert dut.lockout.value == 1, f\"System should be locked out after {max_trials} failed attempts, but lockout={dut.lockout.value}\"\n\n  # Test 4: Admin override to unlock\n  print(f\"Test 4: Admin override to unlock\")\n  await admin_override(checker, dut)\n\n  # Test 5: Change password in Admin Mode\n  print(f\"Test 5: Change password in Admin Mode\")\n  # Generate an new password of the same length as default_password\n  new_password = [random.randint(0, 9) for x in default_password]\n  await set_new_password(checker, dut, new_password)\n\n  # Test 6: Verify new password works\n  print(f\"Test 6: Verify new password works\")\n  await enter_password(checker, dut, new_password)\n\n  # Test 6: Early confirm\n  print(f\"Test 7: Early confirm during password\")\n  await test_early_confirm(checker, dut, password_length, max_trials)\n\n  print(f\"All test cases passed!\")\n\n  # Test 7: Admin override at IDLE\n  await reset_dut(dut)\n  print(f\"Test 7: Admin override to unlock\")\n  await admin_override(checker, dut)\n    \n  # Wait for a few cycles before performing a final reset\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply a final reset to the DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles after reset to stabilize\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n", "src/test_runner.py": "import os\nfrom pathlib import Path\nfrom cocotb.runner import get_runner\nimport pytest\nimport random\nimport harness_library as hrs_lb\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef call_runner(PASSWORD_LENGTH, MAX_TRIALS):\n    parameter = {\n    \"PASSWORD_LENGTH\": PASSWORD_LENGTH,\n    \"MAX_TRIALS\": MAX_TRIALS,\n    }\n    # Debug information\n    print(f\"[DEBUG] Running simulation with PASSWORD_LENGTH={PASSWORD_LENGTH} and MAX_TRIALS={MAX_TRIALS}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameter\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# # Parametrize test for random parameters\n@pytest.mark.parametrize(\"random_test\", range(3))\ndef test_random_door_lock(random_test):\n    PASSWORD_LENGTH = random.randint(4, 8)\n    MAX_TRIALS = random.randint(4, 8)\n    # Run the simulation with specified parameters\n    call_runner(PASSWORD_LENGTH=PASSWORD_LENGTH, MAX_TRIALS=MAX_TRIALS)\n"}}
{"id": "cvdp_agentic_fixed_arbiter_0004", "categories": ["cid014", "easy"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a `fixed_priority_arbiter` module available in the `rtl` directory, and its specification is located in the `docs` directory. Kindly modify the module by adding SystemVerilog assertions to ensure the arbiter operates according to fixed-priority arbitration rules.\n\n## Assertion Details\n\nThe assertions should verify the following conditions:\n\n### 1. Single Grant Validity  \n- Ensure that when a grant is valid (`valid == 1`), **only one bit** in the `grant` signal is high.  \n- This enforces a **one-hot grant encoding** policy.\n\n### 2. Priority-Based Arbitration  \n- When `priority_override` is not asserted (i.e., `priority_override == 8'b0`), the `grant` signal must correspond to the **lowest-indexed active request** in the `req` signal.  \n- This ensures fixed-priority arbitration from `req[0]` (highest) to `req[7]` (lowest).\n\n### 3. Priority Override Enforcement  \n- When `priority_override` is asserted (non-zero), the arbiter must **honor the override** and grant only the overridden request, **regardless of `req`**.\n\n### 4. Correct Grant Index Encoding  \n- The `grant_index` output must always reflect the **bit position** of the active `grant` line, encoded as a **3-bit binary number**.\n\n---\n\n## Expected Behavior on Assertion Failure\n\nIf any of the above assertions fail, the simulation should generate a clear and descriptive error message, such as:\n\n- Assertion Failed: More than one grant active when valid = 1.\n- Assertion Failed: Grant does not match request with no override.\n- Assertion Failed: Priority override is asserted but grant does not match.\n- Assertion Failed: grant_index does not match the granted bit.\n\n---\n", "context": {"docs/specification.md": "# Fixed Priority Arbiter Specification Document\n\n## Introduction\n\nThe **Fixed Priority Arbiter** is designed to handle **arbitration among multiple requesters** using a **fixed-priority scheme**. It ensures that **only one request** is granted at a time, following a **fixed priority order** (lowest index has the highest priority).  \n\nAdditionally, the arbiter **supports external priority overrides**, allowing dynamic control of the granted request. The module operates synchronously with **one-cycle arbitration latency** and provides **valid and grant index outputs** to indicate which request was granted.\n\n---\n\n## Arbitration Overview\n\nThe **fixed-priority arbitration** logic follows these steps:\n\n1. **Check Priority Override:**  \n   - If `priority_override` is **non-zero**, it takes precedence over the `req` input.\n   - The **highest-priority bit** in `priority_override` is granted.\n\n2. **Fixed Priority Selection:**  \n   - If `priority_override` is **zero**, the arbiter **scans `req` from bit 0 to 7**.\n   - The **first active request** (lowest index) is granted.\n\n3. **Grant Output:**  \n   - The grant signal (`grant`) has a **single bit set** corresponding to the granted request.\n   - The `grant_index` output provides the **binary index** of the granted request.\n   - The `valid` signal is set **high** if a request is granted.\n\n4. **Reset Behavior:**  \n   - When `reset` is asserted, the arbiter **clears all outputs** (`grant`, `grant_index`, `valid`).\n\n---\n\n## Module Interface\n\nThe module should be defined as follows:\n\n```verilog\nmodule fixed_priority_arbiter(\n    input clk,                     \n    input reset,                    \n    input [7:0] req,                \n    input [7:0] priority_override,  \n\n    output reg [7:0] grant,        \n    output reg valid,              \n    output reg [2:0] grant_index    \n);\n```\n\n## Port Description\n| **Signal**          | **Direction** | **Description**                                                |\n|---------------------|---------------|----------------------------------------------------------------|\n| `clk`               | **Input**     | System clock (all operations occur on the rising edge).        |\n| `reset`             | **Input**     | Active-high synchronous reset (clears all outputs).            |\n| `req`               | **Input**     | 8-bit request signal. Each bit represents a requester.         |\n| `priority_override` | **Input**     | Allows external modules to force a specific grant.             |\n| `grant`             | **Output**    | 8-bit grant signal; only **one bit** is set based on priority. |\n| `valid`             | **Output**    | High (`1`) when a grant is issued.                             |\n| `grant_index`       | **Output**    | 3-bit index of the granted request.                            |\n\n---\n\n## Internal Architecture\n\nThe **Fixed Priority Arbiter** consists of the following components:\n\n### **1. Priority Override Logic**\n- Checks if `priority_override` is **non-zero**.\n- If so, grants the **highest-priority bit** in `priority_override`.\n\n### **2. Fixed Priority Selection Logic**\n- If `priority_override` is **zero**, the arbiter **scans `req` from bit 0 to bit 7**.\n- The **lowest active bit** is granted.\n\n### **3. Grant Signal Generation**\n- Generates an **8-bit grant signal** with **a single active bit**.\n- The corresponding **binary index** is assigned to `grant_index`.\n\n### **4. Output Registering**\n- Ensures that **outputs are stable** until the next clock cycle.\n- `valid` is set high (`1`) if a request is granted.\n\n---\n\n## Timing and Latency\n\nThe **fixed-priority arbitration** is a **single-cycle operation**, meaning that:\n| **Operation**           | **Latency (Clock Cycles)** |\n|-------------------------|----------------------------|\n| **Request Arbitration** | 1 clock cycle              |\n| **Priority Override**   | 1 clock cycle              |\n| **Reset**               | 1 clock cycle              |\n\nThis ensures **fast response times** for **high-speed applications**.\n\n---\n\n", "rtl/fixed_priority_arbiter.sv": "`timescale 1ns / 1ps\nmodule fixed_priority_arbiter(\n    input clk,                      // Clock signal\n    input reset,                    // Active high reset signal\n    input [7:0] req,                // 8-bit request signal; each bit represents a request from a different source\n    input [7:0] priority_override,  // External priority override signal\n\n    output reg [7:0] grant,         // 8-bit grant signal; only one bit will be set high based on priority\n    output reg valid,               // Indicates if a request is granted\n    output reg [2:0] grant_index    // Outputs the granted request index in binary format\n); \n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            grant <= 8'b00000000;\n            valid <= 1'b0;\n            grant_index <= 3'b000;\n        end \n        else begin\n            if (priority_override != 8'b00000000) begin\n                grant <= priority_override; \n                valid <= 1'b1;\n                grant_index <= (priority_override[0] ? 3'd0 :\n                                priority_override[1] ? 3'd1 :\n                                priority_override[2] ? 3'd2 :\n                                priority_override[3] ? 3'd3 :\n                                priority_override[4] ? 3'd4 :\n                                priority_override[5] ? 3'd5 :\n                                priority_override[6] ? 3'd6 :\n                                priority_override[7] ? 3'd7 : 3'd0);\n            end\n            else if (req[0]) begin\n                grant <= 8'b00000001;\n                grant_index <= 3'd0;\n                valid <= 1'b1;\n            end \n            else if (req[1]) begin\n                grant <= 8'b00000010;\n                grant_index <= 3'd1;\n                valid <= 1'b1;\n            end \n            else if (req[2]) begin\n                grant <= 8'b00000100;\n                grant_index <= 3'd2;\n                valid <= 1'b1;\n            end \n            else if (req[3]) begin\n                grant <= 8'b00001000;\n                grant_index <= 3'd3;\n                valid <= 1'b1;\n            end \n            else if (req[4]) begin\n                grant <= 8'b00010000;\n                grant_index <= 3'd4;\n                valid <= 1'b1;\n            end \n            else if (req[5]) begin\n                grant <= 8'b00100000;\n                grant_index <= 3'd5;\n                valid <= 1'b1;\n            end \n            else if (req[6]) begin\n                grant <= 8'b01000000;\n                grant_index <= 3'd6;\n                valid <= 1'b1;\n            end \n            else if (req[7]) begin\n                grant <= 8'b10000000;\n                grant_index <= 3'd7;\n                valid <= 1'b1;\n            end \n            else begin\n                grant <= 8'b00000000;\n                grant_index <= 3'd0;\n                valid <= 1'b0;\n            end\n        end\n    end\nendmodule", "verif/fixed_priority_arbiter_tb.sv": "`timescale 1ns / 1ps\n\nmodule fixed_priority_arbiter_tb;\n\n    localparam CLK_PERIOD = 10;\n\n    // DUT Inputs\n    reg clk;\n    reg reset;\n    reg enable;\n    reg clear;\n    reg [7:0] req;\n    reg [7:0] priority_override;\n\n    // DUT Outputs\n    wire [7:0] grant;\n    wire       valid;\n    wire [2:0] grant_index;\n    wire [2:0] active_grant;\n\n    // Instantiate the DUT\n    fixed_priority_arbiter dut (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .clear(clear),\n        .req(req),\n        .priority_override(priority_override),\n        .grant(grant),\n        .valid(valid),\n        .grant_index(grant_index),\n        .active_grant(active_grant)\n    );\n\n    // Clock Generation\n    always #(CLK_PERIOD / 2) clk = ~clk;\n\n    // Apply Reset\n    task apply_reset;\n        begin\n            reset = 1;\n            enable = 0;\n            clear = 0;\n            req = 0;\n            priority_override = 0;\n            #(2 * CLK_PERIOD);\n            reset = 0;\n        end\n    endtask\n\n    // Stimulus Generator\n    task drive_stimulus(\n        input [7:0] test_req,\n        input [7:0] test_override,\n        input       enable_i,\n        input       clear_i,\n        string      label\n    );\n        begin\n            enable = enable_i;\n            clear  = clear_i;\n            req    = test_req;\n            priority_override = test_override;\n\n            #(CLK_PERIOD);\n            $display(\">>> %s\", label);\n        end\n    endtask\n\n    // Main Test Sequence\n    initial begin\n        // Init\n        clk = 0;\n        reset = 0;\n        enable = 0;\n        clear = 0;\n        req = 0;\n        priority_override = 0;\n\n        apply_reset;\n        $display(\"RESET complete.\\n\");\n\n        drive_stimulus(8'b00000100, 8'b0, 1, 0, \"Stimulus 1: Single request\");\n        drive_stimulus(8'b00100110, 8'b0, 1, 0, \"Stimulus 2: Multiple requests\");\n        drive_stimulus(8'b00100110, 8'b00010000, 1, 0, \"Stimulus 3: Priority override active\");\n        drive_stimulus(8'b00000000, 8'b00000000, 1, 0, \"Stimulus 4: No requests or override\");\n        drive_stimulus(8'b00001000, 8'b00000000, 1, 1, \"Stimulus 5: Clear signal asserted\");\n        drive_stimulus(8'b00000010, 8'b00000000, 0, 0, \"Stimulus 6: Enable = 0 (arbiter disabled)\");\n        drive_stimulus(8'b00000001, 8'b00000000, 1, 0, \"Stimulus 7: active_grant test\");\n\n        $display(\"Stimulus-only testbench completed.\");\n        #20;\n        $finish;\n    end\n\n    // Optional waveform dump\n    initial begin\n        $dumpfile(\"fixed_priority_arbiter_tb.vcd\");\n        $dumpvars(0, fixed_priority_arbiter_tb);\n    end\n\nendmodule"}, "patch": {"rtl/fixed_priority_arbiter.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/fixed_priority_arbiter.sv\nTOPLEVEL        = fixed_priority_arbiter\nMODULE          = test_fixed_priority_arbiter\nPYTHONPATH      = /src\nHASH            = bdf7d718613288fbd2f6d9322f86d264c973d532", "src/test_fixed_priority_arbiter.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\n#import harness_library as hrs_lb  \n\n@cocotb.test()\nasync def test_fixed_priority_arbiter(dut):\n    \"\"\"Test the fixed_priority_arbiter module.\"\"\"\n\n    # Start the clock with a period of 10ns\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals\n    #await hrs_lb.dut_init(dut)\n\n    # Task: Apply reset (Active High)\n    async def reset_dut(active=True, duration_ns=10):\n        dut.reset.value = active\n        await Timer(duration_ns, units=\"ns\")\n        dut.reset.value = not active\n        await RisingEdge(dut.clk)  # Wait for one clock edge after reset is de-asserted\n\n    # Task: Drive request and optional priority override\n    async def drive_request(request, priority_override=0):\n        dut.req.value = request\n        dut.priority_override.value = priority_override\n        await RisingEdge(dut.clk)\n        await Timer(10, units=\"ns\")  # Wait to observe the output\n\n    # Monitor the signals\n    cocotb.log.info(\"Starting simulation\")\n\n    # Apply a reset to the DUT before starting the test cases\n    await reset_dut(active=True, duration_ns=25)\n\n    # ---------------- Test Case 1: Single Request ----------------\n    await drive_request(0b00001000)  \n    assert dut.grant.value == 0b00001000, f\"Test Case 1 Failed: Expected grant=0b00001000, got grant={dut.grant.value}\"\n    assert dut.grant_index.value == 3, f\"Test Case 1 Failed: Expected grant_index=3, got grant_index={dut.grant_index.value}\"\n    assert dut.valid.value == 1, f\"Test Case 1 Failed: Expected valid=1, got valid={dut.valid.value}\"\n    cocotb.log.info(\"Test Case 1 Passed: Single request granted correctly.\")\n\n    # ---------------- Test Case 2: Multiple Requests (Fixed Priority) ----------------\n    await drive_request(0b00111000)  \n    assert dut.grant.value == 0b00001000, \"Test Case 2 Failed: Incorrect priority handling.\"\n    cocotb.log.info(\"Test Case 2 Passed: Multiple requests handled with fixed priority.\")\n\n    # ---------------- Test Case 3: Priority Override ----------------\n    await drive_request(0b00010010, priority_override=0b00010000)  \n    assert dut.grant.value == 0b00010000, \"Test Case 3 Failed: Priority override did not work.\"\n    cocotb.log.info(\"Test Case 3 Passed: Priority override successful.\")\n\n    # ---------------- Test Case 4: No Requests (Grant Should be Zero) ----------------\n    await drive_request(0b00000000)  \n    assert dut.grant.value == 0b00000000, \"Test Case 4 Failed: Incorrect handling of no requests.\"\n    assert dut.valid.value == 0, \"Test Case 4 Failed: Valid signal should be low when no requests.\"\n    cocotb.log.info(\"Test Case 4 Passed: No requests scenario handled correctly.\")\n\n    # ---------------- Test Case 5: Highest Priority Request Wins ----------------\n    await drive_request(0b10000001)  \n    assert dut.grant.value == 0b00000001, \"Test Case 5 Failed: Incorrect priority decision.\"\n    cocotb.log.info(\"Test Case 5 Passed: Highest priority request wins correctly.\")\n\n    # ---------------- Test Case 6: Changing Requests Dynamically ----------------\n    await drive_request(0b00000010)  \n    assert dut.grant.value == 0b00000010, \"Test Case 6 Failed: Grant did not update correctly.\"\n    cocotb.log.info(\"Test Case 6 Passed: Grant updates dynamically.\")\n\n    await drive_request(0b00000100)  \n    assert dut.grant.value == 0b00000100, \"Test Case 6 Failed: Dynamic request update failed.\"\n    cocotb.log.info(\"Test Case 6 Passed: Dynamic request update confirmed.\")\n\n    # ---------------- Test Case 7: Priority Override While Requests Change ----------------\n    await drive_request(0b00000010, priority_override=0b00100000)  \n    assert dut.grant.value == 0b00100000, \"Test Case 7 Failed: Priority override not applied correctly.\"\n    cocotb.log.info(\"Test Case 7 Passed: Priority override worked dynamically.\")\n\n    await drive_request(0b00010010, priority_override=0b00010000)  \n    assert dut.grant.value == 0b00010000, \"Test Case 7 Failed: Priority override did not take effect.\"\n    cocotb.log.info(\"Test Case 7 Passed: Priority override successfully applied during active requests.\")\n\n    # ---------------- Test Case 8: Reset During Operation ----------------\n    await drive_request(0b00011000)  \n    assert dut.grant.value == 0b00001000, \"Test Case 8 Failed: Incorrect grant before reset.\"\n\n    # Apply reset during active requests\n    await reset_dut(active=False, duration_ns=25)  \n    assert dut.grant.value == 0b00000000, \"Test Case 8 Failed: Grant should be zero after reset.\"\n    assert dut.valid.value == 0, \"Test Case 8 Failed: Valid should be low after reset.\"\n    cocotb.log.info(\"Test Case 8 Passed: Reset handled correctly.\")\n\n    # Log the successful completion of the simulation\n    cocotb.log.info(\"Simulation completed successfully\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources   = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang     = os.getenv(\"TOPLEVEL_LANG\")\nsim               = os.getenv(\"SIM\", \"icarus\")\ntoplevel          = os.getenv(\"TOPLEVEL\")\nmodule            = os.getenv(\"MODULE\")\nwave              = os.getenv(\"WAVE\")\n\ndata_width        = int(os.getenv(\"DATA_WIDTH\", \"32\"))\nenable_threshold  = int(os.getenv(\"ENABLE_THRESHOLD\", \"0\"))\nthreshold         = int(os.getenv(\"THRESHOLD\", \"16\"))\nregister_output   = int(os.getenv(\"REGISTER_OUTPUT\", \"0\"))\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    parameters = {\n        \"DATA_WIDTH\":        data_width,\n        \"ENABLE_THRESHOLD\":  enable_threshold,\n        \"THRESHOLD\":         threshold,\n        \"REGISTER_OUTPUT\":   register_output\n    }\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\",\n        parameters=parameters\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}
{"id": "cvdp_agentic_inv_manchester_codec_0005", "categories": ["cid014", "easy"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a `top_inv_manchester_codec` module available in the `rtl` directory. Kindly modify the module by adding concurrent SystemVerilog assertions. These assertions should display error messages when the following signal conditions are violated during simulation:\n\n**Assertions to Implement:**\n1. Verify that the encoder valid output (`enc_valid_out`) is asserted only if the encoder input valid (`enc_valid_in`) was asserted in the previous clock cycle.\n2. Verify that the decoder valid output (`dec_valid_out`) is asserted only if the decoder input valid (`dec_valid_in`) was asserted in the previous clock cycle.\n3. Ensure that all outputs (`enc_data_out`, `dec_data_out`, `enc_valid_out`, and `dec_valid_out`) are zeroed when both encoder and decoder inputs (`enc_valid_in`, `dec_valid_in`) are invalid.\n\n#### **Module Interface Details:**\n- **Parameters:**\n  - `N` (default = 16): Width of the input and output data.\n  \n- **Input Ports:**\n  - `clk_in`: Positive-Edge triggered Clock input.\n  - `rst_in`: Active high Asynchronous reset input.\n  - `enc_valid_in`: Active HIGH Valid signal for encoder input.\n  - `enc_data_in[N-1:0]`: N-bit input data for encoding.\n  - `dec_valid_in`: Active HIGH Valid signal for decoder input.\n  - `dec_data_in[2*N-1:0]`: 2*N-bit input data for decoding.\n\n- **Output Ports:**\n  - `enc_valid_out`: Active HIGH Valid signal for encoder output.\n  - `enc_data_out[2*N-1:0]`: 2*N-bit encoded output data.\n  - `dec_valid_out`: Active HIGH Valid signal for decoder output.\n  - `dec_data_out[N-1:0]`: N-bit decoded output data.\n\n#### **Functionality:**\n- The module performs inverse Manchester encoding and decoding.\n- **Encoder:**\n  - When `enc_valid_in` is high, the module encodes the input `enc_data_in` into `enc_data_out` using the inverse Manchester encoding scheme.\n  - Each bit of `enc_data_in` is encoded into 2 bits in `enc_data_out`:\n    - `0` is encoded as `01`.\n    - `1` is encoded as `10`.\n- **Decoder:**\n  - When `dec_valid_in` is high, the module decodes the input `dec_data_in` into `dec_data_out` using the inverse Manchester decoding scheme.\n  - Each 2-bit pair in `dec_data_in` is decoded into a single bit in `dec_data_out`:\n    - `01` is decoded as `0`.\n    - `10` is decoded as `1`.\n    - Any invalid pair (e.g., `00` or `11`) is decoded as `0`.\n", "context": {"rtl/top_inv_manchester_codec.sv": "module top_inv_manchester_codec #(\n    parameter N = 16  // Default width of input and output data\n) (\n    input  logic           clk_in,          // Clock input\n    input  logic           rst_in,          // Active high reset input\n    \n    // Encoder Signals\n    input  logic           enc_valid_in,    // Input valid signal\n    input  logic [N-1:0]   enc_data_in,     // N-bit input data\n    output logic           enc_valid_out,   // Output valid signal\n    output logic [2*N-1:0] enc_data_out,    // 2*N-bit encoder output data\n    \n    // Decoder Signals\n    input  logic           dec_valid_in,    // Input valid signal\n    input  logic [2*N-1:0] dec_data_in,     // 2*N-bit input data\n    output logic           dec_valid_out,   // Output valid signal\n    output logic [N-1:0]   dec_data_out     // N-bit output decoded data\n);\n\n    // Encoding\n    always_ff @(posedge clk_in) begin\n        if (rst_in) begin\n            enc_data_out  <= '0; \n            enc_valid_out <= 1'b0; \n        end else if (enc_valid_in) begin\n            for (int i = 0; i < N; i++) begin\n                if (enc_data_in[i] == 1'b1) begin\n                    enc_data_out[2*i]   <= 1'b0;\n                    enc_data_out[2*i+1] <= 1'b1;\n                end else begin\n                    enc_data_out[2*i]   <= 1'b1;\n                    enc_data_out[2*i+1] <= 1'b0;\n                end\n            end\n            enc_valid_out <= 1'b1;\n        end else begin\n            enc_data_out  <= 'd0;\n            enc_valid_out <= 1'b0;\n        end\n    end\n   \n    // Decoding \n    always_ff @(posedge clk_in) begin\n        if (rst_in) begin\n            dec_data_out  <= '0; \n            dec_valid_out <= 1'b0;\n        end else if (dec_valid_in) begin\n            for (int i = 0; i < N; i++) begin\n                if (dec_data_in[2*i] == 1'b0 && dec_data_in[2*i+1] == 1'b1) begin\n                    dec_data_out[i] <= 1'b1;\n                end else if (dec_data_in[2*i] == 1'b1 && dec_data_in[2*i+1] == 1'b0) begin\n                    dec_data_out[i] <= 1'b0;\n                end else begin\n                    dec_data_out[i] <= 1'b0;\n                end\n            end\n            dec_valid_out <= 1'b1;\n        end else begin\n            dec_data_out  <= '0;\n            dec_valid_out <= 1'b0;\n        end\n    end\n\nendmodule"}, "patch": {"rtl/top_inv_manchester_codec.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/top_inv_manchester_codec.sv\nTOPLEVEL        = top_inv_manchester_codec\nMODULE          = test_inv_manchester_codec\nPYTHONPATH      = /src\nHASH            = 5-write-assertions-for-top_inv_manchester_codec \n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameter:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\n\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_inv_manchester_codec.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and start the clock.\"\"\"\n    dut.rst_in.value = 1\n    dut.enc_valid_in.value = 0\n    dut.enc_data_in.value = 0\n    dut.dec_valid_in.value = 0\n    dut.dec_data_in.value = 0\n    \n    clock = Clock(dut.clk_in, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    print(\"DUT initialized.\")\n\nasync def check_encoding(dut, input_data, N):\n    \"\"\"Check if the Manchester encoder outputs the correct encoded data.\"\"\"\n    expected_output = 0\n    for i in range(N):\n        bit = (input_data >> i) & 1\n        expected_output |= ((bit << (2 * i + 1)) | ((~bit & 1) << (2 * i)))\n    \n    await RisingEdge(dut.clk_in)  # Wait for output to stabilize\n    print(f\"Checking Encoding: Input={bin(input_data)}, Expected={bin(expected_output)}, Got={bin(dut.enc_data_out.value.integer)}\")\n    assert dut.enc_data_out.value.integer == expected_output, \"Encoding mismatch.\"\n    assert dut.enc_valid_out.value == 1, \"Encoder valid signal is not asserted.\"\n\nasync def check_decoding(dut, encoded_data, original_data):\n    \"\"\"Check if the Manchester decoder correctly recovers the original data.\"\"\"\n    await RisingEdge(dut.clk_in)  # Wait for output to stabilize\n    print(f\"Checking Decoding: Encoded={bin(encoded_data)}, Expected={bin(original_data)}, Got={bin(dut.dec_data_out.value.integer)}\")\n    assert dut.dec_data_out.value.integer == original_data, \"Decoding mismatch.\"\n    assert dut.dec_valid_out.value == 1, \"Decoder valid signal is not asserted.\"\n\n@cocotb.test()\nasync def test_all_zeros_ones(dut):\n    \"\"\"Test encoding and decoding with all 0s and all 1s inputs.\"\"\"\n    await initialize_dut(dut)\n    N = int(dut.N.value)\n    \n    test_cases = [(0, \"All 0s\"), ((1 << N) - 1, \"All 1s\")]\n    \n    for input_data, description in test_cases:\n        print(f\"Running test: {description}\")\n        dut.enc_data_in.value = input_data\n        dut.enc_valid_in.value = 1\n        \n        await RisingEdge(dut.clk_in)\n        await check_encoding(dut, input_data, N)\n        \n        encoded_data = dut.enc_data_out.value.integer\n        dut.dec_data_in.value = encoded_data\n        dut.dec_valid_in.value = 1\n        \n        await RisingEdge(dut.clk_in)\n        await check_decoding(dut, encoded_data, input_data)\n        print(f\"{description} test passed.\")\n\n@cocotb.test()\nasync def test_encoding(dut):\n    \"\"\"Test encoding by driving random values and comparing with expected encoded values.\"\"\"\n    await initialize_dut(dut)\n    N = int(dut.N.value)\n    \n    for _ in range(10):\n        input_data = random.randint(0, (1 << N) - 1)\n        dut.enc_data_in.value = input_data\n        dut.enc_valid_in.value = 1\n        \n        await RisingEdge(dut.clk_in)\n        await check_encoding(dut, input_data, N)\n\n@cocotb.test()\nasync def test_decoding(dut):\n    \"\"\"Test decoding by driving random decoder inputs and comparing decoder output.\"\"\"\n    await initialize_dut(dut)\n    N = int(dut.N.value)\n    \n    for _ in range(10):\n        input_data = random.randint(0, (1 << N) - 1)\n        expected_encoded_data = 0\n        for i in range(N):\n            bit = (input_data >> i) & 1\n            expected_encoded_data |= ((bit << (2 * i + 1)) | ((~bit & 1) << (2 * i)))\n        \n        dut.dec_data_in.value = expected_encoded_data\n        dut.dec_valid_in.value = 1\n        \n        await RisingEdge(dut.clk_in)\n        await check_decoding(dut, expected_encoded_data, input_data)\n\n@cocotb.test()\nasync def test_encoding_decoding_together(dut):\n    \"\"\"Drive both encoder and decoder inputs at the same time and compare outputs.\"\"\"\n    await initialize_dut(dut)\n    N = int(dut.N.value)\n    \n    for _ in range(10):\n        input_data = random.randint(0, (1 << N) - 1)\n        dut.enc_data_in.value = input_data\n        dut.enc_valid_in.value = 1\n        \n        await RisingEdge(dut.clk_in)\n        await check_encoding(dut, input_data, N)\n        \n        encoded_data = dut.enc_data_out.value.integer\n        dut.dec_data_in.value = encoded_data\n        dut.dec_valid_in.value = 1\n        \n        await RisingEdge(dut.clk_in)\n        await check_decoding(dut, encoded_data, input_data)\n\n@cocotb.test()\nasync def test_reset(dut):\n    \"\"\"Test reset behavior of encoder and decoder.\"\"\"\n    await initialize_dut(dut)\n    N = int(dut.N.value)\n    \n    input_data = random.randint(0, (1 << N) - 1)\n    dut.enc_data_in.value = input_data\n    dut.enc_valid_in.value = 1\n    await RisingEdge(dut.clk_in)\n    \n    # Assert reset\n    dut.rst_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    \n    print(\"Checking Reset: Encoder Output should be 0.\")\n    assert dut.enc_data_out.value.integer == 0, \"Encoder output is not reset to 0.\"\n    assert dut.enc_valid_out.value == 0, \"Encoder valid signal is not reset.\"\n    print(\"Checking Reset: Decoder Output should be 0.\")\n    assert dut.dec_data_out.value.integer == 0, \"Decoder output is not reset to 0.\"\n    assert dut.dec_valid_out.value == 0, \"Decoder valid signal is not reset.\"\n    \n    # Deassert reset\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    print(\"Reset test completed.\")\n\n", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        \n        hrs_lb.runner(wave = wave, toplevel = toplevel, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\nif __name__ == \"__main__\":\n    test_runner()"}}
{"id": "cvdp_agentic_jpeg_runlength_enc_0003", "categories": ["cid014", "hard"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Enhance the design by incorporating SystemVerilog Assertions (SVA) to ensure robust verification of internal control, functional behavior in the `jpeg_runlength_enc` module. The project, located in the **rtl** directory, implements a hierarchical JPEG Run-Length Encoding scheme consisting of three interrelated modules:\n\n- **jpeg_runlength_enc** (Top\u2011Level Interface & Pipeline Integration)  \n  This module is the central integration block that connects the processing pipeline stages. It instantiates:\n  - **jpeg_runlength_stage1** \u2013 the encoding stage responsible for:\n    - Separating DC from AC coefficients.\n    - Calculating run\u2011length for AC coefficients.\n    - Determining coefficient size (category) and adjusting amplitude.\n    - Generating the control flag (`dcterm_out`) when processing the DC term.\n  - **jpeg_runlength_rzs** \u2013 the zero\u2011run suppression stage used in multiple instances (stages 2\u20135) to:\n    - Detect complete zero\u2011blocks from the input signals.\n    - Suppress the output enable (`den_out`) when required.\n    - Propagate data through pipeline registers while ensuring signal timing and integrity.\n    - Manage state transitions between zero\u2011suppression and normal operation via an internal state machine.\n \n### Assertion Requirements\n\nPlease implement SVA  to check that the design module `jpeg_runlength_enc` satisfies the following functional and safety properties:\n\n1. **Pipeline Delay Consistency**  \n   - In **jpeg_runlength_enc**, the `douten_out` signal must follow the assertion of `dstrb_in` after a defined pipeline delay.  \n\n2. **Block Start Validity**  \n   - When `bstart_out` is high, the output valid signal (`douten_out`) must also be asserted, and the run\u2011length output (`rlen_out`) must equal 0, indicating a proper block start.\n\n3. **DC Marker Uniqueness**  \n   - Ensure that the DC marker (originating from `stage1_dc` in **jpeg_runlength_enc**) is asserted only once per block. Once the DC term is issued, it must not be repeated until a new block begins.\n\n4. **Valid Data Output Integrity**  \n   - Whenever `douten_out` is high, the corresponding encoded outputs (`rlen_out`, `size_out`, and `amp_out`) must carry valid data. At least one bit of `amp_out` should be set for non-DC data, and for DC terms, `rlen_out` must be 0.\n\n### Expected Behavior\n\n- The assertion properties must be placed in a separate module named `jpeg_run_length_assertion_check` in the `verif` directory, which instantiates the `jpeg_runlength_enc` module as the Device Under Test (DUT).\n- The properties must reference internal DUT signals directly for verification purposes.\n\n### Notes\n\n- All assertions must use **SystemVerilog Assertions (SVA)** syntax.\n- Create the new **verif** directory file (`jpeg_run_length_assertion_check.sv`)  that should have these assertions implemented.\n", "context": {"rtl/jpeg_runlength_enc.sv": "module jpeg_runlength_enc (\n    // Clock and Control Signals\n    input         clk_in,      // System clock (positive edge)\n    input         reset_in,    // Synchronous active-high reset\n    input         enable_in,   // Clock enable (active high)\n    input         dstrb_in,    // Data strobe (start of block)\n    \n    // Data Input\n    input  [11:0] din_in,      // 12-bit signed DCT coefficient input\n    \n    // Encoded Outputs\n    output [ 3:0] rlen_out,    // Run-length (0-15 zeros)\n    output [ 3:0] size_out,    // Coefficient size/category\n    output [11:0] amp_out,     // Coefficient amplitude\n    output        douten_out,  // Data output valid\n    output        bstart_out   // Block start indicator\n);\n\n    // =========================================================================\n    // Internal Signal Declarations\n    // =========================================================================\n    \n    // Inter-stage signals (renamed with stage suffixes)\n    wire [ 3:0] stage1_rlen, stage2_rlen, stage3_rlen, stage4_rlen, stage5_rlen;\n    wire [ 3:0] stage1_size, stage2_size, stage3_size, stage4_size, stage5_size;\n    wire [11:0] stage1_amp,  stage2_amp,  stage3_amp,  stage4_amp,  stage5_amp;\n    wire        stage1_den,  stage2_den,  stage3_den,  stage4_den,  stage5_den;\n    wire        stage1_dc,   stage2_dc,   stage3_dc,   stage4_dc,   stage5_dc;\n\n    // =========================================================================\n    // Processing Pipeline Stages\n    // =========================================================================\n    \n    // Stage 1: Initial Run-Length Encoding\n    jpeg_runlength_stage1 stage1_inst (\n        .clk_in     (clk_in),\n        .reset_in   (reset_in),\n        .enable_in  (enable_in),\n        .go_in      (dstrb_in),\n        .din_in     (din_in),\n        .rlen_out   (stage1_rlen),\n        .size_out   (stage1_size),\n        .amp_out    (stage1_amp),\n        .den_out    (stage1_den),\n        .dcterm_out (stage1_dc)\n    );\n\n    // Stage 2: First Zero-Run Suppression\n    jpeg_runlength_rzs stage2_inst (\n        .clk_in     (clk_in),\n        .reset_in   (reset_in),\n        .enable_in  (enable_in),\n        .rlen_in    (stage1_rlen),\n        .size_in    (stage1_size),\n        .amp_in     (stage1_amp),\n        .den_in     (stage1_den),\n        .dc_in      (stage1_dc),\n        .rlen_out   (stage2_rlen),\n        .size_out   (stage2_size),\n        .amp_out    (stage2_amp),\n        .den_out    (stage2_den),\n        .dc_out     (stage2_dc)\n    );\n\n    // Stage 3: Second Zero-Run Suppression\n    jpeg_runlength_rzs stage3_inst (\n        .clk_in     (clk_in),\n        .reset_in   (reset_in),\n        .enable_in  (enable_in),\n        .rlen_in    (stage2_rlen),\n        .size_in    (stage2_size),\n        .amp_in     (stage2_amp),\n        .den_in     (stage2_den),\n        .dc_in      (stage2_dc),\n        .rlen_out   (stage3_rlen),\n        .size_out   (stage3_size),\n        .amp_out    (stage3_amp),\n        .den_out    (stage3_den),\n        .dc_out     (stage3_dc)\n    );\n\n    // Stage 4: Third Zero-Run Suppression\n    jpeg_runlength_rzs stage4_inst (\n        .clk_in     (clk_in),\n        .reset_in   (reset_in),\n        .enable_in  (enable_in),\n        .rlen_in    (stage3_rlen),\n        .size_in    (stage3_size),\n        .amp_in     (stage3_amp),\n        .den_in     (stage3_den),\n        .dc_in      (stage3_dc),\n        .rlen_out   (stage4_rlen),\n        .size_out   (stage4_size),\n        .amp_out    (stage4_amp),\n        .den_out    (stage4_den),\n        .dc_out     (stage4_dc)\n    );\n\n    // Stage 5: Fourth Zero-Run Suppression (Final Stage)\n    jpeg_runlength_rzs stage5_inst (\n        .clk_in     (clk_in),\n        .reset_in   (reset_in),\n        .enable_in  (enable_in),\n        .rlen_in    (stage4_rlen),\n        .size_in    (stage4_size),\n        .amp_in     (stage4_amp),\n        .den_in     (stage4_den),\n        .dc_in      (stage4_dc),\n        .rlen_out   (stage5_rlen),\n        .size_out   (stage5_size),\n        .amp_out    (stage5_amp),\n        .den_out    (stage5_den),\n        .dc_out     (stage5_dc)\n    );\n\n    // =========================================================================\n    // Output Assignments\n    // =========================================================================\n    assign rlen_out    = stage5_rlen;\n    assign size_out    = stage5_size;\n    assign amp_out     = stage5_amp;\n    assign douten_out  = stage5_den;\n    assign bstart_out  = stage5_dc;\n\nendmodule", "rtl/jpeg_runlength_rzs.sv": "module jpeg_runlength_rzs (\n    // Clock and Control Signals\n    input         clk_in,      // System clock (positive edge)\n    input         enable_in,   // Clock enable (active high)\n    input         reset_in,    // Synchronous active-high reset\n    \n    // Input Data Bus\n    input         den_in,      // Data input valid\n    input         dc_in,       // DC coefficient indicator\n    input  [ 3:0] rlen_in,     // Run-length input (0-15)\n    input  [ 3:0] size_in,     // Coefficient size/category\n    input  [11:0] amp_in,      // Coefficient amplitude\n    \n    // Output Data Bus\n    output reg    den_out,     // Data output valid\n    output reg    dc_out,      // DC coefficient output indicator\n    output reg [ 3:0] rlen_out, // Run-length output\n    output reg [ 3:0] size_out, // Size/category output\n    output reg [11:0] amp_out   // Amplitude output\n);\n\n    // =========================================================================\n    // Internal Registers and Signals\n    // =========================================================================\n    \n    // Pipeline registers for output data\n    reg [ 3:0] size;\n    reg [ 3:0] rlen;\n    reg [11:0] amp;\n    reg        den;\n    reg        dc;\n    \n    // Control signals\n    wire eob;      // End-of-Block detection\n    wire zerobl;   // Zero-block detection\n    reg  state;    // State machine state (0=normal, 1=zero-block)\n\n    // =========================================================================\n    // Data Pipeline Registers\n    // =========================================================================\n    \n    // Input data pipeline stage\n    always @(posedge clk_in or posedge reset_in)\n        if (reset_in) begin\n            size <= 4'b0;\n            rlen <= 4'b0;\n            amp  <= 12'b0;\n        end else if (enable_in & den_in) begin\n            size <= size_in;\n            rlen <= rlen_in;\n            amp  <= amp_in;\n        end\n    \n    // Output data pipeline stage\n    always @(posedge clk_in or posedge reset_in)\n        if (reset_in) begin\n            size_out <= 4'b0;\n            rlen_out <= 4'b0;\n            amp_out  <= 12'b0;\n            dc       <= 1'b0;\n            dc_out   <= 1'b0;\n        end else if (enable_in) begin\n            size_out <= size;\n            rlen_out <= rlen;\n            amp_out  <= amp;\n            dc       <= dc_in;\n            dc_out   <= dc;\n        end\n\n    // =========================================================================\n    // Control Signal Generation\n    // =========================================================================\n    \n    // Zero-block detection: run-length=15 and size=0 with valid data\n    assign zerobl = &rlen_in & ~|size_in & den_in;\n    \n    // End-of-Block detection: run-length=0 and size=0 with valid AC data\n    assign eob    = ~|{rlen_in, size_in} & den_in & ~dc_in;\n\n    // =========================================================================\n    // Zero-Suppression State Machine\n    // =========================================================================\n    always @(posedge clk_in or posedge reset_in)\n        if (reset_in) begin\n            state   <= 1'b0;  // Start in normal state\n            den     <= 1'b0;\n            den_out <= 1'b0;\n        end else if (enable_in)\n            case (state)\n                // Normal Processing State\n                1'b0: begin\n                    if (zerobl) begin\n                        // Detected zero-block, transition to suppression state\n                        state   <= 1'b1;\n                        den     <= 1'b0;  // Suppress output\n                        den_out <= den;    // Output previous data\n                    end else begin\n                        // Continue normal processing\n                        state   <= 1'b0;\n                        den     <= den_in; // Pass through data enable\n                        den_out <= den;    // Output previous data\n                    end\n                end\n                \n                // Zero-Block Suppression State\n                1'b1: begin\n                    den_out <= 1'b0;  // Default to suppressed output\n                    \n                    if (den_in) begin  // Only act when input valid\n                        if (zerobl) begin\n                            // Another zero-block detected\n                            state   <= 1'b1;  // Stay in suppression state\n                            den     <= 1'b0;  // Continue suppression\n                            den_out <= 1'b1;  // Output previous zero-block\n                        end else if (eob) begin\n                            // EOB marker detected\n                            state   <= 1'b0;  // Return to normal state\n                            den     <= 1'b1;  // Enable EOB output\n                            den_out <= 1'b0;  // Explicitly zero\n                        end else begin\n                            // Non-zero data detected\n                            state   <= 1'b0;  // Return to normal state\n                            den     <= 1'b1;  // Enable data output\n                            den_out <= 1'b1;  // Output zero-block\n                        end\n                    end\n                end\n            endcase\n\nendmodule", "rtl/jpeg_runlength_stage1.sv": "module jpeg_runlength_stage1 (\n    // Clock and reset\n    input         clk_in,       // System clock (positive edge triggered)\n    input         reset_in,     // Synchronous active-high reset\n    \n    // Control signals\n    input         enable_in,    // Clock enable (active high)\n    input         go_in,        // Start new block (pulse high for 1 cycle)\n    \n    // Data input\n    input  [11:0] din_in,       // 12-bit DCT coefficient input\n    \n    // Encoded outputs\n    output reg [ 3:0] rlen_out,     // Run-length (0-15 zeros before this coefficient)\n    output reg [ 3:0] size_out,     // Category (bit size needed for coefficient)\n    output reg [11:0] amp_out,      // Amplitude (modified coefficient value)\n    output reg        den_out,      // Data valid output (active high)\n    output reg        dcterm_out    // Indicates DC term output (active high)\n);\n\n    // =========================================================================\n    // Internal Signals and State\n    // =========================================================================\n    \n    // Sample counter (0-63 for 8x8 block)\n    reg [5:0] sample_cnt;\n    \n    // Zero run-length counter (counts consecutive zeros)\n    reg [3:0] zero_cnt;\n    \n    // Zero detection signal (high when input is zero)\n    wire is_zero = ~|din_in;\n    \n    // State machine states\n    reg state;\n    parameter dc = 1'b0;  // Processing DC coefficient (first in block)\n    parameter ac = 1'b1;  // Processing AC coefficients\n\n    // =========================================================================\n    // Helper Functions\n    // =========================================================================\n    \n    /**\n     * Absolute Value Function\n     * Returns absolute value of 12-bit signed input\n     */\n    function [10:0] abs;\n        input [11:0] a;\n    begin\n        abs = a[11] ? (~a[10:0] + 11'h1) : a[10:0];  // 2's complement conversion\n    end\n    endfunction\n\n    /**\n     * Category (Bit Size) Calculation\n     * Determines the number of bits needed to represent the coefficient\n     * Returns value 0-11 (0 means zero coefficient, special case for DC)\n     */\n    function [3:0] cat;\n        input [11:0] a;\n        reg [10:0] tmp;\n    begin\n        tmp = abs(a);  // Get absolute value first\n        \n        // Priority encoder style category detection\n        casex(tmp) // synopsys full_case parallel_case\n            11'b1??_????_???? : cat = 4'hb; // 1024..2047 (11 bits)\n            11'b01?_????_???? : cat = 4'ha; //  512..1023 (10 bits)\n            11'b001_????_???? : cat = 4'h9; //  256.. 511 (9 bits)\n            11'b000_1???_???? : cat = 4'h8; //  128.. 255 (8 bits)\n            11'b000_01??_???? : cat = 4'h7; //   64.. 127 (7 bits)\n            11'b000_001?_???? : cat = 4'h6; //   32..  63 (6 bits)\n            11'b000_0001_???? : cat = 4'h5; //   16..  31 (5 bits)\n            11'b000_0000_1??? : cat = 4'h4; //    8..  15 (4 bits)\n            11'b000_0000_01?? : cat = 4'h3; //    4..   7 (3 bits)\n            11'b000_0000_001? : cat = 4'h2; //    2..   3 (2 bits)\n            11'b000_0000_0001 : cat = 4'h1; //    1      (1 bit)\n            11'b000_0000_0000 : cat = 4'h0; //    0      (special case)\n        endcase\n    end\n    endfunction\n\n    /**\n     * Amplitude Modification Function\n     * Adjusts coefficient value for more efficient encoding\n     */\n    function [10:0] rem;\n        input [11:0] a;\n        reg [10:0] tmp_rem;\n    begin\n        // For negative numbers: rem = -a - 1\n        // For positive numbers: rem = a\n        tmp_rem = a[11] ? (a[10:0] - 10'h1) : a[10:0];\n        rem = tmp_rem;\n    end\n    endfunction\n\n    // =========================================================================\n    // Main Processing Logic\n    // =========================================================================\n\n    // Amplitude output register\n    always @(posedge clk_in or posedge reset_in)\n        if (reset_in)\n            amp_out <= 12'b0;\n        else if (enable_in)\n            amp_out <= {din_in[11], rem(din_in)}; // Preserve sign bit\n\n    // Sample counter (0-63 for 8x8 block)\n    always @(posedge clk_in or posedge reset_in)\n        if (reset_in)\n            sample_cnt <= 6'b0;\n        else if (enable_in)\n            if (go_in)          // Start new block\n                sample_cnt <= 1; // Skip DC position (handled separately)\n            else if (|sample_cnt) // Only increment if not zero\n                sample_cnt <= sample_cnt + 1;\n\n    // Zero run-length counter\n    always @(posedge clk_in or posedge reset_in)\n        if (reset_in)\n            zero_cnt <= 4'b0;\n        else if (enable_in)\n            if (is_zero)\n                zero_cnt <= zero_cnt + 1; // Increment for zero coefficients\n            else\n                zero_cnt <= 0;           // Reset for non-zero coefficients\n\n    // =========================================================================\n    // State Machine - Controls Output Encoding\n    // =========================================================================\n    always @(posedge clk_in or posedge reset_in)\n        if (reset_in) begin\n            state      <= dc;\n            rlen_out   <= 0;\n            size_out   <= 0;\n            den_out    <= 1'b0;\n            dcterm_out <= 1'b0;\n        end else if (enable_in)\n            case (state)\n                // DC Coefficient Processing State\n                dc: begin\n                    rlen_out <= 0; // DC has no run-length\n                    size_out <= cat(din_in); // Get DC coefficient size\n                    \n                    if (go_in) begin\n                        // Start processing AC coefficients\n                        state      <= ac;\n                        den_out   <= 1'b1;    // Output valid\n                        dcterm_out <= 1'b1;   // Mark as DC term\n                    end else begin\n                        // Stay in DC state\n                        state      <= dc;\n                        den_out   <= 1'b0;    // No output\n                        dcterm_out <= 1'b0;\n                    end\n                end\n                \n                // AC Coefficient Processing State\n                ac: begin\n                    if (&sample_cnt) begin\n                        // End of block processing\n                        state <= dc; // Return to DC state\n                        \n                        if (is_zero) begin\n                            // End-of-block marker\n                            rlen_out   <= 0;\n                            size_out   <= 0;\n                            den_out    <= 1'b1;\n                            dcterm_out <= 1'b0;\n                        end else begin\n                            // Last coefficient in block\n                            rlen_out   <= zero_cnt;\n                            size_out   <= cat(din_in);\n                            den_out    <= 1'b1;\n                            dcterm_out <= 1'b0;\n                        end\n                    end else begin\n                        // Normal AC coefficient processing\n                        state      <= ac;\n                        rlen_out   <= zero_cnt;\n                        dcterm_out <= 1'b0;\n                        \n                        // Handle zero vs non-zero coefficients\n                        size_out <= is_zero ? 0 : cat(din_in);\n                        den_out  <= is_zero ? &zero_cnt : 1'b1; // Only output after 15 zeros\n                    end\n                end\n            endcase\nendmodule"}, "patch": {"verif/jpeg_run_length_assertion_check.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/verif/jpeg_run_length_assertion_check.sv /code/rtl/jpeg_runlength_enc.sv /code/rtl/jpeg_runlength_rzs.sv /code/rtl/jpeg_runlength_stage1.sv\nTOPLEVEL        = jpeg_run_length_assertion_check\nMODULE          = test_jpeg_runlength_enc\nPYTHONPATH      = /src\nHASH            = ee3d9e6d7c7e5f67d40650e2bc466d484fb212b6\nCOV_SELECTIONS  = basic_dstrb_function douten_handling stage_eob_handling valid_data_output\nCOV_THRESHOLDS  = 25 25 25 25\n", "src/coverage.py": "from cocotb.runner import get_runner\nimport os\nimport subprocess\nimport re\nfrom typing import Mapping\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\", cov_selection:str = \"\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    extra_env: Mapping[str, str] = {}\n    if cov_selection:\n        extra_env = { \"SELECTION\": cov_selection }\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\",\n                extra_env=extra_env)\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef coverage_report_clear():\n    report_file=\"/code/rundir/coverage.log\"\n    if os.path.isfile(report_file):\n        os.remove(report_file)\n\ndef coverage_report_check(cov_threshold:float = 100.0):\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    print(f'column: {column}')\n    for line in lines[2:]:\n        match = re.match(r'^(.*?)\\s+(\\d+\\.?\\d*% \\(\\d+/\\d+\\))\\s+(\\d+% \\(\\d+/\\d+/\\d+\\))', line.strip())\n        if match:\n            info = list(match.groups())\n            print(f'info: {info}')\n        else:\n            info = re.split(r'\\s{2,}', line.strip())\n            print(f\"no regular expression match, trying differently: {info}\")\n\n        inst = info[0].lstrip('|-')\n        print(f'inst: {inst}')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= cov_threshold, f\"Didn't achieved the required coverage result (cov_threshold={cov_threshold}).\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/test_jpeg_runlength_enc.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nimport math\nimport os\n\nclass JPEGRLEReference:\n    \"\"\"Reference model for JPEG Run-Length Encoding (RLE) behavior\"\"\"\n    def __init__(self):\n        self.zero_run = 0      # Current count of consecutive zeros\n        self.block_pos = 0     # Position in current block (0-63)\n        self.block_size = 64   # JPEG block size (8x8)\n        self.debug = True      # Debug print enable\n    \n    def process_sample(self, sample, is_block_start):\n        \"\"\"Process a single sample through the reference model\"\"\"\n        outputs = []\n        \n        if is_block_start:\n            # DC term processing (must be first in block)\n            if self.debug:\n                print(f\"\\n[REF] BLOCK START: DC = {sample}\")\n            self.block_pos = 0\n            self.zero_run = 0\n            size = self.get_size(sample)\n            outputs.append((0, size, sample, True))  # (rlen, size, amp, is_dc)\n        else:\n            # AC term processing\n            self.block_pos += 1\n            if self.debug:\n                print(f\"[REF] AC #{self.block_pos}: Input = {sample}, Zero Run = {self.zero_run}\")\n            \n            if sample == 0:\n                self.zero_run += 1\n                if self.zero_run == 16:\n                    # Emit Zero Run Length (ZRL) marker (15,0)\n                    if self.debug:\n                        print(\"[REF] Emitting ZRL (15,0,0)\")\n                    outputs.append((15, 0, 0, False))\n                    self.zero_run = 0\n            else:\n                # Emit pending zeros followed by current non-zero value\n                if self.zero_run > 0:\n                    size = self.get_size(sample)\n                    if self.debug:\n                        print(f\"[REF] Emitting (rlen={self.zero_run}, size={size}, amp={sample})\")\n                    outputs.append((self.zero_run, size, sample, False))\n                    self.zero_run = 0\n                else:\n                    # Immediate non-zero value\n                    size = self.get_size(sample)\n                    if self.debug:\n                        print(f\"[REF] Emitting (rlen=0, size={size}, amp={sample})\")\n                    outputs.append((0, size, sample, False))\n            \n            # Check for End-of-Block (EOB)\n            if self.block_pos == self.block_size - 1 and self.zero_run > 0:\n                if self.debug:\n                    print(\"[REF] Emitting EOB (0,0,0)\")\n                outputs.append((0, 0, 0, False))  # EOB marker\n        \n        return outputs\n    \n    def get_size(self, value):\n        \"\"\"Calculate the size/category for a given value\"\"\"\n        abs_val = abs(value)\n        return math.ceil(math.log2(abs_val + 1)) if abs_val != 0 else 0\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT with proper reset sequence\"\"\"\n    dut.reset_in.value = 1\n    dut.enable_in.value = 0\n    dut.dstrb_in.value = 0\n    dut.din_in.value = 0\n\n    # Start clock generator\n    cocotb.start_soon(Clock(dut.clk_in, 10, units=\"ns\").start())\n\n    # Wait for two clock edges\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    # Activate reset and enable\n    dut.reset_in.value = 0\n    dut.enable_in.value = 1\n\n    await RisingEdge(dut.clk_in)\n    print(\"\\n[TB] DUT initialized\\n\")\n\nasync def apply_input(dut, sample, is_block_start):\n    \"\"\"Apply input to DUT and print debug info\"\"\"\n    print(f\"[IN] {'DC' if is_block_start else 'AC'}: {sample} (dstrb_in={1 if is_block_start else 0})\")\n    dut.din_in.value = sample\n    dut.dstrb_in.value = 1 if is_block_start else 0\n    await RisingEdge(dut.clk_in)\n    dut.dstrb_in.value = 0\n\nasync def verify_output(dut, expected, test_case, cycle):\n    \"\"\"Verify DUT output against expected values\"\"\"\n    if dut.douten_out.value == 1:\n        actual = (\n            int(dut.rlen_out.value),\n            int(dut.size_out.value),\n            int(dut.amp_out.value.signed_integer),\n            bool(dut.bstart_out.value)\n        )\n        \n        print(f\"\\n[TEST {test_case}.{cycle}] OUTPUT COMPARISON:\")\n        print(\"=\"*50)\n        print(f\"[ACTUAL]   rlen={actual[0]}, size={actual[1]}, amp={actual[2]}, bstart={actual[3]}\")\n        print(f\"[EXPECTED] rlen={expected[0]}, size={expected[1]}, amp={expected[2]}, bstart={expected[3]}\")\n        print(\"=\"*50)\n        \n        assert actual == expected, f\"Test {test_case}.{cycle} failed: Expected {expected}, got {actual}\"\n        return True\n    return False\n\n# =============================================================================\n# Test Case 1: Basic Functional Test\n# =============================================================================\n@cocotb.test()\nasync def test_basic_dstrb_function(dut):\n    if os.getenv(\"SELECTION\") != 'basic_dstrb_function':\n        return\n\n    \"\"\"Test basic strobe functionality with mixed coefficients\"\"\"\n    await initialize_dut(dut)\n    ref_model = JPEGRLEReference()\n    \n    print(f\"\\n{'='*60}\")\n    print(\"TEST CASE 1: Basic strobe block with mixed coefficients\")\n    print(f\"{'='*60}\\n\")\n    \n    # DC term\n    sample = 42\n    expected_outputs = ref_model.process_sample(sample, True)\n    await apply_input(dut, sample, True)\n    await verify_output(dut, expected_outputs[0], 1, 1)\n    \n    # AC terms\n    samples = [0, 0, 15, 0, 127] + [0]*59\n    for i, sample in enumerate(samples, 2):  # Start counting from 2 (after DC)\n        expected_outputs = ref_model.process_sample(sample, False)\n        await apply_input(dut, sample, False)\n        \n        for expected in expected_outputs:\n            if await verify_output(dut, expected, 1, i):\n                await RisingEdge(dut.clk_in)\n\n# =============================================================================\n# Test Case 2: douten_out Handling\n# =============================================================================\n@cocotb.test()\nasync def test_douten_handling(dut):\n    if os.getenv(\"SELECTION\") != 'douten_handling':\n        return\n    \n    \"\"\"Test dout enable for Zero Run Length (15,0) sequences\"\"\"\n    await initialize_dut(dut)\n    ref_model = JPEGRLEReference()\n    \n    print(f\"\\n{'='*60}\")\n    print(\"TEST CASE 2: douten Block with Zero Run Length (ZRL)\")\n    print(f\"{'='*60}\\n\")\n    \n    # DC term\n    sample = 128\n    expected_outputs = ref_model.process_sample(sample, True)\n    await apply_input(dut, sample, True)\n    await verify_output(dut, expected_outputs[0], 2, 1)\n    \n    # 16 zeros (should produce ZRL:15,0)\n    samples = [0]*16 + [255] + [0]*47\n    for i, sample in enumerate(samples, 2):\n        expected_outputs = ref_model.process_sample(sample, False)\n        await apply_input(dut, sample, False)\n        \n        for expected in expected_outputs:\n            if await verify_output(dut, expected, 2, i):\n                await RisingEdge(dut.clk_in)\n\n# =============================================================================\n# Test Case 3: stage End-of-Block (EOB) Handling\n# =============================================================================\n@cocotb.test()\nasync def test_stage_eob_handling(dut):\n    if os.getenv(\"SELECTION\") != 'stage_eob_handling':\n        return\n    \n    \"\"\"Test stage 1 to 5 End-of-Block (0,0) marker generation\"\"\"\n    await initialize_dut(dut)\n    ref_model = JPEGRLEReference()\n    \n    print(f\"\\n{'='*60}\")\n    print(\"TEST CASE 3: All zeros after DC (EOB only)\")\n    print(f\"{'='*60}\\n\")\n    \n    # DC term\n    sample = 64\n    expected_outputs = ref_model.process_sample(sample, True)\n    await apply_input(dut, sample, True)\n    await verify_output(dut, expected_outputs[0], 3, 1)\n    \n    # All zeros (should produce EOB immediately)\n    samples = [0]*63\n    for i, sample in enumerate(samples, 2):\n        expected_outputs = ref_model.process_sample(sample, False)\n        await apply_input(dut, sample, False)\n        \n        for expected in expected_outputs:\n            if await verify_output(dut, expected, 3, i):\n                await RisingEdge(dut.clk_in)\n\n# =============================================================================\n# Test Case 4: Valid output data Handling\n# =============================================================================\n@cocotb.test()\nasync def test_valid_data_output(dut):\n    if os.getenv(\"SELECTION\") != 'valid_data_output':\n        return\n    \n    \"\"\"Test Valid data handling\"\"\"\n    await initialize_dut(dut)\n    ref_model = JPEGRLEReference()\n    \n    print(f\"\\n{'='*60}\")\n    print(\"TEST CASE 4: Valid data\")\n    print(f\"{'='*60}\\n\")\n    \n    # DC term (must be positive)\n    sample = 64\n    expected_outputs = ref_model.process_sample(sample, True)\n    await apply_input(dut, sample, True)\n    await verify_output(dut, expected_outputs[0], 4, 1)\n    \n    # AC terms with negative values\n    samples = [-5, 0, 0, -12, -25, 0, -3] + [0]*57\n    for i, sample in enumerate(samples, 2):\n        expected_outputs = ref_model.process_sample(sample, False)\n        await apply_input(dut, sample, False)\n        \n        for expected in expected_outputs:\n            if await verify_output(dut, expected, 4, i):\n                await RisingEdge(dut.clk_in)\n\n\n", "src/test_runner.py": "import os\nimport pytest\nimport coverage\nimport random\nimport traceback\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\ncov_selections  = os.getenv(\"COV_SELECTIONS\", \"\").split()\ncov_thresholds  = [float(s) for s in os.getenv(\"COV_THRESHOLDS\", \"\").split()]\n\ndef call_runner(cov_selection:tuple[str, float] = None):\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.coverage_report_clear()\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter={},\n            cov_selection=cov_selection[0] if cov_selection else \"\",\n        )\n        coverage.coverage_report(\"assertion\")\n        if cov_selection:\n            print(f'cov_selection[0]: {cov_selection[0]} cov_selection[1]: {cov_selection[1]}')\n            coverage.coverage_report_check(cov_selection[1])\n        else:\n            coverage.coverage_report_check()\n    except SystemExit:\n        traceback.print_exc()\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n\n    if len(cov_selections) == 0:\n        # Run the simulation\n        print(\"Calling runner without arguments\")\n        call_runner()\n        return\n\n    print(\"Identified special coverage selections\")\n\n    assert len(cov_selections) == len(cov_thresholds), \"incompatible coverage selections and thresholds\"\n\n    for selection, threshold in zip(cov_selections, cov_thresholds):\n        print(f\"> Running selection: {selection}, for threshold: {threshold}\")\n        call_runner((selection, threshold))\n\n\n"}}
{"id": "cvdp_agentic_memory_scheduler_0005", "categories": ["cid014", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i  \"problematic_line_number s/problematic_statement/non_problematic_statement/\" Buggy_RTL_code.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a memory scheduler module `memory_scheduler.sv` available in the rtl directory. Please modify the module by adding SystemVerilog Assertions (SVA) to check its internal functionality comprehensively. The assertions should verify the following conditions:\n\n**1. Reset Initialization (reset_initialization)**:\nEnsure that all internal registers and outputs are correctly initialized when the reset signal is asserted (active high). In particular, it shouldcheck that:\n\n`current_priority` is set to 2'b11.\n\n`round_robin_index` is set to 2'b00.\n\n`mem_cmd_valid` is deasserted (0).\n\n`grant` is reset to 4'b0000.\n\n`mem_address` is reset to 32'd0.\n\n`mem_cmd_type` is set to 2'b00.\n\n**2. No Request, No Command (no_request_no_cmd)**:\nEnsures that if no request is active (i.e., all bits in the request vector are 0), then the scheduler does not issue any command. It requires that when no request is present, both `mem_cmd_valid` remains low and `grant` is 4'b0000.\n\n**3. One-Hot Grant in Priority Mode (one_hot_grant_priority)**:\nEnsure that if, in the previous cycle, any request channel\u2019s QoS matches the previous cycle\u2019s current_priority, then in the current cycle the scheduler must produce a valid memory command (`mem_cmd_valid` asserted) with a one-hot encoded grant. It ensures that only one request (the highest-priority one in the combinational search) is granted.\n\n**4. One-Hot Grant Output (one_hot_grant)**:\nEnsure that whenever `mem_cmd_valid` is asserted and the grant is nonzero, the grant output is one-hot. In other words, if a command is active, exactly one bit in the grant vector must be high.\n\n**5. Memory Address Mapping (mem_address_mapping)**:\nEnsure that when a memory command is active, the output memory address (`mem_address`) correctly corresponds to the granted request. For example, if the grant equals 4'b0001, then mem_address should equal address 0; if 4'b0010, then it should equal address 1; and so on for channels 2 and 3.\n\n**6. Fixed Memory Command Type (mem_cmd_type_fixed)**:\nEnsure that whenever a memory command is valid (`mem_cmd_valid` is asserted), the memory command type (`mem_cmd_type`) remains fixed at 2'b00. This is a constant design attribute.\n\n**7. Valid Next Granted Request (valid_next_granted_request)**:\nThis property should check the combinational logic output `next_granted_request`. It asserts that the value is either zero (indicating no valid request is granted) or it is a valid one-hot encoded value (exactly one bit set). This helps verify that the scheduler\u2019s internal grant computation is correct.\n\n**8. Valid Request When Command (valid_request_when_cmd)**:\nVerify that if a memory command is issued (i.e., `mem_cmd_valid` is asserted), then there must be at least one active request in the request vector. In other words, the scheduler should never produce a command when no request is active.\n\n**9. No Priority Match Implies Next Grant Equals Temp (no_prio_implies_next_grant_equals_temp)**:\nEnsure that when no request matches the current priority (i.e., `local_found_prio` is 0), the computed `next_granted_request` must equal `temp_granted`. This confirms that the scheduler uses the round-robin branch\u2019s computed grant when no priority match is found.\n\n**10. Local Found RR Flag Set When Request Active (local_found_rr_if_request)**:\nEnsure that if no priority match is found (i.e., `local_found_prio is 0`) and at least one request is active, then the round-robin flag (`local_found_rr`) must be asserted (set to 1). This ensures that the round-robin mechanism is correctly triggered when priority-based selection fails.\n\nIf any of these conditions are violated during simulation, an appropriate error message should be displayed.\n\n\n", "context": {"docs/specs.md": "# Memory Scheduler Module Description\n\nThis module implements a multi\u2010request memory scheduler that grants one of four possible memory requests each cycle based on **rotating priority** and **round\u2010robin fallback**. It selects the next request to serve by first looking for a request matching a 2\u2010bit priority level (which decrements each time a request is serviced) and, if none match, it falls back to a round\u2010robin mechanism. The chosen request is marked by a single\u2010hot grant signal, and the corresponding address is driven onto the memory interface outputs.\n\n---\n\n## Parameterization\n\nThis design is primarily fixed at four requesters, each with a 2\u2010bit QoS level. Key fixed aspects include:\n\n- **Number of Requesters:** Exactly 4.  \n- **QoS Bit\u2010Width:** 2 bits per request, allowing 4 levels of priority (0..3).  \n- **Memory Address Width:** 32 bits for each request\u2019s address.\n\nNo additional compile\u2010time parameters are provided, so the design is specialized for four requesters.\n\n---\n\n## Interfaces\n\n### 1. Clock and Reset\n\n- **clk:** The primary clock input.  \n- **reset:** An active\u2010high reset that reinitializes the scheduler to its default state.\n\nWhen `reset` is asserted, the module clears any internal state and sets outputs to default values.\n\n### 2. Request and QoS Inputs\n\n- **request [3:0]:** A one\u2010bit \u201crequest\u201d signal for each of the four clients.  \n  - `request[i] = 1` indicates that client *i* has an active request.  \n- **qos [7:0]:** Four 2\u2010bit QoS fields, one for each requester.  \n  - `qos[1:0]`   => QoS for requester 0  \n  - `qos[3:2]`   => QoS for requester 1  \n  - `qos[5:4]`   => QoS for requester 2  \n  - `qos[7:6]`   => QoS for requester 3  \n  Higher QoS values (3) imply higher priority; lower values (0) imply lower priority.\n\n### 3. Address Inputs\n\n- **address0, address1, address2, address3 (32 bits each):**  \n  The 32\u2010bit memory addresses associated with each of the four requesters.\n\n### 4. Memory Interface Outputs\n\n- **mem_address [31:0]:** The selected address for the granted request.  \n- **mem_cmd_valid:** A control signal indicating when the scheduler has a valid memory command.  \n- **mem_cmd_type [1:0]:** The command type (e.g., `00` for READ, `01` for WRITE). In this design, it is always set to `READ` (2\u2019b00).\n\n### 5. Handshake and Grant\n\n- **mem_ack:** An input from the memory interface acknowledging that the current command has been accepted.  \n- **grant [3:0]:** A one\u2010hot vector indicating which request is currently granted. For example, `grant = 4'b0100` means request 2 is being serviced.\n\n---\n\n## Detailed Functionality\n\n### 1. Rotating Priority Logic\n\nThe module maintains a 2\u2010bit `current_priority` register, which starts at `3` (binary `11`) after reset. Each time a request is successfully issued (indicated by `mem_ack` going high) or when no request is currently valid, it **rotates** by decrementing this value (`3 \u2192 2 \u2192 1 \u2192 0 \u2192 3 \u2192 ...`).\n\n### 2. Priority\u2010Based Selection\n\nOn each cycle, if a new request can be chosen (i.e., either `mem_cmd_valid == 0` or `mem_ack == 1`):\n\n1. **Priority Pass**: The scheduler loops over the four request lines (from highest index to lowest) to find any requester whose 2\u2010bit QoS matches the `current_priority`. The highest\u2010indexed matching requester is selected.  \n2. **Round\u2010Robin Fallback**: If no requester matched the current priority, the scheduler performs a round\u2010robin search among all four request lines, starting from `round_robin_index`. It picks the first active requester it finds and then increments `round_robin_index`.\n\nIn this manner, the design ensures that:\n\n- Higher QoS requests (matching `current_priority`) are served first.  \n- If no request matches that QoS, the system avoids starvation by falling back to a round\u2010robin selection among all active requesters.\n\n### 3. Single\u2010Hot Grant and Memory Address\n\nOnce a request is selected:\n\n- The scheduler asserts `mem_cmd_valid` and drives the corresponding 32\u2010bit address onto `mem_address`.  \n- A single\u2010hot `grant` vector is generated, e.g. `4'b1000` for requester 3.  \n- The 2\u2010bit `mem_cmd_type` is set to `READ` (`00` in this example).\n\nThe module holds these signals stable until `mem_ack` indicates that the memory interface has accepted the request, allowing a new arbitration cycle to begin.\n\n### 4. Internal Registers and State\n\n- **current_priority:** Tracks which QoS level (0..3) the scheduler is trying to service first.  \n- **round_robin_index:** Tracks where the fallback round\u2010robin search starts.  \n- **granted_request [3:0]:** Stores which requester was chosen in the current cycle (single\u2010hot).\n\nAll updates occur synchronously on the rising edge of `clk` unless `reset` is asserted, which clears the module to default states (`mem_cmd_valid=0`, etc.).\n\n---\n\n## Summary\n\nThis **memory scheduler** module arbitrates up to four simultaneous requesters, each with a 2\u2010bit QoS level. It implements a **rotating QoS priority** (3 \u2192 2 \u2192 1 \u2192 0 \u2192 3 \u2192 \u2026) to ensure that higher\u2010priority requests are serviced first in each cycle. If no request matches the current priority, a **round\u2010robin** fallback ensures fairness among all active requests. The chosen request is granted exclusively via a one\u2010hot `grant` signal, and its address is driven on the `mem_address` output.\n\nThis architecture provides a **flexible yet compact** scheduling design for systems needing QoS priority control plus a backup fairness mechanism.\n", "rtl/memory_scheduler.sv": "`timescale 1ns/1ps\n\nmodule memory_scheduler(\n    input  wire         clk,\n    input  wire         reset,\n    input  wire [3:0]   request,      \n    input  wire [7:0]   qos,          \n    input  wire [31:0]  address0,\n    input  wire [31:0]  address1,\n    input  wire [31:0]  address2,\n    input  wire [31:0]  address3,\n    output reg  [31:0]  mem_address,\n    output reg          mem_cmd_valid,\n    output reg  [1:0]   mem_cmd_type,  \n    input  wire         mem_ack,\n    output reg  [3:0]   grant\n);\n\n    wire [1:0] qos0 = qos[1:0];\n    wire [1:0] qos1 = qos[3:2];\n    wire [1:0] qos2 = qos[5:4];\n    wire [1:0] qos3 = qos[7:6];\n    reg [1:0] current_priority;     \n    reg [1:0] round_robin_index;    \n    reg [3:0] granted_request;       \n    reg [3:0] next_granted_request;  \n    reg [1:0] next_rr_index;         \n    reg        local_found_prio;\n    reg        local_found_rr;\n    integer    i;\n    integer    idx;\n    reg [3:0]  temp_granted;  \n\n    always @* begin\n        \n        temp_granted     = 4'b0000;\n        local_found_prio = 1'b0;\n        local_found_rr   = 1'b0;\n        next_rr_index    = round_robin_index;\n\n        for (i = 3; i >= 0; i = i - 1) begin\n            if (local_found_prio == 1'b0) begin\n                case (i)\n                    3: if (request[3] && (qos3 == current_priority)) begin\n                           temp_granted[3] = 1'b1;\n                           local_found_prio = 1'b1;\n                       end\n                    2: if (request[2] && (qos2 == current_priority)) begin\n                           temp_granted[2] = 1'b1;\n                           local_found_prio = 1'b1;\n                       end\n                    1: if (request[1] && (qos1 == current_priority)) begin\n                           temp_granted[1] = 1'b1;\n                           local_found_prio = 1'b1;\n                       end\n                    0: if (request[0] && (qos0 == current_priority)) begin\n                           temp_granted[0] = 1'b1;\n                           local_found_prio = 1'b1;\n                       end\n                endcase\n            end\n        end\n\n        if (local_found_prio == 1'b0) begin\n            local_found_rr = 1'b0;\n            for (i = 0; i < 4; i = i + 1) begin\n                idx = (round_robin_index + i) % 4;\n                if (local_found_rr == 1'b0) begin\n                    case (idx)\n                        0: if (request[0]) begin\n                               temp_granted[0] = 1'b1;\n                               local_found_rr  = 1'b1;\n                               next_rr_index   = (idx + 1) % 4;\n                           end\n                        1: if (request[1]) begin\n                               temp_granted[1] = 1'b1;\n                               local_found_rr  = 1'b1;\n                               next_rr_index   = (idx + 1) % 4;\n                           end\n                        2: if (request[2]) begin\n                               temp_granted[2] = 1'b1;\n                               local_found_rr  = 1'b1;\n                               next_rr_index   = (idx + 1) % 4;\n                           end\n                        3: if (request[3]) begin\n                               temp_granted[3] = 1'b1;\n                               local_found_rr  = 1'b1;\n                               next_rr_index   = (idx + 1) % 4;\n                           end\n                    endcase\n                end\n            end\n        end\n        next_granted_request = temp_granted;\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_priority  <= 2'b11;  \n            round_robin_index <= 2'b00;\n            granted_request   <= 4'b0000;\n\n            mem_cmd_valid <= 1'b0;\n            mem_cmd_type  <= 2'b00;\n            mem_address   <= 32'd0;\n            grant         <= 4'b0000;\n        end\n        else begin\n            if ((mem_cmd_valid == 1'b0) || (mem_ack == 1'b1)) begin\n\n                granted_request <= next_granted_request;\n\n                if (next_granted_request == 4'b0000) begin\n                    mem_cmd_valid <= 1'b0;\n                    grant         <= 4'b0000;\n                end\n                else begin\n                    mem_cmd_valid <= 1'b1;\n                    mem_cmd_type  <= 2'b00;\n                    grant         <= next_granted_request;\n\n                    case (next_granted_request)\n                        4'b0001: mem_address <= address0;\n                        4'b0010: mem_address <= address1;\n                        4'b0100: mem_address <= address2;\n                        4'b1000: mem_address <= address3;\n                        default: mem_address <= 32'd0; \n                    endcase\n                end\n\n                if (current_priority == 2'b00) begin\n                    current_priority <= 2'b11;\n                end\n                else begin\n                    current_priority <= current_priority - 1'b1;\n                end\n\n                round_robin_index <= next_rr_index;\n            end\n        end\n    end\n\nendmodule"}, "patch": {"rtl/memory_scheduler.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/memory_scheduler.sv\nTOPLEVEL        = memory_scheduler\nMODULE          = test_memory_scheduler\nPYTHONPATH      = /src\nHASH            = 5-memory_scheduler_rtl_assertion_generation\n", "src/test_memory_scheduler.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import Timer, RisingEdge\n\n\ndef to_unsigned(binval, bits=32):\n    \"\"\"\n    Interpret the signal's current value as an unsigned integer\n    by parsing its binary string representation.\n    \"\"\"\n    strval = str(binval)\n    val = int(strval, 2) & ((1 << bits) - 1)\n    return val\n\n@cocotb.test()\nasync def memory_scheduler_test(dut):\n    \n    # 1) Generate a 10 ns clock on dut.clk\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # 2) Initial reset and signal setup\n    dut.reset.value     = 1\n    dut.request.value   = 0\n    dut.qos.value       = 0\n    dut.address0.value  = 0x1000\n    dut.address1.value  = 0x2000\n    dut.address2.value  = 0x3000\n    dut.address3.value  = 0x4000\n    dut.mem_ack.value   = 0\n\n    # Wait 20 ns before deasserting reset\n    await Timer(20, units=\"ns\")\n    dut.reset.value = 0\n\n    #\n    # ---------------- TEST 1 ----------------\n    #\n    cocotb.log.info(\"\\nTEST 1: Single request(0) with QOS=3\")\n    # request=4'b0001, QOS=8'h03 => request0=3, others=0\n    dut.request.value = 0x1\n    dut.qos.value     = 0x03\n\n    # Wait 40 ns\n    await Timer(40, units=\"ns\")\n\n    # Check outputs before mem_ack\n    mem_cmd_valid_u = to_unsigned(dut.mem_cmd_valid.value, 1)\n    mem_address_u   = to_unsigned(dut.mem_address.value, 32)\n    grant_u         = to_unsigned(dut.grant.value, 4)\n    cocotb.log.info(\n        f\"[Before mem_ack in TEST 1] mem_cmd_valid={mem_cmd_valid_u} \"\n        f\"mem_address=0x{mem_address_u:08X} grant=0b{grant_u:04b}\"\n    )\n    # Assertions\n    assert mem_cmd_valid_u == 1, \"TEST 1 (before mem_ack): Expected mem_cmd_valid=1\"\n    assert mem_address_u   == 0x1000, \"TEST 1 (before mem_ack): Expected mem_address=0x1000\"\n    assert grant_u         == 0b0001, \"TEST 1 (before mem_ack): Expected grant=0001 (request0)\"\n\n    # Pulse mem_ack\n    dut.mem_ack.value = 1\n    await Timer(10, units=\"ns\")\n    dut.mem_ack.value = 0\n\n    # Wait 10 ns\n    await Timer(10, units=\"ns\")\n\n    # Check outputs at end of Test 1\n    mem_cmd_valid_u = to_unsigned(dut.mem_cmd_valid.value, 1)\n    mem_address_u   = to_unsigned(dut.mem_address.value, 32)\n    grant_u         = to_unsigned(dut.grant.value, 4)\n    cocotb.log.info(\n        f\"[End of TEST 1] mem_cmd_valid={mem_cmd_valid_u} \"\n        f\"mem_address=0x{mem_address_u:08X} grant=0b{grant_u:04b}\"\n    )\n    # Assertions\n    assert mem_cmd_valid_u == 1, \"TEST 1 (end): Expected mem_cmd_valid=1\"\n    assert mem_address_u   == 0x1000, \"TEST 1 (end): Expected mem_address=0x1000\"\n    assert grant_u         == 0b0001, \"TEST 1 (end): Expected grant=0001 (request0)\"\n\n    #\n    # ---------------- TEST 2 ----------------\n    #\n    cocotb.log.info(\"\\nTEST 2: All requests active, request3=QOS=3, etc.\")\n    # request=4'b1111 => all active\n    # qos=8'hE4 => request3=3, request2=2, request1=1, request0=0\n    dut.request.value = 0xF\n    dut.qos.value     = 0xE4\n\n    # Wait 40 ns\n    await Timer(40, units=\"ns\")\n\n    mem_cmd_valid_u = to_unsigned(dut.mem_cmd_valid.value, 1)\n    mem_address_u   = to_unsigned(dut.mem_address.value, 32)\n    grant_u         = to_unsigned(dut.grant.value, 4)\n    cocotb.log.info(\n        f\"[Before mem_ack in TEST 2] mem_cmd_valid={mem_cmd_valid_u} \"\n        f\"mem_address=0x{mem_address_u:08X} grant=0b{grant_u:04b}\"\n    )\n    # Based on your log, you expected request0 to remain granted here before ack\n    assert mem_cmd_valid_u == 1, \"TEST 2 (before ack): mem_cmd_valid\"\n    assert mem_address_u   in [0x1000, 0x2000, 0x3000, 0x4000], \"TEST 2 (before ack): valid address\"\n    # We won't strictly check which request is granted here, as it might carry over from Test 1.\n    # But let's do a minimal check:\n    assert grant_u != 0, \"TEST 2 (before ack): Some request must be granted\"\n\n    # Pulse mem_ack\n    dut.mem_ack.value = 1\n    await Timer(10, units=\"ns\")\n    dut.mem_ack.value = 0\n\n    # Wait 10 ns\n    await Timer(10, units=\"ns\")\n\n    mem_cmd_valid_u = to_unsigned(dut.mem_cmd_valid.value, 1)\n    mem_address_u   = to_unsigned(dut.mem_address.value, 32)\n    grant_u         = to_unsigned(dut.grant.value, 4)\n    cocotb.log.info(\n        f\"[End of TEST 2] mem_cmd_valid={mem_cmd_valid_u} \"\n        f\"mem_address=0x{mem_address_u:08X} grant=0b{grant_u:04b}\"\n    )\n    # According to your final log, you see request1=0b0010 at address=0x2000\n    assert mem_cmd_valid_u == 1,  \"TEST 2 (end): mem_cmd_valid should be 1\"\n    assert mem_address_u   == 0x2000, \"TEST 2 (end): expected mem_address=0x2000 for request1\"\n    assert grant_u         == 0b0010, \"TEST 2 (end): expected grant=0010 (request1)\"\n\n    #\n    # ---------------- TEST 3 ----------------\n    #\n    cocotb.log.info(\"\\nTEST 3: Round-robin fallback with two requests = QOS=0\")\n    # request=4'b0110 => request2 & request1\n    # qos=8'h00 => all zero => request0=0, request1=0, request2=0, request3=0\n    dut.request.value = 0x6\n    dut.qos.value     = 0x00\n\n    # Wait 40 ns\n    await Timer(40, units=\"ns\")\n\n    mem_cmd_valid_u = to_unsigned(dut.mem_cmd_valid.value, 1)\n    mem_address_u   = to_unsigned(dut.mem_address.value, 32)\n    grant_u         = to_unsigned(dut.grant.value, 4)\n    cocotb.log.info(\n        f\"[Before mem_ack in TEST 3] mem_cmd_valid={mem_cmd_valid_u} \"\n        f\"mem_address=0x{mem_address_u:08X} grant=0b{grant_u:04b}\"\n    )\n    # From your log: It's request1=0b0010 at address=0x2000\n    assert mem_cmd_valid_u == 1,   \"TEST 3 (before ack): mem_cmd_valid=1\"\n    assert mem_address_u   == 0x2000, \"TEST 3 (before ack): expected address=0x2000\"\n    assert grant_u         == 0b0010, \"TEST 3 (before ack): expected grant=0010 (request1)\"\n\n    # Pulse mem_ack\n    dut.mem_ack.value = 1\n    await Timer(10, units=\"ns\")\n    dut.mem_ack.value = 0\n\n    # Wait 10 ns\n    await Timer(10, units=\"ns\")\n\n    mem_cmd_valid_u = to_unsigned(dut.mem_cmd_valid.value, 1)\n    mem_address_u   = to_unsigned(dut.mem_address.value, 32)\n    grant_u         = to_unsigned(dut.grant.value, 4)\n    cocotb.log.info(\n        f\"[End of TEST 3] mem_cmd_valid={mem_cmd_valid_u} \"\n        f\"mem_address=0x{mem_address_u:08X} grant=0b{grant_u:04b}\"\n    )\n    # The final log shows request2=0100 at address=0x3000\n    assert mem_cmd_valid_u == 1,   \"TEST 3 (end): mem_cmd_valid=1\"\n    assert mem_address_u   == 0x3000, \"TEST 3 (end): expected address=0x3000 for request2\"\n    assert grant_u         == 0b0100, \"TEST 3 (end): expected grant=0100 (request2)\"\n\n    # Let the simulation run a bit more, then end\n    await Timer(100, units=\"ns\")\n    cocotb.log.info(\"[Simulation complete]\")\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}
{"id": "cvdp_agentic_multiplexer_0003", "categories": ["cid014", "easy"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a `multiplexer` module available in the `rtl` directory, and its specification is in the `docs` directory. Kindly modify the module by adding SystemVerilog assertions. The assertions should ensure that the multiplexer logic is accurately implemented for different `sel` values, the optional `bypass` path, and the optional default behavior.\n\n## **Assertion Details**\nThe assertions should verify the following conditions:\n- **Bypass Path:** Confirm that when the `bypass` signal is active, the output is driven by the first input.\n- **Selected Input:** Ensure the `sel` signal routes the correct input to the output if `bypass` is disabled.\n- **Default Behavior (if enabled):** Check that the default value is output if `sel` is out of range and `HAS_DEFAULT` is true.\n\n## **Expected Behavior**\nIf any of the assertions fail, they should generate an **error message** pointing to the incorrect behavior in the multiplexer logic.\n", "context": {"docs/multiplexer_specification.md": "# Multiplexer Specification Document\n\n## Introduction\n\nThe **Multiplexer** module is a configurable data selector that chooses one of the multiple input data lines based on a selection signal. It supports configurable data width, input count, optional registered output, and default output handling when an invalid selection is made.\n\n---\n\n## Functional Overview\n\nThe multiplexer operates based on the following conditions:\n\n1. **Selection Logic:**  \n   - The `sel` input selects one of the `NUM_INPUTS` input data lines.\n   - If `HAS_DEFAULT` is enabled and `sel` is out of range, the output is set to `DEFAULT_VALUE`.\n\n2. **Bypass Mode:**  \n   - If the `bypass` signal is active, the multiplexer forces `out` to always select `inp_array[0]`, regardless of the `sel` value.\n\n3. **Registering Output:**  \n   - If `REGISTER_OUTPUT` is enabled, the output data is registered using `clk` and `rst_n`.\n   - If `REGISTER_OUTPUT` is disabled, the output is purely combinational.\n\n---\n\n## Module Interface\n\nThe multiplexer module should be defined as follows:\n\n```verilog\nmodule multiplexer #( \n    parameter DATA_WIDTH = 8,\n    parameter NUM_INPUTS = 4,\n    parameter REGISTER_OUTPUT = 0,\n    parameter HAS_DEFAULT = 0,\n    parameter [DATA_WIDTH-1:0] DEFAULT_VALUE = {DATA_WIDTH{1'b0}}\n)(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [(DATA_WIDTH*NUM_INPUTS)-1:0] inp,\n    input  wire [$clog2(NUM_INPUTS)-1:0]       sel,\n    input  wire bypass,\n    output reg  [DATA_WIDTH-1:0] out\n);\n```\n\n### Port Description\n\n- **clk:** Clock signal (used when REGISTER_OUTPUT is enabled).\n- **rst_n:** Active-low asynchronous reset (used when REGISTER_OUTPUT is enabled).\n- **inp:** A flat input bus containing `NUM_INPUTS` data values, each `DATA_WIDTH` bits wide.\n- **sel:** Select signal used to choose one of the input data lines.\n- **bypass:** If active, forces the output to always be `inp_array[0]`.\n- **out:** Selected output data.\n\n---\n\n## Internal Architecture\n\nThe multiplexer consists of the following key components:\n\n1. **Input Data Array Construction:**  \n   - The flat `inp` vector is split into an internal array using `generate` blocks.\n\n2. **Selection Logic:**  \n   - If `HAS_DEFAULT` is enabled and `sel` is out of range, output `DEFAULT_VALUE` is used.\n   - Otherwise, the selected data input is assigned to the output.\n\n3. **Bypass Logic:**  \n   - If `bypass` is asserted, the multiplexer always selects `inp_array[0]`.\n\n4. **Output Registering (if enabled):**  \n   - If `REGISTER_OUTPUT` is set, the output is latched on the rising edge of `clk`.\n   - If `rst_n` is de-asserted, `out` resets to zero.\n\n---\n\n## Timing and Latency\n\nThe multiplexer is a combinational circuit when `REGISTER_OUTPUT` is disabled, providing zero-cycle latency. However, if `REGISTER_OUTPUT` is enabled, the output will be available after **one clock cycle** due to register delay.\n\n---\n\n## Configuration Options\n\n- **DATA_WIDTH**: Configurable width of the input data.\n- **NUM_INPUTS**: Number of selectable inputs.\n- **REGISTER_OUTPUT**: Enables synchronous output register.\n- **HAS_DEFAULT**: Provides a default value when selection is out of range.\n- **DEFAULT_VALUE**: Defines the default output when `HAS_DEFAULT` is enabled.\n\nThis flexible multiplexer module allows dynamic selection of input signals while offering configurable features for different system requirements.", "rtl/multiplexer.sv": "module multiplexer #(\n    parameter DATA_WIDTH = 8,\n    parameter NUM_INPUTS = 4,\n    parameter REGISTER_OUTPUT = 0,\n    parameter HAS_DEFAULT = 0,\n    parameter [DATA_WIDTH-1:0] DEFAULT_VALUE = {DATA_WIDTH{1'b0}}\n)(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [(DATA_WIDTH*NUM_INPUTS)-1:0] inp,\n    input  wire [$clog2(NUM_INPUTS)-1:0]       sel,\n    input  wire bypass,\n    output reg  [DATA_WIDTH-1:0] out\n);\n\nwire [DATA_WIDTH-1:0] inp_array [0:NUM_INPUTS-1];\ngenvar i;\ngenerate\n    for (i = 0; i < NUM_INPUTS; i = i + 1) begin : GEN_INP\n        assign inp_array[i] = inp[(i+1)*DATA_WIDTH-1 : i*DATA_WIDTH];\n    end\nendgenerate\n\nwire [DATA_WIDTH-1:0] sel_out =\n    (HAS_DEFAULT && sel >= NUM_INPUTS) ? DEFAULT_VALUE : inp_array[sel];\n\nwire [DATA_WIDTH-1:0] mux_out = bypass ? inp_array[0] : sel_out;\n\ngenerate\n    if (REGISTER_OUTPUT) begin\n        always @(posedge clk or negedge rst_n) begin\n            if (!rst_n) out <= {DATA_WIDTH{1'b0}};\n            else        out <= mux_out;\n        end\n    end else begin\n        always @* out = mux_out;\n    end\nendgenerate\n\nendmodule", "verif/multiplexer_tb.sv": "`timescale 1ns/1ps\n\nmodule tb_multiplexer;\n\n  reg clk;\n  reg rst_n;\n  reg [8*3-1:0] inp;\n  reg [1:0] sel;\n  reg bypass;\n  wire [7:0] out;\n  integer i, j;\n  reg [7:0] expected;\n\n  multiplexer #(\n      .DATA_WIDTH(8),\n      .NUM_INPUTS(3),\n      .REGISTER_OUTPUT(1),\n      .HAS_DEFAULT(1),\n      .DEFAULT_VALUE(8'h55)\n  ) dut (\n      .clk(clk),\n      .rst_n(rst_n),\n      .inp(inp),\n      .sel(sel),\n      .bypass(bypass),\n      .out(out)\n  );\n\n  always #5 clk = ~clk;\n\n  initial begin\n    clk = 0; rst_n = 0; inp = 0; sel = 0; bypass = 0;\n    repeat(2) @(posedge clk);\n    rst_n = 1;\n    repeat(2) @(posedge clk);\n    for (i = 0; i < 10; i = i + 1) begin\n      inp = {($random() & 8'hFF), ($random() & 8'hFF), ($random() & 8'hFF)};\n      for (j = 0; j < 4; j = j + 1) begin\n        sel = j[1:0];\n        bypass = 0;\n        #1;\n        if (sel < 3) expected = inp[sel*8 +: 8];\n        else         expected = 8'h55;\n        @(posedge clk);\n        @(posedge clk);\n        if (out !== expected)\n          $display(\"Time=%0t Sel=%0d Bypass=%0b Inp=%0h Expected=%0h Got=%0h\", $time, sel, bypass, inp, expected, out);\n        else\n          $display(\"Time=%0t PASSED Sel=%0d Bypass=%0b\", $time, sel, bypass);\n\n        bypass = 1;\n        #1;\n        expected = inp[0 +: 8];\n        @(posedge clk);\n        @(posedge clk);\n        if (out !== expected)\n          $display(\"Time=%0t Sel=%0d Bypass=%0b Inp=%0h Expected=%0h Got=%0h\", $time, sel, bypass, inp, expected, out);\n        else\n          $display(\"Time=%0t PASSED Sel=%0d Bypass=%0b\", $time, sel, bypass);\n      end\n    end\n    $finish;\n  end\n\nendmodule"}, "patch": {"rtl/multiplexer.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/multiplexer.sv\nTOPLEVEL        = multiplexer\nMODULE          = test_multiplexer\nPYTHONPATH      = /src\nHASH            = 3-rtl-assertion-for-multiplexer\n", "src/test_multiplexer.py": "import os\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n# Read environment variables on the Python side for consistency\nDATA_WIDTH      = int(os.getenv(\"DATA_WIDTH\", \"8\"))\nNUM_INPUTS      = int(os.getenv(\"NUM_INPUTS\", \"4\"))\nREGISTER_OUTPUT = int(os.getenv(\"REGISTER_OUTPUT\", \"0\"))\nHAS_DEFAULT     = int(os.getenv(\"HAS_DEFAULT\", \"0\"))\n# DEFAULT_VALUE can be read similarly if needed, but we'll skip parsing here.\n\nasync def reset_dut(dut):\n    dut.clk.value = 0\n    dut.rst_n.value = 0\n    dut.inp.value = 0\n    dut.sel.value = 0\n    dut.bypass.value = 0\n    await RisingEdge(dut.clk)\n    dut.rst_n.value = 1\n    # Wait a couple of cycles after de-asserting reset\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n@cocotb.test()\nasync def test_basic(dut):\n    \"\"\"Basic Sanity Test\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, \"ns\").start())\n    await reset_dut(dut)\n\n    # If NUM_INPUTS=4 => we have 32 bits for 'inp'\n    # Let's provide a known pattern, e.g., 0xDEADBEEF\n    # If fewer inputs, mask off the higher bits\n    max_bits = 8 * NUM_INPUTS\n    test_inp = 0xDEADBEEF & ((1 << max_bits) - 1)\n    dut.inp.value = test_inp\n\n    # sel=0, bypass=0 => out should become the lowest 8 bits\n    dut.sel.value = 0\n    dut.bypass.value = 0\n\n    # If there's a register on output, allow 2 cycles for stable output\n    cycles_to_stabilize = 2 if REGISTER_OUTPUT else 1\n    for _ in range(cycles_to_stabilize):\n        await RisingEdge(dut.clk)\n\n    expected = test_inp & 0xFF\n    observed = dut.out.value.integer\n    assert observed == expected, f\"test_basic sel=0 => expected 0x{expected:02X}, got 0x{observed:02X}\"\n\n    # Turn on bypass => always select inp_array[0] (lowest 8 bits)\n    dut.bypass.value = 1\n    for _ in range(cycles_to_stabilize):\n        await RisingEdge(dut.clk)\n\n    observed = dut.out.value.integer\n    assert observed == expected, f\"test_basic bypass=1 => expected 0x{expected:02X}, got 0x{observed:02X}\"\n\n@cocotb.test()\nasync def test_random(dut):\n    \"\"\"Random Input Test - restrict sel to valid 2-bit range\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, \"ns\").start())\n    await reset_dut(dut)\n\n    max_bits = 8 * NUM_INPUTS\n    cycles_to_stabilize = 2 if REGISTER_OUTPUT else 1\n\n    for _ in range(5):\n        rand_inp = random.getrandbits(max_bits)\n        # Since sel is 2 bits when NUM_INPUTS=4, only use sel=0..3\n        # If you'd like to cover out-of-range, widen 'sel' or skip that scenario.\n        rand_sel = random.randint(0, NUM_INPUTS - 1)\n        rand_bypass = random.randint(0, 1)\n\n        dut.inp.value = rand_inp\n        dut.sel.value = rand_sel\n        dut.bypass.value = rand_bypass\n\n        # Allow enough clock cycles for output to settle\n        for _ in range(cycles_to_stabilize):\n            await RisingEdge(dut.clk)\n\n        observed = dut.out.value.integer\n\n        if rand_bypass == 1:\n            expected = rand_inp & 0xFF\n        else:\n            # Valid range => extract the correct byte\n            shift_amt = rand_sel * 8\n            expected = (rand_inp >> shift_amt) & 0xFF\n\n        assert observed == expected, (\n            f\"[RANDOM] inp=0x{rand_inp:08X}, sel={rand_sel}, bypass={rand_bypass}, \"\n            f\"expected=0x{expected:02X}, got=0x{observed:02X}\"\n        )\n\n@cocotb.test()\nasync def test_edge_cases(dut):\n    \"\"\"Edge / Boundary Conditions\"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, \"ns\").start())\n    await reset_dut(dut)\n\n    max_bits = 8 * NUM_INPUTS\n    cycles_to_stabilize = 2 if REGISTER_OUTPUT else 1\n\n    # 1) Check highest valid sel => sel=NUM_INPUTS-1\n    pattern_inp = 0x12345678 & ((1 << max_bits) - 1)\n    dut.inp.value = pattern_inp\n    dut.sel.value = NUM_INPUTS - 1\n    dut.bypass.value = 0\n\n    for _ in range(cycles_to_stabilize):\n        await RisingEdge(dut.clk)\n\n    observed = dut.out.value.integer\n    shift_amt = (NUM_INPUTS - 1) * 8\n    expected = (pattern_inp >> shift_amt) & 0xFF\n    assert observed == expected, (\n        f\"[EDGE] sel={NUM_INPUTS-1}, expected=0x{expected:02X}, got=0x{observed:02X}\"\n    )\n\n    # 2) If you truly want to test out-of-range sel, either:\n    #    A) Widen 'sel' in the Verilog, or\n    #    B) skip it here. This code below is commented out to avoid overflow:\n    #\n    # dut.sel.value = NUM_INPUTS  # e.g., 4 => out of range for 2-bit\n    # for _ in range(cycles_to_stabilize):\n    #     await RisingEdge(dut.clk)\n    #\n    # observed = dut.out.value.integer\n    # if HAS_DEFAULT == 1:\n    #     # Suppose we expect 0x55 for default\n    #     expected = 0x55\n    #     assert observed == expected, f\"[EDGE] Out-of-range sel => default mismatch\"\n    # else:\n    #     # No default => can't check reliably\n    #     pass\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources   = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang     = os.getenv(\"TOPLEVEL_LANG\")\nsim               = os.getenv(\"SIM\", \"icarus\")\ntoplevel          = os.getenv(\"TOPLEVEL\")\nmodule            = os.getenv(\"MODULE\")\nwave              = os.getenv(\"WAVE\")\n\ndata_width       = int(os.getenv(\"DATA_WIDTH\", \"8\"))\nnum_inputs       = int(os.getenv(\"NUM_INPUTS\", \"4\"))\nregister_output  = int(os.getenv(\"REGISTER_OUTPUT\", \"0\"))\nhas_default      = int(os.getenv(\"HAS_DEFAULT\", \"0\"))\ndefault_value    = os.getenv(\"DEFAULT_VALUE\", \"8'h00\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    parameters = {\n        \"DATA_WIDTH\": data_width,\n        \"NUM_INPUTS\": num_inputs,\n        \"REGISTER_OUTPUT\": register_output,\n        \"HAS_DEFAULT\": has_default,\n        \"DEFAULT_VALUE\": default_value\n    }\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\",\n        parameters=parameters\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}
{"id": "cvdp_agentic_poly_interpolator_0007", "categories": ["cid014", "hard"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYour task is to modify the existing RTL design based on the provided specifications to improve Quality of Results (QoR) such as timing, area, or power efficiency. Ensure the modifications are verified against the provided testbench and meet the updated specifications.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Develop assertion properties to verify the sanity of the `poly_interpolator` module. The module is available in the `rtl` directory and its documentation is available in `docs` directory. Please use **SystemVerilog Assertions (SVA)** to verify correctness of internal control, functional behavior and state sequencing of the design.\n\n### Assertion Requirements\n\nPlease implement assertions covering the following properties:\n\n1. **Inready Behavior**  \n   When the FSM is in the `WAIT_INPUT` state and an input sample is valid (i.e. `in_valid` is high), the design must assert `in_ready` to signal that it is ready to accept a new sample.\n\n2. **FSM Transition: WAIT to PROCESS**  \n   When in the `WAIT_INPUT` state with `in_valid` asserted, the FSM must transition to the `PROCESS_PHASES` state in the next cycle.\n\n3. **FSM Transition: PROCESS to OUTPUT**  \n   In the `PROCESS_PHASES` state, if the polyphase filter indicates a valid result (`valid_filter` is high) and the phase counter equals `N-1`, the FSM must transition to `OUTPUT_STATE`.\n\n4. **FSM Transition: OUTPUT to WAIT**  \n   When in the `OUTPUT_STATE` and the output index equals `N` (i.e. all outputs have been released), the FSM must transition back to `WAIT_INPUT`.\n\n5. **Output Validity**  \n   In the `OUTPUT_STATE`, while `output_index` is less than `N`, the output valid signal (`out_valid`) must be asserted on next cycle.\n\n6. **Result Buffer Data Storage**  \n   In the `PROCESS_PHASES` state, when `valid_filter` is asserted, the filter result must be stored correctly in the `result_buffer` at the index indicated by the phase counter.\n\n7. **Shift Register Data Drives filter_val_in**  \n   In the `PROCESS_PHASES` state, if valid data is available from the shift register (i.e. `shift_data_val` is high) and `valid_filter` is not yet asserted, then `filter_val_in` must be driven high to trigger processing in the next cycle.\n\n\n### Expected Behavior\n\nIf any of the above conditions are violated, the assertion must fail and produce an informative error message that clearly identifies the failure scenario.\n\n### Notes\n\n- All assertions must use **SystemVerilog Assertions (SVA)** syntax.\n- The assertion properties must be placed in a separate module named `poly_interpolator_assertions` located in the `verif` directory.\n- These assertion properties must be **bound** to the `poly_interpolator` module using the SystemVerilog `bind` construct. In the bind file (which should act as the top-level module and be named `poly_interpolator_bind` in the `verif` directory), the `poly_interpolator` module must be instantiated as `poly_dut` and the assertions module should be instantiated as `inst_poly_assert`.\n- The properties can reference internal DUT signals directly for verification.\n", "context": {"rtl/adder_tree.sv": "module adder_tree #(\n  parameter NUM_INPUTS = 8,\n  parameter WIDTH = 32\n)\n(\n  input  logic                                     clk,\n  input  logic                                     arst_n,\n  input  logic                                     valid_in,\n  input  logic [WIDTH-1:0]                         data_in [NUM_INPUTS],\n  output logic [WIDTH+$clog2(NUM_INPUTS)-1:0]      sum_out,\n  output logic                                     valid_out\n);\n\n  // The number of pipeline stages required:\n  localparam NUM_STAGES = $clog2(NUM_INPUTS);\n\n  // Pipeline registers\n  logic [WIDTH+$clog2(NUM_INPUTS)-1:0] stage_reg [0:NUM_STAGES][0:NUM_INPUTS-1];\n  logic valid_stage [0:NUM_STAGES];\n\n  integer i, s;\n\n  // Stage 0: Register input data\n  always_ff @(posedge clk or negedge arst_n)\n  begin\n    if (!arst_n)\n    begin\n      for (i = 0; i < NUM_INPUTS; i = i + 1)\n        stage_reg[0][i] <= '0;\n      valid_stage[0] <= 1'b0;\n    end\n    else if (valid_in)\n    begin\n      for (i = 0; i < NUM_INPUTS; i = i + 1)\n        stage_reg[0][i] <= {{($clog2(NUM_INPUTS)){data_in[i][WIDTH-1]}}, data_in[i]};\n      valid_stage[0] <= 1'b1;\n    end \n    else\n    begin\n      valid_stage[0] <= 1'b0;\n    end\n  end\n\n  // Subsequent pipeline stages: each stage halves the number of values.\n  generate\n    for (genvar s = 1; s <= NUM_STAGES; s = s + 1)\n    begin : stage_pipeline\n      localparam int NUM_ELEMS = NUM_INPUTS >> s;\n      always_ff @(posedge clk or negedge arst_n)\n      begin\n        if (!arst_n)\n        begin\n          for (int j = 0; j < NUM_ELEMS; j = j + 1)\n            stage_reg[s][j] <= '0;\n          valid_stage[s] <= 1'b0;\n        end\n        else if (valid_stage[s-1])\n        begin\n          for (int j = 0; j < NUM_ELEMS; j = j + 1)\n            stage_reg[s][j] <= stage_reg[s-1][2*j] + stage_reg[s-1][2*j+1];\n          valid_stage[s] <= 1'b1;\n        end\n        else\n        begin\n          valid_stage[s] <= 1'b0;\n        end\n      end\n    end\n  endgenerate\n\n  assign sum_out  = stage_reg[NUM_STAGES][0];\n  assign valid_out = valid_stage[NUM_STAGES];\n\nendmodule", "rtl/coeff_ram.sv": "module coeff_ram #(\n  parameter NUM_COEFFS  = 32,\n  parameter DATA_WIDTH  = 16\n)\n(\n  input  logic                          clk,\n  input  logic [$clog2(NUM_COEFFS)-1:0] addr,\n  output logic [DATA_WIDTH-1:0]         data_out\n);\n\n  // Memory array for coefficients.\n  logic [DATA_WIDTH-1:0] mem [0:NUM_COEFFS-1];\n  integer i;\n\n  // Synchronous read.\n  always_ff @(posedge clk)\n  begin\n    data_out <= mem[addr];\n  end\n\nendmodule", "rtl/poly_filter.sv": "module poly_filter #(\n  parameter  N           = 4,   // Interpolation factor\n  parameter  TAPS        = 8,   // Taps per phase\n  parameter  COEFF_WIDTH = 16,  // Bit width of filter coefficients\n  parameter  DATA_WIDTH  = 16,  // Bit width of input data\n  localparam ACC_WIDTH   = DATA_WIDTH + COEFF_WIDTH + $clog2(TAPS)\n)\n(\n  input  logic                         clk,\n  input  logic                         arst_n,\n  // Sample history (shift register contents)\n  input  logic [DATA_WIDTH-1:0]        sample_buffer [0:TAPS-1],\n  input  logic                         valid_in,\n  // Phase selection for coefficient block\n  input  logic [$clog2(N)-1:0]         phase,\n  output logic [ACC_WIDTH-1:0]         filter_out,\n  output logic                         valid\n);\n\n  // --- Stage 0: Register the input sample buffer and phase ---\n  logic [DATA_WIDTH-1:0]  sample_reg [0:TAPS-1];\n  logic [$clog2(N)-1:0]   phase_reg;\n  logic                   valid_stage0;\n  integer i;\nalways_ff @(posedge clk or negedge arst_n)\nbegin\n    if (!arst_n)\n    begin\n      for (i = 0; i < TAPS; i = i + 1)\n        sample_reg[i] <= '0;\n      phase_reg    <= '0;\n      valid_stage0 <= 1'b0;\n    end\n    else\n    begin\n      if (valid_in)\n      begin\n        for (i = 0; i < TAPS; i = i + 1)\n          sample_reg[i] <= sample_buffer[i];\n        phase_reg    <= phase;\n        valid_stage0 <= 1'b1;\n      end\n      else\n      begin\n        valid_stage0 <= 1'b0;\n      end\n    end\n  end\n\n  // --- Stage 1: Coefficient Fetch ---\n  logic [COEFF_WIDTH-1:0] coeff [0:TAPS-1];\n  genvar j;\n  generate\n    for (j = 0; j < TAPS; j = j + 1)\n    begin : coeff_fetch\n      logic [$clog2(N*TAPS)-1:0] addr;\n      assign addr = phase_reg * TAPS + j;\n      coeff_ram #(\n        .NUM_COEFFS(N*TAPS),\n        .DATA_WIDTH(COEFF_WIDTH)\n      ) u_coeff_ram (\n        .clk     (clk),\n        .addr    (addr),\n        .data_out(coeff[j])\n      );\n    end\n  endgenerate\n\n  // Register a valid flag for stage 1\n  logic valid_stage1;\n  always_ff @(posedge clk or negedge arst_n)\n  begin\n    if (!arst_n)\n      valid_stage1 <= 1'b0;\n    else\n      valid_stage1 <= valid_stage0;\n  end\n\n  // --- Stage 2: Multiply registered samples with coefficients ---\n  logic [DATA_WIDTH+COEFF_WIDTH-1:0] products [TAPS];\n  integer k;\n  always_comb\n  begin\n    for (k = 0; k < TAPS; k = k + 1)\n    begin\n      products[k] = sample_reg[k] * coeff[k];\n    end\n  end\n\n  // --- Stage 3: Sum the products using the adder_tree ---\n  logic [ACC_WIDTH-1:0] sum_result;\n  logic                 valid_adder;\n  adder_tree #(\n    .NUM_INPUTS(TAPS),\n    .WIDTH(DATA_WIDTH+COEFF_WIDTH)\n  ) u_adder_tree (\n    .clk      (clk),\n    .arst_n   (arst_n),\n    .valid_in (valid_stage1),\n    .data_in  (products),\n    .sum_out  (sum_result),\n    .valid_out(valid_adder)\n  );\n\n  // --- Stage 4: Output Registration ---\n  always_ff @(posedge clk or negedge arst_n)\n  begin\n    if (!arst_n)\n    begin\n      filter_out <= '0;\n      valid      <= 1'b0;\n    end\n    else\n    begin\n      filter_out <= sum_result;\n      valid      <= valid_adder;\n    end\n  end\n\nendmodule", "rtl/poly_interpolator.sv": "module poly_interpolator #(\n  parameter  N           = 4,   // Interpolation factor\n  parameter  TAPS        = 8,   // Taps per phase\n  parameter  COEFF_WIDTH = 16,  // Coefficient bit width\n  parameter  DATA_WIDTH  = 16,  // Input data bit width\n  localparam ACC_WIDTH   = DATA_WIDTH + COEFF_WIDTH + $clog2(TAPS)\n)\n(\n  input  logic                  clk,\n  input  logic                  arst_n,\n  input  logic [DATA_WIDTH-1:0] in_sample,\n  input  logic                  in_valid,\n  output logic                  in_ready,\n  output logic [ACC_WIDTH-1:0]  out_sample,\n  output logic                  out_valid\n);\n  logic [ACC_WIDTH-1:0]   result_buffer [0:N-1];\n  logic [$clog2(N+1)-1:0] output_index;\n  logic [ACC_WIDTH-1:0]   filter_result;\n  logic [DATA_WIDTH-1:0]  shift_data [0:TAPS-1];\n  logic                   shift_data_val;\n  logic                   valid_filter;\n\n  typedef enum logic [1:0] {\n    WAIT_INPUT,\n    PROCESS_PHASES,\n    OUTPUT_STATE\n  } state_t;\n  state_t state, next_state;\n\n  // Phase counter\n  logic [$clog2(N)-1:0] phase_counter;\n  // Signal to drive poly_filter's valid input.\n  logic filter_val_in;\n  \n  // --- Instantiate Shift Register ---\n  shift_register #(\n    .TAPS       (TAPS),\n    .DATA_WIDTH (DATA_WIDTH)\n  ) u_shift_reg (\n    .clk         (clk),\n    .arst_n      (arst_n),\n    .load        (in_valid & in_ready),\n    .new_sample  (in_sample),\n    .data_out    (shift_data),\n    .data_out_val(shift_data_val)\n  );\n\n  // --- FSM for Polyphase Control ---\n  always_ff @(posedge clk or negedge arst_n)\n  begin\n    if (!arst_n)\n    begin\n      state         <= WAIT_INPUT;\n      phase_counter <= '0;\n      filter_val_in <= 1'b0;\n      output_index  <= 0;\n      in_ready      <= 1'b1;\n    end\n    else\n    begin\n      state <= next_state;\n      case (state)\n        WAIT_INPUT:\n        begin\n          if (in_valid & in_ready)\n          begin\n            phase_counter <= '0;\n            output_index  <= 0;\n          end\n        end\n        PROCESS_PHASES:\n        begin\n          in_ready <= 1'b0;\n          if (valid_filter)\n          begin\n            result_buffer[phase_counter] <= filter_result;\n            if (phase_counter == N-1)\n            begin\n              filter_val_in <= 1'b0;\n            end\n            else\n            begin\n              phase_counter <= phase_counter + 1;\n              filter_val_in <= 1'b1;\n            end\n          end\n          else\n          begin\n            filter_val_in <= shift_data_val;\n          end\n        end\n        OUTPUT_STATE:\n        begin\n            output_index <= output_index + 1;\n            if (output_index == N)\n              in_ready <= 1'b1;\n        end\n        default: filter_val_in <= 1'b0;\n      endcase\n    end\n  end\n\n  // --- Next State Logic ---\n  always_comb\n  begin\n    case (state)\n      WAIT_INPUT:\n      begin\n        if (in_valid)\n          next_state = PROCESS_PHASES;\n        else\n          next_state = WAIT_INPUT;\n      end\n      PROCESS_PHASES:\n      begin\n        if (valid_filter && (phase_counter == N-1))\n          next_state = OUTPUT_STATE;\n        else\n          next_state = PROCESS_PHASES;\n      end\n      OUTPUT_STATE :\n      begin\n        if (output_index == N)\n          next_state = WAIT_INPUT;\n        else\n          next_state = OUTPUT_STATE;\n      end\n      default: next_state = WAIT_INPUT;\n    endcase\n  end\n\n  // --- Instantiate Polyphase Filter ---\n\n  poly_filter #(\n    .N           (N),\n    .TAPS        (TAPS),\n    .COEFF_WIDTH (COEFF_WIDTH),\n    .DATA_WIDTH  (DATA_WIDTH)\n  ) u_poly_filter (\n    .clk           (clk),\n    .arst_n        (arst_n),\n    .sample_buffer (shift_data),\n    .valid_in      (filter_val_in),\n    .phase         (phase_counter),\n    .filter_out    (filter_result),\n    .valid         (valid_filter)\n  );\n\n  // --- Output Assignment ---\n  always_ff @(posedge clk or negedge arst_n) begin\n    if (!arst_n)\n    begin\n      out_sample <= '0;\n      out_valid  <= 1'b0;\n    end\n    else\n    begin\n      if (state == OUTPUT_STATE && output_index < N)\n      begin\n        out_sample <= result_buffer[output_index];\n        out_valid  <= 1'b1;\n      end\n      else\n      begin\n        out_valid  <= 1'b0;\n      end\n    end\n  end\n\nendmodule", "rtl/shift_register.sv": "module shift_register #(\n  parameter TAPS       = 8,\n  parameter DATA_WIDTH = 16\n)\n(\n  input  logic                  clk,\n  input  logic                  arst_n,\n  input  logic                  load,      // Assert to load a new sample\n  input  logic [DATA_WIDTH-1:0] new_sample,\n  output logic [DATA_WIDTH-1:0] data_out [0:TAPS-1],\n  output logic                  data_out_val  // New valid signal for data_out\n);\n\n  // Internal register array for storing the samples.\n  logic [DATA_WIDTH-1:0] reg_array [0:TAPS-1];\n  integer i;\n\n  always_ff @(posedge clk or negedge arst_n) begin\n    if (!arst_n)\n    begin\n      for (i = 0; i < TAPS; i = i + 1)\n        reg_array[i] <= '0;\n      data_out_val <= 1'b0;\n    end\n    else if (load)\n    begin\n      reg_array[0] <= new_sample;\n      for (i = TAPS-1; i > 0; i = i - 1)\n        reg_array[i] <= reg_array[i-1];\n      data_out_val <= 1'b1;\n    end\n    else\n    begin\n      data_out_val <= 1'b0;\n    end\n  end\n\n  // Continuous assignment of the register values to the output.\n  generate\n    for (genvar j = 0; j < TAPS; j = j + 1)\n    begin : assign_output\n      assign data_out[j] = reg_array[j];\n    end\n  endgenerate\n\nendmodule"}, "patch": {"verif/poly_interpolator_assertions.sv": "", "verif/poly_interpolator_bind.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    image: verification_image\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/adder_tree.sv /code/rtl/coeff_ram.sv /code/rtl/shift_register.sv /code/rtl/poly_filter.sv /code/rtl/poly_interpolator.sv /code/verif/poly_interpolator_assertions.sv /code/verif/poly_interpolator_bind.sv\nTOPLEVEL        = poly_interpolator_bind\nMODULE          = test_poly_interpolator\nPYTHONPATH      = /src\nHASH            = 7-rtl-assertions-for-polyphase-interpolation\nCOV_SELECTIONS  = p_wait_input_in_ready p_wait_to_process\nCOV_THRESHOLDS  = 100 100", "src/coverage.py": "from cocotb.runner import get_runner\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\", cov_selection:str = \"\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    extra_env: dict = {}\n    if cov_selection:\n        extra_env[\"SELECTION\"] = cov_selection\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\",\n                extra_env=extra_env)\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef coverage_report_clear():\n    report_file=\"/code/rundir/coverage.log\"\n    if os.path.isfile(report_file):\n        os.remove(report_file)\n\ndef coverage_report_check(cov_threshold:float = 100.0):\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    print(f'column: {column}')\n    for line in lines[2:]:\n        match = re.match(r'^(.*?)\\s+(\\d+\\.?\\d*% \\(\\d+/\\d+\\))\\s+(\\d+% \\(\\d+/\\d+/\\d+\\))', line.strip())\n        if match:\n            info = list(match.groups())\n            print(f'info: {info}')\n        else:\n            info = re.split(r'\\s{2,}', line.strip())\n            print(f\"no regular expression match, trying differently: {info}\")\n\n        inst = info[0].lstrip('|-')\n        print(f'inst: {inst}')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n    target_inst = None\n    for inst in metrics:\n        if inst == \" |--inst_poly_assert\":\n            target_inst = inst\n            break\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[target_inst][\"Assertion\"]) >= cov_threshold, f\"Didn't achieved the required coverage result (cov_threshold={cov_threshold}).\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def populate_coeff_ram(dut, coeff_list):\n    \"\"\"\n    Populate all coefficient RAMs in the poly_filter.\n    \"\"\"\n    await Timer(1, units='ns')\n    tap_count = int(dut.poly_dut.u_poly_filter.TAPS.value)   # Number of taps (TAPS)\n    phase_count = int(dut.poly_dut.u_poly_filter.N.value)      # Number of phases (N)\n    total_coeffs = tap_count * phase_count\n    dut._log.info(f\"Populating coefficient RAMs: tap_count = {tap_count}, phase_count = {phase_count}, total_coeffs = {total_coeffs}\")\n\n    assert len(coeff_list) == total_coeffs, (\n        f\"Coefficient list length {len(coeff_list)} does not match expected {total_coeffs}\"\n    )\n\n    for j in range(tap_count):\n        try:\n            coeff_ram_inst = dut.poly_dut.u_poly_filter.coeff_fetch[j].u_coeff_ram\n        except Exception as e:\n            dut._log.error(f\"Failed to get coeff_ram instance for tap {j}: {e}\")\n            continue\n\n        for p in range(phase_count):\n            addr = p * tap_count + j\n            coeff_value = coeff_list[addr]\n            try:\n                coeff_ram_inst.mem[addr].value = coeff_value\n                dut._log.info(f\"Set coefficient for tap {j}, phase {p} (addr {addr}) to {coeff_value}\")\n            except Exception as e:\n                dut._log.error(f\"Failed to set coefficient at tap {j}, phase {p} (addr {addr}): {e}\")\n    await Timer(1, units='ns')\n", "src/test_poly_interpolator.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ClockCycles, Timer\nimport harness_library as hrs_lb\nimport random\nimport time\nfrom cocotb.triggers import with_timeout\nimport cocotb.simulator\nimport os\n\n\ncocotb.simulator.dump_enabled = True\n\nWAIT_INPUT     = 0\nPROCESS_PHASES = 1\nOUTPUT_STATE   = 2\n\n@cocotb.test()\nasync def test_wait_input_in_ready(dut):\n\n    # Start a 5ns period clock.\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    \n    # Apply asynchronous reset.\n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n    dut.in_valid.value = 1\n    \n    # Wait one clock cycle\n    await RisingEdge(dut.clk)\n    \n    # Check that in_ready is asserted when in_valid is high in WAIT_INPUT.\n    if int(dut.in_ready.value) != 1:\n        raise AssertionError(\"Test failed: in_ready is not asserted in WAIT_INPUT state when in_valid is high.\")\n    else:\n        dut._log.info(\"Test passed: in_ready is correctly asserted when in_valid is high in WAIT_INPUT state.\")\n\n    dut.in_valid.value = 0\n\n@cocotb.test()\nasync def test_p_wait_to_process(dut):\n    \"\"\"\n    Test Property 2:\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    \n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n    \n    # With reset, expect WAIT_INPUT.\n    dut.in_valid.value = 1\n    await RisingEdge(dut.clk)\n    dut.in_valid.value = 0\n\n    # Check next_state.\n    next_state = int(dut.poly_dut.next_state.value)\n    if next_state != PROCESS_PHASES:\n        raise AssertionError(f\"Test 2 failed: next_state is {next_state} instead of PROCESS_PHASES ({PROCESS_PHASES}).\")\n    dut._log.info(\"Test 2 passed: FSM transitions from WAIT_INPUT to PROCESS_PHASES when in_valid is high.\")\n\n\n@cocotb.test()\nasync def test_p_process_to_output(dut):\n    \"\"\"\n    Test Property 3:\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    \n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n\n    dut.in_valid.value = 1\n    await RisingEdge(dut.clk)\n    dut.in_valid.value = 0\n\n    for _ in range(20):\n        await RisingEdge(dut.clk)\n        if int(dut.poly_dut.state.value) == PROCESS_PHASES and \\\n           int(dut.poly_dut.phase_counter.value) == (int(dut.poly_dut.N.value) - 1) and \\\n           int(dut.poly_dut.valid_filter.value) == 1:\n            break\n    else:\n        raise AssertionError(\"Test 3 failed: Did not reach PROCESS_PHASES with phase_counter == N-1 and valid_filter high.\")\n\n    next_state = int(dut.poly_dut.next_state.value)\n    if next_state != OUTPUT_STATE:\n        raise AssertionError(f\"Test 3 failed: next_state is {next_state} instead of OUTPUT_STATE ({OUTPUT_STATE}).\")\n    dut._log.info(\"Test 3 passed: FSM transitions from PROCESS_PHASES to OUTPUT_STATE as expected.\")\n\n\n@cocotb.test()\nasync def test_p_output_to_wait(dut):\n    \"\"\"\n    Test Property 4:\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    \n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n\n    dut.in_valid.value = 1\n    await RisingEdge(dut.clk)\n    dut.in_valid.value = 0\n\n    for _ in range(50):\n        await RisingEdge(dut.clk)\n        if int(dut.poly_dut.state.value) == OUTPUT_STATE and int(dut.poly_dut.output_index.value) == int(dut.poly_dut.N.value):\n            break\n    else:\n        raise AssertionError(\"Test 4 failed: Did not observe output_index==N in OUTPUT_STATE.\")\n\n    next_state = int(dut.poly_dut.next_state.value)\n    if next_state != WAIT_INPUT:\n        raise AssertionError(f\"Test 4 failed: next_state is {next_state} instead of WAIT_INPUT (0).\")\n    dut._log.info(\"Test 4 passed: FSM transitions from OUTPUT_STATE to WAIT_INPUT when output_index equals N.\")\n\n\n@cocotb.test()\nasync def test_p_out_valid_in_output(dut):\n    \"\"\"\n    Test Property 5:\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    \n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n    \n    # Drive a sample to get to OUTPUT_STATE.\n    dut.in_valid.value = 1\n    await RisingEdge(dut.clk)\n    dut.in_valid.value = 0\n\n    # Wait until FSM is in OUTPUT_STATE.\n    while int(dut.poly_dut.state.value) != OUTPUT_STATE:\n        await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk) \n    if int(dut.poly_dut.output_index.value) < int(dut.poly_dut.N.value):\n        if int(dut.poly_dut.out_valid.value) != 1:\n            raise AssertionError(\"Test 5 failed: out_valid is not asserted in OUTPUT_STATE when output_index < N.\")\n        dut._log.info(\"Test 5 passed: out_valid asserted in OUTPUT_STATE when output_index < N.\")\n    else:\n        dut._log.info(\"Test 5 skipped: output_index >= N; cannot test property.\")\n\n@cocotb.test()\nasync def test_p_store_filter_result(dut):\n    \"\"\"\n    Test Property 6:\n    \"\"\"\n    # Start clock.\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    \n    # Reset DUT.\n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n    \n    tap_count = int(dut.poly_dut.u_poly_filter.TAPS.value)\n    phase_count = int(dut.poly_dut.u_poly_filter.N.value)\n    coeff_list = [i + 1 for i in range(tap_count * phase_count)]\n    await hrs_lb.populate_coeff_ram(dut, coeff_list)\n    \n    # Drive an input sample with a known value.\n    dut.in_sample.value = 10\n    dut.in_valid.value = 1\n    # Wait until the design samples the input.\n    await RisingEdge(dut.clk)\n    dut.in_valid.value = 0\n\n    for _ in range(20):\n        await RisingEdge(dut.clk)\n        if int(dut.poly_dut.state.value) == 1 and int(dut.poly_dut.valid_filter.value) == 1:\n            break\n    else:\n        raise AssertionError(\"Test 6 failed: Did not observe PROCESS_PHASES with valid_filter high.\")\n\n    await RisingEdge(dut.clk)\n    current_phase = int(dut.poly_dut.phase_counter.value)\n    rb_value = int(dut.poly_dut.result_buffer[current_phase-1].value)\n    f_result = int(dut.poly_dut.filter_result.value)\n\n    if rb_value != f_result:\n        raise AssertionError(f\"Test 6 failed: result_buffer[{current_phase}] = {rb_value} does not equal filter_result = {f_result}.\")\n    dut._log.info(\"Test 6 passed: Filter result correctly stored in result_buffer during PROCESS_PHASES.\")\n\n\n@cocotb.test()\nasync def test_p_filter_val_on_shift_val(dut):\n    \"\"\"\n    Test Property 7\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    \n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n    \n    dut.in_valid.value = 1\n    await RisingEdge(dut.clk)\n    dut.in_valid.value = 0\n\n    while int(dut.poly_dut.state.value) != PROCESS_PHASES:\n         await RisingEdge(dut.clk)\n\n    if int(dut.poly_dut.shift_data_val.value) == 1 and int(dut.poly_dut.valid_filter.value) == 0:\n        await RisingEdge(dut.clk)\n        if int(dut.poly_dut.filter_val_in.value) != 1:\n            raise AssertionError(\"Test 7 failed: filter_val_in not asserted when shift_data_val is high and valid_filter is low in PROCESS_PHASES.\")\n        dut._log.info(\"Test 7 passed: filter_val_in correctly asserted under (!valid_filter && shift_data_val) in PROCESS_PHASES.\")\n    else:\n        dut._log.info(\"Test 7 skipped: Condition (!valid_filter && shift_data_val) not met; cannot test property.\")\n", "src/test_runner.py": "import os\nimport pytest\nimport coverage\nimport random\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\ncov_selections  = os.getenv(\"COV_SELECTIONS\", \"\").split()\ncov_thresholds  = [float(s) for s in os.getenv(\"COV_THRESHOLDS\", \"\").split()]\n\ndef call_runner(parameter={}, cov_selection:tuple[str, float] = None):\n    plusargs = {}\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.coverage_report_clear()\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=[],\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameter,\n            cov_selection=cov_selection[0] if cov_selection else \"\",\n        )\n        coverage.coverage_report(\"assertion\")\n        if cov_selection:\n            print(f'cov_selection[0]: {cov_selection[0]} cov_selection[1]: {cov_selection[1]}')\n            coverage.coverage_report_check(cov_selection[1])\n        else:\n            coverage.coverage_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"N\", [2])\n@pytest.mark.parametrize(\"TAPS\", [2])\n@pytest.mark.parametrize(\"COEFF_WIDTH\", [16])\n@pytest.mark.parametrize(\"DATA_WIDTH\", [16])\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(N, TAPS, COEFF_WIDTH, DATA_WIDTH, test):\n\n    if len(cov_selections) == 0:\n        # Run the simulation\n        print(\"Calling runner without arguments\")\n        call_runner(parameter={\"N\": N, \"TAPS\": TAPS, \"COEFF_WIDTH\": COEFF_WIDTH, \"DATA_WIDTH\": DATA_WIDTH})\n        return\n\n    print(\"Identified special coverage selections\")\n\n    assert len(cov_selections) == len(cov_thresholds), \"incompatible coverage selections and thresholds\"\n\n    for selection, threshold in zip(cov_selections, cov_thresholds):\n        print(f\"> Running selection: {selection}, for threshold: {threshold}\")\n        call_runner({\"N\": N, \"TAPS\": TAPS, \"COEFF_WIDTH\": COEFF_WIDTH, \"DATA_WIDTH\": DATA_WIDTH},(selection, threshold))\n\n"}}
{"id": "cvdp_agentic_poly_interpolator_0011", "categories": ["cid014", "hard"], "system_message": "  You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYour task is to modify the existing RTL design based on the provided specifications to improve Quality of Results (QoR) such as timing, area, or power efficiency. Ensure the modifications are verified against the provided testbench and meet the updated specifications.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "Develop assertion properties to verify the sanity of the `poly_filter` module. The module is available in the `rtl` directory and its documentation is available in `docs` directory. Please use **SystemVerilog Assertions (SVA)** to verify correctness of internal control, functional behavior and state sequencing of the design.\n\n### Assertion Requirements\n\nPlease implement assertions covering the following properties:\n\n1. **Invalid Registration**  \n   When `valid_in` is asserted, the entire `sample_buffer` must be registered into `sample_reg`, enabling `valid_stage0` in the next cycle.\n\n2. **Coefficient Fetch Address Consistency**\n   For tap 0, ensure the computed coefficient fetch address equals `**phase_reg * TAPS + 0**`.\n\n3. **Per-tap Multiplication Consistency**\n   When valid_stage1 is asserted, confirm that products[0] equals `sample_reg[0] * coeff[0]`.\n\n4. **Sum Result Latency Check**\n   Once valid_stage1 is asserted, `valid_adder` must be asserted exactly two clock cycles later.\n\n5. **Adder Tree Output Consistency**\n   Ensure that within three cycles after valid_stage1, filter_out equals `sum_result` while valid_adder is high.\n\n6. **Output Registration Reset Behavior**\n   On reset, confirm that `filter_out` is cleared and `valid` is deasserted.\n\n7. **Sum Result Stability Check**\n   Once `valid_adder` is asserted, the value of `sum_result` must remain stable (unchanged from the previous cycle).\n\n\n### Expected Behavior\n\nIf any of the above conditions are violated, the assertion must fail and produce an informative error message that clearly identifies the failure scenario.\n\n### Notes\n\n- All assertions must use **SystemVerilog Assertions (SVA)** syntax.\n- The assertion properties must be placed in a separate module named `poly_filter_assertions` located in the `verif` directory.\n- These assertion properties must be **bound** to the `poly_filter` module using the SystemVerilog `bind` construct. In the bind file (which should act as the top-level module and be named `poly_filter_bind.sv` in the `verif` directory), the `poly_filter` module must be instantiated as `poly_dut` and the assertions module should be instantiated as `inst_poly_filter_assert`.\n- The properties can reference internal DUT signals directly for verification.\n", "context": {"docs/poly_filter.md": "# Polyphase Filter Module\n\nThe `poly_filter` module performs the multiply-accumulate (MAC) operations required in a polyphase filter structure. It takes as inputs:\n- A **sample buffer** (from a shift register) containing the history of input samples.\n- A **phase selection** signal that determines which group of filter coefficients to use.\n- A **valid_in** flag indicating that new input data is available.\n\nThe module operates in four main stages:\n\n1. **Stage 0: Input Registration**  \n   The incoming sample buffer and the phase signal are registered into internal registers (`sample_reg` and `phase_reg`). A valid flag (`valid_stage0`) is generated when the input data is valid.\n\n2. **Stage 1: Coefficient Fetch**  \n   For each tap, a coefficient is fetched from an instance of the **coeff_ram** module.\n\n3. **Stage 2: Multiplication**  \n   Each registered sample is multiplied by its corresponding coefficient to produce a set of products.\n\n4. **Stage 3: Summation**  \n   The products are summed using a pipelined **adder_tree** module. The output of the adder tree is a single sum representing the filtered result.\n\n5. **Stage 4: Output Registration**  \n   The final sum is registered and output along with a valid flag, indicating that the filter output is ready.\n\n---\n\n## Interface Table\n\n| Signal Name     | Direction | Width                                                 | Description                                                         |\n|-----------------|-----------|-------------------------------------------------------|---------------------------------------------------------------------|\n| `clk`           | Input     | 1                                                     | Clock signal                                                        |\n| `arst_n`        | Input     | 1                                                     | Active-low asynchronous reset                                       |\n| `sample_buffer` | Input     | Array of `TAPS` elements, each `DATA_WIDTH` bits wide | Input sample history, from a shift register                         |\n| `valid_in`      | Input     | 1                                                     | Valid flag for the sample_buffer.                                   |\n| `phase`         | Input     | `$clog2(N)` bits                                      | Phase selection signal used to choose the correct coefficient group |\n| `filter_out`    | Output    | `ACC_WIDTH`                                           | Final filter output                                                 |\n| `valid`         | Output    | 1                                                     | Valid flag indicating that the output on `filter_out`               |\n\n\n---\n\n## Submodule Integration\n\n### Coefficient RAM (coeff_ram)\n\n- **Purpose:**  \n  The **coeff_ram** module stores filter coefficients. In the poly_filter, a generate block named `coeff_fetch` instantiates one `coeff_ram` instance per tap.\n  \n- **Operation:**  \n  For each tap (index `j`), the coefficient RAM is accessed with an address computed as:\n  ```\n  addr = phase_reg * TAPS + j\n  ```\n  This fetches the coefficient corresponding to the current phase and tap.\n  \n- **Integration:**  \n  The output of each coefficient RAM instance is assigned to an array (`coeff[j]`), which is later used in the multiplication stage.\n\n### Adder Tree (adder_tree)\n\n- **Purpose:**  \n  The **adder_tree** module sums an array of products obtained from multiplying the registered samples and the fetched coefficients.\n  \n- **Operation:**  \n  The multiplication results are stored in the `products` array. The adder_tree uses a pipelined structure where the number of values is halved at each stage until a single summed value is produced.\n  \n- **Integration:**  \n  The adder_tree is instantiated with the parameters:\n  - `NUM_INPUTS = TAPS`\n  - `DATA_WIDTH = DATA_WIDTH + COEFF_WIDTH`\n  \n  Its output is assigned to the final filter result (`sum_result`), and a valid flag (`valid_adder`) indicates when the summed result is valid.\n\n---\n\n## Detailed Operation Flow\n\n1. **Stage 0 \u2013 Input Registration:**  \n   - Registers each element of `sample_buffer` into `sample_reg`.\n   - Registers the `phase` signal into `phase_reg`.\n   - Generates `valid_stage0` if `valid_in` is high.\n\n2. **Stage 1 \u2013 Coefficient Fetch:**  \n   - For each tap `j`, calculates the coefficient address: `addr = phase_reg * TAPS + j`.\n   - Instantiates `coeff_ram` to retrieve the coefficient at the computed address.\n   - Outputs are stored in the `coeff` array.\n\n3. **Stage 2 \u2013 Multiplication:**  \n   - For each tap `j`, multiplies `sample_reg[j]` with `coeff[j]` to obtain `products[j]`.\n\n4. **Stage 3 \u2013 Summation via Adder Tree:**  \n   - The `products` array is input to the adder_tree module.\n   - The adder_tree computes the sum of all products.\n   - The final sum is available at `sum_result` and is accompanied by a valid signal (`valid_adder`).\n\n5. **Stage 4 \u2013 Output Registration:**  \n   - The `sum_result` is registered and assigned to `filter_out`.\n   - The output valid flag `valid` is set based on `valid_adder`.", "rtl/adder_tree.sv": "module adder_tree #(\n  parameter NUM_INPUTS = 8,\n  parameter WIDTH = 32\n)\n(\n  input  logic                                     clk,\n  input  logic                                     arst_n,\n  input  logic                                     valid_in,\n  input  logic [WIDTH-1:0]                         data_in [NUM_INPUTS],\n  output logic [WIDTH+$clog2(NUM_INPUTS)-1:0]      sum_out,\n  output logic                                     valid_out\n);\n\n  // The number of pipeline stages required:\n  localparam NUM_STAGES = $clog2(NUM_INPUTS);\n\n  // Pipeline registers\n  logic [WIDTH+$clog2(NUM_INPUTS)-1:0] stage_reg [0:NUM_STAGES][0:NUM_INPUTS-1];\n  logic valid_stage [0:NUM_STAGES];\n\n  integer i, s;\n\n  // Stage 0: Register input data\n  always_ff @(posedge clk or negedge arst_n)\n  begin\n    if (!arst_n)\n    begin\n      for (i = 0; i < NUM_INPUTS; i = i + 1)\n        stage_reg[0][i] <= '0;\n      valid_stage[0] <= 1'b0;\n    end\n    else if (valid_in)\n    begin\n      for (i = 0; i < NUM_INPUTS; i = i + 1)\n        stage_reg[0][i] <= {{($clog2(NUM_INPUTS)){data_in[i][WIDTH-1]}}, data_in[i]};\n      valid_stage[0] <= 1'b1;\n    end \n    else\n    begin\n      valid_stage[0] <= 1'b0;\n    end\n  end\n\n  // Subsequent pipeline stages: each stage halves the number of values.\n  generate\n    for (genvar s = 1; s <= NUM_STAGES; s = s + 1)\n    begin : stage_pipeline\n      localparam int NUM_ELEMS = NUM_INPUTS >> s;\n      always_ff @(posedge clk or negedge arst_n)\n      begin\n        if (!arst_n)\n        begin\n          for (int j = 0; j < NUM_ELEMS; j = j + 1)\n            stage_reg[s][j] <= '0;\n          valid_stage[s] <= 1'b0;\n        end\n        else if (valid_stage[s-1])\n        begin\n          for (int j = 0; j < NUM_ELEMS; j = j + 1)\n            stage_reg[s][j] <= stage_reg[s-1][2*j] + stage_reg[s-1][2*j+1];\n          valid_stage[s] <= 1'b1;\n        end\n        else\n        begin\n          valid_stage[s] <= 1'b0;\n        end\n      end\n    end\n  endgenerate\n\n  assign sum_out  = stage_reg[NUM_STAGES][0];\n  assign valid_out = valid_stage[NUM_STAGES];\n\nendmodule", "rtl/coeff_ram.sv": "module coeff_ram #(\n  parameter NUM_COEFFS  = 32,\n  parameter DATA_WIDTH  = 16\n)\n(\n  input  logic                          clk,\n  input  logic [$clog2(NUM_COEFFS)-1:0] addr,\n  output logic [DATA_WIDTH-1:0]         data_out\n);\n\n  // Memory array for coefficients.\n  logic [DATA_WIDTH-1:0] mem [0:NUM_COEFFS-1];\n  integer i;\n\n  // Synchronous read.\n  always_ff @(posedge clk)\n  begin\n    data_out <= mem[addr];\n  end\n\nendmodule", "rtl/poly_filter.sv": "module poly_filter #(\n  parameter  N           = 4,   // Interpolation factor\n  parameter  TAPS        = 8,   // Taps per phase\n  parameter  COEFF_WIDTH = 16,  // Bit width of filter coefficients\n  parameter  DATA_WIDTH  = 16,  // Bit width of input data\n  localparam ACC_WIDTH   = DATA_WIDTH + COEFF_WIDTH + $clog2(TAPS)\n)\n(\n  input  logic                         clk,\n  input  logic                         arst_n,\n  // Sample history (shift register contents)\n  input  logic [DATA_WIDTH-1:0]        sample_buffer [0:TAPS-1],\n  input  logic                         valid_in,\n  // Phase selection for coefficient block\n  input  logic [$clog2(N)-1:0]         phase,\n  output logic [ACC_WIDTH-1:0]         filter_out,\n  output logic                         valid\n);\n\n  // --- Stage 0: Register the input sample buffer and phase ---\n  logic [DATA_WIDTH-1:0]  sample_reg [0:TAPS-1];\n  logic [$clog2(N)-1:0]   phase_reg;\n  logic                   valid_stage0;\n  integer i;\nalways_ff @(posedge clk or negedge arst_n)\nbegin\n    if (!arst_n)\n    begin\n      for (i = 0; i < TAPS; i = i + 1)\n        sample_reg[i] <= '0;\n      phase_reg    <= '0;\n      valid_stage0 <= 1'b0;\n    end\n    else\n    begin\n      if (valid_in)\n      begin\n        for (i = 0; i < TAPS; i = i + 1)\n          sample_reg[i] <= sample_buffer[i];\n        phase_reg    <= phase;\n        valid_stage0 <= 1'b1;\n      end\n      else\n      begin\n        valid_stage0 <= 1'b0;\n      end\n    end\n  end\n\n  // --- Stage 1: Coefficient Fetch ---\n  logic [COEFF_WIDTH-1:0] coeff [0:TAPS-1];\n  genvar j;\n  generate\n    for (j = 0; j < TAPS; j = j + 1)\n    begin : coeff_fetch\n      logic [$clog2(N*TAPS)-1:0] addr;\n      assign addr = phase_reg * TAPS + j;\n      coeff_ram #(\n        .NUM_COEFFS(N*TAPS),\n        .DATA_WIDTH(COEFF_WIDTH)\n      ) u_coeff_ram (\n        .clk     (clk),\n        .addr    (addr),\n        .data_out(coeff[j])\n      );\n    end\n  endgenerate\n\n  // Register a valid flag for stage 1\n  logic valid_stage1;\n  always_ff @(posedge clk or negedge arst_n)\n  begin\n    if (!arst_n)\n      valid_stage1 <= 1'b0;\n    else\n      valid_stage1 <= valid_stage0;\n  end\n\n  // --- Stage 2: Multiply registered samples with coefficients ---\n  logic [DATA_WIDTH+COEFF_WIDTH-1:0] products [TAPS];\n  integer k;\n  always_comb\n  begin\n    for (k = 0; k < TAPS; k = k + 1)\n    begin\n      products[k] = sample_reg[k] * coeff[k];\n    end\n  end\n\n  // --- Stage 3: Sum the products using the adder_tree ---\n  logic [ACC_WIDTH-1:0] sum_result;\n  logic                 valid_adder;\n  adder_tree #(\n    .NUM_INPUTS(TAPS),\n    .WIDTH(DATA_WIDTH+COEFF_WIDTH)\n  ) u_adder_tree (\n    .clk      (clk),\n    .arst_n   (arst_n),\n    .valid_in (valid_stage1),\n    .data_in  (products),\n    .sum_out  (sum_result),\n    .valid_out(valid_adder)\n  );\n\n  // --- Stage 4: Output Registration ---\n  always_ff @(posedge clk or negedge arst_n)\n  begin\n    if (!arst_n)\n    begin\n      filter_out <= '0;\n      valid      <= 1'b0;\n    end\n    else\n    begin\n      filter_out <= sum_result;\n      valid      <= valid_adder;\n    end\n  end\n\nendmodule", "rtl/shift_register.sv": "module shift_register #(\n  parameter TAPS       = 8,\n  parameter DATA_WIDTH = 16\n)\n(\n  input  logic                  clk,\n  input  logic                  arst_n,\n  input  logic                  load,      // Assert to load a new sample\n  input  logic [DATA_WIDTH-1:0] new_sample,\n  output logic [DATA_WIDTH-1:0] data_out [0:TAPS-1],\n  output logic                  data_out_val  // New valid signal for data_out\n);\n\n  // Internal register array for storing the samples.\n  logic [DATA_WIDTH-1:0] reg_array [0:TAPS-1];\n  integer i;\n\n  always_ff @(posedge clk or negedge arst_n) begin\n    if (!arst_n)\n    begin\n      for (i = 0; i < TAPS; i = i + 1)\n        reg_array[i] <= '0;\n      data_out_val <= 1'b0;\n    end\n    else if (load)\n    begin\n      reg_array[0] <= new_sample;\n      for (i = TAPS-1; i > 0; i = i - 1)\n        reg_array[i] <= reg_array[i-1];\n      data_out_val <= 1'b1;\n    end\n    else\n    begin\n      data_out_val <= 1'b0;\n    end\n  end\n\n  // Continuous assignment of the register values to the output.\n  generate\n    for (genvar j = 0; j < TAPS; j = j + 1)\n    begin : assign_output\n      assign data_out[j] = reg_array[j];\n    end\n  endgenerate\n\nendmodule"}, "patch": {"verif/poly_filter_assertions.sv": "", "verif/poly_filter_bind.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    image: verification_image\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/adder_tree.sv /code/rtl/coeff_ram.sv /code/rtl/shift_register.sv /code/rtl/poly_filter.sv /code/verif/poly_filter_assertions.sv /code/verif/poly_filter_bind.sv\nTOPLEVEL        = poly_filter_bind\nMODULE          = test_poly_filter\nPYTHONPATH      = /src\nHASH            = 11-rtl-assertions-for-polyphase-filtering\nCOV_SELECTIONS  = p_reg_input_valid p_coeff_fetch_addr0\nCOV_THRESHOLDS  = 100 100", "src/coverage.py": "from cocotb.runner import get_runner\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\", cov_selection:str = \"\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n\n    extra_env: dict = {}\n    if cov_selection:\n        extra_env[\"SELECTION\"] = cov_selection\n\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\",\n                extra_env=extra_env)\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef coverage_report_clear():\n    report_file=\"/code/rundir/coverage.log\"\n    if os.path.isfile(report_file):\n        os.remove(report_file)\n\ndef coverage_report_check(cov_threshold:float = 100.0):\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    print(f'column: {column}')\n    for line in lines[2:]:\n        match = re.match(r'^(.*?)\\s+(\\d+\\.?\\d*% \\(\\d+/\\d+\\))\\s+(\\d+% \\(\\d+/\\d+/\\d+\\))', line.strip())\n        if match:\n            info = list(match.groups())\n            print(f'info: {info}')\n        else:\n            info = re.split(r'\\s{2,}', line.strip())\n            print(f\"no regular expression match, trying differently: {info}\")\n\n        inst = info[0].lstrip('|-')\n        print(f'inst: {inst}')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n    target_inst = None\n    for inst in metrics:\n        if inst == \" |--inst_poly_filter_assert\":\n            target_inst = inst\n            break\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[target_inst][\"Assertion\"]) >= cov_threshold, f\"Didn't achieved the required coverage result (cov_threshold={cov_threshold}).\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "import cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def populate_coeff_ram(dut, coeff_list):\n    \"\"\"\n    Populate all coefficient RAMs in the poly_filter.\n    \"\"\"\n    await Timer(1, units='ns')\n    tap_count = int(dut.poly_dut.TAPS.value)   # Number of taps (TAPS)\n    phase_count = int(dut.poly_dut.N.value)      # Number of phases (N)\n    total_coeffs = tap_count * phase_count\n    dut._log.info(f\"Populating coefficient RAMs: tap_count = {tap_count}, phase_count = {phase_count}, total_coeffs = {total_coeffs}\")\n\n    assert len(coeff_list) == total_coeffs, (\n        f\"Coefficient list length {len(coeff_list)} does not match expected {total_coeffs}\"\n    )\n\n    for j in range(tap_count):\n        try:\n            coeff_ram_inst = dut.poly_dut.coeff_fetch[j].u_coeff_ram\n        except Exception as e:\n            dut._log.error(f\"Failed to get coeff_ram instance for tap {j}: {e}\")\n            continue\n\n        for p in range(phase_count):\n            addr = p * tap_count + j\n            coeff_value = coeff_list[addr]\n            try:\n                coeff_ram_inst.mem[addr].value = coeff_value\n                dut._log.info(f\"Set coefficient for tap {j}, phase {p} (addr {addr}) to {coeff_value}\")\n            except Exception as e:\n                dut._log.error(f\"Failed to set coefficient at tap {j}, phase {p} (addr {addr}): {e}\")\n    await Timer(1, units='ns')\n", "src/test_poly_filter.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ClockCycles, Timer\nimport harness_library as hrs_lb\nimport random\nimport time\nfrom cocotb.triggers import with_timeout\nimport cocotb.simulator\nimport os\n\n\ncocotb.simulator.dump_enabled = True\n\n@cocotb.test()\nasync def test_reg_input_valid(dut):\n    \"\"\"\n    Test to verify the property p_reg_input_buffer\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.dut_init(dut)\n    \n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n    \n    #Drive valid_in high for one cycle.\n    await RisingEdge(dut.clk)\n    dut.valid_in.value = 1\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    if int(dut.poly_dut.valid_stage0.value) != 1:\n        raise AssertionError(\"Test failed: valid_stage0 not asserted on the cycle following valid_in high.\")\n    else:\n        dut._log.info(\"Test passed: valid_stage0 asserted as expected after valid_in high.\")\n\n@cocotb.test()\nasync def test_coeff_fetch_addr0(dut):\n    \"\"\"\n    Test the computed coefficient address for tap 0\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.dut_init(dut)\n\n    # Reset DUT.\n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n\n    await RisingEdge(dut.clk)\n    dut.valid_in.value = 1\n    await RisingEdge(dut.clk)\n    dut.valid_in.value = 0\n    for _ in range(10):\n        await RisingEdge(dut.clk)\n        if int(dut.poly_dut.valid_stage0.value) == 1:\n            break\n    else:\n        raise AssertionError(\"Test 2 failed: valid_stage0 never asserted.\")\n    \n    # Read phase_reg and computed address for tap 0.\n    phase_reg = int(dut.poly_dut.phase_reg.value)\n    TAPS = int(dut.TAPS.value)\n    expected_addr0 = phase_reg * TAPS + 0\n\n    computed_addr0 = int(dut.poly_dut.coeff_fetch[0].addr.value)\n\n    if computed_addr0 != expected_addr0:\n        raise AssertionError(f\"Test 2 failed: Tap 0 address = {computed_addr0}, expected {expected_addr0}.\")\n    dut._log.info(\"Test 2 passed: Tap 0 coefficient address is correct.\")\n\n@cocotb.test()\nasync def test_multiply_consistency0(dut):\n    \"\"\"\n    Test that once valid_stage1 is asserted, the multiplication for tap 0 is correct.\n    \"\"\"\n    # Start a clock with a period of 10 ns.\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.dut_init(dut)\n\n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n\n    tap_count   = int(dut.poly_dut.TAPS.value)\n    phase_count = int(dut.poly_dut.N.value)\n    total_coeffs = tap_count * phase_count\n    coeff_list = [2 for _ in range(total_coeffs)]\n    await hrs_lb.populate_coeff_ram(dut, coeff_list)\n\n    # Drive the sample_buffer with known values.\n    for i in range(tap_count):\n        dut.poly_dut.sample_buffer[i].value = (i + 1) * 10\n    dut.poly_dut.valid_in.value = 1\n    await RisingEdge(dut.clk)\n    dut.poly_dut.valid_in.value = 0\n\n    # Wait until valid_stage1 is asserted.\n    for _ in range(10):\n        await RisingEdge(dut.clk)\n        if int(dut.poly_dut.valid_stage1.value) == 1:\n            break\n    else:\n        raise AssertionError(\"Test failed: valid_stage1 not asserted after driving sample_buffer and valid_in.\")\n\n    # Now compare the computed product for tap 0.\n    sample0 = int(dut.poly_dut.sample_reg[0].value)\n    coeff0  = int(dut.poly_dut.coeff[0].value)\n    expected_product0 = sample0 * coeff0\n    computed_product0 = int(dut.poly_dut.products[0].value)\n    \n    if computed_product0 != expected_product0:\n        raise AssertionError(f\"Test failed: products[0]={computed_product0}, expected {expected_product0}.\")\n    else:\n        dut._log.info(\"Test passed: Multiplication result for tap 0 is correct.\")\n\n@cocotb.test()\nasync def test_sum_latency(dut):\n    \"\"\"\n    Test that when valid_stage1 is asserted, the adder tree produces a valid_adder exactly one cycle later.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.dut_init(dut)\n\n    # Reset DUT.\n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n    \n    # Drive valid_in to trigger the pipeline.\n    dut.valid_in.value = 1\n    await RisingEdge(dut.clk)\n    dut.valid_in.value = 0\n\n    # Wait until valid_stage1 is high.\n    for _ in range(10):\n        await RisingEdge(dut.clk)\n        if int(dut.poly_dut.valid_stage1.value) == 1:\n            break\n    else:\n        raise AssertionError(\"Test failed: valid_stage1 not asserted.\")\n    \n    # Capture the cycle when valid_stage1 is true.\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    if int(dut.poly_dut.valid_adder.value) != 1:\n        raise AssertionError(\"Test failed: valid_adder was not asserted one cycle after valid_stage1.\")\n    dut._log.info(\"Test passed: valid_adder asserted one cycle after valid_stage1.\")\n\n@cocotb.test()\nasync def test_adder_tree_output(dut):\n    \"\"\"\n    Test Property: Adder Tree Output Consistency\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.dut_init(dut)\n\n    # Reset DUT.\n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n\n    # Populate coefficient RAM.\n    tap_count   = int(dut.poly_dut.TAPS.value)\n    phase_count = int(dut.poly_dut.N.value)\n    total_coeffs = tap_count * phase_count\n    coeff_list = [1 for _ in range(total_coeffs)]\n    await hrs_lb.populate_coeff_ram(dut, coeff_list)\n\n    # Drive the sample_buffer with known values.\n    for i in range(tap_count):\n        dut.poly_dut.sample_buffer[i].value = (i + 1) * 10\n    dut.poly_dut.valid_in.value = 1\n    await RisingEdge(dut.clk)\n    dut.poly_dut.valid_in.value = 0\n\n    # Wait until the multiplication stage (valid_stage1) is asserted.\n    for _ in range(10):\n        await RisingEdge(dut.clk)\n        if int(dut.poly_dut.valid_stage1.value) == 1:\n            break\n    else:\n        raise AssertionError(\"Test failed: valid_stage1 not asserted after driving sample_buffer and valid_in.\")\n    \n    # Wait 2 more cycle for the adder tree to produce its output.\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    if int(dut.poly_dut.valid_adder.value) != 1:\n        raise AssertionError(\"Test failed: valid_adder not asserted one cycle after valid_stage1.\")\n    await RisingEdge(dut.clk)\n    if int(dut.poly_dut.filter_out.value) != int(dut.poly_dut.sum_result.value):\n        raise AssertionError(\"Test failed: filter_out does not equal sum_result after valid_adder assertion.\")\n    \n    dut._log.info(\"Test passed: Adder tree output consistency verified (valid_adder asserted and filter_out equals sum_result).\")\n\n@cocotb.test()\nasync def test_output_reset(dut):\n    \"\"\"\n    Test that after asserting reset, the filter_out signal is '0' and valid is 0.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.dut_init(dut)\n\n    # Apply reset.\n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    # Check immediately after reset is asserted.\n    await RisingEdge(dut.clk)\n    if int(dut.filter_out.value) != 0 or int(dut.valid.value) != 0:\n        raise AssertionError(\"Test failed: filter_out or valid not cleared during reset.\")\n    dut._log.info(\"Test passed: filter_out and valid are cleared upon reset.\")\n\n@cocotb.test()\nasync def test_sum_stability(dut):\n    \"\"\"\n    Test that when valid_adder is asserted, the sum_result signal remains stable \n    \"\"\"\n    # Start clock with a 10 ns period.\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    \n    # Initialize DUT.\n    await hrs_lb.dut_init(dut)\n    \n    dut.arst_n.value = 0\n    await Timer(50, units=\"ns\")\n    dut.arst_n.value = 1\n    await RisingEdge(dut.clk)\n    \n    tap_count   = int(dut.poly_dut.TAPS.value)\n    phase_count = int(dut.poly_dut.N.value)\n    total_coeffs = tap_count * phase_count\n    coeff_list = [1 for _ in range(total_coeffs)]\n    await hrs_lb.populate_coeff_ram(dut, coeff_list)\n    \n    # Drive the sample_buffer with known values.\n    for i in range(tap_count):\n        dut.poly_dut.sample_buffer[i].value = (i + 1) * 10\n    \n    dut.poly_dut.valid_in.value = 1\n    await RisingEdge(dut.clk)\n    dut.poly_dut.valid_in.value = 0\n\n    for _ in range(10):\n        await RisingEdge(dut.clk)\n        if int(dut.poly_dut.valid_adder.value) == 1:\n            break\n    else:\n        raise AssertionError(\"Test failed: valid_adder not asserted after driving sample_buffer and valid_in.\")\n    \n    current_sum = int(dut.poly_dut.sum_result.value)\n    await RisingEdge(dut.clk)\n    next_sum = int(dut.poly_dut.sum_result.value)\n    \n    if current_sum != next_sum:\n        raise AssertionError(f\"Test failed: sum_result changed from {current_sum} to {next_sum} when valid_adder is asserted.\")\n    dut._log.info(\"Test passed: sum_result remains stable when valid_adder is asserted.\")", "src/test_runner.py": "import os\nimport pytest\nimport coverage\nimport random\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\ncov_selections  = os.getenv(\"COV_SELECTIONS\", \"\").split()\ncov_thresholds  = [float(s) for s in os.getenv(\"COV_THRESHOLDS\", \"\").split()]\n\ndef call_runner(parameter={}, cov_selection:tuple[str, float] = None):\n    plusargs = {}\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.coverage_report_clear()\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=[],\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameter,\n            cov_selection=cov_selection[0] if cov_selection else \"\",\n        )\n        coverage.coverage_report(\"assertion\")\n        if cov_selection:\n            print(f'cov_selection[0]: {cov_selection[0]} cov_selection[1]: {cov_selection[1]}')\n            coverage.coverage_report_check(cov_selection[1])\n        else:\n            coverage.coverage_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"N\", [2])\n@pytest.mark.parametrize(\"TAPS\", [2])\n@pytest.mark.parametrize(\"COEFF_WIDTH\", [16])\n@pytest.mark.parametrize(\"DATA_WIDTH\", [16])\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(N, TAPS, COEFF_WIDTH, DATA_WIDTH, test):\n\n    if len(cov_selections) == 0:\n        # Run the simulation\n        print(\"Calling runner without arguments\")\n        call_runner(parameter={\"N\": N, \"TAPS\": TAPS, \"COEFF_WIDTH\": COEFF_WIDTH, \"DATA_WIDTH\": DATA_WIDTH})\n        return\n\n    print(\"Identified special coverage selections\")\n\n    assert len(cov_selections) == len(cov_thresholds), \"incompatible coverage selections and thresholds\"\n\n    for selection, threshold in zip(cov_selections, cov_thresholds):\n        print(f\"> Running selection: {selection}, for threshold: {threshold}\")\n        call_runner({\"N\": N, \"TAPS\": TAPS, \"COEFF_WIDTH\": COEFF_WIDTH, \"DATA_WIDTH\": DATA_WIDTH},(selection, threshold))\n\n"}}
{"id": "cvdp_agentic_rgb_color_space_conversion_0005", "categories": ["cid014", "easy"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a `rgb_color_space_hsv` module available in the `rtl` directory and its' specification is in the `docs` directory. Please modify the module by adding System Verilog assertions to validate the following conditions during simulation. The assertions should display clear error messages when any condition is violated.\n\n**Required Assertions:**\n\n1. **Valid Signal Latency:**  \n   Ensure that `valid_out` is asserted exactly after the expected processing latency from the assertion of `valid_in`.\n\n2. **Zero Outputs When i_max is Zero:**  \n   Confirm that when `i_max` is zero, all outputs (`h_component`, `s_component`, and `v_component`) are driven to zero when the outputs are valid.\n\n3. **Zero h_component and s_component When delta_i is Zero:**  \n   Validate that `h_component` and `s_component` are driven to zero when `delta_i` is zero and the outputs are valid.\n\n4. **V Component Accuracy:**  \n   Verify the correctness of `v_component` relative to `i_max` when the outputs are valid. If there is a mismatch, provide detailed debugging information.\n\n5. **H Range Check:**  \n   Ensure that `h_component` does not exit the maximum upper bound under all input conditions.\n\n6. **Input Stability Check:**  \n   Ensure that the inputs (`r_component`, `g_component`, `b_component`) remain stable throughout the processing period until valid outputs are available.\n", "context": {"docs/specification.md": "# RGB to HSV Conversion Module Specification Document\n\n## Introduction\n\nThe **RGB to HSV Conversion Module** is designed to convert RGB (Red, Green, Blue) color space values into HSV (Hue, Saturation, Value) color space values. This module is optimized for hardware implementation, leveraging pipelining and fixed-point arithmetic to achieve efficient and accurate conversion. The module supports 8-bit RGB input values and produces 12-bit Hue, 13-bit Saturation, and 12-bit Value outputs in fixed-point formats.\n\n\n## Algorithm Overview\n\nThe conversion from RGB to HSV involves the following steps:\n\n1. **Normalize RGB Values:**  \n   The 8-bit RGB values are scaled to 12-bit fixed-point representation to maintain precision during calculations.\n\n2. **Determine Maximum and Minimum Values:**  \n   The maximum (`i_max`) and minimum (`i_min`) values among the R, G, and B components are identified. These values are used to calculate the delta (`delta_i`), which is the difference between `i_max` and `i_min`.\n\n3. **Calculate Hue (H):**  \n   The Hue value is calculated based on the maximum RGB component:\n   - If the maximum component is **Red**, Hue is calculated using the formula:  \n     `H = 60 * ((G - B) / delta)`\n   - If the maximum component is **Green**, Hue is calculated using the formula:  \n     `H = 60 * ((B - R) / delta) + 120`\n   - If the maximum component is **Blue**, Hue is calculated using the formula:  \n     `H = 60 * ((R - G) / delta) + 240`\n   - If `delta_i` is zero, Hue is set to `0`.\n\n4. **Calculate Saturation (S):**  \n   Saturation is calculated using the formula:  \n   `S = (delta / i_max)`\n\n5. **Calculate Value (V):**  \n   Value is simply the maximum RGB component:  \n   `V = i_max`\n\nThe module uses precomputed inverse values of `i_max` and `delta_i` stored in memory to avoid division operations, replacing them with multiplications for efficiency.\n\n\n## Module Interface\n\nThe module is defined as follows:\n\n```verilog\nmodule rgb_color_space_hsv (\n    input               clk,\n    input               rst,\n    \n    // Memory ports to initialize (1/delta) values\n    input               we,\n    input       [7:0]   waddr,\n    input      [24:0]   wdata,\n    \n    // Input data with valid.\n    input               valid_in,\n    input       [7:0]   r_component,\n    input       [7:0]   g_component,\n    input       [7:0]   b_component,\n\n    // Output values\n    output reg [11:0]   h_component,  // Output in fx10.2 format, For actual degree value = (h_component)/4\n    output reg [12:0]   s_component,  // Output in fx1.12 format. For actual % value = (s_component/4096)*100\n    output reg [11:0]   v_component,  // For actual % value = (v_component/255) * 100\n    output reg          valid_out\n);\n```\n\n### Port Descriptions\n\n- **clk:** Clock signal. All operations are synchronized to the positive edge of this signal.\n- **rst:** Active-high asynchronous reset signal. When asserted, all internal registers and shift registers are initialized to their default values.\n- **we:** Active-high write enable signal. Used to initialize the inverse values in the dual-port RAM.\n- **waddr:** 8-bit write address signal. Specifies the memory location to be written during initialization.\n- **wdata:** 25-bit write data signal. Contains the inverse values to be stored in the dual-port RAM during initialization.\n- **valid_in:** Active-high input signal. Indicates that the input RGB data (`r_component`, `g_component`, `b_component`) is valid.\n- **r_component:** 8-bit input signal. Represents the Red component of the RGB input.\n- **g_component:** 8-bit input signal. Represents the Green component of the RGB input.\n- **b_component:** 8-bit input signal. Represents the Blue component of the RGB input.\n- **h_component:** 12-bit output signal. Represents the Hue value in fixed-point format (fx10.2). The degree value is obtained by dividing the decimal value by 4.\n- **s_component:** 13-bit output signal. Represents the Saturation value in fixed-point format (fx1.12). The percentage value is obtained by multiplying the decimal value by 100 and dividing by 4096.\n- **v_component:** 12-bit output signal. Represents the Value in percentage format. The percentage value is obtained by multiplying the decimal value by 100 and dividing by 255.\n- **valid_out:** Active-high output signal. Indicates that the output data (`h_component`, `s_component`, `v_component`) is valid.\n\n## Submodules\n\n### 1. Dual-Port RAM\nThe dual-port RAM is used to store precomputed inverse values for `i_max` and `delta_i`. It supports one write port and two independent read ports.\n\n#### Interface Ports:\n- **clk:** Clock signal for synchronization.\n- **we:** Active-high write enable signal.\n- **waddr:** 8-bit write address for memory initialization.\n- **wdata:** 25-bit write data for memory initialization.\n- **ren_a:** Active-high read enable signal for port A.\n- **raddr_a:** 8-bit read address for port A.\n- **rdata_a:** 25-bit read data from port A.\n- **ren_b:** Active-high read enable signal for port B.\n- **raddr_b:** 8-bit read address for port B.\n- **rdata_b:** 25-bit read data from port B.\n\n### 2. Saturation Multiplier\nThe saturation multiplier performs fixed-point multiplication of the delta value with the inverse of `i_max` to calculate saturation.\n\n#### Interface Ports:\n- **clk:** Clock signal for synchronization.\n- **rst:** Active-high reset signal.\n- **a:** 25-bit multiplicand (inverse of `i_max`).\n- **b:** 13-bit multiplier (delta value).\n- **result:** 26-bit result of the multiplication, representing saturation.\n\nThe module computes the multiplication of a and b and the result is stored in a 39-bit intermediate register.\nThe result is **truncated** by selecting bits `[38:12]`, effectively discarding the lower 12 bits.\n**Rounding is applied** by adding back the most significant bit of the discarded portion.\n\n### 3. Hue Multiplier\nThe hue multiplier performs fixed-point multiplication of the precomputed hue value with the inverse of `delta_i` to calculate the hue value before doing hue addition.\n\n#### Interface Ports:\n- **clk:** Clock signal for synchronization.\n- **rst:** Active-high reset signal.\n- **dataa:** 19-bit signed multiplicand (precomputed hue value).\n- **datab:** 25-bit multiplier (inverse of `delta_i`).\n- **result:** 12-bit signed result of the multiplication, representing hue.\n\nThe `hue_mult` module multiplies dataa and datab and the result is **44-bit wide**.\nThis module selects bits `[33:22]`, effectively truncating the lower 22 bits.\n**No explicit rounding is performed**\n\n## Internal Architecture\n\nThe internal architecture is divided into several stages, each implemented using pipelined logic for efficient processing:\n\n1. **Input Scaling and Max/Min Calculation:**  \n   - The 8-bit RGB inputs are scaled to 12-bit fixed-point values.\n   - The maximum (`i_max`) and minimum (`i_min`) values among the R, G, and B components are determined.\n   - The delta (`delta_i`) is calculated as the difference between `i_max` and `i_min`.\n\n2. **Memory Lookup for Inverse Values:**  \n   - The inverse values of `i_max` and `delta_i` are fetched from the dual-port RAM. These values are precomputed and stored to avoid division operations.\n\n3. **Hue Calculation:**  \n   - The Hue value is calculated based on the maximum RGB component using precomputed inverse values and fixed-point arithmetic.\n   - The result is adjusted based on the maximum component (Red, Green, or Blue) and normalized to the range [0, 360].\n\n4. **Saturation Calculation:**  \n   - Saturation is calculated using the formula `S = (delta / i_max)`, implemented using fixed-point multiplication with the pre-computed inverse of `i_max`.\n\n5. **Value Calculation:**  \n   - Value is the maximum RGB component, scaled to the output format.\n\n6. **Output Pipeline:**  \n   - The calculated Hue, Saturation, and Value are passed through a pipeline to ensure proper timing and synchronization.\n   - The `valid_out` signal is asserted when the output data is ready.\n\n\n## Timing and Latency\n\nThe design is fully pipelined, with a total latency of **8 clock cycles** from the assertion of `valid_in` to the assertion of `valid_out`. Each computational step within the module has a specific processing time, but because the design is **pipelined**, different portions of the input data progress through distinct stages concurrently. \n\n1. **Subtraction (1 cycle)**  \n   - The first stage computes the differences required for Hue calculation: `(G - B)`, `(B - R)`, and `(R - G)`.  \n   - These values are passed forward to later stages while new input data enters the pipeline.  \n\n2. **Max/Min Value Calculation (2 cycles)**  \n   - The second stage determines the **maximum (`i_max`)** and **minimum (`i_min`)** values among `R`, `G`, and `B`.  \n\n3. **Determine the Maximum Component and Compute Delta (3 cycles)**  \n   - This stage identifies which component (`R`, `G`, or `B`) contributed to `i_max`.  \n   - It also calculates **delta (`delta_i`)**, which is the difference between `i_max` and `i_min`.  \n\n4. **Memory Lookup for Inverse Values (4 cycles from `valid_in`)**  \n   - The inverse values of `i_max` and `delta_i` are retrieved from a precomputed lookup table.  \n   - Memory access itself takes **1 cycle**, but the lookup results become available at different times:\n     - The **inverse of `i_max`** is available **3 cycles after `valid_in`**.\n     - The **inverse of `delta_i`** is available **4 cycles after `valid_in`**.  \n\n5. **Saturation Calculation (6 cycles from `valid_in`)**  \n   - Once `delta_i` and `i_max` are available, the saturation computation is performed using **fixed-point multiplication**.  \n   - The **inverse of `i_max`** and `delta_i` become available after 3 cycles. The multiplication takes an additional **3 cycles** for computation and rounding.  \n   - The computed saturation value is stored in the pipeline and remains until **valid_out** is asserted at cycle 8.  \n\n6. **Hue Calculation (8 cycles from `valid_in`)**  \n   - The hue calculation involves two key computations:\n     1. **Precomputed Hue Calculation (`5 cycles`)**  \n        - The **subtracted value** used in Hue calculation (`G - B`, `B - R`, or `R - G`) is available **1 cycle after `valid_in`**.  \n        - Identifying which component contributed to `i_max` takes **3 cycles**, so the appropriate subtracted value is selected by cycle **4**.  \n        - An additional **1 cycle** is required to multiply this value by **60**, making the **precomputed hue** available by cycle **5**.  \n     2. **Final Hue Computation (`3 additional cycles`)**  \n        - The **inverse of `delta_i`** is available at **cycle 4**.  \n        - The **hue multiplication module** receives `precomputed hue` (cycle 5) and `inverse of delta` (cycle 4) and performs the multiplication, which takes **2 cycles**.  \n        - An additional **1 cycle** is required to add the **hue offset** (0, 120, or 240 degrees based on `i_max`).  \n        - The final **Hue (`h_component`) is available at cycle 8**, aligning with `valid_out`.  \n\n7. **Value Calculation (2 cycles from `valid_in`)**  \n   - The **Value (`V`) component** is simply assigned the maximum input (`i_max`).  \n   - Since `i_max` is computed early in the pipeline, `v_component` is ready **by cycle 2** but remains in the pipeline until all outputs are valid.  \n\n\n\n## Memory Initialization\n\nThe dual-port RAM stores precomputed inverse values for `i_max` and `delta_i`. These values are initialized using the `we`, `waddr`, and `wdata` signals. The memory is organized as follows:\n- **Address Range:** 0 to 255 (8-bit address).\n- **Data Width:** 25 bits (fixed-point representation of inverse values).\n\n\n## Fixed-Point Formats\n\n- **Hue (h_component):**  \n  - Format: fx10.2 (10 integer bits, 2 fractional bits).\n  - Range: 0 to 360 degrees (scaled by a factor of 4).\n\n- **Saturation (s_component):**  \n  - Format: fx1.12 (1 integer bit, 12 fractional bits).\n  - Range: 0% to 100% (scaled by a factor of 4096).\n\n- **Value (v_component):**  \n  - Format: 12-bit decimal.\n  - Range: 0% to 100% (scaled by a factor of 255).\n\n\n## Precision and Error Tolerance\n\nThe module is designed to maintain the following error tolerances:\n- **Hue:** \u00b10.25 degree.\n- **Saturation:** \u00b10.25%.\n- **Value:** \u00b10.25%.\n\nThese tolerances account for precision loss during fixed-point arithmetic and rounding operations.\n\n## Input constraints\n- Assume that new inputs are provided to the design only after `valid_out` is asserted indication all outputs are valid.", "rtl/rgb_color_space_hsv.sv": "module rgb_color_space_hsv (\n    input               clk,\n    input               rst,\n\n    // Memory ports to initialize (1/delta) values\n    input               we,\n    input       [7:0]   waddr,\n    input      [24:0]   wdata,\n\n    // Input data with valid.\n    input               valid_in,\n    input       [7:0]   r_component,\n    input       [7:0]   g_component,\n    input       [7:0]   b_component,\n\n    // Output values\n    output reg [11:0]   h_component,  // Output in fx10.2 format, degree value = (h_component)/4\n    output reg [12:0]   s_component,  // Output in fx1.12 format. % value = (s_component/4096)*100\n    output reg [11:0]   v_component,  // % value = (v_componente/255) * 100\n    output reg          valid_out\n);\n\n    integer j;\n\n    reg      [7:0]    valid_in_shreg;\n    reg signed [12:0] pre_hue;\n    reg      [11:0]   i_max, i_min, stage1_max, stage1_min, stage1_b;\n    reg       [8:0]   hue_degrees_offset;\n    reg       [2:0]   i_max_r, i_max_g, i_max_b;\n\n    reg      [12:0]   g_sub_b_shreg [0:1];\n    reg      [12:0]   b_sub_r_shreg [0:1];\n    reg      [12:0]   r_sub_g_shreg [0:1];\n    reg      [11:0]   i_max_shreg [0:1];\n    reg      [11:0]   i_min_shreg [0:1];\n\n    wire     [25:0]   saturation_result;\n    wire     [24:0]   inv_i_max, inv_delta_i;\n    wire     [11:0]   almost_hue;\n    reg signed [11:0] hue;\n\n    assign valid_out = valid_in_shreg[7];\n    assign v_component = i_max;\n    assign s_component = saturation_result;\n    assign h_component = hue;\n\n    reg signed [12:0] g_sub_b, b_sub_r, r_sub_g, delta_i;\n\n    // Internally upscaled 12-bit values for fixed point precision\n    wire [11:0] r_scaled = {4'b0000, r_component}; // Scale 8-bit to 12-bit\n    wire [11:0] g_scaled = {4'b0000, g_component}; // Scale 8-bit to 12-bit\n    wire [11:0] b_scaled = {4'b0000, b_component}; // Scale 8-bit to 12-bit\n\n    // Subtraction logic, to find difference of inputs and delta value\n    // Calculate g-b, b-r, r-g and max-min values to be used in h calculation\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            g_sub_b <= 13'd0;\n            b_sub_r <= 13'd0;\n            r_sub_g <= 13'd0;\n            delta_i <= 13'd0;\n        end else begin\n            g_sub_b <= $signed(g_scaled) - $signed(b_scaled);\n            b_sub_r <= $signed(b_scaled) - $signed(r_scaled);\n            r_sub_g <= $signed(r_scaled) - $signed(g_scaled);\n            delta_i <= $signed(i_max) - $signed(i_min);\n        end\n    end\n\n    // Memory to store 1/delta values (256 values)\n    // 0,1/1,1/2,1/3...1/255)\n    // These values are used to multiply with (g-b)/(b-r)/(r-g) for calculation\n    // h value. It is easy to store inverse values and do multiplication\n    // than division.\n    dual_port_ram inverse_component_inst (\n        .clk(clk),\n        .we(we),\n        .waddr(waddr),\n        .wdata(wdata),\n        .ren_a(1'b1),\n        .raddr_a(i_max[7:0]),\n        .rdata_a(inv_i_max),\n        .ren_b(1'b1),\n        .raddr_b(delta_i[7:0]),\n        .rdata_b(inv_delta_i)\n    );\n\n    // Pre hue constant multiplier for h calculation\n    // Multiply with 60 degrees.\n    // Used 2 stage pipeline\n    localparam signed [6:0] CONST_60 = 7'd60;\n    reg signed [18:0] pre_hue_prod;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pre_hue_prod <= 19'd0;\n        end else begin\n            pre_hue_prod <= pre_hue * CONST_60;\n        end\n    end\n\n    // Saturation calculation multiplier\n    saturation_mult saturation_mult_0 (\n        .clk(clk),\n        .rst(rst),\n        .a(inv_i_max), // Read inverted value from memory port1\n        .b({1'b0, delta_i[11:0]}), // Delta value (max-min)\n        .result(saturation_result)\n    );\n\n    // h value calculation multiplier\n    hue_mult hue_mult_inst (\n        .clk(clk),\n        .rst(rst),\n        .dataa(pre_hue_prod), // Product from constant 60 multiplication\n        .datab(inv_delta_i), // Read inverted data from memory port2\n        .result(almost_hue)\n    );\n\n    // Final h value addition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            hue <= 'd0;\n        else\n            hue <= $signed(almost_hue) + $signed({1'b0, {hue_degrees_offset, 2'd0}});\n    end\n\n    // Pipelining registers to help in each stage of data processing\n    // Help with multiplications and additions\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers and shift registers\n            g_sub_b_shreg[0] <= 0;\n            b_sub_r_shreg[0] <= 0;\n            r_sub_g_shreg[0] <= 0;\n            i_max_shreg[0] <= 0;\n            i_min_shreg[0] <= 0;\n\n            // Reset the shift registers for all stages\n            for (j = 0; j < 2; j = j + 1) begin\n                g_sub_b_shreg[j+1] <= 0;\n                b_sub_r_shreg[j+1] <= 0;\n                r_sub_g_shreg[j+1] <= 0;\n                i_max_shreg[j+1] <= 0;\n                i_min_shreg[j+1] <= 0;\n            end\n        end else begin\n            // Normal operation when reset is not asserted\n            g_sub_b_shreg[0] <= g_sub_b;\n            b_sub_r_shreg[0] <= b_sub_r;\n            r_sub_g_shreg[0] <= r_sub_g;\n            i_max_shreg[0] <= i_max;\n            i_min_shreg[0] <= i_min;\n\n            // Shift register updates\n            for (j = 0; j < 2; j = j + 1) begin\n                g_sub_b_shreg[j+1] <= g_sub_b_shreg[j];\n                b_sub_r_shreg[j+1] <= b_sub_r_shreg[j];\n                r_sub_g_shreg[j+1] <= r_sub_g_shreg[j];\n                i_max_shreg[j+1] <= i_max_shreg[j];\n                i_min_shreg[j+1] <= i_min_shreg[j];\n            end\n        end\n    end\n\n    // Calculate max and min values\n    // Shift valid in for total latency cycles\n    // and assign to output valid when output data is ready\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            valid_in_shreg <= 0;\n            stage1_max <= 0;\n            stage1_min <= 0;\n            stage1_b <= 0;\n            i_max_r <= 0;\n            i_max_g <= 0;\n            i_max_b <= 0;\n            i_max <= 0;\n            i_min <= 0;\n        end else begin\n            valid_in_shreg <= {valid_in_shreg[6:0], valid_in};\n            i_max_r[2] <= i_max_r[1];\n            i_max_g[2] <= i_max_g[1];\n            i_max_b[2] <= i_max_b[1];\n\n            if (valid_in) begin\n                stage1_b <= b_component;\n                if (r_component > g_component) begin\n                    stage1_max <= r_component;\n                    stage1_min <= g_component;\n                    i_max_r[0] <= 1;\n                    i_max_g[0] <= 0;\n                    i_max_b[0] <= 0;\n                end else begin\n                    stage1_max <= g_component;\n                    stage1_min <= r_component;\n                    i_max_r[0] <= 0;\n                    i_max_g[0] <= 1;\n                    i_max_b[0] <= 0;\n                end\n            end\n\n            if (valid_in_shreg[0]) begin\n                if (stage1_max > stage1_b) begin\n                    i_max      <= stage1_max;\n                    i_max_r[1] <= i_max_r[0];\n                    i_max_g[1] <= i_max_g[0];\n                    i_max_b[1] <= i_max_b[0];\n                end else begin\n                    i_max      <= stage1_b;\n                    i_max_r[1] <= 0;\n                    i_max_g[1] <= 0;\n                    i_max_b[1] <= 1;\n                end\n\n                if (stage1_min < stage1_b) i_min <= stage1_min;\n                else                       i_min <= stage1_b;\n            end\n        end\n    end\n\n    // Select degree value to add for h calculation\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            pre_hue <= 'd0;\n            hue_degrees_offset <= 'd0;\n        end else begin\n            if (valid_in_shreg[2]) begin\n                if (i_max_shreg[0] == i_min_shreg[0]) begin\n                    pre_hue <= 0;\n                    hue_degrees_offset <= 9'd0;\n                end else if ((i_max_r[2]) && (~g_sub_b_shreg[0][12])) begin\n                    pre_hue <= g_sub_b_shreg[0];\n                    hue_degrees_offset <= 9'd0;\n                end else if ((i_max_r[2]) && (g_sub_b_shreg[0][12])) begin\n                    pre_hue <= g_sub_b_shreg[0];\n                    hue_degrees_offset <= 9'd360;\n                end else if (i_max_g[2]) begin\n                    pre_hue <= b_sub_r_shreg[0];\n                    hue_degrees_offset <= 9'd120;\n                end else if (i_max_b[2]) begin\n                    pre_hue <= r_sub_g_shreg[0];\n                    hue_degrees_offset <= 9'd240;\n                end\n            end\n        end\n    end\nendmodule\n\n// Write port to initialize 1/delta values, and two read ports.\n// 1. Read port --> read 1/delta address\n// 2. Read port --> read 1/max address\n// Memory is used to store inverted values (0 to 1/255) such that multiplication can be\n// performed easily than division.\nmodule dual_port_ram (\n    input               clk,\n    input               we,\n    input       [7:0]   waddr,\n    input      [24:0]   wdata,\n    input               ren_a,\n    input       [7:0]   raddr_a,\n    output reg [24:0]   rdata_a,\n    input               ren_b,\n    input       [7:0]   raddr_b,\n    output reg [24:0]   rdata_b\n);\n\n    reg [24:0] ram [0:255];\n\n    always @(posedge clk) begin\n        if (we) begin\n            ram[waddr] <= wdata;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (ren_a) begin\n            rdata_a <= ram[raddr_a];\n        end\n    end\n\n    always @(posedge clk) begin\n        if (ren_b) begin\n            rdata_b <= ram[raddr_b];\n        end\n    end\nendmodule\n\n// This is used to multiply delta value with inverted cmax value from memory\n// (used to calculate s, saturation)\nmodule saturation_mult (\n    input  wire         clk,\n    input  wire         rst,\n    input  wire [24:0]  a,\n    input  wire [12:0]  b,\n    output [25:0]  result\n);\n\n    reg [24:0] A_reg;\n    reg [12:0] B_reg;\n    reg [38:0] mult_result;\n    reg [25:0] rounded_result;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            A_reg <= 25'd0;\n            B_reg <= 13'd0;\n        end else begin\n            A_reg <= a;\n            B_reg <= b;\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            mult_result <= 'd0;\n        end else begin\n            mult_result <= A_reg * B_reg;\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rounded_result <= 'd0;\n        end else begin\n            rounded_result <= mult_result[38:12] + mult_result[11];\n        end\n    end\n\n    assign result = rounded_result;\nendmodule\n\n//used for h, hue calculation\nmodule hue_mult (\n    input               clk,\n    input               rst,\n    input signed [18:0] dataa,\n    input      [24:0]   datab,\n    output reg signed [11:0] result\n);\n\n    reg signed [43:0] mult_stage1;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            mult_stage1 <= 44'd0;\n        else\n            mult_stage1 <= $signed(dataa) * $signed({1'b0, datab});\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 12'd0;\n        else\n            result <= mult_stage1[33:22];\n    end\nendmodule\n"}, "patch": {"rtl/rgb_color_space_hsv.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest -s --log-cli-level=INFO -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/rgb_color_space_hsv.sv\nTOPLEVEL        = rgb_color_space_hsv\nMODULE          = test_rgb_color_space_hsv\nPYTHONPATH      = /src\nHASH            = 5-assertions-for-rgb_color_space_hsv \n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameter:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\n\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_rgb_color_space_hsv.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport random\nimport math\n\nasync def initialize_ram(dut):\n    \"\"\"Initialize the RAM (dual_port_ram) with inverse lookup values.\"\"\"\n    dut.we.value = 1  # Enable write mode\n\n    for i in range(256):  # Populate only 256 values as in your SV testbench\n        dut.wdata.value = compute_fx0_24(i)\n        dut.waddr.value = i\n        await RisingEdge(dut.clk)  # Wait for one clock cycle\n\n    dut.we.value = 0  # Disable write mode\n    dut.waddr.value = 0\n\n\ndef compute_fx0_24(n):\n    \"\"\"Compute the fixed-point (fx0.24) representation of 1/n.\"\"\"\n    if n == 0:\n        return 0\n    inverse = 1.0 / n\n    return int(inverse * (2 ** 24))\n\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT, including RAM initialization before testing.\"\"\"\n    dut.rst.value = 1\n    dut.valid_in.value = 0\n    dut.r_component.value = 0\n    dut.g_component.value = 0\n    dut.b_component.value = 0\n    dut.we.value = 1\n    dut.waddr.value = 0\n    dut.wdata.value = 0\n\n    # Start clock\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Initialize RAM before applying any test cases\n    await initialize_ram(dut)\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n\n\nasync def apply_rgb_input(dut, r, g, b):\n    \"\"\"Apply an RGB input to the DUT and wait for the HSV output.\"\"\"\n    dut.r_component.value = r\n    dut.g_component.value = g\n    dut.b_component.value = b\n    dut.valid_in.value = 1\n\n    await RisingEdge(dut.clk)\n    dut.valid_in.value = 0  # Deassert valid\n\n    # Wait for valid_out to be asserted\n    while dut.valid_out.value == 0:\n        await RisingEdge(dut.clk)\n\n    # Capture the output\n    h_out = int(dut.h_component.value)\n    s_out = int(dut.s_component.value)\n    v_out = int(dut.v_component.value)\n\n    return h_out, s_out, v_out\n\n\ndef rgb_to_hsv_python(r, g, b):\n    \"\"\"Compute HSV values in Python to match RTL bit precision.\"\"\"\n    r_prime, g_prime, b_prime = r / 255.0, g / 255.0, b / 255.0\n    c_max = max(r_prime, g_prime, b_prime)\n    c_min = min(r_prime, g_prime, b_prime)\n    delta = c_max - c_min\n\n    # Compute Hue\n    if delta == 0:\n        h = 0\n    elif c_max == r_prime:\n        h = (60 * ((g_prime - b_prime) / delta)) % 360\n    elif c_max == g_prime:\n        h = (60 * ((b_prime - r_prime) / delta) + 120) % 360\n    elif c_max == b_prime:\n        h = (60 * ((r_prime - g_prime) / delta) + 240) % 360\n\n    # Apply correct rounding to match RTL\n    h_fx10_2 = int(h * 4 + 0.5)  # Convert degrees to fx10.2\n\n    # Compute Saturation\n    s_fx1_12 = round((delta / c_max) * 4096) if c_max != 0 else 0  # Convert percentage to fx1.12\n\n    # Compute Value (Direct assignment matches RTL)\n    v_fx0_12 = int(c_max * 255)  # Directly use Cmax (matches RTL behavior)\n\n    return h_fx10_2, s_fx1_12, v_fx0_12\n\nasync def compare_rgb_to_hsv(dut, r, g, b):\n    \"\"\"\n    Shared function to apply RGB input, compute reference values, and compare DUT outputs.\n    \"\"\"\n    # Get DUT output\n    h_out, s_out, v_out = await apply_rgb_input(dut, r, g, b)\n\n    # Convert to degrees and percentages\n    dut_h_deg = h_out / 4\n    dut_s_pct = (s_out / 4096) * 100\n    dut_v_pct = (v_out / 255) * 100  # Normalize V to 100%\n\n    # Get reference output\n    h_ref, s_ref, v_ref = rgb_to_hsv_python(r, g, b)\n\n    # Convert reference values for comparison\n    ref_h_deg = h_ref / 4\n    ref_s_pct = (s_ref / 4096) * 100\n    ref_v_pct = (v_ref / 255) * 100\n\n    print(f\"Input RGB: ({r:3}, {g:3}, {b:3}) \u2192 \"\n          f\"DUT HSV: ({dut_h_deg:7.2f}\u00b0, {dut_s_pct:6.2f}%, {dut_v_pct:6.2f}%) | \"\n          f\"Ref HSV: ({ref_h_deg:7.2f}\u00b0, {ref_s_pct:6.2f}%, {ref_v_pct:6.2f}%)\")\n\n    # Assert correctness\n    assert abs(dut_h_deg - ref_h_deg) <= 0.25, f\"Mismatch in H: Expected {ref_h_deg:.2f}\u00b0, got {dut_h_deg:.2f}\u00b0\"\n    assert abs(dut_s_pct - ref_s_pct) <= 0.25, f\"Mismatch in S: Expected {ref_s_pct:.2f}%, got {dut_s_pct:.2f}%\"\n    assert abs(dut_v_pct - ref_v_pct) <= 0.25, f\"Mismatch in V: Expected {ref_v_pct:.2f}%, got {dut_v_pct:.2f}%\"\n\n@cocotb.test()\nasync def test_rgb_to_hsv(dut):\n    \"\"\"Test predefined RGB inputs and compare HSV outputs with expected values.\"\"\"\n    await initialize_dut(dut)  # Ensure RAM is initialized\n\n    # Predefined test cases\n    test_cases = [\n        (193, 226, 60),   # Normal color\n        (255, 0, 0),      # Red\n        (0, 255, 0),      # Green\n        (0, 0, 255),      # Blue\n        (255, 255, 0),    # Yellow\n        (0, 255, 255),    # Cyan\n        (255, 0, 255),    # Magenta\n        (128, 128, 128),  # Mid Gray\n        (255, 255, 255),  # White\n        (0, 0, 0),        # Black\n        (212, 90, 17),    # Random color\n        (10, 10, 10),     # Almost black\n        (245, 245, 245),  # Almost white\n        (50, 100, 200),   # Random blue shade\n        (200, 50, 100),   # Random red shade\n        (100, 200, 50),   # Random green shade\n        (1, 1, 1),        # Edge case: near black\n        (254, 254, 254),  # Edge case: near white\n    ]\n\n    for r, g, b in test_cases:\n        await compare_rgb_to_hsv(dut, r, g, b)\n\n\n@cocotb.test()\nasync def test_rgb_to_hsv_random(dut):\n    \"\"\"Test random RGB inputs and compare HSV outputs with expected values.\"\"\"\n    await initialize_dut(dut)  # Ensure RAM is initialized\n\n    # Number of random test cases to generate\n    num_random_tests = 50\n\n    for _ in range(num_random_tests):\n        # Generate random RGB values\n        random_r = random.randint(0, 255)\n        random_g = random.randint(0, 255)\n        random_b = random.randint(0, 255)\n\n        # Compare DUT output with reference\n        await compare_rgb_to_hsv(dut, random_r, random_g, random_b)\n\n\n@cocotb.test()\nasync def test_rgb_to_hsv_random_r_max(dut):\n    \"\"\"Test random RGB inputs where R is the maximum value.\"\"\"\n    await initialize_dut(dut)  # Ensure RAM is initialized\n\n    # Number of random test cases to generate\n    num_random_tests = 50\n\n    for _ in range(num_random_tests):\n        # Generate random RGB values where R is the maximum\n        random_r = random.randint(1, 255)  # Ensure R is high\n        random_g = random.randint(0, random_r - 1)  # G < R\n        random_b = random.randint(0, random_r - 1)  # B < R\n\n        # Compare DUT output with reference\n        await compare_rgb_to_hsv(dut, random_r, random_g, random_b)\n\n\n@cocotb.test()\nasync def test_rgb_to_hsv_random_g_max(dut):\n    \"\"\"Test random RGB inputs where G is the maximum value.\"\"\"\n    await initialize_dut(dut)  # Ensure RAM is initialized\n\n    # Number of random test cases to generate\n    num_random_tests = 50\n\n    for _ in range(num_random_tests):\n        # Generate random RGB values where G is the maximum\n        random_g = random.randint(1, 255)  # Ensure G is high\n        random_r = random.randint(0, random_g - 1)  # R < G\n        random_b = random.randint(0, random_g - 1)  # B < G\n\n        # Compare DUT output with reference\n        await compare_rgb_to_hsv(dut, random_r, random_g, random_b)\n\n\n@cocotb.test()\nasync def test_rgb_to_hsv_random_b_max(dut):\n    \"\"\"Test random RGB inputs where B is the maximum value.\"\"\"\n    await initialize_dut(dut)  # Ensure RAM is initialized\n\n    # Number of random test cases to generate\n    num_random_tests = 50\n\n    for _ in range(num_random_tests):\n        # Generate random RGB values where B is the maximum\n        random_b = random.randint(1, 255)  # Ensure B is high\n        random_r = random.randint(0, random_b - 1)  # R < B\n        random_g = random.randint(0, random_b - 1)  # G < B\n\n        # Compare DUT output with reference\n        await compare_rgb_to_hsv(dut, random_r, random_g, random_b)\n\n@cocotb.test()\nasync def test_rgb_to_hsv_max_min_same(dut):\n    \"\"\"Test RGB inputs where max and min values are the same (grayscale colors).\"\"\"\n    await initialize_dut(dut)  # Ensure RAM is initialized\n\n    # Number of random test cases to generate\n    num_random_tests = 50\n\n    for _ in range(num_random_tests):\n        # Generate a random grayscale value (R = G = B)\n        grayscale_value = random.randint(0, 255)\n\n        # Use the same value for R, G, and B\n        r, g, b = grayscale_value, grayscale_value, grayscale_value\n\n        # Compare DUT output with reference\n        await compare_rgb_to_hsv(dut, r, g, b)\n\n@cocotb.test()\nasync def test_reset_outputs_zero(dut):\n    \"\"\"Verify that outputs are 0 after reset.\"\"\"\n    await initialize_dut(dut)  # Ensure RAM is initialized and reset is applied\n\n    # Check outputs after reset\n    h_out = int(dut.h_component.value)\n    s_out = int(dut.s_component.value)\n    v_out = int(dut.v_component.value)\n\n    # Print results\n    print(f\"After reset: H = {h_out}, S = {s_out}, V = {v_out}\")\n\n    # Assert outputs are 0\n    assert h_out == 0, f\"Expected H = 0 after reset, got {h_out}\"\n    assert s_out == 0, f\"Expected S = 0 after reset, got {s_out}\"\n    assert v_out == 0, f\"Expected V = 0 after reset, got {v_out}\"\n\n\n\n", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\ndef test_runner():\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        \n        hrs_lb.runner(wave = wave, toplevel = toplevel, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\nif __name__ == \"__main__\":\n    test_runner()"}}
{"id": "cvdp_agentic_sorter_0007", "categories": ["cid014", "easy"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a `sorting_engine` module available in the `rtl` directory, and its' specification is in the `docs` directory. Kindly modify the module by adding system verilog assertions. The assertions should ensure that the module accurately implements the Parallel merge sort algorithm.\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Intermediate sort results:** Verify that the intermediate arrays and the final array are sorted after each state based on the expected operation of that state.\n- **Sort latency:** Make sure the module latency is correct based on the RTL given.\n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.\n", "context": {"docs/specification.md": "# Sorting Engine Specification Document\n\n## Introduction\n\nThe **Sorting Engine** should implement an **8-element parallel merge sort** algorithm. This module is designed to sort 8 inputs of configurable bit-width (parameterized by `WIDTH`) in ascending order (lowest value at LSB and highest at MSB). The design must leverage the parallelism inherent in the merge sort algorithm by dividing the sort process into multiple stages. Each stage performs compare\u2013swap and merging operations in a pipelined finite state machine (FSM) manner.\n\n---\n\n## Algorithm Overview\n\n**Merge Sort** is a well-known divide-and-conquer sorting algorithm. The basic idea is to divide the unsorted list into smaller sub-lists, sort each sub-list, and then merge them to produce a sorted list. The parallel merge sort algorithm to be implemented in this module works as follows:\n\n1. **Pair Sorting:**  \n   The input array is divided into 4 pairs. Each pair is independently sorted using a compare\u2013swap operation. This is the step where parallel operation happens for all pairs.\n\n2. **Merge Sorted Pairs:**  \n   Two consecutive sorted pairs are merged sequentially into a 4-element sorted group. This is done for both halves of the array, the first 4 pairs of elements and the last 4 elements.\n\n3. **Final Merge:**  \n   The two 4-element groups are merged to produce the final sorted 8-element array.\n\n### Example\n\nConsider the input array (from lowest index to highest):\n\n```\n[8, 7, 6, 5, 4, 3, 2, 1]\n```\n\n**Stage 1 \u2013 Pair Sorting:**  \n- Pairs are sorted:  \n  - Compare 8 and 7 \u2192 [7, 8]  \n  - Compare 6 and 5 \u2192 [5, 6]  \n  - Compare 4 and 3 \u2192 [3, 4]  \n  - Compare 2 and 1 \u2192 [1, 2]\n\n**Stage 2 \u2013 Merge Sorted Pairs:**  \n- Merge the first two pairs: [7, 8] and [5, 6] \u2192 [5, 6, 7, 8]  \n- Merge the next two pairs: [3, 4] and [1, 2] \u2192 [1, 2, 3, 4]\n\n**Stage 3 \u2013 Final Merge:**  \n- Merge the two 4-element groups: [5, 6, 7, 8] and [1, 2, 3, 4] \u2192 [1, 2, 3, 4, 5, 6, 7, 8]\n\nThe final output is the sorted list in ascending order.\n\n---\n\n## Module Interface\n\nThe module should be defined as follows:\n\n```verilog\nmodule sorting_engine #(parameter WIDTH = 8)(\n    input                     clk,\n    input                     rst,\n    input                     start,  \n    input  [8*WIDTH-1:0]      in_data,\n    output reg                done,   \n    output reg [8*WIDTH-1:0]  out_data\n);\n```\n\n### Port Description\n\n- **clk:** Clock signal.\n- **rst:** Active-high asynchronous reset to set the outputs to 0.\n- **start:** Active-high signal to initiate the sort operation. High for 1 clock cycle.\n- **in_data:** Flat input bus representing 8 data elements, each `WIDTH` bits wide.\n- **done:** Active-high signal indicating the completion of the sort operation. High for 1 clock cycle after sorting completes.\n- **out_data:** Flat output bus containing the sorted data. Updated along with done signal and remains stable until data from next sorting operation is updated.\n\n---\n\n## Internal Architecture\n\nThe internal architecture must be organized into several stages controlled by an FSM:\n\n1. **Data Loading:**  \n   The flat `in_data` vector should be unpacked into an internal array.\n\n2. **Stage 1 \u2013 Pair Compare\u2013Swap:**  \n   Four pairs of data must be compared and swapped in parallel if necessary. The sorted pairs should be stored for subsequent merging.\n\n3. **Stage 2 \u2013 Merging Sorted Pairs:**  \n   Two merge operations to be performed sequentially:\n   - The first merge combines pairs `[0,1]` with `[2,3]` into a sorted 4-element group.\n   - The second merge combines pairs `[4,5]` with `[6,7]` into another sorted 4-element group.\n\n4. **Stage 3 \u2013 Final Merge:**  \n   The two 4-element groups should be merged to produce the final sorted array.\n\nThe design should utilize sequential merging with pointer and counter logic, allowing the design to be pipelined and easily scalable for production.\n\n---\n\n## Timing and Latency\n\nThe design should be fully synchronous with a pipelined FSM. The expected latency from asserting the start signal to asserting the done signal is **20 clock cycles**. This includes:\n- A few cycles for data loading.\n- Cycles dedicated to the pair sorting and merging stages.\n- Final packaging of the sorted output into the flat bus.", "rtl/sorting_engine.sv": "module sorting_engine #(parameter WIDTH = 8)(\n    input                     clk,\n    input                     rst,\n    input                     start,      // Start the sort when start=1\n    input  [8*WIDTH-1:0]      in_data,    // 8 inputs, each WIDTH bits\n    output reg                done,\n    output reg [8*WIDTH-1:0]  out_data    // 8 outputs, sorted ascending\n);\n\n  // FSM state encoding\n  localparam IDLE      = 3'd0,\n             LOAD      = 3'd1,\n             SORT_PAIRS= 3'd2,\n             MERGE_2_1 = 3'd3,  // Merge first two sorted pairs into a 4-element group\n             MERGE_2_2 = 3'd4,  // Merge second two sorted pairs into a 4-element group\n             MERGE_4   = 3'd5,  // Merge the two 4-element groups into final 8-element sorted list\n             DONE      = 3'd6;\n\n  reg [2:0] state;\n\n  // Internal storage for data at different stages.\n  reg [WIDTH-1:0] stage0 [7:0];           // Loaded input data\n  reg [WIDTH-1:0] sorted_pairs [7:0];     // After pair compare\u2013swap\n  reg [WIDTH-1:0] merge4_right [3:0];      // First 4\u2013element sorted group (from indices 0\u20133)\n  reg [WIDTH-1:0] merge4_left [3:0];     // Second 4\u2013element sorted group (from indices 4\u20137)\n  reg [WIDTH-1:0] final_sorted [7:0];     // Final 8\u2013element sorted result\n\n  // Merge pointers and counter used for sequential merging\n  reg [3:0] merge_count;  // Counts how many outputs have been merged in current merge stage\n  reg [2:0] ptr1, ptr2;   // Pointers for the two arrays being merged\n\n  integer i; // loop variable for for\u2013loops\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      state      <= IDLE;\n      done       <= 0;\n      out_data   <= 0;\n      merge_count<= 0;\n      ptr1       <= 0;\n      ptr2       <= 0;\n    end else begin\n      case (state)\n        // Wait for the start signal.\n        IDLE: begin\n          done <= 0;\n          if (start)\n            state <= LOAD;\n        end\n\n        // Capture the 8 input elements from the flat bus into an array.\n        LOAD: begin\n          for (i = 0; i < 8; i = i + 1) begin\n            stage0[i] <= in_data[i*WIDTH +: WIDTH];\n          end\n          state <= SORT_PAIRS;\n        end\n\n        // Stage 1: Compare-swap each adjacent pair.\n        // The 8 numbers are divided into 4 pairs: indices {0,1}, {2,3}, {4,5}, {6,7}.\n        SORT_PAIRS: begin\n          // Pair 0\n          if (stage0[0] <= stage0[1]) begin\n            sorted_pairs[0] <= stage0[0];\n            sorted_pairs[1] <= stage0[1];\n          end else begin\n            sorted_pairs[0] <= stage0[1];\n            sorted_pairs[1] <= stage0[0];\n          end\n          // Pair 1\n          if (stage0[2] <= stage0[3]) begin\n            sorted_pairs[2] <= stage0[2];\n            sorted_pairs[3] <= stage0[3];\n          end else begin\n            sorted_pairs[2] <= stage0[3];\n            sorted_pairs[3] <= stage0[2];\n          end\n          // Pair 2\n          if (stage0[4] <= stage0[5]) begin\n            sorted_pairs[4] <= stage0[4];\n            sorted_pairs[5] <= stage0[5];\n          end else begin\n            sorted_pairs[4] <= stage0[5];\n            sorted_pairs[5] <= stage0[4];\n          end\n          // Pair 3\n          if (stage0[6] <= stage0[7]) begin\n            sorted_pairs[6] <= stage0[6];\n            sorted_pairs[7] <= stage0[7];\n          end else begin\n            sorted_pairs[6] <= stage0[7];\n            sorted_pairs[7] <= stage0[6];\n          end\n          // Initialize pointers for first merge stage (MERGE_2_1)\n          ptr1        <= 0;\n          ptr2        <= 0;\n          merge_count <= 0;\n          state       <= MERGE_2_1;\n        end\n\n        // Stage 2a: Merge the first two sorted pairs (indices 0\u20131 and 2\u20133)\n        MERGE_2_1: begin\n          // Use ptr1 for sorted_pairs[0:1] and ptr2 for sorted_pairs[2:3].\n          if ((ptr1 < 2) && (ptr2 < 2)) begin\n            if (sorted_pairs[ptr1] <= sorted_pairs[ptr2+2]) begin\n              merge4_right[merge_count] <= sorted_pairs[ptr1];\n              ptr1 <= ptr1 + 1;\n            end else begin\n              merge4_right[merge_count] <= sorted_pairs[ptr2+2];\n              ptr2 <= ptr2 + 1;\n            end\n          end else if (ptr1 < 2) begin\n            merge4_right[merge_count] <= sorted_pairs[ptr1];\n            ptr1 <= ptr1 + 1;\n          end else if (ptr2 < 2) begin\n            merge4_right[merge_count] <= sorted_pairs[ptr2+2];\n            ptr2 <= ptr2 + 1;\n          end\n          // Check if 4 elements have been merged.\n          if (merge_count == 3) begin\n            merge_count <= 0;\n            ptr1        <= 0;\n            ptr2        <= 0;\n            state       <= MERGE_2_2;\n          end else begin\n            merge_count <= merge_count + 1;\n          end\n        end\n\n        // Stage 2b: Merge the second two sorted pairs (indices 4\u20135 and 6\u20137)\n        MERGE_2_2: begin\n          // Use ptr1 for sorted_pairs[4:5] and ptr2 for sorted_pairs[6:7].\n          if ((ptr1 < 2) && (ptr2 < 2)) begin\n            if (sorted_pairs[ptr1+4] <= sorted_pairs[ptr2+6]) begin\n              merge4_left[merge_count] <= sorted_pairs[ptr1+4];\n              ptr1 <= ptr1 + 1;\n            end else begin\n              merge4_left[merge_count] <= sorted_pairs[ptr2+6];\n              ptr2 <= ptr2 + 1;\n            end\n          end else if (ptr1 < 2) begin\n            merge4_left[merge_count] <= sorted_pairs[ptr1+4];\n            ptr1 <= ptr1 + 1;\n          end else if (ptr2 < 2) begin\n            merge4_left[merge_count] <= sorted_pairs[ptr2+6];\n            ptr2 <= ptr2 + 1;\n          end\n          // Check if merge of 4 elements is complete.\n          if (merge_count == 3) begin\n            merge_count <= 0;\n            ptr1        <= 0;\n            ptr2        <= 0;\n            state       <= MERGE_4;\n          end else begin\n            merge_count <= merge_count + 1;\n          end\n        end\n\n        // Stage 3: Merge the two 4\u2013element groups (merge4_right and merge4_left)\n        MERGE_4: begin\n          if ((ptr1 < 4) && (ptr2 < 4)) begin\n            if (merge4_right[ptr1] <= merge4_left[ptr2]) begin\n              final_sorted[merge_count] <= merge4_right[ptr1];\n              ptr1 <= ptr1 + 1;\n            end else begin\n              final_sorted[merge_count] <= merge4_left[ptr2];\n              ptr2 <= ptr2 + 1;\n            end\n          end else if (ptr1 < 4) begin\n            final_sorted[merge_count] <= merge4_right[ptr1];\n            ptr1 <= ptr1 + 1;\n          end else if (ptr2 < 4) begin\n            final_sorted[merge_count] <= merge4_left[ptr2];\n            ptr2 <= ptr2 + 1;\n          end\n          // Check if all 8 elements have been merged.\n          if (merge_count == 7) begin\n            merge_count <= 0;\n            state       <= DONE;\n          end else begin\n            merge_count <= merge_count + 1;\n          end\n        end\n\n        // Final state: pack the final_sorted array back into out_data and assert done.\n        DONE: begin\n          for (i = 0; i < 8; i = i + 1) begin\n            out_data[i*WIDTH +: WIDTH] <= final_sorted[i];\n          end\n          done  <= 1;\n          // Optionally, return to IDLE (or hold in DONE) so a new sort can begin.\n          state <= IDLE;\n        end\n\n        default: state <= IDLE;\n      endcase\n    end\n  end\n\nendmodule"}, "patch": {"rtl/sorting_engine.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sorting_engine.sv\nTOPLEVEL        = sorting_engine\nMODULE          = test_sorting_engine\nPYTHONPATH      = /src\nHASH            = 7-rtl-assertion-parallel-sorter", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.parametrize(\"WIDTH\", [random.randint(1, 32)])\ndef test_runner(WIDTH):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    parameters = { \"WIDTH\": WIDTH }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n", "src/test_sorting_engine.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport math\n\ndef pack_vector(vec, width):\n    \"\"\"\n    Pack a list of integers (representing elements A[0] to A[7]) into a flat integer.\n    The flat vector is constructed as {A[7], A[6], ..., A[0]} so that A[0] maps to the LSB.\n    \"\"\"\n    value = 0\n    for x in reversed(vec):  # Reverse order: MSB is A[7]\n        value = (value << width) | (x & ((1 << width) - 1))\n    return value\n\nasync def reset_dut(dut):\n    \"\"\"\n    Reset the DUT by asserting rst for a couple of clock cycles.\n    \"\"\"\n    dut.rst.value = 1\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\nasync def run_test(dut, test_name, input_vec, expected_vec, width):\n    \"\"\"\n    Apply a test vector to the DUT, check the output, and measure latency.\n    Both input_vec and expected_vec are lists of NUM_ELEMS values.\n    \"\"\"\n    NUM_ELEMS = len(input_vec)\n    dut._log.info(\"***** Starting Test: %s *****\", test_name)\n\n    # Pack the input and expected arrays into flat integers.\n    input_flat    = pack_vector(input_vec, width)\n    expected_flat = pack_vector(expected_vec, width)\n\n    # Drive the input vector and ensure start is low.\n    dut.in_data.value = input_flat\n    dut.start.value   = 0\n\n    # Reset the DUT to initialize for this test.\n    await reset_dut(dut)\n\n    # Issue a start pulse for one clock cycle.\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure latency: count the number of clock cycles from after the start pulse until done is asserted.\n    latency = 0\n    while True:\n        await RisingEdge(dut.clk)\n        latency += 1\n        if int(dut.done.value) == 1:\n            break\n\n    # Expected latency in clock cycles for the provided RTL FSM.\n    expected_latency = 20\n    if latency != expected_latency:\n        dut._log.error(\"Test %s FAILED: Expected latency %d cycles, got %d cycles\", test_name, expected_latency, latency)\n        assert False, f\"Latency check failed for test {test_name}: expected {expected_latency}, got {latency}\"\n    else:\n        dut._log.info(\"Latency check passed for test %s: %d cycles\", test_name, latency)\n\n    # Compare the DUT's output with the expected flat vector.\n    out_val = int(dut.out_data.value)\n    if out_val != expected_flat:\n        dut._log.error(\"Test %s FAILED!\", test_name)\n        dut._log.error(\"   Input   : 0x%0*x\", (NUM_ELEMS * width + 3) // 4, input_flat)\n        dut._log.error(\"   Expected: 0x%0*x\", (NUM_ELEMS * width + 3) // 4, expected_flat)\n        dut._log.error(\"   Got     : 0x%0*x\", (NUM_ELEMS * width + 3) // 4, out_val)\n        assert False, f\"Test {test_name} failed: output mismatch!\"\n    else:\n        dut._log.info(\"Test %s PASSED.\", test_name)\n    # Small delay between tests\n    await Timer(10, units=\"ns\")\n\n@cocotb.test()\nasync def test_sorting_engine(dut):\n    \"\"\"\n    Cocotb Testbench for the sorting_engine module.\n    This test applies multiple corner-case test vectors (with each element's width determined by the DUT parameter)\n    and performs a latency check on each test.\n    \"\"\"\n    # Create and start a clock with a 10 ns period.\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Retrieve the WIDTH parameter from the DUT; default to 8 if not available.\n    try:\n        width = int(dut.WIDTH.value)\n    except Exception as e:\n        dut._log.warning(\"Could not get WIDTH from DUT (defaulting to 8). Error: %s\", e)\n        width = 8\n\n    NUM_ELEMS = 8\n    max_val = (1 << width) - 1\n\n    #--------------------------------------------------------------------------\n    # Test 1: Already Sorted\n    # Internal array A: [1, 2, 3, 4, 5, 6, 7, 8]\n    # Ensure values are within the range of the given width.\n    test_in = [min(i, max_val) for i in [1, 2, 3, 4, 5, 6, 7, 8]]\n    expected = sorted(test_in)\n    await run_test(dut, \"Already Sorted\", test_in, expected, width)\n\n    #--------------------------------------------------------------------------\n    # Test 2: Reverse Sorted\n    test_in = [min(i, max_val) for i in [8, 7, 6, 5, 4, 3, 2, 1]]\n    expected = sorted(test_in)\n    await run_test(dut, \"Reverse Sorted\", test_in, expected, width)\n\n    #--------------------------------------------------------------------------\n    # Test 3: Random Unsorted Data\n    test_in = [min(x, max_val) for x in [0x12, 0x34, 0x23, 0x45, 0x67, 0x56, 0x89, 0x78]]\n    expected = sorted(test_in)\n    await run_test(dut, \"Random Unsorted\", test_in, expected, width)\n\n    #--------------------------------------------------------------------------\n    # Test 4: All Elements Equal\n    test_in = [max_val // 2] * NUM_ELEMS\n    expected = [max_val // 2] * NUM_ELEMS\n    await run_test(dut, \"All Equal\", test_in, expected, width)\n\n    #--------------------------------------------------------------------------\n    # Test 5: Edge Values\n    if width == 8:\n        # For WIDTH==8, use specific edge values.\n        test_in = [0x00, 0xFF, 0x10, 0xF0, 0x01, 0xFE, 0x02, 0xFD]\n    else:\n        # Scale the 8-bit edge values to the current width.\n        test_in = [\n            0,\n            max_val,\n            math.floor(0x10 * max_val / 0xFF),\n            math.floor(0xF0 * max_val / 0xFF),\n            1 if max_val >= 1 else 0,\n            math.floor(0xFE * max_val / 0xFF),\n            2 if max_val >= 2 else 0,\n            math.floor(0xFD * max_val / 0xFF)\n        ]\n    expected = sorted(test_in)\n    await run_test(dut, \"Edge Values\", test_in, expected, width)\n\n    #--------------------------------------------------------------------------\n    # Test 6: Consecutive Operations\n    test_in = [min(x, max_val) for x in [9, 3, 15, 1, 10, 2, 11, 4]]\n    expected = sorted(test_in)\n    await run_test(dut, \"Consecutive Operation 1\", test_in, expected, width)\n\n    test_in = [min(x, max_val) for x in [16, 32, 48, 64, 80, 96, 112, 128]]\n    expected = sorted(test_in)\n    await run_test(dut, \"Consecutive Operation 2\", test_in, expected, width)\n"}}
{"id": "cvdp_agentic_spi_complex_mult_0014", "categories": ["cid014", "medium"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\n  You will be given a prompt and your task is to understand it and solve the given issue by using the commands mentioned above as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have an `spi_complex_mult` module located in the `rtl` directory, and its specification is available in the `docs` directory. Please modify the module by adding **SystemVerilog assertions** to ensure it correctly handles SPI communication.\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:\n\n1. **Reset behavior**: Ensure that `rst_async_n` properly resets all necessary signals.\n2. **Bit counter**: Verify that `bit_count` increments correctly with each SPI clock cycle.\n3. **Data readiness**: Check that the `data_ready` flag is asserted at the appropriate time.\n4. **MOSI shift register**: Validate the correct shifting behavior of the `spi_mosi` input.\n5. **Byte counter**: Verify that `byte_count` increments correctly after each byte.\n6. **Operand storage**: Confirm that `shift_reg` data is correctly stored into the operands `Ar`, `Ai`, `Br`, and `Bi`.\n7. **Multiplication result**: Ensure that the parallel multiplier output is valid and stable when expected.\n8. **MISO output**: Verify that the `spi_miso` signal correctly reflects the expected bits of the result based on the protocol.\n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the specific condition that was violated.\n", "context": {"docs/specification.md": "# SPI Slave Complex Multiplication Specification\n\n## Overview\nThe `spi_complex_mult` module implements a SPI Slave module that receives the complex number components Ar, Ai, Br, and Bi (real and imaginary parts) via SPI and performs complex multiplication using DSP operations. The results are stored in internal registers and are transmitted back through SPI. Additionally, the module supports SPI Mode 0 (CPOL=0, CPHA=0).\n\n## Features\n- Receives the complex number components Ar, Ai, Br, and Bi by SPI.\n- Implements a complex multiplication using DSP operations.\n- The results are stored in internal registers and transmitted back through SPI.\n- While transmitting the result of the complex multiplication, the system can simultaneously receive data for the next multiplication.\n- Operates in SPI Mode 0 (CPOL=0, CPHA=0), where data is sampled on the rising edge and transmitted on the falling edge.\n\n## Interface\n\n### Signals Table\n| Signal      | In/Out | Width | Description                                                                |\n|-------------|--------|-------|----------------------------------------------------------------------------|\n| rst_async_n | Input  | 1     | Active low asynchronous reset                                              |\n| spi_sck     | Input  | 1     | SPI clock generated by the SPI master                                      |\n| spi_cs_n    | Input  | 1     | Chip Select \u2013 Active-low signal (0) used by the master to select the slave |\n| spi_mosi    | Input  | 1     | Master Out, Slave In \u2013 Line where the master sends data to the slave       |\n| spi_miso    | Output | 1     | Master In, Slave Out \u2013 Line where the slave sends data to the master       |\n\n### Parameters Table\n| Parameter | Value | Description                  |\n|-----------|-------|------------------------------|\n| IN_WIDTH  | 16    | Bit width of the input data  |\n| OUT_WIDTH | 32    | Bit width of the output data |\n\n## Description of the SPI Protocol (Serial Peripheral Interface)\n\nThe **Serial Peripheral Interface (SPI)** is a **high-speed, full-duplex, synchronous** serial communication protocol used to exchange data between a **master device** and one or more **slave devices**. SPI follows a **master-slave architecture**, where:\n- **The master** controls the communication, generates the clock signal (`spi_sck`), and selects which slave to communicate with.\n- **The slave(s)** respond to the master's requests but do not initiate communication.\n\nSPI transfers data using a **synchronous serial clock (spi_sck)**, allowing data to be **sent and received simultaneously (full-duplex)**. \n\n### SPI Data Transfer Process\n1. **Master selects the slave** by pulling `spi_cs_n` low (`0`).\n2. **Master generates clock pulses (`spi_sck`)** to synchronize the transfer.\n3. **Master sends data via `spi_mosi`**, and the slave **sends data back via `spi_miso`** (if needed).\n4. **Master reads data on `spi_miso`** while transmitting on `spi_mosi`.\n5. **After the transaction**, the master **deactivates the slave (`spi_cs_n` = `1`)**.\n\n### SPI Modes (Clock Configuration)\nThe SPI protocol has **four modes**, controlled by **two bits:**\n- **CPOL (Clock Polarity)**: Determines the idle state of the clock.\n- **CPHA (Clock Phase)**: Determines when data is sampled.\n\n| **Mode** | **CPOL** | **CPHA** | **Clock Idle State** | **Data Captured On** | **Data Changed On** |\n|----------|----------|----------|----------------------|----------------------|---------------------|\n| **0**    | 0        | 0        | Low (`0`)            | Rising edge          | Falling edge        |\n| **1**    | 0        | 1        | Low (`0`)            | Falling edge         | Rising edge         |\n| **2**    | 1        | 0        | High (`1`)           | Falling edge         | Rising edge         |\n| **3**    | 1        | 1        | High (`1`)           | Rising edge          | Falling edge        |\n\nMaster and slave must operate in the same mode to ensure proper data synchronization.\n\n# SPI Master Interface\n\n## Signals Table\n| Signal          | In/Out | Width | Description                                                        |\n|-----------------|--------|-------|--------------------------------------------------------------------|\n| clk             | Input  | 1     | System clock                                                       |\n| rst_async_n     | Input  | 1     | Asynchronous active-low reset                                      |\n| Ar              | Input  | 16    | Real part of data A                                                |\n| Ai              | Input  | 16    | Imaginary part of data A                                           |\n| Br              | Input  | 16    | Real part of data B                                                |\n| Bi              | Input  | 16    | Imaginary part of data B                                           |\n| start           | Input  | 1     | Start signal to initiate transmission                              |\n| slave_select    | Input  | 2     | Sele\u00e7\u00e3o de slave (00: none; 01: slave 0; 10: slave 1; 11: slave 2) |\n| Cr              | Output | 32    | Real part of data C (Result)                                       |\n| Ci              | Output | 32    | Imaginary part of data C (Result)                                  |\n| spi_rst_async_n | Output | 1     | SPI asynchronous active-low reset                                  |\n| spi_sck         | Output | 1     | SPI clock                                                          |\n| spi_cs_n        | Output | 3     | Chip select signals for 3 slaves (active low)                      |\n| spi_mosi        | Output | 1     | Master Out Slave In (data line to slaves)                          |\n| spi_miso        | Input  | 1     | Master In Slave Out (data line from slaves)                        |\n\n## Parameters Table\n| Parameter    | Value | Description                            |   |   |\n|--------------|-------|----------------------------------------|---|---|\n| OP_WIDTH     | 16    | Operands data width in bits            |   |   |\n| RESULT_WIDTH | 32    | Results data width in bits             |   |   |\n| CLK_DIV      | 2     | Clock divider for SPI clock generation |   |   |\n\n# SPI Top Interface\n\n## Signals Table\n| Signal       | In/Out | Width | Description                                             |\n|--------------|--------|-------|---------------------------------------------------------|\n| clk          | Input  | 1     | System clock                                            |\n| rst_async_n  | Input  | 1     | Asynchronous active-low reset                           |\n| start        | Input  | 1     | Start signal to initiate transmission                   |\n| slave_select | Input  | 2     | Slave selection (01: slave 0; 10: slave 1; 11: slave 2) |\n| Ar           | Input  | 16    | Real part of operand A                                  |\n| Ai           | Input  | 16    | Imaginary part of operand A                             |\n| Br           | Input  | 16    | Real part of operand B                                  |\n| Bi           | Input  | 16    | Imaginary part of operand B                             |\n| Cr           | Output | 32    | Real part of result                                     |\n| Ci           | Output | 32    | Imaginary part of result                                |\n\n## Parameters Table\n| Parameter    | Value | Description                            |   |   |\n|--------------|-------|----------------------------------------|---|---|\n| OP_WIDTH     | 16    | Operands data width in bits            |   |   |\n| RESULT_WIDTH | 32    | Results data width in bits             |   |   |\n| CLK_DIV      | 2     | Clock divider for SPI clock generation |   |   |", "rtl/spi_complex_mult.sv": "module spi_complex_mult #(\n    parameter IN_WIDTH  = 'd16, // Parameter defining the input width\n    parameter OUT_WIDTH = 'd32  // Parameter defining the output width\n) (\n    input  logic                 rst_async_n,  // Asynchronous reset signal, active low\n    input  logic                 spi_sck,      // SPI clock signal\n    input  logic                 spi_cs_n,     // SPI chip select signal, active low\n    input  logic                 spi_mosi,     // SPI master out, slave in signal (data from master to slave)\n    output logic                 spi_miso,     // SPI master in, slave out signal (data from slave to master)\n    output logic                 mult_valid_o, // Indicates that the complex multiplication result is valid\n    output logic [OUT_WIDTH-1:0] mult_real_o,  // Real part of the complex multiplication result\n    output logic [OUT_WIDTH-1:0] mult_imag_o   // Imaginary part of the complex multiplication result\n);\n\n    // Internal signals\n    logic signed [IN_WIDTH-1:0] Ar;\n    logic signed [IN_WIDTH-1:0] Ai;\n    logic signed [IN_WIDTH-1:0] Br;\n    logic signed [IN_WIDTH-1:0] Bi;\n\n    logic       data_ready;\n    logic       spi_ready;\n    logic       mult_ready;\n    logic [7:0] shift_reg;\n    logic [2:0] bit_count;\n    logic [2:0] byte_count;\n\n    logic signed [OUT_WIDTH-1:0] mult_real;\n    logic signed [OUT_WIDTH-1:0] mult_imag;\n\n    // Shift register to store incoming SPI MOSI data\n    always_ff @(negedge spi_sck or negedge rst_async_n or negedge spi_cs_n) begin\n        if (!rst_async_n) begin\n            shift_reg <= 'd0;\n            bit_count <= 'd0;\n            data_ready <= 'd0;\n        end else begin\n            if (!spi_cs_n && !data_ready) begin\n                shift_reg <= {shift_reg[6:0], spi_mosi};\n                bit_count <= bit_count + 1'b1;\n            end\n\n            if (bit_count == 3'd7) begin\n                data_ready <= 1'b1;\n            end else begin\n                data_ready <= 1'b0;\n            end\n        end\n    end\n\n    // Store data in the operands\n    always_ff @(posedge spi_sck or negedge rst_async_n) begin\n        if (!rst_async_n) begin\n            byte_count <= 'd0;\n        end else if (data_ready) begin\n            byte_count <= byte_count + 1'b1;\n\n            if (byte_count == 'd0) begin\n                Ar[15:8] <= shift_reg;\n                spi_ready <= 1'b0;\n            end else if (byte_count == 'd1) begin\n                Ar[7:0] <= shift_reg;\n            end else if (byte_count == 'd2) begin\n                Ai[15:8] <= shift_reg;\n            end else if (byte_count == 'd3) begin\n                Ai[7:0] <= shift_reg;\n            end else if (byte_count == 'd4) begin\n                Br[15:8] <= shift_reg;\n            end else if (byte_count == 'd5) begin\n                Br[7:0] <= shift_reg;\n            end else if (byte_count == 'd6) begin\n                Bi[15:8] <= shift_reg;\n            end else if (byte_count == 'd7) begin\n                Bi[7:0] <= shift_reg;\n                spi_ready <= 1'b1;\n            end\n        end\n    end\n\n    // Complex multiplication\n    always_ff @(negedge spi_sck or negedge rst_async_n) begin\n        if (!rst_async_n) begin\n            mult_real  <= 'd0;\n            mult_imag  <= 'd0;\n            mult_ready <= 'd0;\n        end else if (spi_ready) begin\n            mult_real  <= (Ar * Br) - (Ai * Bi);\n            mult_imag  <= (Ar * Bi) + (Ai * Br);\n            mult_ready <= 1'b1;\n        end\n    end\n\n    // Logic for transmitting the data result via the SPI MISO line\n    always_ff @(negedge spi_sck or negedge rst_async_n or negedge spi_cs_n) begin\n        if (!rst_async_n) begin\n            spi_miso <= 'd0;\n        end else if (!spi_cs_n) begin\n            if (byte_count == 'd0) begin\n                spi_miso <= mult_real[32 - (bit_count + 1)];  \n            end else if (byte_count == 'd1) begin\n                spi_miso <= mult_real[24 - (bit_count + 1)];\n            end else if (byte_count == 'd2) begin\n                spi_miso <= mult_real[16 - (bit_count + 1)];\n            end else if (byte_count == 'd3) begin\n                spi_miso <= mult_real[8 - (bit_count + 1)];\n            end else if (byte_count == 'd4) begin\n                spi_miso <= mult_imag[32 - (bit_count + 1)];\n            end else if (byte_count == 'd5) begin\n                spi_miso <= mult_imag[24 - (bit_count + 1)];\n            end else if (byte_count == 'd6) begin\n                spi_miso <= mult_imag[16 - (bit_count + 1)];\n            end else if (byte_count == 'd7) begin\n                spi_miso <= mult_imag[8 - (bit_count + 1)];\n            end\n        end\n    end\n\n    // Drive the output interface signals with multiplication results\n    always_comb begin\n        mult_valid_o = mult_ready;\n        mult_real_o  = mult_real;\n        mult_imag_o  = mult_imag;\n    end\n\nendmodule", "rtl/spi_master.sv": "module spi_master #(\n    parameter OP_WIDTH     = 'd16, // Operands data width in bits\n    parameter RESULT_WIDTH = 'd32, // Results data width in bits\n    parameter CLK_DIV      = 'd2   // Clock divider for SPI clock generation\n)(\n    input  logic                    clk,          // System clock\n    input  logic                    rst_async_n,  // Asynchronous active-low reset\n    input  logic [OP_WIDTH-1:0]     Ar,           // Real part of data A\n    input  logic [OP_WIDTH-1:0]     Ai,           // Imaginary part of data A\n    input  logic [OP_WIDTH-1:0]     Br,           // Real part of data B\n    input  logic [OP_WIDTH-1:0]     Bi,           // Imaginary part of data B\n    input  logic                    start,        // Start signal to initiate transmission\n    input  logic [1:0]              slave_select, // Sele\u00e7\u00e3o de slave (00: none; 01: slave 0; 10: slave 1; 11: slave 2)\n    output logic [RESULT_WIDTH-1:0] Cr,           // Real part of data C (Result)\n    output logic [RESULT_WIDTH-1:0] Ci,           // Imaginary part of data C (Result)\n    // SPI Interface\n    output logic       spi_rst_async_n, // SPI asynchronous active-low reset\n    output logic       spi_sck,         // SPI clock\n    output logic [2:0] spi_cs_n,        // Chip select signals for 3 slaves (active low)\n    output logic       spi_mosi,        // Master Out Slave In (data line to slaves)\n    input  logic       spi_miso         // Master In Slave Out (data line from slaves)\n);\n    // Define FSM states \n    typedef enum logic [2:0] {\n        IDLE,\n        TRANSFER,\n        DONE,\n        UPDATE_REG\n    } state_t;\n\n    state_t state;\n\n    // Internal variables\n    localparam BYTE_WIDTH = 'd8;\n\n    logic [BYTE_WIDTH-1:0] shift_reg;   // Shift register for store a byte\n    logic [2:0]            bit_cnt;     // Bit counter\n    logic [2:0]            byte_cnt;    // Byte counter\n    logic [CLK_DIV-1:0]    clk_div_cnt; // Clock divider counter\n    logic                  spi_clk_ff;  // SPI clock generation\n    logic                  spi_clk_en;  // SPI clock enable\n\n    // Sequential logic of FSM\n    always_ff @(posedge clk or negedge rst_async_n) begin\n        if (!rst_async_n) begin\n            state           <= IDLE;\n            spi_clk_ff      <= 1'b0;\n            spi_cs_n        <= 3'b111; // Deactivate all slaves\n            spi_mosi        <= 1'b0;\n            bit_cnt         <= 'd0;\n            byte_cnt        <= 'd0;\n            clk_div_cnt     <= 'd0;\n            spi_clk_en      <= 1'b0;\n            shift_reg       <= 'd0;\n            Cr              <= 'd0;\n            Ci              <= 'd0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (start) begin\n                        state <= TRANSFER;\n                        case (slave_select)\n                            2'b00: spi_cs_n <= 3'b111; // Activate all slaves\n                            2'b01: spi_cs_n <= 3'b110; // Activate slave 0\n                            2'b10: spi_cs_n <= 3'b101; // Activate slave 1\n                            2'b11: spi_cs_n <= 3'b011; // Activate slave 2                            \n                        endcase\n                        shift_reg   <= {Ar[14:8], 1'b0}; // Load data to shift registers\n                        spi_mosi    <= Ar[15];\n                        bit_cnt     <= BYTE_WIDTH - 1'b1;\n                        byte_cnt    <= 'd0;\n                        clk_div_cnt <= 'd0;\n                        spi_clk_en  <= 1'b1;\n                    end\n                end\n\n                TRANSFER: begin\n                    if (clk_div_cnt == CLK_DIV - 1) begin\n                        clk_div_cnt <= 'd0;\n                        spi_clk_ff  <= ~spi_clk_ff; // Toggle SPI clock\n\n                        if (spi_clk_ff == 1'b0) begin\n                            // On rising edge, sample MISO\n                            case (byte_cnt)\n                                8'd0: Cr[31:24] <= {Cr[30:24], spi_miso};\n                                8'd1: Cr[23:16] <= {Cr[22:16], spi_miso};\n                                8'd2: Cr[15:8]  <= {Cr[14:8] , spi_miso};\n                                8'd3: Cr[7:0]   <= {Cr[6:0]  , spi_miso};\n                                8'd4: Ci[31:24] <= {Ci[30:24], spi_miso};\n                                8'd5: Ci[23:16] <= {Ci[22:16], spi_miso};\n                                8'd6: Ci[15:8]  <= {Ci[14:8] , spi_miso};\n                                8'd7: Ci[7:0]   <= {Ci[6:0]  , spi_miso};\n                            endcase\n                        end else begin\n                            // On falling edge, shift out MOSI\n                            spi_mosi  <= shift_reg[BYTE_WIDTH-1];           // Send MSB of first slave's data\n                            shift_reg <= {shift_reg[BYTE_WIDTH-2:0], 1'b0}; // Shift left\n                            if (bit_cnt == 'd0) begin\n                                state      <= DONE;\n                                spi_clk_en <= 1'b0;\n                            end else begin\n                                bit_cnt <= bit_cnt - 1'b1;\n                            end\n                        end\n                    end else begin\n                        clk_div_cnt <= clk_div_cnt + 1'b1;\n                    end\n                end\n\n                DONE: begin\n                    spi_cs_n <= 3'b111; // Deactivate all slaves\n                    if (byte_cnt == 'd7) begin\n                        state <= IDLE;\n                    end else begin\n                        state <= UPDATE_REG;\n                    end\n                end\n\n                UPDATE_REG: begin\n                    state       <= TRANSFER;\n                    byte_cnt    <= byte_cnt + 1'b1;\n                    bit_cnt     <= BYTE_WIDTH - 1'b1;\n                    clk_div_cnt <= 'd0;\n                    spi_clk_en  <= 1'b1;\n                    case (slave_select)\n                        2'b00: spi_cs_n <= 3'b111; // Activate all slaves\n                        2'b01: spi_cs_n <= 3'b110; // Activate slave 0\n                        2'b10: spi_cs_n <= 3'b101; // Activate slave 1\n                        2'b11: spi_cs_n <= 3'b011; // Activate slave 2                            \n                    endcase\n                    case (byte_cnt)\n                        8'd0: begin\n                            shift_reg <= {Ar[6:0], 1'b0};\n                            spi_mosi  <= Ar[7];\n                        end\n                        8'd1: begin\n                            shift_reg <= {Ai[14:8], 1'b0};\n                            spi_mosi  <= Ai[15];\n                        end\n                        8'd2: begin\n                            shift_reg <= {Ai[6:0], 1'b0};\n                            spi_mosi  <= Ai[7];\n                        end\n                        8'd3: begin\n                            shift_reg <= {Br[14:8], 1'b0};\n                            spi_mosi  <= Br[15];\n                        end\n                        8'd4: begin\n                            shift_reg <= {Br[6:0], 1'b0};\n                            spi_mosi  <= Br[7];\n                        end\n                        8'd5: begin\n                            shift_reg <= {Bi[14:8], 1'b0};\n                            spi_mosi  <= Bi[15];\n                        end\n                        8'd6: begin\n                            shift_reg <= {Bi[6:0], 1'b0};\n                            spi_mosi  <= Bi[7];\n                        end\n                    endcase\n                end\n            endcase\n        end\n    end\n\n    // SPI clock gating\n    assign spi_sck = (spi_clk_en) ? spi_clk_ff : 1'b0;\n\n    // Drive the asynchronous active-low reset\n    assign spi_rst_async_n = rst_async_n;\n\nendmodule", "rtl/spi_top.sv": "module spi_top #(\n    parameter OP_WIDTH     = 16, // Operands data width in bits\n    parameter RESULT_WIDTH = 32, // Results data width in bits\n    parameter CLK_DIV      = 2   // Clock divider for SPI clock generation\n)(\n    input  logic                    clk,          // System clock\n    input  logic                    rst_async_n,  // Asynchronous active-low reset\n    // Control Interface\n    input  logic                    start,        // Start signal to initiate transmission\n    input  logic [1:0]              slave_select, // Slave selection (01: slave 0; 10: slave 1; 11: slave 2)\n    // Data Inputs\n    input  logic [OP_WIDTH-1:0]     Ar,           // Real part of operand A\n    input  logic [OP_WIDTH-1:0]     Ai,           // Imaginary part of operand A\n    input  logic [OP_WIDTH-1:0]     Br,           // Real part of operand B\n    input  logic [OP_WIDTH-1:0]     Bi,           // Imaginary part of operand B\n    // Data Outputs\n    output logic [RESULT_WIDTH-1:0] Cr,           // Real part of result\n    output logic [RESULT_WIDTH-1:0] Ci            // Imaginary part of result\n);\n\n    // SPI Master Interface Signals\n    logic       spi_rst_async_n;\n    logic       spi_sck;\n    logic [2:0] spi_cs_n;\n    logic       spi_mosi;\n    logic       spi_miso;\n    \n    // Individual slave MISO signals\n    logic slave0_miso;\n    logic slave1_miso;\n    logic slave2_miso;\n    \n    // SPI Master\n    spi_master #(\n        .OP_WIDTH     (OP_WIDTH     ),\n        .RESULT_WIDTH (RESULT_WIDTH ),\n        .CLK_DIV      (CLK_DIV      )\n    ) u_spi_master (\n        .clk             (clk            ),\n        .rst_async_n     (rst_async_n    ),\n        .Ar              (Ar             ),\n        .Ai              (Ai             ),\n        .Br              (Br             ),\n        .Bi              (Bi             ),\n        .start           (start          ),\n        .slave_select    (slave_select   ),\n        .Cr              (Cr             ),\n        .Ci              (Ci             ),\n        .spi_rst_async_n (spi_rst_async_n),\n        .spi_sck         (spi_sck        ),\n        .spi_cs_n        (spi_cs_n       ),\n        .spi_mosi        (spi_mosi       ),\n        .spi_miso        (spi_miso       )\n    );\n    \n    // SPI Slave 0\n    spi_complex_mult #(\n        .IN_WIDTH  (OP_WIDTH    ),\n        .OUT_WIDTH (RESULT_WIDTH)\n    ) uu_spi_slave_0 (\n        .rst_async_n (spi_rst_async_n),\n        .spi_sck     (spi_sck        ),\n        .spi_cs_n    (spi_cs_n[0]    ),\n        .spi_mosi    (spi_mosi       ),\n        .spi_miso    (slave0_miso    )\n    );\n\n    // SPI Slave 1\n    spi_complex_mult #(\n        .IN_WIDTH  (OP_WIDTH    ),\n        .OUT_WIDTH (RESULT_WIDTH)\n    ) uu_spi_slave_1 (\n        .rst_async_n (spi_rst_async_n),\n        .spi_sck     (spi_sck        ),\n        .spi_cs_n    (spi_cs_n[1]    ),\n        .spi_mosi    (spi_mosi       ),\n        .spi_miso    (slave1_miso    )\n    );\n\n    // SPI Slave 2\n    spi_complex_mult #(\n        .IN_WIDTH  (OP_WIDTH    ),\n        .OUT_WIDTH (RESULT_WIDTH)\n    ) uu_spi_slave_2 (\n        .rst_async_n (spi_rst_async_n),\n        .spi_sck     (spi_sck        ),\n        .spi_cs_n    (spi_cs_n[2]    ),\n        .spi_mosi    (spi_mosi       ),\n        .spi_miso    (slave2_miso    )\n    );\n    \n    // MISO multiplexer - only selected slave drives the line\n    always_comb begin\n        if (!spi_cs_n[0]) begin\n            spi_miso = slave0_miso;\n        end else if (!spi_cs_n[1]) begin\n            spi_miso = slave1_miso;\n        end else if (!spi_cs_n[2]) begin\n            spi_miso = slave2_miso;\n        end else begin\n            spi_miso = 1'bz; // High impedance when no slave selected\n        end\n    end\n\nendmodule", "verif/spi_complex_mult_tb.sv": "module spi_complex_mult_tb();\n\n    // Parameters\n    parameter IN_WIDTH   = 'd16;\n    parameter OUT_WIDTH  = 'd32;\n    parameter CLK_PERIOD = 'd10;\n\n    // SPI signals\n    logic                 rst_async_n;\n    logic                 spi_sck;\n    logic                 spi_cs_n;\n    logic                 spi_mosi;\n    logic                 spi_miso;\n    logic                 mult_valid_o;\n    logic [OUT_WIDTH-1:0] mult_real_o;\n    logic [OUT_WIDTH-1:0] mult_imag_o;\n\n    logic                 spi_sck_cg;\n    logic                 spi_sck_en;\n\n    // Instantiate DUT\n    spi_complex_mult #(\n        .IN_WIDTH  (IN_WIDTH ),\n        .OUT_WIDTH (OUT_WIDTH)\n    ) dut (\n        .rst_async_n  (rst_async_n ),\n        .spi_sck      (spi_sck_cg  ),\n        .spi_cs_n     (spi_cs_n    ),\n        .spi_mosi     (spi_mosi    ),\n        .spi_miso     (spi_miso    ),\n        .mult_valid_o (mult_valid_o),\n        .mult_real_o  (mult_real_o ),\n        .mult_imag_o  (mult_imag_o )\n    );\n\n    // Testbench signals\n    parameter CYCLES = 100;\n    int       errors = 0;\n\n    logic [7:0] msb_Ar;\n    logic [7:0] lsb_Ar;\n    logic [7:0] msb_Ai;\n    logic [7:0] lsb_Ai;\n    logic [7:0] msb_Br;\n    logic [7:0] lsb_Br;\n    logic [7:0] msb_Bi;\n    logic [7:0] lsb_Bi;\n\n    logic signed [IN_WIDTH-1:0] Ar;\n    logic signed [IN_WIDTH-1:0] Ai;\n    logic signed [IN_WIDTH-1:0] Br;\n    logic signed [IN_WIDTH-1:0] Bi;\n\n    logic signed [OUT_WIDTH-1:0] expected_real;\n    logic signed [OUT_WIDTH-1:0] expected_imag;\n\n    logic [7:0] byte3_Cr;\n    logic [7:0] byte2_Cr;\n    logic [7:0] byte1_Cr;\n    logic [7:0] byte0_Cr;\n    logic [7:0] byte3_Ci;\n    logic [7:0] byte2_Ci;\n    logic [7:0] byte1_Ci;\n    logic [7:0] byte0_Ci;\n    \n    int received_real;\n    int received_imag;\n\n    // Clock generation\n    initial begin\n        spi_sck    = 0;\n        spi_sck_en = 0;\n    end\n    always begin\n        #(CLK_PERIOD / 2) spi_sck = ~spi_sck;\n        assign spi_sck_cg = (spi_sck_en) ? spi_sck : 1'b0;\n    end\n\n    // Task to send one byte over SPI\n    task automatic spi_send_byte(input byte data);\n        @(negedge spi_sck);\n        spi_cs_n   = 0;\n        spi_sck_en = 1;\n\n        for (int i = 7; i >= 0; i--) begin\n            spi_mosi = data[i];\n            @(negedge spi_sck or negedge spi_cs_n);\n        end\n        \n        #(CLK_PERIOD / 2)\n        spi_sck_en = 0;\n        spi_cs_n   = 1;\n    endtask\n\n    // Task to read one byte from MISO\n    task automatic spi_read_byte(output byte data);\n        @(negedge spi_sck);\n        spi_cs_n   = 0;\n        spi_sck_en = 1;\n        data = 0;\n\n        for (int i = 7; i >= 0; i--) begin\n            @(posedge spi_sck);\n            data[i] = spi_miso;\n        end\n        \n        #(CLK_PERIOD)\n        spi_sck_en = 0;\n        spi_cs_n   = 1;\n    endtask\n\n    // Convert a 16-bit signed number from two bytes\n    function signed [IN_WIDTH-1:0] combine16(input byte msb, input byte lsb);\n        return {msb, lsb};\n    endfunction\n\n    // Compute complex multiplication\n    task reference_complex_mult(\n        input  signed [IN_WIDTH-1:0]  Ar,\n        input  signed [IN_WIDTH-1:0]  Ai,\n        input  signed [IN_WIDTH-1:0]  Br,\n        input  signed [IN_WIDTH-1:0]  Bi,\n        output signed [OUT_WIDTH-1:0] Cr,\n        output signed [OUT_WIDTH-1:0] Ci\n    );\n        Cr = (Ar * Br) - (Ai * Bi);\n        Ci = (Ar * Bi) + (Ai * Br);\n    endtask\n\n    // Main task procedure\n    task main();\n        // Generate random input values\n        msb_Ar = $urandom_range(0, 255);\n        lsb_Ar = $urandom_range(0, 255);\n        msb_Ai = $urandom_range(0, 255);\n        lsb_Ai = $urandom_range(0, 255);\n        msb_Br = $urandom_range(0, 255);\n        lsb_Br = $urandom_range(0, 255);\n        msb_Bi = $urandom_range(0, 255);\n        lsb_Bi = $urandom_range(0, 255);\n\n        Ar = combine16(msb_Ar, lsb_Ar);\n        Ai = combine16(msb_Ai, lsb_Ai);\n        Br = combine16(msb_Br, lsb_Br);\n        Bi = combine16(msb_Bi, lsb_Bi);\n\n        reference_complex_mult(Ar, Ai, Br, Bi, expected_real, expected_imag);\n\n        // Apply reset\n        spi_cs_n = 1;\n        spi_mosi = 0;\n        rst_async_n = 0;\n        repeat (5) @(posedge spi_sck);\n        rst_async_n = 1;\n\n        // Verify signal values after reset\n        if (dut.shift_reg  !== 0 ||\n            dut.bit_count  !== 0 ||\n            dut.data_ready !== 0 ||\n            dut.byte_count !== 0 ||\n            spi_miso       !== 0 ||\n            mult_real_o    !== 0 ||\n            mult_imag_o    !== 0 ||\n            mult_valid_o   !== 0    ) begin\n            $error(1, \"[FAIL] Signals not properly reset.\");\n            errors += 1;\n        end\n\n        $display(\"[INFO] Reset completed. Starting SPI transaction...\");\n\n        // First transaction \u2014 send operands\n        spi_send_byte(msb_Ar);\n        spi_send_byte(lsb_Ar);\n        spi_send_byte(msb_Ai);\n        spi_send_byte(lsb_Ai);\n        spi_send_byte(msb_Br);\n        spi_send_byte(lsb_Br);\n        spi_send_byte(msb_Bi);\n        spi_send_byte(lsb_Bi);\n\n        // Check the parallel outputs (mult_real_o and mult_imag_o)\n        if (mult_real_o !== expected_real || mult_imag_o !== expected_imag) begin\n            $display(\"[FAIL] Parallel outputs do not match expected values:\");\n            $display(\"       mult_real_o = 0x%08X, expected = 0x%08X\", mult_real_o, expected_real);\n            $display(\"       mult_imag_o = 0x%08X, expected = 0x%08X\", mult_imag_o, expected_imag);\n            $error(1, \"Parallel output mismatch.\");\n            errors += 1;\n        end else begin\n            $display(\"[PASS] Parallel outputs match expected values.\");\n        end\n\n        // Second transaction \u2014 read result from MISO\n        spi_read_byte(byte3_Cr);\n        spi_read_byte(byte2_Cr);\n        spi_read_byte(byte1_Cr);\n        spi_read_byte(byte0_Cr);\n        spi_read_byte(byte3_Ci);\n        spi_read_byte(byte2_Ci);\n        spi_read_byte(byte1_Ci);\n        spi_read_byte(byte0_Ci);\n\n        @(negedge spi_sck);\n        received_real = {byte3_Cr, byte2_Cr, byte1_Cr, byte0_Cr};\n        received_imag = {byte3_Ci, byte2_Ci, byte1_Ci, byte0_Ci};\n\n        $display(\"[INFO] Result received from spi_miso:\");\n        $display(\"  Cr = 0x%08X\", received_real);\n        $display(\"  Ci = 0x%08X\", received_imag);\n\n        // Validate the MISO results\n        if (received_real !== expected_real) begin\n            $display(\"[FAIL] Real part mismatch: expected 0x%08X, got 0x%08X\", expected_real, received_real);\n            $error(1, \"Test failed due to Cr mismatch.\");\n            errors += 1;\n        end else begin\n            $display(\"[PASS] Real part matches expected result.\");\n        end\n\n        if (received_imag !== expected_imag) begin\n            $display(\"[FAIL] Imaginary part mismatch: expected 0x%08X, got 0x%08X\", expected_imag, received_imag);\n            $error(1, \"Test failed due to Ci mismatch.\");\n            errors += 1;\n        end else begin\n            $display(\"[PASS] Imaginary part matches expected result.\");\n        end\n    endtask\n\n    initial begin\n        repeat(CYCLES) main();\n        if (errors == 0) begin\n            $display(\"Testbench PASSED all tests!!!\");\n        end else begin\n            $display(\"Testbench finished with %d errors!!!\", errors);\n        end\n        $finish;\n    end\n\n    initial begin\n        $dumpfile(\"waveform.vcd\");\n        $dumpvars(0, spi_complex_mult_tb);\n    end\nendmodule"}, "patch": {"rtl/spi_complex_mult.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest -o cache_dir=/code/rundir/.cache /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/spi_complex_mult.sv\nTOPLEVEL        = spi_complex_mult\nMODULE          = test_spi_complex_mult\nPYTHONPATH      = /src\nHASH            = 14-cid014---rtl-assertion-generation", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\nIN_WIDTH = os.getenv(\"IN_WIDTH\", 16)\nOUT_WIDTH = os.getenv(\"OUT_WIDTH\", 32)\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=False,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        parameters={\n            \"IN_WIDTH\": IN_WIDTH,\n            \"OUT_WIDTH\": OUT_WIDTH\n                    },\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=False\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n", "src/test_spi_complex_mult.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nfrom cocotb.clock import Clock\nimport logging\n\nasync def gated_clock(dut, clk_enable):\n    while True:\n        if clk_enable:\n            dut.spi_sck.value = 0\n            await Timer(5, units=\"ns\")\n            dut.spi_sck.value = 1\n            await Timer(5, units=\"ns\")\n        else:\n            dut.spi_sck.value = 0\n            await Timer(10, units=\"ns\")\n\nasync def send_byte(dut, data_in):\n    \"\"\"\n    Sends a byte (8 bits) via SPI using bit-banging.\n\n    Args:\n        dut: The Device Under Test (DUT) instance.\n        data_in (int): The 8-bit data to send via MOSI.\n\n    Usage:\n        received_data = []\n        await send_byte(dut, 0xA5)\n    \"\"\"\n    \n    # Ensure CS (Chip Select) is active (low)\n    await FallingEdge(dut.spi_sck)  # Wait for a stable clock\n    dut.spi_cs_n.value = 0\n    clk_enable = 1\n\n    for i in range(8):\n        # Set MOSI bit (MSB first)\n        dut.spi_mosi.value = (data_in >> (7 - i)) & 1\n        await Timer(10, units=\"ns\")  # Wait for clock falling edge\n\n    # Deactivate CS after transmission\n    await RisingEdge(dut.spi_sck)\n    dut.spi_cs_n.value = 1\n    clk_enable = 0\n\nasync def send_receive_byte(dut, data_in, data_out):\n    \"\"\"\n    Sends a byte (8 bits) via SPI using bit-banging and simultaneously reads a byte.\n\n    Args:\n        dut: The Device Under Test (DUT) instance.\n        data_in (int): The 8-bit data to send via MOSI.\n        data_out (list): A mutable list to store the received 8-bit data from MISO.\n\n    Usage:\n        received_data = []\n        await send_receive_byte(dut, 0xA5, received_data)\n        print(f\"Received: {hex(received_data[0])}\")\n    \"\"\"\n    \n    # Ensure CS (Chip Select) is active (low)\n    await FallingEdge(dut.spi_sck)  # Wait for a stable clock\n    dut.spi_cs_n.value = 0\n    clk_enable = 1\n\n    received = 0  # Variable to store the received byte\n\n    for i in range(8):\n        # Set MOSI bit (MSB first)\n        dut.spi_mosi.value = (data_in >> (7 - i)) & 1\n\n        # Read MISO bit (MSB first)\n        await Timer(5, units=\"ns\")  # Wait for clock falling edge\n        received = (received << 1) | int(dut.spi_miso.value)\n\n        await Timer(5, units=\"ns\")  # Wait for clock falling edge\n\n    # Store the received data in the list (so it can be accessed outside the function)\n    data_out.append(received)\n\n    # Deactivate CS after transmission\n    await RisingEdge(dut.spi_sck)\n    #await Timer(5, units=\"ns\")\n    dut.spi_cs_n.value = 1\n    clk_enable = 0\n\ndef complex_multiply(msb_Ar, lsb_Ar, msb_Ai, lsb_Ai, msb_Br, lsb_Br, msb_Bi, lsb_Bi):\n    \"\"\"\n    Combines two separate bytes into signed 16-bit integers for Ar, Ai, Br, Bi\n    and performs complex multiplication.\n\n    Args:\n        msb_Ar, lsb_Ar (int): Most and least significant bytes for Ar.\n        msb_Ai, lsb_Ai (int): Most and least significant bytes for Ai.\n        msb_Br, lsb_Br (int): Most and least significant bytes for Br.\n        msb_Bi, lsb_Bi (int): Most and least significant bytes for Bi.\n\n    Returns:\n        tuple: (Cr, Ci) - The real and imaginary parts of the complex multiplication result.\n    \"\"\"\n\n    # Combine MSB and LSB into a signed 16-bit integer\n    Ar = int.from_bytes([msb_Ar, lsb_Ar], byteorder='big', signed=True)\n    Ai = int.from_bytes([msb_Ai, lsb_Ai], byteorder='big', signed=True)\n    Br = int.from_bytes([msb_Br, lsb_Br], byteorder='big', signed=True)\n    Bi = int.from_bytes([msb_Bi, lsb_Bi], byteorder='big', signed=True)\n\n    # Perform complex multiplication\n    Cr = (Ar * Br) - (Ai * Bi)  # Real part\n    Ci = (Ar * Bi) + (Ai * Br)  # Imaginary part\n\n    return Cr, Ci  # Return the result as a tuple\n\ndef check_condition(condition, fail_msg, pass_msg, test_failures):\n    \"\"\"Helper function to log test results\"\"\"\n    if not condition:\n        logging.getLogger().error(fail_msg)\n        test_failures.append(fail_msg)\n    else:\n        logging.getLogger().info(pass_msg)\n\n@cocotb.test()\nasync def test1(dut):\n    \"\"\"Test 1: Send operands bytes and compare complex multiplication\"\"\"\n\n    logger = dut._log\n    logger.setLevel(logging.INFO)\n    logger.info(\"Test 1: Send operands bytes and compare complex multiplication\")\n\n    # Retrieve IN_WIDTH and OUT_WIDTH from DUT parameters\n    IN_WIDTH = int(dut.IN_WIDTH.value)\n    OUT_WIDTH = int(dut.OUT_WIDTH.value)\n\n    # Reset\n    dut.spi_cs_n.value = 1\n    dut.rst_async_n.value = 0\n    await Timer(50, units='ns')  # Hold reset low for 50 ns\n    dut.rst_async_n.value = 1\n\n    # Start the clock\n    clk_enable = 1\n    cocotb.start_soon(gated_clock(dut, clk_enable))\n\n    # Wait for reset deassertion\n    await RisingEdge(dut.spi_sck)\n\n    # Send the bytes to perform the complex multiplication\n    msb_Ar = 0xA5  # Write a byte\n    lsb_Ar = 0xF2  # Write a byte\n    msb_Ai = 0xB3  # Write a byte\n    lsb_Ai = 0x08  # Write a byte\n    msb_Br = 0xFF  # Write a byte\n    lsb_Br = 0x42  # Write a byte\n    msb_Bi = 0x77  # Write a byte\n    lsb_Bi = 0x2C  # Write a byte\n\n    await send_byte(dut, msb_Ar)\n    await send_byte(dut, lsb_Ar)\n    await send_byte(dut, msb_Ai)\n    await send_byte(dut, lsb_Ai)\n    await send_byte(dut, msb_Br)\n    await send_byte(dut, lsb_Br)\n    await send_byte(dut, msb_Bi)\n    await send_byte(dut, lsb_Bi)\n\n    # Perform complex multiplication\n    expected_real, expected_imag = complex_multiply(msb_Ar, lsb_Ar, msb_Ai, lsb_Ai, msb_Br, lsb_Br, msb_Bi, lsb_Bi)\n\n    # Receive the result multiplication while send another bytes\n    byte_3_Cr = []\n    byte_2_Cr = []\n    byte_1_Cr = []\n    byte_0_Cr = []\n    byte_3_Ci = []\n    byte_2_Ci = []\n    byte_1_Ci = []\n    byte_0_Ci = []\n    await send_receive_byte(dut, msb_Ar, byte_3_Cr)\n    await send_receive_byte(dut, msb_Ar, byte_2_Cr)\n    await send_receive_byte(dut, msb_Ar, byte_1_Cr)\n    await send_receive_byte(dut, msb_Ar, byte_0_Cr)\n    await send_receive_byte(dut, msb_Ar, byte_3_Ci)\n    await send_receive_byte(dut, msb_Ar, byte_2_Ci)\n    await send_receive_byte(dut, msb_Ar, byte_1_Ci)\n    await send_receive_byte(dut, msb_Ar, byte_0_Ci)\n\n    Cr = int.from_bytes([int(byte_3_Cr[0]), int(byte_2_Cr[0]), int(byte_1_Cr[0]), int(byte_0_Cr[0])], byteorder='big', signed=True)\n    Ci = int.from_bytes([int(byte_3_Ci[0]), int(byte_2_Ci[0]), int(byte_1_Ci[0]), int(byte_0_Ci[0])], byteorder='big', signed=True)\n    \n    # Initialize list to collect failures\n    test_failures = []\n\n    # Check Data Output Real\n    check_condition(\n        Cr == expected_real,\n        f\"FAIL: Data Output Real mismatch. Expected: 0x{expected_real}, \"\n        f\"Got: 0x{Cr}\",\n        f\"PASS: Data Output Real value: 0x{Cr}\",\n        test_failures\n    )\n\n    # Check Data Output Imaginary\n    check_condition(\n        Ci == expected_imag,\n        f\"FAIL: Data Output Imaginary mismatch. Expected: 0x{expected_imag}, \"\n        f\"Got: 0x{Ci}\",\n        f\"PASS: Data Output Imaginary value: 0x{Ci}\",\n        test_failures\n    )\n    \n    # Report failures if any\n    if test_failures:\n        failure_message = \"\\n\".join(test_failures)\n        logger.error(f\"Test 1 completed with failures:\\n{failure_message}\")\n        assert False, f\"Some test cases failed. Check the log for details:\\n{failure_message}\"\n    else:\n        logger.info(\"Test 1 completed successfully\")"}}
{"id": "cvdp_agentic_ttc_lite_0004", "categories": ["cid014", "medium"], "system_message": " You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n - **Update the file content** by using:\n    - `sed -i '3s/old/new/' file.txt`\n  - **Find current working directory** by using:\n    - `pwd`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch to highlight the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take)\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "I have a `ttc_counter_lite` module available in the `rtl` directory. Kindly modify the module by adding SystemVerilog Assertions (SVA) to check its internal functionality comprehensively. The assertions should verify the following conditions:\n\n- **Reset Consistency:** Upon `reset`, all internal registers  must be cleared to their default values.\n- **Prescaler Logic:** After a valid write to the ADDR_PRESCALER register, the internal prescaler must reflect the written value in the next cycle.\n- **Match Value Behavior:** After writing to the ADDR_MATCH_VALUE register, the match_value must be updated correctly in the next cycle.\n- **Reload Value Behavior:** After writing to the ADDR_RELOAD_VALUE register, the reload_value must reflect the correct value in the next cycle.\n- **Control Register Behavior:** A write to the ADDR_CONTROL register should correctly update the enable, interval_mode, and interrupt_enable bits.\n- **Interrupt Generation:** When count equals match_value and interrupt_enable is set, the interrupt signal must be asserted.\n- **Interrupt Clear:** Writing to the ADDR_STATUS register while `axi_write_en` is high must clear the interrupt signal in the next cycle.\n- **Counter Range Validity:** The counter must remain within the range of [reload_value, match_value] while enabled, especially in interval mode.\n- **Read Behavior Consistency:** Ensure that AXI reads from known addresses return the correct content as per the internal register values.\n\nIf any of these conditions are violated during simulation, an appropriate error message should be displayed.\n", "context": {"docs/specification.md": "# ttc_counter_lite Specification Document\n\n## Introduction\n\nThe **ttc_counter_lite** module implements a lightweight, programmable timer with support for **interval and single-shot counting modes**. It includes a 16-bit up-counter, configurable match and reload registers, a programmable prescaler, and an interrupt generation mechanism. The module is controlled through a **simple AXI-like register interface**.\n\nThis timer is useful for general-purpose timing operations, including periodic interrupts, timeouts, and system heartbeats.\n\n---\n\n## Functional Overview\n\nThe timer counts system clock cycles and generates an interrupt when the count value matches a programmable `match_value`. Optionally, in **interval mode**, the counter reloads a pre-programmed `reload_value` and continues counting.\n\nKey features include:\n\n- Start/stop control via `enable` bit.\n- **Prescaler** to divide the input clock.\n- **Interrupt output** that asserts when a match occurs.\n- **Register interface** for runtime configuration and monitoring.\n\n---\n\n## Example Operation\n\n1. Set `match_value` to 1000.\n2. Set `reload_value` to 500.\n3. Set `prescaler` to 3 (divide-by-4 behavior).\n4. Enable **interval mode** and **interrupt** via the `control` register.\n5. When `count` reaches 1000, an interrupt is generated and the counter resets to 500.\n\n---\n\n## Module Interface\n\n```verilog\nmodule ttc_counter_lite (\n    input wire         clk,\n    input wire         reset,\n    input wire [3:0]   axi_addr,\n    input wire [31:0]  axi_wdata,\n    input wire         axi_write_en,\n    input wire         axi_read_en,\n    output reg [31:0]  axi_rdata,\n    output reg         interrupt\n);\n```\n## Port Description\n\n| Port Name     | Direction | Width   | Description                                |\n|---------------|-----------|---------|--------------------------------------------|\n| `clk`         | Input     | 1 bit   | System clock                               |\n| `reset`       | Input     | 1 bit   | Active-high synchronous reset              |\n| `axi_addr`    | Input     | 4 bits  | Address input for read/write access        |\n| `axi_wdata`   | Input     | 32 bits | Data to be written to register             |\n| `axi_write_en`| Input     | 1 bit   | Write enable signal                        |\n| `axi_read_en` | Input     | 1 bit   | Read enable signal                         |\n| `axi_rdata`   | Output    | 32 bits | Data read from selected register           |\n| `interrupt`   | Output    | 1 bit   | Asserted when count reaches match_value    |\n\n---\n\n## Register Map\n\n| Address | Name           | Access | Description                                         |\n|---------|----------------|--------|-----------------------------------------------------|\n| `0x0`   | COUNT          | R      | Current value of the 16-bit counter                |\n| `0x1`   | MATCH_VALUE    | R/W    | Target value at which the timer will trigger       |\n| `0x2`   | RELOAD_VALUE   | R/W    | Reload value when in interval mode                 |\n| `0x3`   | CONTROL        | R/W    | Timer control: enable, mode, interrupt enable      |\n| `0x4`   | STATUS         | R/W    | Interrupt status; write to clear                   |\n| `0x5`   | PRESCALER      | R/W    | Prescaler value for input clock division (4 bits)  |\n\n---\n\n## Control Register Description\n\nBits `[2:0]` of the `CONTROL` register define timer behavior:\n\n| Bit Index | Field Name        | Description                              |\n|-----------|-------------------|------------------------------------------|\n| 0         | `enable`          | Starts the counter when set              |\n| 1         | `interval_mode`   | Enables automatic reloading              |\n| 2         | `interrupt_enable`| Enables interrupt output on match        |\n\n---\n\n## Internal Architecture\n\n### Counter Unit\nA 16-bit register that increments on each prescaler pulse. If `interval_mode` is enabled and a match occurs, it reloads from `reload_value`.\n\n### Prescaler Logic\nDivides the input clock by `(prescaler + 1)` to control the counting frequency.\n\n### Interrupt Generator\nWhen the counter matches `match_value` and `interrupt_enable` is asserted, the `interrupt` output is driven high.\n\n### AXI-Like Register Access\nSupports independent read and write paths. Registers are accessed through the `axi_addr` interface.\n\n---\n\n## Timing and Latency\n\n- Counter increments based on prescaler frequency.\n- Interrupt is asserted within **1 clock cycle** after `count == match_value`.\n- In **interval mode**, counter reloads and continues counting after match.\n- All register **reads/writes are handled in 1 clock cycle**.\n\n---", "rtl/ttc_counter_lite.sv": "`timescale 1ns / 1ps\nmodule ttc_counter_lite (\n    input wire          clk,                // Clock signal\n    input wire          reset,              // Reset signal\n    input wire [3:0]    axi_addr,           // AXI address for read/write\n    input wire [31:0]   axi_wdata,          // AXI write data\n    input wire          axi_write_en,       // AXI write enable\n    input wire          axi_read_en,        // AXI read enable\n    output reg [31:0]   axi_rdata,          // AXI read data\n    output reg          interrupt           // Interrupt signal\n);\n\n    // Timer registers\n    reg [15:0] count;                       // Counter register\n    reg [15:0] match_value;                 // Match value for interval mode\n    reg [15:0] reload_value;                // Reload value in interval mode\n    reg        enable;                      // Timer enable flag\n    reg        interval_mode;               // Interval mode enable flag\n    reg        interrupt_enable;            // Interrupt enable flag\n    reg [3:0]  prescaler;                   // Prescaler value\n    reg [3:0]  prescaler_count;             // Prescaler counter\n\n    // Address map\n    localparam ADDR_COUNT        = 4'b0000; // Counter register (read only)\n    localparam ADDR_MATCH_VALUE  = 4'b0001; // Match value register\n    localparam ADDR_RELOAD_VALUE = 4'b0010; // Reload value register\n    localparam ADDR_CONTROL      = 4'b0011; // Control register\n    localparam ADDR_STATUS       = 4'b0100; // Status register\n    localparam ADDR_PRESCALER    = 4'b0101; // Prescaler register\n\n    // Interrupt flag\n    reg match_flag;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            prescaler_count <= 4'b0;\n\t\tcount    <= 16'b0;   \n    end else if (enable) begin\n            if (prescaler_count == prescaler) begin\n                prescaler_count <= 4'b0;\n                if (interval_mode && match_flag) begin\n                    count <= reload_value;\n                end \n                else if (count != match_value) begin\n                    count <= count + 16'b1;  \n                end\n            end else begin\n                prescaler_count <= prescaler_count + 4'b1; \n            end\n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            match_flag <= 1'b0; \n        end else begin\n            match_flag <= (count == match_value); \n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            interrupt <= 1'b0; \n        end else if (match_flag && interrupt_enable) begin\n            interrupt <= 1'b1; \n        end else if (axi_write_en && axi_addr == ADDR_STATUS) begin\n            interrupt <= 1'b0; \n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            match_value      <= 16'b0; \n            reload_value     <= 16'b0; \n            enable           <= 1'b0; \n            interval_mode    <= 1'b0; \n            interrupt_enable <= 1'b0; \n            prescaler        <= 4'b0; \n        end else if (axi_write_en) begin\n            case (axi_addr)\n                ADDR_MATCH_VALUE:  match_value      <= axi_wdata[15:0]; \n                ADDR_RELOAD_VALUE: reload_value     <= axi_wdata[15:0]; \n                ADDR_CONTROL: begin\n                    enable           <= axi_wdata[0]; \n                    interval_mode    <= axi_wdata[1]; \n                    interrupt_enable <= axi_wdata[2]; \n                end\n                ADDR_PRESCALER: prescaler <= axi_wdata[3:0]; \n                default: ; \n            endcase\n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            axi_rdata <= 32'b0; \n        end else if (axi_read_en) begin\n            case (axi_addr)\n                ADDR_COUNT:        axi_rdata <= {16'b0, count};       \n                ADDR_MATCH_VALUE:  axi_rdata <= {16'b0, match_value}; \n                ADDR_RELOAD_VALUE: axi_rdata <= {16'b0, reload_value}; \n                ADDR_CONTROL:      axi_rdata <= {29'b0, interrupt_enable, interval_mode, enable}; \n                ADDR_STATUS:       axi_rdata <= {31'b0, interrupt};   \n                ADDR_PRESCALER:    axi_rdata <= {28'b0, prescaler};  \n                default:           axi_rdata <= 32'b0;               \n            endcase\n        end\n    end\n\nendmodule", "verif/ttc_counter_lite_tb.sv": "`timescale 1ns / 1ps\n\nmodule ttc_counter_lite_tb;\n    \n    reg clk;                    // Clock signal\n    reg reset;                  // Reset signal\n    reg [3:0] axi_addr;         // AXI address\n    reg [31:0] axi_wdata;       // AXI write data\n    reg axi_write_en;           // AXI write enable\n    reg axi_read_en;            // AXI read enable\n    wire [31:0] axi_rdata;      // AXI read data\n    wire interrupt;             // Interrupt signal\n\n    // Instantiate the DUT (Device Under Test)\n    ttc_counter_lite uut (\n        .clk(clk),\n        .reset(reset),\n        .axi_addr(axi_addr),\n        .axi_wdata(axi_wdata),\n        .axi_write_en(axi_write_en),\n        .axi_read_en(axi_read_en),\n        .axi_rdata(axi_rdata),\n        .interrupt(interrupt)\n    );\n\n    // Clock generation: Generates a 100 MHz clock (10 ns period)\n    always begin\n        #5 clk = ~clk;\n    end\n\n    initial begin\n        clk = 0;\n        reset = 1;\n        axi_addr = 4'b0;\n        axi_wdata = 32'b0;\n        axi_write_en = 0;\n        axi_read_en = 0;\n        #20;\n        reset = 0;\n\n        axi_addr = 4'b0001; \n        axi_wdata = 32'h0000008; \n        axi_write_en = 1;\n        #10 axi_write_en = 0;\n        \n        axi_addr = 4'b0010; \n        axi_wdata = 32'h00000006; \n        axi_write_en = 1;\n        #10 axi_write_en = 0;\n\n        axi_addr = 4'b0011; \n        axi_wdata = 32'h00000007; \n        axi_write_en = 1;\n        #10 axi_write_en = 0;\n\n        axi_addr = 4'b0101; \n        axi_wdata = 32'h00000003; \n        axi_write_en = 1;\n        #10 axi_write_en = 0;\n\n        #200; \n        axi_addr = 4'b0000; \n        axi_read_en = 1;\n        #90 axi_read_en = 0;\n\tif(axi_rdata[15:0]==32'h0000008)begin\n\t    \t$display(\"[INFO] PASS Counter value read: %d\", axi_rdata[15:0]);\n\tend\n\telse\n\t\tbegin \n\t\t$display(\"[ERROR] FAIL counter did not match \");\n\tend\n        #50;\n        axi_addr = 4'b0100; \n        axi_read_en = 1;\n        #50 axi_read_en = 0;\n\t#10;\n\tif(axi_rdata[0])\n\tbegin \n        $display(\"[INFO] PASS Interrupt status read: %b\", axi_rdata[0]);\n\tend\n\telse\n\tbegin\n\t$display(\"[ERROR] FAIL\");\n\tend \n        axi_addr = 4'b0100; \n        axi_wdata = 32'b0;\n        axi_write_en = 1;\n        #60 axi_write_en = 0;\n\tif(~interrupt)\n\t\t$display(\"[INFO] PASS interupt is cleared  PASS\");\n\telse  begin\n\t\t$display(\"[INFO] FAIL Interupt is not cleared  FAIL\");\n\tend\n        #100;\n        $display(\"[INFO] Ending simulation\");\n        $finish;\n    end\n\n    initial begin\n        $dumpfile(\"test.vcd\");          \n        $dumpvars(0, ttc_counter_lite_tb);     \n    end    \n\nendmodule"}, "patch": {"rtl/ttc_counter_lite.sv": ""}, "harness": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 80\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ttc_counter_lite.sv\nTOPLEVEL        = ttc_counter_lite\nMODULE          = test_ttc_counter_lite\nPYTHONPATH      = /src\nHASH            = 788bafd923d14e2f4951372f00d6779aea18b5e3\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 2, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_ttc_counter_lite.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\n\n@cocotb.test()\nasync def test_ttc_counter_lite(dut):\n    \"\"\"\n    Cocotb-based testbench for the ttc_counter_lite module.\n    \"\"\"\n\n    # Generate clock (100 MHz -> 10 ns period)\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Initialize DUT signals\n    #await hrs_lb.dut_init(dut)\n\n    # Reset DUT\n    dut.reset.value = 1\n    await Timer(20, units=\"ns\")\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\n    # Helper function to write to AXI\n    async def axi_write(addr, data):\n        dut.axi_addr.value = addr\n        dut.axi_wdata.value = data\n        dut.axi_write_en.value = 1\n        await RisingEdge(dut.clk)\n        dut.axi_write_en.value = 0\n        await RisingEdge(dut.clk)\n\n    # Helper function to read from AXI\n    async def axi_read(addr):\n        dut.axi_addr.value = addr\n        dut.axi_read_en.value = 1\n        await RisingEdge(dut.clk)\n        dut.axi_read_en.value = 0\n        await RisingEdge(dut.clk)\n        read_value = int(dut.axi_rdata.value)\n        dut._log.info(f\"[READ] Address: {addr:#x}, Data: {read_value:#x}\")\n        return read_value\n\n    # *Set register values as per Verilog TB*\n    \n    # 1. Set match value to 8 (Verilog: axi_wdata = 32'h0000008)\n    await axi_write(0x1, 0x8)\n    assert dut.match_value.value == 0x8, \"[ERROR] Match value not set correctly\"\n\n    # 2. Set reload value to 10 (axi_wdata = 32'h0000000A)\n    await axi_write(0x2, 0xA)\n    assert dut.reload_value.value == 0xA, \"[ERROR] Reload value not set correctly\"\n\n    # 3. Configure control register (Enable=1, Interval=1, Interrupt Enable=1)\n    await axi_write(0x3, 0x7)\n    assert dut.enable.value == 1, \"[ERROR] Control register enable not set\"\n    assert dut.interval_mode.value == 1, \"[ERROR] Interval mode not set\"\n    assert dut.interrupt_enable.value == 1, \"[ERROR] Interrupt enable not set\"\n\n    # 4. Set prescaler value to 3 (axi_wdata = 32'h00000003)\n     # Set prescaler value to 3 (counter increments every 4th cycle)\n    await axi_write(0x5, 0x3)  # Prescaler set to 3 (counter updates every 4th cycle)\n\n    # Ensure the counter increments only after 4 cycles\n    initial_count = int(dut.count.value)\n\n    # Wait for 3 clock cycles (no change should occur)\n    for _ in range(3):\n        await RisingEdge(dut.clk)\n        assert int(dut.count.value) == initial_count, f\"[ERROR] Counter updated before 4 cycles. Count: {int(dut.count.value)}\"\n\n    # On the 4th clock cycle, the counter should increment\n    await RisingEdge(dut.clk)\n    assert int(dut.count.value) == initial_count + 1, f\"[ERROR] Counter did not increment correctly on 4th cycle. Expected: {initial_count + 1}, Got: {int(dut.count.value)}\"\n\n    dut._log.info(f\"[CHECK] Counter increments every 4 cycles correctly. Count: {int(dut.count.value)}\")    # *Wait for counter to increment*\n    await Timer(200, units=\"ns\")\n\n    # 5. Read and verify counter value\n    count_val = await axi_read(0x0)\n    assert 0x6 <= count_val <= 0x8, f\"[ERROR] Counter value out of range: {count_val}\"\n\n    # 6. Wait and check interrupt status\n    await Timer(50, units=\"ns\")\n    assert dut.interrupt.value == 1, \"[ERROR] Interrupt not asserted!\"\n    \n    interrupt_status = await axi_read(0x4)\n    assert interrupt_status == 1, \"[ERROR] Interrupt status mismatch!\"\n\n    # 7. Clear interrupt and verify\n    dut.axi_addr.value = 0x4\n    dut.axi_wdata.value = 0\n    dut.axi_write_en.value = 1\n    await RisingEdge(dut.clk)\n    await Timer(50, units=\"ns\")\n \n    dut.axi_write_en.value = 0\n   # await RisingEdge(dut.clk)\n    assert dut.interrupt.value == 0,f\"[ERROR] Interrupt not cleared{dut.interrupt.value}\"\n\n    dut._log.info(\"[INFO] Simulation completed successfully!\")"}}
