{"id": "cvdp_copilot_32_bit_Brent_Kung_PP_adder_0008", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the Brent-Kung Adder (brent_kung_adder) to ensure its correct functionality during simulation? The assertion should specifically cover the sum and carry out signal validation. This assertion should display error messages when the following condition is violated during simulation:\n\n**Sum and Carry-Out Validation**: \nEnsure that the sum and carry-out signals are correctly calculated as the bitwise sum of `a`, `b`, and `carry_in`. If the result is incorrect, an error message should be displayed.\n\nFollowing should be the interface of the RTL design of Brent Kung Adder module named `brent_kung_adder`.\n## Interface:\n### **Inputs**:\n`clk(1-bit)`: Posedge clk for executing assertion.\n`a(32-bit,[31:0])`: First 32-bit operand or augend of the `brent_kung` adder.\n`b(32-bit,[31:0])`: Second 32-bit operand or addend of the `brent_kung` adder.\n`carry_in(1-bit)` : Input carry of the `brent_kung` adder.\n\n### **Outputs**:\n`sum(32-bit,[31:0])` : 32-bit sum generated by the `brent_kung` adder.\n`carry_out(1-bit)`: Output carry bit generated from the most significant bit of the addition operation.\n", "context": {"rtl/brent_kung_adder.sv": "module brent_kung_adder(\n    input  logic [31:0] a,\n    input  logic [31:0] b,\n    input  logic carry_in,\n    output logic [31:0] sum,\n    output logic carry_out\n);\n    logic [31:0] P1, G1;\n    logic [32:1] C;\n    logic [15:0] G2, P2;\n    logic [7:0] G3, P3;\n    logic [3:0] G4, P4;\n    logic [1:0] G5, P5;\n    logic G6, P6;\n    \n    assign P1 = a ^ b;\n    assign G1 = a & b;\n    \n    genvar i;\n    generate\n        for(i=0; i<=30; i=i+2) begin: second_stage  \n            assign G2[i/2] = G1[i+1] | (P1[i+1] & G1[i]);\n            assign P2[i/2] = P1[i+1] & P1[i];\n        end\n    endgenerate\n    \n    generate\n        for(i=0; i<=14; i=i+2) begin: third_stage   \n            assign G3[i/2] = G2[i+1] | (P2[i+1] & G2[i]);\n            assign P3[i/2] = P2[i+1] & P2[i];\n        end\n    endgenerate\n    \n    generate\n        for(i=0; i<=6; i=i+2) begin: fourth_stage  \n            assign G4[i/2] = G3[i+1] | (P3[i+1] & G3[i]);\n            assign P4[i/2] = P3[i+1] & P3[i];\n        end\n    endgenerate\n    \n    generate\n        for(i=0; i<=2; i=i+2) begin: fifth_stage  \n            assign G5[i/2] = G4[i+1] | (P4[i+1] & G4[i]);\n            assign P5[i/2] = P4[i+1] & P4[i];\n        end\n    endgenerate\n        \n    assign G6 = G5[1] | (P5[1] & G5[0]);\n    assign P6 = P5[1] & P5[0];\n       \n    assign C[1] = G1[0] | (P1[0] & carry_in);\n    assign C[2] = G2[0] | (P2[0] & carry_in);\n    assign C[4] = G3[0] | (P3[0] & carry_in);\n    assign C[8] = G4[0] | (P4[0] & carry_in);\n    assign C[16] = G5[0] | (P5[0] & carry_in);\n    assign C[32] = G6 | (P6 & carry_in);\n        \n    assign C[3] = G1[2] | (P1[2] & C[2]);\n    assign C[5] = G1[4] | (P1[4] & C[4]);\n    assign C[6] = G2[2] | (P2[2] & C[4]);\n    assign C[7] = G1[6] | (P1[6] & C[6]);\n    \n    assign C[9] = G1[8] | (P1[8] & C[8]);\n    assign C[10] = G2[4] | (P2[4] & C[8]);\n    assign C[11] = G1[10] | (P1[10] & C[10]);\n    assign C[12] = G3[2] | (P3[2] & C[8]);\n    assign C[13] = G1[12] | (P1[12] & C[12]);\n    assign C[14] = G2[6] | (P2[6] & C[12]);\n    assign C[15] = G1[14] | (P1[14] & C[14]);\n    \n    assign C[17] = G1[16] | (P1[16] & C[16]);\n    assign C[18] = G2[8] | (P2[8] & C[16]);\n    assign C[19] = G1[18] | (P1[18] & C[18]);\n    assign C[20] = G3[4] | (P3[4] & C[16]);\n    assign C[21] = G1[20] | (P1[20] & C[20]);\n    assign C[22] = G2[10] | (P2[10] & C[20]);\n    assign C[23] = G1[22] | (P1[22] & C[22]);\n    assign C[24] = G4[2] | (P4[2] & C[16]);\n    assign C[25] = G1[24] | (P1[24] & C[24]);\n    assign C[26] = G2[12] | (P2[12] & C[24]);\n    assign C[27] = G1[26] | (P1[26] & C[26]);\n    assign C[28] = G3[6] | (P3[6] & C[24]);\n    assign C[29] = G1[28] | (P1[28] & C[28]);\n    assign C[30] = G2[14] | (P2[14] & C[28]);\n    assign C[31] = G1[30] | (P1[30] & C[30]);\n        \n    assign sum = P1 ^ {C[31:1], carry_in};\n    assign carry_out = C[32];\n    \nendmodule"}}, "output": {"response": "", "context": {"rtl/brent_kung_adder.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/brent_kung_adder.sv\nTOPLEVEL        = brent_kung_adder\nMODULE          = test_brent_kung_adder\nPYTHONPATH      = /src\nHASH            = 8-brent_kung_adder_tb_assertion_generation_issue\n", "src/test_brent_kung_adder.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.regression import TestFactory\nfrom cocotb.triggers import Timer\nfrom random import randint\n\n# Cocotb testbench for Brent-Kung Adder\n@cocotb.test()\nasync def test_brent_kung_adder(dut):\n    \"\"\"Test the 32-bit Brent-Kung Adder for different input cases.\"\"\"\n    dut.clk.value = 0\n      \n       \n    # Clock generation\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    # Define the test vectors based on the SystemVerilog run_test_case task\n    test_vectors = [\n        (0x00000000, 0x00000000, 0, 0x00000000, 0, \"Test Case 1: Zero inputs\"),\n        (0x7FFFFFFF, 0x7FFFFFFF, 0, 0xFFFFFFFE, 0, \"Test Case 2: Large positive numbers with no carry\"),\n        (0x80000000, 0x80000000, 0, 0x00000000, 1, \"Test Case 3: Adding two large negative numbers, carry-out expected\"),\n        (0x0000FFFF, 0xFFFF0000, 0, 0xFFFFFFFF, 0, \"Test Case 4: Numbers with different magnitudes\"),\n        (0xFFFFFFFF, 0xFFFFFFFF, 1, 0xFFFFFFFF, 1, \"Test Case 5: Large numbers with carry-in\"),\n        (0x55555555, 0xAAAAAAAA, 0, 0xFFFFFFFF, 0, \"Test Case 6: Alternating 1's and 0's, no carry-in\"),\n        (0xA1B2C3D4, 0x4D3C2B1A, 1, 0xEEEEEEEF, 0, \"Test Case 7: Random values with carry-in\"),\n        (0xF0F0F0F0, 0x0F0F0F0F, 0, 0xFFFFFFFF, 0, \"Test Case 8: Large hexadecimal numbers\"),\n        (0x12345678, 0x87654321, 1, 0x9999999A, 0, \"Test Case 9: Random edge case with carry-in\"),\n        (0xDEADBEEF, 0xC0FFEE00, 0, 0x9FADACEF, 1, \"Test Case 10: Random edge case, carry-out expected\"),\n        (0x11111111, 0x22222222, 1, 0x33333334, 0, \"Test Case 11: Simple increasing values with carry-in\"),\n        (0x00000001, 0x00000001, 1, 0x00000003, 0, \"Test Case 12: Smallest non-zero inputs with carry-in\"),\n    ]\n\n    # Iterate through the test vectors and apply them to the DUT\n    for a, b, carry_in, expected_sum, expected_carry_out, case_name in test_vectors:\n        # Apply inputs\n        dut.a.value = a\n        dut.b.value = b\n        dut.carry_in.value = carry_in\n        \n        # Wait for the DUT to process the inputs\n        await Timer(10, units=\"ns\")\n\n        # Capture the outputs\n        actual_sum = dut.sum.value\n        actual_carry_out = dut.carry_out.value\n\n        # Convert `LogicArray` to integer for correct formatting\n        actual_sum_int = int(actual_sum)\n        actual_carry_out_int = int(actual_carry_out)\n\n        # Log the test case details\n        dut._log.info(f\"Running test case: {case_name}\")\n        dut._log.info(f\"a: {a:08X}, b: {b:08X}, carry_in: {carry_in}\")\n        dut._log.info(f\"Expected Sum: {expected_sum:08X}, Actual Sum: {actual_sum_int:08X}\")\n        dut._log.info(f\"Expected Carry Out: {expected_carry_out}, Actual Carry Out: {actual_carry_out_int}\")\n\n        # Assertions to check if outputs match expectations\n        assert actual_sum_int == expected_sum, f\"{case_name} - Sum Mismatch: Expected {expected_sum:08X}, Got {actual_sum_int:08X}\"\n        assert actual_carry_out_int == expected_carry_out, f\"{case_name} - Carry Out Mismatch: Expected {expected_carry_out}, Got {actual_carry_out_int}\"\n\n        # Wait for a short time before the next test case\n        await Timer(10, units=\"ns\")\n\n    # Additional random test cases\n    num_random_tests = 10  # Number of random tests to generate\n    for i in range(num_random_tests):\n        # Generate random values for a, b, and carry_in\n        a = randint(0, 0xFFFFFFFF)\n        b = randint(0, 0xFFFFFFFF)\n        carry_in = randint(0, 1)\n\n        # Apply inputs\n        dut.a.value = a\n        dut.b.value = b\n        dut.carry_in.value = carry_in\n\n        # Wait for the DUT to process the inputs\n        await Timer(10, units=\"ns\")\n\n        # Capture the outputs\n        actual_sum = dut.sum.value\n        actual_carry_out = dut.carry_out.value\n        \n        # Convert `LogicArray` to integer for correct formatting\n        actual_sum_int = int(actual_sum)\n        actual_carry_out_int = int(actual_carry_out)\n\n        # Log the random test case details\n        dut._log.info(f\"Random Test Case {i + 1}\")\n        dut._log.info(f\"a: {a:08X}, b: {b:08X}, carry_in: {carry_in}\")\n        dut._log.info(f\"sum: {actual_sum_int:08X}, carry_out: {actual_carry_out_int}\")\n\n               \n        # Wait for a short time before the next random test case\n        await Timer(10, units=\"ns\")\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_64b66b_decoder_0020", "categories": ["cid014", "medium"], "input": {"prompt": "Create SystemVerilog Assertions to verify the **functional correctness** of the `decoder_64b66b` module. The properties should ensure that:  \n\n1. **Valid Sync Header**: The `sync_header` must be either `2'b01` or `2'b10` when `decoder_data_valid_in` is HIGH.  \n\n2. **Type Field Validity**: When the `sync_header` is `2'b10`, the `type_field` must be valid (i.e., match one of the predefined values).  \n\n3. **Control Output for Non-Data Sync**: The `decoder_control_out` must be `8'b0` when the `sync_header` is not `2'b10`.  \n\n4. **Control Output for Data Sync**: The `decoder_control_out` must be a **non-zero value** when the `sync_header` is `2'b10`.  \n\n5. **Type Field Stability**: The `type_field` must remain stable during valid sync (`sync_header == 2'b10`).  \n\nEach assertion must provide a **detailed failure message**, including the `sync_header`, `type_field`, and `decoder_control_out` where applicable, for debugging purposes.  \n\n---\n\n### RTL Specification  \n\n#### Module Name: `decoder_64b66b`  \n\n1. The module processes the 66-bit input data (`decoder_data_in`) based on the sync header and type field:\n   - The sync header (`sync_header`) is the first 2 bits of the input:\n     - `2'b01`: Data-only mode.\n     - `2'b10`: Control-only or mixed mode.\n   - The type field (`type_field`) is the next 8 bits of the input, which determines the control output and how the data is decoded.\n\n2. The module checks for:\n   - **Synchronization errors**: Invalid sync headers (neither `2'b01` nor `2'b10`).\n   - **Type field errors**: Invalid type fields (not in the predefined list of valid type fields).\n\n3. The outputs include:\n   - Decoded 64-bit data (`decoder_data_out`).\n   - Decoded 8-bit control (`decoder_control_out`).\n   - Error flags (`sync_error` and `decoder_error_out`).\n\n4. Latency:\n   - The module has a **1-cycle latency** for decoding and error checking.\n\n5. Control Characters:\n   - The module uses specific control characters to represent special signals in the decoded data. These control characters are defined as follows:\n\n     | **Control Character** | **Value** |\n     |-----------------------|-----------|\n     | `/I/` (Idle)          | `0x07`    |\n     | `/S/` (Start of Frame)| `0xFB`    |\n     | `/T/` (End of Frame)  | `0xFD`    |\n     | `/E/` (Error)         | `0xFE`    |\n     | `/Q/` (Ordered Set)   | `0x9C`    |\n\n   - These control characters are inserted into the decoded data output based on the type field and sync header.\n\n6. Decoder Table:\n   - The module uses a predefined mapping between the type field and the control output/decoded data output. The table below defines the behavior for each type of field:\n\n     | **Type Field** | **decoder_control_out**  | **decoder_data_out**              |\n     |----------------|--------------------------|-----------------------------------|\n     | `0x1E`         | `8'b11111111`            | `{E7, E6, E5, E4, E3, E2, E1, E0}`|\n     | `0x33`         | `8'b00011111`            | `{D6, D5, D4, S4, I3, I2, I1, I0}`|\n     | `0x78`         | `8'b00000001`            | `{D6, D5, D4, D3, D2, D1, D0, S0}`|\n     | `0x87`         | `8'b11111110`            | `{I7, I6, I5, I4, I3, I2, I1, T0}`|\n     | `0x99`         | `8'b11111110`            | `{I7, I6, I5, I4, I3, I2, T1, D0}`|\n     | `0xAA`         | `8'b11111100`            | `{I7, I6, I5, I4, I3, T2, D1, D0}`|\n     | `0xB4`         | `8'b11111000`            | `{I7, I6, I5, I4, T3, D2, D1, D0}`|\n     | `0xCC`         | `8'b11110000`            | `{I7, I6, I5, T4, D3, D2, D1, D0}`|\n     | `0xD2`         | `8'b11100000`            | `{I7, I6, T5, D4, D3, D2, D1, D0}`|\n     | `0xE1`         | `8'b11000000`            | `{I7, T6, D5, D4, D3, D2, D1, D0}`|\n     | `0xFF`         | `8'b10000000`            | `{T7, D6, D5, D4, D3, D2, D1, D0}`|\n     | `0x2D`         | `8'b00011111`            | `{D6, D5, D4, Q4, I3, I2, I1, I0}`|\n     | `0x4B`         | `8'b11110001`            | `{I7, I6, I5, I4, D2, D1, D0, Q0}`|\n     | `0x55`         | `8'b00010001`            | `{D6, D5, D4, Q4, D2, D1, D0, Q0}`|\n     | `0x66`         | `8'b00010001`            | `{D6, D5, D4, S4, D2, D1, D0, Q0}`|\n\n   - **Explanation**:\n     - `Dx`: Represents data bits from the input.\n     - `Ix`: Represents idle control characters (`/I/`).\n     - `Sx`: Represents start-of-frame control characters (`/S/`).\n     - `Tx`: Represents end-of-frame control characters (`/T/`).\n     - `Ex`: Represents error control characters (`/E/`).\n     - `Qx`: Represents ordered-set control characters (`/Q/`).\n\n#### IO Ports  \n\n| Port Name                    | Direction| Size       | Description                                        |\n|------------------------------|----------|------------|----------------------------------------------------|\n| `clk_in`                     | Input    | 1 bit      | Positive Edge triggered Clock signal               |\n| `rst_in`                     | Input    | 1 bit      | Asynchronous Active-high reset                     |\n| `decoder_data_valid_in`      | Input    | 1 bit      | Input data valid signal                            |\n| `decoder_data_in[65:0]`      | Input    | 66 bits    | 66-bit encoded input                               |\n| `decoder_data_out[63:0]`     | Output   | 64 bits    | Decoded 64-bit data output                         |\n| `decoder_control_out[7:0]`   | Output   | 8 bits     | Decoded 8-bit control output                       |\n| `sync_error`                 | Output   | 1 bit      | Sync error flag                                    |\n| `decoder_error_out`          | Output   | 1 bit      | Type field error flag                              |", "context": {"rtl/decoder_64b66b.sv": "module decoder_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic         decoder_data_valid_in, // Input data valid signal\n    input  logic [65:0]  decoder_data_in,     // 66-bit encoded input\n    output logic [63:0]  decoder_data_out,    // Decoded 64-bit data output\n    output logic [7:0]   decoder_control_out, // Decoded 8-bit control output\n    output logic         sync_error,          // Sync error flag\n    output logic         decoder_error_out    // Type field error flag\n);\n\n    logic [1:0] sync_header;\n    logic [7:0] type_field;\n    logic [63:0] data_in;\n    logic type_field_valid;\n    logic decoder_wrong_ctrl_received;\n    logic decoder_wrong_type_field;\n\n    assign sync_header = decoder_data_in[65:64];\n    assign type_field = decoder_data_in[63:56];\n    assign data_in = decoder_data_in[55:0];\n\n    always_comb begin\n        type_field_valid = 1'b0;\n        if (sync_header == 2'b10) begin\n            case (type_field)\n                8'h1E, 8'h33, 8'h78, 8'h87, 8'h99, 8'hAA, 8'hB4, \n                8'hCC, 8'hD2, 8'hE1, 8'hFF, 8'h2D, 8'h4B, 8'h55, 8'h66: \n                    type_field_valid = 1'b1;\n                default: type_field_valid = 1'b0;\n            endcase\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_control_out <= 8'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            if (sync_header == 2'b10) begin\n                case (type_field)\n                    8'h1E: decoder_control_out <= 8'b11111111;\n                    8'h33: decoder_control_out <= 8'b00011111;\n                    8'h78: decoder_control_out <= 8'b00000001;\n                    8'h87: decoder_control_out <= 8'b11111110;\n                    8'h99: decoder_control_out <= 8'b11111110;\n                    8'hAA: decoder_control_out <= 8'b11111100;\n                    8'hB4: decoder_control_out <= 8'b11111000;\n                    8'hCC: decoder_control_out <= 8'b11110000;\n                    8'hD2: decoder_control_out <= 8'b11100000;\n                    8'hE1: decoder_control_out <= 8'b11000000;\n                    8'hFF: decoder_control_out <= 8'b10000000;\n                    8'h2D: decoder_control_out <= 8'b00011111;\n                    8'h4B: decoder_control_out <= 8'b11110001;\n                    8'h55: decoder_control_out <= 8'b00010001;\n                    8'h66: decoder_control_out <= 8'b00010001;\n                    default: decoder_control_out <= 8'b0;\n                endcase\n            end\n            else begin\n                decoder_control_out <= 8'b0;\n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_data_out <= 64'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            case (sync_header)\n                2'b01: begin\n                    decoder_data_out <= decoder_data_in[63:0];\n                end\n                2'b10: begin\n                    case (type_field)\n                        8'h1E: if (data_in[55:0] == {8{7'h1E}}) decoder_data_out <= {8{8'hFE}};\n                               else decoder_data_out <= {8{8'h07}};\n                        8'h33: decoder_data_out <= {data_in[55:32], 8'hFB, {4{8'h07}}};\n                        8'h78: decoder_data_out <= {data_in[55:0], 8'hFB};\n                        8'h87: decoder_data_out <= {{7{8'h07}},8'hFD};\n                        8'h99: decoder_data_out <= {{6{8'h07}}, 8'hFD, data_in[7:0]};\n                        8'hAA: decoder_data_out <= {{5{8'h07}}, 8'hFD, data_in[15:0]};\n                        8'hB4: decoder_data_out <= {{4{8'h07}}, 8'hFD, data_in[23:0]};\n                        8'hCC: decoder_data_out <= {{3{8'h07}}, 8'hFD, data_in[31:0]};\n                        8'hD2: decoder_data_out <= {{2{8'h07}}, 8'hFD, data_in[39:0]};\n                        8'hE1: decoder_data_out <= {8'h07, 8'hFD, data_in[47:0]};\n                        8'hFF: decoder_data_out <= {8'hFD, data_in[55:0]};\n                        8'h2D: decoder_data_out <= {data_in[55:32], 8'h9C, {4{8'h07}}};\n                        8'h4B: decoder_data_out <= {{4{8'h07}}, data_in[28:5], 8'h9C};\n                        8'h55: decoder_data_out <= {data_in[55:32], 8'h9C, data_in[23:0], 8'h9C};\n                        8'h66: decoder_data_out <= {data_in[55:32], 8'hFB, data_in[23:0], 8'h9C};\n                        default: decoder_data_out <= 64'b0;\n                    endcase\n                end\n                default: decoder_data_out <= 64'b0;\n            endcase\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_error <= 1'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            sync_error <= (sync_header != 2'b01 && sync_header != 2'b10);\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_wrong_type_field <= 1'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            if (sync_header == 2'b10) begin\n                decoder_wrong_type_field <= ~type_field_valid;\n            end\n            else begin\n                decoder_wrong_type_field <= 1'b0;\n            end\n        end\n    end\n    \n    assign decoder_error_out = decoder_wrong_ctrl_received || decoder_wrong_type_field;\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            decoder_wrong_ctrl_received <= 1'b0;\n        end \n        else if (decoder_data_valid_in) begin\n            if (sync_header == 2'b10) begin\n                case (type_field)\n                    8'h1E: if ((data_in[55:0] == {8{7'h1E}}) || (data_in[55:0] == {8{7'h00}})) decoder_wrong_ctrl_received <= 1'b0;\n                           else decoder_wrong_ctrl_received <= 1'b1;\n                    8'h33: if (data_in [31:0] != 32'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h87: if (data_in [55:0] != 56'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h99: if (data_in [55:8] != 48'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hAA: if (data_in [55:16] != 40'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hB4: if (data_in [55:24] != 32'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hCC: if (data_in [55:32] != 24'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hD2: if (data_in [55:40] != 16'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'hE1: if (data_in [55:48] != 8'd0) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h2D: if (data_in [31:0] != 32'hF0000000) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;\n                    8'h4B: if (data_in[55:28] != {4{7'h00}} && data_in[3:0] != 4'b1111) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0;              \n                    8'h55: if (data_in[31:24] != 8'hFF) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0; \n                    8'h66: if (data_in[31:24] != 8'h0F) decoder_wrong_ctrl_received <= 1'b1;\n                           else decoder_wrong_ctrl_received <= 1'b0; \n                    default: decoder_wrong_ctrl_received <= 1'b0; \n                endcase\n            end\n            else begin\n                decoder_wrong_ctrl_received <= 1'b0;\n            end\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/decoder_64b66b.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/decoder_64b66b.sv\nTOPLEVEL        = decoder_64b66b\nMODULE          = test_decoder_64b66b\nPYTHONPATH      = /src\nHASH            = 350c34ca7fa4211359d2aaff83db4f10db1a0abc\n", "src/test_decoder_64b66b.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n# Helper function to initialize DUT inputs\nasync def dut_initialization(dut):\n    \"\"\" Initialize all inputs for DUT \"\"\"\n    dut.rst_in.value = 1\n    dut.decoder_data_valid_in.value = 0\n    dut.decoder_data_in.value = 0\n    await RisingEdge(dut.clk_in)  # Wait for one clock cycle\n    await RisingEdge(dut.clk_in)  # Wait for one clock cycle\n    await RisingEdge(dut.clk_in)  # Wait for one clock cycle\n\n# Helper function to check the output with debug logging\nasync def check_output(dut, expected_data, expected_sync_error, expected_control_out=0, expected_decoder_error_out=0):\n    \"\"\"Check DUT output against expected values\"\"\"\n    await RisingEdge(dut.clk_in)  # Wait for the output latency of 1 cycle\n    actual_data_out = dut.decoder_data_out.value.integer\n    actual_sync_error = dut.sync_error.value.integer\n    actual_control_out = dut.decoder_control_out.value.integer\n    actual_decoder_error_out = dut.decoder_error_out.value.integer\n    decoder_data_in = dut.decoder_data_in.value.integer\n\n    # Log the actual and expected outputs\n    dut._log.info(f\"Checking output - Input: {hex(decoder_data_in)},  Actual decoder_data_out: {hex(actual_data_out)}, Expected decoder_data_out: {hex(expected_data)}\\n\"\n                  f\"  Actual sync_error: {actual_sync_error}, Expected sync_error: {expected_sync_error}\\n\"\n                  f\"  Actual decoder_control_out: {hex(actual_control_out)}, Expected decoder_control_out: {hex(expected_control_out)}\\n\"\n                  f\"  Actual decoder_error_out: {actual_decoder_error_out}, Expected decoder_error_out: {expected_decoder_error_out}\\n\")\n\n    # Always check sync_error and decoder_error_out\n    assert actual_sync_error == expected_sync_error, \\\n        f\"Sync error mismatch: sync_error={actual_sync_error} (expected {expected_sync_error})\"\n    assert actual_decoder_error_out == expected_decoder_error_out, \\\n        f\"Decoder error mismatch: decoder_error_out={actual_decoder_error_out} (expected {expected_decoder_error_out})\"\n\n    # Check data and control output only if both sync_error and decoder_error_out are 0\n    if expected_sync_error == 0 and expected_decoder_error_out == 0:\n        assert actual_data_out == expected_data, \\\n            f\"Data mismatch: decoder_data_out={hex(actual_data_out)} (expected {hex(expected_data)})\"\n        assert actual_control_out == expected_control_out, \\\n            f\"Control output mismatch: decoder_control_out={hex(actual_control_out)} (expected {hex(expected_control_out)})\"\n\n@cocotb.test()\nasync def reset_test(dut):\n    \"\"\" Test the reset behavior of the decoder \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    \n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    # Log the output after reset\n    dut._log.info(f\"Reset Test:\\n  decoder_data_out: {hex(dut.decoder_data_out.value.integer)}\\n  Expected: 0\")\n\n    # Check that output is zero after reset\n    assert dut.decoder_data_out.value == 0, \"Reset test failed: decoder_data_out should be zero after reset\"\n    assert dut.sync_error.value == 0, \"Reset test failed: sync_error should be zero after reset\"\n\n@cocotb.test()\nasync def valid_data_test(dut):\n    \"\"\" Test decoding when the sync header indicates valid data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    \n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Set test inputs\n    dut.decoder_data_in.value = (0b01 << 64) | 0xA5A5A5A5A5A5A5A5\n    dut.decoder_data_valid_in.value = 1\n\n    await Timer(5, units=\"ns\")\n    # Apply test and check output\n    await RisingEdge(dut.clk_in)\n    dut.decoder_data_valid_in.value = 0\n    dut._log.info(f\"Valid Data Test:\\n\"\n                  f\"  decoder_data_in: {hex(dut.decoder_data_in.value.integer)}\")\n    await check_output(dut, expected_data=0xA5A5A5A5A5A5A5A5, expected_sync_error=0)\n\n\n\n\n\n\n\n@cocotb.test()\nasync def random_valid_data_test(dut):\n    \"\"\" Test decoding with random sync headers and data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    await RisingEdge(dut.clk_in)\n\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    for i in range(5):  # Run 5 random tests\n        random_sync_header = random.choice([0b01])\n        random_data = random.getrandbits(64)\n\n        dut.decoder_data_in.value = (random_sync_header << 64) | random_data\n        dut.decoder_data_valid_in.value = 1\n\n        expected_data = random_data if random_sync_header == 0b01 else 0x0000000000000000\n        expected_sync_error = 0 if random_sync_header == 0b01 else 1\n\n        # Apply test and check output\n        await Timer(5, units=\"ns\")  # Wait before next random test\n        await RisingEdge(dut.clk_in)\n        dut.decoder_data_valid_in.value = 0\n        dut._log.info(f\"Random Test {i+1}:\\n\"\n                      f\"  decoder_data_in: {hex(dut.decoder_data_in.value.integer)}\")\n        await check_output(dut, expected_data=expected_data, expected_sync_error=expected_sync_error)\n\n@cocotb.test()\nasync def control_only_test(dut):\n    \"\"\" Test decoding for control-only mode \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    await RisingEdge(dut.clk_in)\n\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Control-only mode test cases\n    test_cases = [\n        (0b10, 0x1E, 0x3C78F1E3C78F1E, 0xFEFEFEFEFEFEFEFE, 0, 0),  # All control characters\n        (0b10, 0x1E, 0x00000000000000, 0x0707070707070707, 0, 0),  # All control characters\n        (0b10, 0x1E, 0x00000000000000, 0x0707070707070707, 0, 0),  # All control characters\n        (0b10, 0x1E, 0x3C78F1E3C78F1E, 0xFEFEFEFEFEFEFEFE, 0, 0),  # All control characters\n    ]\n\n    for sync_header, type_field, data_in, expected_data, expected_sync_error, expected_decoder_error_out in test_cases:\n        dut.decoder_data_in.value = (sync_header << 64) | (type_field << 56) | data_in\n        dut.decoder_data_valid_in.value = 1\n\n        await Timer(5, units=\"ns\")\n        await RisingEdge(dut.clk_in)\n        dut.decoder_data_valid_in.value = 0\n        dut._log.info(f\"Control-Only Test:\\n\"\n                      f\"  decoder_data_in: {hex(dut.decoder_data_in.value.integer)}\")\n        await check_output(dut, expected_data=expected_data, expected_sync_error=expected_sync_error,\n                           expected_control_out=0xFF, expected_decoder_error_out=expected_decoder_error_out)\n\n@cocotb.test()\nasync def mixed_mode_test(dut):\n    \"\"\" Test decoding for mixed mode \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    await RisingEdge(dut.clk_in)\n\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Mixed mode test cases\n    test_cases = [\n        # Format: (sync_header, type_field, data_in, expected_data, expected_control_out, expected_sync_error, expected_decoder_error_out)\n        (0b10, 0x33, 0xDDCCBB00000000, 0xDDCCBBFB07070707, 0x1F, 0, 0),  # Mixed mode example\n        (0b10, 0x78, 0x3456789ABCDEF0, 0x3456789ABCDEF0FB, 0x01, 0, 0),  # Mixed mode example\n        (0b10, 0x87, 0x00000000000000, 0x07070707070707FD, 0xFE, 0, 0),  # Mixed mode example\n        (0b10, 0x99, 0x000000000000AE, 0x070707070707FDAE, 0xFE, 0, 0),  # Mixed mode example\n        (0b10, 0xAA, 0x0000000000A5A5, 0x0707070707FDA5A5, 0xFC, 0, 0),  # Mixed mode example\n        (0b10, 0xB4, 0x00000000FEED55, 0x07070707FDFEED55, 0xF8, 0, 0),  # Mixed mode example\n        (0b10, 0xCC, 0x00000099887766, 0x070707FD99887766, 0xF0, 0, 0),  # Mixed mode example\n        (0b10, 0xD2, 0x00001234567890, 0x0707FD1234567890, 0xE0, 0, 0),  # Mixed mode example\n        (0b10, 0xE1, 0x00FFEEDDCCBBAA, 0x07FDFFEEDDCCBBAA, 0xC0, 0, 0),  # Mixed mode example\n        (0b10, 0xFF, 0x773388229911AA, 0xFD773388229911AA, 0x80, 0, 0),  # Mixed mode example\n        (0b10, 0x55, 0x070707FF070707, 0x0707079C0707079C, 0x11, 0, 0),  # Mixed mode example\n        (0b10, 0x66, 0x7777770FDEEDDE, 0x777777FBDEEDDE9C, 0x11, 0, 0),  # Mixed mode example\n        (0b10, 0x4B, 0x0000000ABCDEFF, 0x0707070755E6F79C, 0xF1, 0, 0),  # Mixed mode example\n        (0b10, 0x2D, 0xAAAAAAF0000000, 0xAAAAAA9C07070707, 0x1F, 0, 0),  # Mixed mode example\n    ]\n\n    for sync_header, type_field, data_in, expected_data, expected_control_out, expected_sync_error, expected_decoder_error_out in test_cases:\n        # Set inputs\n        dut.decoder_data_in.value = (sync_header << 64) | (type_field << 56) | data_in\n        dut.decoder_data_valid_in.value = 1\n\n        # Wait for the output to stabilize\n        await Timer(5, units=\"ns\")\n        await RisingEdge(dut.clk_in)\n\n        # Check outputs\n        await check_output(dut, expected_data=expected_data, expected_sync_error=expected_sync_error,\n                           expected_control_out=expected_control_out, expected_decoder_error_out=expected_decoder_error_out)\n\n        # Deassert valid signal\n        dut.decoder_data_valid_in.value = 0\n        await RisingEdge(dut.clk_in)\n\n\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_64b66b_encoder_0018", "categories": ["cid014", "easy"], "input": {"prompt": "The encoder module, `encoder_64b66b`, produces a 66\u2011bit output by concatenating a 2\u2011bit sync_word and a 64\u2011bit encoded_data. The encoder is intended to operate only in \u201cdata mode.\u201d That is, the design supports only data encoding and does not support control encoding. In data mode, the control input (`encoder_control_in`) must be 8'b00000000; when it is zero, the module sets the sync_word to 2'b01 and passes the 64\u2011bit input data through to the output.  \n \n**Requirement**:  \nAdd an immediate assertion to the RTL that checks, on every positive clock edge (when not in reset), that `encoder_control_in` is zero. If `encoder_control_in` is non-zero, the assertion should trigger an error message indicating that only data encoding is supported.\n\n**Interface**:\n- **Inputs**:\n  - `clk_in`: Positive edge-triggered clock signal.\n  - `rst_in`: Asynchronous reset (active high).\n  - `encoder_data_in[63:0]`: 64\u2011bit data input.\n  - `encoder_control_in[7:0]`: 8\u2011bit control input (must be 0 for valid data mode).\n- **Output**:\n  - `encoder_data_out[65:0]` : 66\u2011bit output, consisting of the sync_word([65:64] bits) and encoded_data([63:0] bits).\n", "context": {"rtl/encoder_64b66b.sv": "module encoder_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic [63:0]  encoder_data_in,     // 64-bit data input\n    input  logic [7:0]   encoder_control_in,  // 8-bit control input\n    output logic [65:0]  encoder_data_out     // 66-bit encoded output\n);\n\n    logic [1:0] sync_word;     \n    logic [63:0] encoded_data; \n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_word <= 2'b00;            \n        end \n        else begin\n            if (encoder_control_in == 8'b00000000) begin\n                sync_word <= 2'b01;         \n            end \n            else begin\n                sync_word <= 2'b10;         \n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_data <= 64'b0;         \n        end \n        else begin\n            if (encoder_control_in == 8'b00000000) begin\n                encoded_data <= encoder_data_in; \n            end\n            else begin\n                encoded_data <= 64'b0; \n            end\n        end\n    end\n\n    assign encoder_data_out = {sync_word, encoded_data};\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/encoder_64b66b.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/encoder_64b66b.sv\nTOPLEVEL        = encoder_64b66b\nMODULE          = test_encoder_64b66b\nPYTHONPATH      = /src\nHASH            = e5c1ef6679fc1febf401202f234a17c7034c1e0d\n", "src/test_encoder_64b66b.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n# Helper function to initialize DUT inputs\nasync def dut_initialization(dut):\n    \"\"\" Initialize all inputs for DUT \"\"\"\n    dut.rst_in.value = 1\n    dut.encoder_data_in.value = 0\n    dut.encoder_control_in.value = 0\n    await RisingEdge(dut.clk_in)  # Wait for one clock cycle\n\n# Helper function to check the output with debug logging\nasync def check_output(dut, expected_sync, expected_data):\n    await RisingEdge(dut.clk_in)\n    actual_output = int(dut.encoder_data_out.value)\n    expected_output = (expected_sync << 64) | expected_data\n\n    # Log the actual and expected outputs\n    dut._log.info(f\"Checking output:\\n\"\n                  f\"  Actual encoder_data_out: {hex(actual_output)}\\n\"\n                  f\"  Expected encoder_data_out: {hex(expected_output)}\\n\")\n\n    assert actual_output == expected_output, \\\n        f\"Test failed: encoder_data_out={hex(actual_output)} (expected {hex(expected_output)})\"\n\n@cocotb.test()\nasync def reset_test(dut):\n    \"\"\" Test the reset behavior of the encoder \"\"\"\n    # Start the clock\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    \n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    # Log the output after reset\n    dut._log.info(f\"Reset Test:\\n  encoder_data_out: {hex((int(dut.encoder_data_out.value)))}\\n  Expected: 0\")\n\n    # Check that output is zero after reset\n    assert int(dut.encoder_data_out.value) == 0, \"Reset test failed: encoder_data_out should be zero after reset\"\n\n@cocotb.test()\nasync def data_encoding_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0xA5A5A5A5A5A5A5A5\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0xA5A5A5A5A5A5A5A5)\n\n\n\n@cocotb.test()\nasync def random_data_control_test(dut):\n    \"\"\" Test encoding with random data and control inputs \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    \n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    for i in range(5):  # Run 5 random tests\n        # Generate random data and control inputs\n        random_data = random.getrandbits(64)\n        random_control = 0x00\n\n        dut.encoder_data_in.value = random_data\n        dut.encoder_control_in.value = random_control\n\n        # Determine expected sync word and data based on control input\n        expected_sync = 0b01 if random_control == 0 else 0b10\n        expected_data = random_data if random_control == 0 else 0x0000000000000000\n\n        await RisingEdge(dut.clk_in)\n        # Log inputs for each random test\n        dut._log.info(f\"Random Test {i+1}:\\n\"\n                      f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                      f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n        await check_output(dut, expected_sync=expected_sync, expected_data=expected_data)\n\n        await Timer(10, units=\"ns\")  # Wait for next random test\n\n    dut._log.info(\"Randomized tests completed successfully\")\n\n@cocotb.test()\nasync def random_data_only_test(dut):\n    \"\"\" Test encoding with random data and control inputs \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    \n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    dut.encoder_control_in.value = 0  # All data\n    await RisingEdge(dut.clk_in)\n\n    for i in range(5):  # Run 5 random tests\n        # Generate random data\n        random_data = random.getrandbits(64)\n        dut.encoder_data_in.value = random_data\n\n        # Determine expected sync word and data\n        expected_sync = 0b01\n        expected_data = random_data\n\n        await RisingEdge(dut.clk_in)\n        # Log inputs for each random test\n        dut._log.info(f\"Random Test {i+1}:\\n\"\n                      f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                      f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n        await check_output(dut, expected_sync=expected_sync, expected_data=expected_data)\n\n        await Timer(10, units=\"ns\")  # Wait for next random test\n\n    dut._log.info(\"Randomized tests completed successfully\")\n\n@cocotb.test()\nasync def tc1_data_encoding_bug_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0xFEDCBA9876543210\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0xFEDCBA9876543210)\n    \n  \n@cocotb.test()\nasync def tc2_reset_bug_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0xA5A5A5A5A5A5A5A5\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b00, expected_data=0x0000000000000000)\n\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0xA5A5A5A5A5A5A5A5\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0xA5A5A5A5A5A5A5A5)\n\n@cocotb.test()\nasync def tc3_stuck_at_zero_bug_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0x123456789ABCDEF0\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0x123456789ABCDEF0)\n    \n   \n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_64b66b_encoder_0020", "categories": ["cid014", "medium"], "input": {"prompt": "Create SystemVerilog Assertions to verify the **functional correctness** of the `encoder_64b66b` module. The properties should ensure that:  \n\n1. **Valid `encoder_data_in` for Control Input `8'b11111111`**: When `encoder_control_in == 8'b11111111`, the `encoder_data_in` must be one of the expected patterns:  \n   - `64'h0707070707070707`  \n   - `64'hFEFEFEFEFEFEFEFE`  \n   - `64'h07070707070707FD`  \n2. **Valid `encoder_data_in[39:0]` for Control Input `8'b00011111`**: When `encoder_control_in == 8'b00011111`, the lower 40 bits of `encoder_data_in` must match:  \n   - `40'hFB07070707`  \n   - `40'h9C07070707`  \n3. **Valid `encoder_data_in[63:8]` for Control Input `8'b11111110`**: When `encoder_control_in == 8'b11111110`, the upper 56 bits of `encoder_data_in` must be `56'h070707070707FD`.  \n4. **Valid `encoder_data_in[63:32]` and `encoder_data_in[7:0]` for Control Input `8'b11110001`**: When `encoder_control_in == 8'b11110001`, the concatenation of `encoder_data_in[63:32]` and `encoder_data_in[7:0]` must be `40'h070707079C`.  \n5. **Synchronization Control Word**: When `encoder_control_in` is non-zero, `sync_ctrl_word` must always be set to `2'b10`.  \n6. **No Invalid Values in `encoder_data_out`**: The `encoder_data_out` signal must never contain unknown (`x`) or high-impedance (`z`) values.  \n\nEach assertion must provide a **detailed failure message**, including `encoder_control_in`, `encoder_data_in`, `sync_ctrl_word`, and `encoder_data_out` where applicable, for debugging purposes.\n\n---\n\n### RTL Specification  \n\n#### Module Name: `encoder_64b66b` \n\nThe `encoder_64b66b` is a digital circuit that converts a 64-bit data word and an 8-bit control word into a 66-bit encoded output. The sync word (2 bits) indicates whether the encoded data is purely data or contains control characters. The encoder must support three modes of operation:\n\n1. **Data-Only Mode**:  \n   - If all control input bits (`encoder_control_in`) are `0`, the input data (`encoder_data_in`) is passed unchanged, and the sync word is set to `2'b01`.\n\n2. **Control-Only Mode**:  \n   - If all control input bits (`encoder_control_in`) are `1`, the encoded data includes encoded control characters corresponding to the input control values, and the sync word is set to `2'b10`.\n\n3. **Mixed Mode**:  \n   - If some bits of the control input are `1` and others are `0`, the data input and control characters are combined. The data bytes pass unchanged for control bits set to `0`, while the control characters are encoded for control bits set to `1`. The sync word is set to `2'b10`.\n\n---\n\n### **Encoding Rules**\n\n**1. Sync Word**:\n   - Set to `2'b01` if all control bits are `0` (data-only mode).\n   - Set to `2'b10` if any control bit is `1` (control-only or mixed mode).\n\n**2. Control Character Encoding**:\n   - Control characters in 64-bit input are encoded into respective 7-bit control codes according to the table:\n\n#### **Valid Control Characters in Input and Their Encoding Values**\n\n| **Control Character**  | **Value** | **Encoded Control Code** | \n|------------------------|-----------|--------------------------|\n| `/I/` (Idle)           | `0x07`    | `7'h00`                  |\n| `/S/` (Start of Frame) | `0xfb`    | `4'b0000`                |\n| `/T/` (End of Frame)   | `0xfd`    | `4'b0000`                |\n| `/E/` (Error)          | `0xfe`    | `7'h1e`                  |\n| `/Q/` (Ordered Set)    | `0x9c`    | `4'b1111`                |\n\n---\n\n#### **Valid Control Input Combinations Encoding with Type Field Lookup Table**\n\n| **Data Input [63:0]**            | **Control Input [7:0]**| **Output [65:64]**| **Output [63:56]**| **Output [55:0]**                       |\n|----------------------------------|------------------------|-------------------|-------------------|-----------------------------------------|\n| `I7, I6, I5, I4, I3, I2, I1, I0` | `8'b11111111`          | `2'b10`           | `0x1e`            | `C7, C6, C5, C4, C3, C2, C1, C0`        |\n| `E7, E6, E5, E4, E3, E2, E1, E0` | `8'b11111111`          | `2'b10`           | `0x1e`            | `C7, C6, C5, C4, C3, C2, C1, C0`        |\n| `D7, D6, D5, S4, I3, I2, I1, I0` | `8'b00011111`          | `2'b10`           | `0x33`            | `D7, D6, D5, 4'b0000, C3, C2, C1, C0`   |\n| `D7, D6, D5, D4, D3, D2, D1, S0` | `8'b00000001`          | `2'b10`           | `0x78`            | `D7, D6, D5, D4, D3, D2, D1, D0`        |\n| `I7, I6, I5, I4, I3, I2, I1, T0` | `8'b11111110`          | `2'b10`           | `0x87`            | `C7, C6, C5, C4, C3, C2, C1, 7'b0000000`|\n| `I7, I6, I5, I4, I3, I2, T1, D0` | `8'b11111110`          | `2'b10`           | `0x99`            | `C7, C6, C5, C4, C3, C2, 6'b000000, D0` |\n| `I7, I6, I5, I4, I3, T2, D1, D0` | `8'b11111100`          | `2'b10`           | `0xaa`            | `C7, C6, C5, C4, C3, 5'b00000, D1, D0`  |\n| `I7, I6, I5, I4, T3, D2, D1, D0` | `8'b11111000`          | `2'b10`           | `0xb4`            | `C7, C6, C5, C4, 4'b0000, D2, D1, D0`   |\n| `I7, I6, I5, T4, D3, D2, D1, D0` | `8'b11110000`          | `2'b10`           | `0xcc`            | `C7, C6, C5, 3'b000, D3, D2, D1, D0`    |\n| `I7, I6, T5, D4, D3, D2, D1, D0` | `8'b11100000`          | `2'b10`           | `0xd2`            | `C7, C6, 2'b00, D4, D3, D2, D1, D0`     |\n| `I7, T6, D5, D4, D3, D2, D1, D0` | `8'b11000000`          | `2'b10`           | `0xe1`            | `C7, 1'b0, D5, D4, D3, D2, D1, D0`      |\n| `T7, D6, D5, D4, D3, D2, D1, D0` | `8'b10000000`          | `2'b10`           | `0xff`            | `D6, D5, D4, D3, D2, D1, D0`            |\n| `D7, D6, D5, Q4, I3, I2, I1, I0` | `8'b00011111`          | `2'b10`           | `0x2d`            | `D7, D6, D5, 4'b1111, C3, C2, C1, C0`   |\n| `I7, I6, I5, I4, D3, D2, D1, Q0` | `8'b11110001`          | `2'b10`           | `0x4b`            | `C7, C6, C5, C4, D3, D2, D1, 4'b1111`   |\n| `D7, D6, D5, Q4, D3, D2, D1, Q0` | `8'b00010001`          | `2'b10`           | `0x55`            | `D7, D6, D5, 8'b11111111, D3, D2, D1`   |\n| `D7, D6, D5, S4, D3, D2, D1, Q0` | `8'b00010001`          | `2'b10`           | `0x66`            | `D7, D6, D5, 8'b00001111, D3, D2, D1`   |\n\n---\n\n**3. Mixed Mode Encoding**:\n   - For data bytes (control bit = `0`), pass the corresponding byte from `encoder_data_in`.\n   - For control bytes (control bit = `1`), replace the corresponding byte with its 7-bit control code.\n\n\n### Inputs:\n\n- `clk_in`: Rising-edge triggered clock signal.\n- `rst_in`: 1-bit asynchronous reset, active HIGH.\n- `encoder_data_in[63:0]`: 64-bit input data word.\n- `encoder_control_in[7:0]`: 8-bit control word, where each bit indicates whether the corresponding data byte is control (`1`) or data (`0`).\n\n\n### Outputs:\n\n- `encoder_data_out[65:0]`: 66-bit encoded output consisting of:\n  - 2-bit sync word.\n  - 8-bit Type Filed in case of control/mixed case.\n  - 56-bit encoded data word, including data bytes and/or control characters. In the case of data-only mode, there is no type field. Complete 64 bits are data.\n", "context": {"rtl/encoder_64b66b.sv": "module encoder_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic [63:0]  encoder_data_in,     // 64-bit data input\n    input  logic [7:0]   encoder_control_in,  // 8-bit control input\n    output logic [65:0]  encoder_data_out     // 66-bit encoded output\n);\n\n    logic [1:0] sync_word;\n    logic [63:0] encoded_data;\n\n    // Synchronize sync_word based on encoder_control_in\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_word <= 2'b00;\n        end else begin\n            if (encoder_control_in == 8'b00000000) begin\n                sync_word <= 2'b01;\n            end else begin\n                sync_word <= 2'b10;\n            end\n        end\n    end\n\n    // Synchronize encoded_data based on encoder_control_in\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_data <= 64'b0;\n        end else begin\n            if (encoder_control_in == 8'b00000000) begin\n                encoded_data <= encoder_data_in;\n            end else begin\n                encoded_data <= 64'b0;\n            end\n        end\n    end\n\n    // Function to determine the output based on control and data inputs\n    function [7:0] get_output(input [63:0] data_in, input [7:0] control_input);\n        case (control_input)\n            8'b11111111: begin\n                if (data_in == 64'h0707070707070707) get_output = 8'h1e;\n                else if (data_in == 64'hFEFEFEFEFEFEFEFE) get_output = 8'h1e;\n                else if (data_in == 64'h07070707070707FD) get_output = 8'h87;\n                else get_output = 8'b0;\n            end\n            8'b00011111: begin\n                if (data_in[39:0] == 40'hFB07070707) get_output = 8'h33;\n                else if (data_in[39:0] == 40'h9C07070707) get_output = 8'h2d;\n                else get_output = 8'b0;\n            end\n            8'b00000001: begin\n                if (data_in[7:0] == 8'hFB) get_output = 8'h78;\n                else get_output = 8'b0;\n            end\n            8'b11111110: begin\n                if (data_in[63:8] == 56'h070707070707FD) get_output = 8'h99;\n                else get_output = 8'b0;\n            end\n            8'b11111100: begin\n                if (data_in[63:16] == 48'h0707070707FD) get_output = 8'haa;\n                else get_output = 8'b0;\n            end\n            8'b11111000: begin\n                if (data_in[63:24] == 40'h07070707FD) get_output = 8'hb4;\n                else get_output = 8'b0;\n            end\n            8'b11110000: begin\n                if (data_in[63:32] == 32'h070707FD) get_output = 8'hcc;\n                else get_output = 8'b0;\n            end\n            8'b11100000: begin\n                if (data_in[63:40] == 24'h0707FD) get_output = 8'hd2;\n                else get_output = 8'b0;\n            end\n            8'b11000000: begin\n                if (data_in[63:48] == 16'h07FD) get_output = 8'he1;\n                else get_output = 8'b0;\n            end\n            8'b10000000: begin\n                if (data_in[63:56] == 8'hFD) get_output = 8'hff;\n                else get_output = 8'b0;\n            end\n            8'b11110001: begin\n                if ({data_in[63:32], data_in[7:0]} == 40'h070707079C) get_output = 8'h4b;\n                else get_output = 8'b0;\n            end\n            8'b00010001: begin\n                if ({data_in[39:32], data_in[7:0]} == 16'h9C9C) get_output = 8'h55;\n                else if ({data_in[39:32], data_in[7:0]} == 16'hFB9C) get_output = 8'h66;\n                else get_output = 8'b0;\n            end\n            default: get_output = 8'b0;\n        endcase\n    endfunction\n\n    logic [1:0] sync_ctrl_word;\n    logic [7:0] type_field;\n    logic [55:0] encoded_ctrl_words;\n\n    // Synchronize sync_ctrl_word, type_field, and encoded_ctrl_words based on encoder_control_in\n    always @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_ctrl_words <= 56'b0;\n            sync_ctrl_word <= 2'b00;\n            type_field <= 8'b0;\n        end else begin\n            sync_ctrl_word <= 2'b10;\n            type_field <= get_output(encoder_data_in, encoder_control_in);\n\n            case (encoder_control_in)\n                8'b11111111: begin\n                    if (encoder_data_in == 64'h0707070707070707) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else if (encoder_data_in == 64'hFEFEFEFEFEFEFEFE) encoded_ctrl_words <= {7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E};\n                    else if (encoder_data_in == 64'h07070707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00011111: begin\n                    if (encoder_data_in[39:0] == 40'hFB07070707) encoded_ctrl_words <= {encoder_data_in[63:40], 4'h0, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else if (encoder_data_in[39:0] == 40'h9C07070707) encoded_ctrl_words <= {encoder_data_in[63:40], 4'hF, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00000001: begin\n                    if (encoder_data_in[7:0] == 8'hFB) encoded_ctrl_words <= {encoder_data_in[63:8]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111110: begin\n                    if (encoder_data_in[63:8] == 56'h070707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 6'b000000, encoder_data_in[7:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111100: begin\n                    if (encoder_data_in[63:16] == 48'h0707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 5'b00000, encoder_data_in[15:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111000: begin\n                    if (encoder_data_in[63:24] == 40'h07070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 4'b0000, encoder_data_in[23:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11110000: begin\n                    if (encoder_data_in[63:32] == 32'h070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 3'b000, encoder_data_in[31:0]};\n                    else encoded_ctrl_words <= 56'hFFFFFFF;\n                end\n                8'b11100000: begin\n                    if (encoder_data_in[63:40] == 24'h0707FD) encoded_ctrl_words <= {7'h00, 7'h00, 2'b00, encoder_data_in[39:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11000000: begin\n                    if (encoder_data_in[63:48] == 16'h07FD) encoded_ctrl_words <= {7'h00, 1'b0, encoder_data_in[47:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b10000000: begin\n                    if (encoder_data_in[63:56] == 8'hFD) encoded_ctrl_words <= encoder_data_in[55:0];\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11110001: begin\n                    if ({encoder_data_in[63:32], encoder_data_in[7:0]} == 40'h070707079C) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, encoder_data_in[31:8], 4'b1111};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00010001: begin\n                    if ({encoder_data_in[39:32], encoder_data_in[7:0]} == 16'h9C9C) encoded_ctrl_words <= {encoder_data_in[63:40], 8'hFF, encoder_data_in[31:8]};\n                    else if ({encoder_data_in[39:32], encoder_data_in[7:0]} == 16'hFB9C) encoded_ctrl_words <= {encoder_data_in[63:40], 8'h0F, encoder_data_in[31:8]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                default: encoded_ctrl_words <= 56'h0000000;\n            endcase\n        end\n    end\n\n    assign encoder_data_out = (|encoder_control_in) ? {sync_ctrl_word, type_field, encoded_ctrl_words} : {sync_word, encoded_data};\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/encoder_64b66b.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/encoder_64b66b.sv\nTOPLEVEL        = encoder_64b66b\nMODULE          = test_encoder_64b66b\nPYTHONPATH      = /src\nHASH            = 674e365a3aea9bc142da5e4ba7833ce98333c294\n", "src/test_encoder_64b66b.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n# Helper function to initialize DUT inputs\nasync def dut_initialization(dut):\n    \"\"\" Initialize all inputs for DUT \"\"\"\n    dut.rst_in.value = 1\n    dut.encoder_data_in.value = 0\n    dut.encoder_control_in.value = 0\n    await RisingEdge(dut.clk_in)  # Wait for one clock cycle\n\n# Helper function to check the output with debug logging\nasync def check_output(dut, expected_sync, expected_data):\n    await RisingEdge(dut.clk_in)\n    actual_output = int(dut.encoder_data_out.value)\n    expected_output = (expected_sync << 64) | expected_data\n\n    # Log the actual and expected outputs\n    dut._log.info(f\"Checking output:\\n\"\n                  f\"  Actual encoder_data_out: {hex(actual_output)}\\n\"\n                  f\"  Expected encoder_data_out: {hex(expected_output)}\\n\")\n\n    assert actual_output == expected_output, \\\n        f\"Test failed: encoder_data_out={hex(actual_output)} (expected {hex(expected_output)})\"\n\n@cocotb.test()\nasync def reset_test(dut):\n    \"\"\" Test the reset behavior of the encoder \"\"\"\n    # Start the clock\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    \n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    # Log the output after reset\n    dut._log.info(f\"Reset Test:\\n  encoder_data_out: {hex(int(dut.encoder_data_out.value))}\\n  Expected: 0\")\n\n    # Check that output is zero after reset\n    assert int(dut.encoder_data_out.value) == 0, \"Reset test failed: encoder_data_out should be zero after reset\"\n\n@cocotb.test()\nasync def data_encoding_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0xA5A5A5A5A5A5A5A5\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0xA5A5A5A5A5A5A5A5)\n\n@cocotb.test()\nasync def control_encoding_test(dut):\n    \"\"\" Test encoding when control characters are in the last four octets \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    \n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    # Set test inputs\n    dut.encoder_data_in.value = 0xFFFFFFFFFFFFFFFF\n    dut.encoder_control_in.value = 0x0F  # Control in last four octets\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for control encoding test\n    dut._log.info(f\"Control Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b10, expected_data=0x0000000000000000)  # Expected data output is zero\n\n@cocotb.test()\nasync def mixed_data_control_test(dut):\n    \"\"\" Test encoding when control characters are mixed in the data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Set test inputs\n    dut.encoder_data_in.value = 0x123456789ABCDEF0\n    dut.encoder_control_in.value = 0x81  # Control in first and last octets\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for mixed data and control test\n    dut._log.info(f\"Mixed Data and Control Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await RisingEdge(dut.clk_in)\n    await check_output(dut, expected_sync=0b10, expected_data=0x0000000000000000)  # Expected data output is zero\n\n@cocotb.test()\nasync def all_control_symbols_test(dut):\n    \"\"\" Test encoding when all characters are control \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Set test inputs\n    dut.encoder_data_in.value = 0x0707070707070707\n    dut.encoder_control_in.value = 0xFF  # All control\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for all control symbols test\n    dut._log.info(f\"All Control Symbols Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b10, expected_data=0x1E00000000000000)  # Expected data output is zero\n\n\n@cocotb.test()\nasync def random_data_only_test(dut):\n    \"\"\" Test encoding with random data and control inputs \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n    \n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    dut.encoder_control_in.value = 0  # All data\n    await RisingEdge(dut.clk_in)\n\n    for i in range(5):  # Run 5 random tests\n        # Generate random data\n        random_data = random.getrandbits(64)\n        dut.encoder_data_in.value = random_data\n\n        # Determine expected sync word and data\n        expected_sync = 0b01\n        expected_data = random_data\n\n        await RisingEdge(dut.clk_in)\n        # Log inputs for each random test\n        dut._log.info(f\"Random Test {i+1}:\\n\"\n                      f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                      f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n        await check_output(dut, expected_sync=expected_sync, expected_data=expected_data)\n\n        await Timer(10, units=\"ns\")  # Wait for next random test\n\n    dut._log.info(\"Randomized tests completed successfully\")\n\n@cocotb.test()\nasync def tc1_data_encoding_bug_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0xFEDCBA9876543210\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0xFEDCBA9876543210)\n    \n    await RisingEdge(dut.clk_in)\n    # Set test inputs\n    dut.encoder_data_in.value = 0x0707070707070707\n    dut.encoder_control_in.value = 0xFF  # All control\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for all control symbols test\n    dut._log.info(f\"All Control Symbols Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b10, expected_data=0x1E00000000000000)  # Expected data output is zero\n\n\n@cocotb.test()\nasync def tc3_stuck_at_zero_bug_test(dut):\n    \"\"\" Test encoding when all data octets are pure data \"\"\"\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await Timer(20, units=\"ns\")  # hold reset for 20ns\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut.encoder_data_in.value = 0x123456789ABCDEF0\n    dut.encoder_control_in.value = 0x00  # All data\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for data encoding test\n    dut._log.info(f\"Data Encoding Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b01, expected_data=0x123456789ABCDEF0)\n    \n    await RisingEdge(dut.clk_in)\n    # Set test inputs\n    dut.encoder_data_in.value = 0x0707070707070707\n    dut.encoder_control_in.value = 0xFF  # All control\n\n    await RisingEdge(dut.clk_in)\n    # Log inputs for all control symbols test\n    dut._log.info(f\"All Control Symbols Test:\\n\"\n                  f\"  encoder_data_in: {hex(int(dut.encoder_data_in.value))}\\n\"\n                  f\"  encoder_control_in: {bin(int(dut.encoder_control_in.value))}\")\n\n    # Apply test and check output\n    await check_output(dut, expected_sync=0b10, expected_data=0x1E00000000000000)  # Expected data output is zero\n\n\n@cocotb.test()\nasync def test_encoder_all_control_combinations(dut):\n    \"\"\"Cocotb test for 64b/66b encoder with full test cases and expected outputs\"\"\"\n\n    # Start the clock\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Test cases with expected values\n    test_cases = [\n        (0x0707070707070707, 0b11111111, 0x21e00000000000000),\n        (0x070707070707FDAE, 0b11111110, 0x299000000000000ae),\n        (0x0707070707FDA5A5, 0b11111100, 0x2aa0000000000a5a5),\n        (0x07070707FDFEED55, 0b11111000, 0x2b400000000feed55),\n        (0x070707FD99887766, 0b11110000, 0x2cc00000099887766),\n        (0x0707FDAABBCCDDEE, 0b11100000, 0x2d20000aabbccddee),\n        (0x07FDAAAAAA555555, 0b11000000, 0x2e100aaaaaa555555),\n        (0xFD773388229911AA, 0b10000000, 0x2ff773388229911aa),\n        (0xDDCCBBFB07070707, 0b00011111, 0x233ddccbb00000000),\n        (0x0707079C0707079C, 0b00010001, 0x255070707ff070707),\n        (0x3456789ABCDEF0FB, 0b00000001, 0x2783456789abcdef0),\n        (0x777777FBDEEDDE9C, 0b00010001, 0x2667777770fdeedde),\n        (0x07070707ABCDEF9C, 0b11110001, 0x24b0000000abcdeff),\n        (0xAAAAAA9C07070707, 0b00011111, 0x22daaaaaaf0000000),\n        (0xFEFEFEFEFEFEFEFE, 0b11111111, 0x21e3c78f1e3c78f1e),\n        (0x07070707070707FD, 0b11111111, 0x28700000000000000),\n    ]\n\n    # Apply test cases and compare DUT output with expected values\n    for idx, (data_in, control_in, expected_output) in enumerate(test_cases):\n        # Apply inputs\n        await RisingEdge(dut.clk_in)\n        dut.encoder_data_in.value = data_in\n        dut.encoder_control_in.value = control_in\n\n        # Wait for a clock cycle\n        await RisingEdge(dut.clk_in)\n        await RisingEdge(dut.clk_in)\n\n        # Get DUT output\n        dut_output = int(dut.encoder_data_out.value)\n\n        # Compare DUT output with expected output\n        assert dut_output == expected_output, (\n            f\"Test case {idx+1} failed: \"\n            f\"Data: {hex(data_in)}, Control: {bin(control_in)}, \"\n            f\"Expected: {hex(expected_output)}, Got: {hex(dut_output)}\"\n        )\n\n        dut._log.info(\n            f\"Test Case {idx + 1}:\\n\"\n            f\"  encoder_data_in: {hex(data_in)}\\n\"\n            f\"  encoder_control_in: {bin(control_in)}\\n\"\n            f\"  encoder_data_out (DUT): {hex(dut_output)}\\n\"\n            f\"  Expected: {hex(expected_output)}\"\n        )\n\n@cocotb.test()\nasync def test_encoder_all_octets_control(dut):\n    \"\"\"Cocotb test for 64b/66b encoder with full test cases and expected outputs\"\"\"\n\n    # Start the clock\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Test cases with expected values\n    test_cases = [\n        (0x0707070707070707, 0b11111111, 0x21e00000000000000),\n        (0xFEFEFEFEFEFEFEFE, 0b11111111, 0x21e3c78f1e3c78f1e),\n        (0x07070707070707FD, 0b11111111, 0x28700000000000000),\n    ]\n\n    # Apply test cases and compare DUT output with expected values\n    for idx, (data_in, control_in, expected_output) in enumerate(test_cases):\n        # Apply inputs\n        await RisingEdge(dut.clk_in)\n        dut.encoder_data_in.value = data_in\n        dut.encoder_control_in.value = control_in\n\n        # Wait for a clock cycle\n        await RisingEdge(dut.clk_in)\n        await RisingEdge(dut.clk_in)\n\n        # Get DUT output\n        dut_output = int(dut.encoder_data_out.value)\n\n        # Compare DUT output with expected output\n        assert dut_output == expected_output, (\n            f\"Test case {idx+1} failed: \"\n            f\"Data: {hex(data_in)}, Control: {bin(control_in)}, \"\n            f\"Expected: {hex(expected_output)}, Got: {hex(dut_output)}\"\n        )\n\n        dut._log.info(\n            f\"Test Case {idx + 1}:\\n\"\n            f\"  encoder_data_in: {hex(data_in)}\\n\"\n            f\"  encoder_control_in: {bin(control_in)}\\n\"\n            f\"  encoder_data_out (DUT): {hex(dut_output)}\\n\"\n            f\"  Expected: {hex(expected_output)}\"\n        )\n\n@cocotb.test()\nasync def test_encoder_mixed_data_control_octets(dut):\n    \"\"\"Cocotb test for 64b/66b encoder with full test cases and expected outputs\"\"\"\n\n    # Start the clock\n    clock = Clock(dut.clk_in, 10, units=\"ns\")  # 100 MHz\n    cocotb.start_soon(clock.start())\n    # Initialize DUT inputs\n    await dut_initialization(dut)\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.clk_in)\n\n    # Test cases with expected values\n    test_cases = [\n        (0x070707070707FDAE, 0b11111110, 0x299000000000000ae),\n        (0x0707070707FDA5A5, 0b11111100, 0x2aa0000000000a5a5),\n        (0x07070707FDFEED55, 0b11111000, 0x2b400000000feed55),\n        (0x070707FD99887766, 0b11110000, 0x2cc00000099887766),\n        (0x0707FDAABBCCDDEE, 0b11100000, 0x2d20000aabbccddee),\n        (0x07FDAAAAAA555555, 0b11000000, 0x2e100aaaaaa555555),\n        (0xFD773388229911AA, 0b10000000, 0x2ff773388229911aa),\n        (0xDDCCBBFB07070707, 0b00011111, 0x233ddccbb00000000),\n        (0x0707079C0707079C, 0b00010001, 0x255070707ff070707),\n        (0x3456789ABCDEF0FB, 0b00000001, 0x2783456789abcdef0),\n        (0x777777FBDEEDDE9C, 0b00010001, 0x2667777770fdeedde),\n        (0x07070707ABCDEF9C, 0b11110001, 0x24b0000000abcdeff),\n        (0xAAAAAA9C07070707, 0b00011111, 0x22daaaaaaf0000000),\n    ]\n\n\n    # Apply test cases and compare DUT output with expected values\n    for idx, (data_in, control_in, expected_output) in enumerate(test_cases):\n        # Apply inputs\n        await RisingEdge(dut.clk_in)\n        dut.encoder_data_in.value = data_in\n        dut.encoder_control_in.value = control_in\n\n        # Wait for a clock cycle\n        await RisingEdge(dut.clk_in)\n        await RisingEdge(dut.clk_in)\n\n        # Get DUT output\n        dut_output = int(dut.encoder_data_out.value)\n\n        # Compare DUT output with expected output\n        assert dut_output == expected_output, (\n            f\"Test case {idx+1} failed: \"\n            f\"Data: {hex(data_in)}, Control: {bin(control_in)}, \"\n            f\"Expected: {hex(expected_output)}, Got: {hex(dut_output)}\"\n        )\n\n        dut._log.info(\n            f\"Test Case {idx + 1}:\\n\"\n            f\"  encoder_data_in: {hex(data_in)}\\n\"\n            f\"  encoder_control_in: {bin(control_in)}\\n\"\n            f\"  encoder_data_out (DUT): {hex(dut_output)}\\n\"\n            f\"  Expected: {hex(expected_output)}\"\n        )\n    dut._log.info(\"All test cases passed!\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_IIR_filter_0015", "categories": ["cid014", "medium"], "input": {"prompt": "\nCan you add assertions in the RTL design of the  `iir_filter` module based on the following requirements:  \n\n---\n\n### **Assertion Requirements:**  \n1. **Reset Check**  \n   - Ensure all filter state variables (`x_prev1` to `x_prev6`, `y_prev1` to `y_prev6`, and `y`) **reset to zero** when `rst` is asserted.  \n   - If any register does not reset properly, an **error message should be displayed**.  \n\n2. **Input Stability Check**  \n   - Verify that **`x_prev1` always captures `x` correctly** on every clock cycle.  \n   - If `x_prev1` does not match the previous value of `x,` the assertion should trigger a warning.  \n\n3. **Shift Register Integrity**  \n   - Ensure that **input samples correctly shift across registers (`x_prev6` to `x_prev1`)**.  \n   - If the shift order is incorrect, an **error message should be displayed**.  \n\n4. **Output Range Check**  \n   - Ensure the filter **output `y` remains within the valid signed 16-bit range** (`-32768` to `32767`).  \n   - If `y` exceeds this range, a **warning message should be triggered** to indicate possible overflow.  \n\n### **Interface:**  \n#### **Inputs:**  \n- `clk (1-bit)`: The **positive-edged clock signal** driving the module.  \n- `rst (1-bit)`: The **active-high synchronous reset signal**, which resets the filter state.  \n- `x (16-bit, signed [15:0])`: A **signed 16-bit input sample** representing the current input to the IIR filter.  \n\n#### **Outputs:**  \n- `y (16-bit, signed [15:0])`: A **signed 16-bit output sample** representing the current filtered value.  \n\n---\n\n", "context": {"rtl/iir_filter.sv": "module iir_filter (\n    input logic clk,\n    input logic rst,\n    input logic signed [15:0] x,    // Input sample\n    output logic signed [15:0] y    // Output sample\n);\n\n    // Filter coefficients\n    parameter signed [15:0] b0 = 16'h0F00;\n    parameter signed [15:0] b1 = 16'h0E00;\n    parameter signed [15:0] b2 = 16'h0D00;\n    parameter signed [15:0] b3 = 16'h0C00;\n    parameter signed [15:0] b4 = 16'h0B00;\n    parameter signed [15:0] b5 = 16'h0A00;\n    parameter signed [15:0] b6 = 16'h0900;\n    parameter signed [15:0] a1 = -16'h0800;\n    parameter signed [15:0] a2 = -16'h0700;\n    parameter signed [15:0] a3 = -16'h0600;\n    parameter signed [15:0] a4 = -16'h0500;\n    parameter signed [15:0] a5 = -16'h0400;\n    parameter signed [15:0] a6 = -16'h0300;\n\n    // Explicitly declare each state variable\n    logic signed [15:0] x_prev1, x_prev2, x_prev3, x_prev4, x_prev5, x_prev6;\n    logic signed [15:0] y_prev1, y_prev2, y_prev3, y_prev4, y_prev5, y_prev6;\n\n    // Temporary accumulator (40-bit to prevent overflow)\n    logic signed [39:0] acc;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            x_prev1 <= 0; x_prev2 <= 0; x_prev3 <= 0;\n            x_prev4 <= 0; x_prev5 <= 0; x_prev6 <= 0;\n            y_prev1 <= 0; y_prev2 <= 0; y_prev3 <= 0;\n            y_prev4 <= 0; y_prev5 <= 0; y_prev6 <= 0;\n            y <= 0;\n        end else begin\n            // 40-bit accumulation\n            acc = (b0 * x) + (b1 * x_prev1) + (b2 * x_prev2) + (b3 * x_prev3) +\n                  (b4 * x_prev4) + (b5 * x_prev5) + (b6 * x_prev6) -\n                  (a1 * y_prev1) - (a2 * y_prev2) - (a3 * y_prev3) -\n                  (a4 * y_prev4) - (a5 * y_prev5) - (a6 * y_prev6);\n\n            // Scaling\n            acc = acc >>> 16;\n\n            // Saturation logic\n            if (acc > 16'sh7FFF) acc = 16'sh7FFF;\n            else if (acc < -16'sh8000) acc = -16'sh8000;\n            y <= acc[15:0];\n\n            // Update the historical data (shift registers)\n            x_prev6 <= x_prev5; x_prev5 <= x_prev4; x_prev4 <= x_prev3;\n            x_prev3 <= x_prev2; x_prev2 <= x_prev1; x_prev1 <= x;\n            y_prev6 <= y_prev5; y_prev5 <= y_prev4; y_prev4 <= y_prev3;\n            y_prev3 <= y_prev2; y_prev2 <= y_prev1; y_prev1 <= y;\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/iir_filter.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/iir_filter.sv\nTOPLEVEL        = iir_filter\nMODULE          = test_iir_filter\nPYTHONPATH      = /src\nHASH            = e14308b6d07bfe0bdf9dd1042187e6b968d41376\n", "src/test_iir_filter.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n@cocotb.test()\nasync def test_iir_filter(dut):\n    \"\"\"Test the IIR filter with various input patterns and monitor assertions.\"\"\"\n\n    # Start the clock (10ns period = 100MHz)\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Apply reset\n    dut.rst.value = 1\n    dut.x.value = 0\n    print(\"[INFO] Applying reset\")\n    await Timer(20, units=\"ns\")  # Wait for two clock cycles\n    dut.rst.value = 0\n    print(\"[INFO] Deasserting reset\")\n\n    # Wait for the system to stabilize\n    for _ in range(3):\n        await RisingEdge(dut.clk)\n\n    # Apply an impulse response (dirac delta function)\n    dut.x.value = 1 << 14  # Large single impulse\n    print(f\"[STIM] Impulse applied: {dut.x.value.signed_integer}\")\n    await RisingEdge(dut.clk)\n    dut.x.value = 0  # Zero input after impulse\n    print(f\"[STIM] Input set to zero after impulse\")\n\n    # Wait for response propagation\n    for _ in range(10):\n        await RisingEdge(dut.clk)\n\n    # Apply random noise input\n    print(\"[INFO] Applying random noise input\")\n    for _ in range(20):\n        rand_val = random.randint(-32768, 32767)\n        dut.x.value = rand_val\n        print(f\"[STIM] Random input: {rand_val}\")\n        await RisingEdge(dut.clk)\n\n    # Ensure shift registers are updating correctly (wait a few cycles)\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)  # Extra cycle for propagation\n\n    print(f\"[CHECK] x_prev1: {dut.x_prev1.value.signed_integer}, Expected: {dut.x.value.signed_integer}\")\n    print(f\"[CHECK] x_prev2: {dut.x_prev2.value.signed_integer}, Expected: {dut.x_prev1.value.signed_integer}\")\n    \n    assert dut.x_prev1.value.signed_integer == dut.x.value.signed_integer, \"Shift register failure in x_prev1\"\n    assert dut.x_prev2.value.signed_integer == dut.x_prev1.value.signed_integer, \"Shift register failure in x_prev2\"\n\n    print(\"[TEST PASSED] IIR filter shift registers updated correctly.\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_Serial_Line_Converter_0019", "categories": ["cid014", "medium"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the `serial_line_code_converter` module based on the design specifications provided? Please ensure that your assertions include clear error messages for simulation failures and follow industry standards for concise, effective verification.\n\n## Interface\n\n### Parameters\n- **`CLK_DIV`**: Specifies the clock divider for generating clk_pulse. The default value is 16. It must be a positive integer greater than or equal to 2.\n\n### Inputs\n- **`clk`**: System clock signal. The design operates synchronously with the rising edge of `clk`.\n- **`reset_n`**: Active-low asynchronous reset signal. When asserted low, it resets all internal states and outputs.\n- **`serial_in`**: Input signal carrying the serial data stream to be encoded according to the selected mode.\n- **`mode [2:0] `**: A 3-bit input that determines the encoding mode. Possible values:\n  - `000`: NRZ (Non-Return-to-Zero).\n  - `001`: RZ (Return-to-Zero).\n  - `010`: Differential Encoding.\n  - `011`: Inverted NRZ.\n  - `100`: NRZ with Alternating Bit Inversion.\n  - `101`: Parity Bit Output (Odd Parity).\n  - `110`: Scrambled NRZ.\n  - `111`: Edge-Triggered NRZ.\n\n### Outputs\n- **`serial_out`**: Encoded output signal. The encoding applied to `serial_in` is determined by the value of the `mode` input. The output updates on every clock cycle based on the selected encoding method.\n\n## Design Specifications\n\nThe module implements several encoding schemes and uses internal signals and registers to capture previous input values, generate a clock pulse via a divider, and compute various encoded outputs:\n\n### Clock Divider and Sampling Pulse:\n\n- A counter increments on each clock cycle and resets when it reaches CLK_DIV - 1.\n- A sampling pulse is generated high for one clock cycle when the counter resets; this pulse is used for the Return-to-Zero mode.\n\n### Edge Detection and Input History:\n\n- The module captures previous values of serial_in in registers (prev_value and prev_serial_in) to facilitate edge detection and differential encoding.\n\n### Encoding Implementations\n1. **NRZ (Non-Return-to-Zero)**: Direct pass-through of `serial_in`.\n2. **RZ (Return-to-Zero)**: Outputs high only during the first half of the clock cycle when `serial_in` is high.\n3. **Differential Encoding**: Outputs the XOR of the current and previous serial input.\n4. **Inverted NRZ**: Outputs the inverted value of `serial_in`.\n5. **NRZ with Alternating Bit Inversion**: Inverts every alternate bit of `serial_in`.\n6. **Parity Bit Output (Odd Parity)**: Generates an odd parity bit based on the serial input.\n7. **Scrambled NRZ**: XORs `serial_in` with the least significant bit of the clock counter for scrambling.\n8. **Edge-Triggered NRZ**: Detects rising edges of `serial_in` and outputs accordingly.\n\n## Assertion Requirements\n\nDevelop a set of SystemVerilog assertions to validate the following behaviors: All assertions are evaluated on the rising edge of clk and assertions are disabled when reset_n is low.\n\n#### NRZ Mode (3'b000):\n- **Condition**: Mode is `3'b000`.\n- **Expected Behavior**: `serial_out` must equal the current sampled value of `serial_in`.\n\n#### Return-to-Zero (RZ) Mode (3'b001):\n- **Condition**: Mode is `3'b001`.\n- **Expected Behavior**: `serial_out` must equal the logical AND of `serial_in` and `clk_pulse`.\n\n#### Differential Encoding Mode (3'b010):\n- **Condition**: Mode is `3'b010`.\n- **Expected Behavior**: `serial_out` must be the XOR of the current `serial_in` and its previous state.\n\n#### Inverted NRZ Mode (3'b011):\n- **Condition**: Mode is `3'b011`.\n- **Expected Behavior**: `serial_out` must equal the inverted `serial_in`.\n\n#### Alternating Inversion Mode (3'b100):\n- **Condition**: Mode is `3'b100`.\n- **Expected Behavior**: `serial_out` must alternate between `serial_in` and its inverted value on successive clock cycles.\n\n#### Parity Mode (3'b101):\n- **Condition**: Mode is `3'b101`.\n- **Expected Behavior**: `serial_out` should equal the XOR of `serial_in` and the accumulated parity bit.\n\n#### Scrambled NRZ Mode (3'b110):\n- **Condition**: Mode is `3'b110`.\n- **Expected Behavior**: `serial_out` must equal the XOR of `serial_in` and the least-significant bit of the clock divider counter.\n\n#### Edge-Triggered NRZ Mode (3'b111):\n- **Condition**: Mode is `3'b111`.\n- **Expected Behavior**: `serial_out` must be high only when a rising edge is detected on `serial_in`.\n\nCan you add SystemVerilog assertions to this RTL design to validate all of the specified behaviors and ensure that each encoding mode operates according to the detailed specifications? Please include descriptive error messages for any simulation failures and follow industry standards for concise, effective verification.", "context": {"rtl/serial_line_code_converter.sv": "module serial_line_code_converter #(parameter CLK_DIV = 16)(\n    input  logic clk,             // System clock\n    input  logic reset_n,         // Active-low reset\n    input  logic serial_in,       // Serial input signal\n    input  logic [2:0] mode,      // Mode selector\n    output logic serial_out       // Serial output signal\n);\n\n    // Internal signals\n    logic [3:0] clk_counter;      // Clock divider counter\n    logic clk_pulse;              // Clock pulse for sampling\n    logic prev_serial_in;         // Previous serial input for edge detection\n    logic prev_value;             // Holds the previous value of serial_in\n    logic nrz_out;                // NRZ encoding output\n    logic rz_out;                 // Return-to-Zero encoding output\n    logic diff_out;               // Differential encoding output\n    logic inv_nrz_out;            // Inverted NRZ output\n    logic alt_invert_out;         // NRZ with alternating bit inversion output\n    logic alt_invert_state;       // State for alternating inversion\n    logic parity_out;             // Parity Bit Output\n    logic scrambled_out;          // Scrambled NRZ output\n    logic edge_triggered_out;     // Edge-Triggered NRZ output\n\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            clk_counter <= 0;\n            clk_pulse <= 0;\n        end else if (clk_counter == CLK_DIV - 1) begin\n            clk_counter <= 0;\n            clk_pulse <= 1;\n        end else begin\n            clk_counter <= clk_counter + 1;\n            clk_pulse <= 0;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            prev_value <= 0;\n            prev_serial_in <= 0;\n        end else begin\n            prev_value <= serial_in;\n            prev_serial_in <= prev_value;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            nrz_out <= 0;\n        end else begin\n            nrz_out <= serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            rz_out <= 0;\n        end else begin\n            rz_out <= serial_in & clk_pulse; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            diff_out <= 0;\n        end else  begin\n            diff_out <= serial_in ^ prev_serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            inv_nrz_out <= 0;\n        end else  begin\n            inv_nrz_out <= ~serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            alt_invert_out <= 0;\n            alt_invert_state <= 0;\n        end else  begin\n            alt_invert_state <= ~alt_invert_state; \n            alt_invert_out <= alt_invert_state ? ~serial_in : serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            parity_out <= 0;\n        end else  begin\n            parity_out <= serial_in ^ parity_out; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            scrambled_out <= 0;\n        end else  begin\n            scrambled_out <= serial_in ^ clk_counter[0]; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            edge_triggered_out <= 0;\n        end else  begin\n            edge_triggered_out <= (serial_in & ~prev_serial_in);\n        end\n    end\n\n    always_comb begin\n        case (mode)\n            3'b000: serial_out = nrz_out;                \n            3'b001: serial_out = rz_out;                 \n            3'b010: serial_out = diff_out;               \n            3'b011: serial_out = inv_nrz_out;            \n            3'b100: serial_out = alt_invert_out;         \n            3'b101: serial_out = parity_out;             \n            3'b110: serial_out = scrambled_out;          \n            3'b111: serial_out = edge_triggered_out;     \n            default: serial_out = 0;                     \n        endcase\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/serial_line_code_converter.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/serial_line_code_converter.sv\nTOPLEVEL        = serial_line_code_converter\nMODULE          = test_serial_line_code_converter\nPYTHONPATH      = /src\nRANDOM_SEED     = 1735141348\nHASH            = c1de9d38616f093f828f98be1e471e224e3b1141", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_serial_line_code_converter.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ReadOnly, Timer\n\nimport harness_library as hrs_lb\nimport random\n\n# Function to calculate the expected output based on mode\ndef calculate_expected_output(serial_in, prev_serial_in, mode, clk_pulse, counter, parity_state, invert_state):\n    if mode == 0:  # NRZ\n        return serial_in\n    elif mode == 1:  # Return-to-Zero\n        return serial_in and clk_pulse\n    elif mode == 2:  # Differential Encoding\n        return serial_in ^ prev_serial_in\n    elif mode == 3:  # Inverted NRZ\n        return not serial_in\n    elif mode == 4:  # Alternate Inversion\n        return not serial_in if invert_state else serial_in\n    elif mode == 5:  # Parity-Added\n        return parity_state ^ serial_in\n    elif mode == 6:  # Scrambled NRZ\n        return serial_in ^ (counter % 2)\n    elif mode == 7:  # Edge-Triggered NRZ\n        return serial_in and not prev_serial_in\n    return 0\n\n@cocotb.test()\nasync def test_serial_line_code_converter(dut):\n    CLK_DIV = int(dut.CLK_DIV.value)\n\n    # Start the clock with a 10ns time period (100 MHz clock)\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n\n    # Local variables to simulate RTL behavior\n    tb_counter = 0\n    tb_clk_pulse = 0\n    tb_parity_state = 0\n    tb_alt_invert_state = 0\n    prev_serial_in = 0\n\n    await Timer(10, units=\"ns\")\n\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=True)\n\n    await RisingEdge(dut.clk) \n\n\n    # Handle reset behavior\n    if dut.reset_n.value == 0:\n        tb_counter = 0\n        tb_clk_pulse = 0\n        tb_parity_state = 0\n        tb_alt_invert_state = 0\n        expected_output = 0\n    else:\n        # Update the clock counter and pulse\n        if tb_counter == CLK_DIV - 1:\n            tb_counter = 0\n            tb_clk_pulse = 1\n        else:\n            tb_counter += 1\n            tb_clk_pulse = 0\n\n        # Generate a random serial input\n        serial_in = random.randint(0, 1)\n        dut.serial_in.value = serial_in\n\n        # Update parity state for odd parity\n        tb_parity_state ^= serial_in\n\n        # Update alternating inversion state\n        tb_alt_invert_state = not tb_alt_invert_state\n\n    # Iterate over all modes\n    for mode in range(8):\n        dut.mode.value = mode\n\n        # Simulate for 10 cycles per mode\n        for i in range(10):\n            # Update test state variables\n\n            await FallingEdge(dut.clk)\n            serial_in = random.randint(0, 1)\n            dut.serial_in.value = serial_in\n\n\n            # Calculate expected output\n            expected_output = calculate_expected_output(\n                serial_in,\n                prev_serial_in,\n                mode,\n                tb_clk_pulse,\n                tb_counter,\n                tb_parity_state,\n                tb_alt_invert_state\n            )\n            \n\n            # Display current state and DUT outputs\n            dut._log.info(\n                f\"Mode: {mode} | serial_in: {serial_in} | prev_serial_in: {prev_serial_in} | serial_out: {int(dut.serial_out.value)} \"\n            )\n            await FallingEdge(dut.clk)\n            # Check DUT output\n            assert int(dut.serial_out.value) == expected_output, (\n                f\"Mode {mode}: Expected {expected_output}, Got {int(dut.serial_out.value)} \"\n                f\"for serial_in={serial_in}, prev_serial_in={prev_serial_in}, clk_pulse={int(tb_clk_pulse)}, counter={tb_counter}\"\n            )\n\n            # Update previous serial input\n            prev_serial_in = serial_in\n        \n\n\n        # Add separation between modes\n        await RisingEdge(dut.clk)\n\n    # Final message\n    dut._log.info(\"All modes and test cases passed.\")\n    await RisingEdge(dut.clk)\n    dut.reset_n.value = 0\n    await FallingEdge(dut.clk)\n    assert dut.serial_out.value == 0, \"serial_out should be 0 during reset\"\n    assert dut.clk_pulse.value == 0, \"clk_pulse should be 0 during reset\"\n    assert dut.clk_counter.value == 0, \"clk_counter should be 0 during reset\"\n    assert dut.prev_serial_in.value == 0, \"prev_serial_in should be 0 during reset\"\n    assert dut.alt_invert_state.value == 0, \"alt_invert_state should be 0 during reset\"\n    assert dut.parity_out.value == 0, \"parity_out should be 0 during reset\"\n    await RisingEdge(dut.clk)\n    dut.reset_n.value = 1\n    dut._log.info(\"Reset behavior passed. Resuming normal operation...\")\n\n    dut.mode.value = 0\n\n    await FallingEdge(dut.clk)\n    serial_in = random.randint(0, 1)\n    dut.serial_in.value = serial_in\n\n\n    # Calculate expected output\n    expected_output = calculate_expected_output(\n        serial_in,\n        prev_serial_in,\n        int(dut.mode.value),\n        tb_clk_pulse,\n        tb_counter,\n        tb_parity_state,\n        tb_alt_invert_state\n    )\n            \n    await FallingEdge(dut.clk)\n    # Check DUT output\n    assert int(dut.serial_out.value) == expected_output, (\n        f\"Mode {mode}: Expected {expected_output}, Got {int(dut.serial_out.value)} \"\n        f\"for serial_in={serial_in}, prev_serial_in={prev_serial_in}, clk_pulse={int(dut.clk_pulse.value)}, counter={tb_counter}\"\n    )\n\n    # Update previous serial input\n    prev_serial_in = serial_in\n        \n\n\n    # Add separation between modes\n    await RisingEdge(dut.clk)\n"}}}
{"id": "cvdp_copilot_Synchronous_Muller_C_Element_0013", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `sync_muller_c_element` module. The assertions should ensure correct reset behavior, pipeline data retention, and output conditions based on the input signals.  \n\n## **RTL Design Overview**  \nThe `sync_muller_c_element` module implements a **Synchronous Muller C-element with pipeline stages**. It synchronizes Multi-bit input signals (`inp`) through a **pipeline of configurable depth (`PIPE_DEPTH`)** and produces an output (`out`) based on the logical states of the last pipeline stage.  \n\n### **Key Components of the Module**  \n- **`pipe`**: A pipeline register array storing intermediate states of input signals.  \n- **`clk_en`**: Acive high signal. Enables pipeline updates and output on clock edges.  \n- **`clr`**: Acive high signal. Clears the pipeline and output.  \n- **`srst`**: Synchronous active high reset signal.  \n- **`out`**: The final computed output based on the last stage of the pipeline.  \n- **`clk`** Clock signal. Design is synchronized to the posedge of this clock\n- **`[NUM_INPUT-1:0] inp`**: Input signals (NUM_INPUT-width vector)\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n\n- **Clear signal Behavior:**  \n  - When `clr` is asserted, `out` should be **cleared to `0`** on the next clock cycle.  \n\n- **Clock Enable Control:**  \n  - When `clk_en` is **low**, the pipeline should **retain** its previous state.  \n\n- **Output High Condition:**  \n  - If all inputs in the **last pipeline stage** are **high**, then `out` should be `1`.  \n\n- **Output Low Condition:**  \n  - If all inputs in the **last pipeline stage** are **low**, then `out` should be `0`.  \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.  ", "context": {"rtl/sync_muller_c_element.sv": "module sync_muller_c_element #(\n  parameter NUM_INPUT  = 2, // Number of input signals\n  parameter PIPE_DEPTH = 1  // Number of pipeline stages\n) (\n  input  logic                  clk   , // Clock signal\n  input  logic                  srst  , // Synchronous reset signal\n  input  logic                  clr   , // Clear pipeline and output\n  input  logic                  clk_en, // Clock enable signal\n  input  logic  [NUM_INPUT-1:0] inp   , // Input signals (NUM_INPUT-width vector)\n  output logic                  out     // Output signal\n);\n\n  // Pipeline to store intermediate states of inputs\n  logic [(PIPE_DEPTH*NUM_INPUT)-1:0] pipe; \n  genvar i;\n\n  // Generate block for pipeline implementation\n  generate\n    for (i = 0; i < PIPE_DEPTH; i = i + 1) begin : pipeline_stage\n      always_ff @(posedge clk) begin\n        if (srst | clr) begin\n          // Reset the pipeline stage\n          pipe[i*NUM_INPUT+:NUM_INPUT] <= '0;\n        end\n        else if (clk_en) begin\n          if (i == 0) begin\n            // Load inputs into the first stage of the pipeline\n            pipe[i*NUM_INPUT+:NUM_INPUT] <= inp;\n          end\n          else begin\n            // Shift data from the previous stage to the current stage\n            pipe[i*NUM_INPUT+:NUM_INPUT] <= pipe[(i-1)*NUM_INPUT+:NUM_INPUT];\n          end\n        end\n      end\n    end\n  endgenerate\n\n  // Always block to compute the output signal\n  always_ff @(posedge clk) begin\n    if (srst | clr) begin\n      // Reset the output signal\n      out <= 1'b0;\n    end\n    else if (clk_en) begin\n      // Output logic: High if all inputs in the last pipeline stage are high\n      // Low if all inputs in the last pipeline stage are low\n      if (&pipe[(PIPE_DEPTH-1)*NUM_INPUT+:NUM_INPUT]) begin\n        out <= 1'b1; \n      end\n      else if (!(|pipe[(PIPE_DEPTH-1)*NUM_INPUT+:NUM_INPUT])) begin\n        out <= 1'b0;\n      end\n    end\n  end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sync_muller_c_element.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sync_muller_c_element.sv\nTOPLEVEL        = sync_muller_c_element\nMODULE          = test_sync_muller_c_element\nPYTHONPATH      = /src\nHASH            = 13-rtl-assertion-generation-for-synchronous-muller-c-element", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner(NUM_INPUT: int=2, PIPE_DEPTH: int=1):\n    parameters = {\n        \"NUM_INPUT\": NUM_INPUT,\n        \"PIPE_DEPTH\": PIPE_DEPTH,\n    }\n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n\n# Random Synchronous Muller C Element Tests\n# Generate random parameters for the Synchronous Muller C Element testbench and run the test multiple times\n@pytest.mark.parametrize(\"random_test\", range(3))\ndef test_random_sync_muller_c_element(random_test):\n  # Generate random dimensions for the matrices\n  NUM_INPUT = random.randint(1, 8)\n  PIPE_DEPTH = random.randint(1, 8)\n\n  # Run the test with the generated parameters\n  call_runner(NUM_INPUT=NUM_INPUT, PIPE_DEPTH=PIPE_DEPTH)\n\n", "src/test_sync_muller_c_element.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport harness_library as hrs_lb\nimport math\n\n# ----------------------------------------\n# - Synchornous Muller C Element Test\n# ----------------------------------------\n\nasync def reset_dut(dut, duration_ns=10):\n    \"\"\"\n    Perform a synchronous reset on the Design Under Test (DUT).\n\n    - Sets the reset signal high for the specified duration.\n    - Ensures all output signals are zero during the reset.\n    - Deactivates the reset signal and stabilizes the DUT.\n\n    Args:\n        dut: The Design Under Test (DUT).\n        duration_ns: The time duration in nanoseconds for which the reset signal will be held high.\n    \"\"\"\n    dut.srst.value = 1  # Activate reset (set to high)\n    await Timer(duration_ns, units=\"ns\")  # Hold reset high for the specified duration\n    await Timer(1, units=\"ns\")\n\n    # Verify that outputs are zero during reset\n    assert dut.out.value == 0, f\"[ERROR] out is not zero during reset: {dut.out.value}\"\n\n    dut.srst.value = 0  # Deactivate reset (set to low)\n    await Timer(duration_ns, units='ns')  # Wait for the reset to stabilize\n    dut.srst._log.debug(\"Reset complete\")\n\ndef weighted_random_input(num_inputs):\n    \"\"\"\n    Generate weighted random inputs.\n\n    Args:\n        num_inputs: Number of input bits.\n\n    Returns:\n        An integer representing the input vector.\n    \"\"\"\n    if random.random() < 0.6:  # 60% chance to generate all 0's or all 1's\n        return 0 if random.random() < 0.5 else (1 << num_inputs) - 1\n    else:  # 40% chance to generate other combinations\n        return random.randint(0, (1 << num_inputs) - 1)\n\n\n@cocotb.test()\nasync def test_sync_muller_c_element(dut):\n  \"\"\"\n  Verify the functionality of the sync_muller_c_element module with weighted random input vectors.\n\n  Test Steps:\n  1. Perform a synchronous reset.\n  2. Drive the DUT with weighted random inputs.\n  3. Verify correctness of the output based on input logic.\n  4. Cover scenarios including reset and stable input combinations.\n  \"\"\"\n\n  # Start the clock with a 10ns period\n  cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few clock cycles to ensure proper initialization\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve DUT configuration parameters\n  num_inputs = int(dut.NUM_INPUT.value)\n  pipe_depth = int(dut.PIPE_DEPTH.value)\n  num_samples = 20\n\n  # Print parameters for debugging\n  print(f\"NUM_INPUT: {num_inputs}\")\n  print(f\"PIPE_DEPTH: {pipe_depth}\")\n\n  # Test with weighted random input vectors\n  in_queue = []\n  out_queue = []\n  dut.clk_en.value = 1\n\n  for i in range(num_samples):\n    # Generate a random input\n    random_input = weighted_random_input(num_inputs)\n    dut.inp.value = random_input\n    # Add input to the queue for later verification\n    in_queue.append(random_input)\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Handle pipeline delay outputs\n  for i in range(pipe_depth):\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Remove outputs corresponding to initial pipeline latency\n  for i in range(pipe_depth):\n    prev_out = out_queue.pop(0)\n\n  # Perform verification of DUT outputs\n  for i in range(num_samples):\n    # Retrieve the input and output from the queues\n    in_temp = in_queue.pop(0)\n    out_temp = out_queue.pop(0)\n    \n    # Compute the expected output\n    all_high = (1 << num_inputs) - 1\n    all_low  = 0\n\n    expected_output = 1 if (in_temp == all_high) else (0 if (in_temp == all_low) else prev_out)\n\n    # Verify that the DUT output matches the expected output\n    assert out_temp == expected_output, f\"Test {i+1}: Output does not match the expected result: {out_temp} != {expected_output}\"\n\n    print(f\"Test {i+1} passed\")\n    prev_out = out_temp\n\n  # Wait for a few cycles before performing a final reset\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply a final reset to the DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles after reset to stabilize\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n\n@cocotb.test()\nasync def test_sync_muller_c_element_with_clk_en_toggle(dut):\n  \"\"\"\n  Verify the functionality of sync_muller_c_element with clock enable toggling.\n\n  Test Steps:\n  1. Perform a synchronous reset.\n  2. Toggle clock enable at specific intervals.\n  3. Drive inputs and verify outputs during enabled and disabled periods.\n  \"\"\"\n\n  # Start the clock with a 10ns period\n  cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few clock cycles to ensure proper initialization\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve DUT configuration parameters\n  num_inputs = int(dut.NUM_INPUT.value)\n  pipe_depth = int(dut.PIPE_DEPTH.value)\n  num_samples = 30\n\n  # Print parameters for debugging\n  print(f\"NUM_INPUT: {num_inputs}\")\n  print(f\"PIPE_DEPTH: {pipe_depth}\")\n\n  # Test with clock enable toggle\n  in_queue = []\n  out_queue = []\n  clk_en = 1\n  dut.clk_en.value = clk_en\n\n  for i in range(num_samples):\n\n    if (i  == 10):\n      clk_en = 0\n    elif (i  == 20):\n      clk_en = 1\n\n    dut.clk_en.value = clk_en\n\n    # Generate a random input\n    random_input = weighted_random_input(num_inputs)\n    dut.inp.value = random_input\n    # Add input to the queue for later verification\n    if (clk_en):\n      in_queue.append(random_input)\n\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Handle pipeline delay outputs\n  for i in range(pipe_depth):\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Remove outputs corresponding to initial pipeline latency\n  for i in range(pipe_depth):\n    prev_out = out_queue.pop(0)\n\n  # Perform verification of DUT outputs\n  for i in range(num_samples):\n    if (i >= (10 - pipe_depth) and i <= (19 - pipe_depth)):\n      expected_output = prev_out\n      out_temp = out_queue.pop(0)\n    else:\n      # Retrieve the input and output from the queues\n      in_temp = in_queue.pop(0)\n      out_temp = out_queue.pop(0)\n      \n      # Compute the expected output\n      all_high = (1 << num_inputs) - 1\n      all_low  = 0\n      expected_output = 1 if (in_temp == all_high) else (0 if (in_temp == all_low) else prev_out)\n\n    # Verify that the DUT output matches the expected output\n    assert out_temp == expected_output, f\"Test {i+1}: Output does not match the expected result: {out_temp} != {expected_output}\"\n\n    print(f\"Test {i+1} passed\")\n    prev_out = out_temp\n\n  # Wait for a few cycles before performing a final reset\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply a final reset to the DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles after reset to stabilize\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n\n\n@cocotb.test()\nasync def test_sync_muller_c_element_with_clr_toggle(dut):\n  \"\"\"\n  Verify the functionality of sync_muller_c_element with clear signal toggling.\n\n  Test Steps:\n  1. Perform a synchronous reset.\n  2. Drive inputs with random data.\n  3. Toggle the clear signal and verify output behavior.\n  \"\"\"\n\n  # Start the clock with a 10ns period\n  cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few clock cycles to ensure proper initialization\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve DUT configuration parameters\n  num_inputs = int(dut.NUM_INPUT.value)\n  pipe_depth = int(dut.PIPE_DEPTH.value)\n  num_samples = 30\n\n  # Print parameters for debugging\n  print(f\"NUM_INPUT: {num_inputs}\")\n  print(f\"PIPE_DEPTH: {pipe_depth}\")\n\n  # Test with clear signal toggling\n  in_queue = []\n  out_queue = []\n  dut.clk_en.value = 1\n  clr = 0\n  dut.clr.value = clr\n\n  for i in range(num_samples):\n    # Generate a random input\n    random_input = weighted_random_input(num_inputs)\n    dut.inp.value = random_input\n    # Add input to the queue for later verification\n    in_queue.append(random_input)\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n    if (i == 20):\n      clr = 1\n      dut.clr.value = clr\n\n  # Handle pipeline delay outputs\n  for i in range(pipe_depth):\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Remove outputs corresponding to initial pipeline latency\n  for i in range(pipe_depth):\n    prev_out = out_queue.pop(0)\n\n  # Perform verification for DUT Outputs\n  for i in range(num_samples):\n    # Retrieve the input and output from the queues\n    in_temp = in_queue.pop(0)\n    out_temp = out_queue.pop(0)\n    \n    # Compute the expected output\n    all_high = (1 << num_inputs) - 1\n    all_low  = 0\n\n    if (i > (20 - pipe_depth)):\n      expected_output = 0\n    else:\n      expected_output = 1 if (in_temp == all_high) else (0 if (in_temp == all_low) else prev_out)\n\n    # Verify that the DUT output matches the expected output\n    assert out_temp == expected_output, f\"Test {i+1}: Output does not match the expected result: {out_temp} != {expected_output}\"\n\n    print(f\"Test {i+1} passed\")\n    prev_out = out_temp\n\n  # Wait for a few cycles before performing a final reset\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply a final reset to the DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles after reset to stabilize\n  for k in range(2):\n    await RisingEdge(dut.clk)"}}}
{"id": "cvdp_copilot_ahb_clk_counter_0004", "categories": ["cid014", "easy"], "input": {"prompt": "Create an SVA Assertion for Counter Overflow Reset in `ahb_clock_counter`\n\n## Description\nWe need a **SystemVerilog Assertion (SVA)** to validate the behavior of the `COUNTER` in the `ahb_clock_counter` module. Specifically, the assertion should ensure that when the counter reaches the `max_count` value, it resets to `0` on the next clock cycle if the `enable` signal is active.\n\n## Assertion Details\nThe assertion should follow these conditions:\n- It should trigger on the rising edge of `HCLK`.\n- It must be disabled when `HRESETn` is de-asserted.\n- The `COUNTER` should reset to `0` once it reaches the value of `max_count` and `enable` is active.\n\n## Expected Behavior\nIf the property fails, the assertion should report the current values of `COUNTER` and `max_count` to help debug the issue.", "context": {"rtl/ahb_clock_counter.sv": "module ahb_clock_counter #(\n    parameter ADDR_WIDTH = 32, // Width of the address bus\n    parameter DATA_WIDTH = 32  // Width of the data bus\n)(\n    input wire HCLK,                       // AHB Clock\n    input wire HRESETn,                    // AHB Reset (Active Low)\n    input wire HSEL,                       // AHB Select\n    input wire [ADDR_WIDTH-1:0] HADDR,     // AHB Address\n    input wire HWRITE,                     // AHB Write Enable\n    input wire [DATA_WIDTH-1:0] HWDATA,    // AHB Write Data\n    input wire HREADY,                     // AHB Ready Signal\n    output reg [DATA_WIDTH-1:0] HRDATA,    // AHB Read Data\n    output reg HRESP,                      // AHB Response\n    output reg [DATA_WIDTH-1:0] COUNTER    // Counter Output\n);\n\n    // Internal Registers\n    reg [DATA_WIDTH-1:0] max_count;          // Maximum value before overflow\n    reg overflow;                            // Overflow flag\n    reg enable;                              // Enable signal for counter\n\n    // Address Map\n    localparam [ADDR_WIDTH-1:0] ADDR_START    = {ADDR_WIDTH{1'b0}};          // 0x00000000\n    localparam [ADDR_WIDTH-1:0] ADDR_STOP     = {ADDR_WIDTH{1'b0}} + 4;      // 0x00000004\n    localparam [ADDR_WIDTH-1:0] ADDR_COUNTER  = {ADDR_WIDTH{1'b0}} + 8;      // 0x00000008\n    localparam [ADDR_WIDTH-1:0] ADDR_OVERFLOW = {ADDR_WIDTH{1'b0}} + 12;     // 0x0000000C\n    localparam [ADDR_WIDTH-1:0] ADDR_MAXCNT   = {ADDR_WIDTH{1'b0}} + 16;     // 0x00000010\n\n    // AHB Write Operation\n    always @(posedge HCLK or negedge HRESETn) begin\n        if (!HRESETn) begin\n            enable <= 1'b0;\n            max_count <= {DATA_WIDTH{1'b1}}; // Default max count to max possible value\n        end else if (HSEL && HWRITE && HREADY) begin\n            case (HADDR)\n                ADDR_START:    enable <= HWDATA[0]; // Set start signal\n                ADDR_STOP:     enable <= !HWDATA[0];  // Set stop signal\n                ADDR_MAXCNT:   max_count <= HWDATA; // Update max_count\n                default:       ; // Do nothing for undefined addresses\n            endcase\n        end\n    end\n\n    // Counter and Overflow Logic\n    always @(posedge HCLK or negedge HRESETn) begin\n        if (!HRESETn) begin\n            COUNTER <= {DATA_WIDTH{1'b0}};\n            overflow <= 1'b0;\n        end else begin\n            if (enable) begin\n                if (COUNTER < max_count) begin\n                    COUNTER <= COUNTER + 1; // Increment counter\n                end else begin\n                    COUNTER <= {DATA_WIDTH{1'b0}}; // Reset counter on overflow\n                    overflow <= 1'b1; // Set overflow flag\n                end\n            end\n        end\n    end\n\n    // AHB Read Operation\n    always @(*) begin\n        if (HSEL && !HWRITE && HREADY) begin\n            case (HADDR)\n                ADDR_START:    HRDATA = {{DATA_WIDTH-1{1'b0}}, enable};\n                ADDR_STOP:     HRDATA = {{DATA_WIDTH-1{1'b0}}, !enable};\n                ADDR_COUNTER:  HRDATA = COUNTER;\n                ADDR_OVERFLOW: HRDATA = {{DATA_WIDTH-1{1'b0}}, overflow};\n                ADDR_MAXCNT:   HRDATA = max_count;\n                default:       HRDATA = {DATA_WIDTH{1'b0}}; // Default read value\n            endcase\n        end else begin\n            HRDATA = {DATA_WIDTH{1'b0}};\n        end\n        HRESP = 1'b0; // Always OKAY response\n    end\n\nendmodule : ahb_clock_counter"}}, "output": {"response": "", "context": {"rtl/ahb_clock_counter.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ahb_clock_counter.sv\nTOPLEVEL        = ahb_clock_counter\nMODULE          = test_ahb_clock_counter\nPYTHONPATH      = /src\nHASH            = 4894af918a89a58a4e83db2e94c85b22fd970e73", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n", "src/test_ahb_clock_counter.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nimport math\n\n@cocotb.test()\nasync def test_ahb_clock_counter(dut):\n    \"\"\"Test AHB Clock Counter module functionality.\"\"\"\n\n    # Start clock with a period of 10 ns\n    cocotb.start_soon(Clock(dut.HCLK, 10, units='ns').start())\n\n    # Reset the design\n    dut.HRESETn.value = 1\n    await Timer(5, units='ns')\n    dut.HRESETn.value = 0\n    await Timer(10, units='ns')\n    dut.HRESETn.value = 1\n\n    # Initialize inputs\n    dut.HSEL.value = 0\n    dut.HWRITE.value = 0\n    dut.HREADY.value = 1\n    dut.HADDR.value = 0\n    dut.HWDATA.value = 0\n\n    # Wait for the reset to complete\n    await RisingEdge(dut.HCLK)\n\n    # Write to the ADDR_MAXCNT to set a maximum count\n    max_count = 10\n    assert max_count <= int(math.pow(2, int(dut.DATA_WIDTH.value)) - 1)\n    dut.HSEL.value = 1\n    dut.HWRITE.value = 1\n    dut.HADDR.value = 0x10  # ADDR_MAXCNT\n    dut.HWDATA.value = max_count\n    await RisingEdge(dut.HCLK)\n\n    # Start the counter by writing to ADDR_START\n    dut.HADDR.value = 0x00  # ADDR_START\n    dut.HWDATA.value = 1\n    await RisingEdge(dut.HCLK)\n\n    # Monitor the COUNTER output\n    dut.HWRITE.value = 0  # Set to read mode\n    counter_val = 0\n    for i in range(max_count + 5):  # Run for max_count + extra cycles\n        dut.HADDR.value = 0x08  # ADDR_COUNTER\n        await RisingEdge(dut.HCLK)\n        if 0 < counter_val < (max_count - 2):\n            assert int(dut.HRDATA.value) == counter_val + 2\n            assert int(dut.HRDATA.value) == int(dut.COUNTER.value)\n            assert int(dut.HRESP.value) == 0 # HRESP returned ok\n        counter_val = int(dut.HRDATA.value)\n        print(f\"Cycle {i}, Counter: {counter_val}\")\n\n        # Check for overflow\n        dut.HADDR.value = 0x0C  # ADDR_OVERFLOW\n        await RisingEdge(dut.HCLK)\n        assert int(dut.HRESP.value) == 0  # HRESP returned ok\n        overflow = int(dut.HRDATA.value)\n        print(f\"Cycle {i}, Overflow: {overflow}\")\n\n        if i == max_count:\n            assert overflow == 1, \"Overflow should occur at max_count\"\n\n    # Stop the counter by writing to ADDR_STOP\n    dut.HWRITE.value = 1\n    dut.HADDR.value = 0x04  # ADDR_STOP\n    dut.HWDATA.value = 1\n    await RisingEdge(dut.HCLK)\n\n    # Verify the counter stops\n    dut.HWRITE.value = 0  # Set to read mode\n    for _ in range(3):  # Check for a few cycles\n        dut.HADDR.value = 0x08  # ADDR_COUNTER\n        await RisingEdge(dut.HCLK)\n        assert int(dut.HRESP.value) == 0  # HRESP returned ok\n        assert int(dut.HRDATA.value) == int(dut.COUNTER.value)\n        stopped_value = int(dut.HRDATA.value)\n        print(f\"Stopped Counter: {stopped_value}\")\n\n    max_count = int(math.pow(2, int(dut.DATA_WIDTH.value)) - 1)\n\n    # Restrict this part of the test to instances where the maximum counter value is small (<= 255),\n    # to avoid excessively long runtimes for the test.\n    if max_count <= 255:\n        print(\"Running test for Max Counter\")\n\n        # Write to the ADDR_MAXCNT to set a maximum count\n        dut.HSEL.value = 1\n        dut.HWRITE.value = 1\n        dut.HADDR.value = 0x10  # ADDR_MAXCNT\n        dut.HWDATA.value = max_count\n        await RisingEdge(dut.HCLK)\n        print(f\"Set the new Max Counter={max_count}\")\n\n        # Start the counter by writing to ADDR_START\n        dut.HADDR.value = 0x00  # ADDR_START\n        dut.HWDATA.value = 1\n        await RisingEdge(dut.HCLK)\n        print(\"Started the Counter\")\n\n        dut.HADDR.value = 0x08  # ADDR_COUNTER\n        dut.HWRITE.value = 0  # Switch to read mode\n        await RisingEdge(dut.HCLK)\n\n        while int(dut.HRDATA.value) < max_count:\n            print(f\"Counter={int(dut.HRDATA.value)}\")\n            await RisingEdge(dut.HCLK)\n\n        print(\"Reached the Max Counter\")\n\n        dut.HADDR.value = 0x0C  # ADDR_OVERFLOW\n        await RisingEdge(dut.HCLK)\n        assert int(dut.HRDATA.value) == 1\n\n\n@cocotb.test()\nasync def test_ahb_clock_counter_overflow_persistence_and_post_overflow_reset(dut):\n    \"\"\"Test overflow persistence and counter behavior after an overflow.\"\"\"\n\n    # Start clock with a period of 10 ns\n    cocotb.start_soon(Clock(dut.HCLK, 10, units='ns').start())\n\n    # Reset the design\n    dut.HRESETn.value = 1\n    await Timer(5, units='ns')\n    dut.HRESETn.value = 0\n    await Timer(10, units='ns')\n    dut.HRESETn.value = 1\n\n    # Initialize inputs\n    dut.HSEL.value = 0\n    dut.HWRITE.value = 0\n    dut.HREADY.value = 1\n    dut.HADDR.value = 0\n    dut.HWDATA.value = 0\n\n    # Wait for reset to complete\n    await RisingEdge(dut.HCLK)\n\n    # Set a maximum count value\n    max_count = 3\n    dut.HSEL.value = 1\n    dut.HWRITE.value = 1\n    dut.HADDR.value = 0x10  # ADDR_MAXCNT\n    dut.HWDATA.value = max_count\n    await RisingEdge(dut.HCLK)\n\n    # Start the counter\n    dut.HADDR.value = 0x00  # ADDR_START\n    dut.HWDATA.value = 1\n    await RisingEdge(dut.HCLK)\n\n    # Run until overflow\n    dut.HWRITE.value = 0  # Switch to read mode\n    for i in range(max_count + 1):\n        # Read counter value\n        dut.HADDR.value = 0x08  # ADDR_COUNTER\n        await RisingEdge(dut.HCLK)\n        assert int(dut.HRESP.value) == 0  # HRESP returned ok\n        assert int(dut.HRDATA.value) == int(dut.COUNTER.value)\n        counter_val = int(dut.HRDATA.value)\n        print(f\"Cycle {i}, Counter: {counter_val}\")\n\n        if i == max_count:\n            # Check if overflow is set correctly\n            dut.HADDR.value = 0x0C  # ADDR_OVERFLOW\n            await RisingEdge(dut.HCLK)\n            assert int(dut.HRESP.value) == 0 # HRESP returned ok\n            overflow = int(dut.HRDATA.value)\n            assert overflow == 1, \"Overflow flag should be set at max_count\"\n            print(\"Overflow flag correctly set at max_count.\")\n\n    # Verify overflow flag persists\n    dut.HADDR.value = 0x0C  # ADDR_OVERFLOW\n    await RisingEdge(dut.HCLK)\n    assert int(dut.HRESP.value) == 0  # HRESP returned ok\n    overflow_persistent = int(dut.HRDATA.value)\n    assert overflow_persistent == 1, \"Overflow flag should persist until reset\"\n\n    # Perform manual reset of the overflow flag\n    dut.HRESETn.value = 0\n    await Timer(10, units='ns')\n    dut.HRESETn.value = 1\n\n    # Verify overflow flag is cleared after reset\n    await RisingEdge(dut.HCLK)\n    dut.HADDR.value = 0x0C  # ADDR_OVERFLOW\n    await RisingEdge(dut.HCLK)\n    assert int(dut.HRESP.value) == 0  # HRESP returned ok\n    overflow_after_reset = int(dut.HRDATA.value)\n    assert overflow_after_reset == 0, \"Overflow flag should reset to 0 after manual reset\"\n\n    # Restart the counter and validate proper operation\n    dut.HADDR.value = 0x00  # ADDR_START\n    dut.HWDATA.value = 1\n    dut.HWRITE.value = 1\n    await RisingEdge(dut.HCLK)\n\n    dut.HWRITE.value = 0\n    dut.HADDR.value = 0x08  # ADDR_COUNTER\n    for i in range(3):\n        await RisingEdge(dut.HCLK)\n        assert int(dut.HRESP.value) == 0  # HRESP returned ok\n        assert int(dut.HRDATA.value) == int(dut.COUNTER.value)\n        counter_val = int(dut.HRDATA.value)\n        print(f\"Cycle {i}, Counter After Restart: {counter_val}\")\n        assert counter_val == i, f\"Counter mismatch after restart at cycle {i}: expected {i}, got {counter_val}\"\n\n    print(\"Test for overflow persistence and post-overflow behavior completed successfully.\")\n\n", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner(data_width: int = 32, addr_width: int = 32):\n    parameters = {\n        \"ADDR_WIDTH\": addr_width,\n        \"DATA_WIDTH\": data_width\n    }\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n\n# random test\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_run(test):\n    call_runner()\n\n    # Test with different parameter values\n    call_runner(8, 8)\n    call_runner(8, 16)\n    call_runner(8, 32)\n    call_runner(16, 32)\n"}}}
{"id": "cvdp_copilot_ahb_lite_srom_0001", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add concurrent assertions in the RTL design of the `ahb_lite_srom` module to enforce correct behavior for both read and write transactions?\n**1. Read Transaction-Based Assertion** :\n - For read transactions, the module must immediately produce an OKAY response (i.e. `hresp_o` equals `H_OKAY` and `hreadyout_o` is asserted HIGH ) when a valid transaction is initiated. A valid transaction is signaled by `hsel_i` being high, `htrans_i` being a valid transfer, and `hwrite_i` being de-asserted. \n\n**2. Write Transaction-Based Assertion** :\n - For write transactions\u2014since the memory is read-only\u2014the module should trigger a two\u2011cycle error response: one cycle with `hresp_o` set to `H_ERROR` and `hreadyout_o` de-asserted to LOW, followed by a cycle where `hresp_o` remains at `H_ERROR` and `hreadyout_o` is reasserted to HIGH. \n\nProvide the appropriate SystemVerilog property\u2011based concurrent assertions to be inserted into the RTL code.\n\n## Interface:\n### **Inputs:**\n- `hclk (1-bit)`: The positive edge clock signal that drives the module.\n- `hreset_n (1-bit)`: Active-low asynchronous reset signal which initializes the module.\n- `haddr_i (32-bit,[31:0])`: The address bus input from the AHB bus used to select the memory location.\n- `hwdata_i (64-bit,[63:0])`: Data input for write transactions coming from the AHB bus.\n- `hsel_i (1-bit)`: AHB slave select signal indicating that the device is being addressed.\n- `hwrite_i (1-bit)`: Write enable signal; when high, it indicates a write transaction, and when low, a read transaction.\n- `hready_i (1-bit)`: Indicates that the AHB bus is ready for a new transaction.\n- `htrans_i (2-bit,[1:0])`: Transfer type signal that specifies the nature of the transaction (idle, sequential, or non-sequential).\n- `hsize_i (3-bit,[2:0])`: Specifies the size (in bytes) of the current transfer.\n- `rdata (64-bit,[63:0])`: Data input coming from the SROM, which is passed to the AHB bus during read transactions.\n\n### **Outputs**:\n- `hresp_o (1-bit)`: AHB response signal that indicates the status of the transaction\u2014H_OKAY (0) for successful operations or H_ERROR (1) for errors.\n- `hreadyout_o (1-bit)`: Indicates whether the SROM is ready to complete the current transaction.\n- `hrdata_o (64-bit,[63:0])`: Data output to the AHB bus, directly passed from the SROM.\n- `cs (1-bit)`: Chip select signal for the SROM, activated when a valid transaction is initiated.\n- `addr (32-bit,[31:0])`: Address output to the SROM, derived from the AHB address input by shifting right by the number of byte-select bits.", "context": {"rtl/ahb_lite_srom.sv": "module ahb_lite_srom \n #(\n    parameter AHB_DATA_WIDTH    = 64,\n    parameter AHB_ADDR_WIDTH    = 32,\n    parameter CLIENT_ADDR_WIDTH = 32,\n    parameter H_OKAY=1'b0,\n    parameter H_ERROR=1'b1)(\n\n    input logic                          hclk,\n    input logic                          hreset_n,\n    input logic [AHB_ADDR_WIDTH-1:0]     haddr_i,\n    input logic [AHB_DATA_WIDTH-1:0]     hwdata_i,\n    input logic                          hsel_i,\n    input logic                          hwrite_i,\n    input logic                          hready_i,\n    input logic [1:0]                    htrans_i,\n    input logic [2:0]                    hsize_i,\n    input logic [AHB_DATA_WIDTH-1:0]     rdata,\n\n    output logic                         hresp_o,\n    output logic                         hreadyout_o,\n    output logic [AHB_DATA_WIDTH-1:0]    hrdata_o,\n    output logic                         cs,\n    output logic [CLIENT_ADDR_WIDTH-1:0] addr\n);\n\n    logic    sram_error, sram_error_data_ph, sram_error_data_ph_f;\n\n    assign cs = hready_i & hsel_i & ((htrans_i == 2'b10) || (htrans_i == 2'b11));\n    assign addr = haddr_i >> $clog2(AHB_DATA_WIDTH/8);\n\n    assign sram_error = cs & hwrite_i; \n\n    assign hrdata_o = rdata;\n\n    always_comb begin : response_block\n      hreadyout_o = 1'b1;\n      hresp_o = H_OKAY;\n      if (sram_error_data_ph & ~sram_error_data_ph_f) begin\n        hreadyout_o = 1'b0;\n        hresp_o = H_ERROR;\n      end else if (sram_error_data_ph_f) begin\n        hreadyout_o = 1'b1;\n        hresp_o = H_ERROR;\n      end\n    end\n\n    always_ff @(posedge hclk or negedge hreset_n) begin\n      if (~hreset_n) begin\n        sram_error_data_ph <= '0;\n        sram_error_data_ph_f <= '0;\n      end else begin\n        sram_error_data_ph <= sram_error;\n        sram_error_data_ph_f <= sram_error_data_ph;\n      end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/ahb_lite_srom.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ahb_lite_srom.sv\nTOPLEVEL        = ahb_lite_srom\nMODULE          = test_ahb_lite_srom\nPYTHONPATH      = /src\nHASH            = 1-ahb_lite_srom_tb_assertion_generation\n", "src/test_ahb_lite_srom.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nimport math\n\n# AHB response definitions matching DUT parameters\nH_OKAY  = 0\nH_ERROR = 1\n\n# Calculate the address-shift amount based on AHB_DATA_WIDTH (assumes power-of-2)\nADDR_SHIFT = int(math.log2(64//8))  # For 64-bit data: 64/8 = 8, shift by 3\n\nasync def drive_rdata(dut):\n    \"\"\" Continuously drive rdata with a known 64-bit value. \"\"\"\n    while True:\n        dut.rdata.value = 0x0123456789ABCDEF\n        await Timer(1, units=\"ns\")\n\n@cocotb.test()\nasync def test_srom_read(dut):\n    \"\"\"\n    Test reading from the SROM.\n    This test verifies:\n      - The read response is OKAY and hreadyout is asserted.\n      - hrdata_o follows rdata.\n      - The chip select (cs) is asserted when a valid read transfer is initiated.\n      - The ROM address (addr) is computed correctly from haddr_i.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.hclk, 10, units=\"ns\").start())\n    cocotb.start_soon(drive_rdata(dut))\n\n    # Apply reset (active low)\n    dut.hreset_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.hclk)\n    dut.hreset_n.value = 1\n    await RisingEdge(dut.hclk)\n\n    # Drive default bus values\n    dut.hsel_i.value   = 0\n    dut.hwrite_i.value = 0  # Read transaction\n    dut.hready_i.value = 1\n    dut.htrans_i.value = 0\n    dut.haddr_i.value  = 0\n    dut.hwdata_i.value = 0\n    dut.hsize_i.value  = 0\n\n    num_reads = 5\n    for addr in range(num_reads):\n        # Initiate a read transfer\n        dut.hsel_i.value   = 1\n        dut.hwrite_i.value = 0\n        dut.htrans_i.value = 2  # NONSEQ transfer (2'b10)\n        dut.haddr_i.value  = addr\n        dut._log.info(f\"Initiating READ from address 0x{addr:08X}\")\n\n        await RisingEdge(dut.hclk)\n        await Timer(1, units=\"ns\")  # Allow combinational logic to settle\n\n        # Capture DUT outputs\n        hresp     = int(dut.hresp_o.value)\n        hreadyout = int(dut.hreadyout_o.value)\n        read_data = int(dut.hrdata_o.value)\n        cs_val    = int(dut.cs.value)\n        calc_addr = int(dut.addr.value)\n        expected_addr = addr >> ADDR_SHIFT\n\n        dut._log.info(f\"Address 0x{addr:08X}: hresp_o={hresp}, hreadyout_o={hreadyout}, hrdata_o=0x{read_data:016X}\")\n        dut._log.info(f\"Chip Select (cs) = {cs_val}, Computed addr = 0x{calc_addr:08X} (expected: 0x{expected_addr:08X})\")\n        assert hresp == H_OKAY, f\"Expected H_OKAY (0), got {hresp}\"\n        assert hreadyout == 1, f\"Expected hreadyout_o=1, got {hreadyout}\"\n        assert read_data == 0x0123456789ABCDEF, \"hrdata_o does not match rdata\"\n        assert cs_val == 1, f\"Expected cs to be asserted (1), got {cs_val}\"\n        assert calc_addr == expected_addr, f\"Expected addr = (haddr_i >> {ADDR_SHIFT}) = {expected_addr}, got {calc_addr}\"\n\n    # End the read transaction\n    dut.hsel_i.value = 0\n    dut._log.info(\"Read test completed successfully.\")\n\n@cocotb.test()\nasync def test_srom_write(dut):\n    \"\"\"\n    Test writing to the SROM.\n    Since the SROM is read-only, a write transaction should produce a two-cycle error:\n      - First error cycle: hresp_o = H_ERROR and hreadyout_o = 0.\n      - Second error cycle: hresp_o = H_ERROR and hreadyout_o = 1.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.hclk, 10, units=\"ns\").start())\n    cocotb.start_soon(drive_rdata(dut))\n\n    # Apply reset (active low)\n    dut.hreset_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.hclk)\n    dut.hreset_n.value = 1\n    await RisingEdge(dut.hclk)\n\n    # Set default bus values\n    dut.hready_i.value = 1\n    dut.haddr_i.value  = 0\n    dut.hwdata_i.value = 0\n    dut.hsize_i.value  = 0\n\n    # Pulse a write transaction for one clock cycle\n    dut.hsel_i.value   = 1\n    dut.hwrite_i.value = 1  # Write transaction\n    dut.htrans_i.value = 2  # NONSEQ transfer (2'b10)\n    dut.haddr_i.value  = 0\n    dut.hwdata_i.value = 0xDEADBEEFDEADBEEF\n    dut._log.info(\"Initiating WRITE transaction to read-only memory for one clock cycle...\")\n\n    await RisingEdge(dut.hclk)  # Transaction active in this cycle\n\n    # Deassert transaction signals immediately after one cycle\n    dut.hsel_i.value   = 0\n    dut.hwrite_i.value = 0\n    dut.htrans_i.value = 0\n\n    # Wait for the first error cycle: wait for the next rising edge and a delta cycle for combinational updates\n    await RisingEdge(dut.hclk)\n    await Timer(0, units=\"ns\")  # Allow delta cycles to settle\n    hresp_cycle1     = int(dut.hresp_o.value)\n    hreadyout_cycle1 = int(dut.hreadyout_o.value)\n    dut._log.info(f\"First error cycle => hresp_o={hresp_cycle1}, hreadyout_o={hreadyout_cycle1}\")\n    assert hresp_cycle1 == H_ERROR, f\"Expected H_ERROR (1) in first error cycle, got {hresp_cycle1}\"\n    assert hreadyout_cycle1 == 0, f\"Expected hreadyout_o=0 in first error cycle, got {hreadyout_cycle1}\"\n\n    # Wait for the second error cycle (next rising edge)\n    await RisingEdge(dut.hclk)\n    await Timer(0, units=\"ns\")\n    hresp_cycle2     = int(dut.hresp_o.value)\n    hreadyout_cycle2 = int(dut.hreadyout_o.value)\n    dut._log.info(f\"Second error cycle => hresp_o={hresp_cycle2}, hreadyout_o={hreadyout_cycle2}\")\n    assert hresp_cycle2 == H_ERROR, f\"Expected H_ERROR (1) in second error cycle, got {hresp_cycle2}\"\n    assert hreadyout_cycle2 == 1, f\"Expected hreadyout_o=1 in second error cycle, got {hreadyout_cycle2}\"\n\n    dut._log.info(\"Write-to-ROM error response test completed successfully.\")\n\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_ahb_lite_srom_0003", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add concurrent assertions in the RTL design of the `ahb_lite_srom` module to ensure that the module correctly implements its control and data path functions? Specifically:\n\n**1. Chip Select Generation Assertion**:\nWhen a valid AHB transaction is initiated\u2014i.e., when `hsel_i` is high, `htrans_i` indicates a valid transfer when it holds 2'b10 or 2'b11, and `hready_i` is asserted HIGH \u2014the chip select output (cs) should be asserted HIGH.\n\n**2. Address Calculation Assertion**:\nWhen the chip select (`cs`) is LOGIC HIGH, the address output (`addr`) must equal the AHB address input (`haddr_i`) shifted right by the number of byte-selection bits (`64 bits`).\n\n**3. Data Pass-Through Assertion**:\nThe read data output (`hrdata_o`) should always follow the SROM data input (`rdata`).\n\nProvide the appropriate SystemVerilog property\u2011based concurrent assertions to be inserted into the RTL code.\n\n## Interface:\n### **Inputs:**\n- `hclk (1-bit)`: The positive edge clock signal that drives the module.\n- `hreset_n (1-bit)`: Active-low asynchronous reset signal which initializes the module.\n- `haddr_i (32-bit,[31:0])`: The address bus input from the AHB bus used to select the memory location.\n- `hwdata_i (64-bit,[63:0])`: Data input for write transactions coming from the AHB bus.\n- `hsel_i (1-bit)`: AHB slave select signal indicating that the device is being addressed.\n- `hwrite_i (1-bit)`: Write enable signal; when high, it indicates a write transaction, and when low, a read transaction.\n- `hready_i (1-bit)`: Indicates that the AHB bus is ready for a new transaction.\n- `htrans_i (2-bit,[1:0])`: Transfer type signal that specifies the nature of the transaction (idle, sequential, or non-sequential).\n- `hsize_i (3-bit,[2:0])`: Specifies the size (in bytes) of the current transfer.\n- `rdata (64-bit,[63:0])`: Data input coming from the SROM, which is passed to the AHB bus during read transactions.\n\n### **Outputs**:\n- `hresp_o (1-bit)`: AHB response signal that indicates the status of the transaction\u2014H_OKAY (0) for successful operations or H_ERROR (1) for errors.\n- `hreadyout_o (1-bit)`: Indicates whether the SROM is ready to complete the current transaction.\n- `hrdata_o (64-bit,[63:0])`: Data output to the AHB bus, directly passed from the SROM.\n- `cs (1-bit)`: Chip select signal for the SROM, activated when a valid transaction is initiated.\n- `addr (32-bit,[31:0])`: Address output to the SROM, derived from the AHB address input by shifting right by the number of byte-select bits.", "context": {"rtl/ahb_lite_srom.sv": "module ahb_lite_srom \n #(\n    parameter AHB_DATA_WIDTH    = 64,\n    parameter AHB_ADDR_WIDTH    = 32,\n    parameter CLIENT_ADDR_WIDTH = 32,\n    parameter H_OKAY=1'b0,\n    parameter H_ERROR=1'b1)(\n\n    input logic                          hclk,\n    input logic                          hreset_n,\n    input logic [AHB_ADDR_WIDTH-1:0]     haddr_i,\n    input logic [AHB_DATA_WIDTH-1:0]     hwdata_i,\n    input logic                          hsel_i,\n    input logic                          hwrite_i,\n    input logic                          hready_i,\n    input logic [1:0]                    htrans_i,\n    input logic [2:0]                    hsize_i,\n    input logic [AHB_DATA_WIDTH-1:0]     rdata,\n    \n    output logic                         hresp_o,\n    output logic                         hreadyout_o,\n    output logic [AHB_DATA_WIDTH-1:0]    hrdata_o,\n    output logic                         cs,\n    output logic [CLIENT_ADDR_WIDTH-1:0] addr\n);\n\n    logic    sram_error, sram_error_data_ph, sram_error_data_ph_f;\n\n    assign cs = hready_i & hsel_i & ((htrans_i == 2'b10) || (htrans_i == 2'b11));\n    assign addr = haddr_i >> $clog2(AHB_DATA_WIDTH/8);\n\n    assign sram_error = cs & hwrite_i; \n\n    assign hrdata_o = rdata;\n\n    always@(*) begin : response_block\n      hreadyout_o = 1'b1;\n      hresp_o = H_OKAY;\n      if (sram_error_data_ph & ~sram_error_data_ph_f) begin\n        hreadyout_o = 1'b0;\n        hresp_o = H_ERROR;\n      end else if (sram_error_data_ph_f) begin\n        hreadyout_o = 1'b1;\n        hresp_o = H_ERROR;\n      end\n    end\n\n    always@(posedge hclk or negedge hreset_n) begin\n      if (~hreset_n) begin\n        sram_error_data_ph <= '0;\n        sram_error_data_ph_f <= '0;\n      end else begin\n        sram_error_data_ph <= sram_error;\n        sram_error_data_ph_f <= sram_error_data_ph;\n      end\n    end\n\n    \nendmodule"}}, "output": {"response": "", "context": {"rtl/ahb_lite_srom.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ahb_lite_srom.sv\nTOPLEVEL        = ahb_lite_srom\nMODULE          = test_ahb_lite_srom\nPYTHONPATH      = /src\nHASH            = 3-ahb_lite_srom_tb_assertion_generation_2\n", "src/test_ahb_lite_srom.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nimport math\n\n# AHB response definitions matching DUT parameters\nH_OKAY  = 0\nH_ERROR = 1\n\n# Calculate the address-shift amount based on AHB_DATA_WIDTH (assumes power-of-2)\nADDR_SHIFT = int(math.log2(64//8))  # For 64-bit data: 64/8 = 8, shift by 3\n\nasync def drive_rdata(dut):\n    \"\"\" Continuously drive rdata with a known 64-bit value. \"\"\"\n    while True:\n        dut.rdata.value = 0x0123456789ABCDEF\n        await Timer(1, units=\"ns\")\n\n@cocotb.test()\nasync def test_srom_read(dut):\n    \"\"\"\n    Test reading from the SROM.\n    This test verifies:\n      - The read response is OKAY and hreadyout is asserted.\n      - hrdata_o follows rdata.\n      - The chip select (cs) is asserted when a valid read transfer is initiated.\n      - The ROM address (addr) is computed correctly from haddr_i.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.hclk, 10, units=\"ns\").start())\n    cocotb.start_soon(drive_rdata(dut))\n\n    # Apply reset (active low)\n    dut.hreset_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.hclk)\n    dut.hreset_n.value = 1\n    await RisingEdge(dut.hclk)\n\n    # Drive default bus values\n    dut.hsel_i.value   = 0\n    dut.hwrite_i.value = 0  # Read transaction\n    dut.hready_i.value = 1\n    dut.htrans_i.value = 0\n    dut.haddr_i.value  = 0\n    dut.hwdata_i.value = 0\n    dut.hsize_i.value  = 0\n\n    num_reads = 5\n    for addr in range(num_reads):\n        # Initiate a read transfer\n        dut.hsel_i.value   = 1\n        dut.hwrite_i.value = 0\n        dut.htrans_i.value = 2  # NONSEQ transfer (2'b10)\n        dut.haddr_i.value  = addr\n        dut._log.info(f\"Initiating READ from address 0x{addr:08X}\")\n\n        await RisingEdge(dut.hclk)\n        await Timer(1, units=\"ns\")  # Allow combinational logic to settle\n\n        # Capture DUT outputs\n        hresp     = int(dut.hresp_o.value)\n        hreadyout = int(dut.hreadyout_o.value)\n        read_data = int(dut.hrdata_o.value)\n        cs_val    = int(dut.cs.value)\n        calc_addr = int(dut.addr.value)\n        expected_addr = addr >> ADDR_SHIFT\n\n        dut._log.info(f\"Address 0x{addr:08X}: hresp_o={hresp}, hreadyout_o={hreadyout}, hrdata_o=0x{read_data:016X}\")\n        dut._log.info(f\"Chip Select (cs) = {cs_val}, Computed addr = 0x{calc_addr:08X} (expected: 0x{expected_addr:08X})\")\n        assert hresp == H_OKAY, f\"Expected H_OKAY (0), got {hresp}\"\n        assert hreadyout == 1, f\"Expected hreadyout_o=1, got {hreadyout}\"\n        assert read_data == 0x0123456789ABCDEF, \"hrdata_o does not match rdata\"\n        assert cs_val == 1, f\"Expected cs to be asserted (1), got {cs_val}\"\n        assert calc_addr == expected_addr, f\"Expected addr = (haddr_i >> {ADDR_SHIFT}) = {expected_addr}, got {calc_addr}\"\n\n    # End the read transaction\n    dut.hsel_i.value = 0\n    dut._log.info(\"Read test completed successfully.\")\n\n@cocotb.test()\nasync def test_srom_write(dut):\n    \"\"\"\n    Test writing to the SROM.\n    Since the SROM is read-only, a write transaction should produce a two-cycle error:\n      - First error cycle: hresp_o = H_ERROR and hreadyout_o = 0.\n      - Second error cycle: hresp_o = H_ERROR and hreadyout_o = 1.\n    \"\"\"\n    cocotb.start_soon(Clock(dut.hclk, 10, units=\"ns\").start())\n    cocotb.start_soon(drive_rdata(dut))\n\n    # Apply reset (active low)\n    dut.hreset_n.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.hclk)\n    dut.hreset_n.value = 1\n    await RisingEdge(dut.hclk)\n\n    # Set default bus values\n    dut.hready_i.value = 1\n    dut.haddr_i.value  = 0\n    dut.hwdata_i.value = 0\n    dut.hsize_i.value  = 0\n\n    # Pulse a write transaction for one clock cycle\n    dut.hsel_i.value   = 1\n    dut.hwrite_i.value = 1  # Write transaction\n    dut.htrans_i.value = 2  # NONSEQ transfer (2'b10)\n    dut.haddr_i.value  = 0\n    dut.hwdata_i.value = 0xDEADBEEFDEADBEEF\n    dut._log.info(\"Initiating WRITE transaction to read-only memory for one clock cycle...\")\n\n    await RisingEdge(dut.hclk)  # Transaction active in this cycle\n\n    # Deassert transaction signals immediately after one cycle\n    dut.hsel_i.value   = 0\n    dut.hwrite_i.value = 0\n    dut.htrans_i.value = 0\n\n    # Wait for the first error cycle: wait for the next rising edge and a delta cycle for combinational updates\n    await RisingEdge(dut.hclk)\n    await Timer(0, units=\"ns\")  # Allow delta cycles to settle\n    hresp_cycle1     = int(dut.hresp_o.value)\n    hreadyout_cycle1 = int(dut.hreadyout_o.value)\n    dut._log.info(f\"First error cycle => hresp_o={hresp_cycle1}, hreadyout_o={hreadyout_cycle1}\")\n    assert hresp_cycle1 == H_ERROR, f\"Expected H_ERROR (1) in first error cycle, got {hresp_cycle1}\"\n    assert hreadyout_cycle1 == 0, f\"Expected hreadyout_o=0 in first error cycle, got {hreadyout_cycle1}\"\n\n    # Wait for the second error cycle (next rising edge)\n    await RisingEdge(dut.hclk)\n    await Timer(0, units=\"ns\")\n    hresp_cycle2     = int(dut.hresp_o.value)\n    hreadyout_cycle2 = int(dut.hreadyout_o.value)\n    dut._log.info(f\"Second error cycle => hresp_o={hresp_cycle2}, hreadyout_o={hreadyout_cycle2}\")\n    assert hresp_cycle2 == H_ERROR, f\"Expected H_ERROR (1) in second error cycle, got {hresp_cycle2}\"\n    assert hreadyout_cycle2 == 1, f\"Expected hreadyout_o=1 in second error cycle, got {hreadyout_cycle2}\"\n\n    dut._log.info(\"Write-to-ROM error response test completed successfully.\")\n\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_asyc_reset_0001", "categories": ["cid014", "easy"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the `async_reset` module based on the design specifications provided? Below are the module details and design requirements for assertion development.\n\n---\n\n### Specifications\n\n#### **Module IO Specifications**\n- **Inputs**:\n  - `clk`: Positive edge-triggered clock signal.\n  - `reset`: Asynchronous reset signal (active-high). When asserted, it initializes the module.\n  \n- **Outputs**:\n  - `release_reset_o`: Indicates when the reset can be safely released (asserted when `cnt_q < 8`).\n  - `gate_clk_o`: Controls clock gating (asserted when `(cnt_q < 14)` and `(cnt_q != 0)`).\n  - `cnt_q`: a 5-bit counter that decrements to zero when reset is de-asserted.\n\n#### **Design Specifications**\nThe circuit takes an asynchronous reset as input, which is synchronized to the clock (`clk`) domain. The circuit drives two critical output signals:\n\n1. **`release_reset_o`**: This signal indicates when it is safe to deassert the reset for the rest of the circuit.\n2. **`gate_clk_o`**: This signal gates the clock to the rest of the circuit.\n\nThe design must meet the following specifications:\n- **Reset Deassertion Safety**:\n  - The reset should only be released if the asynchronous reset input (`reset`) has been de-asserted (driven low) for at least 5 cycles.\n- **Clock and Reset Tree Timing**:\n  - The clock tree time is 7 cycles, while the reset tree time is 8 cycles. These timing requirements must be accounted for in the logic driving `release_reset_o` and `gate_clk_o`.\n\n---\n\n### Assertion Requirements\n\n1. **Asynchronous Reset Behavior**:\n   - Validate that the counter (`cnt_q`) initializes to `5'h11` (decimal 17) when the asynchronous `reset` is asserted.\n\n2. **Reset Synchronization**:\n   - Ensure that the reset is held low for at least 5 cycles before deasserting the `release_reset_o` signal.\n\n3. **Counter Behavior**:\n   - Verify that the counter decrements correctly until it reaches 0.\n   - Ensure that the counter does not decrement below 0.\n\n4. **Output Signal Validation**:\n   - Validate the correct behavior of `release_reset_o` (asserted when reset deassertion conditions are satisfied).\n   - Verify the correct behavior of `gate_clk_o` (asserted when `(cnt_q < 14)` and `(cnt_q != 0)`).\n\n---\n\n### RTL Code (Without Assertions)\n\n```systemverilog\nmodule async_reset (\n  input   logic        clk,\n  input   logic        reset,\n\n  output  logic        release_reset_o,\n  output  logic        gate_clk_o,\n  output  logic [4:0]  cnt_q  \n);\n\n  // --------------------------------------------------------\n  // Asynchronous reset and counter logic\n  // --------------------------------------------------------\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n      cnt_q <= 5'h11; // Initialize to 17\n    end else begin\n      if (cnt_q > 0) begin\n        cnt_q <= cnt_q - 1;\n      end else begin\n        cnt_q <= cnt_q; // Hold at 0\n      end\n    end\n  end\n\n  // --------------------------------------------------------\n  // Output assignments\n  // --------------------------------------------------------\n  assign gate_clk_o      = (cnt_q < 5'hE) && (cnt_q != 0); // (cnt_q < 14) && (cnt_q != 0)\n  assign release_reset_o = (cnt_q < 5'h8);                  // (cnt_q < 8)\n\nendmodule\n```\n\n---\n\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.", "context": {}}, "output": {"response": "", "context": {"rtl/async_reset.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    environment:\n      - PYTHONPATH=/code/harness/lib\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/async_reset.sv\nTOPLEVEL        = async_reset\nMODULE          = test_async_reset\nPYTHONPATH      = /src\nHASH            = 1-rtl-assertions-addition", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\n\nasync def access_hit(dut, index_a, way_select_a):\n    await FallingEdge(dut.clock)\n    dut.access.value = 1\n    dut.hit.value = 1\n    dut.index.value = index_a\n    dut.way_select.value = way_select_a\n\n    await FallingEdge(dut.clock)\n    print(f\"[DEBUG] way_replace: {dut.way_replace.value}\")\n    dut.access.value = 0\n    dut.hit.value = 0\n\n\nasync def access_miss(dut, index_a, way_select_a):\n    await FallingEdge(dut.clock)\n    dut.access.value = 1\n    dut.hit.value = 0\n    dut.index.value = index_a\n    dut.way_select.value = way_select_a\n\n    await FallingEdge(dut.clock)\n    print(f\"[DEBUG] way_replace: 0b{dut.way_replace.value.integer:04b}\")\n    dut.access.value = 0\n    dut.hit.value = 0\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n", "src/test_async_reset.py": "# test_async_reset.py\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nfrom cocotb.result import TestFailure\n\n@cocotb.test()\nasync def test_async_reset(dut):\n    \"\"\"Testbench for async_reset module using cocotb.\"\"\"\n\n    # Initialize test counters\n    test_pass = 0\n    test_fail = 0\n    total_tests = 0\n\n    # Function to check conditions\n    async def check_condition(test_name, condition):\n        nonlocal test_pass, test_fail, total_tests\n        total_tests += 1\n        if condition:\n            dut._log.info(f\"[PASS] {test_name}\")\n            test_pass += 1\n        else:\n            dut._log.error(f\"[FAIL] {test_name}\")\n            test_fail += 1\n\n    # Start the clock at 100MHz (10ns period)\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Initialize signals\n    dut.reset.value = 1\n    # cnt_q and other outputs are not driven by the testbench\n\n    dut._log.info(\"Starting async_reset cocotb Testbench...\")\n\n    # Wait for 6 posedges clk to hold reset high\n    for i in range(6):\n        await RisingEdge(dut.clk)\n        dut._log.info(f\"Holding reset high. Cycle: {i+1}, Time: {cocotb.utils.get_sim_time(units='ns')}, cnt_q: {dut.cnt_q.value}\")\n\n    # Deassert reset on FallingEdge clk to ensure it's low before next posedge clk\n    await FallingEdge(dut.clk)\n    dut.reset.value = 0\n    dut._log.info(f\"Deasserting reset on falling edge at time {cocotb.utils.get_sim_time(units='ns')} ns.\")\n\n    # Wait for a small delay to allow reset to propagate\n    await Timer(5, units='ns')  # Increased delay for better synchronization\n\n    # Immediately check cnt_q ==0x11 after reset deassertion\n    await check_condition(\n        \"Test 1: cnt_q initialized to 0x11 after reset deassertion\",\n        dut.cnt_q.value.integer == 0x11\n    )\n\n    # Log current state\n    await RisingEdge(dut.clk)\n    dut._log.info(f\"After first posedge clk post-reset deassertion. Time: {cocotb.utils.get_sim_time(units='ns')} ns, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # Wait for next posedge clk to allow cnt_q to decrement\n    await RisingEdge(dut.clk)\n    dut._log.info(f\"After second posedge clk post-reset deassertion. Time: {cocotb.utils.get_sim_time(units='ns')} ns, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # Now, check that cnt_q has decremented to 0x10\n    await check_condition(\n        \"Test 2: cnt_q decremented to 0x10 after reset\",\n        dut.cnt_q.value.integer == 0x10\n    )\n\n    # Test Case 3: Check release_reset_o is inactive (cnt_q >=8)\n    await check_condition(\n        \"Test 3: release_reset_o is inactive (cnt_q >= 8)\",\n        dut.release_reset_o.value.integer == 0\n    )\n\n    # Wait until cnt_q reaches 0x07\n    while dut.cnt_q.value.integer > 0x7:\n        await RisingEdge(dut.clk)\n        dut._log.info(f\"Counting down. Time: {cocotb.utils.get_sim_time(units='ns')}, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # Test Case 4: Check release_reset_o is active (cnt_q <8)\n    await check_condition(\n        \"Test 4: release_reset_o is active (cnt_q < 8)\",\n        dut.release_reset_o.value.integer == 1\n    )\n\n    # Wait until cnt_q reaches 0\n    while dut.cnt_q.value.integer > 0x0:\n        await RisingEdge(dut.clk)\n        dut._log.info(f\"Counting down. Time: {cocotb.utils.get_sim_time(units='ns')}, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # Test Case 5: Check that cnt_q does not go below 0\n    await check_condition(\n        \"Test 5: cnt_q is 0 and does not decrement further\",\n        dut.cnt_q.value.integer == 0x0\n    )\n\n    # Check outputs when cnt_q is 0\n    await check_condition(\n        \"Test 6: gate_clk_o is inactive when cnt_q is 0\",\n        dut.gate_clk_o.value.integer == 0\n    )\n    await check_condition(\n        \"Test 6: release_reset_o is active when cnt_q is 0\",\n        dut.release_reset_o.value.integer == 1\n    )\n\n    # Test Case 7: Assert reset asynchronously\n    dut.reset.value = 1\n    dut._log.info(f\"Asserting reset asynchronously at time {cocotb.utils.get_sim_time(units='ns')} ns.\")\n\n    # Wait for 5 ns to allow reset to propagate\n    await Timer(5, units='ns')\n\n    # Deassert reset on FallingEdge clk to ensure it's low before next posedge clk\n    await FallingEdge(dut.clk)\n    dut.reset.value = 0\n    dut._log.info(f\"Deasserting reset asynchronously on falling edge at time {cocotb.utils.get_sim_time(units='ns')} ns.\")\n\n    # Wait for a small delay to allow reset to propagate\n    await Timer(5, units='ns')  # Increased delay for better synchronization\n\n    # Immediately check cnt_q ==0x11 after reset deassertion\n    await check_condition(\n        \"Test 7: cnt_q initialized to 0x11 after reset deassertion\",\n        dut.cnt_q.value.integer == 0x11\n    )\n\n    # Log current state\n    await RisingEdge(dut.clk)\n    dut._log.info(f\"After first posedge clk post-reset deassertion. Time: {cocotb.utils.get_sim_time(units='ns')} ns, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # Wait for next posedge clk to allow cnt_q to decrement\n    await RisingEdge(dut.clk)\n    dut._log.info(f\"After second posedge clk post-reset deassertion. Time: {cocotb.utils.get_sim_time(units='ns')} ns, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # Now, check that cnt_q has decremented to 0x10\n    await check_condition(\n        \"Test 8: cnt_q decremented to 0x10 after reset\",\n        dut.cnt_q.value.integer == 0x10\n    )\n\n    # Test Case 9: Hold reset for exactly 6 cycles (to satisfy min_reset_duration)\n    dut.reset.value = 1\n    dut._log.info(f\"Asserting reset for exactly 6 cycles at time {cocotb.utils.get_sim_time(units='ns')} ns.\")\n\n    for i in range(6):\n        await RisingEdge(dut.clk)\n        dut._log.info(f\"Holding reset high. Cycle: {i+1}, Time: {cocotb.utils.get_sim_time(units='ns')} ns, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # Deassert reset on FallingEdge clk to satisfy min_reset_duration\n    await FallingEdge(dut.clk)\n    dut.reset.value = 0\n    dut._log.info(f\"Deasserting reset after holding for 6 cycles on falling edge at posedge clk {cocotb.utils.get_sim_time(units='ns')} ns.\")\n\n    # Wait for a small delay to allow reset to propagate\n    await Timer(5, units='ns')  # Increased delay for better synchronization\n\n    # Immediately check cnt_q ==0x11 after reset deassertion\n    await check_condition(\n        \"Test 9: cnt_q reset to 0x11 after 6-cycle reset\",\n        dut.cnt_q.value.integer == 0x11\n    )\n\n    # Wait for next posedge clk\n    await RisingEdge(dut.clk)\n    dut._log.info(f\"After posedge clk post-6-cycle reset deassertion. Time: {cocotb.utils.get_sim_time(units='ns')} ns, cnt_q: {dut.cnt_q.value.integer}\")\n\n    # ---------------------------\n    # Final Results\n    # ---------------------------\n    dut._log.info(\"==================================\")\n    dut._log.info(\"Cocotb Testbench Completed\")\n    dut._log.info(f\"Total Tests: {total_tests}\")\n    dut._log.info(f\"Passed: {test_pass}\")\n    dut._log.info(f\"Failed: {test_fail}\")\n    dut._log.info(\"==================================\")\n\n    # Use assert statements to reflect test results\n    assert test_fail == 0, f\"Some tests failed: {test_fail} failed out of {total_tests}\"\n", "src/test_runner.py": "import cocotb\nimport os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nfrom cocotb.runner import get_runner\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef call_runner():\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n    # Run the simulation\n    call_runner()"}}}
{"id": "cvdp_copilot_bcd_adder_0038", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add an immediate assertion in the RTL design of the `multi_digit_bcd_add_sub` module to verify the correctness of the BCD addition and subtraction outputs? The assertion should check the following conditions:\n\n## 1. Valid BCD Result:\nEnsure that each digit in the result remains within the valid BCD range (0\u20139). If any digit exceeds 9, the assertion should trigger an error.\n\n## 2. Carry/Borrow Behavior:\n- **Addition:** The carry-out (`carry_borrow`) should correctly reflect the propagated carry from the final digit.\n- **Subtraction:** The borrow-out (`carry_borrow`) should either be asserted correctly or the result should not be zero, preventing an invalid subtraction case.\n\n## 3. Valid Parameter N:\nEnsure that the parameter `N` (number of BCD digits) is always greater than zero.\n\nAdditionally, the design uses a register check_done to delay the assertions until all inputs (a and b) have stabilized. The check_done register is set to 1'b1 whenever inputs are updated, ensuring that the assertions are evaluated only after input stabilization. This mechanism prevents false assertion failures during transitional states of the inputs.\n\nThe assertion should use System Verilog constructs and display appropriate error messages if any of the above conditions are violated.\n\n## Interface\n\n### Module Name:\nThe module must be named `multi_digit_bcd_add_sub`.\n\n### Parameters:\n- **N**: Defines the number of BCD digits to process, with a default value of 4. This must be a positive integer greater than or equal to 1.\n\n### Inputs:\n- `[4*N-1:0] A`: N-digit Binary-Coded Decimal (BCD) input, with each digit represented as a 4-bit binary value\n- `[4*N-1:0] B`: N-digit Binary-Coded Decimal (BCD) input, with each digit represented as a 4-bit binary value\n- `add_sub`: Operation selection signal. A high signal (1) selects addition, and a low signal (0) selects subtraction.\n  \n### Outputs:\n- `[4*N-1:0] result`: N-digit Binary-Coded Decimal (BCD) result of the operation, each digit represented as a 4-bit binary value\n- `carry_borrow`: Indicates a carry-out from addition or a borrow-out from subtraction.\n     - For addition (add_sub = 1), carry_borrow is high when there is a carry-out from the most significant digit, otherwise remains low\n     - For subtraction (add_sub = 0), carry_borrow is high when no borrow is required (i.e., when A \u2265 B), and low when a borrow is required (i.e., when A < B).\n\nThe assertion should be integrated into the RTL design to verify these constraints during simulation and trigger error messages when violations occur.", "context": {"rtl/bcd_adder.sv": "module multi_digit_bcd_add_sub #(parameter N = 4)(\n    input  [4*N-1:0] A,           // N-digit BCD number\n    input  [4*N-1:0] B,           // N-digit BCD number\n    input            add_sub,     // 1 for addition, 0 for subtraction\n    output [4*N-1:0] result,      // Result (sum or difference)\n    output           carry_borrow // Carry-out for addition or Borrow-out for subtraction\n);\n    wire [N:0] carry;          // Carry between digits\n    wire [4*N-1:0] B_comp;     // Complemented B for subtraction\n    wire [4*N-1:0] operand_B;  // Operand B after considering addition or subtraction\n\n    assign carry[0] = add_sub ? 1'b0 : 1'b1; \n\n    // Generate 9's complement of B for subtraction\n    genvar i;\n    generate\n        for (i = 0; i < N; i = i + 1) begin \n            assign B_comp[4*i+3:4*i] = 4'b1001 - B[4*i+3:4*i]; \n        end\n    endgenerate\n\n    assign operand_B = add_sub ? B : B_comp;\n\n    generate\n        for (i = 0; i < N; i = i + 1) begin \n            bcd_adder bcd_adder_inst(\n                .a(A[4*i+3:4*i]),\n                .b(operand_B[4*i+3:4*i]),\n                .cin(carry[i]),\n                .sum(result[4*i+3:4*i]),\n                .cout(carry[i+1])\n            );\n        end\n    endgenerate\n\n    assign carry_borrow = carry[N]; \nendmodule\n\n//module of bcd_adder\nmodule bcd_adder(                \n                 input  [3:0] a,             // 4-bit BCD input\n                 input  [3:0] b,             // 4-bit BCD input\n                 input        cin,           // Carry-in\n                 output [3:0] sum,           // The corrected 4-bit BCD result of the addition\n                 output       cout           // Carry-out to indicate overflow beyond BCD range (i.e., when the result exceeds 9)\n                );\n    \nwire [3:0] binary_sum;         \nwire binary_cout;              \nwire z1, z2;                   \nwire carry;                    \n   \nfour_bit_adder adder1(         \n                      .a(a),            \n                      .b(b),            \n                      .cin(cin),       \n                      .sum(binary_sum), \n                      .cout(binary_cout) \n                     );\n       \nassign z1 = (binary_sum[3] & binary_sum[2]); \nassign z2 = (binary_sum[3] & binary_sum[1]); \nassign cout = (z1 | z2 | binary_cout);        \n\nfour_bit_adder adder2(         \n                      .a(binary_sum),     \n                      .b({1'b0, cout, cout, 1'b0}), \n                      .cin(1'b0),         \n                      .sum(sum),          \n                      .cout(carry)        \n                     );\n\nendmodule     \n\n\n//module of four_bit_adder\nmodule four_bit_adder(        \n                      input [3:0] a,           // 4-bit input a\n                      input [3:0] b,           // 4-bit input b\n                      input cin,               // Carry input\n                      output [3:0] sum,        // 4-bit sum output\n                      output cout              // Carry output\n                     );\n\n  wire [2:0] carry;         \n\n  genvar i;                 \n\n  generate\n    for (i = 0; i < 4; i = i + 1) begin: adder \n\n      if (i == 0) begin\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(cin),          \n                       .sum(sum[i]),       \n                       .cout(carry[i])     \n                      );\n      end \n      else if (i < 3) begin\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(carry[i-1]),   \n                       .sum(sum[i]),       \n                       .cout(carry[i])     \n                      );\n      end\n      else begin\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(carry[i-1]),   \n                       .sum(sum[i]),       \n                       .cout(cout)         \n                     );\n      end\n    end\n  endgenerate\n\nendmodule     \n\n//module of full_adder\nmodule full_adder(       \n                  input a,     // First Addend input\n                  input b,     // Second Addend input\n                  input cin,   // Carry input\n                  output sum,  // Sum output\n                  output cout  // Carry output\n                );\n                  \n  assign sum = a ^ b ^ cin;                      \n  assign cout = (a & b) | (b & cin) | (a & cin); \n  \nendmodule"}}, "output": {"response": "", "context": {"rtl/bcd_adder.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 90\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/bcd_adder.sv\nTOPLEVEL        = multi_digit_bcd_add_sub\nMODULE          = test_multi_dig_bcd_add_sub\nPYTHONPATH      = /src\nHASH            = cba61cf00e638af325ae223a8a8119752506742a\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_multi_dig_bcd_add_sub.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ReadOnly , Timer\n\nimport harness_library as hrs_lb\nimport random\n\ndef int_to_bcd(value, N):\n\n    bcd = 0\n    for i in range(N):\n        digit = value % 10\n        value = value // 10\n        bcd |= (digit << (4 * i))\n    return bcd\n\ndef bcd_to_str(bcd, N):\n\n    digits = []\n    for i in reversed(range(N)):\n        digit = (bcd >> (4 * i)) & 0xF\n        digits.append(str(digit))\n    return ''.join(digits)\n\n@cocotb.test()\nasync def test_multi_digit_bcd_add_sub(dut):\n\n    # Initialize the DUT signals\n    dut.A.value = 0\n    dut.B.value = 0\n    dut.add_sub.value = 0\n    # Determine the number of digits (N) from the width of input A\n    N = len(dut.A.value) // 4\n    max_value = 10 ** N\n    for _ in range(100):  \n\n        # Generate random integers within the range of N-digit numbers\n        A_int = random.randint(0, max_value - 1)\n        B_int = random.randint(0, max_value - 1)\n        add_sub = random.randint(0, 1)  # 1 for addition, 0 for subtraction\n\n        # Convert integers to BCD representation\n        A_bcd = int_to_bcd(A_int, N)\n        B_bcd = int_to_bcd(B_int, N)\n\n        # Assign values to DUT\n        dut.A.value = A_bcd\n        dut.B.value = B_bcd\n        dut.add_sub.value = add_sub\n\n        # Wait for the combinational logic to settle\n        await Timer(1, units='ns')\n\n        # Read outputs\n        result_bcd = int(dut.result.value)\n        carry_borrow = int(dut.carry_borrow.value)\n\n        # Compute expected result\n        if add_sub == 1:\n            # Addition\n            expected_result_int = A_int + B_int\n            expected_carry_out = 1 if expected_result_int >= max_value else 0\n            expected_result_int = expected_result_int % max_value\n        else:\n            # Subtraction\n            expected_result_int = A_int - B_int\n            if expected_result_int < 0:\n                expected_result_int += max_value\n                expected_carry_out = 0\n            else:\n                expected_carry_out = 1\n\n        # Convert expected result to BCD\n        expected_result_bcd = int_to_bcd(expected_result_int, N)\n\n        # Compare DUT outputs with expected values\n        if result_bcd != expected_result_bcd or carry_borrow != expected_carry_out:\n            A_str = bcd_to_str(A_bcd, N)\n            B_str = bcd_to_str(B_bcd, N)\n            result_str = bcd_to_str(result_bcd, N)\n            expected_str = bcd_to_str(expected_result_bcd, N)\n            operation = 'Addition' if add_sub else 'Subtraction'\n            error_msg = (f\"Test failed for A={A_str}, B={B_str}, Operation={operation}.\\n\"\n                         f\"Expected result={expected_str}, carry_out={expected_carry_out}, \"\n                         f\"Got result={result_str}, carry_out={carry_borrow}\")\n            raise AssertionError(error_msg)\n        else:\n            if add_sub:\n                # Addition\n                dut._log.info(f\"Addition: A={bcd_to_str(A_bcd, N)}, B={bcd_to_str(B_bcd, N)}, \"\n                              f\"Result={bcd_to_str(result_bcd, N)}, Carry_Out={carry_borrow}\")\n            else:\n                # Subtraction\n                dut._log.info(f\"Subtraction: A={bcd_to_str(A_bcd, N)}, B={bcd_to_str(B_bcd, N)}, \"\n                              f\"Result={bcd_to_str(result_bcd, N)}, Borrow_Out={carry_borrow}\")\n\n        # Wait before next iteration\n        await Timer(1, units='ns')", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\nN               = [4] \n@pytest.mark.parametrize(\"N\", N)\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate(N):\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\",\n        parameters={\"N\": N} \n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_binary_search_tree_sorting_0044", "categories": ["cid014", "medium"], "input": {"prompt": "Implement SystemVerilog Assertions (SVA) to validate the behaviour of the given `binary_search_tree_sort` module that processes an array of unsigned integers with a parameterizable size, ARRAY_SIZE (number of elements in the array, will be greater than 0) and sorts the array in ascending order via the Binary Search Tree (BST) algorithm. \n\n## Design Specification:\n\nA BST is a data structure where each node has a key, and its left child contains keys less than or equal to the node, while its right child contains keys greater than the node and thereby constructs a tree. The algorithm organizes the integers into a binary search tree and traverses the tree to produce a sorted output array. The maximum data value possible for an element within the array can be set with the parameter DATA_WIDTH (width of a single element, greater than 0). Sorting arranges the elements of the array in ascending order, such that the smallest element is at index 0 and the largest element is at index ARRAY_SIZE-1. `sorted_out` holds the sorted array when the `done` signal asserts high. Both `done` and `sorted_out` are set to 0 after 1 clock cycle.\n\n### Design Details\n\n**Parameterization**\n\n- **ARRAY_SIZE**: Specifies the number of elements in the input array.\n  - Default: 15\n- **DATA_WIDTH**: Specifies the bit-width of each array element.\n  - Default: 32\n \n**Inputs and Outputs**\n\n**Inputs:**\n\n- **clk**: Clock signal for synchronization. The design is synchronized to the positive edge of this clock.\n- **reset**: Active-high asynchronous reset.When asserted, it immediately resets all outputs (**sorted_out** array and **done**) to zero.\n- **start**: Active-high signal for 1 clock cycle to initiate the sorting process.\n- **data_in [ARRAY_SIZE*DATA_WIDTH-1:0]**: The unsorted input array that will be sorted by the BST-based algorithm.\n\n**Outputs:**\n\n- **done**: An active high signal for 1 clock cycle indicates when the sorting operation is complete.\n- **sorted_out [ARRAY_SIZE*DATA_WIDTH-1:0]**: The sorted array output in ascending order, such that the smallest element is at index 0 and the largest element is at index ARRAY_SIZE-1.\n\n### Note: \n- An index or a node in the `left_child` or `right_child` is considered to be invalid or does not exist when all the bits are set to 1. \n- A left-skewed tree is a BST where every node only consists of a left_child and no right_child. \n- A right-skewed tree is a BST where every node only consists of a right_child and no left_child. \n- In the following section describing the required assertions, if `data_in` is referred to as sorted in ascending or descending order (reverse sorted), assume there are no duplicate keys.\n\n## Assertions: \n\n1. Sorted data input results in the same array as input: When `data_in` is a sorted array in ascending order, the output `sorted_out` is the same as `data_in`.\n\n2. Output array is always sorted: For any given `data_in`, the output `sorted_out` should be sorted in ascending order (with or without duplicate keys).\n \n3. Duplicated data input results in the same array as input: When `data_in` consists of identical values across all nodes, the output `sorted_out` remains identical to `data_in`.\n \n4. Total latency of the worst case scenarios: For worst-case scenarios, including left-skewed trees, right-skewed trees, and arrays with duplicate values, and when ARRAY_SIZE > 1, the total number of clock cycles from the moment `start` is asserted until `done` is set high is equal to ((ARRAY_SIZE - 1) * ARRAY_SIZE)/2 + 4 * ARRAY_SIZE + 5.\n\n5. Latency for constructing a BST from an already sorted array (ascending order) and check the condition for the constructed right-skewed BST: \n   - When `data_in` is sorted in ascending order and ARRAY_SIZE > 1, the total latency for constructing the BST is ((ARRAY_SIZE - 1) * ARRAY_SIZE) / 2 + 2 * ARRAY_SIZE + 2 clock cycles.\n   - The constructed BST must be a right-skewed tree where all the indices of the `left_child` are invalid, indicating that no left child exists, and at least one index of `right_child` is valid.\n\n6.  Latency for constructing a BST from an already sorted array (ascending order) and check the condition for the constructed left-skewed BST: \n     - When `data_in` is sorted in descending order or is duplicated throughout and ARRAY_SIZE > 1, the total latency for constructing the BST is ((ARRAY_SIZE - 1) * ARRAY_SIZE) / 2 + 2 * ARRAY_SIZE + 2 clock cycles.\n     - The constructed BST must be a left-skewed tree where all the indices of the `right_child` are invalid, indicating that no right child exists, and at least one index of `left_child` is valid.\n\n7. Construction of the BST is complete when all the indices in the input array are traversed: When the tree is complete, all the indices of the `data_in` must be traversed (`input_index` is equal to ARRAY_SIZE).\n\n8. Maximum depth of a sorted array: A sorted array forms a right-skewed tree. The maximum depth of `right_child` in the right-skewed BST is ARRAY_SIZE - 1. This depth is determined by index ARRAY_SIZE - 1 of `right_child` being invalid and index  ARRAY_SIZE - 2 of `right_child` being valid (as it implies all indices up to ARRAY_SIZE - 2 are valid).\n\n9. Maximum depth of a reverse sorted or duplicated array: An array that is sorted in reverse order or containing identical keys, forms a left-skewed binary search tree (BST). The maximum depth of `left_child` in the left-skewed BST is ARRAY_SIZE - 1. This depth is determined by index ARRAY_SIZE - 1 of `left_child` being invalid and index  ARRAY_SIZE - 2 of `left_child` being valid (as it implies all indices up to ARRAY_SIZE - 2 are valid).", "context": {"rtl/binary_search_tree_sort.sv": "module binary_search_tree_sort #(\n    parameter DATA_WIDTH = 32,\n    parameter ARRAY_SIZE = 15\n) (\n    input clk,\n    input reset,\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in, // Input data to be sorted\n    input start,\n    output reg [ARRAY_SIZE*DATA_WIDTH-1:0] sorted_out, // Sorted output\n    output reg done\n);\n\n    // Parameters for top-level FSM states\n    parameter IDLE = 2'b00, BUILD_TREE = 2'b01, SORT_TREE = 2'b10;\n\n    // Parameters for nested FSM states (Build Tree)\n    parameter INIT = 2'b00, INSERT = 2'b01, TRAVERSE = 2'b10, COMPLETE = 2'b11;\n\n    // Parameters for nested FSM states (Sort Tree)\n    parameter S_INIT = 2'b00, S_SORT_LEFT_RIGHT = 2'b01, S_MERGE_RESULTS = 2'b10;\n    // Registers for FSM states\n    reg [1:0] top_state, build_state, sort_state;\n\n    // BST representation\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in_copy;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys; // Array to store node keys\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child; // Left child pointers\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child; // Right child pointers\n    reg [$clog2(ARRAY_SIZE):0] root; // Root node pointer\n    reg [$clog2(ARRAY_SIZE):0] next_free_node; // Pointer to the next free node\n\n    // Working registers\n    reg [$clog2(ARRAY_SIZE):0] current_node; // Current node being processed\n    reg [$clog2(ARRAY_SIZE):0] input_index; // Index for input data\n    reg [DATA_WIDTH-1:0] temp_data; // Temporary data register\n\n    // Intermediate buffers for storing sorted values of left and right subtrees\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] left_sorted;  // Buffer for left subtree sorted values\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] right_sorted; // Buffer for right subtree sorted values\n\n    // Stack and pointers for left and right subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_stack; // Stack for left subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_stack; // Stack for right subtree traversal\n    reg [$clog2(ARRAY_SIZE):0] sp_left; // Stack pointer for left subtree\n    reg [$clog2(ARRAY_SIZE):0] sp_right; // Stack pointer for right subtree\n\n    // Current node pointers for left and right subtrees\n    reg [$clog2(ARRAY_SIZE):0] current_left_node; // Current node in left subtree\n    reg [$clog2(ARRAY_SIZE):0] current_right_node; // Current node in right subtree\n\n    // Flags to indicate when sorting of left and right subtrees is done\n    reg left_done; // Flag for completion of left subtree sorting\n    reg right_done; // Flag for completion of right subtree sorting\n\n    // Output indices for left and right subtree buffers\n    reg [$clog2(ARRAY_SIZE):0] left_output_index; // Output index for left_sorted buffer\n    reg [$clog2(ARRAY_SIZE):0] right_output_index; // Output index for right_sorted buffer\n\n    // Initialize all variables\n    integer i, j;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all states and variables\n            top_state <= IDLE;\n            build_state <= INIT;\n            sort_state <= S_INIT;\n            root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; ; // Null pointer\n            next_free_node <= 0;\n            input_index <= 0;\n            done <= 0;\n\n            // Clear tree arrays\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                left_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                right_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n            end\n\n        end \n        else begin\n            case (top_state)\n                IDLE: begin\n                    done <= 0;\n                    input_index <= 0;\n                    root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; ; // Null pointer\n                    next_free_node <= 0;\n                    for (i = 0; i < ARRAY_SIZE+1; i = i + 1) begin\n                        keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                        right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        left_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        right_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                    end\n                    if (start) begin\n                        // Load input data into input array\n                        top_state <= BUILD_TREE;\n                        build_state <= INIT;\n                        data_in_copy <= data_in;\n                    end\n                end\n\n                BUILD_TREE: begin\n                    case (build_state)\n                        INIT: begin\n                            if (input_index < ARRAY_SIZE) begin\n                                temp_data <= data_in_copy[input_index*DATA_WIDTH +: DATA_WIDTH]; \n                                input_index <= input_index + 1;\n                                build_state <= INSERT;\n                            end else begin\n                                build_state <= COMPLETE;\n                            end\n                        end\n\n                        INSERT: begin\n                            if (root == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                // Tree is empty, insert at root\n                                root <= next_free_node;\n                                keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                next_free_node <= next_free_node + 1; \n                                build_state <= INIT;\n                            end else begin\n                                // Traverse the tree to find the correct position\n                                current_node <= root; \n                                build_state <= TRAVERSE;\n                            end\n                        end\n\n                        TRAVERSE: begin      \n                            if ((temp_data < keys[current_node*DATA_WIDTH +: DATA_WIDTH]) || (temp_data == keys[current_node*DATA_WIDTH +: DATA_WIDTH])) begin\n                                if (left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                    left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                                    keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                    next_free_node <= next_free_node + 1;\n                                    build_state <= INIT;\n                                end else begin\n                                    current_node <= left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                                end\n                            end else begin\n                                if (right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                    right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                                    keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data; \n                                    next_free_node <= next_free_node + 1;\n                                    build_state <= INIT;\n                                end else begin\n                                    current_node <= right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                                end\n                            end\n                        end\n\n                        COMPLETE: begin\n                            // Tree construction complete\n                            top_state <= SORT_TREE;\n                            sort_state <= S_INIT;\n                        end\n\n                    endcase\n                end\n\n                SORT_TREE: begin\n                    case (sort_state)\n                        S_INIT: begin\n                            if (root != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                // Start parallel sorting for left and right subtrees\n                                left_output_index <= 0;\n                                right_output_index <= 0;\n                                sp_left <= 0;\n                                sp_right <= 0;\n                                left_done <= 0;\n                                right_done <= 0;\n                                current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                current_right_node <= right_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                sort_state <= S_SORT_LEFT_RIGHT;\n                            end else begin\n                                done <= 1; // No tree to sort\n                                top_state <= IDLE;\n                            end\n                        end\n\n                        S_SORT_LEFT_RIGHT: begin\n                            // Sort left subtree in parallel\n                            if (!left_done && current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                                sp_left <= sp_left + 1;\n                                current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!left_done && sp_left > 0) begin\n                                sp_left <= sp_left - 1;\n                                current_left_node <= left_stack[({{(32-$bits(sp_left)){1'b0}}, sp_left} - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                left_sorted[left_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[left_stack[({{(32-$bits(sp_left)){1'b0}}, sp_left} - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH];\n                                left_output_index <= left_output_index + 1;\n                                current_left_node <= right_child[left_stack[({{(32-$bits(sp_left)){1'b0}}, sp_left} - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!left_done) begin\n                                left_done <= 1;\n                            end\n\n                            // Sort right subtree in parallel\n                            if (!right_done && current_right_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                right_stack[sp_right*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_right_node;\n                                sp_right <= sp_right + 1;\n                                current_right_node <= left_child[current_right_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!right_done && sp_right > 0) begin\n                                sp_right <= sp_right - 1;\n                                current_right_node <= right_stack[({{(32-$bits(sp_right)){1'b0}}, sp_right} - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                right_sorted[right_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[right_stack[({{(32-$bits(sp_right)){1'b0}}, sp_right} - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH];\n                                right_output_index <= right_output_index + 1;\n                                current_right_node <= right_child[right_stack[({{(32-$bits(sp_right)){1'b0}}, sp_right} - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!right_done) begin\n                                right_done <= 1;\n                            end\n\n                            // Transition to merging once both left and right sorting are done\n                            if (left_done && right_done) begin\n                                sort_state <= S_MERGE_RESULTS;\n                            end\n                        end\n\n                        S_MERGE_RESULTS: begin\n\n                            // Merge left_sorted, root, and right_sorted into final sorted output\n                            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                                if (i < left_output_index) begin\n                                    sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= left_sorted[i*DATA_WIDTH +: DATA_WIDTH];\n                                end\n                            end\n\n                            // Insert the root into `sorted_out`\n                            sorted_out[left_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[root*DATA_WIDTH +: DATA_WIDTH];\n\n                            // Copy `right_sorted` into `sorted_out`\n                            for (j = 0; j < ARRAY_SIZE; j = j + 1) begin\n                                if (j < right_output_index) begin\n                                    sorted_out[(({{(32-$bits(left_output_index)){1'b0}}, left_output_index} + 1) + j)*DATA_WIDTH +: DATA_WIDTH] <= right_sorted[j*DATA_WIDTH +: DATA_WIDTH];\n                                end\n                            end\n\n                            done <= 1; // Sorting complete\n                            top_state <= IDLE;\n\n                        end\n\n                        default: begin\n                            sort_state <= S_INIT; // Reset to initial sort state\n                        end\n                    endcase\n                end\n\n                default: begin\n                    top_state <= IDLE; // Default behavior for top-level FSM\n                end\n                \n            endcase\n        end\n    end\nendmodule"}}, "output": {"response": "", "context": {"rtl/binary_search_tree_sort.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/binary_search_tree_sort.sv \nTOPLEVEL        = binary_search_tree_sort\nMODULE          = test_binary_search_tree_sort\nPYTHONPATH      = /src\nHASH            = 44-rtl-assertion-bst-sorter", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/binary_search_tree_sort.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build -vcd dumpon\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0", "src/test_binary_search_tree_sort.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\ndef create_balanced_array(sorted_array):\n    # Recursive function to create a balanced array\n    if not sorted_array:\n        return []\n    mid = len(sorted_array) // 2\n    return [sorted_array[mid]] + create_balanced_array(sorted_array[:mid]) + create_balanced_array(sorted_array[mid + 1:])\n\ndef calculate_latency(array_size, sorted):\n    if array_size == 1: \n        # (INIT + INSERT = 2) + (INIT + Complete (for any node)) + IDLE \n        latency_build_tree = 5\n        # (INIT +  check for right/left + left/right done + 1(done set))\n        latency_sort_tree = 4\n    \n    if sorted:\n        # For any node (INIT + INSERT = 2) = 2 * array_size + 2 (INIT + Complete (final))\n        # for sorted(for each node traverse until current depth) = (sum of array_size-1) = (array_size -1) * array_size / 2\n        latency_build_tree = ((array_size - 1) * array_size)/2 + 2 * array_size + 2\n\n        # (Every node (except root) goes through traverse left + process node) + Set Root Node + Set Done + Move to Merge Results + Merge\n        # An additional clcok as the count is incremented when the done signal sets\n        latency_sort_tree = 2 * (array_size - 1) + 4 + 1\n\n    total_latency = latency_build_tree + latency_sort_tree\n\n    return total_latency\n\n\n@cocotb.test()\nasync def test_bst_sorter(dut):\n    ARRAY_SIZE = int(dut.ARRAY_SIZE.value)\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n\n    clk_period = 10  # ns\n    random.seed(0)  # For reproducibility\n\n    cocotb.start_soon(clock(dut, clk_period))\n\n    await reset_dut(dut, 5)\n    dut.start.value = 0\n\n    # Increase the count for more tests\n    test_count = 2\n    for idx in range(test_count):\n        arr = [random.randint(0, (1 << DATA_WIDTH)-1) for _ in range(ARRAY_SIZE)]\n        cocotb.log.info(f\"Random: {arr}!\")\n        await run_test_case(f\"Random {idx}\", dut, arr, DATA_WIDTH, ARRAY_SIZE, 0)\n\n    # Worst case scenario for BST (descending)\n    arr = random.sample(range(1 << DATA_WIDTH), ARRAY_SIZE)\n    cocotb.log.info(f\"Worst case scenario for BST (descending): {sorted(arr)}!\")\n    await run_test_case(f\" Worst case scenario (descending)\", dut, sorted(arr), DATA_WIDTH, ARRAY_SIZE, 1)\n    \n    # Worst case scenario for BST (ascending)\n    name = \"Worst case scenario (ascending)\"\n    arr = random.sample(range(1 << DATA_WIDTH), ARRAY_SIZE)\n    cocotb.log.info(f\"Worst case scenario for BST (ascending): {sorted(arr, reverse=True)}!\")\n    await run_test_case(f\"{name}\", dut, sorted(arr, reverse=True), DATA_WIDTH, ARRAY_SIZE, 1)\n    \n    # Best case scenario for BST (Balanced Tree)\n    elements = sorted(random.sample(range(1 << DATA_WIDTH), ARRAY_SIZE))\n    balanced_array = lambda nums: nums[len(nums)//2:len(nums)//2+1] + balanced_array(nums[:len(nums)//2]) + balanced_array(nums[len(nums)//2+1:]) if nums else []\n    balanced_tree_array = balanced_array(elements)\n    cocotb.log.info(f\"Balanced_tree_array: {balanced_tree_array}!\")\n    await run_test_case(f\"Balanced Tree\", dut, balanced_tree_array, DATA_WIDTH, ARRAY_SIZE, 0)\n\n    # Mixed min/max pattern \n    arr = [0 if i % 2 == 0 else (1 << DATA_WIDTH)-1 for i in range(ARRAY_SIZE)]\n    cocotb.log.info(f\"Mixed min/max pattern: {arr}!\")\n    await run_test_case(\"Min-Max Alternating\", dut, arr, DATA_WIDTH, ARRAY_SIZE, 0)\n\n    # All duplicates - check for latency as it traverses only left tree similar to sorted input array in ascending order\n    random_val = random.randint(0, (1 << DATA_WIDTH)-1)\n    cocotb.log.info(f\"All duplicates: {[random_val] * ARRAY_SIZE}!\")\n    await run_test_case(\"All Duplicates\", dut, [random_val] * ARRAY_SIZE, DATA_WIDTH, ARRAY_SIZE, 1)\n\n\nasync def reset_dut(dut, duration):\n    dut.reset.value = 1\n    for _ in range(duration):\n        await RisingEdge(dut.clk)\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\nasync def clock(dut, clk_period):\n        while True:\n            dut.clk.value = 0\n            await Timer(clk_period/2, units='ns')\n            dut.clk.value = 1\n            await Timer(clk_period/2, units='ns')\n\nasync def run_test_case(name, dut, input_array, data_width, array_size, sort):\n        cocotb.log.info(f\"Running Test: {name}\")\n        packed_input = 0\n        for idx, val in enumerate(input_array):\n            packed_input |= (val << (idx * data_width))\n        dut.data_in.value = packed_input\n     \n        await RisingEdge(dut.clk)\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        cycle_count = 0\n        while True:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n            if dut.done.value == 1:\n                break\n\n        cocotb.log.info(f\"Total Latency {cycle_count}\")\n        out_data_val = int(dut.sorted_out.value)\n\n        output_array = [ (out_data_val >> (i * data_width)) & ((1 << data_width) - 1) for i in range(array_size)]\n        expected_output = sorted(input_array)\n        \n        assert output_array == expected_output, f\"[{name}] Output incorrect. Got: {output_array}, Expected: {expected_output}\"\n        \n        # Check for Latency\n        if ((sort) or (array_size == 1)):\n            cocotb.log.debug(f\"{name}: Total Latency for BUILD_TREE and SORT_TREE FSM: {cycle_count}, expected : {calculate_latency(array_size, 1)}\")\n            assert calculate_latency(array_size, 1) == cycle_count, f\"[{name}] Latency incorrect. Got: {cycle_count}, Expected: {calculate_latency(array_size, 1)}\"\n\n        cocotb.log.info(f\"Test {name} passed.\")\n", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\n\ndef call_runner(DATA_WIDTH, ARRAY_SIZE):\n   \n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            parameter={'DATA_WIDTH': DATA_WIDTH, 'ARRAY_SIZE' : ARRAY_SIZE},\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n        hrs_lb.xrun_tb()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n\n# Parametrize test for different WIDTH and SIGNED_EN\n@pytest.mark.parametrize(\"DATA_WIDTH\", [6,32])\n@pytest.mark.parametrize(\"ARRAY_SIZE\", [8,15])\n\ndef test_bst(DATA_WIDTH, ARRAY_SIZE):\n    # Log the randomized WIDTH\n    print(f'Running with: DATA_WIDTH = {DATA_WIDTH}, ARRAY_SIZE = {ARRAY_SIZE}')\n\n    # Call the runner function with the randomized WIDTH\n    call_runner(DATA_WIDTH,ARRAY_SIZE)\n"}}}
{"id": "cvdp_copilot_binary_to_BCD_0034", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the `binary_to_bcd` module to ensure its correct functionality during simulation? The assertions should cover the key aspects of the Double Dabble algorithm, ensuring that the output (`bcd_out`) remains within valid bounds (each 4-bit BCD digit should be between `0 to 9`) after the binary-to-BCD conversion process.\n___\n### Key Assertions\n##\n**1. BCD Output Validity**\n  - Condition:\n    - Each 4-bit BCD digit must be within the valid decimal range (`0\u20139`).\n    - If any BCD digit exceeds `1001`, the assertion should trigger an error message that includes:\n      - Binary input (`binary_in`).\n      - Faulty BCD output (`bcd_out`).\n  -  Assertion Implementation:\n     - Check each BCD digit (hundreds, tens, ones):\n      - `bcd_out[11:8]` (Hundreds)\n      - `bcd_out[7:4]` (Tens)\n      - `bcd_out[3:0]` (Ones)\n  - Error Message:\n    - The display message of actual value of result.\n\n___\n### Implementation Requirements\n**1. Placement**\n  - Assertions must be placed inside the RTL module (`binary_to_bcd`) to check for violations at runtime.\n\n**2. Immediate Assertions**\n  - Use `assert()` inside `always` for real-time verification of the BCD conversion.\n\n**3. Failure Handling**\n  - If an assertion fails, the simulation should:\n    - Display debug information (`$display`).\n\n___\n### Interface\n##\n**INPUT**\n  - `binary_in[7:0]`: A 8-bit Binary input value to be converted into BCD.\n\n**OUTPUT**\n  - `bcd_out[11:0]`: A 3-digit BCD output converted from binary input, each digit represented by 4 bits.\n___", "context": {"rtl/binary_to_bcd.sv": "module binary_to_bcd (\n    input logic [7:0] binary_in,  // 8-bit binary input\n    output logic [11:0] bcd_out  // 12-bit BCD output (3 digits)\n);\n\n  logic [19:0] shift_reg;  \n  integer i;\n\n  always @* begin\n    shift_reg = {12'd0, binary_in};  \n    for (i = 0; i < 8; i = i + 1) begin\n      if (shift_reg[11:8] >= 5) shift_reg[11:8] = shift_reg[11:8] + 3;\n      if (shift_reg[15:12] >= 5) shift_reg[15:12] = shift_reg[15:12] + 3;\n      if (shift_reg[19:16] >= 5) shift_reg[19:16] = shift_reg[19:16] + 3;\n\n      shift_reg = shift_reg << 1;\n    end\n\n    bcd_out = shift_reg[19:8];\n\n  end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/binary_to_bcd.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/binary_to_bcd.sv\nTOPLEVEL        = binary_to_bcd\nMODULE          = test_binary_to_bcd\nPYTHONPATH      = /src\nHASH            = 34-assertion-for-binary-to-bcd-converter\n", "src/test_binary_to_bcd.py": "\nimport cocotb\nfrom cocotb.triggers import Timer\nimport random\n\n\ndef binary_to_bcd(binary_in):\n    \"\"\" Reference function for binary to BCD conversion using Double Dabble algorithm in Python \"\"\"\n    bcd_digits = [0, 0, 0]  # Initialize 3 BCD digits\n    for i in range(8):  # 8-bit binary input\n        # Add 3 if any BCD digit is 5 or greater\n        if bcd_digits[2] >= 5:\n            bcd_digits[2] += 3\n        if bcd_digits[1] >= 5:\n            bcd_digits[1] += 3\n        if bcd_digits[0] >= 5:\n            bcd_digits[0] += 3\n        # Shift left and add next binary bit\n        bcd_digits[2] = (bcd_digits[2] << 1) | (bcd_digits[1] >> 3)\n        bcd_digits[1] = ((bcd_digits[1] << 1) & 0xF) | (bcd_digits[0] >> 3)\n        bcd_digits[0] = ((bcd_digits[0] << 1) & 0xF) | ((binary_in >> (7 - i)) & 0x1)\n    return (bcd_digits[2] << 8) | (bcd_digits[1] << 4) | bcd_digits[0]\n\n\n@cocotb.test()\nasync def test_binary_to_bcd(dut):\n    \"\"\" Test binary to BCD conversion using a reference model, with predefined and random test cases \"\"\"\n    \n    # Define a range of predefined test cases\n    test_cases = [0, 20, 99, 128, 255]\n    \n    # Generate additional random test cases\n    random_test_cases = [random.randint(0, 255) for _ in range(5)]\n    \n    # Combine predefined and random test cases\n    all_test_cases = test_cases + random_test_cases\n\n    for binary_value in all_test_cases:\n        # Apply the binary input to the DUT\n        dut.binary_in.value = binary_value\n        await Timer(10, units=\"ns\")\n\n        # Calculate the expected BCD output using the reference model\n        expected_bcd = binary_to_bcd(binary_value)\n\n        # Retrieve the actual BCD output from the DUT\n        bcd_out = int(dut.bcd_out.value)\n\n        # Check if the DUT output matches the expected BCD output\n        assert bcd_out == expected_bcd, f\"Test failed for binary {binary_value}: Expected {expected_bcd:012b}, got {bcd_out:012b}\"\n        \n        # Print results\n        dut._log.info(f\"Binary Input: {binary_value} | Expected BCD Output: {expected_bcd:012b} | DUT BCD Output: {bcd_out:012b}\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}}
{"id": "cvdp_copilot_binary_to_gray_0011", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the `binary_to_gray` module to ensure its correct functionality during simulation? The assertions should validate the correctness of the Binary to Gray code conversion, ensuring that the Gray code output (`gray_out`) follows the expected XOR-based transformation rules and maintains one-bit change property between successive binary inputs.\n\n___\nKey Assertions\n**1. Correct Gray Code Conversion**\n  - **Condition:**\n    - Each bit of the Gray code output should follow the rule:\n                                   `G[i]=B[i+1] XOR B[i]`\n     where the most significant bit (MSB) remains unchanged:\n                              `G[WIDTH\u22121]=B[WIDTH\u22121]`\n    - If the computed `gray_out` does not match the expected value, the assertion should trigger an error message that includes:\n      - Binary input (`binary_in`).\n      - Faulty Gray code output (`gray_out`).\n      - Expected correct Gray code value.\n\n  - **Assertion Implementation:**\n    - Verify that the generated Gray code follows the `XOR` transformation for all bits.\n    - Ensure the `MSB` remains the same as the binary input's `MSB`.\n \n  - **Error Message:**\n    - The assertion should display the actual and expected values to aid debugging.\n\n___\n### Implementation Requirements\n\n  **1. Placement**\n   - Assertions must be placed inside the RTL module (`binary_to_gray`) to validate real-time behavior during simulation.\n\n  **2. Immediate Assertions**\n   - Use `assert()` inside an always block for real-time validation of Gray code conversion logic.\n\n  **3. Failure Handling**\n   - If an assertion fails, the simulation should:\n   - Display debug information (`$display`).\n   - Identify the incorrect transformation and indicate the expected behavior.\n\n___\n### Interface: \n  **PARAMETER**\n   - `WIDTH`: Define the bit width of the input(Default: 6)\n\n  **INPUT**\n   - `binary_in[5:0]`: A 6-bit binary input value to be converted into Gray code.\n  \n  **OUTPUT**\n   - `gray_out[5:0]`: A 6-bit Gray code output derived from the binary input.", "context": {"rtl/binary_to_gray.sv": "module binary_to_gray #(\n    parameter WIDTH = 6 \n    input  wire [WIDTH-1:0] binary_in,  \n    output wire [WIDTH-1:0] gray_out    \n);\n\n \n  assign gray_out[WIDTH-1] = binary_in[WIDTH-1];\n\n  generate\n    genvar i;\n    for (i = 0; i < WIDTH - 1; i = i + 1) begin\n      assign gray_out[i] = binary_in[i+1] ^ binary_in[i];\n    end\n  endgenerate\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/binary_to_gray.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/binary_to_gray.sv\nTOPLEVEL        = binary_to_gray\nMODULE          = test_binary_to_gray\nPYTHONPATH      = /src\nHASH            = 11-assertion-generation-for-binary-to-gray-converter\n", "src/test_binary_to_gray.py": "import cocotb\nfrom cocotb.triggers import Timer\nimport random\nimport os\n\n@cocotb.test()\nasync def test_binary_to_gray(dut):\n    \"\"\"Test Binary to Gray Code Conversion\"\"\"\n\n    # Read width parameter from DUT\n    WIDTH = int(dut.WIDTH.value)\n\n    # Function to calculate Gray code in Python\n    def binary_to_gray(binary):\n        return binary ^ (binary >> 1)\n\n    # Predefined test cases based on WIDTH\n    predefined_cases = [i for i in range(2 ** WIDTH)]  # All possible values for WIDTH bits\n\n    # Run predefined test cases\n    dut._log.info(f\"Running predefined test cases with WIDTH={WIDTH}\")\n    for binary in predefined_cases:\n        dut.binary_in.value = binary\n        await Timer(10, units=\"ns\")  # Wait for 10 ns\n        gray = binary_to_gray(binary)\n        dut_gray = int(dut.gray_out.value)  # Convert LogicArray to integer\n        cocotb.log.info(f\"Pushed Binary: {binary:0{WIDTH}b}, Expected Gray: {gray:0{WIDTH}b}, DUT Gray: {dut_gray:0{WIDTH}b}\")\n        assert dut_gray == gray, \\\n            f\"Predefined Test Failed: Binary={binary:0{WIDTH}b}, Expected Gray={gray:0{WIDTH}b}, Got={dut_gray:0{WIDTH}b}\"\n\n    # Print message to indicate transition to random cases\n    dut._log.info(\"--- Printing Random Values ---\")\n\n    # Random test cases\n    for _ in range(16):\n        binary = random.randint(0, (1 << WIDTH) - 1)  # Generate random WIDTH-bit binary\n        dut.binary_in.value = binary\n        await Timer(10, units=\"ns\")  # Wait for 10 ns\n        gray = binary_to_gray(binary)\n        dut_gray = int(dut.gray_out.value)  # Convert LogicArray to integer\n        cocotb.log.info(f\"Pushed Binary: {binary:0{WIDTH}b}, Expected Gray: {gray:0{WIDTH}b}, DUT Gray: {dut_gray:0{WIDTH}b}\")\n        assert dut_gray == gray, \\\n            f\"Random Test Failed: Binary={binary:0{WIDTH}b}, Expected Gray={gray:0{WIDTH}b}, Got={dut_gray:0{WIDTH}b}\"\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}}
{"id": "cvdp_copilot_cache_lru_0027", "categories": ["cid014", "easy"], "input": {"prompt": "Create a SystemVerilog Assertion to verify that for a given index, once one of its way counters has reached the\nmaximum frequency, it remains possible for this same way to eventually be selected for replacement in the future.\nThis is a liveness check. The assertion should be designed to allow verification of any index or way during\nsimulation.\n\n## Design Specifications\n\n### Module Name: `lfu_counter_policy`\n\n### Parameters\n1. **NWAYS**: Number of ways in the cache (default: 4). Must be a power of 2 and at least 4.\n2. **NINDEXES**: Number of indexes in the cache (default: 32). Must be a power of 2.\n3. **COUNTERW**: Width of frequency counters for LFU (default: 2). Must be at least 2.\n\n### Ports\n\n| Port Name       | Direction | Size                          | Description                                          |\n|-----------------|-----------|-------------------------------|------------------------------------------------------|\n| `clock`         | Input     | 1 bit                         | Clock signal (rising edge)                           |\n| `reset`         | Input     | 1 bit                         | Asynchronous reset signal, active high               |\n| `index`         | Input     | `ceil(log2(NINDEXES))` bits   | Index to select the cache set                        |\n| `way_select`    | Input     | `ceil(log2(NWAYS))` bits      | Cache way selected for access                        |\n| `access`        | Input     | 1 bit                         | Signal indicating a cache access                     |\n| `hit`           | Input     | 1 bit                         | Signal indicating a cache hit                        |\n| `way_replace`   | Output    | `ceil(log2(NWAYS))` bits      | Way selected for replacement                         |\n\n### Relevant Code Details\n\nThe `lfu_counter_policy` module maintains a frequency file that stores bit arrays for each cache index. Each bit array\ncontains one counter per way, with the counter size defined by `COUNTERW`.\n\n```sv\n    reg [(NWAYS * COUNTERW)-1:0] frequency [NINDEXES-1:0];\n```\n\n### Expected Behavior\n\nAn assertion failure must include an error message with details helpful for debugging.", "context": {"rtl/lfu_counter_policy.sv": "module lfu_counter_policy #(\n    parameter NWAYS = 4,\n    parameter NINDEXES = 32,\n    parameter COUNTERW = 2\n)(\n    input clock,\n    input reset,\n    input [$clog2(NINDEXES)-1:0] index,\n    input [$clog2(NWAYS)-1:0] way_select,\n    input access,\n    input hit,\n    output [$clog2(NWAYS)-1:0] way_replace\n);\n\n    localparam int unsigned MAX_FREQUENCY = $pow(2, COUNTERW) - 1;\n\n    // Frequency array to track next way to be replaced\n    reg [(NWAYS * COUNTERW)-1:0] frequency [NINDEXES-1:0];\n\n    integer i, n;\n\n    // Sequential logic for reset and frequency updates\n    always_ff @ (posedge clock or posedge reset) begin\n        if (reset) begin\n            for (i = 0; i < NINDEXES; i = i + 1) begin\n                for (n = 0; n < NWAYS; n = n + 1) begin\n                    frequency[i][(n * COUNTERW) +: COUNTERW] <= COUNTERW'(0);\n                end\n            end\n        end else begin\n            if (access) begin\n                if (hit) begin\n                    // Set the frequency counter of the accessed way\n                    if (frequency[index][(way_select * COUNTERW) +: COUNTERW] < COUNTERW'(MAX_FREQUENCY)) begin\n                        frequency[index][(way_select * COUNTERW) +: COUNTERW] <= frequency[index][(way_select * COUNTERW) +: COUNTERW] + COUNTERW'(1);\n                    end else begin\n                        for (n = 0; n < NWAYS; n = n + 1) begin\n                            if (n != way_select && frequency[index][(n * COUNTERW) +: COUNTERW] > COUNTERW'(2)) begin\n                                frequency[index][(n * COUNTERW) +: COUNTERW] <= frequency[index][(n * COUNTERW) +: COUNTERW] - COUNTERW'(1);\n                            end\n                        end\n                    end\n                end else begin\n                    // Set the frequency counter of the replaced way\n                    frequency[index][(way_replace * COUNTERW) +: COUNTERW] <= COUNTERW'(1);\n                end\n            end\n        end\n    end\n\n    // Select the LFU slot\n    slot_select_lfu_counter #(\n        .NWAYS (NWAYS),\n        .COUNTERW (COUNTERW)\n    ) slot_select_unit (\n        .array (frequency[index]),\n        .index (way_replace)\n    );\n\nendmodule : lfu_counter_policy\n\nmodule slot_select_lfu_counter #(\n    parameter NWAYS = 4,\n    parameter COUNTERW = $clog2(NWAYS)\n)(\n    input logic [(NWAYS * COUNTERW)-1:0] array,\n    output logic [$clog2(NWAYS)-1:0] index\n);\n\n    integer i;\n\n    always_comb begin\n        // Default outputs\n        index = $clog2(NWAYS)'(0);\n\n        // Find the index of the first counter with minimum frequency\n        for (i = 0; i < NWAYS; i++) begin\n            if (array[(i * COUNTERW) +: COUNTERW] < array[(index * COUNTERW) +: COUNTERW]) begin\n                index = $clog2(NWAYS)'(i);\n            end\n        end\n    end\n\nendmodule : slot_select_lfu_counter"}}, "output": {"response": "", "context": {"rtl/lfu_counter_policy.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    image: verification_image\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/lfu_counter_policy.sv\nTOPLEVEL        = lfu_counter_policy\nMODULE          = test_lfu_counter_policy\nPYTHONPATH      = /src\nHASH            = 26782beaeb59212a70be799bd32493b75c05abf2", "src/coverage.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n", "src/test_lfu_counter_policy.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\n\nasync def test_lfu_max_frequency(dut):\n    \"\"\"Test behavior when counters reach MAX_FREQUENCY.\"\"\"\n    cocotb.log.info(\"Starting test_lfu_max_frequency...\")\n\n    nways = int(dut.NWAYS.value)\n    index = int(dut.VERIFY_INDEX.value)\n    target_way = int(dut.VERIFY_WAY.value)\n    max_frequency = int(dut.MAX_FREQUENCY.value)\n\n    await hrs_lb.reset(dut)\n\n    cocotb.log.debug(f\"Target index: {index}, Target way: {target_way}, MAX_FREQUENCY: {max_frequency}\")\n\n    await FallingEdge(dut.clock)\n    dut.way_select.value = target_way\n    dut.index.value = index\n    dut.access.value = 1\n    dut.hit.value = 1\n\n    # Set selected way counter to the max frequency value\n    for i in range(max_frequency):\n        await FallingEdge(dut.clock)\n\n    # Set max frequency to another way, so the target way has its counter decreased\n    for n in reversed(range(nways)):\n        if n == target_way:\n            continue\n        dut.way_select.value = n\n        assert n != target_way\n\n    iterations = max_frequency * 2\n    for i in range(iterations):\n        await FallingEdge(dut.clock)\n\n    # Set the frequency to at least 3 in the other ways\n    for n in reversed(range(nways)):\n        if n == target_way:\n            continue\n        dut.way_select.value = n\n        iterations = 3\n        for i in range(iterations):\n            await FallingEdge(dut.clock)\n\n\n@cocotb.test()\nasync def test_policy_working(dut):\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_policy_working...\")\n\n    clock_period = 10  # ns\n    await cocotb.start(Clock(dut.clock, clock_period, units=\"ns\").start())\n    await hrs_lb.dut_init(dut)\n\n    nways = int(dut.NWAYS.value)\n    nindexes = int(dut.NINDEXES.value)\n    max_frequency = int(dut.MAX_FREQUENCY.value)\n    counter_width = int(dut.COUNTERW.value)\n    cocotb.log.info(f\"NWAYS: {nways}  NINDEXES: {nindexes}  COUNTERW: {counter_width}  MAX_FREQUENCY: {max_frequency}\")\n\n    await test_lfu_max_frequency(dut)\n    cocotb.log.info(\"Test 1: MAX_FREQUENCY passed.\")\n\n    cocotb.log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nimport random\nimport pytest\nimport coverage\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef call_runner(NWAYS: int = 4, NINDEXES: int = 32, COUNTERW: int = 2):\n    parameters = {\n        \"NWAYS\": NWAYS,\n        \"NINDEXES\": NINDEXES,\n        \"COUNTERW\": COUNTERW,\n        \"VERIFY_WAY\": random.randint(0, NWAYS-1),\n        \"VERIFY_INDEX\": random.randint(0, NINDEXES-1)\n    }\n\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        coverage.coverage_report(\"assertion\")\n        coverage.covt_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n    # Run the simulation\n    call_runner()\n\n    # # Run the simulation with different parameters\n    call_runner(8, 16, math.ceil(math.log2(8)))\n    call_runner(8, 16, math.ceil(math.log2(8))+1)\n    call_runner(8, 16, math.ceil(math.log2(8))-1)\n    call_runner(16, 64)\n    call_runner(16, 64, math.ceil(math.log2(16)))\n"}}}
{"id": "cvdp_copilot_cache_lru_0028", "categories": ["cid014", "easy"], "input": {"prompt": "Create a SystemVerilog Assertion to verify the **FIFO behavior** in the `fifo_policy` module. The module implements a FIFO-based cache replacement policy. Please verify that once one way is selected for replacement, after a new batch of miss cycles (not necessarily in consecutive cycles), the same way is selected for replacement again.\n\n## Design Specifications\n\n### Module Name: `fifo_policy`\n\n### Parameters:\n- **NWAYS**: Number of cache ways.\n- **NINDEXES**: Number of cache indexes.\n\n### Inputs:\n- **clock**: System clock (rising edge).\n- **reset**: Reset signal for initializing the FIFO state. Reset is active-high and asynchronous.\n- **index**: Cache index, selects the set in the cache.\n- **way_select**: Currently selected cache way (input, but not directly used in the FIFO logic).\n- **access**: Indicates an access to the cache.\n- **hit**: Indicates whether the access was a cache hit. A value of `0` indicates a miss.\n\n### Outputs:\n- **way_replace**: The cache way to be replaced is determined based on the FIFO policy. After reset, it remains unchanged until the first miss for the index occurs.\n\n### Relevant Code Details\n\nThe `fifo_policy` module maintains a **FIFO array** that stores a pointer to the next way to be replaced for each cache index. **The pointer functions as a counter that increments on each miss.** When it reaches `NWAYS-1`, it overflows and restarts, **pointing to position `0`**.\n\n```sv\n    reg [$clog2(NWAYS)-1:0] fifo_array [NINDEXES-1:0];    \n```\n\n### Expected Behavior\n\nAn assertion failure must include an error message to help debugging.", "context": {"rtl/fifo_policy.sv": "module fifo_policy #(\n    parameter NWAYS = 4,\n    parameter NINDEXES = 32\n)(\n    input clock,\n    input reset,\n    input [$clog2(NINDEXES)-1:0] index,\n    input [$clog2(NWAYS)-1:0] way_select,\n    input access,\n    input hit,\n    output [$clog2(NWAYS)-1:0] way_replace\n);\n\n    // FIFO array to track next way to be replaced\n    reg [$clog2(NWAYS)-1:0] fifo_array [NINDEXES-1:0];\n\n    integer i;\n\n    // Sequential logic for reset and fifo_array updates\n    always_ff @ (posedge clock or posedge reset) begin\n        if (reset) begin\n            for (i = 0; i < NINDEXES; i++) begin\n                fifo_array[i] <= $clog2(NWAYS)'(0);\n            end\n        end else begin\n            if (access && ~hit) begin\n                // Set the fifo_array position for the next replacement\n                fifo_array[index] <= fifo_array[index] + $clog2(NWAYS)'(1);\n            end\n        end\n    end\n\n    assign way_replace = fifo_array[index];\n\nendmodule : fifo_policy"}}, "output": {"response": "", "context": {"rtl/fifo_policy.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    image: verification_image\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/fifo_policy.sv\nTOPLEVEL        = fifo_policy\nMODULE          = test_fifo_policy\nPYTHONPATH      = /src\nHASH            = c3f6c3ed031df38d5820fef5cfe4afffed1fb171", "src/coverage.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\n\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\n\nasync def access_hit(dut, index_a, way_select_a):\n    dut.access.value = 1\n    dut.hit.value = 1\n    dut.index.value = index_a\n    dut.way_select.value = way_select_a\n\n    await FallingEdge(dut.clock)\n    print(f\"[DEBUG] way_replace: {dut.way_replace.value}\")\n    dut.access.value = 0\n    dut.hit.value = 0\n\n\nasync def access_miss(dut, index_a, way_select_a):\n    dut.access.value = 1\n    dut.hit.value = 0\n    dut.index.value = index_a\n    dut.way_select.value = way_select_a\n\n    await FallingEdge(dut.clock)\n    print(f\"[DEBUG] way_replace: 0b{dut.way_replace.value.integer:04b}\")\n    dut.access.value = 0\n    dut.hit.value = 0\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n", "src/test_fifo_policy.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nimport harness_library as hrs_lb\nimport random\n\n\nasync def test_fifo_behavior(dut):\n    \"\"\"Test the replacement order.\"\"\"\n    cocotb.log.info(\"Starting test_fifo_behavior...\")\n\n    await hrs_lb.dut_init(dut)\n    await hrs_lb.reset(dut)\n\n    nindexes = int(dut.NINDEXES.value)\n    nways = int(dut.NWAYS.value)\n\n    index = random.randint(0, nindexes-1)\n    target_way = random.randint(0, nways-1)\n\n    dut.index.value = index\n    dut.way_select.value = target_way\n\n    for n in range((nways * 2) + 1):\n        cocotb.log.debug(f\"Target index: {index}, Target way: {target_way}\")\n        if n > nways - 2:\n            await hrs_lb.access_hit(dut, index, target_way)\n        else:\n            await hrs_lb.access_miss(dut, index, target_way)\n\n    cocotb.log.debug(f\"Target index: {index}, Target way: {target_way}\")\n    await hrs_lb.access_miss(dut, index, target_way)\n    await hrs_lb.access_miss(dut, index, target_way)\n\n    cocotb.log.info(\"test_fifo_behavior passed.\")\n\n\n@cocotb.test()\nasync def test_policy_working(dut):\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_policy_working...\")\n\n    clock_period = 10  # ns\n    await cocotb.start(Clock(dut.clock, clock_period, units=\"ns\").start())\n\n    nways = int(dut.NWAYS.value)\n    nindexes = int(dut.NINDEXES.value)\n    cocotb.log.info(f\"NWAYS: {nways}  NINDEXES: {nindexes}\")\n\n    await test_fifo_behavior(dut)\n\n    cocotb.log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nimport random\nimport pytest\nimport coverage\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef call_runner(NWAYS: int = 4, NINDEXES: int = 32):\n    parameters = {\n        \"NWAYS\": NWAYS,\n        \"NINDEXES\": NINDEXES\n    }\n\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        coverage.coverage_report(\"assertion\")\n        coverage.covt_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n    # Run the simulation\n    call_runner()\n\n    # # Run the simulation with different parameters\n    call_runner(8, 32)\n    call_runner(16, 32)\n    call_runner(32, 32)\n"}}}
{"id": "cvdp_copilot_cascaded_adder_0028", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `cascaded_adder` module. The assertions should ensure correct reset behavior, data latching, valid signal propagation, and output correctness.  \n\n## **RTL Design Overview**  \nThe `cascaded_adder` module implements a **multi-stage adder tree** that sums `IN_DATA_NS` input values. It registers the input, processes the sum based on **pipeline register control bits (`REG`)**, and propagates the valid signal through a pipeline.  \n\n### **Parameters**\n - **`IN_DATA_WIDTH` (default = 16):** Specifies the bit-width of each individual input data element.\n - **`IN_DATA_NS` (default = 4):** Defines the number of input data elements to be summed.\n - **REG (default = 4'b1010):** Controls whether each intermediate stage in the adder tree will be registered or combinational. Each bit of REG corresponds to one summation stage, starting from the least significant bit (LSB) at the first stage.\n     - **`1`**: The stage will be registered, introducing a clock cycle latency.\n     - **`0`**: The stage will be combinational, with no added latency.\n     - The width of REG should match `IN_DATA_NS` to allow control over each stage in the adder tree. \n     \n### **Key Components of the Module**  \n\n- **`i_data_ff`**: Stores the registered input data.  \n- **`in_data_2d`**: Converts the flattened input array into a 2D structure for addition.  \n- **`sum_stage`**: Stores intermediate sum results in a cascaded manner.  \n- **`valid_ff`**: Registers the input `i_valid` signal.  \n- **`valid_pipeline`**: Propagates `valid_ff` with configurable latency based on `REG`.  \n- **`o_valid`**: Active high signal indicating when output data is valid.  \n- **`o_data`**: Final output sum after cascading through `sum_stage`.  \n- **`clk`**: Clock signal. Design is synchronized to the posedge of this clock.  \n- **`srst`**: Synchronous active-high reset signal.  \n- **`i_valid`**: Active-high signal indicating valid input data.  \n- **`i_data`**: Flattened array of `IN_DATA_NS` input values.  \n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n\n- **Reset Initialization Behavior:**  \n  - When `srst` is asserted, `i_data_ff` and `valid_ff` should be **cleared to `0`** on the next clock cycle.  \n\n- **Input Data Registration:**  \n  - When `i_valid` is asserted, `i_data_ff` should **capture the value of `i_data`** on the next clock cycle.  \n\n- **Valid Signal Latency:**  \n  - The output `o_valid` should **assert after the expected latency**.  \n  - The **expected latency** is determined by the **number of 1's in `REG` + 2**.  \n  - To compute the number of 1's in `REG`, a function named **`count_ones`** can be implemented.  \n\n\n- **Output Data Correctness:**  \n  - When `o_valid` is high, `o_data` should **match `sum_stage[IN_DATA_NS-1]`** at the same time, ensuring correct summation.  \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.  ", "comments": [], "context": {"rtl/cascaded_adder.sv": "module cascaded_adder #(\n    parameter int IN_DATA_WIDTH = 16,  // Width of each input data\n    parameter int IN_DATA_NS = 4,      // Number of input data elements\n    parameter [IN_DATA_NS-1:0] REG = 4'b1010        // Control bits for register insertion\n) (\n   input  logic clk,\n   input  logic srst,\n   input  logic i_valid, \n   input  logic [IN_DATA_WIDTH*IN_DATA_NS-1:0] i_data,  // Flattened input data array\n   output logic o_valid,\n   output logic [(IN_DATA_WIDTH+$clog2(IN_DATA_NS))-1:0] o_data // Output data (sum)\n);\n\n   // Internal signals for the adder tree\n   logic [IN_DATA_WIDTH*IN_DATA_NS-1:0] i_data_ff;                             // Flattened input data array register\n   logic [IN_DATA_WIDTH-1:0] in_data_2d [IN_DATA_NS-1:0];                      // Intermediate 2D array\n   logic [(IN_DATA_WIDTH+$clog2(IN_DATA_NS))-1:0] sum_stage [IN_DATA_NS-1:0];  // Intermediate sum array\n   logic valid_ff;\n   logic valid_pipeline [IN_DATA_NS-1:0];  // Pipeline to handle the valid signal latencies based on REG\n   \n   // Register the input data on valid signal\n   always_ff @(posedge clk) begin : reg_indata\n      if(srst)\n         i_data_ff <= 0;\n      else begin\n         if(i_valid) begin\n            i_data_ff <= i_data;\n         end\n      end\n   end\n\n   // Convert flattened input to 2D array\n   always_comb begin\n      for (int i = 0; i < IN_DATA_NS; i++) begin : conv_1d_to_2d\n         in_data_2d[i] = i_data_ff[(i+1)*IN_DATA_WIDTH-1 -: IN_DATA_WIDTH];\n      end\n   end\n\n   // Generate logic for the adder tree using generate statement\n   genvar i;\n   generate\n      for (i = 0; i < IN_DATA_NS ; i++) begin : sum_stage_gen\n         if(i == 0) begin\n            if(REG[i]) begin\n               always_ff @(posedge clk) begin\n                  if (srst) begin\n                     sum_stage[i] <= 0 ;\n                  end\n                  else begin\n                      sum_stage[i] <= in_data_2d[i];\n                  end\n               end\n            end\n            else begin\n               always_comb sum_stage[i] = in_data_2d[i];\n            end\n         end\n         else begin\n            if(REG[i]) begin\n               always_ff @(posedge clk) begin\n                  if (srst) begin\n                     sum_stage[i] <= 0 ;\n                  end\n                  else begin\n                      sum_stage[i] <= sum_stage[i-1] + in_data_2d[i];\n                  end\n               end\n            end\n            else begin\n               always_comb sum_stage[i] = sum_stage[i-1] + in_data_2d[i];\n            end\n         end\n      end\n   endgenerate\n\n   always_ff @(posedge clk) begin\n      if(srst)\n         valid_ff <= 1'b0;\n      else \n         valid_ff <= i_valid;\n   end\n\n\n   // Valid signal propagation with latency based on REG\n   generate\n      for (i = 0; i < IN_DATA_NS; i++) begin : valid_latency_gen\n         if (i == 0) begin\n            if (REG[0]) begin\n               always_ff @(posedge clk) begin\n                  if (srst)\n                     valid_pipeline[0] <= 1'b0;\n                  else\n                     valid_pipeline[0] <= valid_ff;  // Register valid_ff if REG[0] == 1\n               end\n            end\n            else begin\n               always_comb begin\n                  valid_pipeline[0] = valid_ff;  // Combinational if REG[0] == 0\n               end\n            end\n         end\n         else begin\n            if (REG[i]) begin\n               always_ff @(posedge clk) begin\n                  if (srst)\n                     valid_pipeline[i] <= 1'b0;\n                  else\n                     valid_pipeline[i] <= valid_pipeline[i-1];  // Shift the valid signal based on REG\n               end\n            end\n            else begin\n               always_comb begin\n                  valid_pipeline[i] = valid_pipeline[i-1];  // No clock latency if REG[i] is 0\n               end\n            end\n         end\n      end\n   endgenerate\n\n\n   // Assign the final stage of valid_pipeline to o_valid\n   always_ff @(posedge clk) begin\n      if(srst)\n         o_valid <= 1'b0;\n      else\n         o_valid <= valid_pipeline[IN_DATA_NS-1];\n   end\n\n   // Output data assignment\n   always_ff @(posedge clk) begin : reg_outdata\n      if (srst) begin\n         o_data <= 0 ;\n      end else if (valid_pipeline[IN_DATA_NS-1]) begin\n         o_data <= sum_stage[IN_DATA_NS-1];\n      end\n   end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/cascaded_adder.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cascaded_adder.sv\nTOPLEVEL        = cascaded_adder\nMODULE          = test_cascaded_adder\nPYTHONPATH      = /src\nHASH            = 28-rtl-assertion-generation-for-cascaded-adder", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clk)\n    dut.srst.value = 1\n\n    await FallingEdge(dut.clk)\n    dut.srst.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\ndef random_stim_generator(IN_DATA_NS, IN_DATA_WIDTH, StimType):\n    golden_output = 0 \n    input_1d = 0 \n    for _ in range (IN_DATA_NS):\n        if StimType == \"RANDOM\":\n            random_value = random.randint(0, (1 << IN_DATA_WIDTH) - 1)\n        elif StimType == \"DIRECT_MAX\":\n            random_value = (1 << IN_DATA_WIDTH) - 1\n        elif StimType == \"DIRECT_MIN\":\n            random_value = 0    \n        golden_output = golden_output + random_value \n        input_1d = (input_1d << IN_DATA_WIDTH) | random_value\n    \n    return (input_1d, golden_output)\n", "src/test_cascaded_adder.py": "import cocotb\nfrom cocotb.triggers import  Timer, RisingEdge, ReadOnly\nfrom cocotb.clock import Clock\nimport harness_library as util\nimport random\n\n@cocotb.test()\nasync def test_cascaded_adder(dut):\n    # Generate  random period clock \n    DUT_CLK = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(DUT_CLK.start())\n    dut._log.info(f\"DUT_CLK STARTED\")\n\n    # Initialize DUT\n    await util.dut_init(dut) \n    dut.srst.value = 1\n    # Apply reset and enable\n    await util.reset(dut)\n\n    # Wait for a couple of cycles to stabilize\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n    # Dut parameters\n    IN_DATA_WIDTH = int(dut.IN_DATA_WIDTH.value)\n    IN_DATA_NS = int(dut.IN_DATA_NS.value)\n    REG = int(dut.REG.value) & 0xFFFFFFFF  # Treat REG as unsigned 32-bit\n    LATENCY = 2 + bin(REG).count('1')\n    \n    # overflow TC\n    stimulus= util.random_stim_generator(IN_DATA_NS, IN_DATA_WIDTH, \"DIRECT_MAX\")\n    input_data = stimulus[0]\n    golden_output = stimulus[1]\n    await RisingEdge(dut.clk)\n    dut.i_data.value = input_data\n    dut.i_valid.value = 1  \n    await RisingEdge(dut.clk)\n    dut.i_valid.value = 0\n\n    latency = 0\n    while (dut.o_valid.value != 1):\n        await RisingEdge(dut.clk)\n        latency = latency + 1\n\n    assert latency == LATENCY, f\"Valid output should have latency of {LATENCY} clk cycles\"\n    assert dut.o_data.value == golden_output , f\"Outpud doesn't match golden output: dut_output {hex(dut.o_data.value)}, Expected output {hex(golden_output)}\"\n    \n\n    for i in range(50):\n        stimulus= util.random_stim_generator(IN_DATA_NS, IN_DATA_WIDTH, \"RANDOM\")\n        input_data = stimulus[0]\n        golden_output = stimulus[1]\n        await RisingEdge(dut.clk)\n        dut.i_data.value = input_data\n        dut.i_valid.value = 1  \n        await RisingEdge(dut.clk)\n        dut.i_valid.value = 0\n\n        latency = 0\n        while (dut.o_valid.value != 1):\n            await RisingEdge(dut.clk)\n            latency = latency + 1\n\n        assert latency == LATENCY, f\"Valid output should have latency of {LATENCY} clk cycles\"\n        assert dut.o_data.value == golden_output , f\"Outpud doesn't match golden output: dut_output {hex(dut.o_data.value)}, Expected output {hex(golden_output)}\"  \n\n\n    await util.reset(dut)\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner(IN_DATA_NS, IN_DATA_WIDTH, REG):\n    parameters = {\n        \"IN_DATA_NS\": IN_DATA_NS,\n        \"IN_DATA_WIDTH\": IN_DATA_WIDTH,\n        \"REG\": REG,\n    }\n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"random_test\", range(3))\ndef test_tree_adder(random_test):\n    IN_DATA_NS = (random.randint(1, 32))\n    IN_DATA_WIDTH = (random.randint(1, 64))\n    REG_random = random.getrandbits(IN_DATA_NS)\n    print(f'Running with: IN_DATA_NS = {IN_DATA_NS}, IN_DATA_WIDTH = {IN_DATA_WIDTH}, REG (random) = {REG_random}')\n    call_runner(IN_DATA_NS, IN_DATA_WIDTH, REG_random)\n", "src/test_sync_muller_c_element.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport harness_library as hrs_lb\nimport math\n\n# ----------------------------------------\n# - Synchornous Muller C Element Test\n# ----------------------------------------\n\nasync def reset_dut(dut, duration_ns=10):\n    \"\"\"\n    Perform a synchronous reset on the Design Under Test (DUT).\n\n    - Sets the reset signal high for the specified duration.\n    - Ensures all output signals are zero during the reset.\n    - Deactivates the reset signal and stabilizes the DUT.\n\n    Args:\n        dut: The Design Under Test (DUT).\n        duration_ns: The time duration in nanoseconds for which the reset signal will be held high.\n    \"\"\"\n    dut.srst.value = 1  # Activate reset (set to high)\n    await Timer(duration_ns, units=\"ns\")  # Hold reset high for the specified duration\n    await Timer(1, units=\"ns\")\n\n    # Verify that outputs are zero during reset\n    assert dut.out.value == 0, f\"[ERROR] out is not zero during reset: {dut.out.value}\"\n\n    dut.srst.value = 0  # Deactivate reset (set to low)\n    await Timer(duration_ns, units='ns')  # Wait for the reset to stabilize\n    dut.srst._log.debug(\"Reset complete\")\n\ndef weighted_random_input(num_inputs):\n    \"\"\"\n    Generate weighted random inputs.\n\n    Args:\n        num_inputs: Number of input bits.\n\n    Returns:\n        An integer representing the input vector.\n    \"\"\"\n    if random.random() < 0.6:  # 60% chance to generate all 0's or all 1's\n        return 0 if random.random() < 0.5 else (1 << num_inputs) - 1\n    else:  # 40% chance to generate other combinations\n        return random.randint(0, (1 << num_inputs) - 1)\n\n\n@cocotb.test()\nasync def test_sync_muller_c_element(dut):\n  \"\"\"\n  Verify the functionality of the sync_muller_c_element module with weighted random input vectors.\n\n  Test Steps:\n  1. Perform a synchronous reset.\n  2. Drive the DUT with weighted random inputs.\n  3. Verify correctness of the output based on input logic.\n  4. Cover scenarios including reset and stable input combinations.\n  \"\"\"\n\n  # Start the clock with a 10ns period\n  cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few clock cycles to ensure proper initialization\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve DUT configuration parameters\n  num_inputs = int(dut.NUM_INPUT.value)\n  pipe_depth = int(dut.PIPE_DEPTH.value)\n  num_samples = 20\n\n  # Print parameters for debugging\n  print(f\"NUM_INPUT: {num_inputs}\")\n  print(f\"PIPE_DEPTH: {pipe_depth}\")\n\n  # Test with weighted random input vectors\n  in_queue = []\n  out_queue = []\n  dut.clk_en.value = 1\n\n  for i in range(num_samples):\n    # Generate a random input\n    random_input = weighted_random_input(num_inputs)\n    dut.inp.value = random_input\n    # Add input to the queue for later verification\n    in_queue.append(random_input)\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Handle pipeline delay outputs\n  for i in range(pipe_depth):\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Remove outputs corresponding to initial pipeline latency\n  for i in range(pipe_depth):\n    prev_out = out_queue.pop(0)\n\n  # Perform verification of DUT outputs\n  for i in range(num_samples):\n    # Retrieve the input and output from the queues\n    in_temp = in_queue.pop(0)\n    out_temp = out_queue.pop(0)\n    \n    # Compute the expected output\n    all_high = (1 << num_inputs) - 1\n    all_low  = 0\n\n    expected_output = 1 if (in_temp == all_high) else (0 if (in_temp == all_low) else prev_out)\n\n    # Verify that the DUT output matches the expected output\n    assert out_temp == expected_output, f\"Test {i+1}: Output does not match the expected result: {out_temp} != {expected_output}\"\n\n    print(f\"Test {i+1} passed\")\n    prev_out = out_temp\n\n  # Wait for a few cycles before performing a final reset\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply a final reset to the DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles after reset to stabilize\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n\n@cocotb.test()\nasync def test_sync_muller_c_element_with_clk_en_toggle(dut):\n  \"\"\"\n  Verify the functionality of sync_muller_c_element with clock enable toggling.\n\n  Test Steps:\n  1. Perform a synchronous reset.\n  2. Toggle clock enable at specific intervals.\n  3. Drive inputs and verify outputs during enabled and disabled periods.\n  \"\"\"\n\n  # Start the clock with a 10ns period\n  cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few clock cycles to ensure proper initialization\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve DUT configuration parameters\n  num_inputs = int(dut.NUM_INPUT.value)\n  pipe_depth = int(dut.PIPE_DEPTH.value)\n  num_samples = 30\n\n  # Print parameters for debugging\n  print(f\"NUM_INPUT: {num_inputs}\")\n  print(f\"PIPE_DEPTH: {pipe_depth}\")\n\n  # Test with clock enable toggle\n  in_queue = []\n  out_queue = []\n  clk_en = 1\n  dut.clk_en.value = clk_en\n\n  for i in range(num_samples):\n\n    if (i  == 10):\n      clk_en = 0\n    elif (i  == 20):\n      clk_en = 1\n\n    dut.clk_en.value = clk_en\n\n    # Generate a random input\n    random_input = weighted_random_input(num_inputs)\n    dut.inp.value = random_input\n    # Add input to the queue for later verification\n    if (clk_en):\n      in_queue.append(random_input)\n\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Handle pipeline delay outputs\n  for i in range(pipe_depth):\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Remove outputs corresponding to initial pipeline latency\n  for i in range(pipe_depth):\n    prev_out = out_queue.pop(0)\n\n  # Perform verification of DUT outputs\n  for i in range(num_samples):\n    if (i >= (10 - pipe_depth) and i <= (19 - pipe_depth)):\n      expected_output = prev_out\n      out_temp = out_queue.pop(0)\n    else:\n      # Retrieve the input and output from the queues\n      in_temp = in_queue.pop(0)\n      out_temp = out_queue.pop(0)\n      \n      # Compute the expected output\n      all_high = (1 << num_inputs) - 1\n      all_low  = 0\n      expected_output = 1 if (in_temp == all_high) else (0 if (in_temp == all_low) else prev_out)\n\n    # Verify that the DUT output matches the expected output\n    assert out_temp == expected_output, f\"Test {i+1}: Output does not match the expected result: {out_temp} != {expected_output}\"\n\n    print(f\"Test {i+1} passed\")\n    prev_out = out_temp\n\n  # Wait for a few cycles before performing a final reset\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply a final reset to the DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles after reset to stabilize\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n\n\n@cocotb.test()\nasync def test_sync_muller_c_element_with_clr_toggle(dut):\n  \"\"\"\n  Verify the functionality of sync_muller_c_element with clear signal toggling.\n\n  Test Steps:\n  1. Perform a synchronous reset.\n  2. Drive inputs with random data.\n  3. Toggle the clear signal and verify output behavior.\n  \"\"\"\n\n  # Start the clock with a 10ns period\n  cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few clock cycles to ensure proper initialization\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve DUT configuration parameters\n  num_inputs = int(dut.NUM_INPUT.value)\n  pipe_depth = int(dut.PIPE_DEPTH.value)\n  num_samples = 30\n\n  # Print parameters for debugging\n  print(f\"NUM_INPUT: {num_inputs}\")\n  print(f\"PIPE_DEPTH: {pipe_depth}\")\n\n  # Test with clear signal toggling\n  in_queue = []\n  out_queue = []\n  dut.clk_en.value = 1\n  clr = 0\n  dut.clr.value = clr\n\n  for i in range(num_samples):\n    # Generate a random input\n    random_input = weighted_random_input(num_inputs)\n    dut.inp.value = random_input\n    # Add input to the queue for later verification\n    in_queue.append(random_input)\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n    if (i == 20):\n      clr = 1\n      dut.clr.value = clr\n\n  # Handle pipeline delay outputs\n  for i in range(pipe_depth):\n    await RisingEdge(dut.clk)\n    await Timer(1, units=\"ns\")\n    out = int(dut.out.value)\n    out_queue.append(out)\n\n  # Remove outputs corresponding to initial pipeline latency\n  for i in range(pipe_depth):\n    prev_out = out_queue.pop(0)\n\n  # Perform verification for DUT Outputs\n  for i in range(num_samples):\n    # Retrieve the input and output from the queues\n    in_temp = in_queue.pop(0)\n    out_temp = out_queue.pop(0)\n    \n    # Compute the expected output\n    all_high = (1 << num_inputs) - 1\n    all_low  = 0\n\n    if (i > (20 - pipe_depth)):\n      expected_output = 0\n    else:\n      expected_output = 1 if (in_temp == all_high) else (0 if (in_temp == all_low) else prev_out)\n\n    # Verify that the DUT output matches the expected output\n    assert out_temp == expected_output, f\"Test {i+1}: Output does not match the expected result: {out_temp} != {expected_output}\"\n\n    print(f\"Test {i+1} passed\")\n    prev_out = out_temp\n\n  # Wait for a few cycles before performing a final reset\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply a final reset to the DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles after reset to stabilize\n  for k in range(2):\n    await RisingEdge(dut.clk)"}}}
{"id": "cvdp_copilot_cdc_pulse_synchronizer_0022", "categories": ["cid014", "easy"], "input": {"prompt": "We have a `cdc_pulse_synchronizer` module designed to synchronize a single\u2010cycle pulse (`src_pulse`) from a source clock domain (`src_clock`) to a destination clock domain (`des_clock`). The module includes a reset (`rst_in`) that asynchronously initializes internal flip\u2010flops. To ensure robust pulse synchronization, below two checks are required. Hence, Add two immediate SystemVerilog assertions inside the `cdc_pulse_synchronizer` module:\n\n1. **Reset\u2010based assertion**: If `rst_in` is high on a rising edge of `src_clock`, then `src_pulse` must be `0`. If it is `1`, display an error message indicating that `src_pulse` is incorrectly asserted during reset.  \n2. **Single\u2010cycle pulse assertion**: Verify that `src_pulse` never stays high across two consecutive rising edges of `src_clock`. If `src_pulse` is still high on the next clock cycle, display an error message indicating an invalid multi\u2010cycle pulse.  \n\n---\n\n### **Inputs**:\n- `src_clock (1-bit)`: Rising edge triggered source clock domain.  \n- `des_clock (1-bit)`: Rising edge triggered destination clock domain.  \n- `rst_in (1-bit)`: Asynchronous reset input (active high).  \n- `src_pulse (1-bit)`: A single\u2010cycle pulse in the source domain.  \n\n### **Output**:\n- `des_pulse (1-bit)`: The synchronized pulse output in the destination domain.  ", "context": {"rtl/cdc_pulse_synchronizer.sv": "module cdc_pulse_synchronizer (\n    input  logic src_clock,   // Source Clock Domain\n    input  logic des_clock,   // Destination Clock Domain\n    input  logic rst_in,      // Reset\n    input  logic src_pulse,   // Source Pulse\n    output logic des_pulse    // Destination Pulse\n);\n\n    logic pls_toggle;      \n    logic pls_toggle_synca;\n    logic pls_toggle_syncb;\n    logic pls_toggle_syncc;\n\n    //--------------------------------------------------\n    //   Toggle Flop Circuit\n    //---------------------------------------------------\n    always_ff @(posedge src_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle <= 1'b0;\n        end \n        else if (src_pulse) begin\n            pls_toggle <= ~pls_toggle;\n        end \n        else begin\n            pls_toggle <= pls_toggle;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Double Flop Bit Synchronizer\n    //---------------------------------------------------\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle_synca <= 1'b0;\n            pls_toggle_syncb <= 1'b0;\n        end \n        else begin\n            pls_toggle_synca <= pls_toggle;\n            pls_toggle_syncb <= pls_toggle_synca;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Delay Logic of Output signal\n    //---------------------------------------------------\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle_syncc <= 1'b0;\n        end \n        else begin\n            pls_toggle_syncc <= pls_toggle_syncb;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Assign Statement for posedge and negedge detection\n    //---------------------------------------------------\n    assign des_pulse = pls_toggle_syncc ^ pls_toggle_syncb;\n\nendmodule\n\n"}}, "output": {"response": "", "context": {"rtl/cdc_pulse_synchronizer.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cdc_pulse_synchronizer.sv\nTOPLEVEL        = cdc_pulse_synchronizer\nMODULE          = test_cdc_pulse_synchronizer\nPYTHONPATH      = /src\nHASH            = cf1d4dba198b79a5245c75daca44e3b73c75ad6c\n", "src/test_cdc_pulse_synchronizer.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n# Initialize DUT\nasync def init_dut(dut):\n    dut.rst_in.value = 1\n    dut.src_pulse.value = 0\n    await RisingEdge(dut.src_clock)\n    await RisingEdge(dut.src_clock)\n    await RisingEdge(dut.src_clock)\n    await RisingEdge(dut.src_clock)\n\n# Test Case Run: src_pulse toggles and observe des_pulse\nasync def run_test(dut):\n    await RisingEdge(dut.src_clock)\n    dut.rst_in.value = 0\n\n    # Toggle src_pulse once\n    for _ in range(1):\n        await RisingEdge(dut.src_clock)\n        dut.src_pulse.value = 1\n        await RisingEdge(dut.src_clock)\n        dut.src_pulse.value = 0\n\n    # Monitor des_pulse\n    des_pulse_received = False\n    des_clock_cycles = 0\n    while not des_pulse_received and des_clock_cycles < 5:\n        await RisingEdge(dut.des_clock)\n        des_clock_cycles += 1\n        dut._log.info(f\"des_pulse = {dut.des_pulse.value}\")\n        if dut.des_pulse.value == 1:\n            des_pulse_received = True\n\n    assert des_pulse_received, \"des_pulse was not received within 4 des_clock cycles\"\n\n# Test Case 1: src_clock and des_clock same speed, same phase\n@cocotb.test()\nasync def test_src_100MHz_des_100MHz_same_phase(dut):\n    cocotb.start_soon(Clock(dut.src_clock, 10, units='ns').start())  # src_clock, 100MHz\n    cocotb.start_soon(Clock(dut.des_clock, 10, units='ns').start())  # des_clock, 100MHz same phase\n    await init_dut(dut)\n    await run_test(dut)\n\n# Test Case 2: src_clock fast, des_clock slow\n@cocotb.test()\nasync def test_src_100MHz_des_50MHz(dut):\n    cocotb.start_soon(Clock(dut.src_clock, 10, units='ns').start())  # Fast src_clock, 100 MHz\n    cocotb.start_soon(Clock(dut.des_clock, 20, units='ns').start())  # Slow des_clock, 50 MHz\n    await init_dut(dut)\n    await run_test(dut)\n\n# Test Case 3: src_clock slow, des_clock fast\n@cocotb.test()\nasync def test_src_50MHz_des_100MHz(dut):\n    cocotb.start_soon(Clock(dut.src_clock, 20, units='ns').start())  # Slow src_clock, 50MHz\n    cocotb.start_soon(Clock(dut.des_clock, 10, units='ns').start())   # Fast des_clock, 100MHz\n    await init_dut(dut)\n    await run_test(dut)\n\n# Test Case 4: src_clock and des_clock same speed, different phase\n@cocotb.test()\nasync def test_src_100MHz_des_100MHz_and_different_phase(dut):\n    cocotb.start_soon(Clock(dut.src_clock, 10, units='ns').start())  # src_clock, 100MHz\n    await Timer(5, units='ns')  # Add manual phase shift\n    cocotb.start_soon(Clock(dut.des_clock, 10, units='ns').start())  # des_clock, 100MHz with phase shift\n    await init_dut(dut)\n    await run_test(dut)\n\n# Test Case 5: src_clock slow, des_clock fast\n@cocotb.test()\nasync def test_RTL_Bug_src_100MHz_des_250MHz(dut):\n    cocotb.start_soon(Clock(dut.src_clock, 10, units='ns').start())  # Slow src_clock, 100MHz\n    cocotb.start_soon(Clock(dut.des_clock, 4, units='ns').start())   # Fast des_clock, 250MHz\n    await init_dut(dut)\n    await run_test(dut)\n\n\n# Test Case 6: Reset Test\n@cocotb.test()\nasync def test_reset(dut):\n    src_period = 10  # Fixed period for src_clock\n    des_period = 10  # Fixed period for des_clock\n\n    cocotb.start_soon(Clock(dut.src_clock, src_period, units='ns').start())\n    cocotb.start_soon(Clock(dut.des_clock, des_period, units='ns').start())\n\n    # Initialize DUT with reset\n    await init_dut(dut)\n\n    # De-assert reset and toggle src_pulse\n    dut.rst_in.value = 0\n    await RisingEdge(dut.src_clock)\n    dut.src_pulse.value = 1\n    await RisingEdge(dut.src_clock)\n    dut.src_pulse.value = 0\n\n    # Assert & De-assert reset\n    await RisingEdge(dut.src_clock)\n    await RisingEdge(dut.src_clock)\n    dut.rst_in.value = 1\n    await RisingEdge(dut.src_clock)\n    dut.rst_in.value = 0\n    await RisingEdge(dut.src_clock)\n\n\n    # Ensure des_pulse is not asserted after reset\n    des_pulse_received = False\n    des_clock_cycles = 0\n    while not des_pulse_received and des_clock_cycles < 5:\n        await RisingEdge(dut.des_clock)\n        des_clock_cycles += 1\n        dut._log.info(f\"des_pulse = {dut.des_pulse.value}\")\n        if dut.des_pulse.value == 0:\n            des_pulse_received = True\n\n    assert des_pulse_received, \"des_pulse should not be asserted after reset\"\n\n\n# Test Case 7: distance frequencies\n@cocotb.test()\nasync def test_src_1MHz_des_100MHz(dut):\n    cocotb.start_soon(Clock(dut.src_clock, 1000, units='ns').start())  # Slow src_clock, 1MHz\n    cocotb.start_soon(Clock(dut.des_clock, 10, units='ns').start())   # Fast des_clock, 100MHz\n    await init_dut(dut)\n    await run_test(dut)\n\n# Test Case 8: Inverse frequencies\n@cocotb.test()\nasync def test_src_100MHz_des_1MHz(dut):\n    cocotb.start_soon(Clock(dut.src_clock, 10, units='ns').start())  # Slow src_clock, 100MHz\n    cocotb.start_soon(Clock(dut.des_clock, 1000, units='ns').start())   # Fast des_clock, 1MHz\n    await init_dut(dut)\n    await run_test(dut)\n\n\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_cellular_automata_0014", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add an immediate assertion in the RTL design of the Cellular Automata (`pseudoRandGenerator_ca`) module to check whether the `CA_seed` is initialized to all zeros (16'd0)? Add a suitable SystemVerilog assertion statement in the RTL code that displays an error message when the Cellular Automata is loaded with an all-zero seed. The assertion should check that `CA_seed` is not equal to zero during reset, as initializing the Cellular Automata with an all-zero seed will cause the `CA_out` to remain at zero indefinitely, which is invalid for generating pseudorandom outputs.\n\nThe assertion should be added to ensure the `CA_seed` is a non-zero value before the module begins operating. If the `CA_seed` is zero, the assertion should trigger an error message and display an error message during the simulation.\n\n## Interface:\n### **Inputs**:\n- `clock (1-bit)`: The positive edged clock signal driving the module.\n- `reset (1-bit)`: The active-high synchronous reset signal, which resets the Cellular Automata to the `CA_seed`.\n- `CA_seed (16-bit,[15:0])`: A 16-bit input seed used for initialization and subsequent operations of the Cellular Automata.\n### **Outputs**:\n- `CA_out (16-bit,[15:0])`: The 16-bit output representing the current state of the Cellular Automata.\n", "context": {"rtl/pseudoRandGenerator_ca.sv": "module pseudoRandGenerator_ca (\n    input  logic       clock,    // Clock input\n    input  logic       reset,    // Active-high synchronous Reset\n    input  logic [15:0] CA_seed,  // 16-bit Cellular Automata seed\n    output logic [15:0] CA_out    // 16-bit Cellular Automata output\n);\n\n    logic q1, q2, q3, q4, q5, q6, q7, q8;\n    logic q9, q10, q11, q12, q13, q14, q15, q16;\n\n    assign q1  = CA_out[14];                             \n    assign q2  = CA_out[15] ^ CA_out[13];                \n    assign q3  = CA_out[14] ^ CA_out[13] ^ CA_out[12];   \n    assign q4  = CA_out[13] ^ CA_out[11];                \n    assign q5  = CA_out[12] ^ CA_out[11] ^ CA_out[10];   \n    assign q6  = CA_out[11] ^ CA_out[9];                 \n    assign q7  = CA_out[10] ^ CA_out[9] ^ CA_out[8];     \n    assign q8  = CA_out[9] ^ CA_out[7];                  \n    assign q9  = CA_out[8] ^ CA_out[7] ^ CA_out[6];      \n    assign q10 = CA_out[7] ^ CA_out[5];                  \n    assign q11 = CA_out[6] ^ CA_out[5] ^ CA_out[4];      \n    assign q12 = CA_out[5] ^ CA_out[3];                  \n    assign q13 = CA_out[4] ^ CA_out[3] ^ CA_out[2];      \n    assign q14 = CA_out[3] ^ CA_out[1];                  \n    assign q15 = CA_out[2] ^ CA_out[1] ^ CA_out[0];      \n    assign q16 = CA_out[1];                              \n\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            CA_out <= CA_seed;\n        end else begin\n            CA_out[15] <= q1;\n            CA_out[14] <= q2;\n            CA_out[13] <= q3;\n            CA_out[12] <= q4;\n            CA_out[11] <= q5;\n            CA_out[10] <= q6;\n            CA_out[9]  <= q7;\n            CA_out[8]  <= q8;\n            CA_out[7]  <= q9;\n            CA_out[6]  <= q10;\n            CA_out[5]  <= q11;\n            CA_out[4]  <= q12;\n            CA_out[3]  <= q13;\n            CA_out[2]  <= q14;\n            CA_out[1]  <= q15;\n            CA_out[0]  <= q16;\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/pseudoRandGenerator_ca.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/pseudoRandGenerator_ca.sv\nTOPLEVEL        = pseudoRandGenerator_ca\nMODULE          = test_pseudoRandGenerator_ca\nPYTHONPATH      = /src\nHASH            = 14-cellular_automata_tb_assertion_generation\n", "src/test_pseudoRandGenerator_ca.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport random\n\nasync def is_maximal_length_sequence(dut, cycles):\n    \"\"\"\n    Check whether the sequence generated by the DUT is a maximal-length sequence.\n    A maximal-length sequence for a 16-bit CA visits all 2^16 - 1 = 65535 unique states before repeating.\n    \"\"\"\n    visited_states = set()\n\n    for i in range(cycles):\n        await RisingEdge(dut.clock)\n        current_value = int(dut.CA_out.value)\n\n        # Track visited states\n        visited_states.add(current_value)\n\n    # A maximal-length sequence for a 16-bit CA should have 65535 unique states\n    expected_length = 2**16 - 1\n    if len(visited_states) == expected_length:\n        dut._log.info(f\"Maximal-length sequence achieved with {len(visited_states)} unique states.\")\n        return True\n    else:\n        dut._log.warning(f\"Sequence is not maximal-length. Only {len(visited_states)} unique states visited.\")\n        return False\n\n\n@cocotb.test()\nasync def display_CA_out_and_check_sequence(dut):\n    \"\"\"\n    Display the value of CA_out at each clock cycle, count repeated values, \n    and check whether the sequence is maximal-length.\n    \"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clock, 10, units=\"ns\").start())\n\n    # Initialize the DUT\n    seed = 0b0001000100100011  # Non-zero seed\n    dut.reset.value = 1\n    dut.CA_seed.value = seed\n    await RisingEdge(dut.clock)  # Apply reset\n    dut.reset.value = 0\n    await RisingEdge(dut.clock)  # Allow one clock cycle after deasserting reset\n    dut._log.info(f\"Initialized with seed: {seed:#06x}\")\n\n    # Dictionary to track the count of each value\n    value_count = {}\n\n    # Number of cycles to run\n    cycles = 65536  # Set to 2^16 for maximal-length sequence check\n\n    for i in range(cycles):\n        await RisingEdge(dut.clock)\n        current_value = int(dut.CA_out.value)\n\n        # Update the count for the current value\n        if current_value in value_count:\n            value_count[current_value] += 1\n        else:\n            value_count[current_value] = 1\n\n        # Display the value and the current count for it\n        dut._log.info(f\"Cycle {i+1}: CA_out = {current_value:#06x}, Count = {value_count[current_value]}\")\n\n    # Log the values that were repeated\n    repeated_values = {val: count for val, count in value_count.items() if count > 1}\n    if repeated_values:\n        dut._log.warning(\"Repeated values detected:\")\n        for val, count in repeated_values.items():\n            dut._log.warning(f\"Value {val:#06x} repeated {count} times.\")\n    else:\n        dut._log.info(\"No repeated values detected.\")\n\n    # Check if the sequence is maximal-length\n    maximal_length = await is_maximal_length_sequence(dut, cycles)\n    if maximal_length:\n        dut._log.info(\"The sequence generated by the DUT is maximal-length.\")\n    else:\n        dut._log.warning(\"The sequence generated by the DUT is not maximal-length.\")\n\n\n@cocotb.test()\nasync def test_fixed_seed(dut):\n    \"\"\"\n    Test the DUT with a fixed seed value.\n    \"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clock, 10, units=\"ns\").start())\n\n    # Use a fixed seed\n    seed = 0x1234  # Example fixed seed\n    dut.reset.value = 1\n    dut.CA_seed.value = seed\n    await RisingEdge(dut.clock)  # Apply reset\n    dut.reset.value = 0\n    await RisingEdge(dut.clock)  # Allow one clock cycle after deasserting reset\n    dut._log.info(f\"Initialized with fixed seed: {seed:#06x}\")\n\n    # Observe behavior for 20 cycles\n    for i in range(20):\n        await RisingEdge(dut.clock)\n        dut._log.info(f\"Cycle {i + 1}: CA_out = {int(dut.CA_out.value):#06x}\")\n\n\n@cocotb.test()\nasync def test_incremental_seeds(dut):\n    \"\"\"\n    Test the DUT with incremental seed values.\n    \"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clock, 10, units=\"ns\").start())\n\n    # Test for seeds from 0x0001 to 0x0010\n    for seed in range(0x0001, 0x0011):\n        dut.reset.value = 1\n        dut.CA_seed.value = seed\n        await RisingEdge(dut.clock)  # Apply reset\n        dut.reset.value = 0\n        await RisingEdge(dut.clock)  # Allow one clock cycle after deasserting reset\n        dut._log.info(f\"Initialized with incremental seed: {seed:#06x}\")\n\n        # Observe behavior for 10 cycles\n        for i in range(10):\n            await RisingEdge(dut.clock)\n            dut._log.info(f\"Cycle {i + 1}: CA_out = {int(dut.CA_out.value):#06x}\")\n\n\n@cocotb.test()\nasync def test_random_seeds(dut):\n    \"\"\"\n    Test the DUT with random seed values.\n    \"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clock, 10, units=\"ns\").start())\n\n    # Test for 5 random seeds\n    for _ in range(5):\n        seed = random.randint(1, 0xFFFF)  # Non-zero random seed\n        dut.reset.value = 1\n        dut.CA_seed.value = seed\n        await RisingEdge(dut.clock)  # Apply reset\n        dut.reset.value = 0\n        await RisingEdge(dut.clock)  # Allow one clock cycle after deasserting reset\n        dut._log.info(f\"Initialized with random seed: {seed:#06x}\")\n\n        # Observe behavior for 10 cycles\n        for i in range(10):\n            await RisingEdge(dut.clock)\n            dut._log.info(f\"Cycle {i + 1}: CA_out = {int(dut.CA_out.value):#06x}\")\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_coffee_machine_0003", "categories": ["cid014", "medium"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `coffee_machine` module. The assertions should ensure correct reset behavior, proper operation sequencing, and correct output conditions based on the input signals.\n\n## **RTL Design Overview**  \nThe `coffee_machine` module implements a **state-based coffee brewing system** that processes input commands and sensor data to control the coffee-making process. It takes parameters for operation delays and bean selection and generates output signals to control different steps of coffee preparation.\n\n### **Key Components of the Module**\n- **`clk`**: Clock signal, synchronizing operations.\n- **`rst_async_n`**: Asynchronous active-low reset.\n- **`i_operation_sel`**: Defines the operation to be performed (grinding, heating, pouring, etc.).\n- **`i_start`**: Start signal initiating the coffee-making process.\n- **`i_sensor`**: Sensor data input for monitoring machine status.\n- **`i_grind_delay`**: Configures the delay of the GRIND operation.\n- **`i_heat_delay`**: Configures the delay of the HEAT operation.\n- **`i_pour_delay`**: Configures the delay of the POUR operation.\n- **`i_bean_sel`**: Selects which bean to use.\n- **`o_bean_sel`**: Output representing the selected bean type for grinding.\n- **`o_grind_beans`**: Output signal controlling bean grinding.\n- **`o_use_powder`**: Output signal for using pre-ground powder instead of beans.\n- **`o_heat_water`**: Output controlling the water heating process.\n- **`o_pour_coffee`**: Output controlling the water pouring process.\n- **`o_error`**: Error output. Indicates an error either during the operation or prior to its start.\n- **`state_ff`**: Tracks the current state of the internal FSM.\n- **`state_nx`**: Tracks the next state of the internal FSM.\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:\n\n1. **Reset Behavior:**\n  - When `rst_async_n` is asserted (goes low), all output control signals (`o_bean_sel`, `o_grind_beans`, `o_use_powder`, `o_heat_water`, `o_pour_coffee`) and the internal FSM `state_ff` must be reset to `0` immediately.\n\n2. **State Number of Cycles Tracking:**\n  - When entering _BEAN_SEL_ state, the FSM must stay in it for `SEL_CYCLES` cycles. (SEL_CYCLES is an internal parameter, set to 3).\n  - When entering _POWDER_ state, the FSM must stay in it for `POWDER_CYCLES` cycles. (POWDER_CYCLES is an internal parameter, set to 2).\n\n3. **State Changes**\n  - The FSM state transition must follow these rules:\n     1. From _IDLE_, it can go to _HEAT_, _BEAN_SEL_, _POWDER_, _POUR_ or _IDLE_.\n     2. From _BEAN_SEL_, it can go to _BEAN_SEL_, _GRIND_ or _IDLE_.\n     3. From _GRIND_, it can go to _GRIND_, _HEAT_, _POWDER_ or _IDLE_.\n     4. From _POWDER_, it can go to _POWDER_, _POUR_ or _IDLE_.\n     5. From _HEAT_, it can go to _HEAT_, _POWDER_, _POUR_ or _IDLE_.\n     6. From _POUR_, it can go to _POUR_ or _IDLE_.\n  - All states can be active for more than 1 clock cycles.\n\n4. **Error behavior**\n  - When `i_sensor[3]` is asserted, `o_error` must always be asserted.\n  - When the FSM state is not _IDLE_ and `i_sensor[3] == 0`, `o_error` can never be 1.\n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating incorrect operation sequencing or violations of expected conditions.  ", "context": {"rtl/coffee_machine.sv": "module coffee_machine #(\n    parameter NBW_DLY    = 'd5,\n    parameter NBW_BEANS  = 'd2,\n    parameter NS_BEANS   = 'd4,\n    parameter NS_OP      = 'd3, // Fixed\n    parameter NS_SENSOR  = 'd4  // Fixed\n) (\n    input  logic                 clk,\n    input  logic                 rst_async_n,\n    input  logic [NBW_DLY-1:0]   i_grind_delay,\n    input  logic [NBW_DLY-1:0]   i_heat_delay,\n    input  logic [NBW_DLY-1:0]   i_pour_delay,\n    input  logic [NBW_BEANS-1:0] i_bean_sel,\n    input  logic [NS_OP-1:0]     i_operation_sel,\n    input  logic                 i_start,\n    input  logic [NS_SENSOR-1:0] i_sensor,\n    output logic [NS_BEANS-1:0]  o_bean_sel,\n    output logic                 o_grind_beans,\n    output logic                 o_use_powder,\n    output logic                 o_heat_water,\n    output logic                 o_pour_coffee,\n    output logic                 o_error\n);\n\n// Fixed delays (bean selection and powder usage)\nlocalparam SEL_CYCLES    = 'd3;\nlocalparam POWDER_CYCLES = 'd2;\n\ntypedef enum logic [2:0] {\n    IDLE     = 3'b000,\n    BEAN_SEL = 3'b001,\n    GRIND    = 3'b011,\n    POWDER   = 3'b111,\n    HEAT     = 3'b110,\n    POUR     = 3'b100\n} state_t;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nstate_t state_ff, state_nx;\nlogic [NS_BEANS-1:0]  bean_sel_out_ff, bean_sel_out_nx;\nlogic [NBW_DLY:0]     counter_ff, counter_nx;\nlogic [NBW_DLY-1:0]   grind_delay_ff, heat_delay_ff, pour_delay_ff;\nlogic [NS_OP-1:0]     operation_sel_ff;\nlogic [NBW_BEANS-1:0] bean_sel_in_ff;\nlogic                 start_ff;\n\n// Output assignment (error conditions)\nalways_comb begin : error_logic\n    if(state_ff == IDLE) begin\n        o_error = (i_sensor[0] | i_sensor[3]) | (&i_operation_sel[2:1]) | (i_operation_sel[1] & i_sensor[1]) | ((i_operation_sel == 3'b100 || i_operation_sel == 3'b001) & i_sensor[2]);\n    end else begin\n        o_error = i_sensor[3];\n    end\nend\n\n// ----------------------------------------\n// - Registers\n// ----------------------------------------\nalways_ff @(posedge clk) begin : data_regs\n    start_ff <= i_start & ~(i_sensor[0] | i_sensor[3]) & ~(&i_operation_sel[2:1]) & ~(i_operation_sel[1] & i_sensor[1]) & ~((i_operation_sel == 3'b100 || i_operation_sel == 3'b001) & i_sensor[2]);\n\n    if(i_start && state_ff == IDLE) begin\n        operation_sel_ff <= i_operation_sel;\n        grind_delay_ff   <= i_grind_delay;\n        heat_delay_ff    <= i_heat_delay;\n        pour_delay_ff    <= i_pour_delay;\n        bean_sel_in_ff   <= i_bean_sel;\n    end\n\n    counter_ff      <= counter_nx;\n    bean_sel_out_ff <= bean_sel_out_nx;\nend\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : reset_regs\n    if(~rst_async_n) begin\n        state_ff <= IDLE;\n    end else begin\n        state_ff <= state_nx;\n    end\nend\n\n// ----------------------------------------\n// - FSM update\n// ----------------------------------------\nalways_comb begin\n    case(state_ff)\n        IDLE: begin\n            counter_nx = 0;\n\n            if(start_ff) begin\n                if(~(|i_operation_sel[2:1])) begin\n                    state_nx = HEAT;\n                end else if(i_operation_sel[1]) begin\n                    state_nx = BEAN_SEL;\n                end else if(i_operation_sel[0]) begin\n                    state_nx = POUR;\n                end else begin\n                    state_nx = POWDER;\n                end\n            end else begin\n                state_nx = IDLE;\n            end\n        end\n        BEAN_SEL: begin\n            if(i_sensor[3]) begin\n                counter_nx = 0;\n                state_nx   = IDLE;\n            end else begin\n                if(counter_ff >= SEL_CYCLES-1) begin\n                    counter_nx = 0;\n                    state_nx   = GRIND;\n                end else begin\n                    counter_nx = counter_ff + 1'b1;\n                    state_nx   = BEAN_SEL;\n                end\n            end\n        end\n        GRIND: begin\n            if(i_sensor[3]) begin\n                counter_nx = 0;\n                state_nx   = IDLE;\n            end else begin\n                if(counter_ff >= grind_delay_ff-1) begin\n                    counter_nx = 0;\n                    if(operation_sel_ff[0]) begin\n                        state_nx = POWDER;\n                    end else begin\n                        state_nx = HEAT;\n                    end\n                end else begin\n                    counter_nx = counter_ff + 1'b1;\n                    state_nx   = GRIND;\n                end\n            end\n        end\n        POWDER: begin\n            if(i_sensor[3]) begin\n                counter_nx = 0;\n                state_nx   = IDLE;\n            end else begin\n                if(counter_ff >= POWDER_CYCLES-1) begin\n                    counter_nx = 0;\n                    state_nx   = POUR;\n                end else begin\n                    counter_nx = counter_ff + 1'b1;\n                    state_nx   = POWDER;\n                end\n            end\n        end\n        HEAT: begin\n            if(i_sensor[3]) begin\n                counter_nx = 0;\n                state_nx   = IDLE;\n            end else begin\n                if(counter_ff >= heat_delay_ff-1) begin\n                    counter_nx = 0;\n                    if(|operation_sel_ff[1:0]) begin\n                        state_nx = POWDER;\n                    end else begin\n                        state_nx = POUR;\n                    end\n                end else begin\n                    counter_nx = counter_ff + 1'b1;\n                    state_nx   = HEAT;\n                end\n            end\n        end\n        POUR: begin\n            if(i_sensor[3]) begin\n                counter_nx = 0;\n                state_nx   = IDLE;\n            end else begin\n                if(counter_ff >= pour_delay_ff-1) begin\n                    counter_nx = 0;\n                    state_nx   = IDLE;\n                end else begin\n                    counter_nx = counter_ff + 1'b1;\n                    state_nx   = POUR;\n                end\n            end\n        end\n        default: begin\n            counter_nx = 0;\n            state_nx   = IDLE;\n        end\n    endcase\nend\n\n// ----------------------------------------\n// - Controller outputs\n// ----------------------------------------\nalways_comb begin\n    case(state_ff)\n        IDLE: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_use_powder    = 1'b0;\n            o_grind_beans   = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n            bean_sel_out_nx = {NS_BEANS{1'b0}};\n        end\n        BEAN_SEL: begin\n            o_bean_sel                      = 1'b0; // Set all bits to 0\n            o_bean_sel[bean_sel_in_ff]      = 1'b1; // Only the position of bean_sel_ff should be 1\n            o_grind_beans                   = 1'b0;\n            o_use_powder                    = 1'b0;\n            o_heat_water                    = 1'b0;\n            o_pour_coffee                   = 1'b0;\n            bean_sel_out_nx                 = 1'b0;\n            bean_sel_out_nx[bean_sel_in_ff] = 1'b1;\n        end\n        GRIND: begin\n            o_bean_sel      = bean_sel_out_ff;\n            o_grind_beans   = 1'b1;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n            bean_sel_out_nx = bean_sel_out_ff;\n        end\n        POWDER: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b1;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n            bean_sel_out_nx = {NS_BEANS{1'b0}};\n        end\n        HEAT: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b1;\n            o_pour_coffee   = 1'b0;\n            bean_sel_out_nx = {NS_BEANS{1'b0}};\n        end\n        POUR: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b1;\n            bean_sel_out_nx = {NS_BEANS{1'b0}};\n        end\n        default: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n            bean_sel_out_nx = {NS_BEANS{1'b0}};\n        end\n    endcase\nend\n \nendmodule : coffee_machine"}}, "output": {"response": "", "context": {"rtl/coffee_machine.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nSIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/coffee_machine.sv\nTOPLEVEL        = coffee_machine\nMODULE          = test_coffee_machine\nPYTHONPATH      = /src\nHASH            = 3-coffee-marchine-assertions\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport os\nimport subprocess\nimport re\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nclass CoffeeMachine:\n    def __init__(self, operation=0, i_grind_delay=1, i_heat_delay=1, i_pour_delay=1, i_bean_sel=0, num_beans=4):\n        self.state = \"IDLE\"\n        self.o_bean_sel = 0\n        self.o_grind_beans = 0\n        self.o_use_powder = 0\n        self.o_heat_water = 0\n        self.o_pour_coffee = 0\n        self.o_error = 0\n        self.i_sensor = 0\n        self.operation = operation\n        self.step = 0  # Track progress in operation sequence\n        self.i_grind_delay = i_grind_delay\n        self.i_heat_delay = i_heat_delay\n        self.i_pour_delay = i_pour_delay\n        self.state_counter = 0  # Counter for state delays\n        self.POWDER_DELAY = 2  # Fixed delay for POWDER state\n        self.BEAN_SEL_DELAY = 3  # Fixed delay for BEAN_SEL state\n        self.i_bean_sel = i_bean_sel\n        self.num_beans = num_beans\n    \n    def reset(self):\n        self.state = \"IDLE\"\n        self.reset_outputs()\n        \n    \n    def update_error(self):\n        if self.i_sensor & 0b1000:  # Generic error\n            self.o_error = 1\n        elif self.state == \"IDLE\":\n            if self.i_sensor & 0b0001:  # No water error\n                self.o_error = 1\n            elif (self.i_sensor & 0b0010) and (self.operation == 0b010 or self.operation == 0b011):  # No beans error\n                self.o_error = 1\n            elif (self.i_sensor & 0b0100) and (self.operation == 0b100 or self.operation == 0b001):  # No powder error\n                self.o_error = 1\n            elif self.operation == 0b110 or self.operation == 0b111:\n                self.o_error = 1\n            else:\n                self.o_error = 0\n        else:\n            self.o_error = 0\n    \n    def update_state(self, operation, i_sensor, i_grind_delay, i_heat_delay, i_pour_delay, i_bean_sel):\n        self.i_sensor = i_sensor\n        if self.state == \"IDLE\":\n            self.operation = operation\n            self.i_grind_delay = i_grind_delay\n            self.i_heat_delay = i_heat_delay\n            self.i_pour_delay = i_pour_delay\n            self.i_bean_sel = i_bean_sel\n            self.step = 0  # Reset step counter\n            self.state_counter = 0\n        self.update_error()\n\n        steps = {\n            0b000: [self.heat, self.pour, self.idle],\n            0b001: [self.heat, self.powder, self.pour, self.idle],\n            0b010: [self.bean_sel, self.grind, self.heat, self.powder, self.pour, self.idle],\n            0b011: [self.bean_sel, self.grind, self.powder, self.pour, self.idle],\n            0b100: [self.powder, self.pour, self.idle],\n            0b101: [self.pour, self.idle],\n        }\n        \n        if self.o_error:\n            current_state = steps[self.operation][self.step]\n            current_state()\n            self.state = \"IDLE\"\n            return\n\n        \n        if self.operation in steps and self.step < len(steps[self.operation]):\n            current_state = steps[self.operation][self.step]\n            \n            if self.state == \"BEAN_SEL\" and self.state_counter < self.BEAN_SEL_DELAY-1:\n                self.state_counter += 1\n            elif self.state == \"GRIND\" and self.state_counter < self.i_grind_delay-1:\n                self.state_counter += 1\n            elif self.state == \"HEAT\" and self.state_counter < self.i_heat_delay-1:\n                self.state_counter += 1\n            elif self.state == \"POWDER\" and self.state_counter < self.POWDER_DELAY-1:\n                self.state_counter += 1\n            elif self.state == \"POUR\" and self.state_counter < self.i_pour_delay-1:\n                self.state_counter += 1\n            else:\n                self.state_counter = 0\n                current_state()\n                self.step += 1  # Move to next step in the sequence\n        \n        return 0\n    \n    def idle(self):\n        self.state = \"IDLE\"\n        self.reset_outputs()\n    \n    def bean_sel(self):\n        self.reset_outputs()\n        self.state = \"BEAN_SEL\"\n        self.o_bean_sel = 1 << self.i_bean_sel  # One-hot encoding\n    \n    def grind(self):\n        self.reset_outputs()\n        self.state = \"GRIND\"\n        self.o_grind_beans = 1\n        self.o_bean_sel = 1 << self.i_bean_sel  # Maintain bean selection in one-hot encoding\n    \n    def powder(self):\n        self.reset_outputs()\n        self.state = \"POWDER\"\n        self.o_use_powder = 1\n    \n    def heat(self):\n        self.reset_outputs()\n        self.state = \"HEAT\"\n        self.o_heat_water = 1\n    \n    def pour(self):\n        self.reset_outputs()\n        self.state = \"POUR\"\n        self.o_pour_coffee = 1\n    \n    def reset_outputs(self):\n        self.o_bean_sel = 0\n        self.o_grind_beans = 0\n        self.o_use_powder = 0\n        self.o_heat_water = 0\n        self.o_pour_coffee = 0\n    \n    def get_status(self):\n        return {\n            \"state\": self.state,\n            \"o_bean_sel\": self.o_bean_sel,\n            \"o_grind_beans\": self.o_grind_beans,\n            \"o_use_powder\": self.o_use_powder,\n            \"o_heat_water\": self.o_heat_water,\n            \"o_pour_coffee\": self.o_pour_coffee,\n            \"o_error\": self.o_error,\n            \"step\": self.step,\n            \"state_counter\": self.state_counter,\n        }\n\n    \n#################    ASSERTIONS STUFF        ###############\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n", "src/test_coffee_machine.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb\nimport random\n\ndef compare_values(dut, model, debug=0):\n    dut_bean_sel = dut.o_bean_sel.value\n    dut_grind_beans = dut.o_grind_beans.value\n    dut_use_powder = dut.o_use_powder.value\n    dut_heat_water = dut.o_heat_water.value\n    dut_pour_coffee = dut.o_pour_coffee.value\n    dut_error = dut.o_error.value\n\n    model_output = model.get_status()\n    model_bean_sel    = int(model_output[\"o_bean_sel\"])\n    model_grind_beans = int(model_output[\"o_grind_beans\"])\n    model_use_powder  = int(model_output[\"o_use_powder\"])\n    model_heat_water  = int(model_output[\"o_heat_water\"])\n    model_pour_coffee = int(model_output[\"o_pour_coffee\"])\n    model_error       = int(model_output[\"o_error\"])\n\n    if debug == 1:\n        print(\"\\nINPUTS\")\n        print(f\"DUT i_grind_delay   = {dut.i_grind_delay.value} MODEL i_grind_delay   = {model.i_grind_delay}\")\n        print(f\"DUT i_heat_delay    = {dut.i_heat_delay.value} MODEL i_heat_delay    = {model.i_heat_delay}\")\n        print(f\"DUT i_pour_delay    = {dut.i_pour_delay.value} MODEL i_pour_delay    = {model.i_pour_delay}\")\n        print(f\"DUT i_bean_sel      = {dut.i_bean_sel.value} MODEL i_bean_sel      = {model.i_bean_sel}\")\n        print(f\"DUT i_operation_sel = {dut.i_operation_sel.value} MODEL i_operation_sel = {model.operation}\")\n        print(\"\\nOUTPUTS\")\n        print(f\"DUT o_bean_sel    = {dut_bean_sel} MODEL o_bean_sel    = {model_bean_sel}\")\n        print(f\"DUT o_grind_beans = {dut_grind_beans} MODEL o_grind_beans = {model_grind_beans}\")\n        print(f\"DUT o_use_powder  = {dut_use_powder} MODEL o_use_powder  = {model_use_powder}\")\n        print(f\"DUT o_heat_water  = {dut_heat_water} MODEL o_heat_water  = {model_heat_water}\")\n        print(f\"DUT o_pour_coffee = {dut_pour_coffee} MODEL o_pour_coffee = {model_pour_coffee}\")\n        print(f\"DUT o_error = {dut_error} MODEL o_error = {model_error}\")\n        print(f\"DUT state = {dut.state_ff.value} MODEL state = {model.state}\")\n\n    assert dut_bean_sel    == model_bean_sel,    f\"[ERROR] DUT o_bean_sel does not match model o_bean_sel: {dut_bean_sel} != {model_bean_sel}\"\n    assert dut_grind_beans == model_grind_beans, f\"[ERROR] DUT o_grind_beans does not match model o_grind_beans: {dut_grind_beans} != {model_grind_beans}\"\n    assert dut_use_powder  == model_use_powder,  f\"[ERROR] DUT o_use_powder does not match model o_use_powder: {dut_use_powder} != {model_use_powder}\"\n    assert dut_heat_water  == model_heat_water,  f\"[ERROR] DUT o_heat_water does not match model o_heat_water: {dut_heat_water} != {model_heat_water}\"\n    assert dut_pour_coffee == model_pour_coffee, f\"[ERROR] DUT o_pour_coffee does not match model o_pour_coffee: {dut_pour_coffee} != {model_pour_coffee}\"\n    assert dut_error       == model_error,       f\"[ERROR] DUT o_error does not match model o_error: {dut_error} != {model_error}\"\n\n\n\n@cocotb.test()\nasync def test_coffee_machine(dut):\n    \"\"\"Test the Coffee Machine module with edge cases and random data.\"\"\"\n\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    model = hrs_lb.CoffeeMachine()\n\n    # Retrieve parameters from the DUT\n    NBW_DLY   = dut.NBW_DLY.value\n    NBW_BEANS = dut.NBW_BEANS.value\n    NS_BEANS  = dut.NS_BEANS.value\n    \n    model.num_beans = NS_BEANS\n\n    # Range for input values\n    delay_min = 2\n    delay_max = int(2**NBW_DLY - 1)\n\n    beans_min = 1\n    beans_max = int(2**NBW_BEANS - 1)\n\n    resets = 5\n    runs = 5\n\n    await hrs_lb.dut_init(dut)\n\n    for k in range(resets):\n        # Reset the DUT\n        \n        # Set all inputs to zero\n        dut.i_grind_delay.value   = 0\n        dut.i_heat_delay.value    = 0\n        dut.i_pour_delay.value    = 0\n        dut.i_bean_sel.value      = 0\n        dut.i_operation_sel.value = 0\n        dut.i_start.value         = 0\n        dut.i_sensor.value        = 0\n        dut.rst_async_n.value     = 0\n        await RisingEdge(dut.clk)\n\n        model.reset()\n        model.i_sensor = 0\n        model.update_error()\n        \n        dut.rst_async_n.value = 1\n        await RisingEdge(dut.clk)\n        # Compare reset values\n        compare_values(dut, model)\n\n        await RisingEdge(dut.clk)\n        \n        ## Test errors\n\n        # Generic error\n        dut.i_sensor.value = 8\n        model.i_sensor = 8\n        model.update_error()\n\n        await RisingEdge(dut.clk)\n        compare_values(dut, model)\n\n        # No water error\n        dut.i_sensor.value = 1\n        operation = random.randint(0,5)\n        dut.i_operation_sel.value = operation\n        model.i_sensor = 1\n        model.operation = operation\n        model.update_error()\n\n        await RisingEdge(dut.clk)\n        compare_values(dut, model)\n\n        # No beans error\n        dut.i_sensor.value = 2\n        operation = random.randint(2,3)\n        dut.i_operation_sel.value = operation\n        model.i_sensor = 2\n        model.operation = operation\n        model.update_error()\n\n        await RisingEdge(dut.clk)\n        compare_values(dut, model)\n\n        # No powder error (op = 1)\n        dut.i_sensor.value = 4\n        dut.i_operation_sel.value = 1\n        model.i_sensor = 4\n        model.operation = 1\n        model.update_error()\n\n        await RisingEdge(dut.clk)\n        compare_values(dut, model)\n\n        # No powder error (op = 4)\n        dut.i_sensor.value = 4\n        dut.i_operation_sel.value = 4\n        model.i_sensor = 4\n        model.operation = 4\n        model.update_error()\n\n        await RisingEdge(dut.clk)\n        compare_values(dut, model)\n\n        # Wrong operation error\n        dut.i_sensor.value = 0\n        operation = random.randint(6,7)\n        dut.i_operation_sel.value = operation\n        model.i_sensor = 0\n        model.operation = operation\n        model.update_error()\n\n        await RisingEdge(dut.clk)\n        compare_values(dut, model)\n\n        for i in range(runs):\n            # Generate random delay\n            grind_delay = random.randint(delay_min, delay_max)\n            heat_delay  = random.randint(delay_min, delay_max)\n            pour_delay  = random.randint(delay_min, delay_max)\n            bean_sel    = random.randint(beans_min, beans_max)\n            operation   = random.randint(0,5)\n\n            dut.i_sensor.value        = 0\n            dut.i_grind_delay.value   = grind_delay\n            dut.i_heat_delay.value    = heat_delay\n            dut.i_pour_delay.value    = pour_delay\n            dut.i_bean_sel.value      = bean_sel\n            dut.i_operation_sel.value = operation\n            dut.i_start.value         = 1\n\n            model.i_sensor  = 0\n            model.operation = operation\n            model.update_error()\n\n            await RisingEdge(dut.clk)\n            dut.i_start.value         = 0\n            compare_values(dut, model)\n            await RisingEdge(dut.clk)\n            compare_values(dut, model)\n            while dut.o_pour_coffee.value == 0:\n                await RisingEdge(dut.clk)\n                model.update_state(operation=operation, i_sensor=0, i_grind_delay=grind_delay, i_heat_delay=heat_delay, i_pour_delay=pour_delay, i_bean_sel=bean_sel)\n                compare_values(dut, model)\n            \n            while dut.o_pour_coffee.value == 1:\n                await RisingEdge(dut.clk)\n                model.update_state(operation=operation, i_sensor=0, i_grind_delay=grind_delay, i_heat_delay=heat_delay, i_pour_delay=pour_delay, i_bean_sel=bean_sel)\n                compare_values(dut, model)\n\n        # Create a test to validate that i_sensor[3] stops the opeartion\n        # Generate random delay\n        grind_delay = random.randint(delay_min, delay_max)\n        heat_delay  = random.randint(delay_min, delay_max)\n        pour_delay  = random.randint(delay_min, delay_max)\n        bean_sel    = random.randint(beans_min, beans_max)\n        operation   = random.randint(0,5)\n\n        dut.i_sensor.value        = 0\n        dut.i_grind_delay.value   = grind_delay\n        dut.i_heat_delay.value    = heat_delay\n        dut.i_pour_delay.value    = pour_delay\n        dut.i_bean_sel.value      = bean_sel\n        dut.i_operation_sel.value = operation\n        dut.i_start.value         = 1\n\n        model.i_sensor  = 0\n        model.operation = operation\n        model.update_error()\n\n        await RisingEdge(dut.clk)\n        dut.i_start.value = 0\n        compare_values(dut, model)\n\n        await RisingEdge(dut.clk)\n        compare_values(dut, model)\n        # Set sensor value to 8 -> Generic error\n        dut.i_sensor.value = 8\n        model.update_state(operation=operation, i_sensor=8, i_grind_delay=grind_delay, i_heat_delay=heat_delay, i_pour_delay=pour_delay, i_bean_sel=bean_sel)\n\n        await RisingEdge(dut.clk)\n        # o_error should be 1 here\n        compare_values(dut, model)\n\n        await RisingEdge(dut.clk)\n        # DUT must be back in IDLE\n        model.idle()\n        compare_values(dut, model)\n        \n", "src/test_runner.py": "import os\n\nfrom cocotb.runner import get_runner\n\nimport harness_library as hrs_lb\nimport pytest\nimport random\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(NBW_DLY: int = 5, NBW_BEANS: int = 2, NS_BEANS: int = 4):\n    # Simulation parameters\n    parameter = {\n        \"NBW_DLY\": NBW_DLY,\n        \"NBW_BEANS\": NBW_BEANS,\n        \"NS_BEANS\": NS_BEANS\n    }\n\n    # Debug information\n    print(f\"\\n[DEBUG] Running simulation with NBW_DLY={NBW_DLY}\")\n    print(f\"[DEBUG] Running simulation with NBW_BEANS={NBW_BEANS}\")\n    print(f\"[DEBUG] Running simulation with NS_BEANS={NS_BEANS}\")\n    print(f\"[DEBUG] Parameters: {parameter}\")\n\n    print(\"Inside Runner\")\n    runner = get_runner(\"xcelium\")\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        build_args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\"),\n        parameters = parameter,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=False,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    print(\"Running\")    \n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n    hrs_lb.coverage_report(\"assertion\")\n    hrs_lb.covt_report_check()\n\n# Generate default and a random size\nrandom_nbw_dly   = [5] + [random.randint(3, 8) for _ in range(1)]\nrandom_nbw_beans = [2] + [random.randint(3, 8) for _ in range(1)]\n\n# Parametrize test for different random data sizes\n@pytest.mark.parametrize(\"NBW_DLY\", random_nbw_dly)\n@pytest.mark.parametrize(\"NBW_BEANS\", random_nbw_beans)\ndef test_data(NBW_DLY, NBW_BEANS):\n    random_ns_beans = 2**NBW_BEANS\n    # Run the simulation with specified parameters\n    runner(NBW_DLY=NBW_DLY, NBW_BEANS=NBW_BEANS, NS_BEANS=random_ns_beans)\n"}}}
{"id": "cvdp_copilot_cont_adder_0040", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the `continuous_adder` RTL to ensure signals remain valid during simulation? Specifically, the assertions should check:\n\n1. **That `sum_out` and `sum_accum` remain within 8-bit bounds**, and  \n2. **That `sum_ready` is always either 0 or 1**, reflecting a proper single-bit signal.\n\nWhenever one of these conditions is violated, the assertion should print an error message with the current simulation time and the offending signal values.\n\n---\n\n## **Key Assertions**\n\n### **1. 8-bit Range Checks**\n- **Condition**:  \n  - `sum_out` must stay below 256 (since it is an 8-bit output).  \n  - `sum_accum` must stay below 256 (since it is an 8-bit internal accumulator).\n- **Assertion**:  \n  - If `sum_out` or `sum_accum` exceed `255`, display an error message with the offending signal value.\n\n### **2. Valid `sum_ready` Signal**\n- **Condition**:  \n  - `sum_ready` should always be exactly 0 or 1. \n- **Assertion**:  \n  - Check that `(sum_ready === 1'b0) || (sum_ready === 1'b1)`. If not, display an error.\n\n---\n\n## **Interface**\n\n### **Inputs**\n1. `clk` : Clock signal (1-bit).  \n2. `reset` : Synchronous reset (active high, 1-bit).  \n3. `data_in [7:0]` : 8-bit input to be added into the accumulator.  \n4. `data_valid` : Indicates when `data_in` should be accumulated.\n\n### **Outputs**\n1. `sum_out [7:0]` : 8-bit total when crossing the threshold of 100.  \n2. `sum_ready` : Signals that `sum_out` is valid and `sum_accum` has reset.\n\n---\n\n\nIf the assertion fails, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/cont_adder.sv": "`timescale 1ns/1ps\n\nmodule continuous_adder (\n    input logic         clk,         // Clock signal\n    input logic         reset,       // Reset signal, Active high and Synchronous\n    input logic [7:0]   data_in,     // Input data stream (8-bit)\n    input logic         data_valid,  // Input data valid signal\n    output logic [7:0]  sum_out,     // Output the accumulated sum\n    output logic        sum_ready    // Signal to indicate sum is output and accumulator is reset\n);\n\n    logic [7:0] sum_accum;\n\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            sum_accum         <= 8'd0;\n            sum_ready         <= 1'b0;\n            sum_out           <= 8'h0;\n        end\n        else begin\n            if (data_valid) begin\n                sum_accum     <= sum_accum + data_in;\n\n                if (sum_accum + data_in >= 8'd100) begin\n                    sum_out   <= sum_accum + data_in;\n                    sum_ready <= 1'b1;\n                    sum_accum <= 8'd0;\n                end\n                else begin\n                    sum_ready <= 1'b0;\n                end\n            end\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/cont_adder.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cont_adder.sv\nTOPLEVEL        = continuous_adder\nMODULE          = test_cont_adder\nPYTHONPATH      = /src\nHASH            = 40-cont-adder-assertion\n", "src/test_cont_adder.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\nasync def reset_dut(dut, cycles=2):\n    dut.reset.value = 1\n    dut.data_in.value = 0\n    dut.data_valid.value = 0\n    for _ in range(cycles):\n        await RisingEdge(dut.clk)\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\nasync def apply_input(dut, data_val, valid_val=1, wait_cycles=1):\n    dut.data_in.value = data_val\n    dut.data_valid.value = valid_val\n    for _ in range(wait_cycles):\n        await RisingEdge(dut.clk)\n    dut.data_valid.value = 0\n    cocotb.log.info(\n        f\"[{cocotb.utils.get_sim_time('ns')} ns] data_in={data_val}, data_valid={valid_val}, \"\n        f\"sum_out={int(dut.sum_out.value)}, sum_ready={int(dut.sum_ready.value)}, sum_accum={int(dut.sum_accum.value)}\"\n    )\n\n@cocotb.test()\nasync def direct_test(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await reset_dut(dut)\n    cocotb.log.info(\"Starting DIRECT test\")\n    await apply_input(dut, 50)\n    await apply_input(dut, 10)\n    await apply_input(dut, 40)\n    await apply_input(dut, 5)\n    # Wait a bit to see final results\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n@cocotb.test()\nasync def boundary_test(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await reset_dut(dut)\n    cocotb.log.info(\"Starting BOUNDARY test\")\n    await apply_input(dut, 99)\n    await apply_input(dut, 1)\n    await apply_input(dut, 100)\n    await apply_input(dut, 0)\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n@cocotb.test()\nasync def random_test(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await reset_dut(dut)\n    cocotb.log.info(\"Starting RANDOM test\")\n    for i in range(10):\n        val = random.randint(0, 255)\n        # Toggle data_valid every iteration or randomly\n        valid = 1 if (i % 2 == 0) else 0\n        await apply_input(dut, val, valid)\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}}
{"id": "cvdp_copilot_crypto_0013", "categories": ["cid014", "easy"], "input": {"prompt": "Elaborate assertion properties to ensure that the `CTRL_IDLE` state of the `sha1_core` module's FSM is safe. The properties should verify the following conditions:\n\n1. The design **must** enter the `CTRL_IDLE` state immediately after an asynchronous reset.  \n2. The `CTRL_IDLE` state **must** indicate that the design is ready to process new data.  \n3. The design **must** return to the `CTRL_IDLE` state after completing a computation.  \n\nIt is necessary to address the requirements described below.\n\n- The properties should be placed in a separate module named `sha1_core_rounds_safety_check` that instantiates `sha1_core` as a DUT (Device Under Test).  \n- The properties should directly reference internal DUT signals to perform verification.  \n\n## **Design Specifications**  \n\n### **Module Name:** `sha1_core`  \n\n### **Inputs:**  \n- **clk**: System clock (rising edge).  \n- **reset_n**: Active-low asynchronous reset.  \n- **init**: Signal to start hashing with a new block.  \n- **next**: Signal to continue hashing with a new block after initialization.  \n- **block** (`[511:0]`): 512-bit input data block.  \n\n### **Outputs:**  \n- **ready**: Indicates when the core is ready to process a new block.  \n- **digest** (`[159:0]`): The 160-bit computed hash value.  \n- **digest_valid**: Indicates that the digest output is valid.  \n\n### **Functional Overview:**  \n- When **init** is asserted, the core initializes the hash state using SHA-1 constants and begins processing the input block.  \n- When **next** is asserted, the core continues processing with the new block.  \n- The FSM transitions through:  \n  - **CTRL_IDLE**: Waiting for `init` or `next`.  \n  - **CTRL_ROUNDS**: Processing 80 rounds of SHA-1.  \n  - **CTRL_DONE**: Finalizing the hash and updating the digest.  \n- When processing is complete, **digest_valid** is asserted, and **ready** becomes high.  \n- The core uses a **W memory scheduler** (`sha1_w_mem` module) to expand the input block into 80 words dynamically.  \n\nInternally, the FSM state transitions are controlled by the `sha1_ctrl_reg` register, which holds the current state, and `sha1_ctrl_new`, which represents the next state. The `sha1_ctrl_we` signal determines when the state register updates. These registers ensure that the core progresses through the expected SHA-1 processing stages and returns to `CTRL_IDLE` upon completion.  \n\nThere is a threshold (`SHA1_ROUNDS`) for the number of cycles in the `CTRL_ROUNDS` state, and an internal counter named `round_ctr_reg` is used to control the rounds, limited to the threshold.\n\n### **Note:**  \n- An **assertion failure** must include a **descriptive error message** to aid debugging", "context": {"rtl/sha1_core.v": "//======================================================================\n//\n// sha1_core.v\n// -----------\n// Verilog 2001 implementation of the SHA-1 hash function.\n// This is the internal core with wide interfaces.\n//\n//\n// Copyright (c) 2013 Secworks Sweden AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\n`default_nettype none\n\nmodule sha1_core(\n                 input wire            clk,\n                 input wire            reset_n,\n\n                 input wire            init,\n                 input wire            next,\n\n                 input wire [511 : 0]  block,\n\n                 output wire           ready,\n\n                 output wire [159 : 0] digest,\n                 output wire           digest_valid\n                );\n\n\n  //----------------------------------------------------------------\n  // Internal constant and parameter definitions.\n  //----------------------------------------------------------------\n  parameter H0_0 = 32'h67452301;\n  parameter H0_1 = 32'hefcdab89;\n  parameter H0_2 = 32'h98badcfe;\n  parameter H0_3 = 32'h10325476;\n  parameter H0_4 = 32'hc3d2e1f0;\n\n  parameter SHA1_ROUNDS = 79;\n\n  parameter CTRL_IDLE   = 0;\n  parameter CTRL_ROUNDS = 1;\n  parameter CTRL_DONE   = 2;\n\n\n  //----------------------------------------------------------------\n  // Registers including update variables and write enable.\n  //----------------------------------------------------------------\n  reg [31 : 0] a_reg;\n  reg [31 : 0] a_new;\n  reg [31 : 0] b_reg;\n  reg [31 : 0] b_new;\n  reg [31 : 0] c_reg;\n  reg [31 : 0] c_new;\n  reg [31 : 0] d_reg;\n  reg [31 : 0] d_new;\n  reg [31 : 0] e_reg;\n  reg [31 : 0] e_new;\n  reg          a_e_we;\n\n  reg [31 : 0] H0_reg;\n  reg [31 : 0] H0_new;\n  reg [31 : 0] H1_reg;\n  reg [31 : 0] H1_new;\n  reg [31 : 0] H2_reg;\n  reg [31 : 0] H2_new;\n  reg [31 : 0] H3_reg;\n  reg [31 : 0] H3_new;\n  reg [31 : 0] H4_reg;\n  reg [31 : 0] H4_new;\n  reg          H_we;\n\n  reg [6 : 0] round_ctr_reg;\n  reg [6 : 0] round_ctr_new;\n  reg         round_ctr_we;\n  reg         round_ctr_inc;\n  reg         round_ctr_rst;\n\n  reg digest_valid_reg;\n  reg digest_valid_new;\n  reg digest_valid_we;\n\n  reg [1 : 0] sha1_ctrl_reg;\n  reg [1 : 0] sha1_ctrl_new;\n  reg         sha1_ctrl_we;\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg           digest_init;\n  reg           digest_update;\n  reg           state_init;\n  reg           state_update;\n  reg           first_block;\n  reg           ready_flag;\n  reg           w_init;\n  reg           w_next;\n  wire [31 : 0] w;\n\n\n  //----------------------------------------------------------------\n  // Module instantiantions.\n  //----------------------------------------------------------------\n  sha1_w_mem w_mem_inst(\n                        .clk(clk),\n                        .reset_n(reset_n),\n\n                        .block(block),\n\n                        .init(w_init),\n                        .next(w_next),\n\n                        .w(w)\n                       );\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign ready        = ready_flag;\n  assign digest       = {H0_reg, H1_reg, H2_reg, H3_reg, H4_reg};\n  assign digest_valid = digest_valid_reg;\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  // Update functionality for all registers in the core.\n  // All registers are positive edge triggered with\n  // asynchronous active low reset.\n  //----------------------------------------------------------------\n  always @ (posedge clk or negedge reset_n)\n    begin : reg_update\n      if (!reset_n)\n        begin\n          a_reg            <= 32'h0;\n          b_reg            <= 32'h0;\n          c_reg            <= 32'h0;\n          d_reg            <= 32'h0;\n          e_reg            <= 32'h0;\n          H0_reg           <= 32'h0;\n          H1_reg           <= 32'h0;\n          H2_reg           <= 32'h0;\n          H3_reg           <= 32'h0;\n          H4_reg           <= 32'h0;\n          digest_valid_reg <= 1'h0;\n          round_ctr_reg    <= 7'h0;\n          sha1_ctrl_reg    <= CTRL_IDLE;\n        end\n      else\n        begin\n          if (a_e_we)\n            begin\n              a_reg <= a_new;\n              b_reg <= b_new;\n              c_reg <= c_new;\n              d_reg <= d_new;\n              e_reg <= e_new;\n            end\n\n          if (H_we)\n            begin\n              H0_reg <= H0_new;\n              H1_reg <= H1_new;\n              H2_reg <= H2_new;\n              H3_reg <= H3_new;\n              H4_reg <= H4_new;\n            end\n\n          if (round_ctr_we)\n            round_ctr_reg <= round_ctr_new;\n\n          if (digest_valid_we)\n            digest_valid_reg <= digest_valid_new;\n\n          if (sha1_ctrl_we)\n            sha1_ctrl_reg <= sha1_ctrl_new;\n        end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // digest_logic\n  //\n  // The logic needed to init as well as update the digest.\n  //----------------------------------------------------------------\n  always @*\n    begin : digest_logic\n      H0_new = 32'h0;\n      H1_new = 32'h0;\n      H2_new = 32'h0;\n      H3_new = 32'h0;\n      H4_new = 32'h0;\n      H_we = 0;\n\n      if (digest_init)\n        begin\n          H0_new = H0_0;\n          H1_new = H0_1;\n          H2_new = H0_2;\n          H3_new = H0_3;\n          H4_new = H0_4;\n          H_we = 1;\n        end\n\n      if (digest_update)\n        begin\n          H0_new = H0_reg + a_reg;\n          H1_new = H1_reg + b_reg;\n          H2_new = H2_reg + c_reg;\n          H3_new = H3_reg + d_reg;\n          H4_new = H4_reg + e_reg;\n          H_we = 1;\n        end\n    end // digest_logic\n\n\n  //----------------------------------------------------------------\n  // state_logic\n  //\n  // The logic needed to init as well as update the state during\n  // round processing.\n  //----------------------------------------------------------------\n  always @*\n    begin : state_logic\n      reg [31 : 0] a5;\n      reg [31 : 0] f;\n      reg [31 : 0] k;\n      reg [31 : 0] t;\n\n      a5     = 32'h0;\n      f      = 32'h0;\n      k      = 32'h0;\n      t      = 32'h0;\n      a_new  = 32'h0;\n      b_new  = 32'h0;\n      c_new  = 32'h0;\n      d_new  = 32'h0;\n      e_new  = 32'h0;\n      a_e_we = 1'h0;\n\n      if (state_init)\n        begin\n          if (first_block)\n            begin\n              a_new  = H0_0;\n              b_new  = H0_1;\n              c_new  = H0_2;\n              d_new  = H0_3;\n              e_new  = H0_4;\n              a_e_we = 1;\n            end\n          else\n            begin\n              a_new  = H0_reg;\n              b_new  = H1_reg;\n              c_new  = H2_reg;\n              d_new  = H3_reg;\n              e_new  = H4_reg;\n              a_e_we = 1;\n            end\n        end\n\n      if (state_update)\n        begin\n          if (round_ctr_reg <= 19)\n            begin\n              k = 32'h5a827999;\n              f =  ((b_reg & c_reg) ^ (~b_reg & d_reg));\n            end\n          else if ((round_ctr_reg >= 20) && (round_ctr_reg <= 39))\n            begin\n              k = 32'h6ed9eba1;\n              f = b_reg ^ c_reg ^ d_reg;\n            end\n          else if ((round_ctr_reg >= 40) && (round_ctr_reg <= 59))\n            begin\n              k = 32'h8f1bbcdc;\n              f = ((b_reg | c_reg) ^ (b_reg | d_reg) ^ (c_reg | d_reg));\n            end\n          else if (round_ctr_reg >= 60)\n            begin\n              k = 32'hca62c1d6;\n              f = b_reg ^ c_reg ^ d_reg;\n            end\n\n          a5 = {a_reg[26 : 0], a_reg[31 : 27]};\n          t = a5 + e_reg + f + k + w;\n\n          a_new  = t;\n          b_new  = a_reg;\n          c_new  = {b_reg[1 : 0], b_reg[31 : 2]};\n          d_new  = c_reg;\n          e_new  = d_reg;\n          a_e_we = 1;\n        end\n    end // state_logic\n\n\n  //----------------------------------------------------------------\n  // round_ctr\n  //\n  // Update logic for the round counter, a monotonically\n  // increasing counter with reset.\n  //----------------------------------------------------------------\n  always @*\n    begin : round_ctr\n      round_ctr_new = 7'h0;\n      round_ctr_we  = 1'h0;\n\n      if (round_ctr_rst)\n        begin\n          round_ctr_new = 7'h0;\n          round_ctr_we  = 1'h1;\n        end\n\n      if (round_ctr_inc)\n        begin\n          round_ctr_new = round_ctr_reg + 1'h1;\n          round_ctr_we  = 1;\n        end\n    end // round_ctr\n\n\n  //----------------------------------------------------------------\n  // sha1_ctrl_fsm\n  // Logic for the state machine controlling the core behaviour.\n  //----------------------------------------------------------------\n  always @*\n    begin : sha1_ctrl_fsm\n      digest_init      = 1'h0;\n      digest_update    = 1'h0;\n      state_init       = 1'h0;\n      state_update     = 1'h0;\n      first_block      = 1'h0;\n      ready_flag       = 1'h0;\n      w_init           = 1'h0;\n      w_next           = 1'h0;\n      round_ctr_inc    = 1'h0;\n      round_ctr_rst    = 1'h0;\n      digest_valid_new = 1'h0;\n      digest_valid_we  = 1'h0;\n      sha1_ctrl_new    = CTRL_IDLE;\n      sha1_ctrl_we     = 1'h0;\n\n      case (sha1_ctrl_reg)\n        CTRL_IDLE:\n          begin\n            ready_flag = 1;\n\n            if (init)\n              begin\n                digest_init      = 1'h1;\n                w_init           = 1'h1;\n                state_init       = 1'h1;\n                first_block      = 1'h1;\n                round_ctr_rst    = 1'h1;\n                digest_valid_new = 1'h0;\n                digest_valid_we  = 1'h1;\n                sha1_ctrl_new    = CTRL_ROUNDS;\n                sha1_ctrl_we     = 1'h1;\n              end\n\n            if (next)\n              begin\n                w_init           = 1'h1;\n                state_init       = 1'h1;\n                round_ctr_rst    = 1'h1;\n                digest_valid_new = 1'h0;\n                digest_valid_we  = 1'h1;\n                sha1_ctrl_new    = CTRL_ROUNDS;\n                sha1_ctrl_we     = 1'h1;\n              end\n          end\n\n\n        CTRL_ROUNDS:\n          begin\n            state_update  = 1'h1;\n            round_ctr_inc = 1'h1;\n            w_next        = 1'h1;\n\n            if (round_ctr_reg == SHA1_ROUNDS)\n              begin\n                sha1_ctrl_new = CTRL_DONE;\n                sha1_ctrl_we  = 1'h1;\n              end\n          end\n\n\n        CTRL_DONE:\n          begin\n            digest_update    = 1'h1;\n            digest_valid_new = 1'h1;\n            digest_valid_we  = 1'h1;\n            sha1_ctrl_new    = CTRL_IDLE;\n            sha1_ctrl_we     = 1'h1;\n          end\n      endcase // case (sha1_ctrl_reg)\n    end // sha1_ctrl_fsm\n\nendmodule // sha1_core\n\n//======================================================================\n// EOF sha1_core.v\n//======================================================================", "rtl/sha1_w_mem.v": "//======================================================================\n//\n// sha1_w_mem_reg.v\n// -----------------\n// The SHA-1 W memory. This memory includes functionality to\n// expand the block into 80 words.\n//\n//\n// Copyright (c) 2013 Secworks Sweden AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\n`default_nettype none\n\nmodule sha1_w_mem(\n                  input wire           clk,\n                  input wire           reset_n,\n\n                  input wire [511 : 0] block,\n\n                  input wire           init,\n                  input wire           next,\n\n                  output wire [31 : 0] w\n                 );\n\n\n  //----------------------------------------------------------------\n  // Registers including update variables and write enable.\n  //----------------------------------------------------------------\n  reg [31 : 0] w_mem [0 : 15];\n  reg [31 : 0] w_mem00_new;\n  reg [31 : 0] w_mem01_new;\n  reg [31 : 0] w_mem02_new;\n  reg [31 : 0] w_mem03_new;\n  reg [31 : 0] w_mem04_new;\n  reg [31 : 0] w_mem05_new;\n  reg [31 : 0] w_mem06_new;\n  reg [31 : 0] w_mem07_new;\n  reg [31 : 0] w_mem08_new;\n  reg [31 : 0] w_mem09_new;\n  reg [31 : 0] w_mem10_new;\n  reg [31 : 0] w_mem11_new;\n  reg [31 : 0] w_mem12_new;\n  reg [31 : 0] w_mem13_new;\n  reg [31 : 0] w_mem14_new;\n  reg [31 : 0] w_mem15_new;\n  reg          w_mem_we;\n\n  reg [6 : 0] w_ctr_reg;\n  reg [6 : 0] w_ctr_new;\n  reg         w_ctr_we;\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg [31 : 0] w_tmp;\n  reg [31 : 0] w_new;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign w = w_tmp;\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //\n  // Update functionality for all registers in the core.\n  // All registers are positive edge triggered with\n  // asynchronous active low reset.\n  //----------------------------------------------------------------\n  always @ (posedge clk or negedge reset_n)\n    begin : reg_update\n      integer i;\n\n      if (!reset_n)\n        begin\n          for (i = 0 ; i < 16 ; i = i + 1)\n            w_mem[i] <= 32'h0;\n\n          w_ctr_reg <= 7'h0;\n        end\n      else\n        begin\n          if (w_mem_we)\n            begin\n              w_mem[00] <= w_mem00_new;\n              w_mem[01] <= w_mem01_new;\n              w_mem[02] <= w_mem02_new;\n              w_mem[03] <= w_mem03_new;\n              w_mem[04] <= w_mem04_new;\n              w_mem[05] <= w_mem05_new;\n              w_mem[06] <= w_mem06_new;\n              w_mem[07] <= w_mem07_new;\n              w_mem[08] <= w_mem08_new;\n              w_mem[09] <= w_mem09_new;\n              w_mem[10] <= w_mem10_new;\n              w_mem[11] <= w_mem11_new;\n              w_mem[12] <= w_mem12_new;\n              w_mem[13] <= w_mem13_new;\n              w_mem[14] <= w_mem14_new;\n              w_mem[15] <= w_mem15_new;\n            end\n\n          if (w_ctr_we)\n            w_ctr_reg <= w_ctr_new;\n        end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // select_w\n  //\n  // W word selection logic. Returns either directly from the\n  // memory or the next w value calculated.\n  //----------------------------------------------------------------\n  always @*\n    begin : select_w\n      if (w_ctr_reg < 16)\n        w_tmp = w_mem[w_ctr_reg[3 : 0]];\n      else\n        w_tmp = w_new;\n    end // select_w\n\n\n  //----------------------------------------------------------------\n  // w_mem_update_logic\n  //\n  // Update logic for the W memory. This is where the scheduling\n  // based on a sliding window is implemented.\n  //----------------------------------------------------------------\n  always @*\n    begin : w_mem_update_logic\n      reg [31 : 0] w_0;\n      reg [31 : 0] w_2;\n      reg [31 : 0] w_8;\n      reg [31 : 0] w_13;\n      reg [31 : 0] w_16;\n\n      w_mem00_new = 32'h0;\n      w_mem01_new = 32'h0;\n      w_mem02_new = 32'h0;\n      w_mem03_new = 32'h0;\n      w_mem04_new = 32'h0;\n      w_mem05_new = 32'h0;\n      w_mem06_new = 32'h0;\n      w_mem07_new = 32'h0;\n      w_mem08_new = 32'h0;\n      w_mem09_new = 32'h0;\n      w_mem10_new = 32'h0;\n      w_mem11_new = 32'h0;\n      w_mem12_new = 32'h0;\n      w_mem13_new = 32'h0;\n      w_mem14_new = 32'h0;\n      w_mem15_new = 32'h0;\n      w_mem_we    = 1'h0;\n\n      w_0   = w_mem[0];\n      w_2   = w_mem[2];\n      w_8   = w_mem[8];\n      w_13  = w_mem[13];\n      w_16  = w_13 ^ w_8 ^ w_2 ^ w_0;\n      w_new = {w_16[30 : 0], w_16[31]};\n\n      if (init)\n        begin\n          w_mem00_new = block[511 : 480];\n          w_mem01_new = block[479 : 448];\n          w_mem02_new = block[447 : 416];\n          w_mem03_new = block[415 : 384];\n          w_mem04_new = block[383 : 352];\n          w_mem05_new = block[351 : 320];\n          w_mem06_new = block[319 : 288];\n          w_mem07_new = block[287 : 256];\n          w_mem08_new = block[255 : 224];\n          w_mem09_new = block[223 : 192];\n          w_mem10_new = block[191 : 160];\n          w_mem11_new = block[159 : 128];\n          w_mem12_new = block[127 :  96];\n          w_mem13_new = block[95  :  64];\n          w_mem14_new = block[63  :  32];\n          w_mem15_new = block[31  :   0];\n          w_mem_we    = 1'h1;\n        end\n\n      if (next && (w_ctr_reg > 15))\n        begin\n          w_mem00_new = w_mem[01];\n          w_mem01_new = w_mem[02];\n          w_mem02_new = w_mem[03];\n          w_mem03_new = w_mem[04];\n          w_mem04_new = w_mem[05];\n          w_mem05_new = w_mem[06];\n          w_mem06_new = w_mem[07];\n          w_mem07_new = w_mem[08];\n          w_mem08_new = w_mem[09];\n          w_mem09_new = w_mem[10];\n          w_mem10_new = w_mem[11];\n          w_mem11_new = w_mem[12];\n          w_mem12_new = w_mem[13];\n          w_mem13_new = w_mem[14];\n          w_mem14_new = w_mem[15];\n          w_mem15_new = w_new;\n          w_mem_we    = 1'h1;\n        end\n    end // w_mem_update_logic\n\n\n  //----------------------------------------------------------------\n  // w_ctr\n  //\n  // W schedule adress counter. Counts from 0x10 to 0x3f and\n  // is used to expand the block into words.\n  //----------------------------------------------------------------\n  always @*\n    begin : w_ctr\n      w_ctr_new = 7'h0;\n      w_ctr_we  = 1'h0;\n\n      if (init)\n        begin\n          w_ctr_new = 7'h0;\n          w_ctr_we  = 1'h1;\n        end\n\n      if (next)\n        begin\n          w_ctr_new = w_ctr_reg + 7'h01;\n          w_ctr_we  = 1'h1;\n        end\n    end // w_ctr\nendmodule // sha1_w_mem\n\n//======================================================================\n// sha1_w_mem.v\n//======================================================================", "verif/sha1_core_idle_state_safety_check.sv": "module sha1_core_idle_state_safety_check (\n    input wire            clk,\n    input wire            reset_n,\n    input wire            init,\n    input wire            next,\n    input wire [511 : 0]  block,\n    output wire           ready,\n    output wire [159 : 0] digest,\n    output wire           digest_valid\n);\n\n    sha1_core dut (\n        .clk(clk),\n        .reset_n(reset_n),\n        .init(init),\n        .next(next),\n        .block(block),\n        .ready(ready),\n        .digest(digest),\n        .digest_valid(digest_valid)\n    );\n\nendmodule : sha1_core_idle_state_safety_check"}}, "output": {"response": "", "context": {"verif/sha1_core_idle_state_safety_check.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    image: verification_image\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/verif/sha1_core_idle_state_safety_check.sv /code/rtl/sha1_core.v /code/rtl/sha1_w_mem.v\nTOPLEVEL        = sha1_core_idle_state_safety_check\nMODULE          = test_sha1_core\nPYTHONPATH      = /src\nHASH            = 507245a74efc0a20ee506da956c8005006f0c9bf", "src/coverage.py": "from cocotb.runner import get_runner\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_clear():\n    covt_report_file=\"/code/rundir/coverage.log\"\n    if os.path.isfile(covt_report_file):\n        os.remove(covt_report_file)\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "\nfrom cocotb.binary import BinaryValue\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\n\nCLK_HALF_PERIOD = 1\nCLK_PERIOD = CLK_HALF_PERIOD * 2\nCLK_TIME_UNIT = 'ns'\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def init_sim(dut):\n    dut.reset_n.value = 1\n    dut.init.value = 0\n    dut.next.value = 0\n    dut.block.value = 0\n\nasync def reset_dut(dut):\n    dut.reset_n.value = 0\n    await Timer(4 * CLK_HALF_PERIOD, units=CLK_TIME_UNIT)\n    dut.reset_n.value = 1\n\nasync def wait_ready(dut):\n    while dut.ready.value.integer != 1:\n        await FallingEdge(dut.clk)\n\nasync def single_block_test(dut, block: BinaryValue, expected: BinaryValue):\n    dut.block.value = block\n    dut.init.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.init.value = 0\n    await wait_ready(dut)\n\n    assert dut.digest.value == expected, \"didn't get the expected digest output\"\n\nasync def double_block_test(dut, blocks: list[BinaryValue], expected: list[BinaryValue]):\n    dut.block.value = blocks[0]\n    dut.init.value = 1\n    await FallingEdge(dut.clk)\n\n    dut.init.value = 0\n    await wait_ready(dut)\n\n    assert dut.digest.value == expected[0], \"didn't get the expected digest output for block1\"\n\n    dut.block.value = blocks[1]\n    dut.next.value = 1\n    await FallingEdge(dut.clk)\n\n    dut.next.value = 0\n    await wait_ready(dut)\n\n    assert dut.digest.value == expected[1], \"didn't get the expected digest output for block2\"\n\n", "src/test_runner.py": "import os\nimport pytest\nimport coverage\nimport random\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef call_runner():\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.covt_report_clear()\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter={}\n        )\n        coverage.coverage_report(\"assertion\")\n        coverage.covt_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n    # Run the simulation\n    call_runner()\n", "src/test_sha1_core.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.binary import BinaryValue\nimport harness_library as hrs_lb\n\n\n@cocotb.test()\nasync def test_dut(dut):\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_dut...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    # TC1: Single block message: \"abc\".\n    # tc1 = 512'h61626380000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000018;\n    # res1 = 160'ha9993e364706816aba3e25717850c26c9cd0d89d;\n\n    tc1 = int('61626380000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000018', 16)\n    res1 = int('a9993e364706816aba3e25717850c26c9cd0d89d', 16)\n    tc1_bin = BinaryValue(tc1, 512, False)\n    res1_bin = BinaryValue(res1, 160, False)\n    await hrs_lb.single_block_test(dut, tc1_bin, res1_bin)\n\n    # TC2: Double block message.\n    # \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n    # tc2_1 = 512'h6162636462636465636465666465666765666768666768696768696A68696A6B696A6B6C6A6B6C6D6B6C6D6E6C6D6E6F6D6E6F706E6F70718000000000000000;\n    # res2_1 = 160'hf4286818c37b27ae0408f581846771484a566572;\n    # tc2_2 = 512'h000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001C0;\n    # res2_2 = 160'h84983e441c3bd26ebaae4aa1f95129e5e54670f1;\n\n    tc2 = [\n        int('6162636462636465636465666465666765666768666768696768696A68696A6B696A6B6C6A6B6C6D6B6C6D6E6C6D6E6F6D6E6F706E6F70718000000000000000', 16),\n        int('000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001C0', 16)\n    ]\n    res2 = [\n        int('f4286818c37b27ae0408f581846771484a566572', 16),\n        int('84983e441c3bd26ebaae4aa1f95129e5e54670f1', 16)\n    ]\n    tc2_bin = [\n        BinaryValue(tc2[0], 512, False),\n        BinaryValue(tc2[1], 512, False)\n    ]\n    res2_bin = [\n        BinaryValue(res2[0], 160, False),\n        BinaryValue(res2[1], 160, False)\n    ]\n    await hrs_lb.double_block_test(dut, tc2_bin, res2_bin)\n\n    cocotb.log.info(\"All tests passed.\")\n"}}}
{"id": "cvdp_copilot_crypto_0019", "categories": ["cid014", "medium"], "input": {"prompt": "Add an assertion to verify that the `prince_core` module can **cipher** and **decipher** a given data block using a given key, considering the conditions described below.  \n\n- The property must be placed in a separate module named `prince_core_cipher_operations_check`, which instantiates `prince_core` as `dut` (Device Under Test).  \n- The property must directly reference internal DUT signals for verification.  \n\n### **Design Specification: `prince_core`**\n\n#### **Inputs:**  \n- **clk**: System clock (rising edge).  \n- **reset_n**: Active-low asynchronous reset.  \n- **encdec**: Mode selection (1 = encryption, 0 = decryption).  \n- **next**: Starts encryption/decryption when asserted.  \n- **key** (`[127:0]`): 128-bit encryption key.  \n- **block** (`[63:0]`): 64-bit input (plaintext or ciphertext).  \n\n#### **Outputs:**  \n- **ready**: High when the core is idle and ready for a new operation.  \n- **result** (`[63:0]`): 64-bit processed output (ciphertext or plaintext).  \n\n---\n\n### **Functional Overview:**  \n- Implements **PRINCE**, a lightweight 64-bit block cipher with a **128-bit key**.  \n- Uses a **12-round transformation**, split into forward and inverse rounds for encryption and decryption.  \n- Computes the result over multiple clock cycles, updating internal registers.  \n- The **FSM state** is controlled by:  \n  - `core_ctrl_reg`: Holds the current state.  \n  - `core_ctrl_new`: Stores the next state before updating.  \n\n---\n\n### **FSM (Finite State Machine) States:**  \n1. **CTRL_IDLE**: Waits for `next` to start processing. (`ready = 1`)  \n2. **CTRL_PIPE0 \u2192 CTRL_PIPE1 \u2192 CTRL_PIPE2**: Sequential processing stages applying encryption/decryption transformations.  \n3. **CTRL_UPDATE**: Writes the final result, sets `ready = 1`, and returns to `CTRL_IDLE`.  \n\n`core_ctrl_reg` updates to `core_ctrl_new` on each clock cycle when a transition occurs.  \n\n---\n\n### **Signal Behavior:**  \n\n| **Signal**   | **Description**                               |\n|--------------|-----------------------------------------------|\n| **clk**      | Drives all internal operations.               |\n| **reset_n**  | Resets internal registers.                    |\n| **next**     | Triggers processing when asserted.            |\n| **encdec**   | Selects encryption (`1`) or decryption (`0`). |\n| **key**      | 128-bit secret key.                           |\n| **block**    | Input data (plaintext/ciphertext).            |\n| **ready**    | High when idle, low during processing.        |\n| **result**   | Outputs the processed 64-bit data.            |\n\n---\n\n### **Processing Flow:**  \n1. **Idle:** `ready = 1`, waits for `next`.  \n2. **Pipeline Processing:** Transitions through `PIPE0 \u2192 PIPE1 \u2192 PIPE2`.  \n3. **Update:** Stores result, sets `ready = 1`, returns to `CTRL_IDLE`.  \n\n**Key Features:**  \n- **Low-latency:** Optimized for fast encryption/decryption.  \n- **Encryption & Decryption Support:** Controlled via `encdec`.  \n- **FSM Control:** `core_ctrl_reg` determines state transitions.  \n- **Internal Key Schedule:** Uses `k0`, `k1`, and derived `kp` for transformations.  \n\n---\n\n### **Note:**  \n- An **assertion failure** must include a **descriptive error message** to aid debugging.  ", "context": {"rtl/prince_core.v": "//======================================================================\n//\n// prince_core.v\n// -------------\n// Prince block cipher core.\n//\n//\n// Author: Joachim Strombergson\n// Copyright (c) 2019, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\n`default_nettype none\n\nmodule prince_core(\n                   input wire           clk,\n                   input wire           reset_n,\n\n                   input wire           encdec,\n                   input wire           next,\n                   output wire          ready,\n\n                   input wire [127 : 0] key,\n\n                   input wire [63 : 0]  block,\n                   output wire [63 : 0] result\n                  );\n\n\n  //----------------------------------------------------------------\n  // Internal constant and parameter definitions.\n  //----------------------------------------------------------------\n  localparam CTRL_IDLE   = 3'h0;\n  localparam CTRL_PIPE0  = 3'h1;\n  localparam CTRL_PIPE1  = 3'h2;\n  localparam CTRL_PIPE2  = 3'h3;\n  localparam CTRL_UPDATE = 3'h4;\n\n  localparam ALPHA = 64'hc0ac29b7c97c50dd;\n\n\n  //----------------------------------------------------------------\n  // Registers including update variables and write enable.\n  //----------------------------------------------------------------\n  reg [63 : 0] k0_reg;\n  reg [63 : 0] k0_new;\n  reg [63 : 0] k1_reg;\n  reg [63 : 0] k1_new;\n  reg [63 : 0] kp_reg;\n  reg [63 : 0] kp_new;\n  reg          k_we;\n\n  reg          ready_reg;\n  reg          ready_new;\n  reg          ready_we;\n\n  reg [63 : 0] state_reg;\n  reg [63 : 0] state_new;\n  reg          state_we;\n\n  reg [63 : 0] r3_reg;\n  reg [63 : 0] r3_new;\n\n  reg [63 : 0] r8_reg;\n  reg [63 : 0] r8_new;\n\n  reg [63 : 0] mr_reg;\n  reg [63 : 0] mr_new;\n\n  reg [2 : 0]  core_ctrl_reg;\n  reg [2 : 0]  core_ctrl_new;\n  reg          core_ctrl_we;\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg init_state;\n  reg update_state;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign ready  = ready_reg;\n  assign result = state_reg;\n\n\n  //----------------------------------------------------------------\n  // Internal functions.\n  //----------------------------------------------------------------\n//`include \"prince_round_functions.vh\"\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //\n  // Update functionality for all registers in the core.\n  // All registers are positive edge triggered with asynchronous\n  // active low reset.\n  //----------------------------------------------------------------\n  always @ (posedge clk or negedge reset_n)\n    begin: reg_update\n      if (!reset_n)\n        begin\n          ready_reg     <= 1'h1;\n          k0_reg        <= 64'h0;\n          k1_reg        <= 64'h0;\n          kp_reg        <= 64'h0;\n          r3_reg        <= 64'h0;\n          r8_reg        <= 64'h0;\n          mr_reg        <= 64'h0;\n          state_reg     <= 64'h0;\n          core_ctrl_reg <= CTRL_IDLE;\n        end\n      else\n        begin\n          r3_reg <= r3_new;\n          r8_reg <= r8_new;\n          mr_reg <= mr_new;\n\n          if (ready_we)\n            ready_reg <= ready_new;\n\n          if (state_we)\n            state_reg <= state_new;\n\n          if (k_we)\n            begin\n              k0_reg <= k0_new;\n              k1_reg <= k1_new;\n              kp_reg <= kp_new;\n            end\n\n          if (core_ctrl_we)\n            core_ctrl_reg <= core_ctrl_new;\n        end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // prince_core_dp\n  //\n  // Datapath with state update logic.\n  //----------------------------------------------------------------\n  always @*\n    begin : prince_core_dp\n\n      reg [63 : 0] core_input;\n      reg [63 : 0] core_output;\n\n      reg [63 : 0] r0;\n      reg [63 : 0] r1;\n      reg [63 : 0] r2;\n      reg [63 : 0] r4;\n      reg [63 : 0] r5;\n      reg [63 : 0] r6;\n      reg [63 : 0] r7;\n      reg [63 : 0] r9;\n      reg [63 : 0] r10;\n      reg [63 : 0] r11;\n\n      state_new = 64'h0;\n      state_we  = 1'h0;\n      k0_new    = 64'h0;\n      k1_new    = 64'h0;\n      kp_new    = 64'h0;\n      k_we      = 1'h0;\n\n\n      // Pipeline stages.\n      core_input = state_reg ^ k0_reg;\n      r0 = round0(core_input, k1_reg);\n      r1 = round(r0, k1_reg, 1);\n      r2 = round(r1, k1_reg, 2);\n      r3_new = round(r2, k1_reg, 3);\n\n      r4 = round(r3_reg, k1_reg, 4);\n      r5 = round(r4, k1_reg, 5);\n      mr_new = middle_round(r5);\n\n      r6 = iround(mr_reg, k1_reg, 6);\n      r7 = iround(r6, k1_reg, 7);\n      r8_new = iround(r7, k1_reg, 8);\n\n      r9  = iround(r8_reg, k1_reg, 9);\n      r10 = iround(r9, k1_reg, 10);\n      r11 = round11(r10, k1_reg);\n      core_output = r11 ^ kp_reg;\n\n\n      if (init_state)\n        begin\n          k_we      = 1'h1;\n          state_new = block;\n          state_we  = 1'h1;\n\n          if (encdec)\n            begin\n              k0_new = key[127 : 64];\n              kp_new = {k0_new[0], k0_new[63 : 2], (k0_new[1] ^ k0_new[63])};\n              k1_new = key[63 : 0];\n            end\n          else\n            begin\n              kp_new = key[127 : 64];\n              k0_new = {kp_new[0], kp_new[63 : 2], (kp_new[1] ^ kp_new[63])};\n              k1_new = key[63 : 0] ^ ALPHA;\n            end\n        end\n\n      if (update_state)\n        begin\n          state_new = core_output;\n          state_we  = 1'h1;\n        end\n    end // prince_core_dp\n\n\n  //----------------------------------------------------------------\n  // prince_core_ctrl\n  //\n  // Control FSM for aes core.\n  //----------------------------------------------------------------\n  always @*\n    begin : prince_core_ctrl\n      ready_new     = 1'h0;\n      ready_we      = 1'h0;\n      init_state    = 1'h0;\n      update_state  = 1'h0;\n      core_ctrl_new = CTRL_IDLE;\n      core_ctrl_we  = 1'h0;\n\n      case (core_ctrl_reg)\n        CTRL_IDLE:\n          begin\n            if (next)\n              begin\n                ready_new     = 1'h0;\n                ready_we      = 1'h1;\n                init_state    = 1'h1;\n                core_ctrl_new = CTRL_PIPE0;\n                core_ctrl_we  = 1'h1;\n              end\n          end\n\n        CTRL_PIPE0:\n          begin\n            core_ctrl_new = CTRL_PIPE1;\n            core_ctrl_we  = 1'h1;\n          end\n\n        CTRL_PIPE1:\n          begin\n            core_ctrl_new = CTRL_PIPE2;\n            core_ctrl_we  = 1'h1;\n          end\n\n        CTRL_PIPE2:\n          begin\n            core_ctrl_new = CTRL_UPDATE;\n            core_ctrl_we  = 1'h1;\n          end\n\n        CTRL_UPDATE:\n          begin\n            ready_new     = 1'h1;\n            ready_we      = 1'h1;\n            update_state  = 1'h1;\n            core_ctrl_new = CTRL_IDLE;\n            core_ctrl_we  = 1'h1;\n          end\n\n        default:\n          begin\n          end\n      endcase // case (core_ctrl_reg)\n    end // prince_core_ctrl\n\nendmodule // prince_core\n\n//======================================================================\n// EOF prince_core.v\n//======================================================================", "rtl/prince_round_functions.vh": "//======================================================================\n//\n// prince_round_functions.v\n// ------------------------\n// Functions used in the prince core.\n//\n//\n// Author: Joachim Strombergson\n// Copyright (c) 2023, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\n  function [3 : 0] sb(input [3 : 0] x);\n    case(x)\n      4'h0: sb = 4'hb;\n      4'h1: sb = 4'hf;\n      4'h2: sb = 4'h3;\n      4'h3: sb = 4'h2;\n      4'h4: sb = 4'ha;\n      4'h5: sb = 4'hc;\n      4'h6: sb = 4'h9;\n      4'h7: sb = 4'h1;\n      4'h8: sb = 4'h6;\n      4'h9: sb = 4'h7;\n      4'ha: sb = 4'h8;\n      4'hb: sb = 4'h0;\n      4'hc: sb = 4'he;\n      4'hd: sb = 4'h5;\n      4'he: sb = 4'hd;\n      4'hf: sb = 4'h4;\n    endcase // case (x)\n  endfunction // sb\n\n  function [63 : 0] s(input [63 : 0] x);\n    s = {sb(x[63 : 60]), sb(x[59 : 56]),\n         sb(x[55 : 52]), sb(x[51 : 48]),\n         sb(x[47 : 44]), sb(x[43 : 40]),\n         sb(x[39 : 36]), sb(x[35 : 32]),\n         sb(x[31 : 28]), sb(x[27 : 24]),\n         sb(x[23 : 20]), sb(x[19 : 16]),\n         sb(x[15 : 12]), sb(x[11 : 08]),\n         sb(x[07 : 04]), sb(x[03 : 00])};\n  endfunction // s\n\n  function [3 : 0] isb(input [3 : 0] x);\n    case(x)\n      4'h0: isb = 4'hb;\n      4'h1: isb = 4'h7;\n      4'h2: isb = 4'h3;\n      4'h3: isb = 4'h2;\n      4'h4: isb = 4'hf;\n      4'h5: isb = 4'hd;\n      4'h6: isb = 4'h8;\n      4'h7: isb = 4'h9;\n      4'h8: isb = 4'ha;\n      4'h9: isb = 4'h6;\n      4'ha: isb = 4'h4;\n      4'hb: isb = 4'h0;\n      4'hc: isb = 4'h5;\n      4'hd: isb = 4'he;\n      4'he: isb = 4'hc;\n      4'hf: isb = 4'h1;\n    endcase // case (x)\n  endfunction // isb\n\n  function [63 : 0] si(input [63 : 0] x);\n    si = {isb(x[63 : 60]), isb(x[59 : 56]),\n          isb(x[55 : 52]), isb(x[51 : 48]),\n          isb(x[47 : 44]), isb(x[43 : 40]),\n          isb(x[39 : 36]), isb(x[35 : 32]),\n          isb(x[31 : 28]), isb(x[27 : 24]),\n          isb(x[23 : 20]), isb(x[19 : 16]),\n          isb(x[15 : 12]), isb(x[11 : 08]),\n          isb(x[07 : 04]), isb(x[03 : 00])};\n  endfunction // si\n\n  function [63 : 0] rc(input [3 : 0] round);\n    begin\n      case(round)\n        00: rc = 64'h0000000000000000;\n        01: rc = 64'h13198a2e03707344;\n        02: rc = 64'ha4093822299f31d0;\n        03: rc = 64'h082efa98ec4e6c89;\n        04: rc = 64'h452821e638d01377;\n        05: rc = 64'hbe5466cf34e90c6c;\n        06: rc = 64'h7ef84f78fd955cb1;\n        07: rc = 64'h85840851f1ac43aa;\n        08: rc = 64'hc882d32f25323c54;\n        09: rc = 64'h64a51195e0e3610d;\n        10: rc = 64'hd3b5a399ca0c2399;\n        11: rc = 64'hc0ac29b7c97c50dd;\n        default:\n          rc = 64'h0;\n      endcase // case (round)\n    end\n  endfunction // rc\n\n  function [63 : 0] mp(input [63 : 0] b);\n    begin\n      mp[63] = b[59] ^ b[55] ^ b[51];\n      mp[62] = b[62] ^ b[54] ^ b[50];\n      mp[61] = b[61] ^ b[57] ^ b[49];\n      mp[60] = b[60] ^ b[56] ^ b[52];\n      mp[59] = b[63] ^ b[59] ^ b[55];\n      mp[58] = b[58] ^ b[54] ^ b[50];\n      mp[57] = b[61] ^ b[53] ^ b[49];\n      mp[56] = b[60] ^ b[56] ^ b[48];\n      mp[55] = b[63] ^ b[59] ^ b[51];\n      mp[54] = b[62] ^ b[58] ^ b[54];\n      mp[53] = b[57] ^ b[53] ^ b[49];\n      mp[52] = b[60] ^ b[52] ^ b[48];\n      mp[51] = b[63] ^ b[55] ^ b[51];\n      mp[50] = b[62] ^ b[58] ^ b[50];\n      mp[49] = b[61] ^ b[57] ^ b[53];\n      mp[48] = b[56] ^ b[52] ^ b[48];\n      mp[47] = b[47] ^ b[43] ^ b[39];\n      mp[46] = b[42] ^ b[38] ^ b[34];\n      mp[45] = b[45] ^ b[37] ^ b[33];\n      mp[44] = b[44] ^ b[40] ^ b[32];\n      mp[43] = b[47] ^ b[43] ^ b[35];\n      mp[42] = b[46] ^ b[42] ^ b[38];\n      mp[41] = b[41] ^ b[37] ^ b[33];\n      mp[40] = b[44] ^ b[36] ^ b[32];\n      mp[39] = b[47] ^ b[39] ^ b[35];\n      mp[38] = b[46] ^ b[42] ^ b[34];\n      mp[37] = b[45] ^ b[41] ^ b[37];\n      mp[36] = b[40] ^ b[36] ^ b[32];\n      mp[35] = b[43] ^ b[39] ^ b[35];\n      mp[34] = b[46] ^ b[38] ^ b[34];\n      mp[33] = b[45] ^ b[41] ^ b[33];\n      mp[32] = b[44] ^ b[40] ^ b[36];\n      mp[31] = b[31] ^ b[27] ^ b[23];\n      mp[30] = b[26] ^ b[22] ^ b[18];\n      mp[29] = b[29] ^ b[21] ^ b[17];\n      mp[28] = b[28] ^ b[24] ^ b[16];\n      mp[27] = b[31] ^ b[27] ^ b[19];\n      mp[26] = b[30] ^ b[26] ^ b[22];\n      mp[25] = b[25] ^ b[21] ^ b[17];\n      mp[24] = b[28] ^ b[20] ^ b[16];\n      mp[23] = b[31] ^ b[23] ^ b[19];\n      mp[22] = b[30] ^ b[26] ^ b[18];\n      mp[21] = b[29] ^ b[25] ^ b[21];\n      mp[20] = b[24] ^ b[20] ^ b[16];\n      mp[19] = b[27] ^ b[23] ^ b[19];\n      mp[18] = b[30] ^ b[22] ^ b[18];\n      mp[17] = b[29] ^ b[25] ^ b[17];\n      mp[16] = b[28] ^ b[24] ^ b[20];\n      mp[15] = b[11] ^ b[07] ^ b[03];\n      mp[14] = b[14] ^ b[06] ^ b[02];\n      mp[13] = b[13] ^ b[09] ^ b[01];\n      mp[12] = b[12] ^ b[08] ^ b[04];\n      mp[11] = b[15] ^ b[11] ^ b[07];\n      mp[10] = b[10] ^ b[06] ^ b[02];\n      mp[09] = b[13] ^ b[05] ^ b[01];\n      mp[08] = b[12] ^ b[08] ^ b[00];\n      mp[07] = b[15] ^ b[11] ^ b[03];\n      mp[06] = b[14] ^ b[10] ^ b[06];\n      mp[05] = b[09] ^ b[05] ^ b[01];\n      mp[04] = b[12] ^ b[04] ^ b[00];\n      mp[03] = b[15] ^ b[07] ^ b[03];\n      mp[02] = b[14] ^ b[10] ^ b[02];\n      mp[01] = b[13] ^ b[09] ^ b[05];\n      mp[00] = b[08] ^ b[04] ^ b[00];\n    end\n  endfunction // mp\n\n  function [63 : 0] m(input [63 : 0] b);\n    begin : m_func\n      reg [63 : 0] t;\n      t = mp(b);\n\n      m = {t[63 : 60], t[43 : 40], t[23 : 20], t[03 : 00],\n           t[47 : 44], t[27 : 24], t[07 : 04], t[51 : 48],\n           t[31 : 28], t[11 : 08], t[55 : 52], t[35 : 32],\n           t[15 : 12], t[59 : 56], t[39 : 36], t[19 : 16]};\n    end\n  endfunction // m\n\n  function [63 : 0] mi(input [63 : 0] b);\n    begin : mi_func\n      reg [63 : 0] t;\n\n      t = {b[63 : 60], b[11 : 08], b[23 : 20], b[35 : 32],\n           b[47 : 44], b[59 : 56], b[07 : 04], b[19 : 16],\n           b[31 : 28], b[43 : 40], b[55 : 52], b[03 : 00],\n           b[15 : 12], b[27 : 24], b[39 : 36], b[51 : 48]};\n\n      mi = mp(t);\n    end\n  endfunction // m\n\n  function [63 : 0] round0(input [63 : 0] b, input [63 : 0] k);\n    begin\n      round0 = b ^ k ^ rc(0);\n    end\n  endfunction // round0\n\n  function [63 : 0] round11(input [63 : 0] b, input [63 : 0] k);\n    begin\n      round11 =  b ^ k ^ rc(11);\n    end\n  endfunction // round11\n\n  function [63 : 0] round(input [63 : 0] b, input [63 : 0] k, input [3 : 0] n);\n    begin\n      round = m(s(b)) ^ rc(n) ^ k;\n    end\n  endfunction // round\n\n  function [63 : 0] middle_round(input [63 : 0] b);\n    begin\n      middle_round = si(mp(s(b)));\n    end\n  endfunction // middle_round\n\n  function [63 : 0] iround(input [63 : 0] b, input [63 : 0] k, input [3 : 0] n);\n    begin\n      iround = si(mi(rc(n) ^ k ^ b));\n    end\n  endfunction // iround\n\n//======================================================================\n// EOF prince_round_functions.vh\n//======================================================================", "verif/prince_core_cipher_operations_check.sv": "module prince_core_cipher_operations_check (\n    input wire           clk,\n    input wire           reset_n,\n    input wire           encdec,\n    input wire           next,\n    output wire          ready,\n    input wire [127 : 0] key,\n    input wire [63 : 0]  block,\n    output wire [63 : 0] result\n);\n\n    prince_core dut (\n        .clk(clk),\n        .reset_n(reset_n),\n        .encdec(encdec),\n        .next(next),\n        .ready(ready),\n        .key(key),\n        .block(block),\n        .result(result)\n    );\n\nendmodule : prince_core_cipher_operations_check"}}, "output": {"response": "", "context": {"verif/prince_core_cipher_operations_check.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    image: verification_image\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/verif/prince_core_cipher_operations_check.sv /code/rtl/prince_core.v /code/rtl/prince_round_functions.vh\nTOPLEVEL        = prince_core_cipher_operations_check\nMODULE          = test_prince_core\nPYTHONPATH      = /src\nHASH            = aa7b0ed0e861ccab67e24332414fb028024c4377", "src/coverage.py": "from cocotb.runner import get_runner\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_clear():\n    covt_report_file=\"/code/rundir/coverage.log\"\n    if os.path.isfile(covt_report_file):\n        os.remove(covt_report_file)\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "\nfrom cocotb.binary import BinaryValue\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\n\nCLK_HALF_PERIOD = 1\nCLK_PERIOD = CLK_HALF_PERIOD * 2\nCLK_TIME_UNIT = 'ns'\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def init_sim(dut):\n    dut.reset_n.value = 1\n    dut.encdec.value = 0\n    dut.next.value = 0\n    dut.key.value = 0\n    dut.block.value = 0\n\nasync def reset_dut(dut):\n    dut.reset_n.value = 0\n    await Timer(2 * CLK_PERIOD, units=CLK_TIME_UNIT)\n    dut.reset_n.value = 1\n\nasync def wait_ready(dut):\n    while dut.ready.value.integer != 1:\n        await FallingEdge(dut.clk)\n\nasync def block_test(dut, key: BinaryValue, block: BinaryValue, ciphertext: BinaryValue):\n    dut.key.value = key\n    dut.encdec.value = 1\n    dut.block.value = block\n    dut.next.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.next.value = 0\n    await wait_ready(dut)\n\n    assert dut.result.value == ciphertext, \"didn't get the expected ciphertext result\"\n\n    dut.block.value = ciphertext\n    dut.encdec.value = 0\n    dut.next.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.next.value = 0\n    await wait_ready(dut)\n\n    assert dut.result.value == block, \"didn't get the expected block result\"\n", "src/test_prince_core.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.binary import BinaryValue\nimport harness_library as hrs_lb\n\n\n@cocotb.test()\nasync def test_dut(dut):\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_dut...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    # test(1, 128'h00000000_00000000_00000000_00000000,\n    #      64'h00000000_00000000, 64'h818665aa_0d02dfda);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('00000000000000000000000000000000', 16), 128, False),\n        BinaryValue(int('0000000000000000', 16), 64, False),\n        BinaryValue(int('818665aa0d02dfda', 16), 64, False)\n    )\n\n    # test(2, 128'h00000000_00000000_00000000_00000000,\n    #      64'hffffffff_ffffffff, 64'h604ae6ca_03c20ada);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('00000000000000000000000000000000', 16), 128, False),\n        BinaryValue(int('ffffffffffffffff', 16), 64, False),\n        BinaryValue(int('604ae6ca03c20ada', 16), 64, False)\n    )\n\n    # test(3, 128'hffffffff_ffffffff_00000000_00000000,\n    #      64'h00000000_00000000, 64'h9fb51935_fc3df524);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('ffffffffffffffff0000000000000000', 16), 128, False),\n        BinaryValue(int('0000000000000000', 16), 64, False),\n        BinaryValue(int('9fb51935fc3df524', 16), 64, False)\n    )\n\n    # test(4, 128'h00000000_00000000_ffffffff_ffffffff,\n    #      64'h00000000_00000000, 64'h78a54cbe_737bb7ef);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0000000000000000ffffffffffffffff', 16), 128, False),\n        BinaryValue(int('0000000000000000', 16), 64, False),\n        BinaryValue(int('78a54cbe737bb7ef', 16), 64, False)\n    )\n\n    # test(5, 128'h00000000_00000000_fedcba98_76543210,\n    #      64'h01234567_89abcdef, 64'hae25ad3c_a8fa9ccf);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0000000000000000fedcba9876543210', 16), 128, False),\n        BinaryValue(int('0123456789abcdef', 16), 64, False),\n        BinaryValue(int('ae25ad3ca8fa9ccf', 16), 64, False)\n    )\n\n    # test(6, 128'h00112233_44556677_8899aabb_ccddeeff,\n    #      64'h01234567_89abcdef, 64'hd6dcb597_8de756ee);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('00112233445566778899aabbccddeeff', 16), 128, False),\n        BinaryValue(int('0123456789abcdef', 16), 64, False),\n        BinaryValue(int('d6dcb5978de756ee', 16), 64, False)\n    )\n\n    # test(7, 128'h01122334_45566778_899aabbc_cddeeff0,\n    #      64'h01234567_89abcdef, 64'h392f599f_46761cd3);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0112233445566778899aabbccddeeff0', 16), 128, False),\n        BinaryValue(int('0123456789abcdef', 16), 64, False),\n        BinaryValue(int('392f599f46761cd3', 16), 64, False)\n    )\n\n    # test(8, 128'h01122334_45566778_899aabbc_cddeeff0,\n    #      64'hf0123456_789abcde, 64'h4fb5e332_b9b409bb);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0112233445566778899aabbccddeeff0', 16), 128, False),\n        BinaryValue(int('f0123456789abcde', 16), 64, False),\n        BinaryValue(int('4fb5e332b9b409bb', 16), 64, False)\n    )\n\n    #\n    # test(9, 128'hd8cdb780_70b4c55a_818665aa_0d02dfda,\n    #      64'h69c4e0d8_6a7b0430, 64'h43c6b256_d79de7e8);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('d8cdb78070b4c55a818665aa0d02dfda', 16), 128, False),\n        BinaryValue(int('69c4e0d86a7b0430', 16), 64, False),\n        BinaryValue(int('43c6b256d79de7e8', 16), 64, False)\n    )\n\n    cocotb.log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nimport pytest\nimport coverage\nimport random\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef call_runner():\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.covt_report_clear()\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter={}\n        )\n        coverage.coverage_report(\"assertion\")\n        coverage.covt_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n    # Run the simulation\n    call_runner()\n"}}}
{"id": "cvdp_copilot_crypto_0022", "categories": ["cid014", "medium"], "input": {"prompt": "Elaborate on assertion properties to ensure that the `CTRL_UPDATE` state of the `prince_core` module's FSM is safe. The properties should check the following:\n\n1. The `CTRL_UPDATE` state must be reachable from a valid previous state when the design is ready and a new computation starts, assuming the necessary clock cycles have elapsed.\n2. After reaching the `CTRL_UPDATE` state, the design must be ready for a new computation in the next cycle.\n3. The design must transition to a new state in the cycle following its entry into the `CTRL_UPDATE` state.\n\nThe following requirements must be addressed:\n- The properties must be placed in a separate module named `prince_core_update_state_safety_check`, which instantiates `prince_core` as the DUT (Device Under Test) for verification.\n- The properties must directly reference internal DUT signals to perform verification.\n\n---\n\n### **Design Specification: `prince_core`**\n\n#### **Inputs:**  \n- **clk**: System clock (rising edge).  \n- **reset_n**: Active-low asynchronous reset.  \n- **encdec**: Mode selection (1 = encryption, 0 = decryption).  \n- **next**: Starts encryption/decryption when asserted.  \n- **key** (`[127:0]`): 128-bit encryption key.  \n- **block** (`[63:0]`): 64-bit input (plaintext or ciphertext).  \n\n#### **Outputs:**  \n- **ready**: High when the core is idle and ready for a new operation.  \n- **result** (`[63:0]`): 64-bit processed output (ciphertext or plaintext).  \n\n---\n\n### **Functional Overview:**  \n- Implements **PRINCE**, a lightweight 64-bit block cipher with a **128-bit key**.  \n- Uses a **12-round transformation**, split into forward and inverse rounds for encryption and decryption.  \n- Computes the result over multiple clock cycles, updating internal registers.  \n- The **FSM state** is controlled by:  \n  - `core_ctrl_reg`: Holds the current state.  \n  - `core_ctrl_new`: Stores the next state before updating.  \n\n---\n\n### **FSM (Finite State Machine) States:**  \n1. **CTRL_IDLE**: Waits for `next` to start processing. (`ready = 1`)  \n2. **CTRL_PIPE0 \u2192 CTRL_PIPE1 \u2192 CTRL_PIPE2**: Sequential processing stages applying encryption/decryption transformations.  \n3. **CTRL_UPDATE**: Writes the final result, sets `ready = 1`, and returns to `CTRL_IDLE`.  \n\n`core_ctrl_reg` updates to `core_ctrl_new` on each clock cycle when a transition occurs.  \n\n---\n\n### **Signal Behavior:**  \n\n| **Signal**   | **Description**                               |\n|--------------|-----------------------------------------------|\n| **clk**      | Drives all internal operations.               |\n| **reset_n**  | Resets internal registers.                    |\n| **next**     | Triggers processing when asserted.            |\n| **encdec**   | Selects encryption (`1`) or decryption (`0`). |\n| **key**      | 128-bit secret key.                           |\n| **block**    | Input data (plaintext/ciphertext).            |\n| **ready**    | High when idle, low during processing.        |\n| **result**   | Outputs the processed 64-bit data.            |\n\n---\n\n### **Processing Flow:**  \n1. **Idle:** `ready = 1`, waits for `next`.  \n2. **Pipeline Processing:** Transitions through `PIPE0 \u2192 PIPE1 \u2192 PIPE2`.  \n3. **Update:** Stores result, sets `ready = 1`, returns to `CTRL_IDLE`.  \n\n**Key Features:**  \n- **Low-latency:** Optimized for fast encryption/decryption.  \n- **Encryption & Decryption Support:** Controlled via `encdec`.  \n- **FSM Control:** `core_ctrl_reg` determines state transitions.  \n- **Internal Key Schedule:** Uses `k0`, `k1`, and derived `kp` for transformations.  \n\n---\n\n### **Note:**  \n- An **assertion failure** must include a **descriptive error message** to aid debugging.  ", "context": {"rtl/prince_core.v": "//======================================================================\n//\n// prince_core.v\n// -------------\n// Prince block cipher core.\n//\n//\n// Author: Joachim Strombergson\n// Copyright (c) 2019, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\n`default_nettype none\n\nmodule prince_core(\n                   input wire           clk,\n                   input wire           reset_n,\n\n                   input wire           encdec,\n                   input wire           next,\n                   output wire          ready,\n\n                   input wire [127 : 0] key,\n\n                   input wire [63 : 0]  block,\n                   output wire [63 : 0] result\n                  );\n\n\n  //----------------------------------------------------------------\n  // Internal constant and parameter definitions.\n  //----------------------------------------------------------------\n  localparam CTRL_IDLE   = 3'h0;\n  localparam CTRL_PIPE0  = 3'h1;\n  localparam CTRL_PIPE1  = 3'h2;\n  localparam CTRL_PIPE2  = 3'h3;\n  localparam CTRL_UPDATE = 3'h4;\n\n  localparam ALPHA = 64'hc0ac29b7c97c50dd;\n\n\n  //----------------------------------------------------------------\n  // Registers including update variables and write enable.\n  //----------------------------------------------------------------\n  reg [63 : 0] k0_reg;\n  reg [63 : 0] k0_new;\n  reg [63 : 0] k1_reg;\n  reg [63 : 0] k1_new;\n  reg [63 : 0] kp_reg;\n  reg [63 : 0] kp_new;\n  reg          k_we;\n\n  reg          ready_reg;\n  reg          ready_new;\n  reg          ready_we;\n\n  reg [63 : 0] state_reg;\n  reg [63 : 0] state_new;\n  reg          state_we;\n\n  reg [63 : 0] r3_reg;\n  reg [63 : 0] r3_new;\n\n  reg [63 : 0] r8_reg;\n  reg [63 : 0] r8_new;\n\n  reg [63 : 0] mr_reg;\n  reg [63 : 0] mr_new;\n\n  reg [2 : 0]  core_ctrl_reg;\n  reg [2 : 0]  core_ctrl_new;\n  reg          core_ctrl_we;\n\n\n  //----------------------------------------------------------------\n  // Wires.\n  //----------------------------------------------------------------\n  reg init_state;\n  reg update_state;\n\n\n  //----------------------------------------------------------------\n  // Concurrent connectivity for ports etc.\n  //----------------------------------------------------------------\n  assign ready  = ready_reg;\n  assign result = state_reg;\n\n\n  //----------------------------------------------------------------\n  // Internal functions.\n  //----------------------------------------------------------------\n//`include \"prince_round_functions.vh\"\n\n\n  //----------------------------------------------------------------\n  // reg_update\n  //\n  // Update functionality for all registers in the core.\n  // All registers are positive edge triggered with asynchronous\n  // active low reset.\n  //----------------------------------------------------------------\n  always @ (posedge clk or negedge reset_n)\n    begin: reg_update\n      if (!reset_n)\n        begin\n          ready_reg     <= 1'h1;\n          k0_reg        <= 64'h0;\n          k1_reg        <= 64'h0;\n          kp_reg        <= 64'h0;\n          r3_reg        <= 64'h0;\n          r8_reg        <= 64'h0;\n          mr_reg        <= 64'h0;\n          state_reg     <= 64'h0;\n          core_ctrl_reg <= CTRL_IDLE;\n        end\n      else\n        begin\n          r3_reg <= r3_new;\n          r8_reg <= r8_new;\n          mr_reg <= mr_new;\n\n          if (ready_we)\n            ready_reg <= ready_new;\n\n          if (state_we)\n            state_reg <= state_new;\n\n          if (k_we)\n            begin\n              k0_reg <= k0_new;\n              k1_reg <= k1_new;\n              kp_reg <= kp_new;\n            end\n\n          if (core_ctrl_we)\n            core_ctrl_reg <= core_ctrl_new;\n        end\n    end // reg_update\n\n\n  //----------------------------------------------------------------\n  // prince_core_dp\n  //\n  // Datapath with state update logic.\n  //----------------------------------------------------------------\n  always @*\n    begin : prince_core_dp\n\n      reg [63 : 0] core_input;\n      reg [63 : 0] core_output;\n\n      reg [63 : 0] r0;\n      reg [63 : 0] r1;\n      reg [63 : 0] r2;\n      reg [63 : 0] r4;\n      reg [63 : 0] r5;\n      reg [63 : 0] r6;\n      reg [63 : 0] r7;\n      reg [63 : 0] r9;\n      reg [63 : 0] r10;\n      reg [63 : 0] r11;\n\n      state_new = 64'h0;\n      state_we  = 1'h0;\n      k0_new    = 64'h0;\n      k1_new    = 64'h0;\n      kp_new    = 64'h0;\n      k_we      = 1'h0;\n\n\n      // Pipeline stages.\n      core_input = state_reg ^ k0_reg;\n      r0 = round0(core_input, k1_reg);\n      r1 = round(r0, k1_reg, 1);\n      r2 = round(r1, k1_reg, 2);\n      r3_new = round(r2, k1_reg, 3);\n\n      r4 = round(r3_reg, k1_reg, 4);\n      r5 = round(r4, k1_reg, 5);\n      mr_new = middle_round(r5);\n\n      r6 = iround(mr_reg, k1_reg, 6);\n      r7 = iround(r6, k1_reg, 7);\n      r8_new = iround(r7, k1_reg, 8);\n\n      r9  = iround(r8_reg, k1_reg, 9);\n      r10 = iround(r9, k1_reg, 10);\n      r11 = round11(r10, k1_reg);\n      core_output = r11 ^ kp_reg;\n\n\n      if (init_state)\n        begin\n          k_we      = 1'h1;\n          state_new = block;\n          state_we  = 1'h1;\n\n          if (encdec)\n            begin\n              k0_new = key[127 : 64];\n              kp_new = {k0_new[0], k0_new[63 : 2], (k0_new[1] ^ k0_new[63])};\n              k1_new = key[63 : 0];\n            end\n          else\n            begin\n              kp_new = key[127 : 64];\n              k0_new = {kp_new[0], kp_new[63 : 2], (kp_new[1] ^ kp_new[63])};\n              k1_new = key[63 : 0] ^ ALPHA;\n            end\n        end\n\n      if (update_state)\n        begin\n          state_new = core_output;\n          state_we  = 1'h1;\n        end\n    end // prince_core_dp\n\n\n  //----------------------------------------------------------------\n  // prince_core_ctrl\n  //\n  // Control FSM for aes core.\n  //----------------------------------------------------------------\n  always @*\n    begin : prince_core_ctrl\n      ready_new     = 1'h0;\n      ready_we      = 1'h0;\n      init_state    = 1'h0;\n      update_state  = 1'h0;\n      core_ctrl_new = CTRL_IDLE;\n      core_ctrl_we  = 1'h0;\n\n      case (core_ctrl_reg)\n        CTRL_IDLE:\n          begin\n            if (next)\n              begin\n                ready_new     = 1'h0;\n                ready_we      = 1'h1;\n                init_state    = 1'h1;\n                core_ctrl_new = CTRL_PIPE0;\n                core_ctrl_we  = 1'h1;\n              end\n          end\n\n        CTRL_PIPE0:\n          begin\n            core_ctrl_new = CTRL_PIPE1;\n            core_ctrl_we  = 1'h1;\n          end\n\n        CTRL_PIPE1:\n          begin\n            core_ctrl_new = CTRL_PIPE2;\n            core_ctrl_we  = 1'h1;\n          end\n\n        CTRL_PIPE2:\n          begin\n            core_ctrl_new = CTRL_UPDATE;\n            core_ctrl_we  = 1'h1;\n          end\n\n        CTRL_UPDATE:\n          begin\n            ready_new     = 1'h1;\n            ready_we      = 1'h1;\n            update_state  = 1'h1;\n            core_ctrl_new = CTRL_IDLE;\n            core_ctrl_we  = 1'h1;\n          end\n\n        default:\n          begin\n          end\n      endcase // case (core_ctrl_reg)\n    end // prince_core_ctrl\n\nendmodule // prince_core\n\n//======================================================================\n// EOF prince_core.v\n//======================================================================", "rtl/prince_round_functions.vh": "//======================================================================\n//\n// prince_round_functions.v\n// ------------------------\n// Functions used in the prince core.\n//\n//\n// Author: Joachim Strombergson\n// Copyright (c) 2023, Assured AB\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the following\n// conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in\n//    the documentation and/or other materials provided with the\n//    distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//======================================================================\n\n  function [3 : 0] sb(input [3 : 0] x);\n    case(x)\n      4'h0: sb = 4'hb;\n      4'h1: sb = 4'hf;\n      4'h2: sb = 4'h3;\n      4'h3: sb = 4'h2;\n      4'h4: sb = 4'ha;\n      4'h5: sb = 4'hc;\n      4'h6: sb = 4'h9;\n      4'h7: sb = 4'h1;\n      4'h8: sb = 4'h6;\n      4'h9: sb = 4'h7;\n      4'ha: sb = 4'h8;\n      4'hb: sb = 4'h0;\n      4'hc: sb = 4'he;\n      4'hd: sb = 4'h5;\n      4'he: sb = 4'hd;\n      4'hf: sb = 4'h4;\n    endcase // case (x)\n  endfunction // sb\n\n  function [63 : 0] s(input [63 : 0] x);\n    s = {sb(x[63 : 60]), sb(x[59 : 56]),\n         sb(x[55 : 52]), sb(x[51 : 48]),\n         sb(x[47 : 44]), sb(x[43 : 40]),\n         sb(x[39 : 36]), sb(x[35 : 32]),\n         sb(x[31 : 28]), sb(x[27 : 24]),\n         sb(x[23 : 20]), sb(x[19 : 16]),\n         sb(x[15 : 12]), sb(x[11 : 08]),\n         sb(x[07 : 04]), sb(x[03 : 00])};\n  endfunction // s\n\n  function [3 : 0] isb(input [3 : 0] x);\n    case(x)\n      4'h0: isb = 4'hb;\n      4'h1: isb = 4'h7;\n      4'h2: isb = 4'h3;\n      4'h3: isb = 4'h2;\n      4'h4: isb = 4'hf;\n      4'h5: isb = 4'hd;\n      4'h6: isb = 4'h8;\n      4'h7: isb = 4'h9;\n      4'h8: isb = 4'ha;\n      4'h9: isb = 4'h6;\n      4'ha: isb = 4'h4;\n      4'hb: isb = 4'h0;\n      4'hc: isb = 4'h5;\n      4'hd: isb = 4'he;\n      4'he: isb = 4'hc;\n      4'hf: isb = 4'h1;\n    endcase // case (x)\n  endfunction // isb\n\n  function [63 : 0] si(input [63 : 0] x);\n    si = {isb(x[63 : 60]), isb(x[59 : 56]),\n          isb(x[55 : 52]), isb(x[51 : 48]),\n          isb(x[47 : 44]), isb(x[43 : 40]),\n          isb(x[39 : 36]), isb(x[35 : 32]),\n          isb(x[31 : 28]), isb(x[27 : 24]),\n          isb(x[23 : 20]), isb(x[19 : 16]),\n          isb(x[15 : 12]), isb(x[11 : 08]),\n          isb(x[07 : 04]), isb(x[03 : 00])};\n  endfunction // si\n\n  function [63 : 0] rc(input [3 : 0] round);\n    begin\n      case(round)\n        00: rc = 64'h0000000000000000;\n        01: rc = 64'h13198a2e03707344;\n        02: rc = 64'ha4093822299f31d0;\n        03: rc = 64'h082efa98ec4e6c89;\n        04: rc = 64'h452821e638d01377;\n        05: rc = 64'hbe5466cf34e90c6c;\n        06: rc = 64'h7ef84f78fd955cb1;\n        07: rc = 64'h85840851f1ac43aa;\n        08: rc = 64'hc882d32f25323c54;\n        09: rc = 64'h64a51195e0e3610d;\n        10: rc = 64'hd3b5a399ca0c2399;\n        11: rc = 64'hc0ac29b7c97c50dd;\n        default:\n          rc = 64'h0;\n      endcase // case (round)\n    end\n  endfunction // rc\n\n  function [63 : 0] mp(input [63 : 0] b);\n    begin\n      mp[63] = b[59] ^ b[55] ^ b[51];\n      mp[62] = b[62] ^ b[54] ^ b[50];\n      mp[61] = b[61] ^ b[57] ^ b[49];\n      mp[60] = b[60] ^ b[56] ^ b[52];\n      mp[59] = b[63] ^ b[59] ^ b[55];\n      mp[58] = b[58] ^ b[54] ^ b[50];\n      mp[57] = b[61] ^ b[53] ^ b[49];\n      mp[56] = b[60] ^ b[56] ^ b[48];\n      mp[55] = b[63] ^ b[59] ^ b[51];\n      mp[54] = b[62] ^ b[58] ^ b[54];\n      mp[53] = b[57] ^ b[53] ^ b[49];\n      mp[52] = b[60] ^ b[52] ^ b[48];\n      mp[51] = b[63] ^ b[55] ^ b[51];\n      mp[50] = b[62] ^ b[58] ^ b[50];\n      mp[49] = b[61] ^ b[57] ^ b[53];\n      mp[48] = b[56] ^ b[52] ^ b[48];\n      mp[47] = b[47] ^ b[43] ^ b[39];\n      mp[46] = b[42] ^ b[38] ^ b[34];\n      mp[45] = b[45] ^ b[37] ^ b[33];\n      mp[44] = b[44] ^ b[40] ^ b[32];\n      mp[43] = b[47] ^ b[43] ^ b[35];\n      mp[42] = b[46] ^ b[42] ^ b[38];\n      mp[41] = b[41] ^ b[37] ^ b[33];\n      mp[40] = b[44] ^ b[36] ^ b[32];\n      mp[39] = b[47] ^ b[39] ^ b[35];\n      mp[38] = b[46] ^ b[42] ^ b[34];\n      mp[37] = b[45] ^ b[41] ^ b[37];\n      mp[36] = b[40] ^ b[36] ^ b[32];\n      mp[35] = b[43] ^ b[39] ^ b[35];\n      mp[34] = b[46] ^ b[38] ^ b[34];\n      mp[33] = b[45] ^ b[41] ^ b[33];\n      mp[32] = b[44] ^ b[40] ^ b[36];\n      mp[31] = b[31] ^ b[27] ^ b[23];\n      mp[30] = b[26] ^ b[22] ^ b[18];\n      mp[29] = b[29] ^ b[21] ^ b[17];\n      mp[28] = b[28] ^ b[24] ^ b[16];\n      mp[27] = b[31] ^ b[27] ^ b[19];\n      mp[26] = b[30] ^ b[26] ^ b[22];\n      mp[25] = b[25] ^ b[21] ^ b[17];\n      mp[24] = b[28] ^ b[20] ^ b[16];\n      mp[23] = b[31] ^ b[23] ^ b[19];\n      mp[22] = b[30] ^ b[26] ^ b[18];\n      mp[21] = b[29] ^ b[25] ^ b[21];\n      mp[20] = b[24] ^ b[20] ^ b[16];\n      mp[19] = b[27] ^ b[23] ^ b[19];\n      mp[18] = b[30] ^ b[22] ^ b[18];\n      mp[17] = b[29] ^ b[25] ^ b[17];\n      mp[16] = b[28] ^ b[24] ^ b[20];\n      mp[15] = b[11] ^ b[07] ^ b[03];\n      mp[14] = b[14] ^ b[06] ^ b[02];\n      mp[13] = b[13] ^ b[09] ^ b[01];\n      mp[12] = b[12] ^ b[08] ^ b[04];\n      mp[11] = b[15] ^ b[11] ^ b[07];\n      mp[10] = b[10] ^ b[06] ^ b[02];\n      mp[09] = b[13] ^ b[05] ^ b[01];\n      mp[08] = b[12] ^ b[08] ^ b[00];\n      mp[07] = b[15] ^ b[11] ^ b[03];\n      mp[06] = b[14] ^ b[10] ^ b[06];\n      mp[05] = b[09] ^ b[05] ^ b[01];\n      mp[04] = b[12] ^ b[04] ^ b[00];\n      mp[03] = b[15] ^ b[07] ^ b[03];\n      mp[02] = b[14] ^ b[10] ^ b[02];\n      mp[01] = b[13] ^ b[09] ^ b[05];\n      mp[00] = b[08] ^ b[04] ^ b[00];\n    end\n  endfunction // mp\n\n  function [63 : 0] m(input [63 : 0] b);\n    begin : m_func\n      reg [63 : 0] t;\n      t = mp(b);\n\n      m = {t[63 : 60], t[43 : 40], t[23 : 20], t[03 : 00],\n           t[47 : 44], t[27 : 24], t[07 : 04], t[51 : 48],\n           t[31 : 28], t[11 : 08], t[55 : 52], t[35 : 32],\n           t[15 : 12], t[59 : 56], t[39 : 36], t[19 : 16]};\n    end\n  endfunction // m\n\n  function [63 : 0] mi(input [63 : 0] b);\n    begin : mi_func\n      reg [63 : 0] t;\n\n      t = {b[63 : 60], b[11 : 08], b[23 : 20], b[35 : 32],\n           b[47 : 44], b[59 : 56], b[07 : 04], b[19 : 16],\n           b[31 : 28], b[43 : 40], b[55 : 52], b[03 : 00],\n           b[15 : 12], b[27 : 24], b[39 : 36], b[51 : 48]};\n\n      mi = mp(t);\n    end\n  endfunction // m\n\n  function [63 : 0] round0(input [63 : 0] b, input [63 : 0] k);\n    begin\n      round0 = b ^ k ^ rc(0);\n    end\n  endfunction // round0\n\n  function [63 : 0] round11(input [63 : 0] b, input [63 : 0] k);\n    begin\n      round11 =  b ^ k ^ rc(11);\n    end\n  endfunction // round11\n\n  function [63 : 0] round(input [63 : 0] b, input [63 : 0] k, input [3 : 0] n);\n    begin\n      round = m(s(b)) ^ rc(n) ^ k;\n    end\n  endfunction // round\n\n  function [63 : 0] middle_round(input [63 : 0] b);\n    begin\n      middle_round = si(mp(s(b)));\n    end\n  endfunction // middle_round\n\n  function [63 : 0] iround(input [63 : 0] b, input [63 : 0] k, input [3 : 0] n);\n    begin\n      iround = si(mi(rc(n) ^ k ^ b));\n    end\n  endfunction // iround\n\n//======================================================================\n// EOF prince_round_functions.vh\n//======================================================================", "verif/prince_core_update_state_safety_check.sv": "module prince_core_update_state_safety_check (\n    input wire           clk,\n    input wire           reset_n,\n    input wire           encdec,\n    input wire           next,\n    output wire          ready,\n    input wire [127 : 0] key,\n    input wire [63 : 0]  block,\n    output wire [63 : 0] result\n);\n\n    prince_core dut (\n        .clk(clk),\n        .reset_n(reset_n),\n        .encdec(encdec),\n        .next(next),\n        .ready(ready),\n        .key(key),\n        .block(block),\n        .result(result)\n    );\n\nendmodule : prince_core_update_state_safety_check"}}, "output": {"response": "", "context": {"verif/prince_core_update_state_safety_check.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    image: verification_image\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/verif/prince_core_update_state_safety_check.sv /code/rtl/prince_core.v /code/rtl/prince_round_functions.vh\nTOPLEVEL        = prince_core_update_state_safety_check\nMODULE          = test_prince_core\nPYTHONPATH      = /src\nHASH            = b7f087632e76423cb75981b16e6e9aa1018f78d1", "src/coverage.py": "from cocotb.runner import get_runner\nimport os\nimport aes\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_clear():\n    covt_report_file=\"/code/rundir/coverage.log\"\n    if os.path.isfile(covt_report_file):\n        os.remove(covt_report_file)\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n", "src/harness_library.py": "\nfrom cocotb.binary import BinaryValue\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\n\nCLK_HALF_PERIOD = 1\nCLK_PERIOD = CLK_HALF_PERIOD * 2\nCLK_TIME_UNIT = 'ns'\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def init_sim(dut):\n    dut.reset_n.value = 1\n    dut.encdec.value = 0\n    dut.next.value = 0\n    dut.key.value = 0\n    dut.block.value = 0\n\nasync def reset_dut(dut):\n    dut.reset_n.value = 0\n    await Timer(2 * CLK_PERIOD, units=CLK_TIME_UNIT)\n    dut.reset_n.value = 1\n\nasync def wait_ready(dut):\n    while dut.ready.value.integer != 1:\n        await FallingEdge(dut.clk)\n\nasync def block_test(dut, key: BinaryValue, block: BinaryValue, ciphertext: BinaryValue):\n    dut.key.value = key\n    dut.encdec.value = 1\n    dut.block.value = block\n    dut.next.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.next.value = 0\n    await wait_ready(dut)\n\n    assert dut.result.value == ciphertext, \"didn't get the expected ciphertext result\"\n\n    dut.block.value = ciphertext\n    dut.encdec.value = 0\n    dut.next.value = 1\n    await Timer(CLK_PERIOD, units=CLK_TIME_UNIT)\n\n    dut.next.value = 0\n    await wait_ready(dut)\n\n    assert dut.result.value == block, \"didn't get the expected block result\"\n", "src/test_prince_core.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.binary import BinaryValue\nimport harness_library as hrs_lb\n\n\n@cocotb.test()\nasync def test_dut(dut):\n    \"\"\"Main test function to call all tests.\"\"\"\n    cocotb.log.setLevel(\"DEBUG\")\n    cocotb.log.info(\"Starting test_dut...\")\n\n    await hrs_lb.dut_init(dut)\n    await cocotb.start(Clock(dut.clk, hrs_lb.CLK_PERIOD, units=hrs_lb.CLK_TIME_UNIT).start(start_high=False))\n\n    await hrs_lb.init_sim(dut)\n    await hrs_lb.reset_dut(dut)\n\n    # test(1, 128'h00000000_00000000_00000000_00000000,\n    #      64'h00000000_00000000, 64'h818665aa_0d02dfda);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('00000000000000000000000000000000', 16), 128, False),\n        BinaryValue(int('0000000000000000', 16), 64, False),\n        BinaryValue(int('818665aa0d02dfda', 16), 64, False)\n    )\n\n    # test(2, 128'h00000000_00000000_00000000_00000000,\n    #      64'hffffffff_ffffffff, 64'h604ae6ca_03c20ada);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('00000000000000000000000000000000', 16), 128, False),\n        BinaryValue(int('ffffffffffffffff', 16), 64, False),\n        BinaryValue(int('604ae6ca03c20ada', 16), 64, False)\n    )\n\n    # test(3, 128'hffffffff_ffffffff_00000000_00000000,\n    #      64'h00000000_00000000, 64'h9fb51935_fc3df524);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('ffffffffffffffff0000000000000000', 16), 128, False),\n        BinaryValue(int('0000000000000000', 16), 64, False),\n        BinaryValue(int('9fb51935fc3df524', 16), 64, False)\n    )\n\n    # test(4, 128'h00000000_00000000_ffffffff_ffffffff,\n    #      64'h00000000_00000000, 64'h78a54cbe_737bb7ef);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0000000000000000ffffffffffffffff', 16), 128, False),\n        BinaryValue(int('0000000000000000', 16), 64, False),\n        BinaryValue(int('78a54cbe737bb7ef', 16), 64, False)\n    )\n\n    # test(5, 128'h00000000_00000000_fedcba98_76543210,\n    #      64'h01234567_89abcdef, 64'hae25ad3c_a8fa9ccf);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0000000000000000fedcba9876543210', 16), 128, False),\n        BinaryValue(int('0123456789abcdef', 16), 64, False),\n        BinaryValue(int('ae25ad3ca8fa9ccf', 16), 64, False)\n    )\n\n    # test(6, 128'h00112233_44556677_8899aabb_ccddeeff,\n    #      64'h01234567_89abcdef, 64'hd6dcb597_8de756ee);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('00112233445566778899aabbccddeeff', 16), 128, False),\n        BinaryValue(int('0123456789abcdef', 16), 64, False),\n        BinaryValue(int('d6dcb5978de756ee', 16), 64, False)\n    )\n\n    # test(7, 128'h01122334_45566778_899aabbc_cddeeff0,\n    #      64'h01234567_89abcdef, 64'h392f599f_46761cd3);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0112233445566778899aabbccddeeff0', 16), 128, False),\n        BinaryValue(int('0123456789abcdef', 16), 64, False),\n        BinaryValue(int('392f599f46761cd3', 16), 64, False)\n    )\n\n    # test(8, 128'h01122334_45566778_899aabbc_cddeeff0,\n    #      64'hf0123456_789abcde, 64'h4fb5e332_b9b409bb);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('0112233445566778899aabbccddeeff0', 16), 128, False),\n        BinaryValue(int('f0123456789abcde', 16), 64, False),\n        BinaryValue(int('4fb5e332b9b409bb', 16), 64, False)\n    )\n\n    #\n    # test(9, 128'hd8cdb780_70b4c55a_818665aa_0d02dfda,\n    #      64'h69c4e0d8_6a7b0430, 64'h43c6b256_d79de7e8);\n    await hrs_lb.block_test(\n        dut,\n        BinaryValue(int('d8cdb78070b4c55a818665aa0d02dfda', 16), 128, False),\n        BinaryValue(int('69c4e0d86a7b0430', 16), 64, False),\n        BinaryValue(int('43c6b256d79de7e8', 16), 64, False)\n    )\n\n    cocotb.log.info(\"All tests passed.\")\n", "src/test_runner.py": "import os\nimport pytest\nimport coverage\nimport random\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef call_runner():\n    encoder_in = random.randint(0, 255)\n    plusargs = [f'+encoder_in={encoder_in}']\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        coverage.covt_report_clear()\n        coverage.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter={}\n        )\n        coverage.coverage_report(\"assertion\")\n        coverage.covt_report_check()\n    except SystemExit:\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n@pytest.mark.parametrize(\"test\", range(1))\ndef test_data(test):\n    # Run the simulation\n    call_runner()\n"}}}
{"id": "cvdp_copilot_decoder_8b10b_0021", "categories": ["cid014", "easy"], "input": {"prompt": "We have an 8b10b decoder module, `decoder_8b10b`, which receives a 10\u2010bit input (`decoder_in`) and outputs an 8\u2010bit decoded value (`decoder_out`) plus a 1\u2010bit control flag (`control_out`). The decoder logic uses a `decode_8b10b()` function, mapping certain valid 10\u2010bit patterns to a specific 8\u2010bit code (and setting the control bit to `1`). Any 10\u2010bit pattern not recognized results in `control_out == 0` and `decoder_out == 8\u2019h00`.  \n\n| **10-bit Input**      | **8-bit Output** | **Symbol** | **DEC Value** | **HEX Value** |\n|-----------------------|------------------|------------|---------------|---------------|\n| 001111 0100           | 000 11100        | K.28.0     | 28            | 1C            |\n| 110000 1011           | 000 11100        | K.28.0     | 28            | 1C            |\n| 001111 1001           | 001 11100        | K.28.1     | 60            | 3C            |\n| 110000 0110           | 001 11100        | K.28.1     | 60            | 3C            |\n| 001111 0101           | 010 11100        | K.28.2     | 92            | 5C            |\n| 110000 1010           | 010 11100        | K.28.2     | 92            | 5C            |\n| 001111 0011           | 011 11100        | K.28.3     | 124           | 7C            |\n| 110000 1100           | 011 11100        | K.28.3     | 124           | 7C            |\n| 001111 0010           | 100 11100        | K.28.4     | 156           | 9C            |\n| 110000 1101           | 100 11100        | K.28.4     | 156           | 9C            |\n| 001111 1010           | 101 11100        | K.28.5     | 188           | BC            |\n| 110000 0101           | 101 11100        | K.28.5     | 188           | BC            |\n| 001111 0110           | 110 11100        | K.28.6     | 220           | DC            |\n| 110000 1001           | 110 11100        | K.28.6     | 220           | DC            |\n| 001111 1000           | 111 11100        | K.28.7     | 252           | FC            |\n| 110000 0111           | 111 11100        | K.28.7     | 252           | FC            |\n| 111010 1000           | 111 10111        | K.23.7     | 247           | F7            |\n| 000101 0111           | 111 10111        | K.23.7     | 247           | F7            |\n| 110110 1000           | 111 11011        | K.27.7     | 251           | FB            |\n| 001001 0111           | 111 11011        | K.27.7     | 251           | FB            |\n| 101110 1000           | 111 11101        | K.29.7     | 253           | FD            |\n| 010001 0111           | 111 11101        | K.29.7     | 253           | FD            |\n| 011110 1000           | 111 11110        | K.30.7     | 254           | FE            |\n| 100001 0111           | 111 11110        | K.30.7     | 254           | FE            |\n\nTo verify correct operation, we need two **Concurrent SystemVerilog assertions**:\n\n1. **Valid Output Range for Data Characters**  \n   If `control_out` is `0` (indicating a data character), then `decoder_out` must be within the valid 8-bit range (`8'h00` to `8'hFF`).  \n\n2. **Consistency Between Input and Output**  \n   If the input does not change between two consecutive clock cycles, then the output (`decoder_out` and `control_out`) must remain the same.  \n\nThese assertions ensure that the decoder behaves predictably and produces valid outputs for control characters while maintaining consistency for repeated inputs.\n\n---\n\n### **Inputs**:\n- `clk_in`: Positive\u2010edge clock.  \n- `reset_in`: Asynchronous reset (active high).  \n- `decoder_in[9:0]`: The 10\u2010bit encoded input to be decoded.\n\n### **Outputs**:\n- `decoder_out[7:0]`: The decoded 8\u2010bit output.  \n- `control_out`: Indicates if the decoded word is a recognized control code (`1`) or data (`0`).", "context": {"rtl/decoder_8b10b.sv": "module decoder_8b10b (\n    input  logic        clk_in,       // trigger on rising edge\n    input  logic        reset_in,     // reset_in, assert HI\n    input  logic [9:0]  decoder_in,   // 10bit input\n    output logic [7:0]  decoder_out,  // 8bit decoded output\n    output logic        control_out   // control char, assert HI for control words\n);\n\n    logic [9:0] s_in_10b_reg;  \n    logic [7:0] s_decoder_out; \n    logic       s_control_out;       \n\n    function automatic [8:0] decode_8b10b(input logic [9:0] in);\n        case (in)\n            // recognized patterns => top bit=1 (control_out), plus 8-bit code\n            10'b0011110100, 10'b1100001011: decode_8b10b = {1'b1, 8'h1C};\n            10'b0011110010, 10'b1100001101: decode_8b10b = {1'b1, 8'h9C};\n            10'b0011111000, 10'b1100000111: decode_8b10b = {1'b1, 8'hFC};\n            10'b1110101000, 10'b0001010111: decode_8b10b = {1'b1, 8'hF7};\n            10'b1101101000, 10'b0010010111: decode_8b10b = {1'b1, 8'hFB};\n            10'b1011101000, 10'b0100010111: decode_8b10b = {1'b1, 8'hFD};\n            10'b0111101000, 10'b1000010111: decode_8b10b = {1'b1, 8'hFE};\n            10'b0011111001, 10'b1100000110: decode_8b10b = {1'b1, 8'h3C};\n            10'b0011110101, 10'b1100001010: decode_8b10b = {1'b1, 8'h5C};\n            10'b0011110011, 10'b1100001100: decode_8b10b = {1'b1, 8'h7C};\n            10'b0011111010, 10'b1100000101: decode_8b10b = {1'b1, 8'hBC};\n            10'b0011110110, 10'b1100001001: decode_8b10b = {1'b1, 8'hDC};\n\n            // unrecognized pattern => top bit=0 (control_out=0), decoded=0\n            default: decode_8b10b = {1'b0, 8'b00000000};\n        endcase\n    endfunction\n\n    always_comb begin\n        {s_control_out, s_decoder_out} = decode_8b10b(s_in_10b_reg);\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            s_in_10b_reg <= 10'b0000000000;\n        end \n        else begin\n            s_in_10b_reg <= decoder_in;\n        end\n    end\n\n    assign decoder_out = s_decoder_out;\n    assign control_out = s_control_out;\nendmodule"}}, "output": {"response": "", "context": {"rtl/decoder_8b10b.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/decoder_8b10b.sv\nTOPLEVEL        = decoder_8b10b\nMODULE          = test_decoder_8b10b\nPYTHONPATH      = /src\nHASH            = 0c1a9be8b0ee7149733e3d41644a4879aa18e399\n", "src/test_decoder_8b10b.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nfrom collections import deque\n\n# Special character code values\nK28d0_RD0 = \"0011110100\"\nK28d0_RD1 = \"1100001011\"\nK28d1_RD0 = \"0011111001\"\nK28d1_RD1 = \"1100000110\"\nK28d2_RD0 = \"0011110101\"\nK28d2_RD1 = \"1100001010\"\nK28d3_RD0 = \"0011110011\"\nK28d3_RD1 = \"1100001100\"\nK28d4_RD0 = \"0011110010\"\nK28d4_RD1 = \"1100001101\"\nK28d5_RD0 = \"0011111010\"\nK28d5_RD1 = \"1100000101\"\nK28d6_RD0 = \"0011110110\"\nK28d6_RD1 = \"1100001001\"\nK28d7_RD0 = \"0011111000\"\nK28d7_RD1 = \"1100000111\"\nK23d7_RD0 = \"1110101000\"\nK23d7_RD1 = \"0001010111\"\nK27d7_RD0 = \"1101101000\"\nK27d7_RD1 = \"0010010111\"\nK29d7_RD0 = \"1011101000\"\nK29d7_RD1 = \"0100010111\"\nK30d7_RD0 = \"0111101000\"\nK30d7_RD1 = \"1000010111\"\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and start the clock.\"\"\"\n    dut.reset_in.value = 1\n    dut.decoder_in.value = 0\n\n    clock = Clock(dut.clk_in, 50, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    dut.reset_in.value = 0\n\nasync def check_output(dut, expected_value, expected_control, input_value):\n    \"\"\"Check the output of the DUT against the expected value.\"\"\"\n    expected_value_bin = f\"{int(expected_value, 16):08b}\"  # Convert hex to binary\n    print(f\"Expected: {hex(int(expected_value, 16)):>4}, Got: {hex(int(str(dut.decoder_out.value), 2)):>4}, Input: {input_value}\")\n    assert str(dut.decoder_out.value) == expected_value_bin, f\"Expected {expected_value_bin}, got {str(dut.decoder_out.value)}\"\n    assert dut.control_out.value == expected_control, f\"Expected control {expected_control}, got {dut.control_out.value}\"\n\ndef calculate_expected_value(codeword):\n    \"\"\"Calculate the expected value based on the 10-bit codeword.\"\"\"\n    if codeword in [K28d0_RD0, K28d0_RD1]:\n        return \"1C\"\n    elif codeword in [K28d1_RD0, K28d1_RD1]:\n        return \"3C\"\n    elif codeword in [K28d2_RD0, K28d2_RD1]:\n        return \"5C\"\n    elif codeword in [K28d3_RD0, K28d3_RD1]:\n        return \"7C\"\n    elif codeword in [K28d4_RD0, K28d4_RD1]:\n        return \"9C\"\n    elif codeword in [K28d5_RD0, K28d5_RD1]:\n        return \"BC\"\n    elif codeword in [K28d6_RD0, K28d6_RD1]:\n        return \"DC\"\n    elif codeword in [K28d7_RD0, K28d7_RD1]:\n        return \"FC\"\n    elif codeword in [K23d7_RD0, K23d7_RD1]:\n        return \"F7\"\n    elif codeword in [K27d7_RD0, K27d7_RD1]:\n        return \"FB\"\n    elif codeword in [K29d7_RD0, K29d7_RD1]:\n        return \"FD\"\n    elif codeword in [K30d7_RD0, K30d7_RD1]:\n        return \"FE\"\n    else:\n        return \"00\"\n\n@cocotb.test()\nasync def test_decoder_8b10b_reset(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols and reset HIGH.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        print(f\"Delayed decoder_in: {delayed_decoder_in}\")  # Debug print\n\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n    dut.reset_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    expected_value = \"00\"\n    expected_control = 0\n    await check_output(dut, expected_value, expected_control, \"0000000000\")\n\n@cocotb.test()\nasync def test_continuous_control_symbol(dut):\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(28):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n    await Timer(100, units=\"ns\")\n\n\n@cocotb.test()\nasync def test_random_control_symbol(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n@cocotb.test()\nasync def test_same_control_symbol(dut):\n    \"\"\"Test sending the same control symbol continuously.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d6_RD0, K28d6_RD1]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(20):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n@cocotb.test()\nasync def test_random_invalid_control_input(dut):\n    \"\"\"Test sending any 10-bit input other than 12 control symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_data = random.randint(0, 1023)\n        while f\"{random_data:010b}\" in control_symbols:\n            random_data = random.randint(0, 1023)\n        dut.decoder_in.value = random_data\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n    await Timer(100, units=\"ns\")\n\n@cocotb.test()\nasync def test_random_imbalanced_control_symbol(dut):\n    \"\"\"Test sending any random control symbol continuously out of 5 imbalanced symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(20):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_decoder_8b10b_0023", "categories": ["cid014", "medium"], "input": {"prompt": "Create SystemVerilog Assertions to verify the **functional correctness** of the `decoder_8b10b` module. The properties should ensure that:  \n\n1. **Valid Output for Data Characters**: When `control_out` is LOW, the `decoder_out` must be a valid 8-bit data value (i.e., within the range `8'h00` to `8'hFF`).  \n\n2. **Output Consistency for Repeated Inputs**: If the input (`s_in_10b_reg`) remains unchanged, the output (`decoder_out` and `control_out`) must also remain unchanged.  \n\n3. **Valid Output Follows Valid Input**: The `decoder_valid_out` signal must be asserted in the cycle immediately following a valid input (`decoder_valid_in`).  \n\n4. **Stable Output When No New Input**: If no new valid input is provided (`decoder_valid_in` is LOW), the `decoder_out` must remain stable.  \n\n5. **Control Symbol Detection**: When `control_in` is HIGH and `decoder_valid_in` is HIGH, the `s_control_out` signal must be asserted.  \n\n6. **No x or z in Outputs**: The outputs (`decoder_out`, `decoder_valid_out`, and `control_out`) must never contain unknown (`x`) or high-impedance (`z`) values.  \n\n7. **Invalid Control Codeword Detection**: When `control_in` is HIGH and `decoder_valid_out` is HIGH, the `decoder_out` must not be `8'h00` or `8'hFF`.  \n\nEach assertion must provide a **detailed failure message**, including the relevant signals and their values for debugging purposes.  \n\n---\n\n### RTL Specification  \n\n#### Module Name: `decoder_8b10b`\n\nThe 8b10b decoder is a digital circuit that converts a 10-bit encoded word back into its corresponding 8-bit data or control symbol. This decoder identifies whether the input is a control or data symbol and ensures the correct decoding of both types. The module must maintain compatibility with control symbols while extending its functionality to decode data symbols accurately.\n\n#### **Symbol Types**:\n- **Control Symbols**: These are special synchronization and protocol management symbols. Control symbols are indicated by the `control_in` signal being HIGH.\n- **Data Symbols**: These are standard 8-bit data inputs encoded as 10-bit words. Data symbols are indicated by the `control_in` signal being LOW.\n\n#### **Data Symbol Decoding Rules**\n\n1. **Data Symbol Decoding**:  \n   - Split the 10-bit encoded input into its 6-bit and 4-bit segments.\n   - Decode the 6-bit segment (`abcdei`) into 5 bits (`EDCBA`) and the 4-bit segment (`fghj`) into 3 bits (`HGF`).\n   - Combine the decoded results into the final 8-bit output.\n   - Set `control_out` LOW for data symbols.\n\n3. **Validation**:  \n   - Verify the 10-bit encoded input against the 8b/10b decoding rules.\n   - Invalidate the output (`decoder_valid_out = 0`) for invalid inputs.\n\n\n#### Decoding Tables\n\n\n#### **5b/6b Decoding Table**\n\nThe MSB 6-bit of the 10-bit input is mapped back to its corresponding 5-bit (`EDCBA`).\n\n| Encoded 6-bit (abcdei)       | Decoded 5-bit (EDCBA) |\n|------------------------------|-----------------------|\n| 100111, 011000               | 00000                 |\n| 011101, 100010               | 00001                 |\n| 101101, 010010               | 00010                 |\n| 110001                       | 00011                 |\n| 110101, 001010               | 00100                 |\n| 101001                       | 00101                 |\n| 011001                       | 00110                 |\n| 111000, 000111               | 00111                 |\n| 111001, 000110               | 01000                 |\n| 100101                       | 01001                 |\n| 010101                       | 01010                 |\n| 110100                       | 01011                 |\n| 001101                       | 01100                 |\n| 101100                       | 01101                 |\n| 011100                       | 01110                 |\n| 010111, 101000               | 01111                 |\n| 011011, 100100               | 10000                 |\n| 100011                       | 10001                 |\n| 010011                       | 10010                 |\n| 110010                       | 10011                 |\n| 001011                       | 10100                 |\n| 101010                       | 10101                 |\n| 011010                       | 10110                 |\n| 111010, 000101               | 10111                 |\n| 110011, 001100               | 11000                 |\n| 100110                       | 11001                 |\n| 010110                       | 11010                 |\n| 110110, 001001               | 11011                 |\n| 001110                       | 11100                 |\n| 101110, 010001               | 11101                 |\n| 011110, 100001               | 11110                 |\n| 101011, 010100               | 11111                 |\n\n\n\n#### **3b/4b Decoding Table**\n\nThe LSB 4-bit of the 10-bit input is mapped back to its corresponding 3-bit (`HGF`).\n\n| Encoded 4-bit (fghj)         | Decoded 3-bit (HGF) |\n|------------------------------|---------------------|\n| 0100, 1011                   | 000                 |\n| 1001                         | 001                 |\n| 0101                         | 010                 |\n| 0011, 1100                   | 011                 |\n| 0010, 1101                   | 100                 |\n| 1010                         | 101                 |\n| 0110                         | 110                 |\n| 1110, 0001                   | 111                 |\n  \n\n#### IO Ports  \n\n| Port Name              | Direction| Size       | Description                                        |\n|------------------------|----------|------------|----------------------------------------------------|\n| `clk_in`               | Input    | 1 bit      | Positive Edge triggered Clock signal               |\n| `reset_in`             | Input    | 1 bit      | Asynchronous Active-high reset                     |\n| `control_in`           | Input    | 1 bit      | Control symbol indicator: HIGH for control words   |\n| `decoder_in`           | Input    | 10 bits    | 10-bit encoded input                               |\n| `decoder_valid_in`     | Input    | 1 bit      | Input valid signal, active high                    |\n| `decoder_out`          | Output   | 8 bits     | 8-bit decoded output                               |\n| `decoder_valid_out`    | Output   | 1 bit      | Output valid signal, active high                   |\n| `control_out`          | Output   | 1 bit      | Control symbol output, active high for control words|\n\n", "context": {"rtl/decoder_8b10b.sv": "module decoder_8b10b (\n    input  logic        clk_in,             // Clock signal, triggers on rising edge\n    input  logic        reset_in,           // Reset signal, active high\n    input  logic        control_in,         // Control symbol indicator: HIGH for control, LOW for data\n    input  logic [9:0]  decoder_in,         // 10-bit encoded input\n    input  logic        decoder_valid_in,   // Input valid signal, active high\n    output logic [7:0]  decoder_out,        // 8-bit decoded output\n    output logic        decoder_valid_out,  // Output valid signal, active high\n    output logic        control_out         // Control symbol output, active high for control words\n);\n\n    logic [9:0] s_in_10b_reg;  \n    logic [7:0] s_decoder_out; \n    logic s_control_out;\n    logic [7:0] decoder_data_out;\n    logic control_data_out;    \n    logic decoder_control_valid;    \n    logic decoder_data_valid;    \n    logic a,b,c,d,e,i,f,g,h,j;  \n    logic w_aeqb, w_ceqd, w_p22, w_p13, w_p31;\n    logic eeqi, c_d_e_i, cn_dn_en_in;\n    logic w_p22_a_c_eeqi, w_p22_an_cn_eeqi;\n    logic w_p22_b_c_eeqi, w_p22_bn_cn_eeqi, an_bn_en_in;\n    logic a_b_e_i, w_p13_d_e_i, w_p13_in, w_p13_en, w_p31_i;\n    logic w_or12_1, w_or12_2, w_or12_3, w_or12_4, w_or12_5, w_or12_6, w_or12_7;\n    logic A, B, C, D, E;\n    logic K, F, G, H, K28p, w_ka, w_kb, w_kc;\n\n    function automatic [8:0] decode_8b10b(input logic [9:0] in);\n        case (in)\n            10'b0011110100, 10'b1100001011: decode_8b10b = {1'b1, 8'h1C};\n            10'b0011110010, 10'b1100001101: decode_8b10b = {1'b1, 8'h9C};\n            10'b0011111000, 10'b1100000111: decode_8b10b = {1'b1, 8'hFC};\n            10'b1110101000, 10'b0001010111: decode_8b10b = {1'b1, 8'hF7};\n            10'b1101101000, 10'b0010010111: decode_8b10b = {1'b1, 8'hFB};\n            10'b1011101000, 10'b0100010111: decode_8b10b = {1'b1, 8'hFD};\n            10'b0111101000, 10'b1000010111: decode_8b10b = {1'b1, 8'hFE};\n            10'b0011111001, 10'b1100000110: decode_8b10b = {1'b1, 8'h3C};\n            10'b0011110101, 10'b1100001010: decode_8b10b = {1'b1, 8'h5C};\n            10'b0011110011, 10'b1100001100: decode_8b10b = {1'b1, 8'h7C};\n            10'b0011111010, 10'b1100000101: decode_8b10b = {1'b1, 8'hBC};\n            10'b0011110110, 10'b1100001001: decode_8b10b = {1'b1, 8'hDC};\n            default: decode_8b10b = {1'b0, 8'b00000000};\n        endcase\n    endfunction\n\n    always_comb begin\n        {s_control_out, s_decoder_out} = decode_8b10b(s_in_10b_reg);  \n    end\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            s_in_10b_reg <= 10'b0000000000;\n            decoder_control_valid <= 1'b0;\n        end else if (decoder_valid_in) begin\n            s_in_10b_reg <= decoder_in;  \n            decoder_control_valid <= 1'b1;  \n        end else begin\n            decoder_control_valid <= 1'b0;\n        end\n    end\n\n    assign {a,b,c,d,e,i,f,g,h,j} = decoder_in[9:0];\n\n    assign K28p = ! (c | d | e | i);\n    assign F = (j & !f & (h | !g | K28p)) | (f & !j & (!h | g | !K28p)) | (K28p & g & h) | (!K28p & !g & !h);\n    assign G = (j & !f & (h | !g | !K28p)) | (f & !j & (!h | g |K28p)) | (!K28p & g & h) | (K28p & !g & !h);\n    assign H = ((j ^ h) & ! ((!f & g & !h & j & !K28p) | (!f & g & h & !j & K28p) | (f & !g & !h & j & !K28p) | (f & !g & h & !j & K28p))) | (!f & g & h & j) | (f & !g & !h & !j);\n\n    assign w_aeqb = (a & b) | (!a & !b);\n    assign w_ceqd = (c & d) | (!c & !d);\n    assign w_p22 = (a & b & !c & !d) | (c & d & !a & !b) | ( !w_aeqb & !w_ceqd);\n    assign w_p13 = ( !w_aeqb & !c & !d) | ( !w_ceqd & !a & !b);\n    assign w_p31 = ( !w_aeqb & c & d) | ( !w_ceqd & a & b);\n\n    assign eeqi = (e == i);\n    assign w_p22_a_c_eeqi = w_p22 & a & c & eeqi;\n    assign w_p22_an_cn_eeqi = w_p22 & !a & !c & eeqi;\n    assign cn_dn_en_in = (!c & !d & !e & !i);\n    assign c_d_e_i = (c & d & e & i);\n    assign w_ka = c_d_e_i | cn_dn_en_in;\n    assign w_kb = w_p13 & (!e & i & g & h & j);\n    assign w_kc = w_p31 & (e & !i & !g & !h & !j);\n    assign K = w_ka | w_kb | w_kc;\n    assign w_p22_b_c_eeqi = w_p22 & b & c & eeqi;\n    assign w_p22_bn_cn_eeqi = w_p22 & !b & !c & eeqi;\n    assign an_bn_en_in = !a & !b & !e & !i;\n    assign a_b_e_i = a & b & e & i;\n    assign w_p13_d_e_i = w_p13 & d & e & i;\n    assign w_p13_in = w_p13 & !i;\n    assign w_p13_en = w_p13 & !e;\n    assign w_p31_i = w_p31 & i;\n\n    assign w_or12_1 = w_p22_an_cn_eeqi | w_p13_en;\n    assign w_or12_2 = a_b_e_i | cn_dn_en_in | w_p31_i;\n    assign w_or12_3 = w_p31_i | w_p22_b_c_eeqi | w_p13_d_e_i;\n    assign w_or12_4 = w_p22_a_c_eeqi | w_p13_en;\n    assign w_or12_5 = w_p13_en | cn_dn_en_in | an_bn_en_in;\n    assign w_or12_6 = w_p22_an_cn_eeqi | w_p13_in;\n    assign w_or12_7 = w_p13_d_e_i | w_p22_bn_cn_eeqi;\n\n    assign A = a ^ (w_or12_7 | w_or12_1 | w_or12_2);\n    assign B = b ^ (w_or12_2 | w_or12_3 | w_or12_4);\n    assign C = c ^ (w_or12_1 | w_or12_3 | w_or12_5);\n    assign D = d ^ (w_or12_2 | w_or12_4 | w_or12_7);\n    assign E = e ^ (w_or12_5 | w_or12_6 | w_or12_7);\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            control_data_out <= 0; \n            decoder_data_out <= 8'b0;\n            decoder_data_valid <= 0; \n        end else begin\n            control_data_out <= K; \n            decoder_data_out <= { H, G, F, E, D, C, B, A };\n            decoder_data_valid <= decoder_valid_in;\n        end\n    end\n    \n    assign decoder_out = (control_in) ? s_decoder_out  : decoder_data_out;\n    assign control_out = (control_in) ? s_control_out  : control_data_out;\n    assign decoder_valid_out = (control_in) ? decoder_control_valid  : decoder_data_valid;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/decoder_8b10b.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/decoder_8b10b.sv \nTOPLEVEL        = decoder_8b10b\nMODULE          = test_decoder_8b10b\nPYTHONPATH      = /src\nHASH            = bc92750b200432446a29bd251f1ca1f83811567d\n", "src/test_decoder_8b10b.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nfrom collections import deque\n\n# Special character code values\nK28d0_RD0 = \"0011110100\"\nK28d0_RD1 = \"1100001011\"\nK28d1_RD0 = \"0011111001\"\nK28d1_RD1 = \"1100000110\"\nK28d2_RD0 = \"0011110101\"\nK28d2_RD1 = \"1100001010\"\nK28d3_RD0 = \"0011110011\"\nK28d3_RD1 = \"1100001100\"\nK28d4_RD0 = \"0011110010\"\nK28d4_RD1 = \"1100001101\"\nK28d5_RD0 = \"0011111010\"\nK28d5_RD1 = \"1100000101\"\nK28d6_RD0 = \"0011110110\"\nK28d6_RD1 = \"1100001001\"\nK28d7_RD0 = \"0011111000\"\nK28d7_RD1 = \"1100000111\"\nK23d7_RD0 = \"1110101000\"\nK23d7_RD1 = \"0001010111\"\nK27d7_RD0 = \"1101101000\"\nK27d7_RD1 = \"0010010111\"\nK29d7_RD0 = \"1011101000\"\nK29d7_RD1 = \"0100010111\"\nK30d7_RD0 = \"0111101000\"\nK30d7_RD1 = \"1000010111\"\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and start the clock.\"\"\"\n    dut.reset_in.value = 1\n    dut.decoder_in.value = 0\n    dut.decoder_valid_in.value = 0\n    dut.control_in.value = 0\n\n    clock = Clock(dut.clk_in, 50, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    dut.reset_in.value = 0\n\nasync def check_output(dut, expected_value, expected_control, input_value):\n    \"\"\"Check the output of the DUT against the expected value.\"\"\"\n    expected_value_bin = f\"{int(expected_value, 16):08b}\"  # Convert hex to binary\n    print(f\"Expected: {hex(int(expected_value, 16)):>4}, Got: {hex(int(str(dut.decoder_out.value), 2)):>4}, Input: {input_value}\")\n    assert str(dut.decoder_out.value) == expected_value_bin, f\"Expected {expected_value_bin}, got {str(dut.decoder_out.value)}\"\n    assert dut.control_out.value == expected_control, f\"Expected control {expected_control}, got {dut.control_out.value}\"\n\ndef calculate_expected_value(codeword):\n    \"\"\"Calculate the expected value based on the 10-bit codeword.\"\"\"\n    if codeword in [K28d0_RD0, K28d0_RD1]:\n        return \"1C\"\n    elif codeword in [K28d1_RD0, K28d1_RD1]:\n        return \"3C\"\n    elif codeword in [K28d2_RD0, K28d2_RD1]:\n        return \"5C\"\n    elif codeword in [K28d3_RD0, K28d3_RD1]:\n        return \"7C\"\n    elif codeword in [K28d4_RD0, K28d4_RD1]:\n        return \"9C\"\n    elif codeword in [K28d5_RD0, K28d5_RD1]:\n        return \"BC\"\n    elif codeword in [K28d6_RD0, K28d6_RD1]:\n        return \"DC\"\n    elif codeword in [K28d7_RD0, K28d7_RD1]:\n        return \"FC\"\n    elif codeword in [K23d7_RD0, K23d7_RD1]:\n        return \"F7\"\n    elif codeword in [K27d7_RD0, K27d7_RD1]:\n        return \"FB\"\n    elif codeword in [K29d7_RD0, K29d7_RD1]:\n        return \"FD\"\n    elif codeword in [K30d7_RD0, K30d7_RD1]:\n        return \"FE\"\n    else:\n        return \"00\"\n\n# Data symbols for 8b10b decoder\nDATA_SYMBOLS = [\n     \"1001110100\", \"0110001011\", \"0111010010\", \"1000101101\", \"1011010101\", \"0100100101\", \"1100010110\", \"1100010110\",\n     \"0111010100\", \"1000101011\", \"1011010010\", \"0100101101\", \"1100010101\", \"1100010101\", \"1101010110\", \"0010100110\",\n     \"1011010100\", \"0100101011\", \"1100011101\", \"1100010010\", \"1101010101\", \"0010100101\", \"1010010110\", \"1010010110\",\n     \"1100011011\", \"1100010100\", \"1101010010\", \"0010101101\", \"1010010101\", \"1010010101\", \"0110010110\", \"0110010110\",\n     \"1101010100\", \"0010101011\", \"1010011101\", \"1010010010\", \"0110010101\", \"0110010101\", \"1110000110\", \"0001110110\",\n     \"1010011011\", \"1010010100\", \"0110011101\", \"0110010010\", \"1110000101\", \"0001110101\", \"1110010110\", \"0001100110\",\n     \"0110011011\", \"0110010100\", \"1110001101\", \"0001110010\", \"1110010101\", \"0001100101\", \"1001010110\", \"1001010110\",\n     \"1110001011\", \"0001110100\", \"1110010010\", \"0001101101\", \"1001010101\", \"1001010101\", \"0101010110\", \"0101010110\",\n     \"1110010100\", \"0001101011\", \"1001011101\", \"1001010010\", \"0101010101\", \"0101010101\", \"1101000110\", \"1101000110\",\n     \"1001011011\", \"1001010100\", \"0101011101\", \"0101010010\", \"1101000101\", \"1101000101\", \"0011010110\", \"0011010110\",\n     \"0101011011\", \"0101010100\", \"1101001101\", \"1101000010\", \"0011010101\", \"0011010101\", \"1011000110\", \"1011000110\",\n     \"1101001011\", \"1101000100\", \"0011011101\", \"0011010010\", \"1011000101\", \"1011000101\", \"0111000110\", \"0111000110\",\n     \"0011011011\", \"0011010100\", \"1011001101\", \"1011000010\", \"0111000101\", \"0111000101\", \"0101110110\", \"1010000110\",\n     \"1011001011\", \"1011000100\", \"0111001101\", \"0111000010\", \"0101110101\", \"1010000101\", \"0110110110\", \"1001000110\",\n     \"0111001011\", \"0111000100\", \"0101110010\", \"1010001101\", \"0110110101\", \"1001000101\", \"1000110110\", \"1000110110\",\n     \"0101110100\", \"1010001011\", \"0110110010\", \"1001001101\", \"1000110101\", \"1000110101\", \"0100110110\", \"0100110110\",\n     \"0110110100\", \"1001001011\", \"1000111101\", \"1000110010\", \"0100110101\", \"0100110101\", \"1100100110\", \"1100100110\",\n     \"1000111011\", \"1000110100\", \"0100111101\", \"0100110010\", \"1100100101\", \"1100100101\", \"0010110110\", \"0010110110\",\n     \"0100111011\", \"0100110100\", \"1100101101\", \"1100100010\", \"0010110101\", \"0010110101\", \"1010100110\", \"1010100110\",\n     \"1100101011\", \"1100100100\", \"0010111101\", \"0010110010\", \"1010100101\", \"1010100101\", \"0110100110\", \"0110100110\",\n     \"0010111011\", \"0010110100\", \"1010101101\", \"1010100010\", \"0110100101\", \"0110100101\", \"1110100110\", \"0001010110\",\n     \"1010101011\", \"1010100100\", \"0110101101\", \"0110100010\", \"1110100101\", \"0001010101\", \"1100110110\", \"0011000110\",\n     \"0110101011\", \"0110100100\", \"1110100010\", \"0001011101\", \"1100110101\", \"0011000101\", \"1001100110\", \"1001100110\",\n     \"1110100100\", \"0001011011\", \"1100110010\", \"0011001101\", \"1001100101\", \"1001100101\", \"0101100110\", \"0101100110\",\n     \"1100110100\", \"0011001011\", \"1001101101\", \"1001100010\", \"0101100101\", \"0101100101\", \"1101100110\", \"0010010110\",\n     \"1001101011\", \"1001100100\", \"0101101101\", \"0101100010\", \"1101100101\", \"0010010101\", \"0011100110\", \"0011100110\",\n     \"0101101011\", \"0101100100\", \"1101100010\", \"0010011101\", \"0011100101\", \"0011100101\", \"1011100110\", \"0100010110\",\n     \"1101100100\", \"0010011011\", \"0011101101\", \"0011100010\", \"1011100101\", \"0100010101\", \"0111100110\", \"1000010110\",\n     \"0011101011\", \"0011100100\", \"1011100010\", \"0100011101\", \"0111100101\", \"1000010101\", \"1010110110\", \"0101000110\",\n     \"1011100100\", \"0100011011\", \"0111100010\", \"1000011101\", \"1010110101\", \"0101000101\", \"1001110001\", \"0110001110\",\n     \"0111100100\", \"1000011011\", \"1010110010\", \"0101001101\", \"1001110011\", \"0110001100\", \"0111010001\", \"1000101110\",\n     \"1010110100\", \"0101001011\", \"1001111010\", \"0110001010\", \"0111010011\", \"1000101100\", \"1011010001\", \"0100101110\",\n     \"1001111001\", \"0110001001\", \"0111011010\", \"1000101010\", \"1011010011\", \"0100101100\", \"1100011110\", \"1100010001\",\n     \"0111011001\", \"1000101001\", \"1011011010\", \"0100101010\", \"1100011100\", \"1100010011\", \"1101010001\", \"0010101110\",\n     \"1011011001\", \"0100101001\", \"1100011010\", \"1100011010\", \"1101010011\", \"0010101100\", \"1010011110\", \"1010010001\",\n     \"1100011001\", \"1100011001\", \"1101011010\", \"0010101010\", \"1010011100\", \"1010010011\", \"0110011110\", \"0110010001\",\n     \"1101011001\", \"0010101001\", \"1010011010\", \"1010011010\", \"0110011100\", \"0110010011\", \"1110001110\", \"0001110001\",\n     \"1010011001\", \"1010011001\", \"0110011010\", \"0110011010\", \"1110001100\", \"0001110011\", \"1110010001\", \"0001101110\",\n     \"0110011001\", \"0110011001\", \"1110001010\", \"0001111010\", \"1110010011\", \"0001101100\", \"1001011110\", \"1001010001\",\n     \"1110001001\", \"0001111001\", \"1110011010\", \"0001101010\", \"1001011100\", \"1001010011\", \"0101011110\", \"0101010001\",\n     \"1110011001\", \"0001101001\", \"1001011010\", \"1001011010\", \"0101011100\", \"0101010011\", \"1101001110\", \"1101001000\",\n     \"1001011001\", \"1001011001\", \"0101011010\", \"0101011010\", \"1101001100\", \"1101000011\", \"0011011110\", \"0011010001\",\n     \"0101011001\", \"0101011001\", \"1101001010\", \"1101001010\", \"0011011100\", \"0011010011\", \"1011001110\", \"1011001000\",\n     \"1101001001\", \"1101001001\", \"0011011010\", \"0011011010\", \"1011001100\", \"1011000011\", \"0111001110\", \"0111001000\",\n     \"0011011001\", \"0011011001\", \"1011001010\", \"1011001010\", \"0111001100\", \"0111000011\", \"0101110001\", \"1010001110\",\n     \"1011001001\", \"1011001001\", \"0111001010\", \"0111001010\", \"0101110011\", \"1010001100\", \"0110110001\", \"1001001110\",\n     \"0111001001\", \"0111001001\", \"0101111010\", \"1010001010\", \"0110110011\", \"1001001100\", \"1000110111\", \"1000110001\",\n     \"0101111001\", \"1010001001\", \"0110111010\", \"1001001010\", \"1000111100\", \"1000110011\", \"0100110111\", \"0100110001\",\n     \"0110111001\", \"1001001001\", \"1000111010\", \"1000111010\", \"0100111100\", \"0100110011\", \"1100101110\", \"1100100001\",\n     \"1000111001\", \"1000111001\", \"0100111010\", \"0100111010\", \"1100101100\", \"1100100011\", \"0010110111\", \"0010110001\",\n     \"0100111001\", \"0100111001\", \"1100101010\", \"1100101010\", \"0010111100\", \"0010110011\", \"1010101110\", \"1010100001\",\n     \"1100101001\", \"1100101001\", \"0010111010\", \"0010111010\", \"1010101100\", \"1010100011\", \"0110101110\", \"0110100001\",\n     \"0010111001\", \"0010111001\", \"1010101010\", \"1010101010\", \"0110101100\", \"0110100011\", \"1110100001\", \"0001011110\",\n     \"1010101001\", \"1010101001\", \"0110101010\", \"0110101010\", \"1110100011\", \"0001011100\", \"1100110001\", \"0011001110\",\n     \"0110101001\", \"0110101001\", \"1110101010\", \"0001011010\", \"1100110011\", \"0011001100\", \"1001101110\", \"1001100001\",\n     \"1110101001\", \"0001011001\", \"1100111010\", \"0011001010\", \"1001101100\", \"1001100011\", \"0101101110\", \"0101100001\",\n     \"1100111001\", \"0011001001\", \"1001101010\", \"1001101010\", \"0101101100\", \"0101100011\", \"1101100001\", \"0010011110\",\n     \"1001101001\", \"1001101001\", \"0101101010\", \"0101101010\", \"1101100011\", \"0010011100\", \"0011101110\", \"0011100001\",\n     \"0101101001\", \"0101101001\", \"1101101010\", \"0010011010\", \"0011101100\", \"0011100011\", \"1011100001\", \"0100011110\",\n     \"1101101001\", \"0010011001\", \"0011101010\", \"0011101010\", \"1011100011\", \"0100011100\", \"0111100001\", \"1000011110\",\n     \"0011101001\", \"0011101001\", \"1011101010\", \"0100011010\", \"0111100011\", \"1000011100\", \"1010110001\", \"0101001110\",\n     \"1011101001\", \"0100011001\", \"0111101010\", \"1000011010\", \"1010110011\", \"0101001100\", \"1001110010\", \"0110001101\",\n     \"0111101001\", \"1000011001\", \"1010111010\", \"0101001010\", \"1001110101\", \"0110000101\", \"0111010110\", \"1000100110\",\n     \"1010111001\", \"0101001001\", \"1001110110\", \"0110000110\", \"0111010101\", \"1000100101\", \"1011010110\", \"0100100110\" \n]\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and start the clock.\"\"\"\n    dut.reset_in.value = 1\n    dut.decoder_in.value = 0\n    dut.decoder_valid_in.value = 0\n    dut.control_in.value = 0\n\n    clock = Clock(dut.clk_in, 50, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    dut.reset_in.value = 0\n\ndef calculate_doi(d):\n    d = [int(bit) for bit in f\"{int(d, 2):010b}\"][::-1] \n    def not_(x): return 1 if x == 0 else 0\n\n    doi = [0] * 8\n\n    doi[7] = (((d[0] ^ d[1]) & not_(\n        (not_(d[3]) & d[2] & not_(d[1]) & d[0] & not_(not_(d[7] | d[6] | d[5] | d[4]))) |\n        (not_(d[3]) & d[2] & d[1] & not_(d[0]) & not_(d[7] | d[6] | d[5] | d[4])) |\n        (d[3] & not_(d[2]) & not_(d[1]) & d[0] & not_(not_(d[7] | d[6] | d[5] | d[4]))) |\n        (d[3] & not_(d[2]) & d[1] & not_(d[0]) & not_(d[7] | d[6] | d[5] | d[4]))\n    ))) | (not_(d[3]) & d[2] & d[1] & d[0]) | (d[3] & not_(d[2]) & not_(d[1]) & not_(d[0]))\n\n    doi[6] = ((d[0] & not_(d[3]) & (d[1] | not_(d[2]) | not_(not_(d[7] | d[6] | d[5] | d[4])))) |\n              (d[3] & not_(d[0]) & (not_(d[1]) | d[2] | not_(d[7] | d[6] | d[5] | d[4]))) |\n              (not_(not_(d[7] | d[6] | d[5] | d[4])) & d[2] & d[1]) |\n              (not_(d[7] | d[6] | d[5] | d[4]) & not_(d[2]) & not_(d[1])))\n\n    doi[5] = ((d[0] & not_(d[3]) & (d[1] | not_(d[2]) | not_(d[7] | d[6] | d[5] | d[4]))) |\n              (d[3] & not_(d[0]) & (not_(d[1]) | d[2] | not_(not_(d[7] | d[6] | d[5] | d[4])))) |\n              (not_(d[7] | d[6] | d[5] | d[4]) & d[2] & d[1]) |\n              (not_(not_(d[7] | d[6] | d[5] | d[4])) & not_(d[2]) & not_(d[1])))\n\n    \n\n    term32 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term33 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term34 = (term32 | term33) & not_(d[5])\n    term35 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term36 = not_(d[9]) & not_(d[8]) & not_(d[5]) & not_(d[4])\n    term37 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term38 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term39 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term40 = (term37 | term38 | term39) & not_(d[9]) & not_(d[7]) & not_(d[5] ^ d[4])\n    term41 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term42 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term43 = (term41 | term42) & not_(d[4])\n    term44 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term45 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term46 = (term44 | term45) & d[6] & d[5] & d[4]\n    term47 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term48 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term49 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term50 = (term47 | term48 | term49) & not_(d[8]) & not_(d[7]) & not_(d[5] ^ d[4])\n\n    doi[4] = d[5] ^ (term34 | term35 | term36 | term40 | term43 | term46 | term50)\n\n    term1 = d[9] & d[8] & d[5] & d[4]\n    term2 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term3 = (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6])\n    term4 = (not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8])\n    term5 = (term3 | term4) & d[4]\n\n    term6 = (\n        ((d[9] & d[8] & not_(d[7]) & not_(d[6])) |\n         (d[7] & d[6] & not_(d[9]) & not_(d[8])) |\n         (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))))\n        ) & d[9] & d[7] & not_(d[5] ^ d[4])\n    )\n    term7 = (\n        (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])) |\n        (not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8]))\n    ) & not_(d[5])\n    term8 = (\n        (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])) |\n        (not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8]))\n    ) & d[6] & d[5] & d[4]\n    term9 = (\n        ((d[9] & d[8] & not_(d[7]) & not_(d[6])) |\n         (d[7] & d[6] & not_(d[9]) & not_(d[8])) |\n         (not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))))\n        ) & not_(d[8]) & not_(d[7]) & not_(d[5] ^ d[4])\n    )\n\n    doi[3] = d[6] ^ (term1 | term2 | term5 | term6 | term7 | term8 | term9)\n\n\n    \n    term10 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term11 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term12 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term13 = (term10 | term11 | term12) & not_(d[9]) & not_(d[7]) & not_(d[5] ^ d[4])\n    term14 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term15 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term16 = (term14 | term15) & not_(d[5])\n    term17 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6]\n    term18 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8]\n    term19 = (term17 | term18) & d[4]\n    term20 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term21 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term22 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term23 = (term20 | term21 | term22) & d[8] & d[7] & not_(d[5] ^ d[4])\n    term24 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term25 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term26 = (term24 | term25) & d[6] & d[5] & d[4]\n    term27 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term28 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term29 = (term27 | term28) & not_(d[5])\n    term30 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term31 = not_(d[9]) & not_(d[8]) & not_(d[5]) & not_(d[4])\n\n    doi[2] = d[7] ^ (term13 | term16 | term19 | term23 | term26 | term29 | term30 | term31)\n\n       \n    term51 = d[9] & d[8] & d[5] & d[4]\n    term52 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term53 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6]\n    term54 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8]\n    term55 = (term53 | term54) & d[4]\n    term56 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6]\n    term57 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8]\n    term58 = (term56 | term57) & d[4]\n    term59 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term60 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term61 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term62 = (term59 | term60 | term61) & d[8] & d[7] & not_(d[5] ^ d[4])\n    term63 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term64 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term65 = (term63 | term64) & d[6] & d[5] & d[4]\n    term66 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term67 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term68 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term69 = (term66 | term67 | term68) & d[9] & d[7] & not_(d[5] ^ d[4])\n    term70 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term71 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term72 = (term70 | term71) & not_(d[5])\n\n    doi[1] = d[8] ^ (term51 | term52 | term55 | term58 | term62 | term65 | term69 | term72)\n\n   \n    term73 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term74 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term75 = (term73 | term74) & d[6] & d[5] & d[4]\n    term76 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term77 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term78 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term79 = (term76 | term77 | term78) & not_(d[8]) & not_(d[7]) & not_(d[5] ^ d[4])\n    term80 = d[9] & d[8] & not_(d[7]) & not_(d[6])\n    term81 = d[7] & d[6] & not_(d[9]) & not_(d[8])\n    term82 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6])))\n    term83 = (term80 | term81 | term82) & not_(d[9]) & not_(d[7]) & not_(d[5] ^ d[4])\n    term84 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & not_(d[7]) & not_(d[6])\n    term85 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & not_(d[9]) & not_(d[8])\n    term86 = (term84 | term85) & not_(d[5])\n    term87 = d[9] & d[8] & d[5] & d[4]\n    term88 = not_(d[7]) & not_(d[6]) & not_(d[5]) & not_(d[4])\n    term89 = not_((d[9] & d[8]) | (not_(d[9]) & not_(d[8]))) & d[7] & d[6]\n    term90 = not_((d[7] & d[6]) | (not_(d[7]) & not_(d[6]))) & d[9] & d[8]\n    term91 = (term89 | term90) & d[4]\n\n    doi[0] = d[9] ^ (term75 | term79 | term83 | term86 | term87 | term88 | term91)\n\n       \n    return \"\".join(map(str, reversed(doi)))\n\n\n@cocotb.test()\nasync def test_decoder_8b10b_reset(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols and reset HIGH.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n    dut.reset_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    expected_value = \"00\"\n    expected_control = 0\n    await check_output(dut, expected_value, expected_control, \"0000000000\")\n\n@cocotb.test()\nasync def test_continuous_control_symbol(dut):\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(28):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n    await Timer(100, units=\"ns\")\n\n\n@cocotb.test()\nasync def test_random_control_symbol(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d0_RD0, K28d0_RD1, K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d4_RD0, K28d4_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1, K28d7_RD0, K28d7_RD1, K23d7_RD0, K23d7_RD1,\n        K27d7_RD0, K27d7_RD1, K29d7_RD0, K29d7_RD1, K30d7_RD0, K30d7_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n@cocotb.test()\nasync def test_same_control_symbol(dut):\n    \"\"\"Test sending the same control symbol continuously.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d6_RD0, K28d6_RD1]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(20):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n\n@cocotb.test()\nasync def test_random_imbalanced_control_symbol(dut):\n    \"\"\"Test sending any random control symbol continuously out of 5 imbalanced symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [\n        K28d1_RD0, K28d1_RD1, K28d2_RD0, K28d2_RD1,\n        K28d3_RD0, K28d3_RD1, K28d5_RD0, K28d5_RD1,\n        K28d6_RD0, K28d6_RD1\n    ]\n\n    # Queue to store previous decoder_in values\n    decoder_in_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(20):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.decoder_in.value = int(random_symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 1\n        await RisingEdge(dut.clk_in)\n\n        # Store the current decoder_in value in the queue\n        decoder_in_queue.append(dut.decoder_in.value)\n\n        # Use the delayed decoder_in value for comparison\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n        expected_value = calculate_expected_value(delayed_decoder_in)\n        expected_control = 1 if delayed_decoder_in in control_symbols else 0\n        await check_output(dut, expected_value, expected_control, delayed_decoder_in)\n\n@cocotb.test()\nasync def test_tc1_seq_data_symbols(dut):\n    \"\"\"Test sequential data symbols.\"\"\"\n    await initialize_dut(dut)\n\n    default_value = int('1001110100', 2)  # This will be 628\n\n    # Initialize the deque with the default value\n    decoder_in_queue = deque([default_value, default_value], maxlen=2)\n\n    for symbol in DATA_SYMBOLS:  # Iterate through all symbols in DATA_SYMBOLS\n        dut.decoder_in.value = int(symbol, 2)\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 0  # Data symbols\n        await RisingEdge(dut.clk_in)\n        decoder_in_queue.append(dut.decoder_in.value)\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n\n        # Wait for decoder_valid_out to be HIGH\n        while not dut.decoder_valid_out.value:\n            await RisingEdge(dut.clk_in)\n\n        expected_value = calculate_doi(delayed_decoder_in)\n        dut_doi = f\"{int(dut.decoder_out.value):08b}\"\n\n        print(f\"Expected: {hex(int(expected_value, 2)):>4}, Got: {hex(int(str(dut_doi), 2)):>4}, Got control: {hex(int(str(dut.control_out.value), 2)):>4}, Input: {delayed_decoder_in}\")\n\n        assert (dut_doi == expected_value) and (dut.control_out.value == 0), f\"Mismatch: Input={symbol}, Expected DOI={expected_value}, Got DOI={dut_doi}, Control Out={dut.control_out.value}\"\n\n@cocotb.test()\nasync def test_tc3_incrementing_data_symbols(dut):\n    \"\"\"Test data symbols using the allowed_values array for 10 cycles\"\"\"\n    await initialize_dut(dut)\n    allowed_values = [\n    0x274, 0x1d4, 0x2d4, 0x31b, 0x0ab, 0x294, 0x19b, 0x074,\n    0x394, 0x25b, 0x154, 0x34b, 0x0d4, 0x2cb, 0x1c4, 0x174,\n    0x1b4, 0x23b, 0x134, 0x32b, 0x0b4, 0x2ab, 0x1a4, 0x3a4\n    ]\n\n    default_value = int('1001110100', 2)  # This will be 628\n\n    # Initialize the deque with the default value\n    decoder_in_queue = deque([default_value, default_value], maxlen=2)\n\n    for i in range(24):  # Run for 10 cycles\n        symbol = allowed_values[i % len(allowed_values)]\n\n        dut.decoder_in.value = symbol\n        dut.decoder_valid_in.value = 1\n        dut.control_in.value = 0  # Data symbols\n        await RisingEdge(dut.clk_in)\n        decoder_in_queue.append(dut.decoder_in.value)\n        delayed_decoder_in = f\"{int(decoder_in_queue[0]):010b}\"\n\n        # Wait for decoder_valid_out to be HIGH\n        while not dut.decoder_valid_out.value:\n            await RisingEdge(dut.clk_in)\n\n        expected_value = calculate_doi(delayed_decoder_in)\n        dut_doi = f\"{int(dut.decoder_out.value):08b}\"\n\n        print(f\"Expected: {hex(int(expected_value, 2)):>4}, Got: {hex(int(str(dut_doi), 2)):>4}, Got control: {hex(int(str(dut.control_out.value), 2)):>4}, Input: {delayed_decoder_in}\")\n\n        assert (dut_doi == expected_value) and (dut.control_out.value == 0), f\"Mismatch: Input={symbol}, Expected DOI={expected_value}, Got DOI={dut_doi}, Control Out={dut.control_out.value}\"\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_dot_product_0014", "categories": ["cid014", "medium"], "input": {"prompt": "Create SystemVerilog Assertions to verify the **functional correctness** of the `dot_product` module. The properties should ensure that:  \n\n1. **Start Signal Restrictions**: The `start_in` signal should not be asserted HIGH during the `COMPUTE`, `OUTPUT`, or `ERROR` states.  \n2. **Single Cycle Start Pulse**: The `start_in` signal must be asserted for only **one clock cycle** at the start of computation.  \n3. **Valid Dot Product Length**: When transitioning from `IDLE` to `COMPUTE` state (`start_in` asserted HIGH), `dot_length_in` must be nonzero.  \n4. **Error Flag Stability**: The `dot_product_error_out` signal should not be HIGH **if both `vector_a_valid_in` and `vector_b_valid_in` remain stable** throughout the `COMPUTE` state.  \n\nEach assertion must provide a **detailed failure message**, including `state`, `start_in`, `dot_length_in`, and `dot_product_error_out` where applicable, for debugging purposes.\n\n---\n\n### RTL Specification  \n\n#### Module Name: `dot_product` \n\nThe `dot_product` module computes the dot product of two input vectors (A and B) with configurable lengths and complexities (real or complex). The module supports three modes of operation: real-only, complex-only, and mixed (one real and one complex). The output format is dynamically adjusted based on the input configuration, providing either a 32-bit real result or concatenated real and imaginary components.\n\n#### **Modes of Operation**:\n1. **Real-Only Mode**:  \n   - Both vectors are real. The dot product is calculated as the summation of element-wise multiplication:  \n     `Dot Product = SUM(A \u00d7 B)`.\n\n2. **Complex-Only Mode**:  \n   - Both vectors are complex, represented as `{Imaginary[31:16], Real[15:0]}`.  \n   - Dot product is computed as:  \n     - Real part: `SUM (A_re \u00d7 B_re - A_im \u00d7 B_im)`  \n     - Imaginary part: `SUM (A_re \u00d7 B_im + A_im \u00d7 B_re)`  \n\n3. **Mixed Mode**:  \n   - One vector is complex, and the other is real. The dot product is computed as:  \n     - Real part: `SUM (A_re \u00d7 B_re)`  \n     - Imaginary part: `SUM (A_im \u00d7 B_re)` (or vice versa depending on input).\n \n#### IO Ports  \n\n| Port Name              | Direction| Size       | Description                                        |\n|------------------------|----------|------------|----------------------------------------------------|\n| `clk_in`               | Input    | 1 bit      | Positive Edge triggered Clock signal               |\n| `reset_in`             | Input    | 1 bit      | Asynchronous Active-high reset                     |\n| `start_in`             | Input    | 1 bit      | Start computation signal                           |\n| `dot_length_in[7:0]`   | Input    | 8 bits     | Length of the dot product vectors                  |\n| `vector_a_in[31:0]`    | Input    | 32 bits    | Input vector A (32-bit)                            |\n| `vector_a_valid_in`    | Input    | 1 bit      | Valid signal for vector A                          |\n| `vector_b_in[31:0]`    | Input    | 32 bits    | Input vector B (32-bit)                            |\n| `vector_b_valid_in`    | Input    | 1 bit      | Valid signal for vector B                          |\n| `a_complex_in`         | Input    | 1 bit      | Is vector A complex? (1 = complex, 0 = real)       |\n| `b_complex_in`         | Input    | 1 bit      | Is vector B complex? (1 = complex, 0 = real)       |\n| `dot_product_out[31:0]`| Output   | 32 bits    | Output dot product result (32-bit)                 |\n| `dot_product_error_out`| Output   | 1 bit      | Error signal for invalid input conditions          |\n| `dot_product_valid_out`| Output   | 1 bit      | Valid signal for dot product output                |", "context": {"rtl/dot_product.sv": "module dot_product (\n    input               clk_in,                     // Clock signal\n    input               reset_in,                   // Asynchronous Reset signal, Active HIGH\n    input               start_in,                   // Start computation signal\n    input       [7:0]   dot_length_in,              // Length of the dot product vectors\n    input       [31:0]  vector_a_in,                // Input vector A (32-bit)\n    input               vector_a_valid_in,          // Valid signal for vector A\n    input       [31:0]  vector_b_in,                // Input vector B (32-bit)\n    input               vector_b_valid_in,          // Valid signal for vector B\n    input               a_complex_in,               // Is vector A complex? (1 = complex, 0 = real)\n    input               b_complex_in,               // Is vector B complex? (1 = complex, 0 = real)\n    output logic [31:0] dot_product_out,            // Output dot product result (32-bit)\n    output logic        dot_product_error_out,      // Error signal for invalid input conditions\n    output logic        dot_product_valid_out       // Valid signal for dot product output\n);\n\n    typedef enum logic [1:0] {\n        IDLE    = 2'b00,\n        COMPUTE = 2'b01,\n        OUTPUT  = 2'b10,\n        ERROR   = 2'b11\n    } state_t;\n\n    state_t state;\n    logic [31:0] acc;\n    logic signed [31:0] acc_re, acc_im;\n    logic [7:0] cnt;\n    logic [7:0] dot_length_reg;\n    logic a_complex_reg;\n    logic b_complex_reg;\n    logic vector_a_valid_in_prev;\n    logic vector_b_valid_in_prev;\n\n    wire signed [15:0] a_re, a_im;\n    wire signed [15:0] b_re, b_im;\n\n    logic               start_d1;\n    logic       [7:0]   dot_length_d1;\n    logic       [31:0]  vector_a_d1;\n    logic               vector_a_valid_d1;\n    logic       [31:0]  vector_b_d1;\n    logic               vector_b_valid_d1;\n    logic               a_complex_d1;\n    logic               b_complex_d1;\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            start_d1           <= 1'b0;\n            dot_length_d1      <= 8'b0;\n            vector_a_d1        <= 32'b0;\n            vector_a_valid_d1  <= 1'b0;\n            vector_b_d1        <= 32'b0;\n            vector_b_valid_d1  <= 1'b0;\n            a_complex_d1      <= 1'b0;\n            b_complex_d1       <= 1'b0;\n        end else begin\n            start_d1           <= start_in;\n            dot_length_d1      <= dot_length_in;\n            vector_a_d1        <= vector_a_in;\n            vector_a_valid_d1  <= vector_a_valid_in;\n            vector_b_d1        <= vector_b_in;\n            vector_b_valid_d1  <= vector_b_valid_in;\n            a_complex_d1       <= a_complex_in;\n            b_complex_d1       <= b_complex_in;\n        end\n    end\n\n    assign a_re = a_complex_reg ? vector_a_d1[15:0] : vector_a_d1;\n    assign a_im = a_complex_reg ? vector_a_d1[31:16] : 0;\n    assign b_re = b_complex_reg ? vector_b_d1[15:0] : vector_b_d1;\n    assign b_im = b_complex_reg ? vector_b_d1[31:16] : 0;\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            state <= IDLE;\n            acc <= 0;\n            acc_re <= 0;\n            acc_im <= 0;\n            cnt <= 0;\n            dot_product_out <= 0;\n            dot_product_valid_out <= 0;\n            dot_length_reg <= 0;\n            a_complex_reg <= 0;\n            b_complex_reg <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    dot_product_valid_out <= 0;\n                    dot_length_reg <= dot_length_d1;\n                    a_complex_reg <= a_complex_d1;\n                    b_complex_reg <= b_complex_d1;\n                    if (start_d1) begin\n                        state <= COMPUTE;\n                        acc <= 0;\n                        acc_re <= 0;\n                        acc_im <= 0;\n                        cnt <= 0;\n                    end\n                end\n                COMPUTE: begin\n                    if (vector_a_valid_d1 && vector_b_valid_d1) begin\n                        if (a_complex_reg || b_complex_reg) begin\n                            if (a_complex_reg && b_complex_reg) begin\n                                acc_re <= acc_re + (a_re * b_re - a_im * b_im);\n                                acc_im <= acc_im + (a_re * b_im + a_im * b_re);\n                            end else if (a_complex_reg) begin\n                                acc_re <= acc_re + (a_re * b_re);\n                                acc_im <= acc_im + (a_im * b_re);\n                            end else if (b_complex_reg) begin\n                                acc_re <= acc_re + (a_re * b_re);\n                                acc_im <= acc_im + (a_re * b_im);\n                            end\n                        end else begin\n                            acc <= acc + (vector_a_d1 * vector_b_d1);\n                        end\n                        cnt <= cnt + 1;\n                    end\n                    if (cnt == dot_length_reg - 1) begin\n                        state <= OUTPUT;\n                    end else if (dot_product_error_out) begin\n                        state <= ERROR;\n                    end else begin\n                        state <= COMPUTE;\n                    end\n                end\n                OUTPUT: begin\n                    if (a_complex_reg || b_complex_reg) begin\n                        dot_product_out <= {acc_im[15:0], acc_re[15:0]};\n                    end else begin\n                        dot_product_out <= acc;\n                    end\n                    dot_product_valid_out <= 1;\n                    state <= IDLE;\n                end\n                ERROR: begin\n                    dot_product_out <= 0;\n                    dot_product_valid_out <= 0;\n                    state <= IDLE;\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            dot_product_error_out <= 0;\n        end else begin\n            if (state == IDLE && start_d1) begin\n                dot_product_error_out <= 0;\n            end\n            if (state == COMPUTE) begin\n                if ((vector_a_valid_in_prev && !vector_a_valid_d1) || (vector_b_valid_in_prev && !vector_b_valid_d1)) begin\n                    dot_product_error_out <= 1;\n                end\n            end\n        end\n    end\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            vector_a_valid_in_prev <= 0;\n            vector_b_valid_in_prev <= 0;\n        end else begin\n            vector_a_valid_in_prev <= vector_a_valid_d1;\n            vector_b_valid_in_prev <= vector_b_valid_d1;\n        end\n    end\n    \nendmodule"}}, "output": {"response": "", "context": {"rtl/dot_product.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/dot_product.sv\nTOPLEVEL        = dot_product\nMODULE          = test_dot_product\nPYTHONPATH      = /src\nHASH            = 6cdca0186b81b95992b89e30c8e71739ef596152\n", "src/test_dot_product.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n# Parameters\nA_DW = 32\nB_DW = 32\nOUT_DW = 32\nrandom.seed(42)  # Ensures reproducibility of random values\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and set all inputs to their default values.\"\"\"\n    dut.reset_in.setimmediatevalue(1)\n    dut.vector_a_valid_in.value = 0\n    dut.dot_length_in.value = 0\n    dut.vector_b_valid_in.value = 0\n    dut.start_in.value = 0\n    dut.vector_a_in.value = 0\n    dut.vector_b_in.value = 0\n    dut.a_complex_in.value = 0\n    dut.b_complex_in.value = 0\n\n    # Start the clock\n    clock = Clock(dut.clk_in, 20, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Reset procedure\n    await RisingEdge(dut.clk_in)\n    dut.reset_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    dut.reset_in.value = 0\n    await RisingEdge(dut.clk_in)\n    dut._log.info(\"DUT Initialized: Reset completed and inputs set to default.\")\n\nasync def send_vector(dut, vec_a, vec_b, length, a_complex=0, b_complex=0, interrupt_valid=False):\n    \"\"\"Send vector inputs to the DUT.\"\"\"\n    dut.dot_length_in.value = length\n    dut.a_complex_in.value = a_complex\n    dut.b_complex_in.value = b_complex\n    await RisingEdge(dut.clk_in)\n    dut.start_in.value = 1\n\n    dut._log.info(f\"Sending Vectors: Length = {length}, a_complex = {a_complex}, b_complex = {b_complex}\")\n    for i in range(length):\n        await RisingEdge(dut.clk_in)\n        dut.start_in.value = 0\n        dut.vector_a_in.value = vec_a[i]\n        dut.vector_b_in.value = vec_b[i]\n        dut.vector_a_valid_in.value = 1\n        dut.vector_b_valid_in.value = 1\n# Print the input vectors and valid signals in hex format\n        if interrupt_valid and i == length // 2:\n            # Simulate an interruption\n            dut.vector_a_valid_in.value = 0\n            dut.vector_b_valid_in.value = 0\n            await RisingEdge(dut.clk_in)\n        dut._log.info(f\"Cycle {i + 1}: vector_a_in = {hex(vec_a[i])}, \"\n                      f\"vector_b_in = {hex(vec_b[i])}, \"\n                      f\"vector_a_valid_in = {hex(int(dut.vector_a_valid_in.value))}, \"\n                      f\"vector_b_valid_in = {hex(int(dut.vector_b_valid_in.value))}\")\n\n    await RisingEdge(dut.clk_in)\n    dut.vector_a_valid_in.value = 0\n    dut.vector_b_valid_in.value = 0\n\nasync def check_result(dut, expected_result, expected_error=False):\n    \"\"\"Check the DUT result and validate correctness.\"\"\"\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    valid = int(dut.dot_product_valid_out.value)\n    error = int(dut.dot_product_error_out.value)\n    result = int(dut.dot_product_out.value)\n\n    dut._log.info(f\"DUT Output: result = {result}, valid = {valid}, error = {error}\")\n\n    if error:\n        if not expected_error:\n            dut._log.error(\"Unexpected error detected! Dot product error asserted when it shouldn't be.\")\n            assert False\n        else:\n            dut._log.info(\"Dot product error correctly asserted as expected.\")\n    elif valid:\n        if expected_error:\n            dut._log.error(\"Expected dot product error, but valid_out is HIGH.\")\n            assert False\n        elif result != expected_result:\n            dut._log.error(f\"Result mismatch! Expected: {expected_result}, Got: {result}\")\n            assert False\n        else:\n            dut._log.info(f\"Result matches expected value: {expected_result}\")\n    else:\n        dut._log.error(\"Unexpected state: Neither valid_out nor error_out is asserted.\")\n        assert False\n\n# Original Tests (Updated to include a_complex and b_complex)\n\n@cocotb.test()\nasync def test_case_reset_assert(dut):\n    \"\"\"Test Case: Reset behavior during computation.\"\"\"\n    await initialize_dut(dut)\n\n    vec_a = [1, 1, 1, 1]\n    vec_b = [1, 2, 3, 4]\n\n    await send_vector(dut, vec_a, vec_b, 4, a_complex=0, b_complex=0)\n\n    # Assert reset during computation\n    dut.reset_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    dut._log.info(f\"Inputs after reset: vector_a_in = {dut.vector_a_in.value}, vector_b_in = {dut.vector_b_in.value}\")\n    dut._log.info(f\"Outputs after reset: dot_product_out = {dut.dot_product_out.value}, dot_product_valid_out = {dut.dot_product_valid_out.value}\")\n\n    assert dut.dot_product_out.value == 0, f\"dot_product_out expected to be 0, got {int(dut.dot_product_out.value)}\"\n    assert dut.dot_product_valid_out.value == 0, \"dot_product_valid_out expected to be 0, but it is HIGH\"\n\n    dut._log.info(\"Reset behavior verified: Outputs reset to 0 as expected.\")\n\n@cocotb.test()\nasync def test_case_length_4(dut):\n    \"\"\"Test Case : Length 4.\"\"\"\n    await initialize_dut(dut)\n\n    vec_a = [1, 1, 1, 1]\n    vec_b = [1, 2, 3, 4]\n    expected_result = sum(a * b for a, b in zip(vec_a, vec_b))\n\n    await send_vector(dut, vec_a, vec_b, 4, a_complex=0, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def test_case_length_8(dut):\n    \"\"\"Test Case : Length 8.\"\"\"\n    await initialize_dut(dut)\n\n    vec_a = [2] * 8\n    vec_b = [i + 1 for i in range(8)]\n    expected_result = sum(a * b for a, b in zip(vec_a, vec_b))\n\n    await send_vector(dut, vec_a, vec_b, 8, a_complex=0, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def test_case_random_length_6(dut):\n    \"\"\"Test Case : Random Length 6.\"\"\"\n    await initialize_dut(dut)\n\n    vec_a = [random.randint(0, 255) for _ in range(6)]\n    vec_b = [random.randint(0, 65535) for _ in range(6)]\n    expected_result = sum(a * b for a, b in zip(vec_a, vec_b))\n\n    await send_vector(dut, vec_a, vec_b, 6, a_complex=0, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def test_case_random_length_127(dut):\n    \"\"\"Test Case : Random Length 127.\"\"\"\n    await initialize_dut(dut)\n\n    vec_a = [random.randint(0, 255) for _ in range(127)]\n    vec_b = [random.randint(0, 65535) for _ in range(127)]\n    expected_result = sum(a * b for a, b in zip(vec_a, vec_b))\n\n    await send_vector(dut, vec_a, vec_b, 127, a_complex=0, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def test_case_random_length_99(dut):\n    \"\"\"Test Case : Random Length 99.\"\"\"\n    await initialize_dut(dut)\n\n    vec_a = [random.randint(0, 255) for _ in range(99)]\n    vec_b = [random.randint(0, 65535) for _ in range(99)]\n    expected_result = sum(a * b for a, b in zip(vec_a, vec_b))\n\n    await send_vector(dut, vec_a, vec_b, 99, a_complex=0, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def test_case_random_vectors_and_length(dut):\n    \"\"\"Test Case : Random Length.\"\"\"\n    await initialize_dut(dut)\n\n    length = random.randint(1, 127)\n    vec_a = [random.randint(0, 255) for _ in range(length)]\n    vec_b = [random.randint(0, 65535) for _ in range(length)]\n    expected_result = sum(a * b for a, b in zip(vec_a, vec_b))\n\n    dut._log.info(f\"Random Length: {length}\")\n\n    await send_vector(dut, vec_a, vec_b, length, a_complex=0, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n# New Tests (Appended)\n@cocotb.test()\nasync def dot_product_complex_vecb_test(dut):\n    \"\"\"Test Case: Complex Mode for Vector B\"\"\"\n    await initialize_dut(dut)\n\n    LEN = 4\n    vec_a = [1] * LEN\n    vec_b = [-x for x in range(LEN)]\n\n    # Correctly pack vec_b: MSB = Imaginary, LSB = Real\n    vec_b_twos_complex = [(b & 0xFFFF) | ((b & 0xFFFF) << 16) for b in vec_b]\n\n    # Calculate expected result\n    acc_re, acc_im = 0, 0\n    for a, b in zip(vec_a, vec_b_twos_complex):\n        b_re = b & 0xFFFF\n        b_im = (b >> 16) & 0xFFFF\n\n        b_re = b_re if b_re < 0x8000 else b_re - 0x10000\n        b_im = b_im if b_im < 0x8000 else b_im - 0x10000\n\n        acc_re += a * b_re\n        acc_im += a * b_im\n\n    acc_re &= 0xFFFF\n    acc_im &= 0xFFFF\n    expected_result = (acc_im << 16) | acc_re\n\n    await send_vector(dut, vec_a, vec_b_twos_complex, LEN, a_complex=0, b_complex=1, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def dot_product_complex_veca_test(dut):\n    \"\"\"Test Case: Complex Mode for Vector A\"\"\"\n    await initialize_dut(dut)\n\n    LEN = 4\n    vec_a = [-x for x in range(LEN)]\n    vec_b = [1] * LEN\n\n    # Correctly pack vec_a: MSB = Imaginary, LSB = Real\n    vec_a_twos_complex = [(a & 0xFFFF) | ((a & 0xFFFF) << 16) for a in vec_a]\n\n    acc_re, acc_im = 0, 0\n    for a, b in zip(vec_a_twos_complex, vec_b):\n        a_re = a & 0xFFFF\n        a_im = (a >> 16) & 0xFFFF\n\n        a_re = a_re if a_re < 0x8000 else a_re - 0x10000\n        a_im = a_im if a_im < 0x8000 else a_im - 0x10000\n\n        acc_re += a_re * b\n        acc_im += a_im * b\n\n    acc_re &= 0xFFFF\n    acc_im &= 0xFFFF\n    expected_result = (acc_im << 16) | acc_re\n\n    await send_vector(dut, vec_a_twos_complex, vec_b, LEN, a_complex=1, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def dot_product_both_vec_complex_test(dut):\n    \"\"\"Test Case: Both Vectors in Complex Mode\"\"\"\n    await initialize_dut(dut)\n\n    LEN = 8\n    vec_a = [-x for x in range(LEN)]\n    vec_b = [-x for x in range(LEN)]\n\n    # Correctly pack vec_a and vec_b into unsigned 32-bit format\n    vec_a_twos_complex = [(a & 0xFFFF) | ((a & 0xFFFF) << 16) for a in vec_a]\n    vec_b_twos_complex = [(b & 0xFFFF) | ((b & 0xFFFF) << 16) for b in vec_b]\n\n    # Calculate expected result\n    acc_re = 0\n    acc_im = 0\n    for a, b in zip(vec_a_twos_complex, vec_b_twos_complex):\n        # Extract real and imaginary parts\n        a_re = a & 0xFFFF\n        a_im = (a >> 16) & 0xFFFF\n        b_re = b & 0xFFFF\n        b_im = (b >> 16) & 0xFFFF\n\n        # Convert to signed 16-bit\n        a_re = a_re if a_re < 0x8000 else a_re - 0x10000\n        a_im = a_im if a_im < 0x8000 else a_im - 0x10000\n        b_re = b_re if b_re < 0x8000 else b_re - 0x10000\n        b_im = b_im if b_im < 0x8000 else b_im - 0x10000\n\n        # Accumulate real and imaginary parts\n        acc_re += a_re * b_re - a_im * b_im\n        acc_im += a_re * b_im + a_im * b_re\n\n    # Convert to 16-bit two's complement\n    acc_re &= 0xFFFF\n    acc_im &= 0xFFFF\n\n    # Combine into 32-bit result\n    expected_result = (acc_im << 16) | acc_re\n\n    # Send vectors to the DUT and check the result\n    await send_vector(dut, vec_a_twos_complex, vec_b_twos_complex, LEN, a_complex=1, b_complex=1, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n\n@cocotb.test()\nasync def dot_product_complex_veca_random_vecb_test(dut):\n    \"\"\"Test Case: Complex Mode for Vector A with Random Length and Values for Vector B\"\"\"\n    await initialize_dut(dut)\n\n    # Randomize length and vectors\n    LEN = random.randint(2, 128)  # Random length between 2 and 128\n    vec_a = [-x for x in range(LEN)]  # Deterministic values for vector A\n    vec_b = [random.randint(-128, 127) for _ in range(LEN)]  # Random values for vector B\n\n    # Correctly pack vec_a: MSB = Imaginary, LSB = Real\n    vec_a_twos_complex = [(a & 0xFFFF) | ((a & 0xFFFF) << 16) for a in vec_a]\n\n    acc_re, acc_im = 0, 0\n    for a, b in zip(vec_a_twos_complex, vec_b):\n        a_re = a & 0xFFFF\n        a_im = (a >> 16) & 0xFFFF\n\n        # Convert to signed 16-bit\n        a_re = a_re if a_re < 0x8000 else a_re - 0x10000\n        a_im = a_im if a_im < 0x8000 else a_im - 0x10000\n\n        # Accumulate real and imaginary parts\n        acc_re += a_re * b\n        acc_im += a_im * b\n\n    # Truncate results to 16-bit and combine into 32-bit output\n    acc_re &= 0xFFFF\n    acc_im &= 0xFFFF\n    expected_result = (acc_im << 16) | acc_re\n\n    # Log the test details for debugging\n    dut._log.info(f\"Test Parameters: LEN = {LEN}\")\n    dut._log.info(f\"Expected Result: 0x{expected_result:08X}\")\n\n    # Send vectors to the DUT and check the result\n    await send_vector(dut, vec_a_twos_complex, vec_b, LEN, a_complex=1, b_complex=0, interrupt_valid=False)\n    await check_result(dut, expected_result, expected_error=False)\n\n@cocotb.test()\nasync def dot_product_error_insert_test(dut):\n    \"\"\"Test Case: Complex Mode for Vector B\"\"\"\n    await initialize_dut(dut)\n\n    LEN = 4\n    vec_a = [1] * LEN\n    vec_b = [-x for x in range(LEN)]\n\n    # Correctly pack vec_b: MSB = Imaginary, LSB = Real\n    vec_b_twos_complex = [(b & 0xFFFF) | ((b & 0xFFFF) << 16) for b in vec_b]\n\n    # Calculate expected result\n    acc_re, acc_im = 0, 0\n    for a, b in zip(vec_a, vec_b_twos_complex):\n        b_re = b & 0xFFFF\n        b_im = (b >> 16) & 0xFFFF\n\n        b_re = b_re if b_re < 0x8000 else b_re - 0x10000\n        b_im = b_im if b_im < 0x8000 else b_im - 0x10000\n\n        acc_re += a * b_re\n        acc_im += a * b_im\n\n    acc_re &= 0xFFFF\n    acc_im &= 0xFFFF\n    expected_result = (acc_im << 16) | acc_re\n\n    await send_vector(dut, vec_a, vec_b_twos_complex, LEN, a_complex=0, b_complex=1, interrupt_valid=True)\n    await check_result(dut, expected_result, expected_error=True)\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_encoder_8b10b_0023", "categories": ["cid014", "easy"], "input": {"prompt": "We have an 8b10b encoder module intended for control-symbol encoding only. The encoder converts an 8\u2011bit input into a 10\u2011bit encoded output and tracks running disparity. Internally, it registers the 8\u2011bit input and the control flag. When the control flag is asserted HIGH, the encoder uses a lookup table to map the 8\u2011bit value to a 10\u2011bit control code. Only 12 valid control codes are supported (8'h1C, 8'h3C, 8'h5C, 8'h7C, 8'h9C, 8'hBC, 8'hDC, 8'hFC, 8'hF7, 8'hFB, 8'hFD, and 8'hFE). If an unrecognized control code is detected while the control flag is high, the design defaults to a zero codeword. The encoding behavior is as follows:\n\n- In **data mode** (when no `control_in` is indicated), the encoder output is zero.\n- In **control mode** (when `control_in` is indicated, i.e. when the registered control input, `s_ctrl_reg`, is 1), the encoder uses a lookup based on the 8\u2011bit registered input (`s_in_8b_reg`) to produce a corresponding 10\u2011bit control code. If `s_in_8b_reg` does not match any recognized control code, the design will produce a zero codeword. \n\n**Requirement**:  \nAdd an immediate assertion to this RTL code to verify that the design supports only valid control encoding. The recognized codes are:  \n- 8'h1C, 8'h3C, 8'h5C, 8'h7C, 8'h9C, 8'hBC, 8'hDC, 8'hFC, 8'hF7, 8'hFB, 8'hFD, and 8'hFE.\n\n**Interface**:\n\n- **Inputs**:\n  - `clk_in` (1-bit): Clock signal (active on the rising edge).\n  - `reset_in` (1-bit): Asynchronous reset (active high).\n  - `encoder_in` (8-bit): Data input for encoding.\n  - `control_in` (1-bit): Control input; when high, the encoder should use a control code.\n  \n- **Outputs**:\n  - `disparity_out` (1-bit): Running disparity output (1 indicates positive, 0 indicates negative).\n  - `encoder_out` (10-bit): 10-bit encoded output, which is a concatenation of a 2-bit sync_word and a 64-bit encoded_data.", "context": {"rtl/encoder_8b10b.sv": "module encoder_8b10b (\n    input  logic        clk_in,       // trigger on rising edge\n    input  logic        reset_in,     // reset_in, assert HI\n    input  logic        control_in,   // control char, assert HI for control words\n    input  logic [7:0]  encoder_in,   // 8bit input\n    output logic        disparity_out,// running disparity_out: HI = +1, LO = 0\n    output logic [9:0]  encoder_out   // 10bit codeword output\n);\n\n    typedef enum logic [1:0] {RD_MINUS, RD_PLUS} t_state_type;\n    t_state_type s_RunDisp;\n\n    logic [31:0] c_disPar_6b = 32'b11101000100000011000000110010111;\n    logic [7:0]  c_disPar_4b = 8'b10001001;\n    logic        s_dpTrack;\n    logic [7:0]  s_in_8b_reg;\n    logic        s_ctrl_reg;\n    logic [2:0]  s_ind3b;\n    logic        s_dP4bit;\n    logic [4:0]  s_ind5b;\n    logic        s_dP6bit;\n\n    assign s_ind3b       = s_in_8b_reg[7:5];\n    assign s_dP4bit      = c_disPar_4b[s_ind3b];\n    assign s_ind5b       = s_in_8b_reg[4:0];\n    assign s_dP6bit      = c_disPar_6b[s_ind5b];\n    assign disparity_out = s_dpTrack;\n\n    always_comb begin\n        logic [9:0] v_ctrl_code;\n\n        if (s_ctrl_reg == 1'b1) begin\n            case (s_in_8b_reg)\n                8'h1C: v_ctrl_code = (10'b0011110100);\n                8'h3C: v_ctrl_code = (10'b0011111001);\n                8'h5C: v_ctrl_code = (10'b0011110101);\n                8'h7C: v_ctrl_code = (10'b0011110011);\n                8'h9C: v_ctrl_code = (10'b0011110010);\n                8'hBC: v_ctrl_code = (10'b0011111010);\n                8'hDC: v_ctrl_code = (10'b0011110110);\n                8'hFC: v_ctrl_code = (10'b0011111000);\n                8'hF7: v_ctrl_code = (10'b1110101000);\n                8'hFB: v_ctrl_code = (10'b1101101000);\n                8'hFD: v_ctrl_code = (10'b1011101000);\n                8'hFE: v_ctrl_code = (10'b0111101000);\n                default: v_ctrl_code = (10'b0000000000);\n            endcase\n\n            if (s_RunDisp == RD_MINUS) begin\n                encoder_out = v_ctrl_code;\n                s_dpTrack   = 1'b0;\n            end else begin\n                encoder_out = ~v_ctrl_code;\n                s_dpTrack   = 1'b1;\n            end\n        end else begin\n            encoder_out = 10'b0000000000;\n            v_ctrl_code = 10'b0;\n            s_dpTrack   = 1'b0;\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            s_RunDisp <= RD_MINUS;\n        end else begin\n            if ((s_in_8b_reg[1:0] != 2'b00) && (s_ctrl_reg == 1'b1)) begin\n                s_RunDisp <= s_RunDisp;\n            end else begin\n                case (s_RunDisp)\n                    RD_MINUS: begin\n                        if ((s_ctrl_reg ^ s_dP6bit ^ s_dP4bit) != 1'b0) begin\n                            s_RunDisp <= RD_PLUS;\n                        end\n                    end\n                    RD_PLUS: begin\n                        if ((s_ctrl_reg ^ s_dP6bit ^ s_dP4bit) != 1'b0) begin\n                            s_RunDisp <= RD_MINUS;\n                        end\n                    end\n                    default: s_RunDisp <= RD_MINUS;\n                endcase\n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            s_in_8b_reg <= 8'b00000000;\n        end else begin\n            s_in_8b_reg <= encoder_in;\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            s_ctrl_reg <= 1'b0;\n        end else begin\n            s_ctrl_reg <= control_in;\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/encoder_8b10b.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/encoder_8b10b.sv\nTOPLEVEL        = encoder_8b10b\nMODULE          = test_encoder_8b10b\nPYTHONPATH      = /src\nHASH            = e42a9d46c58335f898d923553c46316a8b523ff8\n", "src/test_encoder_8b10b.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nfrom collections import deque\nimport random\n\n# Special character code values\nK28d0 = \"00011100\"\nK28d1 = \"00111100\"\nK28d2 = \"01011100\"\nK28d3 = \"01111100\"\nK28d4 = \"10011100\"\nK28d5 = \"10111100\"\nK28d6 = \"11011100\"\nK28d7 = \"11111100\"\nK23d7 = \"11110111\"\nK27d7 = \"11111011\"\nK29d7 = \"11111101\"\nK30d7 = \"11111110\"\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and start the clock.\"\"\"\n    dut.reset_in.value = 1\n    dut.control_in.value = 0\n    dut.encoder_in.value = 0\n\n    clock = Clock(dut.clk_in, 50, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n\n    dut.reset_in.value = 0\n\nasync def check_output(dut, expected_value, expected_disparity, input_value):\n    \"\"\"Check the output of the DUT against the expected value.\"\"\"\n    print(f\"Expected: {hex(int(expected_value, 2)):>6}, Got: {hex(int(dut.encoder_out.value.binstr, 2)):>6}, Input: {hex(int(input_value, 2)):>6}\")\n    assert dut.encoder_out.value.binstr == expected_value, f\"Expected {expected_value}, got {dut.encoder_out.value.binstr}\"\n    assert dut.disparity_out.value == expected_disparity, f\"Expected disparity {expected_disparity}, got {dut.disparity_out.value}\"\n\ndef calculate_expected_value(control_symbol, rd):\n    \"\"\"Calculate the expected value based on the control symbol and running disparity.\"\"\"\n    if control_symbol == K28d0:\n        return \"0011110100\" if rd == -1 else \"1100001011\"\n    elif control_symbol == K28d1:\n        return \"0011111001\" if rd == -1 else \"1100000110\"\n    elif control_symbol == K28d2:\n        return \"0011110101\" if rd == -1 else \"1100001010\"\n    elif control_symbol == K28d3:\n        return \"0011110011\" if rd == -1 else \"1100001100\"\n    elif control_symbol == K28d4:\n        return \"0011110010\" if rd == -1 else \"1100001101\"\n    elif control_symbol == K28d5:\n        return \"0011111010\" if rd == -1 else \"1100000101\"\n    elif control_symbol == K28d6:\n        return \"0011110110\" if rd == -1 else \"1100001001\"\n    elif control_symbol == K28d7:\n        return \"0011111000\" if rd == -1 else \"1100000111\"\n    elif control_symbol == K23d7:\n        return \"1110101000\" if rd == -1 else \"0001010111\"\n    elif control_symbol == K27d7:\n        return \"1101101000\" if rd == -1 else \"0010010111\"\n    elif control_symbol == K29d7:\n        return \"1011101000\" if rd == -1 else \"0100010111\"\n    elif control_symbol == K30d7:\n        return \"0111101000\" if rd == -1 else \"1000010111\"\n    else:\n        return \"0000000000\"\n\n\ndef calculate_expected_rd(codeword):\n    #Calculate the expected running disparity (RD) for a given 10-bit codeword.\n    \n    # Hardcoded values from the table\n    rd_0_table = {\n        \"0011110100\": 0, \"0011111001\": 0, \"0011110101\": 0, \"0011110011\": 0,\n        \"0011110010\": 0, \"0011111010\": 0, \"0011110110\": 0, \"0011111000\": 0,\n        \"1110101000\": 0, \"1101101000\": 0, \"1011101000\": 0, \"0111101000\": 0\n    }\n    rd_1_table = {\n        \"1100001011\": 1, \"1100000110\": 1, \"1100001010\": 1, \"1100001100\": 1,\n        \"1100001101\": 1, \"1100000101\": 1, \"1100001001\": 1, \"1100000111\": 1,\n        \"0001010111\": 1, \"0010010111\": 1, \"0100010111\": 1, \"1000010111\": 1\n    }\n    \n    # Check if the codeword exists in either of the tables\n    if codeword in rd_0_table:\n        return rd_0_table[codeword]  # RD = 0\n    elif codeword in rd_1_table:\n        return rd_1_table[codeword]  # RD = 1\n    else:\n        return 0  # Default to RD=0 if no match is found\n\n\n@cocotb.test()\nasync def test_encoder_8b10b_reset(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols and reset HIGH.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d0, K28d1, K28d2, K28d3, K28d4, K28d5, K28d6, K28d7, K23d7, K27d7, K29d7, K30d7]\n    rd = -1  # Initial running disparity\n\n    # Queue to store previous ebi values\n    ebi_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.control_in.value = 1\n        dut.encoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current ebi value in the queue\n        ebi_queue.append(dut.encoder_in.value)\n\n        ebi_binstr = f\"{int(ebi_queue[0]):08b}\"  # Use the delayed ebi value\n        if dut.disparity_out.value == 1:\n            rd = 1\n        else:\n            rd = -1\n                \n    dut.reset_in.value = 1\n    await RisingEdge(dut.clk_in)\n    await RisingEdge(dut.clk_in)\n    expected_value = \"0000000000\"\n    expected_disparity = calculate_expected_rd(expected_value)\n    await check_output(dut, expected_value, expected_disparity, str(dut.encoder_in.value))\n\n    await RisingEdge(dut.clk_in)\n\n@cocotb.test()\nasync def test_continuous_control_symbol(dut):\n    await initialize_dut(dut)\n\n    # Initialize signals for TestBench control functions\n    kcounter = 0\n    dcounter = 0\n    tks = 1\n    dk = 0\n    rd = -1  # Initial running disparity\n\n    # Queue to store previous ebi values\n    ebi_queue = deque([0, 0], maxlen=2)\n\n    # List to store KXX values\n    k_values = [\n        int(K28d0, 2), int(K28d1, 2), int(K28d2, 2), int(K28d3, 2),\n        int(K28d4, 2), int(K28d5, 2), int(K28d6, 2), int(K28d7, 2),\n        int(K23d7, 2), int(K27d7, 2), int(K29d7, 2), int(K30d7, 2)\n    ]\n\n    # Test loop\n    for _ in range(28):  # Adjust the range as needed\n\n        # Update control signals\n        dk = tks\n        dut.control_in.value = dk\n\n        if tks:  # Output K characters\n            dcounter = 0\n            case_value = kcounter % 12\n            dut.encoder_in.value = k_values[case_value]\n        else:  # Output D values\n            dcounter += 1\n            dut.encoder_in.value = dcounter\n            if dcounter == 255:\n                tks = 1  # Repeat K portion\n                kcounter = 0  # Reset K counter\n\n        # Store the current ebi value in the queue\n        ebi_queue.append(dut.encoder_in.value)\n\n        ebi_binstr = f\"{int(ebi_queue[0]):08b}\"  # Use the delayed ebi value\n        \n        if tks:\n            # Control characters\n            expected_value = calculate_expected_value(ebi_binstr, rd)\n            expected_disparity = calculate_expected_rd(str(dut.encoder_out.value))\n        else:\n            # Data characters\n            high_nibble = ebi_binstr[:5]\n            low_nibble = ebi_binstr[5:]\n            expected_value = high_encoded + low_encoded\n\n        await check_output(dut, expected_value, expected_disparity, ebi_binstr)\n        await RisingEdge(dut.clk_in)\n        if dut.disparity_out.value == 1:\n           rd = 1\n        else:\n           rd = -1\n\n        kcounter += 1\n    await Timer(100, units=\"ns\")\n\n@cocotb.test()\nasync def test_initial_default_output(dut):\n    \"\"\"Test initial default output if no input/control input is given.\"\"\"\n    await initialize_dut(dut)\n\n    dut.control_in.value = 0\n    dut.encoder_in.value = 0\n    await RisingEdge(dut.clk_in)\n    expected_value = \"0000000000\"\n    expected_disparity = calculate_expected_rd(str(dut.encoder_out.value))\n    await check_output(dut, expected_value, expected_disparity, str(dut.encoder_in.value))\n\n@cocotb.test()\nasync def test_random_control_symbol(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d0, K28d1, K28d2, K28d3, K28d4, K28d5, K28d6, K28d7, K23d7, K27d7, K29d7, K30d7]\n    rd = -1  # Initial running disparity\n\n    # Queue to store previous ebi values\n    ebi_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(10):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.control_in.value = 1\n        dut.encoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current ebi value in the queue\n        ebi_queue.append(dut.encoder_in.value)\n\n        ebi_binstr = f\"{int(ebi_queue[0]):08b}\"  # Use the delayed ebi value\n        if dut.disparity_out.value == 1:\n            rd = 1\n        else:\n            rd = -1\n        # Calculate the expected value based on the control symbol and running disparity\n        expected_value = calculate_expected_value(ebi_binstr, rd)\n        expected_disparity = calculate_expected_rd(str(dut.encoder_out.value))\n        await check_output(dut, expected_value, expected_disparity, str(dut.encoder_in.value))\n        \n@cocotb.test()\nasync def test_same_control_symbol(dut):\n    \"\"\"Test sending any random control symbol continuously out of 12 symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d6]\n    rd = -1  # Initial running disparity\n\n    # Queue to store previous ebi values\n    ebi_queue = deque([0, 0], maxlen=2)\n\n    for _ in range(20):  # Adjust the range as needed\n        random_symbol = random.choice(control_symbols)\n        dut.control_in.value = 1\n        dut.encoder_in.value = int(random_symbol, 2)\n        await RisingEdge(dut.clk_in)\n\n        # Store the current ebi value in the queue\n        ebi_queue.append(dut.encoder_in.value)\n\n        ebi_binstr = f\"{int(ebi_queue[0]):08b}\"  # Use the delayed ebi value\n        if dut.disparity_out.value == 1:\n            rd = 1\n        else:\n            rd = -1\n        # Calculate the expected value based on the control symbol and running disparity\n        expected_value = calculate_expected_value(ebi_binstr, rd)\n        expected_disparity = calculate_expected_rd(str(dut.encoder_out.value))\n        await check_output(dut, expected_value, expected_disparity, str(dut.encoder_in.value))\n\n\n@cocotb.test()\nasync def test_random_invalid_control_input(dut):\n    \"\"\"Test sending any 8-bit input other than 12 control symbols.\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d0, K28d1, K28d2, K28d3, K28d4, K28d5, K28d6, K28d7, K23d7, K27d7, K29d7, K30d7]\n    rd = -1  # Initial running disparity\n\n    for _ in range(10):  # Adjust the range as needed\n        random_data = random.randint(0, 255)\n        while f\"{random_data:08b}\" in control_symbols:\n            random_data = random.randint(0, 255)\n        dut.control_in.value = 0\n        dut.encoder_in.value = random_data\n        await RisingEdge(dut.clk_in)\n        expected_value = \"0000000000\"  # Example for data characters\n        expected_disparity = calculate_expected_rd(str(dut.encoder_out.value))\n        await check_output(dut, expected_value, expected_disparity, f\"{random_data:08b}\")\n\n        if dut.disparity_out.value == 1:\n            rd = 1\n        else:\n            rd = -1\n\n    await Timer(100, units=\"ns\")\n\n@cocotb.test()\nasync def test_rtl_continuous_control_symbol_encoding(dut):\n    \"\"\"Test continuous input encoding issue for specific control inputs (K28d7, K28d6).\"\"\"\n    await initialize_dut(dut)\n\n    control_symbols = [K28d7, K28d6]\n    rd = -1  # Initial running disparity\n\n    ebi_queue = deque([0, 0], maxlen=2)\n\n    for symbol in control_symbols:\n        cycle_count = 10 if symbol == K28d7 else 11  # K28d7 for 4 cycles, K28d6 for 5 cycles\n        for _ in range(cycle_count):  # Send each symbol for the specified number of clock cycles\n            dut.control_in.value = 1  # Assert control input\n            dut.encoder_in.value = int(symbol, 2)  # Set the control symbol\n            await RisingEdge(dut.clk_in)\n\n            ebi_queue.append(dut.encoder_in.value)\n\n            ebi_binstr = f\"{int(ebi_queue[0]):08b}\"\n            if dut.disparity_out.value == 1:\n                rd = 1\n            else:\n                rd = -1\n\n            expected_value = calculate_expected_value(ebi_binstr, rd)\n            expected_disparity = calculate_expected_rd(str(dut.encoder_out.value))\n\n            await check_output(dut, expected_value, expected_disparity, str(dut.encoder_in.value))\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_events_to_apb_0026", "categories": ["cid014", "easy"], "input": {"prompt": "Add SystemVerilog Assertions (SVA) to validate the result for the apb_controller module. The testbench should check for the outputs for different operating conditions and sequences, including the handling of multiple simultaneous events (Event A, Event B, and Event C), the appropriate assertion of output signals at the correct time, and the built-in timeout mechanism.\n\n#### Inputs:\n- **`clk`**: System clock. The design is synchronized to the positive edge of this clock.\n- **`reset_n`**: Active-low asynchronous reset signal that resets the controller to the `IDLE` state, clears the timeout counter, and sets all registers and outputs to 0.\n- **`select_a_i`**: Active-high control signal to initiate a transaction for Event A.\n- **`select_b_i`**: Active-high control signal to initiate a transaction for Event B.\n- **`select_c_i`**: Active-high control signal to initiate a transaction for Event C.\n- **`addr_a_i [31:0]`**: Address input for Event A.\n- **`data_a_i [31:0]`**: Data input for Event A.\n- **`addr_b_i [31:0]`**: Address input for Event B.\n- **`data_b_i [31:0]`**: Data input for Event B.\n- **`addr_c_i [31:0]`**: Address input for Event C.\n- **`data_c_i [31:0]`**: Data input for Event C.\n- **`apb_pready_i`**:  Ready signal from the peripheral, active high. It indicates when the peripheral is ready to complete the transaction. The controller checks this signal in the `ACCESS` phase to determine transaction completion.\n\n#### Outputs:\n- **`apb_psel_o`**: An active-high signal, asserted during `SETUP`, to select the peripheral for an APB transaction.\n- **`apb_penable_o`**: An active-high signal, asserted during the `ACCESS` phase, indicating the transaction is in progress.\n- **`apb_pwrite_o`**: An active-high signal indicating a write operation, asserted during the `SETUP` and maintained in the `ACCESS` phase.\n- **`apb_paddr_o [31:0]`**: 32-bit address output for the transaction, determined by the selected event's address input (`addr_a_i`, `addr_b_i`, or `addr_c_i`). Defaults to 0 in the `IDLE` state.\n- **`apb_pwdata_o [31:0]`**: 32-bit data output for the write operation, based on the selected event's data input (`data_a_i`, `data_b_i`, or `data_c_i`). Defaults to 0 in the `IDLE` state.\n\n#### Assertion Generation: \n\n1. Setting of `apb_psel_o` and latency validation when the queue is empty: When the queue is empty (`event_list == 0`) and new events are triggered (`select_a_i` or  `select_b_i` or `select_c_i`),  the latency from the event assertion to the first `apb_psel_o` assertion is 3 clock cycles.\n\n2. Setting of `apb_psel_o` and latency validation when the queue is not empty: When the queue is not empty (`event_list != 0`) and the transaction from the previous event has just been completed ( `apb_penable_o` is de-asserted), the latency from the end of the previous event to the `apb_psel_o` assertion for the next event in the queue is 1 clock cycles.    \n\n4. Setting of `apb_psel_o` and latency validation when the queue is empty and another one of the events has already been latched: When the queue is empty (`event_list` is equal to 0 ), and the transaction from the previous event has just been completed (`apb_penable_o` is de-asserted),  but another of the events has already been latched (`select_a_pulse` or  `select_b_pulse` or `select_c_pulse`),  the latency from the end of the previous event to the `apb_psel_o` assertion is 2 clock cycles.   \n \n5. Setting of `apb_penable_o`: When `apb_psel_o` is set, the `apb_penable_o` is asserted 1 clock cycle after the `apb_psel_o`.\n\n6. The setting of `apb_pwrite_o`: When `apb_psel_o` is set, the `apb_pwrite_o` is also asserted in the same cycle. \n\n7. Maximum timeout for `apb_pready_i`: When `apb_penable_o` is asserted for an event, `apb_pready_i` must be asserted within 15 clock cycles to complete the transaction. If `apb_pready_i` remains low for 15 cycles, both `apb_psel_o` and `apb_penable_o` must be de-asserted before for next event to begin.\n\n8. Checking of the priority of events which follows A > B > C based on if the event is selected: If all three events (`select_a_i`, `select_b_i`, `select_c_i`) are selected and the queue is empty (`event_list == 0`), `apb_paddr_o` must be set to `addr_a_i` after 3 clock cycles, ensuring event A has the highest priority. If only events B and C are selected and the queue is empty, `apb_paddr_o` must be set to `addr_b_i` after 3 clock cycles, confirming event B takes priority over event C.", "context": {"rtl/apb_controller.sv": "module apb_controller(\n    input  logic         clk,              // Clock signal\n    input  logic         reset_n,          // Active low asynchronous reset signal\n    input  logic         select_a_i,       // Select signal for event A\n    input  logic         select_b_i,       // Select signal for event B\n    input  logic         select_c_i,       // Select signal for event C\n    input  logic [31:0]  addr_a_i,         // 32-bit address for event A transaction\n    input  logic [31:0]  data_a_i,         // 32-bit data for event A transaction\n    input  logic [31:0]  addr_b_i,         // 32-bit address for event B transaction\n    input  logic [31:0]  data_b_i,         // 32-bit data for event B transaction\n    input  logic [31:0]  addr_c_i,         // 32-bit address for event C transaction\n    input  logic [31:0]  data_c_i,         // 32-bit data for event C transaction\n    output logic         apb_psel_o,       // APB select signal\n    output logic         apb_penable_o,    // APB enable signal\n    output logic [31:0]  apb_paddr_o,      // 32-bit APB address output\n    output logic         apb_pwrite_o,     // APB write signal\n    output logic [31:0]  apb_pwdata_o,     // 32-bit APB write data output\n    input  logic         apb_pready_i      // APB ready signal from the peripheral\n);\n\n    // State definitions\n    typedef enum logic [1:0] {\n       IDLE,   \n       SETUP,  \n       ACCESS\n    } state_t; \n\n    logic [3:0]  count;\n    logic [2:0]  event_sel; \n    logic [2:0]  event_sel_ff; \n    logic [2:0]  event_list;    \n    state_t      current_state, next_state;\n    logic [31:0] sel_addr_next, sel_data_next;  \n    logic [31:0] sel_addr, sel_data;          \n    logic select_a_pulse, select_b_pulse, select_c_pulse;\n\n    assign apb_psel_o    = (current_state == SETUP || current_state == ACCESS) ? 1'b1 : 1'b0;\n    assign apb_penable_o = (current_state == ACCESS) ? 1'b1 : 1'b0;\n    assign apb_pwrite_o  = (current_state == SETUP || current_state == ACCESS) ? 1'b1 : 1'b0;\n    assign apb_paddr_o   = (current_state == SETUP || current_state == ACCESS) ? sel_addr : 32'b0;\n    assign apb_pwdata_o  = (current_state == SETUP || current_state == ACCESS) ? sel_data : 32'b0;\n\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            current_state <= IDLE;\n            event_list    <= 3'b000; \n            event_sel_ff    <= 3'b000; \n            select_a_pulse  <= 1'b0;  \n            select_b_pulse  <= 1'b0; \n            select_c_pulse  <= 1'b0;             \n        end else begin\n            select_a_pulse <= (select_a_i) ? 1'b1 : select_a_pulse;\n            select_b_pulse <= (select_b_i) ? 1'b1 : select_b_pulse;\n            select_c_pulse <= (select_c_i) ? 1'b1 : select_c_pulse;      \n            event_sel_ff   <= event_sel;              \n            current_state  <= next_state;\n            if (current_state == IDLE) begin\n               event_list <= (select_a_pulse ? 3'b001 : 3'b000) | \n                               (select_b_pulse ? 3'b010 : 3'b000) |\n                               (select_c_pulse ? 3'b100 : 3'b000); \n            end \n            else if (next_state == IDLE) begin\n               select_a_pulse <= (event_sel[0]) ? 1'b0 : select_a_pulse;\n               select_b_pulse <= (event_sel[1]) ? 1'b0 : select_b_pulse;\n               select_c_pulse <= (event_sel[2]) ? 1'b0 : select_c_pulse;    \n               event_list   <= event_list & ~event_sel; \n            end            \n        end\n    end\n\n\n    always @(*) begin\n        // Default values\n        next_state = current_state;\n        event_sel  = event_sel_ff; \n        case (current_state)\n            IDLE: begin\n                if (event_list[0]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b001;\n                end else if (event_list[1]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b010;\n                end else if (event_list[2]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b100;\n                end else begin\n                   next_state = IDLE;\n                   event_sel  = 3'b000;\n                end\n            end\n            SETUP: begin\n                next_state = ACCESS;\n            end\n            ACCESS: begin\n                if (apb_pready_i || count == 15) begin\n                    next_state = IDLE;\n                end    \n            end\n            default: begin\n                next_state = IDLE; \n                event_sel  = 3'b000;                 \n            end    \n        endcase\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            count <= 0;\n        end else if (current_state == ACCESS && !apb_pready_i) begin\n            count <= count + 1;\n        end else begin\n            count <= 0;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            sel_addr <= 32'b0;\n            sel_data <= 32'b0;\n        end else if (current_state == IDLE) begin\n            sel_addr <= sel_addr_next;\n            sel_data <= sel_data_next;\n        end\n    end\n    \n    always @(*) begin\n        if (!reset_n) begin\n           sel_addr_next = sel_addr;\n           sel_data_next = sel_data;       \n        end \n        else begin \n            if (next_state == SETUP || next_state == ACCESS) begin\n                case (event_sel)\n                    3'b001: begin    \n                       sel_addr_next = addr_a_i; \n                       sel_data_next = data_a_i;                     \n                    end    \n                    3'b010: begin                    \n                       sel_addr_next = addr_b_i; \n                       sel_data_next = data_b_i;    \n                    end\n                    3'b100: begin                      \n                       sel_addr_next = addr_c_i; \n                       sel_data_next = data_c_i; \n                    end\n                    default: begin\n                       sel_addr_next = 32'b0; \n                       sel_data_next = 32'b0;                     \n                    end \n                endcase           \n            end     \n        end        \n    end    \n\nendmodule"}}, "output": {"response": "", "context": {"rtl/apb_controller.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/apb_controller.sv\nTOPLEVEL        = apb_controller\nMODULE          = test_apb_controller\nPYTHONPATH      = /src\nHASH            = 26-assertion-events-to-ap", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build -vcd dumpon\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n\ndef generate_random_event(base_addr):\n    addr = random.randint(base_addr, base_addr + 0x0FFF_FFFF)\n    data = random.randint(0x0000_0000, 0xFFFF_FFFF)\n    return addr, data\n\nasync def async_reset_dut(dut):\n    dut.reset_n.value = 1\n    await FallingEdge(dut.clk)\n    dut.reset_n.value = 0\n    await Timer(2, units=\"ns\")  # Small delay\n    assert dut.apb_psel_o.value == 0, \"APB select should be 0 at reset\"\n    assert dut.apb_penable_o.value == 0, \"APB enable should be 0 at reset\"\n    assert dut.apb_pwrite_o.value == 0, \"APB write signal should be 0 at reset\"\n    assert dut.apb_paddr_o.value == 0, \"APB address should be 0 at reset\"\n    assert dut.apb_pwdata_o.value == 0, \"APB data should be 0 at reset\"\n    await RisingEdge(dut.clk)\n    dut.reset_n.value = 1\n    await RisingEdge(dut.clk)\n\nasync def run_apb_test_with_delay(dut, select_signal, expected_addr, expected_data):\n    select_signal.value = 1\n    dut.apb_pready_i.value = 0\n\n    await RisingEdge(dut.clk)\n    select_signal.value = 0\n\n    latency_sel = 0\n    while dut.apb_psel_o.value == 0:\n        await RisingEdge(dut.clk)\n        latency_sel += 1\n\n    assert latency_sel == 3, f\"Latency from `apb_psel_o` should be 3 cycles, got {latency_sel}\"\n    assert dut.apb_psel_o.value == 1, \"APB select signal should be high in SETUP state\"\n    assert dut.apb_paddr_o.value == expected_addr, f\"APB address mismatch: {hex(expected_addr)}\"\n    assert dut.apb_pwdata_o.value == expected_data, f\"APB data mismatch: {hex(expected_data)}\"\n\n    latency_enable = 0\n    while dut.apb_penable_o.value == 0:\n        await RisingEdge(dut.clk)\n        latency_enable += 1\n\n    assert latency_enable == 1, f\"Latency from `apb_psel_o` to `apb_penable_o` is wrong, got {latency_enable}\"\n    assert dut.apb_penable_o.value == 1, \"APB enable signal should be asserted in ACCESS state\"\n    assert dut.apb_pwrite_o.value == 1, \"APB write signal should be high in SETUP state\"\n\n    await Timer(3, units=\"ns\")\n    dut.apb_pready_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.apb_pready_i.value = 0\n\n    latency_rdy = 0\n    while dut.apb_penable_o.value == 1:\n        await RisingEdge(dut.clk)\n        latency_rdy += 1\n\n    assert latency_rdy == 1, f\"Latency from `apb_penable_o` deassertion is wrong, got {latency_rdy}\"\n    assert dut.apb_psel_o.value == 0, \"APB select signal should be deasserted after ACCESS\"\n    assert dut.apb_penable_o.value == 0, \"APB enable signal should be deasserted after ACCESS state\"    \n    assert dut.apb_pwrite_o.value == 0, \"APB write signal should be deasserted after ACCESS state\"  \n    assert dut.apb_paddr_o.value == 0, \"APB address should be deasserted after ACCESS state\"\n    assert dut.apb_pwdata_o.value == 0, \"APB data should be deasserted after ACCESS state\"        \n\nasync def run_apb_test_without_delay(dut, select_signal, expected_addr, expected_data):\n    select_signal.value = 1\n    dut.apb_pready_i.value = 0\n\n    await RisingEdge(dut.clk)\n    select_signal.value = 0\n\n    latency_sel = 0  \n    while dut.apb_psel_o.value == 0:\n        await RisingEdge(dut.clk)\n        latency_sel += 1\n\n    dut.apb_pready_i.value = 1  \n    assert latency_sel == 3, f\"Latency from `apb_psel_o` should be 3 cycles, got {latency_sel}\"\n    assert dut.apb_psel_o.value == 1, \"APB select signal should be high in SETUP state\"\n    assert dut.apb_paddr_o.value == expected_addr, f\"APB address mismatch: {hex(expected_addr)}\"\n    assert dut.apb_pwdata_o.value == expected_data, f\"APB data mismatch: {hex(expected_data)}\"\n\n    await RisingEdge(dut.clk)\n    assert dut.apb_penable_o.value == 1, \"APB enable signal should be asserted in ACCESS state\"\n    assert dut.apb_pwrite_o.value == 1, \"APB write signal should be high in SETUP state\"\n    dut.apb_pready_i.value = 0  \n    \n    latency_rdy = 0\n    while dut.apb_penable_o.value == 1:\n        await RisingEdge(dut.clk)\n        latency_rdy += 1\n\n    assert latency_rdy == 1, f\"Latency from `apb_penable_o` deassertion is wrong, got {latency_rdy}\"\n    assert dut.apb_psel_o.value == 0, \"APB select signal should be deasserted after ACCESS\"\n    assert dut.apb_penable_o.value == 0, \"APB enable signal should be deasserted after ACCESS state\"    \n    assert dut.apb_pwrite_o.value == 0, \"APB write signal should be deasserted after ACCESS state\" \n    assert dut.apb_paddr_o.value == 0, \"APB address should be deasserted after ACCESS state\"\n    assert dut.apb_pwdata_o.value == 0, \"APB data should be deasserted after ACCESS state\"       \n\nasync def test_timeout(dut, select_signal, expected_addr, expected_data):\n    select_signal.value = 1\n    dut.apb_pready_i.value = 0\n\n    await RisingEdge(dut.clk)\n    select_signal.value = 0\n    for _ in range(5): \n        await RisingEdge(dut.clk)\n\n    timeout_cycles = 15\n    for _ in range(timeout_cycles):\n        await RisingEdge(dut.clk)\n\n    assert dut.apb_psel_o.value == 0, \"APB select should be deasserted after timeout\"\n    assert dut.apb_penable_o.value == 0, \"APB enable should be deasserted after timeout\"  \n    assert dut.apb_pwrite_o.value == 0, \"APB write signal should be deasserted after timeout\" \n    assert dut.apb_paddr_o.value == 0, \"APB address should be deasserted after timeout\"\n    assert dut.apb_pwdata_o.value == 0, \"APB data should be deasserted after timeout\"          \n\nasync def check_apb_output_order_first_in_queue(dut, events):\n    for event in events:\n        select_signal = event['select']\n        addr = event['addr']\n        data = event['data']\n        \n        for _ in range(3):\n            await RisingEdge(dut.clk) \n        assert dut.apb_psel_o.value == 1, \"APB select signal should be high\"\n\n        await RisingEdge(dut.clk)\n        assert dut.apb_penable_o.value == 1, \"APB enable should be high during transaction\"\n        assert int(dut.apb_paddr_o.value) == addr, f\"APB address should match {hex(addr)}. Found: {hex(int(dut.apb_paddr_o.value))}\"\n        assert int(dut.apb_pwdata_o.value) == data, f\"APB data should match {hex(data)}. Found: {hex(int(dut.apb_pwdata_o.value))}\"\n\n        for _ in range(3,8):\n            await RisingEdge(dut.clk)\n        dut.apb_pready_i.value = 1\n        await RisingEdge(dut.clk)\n        dut.apb_pready_i.value = 0\n        \n        await RisingEdge(dut.clk)\n        assert dut.apb_psel_o.value == 0, \"APB select should be deasserted after transaction\"\n        assert dut.apb_penable_o.value == 0, \"APB enable should be deasserted after transaction\"\n        assert dut.apb_paddr_o.value == 0, \"APB address should be deasserted after transaction\"\n        assert dut.apb_pwdata_o.value == 0, \"APB data should be deasserted after transaction\"\n\n\nasync def check_apb_output_order_subsequent_1(dut, events):\n    for event in events:\n        select_signal = event['select']\n        addr = event['addr']\n        data = event['data']\n        \n        \n        assert dut.apb_psel_o.value == 1, \"APB select signal should be high\"\n\n        await RisingEdge(dut.clk)\n        assert dut.apb_penable_o.value == 1, \"APB enable should be high during transaction\"\n        assert int(dut.apb_paddr_o.value) == addr, f\"APB address should match {hex(addr)}. Found: {hex(int(dut.apb_paddr_o.value))}\"\n        assert int(dut.apb_pwdata_o.value) == data, f\"APB data should match {hex(data)}. Found: {hex(int(dut.apb_pwdata_o.value))}\"\n\n        for _ in range(3,8):\n            await RisingEdge(dut.clk)\n        dut.apb_pready_i.value = 1\n        await RisingEdge(dut.clk)\n        dut.apb_pready_i.value = 0\n        \n        await RisingEdge(dut.clk)\n        assert dut.apb_psel_o.value == 0, \"APB select should be deasserted after transaction\"\n        assert dut.apb_penable_o.value == 0, \"APB enable should be deasserted after transaction\"\n        assert dut.apb_paddr_o.value == 0, \"APB address should be deasserted after transaction\"\n        assert dut.apb_pwdata_o.value == 0, \"APB data should be deasserted after transaction\"\n\n\nasync def check_apb_output_order_subsequent_2(dut, events):\n    for event in events:\n        select_signal = event['select']\n        addr = event['addr']\n        data = event['data']\n        \n        await RisingEdge(dut.clk)\n        assert dut.apb_psel_o.value == 1, \"APB select signal should be high\"\n\n        await RisingEdge(dut.clk)\n        assert dut.apb_penable_o.value == 1, \"APB enable should be high during transaction\"\n        assert int(dut.apb_paddr_o.value) == addr, f\"APB address should match {hex(addr)}. Found: {hex(int(dut.apb_paddr_o.value))}\"\n        assert int(dut.apb_pwdata_o.value) == data, f\"APB data should match {hex(data)}. Found: {hex(int(dut.apb_pwdata_o.value))}\"\n\n        for _ in range(3,8):\n            await RisingEdge(dut.clk)\n        dut.apb_pready_i.value = 1\n        await RisingEdge(dut.clk)\n        dut.apb_pready_i.value = 0\n        \n        await RisingEdge(dut.clk)\n        assert dut.apb_psel_o.value == 0, \"APB select should be deasserted after transaction\"\n        assert dut.apb_penable_o.value == 0, \"APB enable should be deasserted after transaction\"\n        assert dut.apb_paddr_o.value == 0, \"APB address should be deasserted after transaction\"\n        assert dut.apb_pwdata_o.value == 0, \"APB data should be deasserted after transaction\"\n\n", "src/test_apb_controller.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\nimport harness_library as hrs_lb\nfrom collections import deque\n\n@cocotb.test()\nasync def test_apb_controller_with_delay(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.async_reset_dut(dut)\n\n    dut.select_a_i.value = 0\n    dut.select_b_i.value = 0\n    dut.select_c_i.value = 0\n\n    for _ in range(5):\n        addr = random.randint(0x10000000, 0x1FFFFFFF)\n        data = random.randint(0x00000000, 0xFFFFFFFF)\n        dut.addr_a_i.value = addr\n        dut.data_a_i.value = data\n        await hrs_lb.run_apb_test_with_delay(dut, dut.select_a_i, addr, data)\n\n@cocotb.test()\nasync def test_apb_controller_without_delay(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.async_reset_dut(dut)\n\n    dut.select_a_i.value = 0\n    dut.select_b_i.value = 0\n    dut.select_c_i.value = 0\n\n    for _ in range(5):\n        addr = random.randint(0x10000000, 0x1FFFFFFF)\n        data = random.randint(0x00000000, 0xFFFFFFFF)\n        dut.addr_b_i.value = addr\n        dut.data_b_i.value = data\n        await hrs_lb.run_apb_test_without_delay(dut, dut.select_b_i, addr, data)\n\n@cocotb.test()\nasync def test_apb_controller_with_timeout(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.async_reset_dut(dut)\n\n    dut.select_a_i.value = 0\n    dut.select_b_i.value = 0\n    dut.select_c_i.value = 0\n\n    addr = random.randint(0x10000000, 0x1FFFFFFF)\n    data = random.randint(0x00000000, 0xFFFFFFFF)\n    dut.addr_c_i.value = addr\n    dut.data_c_i.value = data\n    await hrs_lb.test_timeout(dut, dut.select_c_i, addr, data)\n\n\n@cocotb.test()\nasync def test_apb_controller_varied_events(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    await hrs_lb.async_reset_dut(dut)\n\n    # Scenario 1: All three select signals asserted simultaneously\n    addr_a, data_a = hrs_lb.generate_random_event(0x1000_0000)\n    addr_b, data_b = hrs_lb.generate_random_event(0x2000_0000)\n    addr_c, data_c = hrs_lb.generate_random_event(0x3000_0000)\n\n    dut.addr_a_i.value = addr_a\n    dut.data_a_i.value = data_a\n    dut.addr_b_i.value = addr_b\n    dut.data_b_i.value = data_b\n    dut.addr_c_i.value = addr_c\n    dut.data_c_i.value = data_c\n\n    dut.select_a_i.value = 1\n    dut.select_b_i.value = 1\n    dut.select_c_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_a_i.value = 0\n    dut.select_b_i.value = 0\n    dut.select_c_i.value = 0\n\n    await hrs_lb.check_apb_output_order_first_in_queue(dut, [\n        {'select': dut.select_a_i, 'addr': addr_a, 'data': data_a}      \n    ])\n\n    await hrs_lb.check_apb_output_order_subsequent_2(dut, [\n        {'select': dut.select_b_i,'addr': addr_b, 'data': data_b}, \n        {'select': dut.select_c_i,'addr': addr_c, 'data': data_c}   \n    ])\n\n    # Scenario 2: Two select signals (A and B)\n    addr_a, data_a = hrs_lb.generate_random_event(0x1000_0000)\n    addr_b, data_b = hrs_lb.generate_random_event(0x2000_0000)\n\n    dut.addr_a_i.value = addr_a\n    dut.data_a_i.value = data_a\n    dut.addr_b_i.value = addr_b\n    dut.data_b_i.value = data_b\n\n    dut.select_a_i.value = 1\n    dut.select_b_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_a_i.value = 0\n    dut.select_b_i.value = 0\n\n    await hrs_lb.check_apb_output_order_first_in_queue(dut, [\n        {'select': dut.select_a_i, 'addr': addr_a, 'data': data_a}      \n    ])\n\n    await hrs_lb.check_apb_output_order_subsequent_2(dut, [\n        {'select': dut.select_b_i,'addr': addr_b, 'data': data_b}  \n    ])\n\n    # Scenario 3: Two select signals (B and C)\n    addr_b, data_b = hrs_lb.generate_random_event(0x2000_0000)\n    addr_c, data_c = hrs_lb.generate_random_event(0x3000_0000)\n\n    dut.addr_b_i.value = addr_b\n    dut.data_b_i.value = data_b\n    dut.addr_c_i.value = addr_c\n    dut.data_c_i.value = data_c\n\n    dut.select_b_i.value = 1\n    dut.select_c_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_b_i.value = 0\n    dut.select_c_i.value = 0\n\n    await hrs_lb.check_apb_output_order_first_in_queue(dut, [\n        {'select': dut.select_b_i, 'addr': addr_b, 'data': data_b}      \n    ])\n\n    await hrs_lb.check_apb_output_order_subsequent_2(dut, [\n        {'select': dut.select_c_i,'addr': addr_c, 'data': data_c}  \n    ])\n \n\n    # Scenario 4: Overlapping Event Reassertion\n    addr_a, data_a = hrs_lb.generate_random_event(0x1000_0000)\n    addr_b, data_b = hrs_lb.generate_random_event(0x2000_0000)\n    addr_c, data_c = hrs_lb.generate_random_event(0x3000_0000)\n\n    dut.addr_a_i.value = addr_a\n    dut.data_a_i.value = data_a\n    dut.addr_b_i.value = addr_b\n    dut.data_b_i.value = data_b\n    dut.addr_c_i.value = addr_c\n    dut.data_c_i.value = data_c\n\n    dut.select_a_i.value = 1\n    dut.select_b_i.value = 1\n    dut.select_c_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_a_i.value = 0\n    dut.select_b_i.value = 0\n    dut.select_c_i.value = 0\n\n    await hrs_lb.check_apb_output_order_first_in_queue(dut, [\n        {'select': dut.select_a_i, 'addr': addr_a, 'data': data_a}      \n    ])\n\n    dut.select_a_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_a_i.value = 0\n\n    await hrs_lb.check_apb_output_order_subsequent_1(dut, [\n        {'select': dut.select_b_i,'addr': addr_b, 'data': data_b}\n    ])\n\n    dut.select_b_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_b_i.value = 0    \n\n    await hrs_lb.check_apb_output_order_subsequent_1(dut, [\n        {'select': dut.select_c_i,'addr': addr_c, 'data': data_c}   \n    ])\n\n    dut.select_c_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_c_i.value = 0    \n\n    await hrs_lb.check_apb_output_order_subsequent_1(dut, [\n        {'select': dut.select_a_i,'addr': addr_a, 'data': data_a} \n    ])\n\n    await hrs_lb.check_apb_output_order_subsequent_2(dut, [\n        {'select': dut.select_b_i,'addr': addr_b, 'data': data_b}, \n        {'select': dut.select_c_i,'addr': addr_c, 'data': data_c}   \n    ])\n  \n     # Scenario 5: Overlapping Event Reassertion with an select signal already latched\n    addr_a, data_a = hrs_lb.generate_random_event(0x1000_0000)\n    addr_b, data_b = hrs_lb.generate_random_event(0x2000_0000)\n    addr_c, data_c = hrs_lb.generate_random_event(0x3000_0000)\n\n    dut.addr_a_i.value = addr_a\n    dut.data_a_i.value = data_a\n    dut.addr_b_i.value = addr_b\n    dut.data_b_i.value = data_b\n    dut.addr_c_i.value = addr_c\n    dut.data_c_i.value = data_c\n\n    dut.select_a_i.value = 1\n    dut.select_b_i.value = 1\n    dut.select_c_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_a_i.value = 0\n    dut.select_b_i.value = 0\n    dut.select_c_i.value = 0\n\n    await hrs_lb.check_apb_output_order_first_in_queue(dut, [\n        {'select': dut.select_a_i, 'addr': addr_a, 'data': data_a}      \n    ])\n\n    await RisingEdge(dut.clk)\n\n    await hrs_lb.check_apb_output_order_subsequent_1(dut, [\n        {'select': dut.select_b_i,'addr': addr_b, 'data': data_b}\n    ])\n\n    dut.select_b_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_b_i.value = 0     \n\n    await hrs_lb.check_apb_output_order_subsequent_1(dut, [\n        {'select': dut.select_c_i,'addr': addr_c, 'data': data_c} \n    ])\n\n    dut.select_a_i.value = 1\n    await RisingEdge(dut.clk)\n    dut.select_a_i.value = 0  \n\n    await RisingEdge(dut.clk)\n\n    await hrs_lb.check_apb_output_order_subsequent_1(dut, [\n        {'select': dut.select_b_i,'addr': addr_b, 'data': data_b}\n    ])\n  ", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner():\n   \n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n        hrs_lb.xrun_tb()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n\ndef test_apb():\n    # Run the simulation\n    call_runner()   "}}}
{"id": "cvdp_copilot_filo_0036", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertion in the RTL design of the `FILO_RTL` module to ensure its correct functionality during simulation? The assertion should cover key aspects of the `FILO` (First-In-Last-Out) stack operation, ensuring that the stack pointer remains within bounds, push and pop operations occur under valid conditions, and the full/empty flags are correctly asserted.\n\n___\n### Key Assertion\n**1. Stack Pointer Validity**\n  - Condition:\n    - The top pointer must always remain within the valid range  `FILO_DEPTH`.\n    - If top exceeds `FILO_DEPTH` or becomes negative, an assertion should trigger an error message.\n\n  - Assertion Implementation:\n    - Check top value during every clock cycle.\n\n  - Error Message:\n    - Display current top pointer value and simulation time when the assertion fails.\n\n##\n### Implementation Requirements\n\n**1. Placement**\n  - Assertions must be placed inside the RTL module (`FILO_RTL`) to ensure violations are detected in real-time during simulation.\n\n**2. Immediate Assertions**\n  - Use `assert()` inside `always` blocks to check for invalid conditions at every clock cycle.\n\n**3. Failure Handling**\n  - If an assertion fails, the simulation should:\n    - Display debug information using `$display()`, including `$time`.\n    - Provide a clear error message to help identify the issue.\n___\n### Interface\n\n**Parameters**\n  - `DATA_WIDTH`: Defines the width of the data stored in the FILO stack (`Default: 8`).\n  - `FILO_DEPTH`: Defines the depth of the FILO stack, determining how many elements it can hold (`Default: 16`).\n\n**Inputs:**\n  - `clk(1-bit)`: This signal drives the FILO operation. All operations (push, pop) happen on the rising edge of the clock.\n  - `reset(1-bit)`: Resets the FILO stack, clearing all stored data and setting the top pointer to 0. \n  - `push(1-bit)`: When high (1), a new data value (`data_in`) is pushed onto the FILO stack.\n  - `pop(1-bit)`: When high (1), the last stored value is popped from the FILO stack.\n  - `data_in [DATA_WIDTH-1:0]`: Data to be pushed into the FILO stack.\n\n**Outputs:**\n  - `data_out [DATA_WIDTH-1:0]`: Data popped from the FILO stack.\n  - `full(1-bit)`: Indicates if the FILO is full.\n  - `empty(1-bit)`: Indicates if the FILO is empty.", "context": {"rtl/FILO_RTL.sv": "module FILO_RTL #(\n    parameter DATA_WIDTH = 8,\n    parameter FILO_DEPTH = 16\n) (\n    input logic clk,\n    input logic reset,\n    input logic push,\n    input logic pop,\n    input logic [DATA_WIDTH-1:0] data_in,\n    output logic [DATA_WIDTH-1:0] data_out,\n    output logic full,\n    output logic empty\n);\n\n  // Internal signals\n  logic [DATA_WIDTH-1:0] stack_mem[0:FILO_DEPTH-1];\n  logic [$clog2(FILO_DEPTH)-1:0] top;\n  logic [DATA_WIDTH-1:0] data_reg;\n\n  // Stack memory and status management\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      top   <= 0;\n      full  <= 0;\n      empty <= 1;\n    end else begin\n      if (push && !full) begin\n        stack_mem[top] <= data_in;\n        top <= top + 1;\n        empty <= 0;  \n\n        // Correct full flag update\n        if (top + 1 == FILO_DEPTH) begin\n          full <= 1;\n        end else begin\n          full <= 0;\n        end\n\n      end else if (pop && !empty) begin\n        top <= top - 1;\n        data_reg <= stack_mem[top-1];\n        full <= 0;  \n\n        if (top - 1 == 0) begin\n          empty <= 1;\n        end else begin\n          empty <= 0;\n        end\n      end\n    end\n  end\n\n  // Output assignments\n  assign data_out = data_reg;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/FILO_RTL.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/FILO_RTL.sv\nTOPLEVEL        = FILO_RTL\nMODULE          = test_filo\nPYTHONPATH      = /src\nHASH            = 36-assertion-generation-for-first-in-last-outfilo\n", "src/test_filo.py": "\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n\n@cocotb.test()\nasync def test_filo_rtl(dut):\n    \"\"\" Test FILO RTL behavior \"\"\"\n\n    # Initialize clock\n    clock = Clock(dut.clk, 10, units=\"ns\")  # Create a 10ns period clock\n    cocotb.start_soon(clock.start())        # Start the clock\n\n    # Reset the design\n    await reset_filo(dut)\n\n    # Push values into the FILO\n    data_to_push = [random.randint(0, 99) for _ in range(16)]\n    await push_values(dut, data_to_push)\n\n    # Pop values from the FILO and check the order\n    await pop_values(dut, data_to_push)\n\n\nasync def reset_filo(dut):\n    \"\"\" Reset the FILO module \"\"\"\n    dut.reset.value = 1\n    await Timer(20, units=\"ns\")  # Wait for a few clock cycles\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)    # Sync to clock edge\n\n    assert dut.empty.value == 1, \"FILO should be empty after reset\"\n    assert dut.full.value == 0, \"FILO should not be full after reset\"\n\n\nasync def push_values(dut, values):\n    \"\"\" Push values into the FILO \"\"\"\n    push_count = 0  # Initialize push count\n    \n    # Use enumerate to get both index (i) and value\n    for i, value in enumerate(values):\n        dut.push.value = 1\n        dut.pop.value = 0\n        dut.data_in.value = value\n        await RisingEdge(dut.clk)\n        dut.push.value = 0\n        await RisingEdge(dut.clk)\n        \n        push_count += 1  # Increment push count\n\n        # Debugging info, include push count\n        dut._log.info(f\"Push #{push_count}: pushed_value={value}, top={dut.top.value}, full={dut.full.value}, empty={dut.empty.value}\")\n\n        # Check if full when pushing the last element\n        if i == len(values) - 1:\n            assert dut.full.value == 1, \"FILO should be full after pushing maximum elements\"\n        else:\n            assert dut.full.value == 0, \"FILO should not be full before maximum elements are pushed\"\n        assert dut.empty.value == 0, \"FILO should not be empty after pushing\"\n\n\nasync def pop_values(dut, expected_values):\n    \"\"\" Pop values from the FILO and verify the popped data \"\"\"\n    \n    data_out_value = 0\n    pop_count = 0  # Initialize pop count\n    \n    # Ensure that you pop all the values in reverse order (since FILO is LIFO)\n    for i in range(len(expected_values)):\n        expected_value = expected_values[-(i + 1)]  # Get values in reverse order\n\n        # Assert the pop signal\n        dut.pop.value = 1\n        dut.push.value = 0\n        data_out_value = expected_value\n        await RisingEdge(dut.clk)\n        \n        # Deassert the pop signal after one clock cycle\n        dut.pop.value = 0\n        await RisingEdge(dut.clk)\n        \n        pop_count += 1  # Increment pop count\n\n        # Wait for one clock cycle to allow data_out to stabilize\n        await RisingEdge(dut.clk)\n        \n        # Log the values for debugging, including the register value\n        dut._log.info(f\"Pop #{pop_count}: pushed_value={expected_value}, data_out={data_out_value}, top={dut.top.value}, empty={dut.empty.value}, full={dut.full.value}\")\n        \n        # Check if the data_out matches the expected value stored in the register\n        assert data_out_value == expected_value, f\"Expected {expected_value}, but got {data_out_value}\"\n\n        # Check for the correct empty condition after the last pop\n        if i == len(expected_values) - 1:\n            assert dut.empty.value == 1, \"FILO should be empty after popping all elements\"\n        else:\n            assert dut.empty.value == 0, \"FILO should not be empty before all elements are popped\"\n        \n        # Assert full is 0 after a pop\n        assert dut.full.value == 0, \"FILO should not be full after popping\"\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}}
{"id": "cvdp_copilot_fixed_arbiter_0023", "categories": ["cid014", "easy"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the `fixed-priority arbiter` module based on the design specifications provided? The module details and design requirements for assertion development are outlined below.\n\n---\n\n## **Design Specifications**\n- The arbiter operates **synchronously** on the **positive edge of the clock (`clk`)**.\n- It includes an **active-high reset (`reset`)**, which clears the grant signal.\n- If **multiple requests** are active, the **lowest indexed request** is granted.\n- If **no requests** are active, the `grant` signal remains `0`.\n- The **grant output** must be **one-hot encoded** or `0` when no request is active.\n\n## **Inputs and Outputs**\n| Signal Name | Direction | Width  | Description                            |\n|-------------|-----------|--------|----------------------------------------|\n| `clk`       | Input     | 1 bit  | Clock signal (positive edge triggered) |\n| `reset`     | Input     | 1 bit  | Active-high reset, clears grant output |\n| `req`       | Input     | 8 bits | Request signals (one bit per source)   |\n| `grant`     | Output    | 8 bits | Grant signal (one-hot encoded)         |\n\n## **Behavioral Definitions**\n- **Reset Behavior:**  \n  - When `reset = 1`, `grant` should be `8'b00000000`.\n  \n- **Grant Logic:**  \n  - The **lowest active request bit** (`req[i]`) is granted access (`grant[i] = 1`).\n  - If multiple `req[i]` bits are active, the **lowest-indexed** request is selected.\n  - If `req = 0`, `grant = 0` (no active request).\n\n- **Priority Scheme:**  \n  - `req[0]` has **highest priority**, `req[7]` has **lowest priority**.\n  - If `req[3] = 1` and `req[5] = 1`, then `grant[3] = 1` (since `req[3]` has higher priority).\n\n- **One-Hot Encoding:**  \n  - `grant` must always have **only one bit set** (`one-hot`) or be `0` when no request is active.\n\n## **Assertion Requirements**\n1. **Reset Clears Grant**  \n   - When `reset` is asserted, `grant` must be `0`.  \n\n2. **One-Hot or Zero Grant**  \n   - `grant` must be **one-hot or zero** at all times.  \n\n3. **Priority Enforcement**  \n   - If `req[i] = 1` and `req[i-1] = 0`, then `grant[i] = 1` only if all lower-priority requests (`req[i-1:0]`) are `0`.  \n\n4. **No Grant When No Request**  \n   - If `req = 0`, then `grant = 0`.  \n\n## **Summary**\nThe **Fixed-Priority Arbiter** ensures that the lowest-indexed request is always granted first among multiple requesters. It operates synchronously, with an active-high reset and an 8-bit one-hot encoded grant output. The design must pass rigorous assertions to validate reset behavior, priority enforcement, and one-hot encoding compliance. ", "context": {"rtl/fixed_priority_arbiter.sv": "module fixed_priority_arbiter(\n    input clk,             // Clock signal\n    input reset,           // Active high reset signal\n    input [7:0] req,       // 8-bit request signal; each bit represents a request from a different source\n    output reg [7:0] grant // 8-bit grant signal; only one bit will be set high based on priority\n); \n  \n    always @(posedge clk or posedge reset) begin\n    \n        if (reset) \n            grant <= 8'b00000000;\n        else begin\n            if (req[0])\n                grant <= 8'b00000001;\n            else if (req[1])\n                grant <= 8'b00000010;\n            else if (req[2])\n                grant <= 8'b00000100;\n            else if (req[3])\n                grant <= 8'b00001000;\n            else if (req[4])\n                grant <= 8'b00010000;\n            else if (req[5])\n                grant <= 8'b00100000;\n            else if (req[6])\n                grant <= 8'b01000000;\n            else if (req[7])\n                grant <= 8'b10000000;\n            else\n                grant <= 8'b00000000;\n        end\n    end\nendmodule"}}, "output": {"response": "", "context": {"rtl/fixed_priority_arbiter.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 80\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/fixed_priority_arbiter.sv\nTOPLEVEL        = fixed_priority_arbiter\nMODULE          = test_fixed_priority_arbiter\nPYTHONPATH      = /src\nHASH            = d73367c408360a929c2c0b49653161f252205a36\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 2, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_fixed_priority_arbiter.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb  \n\n@cocotb.test()\nasync def test_fixed_priority_arbiter(dut):\n    \"\"\"Test the fixed_priority_arbiter module.\"\"\"\n\n    # Start the clock with a period of 10ns\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals\n    await hrs_lb.dut_init(dut)\n\n    # Task: Apply reset (Active High)\n    async def reset_dut(active=True, duration_ns=10):\n        dut.reset.value =  active\n        await Timer(10, units=\"ns\")\n        dut.reset.value = not active\n        #await RisingEdge(dut.clk)  # Wait for one clock edge after reset is de-asserted\n\n    # Task: Drive request\n    async def drive_request(request):\n        dut.req.value = request\n        #await RisingEdge(dut.clk)\n        await Timer(10, units=\"ns\")  # Wait to observe the output\n\n    # Monitor the signals\n    cocotb.log.info(\"Starting simulation\")\n\n    # Apply a reset to the DUT before starting the test cases\n    # Reset duration is 25ns and reset is active low\n    await reset_dut(active=True, duration_ns=25)\n\n    # ---------------- Test Case 1: Single Request ----------------\n    # Apply individual requests and verify that the grant signal matches the request\n    await drive_request(0b00000001)  # Expect grant = 0b00000001\n    await Timer(10, units=\"ns\")  # Wait to observe the output\n    assert dut.grant.value == 0b00000001, f\"Test Case 1 failed: grant={dut.grant.value}\"\n    dut._log.info(f\"Test Case 1 Single request: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n\n    await drive_request(0b00000010)  # Expect grant = 0b00000010\n    assert dut.grant.value == 0b00000010, f\"Test Case 1 failed: grant={dut.grant.value}\"\n\n    await drive_request(0b00000100)  # Expect grant = 0b00000100\n    assert dut.grant.value == 0b00000100, f\"Test Case 1 failed: grant={dut.grant.value}\"\n\n    await drive_request(0b00000000)  # Expect grant = 0b00000000\n    assert dut.grant.value == 0b00000000, f\"Test Case 1 failed: grant={dut.grant.value}\"\n\n    # ---------------- Test Case 2: Multiple Requests ----------------\n    # Apply multiple active requests and check if the highest-priority request is granted\n    await drive_request(0b00001101)  # Expect grant = 0b00000001 (highest priority)\n    assert dut.grant.value == 0b00000001, f\"Test Case 2 failed: grant={dut.grant.value}\"\n    #dut._log.info(f\"Test Case 2 Multiple request: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n\n    await drive_request(0b10010000)  # Expect grant = 0b00010000\n    assert dut.grant.value == 0b00010000, f\"Test Case 2 failed: grant={dut.grant.value}\"\n\n    # ---------------- Test Case 3: No Requests ----------------\n    # Verify that the grant signal is zero when no requests are active\n    await drive_request(0b00000000)  # Expect grant = 0b00000000\n    await Timer(10, units=\"ns\")\n    assert dut.grant.value == 0b00000000, f\"Test Case 3 failed: grant={dut.grant.value}\"\n    dut._log.info(f\"Test Case 3 No request: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n\n    # ---------------- Test Case 4: Reset During Active Requests ----------------\n    # Apply active requests, then reset the DUT and check that the grant is cleared\n    await drive_request(0b00011000)  # Expect grant = 0b00001000\n    assert dut.grant.value == 0b00001000, f\"Test Case 4 failed: grant={dut.grant.value}\"\n\n    # Log the successful completion of the simulation\n    cocotb.log.info(\"Simulation completed successfully\")\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_fixed_arbiter_0027", "categories": ["cid014", "easy"], "input": {"prompt": "Create a SystemVerilog Assertion (SVA) to verify the arbitration behavior in the `fixed_priority_arbiter` module. The module implements a fixed-priority arbitration policy, where the lowest-indexed request (`req[0]`) has the highest priority, and the highest-indexed request (`req[7]`) has the lowest priority. The arbiter locks the granted request until it is released.\n\n## **Design Specifications**\n### **Module Name:** `fixed_priority_arbiter`  \n\n### **Inputs:**\n- `clk`: System clock (rising edge).\n- `reset`: Active-high reset signal.\n- `enable`: Enables the arbitration process.\n- `clear`: Clears the current grant when asserted.\n- `req [7:0]`: 8-bit request signal where each bit represents a request from a different source.\n\n### **Outputs:**\n- `grant [7:0]`: 8-bit grant signal, where only one bit is set high, indicating which request is granted.\n- `active_grant [2:0]`: Encodes the granted request index.\n\n## **Expected Behavior**\n1. **Single Grant Guarantee**: At any given time, at most one grant bit should be set.\n2. **Priority Enforcement**: The request with the lowest index should always be granted when multiple requests are active.\n3. **Grant Locking**: Once a request is granted, it remains locked until the corresponding request is deasserted or `clear` is asserted.\n4. **Enable Signal Compliance**: If `enable` is deasserted, `grant` must be cleared.\n5. **Clear Signal Compliance**: When `clear` is asserted, `grant` must reset to zero.\n6. **Grant Consistency**: The `active_grant` index must correctly correspond to the granted request.\n\n## **Assertion Requirements**\n- Implement an assertion that verifies only one grant bit is set at any given time.\n- Ensure that the granted request follows the fixed-priority scheme.\n- Verify that `grant` is cleared when `enable` is de-asserted.\n- Check that the `clear` signal properly resets the grant.\n- Validate that `active_grant` matches the granted request.\n\n## **Assertion Failure Handling**\nEach assertion failure must trigger an error message to aid debugging.", "context": {"rtl/fixed_priority_arbiter.sv": "module fixed_priority_arbiter(\n    input clk,                    // Clock signal\n    input reset,                  // Active high reset signal\n    input enable,                 // Enable signal for the arbiter\n    input clear,                  // Clear signal to manually clear the grant\n    input [7:0] req,              // 8-bit request signal; each bit represents a request from a different source\n    output reg [7:0] grant,       // 8-bit grant signal; only one bit will be set high based on priority\n    output reg [2:0] active_grant // Binary encoded grant index\n);\n    reg locked;                   // Lock signal to hold the grant\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all signals\n            grant <= 8'b00000000;\n            locked <= 1'b0;\n            active_grant <= 3'b000;\n        end else if (!enable) begin\n            // Disable arbiter operation, clear grant\n            grant <= 8'b00000000;\n            locked <= 1'b0;\n            active_grant <= 3'b000;\n        end else if (clear) begin\n            grant <= 8'b00000000;\n            active_grant <= 3'b000;\n            locked <= 1'b0;\n        end else begin\n            if (locked) begin\n                if (req[active_grant]) begin\n                    grant <= (8'b00000001 << active_grant);\n                end else begin\n                    grant <= 8'b00000000;\n                    locked <= 1'b0;\n                end\n            end else begin\n                if (req[0]) begin\n                    grant <= 8'b00000001;\n                    locked <= 1'b1;\n                    active_grant <= 3'b000;\n                end else if (req[1]) begin\n                    grant <= 8'b00000010;\n                    locked <= 1'b1;\n                    active_grant <= 3'b001;\n                end else if (req[2]) begin\n                    grant <= 8'b00000100;\n                    locked <= 1'b1;\n                    active_grant <= 3'b010;\n                end else if (req[3]) begin\n                    grant <= 8'b00001000;\n                    locked <= 1'b1;\n                    active_grant <= 3'b011;\n                end else if (req[4]) begin\n                    grant <= 8'b00010000;\n                    locked <= 1'b1;\n                    active_grant <= 3'b100;\n                end else if (req[5]) begin\n                    grant <= 8'b00100000;\n                    locked <= 1'b1;\n                    active_grant <= 3'b101;\n                end else if (req[6]) begin\n                    grant <= 8'b01000000;\n                    locked <= 1'b1;\n                    active_grant <= 3'b110;\n                end else if (req[7]) begin\n                    grant <= 8'b10000000;\n                    locked <= 1'b1;\n                    active_grant <= 3'b111;\n                end else begin\n                    // No requests active\n                    grant <= 8'b00000000;\n                end\n            end\n        end\n    end\nendmodule"}}, "output": {"response": "", "context": {"rtl/fixed_priority_arbiter.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 80\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/fixed_priority_arbiter.sv\nTOPLEVEL        = fixed_priority_arbiter\nMODULE          = test_fixed_priority_arbiter\nPYTHONPATH      = /src\nHASH            = 40a2b507c9f8b5f3c4885eebc1771a76099be670\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 2, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_fixed_priority_arbiter.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport harness_library as hrs_lb  \n\n# Task to apply reset\nasync def apply_reset(dut):\n    \"\"\"Apply reset to the DUT.\"\"\"\n    dut.reset.value = 1  # Set reset signal high\n    dut.enable.value = 0  \n    dut.clear.value = 0  \n    dut.req.value = 0  # Clear all request signals\n    await Timer(10, units=\"ns\")  # Wait for 10 ns\n    dut.reset.value = 0  # De-assert reset\n    dut.enable.value = 1  \n    await RisingEdge(dut.clk)  # Wait for a clock edge\n\n# Task to drive request and check outputs\nasync def drive_request(dut, request, expected_grant, expected_active_grant):\n    \"\"\"Drive the request and check grant outputs.\"\"\"\n    dut.req.value = request  # Apply the request signal\n    await RisingEdge(dut.clk)  # Wait for a clock edge\n    await Timer(10, units=\"ns\")  # Wait for grant to stabilize\n\n    # Verify the grant matches the expected value\n    assert dut.grant.value == expected_grant, (\n        f\"Grant mismatch: Req={bin(request)} | Expected Grant={bin(expected_grant)}, Observed Grant={bin(dut.grant.value)}\"\n    )\n\n    # Verify the active grant index matches the expected value\n    assert dut.active_grant.value == expected_active_grant, (\n        f\"Active Grant mismatch: Req={bin(request)} | Expected Active Grant={bin(expected_active_grant)}, Observed Active Grant={bin(dut.active_grant.value)}\"\n    )\n\n@cocotb.test()\nasync def test_fixed_priority_arbiter(dut):\n    \"\"\"Cocotb testbench for fixed_priority_arbiter.\"\"\"\n\n    # Generate the clock with a 10 ns period\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Initialize the DUT signals using a predefined library function\n    await hrs_lb.dut_init(dut)\n\n    # Apply reset\n    dut._log.info(\"Applying reset\")\n    await apply_reset(dut)\n\n    # Test Case 1: Single request\n    dut._log.info(\"Starting Test Case 1: Single request\")\n    # Apply a single request and verify the grant and active grant index\n    await drive_request(dut, 0b00000001, 0b00000001, 0b000)\n    dut._log.info(f\"Test Case 1 Single request: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n\n    # Test Case 2: Multiple requests (priority handling)\n    dut._log.info(\"Starting Test Case 2: Multiple requests\")\n    # Apply multiple requests and verify the highest-priority request is granted\n    await drive_request(dut, 0b00001101, 0b00000001, 0b000)  # Priority: Req[0]\n    dut._log.info(f\"Test Case 2 Multiple request: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n\n    # Test Case 3: Clear grant manually\n    dut._log.info(\"Starting Test Case 3: Clear grant manually\")\n    # Apply a request, then manually clear the grant\n    dut.req.value = 0b00000100  # Active request\n    dut.clear.value = 1  # Set clear signal high\n    await Timer(10, units=\"ns\") \n    dut.clear.value = 0 \n    await RisingEdge(dut.clk)  \n    # Verify the grant is cleared\n    assert dut.grant.value == 0, f\"Clear failed. Grant={bin(dut.grant.value)} (Expected 0)\"\n    dut._log.info(f\"Test Case 3 Clear grant manually: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n\n    # Test Case 4: Disable arbiter\n    dut._log.info(\"Starting Test Case 4: Disable arbiter\")\n    # Disable the arbiter and verify no grant is provided\n    dut.enable.value = 0  # Disable the arbiter\n    dut.req.value = 0b00000100  # Active request\n    await Timer(15, units=\"ns\")\n    # Verify the grant is not provided when disabled\n    assert dut.grant.value == 0, f\"Arbiter not disabled. Grant={dut.grant.value}\"\n    dut._log.info(f\"Test Case 4 Disable arbiter: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n    dut.enable.value = 1  # Re-enable the arbiter\n\n    # Test Case 5: No requests active\n    dut._log.info(\"Starting Test Case 5: No requests active\")\n    # Apply no request and verify no grant is provided\n    await drive_request(dut, 0b00000000, 0b00000000, 0b000)\n    dut._log.info(f\"Test Case 5 No requests active: dut.req.value = {dut.req.value}, dut.grant.value = {dut.grant.value}\")\n\n    # Finish simulation\n    dut._log.info(\"All test cases completed.\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_gcd_0033", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `gcd_controlpath` module. The assertions should ensure that the module correctly handles state transitions and accurately tracks the completion of the GCD calculation.\n\n## **RTL Design Overview**  \nThe Greatest Common Divisor (GCD), also known as the Greatest Common Factor (GCF) or Highest Common Factor (HCF), is the largest positive integer that divides two or more integers without leaving a remainder.\n\nThis RTL design consists of the modules `gcd_top`, `gcd_controlpath`, and `gcd_datapath` that compute the GCD of two inputs, A and B, using the Euclidean algorithm. The Euclidean algorithm calculates the GCD by iteratively replacing the larger of two numbers with the difference between the two numbers. This process is repeated, reducing the larger number each time until the two numbers become equal. At this point, the value of either number is the GCD of the original inputs. The module is designed with a finite state machine (FSM) to control the computation and a datapath to perform arithmetic operations. The result of the computation is output as soon as the calculation completes, along with a signal indicating completion.\n\nThe `gcd_controlpath` module is responsible for maintaining the FSM required to perform the GCD calculation using the Euclidean algorithm.\n\n### **1. Key Components of the `gcd_controlpath` Module**       \n- **Inputs**:\n  - `clk`: Clock signal. The design is synchronized to the positive edge of this clock signal.\n  - `rst`: Active high synchronous reset signal.\n  - `go`: Start signal for GCD computation. Active high.\n  - `equal`: Signal from the datapath indicating that `A == B`. Active high.\n  - `greater_than`: Signal from the datapath indicating `A > B`. Active high.\n\n- **Outputs**:\n  - `controlpath_state [1:0]`: Current FSM state sent to the datapath to control its operations.\n  - `done`: Signal indicating that the computation is complete (`A == B`). Active high.\n\n- **FSM States**:\n  - **S0 (IDLE)**: Wait for `go` to be set high. No operation until `go` is received. When `go` is received at S0 state,\n     - Transition to S1: A is equal to B.\n     - Transition to S2: A is greater than B.\n     - Transition to S3: A is less than B.\n  - **S1 (DONE)**: Set `done` to high when `A == B`. Return to `S0` after the output is provided.\n     - Transition to S0.\n  - **S2 (A > B)**: Control the datapath to subtract `B` from `A`.\n     - Transition to S1: A_ff is equal to B_ff.\n     - Stay in S2: A_ff is  greater than B_ff.\n     - Transition to S3: A_ff is  less than B_ff.\n  - **S3 (B > A)**: Control the datapath to subtract `A` from `B`.\n     - Transition to S1: A_ff is equal to B_ff.\n     - Transition in S2: A_ff is  greater than B_ff.\n     - Stay to S3: A_ff is  less than B_ff.\n  - **Default**: Transition to the S0 state without performing any computation.\n  \n### **2. Key Components of the `gcd_datapath` Module**:  \n- **Inputs**:\n  - `clk`: Clock signal. The design should be synchronized to the positive edge of this clock signal.\n  - `rst`: Active high Synchronous reset signal.\n  - `A [WIDTH-1:0]`: input value A (unsigned and non-zero).\n  - `B [WIDTH-1:0]`: input value B (unsigned and non-zero).\n  - `controlpath_state [1:0]`: The current state of the control path FSM.\n\n- **Outputs**:\n  - `OUT [WIDTH-1:0]`: output holding the GCD value (unsigned). The value of `OUT` is updated every time the `done` signal is asserted. \n  - `equal`: Signal indicating that `A == B`. Active high.\n  - `greater_than`: Signal indicating that `A > B`. Active high.\n\n### **3. GCD Top Module (`gcd_top`)**:\n- **Inputs**:\n  - `clk`: Clock signal. The design should be synchronized to the positive edge of this clock signal..\n  - `rst`: Active high synchronous reset signal.\n  - `A [WIDTH-1:0]`: input value A (unsigned and non-zero). \n  - `B [WIDTH-1:0]`: input value B (unsigned and non-zero).\n  - `go`: Start signal to initiate GCD calculation. Active high.\n\n- **Outputs**:\n  - `OUT [WIDTH-1:0]`: output for the calculated GCD (unsigned) from `gcd_datapath`.\n  - `done`: Signal that indicates when the computation is complete from `gcd_controlpath`. \n  \n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Correct FSM behavior:** Ensure the design performs expected FSM state transitions in `gcd_controlpath` as described above.  \n- **Operations after `go`:** Ensure in the `gcd_controlpath` that initial state transitions occur only after `go` is asserted and in the `gcd_top` module, that whenever `go` is asserted, `done` eventually follows.\n- **Correct completion:** Ensure that the `done` signal is asserted at the correct `gcd_controlpath` FSM state.  \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/gcd_top.sv": "module gcd_top #(\n   parameter WIDTH = 4              // Parameter to define the bit-width of the input and output data\n   )(\n   input                     clk,   // Clock signal\n   input                     rst,   // Active High Synchronous reset signal\n   input  [WIDTH-1:0]        A,     // Input operand A\n   input  [WIDTH-1:0]        B,     // Input operand B\n   input                     go,    // Start signal to begin GCD computation\n   output logic  [WIDTH-1:0] OUT,   // Output for the GCD result\n   output logic              done   // Signal to indicate completion of computation\n);\n\n   // Internal signals to communicate between control path and data path\n   logic equal;                     // Signal indicating A == B\n   logic greater_than;              // Signal indicating A > B\n   logic [1:0] controlpath_state;   // Current state of the control FSM\n\n   // Instantiate the control path module\n   gcd_controlpath gcd_controlpath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .go                (go),                // Connect go signal\n      .equal             (equal),             // Connect equal signal from datapath\n      .greater_than      (greater_than),      // Connect greater_than signal from datapath\n      .controlpath_state (controlpath_state), // Output current state to datapath\n      .done              (done)               // Output done signal\n   );\n\n   // Instantiate the data path module\n   gcd_datapath\n   #( .WIDTH(WIDTH)\n   ) gcd_datapath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .A                 (A),                 // Connect input A\n      .B                 (B),                 // Connect input B\n      .controlpath_state (controlpath_state), // Connect current state from control path\n      .equal             (equal),             // Output equal signal to control path\n      .greater_than      (greater_than),      // Output greater_than signal to control path\n      .OUT               (OUT)                // Output GCD result\n   );\nendmodule\n\n\n// Datapath module for GCD computation\nmodule gcd_datapath  #(\n   parameter WIDTH = 4                           // Bit-width of operands\n   )(\n   input                     clk,                // Clock signal\n   input                     rst,                // Active High Synchronous reset\n   input  [WIDTH-1:0]        A,                  // Input operand A\n   input  [WIDTH-1:0]        B,                  // Input operand B\n   input  [1:0]              controlpath_state,  // Current state from control path\n   output logic              equal,              // Signal indicating A_ff == B_ff\n   output logic              greater_than,       // Signal indicating A_ff > B_ff\n   output logic  [WIDTH-1:0] OUT                 // Output GCD result\n);\n\n   // Registers to hold intermediate values of A and B\n   logic [WIDTH-1:0] A_ff;\n   logic [WIDTH-1:0] B_ff;\n\n   // State encoding for control signals\n   localparam S0 = 2'd0;    // State 0: Initialization state\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff, subtract B_ff from A_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff, subtract A_ff from B_ff\n\n   // Sequential logic to update registers based on controlpath_state\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         // On reset, initialize registers to zero\n         A_ff <= 'b0;\n         B_ff <= 'b0;\n         OUT  <= 'b0;\n      end else begin\n         case (controlpath_state)\n            S0: begin\n                // In state S0, load input values into registers\n                A_ff <= A;\n                B_ff <= B;\n             end\n            S1: begin\n                // In state S1, computation is done, output the result\n                OUT  <= A_ff;\n             end\n            S2: begin\n                // In state S2, A_ff > B_ff, subtract B_ff from A_ff\n                if (greater_than)\n                   A_ff <= A_ff - B_ff;\n             end\n            S3: begin\n                // In state S3, B_ff > A_ff, subtract A_ff from B_ff\n                if (!equal & !greater_than)\n                   B_ff <= B_ff - A_ff;\n             end\n            default: begin\n                A_ff <= 'b0;\n                B_ff <= 'b0;\n                OUT <= 'b0;\n            end\n         endcase\n      end\n   end\n\n   // Generating control response signals for the control path FSM\n   always_comb begin\n      case(controlpath_state)\n         S0: begin\n            // In state S0, compare initial input values A and B\n            equal        = (A == B)? 1'b1 : 1'b0;\n            greater_than = (A >  B)? 1'b1 : 1'b0;\n          end\n          default: begin\n            // In other states, compare the current values in registers A_ff and B_ff\n            equal        = (A_ff == B_ff)? 1'b1 : 1'b0;\n            greater_than = (A_ff >  B_ff)? 1'b1 : 1'b0;\n          end\n      endcase\n   end\nendmodule\n\n// Control path module for GCD computation FSM\nmodule gcd_controlpath (\n   input                    clk,               // Clock signal\n   input                    rst,               // Active High Synchronous reset\n   input                    go,                // Start GCD calculation signal\n   input                    equal,             // From Datapath: A_ff equals B_ff\n   input                    greater_than,      // From Datapath: A_ff is greater than B_ff\n   output logic [1:0]       controlpath_state, // Current state to Datapath\n   output logic             done               // Indicates completion of GCD calculation\n);\n\n   // Internal state registers\n   logic [1:0] curr_state;  // Current state of FSM\n   logic [1:0] next_state;  // Next state of FSM\n\n   // State encoding\n   localparam S0 = 2'd0;    // State 0: Initialization or waiting for 'go' signal\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff\n\n   // State latching logic: Update current state on clock edge\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         curr_state   <= S0;   // On reset, set state to S0\n      end else begin\n         curr_state   <= next_state;   // Transition to next state\n      end\n   end\n\n   // State transition logic: Determine next state based on current state and inputs\n   always_comb begin\n      case(curr_state)\n         S0: begin\n             // State S0: Waiting for 'go' signal\n             if(!go)\n                next_state = S0;         // Remain in S0 until 'go' is asserted\n             else if (equal)\n                next_state = S1;         // If A == B, computation is complete\n             else if (greater_than)\n                next_state = S2;         // If A > B, go to state S2\n             else\n                next_state = S3;         // If B > A, go to state S3\n         end\n         S1: begin\n             // State S1: Computation complete, output the result\n             next_state = S0;           // Return to S0 after completion\n         end\n         S2: begin\n             // State S2: A_ff > B_ff, subtract B_ff from A_ff\n             if(equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, stay in S2\n             else\n                next_state = S3;         // If B_ff > A_ff, go to S3\n         end\n         S3: begin\n             // State S3: B_ff > A_ff, subtract A_ff from B_ff\n             if (equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, go to S2\n             else\n                next_state = S3;         // If B_ff > A_ff, stay in S3\n         end\n         default: begin\n             next_state = S0;\n         end\n      endcase\n   end\n\n   // Output logic: Generate 'done' signal when computation is complete\n   always_ff @ (posedge clk) begin\n     if(rst) begin\n        done <= 1'b0;             // On reset, 'done' is low\n     end else begin\n        done <= (curr_state == S1); // 'done' is asserted when in state S1\n     end\n   end\n\n   // Assign current state to output for datapath\n   assign controlpath_state = curr_state;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/gcd_top.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/gcd_top.sv\nTOPLEVEL        = gcd_top\nMODULE          = test_gcd_top\nPYTHONPATH      = /src\nHASH            = 33-rtl-assertion-controlpath-2-input-gcd", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_gcd_top.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nfrom cocotb.regression import TestFactory\nimport random\n\n# Function to calculate GCD in software for comparison\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\n# Coroutine to reset the DUT\nasync def reset_dut(dut):\n    dut.rst.value = 1\n    dut.go.value  = 0\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    assert dut.OUT.value == 0, f\"Reset Test failed OUT Expected 0, got {int(dut.OUT.value)}\"\n    assert dut.done.value == 0, f\"Reset Test failed done Expected 0, got {int(dut.done.value)}\"\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n    assert dut.OUT.value == 0, f\"Reset Test failed OUT Expected 0, got {int(dut.OUT.value)}\"\n    assert dut.done.value == 0, f\"Reset Test failed done Expected 0, got {int(dut.done.value)}\"\n\n# Main GCD test coroutine\n@cocotb.test()\nasync def gcd_test(dut):\n    \"\"\" Test GCD calculation for different combinations of A and B \"\"\"\n    \n    # Start the clock with 10ns period\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    width  = int(dut.WIDTH.value)\n    max = (1 << width) - 1\n    # Reset the DUT\n    await reset_dut(dut)\n    \n    # Define test cases for non-zero, positive numbers\n    test_cases = [\n        (1, 1),    # GCD(1, 1) = 1\n        (4, 2),    # GCD(4, 2) = 2\n        (6, 3),    # GCD(6, 3) = 3\n        (15, 5),   # GCD(15, 5) = 5\n        (8, 4),    # GCD(8, 4) = 4\n        (9, 6),    # GCD(9, 6) = 3\n        (12, 8),   # GCD(12, 8) = 4\n        (14, 7),   # GCD(14, 7) = 7\n        (max, 1),   # (worst case for WIDTH )\n        (max, max)  # (best case for WIDTH )\n    ]\n    \n    # Test all pre-defined test cases\n    for A, B in test_cases:\n        # Apply inputs\n        dut.A.value  = A\n        dut.B.value  = B\n        dut.go.value = 1\n        latency      = 0\n        \n        # Wait for the `done` signal\n        await RisingEdge(dut.clk)\n        # Release go signal\n        dut.go.value = 0\n        await RisingEdge(dut.clk)\n        latency      = latency + 1\n        while (dut.done.value == 0):\n            await RisingEdge(dut.clk)\n            latency      = latency + 1\n        \n        # Compare the result with expected GCD\n        expected_gcd = gcd(A, B)\n        assert dut.OUT.value == expected_gcd, f\"Test failed with A={A}, B={B}. Expected {expected_gcd}, got {int(dut.OUT.value)}\"\n        if((A==2**width-1) & (B==1)):\n            assert latency == 2**width+1,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        elif((A==1) & (B==2**width-1)):\n            assert latency == 2**width+1,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        elif((A==B)):\n            assert latency == 2,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        await RisingEdge(dut.clk)\n        assert dut.done.value == 0, f\"Done should be high for only 1 clk cycle expected 0, got {int(dut.done.value)}\"\n        latency = 0\n    # Reset the DUT\n    await reset_dut(dut)\n        \n# Additional stress test with random values for A and B\n@cocotb.test()\nasync def gcd_stress_test(dut):\n    \"\"\" Stress test GCD calculation with random non-zero, positive values \"\"\"\n    \n    # Start the clock with 10ns period\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    latency      = 0\n    \n    # Reset the DUT\n    await reset_dut(dut)\n    \n    width  = int(dut.WIDTH.value)\n    \n    # Run random test cases\n    for _ in range(100):\n        A = random.randint(1, 2**width-1)  # A is positive number\n        B = random.randint(1, 2**width-1)  # B is positive number\n        latency = 0\n\n        # Apply inputs\n        dut.A.value  = A\n        dut.B.value  = B\n        dut.go.value = 1\n        \n        # Wait for the `done` signal\n        await RisingEdge(dut.clk)\n        # Release go signal\n        dut.go.value = 0\n        while (dut.done.value == 0):\n            await RisingEdge(dut.clk)\n            latency      = latency + 1\n        \n        # Compare the result with expected GCD\n        expected_gcd = gcd(A, B)\n        assert dut.OUT.value == expected_gcd, f\"Test failed with A={A}, B={B}. Expected {expected_gcd}, got {int(dut.OUT.value)}\"\n        if((A==2**width-1) & (B==1)):\n            assert latency == 2**width+1,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        elif((A==1) & (B==2**width-1)):\n            assert latency == 2**width+1,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        elif((A==B)):\n            assert latency == 2,f\"The design latency to calculate the GCD is incorrect. A={A}, B={B}, Out={int(dut.OUT.value)}\"\n        \n        await RisingEdge(dut.clk)\n        assert dut.done.value == 0, f\"Done should be high for only 1 clk cycle expected 0, got {int(dut.done.value)}\"\n        latency = 0\n    \n    # Reset the DUT\n    await reset_dut(dut)", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.parametrize(\"WIDTH\", [random.randint(4, 6)])\ndef test_runner(WIDTH):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    parameters = { \"WIDTH\": WIDTH }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# if __name__ == \"__main__\":\n#     test_simulate()"}}}
{"id": "cvdp_copilot_gf_multiplier_0045", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the `gf_multiplier` module to ensure its correct functionality during simulation?  The assertions should cover the key aspect of the Galois Field (GF) multiplication operation, ensuring that the output (`result`) remains within valid bounds (4 bits) after the polynomial multiplication and reduction steps.\n\n---\n\n## **Key Assertions**\n\n### **1. Result Within Valid Range**\n- **Condition**:  \n  - `result` should remain within 4 bits (`result < 16`), as we are operating in GF(2<sup>4</sup>).\n- **Assertion**:  \n  - If `result` exceeds `4'b1111`, an error message is displayed indicating that the value is out of bounds.\n\n- **Error Message**:  \n  - The display message includes the simulation time (`$time`) and the actual value of `result`.\n\n---\n\n## **Interface**\n\n### **Inputs**\n\n1. `A [3:0]`  \n   - 4-bit multiplicand in GF(2<sup>4</sup>).\n2. `B [3:0]`  \n   - 4-bit multiplier in GF(2<sup>4</sup>).\n\n### **Output**\n\n1. `result [3:0]`  \n   - 4-bit result after polynomial multiplication and reduction.\n\n---", "context": {"rtl/gf_multiplier.sv": "module gf_multiplier (\n    input [3:0] A,     // Multiplicand\n    input [3:0] B,     // Multiplier\n    output reg [3:0] result // Result\n);\n    reg [3:0] temp_result;\n    reg [4:0] multiplicand;\n    reg [4:0] irreducible_poly = 5'b10011; // Irreducible polynomial x^4 + x + 1\n\n    integer i;\n\n    always @(*) begin\n        temp_result = 4'b0000; // Initialize result to zero\n        multiplicand = {1'b0, A}; // Initialize multiplicand, adding an extra bit to handle overflow\n\n        // Perform multiplication using shift-and-add algorithm\n        for (i = 0; i < 4; i = i + 1) begin\n            if (B[i]) begin\n                temp_result = temp_result ^ multiplicand[3:0]; // XOR the multiplicand with result\n            end\n            multiplicand = multiplicand << 1; // Shift the multiplicand left by 1\n            if (multiplicand[4]) begin\n                multiplicand = multiplicand ^ irreducible_poly; // Polynomial reduction if overflow occurs\n            end\n        end\n\n        result = temp_result; // Output the final result\n    end\nendmodule"}}, "output": {"response": "", "context": {"rtl/gf_multiplier.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/gf_multiplier.sv\nTOPLEVEL        = gf_multiplier\nMODULE          = test_gf_mult\nPYTHONPATH      = /src\nHASH            = 45-assertion-for-4-bit-gf-multiplier\n", "src/test_gf_mult.py": "import cocotb\nfrom cocotb.triggers import Timer\nimport random\n\n# Function to perform GF(2^4) multiplication with polynomial reduction\ndef gf_mult(a, b):\n    irreducible_poly = 0b10011  # x^4 + x + 1 (10011 in binary)\n    result = 0\n\n    print(f\"Calculating GF(2^4) multiplication for A = {a:04b}, B = {b:04b}\")\n    \n    # Perform multiplication using shift-and-add method\n    for i in range(4):  # 4-bit multiplication\n        if (b >> i) & 1:\n            result ^= a << i  # Add shifted multiplicand\n            print(f\"  - Bit {i} of B is 1: result = result XOR (A << {i}) = {result:08b}\")\n\n    # Perform polynomial reduction if the result exceeds 4 bits\n    print(f\"  Before reduction: result = {result:08b}\")\n    for i in range(7, 3, -1):  # Start checking from bit 7 down to bit 4\n        if result & (1 << i):  # If the bit is set\n            result ^= irreducible_poly << (i - 4)  # XOR with irreducible polynomial\n            print(f\"  - Bit {i} of result is 1: result = result XOR (irreducible_poly << {i - 4}) = {result:08b}\")\n\n    final_result = result & 0b1111  # Return the final result (4 bits)\n    print(f\"  Final reduced result: {final_result:04b}\\n\")\n    return final_result\n\n# Test for GF(2^4) multiplier with known vectors\n@cocotb.test()\nasync def gf_multiplier_basic_test(dut):\n    \"\"\"Test the GF multiplier with known test vectors\"\"\"\n    \n    # Test vector: A = 3 (0011), B = 1 (0001)\n    A = 3\n    B = 1\n    expected_result = gf_mult(A, B)\n    dut.A.value = A\n    dut.B.value = B\n    await Timer(1, units='ns')  # Small delay to allow propagation\n\n    actual_result = dut.result.value\n    cocotb.log.info(f\"Basic Test: A = {A}, B = {B}, Expected = {expected_result}, Actual = {actual_result}\")\n    assert actual_result == expected_result, f\"Test failed: {A} * {B} = {actual_result}, expected {expected_result}\"\n\n    # Test vector: A = 3 (0011), B = 7 (0111)\n    A = 3\n    B = 7\n    expected_result = gf_mult(A, B)\n    dut.A.value = A\n    dut.B.value = B\n    await Timer(1, units='ns')\n\n    actual_result = dut.result.value\n    cocotb.log.info(f\"Basic Test: A = {A}, B = {B}, Expected = {expected_result}, Actual = {actual_result}\")\n    assert actual_result == expected_result, f\"Test failed: {A} * {B} = {actual_result}, expected {expected_result}\"\n\n    # Test vector: A = 15 (1111), B = 15 (1111)\n    A = 15\n    B = 15\n    expected_result = gf_mult(A, B)\n    dut.A.value = A\n    dut.B.value = B\n    await Timer(1, units='ns')\n\n    actual_result = dut.result.value\n    cocotb.log.info(f\"Basic Test: A = {A}, B = {B}, Expected = {expected_result}, Actual = {actual_result}\")\n    assert actual_result == expected_result, f\"Test failed: {A} * {B} = {actual_result}, expected {expected_result}\"\n\n@cocotb.test()\nasync def gf_multiplier_random_test(dut):\n    \"\"\"Test the GF multiplier with random values\"\"\"\n    \n    # Perform 20 random tests\n    for i in range(20):\n        A = random.randint(0, 15)  # Random 4-bit value\n        B = random.randint(0, 15)  # Random 4-bit value\n        print(f\"Random Test {i + 1}: A = {A:04b}, B = {B:04b}\")\n        expected_result = gf_mult(A, B)  # Use the GF multiplication logic\n\n        dut.A.value = A\n        dut.B.value = B\n\n        await Timer(1, units='ns')  # Allow propagation delay\n\n        actual_result = dut.result.value\n        cocotb.log.info(f\"Random Test {i + 1}: A = {A}, B = {B}, Expected = {expected_result}, Actual = {actual_result}\")\n        assert actual_result == expected_result, f\"Random test failed: {A} * {B} = {actual_result}, expected {expected_result}\"", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}}
{"id": "cvdp_copilot_hebbian_rule_0022", "categories": ["cid014", "medium"], "input": {"prompt": "Can you add concurrent assertions in the RTL design of the `hebb_gates` module to ensure its correct functionality during simulation? The assertions should cover various key aspects of the `hebb_gates` module's operations such as proper reset initialization of the FSM and weight registers, verifying correct state transitions based on the iteration counter and start signal, checking that the arithmetic operations for delta calculations and weight updates are performed only under the appropriate control conditions, and validating that the gate_target submodule outputs match the expected target values based on the `gate_select` input.\n\nThe assertions should fail when any one of the following 10 conditions fails:\n\n**1. reset_initialization**:\n- Ensure that on asynchronous reset, the FSM is set to `State_0` and the iteration counter is reset to `0`.\n\n**2. state0_to_state1**:\n- Ensure that when the FSM is in `State_0` and the start signal is asserted, the next state is correctly set to `State_1`, indicating that the FSM properly initiates the transition from its idle state upon receiving the start signal.\n\n**3. state2_transition**:\n- Check that when the FSM is in `State_2`, the next state is correctly determined by the current value of the iteration counter. Specifically, if the iteration is 0, the next state should be `State_3`; if 1, it should be `State_4`; if 2, then `State_5`; and for any other iteration value, the next state must be `State_6`.\n\n**4. state9_transition** :\n- Ensure that when the FSM is in State_9, the next state is chosen based on the value of the iteration counter. If the iteration is less than 4, the FSM should loop back to `State_1`; otherwise, if the iteration is 4 or higher, it should transition to `State_10`.\n\n**5. clear_signal_state0**:\n- Verify that when the FSM is in `State_0`, the clear enable signal (`clr_en`) is asserted HIGH (set to 1). This ensures that the clearing functionality\u2014typically responsible for resetting or initializing registers\u2014is active in the idle state.\n\n**6. capture_signal_state1**:\n- Check that when the FSM is in State_1, the capture enable signal (`cap_en`) is asserted HIGH. This ensures that the module properly captures the input values at this stage of the FSM operation.\n\n**7. delta_calculation_state7**:\n- Verify that when the FSM is in `State_7` and the delta enable signal (`delta_en`) is ACTIVE HIGH, the module correctly calculates the delta values.\n\n**8. weight_update_state8**:\n- Verify that when the FSM is in `State_8` and the sum enable (`sum_en`) signal is ACTIVE HIGH, the weight registers are updated correctly.\n\n**9. gate_target_00**:\n- Verify that when the `gate_select` input is set to `2'b00`, the outputs from the gate_target submodule (`t1`, `t2`, `t3`, `t4`) match the expected target values. Specifically, `t1` must be `4'd1` while `t2`, `t3`, and `t4` should each be `-4'd1`.\n\n**10. weights_cleared_in_state0**:\n- Ensure that when the FSM is in `State_0`, the weight registers (`w1`, `w2`, and `bias`) are all reset to zero. This verifies that the clear operation is working correctly, guaranteeing proper initialization or reset of the weight values.\n\n## Inputs and Outputs:\n## Inputs:\n- `clk` (1-bit): Posedge Clock signal.\n- `rst` (1-bit): Asynchronous Negedge Reset signal. When ACTIVE LOW , the FSM is initialized to `State_0` and iteration counter `iteration` to 0\n- `start `(1-bit): Active HIGH Signal to initiate the FSM.\n- `a`, `b` (4-bit each, [3:0],signed): Bipolar input signals [-1 ,1]. Only -1 and 1 have to be considered as valid inputs\n- `gate_select` (2-bit,[1:0]): Selector to specify the target for a given gate\n## Outputs:\n- `w1`, `w2` (4-bit each,[3:0], signed): Trained weights for the inputs.\n- `bias` (4-bit, signed,[3:0]): Trained bias value.\n- `present_state`, `next_state` (4-bit each,[3:0]): Current and next states of the Training FSM.", "context": {"rtl/hebb_gates.sv": "module hebb_gates(\n   input  logic               clk,// Posedge clk\n   input  logic               rst,// Asynchronous negedge rst\n   input  logic               start, // To start the FSM\n   input  logic  signed [3:0] a, // First Input\n   input  logic  signed [3:0] b, // Second Input\n   input  logic         [1:0] gate_select, // To provide the targets for a selected gate in order to train\n   output logic  signed [3:0] w1, // Weight 1 obtained by training\n   output logic  signed [3:0] w2, // Weight 2 obtained by training\n   output logic  signed [3:0] bias,// Bias obtained by training\n   output logic [3:0] present_state,// Present State of the Training FSM\n   output logic [3:0] next_state // Next_State of the Training FSM\n   \n);\n   logic signed [3:0] t1;\n   logic signed [3:0] t2;\n   logic signed [3:0] t3;\n   logic signed [3:0] t4;\n   \n   gate_target dut(\n       .gate_select(gate_select),\n       .o_1        (t1),\n       .o_2        (t2),\n       .o_3        (t3),\n       .o_4        (t4)\n   );\n   \n   localparam [3:0] State_0 = 4'd0;\n   localparam [3:0] State_1 = 4'd1;\n   localparam [3:0] State_2 = 4'd2;\n   localparam [3:0] State_3 = 4'd3;\n   localparam [3:0] State_4 = 4'd4;\n   localparam [3:0] State_5 = 4'd5;\n   localparam [3:0] State_6 = 4'd6;\n   localparam [3:0] State_7 = 4'd7;\n   localparam [3:0] State_8 = 4'd8;\n   localparam [3:0] State_9 = 4'd9;\n   localparam [3:0] State_10 = 4'd10;\n   \n   logic [2:0] iteration;\n   logic signed [3:0] x1;\n   logic signed [3:0] x2;\n   logic signed [3:0] delta_w1;\n   logic signed [3:0] delta_w2;\n   logic signed [3:0] delta_b;\n   logic signed [3:0] w1_reg;\n   logic signed [3:0] w2_reg;\n   logic signed [3:0] bias_reg;\n   logic signed [1:0] target;\n   logic delta_en;\n   logic sum_en;\n   logic clr_en;\n   logic cap_en;\n  \n   always_comb begin\n     if(cap_en ) begin\n        x1 = a;\n        x2 = b;\n     end else begin\n        x1 = x1 + 4'h0;\n        x2 = x2 + 4'h0;\n     end\n   \n   end\n   \n   always_comb begin\n     \n     if(delta_en) begin\n       delta_w1 = x1 * target;\n       delta_w2 = x2 * target;\n       delta_b  = target;\n     end else begin\n       delta_w1 = delta_w1 + 4'h0;\n       delta_w2 = delta_w2 + 4'h0;\n       delta_b  = delta_b + 4'h0; \n   end\n   \n  end\n   \n  always_comb begin\n     \n     if(sum_en) begin\n       w1_reg = w1_reg + delta_w1;\n       w2_reg = w2_reg + delta_w2;\n       bias_reg = bias_reg + delta_b;\n     end else begin\n       w1_reg = w1_reg + 4'h0;\n       w2_reg = w2_reg + 4'h0;\n       bias_reg = bias_reg + 4'h0;\n   end\n  end\n   \n   always_comb begin\n     \n     if(clr_en) begin\n       w1_reg = 0;\n       w2_reg = 0;\n       bias_reg = 0;\n     end else begin\n       w1_reg = w1_reg + 4'h0;\n       w2_reg = w2_reg + 4'h0;\n       bias_reg = bias_reg + 4'h0; \n    end\n   end\n   \n   always_ff@(posedge clk or negedge rst) begin\n       if(!rst) begin\n          present_state <= State_0;\n          iteration <= 0;\n        end else\n          present_state <= next_state;\n   end\n\n   \n   always@(*) begin\n        next_state = present_state;\n        \n     case(present_state)\n            State_0  : begin \n                        if(start)\n                           next_state = State_1;\n                        else\n                           next_state = State_0;\n                       end\n            State_1  : begin \n                           next_state = State_2;\n                       end\n            State_2  : begin \n                         if(iteration == 0)\n                           next_state = State_3;\n                       else if(iteration == 1)\n                           next_state = State_4;\n                       else if(iteration == 2)\n                           next_state = State_5;\n                       else \n                           next_state = State_6;\n                       end\n            State_3  : begin \n                         next_state = State_7;\n                       end\n            State_4  : begin \n                         next_state = State_7;\n                       end\n            State_5  : begin \n                         next_state = State_7;\n                       end\n            State_6  : begin \n                         next_state = State_7;\n                       end\n            State_7  : begin\n                         next_state = State_8;\n                       end\n            State_8  : begin\n                         next_state = State_9;\n                       end\n            State_9  : begin\n                        if(iteration < 4)\n                         next_state = State_1;\n                        else\n                         next_state = State_10;\n                       end\n            State_10 : begin\n                         next_state = State_0;\n                       end\n            default : ;\n     endcase\n   end \n   \n   \n   always@(*) begin    \n      case(present_state)\n             State_0  : begin\n                         clr_en = 1;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en   = 0;\n                         iteration = 0;\n                         target = target + 4'h0;\n                        end \n             State_1  : begin\n                         clr_en = 0;\n                         cap_en = 1;\n                         delta_en = 0;\n                         sum_en = 0;  \n                         iteration = iteration + 0;  \n                         target = target + 4'h0;              \n                        end\n             State_2  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0; \n                         iteration = iteration + 0;     \n                         target = target + 4'h0;              \n                        end\n             State_3  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0;\n                         iteration = iteration + 0;\n                         target = t1;\n                        end\n             State_4  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0;\n                         iteration = iteration + 0;\n                         target = t2;\n                        end     \n             State_5  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0;\n                         iteration = iteration + 0;\n                         target = t3;\n                        end  \n             State_6  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0;\n                         iteration = iteration + 0;\n                         target = t4;\n                        end        \n             State_7  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 1;\n                         sum_en = 0;\n                         iteration = iteration + 0;\n                         target = target + 4'h0;\n                        end\n             State_8  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 1;\n                         iteration = iteration + 1;\n                         target = target + 4'h0;\n                        end\n             State_9  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0;\n                         iteration = iteration + 0;\n                         target = target + 4'h0;\n                        end  \n             State_10 : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0;\n                         iteration = iteration + 0;\n                         target = target + 4'h0;\n                        end\n             default  : begin\n                         clr_en = 0;\n                         cap_en = 0;\n                         delta_en = 0;\n                         sum_en = 0;\n                         iteration = 0;\n                         target = target + 4'h0;\n                        end\n       endcase\n   end\n   assign w1 = w1_reg;\n   assign w2 = w2_reg;\n   assign bias = bias_reg;\n   \nendmodule\n\nmodule gate_target(\n   input  logic        [1:0] gate_select,\n   output logic signed [3:0] o_1,\n   output logic signed [3:0] o_2,\n   output logic signed [3:0] o_3,\n   output logic signed [3:0] o_4\n);\n   always@(*) begin\n     case(gate_select)\n          2'b00 : begin \n                    o_1 =  4'b0001; \n                    o_2 = -4'b0001; \n                    o_3 = -4'b0001; \n                    o_4 = -4'b0001; \n                  end\n          2'b01 : begin \n                    o_1 =  4'b0001; \n                    o_2 =  4'b0001; \n                    o_3 =  4'b0001; \n                    o_4 = -4'b0001; \n                  end\n          2'b10 : begin \n                    o_1 =  4'b0001; \n                    o_2 =  4'b0001; \n                    o_3 =  4'b0001; \n                    o_4 = -4'b0001; \n                  end\n          2'b11 : begin \n                    o_1 =  4'b0001; \n                    o_2 = -4'b0001; \n                    o_3 = -4'b0001; \n                    o_4 = -4'b0001; \n                  end\n        default : begin\n                    o_1 =  4'b0000; \n                    o_2 =  4'b0000; \n                    o_3 =  4'b0000; \n                    o_4 =  4'b0000; \n                  end\n        endcase\n   end\nendmodule"}}, "output": {"response": "", "context": {"rtl/hebb_gates.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/hebb_gates.sv\nTOPLEVEL        = hebb_gates\nMODULE          = test_hebb_gates\nPYTHONPATH      = /src\nHASH            = 22-hebbian_rule_tb_assertion_generation\n", "src/test_hebb_gates.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n@cocotb.test()\nasync def test_hebb_gates(dut):\n    \"\"\"Test the hebb_gates module with different gate selections and inputs.\"\"\"\n\n    # Create a 10ns clock\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Reset logic\n    dut.rst.value = 0\n    await Timer(10, units=\"ns\")\n    dut.rst.value = 1\n\n    # Initialize inputs\n    dut.start.value = 0\n    dut.a.value = 0\n    dut.b.value = 0\n    dut.gate_select.value = 0\n\n    await RisingEdge(dut.rst)\n    await Timer(10, units=\"ns\")\n\n    # Helper function for applying stimulus and logging outputs\n    async def apply_stimulus(a, b, gate_select, duration):\n        dut.a.value = a\n        dut.b.value = b\n        dut.gate_select.value = gate_select\n        await Timer(duration, units=\"ns\")\n        cocotb.log.info(\n              f\"gate_select={gate_select}, a={a}, b={b}, \"\n              f\"w1={int(dut.w1.value)}, w2={int(dut.w2.value)}, \"\n              f\"bias={int(dut.bias.value)}, state={bin(int(dut.present_state.value))}\"\n        )\n\n    # Test AND gate targets (gate_select = 2'b00)\n    dut.gate_select.value = 0b00\n    dut.start.value = 1\n    cocotb.log.info(\"Start of AND gate Training\")\n\n    await apply_stimulus(1, 1, 0b00, 60)\n    await apply_stimulus(1, -1, 0b00, 60)\n    await apply_stimulus(-1, 1, 0b00, 60)\n    await apply_stimulus(-1, -1, 0b00, 70)\n\n    cocotb.log.info(\"End of AND gate Training\")\n\n    # Test OR gate targets (gate_select = 2'b01)\n    dut.gate_select.value = 0b01\n    cocotb.log.info(\"Start of OR gate Training\")\n\n    await apply_stimulus(1, 1, 0b01, 70)\n    await apply_stimulus(-1, 1, 0b01, 60)\n    await apply_stimulus(1, -1, 0b01, 60)\n    await apply_stimulus(-1, -1, 0b01, 70)\n\n    cocotb.log.info(\"End of OR gate Training\")\n\n    # Test NAND gate targets (gate_select = 2'b10)\n    dut.gate_select.value = 0b10\n    cocotb.log.info(\"Start of NAND gate Training\")\n\n    await apply_stimulus(-1, -1, 0b10, 70)\n    await apply_stimulus(-1, 1, 0b10, 60)\n    await apply_stimulus(1, -1, 0b10, 60)\n    await apply_stimulus(1, 1, 0b10, 70)\n\n    cocotb.log.info(\"End of NAND gate Training\")\n\n    # Test NOR gate targets (gate_select = 2'b11)\n    dut.gate_select.value = 0b11\n    cocotb.log.info(\"Start of NOR gate Training\")\n\n    await apply_stimulus(-1, -1, 0b11, 70)\n    await apply_stimulus(-1, 1, 0b11, 60)\n    await apply_stimulus(1, -1, 0b11, 60)\n    await apply_stimulus(1, 1, 0b11, 70)\n\n    cocotb.log.info(\"End of NOR gate Training\")\n\n    # Randomized test cases\n    num_random_cases = 10  # Number of random test cases\n    for i in range(num_random_cases):\n        random_gate_select = random.randint(0, 3)  # Randomly select gate (0b00 to 0b11)\n        random_inputs = [(random.choice([-1, 1]), random.choice([-1, 1])) for _ in range(4)]\n\n        dut.gate_select.value = random_gate_select\n        dut.start.value = 1\n        cocotb.log.info(f\"Start of Random Test Case {i+1} for gate_select={bin(random_gate_select)}\")\n\n        for a, b in random_inputs:\n            await apply_stimulus(a, b, random_gate_select, 65)\n        cocotb.log.info(f\"End of Random Test Case {i+1} for gate_select={bin(random_gate_select)}\")\n    # Stop the test\n    dut.start.value = 0\n    cocotb.log.info(\"Test Completed\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_icache_controller_0004", "categories": ["cid014", "medium"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the `instruction_cache_controller` module based on the design specifications provided? Below are the module details and design requirements for assertion development.\n\n## **Interface**\n\n### **Inputs**\n- **clk**: The clock signal ensures all sequential operations are synchronized and triggers updates on the rising edge.\n- **rst**: The active-high asynchronous reset signal initializes all states and outputs to their default values immediately when asserted.\n- **io_mem_ready**: A 1-bit handshake signal from memory indicating that the memory is ready to accept a request or provide data.\n- **l1b_addr [17:0]**: An 18-bit address input from the L1 cache, where the higher 9 bits represent the tag for validation and the lower 9 bits specify the block offset.\n- **ram256_t0_data [7:0]**: An 8-bit data input from Tag RAM 0, containing tag or validity information for a specific cache line. This input is used to determine whether the requested data is valid and matches the tag of the cache line.\n- **ram256_t1_data [7:0]**: An 8-bit data signal from Tag RAM 1, containing tag or validity information for a different cache line. This input is used to determine whether the requested data is valid and matches the tag of the cache line.\n- **ram512_d0_data [15:0]**: A 16-bit signal from Data RAM 0 representing the lower half of cached block data.\n- **ram512_d1_data [15:0]**: A 16-bit signal from Data RAM 1 providing the upper half of cached block data.\n\n### **Outputs**\n- **io_mem_valid**: A 1-bit signal is asserted HIGH when a valid memory request is issued by the controller to fetch data during a cache miss.\n- **io_mem_addr [16:0]**: A 17-bit signal specifying the external memory address for reading or writing data during memory transactions.\n- **l1b_wait**: A 1-bit signal asserted to notify the L1 cache to pause new requests while the controller resolves a miss or fetches data.\n- **l1b_data [31:0]**: A 32-bit output signal combining data from Data RAM 0 and Data RAM 1, adjusted for unaligned accesses if required.\n- **ram256_t0_we**: A 1-bit write enable signal for Tag RAM 0, activated during cache updates to store new tags or validity bits.\n- **ram256_t0_addr [7:0]**: An 8-bit address output for Tag RAM 0, specifying the location to access or modify a tag or validity bit.\n- **ram256_t1_we**: A 1-bit write enable signal for Tag RAM 1, used to update tags or validity bits in another cache line.\n- **ram256_t1_addr [7:0]**: An 8-bit address output for Tag RAM 1, specifying the address for tag or validity bit access or modification.\n- **ram512_d0_we**: A 1-bit write enable signal for Data RAM 0, used to store the lower half of a cache line during updates.\n- **ram512_d0_addr [8:0]**: A 9-bit address output for Data RAM 0, identifying the memory location for reading or writing the lower half of a cache line.\n- **ram512_d1_we**: A 1-bit write enable signal for Data RAM 1, activated to store the upper half of a cache line.\n- **ram512_d1_addr [8:0]**: A 9-bit address output for Data RAM 1, specifying the location for accessing or modifying the upper half of a cache line.\n\n## Design Specifications\nThe cache controller manages fetching instruction data, ensuring that valid cached data is used whenever possible. If the requested data is not in the cache, it fetches it from memory and updates the cache.\n\n### Cache Hit and Miss Behavior\n- If the requested data is available in the cache, no memory read should occur.\n- If the data is missing, the controller should initiate a memory fetch by asserting a valid memory request signal.\n\n### State Transitions\n- **Idle**: The controller waits for requests. If the requested data is missing, it initiates a memory fetch.\n- **Read Memory Block 0**: Reads the first part of the instruction from memory.\n- **Read Memory Block 1**: Reads the second part of the instruction from memory.\n- **Read Cache**: Ensures the fetched data is valid and updates the cache if necessary.\n\n### Memory Read Operations\n- The memory request signal should only be active when a read operation is required.\n- The memory address must always be within the allowed range.\n- The controller should only transition between read states when the memory signals indicate readiness.\n\n### Write Enable Control\n- The write enable signal should only be active when updating cache memory.\n- Data should only be written to cache during valid read operations.\n\n### L1 Cache Wait Behavior\n- The wait signal should be active when the cache does not have valid data.\n- The wait signal should be cleared once data is available.\n\n## Assertion Requirements\nDevelop SystemVerilog assertions to validate the following behaviors:\n\n### 1. Reset Behavior\n- When the reset signal is high, all internal states and control signals should be properly initialized.\n- The cache controller should return to its idle state, disable write operations, and clear any pending memory requests.\n\n### 2. Memory Address Validation\n- Ensures that whenever a memory operation is initiated, the memory address remains within the valid 17-bit address range. \n- This check happens in the same cycle when a memory request is active, preventing out-of-bounds memory access.\n\n### 3. Data RAM Address Validation\n- Guarantees that when a write operation is enabled, the memory address falls within the expected 9-bit range. \n- This is checked immediately in the same cycle to prevent invalid memory writes.\n\n### 4. Write Enable Timing Validation\n- Enforces that the write enable signal is only active during memory read operations. \n- If it is asserted, the system must be in either the first or second memory read state within the next two cycles. This prevents accidental writes outside the designated states.\n\n### 5. L1 Cache Wait Validation\n- Ensures that if data is missing in the cache, the wait signal must be asserted in the next cycle. \n- This guarantees that the controller correctly signals a waiting state when required.\n\n### 6. State Transition from IDLE\n- Confirms that if the system is idle and the requested data is missing, it must move to the first memory read state. \n- This transition is checked in the same cycle to ensure immediate response to a cache miss.\n\n### 7. State Transition from the First to the Second Memory Read State\n- Ensures that when the system is fetching the first part of memory and memory becomes ready, it must move to the second read state in the next cycle.\n-  This guarantees that the controller fetches data in a structured manner.\n\n### 8. State Transition from the Second Memory Read State to Cache Read\n- Validates that once the second memory read is completed, the controller must transition to the cache read state in the next cycle. \n- This ensures that the fetched data is correctly processed.\n\n### 9. Write Enable Should Be Disabled in IDLE\n- Ensures that no write operations occur while the system is in the idle state. \n- This is checked in the same cycle to prevent unnecessary writes when no memory operation is ongoing.\n\n### 10. Memory Request Signal Should Be Low in IDLE\n- Confirms that when the system is idle, it should not signal a memory operation. \n- This is checked immediately to ensure no unnecessary memory requests.\n\n### 11. L1 Cache Wait Signal in Cache Read State\n- Ensures that if the system is reading from the cache, the wait signal should only be active if the required data is still not available. \n- This is checked in the same cycle to avoid incorrect cache access behavior.\n\n### 12. Memory Request Signal in the Second Memory Read State\n- Enforces that when the system is fetching the second part of memory, the memory request signal must be high. \n- This ensures uninterrupted fetching and is checked in the same cycle.\n\n### 13. Transition from IDLE when Data is Not Ready\n- Ensures that if the system is idle but cache data is missing, it must move to the first memory read state in the next cycle. \n- This guarantees that missing data is fetched without unnecessary delay.\n\n\n## Deliverables\nPlease provide SystemVerilog assertions that:\n- Cover all the validation requirements listed above.\n- Include clear error messages for easier debugging.\n- Follow industry standards for verification efficiency.\n\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.", "context": {"rtl/instruction_cache_controller.sv": "module instruction_cache_controller (\n    input  wire        clk,                // Clock signal\n    input  wire        rst,                // Reset signal\n\n    output reg         io_mem_valid,       // Indicates that memory operation is valid\n    input  wire        io_mem_ready,       // Indicates that memory is ready for the operation\n    output reg  [16:0] io_mem_addr,        // Address for memory operation\n\n    output reg         l1b_wait,           // Indicates if the L1 cache is still waiting for data\n    output wire [31:0] l1b_data,           // Data output from the L1 cache\n    input  wire [17:0] l1b_addr,           // Address of the L1 cache (18-bits)\n\n    // RAM256_T0 (Tag Memory 0)\n    output wire       ram256_t0_we,        // Write enable for the RAM256_T0 (Tag RAM 0)\n    output wire [7:0] ram256_t0_addr,      // Address for the RAM256_T0 (Tag RAM 0)\n    input  wire [7:0] ram256_t0_data,      // Data read from the RAM256_T0 (Tag RAM 0)\n\n    // RAM256_T1 (Tag Memory 1)\n    output wire       ram256_t1_we,        // Write enable for the RAM256_T1 (Tag RAM 1)\n    output wire [7:0] ram256_t1_addr,      // Address for the RAM256_T1 (Tag RAM 1)\n    input  wire [7:0] ram256_t1_data,      // Data read from the RAM256_T1 (Tag RAM 1)\n\n    // RAM512_D0 (Data Memory 0)\n    output wire        ram512_d0_we,       // Write enable for the RAM512_D0 (Data RAM 0)\n    output wire [8:0]  ram512_d0_addr,     // Address for the RAM512_D0 (Data RAM 0)\n    input  wire [15:0] ram512_d0_data,     // Data read from the RAM512_D0 (Data RAM 0)\n\n    // RAM512_D1 (Data Memory 1)\n    output wire        ram512_d1_we,       // Write enable for the RAM512_D1 (Data RAM 1)\n    output wire [8:0]  ram512_d1_addr,     // Address for the RAM512_D1 (Data RAM 1)\n    input  wire [15:0] ram512_d1_data      // Data read from the RAM512_D1 (Data RAM 1)\n);\n    wire [15:0] data_0;\n    wire [15:0] data_1;\n\n    assign l1b_data = l1b_addr[0] ? {data_0, data_1} : {data_1, data_0};\n\n    localparam TAG_BITS = 8;\n    localparam ADR_BITS = 9;\n\n    localparam IDLE      = 3'd0,\n               READMEM0  = 3'd1,\n               READMEM1  = 3'd2,\n               READCACHE = 3'd3;\n\n    reg [2:0] state, next_state;\n    reg [ADR_BITS-1:0] addr_0, addr_1;\n    reg write_enable;\n\n    wire [ADR_BITS-1:0] data_addr_0 = l1b_addr[17:9] + {{8{1'b0}}, l1b_addr[0]};\n    wire [ADR_BITS-1:0] data_addr_1 = l1b_addr[17:9];\n\n    wire valid_0, valid_1;\n    wire [TAG_BITS-1:0] tag_0, tag_1;\n\n    wire data_0_ready = (l1b_addr[17:9] == tag_0) && valid_0;\n    wire data_1_ready = (l1b_addr[17:9] == tag_1) && valid_1;\n\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            write_enable <= 1'b0;\n            addr_0 <= {ADR_BITS{1'b0}};\n            addr_1 <= {ADR_BITS{1'b0}};\n        end else begin\n            if ((state == READMEM0 || state == READMEM1) && io_mem_ready) begin\n                write_enable <= 1'b1;\n            end else begin \n                write_enable <= 1'b0;\n            end\n            state <= next_state;\n            addr_0 <= data_addr_0;\n            addr_1 <= data_addr_1;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        io_mem_valid = 1'b0;\n        io_mem_addr = {17{1'b0}};\n        l1b_wait = 1'b1;\n\n        case (state)\n            IDLE: begin\n                l1b_wait = 1'b0;\n                if (!data_0_ready || !data_1_ready)\n                    next_state = READMEM0;\n            end\n            READMEM0: begin\n                io_mem_addr = {l1b_addr[17:9], data_addr_0[7:0]};\n                io_mem_valid = 1'b1;\n                if (io_mem_ready)\n                    next_state = READMEM1;\n            end\n            READMEM1: begin\n                io_mem_addr = {l1b_addr[17:9], data_addr_1[7:0]};\n                io_mem_valid = 1'b1;\n                if (io_mem_ready)\n                    next_state = READCACHE;\n            end\n            READCACHE: begin\n                l1b_wait = ~(data_0_ready && data_1_ready);\n                if (!data_0_ready)\n                    next_state = READMEM0;\n                else if (!data_1_ready)\n                    next_state = READMEM1;\n                else\n                    next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    assign ram512_d0_we = write_enable;\n    assign ram512_d0_addr = addr_0;\n    assign data_0 = ram512_d0_data;\n\n    assign ram512_d1_we = write_enable;\n    assign ram512_d1_addr = addr_1;\n    assign data_1 = ram512_d1_data;\n\n    tag_controller tag_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .write_enable(write_enable),\n        .write_addr(io_mem_addr[ADR_BITS-1:0]),\n        .data_0_out({valid_0, tag_0}),\n        .read_addr_0(data_addr_0[7:0]),\n        .data_1_out({valid_1, tag_1}),\n        .read_addr_1(data_addr_1[7:0]),\n        .ram_t0_we(ram256_t0_we),\n        .ram_t0_addr(ram256_t0_addr),\n        .ram_t0_data(ram256_t0_data),\n        .ram_t1_we(ram256_t1_we),\n        .ram_t1_addr(ram256_t1_addr),\n        .ram_t1_data(ram256_t1_data)\n    );\n\nendmodule\n\n\nmodule tag_controller (\n   input wire clk,                     // Clock signal\n   input wire rst,                     // Reset signal\n\n   // Port 0: Write operation (W)\n   input wire       write_enable,      // Enable write operation\n   input wire [8:0] write_addr,        // Write address (9 bits)\n\n   // Port 0: Read operation for address 0 (R)\n   output reg [8:0] data_0_out,        // Data output for read operation on address 0 (9 bits)\n   input  wire [7:0] read_addr_0,      // Read address for tag memory 0 (8 bits)\n\n   // Port 1: Read operation for address 1 (R)\n   output reg [8:0] data_1_out,        // Data output for read operation on address 1 (9 bits)\n   input  wire [7:0] read_addr_1,      // Read address for tag memory 1 (8 bits)\n\n   // RAM256_T0 (Tag Memory 0)\n   output reg       ram_t0_we,         // Write enable for the RAM256_T0 (Tag RAM 0)\n   output reg [7:0] ram_t0_addr,       // Address for the RAM256_T0 (Tag RAM 0)\n   input  wire [7:0] ram_t0_data,      // Data read from the RAM256_T0 (Tag RAM 0)\n\n   // RAM256_T1 (Tag Memory 1)\n   output reg       ram_t1_we,         // Write enable for the RAM256_T1 (Tag RAM 1)\n   output reg [7:0] ram_t1_addr,       // Address for the RAM256_T1 (Tag RAM 1)\n   input  wire [7:0] ram_t1_data       // Data read from the RAM256_T1 (Tag RAM 1)\n);\n   reg [511:0] RAM;\n\n   wire [7:0] tag_0_data;\n   wire [7:0] tag_1_data;\n\n   wire [7:0] tag_addr_0 = write_enable ? write_addr[7:0] : read_addr_0;\n   wire [7:0] tag_addr_1 = write_enable ? write_addr[7:0] : read_addr_1;\n\n   always @(posedge clk or posedge rst) begin\n       if (rst) begin\n           RAM <= 0;\n           ram_t0_we <= 1'b0;  \n           ram_t1_we <= 1'b0;  \n           ram_t0_addr <= 8'b0; \n           ram_t1_addr <= 8'b0; \n           data_0_out <= 9'b0;\n           data_1_out <= 9'b0;\n       end else if (write_enable) begin\n           RAM[write_addr[7:0]] <= 1'b1;\n       end\n   end\n\n   assign tag_0_data = ram_t0_data;\n   assign tag_1_data = ram_t1_data;\n\n   always @(*) begin\n       ram_t0_addr = tag_addr_0;\n       ram_t1_addr = tag_addr_1;\n\n       data_0_out = {RAM[read_addr_0], tag_0_data};\n       data_1_out = {RAM[read_addr_1], tag_1_data};\n\n       ram_t0_we = (~write_addr[0]) && write_enable;\n       ram_t1_we = write_addr[0] && write_enable;\n   end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/instruction_cache_controller.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/instruction_cache_controller.sv\nTOPLEVEL        = instruction_cache_controller\nMODULE          = test_instruction_cache_controller\nPYTHONPATH      = /src\nRANDOM_SEED     = 1736275973\nHASH            = c5da356229f42ccf928b6db74d57c9e746468aab", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_instruction_cache_controller.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\nimport harness_library as hrs_lb\n\ndef calculate_expected_data(data_0, data_1, unaligned):\n\n    if unaligned:\n        return (data_0 << 16) | data_1\n    else:\n        return (data_1 << 16) | data_0\n\n\n@cocotb.test()\nasync def test_instruction_cache_controller(dut):\n\n    # Start clock\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Reset initialization\n    await hrs_lb.dut_init(dut)\n    await hrs_lb.reset_dut(dut.rst, duration_ns=25, active=False)\n    await RisingEdge(dut.clk)\n    # Simulate a memory read sequence\n    for _ in range(10):\n        \n        dut.io_mem_ready.value = random.choice([0, 1])\n        dut.l1b_addr.value = random.randint(0, 0x3FFFF)  # Random L1 cache address\n\n        data_0 = random.randint(0, 0xFFFF)\n        data_1 = random.randint(0, 0xFFFF)\n        dut.ram512_d0_data.value = data_0\n        dut.ram512_d1_data.value = data_1\n\n        # Verify output signals\n        unaligned = int(dut.l1b_addr.value) & 0x1\n        expected_data = calculate_expected_data(data_0, data_1, unaligned)\n\n        if dut.l1b_wait.value == 0:\n            assert int(dut.l1b_data.value) == expected_data, (\n                f\"Mismatch in l1b_data. Expected: {expected_data:#010X}, Got: {int(dut.l1b_data.value):#010X}\"\n            )\n        await RisingEdge(dut.clk)\n    # Test corner cases\n    dut._log.info(\"Testing corner cases...\")\n\n    corner_cases = [\n        (0x00000, False),  # Minimum address (aligned)\n        (0x3FFFF, True),   # Maximum address (unaligned)\n        (0x123FE, False),  # Near boundary, aligned\n        (0x123FF, True),   # Near boundary, unaligned\n    ]\n\n    for addr, unaligned in corner_cases:\n        dut.io_mem_ready.value = random.choice([0, 1])\n        dut.l1b_addr.value = addr\n        data_0 = random.randint(0, 0xFFFF)\n        data_1 = random.randint(0, 0xFFFF)\n        dut.ram512_d0_data.value = data_0\n        dut.ram512_d1_data.value = data_1\n\n        # Verify output signals\n        unaligned = dut.l1b_addr.value\n        expected_data = calculate_expected_data(data_0, data_1, unaligned)\n\n        if dut.l1b_wait.value == 0:\n            assert int(dut.l1b_data.value) == expected_data, (\n                f\"Corner Case Mismatch for address {addr:#06X}: Expected {expected_data:#010X}, Got {int(dut.l1b_data.value):#010X}\"\n            )\n        else:\n            dut._log.info(f\"Corner Case Success for address {addr:#06X}: Data is being fetched.\")\n        await RisingEdge(dut.clk)\n\n    # Test random cases\n    dut._log.info(\"Testing random cases...\")\n    for _ in range(20):\n        addr = random.randint(0, 0x3FFFF)\n        unaligned = addr & 0x1\n        data_0 = random.randint(0, 0xFFFF)\n        data_1 = random.randint(0, 0xFFFF)\n\n        dut.l1b_addr.value = addr\n        dut.ram512_d0_data.value = data_0\n        dut.ram512_d1_data.value = data_1\n\n        expected_data = calculate_expected_data(data_0, data_1, unaligned)\n\n        if dut.l1b_wait.value == 0:\n            assert int(dut.l1b_data.value) == expected_data, (\n                f\"Random Case Mismatch for address {addr:#06X}: Expected {expected_data:#010X}, Got {int(dut.l1b_data.value):#010X}\"\n            )\n        else:\n            dut._log.info(f\"Random Case Success for address {addr:#06X}: Data is being fetched.\")\n        await RisingEdge(dut.clk)\n    # End simulation with no errors\n    dut._log.info(\"Test completed successfully.\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_ir_receiver_0013", "categories": ["cid014", "medium"], "input": {"prompt": " Create SystemVerilog Assertions to verify the **functional correctness** of the `ir_receiver` module. The properties should ensure that:  \n\n1. **Start Condition Timing**:  The `started` signal is asserted within **25 clock cycles** after `ir_signal_in` goes HIGH and `started` is LOW.  \n\n2. **Decoding Starts Only if Started**:  The module transitions to the `decoding` state only if the `started` signal was previously asserted.  \n\n3. **Frame Has Minimum Bits**:  The module transitions to the `finish` state only after capturing at least **12 bits** in the `decoding` state.  \n\n4. **Output Valid in Finish State**:  The `ir_output_valid` signal is only asserted in the `finish` state.  \n\n5. **Output Valid Not in Frame Space**:  The `ir_output_valid` signal is never asserted in the `frame_space` state.  \n\n6. **Valid Device Address**:  The `ir_device_address_out` signal always has a valid value when `ir_output_valid` is asserted.  \n\nEach assertion must provide a **detailed failure message**, including the current state, input signals, and relevant outputs for debugging purposes.  \n\n---\n\n### RTL Specification  \n\nThe `ir_receiver` module decodes an IR signal into a function code and device address. It operates based on a state machine and validates the input signal to ensure correct decoding.  \n\n#### Module Name: `ir_receiver`\n\n\n#### **Sony IR Frame Structure**  \n| **Phase**         | **Description**                                                              | **Timing**          |\n|-------------------|------------------------------------------------------------------------------|---------------------|\n| **Start Bit**     | The frame begins with a **2.4 ms HIGH pulse**                                | 2.4 ms              |\n| **Data Bits**     | The frame consists of **12 bits**. Each bit is encoded as follows:           |                     |\n|                   | - **0:** A LOW pulse of **0.6 ms** followed by a HIGH pulse of **0.6 ms**.   | 0.6 ms + 0.6 ms     |\n|                   | - **1:** A LOW pulse of **0.6 ms** followed by a HIGH pulse of **1.2 ms**.   | 0.6 ms + 1.2 ms     |\n| **Frame Space**   | The frame ends after completing **45 ms** before the next frame starts.      | 45-2.4-(12 bit) ms  |\n\n#### **States in the State Machine**\n\n1. **IDLE**:\n   - Waits for the start bit. If the start condition is detected, it transitions to the `START` state.\n\n2. **START**:\n   - Validates the **2.4 ms HIGH pulse** to confirm the start bit.\n   - On successful detection, transition to the `DECODING` state; otherwise, transition back to `IDLE` on failure.\n\n3. **DECODING**:\n   - Decodes the 12-bit data by detecting each bit\u2019s HIGH and LOW timing.\n   - Distinguishes between `0` and `1` based on pulse widths. When all 12 bits are decoded, transitions to the `FINISH` state.\n\n4. **FINISH**:\n   - Extract the 12-bit IR Frame from the received IR signal.\n   - Asserts the valid signal and outputs the decoded data. Then transitions to the `FRAME_SPACE` state.\n\n5. **FRAME_SPACE**:\n   - Monitors the 45 ms frame space. If the space duration completes, transition back to `IDLE`.\n\n#### **Decoding Logic**\nThe module must:\n   - Decode a 12-bit frame extracted from `FINISH` state\n   - Extract:\n     - **Function Code**: The lower 7 bits of the frame (`ir_function_code_out`).\n     - **Device Address**: The upper 5 bits of the frame (`ir_device_address_out`).\n   - Output a **valid signal** (`ir_output_valid`) indicating successful decoding.\n\n\n#### **Function decoding Table Commands **\nCommand is the LSB 7-bit Information received in 12-bit frame.\n| **Command (decimal)** | **Function**    | **ir_function_code_out** |\n|-----------------------|-----------------|--------------------------|\n| `0`                   | digit 1         | `7'b000_0001`            |\n| `1`                   | digit 2         | `7'b000_0010`            |\n| `2`                   | digit 3         | `7'b000_0011`            |\n| `3`                   | digit 4         | `7'b000_0100`            |\n| `4`                   | digit 5         | `7'b000_0101`            |\n| `5`                   | digit 6         | `7'b000_0110`            |\n| `6`                   | digit 7         | `7'b000_0111`            |\n| `7`                   | digit 8         | `7'b000_1000`            |\n| `8`                   | digit 9         | `7'b000_1001`            |\n| `9`                   | digit 0         | `7'b000_0000`            |\n| `16`                  | channel +       | `7'b001_1111`            |\n| `17`                  | channel -       | `7'b010_1111`            |\n| `18`                  | volume +        | `7'b011_1111`            |\n| `19`                  | volume -        | `7'b100_1111`            |\n| `20`                  | mute            | `7'b101_1111`            |\n| `21`                  | power           | `7'b110_1111`            |\n| `22`                  | pause           | `7'b111_1111`            |\n\n\n#### **Address Decoding Table**\nAddress is the MSB 5-bit Information received in 12-bit frame.\n| **Address** | **Device**      | **ir_device_address_out** |\n|-------------|-----------------|---------------------------|\n| `0`         | TV              | `5'b00001`                |\n| `1`         | HDMI1           | `5'b00010`                |\n| `2`         | USB             | `5'b00100`                |\n| `3`         | HDMI2           | `5'b01000`                |\n| `4`         | VCR             | `5'b10000`                |\n\n---\n\n#### IO Ports  \n\n| Port Name                   | Direction| Size       | Description                                        |\n|-----------------------------|----------|------------|----------------------------------------------------|\n| `reset_in`                  | Input    | 1 bit      | Asynchronous Active-high reset                     |\n| `clk_in`                    | Input    | 1 bit      | Positive Edge System clock (10 KHz, 100us)         |\n| `ir_signal_in`              | Input    | 1 bit      | Input signal (IR)                                  |\n| `ir_function_code_out[6:0]` | Output   | 7 bits     | Decoded output for different functions             |\n| `ir_device_address_out[4:0]`| Output   | 5 bits     | Decoded device address                             |\n| `ir_output_valid`           | Output   | 1 bit      | Indicates validity of the decoded frame            |\n", "context": {"rtl/ir_receiver.sv": "module ir_receiver (\n    input  logic        reset_in,               // Active HIGH reset\n    input  logic        clk_in,                 // System clock (10 KHz, 100us)\n    input  logic        ir_signal_in,           // Input signal (IR)\n    output logic [6:0]  ir_function_code_out,   // Decoded output for different functions\n    output logic [4:0]  ir_device_address_out,  // \"00001\": TV, \"00010\":HDMI1, \"00100\":USB, \"01000\":HDMI2, \"10000\": VCR\n    output logic        ir_output_valid         // Indicates validity of the decoded frame\n);\n\n    typedef enum logic [2:0] {idle, start, decoding, finish, frame_space} ir_state;\n    ir_state present_state, next_state;\n\n    logic started;\n    logic decoded;\n    logic failed;\n    logic success;\n    logic frame_full;\n    logic ir_frame_valid;\n\n    int cycle_counter;\n    int frame_space_counter;\n    int bit_counter;\n\n    logic [11:0] ir_frame_reg;\n    logic [11:0] ir_frame_out;\n    logic stored;\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in)\n            present_state <= idle;\n        else\n            present_state <= next_state;\n    end\n\n    always_comb begin\n        case (present_state)\n            idle: begin\n                if (ir_signal_in == 1 && started == 0)\n                    next_state = start;\n                else\n                    next_state = idle;\n            end\n            start: begin\n                if (ir_signal_in == 0 && started == 1)\n                    next_state = decoding;\n                else if (failed == 1)\n                    next_state = idle;\n                else\n                    next_state = start;\n            end\n            decoding: begin\n                if (decoded == 1)\n                    next_state = finish;\n                else if (failed == 1)\n                    next_state = idle;\n                else\n                    next_state = decoding;\n            end\n            finish: begin\n                if (success == 1)\n                    next_state = frame_space;\n                else\n                    next_state = finish;\n            end\n            frame_space: begin\n                if (frame_full)\n                    next_state = idle;\n                else\n                    next_state = frame_space;\n            end\n            default: next_state = idle;\n        endcase\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            cycle_counter        <= 0;\n            frame_space_counter  <= 0;\n            bit_counter          <= -1;\n            failed               <= 0;\n            started              <= 0;\n            decoded              <= 0;\n            success              <= 0;\n            stored               <= 0;\n            ir_frame_reg         <= 12'b000000000000;\n            ir_frame_out         <= 12'b000000000000;\n            ir_frame_valid       <= 1'b0;\n            frame_full           <= 1'b0;\n        end\n        else begin\n            case (next_state)\n                idle: begin\n                    cycle_counter        <= 0;\n                    bit_counter          <= -1;\n                    frame_space_counter  <= 0;\n                    failed               <= 0;\n                    started              <= 0;\n                    decoded              <= 0;\n                    success              <= 0;\n                    stored               <= 0;\n                    ir_frame_reg         <= 12'b000000000000;\n                    ir_frame_valid       <= 1'b0;\n                    frame_full           <= 1'b0;\n                end\n                start: begin\n                    if (cycle_counter < 24) begin\n                        cycle_counter <= cycle_counter + 1;\n                        if (cycle_counter < 20 && ir_signal_in == 0)\n                            failed <= 1;\n                    end\n                    else begin\n                        started       <= 1;\n                        cycle_counter <= 0;\n                    end\n                end\n                decoding: begin\n                    if (bit_counter < 12) begin\n                        if (ir_signal_in == 1) begin\n                            stored        <= 0;\n                            cycle_counter <= cycle_counter + 1;\n                        end\n                        else begin\n                            if (stored == 0) begin\n                                if (bit_counter > -1) begin\n                                    if (cycle_counter > 10)\n                                        ir_frame_reg[bit_counter] <= 1;\n                                    else\n                                        ir_frame_reg[bit_counter] <= 0;\n                                end\n                                bit_counter   <= bit_counter + 1;\n                                cycle_counter <= 0;\n                                stored        <= 1;\n                            end\n                        end\n                    end\n                    else begin\n                        decoded <= 1;\n                    end\n                    frame_space_counter <= frame_space_counter + 1;\n                end\n                finish: begin\n                    ir_frame_out         <= ir_frame_reg;\n                    ir_frame_valid       <= 1'b1;\n                    success              <= 1;\n                    frame_space_counter  <= frame_space_counter + 1;\n                end\n                frame_space: begin\n                    success              <= 0;\n                    ir_frame_valid       <= 1'b0;\n                    ir_frame_out         <= 12'b0;\n                    frame_space_counter  <= frame_space_counter + 1;\n                    if (frame_space_counter < 424)\n                        frame_full <= 0;\n                    else\n                        frame_full <= 1;\n                end\n                default: begin\n                    cycle_counter        <= 0;\n                    frame_space_counter  <= 0;\n                    bit_counter          <= -1;\n                    failed               <= 0;\n                    started              <= 0;\n                    decoded              <= 0;\n                    success              <= 0;\n                    stored               <= 0;\n                    ir_frame_reg         <= 12'b000000000000;\n                    ir_frame_out         <= 12'b000000000000;\n                    ir_frame_valid       <= 1'b0;\n                    frame_full           <= 1'b0;\n                end\n            endcase\n        end\n    end\n\n    logic [3:0] device_function_code;\n    logic [4:0] device_address_out;\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            device_function_code <= 4'b0000;\n        end\n        else begin\n            if (ir_frame_reg[6:4] == 3'b000) begin\n                case (ir_frame_reg[3:0])\n                    4'b0000: device_function_code = 4'b0001;\n                    4'b0001: device_function_code = 4'b0010;\n                    4'b0010: device_function_code = 4'b0011;\n                    4'b0011: device_function_code = 4'b0100;\n                    4'b0100: device_function_code = 4'b0101;\n                    4'b0101: device_function_code = 4'b0110;\n                    4'b0110: device_function_code = 4'b0111;\n                    4'b0111: device_function_code = 4'b1000;\n                    4'b1000: device_function_code = 4'b1001;\n                    4'b1001: device_function_code = 4'b0000;\n                    default: device_function_code = 4'b0000;\n                endcase\n            end\n            else begin\n                case (ir_frame_reg[6:0])\n                    7'b0010000: device_function_code = 4'b0001;\n                    7'b0010001: device_function_code = 4'b0010;\n                    7'b0010010: device_function_code = 4'b0011;\n                    7'b0010011: device_function_code = 4'b0100;\n                    7'b0010100: device_function_code = 4'b0101;\n                    7'b0010101: device_function_code = 4'b0110;\n                    7'b0010110: device_function_code = 4'b0111;\n                    default: device_function_code = 4'b0000;\n                endcase\n            end\n        end\n    end\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            device_address_out <= 5'b00000;\n        end\n        else begin\n            case (ir_frame_reg[11:7])\n                5'b00000: device_address_out = 5'b00001;\n                5'b00001: device_address_out = 5'b00010;\n                5'b00010: device_address_out = 5'b00100;\n                5'b00011: device_address_out = 5'b01000;\n                5'b00100: device_address_out = 5'b10000;\n                default: device_address_out = 5'b00000;\n            endcase\n        end\n    end\n\n    assign ir_function_code_out = (ir_frame_valid) ? ((ir_frame_reg[6:4] == 3'b000) ? {3'b000, device_function_code} : {device_function_code[2:0], 4'b1111}) : 'd0;\n    assign ir_device_address_out = (ir_frame_valid) ? device_address_out : 'd0;\n    assign ir_output_valid = ir_frame_valid;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/ir_receiver.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ir_receiver.sv\nTOPLEVEL        = ir_receiver\nMODULE          = test_ir_receiver\nPYTHONPATH      = /src\nHASH            = 8dd946cad612316cfa4b522c370f0dc54b8c1540\n", "src/test_ir_receiver.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n\ndef calculate_reference_value(predefined_seq):\n    \"\"\"Calculate the expected reference value based on the input frame.\"\"\"\n    if predefined_seq & 0x7F < 10:  # For values less than 10\n        if (predefined_seq & 0x7F) == 9:\n            ref_value = ((1 << ((predefined_seq >> 7) & 0x1F)) << 7)\n        else:\n            ref_value = ((1 << ((predefined_seq >> 7) & 0x1F)) << 7) | ((predefined_seq & 0x7F) + 1)\n    elif 16 <= (predefined_seq & 0x7F) < 23:  # For values between 16 and 23\n        test_bits = (predefined_seq & 0x7F) - 15\n        ref_value = ((1 << ((predefined_seq >> 7) & 0x1F)) << 7) | (test_bits << 4) | 0xF\n    else:\n        ref_value = 0  # Default value if conditions are not met\n    return ref_value\n\nasync def initialize_dut(dut):\n    \"\"\"Initialize the DUT and start the clock.\"\"\"\n    dut.reset_in.value = 1\n    dut.ir_signal_in.value = 1\n\n    # Start the 50 MHz clock (period = 20 ns)\n    clock = Clock(dut.clk_in, 100000, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Wait for reset propagation\n    await Timer(200000, units=\"ns\")\n    dut.reset_in.value = 0\n\nasync def send_ir_signal(dut, predefined_value):\n    \"\"\"Send the IR signal to the DUT.\"\"\"\n    # Start bit: 2.4 ms LOW\n    dut.ir_signal_in.value = 1\n    await Timer(2400000, units=\"ns\")\n\n    for i in range(12):\n        dut.ir_signal_in.value = 0\n        await Timer(600000, units=\"ns\")  # 0.6 ms LOW\n\n        if (predefined_value >> i) & 1:\n            dut.ir_signal_in.value = 1\n            await Timer(1200000, units=\"ns\")  # 1.2 ms HIGH for '1'\n        else:\n            dut.ir_signal_in.value = 1\n            await Timer(600000, units=\"ns\")  # 0.6 ms HIGH for '0'\n\n    # End of transmission: 0.6 ms LOW\n    dut.ir_signal_in.value = 0\n\nasync def run_test_case(dut, address):\n    \"\"\"Run a test case for a specific 5-bit address.\"\"\"\n    await initialize_dut(dut)\n\n    for function in range(10):  # Loop through 7-bit function codes (0 to 16)\n        predefined_value = (address << 7) | function  # Combine address and function\n        reference_value = calculate_reference_value(predefined_value)\n\n        # Send the IR signal\n        await send_ir_signal(dut, predefined_value)\n\n        # Wait for the DUT to process the signal\n        await Timer(100000, units=\"ns\")\n        await Timer(100000, units=\"ns\")\n        await Timer(100000, units=\"ns\")\n\n        received_frame = (int(dut.ir_device_address_out.value) << 7) | int(dut.ir_function_code_out.value)\n\n        dut._log.info(f\"Predefined: {predefined_value:012b}, Expected: {reference_value:012b}, Received: {received_frame:012b}\")\n        assert received_frame == reference_value, (\n            f\"Test Failed: Predefined = {predefined_value:012b}, \"\n            f\"Expected = {reference_value:012b}, Received = {received_frame:012b}\"\n        )\n        await Timer(40000000, units=\"ns\")  # 0.6 ms HIGH for '0'\n\n    for function in range(16, 23):  # Loop through 7-bit function codes (0 to 16)\n        predefined_value = (address << 7) | function  # Combine address and function\n        reference_value = calculate_reference_value(predefined_value)\n\n        # Send the IR signal\n        await send_ir_signal(dut, predefined_value)\n\n        # Wait for the DUT to process the signal\n        await Timer(100000, units=\"ns\")\n        await Timer(100000, units=\"ns\")\n        await Timer(100000, units=\"ns\")\n\n        received_frame = (int(dut.ir_device_address_out.value) << 7) | int(dut.ir_function_code_out.value)\n\n        dut._log.info(f\"Predefined: {predefined_value:012b}, Expected: {reference_value:012b}, Received: {received_frame:012b}\")\n        assert received_frame == reference_value, (\n            f\"Test Failed: Predefined = {predefined_value:012b}, \"\n            f\"Expected = {reference_value:012b}, Received = {received_frame:012b}\"\n        )\n        await Timer(40000000, units=\"ns\")  # 0.6 ms HIGH for '0'\n\n    dut._log.info(f\"Test Case for Address {address:05b} passed successfully.\")\n\n@cocotb.test()\nasync def test_ir_receiver_address_00000(dut):\n    \"\"\"Test Case: Address 5'b00000 with all valid 7-bit function combinations.\"\"\"\n    await run_test_case(dut, address=0b00000)\n\n\n@cocotb.test()\nasync def test_ir_receiver_address_00001(dut):\n    \"\"\"Test Case: Address 5'b00001 with all valid 7-bit function combinations.\"\"\"\n    await run_test_case(dut, address=0b00001)\n\n\n@cocotb.test()\nasync def test_ir_receiver_address_00010(dut):\n    \"\"\"Test Case: Address 5'b00010 with all valid 7-bit function combinations.\"\"\"\n    await run_test_case(dut, address=0b00010)\n\n@cocotb.test()\nasync def test_ir_receiver_address_00011(dut):\n    \"\"\"Test Case: Address 5'b00011 with all valid 7-bit function combinations.\"\"\"\n    await run_test_case(dut, address=0b00011)\n\n\n@cocotb.test()\nasync def test_ir_receiver_address_00100(dut):\n    \"\"\"Test Case: Address 5'b00100 with all valid 7-bit function combinations.\"\"\"\n    await run_test_case(dut, address=0b00100)\n\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n    \n"}}}
{"id": "cvdp_copilot_lfsr_0073", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the `lfsr_16bit` module to ensure its correct functionality during simulation? The assertions should validate the correct operation of the LFSR (Linear Feedback Shift Register), ensuring that:\n  - The weight input remains within the valid range (`0 to 15`).\n  - The `lfsr_out` output is not stuck at all 0s (`16'h0000`), which would indicate a failure in the shifting process.\n\n___\n### Key Assertions\n**1. Valid weight Input Range**\n  - Condition:\n    - The weight signal should always remain within the 4-bit valid range (`0000 to 1111`).\n    - If weight is less than `0000` or greater than `1111`, an error message should be displayed.\n\n  - Failure Handling:\n    - If weight is out of range, an error message should be printed to indicate whether the value exceeded the limit or dropped below the minimum range.\n\n##\n**2. LFSR Should Not Be Stuck at 16'h0000**\n  - Condition:\n    - After reset is deasserted (`reset = 0`), `lfsr_out` should not remain at `16'h0000` indefinitely.\n    - This ensures that the LFSR is not stuck in a non-random state and continues to shift correctly.\n\n  - Failure Handling:\n    - If `lfsr_out` remains at `16'h0000`, an error message should be displayed to indicate that the LFSR is not shifting properly.\n___\n### Implementation Requirements\n**1. Placement**\n  - The assertions must be inside the RTL module (`lfsr_16bit`) to validate real-time behavior during simulation.\n\n**2. Immediate Assertions**\n  - Uses `assert()` inside an `always` block to catch errors during execution.\n\n**3. Failure Handling**\n  - If an assertion fails, the simulation should:\n    - Display debugging information (`$display`).\n    - Indicate the incorrect behavior.\n    - Help identify issues related to invalid weight values or LFSR getting stuck.\n\n##\n### Interface\n**PARAMETER**\n  - `WIDTH`: Defines the bit width of the LFSR (`Default: 16`).\n\n**INPUTS**\n  - `clock`: System clock input that synchronizes state transitions, ensuring the LFSR shifts on every rising edge..\n  - `reset`: An active-high signal that initializes `lfsr_out` with `lfsr_seed`, ensuring a known starting state before normal operation..\n  - `lfsr_seed [15:0]`: Initial seed value for the LFSR.\n  - `sel`: Select signal for `NAND` or `NOR` operation (`0: NOR`, `1: NAND`).\n  - `dir`: Direction control (`0: LSB to MSB`, `1: MSB to LSB`).\n  - `weight [3:0]`: Controls the weight applied to feedback logic.\n\n**OUTPUT**\n  - `lfsr_new [15:0]`: Updated LFSR value after each shift cycle.", "context": {"rtl/lfsr_16bit.sv": "`timescale 1ns / 1ps\n\nmodule lfsr_16bit (\n    input clock,\n    input reset,\n    input [15:0] lfsr_seed,\n    input sel,  // Selector for NAND or NOR operation (0: NOR for more 0s, 1: NAND for more 1s)\n    input dir,  // Direction control (0: LSB to MSB, 1: MSB to LSB)\n    input [3:0] weight,  // Weight control signal\n    output reg [15:0] lfsr_new\n\n);\n  wire q1;\n  wire q2;\n  wire q3;\n  reg [15:0] output_new;\n  reg [15:0] lfsr_out;\n\n  assign q1 = lfsr_out[6] ^ lfsr_out[0];\n  assign q2 = lfsr_out[5] ^ lfsr_out[0];\n  assign q3 = lfsr_out[1] ^ lfsr_out[0];\n\n\n  always @* begin\n    output_new = lfsr_out;  // Default to no change\n\n    if (sel == 0 && dir == 0) begin\n      case (weight)\n        4'b0000: output_new = lfsr_out;\n        4'b0001: output_new = {lfsr_out[15:1], ~(lfsr_out[0] | 1'b1)};\n        4'b0010:\n        output_new = {output_new[15:2], ~(lfsr_out[1] | lfsr_out[0]), ~(lfsr_out[1] | lfsr_out[0])};\n        4'b0011:\n        output_new = {\n          lfsr_out[15:3],\n          ~(lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b0100:\n        output_new = {\n          output_new[15:4],\n          ~(lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b0101:\n        output_new = {\n          lfsr_out[15:5],\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b0110:\n        output_new = {\n          output_new[15:6],\n          ~(lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b0111:\n        output_new = {\n          output_new[15:7],\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b1000:\n        output_new = {\n          output_new[15:8],\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b1001:\n        output_new = {\n          output_new[15:9],\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b1010:\n        output_new = {\n          output_new[15:10],\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n\n        };\n        4'b1011:\n        output_new = {\n          output_new[15:11],\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b1100:\n        output_new = {\n          output_new[15:12],\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b1101:\n        output_new = {\n          output_new[15:13],\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b1110:\n        output_new = {\n          output_new[15:14],\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n        };\n        4'b1111:\n        output_new = {\n          output_new[15],\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0]),\n          ~(lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1] | lfsr_out[0])\n\n        };\n      endcase\n    end else if (sel == 0 && dir == 1) begin\n      case (weight)\n        4'b0000: output_new = lfsr_out;\n        4'b0001: output_new = {~(lfsr_out[15] | 1'b0), lfsr_out[14:0]};\n        4'b0010:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14]), ~(lfsr_out[15] | lfsr_out[14]), lfsr_out[13:0]\n        };\n        4'b0011:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13]),\n\n          lfsr_out[12:0]\n        };\n        4'b0100:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12]),\n          lfsr_out[11:0]\n        };\n        4'b0101:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11]),\n          lfsr_out[10:0]\n        };\n        4'b0110:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10]),\n          lfsr_out[9:0]\n        };\n        4'b0111:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9]),\n          lfsr_out[8:0]\n        };\n        4'b1000:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8]),\n          lfsr_out[7:0]\n        };\n        4'b1001:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7]),\n          lfsr_out[6:0]\n        };\n        4'b1010:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6]),\n          lfsr_out[5:0]\n        };\n        4'b1011:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5]),\n          lfsr_out[4:0]\n        };\n        4'b1100:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4]),\n          lfsr_out[3:0]\n        };\n        4'b1101:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3]),\n          lfsr_out[2:0]\n        };\n        4'b1110:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2]),\n          lfsr_out[1:0]\n        };\n        4'b1111:\n        output_new = {\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          ~(lfsr_out[15] | lfsr_out[14] | lfsr_out[13] | lfsr_out[12] | lfsr_out[11] | lfsr_out[10] | lfsr_out[9] | lfsr_out[8] | lfsr_out[7] | lfsr_out[6] | lfsr_out[5] | lfsr_out[4] | lfsr_out[3] | lfsr_out[2] | lfsr_out[1]),\n          lfsr_out[0]\n        };\n      endcase\n    end else if (sel == 1 && dir == 0) begin\n      case (weight)\n        4'b0000: output_new = lfsr_out;\n        4'b0001: output_new = {lfsr_out[15:1], ~(lfsr_out[0] & 1'b1)};\n        4'b0010:\n        output_new = {output_new[15:2], ~(lfsr_out[1] & lfsr_out[0]), ~(lfsr_out[1] & lfsr_out[0])};\n        4'b0011:\n        output_new = {\n          lfsr_out[15:3],\n          ~(lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b0100:\n        output_new = {\n          output_new[15:4],\n          ~(lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b0101:\n        output_new = {\n          lfsr_out[15:5],\n          ~(lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b0110:\n        output_new = {\n          output_new[15:6],\n          ~(lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b0111:\n        output_new = {\n          output_new[15:7],\n          ~(lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b1000:\n        output_new = {\n          output_new[15:8],\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b1001:\n        output_new = {\n          output_new[15:9],\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b1010:\n        output_new = {\n          output_new[15:10],\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n\n        };\n        4'b1011:\n        output_new = {\n          output_new[15:11],\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b1100:\n        output_new = {\n          output_new[15:12],\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b1101:\n        output_new = {\n          output_new[15:13],\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b1110:\n        output_new = {\n          output_new[15:14],\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n        };\n        4'b1111:\n        output_new = {\n          output_new[15],\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0]),\n          ~(lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1] & lfsr_out[0])\n\n        };\n      endcase\n    end else if (sel == 1 && dir == 1) begin\n      case (weight)\n        4'b0000: output_new = lfsr_out;\n        4'b0001: output_new = {~(lfsr_out[15] & 1'b0), lfsr_out[14:0]};\n        4'b0010:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14]), ~(lfsr_out[15] & lfsr_out[14]), lfsr_out[13:0]\n        };\n        4'b0011:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13]),\n\n          lfsr_out[12:0]\n        };\n        4'b0100:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12]),\n          lfsr_out[11:0]\n        };\n        4'b0101:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11]),\n          lfsr_out[10:0]\n        };\n        4'b0110:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10]),\n          lfsr_out[9:0]\n        };\n        4'b0111:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9]),\n          lfsr_out[8:0]\n        };\n        4'b1000:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8]),\n          lfsr_out[7:0]\n        };\n        4'b1001:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7]),\n          lfsr_out[6:0]\n        };\n        4'b1010:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6]),\n          lfsr_out[5:0]\n        };\n        4'b1011:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5]),\n          lfsr_out[4:0]\n        };\n        4'b1100:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4]),\n          lfsr_out[3:0]\n        };\n        4'b1101:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3]),\n          lfsr_out[2:0]\n        };\n        4'b1110:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2]),\n          lfsr_out[1:0]\n        };\n        4'b1111:\n        output_new = {\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          ~(lfsr_out[15] & lfsr_out[14] & lfsr_out[13] & lfsr_out[12] & lfsr_out[11] & lfsr_out[10] & lfsr_out[9] & lfsr_out[8] & lfsr_out[7] & lfsr_out[6] & lfsr_out[5] & lfsr_out[4] & lfsr_out[3] & lfsr_out[2] & lfsr_out[1]),\n          lfsr_out[0]\n        };\n      endcase\n    end\n  end\n\n  always @(posedge clock or posedge reset) begin\n\n    if (reset) begin\n      lfsr_out <= lfsr_seed;  // Load seed on reset\n      lfsr_new <= lfsr_seed;\n    end else begin\n\n      lfsr_out <= {\n        lfsr_out[0],\n        lfsr_out[15],\n        q1,\n        q2,\n        lfsr_out[12],\n        lfsr_out[11],\n        lfsr_out[10],\n        q3,\n        lfsr_out[8],\n        lfsr_out[7],\n        lfsr_out[6],\n        lfsr_out[5],\n        lfsr_out[4],\n        lfsr_out[3],\n        lfsr_out[2],\n        lfsr_out[1]\n      };\n      lfsr_new <= output_new;\n\n    end\n  end\nendmodule"}}, "output": {"response": "", "context": {"rtl/lfsr_16bit.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/lfsr_16bit.sv\nTOPLEVEL        = lfsr_16bit\nMODULE          = test_lfsr_16bit\nPYTHONPATH      = /src\nHASH            = 73-assertion-generation-for-lfsr-16-bit\n", "src/test_lfsr_16bit.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport random\n\n@cocotb.test()\nasync def test_lfsr(dut):\n    \"\"\"Test LFSR with different seeds, sel, dir, and weight values\"\"\"\n\n    # Start the clock\n    clock = Clock(dut.clock, 10, units=\"ns\")  # Create a clock with 100MHz frequency\n    cocotb.start_soon(clock.start())  # Start the clock\n\n    # Test cases with different configurations of lfsr_seed, sel, dir, and weight\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b0000)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0000)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b0010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0010)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b0011)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0011)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b0101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0101)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b0111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0111)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b1010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1010)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b1101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1101)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=0, weight=0b1111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1111)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b0000)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0000)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b0010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0010)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b0011)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0011)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b0101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0101)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b0111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0111)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b1010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1010)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b1101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1101)\n\n    await test_case(dut, seed=0xAAAA, sel=0, dir=1, weight=0b1111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1111)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b0000)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0000)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b0010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0010)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b0011)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0011)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b0101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0101)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b0111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0111)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b1010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1010)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b1101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1101)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=0, weight=0b1111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1111)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b0000)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0000)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b0010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0010)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b0011)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0011)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b0101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0101)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b0111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b0111)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b1010)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1010)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b1101)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1101)\n\n    await test_case(dut, seed=0xAAAA, sel=1, dir=1, weight=0b1111)\n    await run_lfsr(dut, 0xAAAA, 5, weight=0b1111)\n\n\n\n    # Additional random test cases\n    random_seed = random.randint(0, 65535)\n    await test_case(dut, seed=random_seed, sel=1, dir=1, weight=0b0110)\n    await run_lfsr(dut, random_seed, 5, weight=0b0110)\n\nasync def test_case(dut, seed, sel, dir, weight):\n    \"\"\"Initialize test case with given seed, sel, dir, and weight\"\"\"\n    dut.reset.value = 1\n    await RisingEdge(dut.clock)\n\n    dut.reset.value = 0  # Assert reset\n    dut.lfsr_seed.value = seed\n    dut.sel.value = sel\n    dut.dir.value = dir\n    dut.weight.value = weight\n\n    # Wait for one clock cycle after reset\n    await RisingEdge(dut.clock)\n    cocotb.log.info(f\"Reset is low, output assigned to seed value: {bin(seed)}\")\n    \n    # Release reset and start running\n    dut.reset.value = 1\n    await RisingEdge(dut.clock)\n    cocotb.log.info(f\"Running Test Case: seed={bin(seed)}, sel={sel}, dir={dir}, weight={bin(weight)}\")\n\nasync def run_lfsr(dut, seed, cycles, weight):\n    \"\"\"Run the LFSR for a given number of clock cycles using custom logic\"\"\"\n    lfsr_out = seed  # Initialize testbench LFSR to seed value\n    lfsr_output = None  # Local variable to hold lfsr_new \n\n    for cycle in range(cycles):\n        await RisingEdge(dut.clock)\n        \n        # Corrected conversion from BinaryValue to int\n        lfsr_output = int(dut.lfsr_new.value)  \n        lfsr_out = get_lfsr_output(lfsr_output, int(dut.lfsr_out.value), weight)\n\n        # Read lfsr_new from DUT for comparison\n        lfsr_new_value = int(dut.lfsr_new.value)  # Corrected conversion\n\n        # Log detailed information for debugging\n        cocotb.log.info(f\"Cycle {cycle+1}: LFSR Out = {format(lfsr_out, '016b')} ({lfsr_out}), \"\n                        f\"LFSR New = {format(lfsr_new_value, '016b')} ({lfsr_new_value})\")\n\n        # Perform assertion only if weight is 0\n        if weight == 0:\n            assert lfsr_new_value == lfsr_out, \\\n                f\"Mismatch at cycle {cycle+1}: Expected {bin(lfsr_out)}, got {bin(lfsr_new_value)}\"\n\n        # Additional range checks\n        assert 0 <= lfsr_out < 65536, f\"lfsr_out out of 16-bit range: {bin(lfsr_out)}\"\n        assert 0 <= lfsr_new_value < 65536, f\"lfsr_new out of 16-bit range: {bin(lfsr_new_value)}\"\n\ndef get_lfsr_output(lfsr_output, lfsr_value, weight):\n    \"\"\"Return the new LFSR output; use hidden conditions when weight is zero\"\"\"\n    if weight == 0:\n        return lfsr_output  \n    else:\n        # Calculate feedback bits q1, q2, q3 based on RTL logic\n        q1 = ((lfsr_value >> 6) & 1) ^ ((lfsr_value >> 0) & 1)\n        q2 = ((lfsr_value >> 5) & 1) ^ ((lfsr_value >> 0) & 1)\n        q3 = ((lfsr_value >> 1) & 1) ^ ((lfsr_value >> 0) & 1)\n        # feed the logic to lfsr out to verify\n        return ((lfsr_value & 1) << 15) | (((lfsr_value >> 15) & 1) << 14) | (((lfsr_value >> 14) & 1) << 13) | (((lfsr_value >> 13) & 1) << 12) | (((lfsr_value >> 12) & 1) << 11) | (((lfsr_value >> 11) & 1) << 10) | (((lfsr_value >> 10) & 1) << 9) | (((lfsr_value >> 9) & 1) << 8) | (((lfsr_value >> 8) & 1) << 7) |  (((lfsr_value >> 7) & 1) << 6) | (q1 << 5) | (q2 << 4) | \\\n               ((lfsr_value >> 4) & 1 << 3) | ((lfsr_value >> 3) & 1 << 2) | ((lfsr_value >> 2) & 1 << 1) | q3\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}}
{"id": "cvdp_copilot_load_store_unit_0016", "categories": ["cid014", "medium"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `load_store_unit ` module. \n\n## **RTL Design Overview**  \n\n#### **Description:**\nThe `load_store_unit` (LSU) handles memory read and write operations, managing both aligned and misaligned accesses. It interfaces with the execution stage, writeback stage, and memory subsystem, ensuring that correct addresses, byte enables, and data are sent for load/store operations. It also manages the timing for data propagation between stages and ensures memory access validity using assertions.\n\n---\n\n#### **Ports:**\n\n##### **Inputs:**\n- **clk**: Clock signal for synchronization.\n- **rst_n**: Active-low reset signal.\n- **ex_if_req_i**: LSU request signal indicating a memory access request.\n- **ex_if_we_i**: Write enable signal (0 for load, 1 for store).\n- **ex_if_type_i**: Data type (byte, halfword, or word).\n- **ex_if_wdata_i**: Data to be written (for store operations).\n- **ex_if_addr_base_i**: Base address for the load/store operation.\n- **ex_if_addr_offset_i**: Offset to be added to the base address for memory access.\n- **ex_if_extend_mode_i**: Sign-extension or zero-extension mode for loads.\n\n##### **Outputs:**\n- **ex_if_ready_o**: Ready signal indicating LSU is ready for a new request.\n- **wb_if_rdata_o**: Data read from memory (for load operations).\n- **wb_if_rvalid_o**: Valid signal for the read data.\n- **dmem_req_o**: Memory request signal to DMEM.\n- **dmem_gnt_i**: Grant signal from DMEM, indicating the request has been accepted.\n- **dmem_req_addr_o**: Address for memory access.\n- **dmem_req_we_o**: Write enable signal to DMEM.\n- **dmem_req_be_o**: Byte enable signal for the memory access.\n- **dmem_req_wdata_o**: Data to be written to DMEM (for store operations).\n- **dmem_rsp_rdata_i**: Data read from DMEM (for load operations).\n- **dmem_rvalid_i**: Valid signal for the data read from DMEM.\n\n---\n\n#### **Internal Signals:**\n- **state**: Current state of the load/store unit, which can be IDLE, ALIGNED, or MISALIGNED states.\n- **next_state**: Next state to transition to based on the current state and input conditions.\n- **two_transactions**: Flag indicating whether the current operation requires two transactions (misaligned access).\n- **addr_0, addr_1**: Addresses for the two memory transactions in case of misalignment.\n- **be_0, be_1**: Byte enable signals for the two transactions in case of misalignment.\n- **wdata_q**: Data to be written to memory.\n- **data_rdata_ext**: Extended read data based on the data type.\n- **wb_rsp_valid**: Validity of the response data for writeback.\n\n---\n\n#### **Module Behavior:**\n\n1. **Address and Byte Enable Calculation:**\n   - The LSU calculates memory addresses and byte enables depending on the data type (byte, halfword, word). \n   - If the address is misaligned, the operation is split into two transactions (requiring `two_transactions`).\n\n2. **State Machine:**\nBelow is the FSM representation to handle all scenarios:\n\n```mermaid\nstateDiagram-v2\n    direction LR\n    [*] --> IDLE: rst_n\n    IDLE --> MISALIGNED_WR: wr and misaligned\n    MISALIGNED_WR --> MISALIGNED_WR_1: granted\n    MISALIGNED_WR_1 --> IDLE: granted\n    IDLE --> MISALIGNED_RD: rd and misaligned\n    MISALIGNED_RD --> MISALIGNED_RD_GNT: granted\n    MISALIGNED_RD_GNT --> MISALIGNED_RD_1: dmem_rvalid_i\n    MISALIGNED_RD_1 --> MISALIGNED_RD_GNT_1: granted\n    MISALIGNED_RD_GNT_1 --> IDLE: dmem_rvalid_i\n    IDLE --> ALIGNED_WR: wr and aligned\n    ALIGNED_WR --> IDLE: granted\n    IDLE --> ALIGNED_RD: rd and aligned\n    ALIGNED_RD --> ALIGNED_RD_GNT: granted\n    ALIGNED_RD_GNT --> IDLE: dmem_rvalid_i\n```\n\n### **FSM State Descriptions**\n1. **IDLE:**\n   - Default state where the LSU waits for a request from the execute stage.\n   - Transitions to either `ALIGNED_WR`, `ALIGNED_RD`, `MISALIGNED_WR`, or `MISALIGNED_RD` based on the type and alignment of the request.\n\n2. **ALIGNED_WR:**\n   - Handles single bus transaction for an aligned store.\n   - Transitions back to `IDLE` after the grant signal.\n\n3. **ALIGNED_RD:**\n   - Handles single bus transaction for an aligned load.\n   - Transitions back to `IDLE` after the data memory response (`dmem_rvalid_i`).\n\n4. **MISALIGNED_WR:**\n   - Initiates the first bus transaction for a misaligned store.\n   - Transitions to `MISALIGNED_WR_1` after the first grant signal.\n\n5. **MISALIGNED_WR_1:**\n   - Completes the second bus transaction for a misaligned store.\n   - Returns to `IDLE` after the second grant signal.\n\n6. **MISALIGNED_RD:**\n   - Initiates the first bus transaction for a misaligned load.\n   - Transitions to `MISALIGNED_RD_GNT` after the first grant signal.\n\n7. **MISALIGNED_RD_GNT:**\n   - Waits for the first data response (`dmem_rvalid_i`) and transitions to `MISALIGNED_RD_1`.\n\n8. **MISALIGNED_RD_1:**\n   - Initiates the second bus transaction for a misaligned load.\n   - Transitions to `MISALIGNED_RD_GNT_1` after the second grant signal.\n\n9. **MISALIGNED_RD_GNT_1:**\n   - Waits for the second data response (`dmem_rvalid_i`) and transitions back to `IDLE`.\n\n\n3. **Request Handling:**\n   - The LSU monitors the `ex_if_req_i` signal to trigger a memory request.\n   - It determines whether the request is aligned or misaligned based on `two_transactions` and prepares the corresponding memory access signals.\n\n4. **Memory Request Generation:**\n   - Based on the request, the LSU asserts `dmem_req_o` and provides the memory address, byte enables, and data to the memory subsystem.\n   \n5. **Response Handling:**\n   - For load operations, data is read from memory (`dmem_rsp_rdata_i`), extended according to the data type, and sent to the writeback stage (`wb_if_rdata_o`).\n   - The module ensures proper timing and validity by controlling `dmem_req_o` and `dmem_rsp_rdata_i` based on the state transitions.\n\n---\n## Assertion Details\n\n### 1. **Invalid State Assertion**\nWrite an assertion to check that the `state` signal is always inside a valid set of states. The valid states include:\n- `IDLE`\n- `MISALIGNED_WR`, `MISALIGNED_WR_1`\n- `MISALIGNED_RD`, `MISALIGNED_RD_GNT`, `MISALIGNED_RD_GNT_1`, `MISALIGNED_RD_1`\n- `ALIGNED_RD_GNT`, `ALIGNED_RD`, `ALIGNED_WR`, `ALIGNED_WB`\n- `MISALIGNED_WB`\n\n---\n\n### 2. **Request When Not Ready Assertion**\nWrite an assertion to ensure that if `ex_if_req_i` is active only if `ex_if_ready_o` also active. This asserts that a request cannot happen if the system isn't ready.\n\n---\n\n### 3. **Aligned Write Assertion**\nWrite an assertion to check that when an aligned write request is directed to the memory, the memory responds with a grant (dmem_gnt_i) within 1 to 6 cycles.\n\n---\n\n### 4. **Aligned Read Assertion**\nWrite an assertion to check that when an aligned read request is directed to the memory, the memory responds with a grant (dmem_gnt_i) within 1 to 6 cycles, followed by the memory returning the data (dmem_rvalid_i) within the next 1 to 6 cycles.\n\n---\n\n### 5. **Misaligned Read Assertion**\nWrite an assertion to check that when a **misaligned read** request is directed, `dmem_req_o` is asserted twice to the memory. The memory should respond with a grant (`dmem_gnt_i`) within 1 to 6 cycles, followed by returning the data (`dmem_rvalid_i`) within the next 1 to 6 cycles. The sequence should occur as follows:\n\n1. `dmem_req_o` is asserted to initiate the first transaction.\n2. Once the memory grants the request, within 1 to 6 cycles, `dmem_req_o` is deasserted, and the module waits for `dmem_rvalid_i` to be asserted within 1 to 6 cycles before initiating the second transaction.\n3. `dmem_req_o` is asserted again to initiate the second transaction.\n4. When the memory grants the request, within 1 to 6 cycles, `dmem_req_o` is deasserted, and the module waits for `dmem_rvalid_i` to be asserted within 1 to 6 cycles, completing the misaligned read operation.\n\n---\n\n### 6. **Misaligned Write Assertion**\nWrite an assertion to check that when a **misaligned write** request is directed, `dmem_req_o` is asserted once to the memory. The memory should respond with a grant (`dmem_gnt_i`) within 1 to 6 cycles, followed by another grant (`dmem_gnt_i`) within the next 1 to 6 cycles. The sequence should occur as follows:\n\n1. `dmem_req_o` is asserted to initiate the first transaction.\n2. Once the memory grants the request, within 1 to 6 cycles, `dmem_req_o` **remains high**, and the module initiates the second transaction (without deasserting `dmem_req_o` in between).\n3. When the memory grants the second request, within 1 to 6 cycles, `dmem_req_o` is deasserted, completing the misaligned write operation.\n \n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/load_store_unit.sv": "module load_store_unit (\n    input  logic                 clk,\n    input  logic                 rst_n,\n\n    // EX stage interface\n    input  logic                 ex_if_req_i,           // LSU request\n    input  logic                 ex_if_we_i,            // Write enable: 0 (load), 1 (store)\n    input  logic     [ 1:0]      ex_if_type_i,          // Data type: 0x2 (word), 0x1 (halfword), 0x0 (byte)\n    input  logic     [31:0]      ex_if_wdata_i,         // Data to write to memory\n    input  logic     [31:0]      ex_if_addr_base_i,     // Base address\n    input  logic     [31:0]      ex_if_addr_offset_i,   // Offset address\n    input  logic                 ex_if_extend_mode_i,\n    output logic                 ex_if_ready_o    ,\n\n    \n    // Writeback stage interface\n    output logic     [31:0]      wb_if_rdata_o,         // Requested data\n    output logic                 wb_if_rvalid_o,        // Requested data valid\n\n    // Data memory (DMEM) interface\n    output logic                 dmem_req_o,\n    input  logic                 dmem_gnt_i,\n    output logic     [31:0]      dmem_req_addr_o,\n    output logic                 dmem_req_we_o,\n    output logic     [ 3:0]      dmem_req_be_o,\n    output logic     [31:0]      dmem_req_wdata_o,\n    input  logic     [31:0]      dmem_rsp_rdata_i,\n    input  logic                 dmem_rvalid_i\n    );\n  \n  typedef enum logic [4:0] {\n        IDLE,    \n        MISALIGNED_WR,\n        MISALIGNED_WR_1,  \n        MISALIGNED_RD ,\n        MISALIGNED_RD_GNT,\n        MISALIGNED_RD_GNT_1, \n        MISALIGNED_RD_1,\n        ALIGNED_RD_GNT,\n        ALIGNED_RD,\n        ALIGNED_WR,\n        ALIGNED_WB,\n        MISALIGNED_WB\n        } state_t;\n  state_t state, next_state ;\n  // Internal signals\n  logic ex_req_fire;\n  logic we_q;\n  logic [31:0] data_addr_int, addr_0, addr_1, word_addr, next_word_addr, addr_0_q, addr_1_q ;\n  logic  two_transactions;\n  logic [3:0] be_0, be_1, be_0_q, be_1_q ;\n\n  \n\n  logic [31:0] wdata_q;\n\n  logic wb_rsp_valid;\n\n  logic [1:0] rdata_offset_q ;\n  logic [31:0] rdata_w_ext , rdata_h_ext, rdata_b_ext, data_rdata_ext, dmem_rsp_data, rdata_0_q, rdata_1_q ;\n  logic [1:0] data_type_q ;\n  logic data_sign_ext_q ;\n\n  always_comb begin\n    data_addr_int = ex_if_addr_base_i + ex_if_addr_offset_i;\n    word_addr = {data_addr_int[31:2], 2'b00} ;\n    next_word_addr = word_addr + 3'b100 ;\n  end\n\n  assign ex_req_fire = ex_if_req_i && ex_if_ready_o ;\n\n  always_comb begin : address_bmem_alignment\n    addr_0 = '0 ;\n    be_0 = 4'b0000;\n    addr_1 = '0 ;\n    be_1 = 4'b0000;\n    two_transactions = 1'b0 ; \n    case (ex_if_type_i)  \n      2'b00: begin  \n          addr_0 = word_addr ;\n          case (data_addr_int[1:0])\n            2'b00:   be_0 = 4'b0001;\n            2'b01:   be_0 = 4'b0010;\n            2'b10:   be_0 = 4'b0100;\n            2'b11:   be_0 = 4'b1000;\n            default: be_0 = 4'b0000;\n          endcase\n      end\n\n      2'b01: begin  \n          case (data_addr_int[1:0])\n            2'b00: begin\n              addr_0 = word_addr ; \n              be_0 = 4'b0011;\n            end\n            2'b01: begin\n              addr_0 = word_addr ;\n              be_0 = 4'b0110;\n            end\n            2'b10: begin\n              addr_0 = word_addr ;\n              be_0 = 4'b1100;\n            end\n            2'b11: begin\n              two_transactions = 1'b1 ; \n              addr_0 = word_addr ;\n              be_0 = 4'b1000;\n              addr_1 = next_word_addr ;\n              be_1 = 4'b0001;\n            end\n          endcase\n      end\n\n      2'b10: begin  \n          case (data_addr_int[1:0])\n            2'b00: begin\n              addr_0 = word_addr ;\n              be_0 = 4'b1111;\n            end   \n            2'b01: begin\n              two_transactions = 1'b1 ;\n              addr_0 = word_addr ;\n              be_0 = 4'b1110;\n              addr_1 = next_word_addr ;\n              be_1 = 4'b0001;\n            end\n            2'b10: begin\n              two_transactions = 1'b1 ;\n              addr_0 = word_addr ;\n              be_0 = 4'b1100;\n\n              addr_1 = next_word_addr ;\n              be_1 = 4'b0011;\n            end\n            2'b11: begin\n              two_transactions = 1'b1 ;\n              addr_0 = word_addr ;\n              be_0 = 4'b1000;\n              addr_1 = next_word_addr ;\n              be_1 = 4'b0111;\n            end\n          endcase\n      end\n      default: begin\n        addr_0 = '0 ;\n        be_0 = 4'b0000;\n        addr_1 = '0 ;\n        be_1 = 4'b0000;\n        two_transactions = 1'b0 ;\n      end\n       \n    endcase\n  end\n\n  always_comb begin : state_transition\n    case(state)\n      IDLE: begin // Note req only checked if idle (ready)\n        if (ex_if_req_i) begin\n          if (ex_if_we_i && two_transactions) begin\n            next_state = MISALIGNED_WR ;\n          end \n          else if (!ex_if_we_i && two_transactions) begin \n            next_state = MISALIGNED_RD ;\n          end \n          else if (ex_if_we_i && !two_transactions)  begin\n            next_state = ALIGNED_WR ;\n          end \n          else next_state = ALIGNED_RD ;\n        end else begin\n          next_state = IDLE ;\n        end\n      end\n      MISALIGNED_WR: begin\n        if (dmem_gnt_i) begin\n          next_state = MISALIGNED_WR_1 ; \n        end else begin\n          next_state = MISALIGNED_WR ;\n        end\n      end\n      MISALIGNED_WR_1: begin\n        if (dmem_gnt_i) begin\n          next_state = IDLE ; \n        end else begin\n          next_state = MISALIGNED_WR_1 ;\n        end\n      end\n      \n      MISALIGNED_RD: begin\n        if (dmem_gnt_i) begin\n          next_state = MISALIGNED_RD_GNT ; \n        end else begin\n          next_state = MISALIGNED_RD ;\n        end\n      end\n\n      MISALIGNED_RD_GNT: begin\n        if (dmem_rvalid_i) begin\n          next_state = MISALIGNED_RD_1 ; \n        end else begin\n          next_state = MISALIGNED_RD_GNT ;\n        end\n      end\n\n      MISALIGNED_RD_1: begin\n        if (dmem_gnt_i) begin\n          next_state = MISALIGNED_RD_GNT_1 ; \n        end else begin\n          next_state = MISALIGNED_RD_1 ;\n        end\n      end\n\n      MISALIGNED_RD_GNT_1: begin\n        if (dmem_rvalid_i) begin\n          next_state = MISALIGNED_WB ; \n        end else begin\n          next_state = MISALIGNED_RD_GNT_1 ;\n        end\n      end\n\n      MISALIGNED_WB: begin\n        next_state = IDLE ;\n      end\n\n      ALIGNED_WR: begin\n        if (dmem_gnt_i) begin\n          next_state = IDLE ; \n        end else begin\n          next_state = ALIGNED_WR ;\n        end\n      end\n      ALIGNED_RD : begin\n        if (dmem_gnt_i) begin\n          next_state = ALIGNED_RD_GNT ; \n        end else begin\n          next_state = ALIGNED_RD ;\n        end\n      end\n      ALIGNED_RD_GNT: begin\n        if (dmem_rvalid_i) begin\n          next_state = ALIGNED_WB ; \n        end else begin\n          next_state = ALIGNED_RD_GNT ;\n        end\n      end\n      \n      ALIGNED_WB: begin\n        next_state = IDLE ;\n      end\n      \n      default: begin\n        next_state = IDLE ;\n      end\n    endcase\n  end\n  always_comb begin : output_logic\n    case(state)\n      IDLE: begin\n        ex_if_ready_o     = 1'b1 ;\n        dmem_req_o        = '0 ;\n        dmem_req_addr_o   = '0 ;\n        dmem_req_we_o     = '0 ;\n        dmem_req_be_o     = '0 ;\n        dmem_req_wdata_o  = '0 ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n      MISALIGNED_WR: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b1 ;\n        dmem_req_addr_o   = addr_0_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_0_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ; \n        wb_rsp_valid      = 1'b0 ;\n      end\n      MISALIGNED_WR_1: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b1 ;\n        dmem_req_addr_o   = addr_1_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_1_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n      \n      MISALIGNED_RD: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b1 ;\n        dmem_req_addr_o   = addr_0_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_0_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n\n      MISALIGNED_RD_GNT: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b0 ;\n        dmem_req_addr_o   = addr_0_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_0_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n\n      MISALIGNED_RD_1: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b1 ;\n        dmem_req_addr_o   = addr_1_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_1_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n\n      MISALIGNED_RD_GNT_1: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b0 ;\n        dmem_req_addr_o   = addr_0_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_0_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n\n      MISALIGNED_WB: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b0 ;\n        dmem_req_addr_o   = '0 ;\n        dmem_req_we_o     = '0 ; \n        dmem_req_be_o     = '0 ; \n        dmem_req_wdata_o  = '0 ;\n        dmem_rsp_data     = rdata_0_q | rdata_1_q ;\n        wb_rsp_valid      = 1'b1 ; \n      end\n      ALIGNED_WR: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b1 ;\n        dmem_req_addr_o   = addr_0_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_0_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n      ALIGNED_RD : begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b1 ;\n        dmem_req_addr_o   = addr_0_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_0_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n      ALIGNED_RD_GNT: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b0 ;\n        dmem_req_addr_o   = addr_0_q ;\n        dmem_req_we_o     = we_q ; \n        dmem_req_be_o     = be_0_q ; \n        dmem_req_wdata_o  = wdata_q ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n\n      ALIGNED_WB: begin\n        ex_if_ready_o     = 1'b0 ;\n        dmem_req_o        = 1'b0 ;\n        dmem_req_addr_o   = '0 ;\n        dmem_req_we_o     = '0 ; \n        dmem_req_be_o     = '0 ; \n        dmem_req_wdata_o  = '0 ;\n        dmem_rsp_data     = rdata_0_q ;\n        wb_rsp_valid      = 1'b1 ;\n      end\n      default: begin\n        ex_if_ready_o     = 1'b1 ;\n        dmem_req_o        = '0 ;\n        dmem_req_addr_o   = '0 ;\n        dmem_req_we_o     = '0 ;\n        dmem_req_be_o     = '0 ;\n        dmem_req_wdata_o  = '0 ;\n        dmem_rsp_data = '0 ;\n        wb_rsp_valid      = 1'b0 ;\n      end\n    endcase\n  end\n  \n  always_ff @( posedge clk or negedge rst_n ) begin : FSM\n    if (!rst_n) begin\n      state <= IDLE;\n    end else begin\n      state <= next_state;\n    end  \n  end\n  \n    \n  always_ff @(posedge clk or negedge rst_n) begin : ex_req_reg\n    if (!rst_n) begin\n      we_q <= '0 ;\n      addr_0_q <= '0 ; \n      be_0_q <= '0 ;\n      addr_1_q <= '0 ;\n      be_1_q <= '0 ;\n      wdata_q <= '0 ;\n      data_type_q <= '0 ;\n      rdata_offset_q <= '0 ;\n      data_sign_ext_q <= '0 ;\n      \n    end else if (ex_req_fire) begin\n      we_q <= ex_if_we_i ;\n      addr_0_q <= addr_0; \n      be_0_q <= be_0;\n      addr_1_q <= addr_1;\n      be_1_q <= be_1;\n      wdata_q <= ex_if_wdata_i ;\n      data_type_q <= ex_if_type_i ;\n      rdata_offset_q <= data_addr_int[1:0] ;\n      data_sign_ext_q <= ex_if_extend_mode_i ;\n    end \n  end\n\nalways_comb begin : w_ext\n    case (rdata_offset_q)\n      2'b00: rdata_w_ext = dmem_rsp_data[31:0];\n      2'b01: rdata_w_ext = {dmem_rsp_data[7:0], dmem_rsp_data[31:8]};\n      2'b10: rdata_w_ext = {dmem_rsp_data[15:0], dmem_rsp_data[31:16]};\n      2'b11: rdata_w_ext = {dmem_rsp_data[23:0], dmem_rsp_data[31:24]};\n      default: rdata_w_ext = dmem_rsp_data ;\n    endcase\n  end\n\n  always_comb begin : h_ext\n    case (rdata_offset_q)\n      2'b00: begin\n        if (data_sign_ext_q) rdata_h_ext ={{16{dmem_rsp_data[15]}}, dmem_rsp_data[15:0]};\n        else rdata_h_ext =  {16'h0000, dmem_rsp_data[15:0]};\n      end\n\n      2'b01: begin\n        if (data_sign_ext_q) rdata_h_ext ={{16{dmem_rsp_data[23]}}, dmem_rsp_data[23:8]};\n        else rdata_h_ext =  {16'h0000, dmem_rsp_data[23:8]};\n      end\n      2'b10: begin\n        if (data_sign_ext_q) rdata_h_ext ={{16{dmem_rsp_data[31]}}, dmem_rsp_data[31:16]};\n        else rdata_h_ext =  {16'h0000, dmem_rsp_data[31:16]};\n      end\n      2'b11: begin\n        if (data_sign_ext_q) rdata_h_ext ={{16{dmem_rsp_data[7]}}, dmem_rsp_data[7:0] , dmem_rsp_data[31:24] };\n        else rdata_h_ext =  {16'h0000, dmem_rsp_data[7:0], dmem_rsp_data[31:24] };\n      end\n      \n      default: begin\n        rdata_h_ext = dmem_rsp_data ;  \n      end\n    endcase  \n  end\n  \n  always_comb begin : b_ext\n    case (rdata_offset_q)\n      2'b00: begin\n        if (data_sign_ext_q) rdata_b_ext  = {{24{dmem_rsp_data[7]}}, dmem_rsp_data[7:0]}; \n        else rdata_b_ext = {24'h00_0000, dmem_rsp_data[7:0]};\n      end\n\n      2'b01: begin\n        if (data_sign_ext_q) rdata_b_ext  = {{24{dmem_rsp_data[15]}}, dmem_rsp_data[15:8]}; \n        else rdata_b_ext = {24'h00_0000, dmem_rsp_data[15:8]};\n      end\n\n      2'b10: begin\n        if (data_sign_ext_q) rdata_b_ext  = {{24{dmem_rsp_data[23]}}, dmem_rsp_data[23:16]}; \n        else rdata_b_ext = {24'h00_0000, dmem_rsp_data[23:16]};\n      end\n\n      2'b11: begin\n        if (data_sign_ext_q) rdata_b_ext  = {{24{dmem_rsp_data[31]}}, dmem_rsp_data[31:24]}; \n        else rdata_b_ext = {24'h00_0000, dmem_rsp_data[31:24]};\n      end\n    endcase  \n  end\n\n  always_comb begin : rdata_ext\n    case (data_type_q)\n      2'b00:        data_rdata_ext = rdata_b_ext ;\n      2'b01:        data_rdata_ext = rdata_h_ext;\n      2'b10:        data_rdata_ext = rdata_w_ext;\n      default:      data_rdata_ext = 32'b0;\n    endcase  \n  end\n\n  always_ff @(posedge clk or negedge rst_n) begin :dmem_reg\n    if (!rst_n) begin\n      rdata_0_q   <= 32'b0;\n      rdata_1_q   <=  32'b0;\n    end else if (dmem_rvalid_i) begin\n      rdata_0_q  <= dmem_rsp_rdata_i;\n      rdata_1_q  <= rdata_0_q;\n    end\n  end\n\n\n  assign wb_if_rdata_o =  data_rdata_ext;\n  assign wb_if_rvalid_o = wb_rsp_valid;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/load_store_unit.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\r\n\r\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "SIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/load_store_unit.sv\nTOPLEVEL        = load_store_unit\nMODULE          = test_load_store_unit\nPYTHONPATH      = /src\nHASH            = \"feature/assertions_1\"\n", "src/harness_library.py": "\nimport cocotb\nfrom cocotb.triggers import FallingEdge, RisingEdge, ReadOnly, NextTimeStep, Timer\nimport random\nimport os\nimport subprocess\nimport re\n#       Test_Vec = (type, wdata, addr_base, addr_off, sign_extend)\n\ndef is_cross_boundary(Test_Vec):\n    type = Test_Vec[0] \n    address = (Test_Vec[2]+ Test_Vec[3])\n    addr_offset= address& 0x3\n    crossing_hw = (type == 0x1) and (addr_offset==3)\n    crossing_w = (type == 0x2) and (addr_offset!=0)\n    if ( crossing_hw or crossing_w ):\n            return True\n    else:\n        return False\n\nasync def check_dmem_req(dut, Test_Vec, we):\n    address = (Test_Vec[2]+ Test_Vec[3])\n    expected_addr = (address//4)*4\n    \n    if (is_cross_boundary(Test_Vec)):\n        for _ in range(2):\n            while int(dut.dmem_req_o.value) != 1:\n                await RisingEdge(dut.clk)\n            \n            await FallingEdge(dut.clk)\n            dut_address = int(dut.dmem_req_addr_o.value)\n            dut_we = int(dut.dmem_req_we_o.value)\n\n            assert dut_address == expected_addr, f\"Dmem address mismatch: Expected:{expected_addr}, Got:{dut_address}\"\n            assert dut_we == we, f\"Dmem we mismatch: Expected: {we}, Got:{dut_we}\"\n            # wait for that transaction to be granted/rvalid rsp\n            if(we):\n                await RisingEdge(dut.dmem_gnt_i)\n            else:\n                await RisingEdge(dut.dmem_rvalid_i)\n            await RisingEdge(dut.clk)\n            \n            expected_addr+=4\n    else:\n        while int(dut.dmem_req_o.value) != 1:\n                await RisingEdge(dut.clk)\n        \n        await FallingEdge(dut.clk)\n        dut_address = int(dut.dmem_req_addr_o.value)\n        dut_we = int(dut.dmem_req_we_o.value)\n\n        assert dut_address == expected_addr, f\"Dmem address mismatch: Expected:{expected_addr}, Got:{dut_address}\"\n        assert dut_we == we, f\"Dmem we mismatch: Expected: {we}, Got:{dut_we}\"\n\n    \n    \n\nasync def check_wb_val(dut, dmem_model, Test_Vec):\n    type, _, addr_base, addr_off, sign_extend = Test_Vec\n    address = (addr_base+ addr_off)\n    aligned_address = (address//4)*4\n    expected_wb = 0 \n    read_val_vec = (aligned_address, 0, 0xF, 0)\n    data0 = dmem_model.read_addr(read_val_vec)\n    read_val_vec = (aligned_address+4, 0, 0xF, 0)\n    data1 = dmem_model.read_addr(read_val_vec)\n    byte_offset = address % 4\n\n    if (is_cross_boundary(Test_Vec)):\n        # Calculate offsets and extract relevant data\n        if type == 1:  # Halfword\n            if byte_offset == 3:\n                extracted_data = ((data0 >> (8 * 3)) & 0xFF) | ((data1 & 0xFF) << 8)\n            else:\n                extracted_data = (data0 >> (8 * byte_offset)) & 0xFFFF\n        elif type == 2:  # Word\n            extracted_data = ((data0 >> (8 * byte_offset)) & 0xFFFFFFFF) | ((data1 & 0xFFFFFFFF) << (32 - 8 * byte_offset))\n\n        # Apply sign or zero extension\n        if sign_extend:\n            sign_bit = 1 << (15 if type == 1 else 31)  # MSB for halfword or word\n            if extracted_data & sign_bit:\n                expected_wb = extracted_data | (~((1 << (16 if type == 1 else 32)) - 1))\n            else:\n                expected_wb = extracted_data\n        else:\n            expected_wb = extracted_data\n        \n        expected_wb = expected_wb & 0xFFFFFFFF\n \n    else: # Aligned case\n        if type == 0:  # Byte\n            extracted_data = (data0 >> (8 * byte_offset)) & 0xFF\n        elif type == 1:  # Halfword\n            extracted_data = (data0 >> (8 * byte_offset)) & 0xFFFF\n        elif type == 2:  # Word\n            extracted_data = data0\n\n        # Apply sign or zero extension\n        if sign_extend:\n            sign_bit = 1 << (7 if type == 0 else 15 if type == 1 else 31) # 0b10000000 , 0b1000000000000000\n            if extracted_data & sign_bit:\n                expected_wb = extracted_data | (~((1 << (8 if type == 0 else 16 if type == 1 else 32)) - 1))\n            else:\n                expected_wb = extracted_data\n        else:\n            expected_wb = extracted_data\n        \n        expected_wb = expected_wb & 0xFFFFFFFF\n        expected_wb = expected_wb & 0xFFFFFFFF\n\n    while int(dut.wb_if_rvalid_o.value) != 1:\n            await RisingEdge(dut.clk)\n        \n    \n    wb_if_rdata_o = int(dut.wb_if_rdata_o.value)\n\n    assert wb_if_rdata_o == expected_wb, f\"WB MISMATCH: Expected:{hex(expected_wb)}, Got:{hex(wb_if_rdata_o)}\"\n    \n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def reset_dut(reset, duration_ns = 10):\n    # Restart Interface\n    reset.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    reset.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    reset.value = 1\n    await Timer(duration_ns, units='ns')\n    reset._log.debug(\"Reset complete\")\n\n\n\nclass DataMemory:\n    def __init__(self):\n        self.mem_array = [0] * (2**8)  # 32-bit memory addresses\n\n    # Value tuple is a tuple (addr, we, be, wdata)\n    def write_addr(self, value):\n        \"\"\"\n        Perform a memory write operation considering the byte enable (BE).\n        \"\"\"\n        addr, we, be, wdata = value\n\n        if we:  # Write enable is asserted\n            current_word = self.mem_array[addr]\n            for byte_index in range(4):\n                if be & (1 << byte_index):  \n                    current_word &= ~(0xFF << (byte_index * 8))\n                    current_word |= (wdata & (0xFF << (byte_index * 8)))\n\n            self.mem_array[addr] = current_word\n\n    def read_addr(self, value):\n        \"\"\"\n        Perform a memory read operation considering the byte enable (BE).\n        \"\"\"\n        addr, _, be, _ = value\n\n        \n        current_word = self.mem_array[addr]\n\n        \n        read_data = 0\n        for byte_index in range(4):\n            if be & (1 << byte_index):  \n                read_data |= (current_word & (0xFF << (byte_index * 8)))\n\n        return read_data\n\nclass ExReqDriver:\n    def __init__(self, dut, name, clk, sb_callback):\n        \"\"\"\n        Initialize the InputDriver.\n        :param dut: The DUT instance.\n        :param name: The name of the bus signals (e.g., 'input_bus').\n        :param clk: Clock signal for synchronization.\n        :param sb_callback: Callback function to handle data/address events.\n        \"\"\"\n        self.dut = dut\n        self.clk = clk\n        self.callback = sb_callback\n        \n        # Initialize bus signals\n        self.bus = {\n            \"req_i\"         : getattr(dut, f\"{name}_req_i\"),\n            \"we_i\"          : getattr(dut, f\"{name}_we_i\"),\n            \"type_i\"        : getattr(dut, f\"{name}_type_i\"),\n            \"wdata_i\"       : getattr(dut, f\"{name}_wdata_i\"),\n            \"addr_base_i\"   : getattr(dut, f\"{name}_addr_base_i\"),\n            \"extend_mode_i\" : getattr(dut, f\"{name}_extend_mode_i\"),              \n            \"addr_offset_i\" : getattr(dut, f\"{name}_addr_offset_i\"),\n            \"ready_o\"       : getattr(dut, f\"{name}_ready_o\"), \n        }\n\n        # Reset bus values\n        self.bus[\"req_i\"].value = 0\n\n    async def write_req(self, value):\n        \"\"\"\n        Send a value over the bus.\n        :param value: A tuple (type, wdata, base_addr, off_addr) to send on the bus.\n        \"\"\"\n        # Random delay before request\n        for _ in range(random.randint(1, 20)):\n            await RisingEdge(self.clk)\n\n        # Wait until ready signal is asserted\n        # PROMPT: \" ex_if_req_i Should only be asserted if the module is ready\"\n        while self.bus[\"ready_o\"].value != 1:\n            await RisingEdge(self.clk)\n\n        # Drive the bus\n        # PROMPT:\n        # The module will register the calculated \n        # address, write data (if applicable), and control signals (e.g., write enable, byte enable) to signal a data memory request.\n        self.bus[\"req_i\"].value = 1\n        self.bus[\"we_i\"].value = 1\n        self.bus[\"type_i\"].value = value[0]\n        self.bus[\"wdata_i\"].value = value[1]\n        self.bus[\"addr_base_i\"].value = value[2]\n        self.bus[\"addr_offset_i\"].value = value[3]\n        self.bus[\"extend_mode_i\"].value = 0 # Doesn't affect write\n\n\n        # Allow ReadOnly phase and trigger the callback\n        await ReadOnly()\n        self.callback(self.dut, int(self.bus[\"type_i\"].value), int(self.bus[\"wdata_i\"].value), int(self.bus[\"addr_base_i\"].value), int(self.bus[\"addr_offset_i\"].value))\n\n        # Hold the enable signal for one clock cycle\n        await RisingEdge(self.clk)\n        self.bus[\"req_i\"].value = 0\n        self.bus[\"we_i\"].value = 0\n\n        \n            \n\n    async def read_req(self, value):\n        \"\"\"\n        Send a value over the bus.\n        :param value: A tuple (type, wdata, base_addr, off_addr) to send on the bus.\n        \"\"\"\n        # Random delay before sending data\n        #PROMPT: \" ex_if_req_i Should only be asserted if the module is ready\"\n        for _ in range(random.randint(1, 20)):\n            await RisingEdge(self.clk)\n\n        # Wait until ready signal is asserted\n        # PROMPT: \" ex_if_req_i Should only be asserted if the module is ready\"\n        while self.bus[\"ready_o\"].value != 1:\n            await RisingEdge(self.clk)\n\n        # Drive the bus\n        # PROMPT:\n        # The module will register the calculated \n        # address, write data (if applicable), and control signals (e.g., write enable, byte enable) to signal a data memory request.\n        self.bus[\"req_i\"].value = 1\n        self.bus[\"we_i\"].value = 0\n        self.bus[\"type_i\"].value = value[0]\n        self.bus[\"wdata_i\"].value = 0\n        self.bus[\"addr_base_i\"].value = value[2]\n        self.bus[\"addr_offset_i\"].value = value[3]\n        self.bus[\"extend_mode_i\"].value = value[4]\n        self.extend = value[4]\n\n\n        # Allow ReadOnly phase and trigger the callback\n        await ReadOnly()\n        self.callback(self.dut, int(self.bus[\"type_i\"].value), int(self.bus[\"wdata_i\"].value), int(self.bus[\"addr_base_i\"].value), int(self.bus[\"addr_offset_i\"].value))\n\n        # Hold the enable signal for one clock cycle\n        await RisingEdge(self.clk)\n        self.bus[\"req_i\"].value = 0\n\n        \n\n\nclass dmemIFDriver:\n    def __init__(self, dut, name, clk, dmem_model):\n        \"\"\"\n        Initialize the InputDriver.\n        :param dut: The DUT instance.\n        :param name: The name of the bus signals (e.g., 'input_bus').\n        :param clk: Clock signal for synchronization.\n        \"\"\"\n        self.dut = dut\n        self.clk = clk\n        # Initialize bus signals\n        self.bus = {\n            \"req_o\"        : getattr(dut, f\"{name}_req_o\"),\n            \"req_addr_o\"   : getattr(dut, f\"{name}_req_addr_o\"),\n            \"req_we_o\"     : getattr(dut, f\"{name}_req_we_o\"),\n            \"req_be_o\"     : getattr(dut, f\"{name}_req_be_o\"),\n            \"req_wdata_o\"  : getattr(dut, f\"{name}_req_wdata_o\"),\n            \"rsp_rdata_i\"  : getattr(dut, f\"{name}_rsp_rdata_i\"),\n            \"rvalid_i\"     : getattr(dut, f\"{name}_rvalid_i\"),\n            \"gnt_i\"        : getattr(dut, f\"{name}_gnt_i\"),    \n        }\n\n        # Reset bus values\n        self.bus[\"rvalid_i\"].value = 0\n        self.bus[\"rsp_rdata_i\"].value = 0\n        self.bus[\"gnt_i\"].value = 0\n        self.dmem_model = dmem_model\n        cocotb.start_soon(self._listening())\n\n\n    async def _listening(self):\n        while True:\n            while self.bus[\"req_o\"].value != 1:\n                await RisingEdge(self.clk)\n            addr = int(self.bus[\"req_addr_o\"].value)\n            we = int(self.bus[\"req_we_o\"].value)\n            be = int(self.bus[\"req_be_o\"].value)\n            wdata = int(self.bus[\"req_wdata_o\"].value)\n            Req_vector = (addr, we, be, wdata)\n            await self._process_req(Req_vector)\n            \n          \n    async def _process_req(self, value):\n        \"\"\"\n        Send a value over the bus.\n        :param value: A tuple (addr, we, be, wdata) to send on the bus.\n        \"\"\"\n        # Wait random time to gnt the request \n        for _ in range(random.randint(1, 5)):\n            await RisingEdge(self.clk)\n        self.bus[\"gnt_i\"].value = 1\n        await RisingEdge(self.clk)\n        self.bus[\"gnt_i\"].value = 0\n        await ReadOnly()\n        if value[1] == 1: #Write req\n            self.dmem_model.write_addr(value)\n        else: #Read req\n           # Read from mem model\n           rdata = self.dmem_model.read_addr(value)\n           for _ in range(random.randint(1, 5)):\n               await RisingEdge(self.clk) \n           self.bus[\"rvalid_i\"].value = 1\n           self.bus[\"rsp_rdata_i\"].value = rdata \n           await RisingEdge(self.clk)\n           self.bus[\"rvalid_i\"].value = 0\n           self.bus[\"rsp_rdata_i\"].value = 0\n           \n    \n#################    ASSERTIONS STUFF        ###############\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"    \n     \n        \n    ", "src/test_load_store_unit.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport time\nimport harness_library as hrs_lb\nfrom harness_library import ExReqDriver, dmemIFDriver, DataMemory\n\n# Place holder for coverage\n\ndef execute_sb_fn(dut,type_i, wdata, addr_base, addr_offset):\n   pass\n   #dut._log.info(f\"Execute unit request -- type:{hex(type_i)}, write_data = {hex(wdata)}, addr: {hex(addr_base + addr_offset)}\")\n\n@cocotb.test()\nasync def test_load_store_unit(dut): \n   # Start clock\n   DUT_CLK = Clock(dut.clk, 10, 'ns')\n   await cocotb.start(DUT_CLK.start())\n   dut.clk._log.info(f\"clk STARTED\")\n\n   await hrs_lb.dut_init(dut)\n\n   # Apply reset \n   await hrs_lb.reset_dut(dut.rst_n, 10)\n\n   for i in range(2):\n      await RisingEdge(dut.clk)\n\n   # Ensure  outputs reset value \n\n   # The Execution Stage Interface is signaled as ready for new requests.\n   assert dut.ex_if_ready_o.value == 1, f\"The Execution Stage Interface should be signaled as ready for new requests (ex_if_ready_o = 0x1): {dut.ex_if_ready_o.value}\"\n   \n   # No requests are sent to data memory.\n   assert dut.dmem_req_o.value == 0, f\"\u064fShould be No requests are sent to data memory (dmem_req_o = 0x0). {dut.dmem_req_o.value}\"\n   \n   # No valid data is provided to the writeback stage.\n   assert dut.wb_if_rvalid_o.value == 0, f\"Should be No valid data  provided to the writeback stage (wb_if_rvalid_o = 0x0). {dut.wb_if_rvalid_o.value}\"\n\n   \n   await FallingEdge(dut.clk)\n   \n   execute_if_driver = ExReqDriver(dut,'ex_if',dut.clk,execute_sb_fn)\n   dmem_model = DataMemory()\n   dmemIFDriver(dut,'dmem', dut.clk, dmem_model)\n\n   for i in range(5000):\n      wdata = random.randint(0, 2**32) # 32 bit word data\n      addr_base = random.randint(0,2**6)\n      addr_off = random.randint(0,2**6) # Limiting address space to 7 bit (MemoryModel representation limit)\n      type = random.randint(0,2) # TYPE: can be 0x0, 0x1, 0x2\n      sign_extend = random.randint(0,1)\n      sign_extend = 1\n      Test_Vec = (type, wdata, addr_base, addr_off, sign_extend)\n      # Drive Write operation\n      await execute_if_driver.write_req(Test_Vec)\n      await hrs_lb.check_dmem_req(dut, Test_Vec, 1)\n      \n      # Read the written value\n      await execute_if_driver.read_req(Test_Vec)\n\n      await hrs_lb.check_dmem_req(dut, Test_Vec, 0)\n      await hrs_lb.check_wb_val(dut, dmem_model, Test_Vec)\n\n\n\n    \n\n\n\n", "src/test_runner.py": "import os\nfrom cocotb.runner import get_runner\nimport harness_library as hrs_lb\n\nimport pytest\nimport random\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner():\n    runner = get_runner(\"xcelium\")\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        build_args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\"),\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=False,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n    hrs_lb.coverage_report(\"assertion\")\n    hrs_lb.covt_report_check()\n\ndef test_allocator():\n    runner()\n"}}}
{"id": "cvdp_copilot_mem_allocator_0006", "categories": ["cid014", "medium"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `cvdp_copilot_mem_allocator` module. The assertions should ensure that the module dynamically manages a pool of resources, enabling the acquisition and release of resource slots. The design uses a bitmask (free_slots) to track the availability of resource slots. The module uses the provided cvdp_leading_zero_cnt to track the first available slot (starting from the least significant bit) and provides signals indicating whether the allocator is empty or full.\n\n## **RTL Design Overview**  \n\n### Parameters:\n- `SIZE` (default: 4): Specifies the total number of resource slots managed by the allocator. It must be a positive integer and a multiple of 4.\n-  `ADDRW`: Specifies the bit width of the address required to index all slots. Computed as ceil(log2(SIZE)).\n\n### Inputs:\n   - `clk`: System clock signal. The design is synchronized to the positive edge of this clock\n   - `reset`: Active-high synchronous reset signal.\n   - `acquire_en`: Active-high enable signal for a resource allocation request.\n   - `release_en`: Active-high enable signal for a resource deallocation request.\n   - `release_addr[ADDRW-1:0]`: Address of the slot to be released.\n\n### Outputs:\n   - `acquire_addr[ADDRW-1:0]`: Represents the address of the next available resource slot for allocation. It will be 0 after if the reset is high and index of the least significant free slot after that. The value is invalid (left undefined) when `full` is asserted.\n   - `empty`: High if all slots are free, low otherwise.\n   - `full`: High if no slots are available, low otherwise.\n\n### Behavior\n\n####  `cvdp_leading_zero_cnt` module functionality:\n`cvdp_leading_zero_cnt` module calculates the number of trailing zeros in a given `DATA_WIDTH`-bit input. It computes the total trailing zero count. `all_zeros` is high whenever input data is zero.\n\n#### Reset Behavior\n- On reset, when reset is asserted\n    - All slots are marked as free (free_slots initialized to all 1s).\n    - acquire_addr is set to 0.(indicating first available slot when requested)\n    - empty is set to 1 (all slots are free).\n    - full is set to 0 (slots are not fully occupied).\n\n#### Resource Allocation and Release\n- The first available address, (if all slots are not allocated), is always available on `acquire_addr` output signal. (If all slots are allocated, leave `acquire_addr` undefined)\n- When `acquire_en` is asserted:\n    - The slot specified by `acquire_addr` in `free_slots_n` is cleared **combinationally**.\n- When `release_en` is asserted:\n    - The slot specified by `release_addr` is marked as free in `free_slots_n` **combinationally**.\n- `free_slots_n` is registered on the posedge of `clk` in `free_slots` register **sequentially** to mark the slot as allocated or released.\n- The module **precomputes** the first available slot. Leading zero counter module initialized with correct parameters, **combinationally** updates `free_index` using the updated `free_slots_n`. \n- The `acquire_addr` output is **updated in the next clock cycle**, registering `free_index`, to ensure the address is ready and maintained for the **next acquire request**.\n\n#### Empty and Full Signals\n- `empty` is asserted high when all slots are free. Updated **sequentially** after `release_en` asserted for the last allocated slot.\n- `full` is asserted high when no slots are available for allocation. Updated **sequentially** after an acquire request allocates the last available slot.\n\n### Interface Constraints and Assumptions:\n- The `release_en` signal will only be asserted for addresses that were previously allocated. \n- If the `full` signal is asserted high, indicating no available slots, `acquire_en` will not be asserted.\n\n## Assertion Details\n\n- **Size Alignment:**  \n  Verify that the `SIZE` parameter is a multiple of four.\n\n- **Release Operations:**  \n  - Ensure that a release request does not target an empty slot.\n  - Confirm that after a release request, the `free_slots` array is updated for the given `release_addr`.\n  - Ensure that when `release_en` is asserted, the system is not in an empty state.\n\n- **Acquisition Operations:**  \n  - Verify that when `acquire_en` is asserted, on the following cycle the address stored in `acquire_addr_r` is updated in the `free_slots` array to indicate acquisition.\n  - Ensure that when `acquire_en` is high, the system is not in a full state.\n \n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/cvdp_copilot_mem_allocator.sv": "module cvdp_copilot_mem_allocator #(\n    parameter SIZE  = 4,\n    parameter ADDRW = $clog2(SIZE)\n) (\n    input  wire             clk,\n    input  wire             reset,\n\n    input  wire             acquire_en,    \n    output wire [ADDRW-1:0] acquire_addr,      \n    \n    input  wire             release_en,\n    input  wire [ADDRW-1:0] release_addr,    \n    \n    output wire             empty,\n    output wire             full    \n);\n    reg [SIZE-1:0] free_slots, free_slots_n;\n    reg [ADDRW-1:0] acquire_addr_r;\n    reg empty_r, full_r;    \n    wire [ADDRW-1:0] free_index;\n    wire full_d;\n    \n    /* Leading zero counter instantiation */\n    cvdp_leading_zero_cnt #(\n            .DATA_WIDTH (SIZE),\n            .REVERSE (1)\n        ) free_slots_sel (\n            .data   (free_slots_n),\n            .leading_zeros  (free_index),\n            .all_zeros (full_d)\n        ); \n    \n    always @(*) begin\n        free_slots_n = free_slots;\n        if (release_en) begin\n            free_slots_n[release_addr] = 1;                \n        end\n        if (acquire_en) begin\n            free_slots_n[acquire_addr_r] = 0;\n        end            \n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            acquire_addr_r <= 0;\n            free_slots     <= {SIZE{1'b1}};\n            empty_r        <= 1'b1;\n            full_r         <= 1'b0;            \n        end else begin\n            acquire_addr_r  <= free_index;\n            free_slots      <= free_slots_n;           \n            empty_r         <= (& free_slots_n);\n            full_r          <= full_d;\n        end        \n    end\n        \n    assign acquire_addr = acquire_addr_r;\n    assign empty        = empty_r;\n    assign full         = full_r;\n    \nendmodule\n\nmodule cvdp_leading_zero_cnt #(\n    parameter DATA_WIDTH = 32,\n    parameter REVERSE = 0 \n)(\n    input  [DATA_WIDTH -1:0] data,\n    output  [$clog2(DATA_WIDTH)-1:0] leading_zeros,\n    output all_zeros \n);\n    localparam NIBBLES_NUM = DATA_WIDTH/4 ; \n    reg [NIBBLES_NUM-1 :0] all_zeros_flag ;\n    reg [1:0]  zeros_cnt_per_nibble [NIBBLES_NUM-1 :0]  ;\n\n    genvar i;\n    integer k ;\n    // Assign data/nibble \n    reg [3:0]  data_per_nibble [NIBBLES_NUM-1 :0]  ;\n    generate\n        for (i=0; i < NIBBLES_NUM ; i=i+1) begin\n            always @* begin\n                data_per_nibble[i] = data[(i*4)+3: (i*4)] ;\n            end\n        end\n    endgenerate\n   \n    generate\n        for (i=0; i < NIBBLES_NUM ; i=i+1) begin\n            if (REVERSE) begin\n                always @* begin\n                        zeros_cnt_per_nibble[i] [1] = ~(data_per_nibble[i][1] | data_per_nibble[i][0]); \n                        zeros_cnt_per_nibble[i] [0] = (~data_per_nibble[i][0]) &\n                                                      ((~data_per_nibble[i][2]) | data_per_nibble[i][1]);\n                        all_zeros_flag[i] = (data_per_nibble[i] == 4'b0000);\n                end\n            end else begin\n                always @* begin\n                    zeros_cnt_per_nibble[NIBBLES_NUM-1-i][1] = ~(data_per_nibble[i][3] | data_per_nibble[i][2]); \n                    zeros_cnt_per_nibble[NIBBLES_NUM-1-i][0] = (~data_per_nibble[i][3]) &\n                                     ((~data_per_nibble[i][1]) | data_per_nibble[i][2]);\n                    \n                    all_zeros_flag[NIBBLES_NUM-1-i] = (data_per_nibble[i] == 4'b0000);\n                end\n            end\n        end\n    endgenerate\n\n    \n    \n    reg [$clog2(NIBBLES_NUM)-1:0] index ; \n    reg [1:0]    choosen_nibbles_zeros_count ;\n    reg [ $clog2(NIBBLES_NUM*4)-1:0] zeros_count_result ;\n    wire [NIBBLES_NUM-1:0]         all_zeros_flag_decoded;\n    \n    assign all_zeros_flag_decoded[0] = all_zeros_flag[0] ;\n    genvar j;\n        generate\n            for (j=1; j < NIBBLES_NUM; j=j+1) begin\n                assign all_zeros_flag_decoded[j] = all_zeros_flag_decoded[j-1] & all_zeros_flag[j];\n            end\n        endgenerate\n\n    always@ * begin\n        index = 0 ;\n        for ( k =0 ; k< NIBBLES_NUM ; k =k +1) begin\n            index = index + all_zeros_flag_decoded[k] ;\n        end\n    end\n    \n    always@* begin\n        choosen_nibbles_zeros_count = zeros_cnt_per_nibble[index]  ;  \n        zeros_count_result = choosen_nibbles_zeros_count + (index <<2) ; \n    end\n    \n    assign leading_zeros =  zeros_count_result ;\n    assign all_zeros = (data ==0) ;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/cvdp_copilot_mem_allocator.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb aes", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nSIM             = icarus\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cvdp_copilot_mem_allocator.sv\nTOPLEVEL        = cvdp_copilot_mem_allocator\nMODULE          = test_cvdp_copilot_mem_allocator\nPYTHONPATH      = /src\nHASH            = \"feature/assertions\"\n", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport os\nimport subprocess\nimport re\n\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def reset_dut(reset, duration_ns = 10):\n    # Restart Interface\n    reset.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    reset.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    reset.value = 0\n    await Timer(duration_ns, units='ns')\n    reset._log.debug(\"Reset complete\")\n\n\n    \n#################    ASSERTIONS STUFF        ###############\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n", "src/test_cvdp_copilot_mem_allocator.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport time\nimport harness_library as hrs_lb\n\n\n\n@cocotb.test()\nasync def test_cvdp_copilot_mem_allocator(dut): \n   # Start clock\n   dut_clock_period = 10 \n   print(f\"Clk period is {dut_clock_period}\")\n   DUT_CLK = Clock(dut.clk, dut_clock_period, 'ns')\n   await cocotb.start(DUT_CLK.start())\n   dut.clk._log.info(f\"clk STARTED\")\n\n   await hrs_lb.dut_init(dut)\n\n   # Apply reset \n   await hrs_lb.reset_dut(dut.reset, dut_clock_period)\n\n   for i in range(2):\n      await RisingEdge(dut.clk)\n\n   # Ensure  outputs reset value \n   assert dut.acquire_addr.value == 0, f\"acquire_addr is not zero after reset: {dut.acquire_addr.value}\"\n   assert dut.empty.value == 1, f\"\u064fempty should be asserted: {dut.empty.value}\"\n   assert dut.full.value == 0, f\"full should be low: {dut.full.value}\"\n\n   # Get parameter values from top module\n   SIZE = int(dut.SIZE.value)\n   #ADDRW = int(dut.ADDRW.value)\n\n   #1. Testing Sequential Full condition: Setting acquire request for SIZE cycles After reset (empty) should result in Full assertion\n   await FallingEdge(dut.clk)\n   dut.acquire_en.value = 1\n   cycles_to_full = 0\n   while (dut.full.value != 1):\n      await RisingEdge(dut.clk)\n      cycles_to_full = cycles_to_full + 1\n      await FallingEdge(dut.clk)\n   dut.acquire_en.value = 0\n   assert cycles_to_full == SIZE, f\"full should be asserted. Asserted after: {cycles_to_full}, Expected: {SIZE}\"\n\n   await hrs_lb.reset_dut(dut.reset, dut_clock_period)  \n\n   #2. Randomly verify Allocation address/Dellocation\n   mask_list = [0 for _ in range(SIZE)]  # Keep track of allocated slots\n   addr_list = []  # Store allocated addresses for potential deallocation\n   allocate_index = 0 # First address available for allocation is 0x0\n   await FallingEdge(dut.clk)\n   \n   actions = [0, 1, 2]  # 0: No action, 1: Allocate, 2: Deallocate\n   \n   weights = [1, 3, 1]  # Higher weight for allocation (1: Allocate) #Tends to be full\n   for i in range(5 * SIZE):\n      dut.acquire_en.value = 0\n      dut.release_en.value = 0\n\n      action = random.choices(actions, weights=weights, k=1)[0]\n      #action = random.randint(0, 2)  # 0: No action, 1: Allocate, 2: Deallocate\n      \n      if action == 0:\n         pass\n\n      elif action == 1:  # Allocate\n         if 0 in mask_list: #Empty slot\n            dut.acquire_en.value = 1\n            mask_list[allocate_index] = 1  \n            addr_list.append(allocate_index)\n            # If not, next cycle full will be examined\n            if 0 in mask_list:\n               allocate_index = mask_list.index(0)         \n         else:\n            assert dut.full.value == 1, f\"Full should be asserted when there are no empty slots\"\n\n      elif action == 2:  # Deallocate\n         if addr_list:  # Only attempt deallocation if there are allocated addresses\n            deallocate_index = random.choice(addr_list)  # Randomly choose an allocated address\n            dut.release_en.value = 1\n            dut.release_addr.value = deallocate_index\n            mask_list[deallocate_index] = 0  # Mark the index as free\n            addr_list.remove(deallocate_index)  # Remove from allocated list\n            allocate_index = mask_list.index(0)\n         else:\n            assert dut.empty.value == 1, f\"Empty should be asserted when there are no thing allocated\"\n\n      await RisingEdge(dut.clk)\n      await FallingEdge(dut.clk)\n      # Assert acquire address in case full is deasserted only.\n      if (dut.full.value != 1):\n         assert int(dut.acquire_addr.value) == allocate_index, f\"acquire_addr mismatch Expected: {allocate_index} , dut_output: {int(dut.acquire_addr.value)} \"\n\n   weights = [1, 1, 3]  # Higher weight for deallocation (2: Deallocate) #Tends to be empty\n   for i in range(5 * SIZE):\n      dut.acquire_en.value = 0\n      dut.release_en.value = 0\n\n      action = random.choices(actions, weights=weights, k=1)[0]\n      #action = random.randint(0, 2)  # 0: No action, 1: Allocate, 2: Deallocate\n      \n      if action == 0:\n         pass\n\n      elif action == 1:  # Allocate\n         if 0 in mask_list: #Empty slot\n            dut.acquire_en.value = 1\n            mask_list[allocate_index] = 1  \n            addr_list.append(allocate_index)\n            # If not, next cycle full will be examined\n            if 0 in mask_list:\n               allocate_index = mask_list.index(0)         \n         else:\n            assert dut.full.value == 1, f\"Full should be asserted when there are no empty slots\"\n\n      elif action == 2:  # Deallocate\n         if addr_list:  # Only attempt deallocation if there are allocated addresses\n            deallocate_index = random.choice(addr_list)  # Randomly choose an allocated address\n            dut.release_en.value = 1\n            dut.release_addr.value = deallocate_index\n            mask_list[deallocate_index] = 0  # Mark the index as free\n            addr_list.remove(deallocate_index)  # Remove from allocated list\n            allocate_index = mask_list.index(0)\n         else:\n            assert dut.empty.value == 1, f\"Empty should be asserted when there are no thing allocated\"\n\n      await RisingEdge(dut.clk)\n      await FallingEdge(dut.clk)\n      # Assert acquire address in case full is deasserted only.\n      if (dut.full.value != 1):\n         assert int(dut.acquire_addr.value) == allocate_index, f\"acquire_addr mismatch Expected: {allocate_index} , dut_output: {int(dut.acquire_addr.value)} \"\n\n\n\n\n", "src/test_runner.py": "import os\n\nfrom cocotb.runner import get_runner\n\nimport harness_library as hrs_lb\nimport pytest\nimport random\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\ndef runner(SIZE):\n    print(\"Inside Runner\")\n    print(SIZE)\n    runner = get_runner(\"xcelium\")\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters={'SIZE': SIZE},\n        build_args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\"),\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=False,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\")\n    print(\"Running\")    \n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=True)\n    hrs_lb.coverage_report(\"assertion\")\n    hrs_lb.covt_report_check()\n# random test \ntest_param = [(random.randint(1, 32) * 4) for _ in range(5)]\n\n@pytest.mark.parametrize('SIZE', test_param )\ndef test_allocator(SIZE):\n    print(\"Calling Runner\")\n    runner(SIZE)\n"}}}
{"id": "cvdp_copilot_microcode_sequencer_0026", "categories": ["cid014", "medium"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the microcode sequencer (`microcode_sequencer`) to ensure its correct functionality during simulation? The assertions should cover various key aspects of the microcode sequencer's operations such as preventing push operation when the stack is full, ensuring data output is zero when a soft reset from the `instruction_decoder` submodule is asserted LOGIC HIGH, ensuring output carry of program incrementer is zero irrespective of its input carry, etc. These assertions should fail when any one of the following conditions fails:\n\n1. **stack_push_prevent_full** :\n      - Ensures that a push operation of the `lifo_stack` submodule is not attempted when the stack is full.\n2. **reset_data_output_to_zero**:\n      - Verifies that the data output (`d_out`) is reset to 4'b0000 when the reset signal (`rst_w`) from the `instruction_decoder` submodule is asserted LOGIC HIGH.\n3. **carry_out_zero_when_input_zero** :\n      - Checks that the `c_inc_out`  of the `program_counter` submodule is 0 when its `c_inc_in` is 0 or 1.\n4. **output_enable_zero_when_cc_zero** :\n      - Ensures the output enable signal of the  (`out_ce_w`) `result_register` submodule is 0 when the condition code (`cc`) is 0.\n5. **stack_mux_select_for_instr_01110** :\n      - Verifies that `stack_mux_sel_w` of the `stack_pointer` submodule is set to 1 when `ien` is 0 and `instr_in` is `5'b01110`.\n6. **a_mux_select_for_instr_opcodes** :\n      - Validates that `a_mux_sel_w` of `microcode_arithmetic` submodule is set to 2'b10 when `ien` is 0 and` instr_in` matches one of the specified opcodes(`instr_in == 5'b01110` || `instr_in == 5'b01011` || `instr_in == 5'b00001` || `instr_in == 5'b00000`).\n7. **auxiliary_register_mux_select_zero_when_cc_zero**:\n      - Ensures that the `rsel_w` of the `microcode_arithmetic` submodule is 0 when condition code (`cc`) is 0.\n8. **b_mux_select_for_instr_opcodes**:\n      - Verifies that `b_mux_sel_w`  of `microcode_arithmetic` submodule is set to 2'b10 when `ien` is 0 and `instr_in` matches one of the specified opcodes(`instr_in == 5'b00000` || `instr_in == 5'b00010` || `instr_in == 5'b00011`).\n9. **valid_aux_register_chip_enable**:\n     - Ensures that the auxiliary register chip enable (`rce_w`)  of the `microcode_arithmetic` submodule is either 0 or 1.\n10. **valid_stack_write_enable**:\n     - Verifies that the stack write enable signal (`stack_we_w`) of the `lifo_stack` submodule is either 0 or 1.\n\nFollowing should be the interface of the RTL design of the microcode_sequencer module named `microcode_sequencer`.\n## Interface:\n### Inputs:\n- `clk`(1-bit): The positive edge-triggered clock signal required for the sequential components.\n- `c_n_in`(1-bit): Carry-in signal for the ripple carry adder.\n- `c_inc_in`(1-bit): Carry-in for the program counter incrementer.\n- `r_en`(1-bit): ACTIVE LOW auxiliary register enable signal.\n- `cc`(1-bit): ACTIVE LOW condition code input for instruction decoding.\n- `ien`(1-bit): ACTIVE LOW instruction enable signal.\n- `d_in`(4-bit , [3:0]): A 4-bit data input bus.\n- `instr_in`(5-bit, [4:0]): A 5-bit opcode representing the instruction.\n- `oen`(1-bit): ACTIVE LOW output enable for the data output path.\n\n### Outputs:\n- `d_out`(4-bit,[3:0]): A 4-bit address output bus.\n- `c_n_out`(1-bit): Carry-out signal from the ripple carry adder. LOGIC HIGH in this signal indicates the presence of carry.\n- `c_inc_out`(1-bit): Carry-out signal from the program counter incremented. LOGIC HIGH in this signal indicates the presence of carry.\n- `full`(1-bit): ACTIVE HIGH signal indicates if the Last In First Out (LIFO) stack is full.\n- `empty`(1-bit): ACTIVE HIGH signal indicates if the LIFO stack is empty.", "context": {"rtl/microcode_sequencer.sv": "module microcode_sequencer (\n   // Inputs\n   input logic clk, // Input Clock\n   input logic c_n_in,  // Input Carry for Ripple Carry Adder\n   input logic c_inc_in, // Input Carry for Program Counter Incrementer\n   input logic r_en, // Auxiliary Register enable\n   input logic cc, // Condition Code\n   input logic ien, // Instruction Enable\n   input logic [3:0] d_in, // Data Input\n   input logic [4:0] instr_in, // 5-bit Instruction Opcode\n   input logic oen, // Output Enable\n\n   // Outputs\n   output logic [3:0] d_out, // Data Output\n   output logic c_n_out , // Output Carry from Ripple Carry Adder\n   output logic c_inc_out, // Output Carry from Program Counter Incrementer\n   output logic full, // Stack Full Condition\n   output logic empty // Stack Empty Condition\n   \n );\n\n \n logic [3:0] pc_data_w;\n logic stack_reset_w;\n logic [3:0] stack_data_w;\n logic [3:0] fa_out_w;\n logic [3:0] data_out_w;\n  \n logic rsel_w;\n logic rce_w;\n logic [1:0] a_mux_sel_w;\n logic [1:0] b_mux_sel_w;\n logic cen_w;\n logic rst_w;\n logic push_w;\n logic pop_w;\n logic stack_push_w;\n logic stack_pop_w;\n logic pc_mux_sel_w;\n logic stack_mux_sel_w;\n logic stack_we_w;\n logic stack_re_w;\n logic inc_w;\n logic oen_w;\n logic out_en_w;\n \n lifo_stack dut_1 (\n    .clk              (clk),\n    .stack_data_1_in  (d_in),\n    .stack_data_2_in  (pc_data_w),\n    .stack_reset      (rst_w),\n    .stack_push       (stack_push_w),\n    .stack_pop        (stack_pop_w),\n    .stack_mux_sel    (stack_mux_sel_w),\n    .stack_we         (stack_we_w),\n    .stack_re         (stack_re_w),\n    .stack_data_out   (stack_data_w),\n    .full_o           (full),\n    .empty_o          (empty)\n );\n\n program_counter dut_2 (\n    .clk               (clk),\n    .full_adder_data_i (fa_out_w),\n    .pc_c_in           (c_inc_in),\n    .inc               (inc_w),\n    .pc_mux_sel        (pc_mux_sel_w),\n    .pc_out            (pc_data_w),\n    .pc_c_out          (c_inc_out)\n );\n \n microcode_arithmetic dut_3(\n    .clk              (clk),\n    .fa_in            (data_out_w),\n    .d_in             (d_in),\n    .stack_data_in    (stack_data_w),\n    .pc_data_in       (pc_data_w),\n    .reg_en           (r_en),\n    .oen              (oen_w),\n    .rsel             (rsel_w),\n    .rce              (rce_w),\n    .cen              (cen_w),\n    .a_mux_sel        (a_mux_sel_w),\n    .b_mux_sel        (b_mux_sel_w),\n    .arith_cin        (c_n_in),\n    .arith_cout       (c_n_out),\n    .oe               (oen),\n    .d_out            (fa_out_w)\n );\n \n instruction_decoder dut_4 (\n    .instr_in         (instr_in),\n    .cc_in            (cc),\n    .instr_en         (ien),\n    .cen              (cen_w), \n    .rst              (rst_w), \n    .oen              (oen_w), \n    .inc              (inc_w), \n    .rsel             (rsel_w), \n    .rce              (rce_w),  \n    .pc_mux_sel       (pc_mux_sel_w), \n    .a_mux_sel        (a_mux_sel_w), \n    .b_mux_sel        (b_mux_sel_w), \n    .push             (stack_push_w),\n    .pop              (stack_pop_w), \n    .src_sel          (stack_mux_sel_w),\n    .stack_we         (stack_we_w),\n    .stack_re         (stack_re_w),\n    .out_ce           (out_ce_w)\n);\n\n result_register dut_5 (\n   .clk     (clk),\n   .data_in (fa_out_w),\n   .out_ce  (out_ce_w),\n   .data_out(data_out_w)\n );\nassign d_out = fa_out_w;\nendmodule\n \nmodule stack_pointer (\n  input logic clk,\n  input logic rst,\n  input logic push,\n  input logic pop,\n  output logic [4:0] stack_addr,\n  output logic full,\n  output logic empty\n);\nlogic full_r;\nlogic empty_r;\nassign full_r     = (stack_addr == 5'd16);\nassign empty_r    = (stack_addr == 5'd0);\nalways_ff@(posedge clk) begin\n   if(rst)\n     stack_addr <= 5'd0;\n   else if(push && !full_r)\n     stack_addr  <= stack_addr + 5'd1;\n   else if(pop && !empty_r)\n     stack_addr  <= stack_addr - 5'd1;\n   else\n     stack_addr  <= stack_addr + 5'd0;\nend\nassign full       = full_r;\nassign empty      = empty_r;\nendmodule\n\nmodule stack_ram (\n  input logic clk,\n  input logic  [4:0] stack_addr,\n  input logic  [3:0] stack_data_in,\n  input logic  stack_we,\n  input logic  stack_re,\n  output logic [3:0] stack_data_out\n);\n\nlogic [3:0] stack_arr [16:0];\nalways_ff@(posedge clk) begin\n  if(stack_we)\n    stack_arr[stack_addr] <= stack_data_in;\nend\n\nalways_ff @(posedge clk) begin\n    if (stack_re)\n      stack_data_out <= stack_arr[stack_addr];\nend\nendmodule\n\nmodule stack_data_mux (\n  input  logic [3:0] data_in,\n  input  logic [3:0] pc_in,\n  input  logic stack_mux_sel,\n  output logic [3:0] stack_mux_out\n);\nassign stack_mux_out = (stack_mux_sel & data_in) | (~stack_mux_sel & pc_in);\nendmodule\n\nmodule lifo_stack (\n  input  logic clk,\n  input  logic [3:0] stack_data_1_in,\n  input  logic [3:0] stack_data_2_in,\n  input  logic stack_reset,\n  input  logic stack_push,\n  input  logic stack_pop,\n  input  logic stack_mux_sel,\n  input  logic stack_we,\n  input  logic stack_re,\n  output logic [3:0] stack_data_out,\n  output logic full_o,\n  output logic empty_o\n);\n\nlogic [3:0] stack_data_in_w;\nlogic [4:0] stack_addr_w;\n\nstack_data_mux dut_1(\n    .data_in       (stack_data_1_in),\n    .pc_in         (stack_data_2_in),\n    .stack_mux_sel (stack_mux_sel),\n    .stack_mux_out (stack_data_in_w)\n);\n\nstack_pointer dut_2 (\n     .clk        (clk),\n     .rst        (stack_reset),\n     .push       (stack_push),\n     .pop        (stack_pop),\n     .stack_addr (stack_addr_w),\n     .full       (full_o),\n     .empty      (empty_o)\n);\n\nstack_ram dut_3 (\n     .clk            (clk),\n     .stack_addr     (stack_addr_w),\n     .stack_data_in  (stack_data_in_w),\n     .stack_we       (stack_we),\n     .stack_re       (stack_re),\n     .stack_data_out (stack_data_out)\n);\nendmodule\n\nmodule pc_mux (\n    input logic [3:0] full_adder_data,\n    input logic [3:0] pc_data,\n    input logic pc_mux_sel,\n    output logic [3:0] pc_mux_out\n);\nassign pc_mux_out = pc_mux_sel ? full_adder_data : pc_data;\nendmodule\n\nmodule pc_incrementer (\n  input logic pc_c_in,\n  input logic inc,\n  input logic [3:0] pc_data_in,\n  output logic [3:0] pc_inc_out,\n  output logic pc_c_out\n);\nassign {pc_c_out , pc_inc_out} = pc_data_in + (inc ? pc_c_in : 1'b0); \nendmodule\n\nmodule pc_reg (\n input logic clk,\n input logic[3:0] pc_data_in,\n output logic [3:0] pc_data_out\n);\nalways_ff@(posedge clk) begin\n   pc_data_out <= pc_data_in;\nend\nendmodule\n\nmodule program_counter(\n  input logic clk,\n  input logic [3:0] full_adder_data_i,\n  input logic pc_c_in,\n  input logic inc,\n  input logic pc_mux_sel,\n  output logic [3:0] pc_out,\n  output logic pc_c_out\n);\n \n logic [3:0] pc_out_w;\n logic [3:0] pc_mux_out_w;\n logic [3:0] pc_inc_out_w;\n logic pc_c_out_w;\npc_mux dut_1 (\n   .full_adder_data(full_adder_data_i),\n   .pc_data(pc_out_w),\n   .pc_mux_sel(pc_mux_sel),\n   .pc_mux_out(pc_mux_out_w)\n);\n\npc_incrementer dut_2 (\n  .pc_c_in(pc_c_in),\n  .inc(inc),\n  .pc_data_in(pc_mux_out_w),\n  .pc_inc_out(pc_inc_out_w),\n  .pc_c_out(pc_c_out_w)\n);\n\npc_reg dut_3 (\n   .clk(clk),\n   .pc_data_in(pc_inc_out_w),\n   .pc_data_out(pc_out_w)\n);\n\nassign pc_out = pc_out_w;\nassign pc_c_out = pc_c_out_w;\nendmodule\n\nmodule instruction_decoder(\n    input logic [4:0] instr_in,\n    input logic cc_in,\n    input logic instr_en,\n    output logic cen, \n    output logic rst, \n    output logic oen, \n    output logic inc, \n    output logic rsel, \n    output logic rce,  \n    output logic pc_mux_sel, \n    output logic [1:0] a_mux_sel, \n    output logic [1:0] b_mux_sel, \n    output logic push,\n    output logic pop, \n    output logic src_sel,\n    output logic stack_we,\n    output logic stack_re,\n    output logic out_ce\n );\n\n always_comb begin\n    casex({instr_in,cc_in,instr_en})\n       7'bxxxxxx1 : begin\n                      cen        = 1'b1;\n                      rst        = 1'b0;\n                      oen        = 1'b1;\n                      inc        = 1'b0;\n                      rsel       = 1'b0;\n                      rce        = 1'b0;\n                      a_mux_sel  = 2'b10;\n                      b_mux_sel  = 2'b10;\n                      pc_mux_sel = 1'b1;\n                      push       = 1'b0;\n                      pop        = 1'b0;\n                      src_sel    = 1'b0;\n                      stack_we   = 1'b0;\n                      stack_re   = 1'b0;\n                      out_ce     = 1'b0;\n                    end\n      7'b00000x0 : begin \n                      cen        = 1'b1; \n                      rst        = 1'b1; \n                      oen        = 1'b1;  \n                      inc        = 1'b1; \n                      rsel       = 1'b0; \n                      rce        = 1'b1; \n                      a_mux_sel  = 2'b10;  \n                      b_mux_sel  = 2'b10; \n                      pc_mux_sel = 1'b1; \n                      push       = 1'b0;\n                      pop        = 1'b0;\n                      src_sel    = 1'b0; \n                      stack_we   = 1'b0;\n                      stack_re   = 1'b0;\n                      out_ce     = 1'b0;\n                   end\n      7'b00001x0 : begin \n                     cen         = 1'b0; \n                     rst         = 1'b0; \n                     oen         = 1'b1; \n                     inc         = 1'b1; \n                     rsel        = 1'b0; \n                     rce         = 1'b0; \n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00; \n                     pc_mux_sel  = 1'b0; \n                     push        = 1'b0;\n                     pop         = 1'b0;\n                     src_sel     = 1'b0;\n                     stack_we    = 1'b0;\n                     stack_re    = 1'b0;\n                     out_ce      = 1'b0;\n                   end\n      7'b00010x0 : begin \n                     cen         = 1'b0; \n                     rst         = 1'b0; \n                     oen         = 1'b1; \n                     inc         = 1'b1; \n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     a_mux_sel   = 2'b01; \n                     b_mux_sel   = 2'b10; \n                     pc_mux_sel  = 1'b0; \n                     push        = 1'b0;\n                     pop         = 1'b0;\n                     src_sel     = 1'b0;\n                     stack_we    = 1'b0;\n                     stack_re    = 1'b0;\n                     out_ce      = 1'b0;\n                   end\n      7'b00011x0 : begin \n                     cen         = 1'b0; \n                     rst         = 1'b0; \n                     oen         = 1'b1; \n                     inc         = 1'b1; \n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     a_mux_sel   = 2'b00; \n                     b_mux_sel   = 2'b10; \n                     pc_mux_sel  = 1'b0; \n                     push        = 1'b0;\n                     pop         = 1'b0;\n                     src_sel     = 1'b0;\n                     stack_we    = 1'b0;\n                     stack_re    = 1'b0;\n                     out_ce      = 1'b0;\n                  end\n     7'b00100x0 : begin \n                     cen         = 1'b1; \n                     rst         = 1'b0; \n                     oen         = 1'b1; \n                     inc         = 1'b1; \n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     a_mux_sel   = 2'b00; \n                     b_mux_sel   = 2'b11; \n                     pc_mux_sel  = 1'b0;  \n                     push        = 1'b0;\n                     pop         = 1'b0;\n                     src_sel     = 1'b0;\n                     stack_we    = 1'b0;\n                     stack_re    = 1'b0;\n                     out_ce      = 1'b0;\n                  end\n     7'b01011x0 : begin \n                     cen         = 1'b0; \n                     rst         = 1'b0; \n                     oen         = 1'b1; \n                     inc         = 1'b1; \n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00; \n                     pc_mux_sel  = 1'b0; \n                     push        = 1'b1; \n                     pop         = 1'b0; \n                     src_sel     = 1'b0; \n                     stack_we    = 1'b1;\n                     stack_re    = 1'b0;\n                     out_ce      = 1'b0;\n                  end\n     7'b01110x0 : begin \n                     cen         = 1'b0; \n                     rst         = 1'b0; \n                     oen         = 1'b1; \n                     inc         = 1'b0; \n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     a_mux_sel   = 2'b10;\n                     b_mux_sel   = 2'b01; \n                     pc_mux_sel  = 1'b0; \n                     push        = 1'b0; \n                     pop         = 1'b1; \n                     src_sel     = 1'b1; \n                     stack_we    = 1'b0;\n                     stack_re    = 1'b1;\n                     out_ce      = 1'b0;\n                  end\n                      \n      default   : begin\n                     cen         = 1'b1; \n                     rst         = 1'b0; \n                     oen         = 1'b0; \n                     inc         = 1'b0; \n                     rsel        = 1'b0; \n                     rce         = 1'b0; \n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b10; \n                     pc_mux_sel  = 1'b0; \n                     push        = 1'b0; \n                     pop         = 1'b0; \n                     src_sel     = 1'b1; \n                     stack_we    = 1'b0;\n                     stack_re    = 1'b0;\n                     out_ce      = 1'b0;\n                   end \n                    \n      endcase\n  end\nendmodule\n\n\n\nmodule full_adder (\n    input logic [3:0] a_in,\n    input logic [3:0] b_in,\n    input logic cen,\n    input logic c_in,\n    output logic [3:0] y_out,\n    output logic c_out\n    \n);\nassign {c_out,y_out} = a_in + b_in + (cen ? c_in : 1'b0);\nendmodule\n\n\nmodule aux_reg_mux (\n  input logic [3:0] reg1_in, \n  input logic [3:0] reg2_in, \n  input logic rsel,\n  input logic re,\n  output logic [3:0] reg_mux_out\n);\n\nassign reg_mux_out = (~re & rsel) ? reg1_in : reg2_in;\nendmodule\n\nmodule aux_reg (\n    input logic clk,\n    input logic [3:0] reg_in,\n    input logic rce,\n    input logic re,\n    output logic [3:0] reg_out\n);\n always_ff@(posedge clk) begin\n   if(rce | ~re) \n    reg_out <= reg_in;\n end\nendmodule\n\nmodule a_mux (\n  input logic [3:0] register_data,\n  input logic [3:0] data_in,\n  input logic [1:0] a_mux_sel,\n  output logic [3:0] a_mux_out\n);\nalways@(*) begin\n  case(a_mux_sel) \n      2'b00 : a_mux_out = data_in;\n      2'b01 : a_mux_out = register_data;\n      2'b10 : a_mux_out = 4'b0000;\n      default : a_mux_out = 4'b0000;\n  endcase\nend\nendmodule\n\nmodule b_mux (\n  input logic [3:0] register_data,\n  input logic [3:0] stack_data,\n  input logic [3:0] pc_data,\n  input logic [1:0] b_mux_sel,\n  output logic [3:0] b_mux_out\n);\n\nalways@(*) begin\n    case(b_mux_sel)\n      2'b00 : b_mux_out = pc_data;\n      2'b01 : b_mux_out = stack_data;\n      2'b10 : b_mux_out = 4'b0000;\n      2'b11 : b_mux_out = register_data;\n      default : ;\n    endcase\nend\nendmodule\n\nmodule microcode_arithmetic ( \n  input  logic clk,\n  input  logic [3:0] fa_in,\n  input  logic [3:0] d_in,\n  input  logic [3:0] stack_data_in,\n  input  logic [3:0] pc_data_in,\n  input  logic       reg_en,\n  input  logic       oen,\n  input  logic       rsel,\n  input  logic       rce,\n  input  logic       cen,\n  input  logic [1:0] a_mux_sel,\n  input  logic [1:0] b_mux_sel,\n  input  logic       arith_cin,\n  output logic       arith_cout,\n  input  logic       oe,\n  output logic [3:0] d_out\n);\n\nlogic [3:0] fa_out_w;\nlogic [3:0] reg_mux_out_w;\nlogic [3:0] reg_out_w;\nlogic [3:0] a_mux_out_w;\nlogic [3:0] b_mux_out_w;\n\n\naux_reg_mux dut_1 (\n  .reg1_in     (fa_in),\n  .reg2_in     (d_in),\n  .rsel        (rsel),\n  .re          (reg_en),\n  .reg_mux_out (reg_mux_out_w)\n);\n\naux_reg dut_2 (\n    .clk     (clk),\n    .reg_in  (reg_mux_out_w),\n    .rce     (rce),\n    .re      (reg_en),\n    .reg_out (reg_out_w)\n);\n\na_mux dut_3(\n  .register_data(reg_out_w),\n  .data_in      (d_in),\n  .a_mux_sel    (a_mux_sel),\n  .a_mux_out    (a_mux_out_w)\n);\n\nb_mux dut_4(\n  .register_data  (reg_out_w),\n  .stack_data     (stack_data_in),\n  .pc_data        (pc_data_in),\n  .b_mux_sel      (b_mux_sel),\n  .b_mux_out      (b_mux_out_w)\n);\n\nfull_adder dut_5 (\n  .a_in  (a_mux_out_w),\n  .b_in  (b_mux_out_w),\n  .cen   (cen),\n  .c_in  (arith_cin),\n  .y_out (fa_out_w),\n  .c_out (arith_cout)\n);\nassign d_out = oen & ~oe ? fa_out_w : 4'b0000;\nendmodule\n \nmodule result_register (\n  input  logic clk,\n  input  logic [3:0] data_in,\n  input  logic out_ce,\n  output logic [3:0] data_out\n);\nalways_ff@(posedge clk) begin\n   if(out_ce)\n     data_out <= data_in;\n   else\n     data_out <= data_out;\nend\nendmodule    "}}, "output": {"response": "", "context": {"rtl/microcode_sequencer.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/microcode_sequencer.sv\nTOPLEVEL        = microcode_sequencer\nMODULE          = test_microcode_sequencer\nPYTHONPATH      = /src\nHASH            = 26-microcode_sequencer_tb_assertion_generation\n", "src/test_microcode_sequencer.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge , Timer\nimport random\n\n\n@cocotb.test()\nasync def test_microcode_sequencer(dut):\n    \"\"\"Testbench for microcode_sequencer\"\"\"\n\n    # Create a clock with a period of 20 ns (50 MHz)\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Initialize all inputs\n    dut.instr_in.value = 0\n    dut.c_n_in.value = 0\n    dut.c_inc_in.value = 0\n    dut.r_en.value = 0\n    dut.cc.value = 0\n    dut.ien.value = 0\n    dut.d_in.value = 0\n    dut.oen.value = 0\n\n    # Reset DUT\n    dut._log.info(\"Resetting DUT...\")\n    await Timer(3, units=\"ns\")  # Wait for reset to propagate\n    dut._log.info(\"Reset complete.\")\n\n    # Allow signals to settle\n    await Timer(20, units=\"ns\")\n\n    # Utility function to safely read signal values\n    def safe_read(signal):\n        \"\"\"Safely read a signal, handling unknown ('X') values.\"\"\"\n        try:\n            return int(signal.value)\n        except ValueError:\n            dut._log.warning(f\"Signal {signal._name} has an unknown value ('X'). Defaulting to 0.\")\n            return 0\n\n    @cocotb.test()\n    async def test_push_pc_instruction(dut):\n        \"\"\"Testbench for Push PC Instruction\"\"\"\n        dut._log.info(f\"Push_PC_instruction\")\n        # Start a clock with a period of 20 ns\n        cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n        # Initialize inputs\n        dut.instr_in.value = 0\n        dut.c_n_in.value = 0\n        dut.c_inc_in.value = 0\n        dut.r_en.value = 0\n        dut.cc.value = 0\n        dut.ien.value = 0\n        dut.d_in.value = 0\n        dut.oen.value = 0\n\n        # Reset DUT\n        await Timer(9, units=\"ns\")\n\n        # Apply Push PC Instruction inputs\n        dut.instr_in.value = 0b01011\n        dut.c_n_in.value = 0\n        dut.c_inc_in.value = 0\n        dut.r_en.value = 0\n        dut.cc.value = 0\n        dut.ien.value = 0\n        dut.d_in.value = 0\n        dut.oen.value = 0\n\n        # Wait for the DUT to process the inputs\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        \n        # Assertions\n        expected_d_out = 0b01000  # Update based on expected PC value\n        actual_d_out = safe_read(dut.d_out)\n        assert actual_d_out == expected_d_out, f\"Push PC Instruction failed: Expected {expected_d_out}, got {actual_d_out}\"\n\n        dut._log.info(\"Push PC Instruction test passed.\")\n    \n    @cocotb.test()\n    async def test_pop_pc_instruction(dut):\n        \"\"\"Testbench for Pop PC Instruction\"\"\"\n        dut._log.info(f\"Pop_PC_instruction\")\n        # Start a clock with a period of 20 ns\n        cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n        # Initialize inputs\n        dut.instr_in.value = 0\n        dut.c_n_in.value = 0\n        dut.c_inc_in.value = 0\n        dut.r_en.value = 0\n        dut.cc.value = 0\n        dut.ien.value = 0\n        dut.d_in.value = 0\n        dut.oen.value = 0\n\n        # Reset DUT\n        await Timer(15, units=\"ns\")\n\n        # Apply Pop PC Instruction inputs\n        dut.instr_in.value = 0b01110\n        dut.c_n_in.value = 0\n        dut.c_inc_in.value = 0\n        dut.r_en.value = 0\n        dut.cc.value = 0\n        dut.ien.value = 0\n        dut.d_in.value = 0\n        dut.oen.value = 0\n\n        # Wait for the DUT to process the inputs\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        \n        # Assertions\n        expected_d_out = 0b01000  # Update based on expected PC value\n        actual_d_out = safe_read(dut.d_out)\n        assert actual_d_out == expected_d_out, f\"Push PC Instruction failed: Expected {expected_d_out}, got {actual_d_out}\"\n\n        dut._log.info(\"Pop PC Instruction test passed.\")\n\n    # Test Task equivalent\n    async def run_test_case(\n        test_instr,          # Instruction input\n        test_carry_in,       # Carry input\n        test_carry_inc,      # Carry increment input\n        test_reg_en,         # Register enable\n        test_cond_code,      # Condition code\n        test_instr_en,       # Instruction enable\n        test_data_in,        # Data input\n        test_output_en,      # Output enable\n        expected_d_out,      # Expected data output\n        expected_c_n_out,    # Expected carry out (full adder)\n        expected_c_inc_out,  # Expected carry increment out\n        expected_full,       # Expected full condition\n        expected_empty,      # Expected empty condition\n        case_name            # Name of the test case\n    ):\n        # Apply inputs\n        dut.instr_in.value = test_instr\n        dut.c_n_in.value = test_carry_in\n        dut.c_inc_in.value = test_carry_inc\n        dut.r_en.value = test_reg_en\n        dut.cc.value = test_cond_code\n        dut.ien.value = test_instr_en\n        dut.d_in.value = test_data_in\n        dut.oen.value = test_output_en\n\n        # Wait for two clock cycles to allow the DUT to settle\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n\n        # Log inputs, internal signals, and outputs\n        dut._log.info(f\"Running test case: {case_name}\")\n        dut._log.info(f\"Inputs: instr_in = {int(dut.instr_in.value)}, c_n_in = {dut.c_n_in.value}, \"\n                      f\"c_inc_in = {dut.c_inc_in.value}, r_en = {dut.r_en.value}, cc = {dut.cc.value}, \"\n                      f\"ien = {dut.ien.value}, d_in = {int(dut.d_in.value)}, oen = {dut.oen.value}\")\n        dut._log.info(f\"Expected: d_out = {expected_d_out}, c_n_out = {expected_c_n_out}, \"\n                      f\"c_inc_out = {expected_c_inc_out}, full = {expected_full}, empty = {expected_empty}\")\n        dut._log.info(f\"Actual: d_out = {int(dut.d_out.value)}, c_n_out = {dut.c_n_out.value}, \"\n                      f\"c_inc_out = {dut.c_inc_out.value}, full = {dut.full.value}, empty = {dut.empty.value}\")\n\n        # Assertions\n        assert int(dut.d_out.value) == expected_d_out, f\"{case_name} - d_out mismatch\"\n        assert dut.c_n_out.value == expected_c_n_out, f\"{case_name} - c_n_out mismatch\"\n        assert dut.c_inc_out.value == expected_c_inc_out, f\"{case_name} - c_inc_out mismatch\"\n        assert dut.full.value == expected_full, f\"{case_name} - full mismatch\"\n        assert dut.empty.value == expected_empty, f\"{case_name} - empty mismatch\"\n\n    # Run fixed test cases\n    await run_test_case(0b00000, 0, 0, 0, 0, 0, 0b0000, 0, 0b0000, 0, 0, 0, 1, \"Reset Instruction\")\n    await run_test_case(0b00001, 0, 1, 0, 0, 0, 0b0000, 0, 0b0001, 0, 0, 0, 1, \"Fetch PC Instruction 1\")\n    await run_test_case(0b00001, 0, 0, 0, 0, 0, 0b0000, 0, 0b0010, 0, 0, 0, 1, \"Fetch PC Instruction 2\")\n    await run_test_case(0b00010, 0, 1, 0, 0, 0, 0b1010, 0, 0b1010, 0, 0, 0, 1, \"Fetch R Instruction\")\n    await run_test_case(0b00011, 0, 1, 0, 0, 0, 0b1011, 0, 0b1011, 0, 0, 0, 1, \"Fetch D Instruction\")\n    await run_test_case(0b00100, 1, 1, 0, 0, 0, 0b0011, 0, 0b0111, 0, 0, 0, 1, \"Fetch R+D Instruction\")\n    await test_push_pc_instruction(dut)\n    await test_push_pc_instruction(dut) \n    await test_pop_pc_instruction(dut)\n    await test_pop_pc_instruction(dut)\n\n    # List of all directed test cases with their expected values\n    test_cases = [\n        (0b00000, 0, 0, 0, 0, 0, 0b0000, 0, 0b0000, 0, 0, 0, 1, \"Reset Instruction\"),\n        (0b00001, 0, 1, 0, 0, 0, 0b0000, 0, 0b0001, 0, 0, 0, 1, \"Fetch PC Instruction 1\"),\n        (0b00001, 0, 0, 0, 0, 0, 0b0000, 0, 0b0010, 0, 0, 0, 1, \"Fetch PC Instruction 2\"),\n        (0b00010, 0, 1, 0, 0, 0, 0b1010, 0, 0b1010, 0, 0, 0, 1, \"Fetch R Instruction\"),\n        (0b00011, 0, 1, 0, 0, 0, 0b1011, 0, 0b1011, 0, 0, 0, 1, \"Fetch D Instruction\"),\n        (0b00100, 1, 1, 0, 0, 0, 0b0011, 0, 0b0111, 0, 0, 0, 1, \"Fetch R+D Instruction\"),\n        (0b01011, 0, 0, 0, 0, 0, 0b0000, 0, 0b01000, 0, 0, 0, 1, \"Push PC Instruction\"),\n        (0b01110, 0, 0, 0, 0, 0, 0b0000, 0, 0b01000, 0, 0, 0, 1, \"Pop PC Instruction\")\n    ]\n\n    # Always select \"Reset Instruction\" for the randomized test case\n    for i in range(2):  # Run 2 randomized test cases\n        test_case = test_cases[0]  # Always choose the first test case (Reset Instruction)\n        dut._log.info(f\"Running Randomized Test Case {i+1}: {test_case[13]}\")  # Log which test case is being selected\n        await run_test_case(*test_case)\n\n    dut._log.info(\"All test cases, including randomized tests, completed successfully.\")\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_montgomery_0006", "categories": ["cid014", "medium"], "input": {"prompt": "Add SytemVerilog Assertions (SVA) for the`montgomery_mult` module designed to use the `montgomery_redc` module to compute modular multiplication of unsigned integers without directly performing division operations. The module calculates the result of the modular multiplication: `result = (a * b) mod N`.  \n\n## **Parameters**\n\n`N`: The modulus used for reduction. \n`R`: A Montgomery parameter, typically chosen as a power of 2.\n`R_INVERSE`: The modular inverse of  R modulo N, satisfying (R* R<sup>-1</sup>) mod N=1\n`NWIDTH`: The bit-width of the numbers involved, computed as  log2(N). \n\n## **Inputs**\n\n`clk`: Clock signal. \n`rst_n`: Active-low Asynchronous reset signal. \n`a`:  First input operand of bit width `NWIDTH`.\n`b`:  Second input operand of bit width `NWIDTH`.\n`valid_in`: Active High control signal indicating valid input data. \n\n## **Outputs**\n\n`result`: Montgomery multiplication result of `a` and `b`, reduced modulo `N`.\n`valid_out`: An active high 1-bit control signal indicating valid output data. \n\n## **Assertions:**\n\n1. Pipeline stability: Ensure the pipeline is stable by checking if the intermediate signals (`valid_in_q`, `valid_in_q1`, `valid_in_q2`, `valid_out_q`) are asserted each after 1 clock cycle. (after an input valid is received)\n\n2. Zero Result: If either `a` or `b` is zero, the `result` must be zero after 4 clock cycles. \n\n3. Modular Multiplication Property - When `valid_in` is set to 1, the result must be equal to `(a * b) mod N` after 4 clock cycles, ensuring correctness.\n\n4. Stability of Valid Signal - Ensure `valid_out` is asserted 4 clock cycles after `valid_in`.\n\n5. Assertions should also be added to check the following conditions related to parameters: Selection of N, R and R_INVERSE should satisfy the following:\n\n    - Radix R, is a number greater than N (R > N).\n    - R is chosen to be a power of 2.\n    - Chosen modulus N is greater than 2 and a coprime with R (R and N must not share any common factors other than 1). We assume N is a prime number so that any choice of R (under the above conditions) is coprime to N.\n    - Let R<sup>-1</sup> be an integer such that:\n        - 0 < R<sup>-1</sup> < N, where R<sup>-1</sup> is the multiplicative inverse in the N-residue system.\n        - The following equation must be satisfied: (R* R<sup>-1</sup>) mod N=1", "context": {"rtl/montgomery_redc.sv": "module montgomery_mult #\n(\n    parameter N = 7,              \n    parameter R = 8,              \n    parameter R_INVERSE = 1,\n    parameter NWIDTH = $clog2(N),\n    parameter TWIDTH = $clog2(N*R)   \n\n    )(\n    input clk ,\n    input rst_n,\n    input  wire [NWIDTH-1:0] a,b, \n    input valid_in,  \n    output wire [NWIDTH-1:0] result ,\n    output valid_out\n);\n    \n    \n    localparam  R_SQUARE  =  (R*R)%N;\n\n    reg [NWIDTH-1:0] a_q,b_q;\n\n    wire [NWIDTH-1:0] a_redc, b_redc , ab_redc;\n    reg [NWIDTH-1:0] a_redc_q, b_redc_q ;\n\n    wire [NWIDTH-1:0] result_d ;\n    reg [NWIDTH-1:0] result_q ;\n\n    reg valid_in_q, valid_in_q1, valid_in_q2 ;\n    reg valid_out_q ;\n    wire [TWIDTH-1:0] ar2 = a_q * R_SQUARE ; \n    wire [TWIDTH-1:0] br2 = b_q * R_SQUARE ; \n\n    wire [TWIDTH-1:0] a_redc_x_b_redc ;\n    reg [TWIDTH-1:0] ab_redc_q ;\n    \n    assign a_redc_x_b_redc = a_redc_q * b_redc_q ;\n    assign result = result_q;\n    assign valid_out = valid_out_q ;\n    always_ff @( posedge clk or negedge rst_n ) begin : valid_out_pipeline\n        if (!rst_n) begin\n            valid_in_q      <=  0 ; \n            valid_in_q1     <=  0 ; \n            valid_in_q2     <=  0 ; \n            valid_out_q     <=  0 ; \n        end else begin\n            valid_in_q      <=  valid_in        ;     \n            valid_in_q1     <=  valid_in_q      ;   \n            valid_in_q2     <=  valid_in_q1     ; \n            valid_out_q     <=  valid_in_q2     ; \n        end \n    end\n\n    always_ff @( posedge clk or negedge rst_n ) begin : input_registers\n        if (!rst_n) begin\n            a_q <= 0 ;\n            b_q <= 0 ;\n        end else begin\n            if(valid_in) begin\n                a_q <= a ;\n                b_q <= b ;\n            end\n        end \n    end\n\n    always_ff @( posedge clk or negedge rst_n ) begin : a_b_reduction_pipeline\n        if (!rst_n) begin\n            a_redc_q <= 0 ;\n            b_redc_q <= 0 ;\n        end else begin\n            a_redc_q <= a_redc ;\n            b_redc_q <= b_redc ;\n        end \n    end\n\n    always_ff @( posedge clk or negedge rst_n ) begin : ab_redc_pipeline\n        if (!rst_n) begin\n            ab_redc_q <= 0 ;\n        end else begin\n            ab_redc_q <= ab_redc; \n        end \n    end\n\n    always_ff @( posedge clk or negedge rst_n ) begin : output_register\n        if (!rst_n) begin\n            result_q <= 0 ;\n        end else begin\n            result_q <= result_d ;\n        end \n    end\n\n    montgomery_redc #\n    (\n        .N (N),\n        .R (R),\n        .R_INVERSE(R_INVERSE)     \n    ) ar2_redc (\n        .T(ar2),    \n        .result(a_redc) \n    );\n    \n    montgomery_redc #\n    (\n        .N (N),\n        .R (R),\n        .R_INVERSE(R_INVERSE)     \n    ) br2_redc (\n        .T(br2),    \n        .result(b_redc) \n    );\n\n    montgomery_redc #\n    (\n        .N (N),\n        .R (R),\n        .R_INVERSE(R_INVERSE)     \n    ) prod_redc (\n        .T(a_redc_x_b_redc),    \n        .result(ab_redc) \n    );\n\n    montgomery_redc #\n    (\n        .N (N),\n        .R (R),\n        .R_INVERSE(R_INVERSE)     \n    ) result_redc (\n        .T(ab_redc_q),    \n        .result(result_d) \n    );\n\nendmodule\n\nmodule montgomery_redc #\n(\n    parameter N = 7,              \n    parameter R = 8,              \n    parameter R_INVERSE = 1,\n    parameter NWIDTH = $clog2(N), \n    parameter TWIDTH = $clog2(N*R)     \n)(\n    input  wire [TWIDTH-1:0] T,    \n    output wire [NWIDTH-1:0] result \n);\n    // Derived parameters\n    localparam RWIDTH = $clog2(R);          \n    localparam TWO_NWIDTH = $clog2(2*N)   ;              \n    localparam [RWIDTH-1:0] N_PRIME = (R * R_INVERSE - 1) / N; \n\n    wire [RWIDTH-1:0] T_mod_R;               \n    wire [2*RWIDTH-1:0] T_mod_R_X_N_PRIME;      \n    wire [RWIDTH-1:0] m;                     \n    wire [TWO_NWIDTH-1:0] t;                      \n\n    assign T_mod_R = T[RWIDTH-1:0];\n\n    assign T_mod_R_X_N_PRIME = T_mod_R * N_PRIME;\n\n    assign m = T_mod_R_X_N_PRIME[RWIDTH-1:0];\n\n    assign t = (T + m * N) >> RWIDTH;\n\n    assign result = (t >= N) ? (t - N) : t;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/montgomery_redc.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/montgomery_redc.sv\nTOPLEVEL        = montgomery_mult\nMODULE          = test_montgomery_mult\nPYTHONPATH      = /src\nHASH            = 6-rtl-assertion-design-montgomery-multiplier", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\ndef redc(T, N, R, N_PRIME):\n    m = ((T%R)*N_PRIME)%R\n    \n    t = (T+ m*N)//R\n    if t>=N:\n        t = t-N\n    else:\n        t = t\n    return t\n\ndef mod_mult(a, b, N):\n    return a*b%N\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build -vcd dumpon\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0", "src/test_montgomery_mult.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport harness_library as hrs_lb\n\n\n@cocotb.test()\nasync def test_montgomery_mult(dut): \n   N = int (dut.N.value)\n   clock_period_ns = 10  # For example, 10ns clock period\n   cocotb.start_soon(Clock(dut.clk, clock_period_ns, units='ns').start())\n   await hrs_lb.dut_init(dut)\n   \n   dut.rst_n.value = 0\n   await Timer(5, units=\"ns\")\n\n   dut.rst_n.value = 1 \n\n   outputs_list = []\n   await RisingEdge(dut.clk)\n   for i in range(50):\n      a = random.randint(0, N-1)\n      b = random.randint(0, N-1)\n      print(\"a: \", a)\n      print(\"b: \", b)\n      print(\"N: \", N)\n      print(\"R: \", dut.R)\n      golden_result = hrs_lb.mod_mult(a,b, N)\n      await FallingEdge(dut.clk)\n      dut.a.value = a\n      dut.b.value = b\n      dut.valid_in.value = 1 \n      await FallingEdge(dut.clk)\n      dut.valid_in.value = 0 \n        \n      latency = 0 \n      while (dut.valid_out.value != 1):\n         await RisingEdge(dut.clk)\n         latency = latency + 1\n       \n      dut_result = int (dut.result.value)\n      assert latency == 4, f\"Valid output should have latency of 2 clk cycles\"\n      assert dut_result == golden_result , f\"Output doesn't match golden output: dut_output {hex(dut_result)}, Expected output {hex(golden_result)}\"\n   \n   for i in range(200):\n      a = random.randint(0, N-1)\n      b = random.randint(0, N-1)\n      golden_result = hrs_lb.mod_mult(a,b, N)\n      outputs_list.append(golden_result)\n      await FallingEdge(dut.clk)\n      dut.a.value = a\n      dut.b.value = b\n      dut.valid_in.value = 1\n      if i>3:\n          expected_result =  outputs_list.pop(0)\n          dut_result = int (dut.result.value) \n          assert dut_result == expected_result, \" Failure!\"\n          ", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nfrom math import gcd\n\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner(WIDTH, N, R, R_INVERSE):\n   \n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            parameter= {'N':N, 'R':R, 'R_INVERSE': R_INVERSE},\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n        hrs_lb.xrun_tb()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\ndef is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef modular_inverse(a, mod):\n    \"\"\"Find the modular inverse of a mod mod.\"\"\"\n    for x in range(1, mod):\n        if (a * x) % mod == 1:\n            return x\n    return None\n\ndef ranomize_test_param():\n    WIDTH = 32\n    while True:\n        N = random.randint(2, 1000)\n        if not is_prime(N):\n            continue\n\n        R = 2**random.randint(2,10)\n        if R <= N:\n            continue\n\n        # Compute R_INVERSE (modular inverse of R mod N)\n        R_INVERSE = modular_inverse(R, N)\n        if R_INVERSE is None:\n            continue\n\n        # Ensure all constraints are satisfied\n        if gcd(R, N) == 1:  # R and N must be coprime (ensured since N is prime)\n            break\n    return(WIDTH, N, R, R_INVERSE)\n\ndef test_redc():\n    for _ in range(5):\n        WIDTH, N, R, R_INVERSE = ranomize_test_param()\n        call_runner(WIDTH, N, R, R_INVERSE)\n"}}}
{"id": "cvdp_copilot_moving_average_0025", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `moving_average` module. The assertions should ensure correct reset behavior, memory operations, address control, and output conditions.  \n\n## **RTL Design Overview**  \nThe `moving_average` module implements an **8-sample moving average filter**. It maintains a sliding window of the last **8 input samples**, computing the moving average by **adding the latest sample and subtracting the oldest sample**.  \n\n### **Key Components of the Module**  \n- **`memory`**: Stores the last 8 input samples.  \n- **`sum`**: Maintains the cumulative sum of the stored values.  \n- **`write_address`**: Tracks the position for writing new data.  \n- **`next_address`**: Points to the next read location (oldest sample).  \n- **`read_data`**: Holds the value of the oldest sample being removed from the sum.  \n- **`clk`**: Clock signal. Design is synchronized to the posedge of this clock.  \n- **`reset`**: Synchronous active-high reset signal.  \n- **`enable`**: Active-high signal. Enables write, read, and sum updates.  \n- **`data_in`**: 12-bit input data sample.  \n- **`data_out`**: 12-bit output representing the computed moving average.  \n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n\n- **Memory Reset Behavior:**  \n  - When `reset` is asserted, all memory locations should be **cleared to `0`** at the next clock cycle.  \n\n- **Write Address Validity:**  \n  - `write_address` should always remain **within the valid range** (`0\u20137`).  \n\n- **Read Data Validity:**  \n  - `read_data` should always be **a previously stored value** from `memory`.  \n\n- **Clock Enable Control:**  \n  - When `enable` is **low**, `sum`, `memory`, `write_address`, and `read_data` should **retain their previous values**.  \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.  ", "context": {"rtl/moving_average.sv": "module moving_average(\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input  wire [11 : 0] data_in,\n    output wire [11 : 0] data_out\n);\n\nreg [11 : 0] memory [7 : 0];\nreg [14 : 0] sum;\nreg [2  : 0] write_address;\nwire [2 : 0] next_address;\nreg [11 : 0] read_data;\n\nassign next_address=write_address + 1'b1;\nassign data_out=sum[14 : 3];\n\n    // write current input to memory\n    integer i;\n    always @(posedge clk ) begin\n        if (reset == 1'b1) begin\n            for (i = 0 ;i < 8 ; i = i + 1 ) begin\n                memory[i]<='h0;\n            end\n        end else begin\n            if(enable==1'b1)begin\n                memory[write_address]<=data_in;\n            end\n        end\n    end\n\n    // read the oldest element written to memory\n    always @(posedge clk ) begin\n        if(reset == 1'b1)begin\n            read_data<='h0;\n        end else begin\n            if(enable==1'b1)begin\n                read_data<=memory[next_address];\n            end\n        end\n    end\n\n    // increase the write address to move onto the next data\n    always @(posedge clk ) begin\n        if(reset == 1'b1)begin\n            write_address<='h0;\n        end else begin\n            if(enable==1'b1)begin\n                write_address<=write_address + 1'b1;\n            end\n        end\n    end\n\n    // calculate sum by adding the latest data to the sum and substracting the oldest data\n    always @(posedge clk ) begin\n        if(reset == 1'b1)begin\n            sum<='h0;\n        end else begin\n            if(enable==1'b1)begin\n                sum<=sum+data_in-read_data;\n            end\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/moving_average.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/moving_average.sv\nTOPLEVEL        = moving_average\nMODULE          = test_moving_average\nPYTHONPATH      = /src\nHASH            = 25-create-the-rtl-for-moving-average", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await RisingEdge(dut.clk)\n    dut.reset.value = 1\n\n    await RisingEdge(dut.clk)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\nasync def reset_dut(dut, duration_ns = 10):\n    # Restart Interface\n    dut.reset.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    dut.reset.value = 0\n    await Timer(duration_ns, units='ns')\n    dut.reset._log.debug(\"Reset complete\")\n\nasync def enable_dut(dut):\n    # Restart Interface\n    dut.enable.value = 0\n    await RisingEdge(dut.clk)\n    dut.enable.value = 1\n    await RisingEdge(dut.clk)\n    dut.enable._log.debug(\"enable complete\")\n\n\nasync def calculate_moving_average(data_queue, current_sum, new_data, window):\n    if len(data_queue) < window:\n        data_queue.append(new_data)\n        current_sum += new_data\n    else:\n        oldest_data = data_queue.pop(0)\n        current_sum += new_data - oldest_data\n        data_queue.append(new_data)\n\n    expected_avg = current_sum // window\n    \n    return expected_avg, current_sum\n", "src/test_moving_average.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport random\nimport harness_library as hrs_lb\nimport time\n\n@cocotb.test()\nasync def test_moving_average(dut):\n\n    # Start clock\n    cocotb.start_soon(Clock(dut.clk, 2, units='ns').start())\n    cocotb.log.info(\"[INFO] Clock started.\")\n    width = 12\n    window = 8\n\n    cocotb.log.info(f\"WIDTH = {width}, WINDOW_SIZE = {window}\")\n\n    # Initialize DUT\n    await hrs_lb.dut_init(dut) \n    dut.reset.value = 1\n    # Apply reset and enable\n    await hrs_lb.reset(dut)\n    await hrs_lb.enable_dut(dut)\n\n    # Wait for a couple of cycles to stabilize\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n    # Ensure all outputs are zero\n    assert dut.data_out.value == 0, f\"[ERROR] data_out is not zero after reset: {dut.data_out.value}\"\n\n    current_sum = 0\n    data_queue = []\n    previous_expected_avg = None  # Variable to hold the previous cycle's expected average\n    cycle_num = data_in = random.randint(500, 1000)\n    cycle_off_enable = random.randint(1,int(cycle_num/2))\n    cycle_on_enable  = random.randint(cycle_off_enable+1,int(cycle_num*3/4))\n\n    # Just for DEBUG, set to 1\n    debug = 0\n\n    if debug:\n        cocotb.log.info(cycle_off_enable)\n        cocotb.log.info(cycle_on_enable)\n    # Apply random stimulus and check output\n    for cycle in range(cycle_num):  # Run the test for 20 cycles\n        if cycle == cycle_off_enable:\n            # Disable the DUT after {cycle_off_enable} cycles\n            cocotb.log.info(f'[INFO] Disabling DUT after {cycle_off_enable} cycles')\n            dut.enable.value = 0\n\n        if cycle == cycle_on_enable:\n            # Re-enable the DUT after {cycle_on_enable-cycle_off_enable} cycles\n            cocotb.log.info(f'[INFO] Re-enabling DUT after {cycle_on_enable} cycles')\n            dut.enable.value = 1\n\n        # Generate random data input\n        data_in = random.randint(0, 2**width-1)\n        dut.data_in.value = data_in\n        await RisingEdge(dut.clk)\n\n        if dut.enable.value == 1:\n            # Calculate the expected average using the helper function\n            expected_avg, current_sum = await hrs_lb.calculate_moving_average(data_queue, current_sum, data_in, window)\n\n        # Read the DUT output\n        actual_avg = dut.data_out.value\n\n        # Compare the current DUT output with the previous cycle's expected average\n        if previous_expected_avg is not None:\n            assert actual_avg == previous_expected_avg, \\\n                f\"[ERROR] Mismatch at cycle {cycle}: Expected {previous_expected_avg}, got {actual_avg}\"\n\n            if debug:\n                cocotb.log.info(f\"[DEBUG] Cycle {cycle}/{cycle_num}: DUT average = {actual_avg}\")\n                cocotb.log.info(f\"[DEBUG] Cycle {cycle}/{cycle_num}: Testbench average = {previous_expected_avg}\")\n            \n        # Update the previous expected average only if enable is high\n        if dut.enable.value == 1:\n            previous_expected_avg = expected_avg\n\n\n    await hrs_lb.reset(dut)\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n\n    # Disable the module and finish the test\n    dut.enable.value = 0\n    await RisingEdge(dut.clk)\n    cocotb.log.info(\"[INFO] Test completed successfully.\")", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner():\n    parameters = {}\n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n\n@pytest.mark.parametrize(\"test\", range(3))\ndef test_moving_rndm(test):\n  call_runner()\n\n"}}}
{"id": "cvdp_copilot_nbit_swizzling_0083", "categories": ["cid014", "medium"], "input": {"prompt": "Can you add SystemVerilog assertions to verify the behavior and correctness of the `nbit_swizzling_top` module. The assertions will ensure functional accuracy, detect errors, and confirm adherence to the expected design specifications.\n## Specifications\n### Interface:\n**Parameters:**\n\n- `DATA_WIDTH`: Width of input data. Default is 16.\n- `CRC_WIDTH`:  Width of CRC output. (Default: DATA_WIDTH/2).\n- `POLY`: CRC polynomial. (Default: 8'b11100110).\n- `CODE_WIDTH (DATA_WIDTH + $clog2(DATA_WIDTH + 1))` : Width of Hamming-encoded data.\n\n**Inputs:**\n\n- `clk(1-bit)`:  Clock signal (active on the rising edge).\n- `rst(1-bit)`:  Active-high reset signal.\n- `data_in([DATA_WIDTH-1:0])`:  Input data.\n- `sel [1:0]`: Selection signal for swizzling.\n- `received ([CODE_WIDTH-1:0])`: Received ECC data.\n\n**Outputs:**\n\n- `data_out([DATA_WIDTH:0])`: Swizzled data with appended parity.\n- `encoded([CODE_WIDTH-1:0])`:  Hamming-encoded data.\n- `crc_out([CRC_WIDTH-1:0]`):  CRC output.\n- `error_detected (1-bit)`:  Indicates ECC error detection.\n- `error_corrected (1-bit)`:  Indicates if an error was corrected.\n- `ecc_data_out([DATA_WIDTH-1:0])`: ECC-corrected output.\n\n## Module Overview\n\nThe `nbit_swizzling_top` module integrates three key components:\n\n- **n-bit Swizzling (`nbit_swizzling`):** Rearranges input data based on a 2-bit selection signal (`sel`).\n- **ECC Generator (`one_bit_ecc`):** Implements Hamming encoding for error detection and correction.\n- **CRC Generator (`crc_generator`):** Computes CRC for error detection using a given polynomial (`POLY`).\n\n## Behavioral Specifications\n\n**1. Swizzling Logic (nbit_swizzling)**\n\n- Rearranges bits based on `sel`:\n    - `2'b00`: Reverse the entire data.\n    - `2'b01`: Reverse two halves separately.\n    - `2'b10`: Reverse four quarters separately.\n    - `2'b11`: Reverse eight segments separately.\n- Appends a parity_bit (^data_in).\n\n**2. ECC (`one_bit_ecc`)**\n\n- Encodes input data into an extended Hamming code (`encoded`).\n- Receives potentially corrupted data (`received`) and calculates syndrome bits.\n- Detects single-bit errors and corrects them.\n- Produces error flags (`error_detected` and `error_corrected`).\n- Outputs the corrected data (`ecc_data_out`).\n\n**3. CRC Computation(`crc_generator`)**\n\n- Computes CRC using the given polynomial (`POLY`).\n- Updates CRC sequentially with each input bit.\n- Outputs the CRC checksum (`crc_out`).\n\n## Assertion Requirements\n**1. ECC Error Correction Assertion:**\n\n- Ensures that when an error is detected (`error_detected == 1`), it is subsequently corrected (`error_corrected == 1`).\n\n**2. ECC Data Correctness Assertion:**\n\n- Ensures that when no errors are present (`encoded == received`), the data output remains unchanged (`data_out == ecc_data_out`).\n\n**3. ECC Error Detection and Correction Check:**\n\n- Ensures that when no errors exist (`encoded == received`), `error_detected` and `error_corrected` is set 0.\n\n**4. Full reverse swizzling logic verification:**\n\n- When `sel == 2'b00`, the entire bit sequence must be reversed, and the parity_bit must be appended at the `data_out([DATA_WIDTH])`.\n\n**5. Swap halves swizzling logic verification:**\n\n- When `sel == 2'b01`, the two halves of `data_in` must be reversed separately, and the parity_bit must be appended at the `data_out([DATA_WIDTH])`.\n\n**6. Swap quarters swizzling logic verification:**\n\n- When `sel == 2'b10`, the four quarters of `data_in` must be reversed separately, and the parity_bit must be appended at the `data_out([DATA_WIDTH])`.\n\n**7. Swap eights swizzling logic verification:**\n\n- When `sel == 2'b11`, the eight segments of `data_in` must be reversed separately, and the parity_bit must be appended at the `data_out([DATA_WIDTH])`.\n\n**8. CRC Reset Check:**\n\n- Ensures that when `rst` = 1, `crc_out` is set to 0.\n\n**9. Data Width Consistency Check:**\n\n- Ensures `data_in` and `crc_out` maintain their expected bit widths.\n---\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.\n\n\n\n", "context": {"rtl/nbit_swizzling.sv": "`timescale 1ns / 1ps\nmodule nbit_swizzling_top #(parameter DATA_WIDTH = 16, \n                            parameter CRC_WIDTH = ((DATA_WIDTH)/2), \n                            parameter POLY = 8'b11100110,\n                            parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1)) (\n    input [DATA_WIDTH-1:0] data_in,                          // Input data\n    input clk,                                               // Clock signal\n    input rst,                                               // Reset signal\n    input  [CODE_WIDTH-1: 0]  received, \n    output  [CRC_WIDTH-1:0] crc_out,                         // CRC output  \n    input   [1:0] sel,                \t                     //  2-bit selection signal \n    output  [DATA_WIDTH:0] data_out,                         // Output data of size DATA_WIDTH \n    output  [CODE_WIDTH-1: 0]  encoded,                      //  Output data with hamming code\n    output error_detected,\n    output error_corrected,\n    output [DATA_WIDTH-1:0] ecc_data_out\n\n  \n ); \n  wire [DATA_WIDTH-1:0] swizzled_data;  \n    \n    nbit_swizzling #(.DATA_WIDTH(DATA_WIDTH)) uut_nbit_swizzling(\n    .data_in(data_in),                                        // Input data of size DATA_WIDTH \n    .sel(sel),                \t                              //  2-bit selection signal \n    .data_out(data_out)                                       // Output data of size DATA_WIDTH \n    );\n    \n    assign swizzled_data = data_out[DATA_WIDTH-1:0];\n\n    one_bit_ecc #(.DATA_WIDTH(DATA_WIDTH),\n                            .CODE_WIDTH(CODE_WIDTH)\n    ) uut_ecc(\n    .data_in(data_in),\n    .encoded(encoded),\n    .received(received),\n    .error_detected(error_detected),\n    .error_corrected(error_corrected),\n    .data_out(ecc_data_out)\n    );\n    \n    crc_generator #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .CRC_WIDTH(CRC_WIDTH),\n        .POLY(POLY)\n    ) crc_gen (\n    .data_in(swizzled_data),\n    .clk(clk),\n    .rst(rst),\n    .crc_out(crc_out)\n    );\n\n       \nendmodule\n\n\nmodule nbit_swizzling #(parameter DATA_WIDTH = 64)(\n    input [DATA_WIDTH-1:0] data_in,                                         // Input data of size DATA_WIDTH \n    input [1:0] sel,                \t                                    //  2-bit selection signal \n    output reg [DATA_WIDTH:0] data_out                                      // Output data of size DATA_WIDTH \n);\n\ninteger i; \nwire parity_bit;                                                            \n\n\nassign parity_bit = ^data_in;\n\nalways @(*) begin\n    case(sel)\n        2'b00: begin\n            for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH-1-i];                      \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        \n        2'b01: begin\n            for (i = 0; i < DATA_WIDTH/2; i = i + 1) begin\n                data_out[i]                = data_in[DATA_WIDTH/2-1-i];     \n                data_out[DATA_WIDTH/2 + i] = data_in[DATA_WIDTH-1-i];       \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        \n        2'b10: begin\n            for (i = 0; i < DATA_WIDTH/4; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH/4-1-i]; \t\t            \n                data_out[DATA_WIDTH/4 + i]   = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        \n        2'b11: begin\n            for (i = 0; i < DATA_WIDTH/8; i = i + 1) begin\n                data_out[i]                  = data_in[DATA_WIDTH/8-1-i];   \n                data_out[DATA_WIDTH/8 + i]   = data_in[DATA_WIDTH/4-1-i];   \n                data_out[DATA_WIDTH/4 + i]   = data_in[3*DATA_WIDTH/8-1-i]; \n                data_out[3*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[5*DATA_WIDTH/8-1-i]; \n                data_out[5*DATA_WIDTH/8 + i] = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[7*DATA_WIDTH/8-1-i]; \n                data_out[7*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        default: begin\n            data_out = data_in;\t\n            data_out[DATA_WIDTH] = parity_bit; \t\t\t\t\t                        \n        end\n    endcase\nend\n\n\nfunction automatic logic [DATA_WIDTH-1:0] reverse_bits(input logic [DATA_WIDTH-1:0] input_bits, int N);\n        logic [DATA_WIDTH-1:0] reversed = '0; // Initialize all bits to 0\n        for (int i = 0; i < N; i = i + 1) begin\n            reversed[i] = input_bits[N-1-i];\n        end\n        return reversed;\n    endfunction\n\n    logic [DATA_WIDTH/2-1:0] first_half, second_half;\n    assign first_half  = data_in[DATA_WIDTH/2-1:0];\n    assign second_half = data_in[DATA_WIDTH-1:DATA_WIDTH/2];\n\n    logic [DATA_WIDTH/4-1:0] q1, q2, q3, q4;\n    assign q1 = data_in[DATA_WIDTH/4-1:0];\n    assign q2 = data_in[DATA_WIDTH/2-1:DATA_WIDTH/4];\n    assign q3 = data_in[3*DATA_WIDTH/4-1:DATA_WIDTH/2];\n    assign q4 = data_in[DATA_WIDTH-1:3*DATA_WIDTH/4];\n\n    logic [DATA_WIDTH/8-1:0] e1, e2, e3, e4, e5, e6, e7, e8;\n    assign e1 = data_in[DATA_WIDTH/8-1:0];\n    assign e2 = data_in[DATA_WIDTH/4-1:DATA_WIDTH/8];\n    assign e3 = data_in[3*DATA_WIDTH/8-1:DATA_WIDTH/4];\n    assign e4 = data_in[DATA_WIDTH/2-1:3*DATA_WIDTH/8];\n    assign e5 = data_in[5*DATA_WIDTH/8-1:DATA_WIDTH/2];\n    assign e6 = data_in[3*DATA_WIDTH/4-1:5*DATA_WIDTH/8];\n    assign e7 = data_in[7*DATA_WIDTH/8-1:3*DATA_WIDTH/4];\n    assign e8 = data_in[DATA_WIDTH-1:7*DATA_WIDTH/8];\n\n    always@(*) begin\n        if (sel == 2'b00) begin\n            logic [DATA_WIDTH-1:0] expected_data; \n            expected_data = reverse_bits(data_in, DATA_WIDTH); \n\n        end\n    end\n\n    always@(*) begin\n        if (sel == 2'b01) begin\n            logic [DATA_WIDTH-1:0] expected_data;\n            expected_data[DATA_WIDTH/2-1:0] = reverse_bits(first_half, DATA_WIDTH/2);\n            expected_data[DATA_WIDTH-1:DATA_WIDTH/2] = reverse_bits(second_half, DATA_WIDTH/2);\n        end\n    end\n\n    always@(*) begin\n        if (sel == 2'b10) begin\n            logic [DATA_WIDTH-1:0] expected_data;\n            expected_data[DATA_WIDTH/4-1:0] = reverse_bits(q1, DATA_WIDTH/4);\n            expected_data[DATA_WIDTH/2-1:DATA_WIDTH/4] = reverse_bits(q2, DATA_WIDTH/4);\n            expected_data[3*DATA_WIDTH/4-1:DATA_WIDTH/2] = reverse_bits(q3, DATA_WIDTH/4);\n            expected_data[DATA_WIDTH-1:3*DATA_WIDTH/4] = reverse_bits(q4, DATA_WIDTH/4);\n        end\n    end\n\n    always@(*) begin\n        if (sel == 2'b11) begin\n            logic [DATA_WIDTH-1:0] expected_data;\n            expected_data[DATA_WIDTH/8-1:0] = reverse_bits(e1, DATA_WIDTH/8);\n            expected_data[DATA_WIDTH/4-1:DATA_WIDTH/8] = reverse_bits(e2, DATA_WIDTH/8);\n            expected_data[3*DATA_WIDTH/8-1:DATA_WIDTH/4] = reverse_bits(e3, DATA_WIDTH/8);\n            expected_data[DATA_WIDTH/2-1:3*DATA_WIDTH/8] = reverse_bits(e4, DATA_WIDTH/8);\n            expected_data[5*DATA_WIDTH/8-1:DATA_WIDTH/2] = reverse_bits(e5, DATA_WIDTH/8);\n            expected_data[3*DATA_WIDTH/4-1:5*DATA_WIDTH/8] = reverse_bits(e6, DATA_WIDTH/8);\n            expected_data[7*DATA_WIDTH/8-1:3*DATA_WIDTH/4] = reverse_bits(e7, DATA_WIDTH/8);\n            expected_data[DATA_WIDTH-1:7*DATA_WIDTH/8] = reverse_bits(e8, DATA_WIDTH/8);\n        end\n    end\n\n\nendmodule \n\n\nmodule crc_generator #(\n    parameter DATA_WIDTH = 8,        // Width of input data\n    parameter CRC_WIDTH = 4,        // Width of CRC output\n    parameter POLY = 4'b1101        // Polynomial for CRC\n) (\n    input [DATA_WIDTH-1:0] data_in, // Input data\n    input clk,                      // Clock signal\n    input rst,                      // Reset signal\n    output reg [CRC_WIDTH-1:0] crc_out // CRC output\n);\n    integer i;                     \n    reg [CRC_WIDTH-1:0] crc_reg;  \n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            crc_out <= 0;           \n        end else begin\n            crc_reg = 0;           \n            for (i = DATA_WIDTH - 1; i >= 0; i = i - 1) begin\n                if (crc_reg[CRC_WIDTH-1] ^ data_in[i]) begin\n                    crc_reg = (crc_reg << 1) ^ POLY; \n                end else begin\n                    crc_reg = crc_reg << 1; \n                end\n            end\n            crc_out <= crc_reg;    \n        end\n    end\n\nendmodule\n\nmodule one_bit_ecc #(\n    parameter DATA_WIDTH = 4,                                  // Width of the data input\n    parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1) // Encoded width\n)(\n    input [DATA_WIDTH-1:0] data_in,                     // Input data\n    output reg [CODE_WIDTH-1:0] encoded,                // Encoded output\n    input [CODE_WIDTH-1:0] received,                    // Received encoded data\n    output reg [DATA_WIDTH-1:0] data_out,               // Corrected output\n    output reg error_detected,                          // Error detected flag\n    output reg error_corrected                          // Error corrected flag\n);\n\n    localparam PARITY_BITS = CODE_WIDTH - DATA_WIDTH;   // Number of parity bits\n\n    reg [PARITY_BITS-1:0] syndrome;                     // Syndrome for error detection\n    reg [CODE_WIDTH-1:0] corrected_data;                // Corrected received data\n\n    integer idx_i, idx_j, idx_k;\n    integer idx_m, idx_n;\n    integer idx_p, idx_q;\n\n    always @(*) begin\n        encoded = 0;\n        idx_k = 0;\n\n        for (idx_i = 0; idx_i < CODE_WIDTH; idx_i = idx_i + 1) begin\n            if ((idx_i + 1) & idx_i) begin\n                encoded[idx_i] = data_in[idx_k];\n                idx_k = idx_k + 1;\n            end\n        end\n\n        for (idx_i = 0; idx_i < PARITY_BITS; idx_i = idx_i + 1) begin\n            encoded[(1 << idx_i) - 1] = 0;\n            for (idx_j = 0; idx_j < CODE_WIDTH; idx_j = idx_j + 1) begin\n                if (((idx_j + 1) & (1 << idx_i)) && ((idx_j + 1) != (1 << idx_i))) begin\n                    encoded[(1 << idx_i) - 1] = encoded[(1 << idx_i) - 1] ^ encoded[idx_j];\n                end\n            end\n        end\n    end\n\n    always @(*) begin\n        syndrome = 0;\n        for (idx_m = 0; idx_m < PARITY_BITS; idx_m = idx_m + 1) begin\n            for (idx_n = 0; idx_n < CODE_WIDTH; idx_n = idx_n + 1) begin\n                if ((idx_n + 1) & (1 << idx_m)) begin\n                    syndrome[idx_m] = syndrome[idx_m] ^ received[idx_n];\n                end\n            end\n        end\n    end\n\n    always @(*) begin\n        error_detected = |syndrome;\n    end\n\n    always @(*) begin\n        corrected_data = received;\n        if (error_detected && syndrome <= CODE_WIDTH) begin\n            corrected_data[syndrome - 1] = ~corrected_data[syndrome - 1];\n        end\n    end\n\n    always @(*) begin\n        data_out = 0;\n        idx_q = 0;\n        for (idx_p = 0; idx_p < CODE_WIDTH; idx_p = idx_p + 1) begin\n            if ((idx_p + 1) & idx_p) begin\n                data_out[idx_q] = corrected_data[idx_p];\n                idx_q = idx_q + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        error_corrected = error_detected; \n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/nbit_swizzling.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/nbit_swizzling.sv\nTOPLEVEL        = nbit_swizzling_top\nMODULE          = test_nbit_swizzling_hamming\nPYTHONPATH      = /src\nHASH            = 9bda4d543cd64295c6b712d36ddec4030fff836b\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n\nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_nbit_swizzling_hamming.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nfrom cocotb.triggers import Timer\n\n\ndef reverse_bits(val, width):\n    result = 0\n    for i in range(width):\n        if (val >> i) & 1:\n            result |= 1 << (width - 1 - i)\n    return result\n\n@cocotb.test()\nasync def sanity_check(dut):\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n    print(\"DUT is alive, test passes.\")\n\n@cocotb.test()\nasync def test_ecc_error_correction_flag(dut):\n    \"\"\"\n    Test that whenever error_detected is 1, error_corrected is also 1 (assertion p_error_corrected).\n    \"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Bring the design out of reset\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n    # Put in a known data word\n    test_data = 0xB  # Choose any value in range\n    dut.data_in.value = test_data\n    await RisingEdge(dut.clk)\n\n    # Grab the ECC codeword output\n    codeword = int(dut.encoded.value)\n\n    # Flip one bit in codeword to simulate a single-bit error\n    flip_bit = 0  # LSB for example\n    corrupted_codeword = codeword ^ (1 << flip_bit)\n    dut.received.value = corrupted_codeword   # <-- FIXED\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    # Check: if error_detected, then error_corrected must be set\n    if int(dut.error_detected.value) == 1:\n        assert int(dut.error_corrected.value) == 1, (\n            f\"Assertion failed: error_detected=1 but error_corrected={int(dut.error_corrected.value)}\"\n        )\n    else:\n        # If error not detected, nothing to check for this assertion\n        pass\n\n@cocotb.test()\nasync def test_ecc_data_correct_no_error(dut):\n    \"\"\"\n    Test that when encoded == received, data_out == ecc_data_out (assertion p_data_correct).\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n    width = dut.DATA_WIDTH.value\n\n    for test_data in [0x0, 0x1, 0xF, 0xA5, 0x5A]:\n        dut.data_in.value = test_data\n        await RisingEdge(dut.clk)\n\n        encoded = int(dut.encoded.value)\n        dut.received.value = encoded\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n\n        # Only compare the lower DATA_WIDTH bits (exclude parity)\n        data_only = int(dut.data_out.value) & ((1 << width) - 1)\n        ecc_data = int(dut.ecc_data_out.value)\n\n        assert data_only == ecc_data, (\n            f\"Assertion failed: encoded==received, but data_out({bin(data_only)}) != ecc_data_out({bin(ecc_data)})\"\n        )\n\n@cocotb.test()\nasync def test_ecc_error_flags_clear_when_no_error(dut):\n    \"\"\"\n    Test that when encoded == received, both error_detected and error_corrected are 0 (assertion p_error_correct_check).\n    \"\"\"\n    # Start the clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Apply reset\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n    # Try a few patterns\n    for test_data in [0x0, 0x1, 0x5, 0xA, 0xF]:\n        dut.data_in.value = test_data\n        await RisingEdge(dut.clk)\n\n        encoded = int(dut.encoded.value)\n        dut.received.value = encoded\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n\n        assert int(dut.error_detected.value) == 0, (\n            f\"Assertion failed: error_detected should be 0 when encoded==received for data_in={test_data:#x}\"\n        )\n        assert int(dut.error_corrected.value) == 0, (\n            f\"Assertion failed: error_corrected should be 0 when encoded==received for data_in={test_data:#x}\"\n        )\n\n@cocotb.test()\nasync def test_swizzling_sel_00_assertion_pass(dut):\n    \"\"\"\n    Test the assertion for sel == 00: data_out must be reversed data_in, and data_out[DATA_WIDTH] is parity.\n    \"\"\"\n    # No clock needed for pure combinational, but okay if you have one.\n    width = dut.DATA_WIDTH.value if hasattr(dut, \"DATA_WIDTH\") else 16  # Fallback\n\n    # Try a few values for data_in\n    test_vectors = [0x0, 0x1, 0xA5, 0xFFFF, 0x8001, 0x1234, 0x5555, 0xAAAA]\n    for val in test_vectors:\n        dut.data_in.value = val\n        dut.sel.value = 0b00\n        await Timer(1, units=\"ns\")  # let combinational logic settle\n\n        expected_data = reverse_bits(val, width)\n        expected_parity = bin(val).count(\"1\") % 2\n\n        dout = int(dut.data_out.value)\n        data_bits = dout & ((1 << width) - 1)\n        parity_bit = (dout >> width) & 0x1\n\n        assert data_bits == expected_data, (\n            f\"sel=00: data_out reversed({hex(val)}) = {hex(data_bits)}, expected {hex(expected_data)}\"\n        )\n        assert parity_bit == expected_parity, (\n            f\"sel=00: data_out parity({hex(val)}) = {parity_bit}, expected {expected_parity}\"\n        )\n\n@cocotb.test()\nasync def test_swizzling_sel_01_assertion_pass(dut):\n    \"\"\"\n    Test assertion for sel == 01: data_out lower half is reversed lower half, upper half is reversed upper half, and parity bit is correct.\n    \"\"\"\n    width = dut.DATA_WIDTH.value if hasattr(dut, \"DATA_WIDTH\") else 16\n\n    test_vectors = [0x0, 0x1, 0xA5, 0xFFFF, 0x8001, 0x1234, 0x5555, 0xAAAA]\n    for val in test_vectors:\n        dut.data_in.value = val\n        dut.sel.value = 0b01\n        await Timer(1, units=\"ns\")  # let combinational logic settle\n\n        half_width = width // 2\n        lower_mask = (1 << half_width) - 1\n\n        first_half = val & lower_mask\n        second_half = (val >> half_width) & lower_mask\n\n        reversed_first = reverse_bits(first_half, half_width)\n        reversed_second = reverse_bits(second_half, half_width)\n\n        expected_data = (reversed_second << half_width) | reversed_first\n        expected_parity = bin(val).count(\"1\") % 2\n\n        dout = int(dut.data_out.value)\n        data_bits = dout & ((1 << width) - 1)\n        parity_bit = (dout >> width) & 0x1\n\n        assert data_bits == expected_data, (\n            f\"sel=01: data_out for data_in {hex(val)} = {hex(data_bits)}, expected {hex(expected_data)}\"\n        )\n        assert parity_bit == expected_parity, (\n            f\"sel=01: parity for data_in {hex(val)} = {parity_bit}, expected {expected_parity}\"\n        )\n\n@cocotb.test()\nasync def test_swizzling_sel_10_assertion_pass(dut):\n    \"\"\"\n    Test assertion for sel == 10: data_out is quarter-swizzled and parity is correct.\n    \"\"\"\n    width = dut.DATA_WIDTH.value if hasattr(dut, \"DATA_WIDTH\") else 16\n\n    test_vectors = [0x0, 0x1, 0xA5, 0xFFFF, 0x8001, 0x1234, 0x5555, 0xAAAA]\n    for val in test_vectors:\n        dut.data_in.value = val\n        dut.sel.value = 0b10\n        await Timer(1, units=\"ns\")  # let combinational logic settle\n\n        quarter = width // 4\n        mask = (1 << quarter) - 1\n\n        q1 = val & mask\n        q2 = (val >> quarter) & mask\n        q3 = (val >> (2 * quarter)) & mask\n        q4 = (val >> (3 * quarter)) & mask\n\n        reversed_q1 = reverse_bits(q1, quarter)\n        reversed_q2 = reverse_bits(q2, quarter)\n        reversed_q3 = reverse_bits(q3, quarter)\n        reversed_q4 = reverse_bits(q4, quarter)\n\n        expected_data = (\n            (reversed_q4 << (3 * quarter)) |\n            (reversed_q3 << (2 * quarter)) |\n            (reversed_q2 << (1 * quarter)) |\n            (reversed_q1 << 0)\n        )\n        expected_parity = bin(val).count(\"1\") % 2\n\n        dout = int(dut.data_out.value)\n        data_bits = dout & ((1 << width) - 1)\n        parity_bit = (dout >> width) & 0x1\n\n        assert data_bits == expected_data, (\n            f\"sel=10: data_out for data_in {hex(val)} = {hex(data_bits)}, expected {hex(expected_data)}\"\n        )\n        assert parity_bit == expected_parity, (\n            f\"sel=10: parity for data_in {hex(val)} = {parity_bit}, expected {expected_parity}\"\n        )\n\n@cocotb.test()\nasync def test_swizzling_sel_11_assertion_pass(dut):\n    \"\"\"\n    Test assertion for sel == 11: data_out is octal-swizzled and parity is correct.\n    \"\"\"\n    width = dut.DATA_WIDTH.value if hasattr(dut, \"DATA_WIDTH\") else 16\n    eighth = width // 8\n\n    test_vectors = [0x0, 0x1, 0xA5, 0xFFFF, 0x8001, 0x1234, 0x5555, 0xAAAA]\n    for val in test_vectors:\n        dut.data_in.value = val\n        dut.sel.value = 0b11\n        await Timer(1, units=\"ns\")\n\n        # Extract 8 chunks as per RTL\n        e1 = (val >> 0)             & ((1 << eighth) - 1)\n        e2 = (val >> (1 * eighth))  & ((1 << eighth) - 1)\n        e3 = (val >> (2 * eighth))  & ((1 << eighth) - 1)\n        e4 = (val >> (3 * eighth))  & ((1 << eighth) - 1)\n        e5 = (val >> (4 * eighth))  & ((1 << eighth) - 1)\n        e6 = (val >> (5 * eighth))  & ((1 << eighth) - 1)\n        e7 = (val >> (6 * eighth))  & ((1 << eighth) - 1)\n        e8 = (val >> (7 * eighth))  & ((1 << eighth) - 1)\n\n        expected_data = 0\n        # e1 goes into lowest bits, e8 into MSB\n        expected_data |= reverse_bits(e1, eighth) << (0 * eighth)\n        expected_data |= reverse_bits(e2, eighth) << (1 * eighth)\n        expected_data |= reverse_bits(e3, eighth) << (2 * eighth)\n        expected_data |= reverse_bits(e4, eighth) << (3 * eighth)\n        expected_data |= reverse_bits(e5, eighth) << (4 * eighth)\n        expected_data |= reverse_bits(e6, eighth) << (5 * eighth)\n        expected_data |= reverse_bits(e7, eighth) << (6 * eighth)\n        expected_data |= reverse_bits(e8, eighth) << (7 * eighth)\n\n        expected_parity = bin(val).count(\"1\") % 2\n\n        dout = int(dut.data_out.value)\n        data_bits = dout & ((1 << width) - 1)\n        parity_bit = (dout >> width) & 0x1\n\n        assert data_bits == expected_data, (\n            f\"sel=11: data_out for data_in {hex(val)} = {hex(data_bits)}, expected {hex(expected_data)}\"\n        )\n        assert parity_bit == expected_parity, (\n            f\"sel=11: parity for data_in {hex(val)} = {parity_bit}, expected {expected_parity}\"\n        )\n\n@cocotb.test()\nasync def test_crc_reset_assertion_pass(dut):\n    \"\"\"\n    Test that after asserting rst, crc_out is zero on next clk (reset_crc SVA).\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Give a nonzero crc_out first (by stimulating with some input)\n    dut.rst.value = 0\n    dut.data_in.value = 0xABCD  \n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    # Now assert reset\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n\n    # Check on next clock edge\n    assert int(dut.crc_out.value) == 0, (\n        f\"After reset, crc_out is {int(dut.crc_out.value)}, expected 0\"\n    )\n\n    dut.rst.value = 0\n    dut.data_in.value = 0x1234\n    await RisingEdge(dut.clk)\n\n@cocotb.test()\nasync def test_crc_data_width_assertion_pass(dut):\n    \"\"\"\n    Test that data_in and crc_out always have the correct width (p_data_width assertion).\n    \"\"\"\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Deassert reset after one clock\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n    # Check widths for a few clocks and random data\n    for val in [0, 0x1, 0xAAAA, 0xFFFF]:\n        dut.data_in.value = val\n        await RisingEdge(dut.clk)\n\n        # Check data_in width\n        width_data_in = dut.data_in.value.n_bits\n        expected_data_width = dut.DATA_WIDTH.value if hasattr(dut, \"DATA_WIDTH\") else 16\n\n        # Check crc_out width\n        width_crc_out = dut.crc_out.value.n_bits\n        expected_crc_width = dut.CRC_WIDTH.value if hasattr(dut, \"CRC_WIDTH\") else 8\n\n        assert width_data_in == expected_data_width, (\n            f\"data_in width is {width_data_in}, expected {expected_data_width}\"\n        )\n        assert width_crc_out == expected_crc_width, (\n            f\"crc_out width is {width_crc_out}, expected {expected_crc_width}\"\n        )\n\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    toplevel = os.getenv(\"TOPLEVEL\")\n    target = float(os.getenv(\"TARGET\"))\n\n    if \"Overall Average\" in metrics[toplevel]:\n        assert float(metrics[toplevel][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    elif \"Assertion\" in metrics[toplevel]:\n        assertion_coverage = metrics[toplevel][\"Assertion\"]\n        \n        # Handle the 'n/a' case\n        if assertion_coverage.lower() == \"n/a\":\n            raise AssertionError(\"Coverage report contains 'n/a' for Assertion coverage. Ensure all assertions are exercised in the testbench.\")\n        \n        assert float(assertion_coverage) >= 100.00, \"Didn't achieve the required coverage result.\"\n\n    \nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_password_generator_0013", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the `password_generator` module to ensure its correct functionality during simulation? The assertions should cover key aspects of the password generation process, ensuring that the generated characters are valid and properly packed into the output (`password`).\n\n___\n### Key Assertions\n##\n**1. Password Character Validity**\n  - **Condition:**\n  Each generated password character must be within the valid ASCII printable range:\n    - Lowercase letters (`a-z`): 97\u2013122\n    - Uppercase letters (`A-Z`): 65\u201390\n    - Special characters (`! to /`): 33\u201346\n    - Numeric characters (`0\u20139`): 48\u201357\n\n  - **Assertion:**\n    - Check that each `char_array[i]` falls within one of these valid ASCII ranges.\n\n  - **Error Message:**\n    - The display message should include the simulation time (`$time`), the index of the invalid character, and the actual ASCII value.\n\n**2. Reset Behavior**\n  - Condition:\n    - During reset, all values in `char_array` should be initialized to `0`.\n  - Assertion:\n    - Ensure `char_array[i] == 8'h00` for all positions when reset is high.\n  - Error Message:\n    - If any value is non-zero during reset, the assertion should indicate the failing index and value.\n\n**3. Functionality:**\n  - `Configurable Length`: Generates a password of user-defined length (`WIDTH`).\n  - `Character Categories`: Uses lowercase, uppercase, special, and numeric characters.\n  - `Randomization Logic`: Implements a counter-based algorithm for character variability.\n  - `Efficient Packing`: Stores the password as a single packed output vector.\n  - `Reset Handling`: Clears the password and resets the counter when reset is asserted.\n  - `Ensures Validity`: Ensures all characters fall within printable ASCII range (33\u2013126).\n\n___\n### Interface\n##\n**PARAMETER**\n  - `WIDTH`: Configurable password length defining the number of characters in the generated password(Default 4).\n\n**INPUTS**\n  - `clk`: System clock used to synchronize character generation and password updates on a positive edge of the clock.\n  - `reset`: Active-high Asynchronous reset signal that clears the password and counter.\n\n  \n**OUTPUT**\n  - `password`: Packed 8-bit per character output containing the final generated password, combining sequentially generated characters.", "context": {"rtl/password_generator.sv": "module password_generator #(\n    parameter WIDTH = 4  // Length of the password (default is 4 characters)\n) (\n    input logic clk,\n    input logic reset,\n    output logic [(WIDTH*8)-1:0] password\n);\n\n  logic [7:0] char_array[WIDTH-1:0];\n  logic [7:0] counter;\n  logic [1:0] char_type;\n  int i;\n\n  // Counter Logic\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      counter <= 8'h00;\n    end else begin\n      counter <= counter + 8'h1;\n    end\n  end\n\n  // Character Generation Logic\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      for (i = 0; i < WIDTH; i++) begin\n        char_array[i] <= 8'h00;\n      end\n    end else begin\n      for (i = 0; i < WIDTH; i++) begin\n        char_type = (counter + i) % 4;\n        case (char_type)\n          0: char_array[i] <= ((counter + char_array[(i+1)%WIDTH]) % 26) + 8'd97;  // Lowercase a-z\n          1: char_array[i] <= ((counter + i) % 26) + 8'd65;  // Uppercase A-Z\n          2:\n          char_array[i] <= ((counter + char_array[(i+WIDTH-1)%WIDTH]) % 14) + 8'd33;  // Special chars\n          3: char_array[i] <= ((counter + i) % 10) + 8'd48;  // Numeric 0-9\n        endcase\n      end\n    end\n  end\n\n  // Password Packing Logic\n  always @* begin\n    password = {(WIDTH * 8) {1'b0}};\n    for (i = 0; i < WIDTH; i++) begin\n      password[i*8+:8] = char_array[i];\n    end\n  end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/password_generator.sv": ""}}, "harness": {"files": {".env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/password_generator.sv\nTOPLEVEL        = password_generator\nMODULE          = test_password_generator\nPYTHONPATH      = /src\nHASH            = 13-assertion-for-password-generator\n", "Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/password_generator.sv\nTOPLEVEL        = password_generator\nMODULE          = test_password_generator\nPYTHONPATH      = /src\nHASH            = 13-assertion-for-password-generator\n", "src/test_password_generator.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\n\n\n@cocotb.test()\nasync def test_password_generator(dut):\n\n    WIDTH = 4 \n    print(f\"Detected WIDTH: {WIDTH} (Password length)\")\n\n\n    cocotb.start_soon(clock_gen(dut))\n\n\n    print(f\"Applying reset\")\n    await reset_dut(dut, WIDTH)\n    print(f\"reset completed\")\n\n\n    for _ in range(5): \n        await RisingEdge(dut.clk) \n        await Timer(1, units=\"ns\")  \n\n        password = extract_password(int(dut.password.value), WIDTH)\n        print(f\"Generated Password: {password}\")\n\n     \n        assert validate_password(password), f\"Password validation failed: {password}\"\n\n    await Timer(10, units=\"ns\")\n\n\nasync def reset_dut(dut, width):\n\n    dut.reset.value = 1  \n    await Timer(10, units=\"ns\") \n\n  \n    password = extract_password(int(dut.password.value), width)\n    print(f\"Password during reset: {'0' * width}\")  \n    assert dut.password.value == 0, f\"Password was not cleared during reset, got: {password}\"\n\n    dut.reset.value = 0 \n    await Timer(10, units=\"ns\") \n\n\ndef extract_password(packed_password, width):\n\n    password = \"\"\n    for i in range(width):\n        char_code = (packed_password >> (i * 8)) & 0xFF  \n        password = chr(char_code) + password\n    return password\n\n\ndef validate_password(password):\n\n    has_lowercase = any('a' <= c <= 'z' for c in password)\n    has_uppercase = any('A' <= c <= 'Z' for c in password)\n    has_special = any(33 <= ord(c) <= 46 for c in password)\n    has_numeric = any('0' <= c <= '9' for c in password)\n\n    return has_lowercase and has_uppercase and has_special and has_numeric\n\n\nasync def clock_gen(dut):\n\n    while True:\n        dut.clk.value = 0\n        await Timer(5, units=\"ns\")  \n        dut.clk.value = 1\n        await Timer(5, units=\"ns\") \n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = 'imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\"'\n    assert subprocess.run(cmd, shell=True), \"Coverage report failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n"}}}
{"id": "cvdp_copilot_perceptron_0016", "categories": ["cid014", "medium"], "input": {"prompt": "Can you add concurrent assertions in the RTL design of the `perceptron_gates` module to ensure its correct functionality during simulation? The assertions should cover various key aspects of the module's operations such as ensuring proper reset initialization of the microcode control unit and weight registers, verifying correct state transitions based on the microcode ROM outputs and iteration counter, checking that the arithmetic operations for calculating `y_in` and updating weights are performed only under the appropriate microcode control conditions, and validating that the gate_target submodule outputs match the expected target values based on the `gate_select` input.\n\nThe assertions should fail when any one of the following 10 conditions fails:\n\n**1. rom_index0_check**:\n- This assertion ensures that when the microcode address is 0, the ROM correctly outputs a microinstruction with `next_addr` set to 1 and `train_action` set to 0.\n\n**2. rom_index1_check**:\n- This assertion verifies that when the microcode address is 1, the ROM provides the correct control signals by setting `next_addr` to 2 and `train_action` to 1.\n\n**3. rom_index2_check**:\n- This assertion confirms that when the microcode address is 2, the ROM outputs a microinstruction with `next_addr` equal to 3 and `train_action` equal to 2, ensuring proper ROM content retrieval.\n\n**4. action1_y_calculation**:\n- This assertion verifies that when train_action is 4'd1, the computed output y is correctly determined by comparing `y_in` with the threshold. Specifically, if `y_in` is greater than the threshold, y should be 1; if `y_in` falls within the range of \u2013threshold to threshold, y should be 0; otherwise, y should be \u20131.\n\n**5. action3_weight_update**:\n- This assertion verifies that during train_action 3, if the actual output y does not match the target, the weight updates and bias updates are computed properly.\n\n**6. action3_no_update** :\n- This assertion ensures that during train_action 3, if the computed output y matches the target, then no weight and bias updates occur (i.e., `wt1_update`, `wt2_update`, and `bias_update` remain zero).\n\n**7. microcode_rom_integrity**:\n- This assertion verifies that every entry of the microcode_rom maintains its expected constant value, ensuring that the ROM contents remain intact throughout the simulation.\n\n**8. address_tracking**:\n- This assertion verifies that the sequential address tracking is correct. It checks that if the current `present_addr `equals `next_addr`, then `microcode_addr` should be updated to the previous cycle's present_addr value, ensuring proper pipelining of the microcode addresses.\n\n**9. train_action5_check** :\n- This assertion verifies that during train_action 5, the design correctly latches the current weight update values into their corresponding previous weight update registers, and it also confirms that the microcode ROM's next address is set to 4'd1.\n\n**10. train_action1_y_in_calc**:\n- This assertion verifies that during `train_action 1`, `y_in`  is computed correctly as the sum of `percep_bias_reg` and the weighted inputs (`x1` multiplied by `percep_wt_1_reg` plus `x2` multiplied by `percep_wt_2_reg`).\n\n## Interface\n## Inputs\n- `clk` (1-bit): Positive edge-triggered clock signal for calculating the microcode ROM address.\n- `rst_n` (1-bit): Asynchronous Negative edge-triggered reset signal. When ACTIVE LOW, `present_addr` is initialized to `4'd0`.\n- `x1`, `x2` (4-bit,[3:0], signed): Perceptron inputs. Can take only Bipolar values [`4'd1`,`-4'd1`]\n- `learning_rate` (1-bit): Learning rate for weight and bias updates.\n- `threshold` (4-bit,[3:0], signed): Threshold value for response calculation.\n- `gate_select` (2-bit,[1:0]): Specifies the gate type for determining target outputs.\n\n## Outputs\n- `percep_w1`, `percep_w2` (4-bit, [3:0], signed): Current weights of the perception. Can take Bipolar Values [`4'd1`,`-4'd1`]\n- `percep_bias` (4-bit,[3:0], signed): Current bias of the perception.Can take Bipolar Values [`4'd1`,`-4'd1`]\n- `present_addr` (4-bit,[3:0]): Current microcode ROM address.\n- `stop` (1-bit): Indicates the end of training.\n- `input_index` (3-bit,[2:0]): Tracks the current target value selected during an iteration. Can take values from 3'd0 to 3'd3.\n- `y_in` (4-bit,[3:0] signed): Computed perception output. Can take Bipolar values [`4'd1`,`-4'd1`]\n- `y` (4-bit, [3:0], signed): Perceptron output after applying the threshold.Can take three different values [`4'd1`,`4'd0`,`-4'd1`]\n- `prev_percep_wt_1`, `prev_percep_wt_2`, `prev_percep_bias` (4-bit, [3:0], signed): Weights and Bias during a previous iteration. Can take Bipolar values [`4'd1`, `-4'd1`]", "context": {"rtl/perceptron_gates.sv": "module perceptron_gates (\n   input  logic clk,// Posedge clock\n   input  logic rst_n,// Negedge reset\n   input  logic signed [3:0] x1, // First Input of the Perceptron\n   input  logic signed [3:0] x2, // Second Input of the Perceptron\n   input  logic learning_rate, // Learning rate (alpha)\n   input  logic signed [3:0] threshold, // Threshold value\n   input  logic [1:0] gate_select, // Gate selection for target values\n   output logic signed [3:0] percep_w1, // Trained Weight 1 \n   output logic signed [3:0] percep_w2, // Trained Weight 2\n   output logic signed [3:0] percep_bias, // Trained Bias\n   output logic [3:0] present_addr, // Current address in microcode ROM\n   output logic stop, // Condition to indicate no learning has occurred(i.e. no weight change between iterations)\n   output logic [2:0] input_index,// Vector to track the selection of target for a given input combination for a gate\n   output logic signed [3:0] y_in, // Calculated Response\n   output logic signed [3:0] y, // Calculated Response obtained by comparing y_in against a threshold value\n   output logic signed [3:0] prev_percep_wt_1,//Value of Weight 1 during a previous iteration\n   output logic signed [3:0] prev_percep_wt_2,//Value of Weight 2 during a previous iteration\n   output logic signed [3:0] prev_percep_bias // Value of Bias during a previous iteration\n);\n\n   logic [15:0] microcode_rom [0:5];\n   logic [3:0]  next_addr;\n   logic [3:0]  train_action;\n   logic [3:0]  microcode_addr;\n   logic [15:0] microinstruction;\n   logic signed [3:0] t1, t2, t3, t4;\n   \n   gate_target dut (\n       .gate_select(gate_select),\n       .o_1(t1),\n       .o_2(t2),\n       .o_3(t3),\n       .o_4(t4)\n   );\n\n   logic signed [3:0] percep_wt_1_reg;\n   logic signed [3:0] percep_wt_2_reg;\n   logic signed [3:0] percep_bias_reg;\n\n   \n   logic signed [3:0] target;\n   logic signed [3:0] prev_wt1_update;\n   logic signed [3:0] prev_wt2_update;\n   logic signed [3:0] prev_bias_update;\n   \n   logic signed [3:0] wt1_update;\n   logic signed [3:0] wt2_update;\n   logic signed [3:0] bias_update;\n   logic [7:0] epoch_counter;\n   \n   assign  prev_percep_wt_1 = prev_wt1_update;\n   assign  prev_percep_wt_2 = prev_wt2_update;\n   assign  prev_percep_bias = prev_bias_update;\n\n   initial begin \n      microcode_rom[0] = 16'b0001_0000_0000_0000; \n      microcode_rom[1] = 16'b0010_0001_0000_0000; \n      microcode_rom[2] = 16'b0011_0010_0000_0000; \n      microcode_rom[3] = 16'b0100_0011_0000_0000; \n      microcode_rom[4] = 16'b0101_0100_0000_0000; \n      microcode_rom[5] = 16'b0000_0101_0000_0000; \n   end  \n   \n   always@(*) begin\n      microinstruction = microcode_rom[microcode_addr];\n      next_addr        = microinstruction[15:12];\n      train_action     = microinstruction[11:8];\n   end\n\n   always_ff @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         present_addr    <= 4'd0;\n         microcode_addr  <= 4'd0;\n         percep_wt_1_reg <= 4'd0;\n         percep_wt_2_reg <= 4'd0;\n         percep_bias_reg <= 4'd0;\n         input_index     <= 2'd0;\n         stop            <= 1'b0;\n      end else begin\n         present_addr    <= next_addr;\n         microcode_addr  <= present_addr;\n      end\n   end\n\n   always_comb begin\n      case (train_action)\n         4'd0:  begin \n                   percep_wt_1_reg = 4'd0;\n                   percep_wt_2_reg = 4'd0;\n                   percep_bias_reg = 4'd0;\n                   stop = 1'b0;\n                   next_addr = next_addr + 4'd0;\n                   y_in = 4'd0;\n                   y    = 4'd0;\n                   prev_wt1_update = 4'd0;\n                   prev_wt2_update = 4'd0;\n                   prev_bias_update = 4'd0;\n                   input_index = 0;\n                   target = 0;\n                   wt1_update = 0;\n                   wt2_update = 0;\n                   bias_update = 0;\n                   epoch_counter = 0;\n                end\n         4'd1 : begin \n                   y_in = percep_bias_reg + (x1 * percep_wt_1_reg) + (x2 * percep_wt_2_reg); \n                   if (y_in > threshold)\n                      y = 4'd1;\n                   else if (y_in >= -threshold && y_in <= threshold)\n                      y = 4'd0;\n                   else\n                      y = -4'd1;\n                \n                   percep_wt_1_reg  = percep_wt_1_reg  + 4'd0;\n                   percep_wt_2_reg  = percep_wt_2_reg  + 4'd0;\n                   percep_bias_reg  = percep_bias_reg  + 4'd0;\n                   prev_wt1_update  = prev_wt1_update  + 4'd0;\n                   prev_wt2_update  = prev_wt2_update  + 4'd0;\n                   prev_bias_update = prev_bias_update + 4'd0;\n                   input_index = input_index + 0;\n                   next_addr = next_addr + 4'd0;\n                   stop = stop + 1'b0;\n                   target = target + 4'd0;\n                   wt1_update = wt1_update + 4'd0 ;\n                   wt2_update = wt2_update + 4'd0 ;\n                   bias_update = bias_update + 4'd0 ;\n                   epoch_counter = epoch_counter + 0;\n                end\n         4'd2 : begin\n                   if(input_index == 0)\n                        target = t1;\n                   else if(input_index == 1)\n                        target = t2;\n                   else if(input_index == 2)\n                        target = t3;\n                   else if(input_index == 3)\n                        target = t4;\n                   else begin\n                        input_index = 0;\n                        target = 0;\n                   end\n                   stop = stop + 1'b0;\n                   input_index = input_index + 0;\n                   next_addr = next_addr + 4'd0;\n                   target = target + 4'd0;\n                   prev_wt1_update  = prev_wt1_update  + 4'd0;\n                   prev_wt2_update  = prev_wt2_update  + 4'd0;\n                   prev_bias_update = prev_bias_update + 4'd0;\n                   \n                   percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                   percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                   percep_bias_reg = percep_bias_reg + 4'd0;\n                   y_in = y_in + 4'd0;\n                   y = y + 4'd0;\n                   wt1_update = wt1_update + 4'd0 ;\n                   wt2_update = wt2_update + 4'd0 ;\n                   bias_update = bias_update + 4'd0 ;\n                   epoch_counter = epoch_counter + 0;\n                end\n         4'd3 : begin\n                   if (y != target) begin\n                        wt1_update = learning_rate * x1 * target ;\n                        wt2_update = learning_rate * x2 * target ;\n                        bias_update = learning_rate * target ; \n                    end else begin\n                        wt1_update = 0 ;\n                        wt2_update = 0 ;\n                        bias_update = 0 ;     \n                    end    \n                    percep_wt_1_reg = percep_wt_1_reg + wt1_update;\n                    percep_wt_2_reg = percep_wt_2_reg + wt2_update;\n                    percep_bias_reg = percep_bias_reg + bias_update;\n                    prev_wt1_update  = prev_wt1_update  + 4'd0;\n                    prev_wt2_update  = prev_wt2_update  + 4'd0;\n                    prev_bias_update = prev_bias_update + 4'd0;\n                    y_in = y_in + 4'd0;\n                    y = y + 4'd0;\n                    stop = stop + 1'b0;\n                    input_index = input_index + 0;\n                    next_addr = next_addr + 4'd0;\n                    target = target + 4'd0;\n                    epoch_counter = epoch_counter + 0;\n                end\n         4'd4 : begin\n                  if ((prev_wt1_update == wt1_update) & (prev_wt2_update == wt2_update) & (input_index == 4'd3)) begin \n                          epoch_counter = 0;\n                          stop = 1'b1; \n                          input_index = 0;\n                          next_addr = 4'd0;\n                          percep_wt_1_reg = 0;\n                          percep_wt_2_reg = 0;\n                          percep_bias_reg = 0;\n                          prev_wt1_update =  0;\n                          prev_wt2_update =  0;\n                          prev_bias_update = 0;\n                          y_in = 0;\n                          y = 0;\n                          target = 0;\n                          wt1_update = 0 ;\n                          wt2_update = 0 ;\n                          bias_update = 0 ;\n                  end else begin\n                          stop = 1'b0; \n                          input_index = input_index + 0;\n                          epoch_counter = epoch_counter + 1;    \n                          next_addr = 4'd5;    \n                          percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                          percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                          percep_bias_reg = percep_bias_reg + 4'd0;\n                          prev_wt1_update = prev_wt1_update + 4'd0;\n                          prev_wt2_update = prev_wt2_update + 4'd0;\n                          prev_bias_update = prev_bias_update + 4'd0;\n                          y_in = y_in + 4'd0;\n                          y = y + 4'd0;\n                          target = target + 4'd0;\n                          wt1_update = wt1_update + 4'd0 ;\n                          wt2_update = wt2_update + 4'd0 ;\n                          bias_update = bias_update + 4'd0 ;\n                  end\n                end\n         4'd5 : begin\n                          percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                          percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                          percep_bias_reg = percep_bias_reg + 4'd0;\n                          prev_wt1_update  = wt1_update;\n                          prev_wt2_update  = wt2_update;\n                          prev_bias_update = bias_update;\n                          next_addr = 4'd1;\n                          input_index = input_index + 1;\n                          stop = stop + 1'b0;\n                          epoch_counter = epoch_counter + 0;\n                          y_in = y_in + 4'd0;\n                          y = y + 4'd0;\n                          target = target + 4'd0;\n                          wt1_update = wt1_update + 4'd0;\n                          wt2_update = wt2_update + 4'd0;\n                          bias_update = bias_update + 4'd0;\n                end   \n      default : begin\n                          next_addr = next_addr + 4'd0;\n                          percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                          percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                          percep_bias_reg = percep_bias_reg + 4'd0;\n                          prev_wt1_update = prev_wt1_update + 4'd0;\n                          prev_wt2_update = prev_wt2_update + 4'd0;\n                          prev_bias_update = prev_bias_update + 4'd0;\n                          stop = stop + 1'b0;\n                          y_in = y_in + 4'd0;\n                          y = y + 4'd0;\n                          input_index = input_index + 0;\n                          target = target + 4'd0;\n                          wt1_update = wt1_update + 4'd0 ;\n                          wt2_update = wt2_update + 4'd0 ;\n                          bias_update = bias_update + 4'd0 ;\n                          epoch_counter = epoch_counter + 0;\n                end\n      endcase\n   end\n   assign percep_w1 = percep_wt_1_reg;\n   assign percep_w2 = percep_wt_2_reg;\n   assign percep_bias = percep_bias_reg;\n\nendmodule\n\nmodule gate_target(\n   input  logic        [1:0] gate_select,\n   output logic signed [3:0] o_1,\n   output logic signed [3:0] o_2,\n   output logic signed [3:0] o_3,\n   output logic signed [3:0] o_4\n);\n   always_comb begin\n     case(gate_select)\n          2'b00 : begin \n                    o_1 =  1; \n                    o_2 = -1; \n                    o_3 = -1; \n                    o_4 = -1; \n                  end\n          2'b01 : begin \n                    o_1 =  1; \n                    o_2 =  1; \n                    o_3 =  1; \n                    o_4 = -1; \n                  end\n          2'b10 : begin \n                    o_1 =  1; \n                    o_2 =  1; \n                    o_3 =  1; \n                    o_4 = -1; \n                  end\n          2'b11 : begin \n                    o_1 =  1; \n                    o_2 = -1; \n                    o_3 = -1; \n                    o_4 = -1; \n                  end\n        default : begin\n                    o_1 =  0; \n                    o_2 =  0; \n                    o_3 =  0; \n                    o_4 =  0; \n                  end\n        endcase\n   end\nendmodule"}}, "output": {"response": "", "context": {"rtl/perceptron_gates.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/perceptron_gates.sv\nTOPLEVEL        = perceptron_gates\nMODULE          = test_perceptron_gates\nPYTHONPATH      = /src\nHASH            = 16-perceptron_tb_assertion_issue\n", "src/test_perceptron_gates.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n@cocotb.test()\nasync def test_perceptron_gates(dut):\n    \"\"\"Testbench for the perceptron_gates module using Cocotb.\"\"\"\n\n    # Create a 10ns clock\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Reset logic\n    dut.rst_n.value = 0\n    await Timer(10, units=\"ns\")\n    dut.rst_n.value = 1\n\n    # Initialize inputs\n    dut.x1.value = 0\n    dut.x2.value = 0\n    dut.learning_rate.value = 1\n    dut.threshold.value = 0\n    dut.gate_select.value = 0\n\n    await RisingEdge(dut.rst_n)\n    await Timer(10, units=\"ns\")\n\n    # Helper function for applying stimulus and logging outputs\n    async def apply_stimulus(x1, x2, gate_select, duration):\n        dut.x1.value = x1\n        dut.x2.value = x2\n        dut.gate_select.value = gate_select\n        await Timer(duration, units=\"ns\")\n        cocotb.log.info(\n            f\"gate_select={gate_select}, x1={x1}, x2={x2}, \"\n            f\"percep_w1={int(dut.percep_w1.value)}, \"\n            f\"percep_w2={int(dut.percep_w2.value)}, \"\n            f\"percep_bias={int(dut.percep_bias.value)}, \"\n            f\"present_addr={bin(int(dut.present_addr.value))}, \"\n            f\"stop={bin(int(dut.stop.value))}, \"\n            f\"input_index={bin(int(dut.input_index.value))}, \"\n            f\"y_in={int(dut.y_in.value)}, \"\n            f\"y={int(dut.y.value)}, \"\n            f\"prev_percep_wt_1={int(dut.prev_percep_wt_1.value)}, \"\n            f\"prev_percep_wt_2={int(dut.prev_percep_wt_2.value)}, \"\n            f\"prev_percep_bias={int(dut.prev_percep_bias.value)}\"\n         )\n\n    # Test AND gate targets (gate_select = 2'b00)\n    dut.gate_select.value = 0b00\n    cocotb.log.info(\"Start of AND gate Training\")\n    await apply_stimulus(1, 1, 0b00, 100)\n    await apply_stimulus(1, -1, 0b00, 80)\n    await apply_stimulus(-1, 1, 0b00, 90)\n    await Timer(25, units=\"ns\")\n    await apply_stimulus(-1, -1, 0b00, 95)\n    await apply_stimulus(1, 1, 0b00, 25)\n    await apply_stimulus(1, -1, 0b00, 30)\n    await apply_stimulus(-1, 1, 0b00, 30)\n    await apply_stimulus(-1, -1, 0b00, 90)\n    await Timer(30, units=\"ns\")\n    cocotb.log.info(\"End of AND gate Training\")\n\n    # Test OR gate targets (gate_select = 2'b01)\n    dut.gate_select.value = 0b01\n    cocotb.log.info(\"Start of OR gate Training\")\n    await apply_stimulus(1, 1, 0b01, 95)\n    await Timer(30, units=\"ns\")\n    await apply_stimulus(-1, 1, 0b01, 65)\n    await apply_stimulus(1, -1, 0b01, 30)\n    await apply_stimulus(-1, -1, 0b01, 60)\n    cocotb.log.info(\"End of OR gate Training\")\n\n    # Test NAND gate targets (gate_select = 2'b10)\n    dut.gate_select.value = 0b10\n    cocotb.log.info(\"Start of NAND gate Training\")\n    await apply_stimulus(-1, -1, 0b10, 115)\n    await Timer(30, units=\"ns\")\n    await apply_stimulus(-1, 1, 0b10, 80)\n    await Timer(30, units=\"ns\")\n    await apply_stimulus(1, -1, 0b10, 65)\n    await Timer(10, units=\"ns\")\n    await apply_stimulus(1, 1, 0b10, 70)\n    cocotb.log.info(\"End of NAND gate Training\")\n\n    # Test NOR gate targets (gate_select = 2'b11)\n    dut.gate_select.value = 0b11\n    cocotb.log.info(\"Start of NOR gate Training\")\n    await apply_stimulus(-1, -1, 0b11, 410)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(-1, 1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(1, -1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(1, 1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(-1, -1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(-1, 1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(1, -1, 0b11, 80)\n    await Timer(20, units=\"ns\")\n    await apply_stimulus(1, 1, 0b11, 70)\n    cocotb.log.info(\"End of NOR gate Training\")\n\n    # Randomized test cases\n    num_random_cases = 10  # Number of random test cases\n    for i in range(num_random_cases):\n        random_gate_select = random.randint(0, 3)  # Randomly select gate (0b00 to 0b11)\n        random_inputs = [(random.choice([-1, 1]), random.choice([-1, 1])) for _ in range(4)]\n\n        dut.gate_select.value = random_gate_select\n        cocotb.log.info(f\"Start of Random Test Case {i+1} for gate_select={bin(random_gate_select)}\")\n\n        for x1, x2 in random_inputs:\n            await apply_stimulus(x1, x2, random_gate_select, 100)\n        cocotb.log.info(f\"End of Random Test Case {i+1} for gate_select={bin(random_gate_select)}\")\n\n    # Stop the test\n    cocotb.log.info(\"Test Completed\")\n\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_ring_token_0009", "categories": ["cid014", "easy"], "input": {"prompt": "Add intermediate assertions to verify that **`token_ring_fsm`** module implements a **token-passing protocol** among four nodes. The FSM ensures that only **one token** is active at a time and rotates sequentially among the nodes in a fixed order. **Assertions have to be created** to verify that the **token-passing mechanism** and **data transmission conditions** operate correctly.\n\n### **Expected Behavior**\nEach assertion should validate the **correct operation of the FSM**, including:\n1. **Token Uniqueness**: Ensure that only **one active token** exists at a time.\n2. **Token Passing Sequence**: Verify that the token follows the expected cyclic sequence `{4'b0001 to 4'b0010 to 4'b0100 to 4'b1000 to 4'b0001}`.\n3. **State Transition Validity**: Validate that the FSM transitions correctly between `NODE0 to NODE1 to NODE2 to NODE3 to NODE0`.\n4. **Data Transmission Rules**: Ensure that `data_out` updates **only** when the **current node holds the token** and `has_data_to_send` is asserted when the clock is Active high.\n\nIn the event of an assertion failure, the error message must include **debugging details** such as the **current state, token value, and `data_out`**.\n\n---\n\n## **RTL Specification**\n\n### **Module Name: `token_ring_fsm`**\nA finite state machine that cycles through four nodes, ensuring only one node holds an active token at a time. Each node can send data only when it has the token.\n\n### **Parameters**\n- **NODES**: Number of nodes in the token ring (default: 4).\n\n### **Ports**\n\n| **Port Name**      | **Direction** | **Size** | **Type** | **Description**                         |\n|--------------------|---------------|----------|----------|-----------------------------------------|\n| `clk`              | Input         | 1 bit    | Signal   | Posedge of Clock signal                 |\n| `rst`              | Input         | 1 bit    | Signal   | Asynchronous reset signal, active high  |\n| `data_in`          | Input         | 4 bits   | Data     | Data input from the node                |\n| `data_out`         | Output        | 4 bits   | Data     | Data output to the next node            |\n| `has_data_to_send` | Input         | 1 bit    | Control  | Indicates if the node has data to send  |\n| `token_received`   | Output        | 4 bits   | Control  | Active token indicator for the nodes    |\n| `token`            | Output        | 4 bits   | Control  | Current token status                    |\n\n---\n\n## **Assertions for `token_ring_fsm`**\n\n1. **Token Uniqueness Assertion**  \n   - Ensures that only **one active token** exists at a time.\n   - Detects multiple active tokens, which would indicate a protocol violation.\n\n2. **Token Passing Sequence Assertion**  \n   - Validates that the **token follows the expected cyclic order** `{4'b0001 to 4'b0010 to 4'b0100 to 4'b1000 to 4'b0001}`.\n   - Detects any invalid token assignments.\n\n3. **State Transition Validity Assertion**  \n   - Ensures that the FSM **only transitions between valid states**:  \n     `{NODE0 to NODE1 to NODE2 to NODE3 to NODE0}`.\n   - Catches unexpected state transitions.\n\n4. **Data Transmission Validity Assertion**  \n   - Ensures that **`data_out` is updated only when**:\n     - The **current node has the token** (`token_received[current_state] == 1`).\n     - `has_data_to_send` is **asserted**.\n   - Detects cases where `data_out` updates incorrectly.\n\n---\n\n## **Assertion Reporting**\nEach assertion must **generate detailed error messages** upon failure, including:\n- **Simulation timestamp (`$time`)**.\n- **Current state (`current_state`)**.\n- **Token value (`token`)**.\n- **Data output (`data_out`)**.\n\nThis will help in **debugging and root cause analysis**.\n\n---\n", "context": {"rtl/token_ring_fsm.sv": "module token_ring_fsm (\n    input logic clk,              // Clock input\n    input logic rst,              // Reset input\n    input logic [3:0] data_in,    // Data input from node\n    output reg [3:0] data_out,    // Data output to node\n    input logic has_data_to_send, // Signal indicating data is ready to send\n    output reg [3:0] token_received, // Token received status for nodes\n    output reg [3:0] token        // Token status being passed between nodes\n);\n\ntypedef enum logic [1:0] {\n    NODE0 = 2'b00,\n    NODE1 = 2'b01,\n    NODE2 = 2'b10,\n    NODE3 = 2'b11\n} state_t;\n\nstate_t current_state, next_state;\n\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_state <= NODE0;\n        token <= 4'b0001;\n        token_received <= 4'b0001;\n        data_out <= 4'b0000;\n    end else begin\n        case (current_state)\n            NODE0: begin\n                token_received <= 4'b0001;\n                token <= 4'b0010;\n                next_state = NODE1;\n            end\n            NODE1: begin\n                token_received <= 4'b0010;\n                token <= 4'b0100;\n                next_state = NODE2;\n            end\n            NODE2: begin\n                token_received <= 4'b0100;\n                token <= 4'b1000;\n                next_state = NODE3;\n            end\n            NODE3: begin\n                token_received <= 4'b1000;\n                token <= 4'b0001;\n                next_state = NODE0;\n            end\n            default: begin\n                next_state = NODE0;\n            end\n        endcase\n\n        if (token_received[current_state] && has_data_to_send) begin\n            data_out <= data_in;\n        end else begin\n            data_out <= 4'b0000;\n        end\n\n        current_state <= next_state;\n    end\nend\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/token_ring_fsm.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/token_ring_fsm.sv\nTOPLEVEL        = token_ring_fsm\nMODULE          = test_token_ring_fsm\nPYTHONPATH      = /src\nHASH            = f5ba72d361d8dce872be6ca138e7d14b8e107dab\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_token_ring_fsm.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n# Clock generation coroutine\nasync def generate_clock(dut, period=10, units='ns'):\n    \"\"\"Generate clock with a period of `period` time units.\"\"\"\n    while True:\n        dut.clk.value = 0\n        await Timer(period // 2, units=units)\n        dut.clk.value = 1\n        await Timer(period // 2, units=units)\n\nasync def reset_dut(dut):\n    \"\"\"Reset DUT and verify initial conditions.\"\"\"\n    dut.rst.value = 1\n    dut.data_in.value = 0\n    dut.has_data_to_send.value = 0\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n    assert dut.token.value == 0b0001, f\"Reset failure: expected token 0001, got {dut.token.value}\"\n    assert dut.token_received.value == 0b0001, f\"Reset failure: expected token_received 0001, got {dut.token_received.value}\"\n    assert int(dut.current_state.value) == 0, f\"Reset failure: expected NODE0, got {int(dut.current_state.value)}\"\n    assert dut.data_out.value == 0, f\"Reset failure: expected data_out 0, got {dut.data_out.value}\"\n\n@cocotb.test()\nasync def test_token_passing(dut):\n    \"\"\"Test FSM token passing and state transitions.\"\"\"\n    cocotb.start_soon(generate_clock(dut))\n    await reset_dut(dut)\n\n    expected_tokens = [0b0010, 0b0100, 0b1000, 0b0001]\n    expected_states = [1, 2, 3, 0]\n\n    for expected_token, expected_state in zip(expected_tokens, expected_states):\n        await RisingEdge(dut.clk)\n        assert dut.token.value == expected_token, f\"Token transition error: expected {bin(expected_token)}, got {bin(dut.token.value)}\"\n        assert int(dut.current_state.value) == expected_state, f\"State transition error: expected {expected_state}, got {int(dut.current_state.value)}\"\n\n@cocotb.test()\nasync def test_data_transmission(dut):\n    \"\"\"Test that data is only transmitted when the node has the token.\"\"\"\n    cocotb.start_soon(generate_clock(dut))\n    await reset_dut(dut)\n\n    for _ in range(10):\n        data = random.randint(0, 15)\n        dut.data_in.value = data\n        dut.has_data_to_send.value = 1\n        await RisingEdge(dut.clk)\n\n        expected_data_out = data if (dut.token_received.value.integer & (1 << int(dut.current_state.value))) else 0\n        assert dut.data_out.value == expected_data_out, f\"Data mismatch: expected {expected_data_out}, got {dut.data_out.value}\"\n\n        dut.has_data_to_send.value = 0\n        await RisingEdge(dut.clk)\n\n@cocotb.test()\nasync def test_boundary_conditions(dut):\n    \"\"\"Check boundary conditions for data_in from 0 to 15.\"\"\"\n    cocotb.start_soon(generate_clock(dut))\n    await reset_dut(dut)\n\n    for data_in_value in range(16):\n        dut.data_in.value = data_in_value\n        dut.has_data_to_send.value = 1\n        await RisingEdge(dut.clk)\n\n        expected_data_out = data_in_value if (dut.token_received.value.integer & (1 << int(dut.current_state.value))) else 0\n        assert dut.data_out.value == expected_data_out, f\"Boundary test failed at data_in={data_in_value}, expected {expected_data_out}, got {dut.data_out.value}\"\n\n        dut.has_data_to_send.value = 0\n        await RisingEdge(dut.clk)\n"}}}
{"id": "cvdp_copilot_serial_in_parallel_out_0032", "categories": ["cid014", "medium"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the Serial-In Parallel-Out (sipo_top) shift register that integrates a `serial_in_parallel_out_8bit`, `onebit_ecc` and CRC Generator(`crc_generator`) . The module details and design requirements for assertion development are outlined below.\n\n## **Specifications**\n### Interface:\n**Parameter:**\n- `DATA_WIDTH`: Width of the data (default: 16).  \n- `SHIFT_DIRECTION`: Shift direction (`1` = left, `0` = right).  \n- `CODE_WIDTH`: `DATA_WIDTH + $clog2(DATA_WIDTH + 1)`.  \n- `CRC_WIDTH`: Width of the CRC (`DATA_WIDTH/2`).  \n- `POLY`: Polynomial used for CRC computation. Default is 8'b10101010\n\n### **Inputs**\n- `clk` (1-bit): Clock signal that runs at a 50:50 duty cycle. The positive edge of the clk controls the design.  \n- `reset_n` (1-bit): Active LOW asynchronous reset.  \n- `serial_in` (1-bit): Serial input data.  \n- `shift_en` (1-bit): Shift enable signal.  \n- `received ([CODE_WIDTH-1:0])`: Received encoded data.  \n- `received_crc ([CRC_WIDTH-1:0])`: Received CRC value.\n\n### **Outputs**\n- `done` (1-bit): Shift completion signal.  \n- `data_out ([DATA_WIDTH-1:0])`: ECC-corrected data output.  \n- `encoded ([CODE_WIDTH-1:0])`: ECC-encoded data.  \n- `error_detected` (1-bit): Error detection flag.  \n- `error_corrected` (1-bit): Error correction flag.  \n- `crc_out ([CRC_WIDTH-1:0])`: Generated CRC output.  \n- `crc_error` (1-bit): CRC error detected flag.\n\n## **Behavioral Requirements**\n### **1. Serial-In Parallel-Out (`serial_in_parallel_out_8bit`)**\n- Shifts data when `shift_en` is HIGH.  \n- Asserts `done` when `DATA_WIDTH` bits are received.  \n- Shifts **left** if `SHIFT_DIRECTION = 1`, **right** if `SHIFT_DIRECTION = 0`.  \n\n### **2. One-Bit ECC(`onebit_ecc`)**\n- Calculate parity bits during encoding and insert them into the appropriate positions.\n- Extract and output the corrected data.\n- Detects single-bit errors (`error_detected`).  \n- Corrects single-bit errors (`error_corrected`).  \n\n### **3. CRC Generator(`crc_generator`)**\n- Computes CRC using the given polynomial (`POLY`).\n- Updates CRC sequentially with each input bit.\n- Outputs the CRC checksum (crc_out).\n\n## **Assertion Requirements**\nTo validate the design, implement the following SystemVerilog **assertions**:\n\n1. **ECC Error Correction Validity:**  \n   - Ensure that if an error is detected, it gets corrected (`error_corrected=1`).\n\n2. **ECC Data Integrity  Check:**  \n   - Validate that `data_out` correctly reconstructs the original data_in when there is no error.\n\n3. **ECC Error-Free Behavior Check:**  \n   - Ensure that if `received` matches `encoded`, `error_detected` and `error_corrected` remain 0.\n\n4. **Left Shift Verification:**  \n   - Ensure that when shifting is enabled and `SHIFT_DIRECTION=1`, the serial input correctly propagates into `parallel_out.\n\n5. **Reset Behavior Verification:**  \n   - Ensure that when `reset_n=0`, `parallel_out`, `shift_count`, and `done` reset to 0.\n  \n6. **CRC Match Check:**  \n   - Ensure that if `crc_out` matches `received_crc`, `crc_error` is 0.\n\n7. **CRC Mismatch Detection:**  \n   - Verify that when `crc_out` mismatches `received_crc`, `crc_error` is set to 1.\n\n---\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.\n\n\n\n\n", "context": {"rtl/serial_in_parallel_out_8bit.sv": "module sipo_top#(parameter DATA_WIDTH = 16,                                   // Width of the shift register\n                 parameter SHIFT_DIRECTION = 1,                               // Determines Left or right shift\n                 parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1),  // Encoded width\n                 parameter CRC_WIDTH = ((DATA_WIDTH)/2),                      // width of the CRC output\n                 parameter POLY = 8'b10101010                                 // Polynomial for CRC\n                 ) (\n   \n   input clk,                                   // Clock input\n   input reset_n,                               // Reset input\n   input serial_in,                             // Serial input to SIPO\n   input shift_en,                              // Shift enable                     \n   input [CODE_WIDTH-1:0] received,             // Received encoded data \n   input [CRC_WIDTH-1:0] received_crc,          // Received crc data\n   output done,                                 // Done signal indicating completion of shift\n   output [DATA_WIDTH-1:0] data_out,            // corrected output of ecc block\n   output [CODE_WIDTH-1:0] encoded,             // Encoded output\n   output error_detected,                       // Error detected flag\n   output error_corrected,                      // Error corrected  flag\n   output [CRC_WIDTH-1:0] crc_out,              // CRC output\n   output crc_error                             // CRC error detected flag\n   \n   );\n\nwire [DATA_WIDTH-1:0] parallel_out;\nreg [DATA_WIDTH-1:0] crc_in;\n\nserial_in_parallel_out_8bit  #(.WIDTH(DATA_WIDTH),\n       .SHIFT_DIRECTION(SHIFT_DIRECTION)\n       ) uut_sipo (\n        .clk           (clk),               // Clock input\n        .reset_n       (reset_n),           // Reset input\n        .sin           (serial_in),         // Serial input to SIPO\n        .shift_en      (shift_en),          // Shift enable for SIPO\n        .done          (done),              // Done signal from SIPO\n        .parallel_out  (parallel_out)       // Parallel output from SIPO\n    );\n \n\nonebit_ecc#(.DATA_WIDTH(DATA_WIDTH),\n            .CODE_WIDTH(CODE_WIDTH)\n            ) uut_onebit_ecc1 (\n\n    .data_in(parallel_out),\n    .encoded(encoded),\n    .received(received),\n    .data_out(data_out),\n    .error_detected(error_detected),\n    .error_corrected(error_corrected)\n    );\n\nalways @(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n    crc_in <= {DATA_WIDTH{1'b0}};\n    end\n    else begin\n        if(done == 1'b1) begin\n            crc_in <= parallel_out;\n        end\n        else begin\n            crc_in <= {DATA_WIDTH{1'b0}};\n        end\n    end\nend\n\ncrc_generator #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .CRC_WIDTH(CRC_WIDTH),\n        .POLY(POLY)\n    ) crc_gen (\n    .data_in(crc_in),\n    .clk(clk),\n    .rst(!reset_n),\n    .crc_out(crc_out)\n           \n);\n\nassign crc_error = (crc_out == received_crc)?1'b0:1'b1;\n\nendmodule\n\nmodule serial_in_parallel_out_8bit  #(\n    parameter WIDTH = 64,               // Width of the shift register\n    parameter SHIFT_DIRECTION = 1       // Determines if shifting\n)(\n    input clk,                          // Clock signal\n    input reset_n,                      // Active low reset\n    input sin,                          // Serial input\n    input shift_en,                     // Shift enable signal\n    output reg done,                    // Done signal indicating completion of shift\n    output reg [WIDTH-1:0] parallel_out // Parallel output\n);\n    \n    localparam COUNT_WIDTH = $clog2(WIDTH); // Calculate width for shift_count\n    \n    reg [COUNT_WIDTH:0] shift_count;        // Parameterized counter to track number of shifts\n    \n   \n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin                                   \n            parallel_out     <= {WIDTH{1'b0}};                \n            done             <= 1'b0;                         \n            shift_count      <= {COUNT_WIDTH{1'b0}};          \n        end else begin\n            if (shift_en) begin\n                if (SHIFT_DIRECTION) begin\n                    parallel_out    <= {parallel_out[WIDTH-2:0], sin}; \n                end else begin\n                    parallel_out    <= {sin, parallel_out[WIDTH-1:1]}; \n                end\n                shift_count   <= shift_count + 1;                      \n            end\n            \n            if (shift_count == (WIDTH - 1)) begin\n                done         <= 1'b1;                                 \n                shift_count  <= {COUNT_WIDTH{1'b0}};                  \n            end else begin\n                done         <= 1'b0;                                  \n            end\n        end\n    end \n\nendmodule\n\nmodule onebit_ecc #(\n    parameter DATA_WIDTH = 4,                                  // Width of the data input\n    parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1) // Encoded width\n)(\n    input [DATA_WIDTH-1:0] data_in,                     // Input data\n    output reg [CODE_WIDTH-1:0] encoded,                // Encoded output\n    input [CODE_WIDTH-1:0] received,                    // Received encoded data\n    output reg [DATA_WIDTH-1:0] data_out,               // Corrected output\n    output reg error_detected,                          // Error detected flag\n    output reg error_corrected                          // Error corrected flag\n);\n\n    localparam PARITY_BITS = CODE_WIDTH - DATA_WIDTH;   // Number of parity bits\n\n    reg [PARITY_BITS-1:0] syndrome;                     // Syndrome for error detection\n    reg [CODE_WIDTH-1:0] corrected_data;                // Corrected received data\n\n\n    integer idx_i, idx_j, idx_k;\n    integer idx_m, idx_n;\n    integer idx_p, idx_q;\n\n\n    always @(*) begin\n        encoded = 0;\n        idx_k = 0;\n\n\n        for (idx_i = 0; idx_i < CODE_WIDTH; idx_i = idx_i + 1) begin\n            if ((idx_i + 1) & (idx_i)) begin\n                encoded[idx_i] = data_in[idx_k];\n                idx_k = idx_k + 1;\n            end\n        end\n\n\n        for (idx_i = 0; idx_i < PARITY_BITS; idx_i = idx_i + 1) begin\n            encoded[(1 << idx_i) - 1] = 0; \n            for (idx_j = 0; idx_j < CODE_WIDTH; idx_j = idx_j + 1) begin\n                if (((idx_j + 1) & (1 << idx_i)) && ((idx_j + 1) != (1 << idx_i))) begin\n                    encoded[(1 << idx_i) - 1] = encoded[(1 << idx_i) - 1] ^ encoded[idx_j];\n                end\n            end\n        end\n    end\n\n\n    always @(*) begin\n        syndrome = 0; \n        for (idx_m = 0; idx_m < PARITY_BITS; idx_m = idx_m + 1) begin\n            for (idx_n = 0; idx_n < CODE_WIDTH; idx_n = idx_n + 1) begin\n                if ((idx_n + 1) & (1 << idx_m)) begin\n                    syndrome[idx_m] = syndrome[idx_m] ^ received[idx_n];\n                end\n            end\n        end\n    end\n\n  \n    always @(*) begin\n        error_detected = |syndrome; \n    end\n\n    \n    always @(*) begin\n        corrected_data = received;\n        if (error_detected) begin\n            corrected_data[syndrome - 1] = ~corrected_data[syndrome - 1]; \n        end\n    end\n\n \n    always @(*) begin\n        idx_q = 0;\n        for (idx_p = 0; idx_p < CODE_WIDTH; idx_p = idx_p + 1) begin\n            if ((idx_p + 1) & (idx_p)) begin\n                data_out[idx_q] = corrected_data[idx_p];\n                idx_q = idx_q + 1;\n            end\n        end\n    end\n\n\n    always @(*) begin\n        error_corrected = error_detected; \n    end\nendmodule\n\nmodule crc_generator #(\n    parameter DATA_WIDTH = 8,        // Width of input data\n    parameter CRC_WIDTH = 4,        // Width of CRC output\n    parameter POLY = 4'b1101        // Polynomial for CRC\n) (\n    input [DATA_WIDTH-1:0] data_in, // Input data\n    input clk,                      // Clock signal\n    input rst,                      // Reset signal\n    output reg [CRC_WIDTH-1:0] crc_out // CRC output\n);\n    integer i;                     \n    reg [CRC_WIDTH-1:0] crc_reg;  \n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            crc_out <= 0;           \n        end else begin\n            crc_reg = 0;           \n            for (i = DATA_WIDTH - 1; i >= 0; i = i - 1) begin\n                if (crc_reg[CRC_WIDTH-1] ^ data_in[i]) begin\n                    crc_reg = (crc_reg << 1) ^ POLY; \n                end else begin\n                    crc_reg = crc_reg << 1; \n                end\n            end\n            crc_out <= crc_reg;    \n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/serial_in_parallel_out_8bit.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/serial_in_parallel_out_8bit.sv\nTOPLEVEL        = sipo_top\nMODULE          = test_sipo\nPYTHONPATH      = /src\nHASH            = 02c22dc1ac84dead028a8de3f1d20f9a1fcf1056s\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n\nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_sipo.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge,FallingEdge, Timer\nimport harness_library as hrs_lb\nimport random\nimport math\n\n\n@cocotb.test()\nasync def test_sipo(dut):\n    # Randomly select data width and shift direction for this test iteration\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n    SHIFT_DIRECTION = int(dut.SHIFT_DIRECTION.value)\n    CODE_WIDTH = int(dut.CODE_WIDTH.value)\n    CRC_WIDTH = int(dut.CRC_WIDTH.value)\n    POLY = int(dut.POLY.value)\n    \n\n    # Start the clock with a 10ns time period\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n\n    dut.shift_en.value = 0                          # Disable shift initially\n    dut.done.value = 0                              # Initialize the done signal to 0\n    sin_list = []   \n    sin_list_1 = []                  \n    cocotb.log.info(f\" SHIFT_DIRECTION = {SHIFT_DIRECTION}, data_wd = {DATA_WIDTH}\")\n    # Shift data_wd bits into the shift register\n    print(f\"---------------------------------------------------------------------------------------------------------------------------------------------------------\")\n    print(f\"-----------------------------------------------NORMAL OPERATION ----------------------------------------------------------------------------------------\")\n    print(f\"---------------------------------------------------------------------------------------------------------------------------------------------------------\")\n    for i in range(DATA_WIDTH):\n        sin = random.randint(0, 1)                  # Generate a random bit to shift in (0 or 1)\n        dut.shift_en.value = 1                      # Enable the shift and set the serial input bit\n        dut.serial_in.value = sin          \n        sin_list.append(sin)                        # Store the shifted bit for comparison later\n\n        parallel_out = dut.uut_sipo.parallel_out.value       # Capture parallel output\n        parallel_out_1 = int(dut.uut_sipo.parallel_out.value)  \n        # Define the formatter to control the width of different log fields\n    # For example: timestamp (15 characters), logger name (15 characters), log level (8 characters), message (50 characters)\n        #cocotb.logging.Formatter('%(parallel_out)-15s')\n\n        cocotb.log.info(f\" Shifted sin = {sin}, parallel_out = {(parallel_out)} \")\n\n\n        if i == DATA_WIDTH - 1:\n            dut.done.value = 1                      # Indicate completion after last shift\n            cocotb.log.info(f\" done :{dut.done.value}\")\n        else:\n            dut.done.value = 0                      # Done signal is low until the last shift\n            cocotb.log.info(f\" done :{dut.done.value}\")\n\n        await FallingEdge(dut.clk)                   # Wait for clock rising edge \n    #await RisingEdge(dut.clk)\n    #cocotb.log.info(f\" Shifted_sin = invalid, parallel_out = {(parallel_out)} \")\n    \n\n    if i == DATA_WIDTH - 1:\n        dut.done.value = 1\n        cocotb.log.info(f\" done :{dut.done.value}\")\n    else:\n        dut.done.value = 0\n        cocotb.log.info(f\" done :{dut.done.value}\")\n    # Wait for the final clock cycle to allow for the last shift\n    await RisingEdge(dut.clk)\n\n    # Capture the final parallel output\n    parallel_out = dut.uut_sipo.parallel_out.value\n\n    # expected behavior based on shift direction\n    if SHIFT_DIRECTION == 1:\n        # Shift left, capture parallel_out directly\n        expected_output = int(\"\".join(map(str, sin_list)), 2)\n        cocotb.log.info(f\"Shift left mode, Expected output: {expected_output}, Parallel output: {int(parallel_out)}\")\n    else:\n        # Shift right, reverse the bit order of parallel_out\n        original_parallel_out = format(int(parallel_out), f'0{DATA_WIDTH}b')  # Convert to binary string\n        reversed_parallel_out = int(original_parallel_out[::1], 2)  # Reverse the bit order\n        expected_output = int(\"\".join(map(str, sin_list[::-1])), 2)\n        cocotb.log.info(f\" Shift right mode, Expected output: {expected_output}, Reversed parallel output: {reversed_parallel_out}\")\n    \n    # Compare the parallel output with the expected output\n    \n    if SHIFT_DIRECTION == 1:\n        assert int(parallel_out) == expected_output, f\"Test failed: Expected {expected_output}, got {int(parallel_out)}\"\n    else:\n        assert reversed_parallel_out == expected_output, f\"Test failed: Expected {expected_output}, got {reversed_parallel_out}\" \n\n\n    # Final check for done signal - it should be high after the last shift\n    assert dut.done.value == 1, \"Test failed: 'done' signal was not high after the last bit shift.\"\n\n    ecc_encoded = int(dut.encoded.value)\n    dut.received.value = ecc_encoded\n    await RisingEdge(dut.clk)\n    expected_crc = compute_expected_crc(parallel_out_1, DATA_WIDTH, CRC_WIDTH, POLY)\n    dut.received_crc.value = expected_crc\n    cocotb.log.info(f\" parallel_out = {int(parallel_out)}, ecc_encoded = {ecc_encoded}, received_ecc ={int(dut.received.value)}, data_out = {int(dut.data_out.value)}, crc_in = {int(dut.crc_gen.data_in.value)} \")\n    crc_out = int(dut.crc_out.value)\n    await RisingEdge(dut.clk)\n    cocotb.log.info(f\" got_crc_out = {crc_out},received_crc = {int(dut.received_crc.value)},expected_crc = {int(expected_crc)} , crc_error = {int(crc_out != expected_crc) }\")\n    assert expected_crc == crc_out, f\" TEST FAILED:: expected_crc = {expected_crc}, got_crc = {crc_out}\"\n    assert crc_out == dut.received_crc.value, f\" TEST failed::got_crc_out = {crc_out},received_crc = {int(dut.received_crc.value)}\" \n    await RisingEdge(dut.clk)\n    print(f\"---------------------------------------------------------------------------------------------------------------------------------------------------------\")\n    print(f\"--------------------------------------------------------INJECT SINGLE BIT ERROR -------------------------------------------------------------------------\")\n    print(f\"---------------------------------------------------------------------------------------------------------------------------------------------------------\")\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n    cocotb.log.info(f\" SHIFT_DIRECTION = {SHIFT_DIRECTION}, data_wd = {DATA_WIDTH}\")\n    for i in range(DATA_WIDTH):\n        sin = random.randint(0, 1)                  # Generate a random bit to shift in (0 or 1)\n        dut.shift_en.value = 1                      # Enable the shift and set the serial input bit\n        dut.serial_in.value = sin          \n        sin_list_1.append(sin)                        # Store the shifted bit for comparison later\n\n        parallel_out = dut.uut_sipo.parallel_out.value       # Capture parallel output\n\n        # Define the formatter to control the width of different log fields\n    # For example: timestamp (15 characters), logger name (15 characters), log level (8 characters), message (50 characters)\n        #cocotb.logging.Formatter('%(parallel_out)-15s')\n\n        cocotb.log.info(f\" Shifted sin = {sin}, parallel_out = {(parallel_out)} \")\n\n\n        if i == DATA_WIDTH - 1:\n            dut.done.value = 1                      # Indicate completion after last shift\n            cocotb.log.info(f\" done :{dut.done.value}\")\n        else:\n            dut.done.value = 0                      # Done signal is low until the last shift\n            cocotb.log.info(f\" done :{dut.done.value}\")\n\n        await FallingEdge(dut.clk)                   # Wait for clock rising edge \n        parallel_out = dut.uut_sipo.parallel_out.value\n        parallel_out_1 = int(dut.uut_sipo.parallel_out.value)\n\n    if i == DATA_WIDTH - 1:\n        dut.done.value = 1\n        cocotb.log.info(f\" done :{dut.done.value}\")\n    else:\n        dut.done.value = 0\n        cocotb.log.info(f\" done :{dut.done.value}\")\n    # Wait for the final clock cycle to allow for the last shift\n    await RisingEdge(dut.clk)\n\n    # Capture the final parallel output\n    \n\n    # expected behavior based on shift direction\n    if SHIFT_DIRECTION == 1:\n        # Shift left, capture parallel_out directly\n        expected_output = int(\"\".join(map(str, sin_list_1)), 2)\n        cocotb.log.info(f\"Shift left mode, Expected output: {expected_output}, Parallel output: {int(parallel_out)}\")\n    else:\n        # Shift right, reverse the bit order of parallel_out\n        original_parallel_out = format(int(parallel_out), f'0{DATA_WIDTH}b')  # Convert to binary string\n        reversed_parallel_out = int(original_parallel_out[::1], 2)  # Reverse the bit order\n        expected_output = int(\"\".join(map(str, sin_list_1[::-1])), 2)\n        cocotb.log.info(f\" Shift right mode, Expected output: {expected_output}, Reversed parallel output: {reversed_parallel_out}\")\n    \n    # Compare the parallel output with the expected output\n\n    if SHIFT_DIRECTION == 1:\n        assert int(parallel_out) == expected_output, f\"Test failed: Expected {expected_output}, got {int(parallel_out)}\"\n    else:\n        assert reversed_parallel_out == expected_output, f\"Test failed: Expected {expected_output}, got {reversed_parallel_out}\"\n\n\n    # Final check for done signal - it should be high after the last shift\n    assert dut.done.value == 1, \"Test failed: 'done' signal was not high after the last bit shift.\"\n\n    ecc_encoded = int(dut.encoded.value)\n    ecc_encoded_1= (dut.encoded.value)\n    received_ecc = int(dut.encoded.value)\n    error_bit = random.randint(0, DATA_WIDTH + math.ceil(math.log2(DATA_WIDTH)) - 1)\n    received_ecc ^= (1 << error_bit)  # Flip the error bit\n    dut.received.value = received_ecc\n    corrected_data, corrected_ecc, error_detected, error_position = correct_ecc(received_ecc, DATA_WIDTH)\n    \n    await RisingEdge(dut.clk)\n    cocotb.log.info(f\" DUT::parallel_out = {int(parallel_out)}, ecc_encoded = {ecc_encoded_1}, received_ecc ={(dut.received.value)}, data_out = {int(dut.data_out.value)}, error_position from LSB = {error_bit}, error_corrected = {dut.error_corrected.value}, error_detected = {dut.error_detected.value},crc_in = {int(dut.crc_gen.data_in.value)} \")\n    cocotb.log.info(f\" EXPECTED:: corrected_data = {corrected_data}, corrected_ecc = {corrected_ecc}, error_detected = {int(error_detected)}, error_position from LSB = {error_position} \")\n    expected_crc = compute_expected_crc(parallel_out_1, DATA_WIDTH, CRC_WIDTH, POLY)\n    dut.received_crc.value = expected_crc\n    assert ecc_encoded == corrected_ecc, f\" TEST FAILE:: got_ecc_encoded = {ecc_encoded}, expected_corrected_ecc = {corrected_ecc} \"\n    assert error_detected == dut.error_detected.value, f\" expected_error_detected = {error_detected},got_error_detected = {dut.error_detected.value}  \"\n    if error_detected:\n        assert error_position == error_bit, f\"expected_error_detected = {error_position}, got_error_detected = {error_bit}\"\n    await RisingEdge(dut.clk)\n    cocotb.log.info(f\" got_crc_out = {int(dut.crc_out.value)},received_crc = { int(dut.received_crc.value)}, expected_crc = {int(expected_crc)}, crc_error = {int(dut.crc_error.value)} \")\n    assert expected_crc == int(dut.crc_out.value), f\" TEST FAILED:: expected_crc = {expected_crc}, got_crc = {int(dut.crc_out.value)}\"\n    assert dut.crc_out.value == dut.received_crc.value, f\" test failed:: got_crc_out = {int(dut.crc_out.value)},received_crc = { int(dut.received_crc.value)}\"\n    await RisingEdge(dut.clk)\n    print(f\"---------------------------------------------------------------------------------------------------------------------------------------------------------\")\n\ndef correct_ecc(ecc_in, data_wd):\n    parity_bits_count = math.ceil(math.log2(data_wd + 1)) + 1\n    total_bits = data_wd + parity_bits_count\n    ecc_bits = [int(bit) for bit in f\"{ecc_in:0{total_bits}b}\"[::-1]]\n\n    syndrome = 0\n    for i in range(parity_bits_count):\n        parity_pos = 2**i\n        parity_value = 0\n        for j in range(1, total_bits + 1):\n            if j & parity_pos:\n                parity_value ^= ecc_bits[j - 1]\n        syndrome |= (parity_value << i)\n\n    error_detected = syndrome != 0\n    error_position = syndrome - 1 if syndrome > 0 else -1\n\n    if error_detected and 0 <= error_position < len(ecc_bits):\n        ecc_bits[error_position] ^= 1\n\n    corrected_data_bits = [ecc_bits[i - 1] for i in range(1, total_bits + 1) if not (i & (i - 1)) == 0]\n    corrected_data = int(\"\".join(map(str, corrected_data_bits[::-1])), 2)\n    corrected_ecc = int(\"\".join(map(str, ecc_bits[::-1])), 2)\n\n    return corrected_data, corrected_ecc, error_detected, error_position\n\ndef compute_expected_crc(data, data_width, crc_width, poly):\n    crc = 0  # Initialize the CRC register\n    #print(f\" data_in = {data}, data_wd = {data_width}, crc_width = {crc_width}, poly = {poly} \")\n    for i in range(data_width - 1, -1, -1):  # Iterate through the data bits\n        msb = (crc >> (crc_width - 1)) & 1  # Get the MSB of the current CRC\n        data_bit = (data >> i) & 1  # Get the current data bit\n        \n        if msb ^ data_bit:  # If XOR of MSB and data bit is 1\n            crc = ((crc << 1) ^ poly) & ((1 << crc_width) - 1)  # XOR with POLY\n        else:\n            crc = (crc << 1) & ((1 << crc_width) - 1)  # Just shift left\n    \n    return crc  # Return the computed CRC"}}}
{"id": "cvdp_copilot_sorter_0038", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `sorting_engine` module. The assertions should ensure that the module performs sorting correctly with the expected latency.\n\n## **RTL Design Overview**  \n`sorting_engine` receives an array of unsigned integers as input, sorts them using the bubble sort algorithm, and then provides the sorted array as output. The module is driven by a clock, has a reset mechanism, and provides a control signal to indicate when sorting is complete. Sorting arranges the elements of the array in ascending order, such that the smallest element is at index 0 and the largest element is at index N\u22121.\n\nBubble sort is a straightforward sorting algorithm that works by repeatedly comparing adjacent elements in an array and swapping them if they are out of order. Through multiple passes over the array, larger values \"bubble\" up toward the end of the array, while smaller values move toward the beginning. Eventually, after enough passes, the entire array becomes sorted. For this implementation perform (N)*(N-1) passes to sort the array of N elements. \n\n### **Key Components of the Module**       \n\n**Parameters**\n- `N`  (Default is 8, Greater than 0): Number of elements to sort\n- `WIDTH`(Default is 8, Greater than 0): Bit-width of each input element\n\n**Port List**\n| Port Name               | Direction | Width          | Description                                                                                                                                                                                                                                                              |\n|-------------------------|-----------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `clk`                   | input     | 1 bit          | Main clock input. All operations occur on the rising edge of this signal.                                                                                                                                                                                                |\n| `rst`                   | input     | 1 bit          | Active high, asynchronous reset. When asserted, resets the internal state machine and registers to their initial states.                                                                                                                                                 |\n| `start`                 | input     | 1 bit          | Active high, pulse start signal to indicate that the input data is valid and that sorting should begin on the next clock cycle.                                                                                                                                          |\n| `[N*WIDTH-1:0] in_data` | input     | N * WIDTH bits | Input data bus containing the entire unsorted array. Each element has WIDTH bits, and there are N elements.                                                                                                                                                              |\n| `done`                  | output    | 1 bit          | Active high pulse, asserted for 1 clock cycle when the sorting is complete, indicating that `out_data` is now valid and stable. It will be set to 0 in case of a reset.                                                                                                  |\n| `[N*WIDTH-1:0] out_data`| output    | N * WIDTH bits | Output data bus containing the sorted array. This is to be left uninitialized at reset and updated only when sorting a valid input is complete. Valid once `done` is asserted, and maintains previous values until the update from the next sorting operation completes. |\n\nThe state machine has `IDLE`, `SORTING`, and `DONE` states. The FSM transitions from `IDLE` to `SORTING` when the start signal is asserted, cycles through the comparisons and swaps, and eventually moves to `DONE` when sorting is complete.\n\n- **Latency and Timing**: Each comparison and potential swap takes one clock cycle. Bubble sort in hardware will, by default, consume multiple cycles, as it effectively simulates the step-by-step iterative nature of the algorithm. The done signal is asserted only after the last pass is complete. Latency is equal to (N)*(N-1)+2 for an array with `N` elements.\n  \n- **Output**: Once the sorting finishes, the sorted array is presented at the output port. This involves placing the sorted values back onto an output bus.\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Correct sorted output:** The output data `out_data` should contain correctly sorted data after the sorting operation is completed.\n- **Stable output:** Ensure that the output data is stable once the sorting operation is completed until the next sorting operation completes and the result is updated. \n- **Correct latency:** Ensure that the `done` is asserted indicating the sorting operation is completed within the expected latency.  \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // Internal registers to hold the array\n    reg [WIDTH-1:0] array [0:N-1];\n\n    // FSM states\n    localparam IDLE    = 2'd0;\n    localparam SORTING = 2'd1;\n    localparam DONE    = 2'd2;\n\n    reg [1:0]  state, next_state;\n\n    // Variables for bubble sort indexing\n    reg [$clog2(N)-1:0] i;  // Outer loop index\n    reg [$clog2(N)-1:0] j;  // Inner loop index\n\n    // Wires for comparison and swap\n    wire [WIDTH-1:0] val_j;\n    wire [WIDTH-1:0] val_j1;\n\n    assign val_j  = array[j];\n    assign val_j1 = array[j+1];\n\n    // FSM: Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = SORTING;\n            end\n            SORTING: begin\n                // Transition to DONE once all passes are complete\n                if (i == (N-1) && j == (N-2))\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM: Output and counter updates\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            i <= 0;\n            j <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (start) begin\n                        // Load the array from in_data\n                        for (int k = 0; k < N; k = k + 1) begin\n                            array[k] <= in_data[(k+1)*WIDTH-1 -: WIDTH];\n                        end\n                        i <= 0;\n                        j <= 0;\n                    end\n                end\n\n                SORTING: begin\n                    // Perform a single comparison and swap if needed\n                    if (val_j > val_j1) begin\n                        array[j]   <= val_j1;\n                        array[j+1] <= val_j;\n                    end\n\n                    // Update j\n                    if (j == N-2) begin\n                        // One pass completed, increment i\n                        j <= 0;\n                        i <= i + 1;\n                    end else begin\n                        j <= j + 1;\n                    end\n                end\n\n                DONE: begin\n                    // Sorting complete\n                    done <= 1;\n                    // Output the sorted data\n                    for (int m = 0; m < N; m = m + 1) begin\n                        out_data[(m+1)*WIDTH-1 -: WIDTH] <= array[m];\n                    end\n                end\n                default: begin\n                end\n            endcase\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sorting_engine.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sorting_engine.sv\nTOPLEVEL        = sorting_engine\nMODULE          = test_sorting_engine\nPYTHONPATH      = /src\nHASH            = 38-rtl-assertion-bubble-sort", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.parametrize(\"WIDTH\", [random.randint(4, 32)])\n@pytest.mark.parametrize(\"N\", [random.randint(4, 32)])\ndef test_runner(WIDTH,N):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    if N > 2**WIDTH-1:\n        N = 2**WIDTH-1\n    parameters = { \"WIDTH\": WIDTH, \"N\": N }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# if __name__ == \"__main__\":\n#     test_simulate()", "src/test_sorting_engine.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n@cocotb.test()\nasync def test_sorter_dynamic_latency(dut):\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n    clk_period = 10  # ns\n    random.seed(0)  # For reproducibility\n\n    async def clock():\n        while True:\n            dut.clk.value = 0\n            await Timer(clk_period/2, units='ns')\n            dut.clk.value = 1\n            await Timer(clk_period/2, units='ns')\n\n    cocotb.start_soon(clock())\n\n    await reset_dut(dut, 5)\n    dut.start.value = 0\n\n    async def run_test_case(name, input_array):\n        cocotb.log.info(f\"Running Test: {name}\")\n        packed_input = 0\n        for idx, val in enumerate(input_array):\n            packed_input |= (val << (idx * WIDTH))\n        dut.in_data.value = packed_input\n\n        expected_steps = simulate_bubble_sort_steps(input_array, no_early_termination=True) + 2\n\n        await RisingEdge(dut.clk)\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        cycle_count = 0\n        while True:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n            if dut.done.value == 1:\n                break\n\n        out_data_val = int(dut.out_data.value)\n        output_array = [ (out_data_val >> (i * WIDTH)) & ((1 << WIDTH) - 1) for i in range(N)]\n        expected_output = sorted(input_array)\n\n        assert output_array == expected_output, f\"[{name}] Output incorrect. Got: {output_array}, Expected: {expected_output}\"\n        assert cycle_count == expected_steps, f\"[{name}] Latency mismatch. Got {cycle_count}, Expected {expected_steps}\"\n        cocotb.log.info(f\"Input {input_array}.\")\n        cocotb.log.info(f\"Output {output_array}.\")\n        cocotb.log.info(f\"Expected output {expected_output}.\")\n        cocotb.log.info(f\"Test {name} passed.\")\n\n    # Corner Cases\n    if N == 1:\n        await run_test_case(\"Single Element\", [10])\n\n    await run_test_case(\"Already Sorted\", list(range(N)))\n    await run_test_case(\"Reverse Sorted\", list(range(N-1, -1, -1)))\n    await run_test_case(\"All Duplicates\", [5]*N)\n    await run_test_case(\"All Max Values\", [(1 << WIDTH) - 1]*N)\n    await run_test_case(\"All Min Values\", [0]*N)\n    # Mixed min/max pattern\n    await run_test_case(\"Min-Max Alternating\", [0 if i % 2 == 0 else (1 << WIDTH)-1 for i in range(N)])\n\n    # Partial sorted (first half sorted, second half random)\n    half_sorted = list(range(N//2)) + [random.randint(0, (1 << WIDTH)-1) for _ in range(N - N//2)]\n    await run_test_case(\"Half Sorted\", half_sorted)\n\n    # Stress Testing with multiple random arrays\n    # Increase the count for more thorough stress tests\n    stress_test_count = 20\n    for idx in range(stress_test_count):\n        arr = [random.randint(0, (1 << WIDTH)-1) for _ in range(N)]\n        await run_test_case(f\"Random {idx}\", arr)\n\n    cocotb.log.info(\"All tests completed successfully!\")\n\n\ndef simulate_bubble_sort_steps(arr, no_early_termination=False):\n    N = len(arr)\n    # Given the DUT does no early termination, it always does (N-1)*(N-1) steps.\n    # If no_early_termination is True, ignore input and return full passes.\n    if no_early_termination:\n        return (N)*(N-1)\n\n    # If we were to consider early termination logic, it would go here.\n    return (N)*(N-1)\n\n\nasync def reset_dut(dut, duration):\n    dut.rst.value = 1\n    for _ in range(duration):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n"}}}
{"id": "cvdp_copilot_sorter_0042", "categories": ["cid014", "medium"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `sorting_engine` module. The assertions should ensure that the module accurately implements the Insertion sort algorithm.\n\n## **RTL Design Overview**  \n`sorting_engine` receives an array of unsigned integers as input, sorts them using the Insertion sort algorithm, and then provides the sorted array as output. The module is driven by a clock, has a reset mechanism, and provides a control signal to indicate when sorting is complete. Sorting arranges the elements of the array in ascending order, such that the smallest element is at index 0 and the largest element is at index N\u22121.\n\nInsertion sort iterates, consuming one input element each repetition, and grows a sorted output subarray. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted subarray, and inserts it there. It repeats until no input elements remain. Sorting is typically done in-place, by iterating up the array, and growing the sorted subarray behind it. At each array-position, it checks the value there against the largest value in the sorted subarray (which happens to be next to it, in the previous array-position checked). If larger, it leaves the element in place and moves to the next. If smaller, it finds the correct position within the sorted subarray, shifts all the larger values up to make a space, and inserts into that correct position. The resulting array after k iterations has the property where the first k + 1 entries are sorted (\"+1\" because the first entry is skipped).\n\n\n### **Key Components of the Module**       \n\n**Parameters**\n- `N`  (default is 8, greater than 0): Number of elements to sort\n- `WIDTH`(default is 8, greater than 0): Bit-width of each input element\n\n**Port List**\n| Port Name               | Direction | Width          | Description                                                                                                                                                                                                                                                              |\n|-------------------------|-----------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `clk`                   | input     | 1 bit          | Main clock input. All operations occur on the rising edge of this signal.                                                                                                                                                                                                |\n| `rst`                   | input     | 1 bit          | Active high, asynchronous reset. When asserted, resets the internal state machine and registers to their initial states.                                                                                                                                                 |\n| `start`                 | input     | 1 bit          | Active high, pulse start signal to indicate that the input data is valid and that sorting should begin on the next clock cycle.                                                                                                                                          |\n| `in_data`               | input     | N * WIDTH bits | Input data bus containing the entire unsorted array. Each element has WIDTH bits, and there are N elements.                                                                                                                                                              |\n| `done`                  | output    | 1 bit          | Active high pulse, asserted for 1 clock cycle when the sorting is complete, indicating that `out_data` is now valid and stable. It will be set to 0 in case of a reset.                                                                                                  |\n| `out_data`              | output    | N * WIDTH bits | Output data bus containing the sorted array. This is to be left uninitialized at reset and updated only when sorting a valid input is complete. Valid once `done` is asserted, and maintains previous values until the update from the next sorting operation completes. |\n\nThe state machine has `IDLE`, `SORTING`, and `DONE` states. The FSM transitions from `IDLE` to `SORTING` when the start signal is asserted, cycles through the comparisons and swaps, and eventually moves to `DONE` when sorting is complete.\n\n- **Latency and timing**: Latency for every input pair can vary and the latency distribution should be as described below:\n   - 1 clock cycle to set up the start conditions after the `start` is asserted high.\n   - Following will occur for every element in the array:\n      - 1 clock cycle to access the element in the array to be sorted.\n      - Every shift operation (till the correct spot is found for that element) will take 1 clock cycle.\n      - 1 clock cycle to detect iterations for that element is complete.\n      - Inserting the element at the spot found will take 1 clock cycle.\n   - 1 clock cycle to detect that all elements are sorted.\n   - 1 clock cycle to output the sorted array and assert the `done` signal.\n  \n- **Output**: Once the sorting finishes, the sorted array is presented at the output port. This involves placing the sorted values back onto an output bus.\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Final sorted order in `array` at `DONE`:** Once we enter the `DONE` state, we expect the entire internal array (array[0..N-1]) to be sorted in non-decreasing order.\n- **Partial array sorted after each iteration:** In insertion sort, after completing an iteration, the sub-array should be sorted.\n- **No out-of-bounds write on `array[j+1]`:** During `insert_phase` 1 and 2, ensure `j+1` stays within `[0..N-1]`.\n- **If `j < 0`, then transition to phase 2 next cycle:** In insertion sort, once `j` drops below 0, the design should transition to `insert_phase` 2 (where we insert the key) immediately on the next cycle.\n- **Once `i == N`, next state must be `DONE`** in `SORTING`, if `i == N`, we expect the design to move to `DONE` next cycle.\n- **`key` must stay stable during phase 1 shifting and phase 2:** In insertion sort, `key` is loaded in `insert_phase` 0 and should not change while we are shifting elements in `insert_phase` 1 and 2. This ensures we don\u2019t lose the value to be inserted.\n- **`out_data` must remain stable except in `DONE`:**  Ensure that while not in `DONE`, `out_data` never changes.\n- **`i` never decrements:**  `i` only increments. We ensure it does not accidentally go backward or reset to an unexpected value (except via the `rst` condition)\n- **Shift-then-insert mechanism:** Whenever we remain in `insert_phase` 1 (shifting) and `array[j] > key`, we expect the next cycle to see `array[j+1]` updated with `array[j]`. This ensures the shift is indeed happening. \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // Internal array\n    reg [WIDTH-1:0] array [0:N-1];\n\n    // FSM states\n    localparam IDLE    = 2'd0;\n    localparam SORTING = 2'd1;\n    localparam DONE    = 2'd2;\n\n    reg [1:0] state, next_state;\n\n    // Insertion sort variables\n    integer i;\n    integer j;\n    reg [WIDTH-1:0] key;\n\n    // Insertion sort phases for each i\n    // 0: Initialize key and j\n    // 1: Shift elements greater than key\n    // 2: Insert key\n    reg [1:0] insert_phase;\n\n    // FSM: Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = SORTING;\n            end\n            SORTING: begin\n                // Once i reaches N, sorting is done\n                if (i == N)\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM: main logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state         <= IDLE;\n            done          <= 0;\n            i             <= 0;\n            j             <= 0;\n            key           <= 0;\n            insert_phase  <= 0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (start) begin\n                        // Load array from in_data\n                        for (int k = 0; k < N; k = k + 1) begin\n                            array[k] <= in_data[(k+1)*WIDTH-1 -: WIDTH];\n                        end\n                        i <= 1; // Start insertion sort from index 1\n                        j <= 0;\n                        key <= 0;\n                        insert_phase <= 0;\n                    end\n                end\n\n                SORTING: begin\n                    // Perform insertion sort step-by-step\n                    case (insert_phase)\n                        0: begin\n                            // Phase 0: Setup for inserting array[i]\n                            if (i < N) begin\n                                key <= array[i];\n                                j <= i - 1;\n                                insert_phase <= 1;\n                            end\n                            // If i == N, sorting complete, next cycle moves to DONE\n                        end\n\n                        1: begin\n                            // Phase 1: Shift elements to the right until the correct spot is found\n                            if (j >= 0 && array[j] > key) begin\n                                array[j+1] <= array[j];\n                                j <= j - 1;\n                            end else begin\n                                // We found the spot (or j < 0)\n                                insert_phase <= 2;\n                            end\n                        end\n\n                        2: begin\n                            // Phase 2: Insert the key at array[j+1]\n                            array[j+1] <= key;\n                            i <= i + 1;\n                            insert_phase <= 0; \n                        end\n\n                        default: insert_phase <= 0;\n                    endcase\n                end\n\n                DONE: begin\n                    // Sorting complete, output the result\n                    done <= 1;\n                    for (int m = 0; m < N; m = m + 1) begin\n                        out_data[(m+1)*WIDTH-1 -: WIDTH] <= array[m];\n                    end\n                end\n\n                default: begin\n                    // Should not get here\n                end\n            endcase\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sorting_engine.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sorting_engine.sv\nTOPLEVEL        = sorting_engine\nMODULE          = test_sorting_engine\nPYTHONPATH      = /src\nHASH            = 42-rtl-assertion-insertion-sort", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\nvalid_params = []\nvalid_params.append((8,8))\n\n@pytest.mark.parametrize(\"WIDTH, N\", valid_params)\ndef test_runner(WIDTH,N):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    parameters = { \"WIDTH\": WIDTH, \"N\": N }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# if __name__ == \"__main__\":\n#     test_simulate()\n", "src/test_sorting_engine.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\nimport random\n\nasync def reset_dut(dut):\n    dut.rst.value = 1\n    dut.start.value = 0\n    dut.in_data.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\ndef expected_insertion_sort_operations(arr):\n    \"\"\"\n    Compute the expected \"latency\" in terms of operations for an insertion sort on 'arr'.\n    We'll count the number of comparisons made during a standard insertion sort.\n    \"\"\"\n    # Make a copy to avoid modifying the original array\n    data = arr[:]\n    operations = 0\n    for i in range(1, len(data)):\n        operations += 1\n        key = data[i]\n        j = i - 1\n\n        # In insertion sort, for each element, we compare with previous elements until we find the spot.\n        # Count a comparison for each j we test. If we have to move past array[j], that's another comparison.\n        while j >= 0 and data[j] > key:\n            operations += 1  # comparison\n            data[j+1] = data[j]\n            j -= 1\n        # Even when we break out of loop, we've done one more comparison that fails the condition.\n        operations += 1  # comparison to exit the loop\n        data[j+1] = key\n    operations += (len(data) +2)\n    return operations\n\nasync def run_sort_test(dut, input_array, N, WIDTH):\n    \"\"\"\n    Helper function to run a sort test with a given input_array.\n    Returns the number of cycles it took to complete sorting.\n    Also compares actual latency with expected operations count.\n    \"\"\"\n    # Reset the DUT before each test\n    await reset_dut(dut)\n\n    # Pack the input array into a single integer\n    in_val = 0\n    for i, val in enumerate(input_array):\n        in_val |= (val << (i * WIDTH))\n\n    dut._log.info(f\"Testing with input: {input_array}\")\n    dut.in_data.value = in_val\n\n    # Start sorting\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure how many cycles it takes until done\n    cycles = 0\n    while True:\n        #print(\"State = \",dut.state.value)\n        #print(\"insert_phase = \",dut.insert_phase.value)\n        #print(\"i = \",dut.i.value)\n        #print(*dut.array.value)\n        await RisingEdge(dut.clk)\n        cycles += 1\n        if dut.done.value == 1:\n            break\n\n    # Once done is high, read out the sorted result\n    sorted_val = dut.out_data.value\n    output_array = []\n    for i in range(N):\n        chunk = (sorted_val >> (i * WIDTH)) & ((1 << WIDTH) - 1)\n        output_array.append(chunk)\n\n    dut._log.info(f\"Sorted output after {cycles} cycles: {output_array}\")\n\n    # Check correctness\n    expected = sorted(input_array)\n    assert output_array == expected, f\"DUT output {output_array} does not match expected {expected}\"\n    dut._log.info(\"Output is correctly sorted.\")\n\n    # Compute expected operations for a standard insertion sort on input_array\n    exp_ops = expected_insertion_sort_operations(input_array)\n    assert exp_ops == cycles, f\"Expected latency is not equal to actual latency\"\n\n    return cycles\n\n@cocotb.test()\nasync def test_sorting_engine(dut):\n    \"\"\"Test the insertion sort engine with various cases and compare actual latency to expected operations.\"\"\"\n    # Parameters (these should match the DUT)\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    # Start a clock\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Test cases\n    max_val = (1 << WIDTH) - 1\n\n    test_cases = [\n        [i for i in range(N)],  # ascending\n        [N - 1 - i for i in range(N)],  # descending\n        [5] * N,  # all same\n        [0] * N,  # all minimum\n        [max_val] * N,  # all maximum\n        [0, max_val] + [random.randint(0, max_val) for _ in range(N - 2)]  # mixed\n    ]\n\n    # Add multiple random tests\n    for _ in range(5):\n        test_cases.append([random.randint(0, max_val) for _ in range(N)])\n\n    # Run all tests\n    for test_input in test_cases:\n        await run_sort_test(dut, test_input, N, WIDTH)\n\n    dut._log.info(\"All tests completed successfully with latency checks against expected insertion sort operations.\")\n"}}}
{"id": "cvdp_copilot_sorter_0045", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `sorting_engine` module. The assertions should ensure that the module accurately implements the Brick sort algorithm.\n\n## **RTL Design Overview**  \n**Brick Sort** (also known as **Odd-Even Sort**) is a simple comparison-based sorting algorithm that repeatedly alternates between comparing/swapping all \u201codd-even\u201d index pairs and all \u201ceven-odd\u201d index pairs. After each pass of pairwise comparisons, larger elements gradually \u201cbubble\u201d to the right and smaller elements \u201cbubble\u201d to the left, ensuring that enough iterations will fully sort the array. On **even-numbered passes**, the module compares and, if needed, swaps **even-odd** index pairs ((0,1), (2,3)) (compares elements at even-indexed positions with their immediate next neighbors). On **odd-numbered passes**, it compares and, if needed, swaps **odd-even** index pairs ((1,2), (3,4)) (compares elements at odd-indexed positions with their immediate next neighbors). Each pass is processed in multiple clock cycles: each clock cycle steps through the relevant pairs, performing one compare-and-swap per cycle. After finishing \\(N\\) passes, the array is guaranteed to be sorted.\n\n### **Key Components of the Module**       \n\n**Parameters**\n- `N`  (Default is 8, Greater than 0): Number of elements to sort\n- `WIDTH`(Default is 8, Greater than 0): Bit-width of each input element\n\n**Port List**\n| Port Name               | Direction | Width          | Description                                                                                                                                                                                                                                                              |\n|-------------------------|-----------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `clk`                   | input     | 1 bit          | Main clock input. All operations occur on the rising edge of this signal.                                                                                                                                                                                                |\n| `rst`                   | input     | 1 bit          | Active high, asynchronous reset. When asserted, resets the internal state machine and registers to their initial states.                                                                                                                                                 |\n| `start`                 | input     | 1 bit          | Active high, pulse start signal to indicate that the input data is valid and that sorting should begin on the next clock cycle.                                                                                                                                          |\n| `[N*WIDTH-1:0] in_data` | input     | N * WIDTH bits | Input data bus containing the entire unsorted array. Each element has WIDTH bits, and there are N elements.                                                                                                                                                              |\n| `done`                  | output    | 1 bit          | Active high signal, asserted when sorting is complete. `done` remains high until start is deasserted (set to 0), at which point it returns to 0.                                                                                                                         |\n| `[N*WIDTH-1:0] out_data`| output    | N * WIDTH bits | Output data bus containing the sorted array. This is to be left uninitialized at reset and updated only when sorting a valid input is complete. Valid once `done` is asserted, and maintains previous values until the update from the next sorting operation completes. |\n\n- **Output**: Once the sorting finishes, the sorted array is presented at the output port. This involves placing the sorted values back onto an output bus.\n- The brick sort algorithm uses FSM.\n- Assume that all the numbers will be non-negative integers.\n- Assume `N` is an even integer greater than 2.\n---\n\n### Latency Considerations\nTotal latency = (N * (N - 1)) / 2 + 4\nPerforms a single compare-and-swap operation per clock cycle (sequential approach):  \n- 1 clock cycle for moving from `IDLE` state to `LOAD`.\n- **1 clock cycle** to load the data.  \n- Performs **\\(N\\) passes** to completely sort the array.  \n  - Each **even-numbered pass** has N/2 comparisons and swaps.  \n  - Each **odd-numbered pass** has N/2-1 comparisons and swaps.  \n- Each comparison-and-swap takes **1 clock cycle**.\n- **1 clock cycle** to transition to `DONE` state from the `SORT`.\n- **1 clock cycle** to set the output sorted array and assert the `done` signal after sorting is complete.  \n\n**Latency Example:**  \n- \\(N = 4\\), \\(WIDTH = 4\\)  \n- in_data = [0, 1, 2, 3]\n- out_data = [3, 2, 1, 0]  \n- **Latency = 10 clock cycles**  \n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Final sorted order in `array`:** Once we assert the `done` signal, we expect the entire internal array (array[0..N-1]) to be sorted in non-decreasing order.\n- **Sorting latency**: The latency for sorting an input should not exceed the expected latency mentioned above.\n- **'done' pulse assertion**:  The 'done' signal should be asserted as a one-cycle pulse if `start` is low. (It is not held high for multiple cycles unless `start` is also asserted)\n- **No out-of-bounds pair index access**: Confirm the design never attempts to compare-swap an invalid pair index that would exceed N-1.\n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // ----------------------------------------------------------\n    // Internal Parameters and State Encoding\n    // ----------------------------------------------------------\n    localparam IDLE = 2'd0,\n               LOAD = 2'd1,\n               SORT = 2'd2,\n               DONE = 2'd3;\n\n    // ----------------------------------------------------------\n    // Internal Registers\n    // ----------------------------------------------------------\n    reg [1:0]  state, next_state;\n\n    // Store data in a register array for easy swapping\n    reg [WIDTH-1:0] data_array [0:N-1];\n\n    // Pass counter: we will run up to N passes\n    reg [$clog2(N+1)-1:0] pass_cnt;\n\n    // Pair index: on each pass, we compare-swap one pair per clock\n    reg [$clog2(N/2+1)-1:0] pair_idx;\n\n    // We'll compute how many pairs to process in a pass combinationally\n    wire [$clog2(N/2+1)-1:0] pairs_in_this_pass;\n\n    // ----------------------------------------------------------\n    // Combinational Logic for pairs_in_this_pass\n    // ----------------------------------------------------------\n    // For an even N:\n    //   - On even-numbered passes (pass_cnt[0] == 0), we compare (0,1), (2,3), ...\n    //     => that\u2019s N/2 pairs\n    //   - On odd-numbered passes (pass_cnt[0] == 1), we compare (1,2), (3,4), ...\n    //     => that\u2019s (N/2) - 1 pairs\n    //\n    assign pairs_in_this_pass = (pass_cnt[0] == 1'b0) \n                                ? (N/2) \n                                : ( (N/2) > 0 ? (N/2) - 1 : 0 ); // safety check\n\n    // ----------------------------------------------------------\n    // Next-State Logic\n    // ----------------------------------------------------------\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = LOAD;\n            end\n\n            LOAD: begin\n                // After loading input data, go to SORT state\n                next_state = SORT;\n            end\n\n            SORT: begin\n                // Once we've completed N passes, sorting is done\n                if (pass_cnt == N) \n                    next_state = DONE;\n            end\n\n            DONE: begin\n                // Optionally return to IDLE if desired\n                // For a one-shot, we can just stay in DONE unless reset\n                // Here, we return to IDLE if start is deasserted\n                if (!start)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // ----------------------------------------------------------\n    // Sequential State Update\n    // ----------------------------------------------------------\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // ----------------------------------------------------------\n    // Main Control: pass_cnt, pair_idx, and compare-swap\n    // ----------------------------------------------------------\n    integer i;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done      <= 1'b0;\n            pass_cnt  <= 0;\n            pair_idx  <= 0;\n        end\n        else begin\n            case (state)\n\n                //--------------------------------------\n                // IDLE: wait for start, clear signals\n                //--------------------------------------\n                IDLE: begin\n                    done     <= 1'b0;\n                    pass_cnt <= 0;\n                    pair_idx <= 0;\n                end\n\n                //--------------------------------------\n                // LOAD: capture input data into array\n                //--------------------------------------\n                LOAD: begin\n                    // Load all N elements from in_data\n                    for (i = 0; i < N; i = i + 1) begin\n                        data_array[i] <= in_data[i*WIDTH +: WIDTH];\n                    end\n                    // Initialize counters\n                    pass_cnt <= 0;\n                    pair_idx <= 0;\n                end\n\n                //--------------------------------------\n                // SORT: perform Brick Sort passes\n                //--------------------------------------\n                SORT: begin\n                    // Compare-swap the current pair\n                    // Check if we are within the valid pair range\n                    if (pair_idx < pairs_in_this_pass) begin\n                        // Distinguish odd-even pass from even-odd pass\n                        if (pass_cnt[0] == 1'b0) begin\n                            // Odd-even pass => pair = (2*pair_idx, 2*pair_idx+1)\n                            if (data_array[2*pair_idx] > data_array[2*pair_idx+1]) begin\n                                // Swap\n                                {data_array[2*pair_idx], data_array[2*pair_idx+1]} \n                                    <= {data_array[2*pair_idx+1], data_array[2*pair_idx]};\n                            end\n                        end \n                        else begin\n                            // Even-odd pass => pair = (2*pair_idx+1, 2*pair_idx+2)\n                            if ((2*pair_idx+2) < N) begin\n                                if (data_array[2*pair_idx+1] > data_array[2*pair_idx+2]) begin\n                                    // Swap\n                                    {data_array[2*pair_idx+1], data_array[2*pair_idx+2]} \n                                        <= {data_array[2*pair_idx+2], data_array[2*pair_idx+1]};\n                                end\n                            end\n                        end\n                    end\n\n                    // Increment pair_idx or move to next pass\n                    if (pair_idx + 1 == pairs_in_this_pass) begin\n                        // Completed all pairs in this pass -> next pass\n                        pass_cnt <= pass_cnt + 1;\n                        pair_idx <= 0;\n                    end else begin\n                        // Still more pairs to process\n                        pair_idx <= pair_idx + 1;\n                    end\n\n                end // SORT\n\n                //--------------------------------------\n                // DONE: output final data, assert done\n                //--------------------------------------\n                DONE: begin\n                    done <= 1'b1;\n                    // Drive out_data from data_array\n                    for (i = 0; i < N; i = i + 1) begin\n                        out_data[i*WIDTH +: WIDTH] <= data_array[i];\n                    end\n                end\n\n            endcase\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sorting_engine.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sorting_engine.sv\nTOPLEVEL        = sorting_engine\nMODULE          = test_sorting_engine\nPYTHONPATH      = /src\nHASH            = 45-rtl-assertion-brick-sort", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\ntest_space      = [4,8,12,16]\n\n@pytest.mark.parametrize(\"WIDTH\", [random.choice(test_space)])\n@pytest.mark.parametrize(\"N\", [random.choice(test_space)])\ndef test_runner(WIDTH,N):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    parameters = { \"WIDTH\": WIDTH, \"N\": N }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# if __name__ == \"__main__\":\n#     test_simulate()", "src/test_sorting_engine.py": "###############################################################################\n# test_sorting_engine.py\n#\n# Cocotb testbench for the Brick Sort (odd-even sort) RTL module.\n# This version is compatible with older cocotb versions that do not have\n# certain APIs (e.g. cocotb.result.TestSkip, cocotb.utils.get_sim_time).\n###############################################################################\nimport random\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge\n\n\n###############################################################################\n# Utility Functions\n###############################################################################\ndef list_to_bus(values, width):\n    \"\"\"\n    Pack a list of integers into a single integer bus.\n\n    values: list of integers\n    width: bit-width of each integer\n    returns: integer with bits concatenated in [values[0], values[1], ...] order\n    \"\"\"\n    total_value = 0\n    for i, val in enumerate(values):\n        total_value |= (val & ((1 << width) - 1)) << (i * width)\n    return total_value\n\ndef bus_to_list(bus_value, width, n):\n    \"\"\"\n    Unpack a single integer bus into a list of integers.\n\n    bus_value: integer representing concatenated data\n    width: bit-width of each element\n    n: number of elements\n    returns: list of integers extracted from bus_value\n    \"\"\"\n    values = []\n    mask = (1 << width) - 1\n    for i in range(n):\n        chunk = (bus_value >> (i * width)) & mask\n        values.append(chunk)\n    return values\n\nasync def apply_reset(dut, cycles=2):\n    \"\"\"\n    Assert and deassert reset for a given number of clock cycles.\n    \"\"\"\n    dut.rst.value = 1\n    dut.start.value = 0\n    dut.in_data.value = 0\n    for _ in range(cycles):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n\n###############################################################################\n# Tests\n###############################################################################\n@cocotb.test()\nasync def test_basic_sort(dut):\n    \"\"\"\n    Test a simple random set of values and verify the DUT's sorting.\n    Also measure latency (in cycles) between start and done.\n    \"\"\"\n    # Parameters from DUT\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    # Generate clock (10 ns period)\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Apply reset\n    await apply_reset(dut)\n\n    # Prepare random input data\n    input_values = [random.randint(0, (1 << WIDTH) - 1) for _ in range(N)]\n    dut.in_data.value = list_to_bus(input_values, WIDTH)\n\n    # Assert start for one clock cycle\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure cycles until done\n    cycle_count = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle_count += 1\n        if dut.done.value == 1:\n            break\n\n    out_data = dut.out_data.value\n    output_values = bus_to_list(out_data, WIDTH, N)\n\n    # Check correctness\n    ref_sorted = sorted(input_values)\n    assert output_values == ref_sorted, (\n        f\"ERROR: DUT output={output_values} expected={ref_sorted}\"\n    )\n    # Latency check (same approach as above)\n    overhead = 4\n    expected_latency = (N * (N - 1)) // 2 + overhead\n    assert cycle_count == expected_latency, (\n        f\"Actual Latency: {cycle_count} Expected latency {expected_latency} for N={N}\"\n    )\n\n    dut._log.info(f\"[BASIC SORT] Input        : {input_values}\")\n    dut._log.info(f\"[BASIC SORT] DUT Output   : {output_values}\")\n    dut._log.info(f\"[BASIC SORT] Reference    : {ref_sorted}\")\n    dut._log.info(f\"[BASIC SORT] Latency(cycles) = {cycle_count}\")\n\n\n@cocotb.test()\nasync def test_already_sorted(dut):\n    \"\"\"\n    Test the engine with an already sorted array (ascending).\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    #await apply_reset(dut)\n\n    # Already sorted input (0,1,2,...,N-1)\n    input_values = list(range(N))\n    dut.in_data.value = list_to_bus(input_values, WIDTH)\n\n    # Start\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Wait for done\n    while True:\n        await RisingEdge(dut.clk)\n        if dut.done.value == 1:\n            break\n\n    out_data = dut.out_data.value\n    output_values = bus_to_list(out_data, WIDTH, N)\n\n    # Verify\n    assert output_values == input_values, (\n        f\"Sorted test failed, got {output_values}, expected {input_values}\"\n    )\n\n\n@cocotb.test()\nasync def test_reverse_sorted(dut):\n    \"\"\"\n    Test with reverse-sorted data to see if it sorts properly.\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    #await apply_reset(dut)\n\n    # Reverse sorted input (N-1,N-2,...,0)\n    input_values = list(range(N - 1, -1, -1))\n    dut.in_data.value = list_to_bus(input_values, WIDTH)\n\n    # Start\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Wait for done\n    while True:\n        await RisingEdge(dut.clk)\n        if dut.done.value == 1:\n            break\n\n    out_data = dut.out_data.value\n    output_values = bus_to_list(out_data, WIDTH, N)\n    ref_sorted = sorted(input_values)\n\n    assert output_values == ref_sorted, (\n        f\"Reverse sorted test failed, got {output_values}, expected {ref_sorted}\"\n    )\n\n@cocotb.test()\nasync def test_all_equal(dut):\n    \"\"\"\n    Test the engine with all elements equal.\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n    #await apply_reset(dut)\n\n    # All equal\n    val = random.randint(0, (1 << WIDTH) - 1)\n    input_values = [val] * N\n    dut.in_data.value = list_to_bus(input_values, WIDTH)\n\n    # Start\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Wait for done\n    while True:\n        await RisingEdge(dut.clk)\n        if dut.done.value == 1:\n            break\n\n    out_data = dut.out_data.value\n    output_values = bus_to_list(out_data, WIDTH, N)\n\n    assert output_values == input_values, (\n        f\"All equal test failed, got {output_values}, expected {input_values}\"\n    )\n\n@cocotb.test()\nasync def test_random_cases(dut):\n    \"\"\"\n    Perform multiple random test vectors to gain coverage.\n    Measure and report latency for each.\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    NUM_RANDOM_TESTS = 5\n\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    for test_idx in range(NUM_RANDOM_TESTS):\n        # Reset\n        #await apply_reset(dut)\n\n        # Generate random input\n        input_values = [random.randint(0, (1 << WIDTH) - 1) for _ in range(N)]\n        dut.in_data.value = list_to_bus(input_values, WIDTH)\n\n        # Start\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        # Count cycles until done\n        cycle_count = 0\n        while True:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n            if dut.done.value == 1:\n                break\n\n        out_data = dut.out_data.value\n        output_values = bus_to_list(out_data, WIDTH, N)\n        ref_sorted = sorted(input_values)\n\n        assert output_values == ref_sorted, (\n            f\"[RANDOM {test_idx}] got {output_values}, expected {ref_sorted}\"\n        )\n        \n        # Latency check (same approach as above)\n        overhead = 4\n        expected_latency = (N * (N - 1)) // 2 + overhead\n        assert cycle_count == expected_latency, (\n            f\"[RANDOM {test_idx}] Actual Latency: {cycle_count} Expected latency {expected_latency} for N={N}\"\n        )\n\n        dut._log.info(f\"[RANDOM {test_idx}] Input = {input_values}\")\n        dut._log.info(f\"[RANDOM {test_idx}] Output = {output_values}\")\n        dut._log.info(f\"[RANDOM {test_idx}] Latency (cycles) = {cycle_count}\")\n"}}}
{"id": "cvdp_copilot_sorter_0046", "categories": ["cid014", "medium"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `sorting_engine` module. The assertions should ensure that the module accurately implements the Selection sort algorithm.\n\n## **RTL Design Overview**  \n\n**Selection Sort** is a simple sorting algorithm that repeatedly selects the smallest element from the unsorted portion of an array and places it in its correct position in the sorted portion.\n\n## Algorithm Steps\n\n1. First find the smallest element and swap it with the first element. This way the smallest element is at its correct position.\n2. Then find the smallest among the remaining elements (or the second smallest) and swap it with the second element.\n3. Keep doing this until all elements are moved to the correct positions.\n\n### **Key Components of the Module**       \n\n**Parameters**\n- `N`  (Default is 8, Greater than 0): Number of elements to sort\n- `WIDTH`(Default is 8, Greater than 0): Bit-width of each input element\n\n**Port List**\n| Port Name               | Direction | Width          | Description                                                                                                                                                                                                                                                              |\n|-------------------------|-----------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `clk`                   | input     | 1 bit          | Main clock input. All operations occur on the rising edge of this signal.                                                                                                                                                                                                |\n| `rst`                   | input     | 1 bit          | Active high, asynchronous reset. When asserted, resets the internal state machine and registers to their initial states.                                                                                                                                                 |\n| `start`                 | input     | 1 bit          | Active high, pulse start signal to indicate that the input data is valid and that sorting should begin on the next clock cycle.                                                                                                                                          |\n| `[N*WIDTH-1:0] in_data` | input     | N * WIDTH bits | Input data bus containing the entire unsorted array. Each element has WIDTH bits, and there are N elements.                                                                                                                                                              |\n| `done`                  | output    | 1 bit          | Active high pulse, asserted for 1 clock cycle when the sorting is complete, indicating that `out_data` is now valid and stable. It will be set to 0 in case of a reset.                                                                                                  |\n| `[N*WIDTH-1:0] out_data`| output    | N * WIDTH bits | Output data bus containing the sorted array. This is to be left uninitialized at reset and updated only when sorting a valid input is complete. Valid once `done` is asserted, and maintains previous values until the update from the next sorting operation completes. |\n\n- Assume that all the numbers will be non-negative integers.\n- Assume `N` is an even integer greater than 2.\n---\n\n### Latency Considerations\n\nTotal latency = ((N) * (N - 1)) / 2 + 3*(N-1) + 3\n  \n- **Output**: Once the sorting finishes, the sorted array is presented at the output port. This involves placing the sorted values back onto an output bus.\n\n### FSM Transitions\n- **IDLE:** If `start` is asserted move to the next state `LOAD`.\n- **LOAD:** Move to the next state `FIND` at the next clock cycle.\n- **FIND:**  Move to the next state `CHECK` at the next clock cycle.\n- **CHECK:** Move to the next state `SWAP` if j == N-1.\n- **SWAP:** Move to the next state `NEXT` at the next clock cycle.\n- **NEXT:** Move to the next state `DONE` if i == N-2 else next state is `FIND`.\n- **DONE:** Move to the next state `IDLE` at the next clock cycle.\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Verify all state transitions**\n- **Correct assertion and deassertion of `Done` signal:** \n   - When in the IDLE state, the 'done' signal must remain low.  \n   - The 'done' output must be asserted only when the state machine is in the DONE state.\n   - Whenever 'start' is asserted, the state machine must eventually reach the DONE state\n- **Final sorted order in `array` at `DONE`:** Once we enter the `DONE` state, we expect the entire internal array (array[0..N-1]) to be sorted in non-decreasing order.\n- **Verify correct operation of `SWAP` state:** In the SWAP state, if a swap is needed then the lowest value element from the unsorted array should be found at the lowest available index (first position of the unsorted section) in the next cycle. \n- **Sorting latency:** The latency for sorting an input should not exceed the expected latency mentioned above.\n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,\n    parameter WIDTH = 8\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    typedef enum logic [2:0] {\n        IDLE  = 3'd0,\n        LOAD  = 3'd1,\n        FIND  = 3'd2,\n        CHECK = 3'd3,\n        SWAP  = 3'd4,\n        NEXT  = 3'd5,\n        DONE  = 3'd6\n    } state_t;\n\n    state_t current_state, next_state;\n\n    reg [WIDTH-1:0] data_array [0:N-1];\n\n    reg [$clog2(N)-1:0] i;\n    reg [$clog2(N)-1:0] j;\n    reg [$clog2(N)-1:0] min_idx;\n\n    reg [WIDTH-1:0] min_val;\n    integer idx;\n    integer k;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = current_state;\n        case (current_state)\n            IDLE: begin\n                if (start)\n                    next_state = LOAD;\n            end\n\n            LOAD: begin\n                next_state = FIND;\n            end\n\n            FIND: begin\n                next_state = CHECK;\n            end\n\n            CHECK: begin\n                if (j == N-1)\n                    next_state = SWAP;\n                else\n                    next_state = CHECK;\n            end\n\n            SWAP: begin\n                next_state = NEXT;\n            end\n\n            NEXT: begin\n                if (i == N-2)\n                    next_state = DONE;\n                else\n                    next_state = FIND;\n            end\n\n            DONE: begin\n                next_state = IDLE;\n            end\n\n            default: next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done     <= 1'b0;\n            out_data <= {N*WIDTH{1'b0}};\n        end\n        else begin\n            done <= (current_state == DONE);\n\n            if (current_state == DONE) begin\n                for (idx = 0; idx < N; idx = idx + 1) begin\n                    out_data[idx*WIDTH +: WIDTH] <= data_array[idx];\n                end\n            end\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            for (k = 0; k < N; k = k + 1) begin\n                data_array[k] <= {WIDTH{1'b0}};\n            end\n            i       <= 0;\n            j       <= 0;\n            min_idx <= 0;\n            min_val <= {WIDTH{1'b0}};\n        end\n        else begin\n            case (current_state)\n\n                IDLE: begin\n                end\n\n                LOAD: begin\n                    for (k = 0; k < N; k = k + 1) begin\n                        data_array[k] <= in_data[k*WIDTH +: WIDTH];\n                    end\n                    i       <= 0;\n                    j       <= 0;\n                    min_idx <= 0;\n                    min_val <= {WIDTH{1'b0}};\n                end\n\n                FIND: begin\n                    j          <= i + 1;\n                    min_idx    <= i;\n                    min_val    <= data_array[i];\n                end\n\n                CHECK: begin\n                    if (data_array[j] < min_val) begin\n                        min_val    <= data_array[j];\n                        min_idx    <= j;\n                    end\n\n                    if (j < N-1) begin\n                        j <= j + 1;\n                    end\n                end\n\n                SWAP: begin\n                    if (min_idx != i) begin\n                        data_array[i]        <= data_array[min_idx];\n                        data_array[min_idx]  <= data_array[i];\n                    end\n                end\n\n                NEXT: begin\n                    i <= i + 1;\n                end\n\n                DONE: begin\n                end\n\n                default: begin\n                end\n            endcase\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sorting_engine.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sorting_engine.sv\nTOPLEVEL        = sorting_engine\nMODULE          = test_sorting_engine\nPYTHONPATH      = /src\nHASH            = 46-rtl-assertion-selection-sort", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\nvalid_params = []\nvalid_params.append((8,8))\n\n@pytest.mark.parametrize(\"WIDTH, N\", valid_params)\n\ndef test_runner(WIDTH,N):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    parameters = { \"WIDTH\": WIDTH, \"N\": N }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# if __name__ == \"__main__\":\n#     test_simulate()", "src/test_sorting_engine.py": "# ============================================================\n# test_sorting_engine.py\n#\n# Cocotb testbench for the \"sorting_engine\" module.\n# \n# This testbench demonstrates:\n#   1. Randomized tests\n#   2. Directed corner cases\n#   3. Latency measurements (clock cycles from start to done)\n#   4. Asserting that the latency == expected_latency (for a full selection sort)\n# ============================================================\n\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nimport math\n\n\n# ------------------------------------------------------------------------------\n# Helper function: reset the DUT\n# ------------------------------------------------------------------------------\nasync def reset_dut(dut, cycles=2):\n    \"\"\"Drive reset high for 'cycles' clock cycles, then deassert.\"\"\"\n    dut.rst.value = 1\n    for _ in range(cycles):\n        await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)  # Wait one more cycle after deassert\n\n\n# ------------------------------------------------------------------------------\n# Helper function: pack a list of integers into a single bus of width N*WIDTH\n# ------------------------------------------------------------------------------\ndef pack_data(data_list, width):\n    \"\"\"\n    data_list: list of integers\n    width:     number of bits per integer\n    \"\"\"\n    packed = 0\n    for i, val in enumerate(data_list):\n        w = int(width)\n        packed |= (val & ((1 << w) - 1)) << (i * w)\n    return packed\n\n\n# ------------------------------------------------------------------------------\n# Helper function: unpack a single bus of width N*WIDTH into a list of integers\n# ------------------------------------------------------------------------------\ndef unpack_data(packed, n, width):\n    \"\"\"\n    packed: integer that holds N elements\n    n:      number of elements\n    width:  number of bits per element\n    \"\"\"\n    data_list = []\n    w = int(width)\n    mask = (1 << w) - 1\n    for i in range(n):\n        val = (packed >> (i * w)) & mask\n        data_list.append(val)\n    return data_list\n\n\n# ------------------------------------------------------------------------------\n# Compute expected latency for the full selection sort hardware\n# ------------------------------------------------------------------------------\ndef expected_latency(n):\n    \"\"\"\n    Returns the expected total cycle count (from the cycle after 'start' \n    is deasserted to the first cycle 'done' is high).\n    \"\"\"\n    # \n    # Formula: 1 + sum_{i=0..n-2}[ (n-1 - i) + 3 ] + 1\n    # = 1 + (n-1)*n/2 + 3*(n-1) + 1\n    # = (n-1)*n/2 + 3(n-1) + 2\n    #\n    # For integer math in Python:\n    return 1 + ((n - 1) * n // 2 + 3 * (n - 1)) + 1 + 1\n\n\n@cocotb.test()\nasync def test_sorting_engine_random(dut):\n    \"\"\"\n    Test #1: Random data, checking correctness and latency\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    # Start clock\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    \n    await reset_dut(dut)\n\n    # Generate random data\n    random_data = [random.randint(0, (1 << WIDTH) - 1) for _ in range(N)]\n    dut.in_data.value = pack_data(random_data, WIDTH)\n\n    # Start sorting\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure latency in clock cycles\n    cycle_count = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle_count += 1\n        if dut.done.value == 1:\n            break\n\n    # Check sorting correctness\n    out_list = unpack_data(dut.out_data.value, N, WIDTH)\n    sorted_ref = sorted(random_data)\n    assert out_list == sorted_ref, (\n        f\"ERROR: Output not sorted.\\n\"\n        f\"Input   = {random_data}\\n\"\n        f\"Got     = {out_list}\\n\"\n        f\"Expected= {sorted_ref}\"\n    )\n\n    # Check latency == expected\n    exp = expected_latency(N)\n    assert cycle_count == exp, (\n        f\"Latency mismatch for random data:\\n\"\n        f\"Measured: {cycle_count}, Expected: {exp}\"\n    )\n\n    print(f\"[Random Data] PASS: Sorted in {cycle_count} cycles (expected {exp}).\")\n\n\n@cocotb.test()\nasync def test_sorting_engine_already_sorted(dut):\n    \"\"\"\n    Test #2: Already-sorted data\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Already-sorted data\n    if(WIDTH >= math.log(N,2)):\n        sorted_data = list(range(N))\n    else:\n        sorted_data = [random.randint(0, (1 << WIDTH) - 1) for _ in range(N)]\n    dut.in_data.value = pack_data(sorted_data, WIDTH)\n\n    # Start\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure latency\n    cycle_count = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle_count += 1\n        if dut.done.value == 1:\n            break\n\n    out_list = unpack_data(dut.out_data.value, N, WIDTH)\n    assert out_list == sorted(sorted_data), (\n        f\"ERROR: Output not sorted.\\n\"\n        f\"Input   = {sorted_data}\\n\"\n        f\"Got = {out_list}\\n\"\n        f\"Expected = {sorted_data}\"\n    )\n\n    # Check latency\n    exp = expected_latency(N)\n    assert cycle_count == exp, (\n        f\"Latency mismatch for already-sorted data:\\n\"\n        f\"Measured: {cycle_count}, Expected: {exp}\"\n    )\n\n    print(f\"[Already Sorted] PASS: Sorted in {cycle_count} cycles (expected {exp}).\")\n\n\n@cocotb.test()\nasync def test_sorting_engine_reverse_sorted(dut):\n    \"\"\"\n    Test #3: Reverse-sorted data (worst-case scenario)\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Reverse-sorted data\n    if(WIDTH >= math.log(N,2)):\n        rev_data = list(range(N - 1, -1, -1))\n    else:\n        rev_data = [random.randint(0, (1 << WIDTH) - 1) for _ in range(N)]\n    dut.in_data.value = pack_data(rev_data, WIDTH)\n\n    # Start\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure latency\n    cycle_count = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle_count += 1\n        if dut.done.value == 1:\n            break\n\n    out_list = unpack_data(dut.out_data.value, N, WIDTH)\n    assert out_list == sorted(rev_data), (\n        f\"ERROR: Output not sorted.\\n\"\n        f\"Input   = {rev_data}\\n\"\n        f\"Got = {out_list}\\n\"\n        f\"Expected = {sorted(rev_data)}\"\n    )\n\n    # Check latency\n    exp = expected_latency(N)\n    assert cycle_count == exp, (\n        f\"Latency mismatch for reverse-sorted data:\\n\"\n        f\"Measured: {cycle_count}, Expected: {exp}\"\n    )\n\n    print(f\"[Reverse Sorted] PASS: Sorted in {cycle_count} cycles (expected {exp}).\")\n\n\n@cocotb.test()\nasync def test_sorting_engine_all_equal(dut):\n    \"\"\"\n    Test #4: All elements the same\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n\n    # All elements equal\n    val = random.randint(0, (1 << WIDTH) - 1)\n    equal_data = [val for _ in range(N)]\n    dut.in_data.value = pack_data(equal_data, WIDTH)\n\n    # Start\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure latency\n    cycle_count = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle_count += 1\n        if dut.done.value == 1:\n            break\n\n    out_list = unpack_data(dut.out_data.value, N, WIDTH)\n    assert out_list == equal_data, (\n        f\"ERROR: Output not all-equal.\\n\"\n        f\"Input   = {equal_data}\\n\"\n        f\"Got = {out_list}\\n\"\n        f\"Expected = {equal_data}\"\n    )\n\n    # Check latency\n    exp = expected_latency(N)\n    assert cycle_count == exp, (\n        f\"Latency mismatch for all-equal data:\\n\"\n        f\"Measured: {cycle_count}, Expected: {exp}\"\n    )\n\n    print(f\"[All Equal] PASS: Output is unchanged, sorted in {cycle_count} cycles (expected {exp}).\")\n\n\n@cocotb.test()\nasync def test_sorting_engine_single_element(dut):\n    \"\"\"\n    Test #5: Single-element array (if N=1)\n    \"\"\"\n    N = int(dut.N.value)\n    WIDTH = int(dut.WIDTH.value)\n\n    # If the DUT is not configured for N=1, skip\n    if N != 1:\n        return\n\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Single data\n    single_data = [random.randint(0, (1 << WIDTH) - 1)]\n    dut.in_data.value = pack_data(single_data, WIDTH)\n\n    # Start\n    dut.start.value = 1\n    await RisingEdge(dut.clk)\n    dut.start.value = 0\n\n    # Measure latency\n    cycle_count = 0\n    while True:\n        await RisingEdge(dut.clk)\n        cycle_count += 1\n        if dut.done.value == 1:\n            break\n\n    out_list = unpack_data(dut.out_data.value, N, WIDTH)\n    assert out_list == single_data, (\n        f\"ERROR: Single-element array was changed.\\n\"\n        f\"Input   = {single_data}\\n\"\n        f\"Got = {out_list}\\n\"\n        f\"Expected = {single_data}\"\n    )\n\n    # Check latency\n    exp = expected_latency(N)\n    assert cycle_count == exp, (\n        f\"Latency mismatch for single-element data:\\n\"\n        f\"Measured: {cycle_count}, Expected: {exp}\"\n    )\n\n    print(f\"[Single Element] PASS: No change, done in {cycle_count} cycles (expected {exp}).\")\n"}}}
{"id": "cvdp_copilot_sorter_0066", "categories": ["cid014", "medium"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `sorting_engine` module. The assertions should ensure that the module accurately implements the Bitonic sort algorithm.\n\n## **RTL Design Overview**  \n\n**Bitonic Sort** is a comparison-based sorting algorithm particularly suited for hardware (e.g., FPGAs, ASICs) and parallel architectures. It constructs sequences that are \u201cbitonic\u201d.\n- A bitonic sequence is a list of numbers that first increases and then decreases (or vice versa). This means that there exists an index i such that all elements before i are in ascending order, and all elements after i are in descending order.\n\n## Algorithm Steps\n\nBelow is an outline of how bitonic sort proceeds for \\( N = 2^k \\) elements:\n\n1. **Construct Bitonic Subsequences**  \n   - Recursively form smaller sorted subsequences. The algorithm arranges them so that one subsequence is sorted in ascending order and the other in descending order, thereby forming a **bitonic** sequence.\n\n2. **Bitonic Merge**  \n   - Once a sequence is bitonic, it can be fully sorted (in ascending or descending order) by a cascade of compare-and-swap operations that progressively reduce the bitonic sequence length until the entire array is sorted.\n\n3. **Recursive / Iterative Stages**  \n   - If we\u2019re dealing with ( N ) elements, we typically have (log_2(N)) stages of building bitonic sequences and (log_2(N)) stages of merging. In hardware, this often translates to a series of **pipeline** stages, each performing some pattern of compare-swap pairs.\n\n\n### **Key Components of the Module**       \n\n**Parameters**\n- `WIDTH`(Default is 8, Greater than 0): Bit-width of each input element\n\n**Port List**\n| Port Name               | Direction | Width          | Description                                                                                                                                                                                                                                                              |\n|-------------------------|-----------|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `clk`                   | input     | 1 bit          | Main clock input. All operations occur on the rising edge of this signal.                                                                                                                                                                                                |\n| `rst`                   | input     | 1 bit          | Active high, asynchronous reset. When asserted, resets the internal state machine and registers to their initial states.                                                                                                                                                 |\n| `start`                 | input     | 1 bit          | Active high, pulse start signal to indicate that the input data is valid and that sorting should begin on the next clock cycle.                                                                                                                                          |\n| `[8*WIDTH-1:0] in_data` | input     | 8 * WIDTH bits | Input data bus containing the entire unsorted array. Each element has WIDTH bits, and there are 8 elements.                                                                                                                                                              |\n| `done`                  | output    | 1 bit          | Active high pulse, asserted for 1 clock cycle when the sorting is complete, indicating that `out_data` is now valid and stable. It will be set to 0 in case of a reset.                                                                                                  |\n| `[8*WIDTH-1:0] out_data`| output    | 8 * WIDTH bits | Output data bus containing the sorted array. This is initialized to 0 at reset and updated only when sorting a valid input is complete. Valid once `done` is asserted, and maintains previous values until the update from the next sorting operation completes.         |\n\n- Assume that all the numbers will be non-negative integers.\n---\n\n### Latency Considerations\n\nTotal latency = 9\n  \n- **Output**: Once the sorting finishes, the sorted array is presented at the output port. This involves placing the sorted values back onto an output bus.\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Bitonic Sequence formation:** Verify a bitonic sequence is formed at the correct step.\n- **Bitonic sequence sorting:** Verify the bitonic sequence is correctly sorted when done is high.\n- **One-cycle done pulse and only after `DONE` state:** The done signal should be high for only one clock cycle and only after `DONE` state.\n- **Sort latency:** Make sure the module latency is correct.\n- **State sequence:** After a 'start' is asserted in `cycle` clock cycle, the state machine must follow this sequence: `cycle`+1: SETUP, `cycle`+2: SORT, and `cycle`+8: DONE.\n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/sorting_engine.sv": "module sorting_engine #(parameter WIDTH = 8)(\n    input                     clk,\n    input                     rst,\n    input                     start,      // Start the sort when start=1\n    input  [8*WIDTH-1:0]      in_data,    // 8 inputs, each WIDTH bits\n    output reg                done,\n    output reg [8*WIDTH-1:0]  out_data    // 8 outputs, sorted in_data ascending order\n);\n\n    //////////////////////////////////////////////////////////////////////////\n    // FSM States\n    //////////////////////////////////////////////////////////////////////////\n    localparam  START = 3'b000,\n                SETUP = 3'b001,\n                SORT  = 3'b010,\n                DONE  = 3'b011;\n\n    reg [2:0] state;   // Current FSM state\n    reg [2:0] step;    // Step counter within the SORT state\n\n    // An 8-element array for local sorting\n    // Each element is WIDTH bits\n    reg [WIDTH-1:0] d [0:7];\n\n    integer i;  // For loops\n\n    //////////////////////////////////////////////////////////////////////////\n    // Synchronous FSM\n    //////////////////////////////////////////////////////////////////////////\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state     <= START;\n            step      <= 3'd0;\n            done      <= 1'b0;\n            out_data  <= {8*WIDTH{1'b0}};\n            // Initialize 'd' array\n            for (i = 0; i < 8; i = i + 1) begin\n                d[i]  <= {WIDTH{1'b0}};\n            end\n        end\n        else begin\n            case (state)\n                //////////////////////////////////////////////////////////////////\n                // START: Wait for start to go high. Then move to SETUP.\n                //////////////////////////////////////////////////////////////////\n                START: begin\n                    done <= 1'b0;\n                    if (start) begin\n                        state <= SETUP;\n                        step  <= 3'd0;\n                    end\n                    else begin\n                        state <= START; // remain\n                    end\n                end\n\n                //////////////////////////////////////////////////////////////////\n                // SETUP: Copy the 8 inputs into d[0..7]. Then go to SORT.\n                //////////////////////////////////////////////////////////////////\n                SETUP: begin\n                    for (i = 0; i < 8; i = i + 1) begin\n                        d[i] <= in_data[(i+1)*WIDTH - 1 -: WIDTH];\n                    end\n                    step  <= 3'd0;\n                    state <= SORT;\n                end\n\n                //////////////////////////////////////////////////////////////////\n                // SORT: Perform the bitonic compare-swap sequence (6 steps).\n                //////////////////////////////////////////////////////////////////\n                SORT: begin\n                    case (step)\n                        // Step 0:\n                        //   (0,1), (2,3), (4,5), (6,7)\n                        3'd0: begin\n                            if (d[0] > d[1]) begin\n                                d[0] <= d[1];\n                                d[1] <= d[0];\n                            end\n                            if (d[2] < d[3]) begin\n                                d[2] <= d[3];\n                                d[3] <= d[2];\n                            end\n                            if (d[4] > d[5]) begin\n                                d[4] <= d[5];\n                                d[5] <= d[4];\n                            end\n                            if (d[6] < d[7]) begin\n                                d[6] <= d[7];\n                                d[7] <= d[6];\n                            end\n                            step <= step + 1'b1;\n                        end\n\n                        // Step 1:\n                        //   (0,2), (1,3), (4,6), (5,7)\n                        3'd1: begin\n                            if (d[0] > d[2]) begin\n                                d[0] <= d[2];\n                                d[2] <= d[0];\n                            end\n                            if (d[1] > d[3]) begin\n                                d[1] <= d[3];\n                                d[3] <= d[1];\n                            end\n                            if (d[4] < d[6]) begin\n                                d[4] <= d[6];\n                                d[6] <= d[4];\n                            end\n                            if (d[5] < d[7]) begin\n                                d[5] <= d[7];\n                                d[7] <= d[5];\n                            end\n                            step <= step + 1'b1;\n                        end\n\n                        // Step 2:\n                        //   (0,1), (2,3), (4,5), (6,7)\n                        3'd2: begin\n                            if (d[0] > d[1]) begin\n                                d[0] <= d[1];\n                                d[1] <= d[0];\n                            end\n                            if (d[2] > d[3]) begin\n                                d[2] <= d[3];\n                                d[3] <= d[2];\n                            end\n                            if (d[4] < d[5]) begin\n                                d[4] <= d[5];\n                                d[5] <= d[4];\n                            end\n                            if (d[6] < d[7]) begin\n                                d[6] <= d[7];\n                                d[7] <= d[6];\n                            end\n                            step <= step + 1'b1;\n                        end\n\n                        // Step 3:\n                        //   (0,4), (1,5), (2,6), (3,7)\n                        //   Ascending for even blocks, descending for odd blocks.\n                        3'd3: begin\n                            // For 8 total, let's assume we want all ascending:\n                            if (d[0] > d[4]) begin\n                                d[0] <= d[4];\n                                d[4] <= d[0];\n                            end\n                            if (d[1] > d[5]) begin\n                                d[1] <= d[5];\n                                d[5] <= d[1];\n                            end\n                            if (d[2] > d[6]) begin\n                                d[2] <= d[6];\n                                d[6] <= d[2];\n                            end\n                            if (d[3] > d[7]) begin\n                                d[3] <= d[7];\n                                d[7] <= d[3];\n                            end\n                            step <= step + 1'b1;\n                        end\n\n                        // Step 4:\n                        //   (0,2), (1,3), (4,6), (5,7)\n                        3'd4: begin\n                            if (d[0] > d[2]) begin\n                                d[0] <= d[2];\n                                d[2] <= d[0];\n                            end\n                            if (d[1] > d[3]) begin\n                                d[1] <= d[3];\n                                d[3] <= d[1];\n                            end\n                            if (d[4] > d[6]) begin\n                                d[4] <= d[6];\n                                d[6] <= d[4];\n                            end\n                            if (d[5] > d[7]) begin\n                                d[5] <= d[7];\n                                d[7] <= d[5];\n                            end\n                            step <= step + 1'b1;\n                        end\n\n                        // Step 5:\n                        //   (0,1), (2,3), (4,5), (6,7)\n                        3'd5: begin\n                            if (d[0] > d[1]) begin\n                                d[0] <= d[1];\n                                d[1] <= d[0];\n                            end\n                            if (d[2] > d[3]) begin\n                                d[2] <= d[3];\n                                d[3] <= d[2];\n                            end\n                            if (d[4] > d[5]) begin\n                                d[4] <= d[5];\n                                d[5] <= d[4];\n                            end\n                            if (d[6] > d[7]) begin\n                                d[6] <= d[7];\n                                d[7] <= d[6];\n                            end\n                            step  <= 3'd0;    // reset step\n                            state <= DONE;    // sorting complete\n                        end\n\n                        // Default\n                        default: begin\n                            step  <= 3'd0;\n                            state <= DONE;\n                        end\n                    endcase\n                end\n\n                //////////////////////////////////////////////////////////////////\n                // DONE: Latch the sorted data to 'out_data', assert done = 1.\n                //       Then go to START.\n                //////////////////////////////////////////////////////////////////\n                DONE: begin\n                    // Write final sorted data out_data\n                    for (i = 0; i < 8; i = i + 1) begin\n                        out_data[i*WIDTH +: WIDTH] <= d[i];\n                    end\n\n                    done   <= 1'b1;\n                    state  <= START;\n                end\n\n                //////////////////////////////////////////////////////////////////\n                // DEFAULT\n                //////////////////////////////////////////////////////////////////\n                default: begin\n                    state <= START;\n                end\n            endcase\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sorting_engine.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sorting_engine.sv\nTOPLEVEL        = sorting_engine\nMODULE          = test_sorting_engine\nPYTHONPATH      = /src\nHASH            = 66-rtl-assertion-bitonic-sort", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.parametrize(\"WIDTH\", [random.randint(1, 32)])\ndef test_runner(WIDTH):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    parameters = { \"WIDTH\": WIDTH }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# if __name__ == \"__main__\":\n#     test_simulate()", "src/test_sorting_engine.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport random\n\n# A helper function to split the bits from dut.out_data into a list of integers\n# Each element is WIDTH bits, total 8 elements => 8*WIDTH bits.\ndef unpack_output(dut, width=8):\n    out_val = int(dut.out_data.value)\n    elements = []\n    for i in range(8):\n        # Extract bits [(i*width) : (i+1)*width]\n        chunk = (out_val >> (i * width)) & ((1 << width) - 1)\n        elements.append(chunk)\n    return elements\n\n@cocotb.test()\nasync def test_sorting_engine(dut):\n    \"\"\" Test the sorting engine for various corner cases and random data, \n        making sure no input exceeds the DUT's bit-width. \"\"\"\n\n    # Create a clock on dut.clk with a period of 10ns\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n\n    # Read the parameterized WIDTH from the DUT\n    WIDTH = int(dut.WIDTH.value)\n    N = 8  # Number of elements\n    EXPECTED_LATENCY = 9  # Matches your DUT's expected pipeline latency\n\n    # Compute the maximum representable value for 'WIDTH' bits\n    max_val = (1 << WIDTH) - 1\n\n    # Reset procedure\n    dut.rst.value = 1\n    dut.start.value = 0\n    dut.in_data.value = 0\n    for _ in range(2):\n        await RisingEdge(dut.clk)\n\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n\n    # ---------------\n    # Helper function\n    # ---------------\n    async def apply_inputs_and_sort(data_list):\n        \"\"\"\n        Applies 'data_list' (length = 8) to dut.in_data, asserts 'start',\n        measures the clock cycles until 'done', and checks the sorted result.\n        \"\"\"\n        # Convert data_list to a single integer for dut.in_data\n        packed_val = 0\n        for i, val in enumerate(data_list):\n            # Ensure each value is within [0, max_val]\n            # (In practice, data_list is already clamped, \n            #  but this extra \"& max_val\" is harmless and safe.)\n            val_clamped = val & max_val  \n            packed_val |= val_clamped << (i * WIDTH)\n\n        # Drive the input\n        dut.in_data.value = packed_val\n\n        # Assert 'start' for 1 cycle\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        # Count cycles until done\n        cycle_count = 0\n        while True:\n            await RisingEdge(dut.clk)\n            cycle_count += 1\n            if dut.done.value == 1:\n                break\n\n        # Check the latency\n        assert cycle_count == EXPECTED_LATENCY, \\\n            f\"ERROR: Observed latency {cycle_count} != expected {EXPECTED_LATENCY}\"\n\n        # Now retrieve the output\n        result = unpack_output(dut, WIDTH)\n\n        # Check if output is sorted in ascending order\n        sorted_data = sorted(data_list)\n        if result != sorted_data:\n            # Sometimes reversing might fix indexing mismatches\n            if list(reversed(result)) == sorted_data:\n                pass  # Possibly your hardware packs the data in reverse order\n            else:\n                raise AssertionError(\n                    f\"ERROR: Output not sorted.\\n\"\n                    f\"Input = {data_list},\\n\"\n                    f\"DUT output = {result},\\n\"\n                    f\"Expected sorted = {sorted_data}.\"\n                )\n        print(f\"Input = {data_list},\\n\"\n              f\"DUT output = {result},\\n\"\n              f\"Expected sorted = {sorted_data}.\")\n\n        # Additional clock if you want to see 'done' high for a cycle\n        await RisingEdge(dut.clk)\n\n    # ---------------\n    #  Test Cases\n    # ---------------\n    # Always clamp data to [0..max_val], in case WIDTH < 3\n\n    # 1) Already-sorted input\n    data_sorted = [min(i, max_val) for i in range(N)]\n    await apply_inputs_and_sort(data_sorted)\n\n    # 2) Reverse-sorted input\n    data_reversed = [min(i, max_val) for i in reversed(range(N))]\n    await apply_inputs_and_sort(data_reversed)\n\n    # 3) All elements are the same\n    #    (If WIDTH = 1, '2' is out of range. So clamp to max_val.)\n    data_all_same = [min(2, max_val)] * N\n    await apply_inputs_and_sort(data_all_same)\n\n    # 4) All zero\n    data_zeros = [0]*N\n    await apply_inputs_and_sort(data_zeros)\n\n    # 5) All maximum for WIDTH bits\n    data_all_max = [max_val]*N\n    await apply_inputs_and_sort(data_all_max)\n\n    # 6) Random test: Repeat multiple times\n    for _ in range(10):\n        data_random = [random.randint(0, max_val) for _ in range(N)]\n        await apply_inputs_and_sort(data_random)\n\n    # 7) Mixed corner test: includes 0, max, random mid-values\n    #    Some values (13,15) might exceed max_val if WIDTH < 4, so clamp them\n    data_mixed_raw = [0, max_val, 1, (max_val // 2), 0, max_val, 13, 15]\n    data_mixed = [min(x, max_val) for x in data_mixed_raw]\n    await apply_inputs_and_sort(data_mixed)\n\n    # If we reach here without any assertion failures, the test passes.\n    cocotb.log.info(\"All test cases PASSED!\")\n"}}}
{"id": "cvdp_copilot_square_root_0008", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `square_root_seq` module. The assertions should ensure correct FSM transitions, root calculation, and termination conditions.  \n\n## **RTL Design Overview**  \nThe `square_root_seq` module implements a **sequential square root calculator** using **subtractive iteration**. It determines the integer square root of an input value by continuously subtracting odd numbers from the input number and counting how many times this can be done before the remainder becomes smaller than the current odd number.\n\n### **Key Components of the Module**  \n- **`state`**: FSM state (`IDLE` or `COMPUTE`).  \n- **`remainder`**: Holds the value being reduced through subtraction.  \n- **`odd`**: Tracks the next odd number to subtract from `remainder`.  \n- **`root`**: Holds the current computed square root value.  \n- **`final_root`**: Stores the final computed square root once the computation completes. `WIDTH/2` bit wide output.\n- **`done`**: Active high signal indicates when the computation is complete.  \n- **`clk`**: Clock signal. Design is synchronized to the posedge of this clock.  \n- **`rst`**: Asynchronous active-high reset signal.  \n- **`start`**: Active-high signal that initiates the computation.  \n- **`num`**: Input number for which the square root is computed. `WIDTH` bit wide input. \n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n\n- **FSM State Transition:**  \n  - The FSM must transition from `IDLE` to `COMPUTE` on the next rising clock edge after `start` is asserted.  \n\n- **Final Root Assignment:**  \n  - When `done` is asserted, `final_root` should **match the computed `root` value** from the previous clock cycle.  \n\n- **Root Increment Behavior:**  \n  - When `remainder >= odd` in `COMPUTE` state, `root` should **increment by 1** at the next clock cycle.  \n\n- **Odd Increment Behavior:**  \n  - When `remainder >= odd` in `COMPUTE` state, `odd` should **increment by 2** at the next clock cycle.  \n\n- **Computation Termination:**  \n  - `done` should be **asserted only when `remainder` is less than `odd`**, signaling the end of the computation.  \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.  ", "context": {"rtl/square_root_seq.sv": "module square_root_seq #(parameter WIDTH = 16) (\n    input clk, rst, start,\n    input wire [WIDTH-1:0] num,\n    output reg done,\n    output reg [WIDTH/2-1:0] final_root\n);\n   localparam IDLE = 1'b0;\n   localparam COMPUTE = 1'b1;\n   \n    reg [WIDTH-1:0] remainder;\n    reg [WIDTH-1:0] odd;\n    reg [WIDTH/2-1:0] root;\n    reg  state;\n    \n    always @(posedge clk or posedge rst) \n    begin\n        if (rst) \n        begin\n          state <= IDLE;\n          remainder <= {WIDTH{1'b0}};\n          odd <= 1; \n          root <= 0;\n          done <= 0;\n          final_root <= 0;\n        end \n        else \n        begin\n            case (state)\n                IDLE: \n                begin\n                    done <= 0;\n                    if (start) \n                    begin\n                        remainder <= num; \n                        odd <= 1; \n                        root <= 0;\n                        state <= COMPUTE; \n                    end\n                end\n                COMPUTE: \n                begin\n                    if (remainder >= odd) \n                    begin\n                        remainder <= remainder - odd; \n                        odd <= odd + 2; \n                        root <= root + 1; \n                    end \n                    else \n                    begin\n                        final_root <= root; \n                        done <= 1; \n                        state <= IDLE; \n                    end\n                end\n                default: \n                begin\n                  state <= IDLE;\n                  remainder <= {WIDTH{1'b0}};\n                  odd <= 1; \n                  root <= 0;\n                  done <= 0;\n                  final_root <= 0; \n                end\n            endcase \n        end\n    end\nendmodule"}}, "output": {"response": "", "context": {"rtl/square_root_seq.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/square_root_seq.sv\nTOPLEVEL        = square_root_seq\nMODULE          = test_square_root_seq\nPYTHONPATH      = /src\nHASH            = 8-rtl-assertion-for-squate-root", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner(WIDTH):\n    parameters = {\n        \"WIDTH\": WIDTH,\n    }\n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n\ndef get_powers_of_two_pairs(iterations):\n    value = 2\n    pairs = []\n    for _ in range(iterations):\n        pairs.append(value)\n        value *= 2\n    return pairs\n\n# Test the function\npairs = get_powers_of_two_pairs(1)\n#print(pairs)\n\n# random test\n@pytest.mark.parametrize(\"WIDTH\",pairs)\ndef test(WIDTH):\n    print(f'Running with: WIDTH = {WIDTH}')\n    call_runner(WIDTH)\n", "src/test_square_root_seq.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\nimport math\n\nRANDOM_TESTCASE = 8;\n\nasync def expected_sqrt(value):\n    #Calculate the integer square root.\n    return int(math.isqrt(value))\n\n@cocotb.test()\nasync def test_square_root_seq(dut):\n    width = int(dut.WIDTH.value)\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Define golden latencies for each width and test case\n    golden_latencies = {\n        2:  {'MAX': 2, 'MIN': 1},\n        4:  {'MAX': 4, 'MIN': 1},\n        8:  {'MAX': 16, 'MIN': 1},\n        16: {'MAX': 256, 'MIN': 1},\n        32: {'MAX': 65536, 'MIN': 1}\n    }\n\n    dut.rst.value = 1  # Assert reset\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0  # Deassert reset\n\n    test_cases = [\n        {\"num\": (2**width) - 1, \"description\": \"MAX number\"},\n        {\"num\": 0, \"description\": \"MIN number\"}\n    ]\n\n    for test_case in test_cases:\n        await RisingEdge(dut.clk)\n        num = test_case[\"num\"]\n        dut.num.value = num\n        expected_root = await expected_sqrt(num)\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n\n        # Initialize latency counter\n        latency = 0\n        # Wait for the operation to complete\n        while dut.done.value == 0:\n            await RisingEdge(dut.clk)\n            latency += 1\n\n        final_root = int(dut.final_root.value)\n        assert final_root == expected_root, f\"Test {test_case['description']} FAILED: Input = {num}, Calculated = {final_root}, Expected = {expected_root}\"\n        \n        # Get the expected golden latency for the current test\n        test_key = 'MAX' if num == (2**width) - 1 else 'MIN'\n        expected_latency = golden_latencies[width][test_key]\n\n        # Assert and log if latency mismatch\n        if latency != expected_latency:\n            dut._log.error(f\"Test {test_case['description']} FAILED: Latency mismatch, expected {expected_latency+1}, got {latency+1}\")\n            assert False, f\"Latency mismatch for test {test_case['description']} - expected {expected_latency+1}, got {latency+1}\"\n        else:\n            dut._log.info(f\"Test {test_case['description']} PASSED: Input = {num}, Calculated = {final_root}, Expected = {expected_root}, Latency = {latency+1} cycles\")\n            \n\n@cocotb.test()\nasync def test_square_root_seq(dut):\n    width = int(dut.WIDTH.value)\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Assert and deassert reset\n    dut.rst.value = 1\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)  # Wait for a clock edge post reset deassertion\n\n    test_count = 0\n    # Define test cases including edge cases\n    test_values = [random.randint(0, (1 << width) - 1) for _ in range(RANDOM_TESTCASE-1)] + [(1 << width) - 1, 0]\n    #print(bin(test_values))\n    \n    for num in test_values:\n        dut.num.value = num\n        expected_root = await expected_sqrt(num)\n\n        # Initialize the test action\n        dut.start.value = 1\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        dut.start.value = 0\n        \n        # Initialize latency counter\n        latency = 0\n        # Wait for the operation to complete\n        while dut.done.value == 0:\n            await RisingEdge(dut.clk)\n            latency += 1\n                \n        # Read the result and verify\n        final_root = int(dut.final_root.value)\n        if final_root == expected_root:\n            dut._log.info(f\"Test {test_count} PASSED: Input = {num}, Calculated = {final_root}, Expected = {expected_root}\")\n        else:\n            dut._log.error(f\"Test {test_count} FAILED: Input = {num}, Calculated = {final_root}, Expected = {expected_root}\")\n            assert final_root == expected_root, f\"Assertion failed for test {test_count}\"\n        \n        test_count += 1 \n         \n"}}}
{"id": "cvdp_copilot_sram_fd_0028", "categories": ["cid014", "medium"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `cvdp_sram_fd` module. The assertions should ensure that the module accurately implements the full duplex SRAM.\n\n## **RTL Design Overview**  \n \nA full-duplex SRAM allows simultaneous read and write operations on two separate ports (Port A and Port B)\n\n### **Key Components of the Module**       \n\n1. **Parameters:**\n   - `DATA_WIDTH` (default value: 8): Defines the width of the data bus.\n   - `ADDR_WIDTH` (default value: 4): Defines the width of the address bus.\n   - **Derived Parameter:**\n     - `RAM_DEPTH`: Determines the depth of the memory. It is derived using the ADDR_WIDTH parameter to match the full range of unique addresses possible with the given address width.\n\n2. **Ports:**\n\n   - **Clock and Control Signals:**\n     - `input clk`: Clock signal.\n     - `input ce`: Active-high chip enable signal.\n\n   - **Port A Signals:**\n     - `input a_we`: Active-high write enable for Port A.\n     - `input a_oe`: Active-high output (read) enable for Port A.\n     - `input [ADDR_WIDTH-1:0] a_addr`: Address bus for Port A.\n     - `input [DATA_WIDTH-1:0] a_wdata`: Write data bus for Port A.\n     - `output logic [DATA_WIDTH-1:0] a_rdata`: Read data output for Port A.\n\n   - **Port B Signals:**\n     - `input b_we`: Active-high write enable for Port B.\n     - `input b_oe`: Active-high output (read) enable for Port B.\n     - `input [ADDR_WIDTH-1:0] b_addr`: Address bus for Port B.\n     - `input [DATA_WIDTH-1:0] b_wdata`: Write data bus for Port B.\n     - `output logic [DATA_WIDTH-1:0] b_rdata`: Read data output for Port B.\n     \n3. **Operational Behavior:**\n\n   - **Port A Operations:**\n     - **Write Operation:**\n       - Occurs when `ce` and `a_we` are high.\n       - The data on `a_wdata` is written to the memory location specified by `a_addr`.\n     - **Read Operation:**\n       - Occurs when `ce` is high,  and `a_oe` is high.\n       - The data from the memory location specified by `a_addr` is loaded into `a_rdata`.\n       - `a_rdata` retains its previous value if `a_oe` is low while `ce` is high\n     - **Priority:**\n       - If both `a_we` and `a_oe` are high, the read operation takes precedence, where data previously stored at the address appears on the output while the input data is being stored in memory.\n     - **Timing:**\n       - **Write Latency:** 1 clock cycle.\n       - **Read Latency:** 1 clock cycle.\n\n   - **Port B Operations:**\n     - This port behaves same as Port A. The signals controlling this port are `b_we`, `b_oe`, `b_addr`, `b_wdata` and the output is driven on `b_rdata`.\n\n4. **Simultaneous Access Handling:**\n   - The memory supports simultaneous operations on both ports, including:\n     - Reads on both ports.\n     - Writes on both ports.\n     - A read on one port and a write on the other.\n   - **Same Address Access:**\n     - **If both ports access the same address:**\n       - Read and write: Follows a \"read-first\" approach which means that if a write and read occur at the same address simultaneously, data previously stored at the address appears on the output while the input data is being stored in memory.\n       - Reads on both ports: Supports with both ports providing the same output data.\n       - It is assumed that the write access will not occur for the same address on both ports together. Such a collision is not handled. \n\n5. **Assumptions and Constraints:**\n   - All inputs are synchronous and are sampled on the rising edge of `clk`.\n   - Input addresses (`a_addr`, `b_addr`) are within the valid range (`0` to `RAM_DEPTH - 1`).\n   - Data inputs (`a_wdata`, `b_wdata`) are valid when write enables (`a_we`, `b_we`) are high.\n   - If neither read nor write is enabled for a port during a clock cycle (with `ce` high), the port maintains its previous output state.\n   \n6. **Boundary Conditions:**\n    - **Data Width and Address Width:**\n      - `DATA_WIDTH` and `ADDR_WIDTH` are positive integers greater than zero.\n   \n---\n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Read first behavior and Simultaneous access handling**\n- **Behaviour with chip enable deasserted and the behaviour when chip enable is asserted with no read or write enabled.**\n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/cvdp_sram_fd.sv": "/**************************************************************************\nFILENAME:    cvdp_sram_fd.sv\nDESCRIPTION: This file contains the RTL for a full-duplex dual-port RAM in SystemVerilog.\nLATENCY:     Write latency = 1 clk cycle\n             Read  latency = 1 clk cycle\n**************************************************************************/\nmodule cvdp_sram_fd #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 4\n)(\n    input                         clk     , // clock input\n    input                         ce      , // chip enable\n    input                         a_we    , // channel A write enable\n    input                         a_oe    , // channel A output enable\n    input        [ADDR_WIDTH-1:0] a_addr  , // channel A address\n    input        [DATA_WIDTH-1:0] a_wdata , // channel A write data\n    output logic [DATA_WIDTH-1:0] a_rdata , // channel A read data out\n    input                         b_we    , // channel B write enable\n    input                         b_oe    , // channel B output enable\n    input        [ADDR_WIDTH-1:0] b_addr  , // channel B address\n    input        [DATA_WIDTH-1:0] b_wdata , // channel B write data\n    output logic [DATA_WIDTH-1:0] b_rdata   // channel B read data out\n);\n    // Setup RAM_DEPTH parameter\n    localparam RAM_DEPTH = 1 << ADDR_WIDTH;\n    // Memory array\n    logic [DATA_WIDTH-1:0] mem [0:RAM_DEPTH-1];\n    // Channel A operations\n    always_ff @(posedge clk) begin\n        if (ce) begin\n            if (a_oe) begin\n                a_rdata     <= mem[a_addr];\n            end\n            if (a_we) begin\n                mem[a_addr] <= a_wdata;\n            end\n        end else begin\n            a_rdata         <= 'b0;\n        end\n    end\n    // Channel B operations\n    always_ff @(posedge clk) begin\n        if (ce) begin\n            if (b_oe) begin\n                b_rdata     <= mem[b_addr];\n            end \n            if (b_we) begin\n                mem[b_addr] <= b_wdata;\n            end\n        end else begin\n            b_rdata         <= 'b0;\n        end\n    end\nendmodule"}}, "output": {"response": "", "context": {"rtl/cvdp_sram_fd.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\n# TARGET          = 90\nSIM             = xcelium\nWAVE            = 1\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/cvdp_sram_fd.sv\nTOPLEVEL        = cvdp_sram_fd\nMODULE          = test_sram_fd\nPYTHONPATH      = /src\nHASH            = 28-rtl-assertion-sram-fd", "src/harness_library.py": "\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:str, plusargs:list =[], args:tuple = (), parameters:dict={}, wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameters,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef xrun_tb(lang:str=\"sv\"):\n    VALID_RTYPE = (\"sv\" , \"v\")\n    if lang not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for xrun_tb function.\")\n    \n    cmd = f\"xrun -coverage all -covoverwrite /code/rtl/*.{lang} /code/verif/*.{lang} {'-sv' if lang == 'sv' else ''} -covtest test -svseed random -logfile simulation.log -work sim_build\"\n    # print(cmd)\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n    \ndef coverage_report(asrt_type:str=\"all\", rtype:str = \"text\", rname:str = \"coverage\"):\n    VALID_ATYPE = (\"all\", \"code\", \"fsm\", \"functional\", \"block\", \"expression\", \"toggle\", \"statement\", \"assertion\", \"covergroup\")\n    VALID_RTYPE = (\"text\" , \"html\")\n\n    if asrt_type not in VALID_ATYPE and rtype not in VALID_RTYPE:\n        raise ValueError(\"Invalid argument for coverage_report function.\")\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -{rtype} -out {rname}\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check(rname:str = \"coverage\"):\n\n    metrics = {}\n    try:\n        with open(rname) as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage file.\")\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) == 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list, ewdth: int=8) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, f'0{ewdth}b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n\n# converitng floating point number in scientific notation binary format\ndef float_to_binary(num: float):\n    # Convert float to 32-bit binary representation\n    packed_num = struct.pack('!f', num)  # Packs the float into 32 bits using IEEE 754\n    binary_representation = ''.join(f'{byte:08b}' for byte in packed_num)\n\n    sign = binary_representation[0]\n    exponent = binary_representation[1:9]\n    mantissa = binary_representation[9:]\n\n    return sign, exponent, mantissa", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.parametrize(\"ADDR_WIDTH\", [2])#,4,8])\n@pytest.mark.parametrize(\"DATA_WIDTH\", [4])#,8,32])\n\ndef test_sram_fd(ADDR_WIDTH,DATA_WIDTH):\n    plusargs = [f'+start_val={0}', f'+step_size={0}', f'+enable={0}', f'+reverse={0}']\n    parameters = { \"ADDR_WIDTH\": ADDR_WIDTH, \"DATA_WIDTH\": DATA_WIDTH }\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args=(\"-coverage all\",\" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n        hrs_lb.runner(wave = wave, toplevel = toplevel, plusargs=plusargs, parameters=parameters, module = module, src=verilog_sources, sim=sim, args=args)\n        hrs_lb.coverage_report(\"assertion\", rtype=\"text\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"prioroty_encoder_{tst_seq}_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# if __name__ == \"__main__\":\n#     test_simulate()\n", "src/test_sram_fd.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, Timer\nimport random\n\n# Utility function to initialize the SRAM\nasync def init_sram(dut, depth, width, memory):\n    dut.ce.value = 1\n    prev_memory = memory.copy()\n    for addr in range(depth):\n        # Initialize the memory with random values\n        a_wdata = random.randint(0, 2**width - 1)\n\n        # Channel A: write\n        dut.a_addr.value = addr\n        dut.a_we.value = 1\n        dut.a_wdata.value = a_wdata\n        dut.a_oe.value = 0\n\n        # Wait for write latency\n        await RisingEdge(dut.clk)\n\n        # Update memory model after write latency\n        memory[addr] = a_wdata\n\n        # Reset write enables\n        dut.a_we.value = 0\n        dut.b_we.value = 0\n\n        # Update prev_memory for latency modeling\n        prev_memory = memory.copy()\n\n# Function to perform random read/write operations on the SRAM\nasync def random_rw_test(dut, depth, width, memory):\n    prev_memory = memory.copy()\n    for _ in range(100):  # Run 100 random transactions\n        a_addr = random.randint(0, depth - 1)\n        b_addr = random.randint(0, depth - 1)\n        a_we = random.choice([0, 1])\n        b_we = random.choice([0, 1]) if a_addr != b_addr else int(not a_we)\n        a_wdata = random.randint(0, 2**width - 1) if a_we else 0\n        b_wdata = random.randint(0, 2**width - 1) if b_we else 0\n\n        # Ensure CE is high for this test\n        dut.ce.value = 1\n\n        # Set inputs\n        dut.a_addr.value = a_addr\n        dut.b_addr.value = b_addr\n        dut.a_we.value = a_we\n        dut.b_we.value = b_we\n        dut.a_wdata.value = a_wdata\n        dut.b_wdata.value = b_wdata\n        dut.a_oe.value = 1 if not a_we else 0\n        dut.b_oe.value = 1 if not b_we else 0\n\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n\n        # Apply pending writes after write latency\n        if a_we:\n            memory[a_addr] = a_wdata\n        if b_we:\n            memory[b_addr] = b_wdata\n\n        # Read data from previous memory state (before writes)\n        if dut.a_oe.value == 1:\n            expected_data = prev_memory[a_addr]\n            read_data = int(dut.a_rdata.value)\n            dut._log.info(f\"Channel A read from addr {a_addr}: {read_data}\")\n            assert read_data == expected_data, f\"Mismatch on Channel A: expected {expected_data}, got {read_data}\"\n\n        if dut.b_oe.value == 1:\n            expected_data = prev_memory[b_addr]\n            read_data = int(dut.b_rdata.value)\n            dut._log.info(f\"Channel B read from addr {b_addr}: {read_data}\")\n            assert read_data == expected_data, f\"Mismatch on Channel B: expected {expected_data}, got {read_data}\"\n\n        # Update prev_memory after read latency\n        prev_memory = memory.copy()\n\n        # Reset controls\n        dut.a_we.value = 0\n        dut.b_we.value = 0\n        dut.a_oe.value = 0\n        dut.b_oe.value = 0\n\n# Function to check corner cases like address overlap between ports A and B\nasync def corner_case_test(dut, depth, width, memory):\n    dut._log.info(\"Testing corner cases\")\n    prev_memory = memory.copy()\n\n    # Case: Same address, one write (Port A), one read (Port B)\n    same_addr = random.randint(0, depth - 1)\n    a_wdata = random.randint(0, 2**width - 1)\n    b_wdata = random.randint(0, 2**width - 1)\n\n    # First, write to the address from port A\n    dut.a_addr.value = same_addr\n    dut.a_we.value = 1\n    dut.a_wdata.value = a_wdata\n    dut.a_oe.value = 0\n\n    dut.b_addr.value = same_addr\n    dut.b_we.value = 0\n    dut.b_oe.value = 1\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    # Apply pending writes after write latency\n    memory[same_addr] = a_wdata\n\n    # Read data from previous memory state\n    expected_data = prev_memory[same_addr]\n    read_data = int(dut.b_rdata.value)\n    dut._log.info(f\"Channel B read: {read_data} before Channel A wrote at addr {same_addr}\")\n    assert read_data == expected_data, f\"Mismatch on Channel B: expected {expected_data}, got {read_data}\"\n    \n    await RisingEdge(dut.clk)\n    expected_data = memory[same_addr]\n    read_data = int(dut.b_rdata.value)\n    dut._log.info(f\"Channel B read: {read_data} after Channel A wrote at addr {same_addr}\")\n    assert read_data == expected_data, f\"Mismatch on Channel B: expected {expected_data}, got {read_data}\"\n    \n\n    # Update prev_memory\n    prev_memory = memory.copy()\n\n    # Reset controls\n    dut.a_we.value = 0\n    dut.b_oe.value = 0\n\n    await RisingEdge(dut.clk)\n\n    # Now, write to the same address from port B while reading from port A\n    dut.b_addr.value = same_addr\n    dut.b_we.value = 1\n    dut.b_wdata.value = b_wdata\n    dut.b_oe.value = 0\n\n    dut.a_addr.value = same_addr\n    dut.a_we.value = 0\n    dut.a_oe.value = 1\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    # Apply pending writes after write latency\n    memory[same_addr] = b_wdata\n\n    # Read data from previous memory state\n    expected_data = prev_memory[same_addr]\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"Channel A read: {read_data} before Channel B wrote at addr {same_addr}\")\n    assert read_data == expected_data, f\"Mismatch on Channel A: expected {expected_data}, got {read_data}\"\n    \n    await RisingEdge(dut.clk)\n    expected_data = memory[same_addr]\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"Channel A read: {read_data} after Channel B wrote at addr {same_addr}\")\n    assert read_data == expected_data, f\"Mismatch on Channel A: expected {expected_data}, got {read_data}\"\n\n    # Update prev_memory\n    prev_memory = memory.copy()\n\n    # Reset controls\n    dut.b_we.value = 0\n    dut.a_oe.value = 0\n\n# Test the case when CE is low\nasync def test_ce_low(dut, depth, width, memory):\n    dut._log.info(\"Testing with CE low\")\n    prev_memory = memory.copy()\n\n    # Set CE low\n    dut.ce.value = 0\n\n    # Try to write to SRAM\n    addr = random.randint(0, depth - 1)\n    data = random.randint(0, 2**width - 1)\n    dut.a_addr.value = addr\n    dut.a_we.value = 1\n    dut.a_wdata.value = data\n    dut.a_oe.value = 0\n\n    await RisingEdge(dut.clk)\n\n    # Memory should not be updated\n    expected_data = prev_memory[addr]\n\n    # Try to read from SRAM\n    dut.a_we.value = 0\n    dut.a_oe.value = 1\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    dut.a_oe.value = 0\n\n    # Read data should be zero as per specification\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"Read data with CE low: {read_data}\")\n    assert read_data == 0, f\"Expected read_data to be 0 when CE is low, got {read_data}\"\n\n    await RisingEdge(dut.clk)\n    # Set CE high to verify that the write didnt make any changes\n    dut.ce.value = 1\n    dut.a_addr.value = addr\n    dut.a_we.value = 0\n    dut.a_oe.value = 1\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    \n    # Read data should be zero as per specification\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"Read data with CE high: {read_data}\")\n    assert read_data == expected_data, f\"Expected read_data to be {expected_data} when CE is high, got {read_data}\"\n    \n    # Reset controls\n    dut.a_oe.value = 0\n\n# Test the case when a_we and a_oe are low while CE is high\nasync def test_no_we_oe(dut, depth, width, memory):\n    dut._log.info(\"Testing with CE high but WE and OE low\")\n    prev_memory = memory.copy()\n\n    dut.ce.value = 1\n    old_rdata =  dut.a_rdata.value\n    dut.a_we.value = 0\n    dut.a_oe.value = 0\n\n    addr = random.randint(0, depth - 1)\n    data = random.randint(0, 2**width - 1)\n    dut.a_addr.value = addr\n    dut.a_wdata.value = data\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    \n    # To confirm if a_oe 0 and ce 1 performs a read.\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"Read data with CE high but WE and OE low: {read_data}\")\n    assert read_data == old_rdata, f\"Expected read_data to be {old_rdata}, got {read_data}\" \n\n    # Since WE and OE are low, no write or read should occur\n    expected_data = prev_memory[addr]\n\n    # Read from SRAM to confirm memory is unchanged\n    dut.a_oe.value = 1\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"Read data with CE,OE high to check previous write during WE low: {read_data}\")\n    assert read_data == expected_data, f\"Expected read_data to be {expected_data}, got {read_data}\"\n\n    # Update prev_memory\n    prev_memory = memory.copy()\n\n    # Reset controls\n    dut.a_oe.value = 0\n\n# Test the case when both WE and OE are high in a read-first module\nasync def test_we_and_oe_high(dut, depth, width, memory):\n    dut._log.info(\"Testing with both WE and OE high (Read-First behavior)\")\n\n    prev_memory = memory.copy()\n\n    dut.ce.value = 1\n\n    addr = random.randint(0, depth - 1)\n    old_data = prev_memory[addr]\n    new_data = random.randint(0, 2**width - 1)\n\n    # Set both WE and OE high\n    dut.a_addr.value = addr\n    dut.a_we.value = 1\n    dut.a_oe.value = 1\n    dut.a_wdata.value = new_data\n\n    await RisingEdge(dut.clk)\n    await RisingEdge(dut.clk)\n    \n    # Read data should be the old written data (read-first behavior)\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"With both WE and OE high, wrote new data {new_data} to addr {addr}, read old data {read_data}\")\n    assert read_data == old_data, f\"Expected read_data to be {old_data}, got {read_data}\"\n\n    # Perform another read to check whether the write was performed after the read was performed when both WE and OE were high\n    \n    await RisingEdge(dut.clk)\n\n    # Read data should be the old written data (read-first behavior)\n    read_data = int(dut.a_rdata.value)\n    dut._log.info(f\"On second read, read new data {read_data}\")\n    assert read_data == new_data, f\"Expected read_data to be {new_data}, got {read_data}\"\n    \n    # Update prev_memory\n    prev_memory = memory.copy()\n\n    # Reset controls\n    dut.a_we.value = 0\n    dut.a_oe.value = 0\n\n\n# Testbench to run\n@cocotb.test()\nasync def test_sram_full_duplex(dut):\n    depth = 2**int(dut.ADDR_WIDTH.value)\n    width = int(dut.DATA_WIDTH.value)\n\n    # Initialize memory model\n    memory = [0] * depth\n\n    # Clock generation\n    clock = Clock(dut.clk, 10, units=\"ns\")  # 100 MHz clock\n    cocotb.start_soon(clock.start())\n\n    # Reset\n    dut.ce.value = 0\n    dut.a_we.value = 0\n    dut.a_oe.value = 0\n    dut.b_we.value = 0\n    dut.b_oe.value = 0\n    await Timer(100, units=\"ns\")  # Wait for reset\n\n    # Chip enable\n    dut.ce.value = 1\n    await RisingEdge(dut.clk)\n    \n    # Initialization phase\n    await init_sram(dut, depth, width, memory)\n    await RisingEdge(dut.clk)\n\n    # Random read/write test (stress test)\n    await random_rw_test(dut, depth, width, memory)\n    await RisingEdge(dut.clk)\n\n    # Corner case test (overlap, simultaneous operations)\n    await corner_case_test(dut, depth, width, memory)\n    await RisingEdge(dut.clk)\n\n    # Test CE low\n    await test_ce_low(dut, depth, width, memory)\n    await RisingEdge(dut.clk)\n\n    # Test with WE and OE low while CE high\n    await test_no_we_oe(dut, depth, width, memory)\n    await RisingEdge(dut.clk)\n\n    # Test with both WE and OE high (WE has priority)\n    await test_we_and_oe_high(dut, depth, width, memory)\n    await RisingEdge(dut.clk)\n"}}}
{"id": "cvdp_copilot_static_branch_predict_0032", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add assertions in the RTL design of the `static_branch_predict` module to ensure its correct functionality during simulation? The assertions should specifically validate the branch target and branch-taken signals, and they must trigger clear error messages when any violation occurs.\n\nThe assertions should cover the following conditions:\n\n**1. Branch Target (`predict_branch_pc_o`) Validation**:\nAt every clock cycle, after a 10-time unit delay, the predicted branch PC (`predict_branch_pc_o`) must equal the sum of `fetch_pc_i` and the computed branch immediate (`branch_imm`). If this equality is not met, the assertion should trigger an error message displaying the expected value (`i.e.,fetch_pc_i + branch_imm`)  versus the actual  `predict_branch_pc_o` that  does not match.\n\n**2. Branch Taken (`predict_branch_taken_o`) Validation**:\nAt every clock cycle, after 10-time units delay, the branch is taken signal (`predict_branch_taken_o)` must equal the result of the logical AND of `fetch_valid_i` and the logical OR of `instr_jal`, `instr_jalr`, `instr_cj`, `instr_b_taken`. If this condition is violated, the assertion should trigger an error message showing the expected outcome versus the actual `predict_branch_taken_o` does not match.\n\nFollowing should be the interface of the RTL design of the Static Branch Predict module named `static_branch_predict`.\n## Interface:\n### **Inputs**:\n- `clk (1-bit)`: Clock signal for executing the assertions.\n- `fetch_rdata_i (32-bit,[31:0])`: Instruction fetched from the fetch stage.\n- `fetch_pc_i (32-bit,[31:0])`: Program counter corresponding to the fetched instruction.\n- `register_addr_i (32-bit,[31:0])`: Register address or value used for the immediate value for JALR instruction.\n- `fetch_valid_i (1-bit)`: Indicates that the fetch stage has provided a valid instruction.\n\n### **Outputs**:\n- `predict_branch_taken_o (1-bit)`: Indicates whether the branch is predicted to be taken.\n- `predict_branch_pc_o (32-bit,[31:0])`: The calculated branch target PC based on the immediate value for each branch instruction.", "context": {"rtl/static_branch_predict.sv": "module static_branch_predict (\n  input  logic  clk,\n  // Instruction from fetch stage\n  input  logic [31:0] fetch_rdata_i,\n  input  logic [31:0] fetch_pc_i,\n  input  logic [31:0] register_addr_i,\n  input  logic        fetch_valid_i,\n\n  // Prediction for supplied instruction\n  output logic        predict_branch_taken_o,\n  output logic [31:0] predict_branch_pc_o\n);\n  logic [31:0] reg_addr;\n  logic [31:0] imm_jal_type;\n  logic [31:0] imm_jalr_type;\n  logic [31:0] imm_b_type;\n  logic [31:0] imm_cj_type;\n  logic [31:0] imm_cb_type;\n\n  logic [31:0] branch_imm;\n\n  logic [31:0] instr;\n\n  logic instr_jal;\n  logic instr_jalr;\n  logic instr_b;\n  logic instr_cj;\n  logic instr_cb;\n\n  logic instr_b_taken;\n  \n    \n  localparam OPCODE_BRANCH = 7'h63;\n  localparam OPCODE_JAL    = 7'h6F;\n  localparam OPCODE_JALR   = 7'h67;\n\n  assign instr = fetch_rdata_i;\n  assign reg_addr = register_addr_i;\n\n  assign imm_jal_type = { {12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 };\n  assign imm_jalr_type = {{20{instr[31]}}, instr[31:20]}+reg_addr;\n  assign imm_b_type = { {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 };\n\n  assign imm_cj_type = { {20{instr[12]}}, instr[12], instr[8], instr[10:9], instr[6], instr[7],\n    instr[2], instr[11], instr[5:3], 1'b0 };\n\n  assign imm_cb_type = { {23{instr[12]}}, instr[12], instr[6:5], instr[2], instr[11:10],\n    instr[4:3], 1'b0};\n\n  assign instr_b    = instr[6:0] == OPCODE_BRANCH;\n  assign instr_jal  = instr[6:0] == OPCODE_JAL;\n  assign instr_jalr = instr[6:0] == OPCODE_JALR;\n\n  assign instr_cb = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b110) | (instr[15:13] == 3'b111));\n  assign instr_cj = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b101) | (instr[15:13] == 3'b001));\n\n always_comb begin\n    branch_imm = imm_b_type;\n\n    case(1'b1)\n      instr_jal  : branch_imm = imm_jal_type;\n      instr_jalr : branch_imm = imm_jalr_type;\n      instr_b    : branch_imm = imm_b_type;\n      instr_cj   : branch_imm = imm_cj_type;\n      instr_cb   : branch_imm = imm_cb_type;\n      default    : ;\n    endcase\n  end\n  \n  assign instr_b_taken = (instr_b & imm_b_type[31]) | (instr_cb & imm_cb_type[31]);\n  assign predict_branch_taken_o = fetch_valid_i & (instr_jal | instr_jalr | instr_cj | instr_b_taken);\n  assign predict_branch_pc_o    = fetch_pc_i + branch_imm;\n  \nendmodule"}}, "output": {"response": "", "context": {"rtl/static_branch_predict.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/static_branch_predict.sv\nTOPLEVEL        = static_branch_predict\nMODULE          = test_static_branch_predict\nPYTHONPATH      = /src\nHASH            = 32-static_branch_predict_tb_assertion_generation\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_static_branch_predict.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import Timer\nfrom random import randint\n\n# Cocotb testbench for static branch predictor module\n@cocotb.test()\nasync def test_static_branch_predict(dut):\n    \"\"\"Test Static Branch Predictor for different branch and jump scenarios.\"\"\"\n    dut.clk.value = 0\n           \n    # Clock generation\n    clock = Clock(dut.clk, 10, units=\"ns\")\n    cocotb.start_soon(clock.start())\n    # Define the test vectors based on the SystemVerilog run_test_case task\n    test_vectors = [\n        # Format: (test_instr, test_pc, test_register_operand, test_valid, expected_taken, expected_pc, case_name)\n        (0x8C218363, 0x00001000, 0x00000000, 1, 1, 0x000000C6, \"Branch taken, PC offset negative (B-type), [BEQ]\"),\n        (0x6C2183E3, 0x00001000, 0x00000000, 1, 0, 0x00001EC6, \"Branch taken, PC offset positive (B-type), [BEQ]\"),\n        (0x926CF16F, 0x00001000, 0x00000000, 1, 1, 0xFFFD0126, \"Jump taken (J-type) with negative offset, [JAL]\"),\n        (0x126CF16F, 0x00001000, 0x00000000, 1, 1, 0x000D0126, \"Jump taken (J-type) with positive offset, [JAL]\"),\n        (0xF63101E7, 0x00001000, 0x00000000, 1, 1, 0x00000F63, \"Jump taken (JALR) with negative offset, [JALR]\"),\n        (0x763101E7, 0x00001000, 0x00000000, 1, 1, 0x00001763, \"Jump taken (JALR) with positive offset, [JALR]\"),\n        (0x4840006F, 0x00001000, 0x00000000, 1, 1, 0x00001484, \"Compressed Jump taken (J-type) with positive offset, [C.J]\"),\n        (0x484000EF, 0x00001000, 0x00000000, 1, 1, 0x00001484, \"Compressed Jump taken (J-type) with positive offset, [C.JAL]\"),\n        (0x08040A63, 0x00001000, 0x00000000, 1, 0, 0x00001094, \"Compressed Branch Taken, PC offset positive (B-type), [C.BEQZ]\"),\n        (0x00000001, 0x00002000, 0x00000000, 0, 0, 0x00002000, \"Invalid fetch (not valid)\"),\n        (0x00000000, 0x00002000, 0x00000000, 1, 0, 0x00002000, \"No branch or jump\"),\n        (0xFE000E63, 0x00001000, 0x00000000, 1, 1, 0x000007FC, \"Improper Instruction Encoding\"),\n    ]\n\n    # Iterate through the test vectors and apply them to the DUT\n    for (test_instr, test_pc, test_register_operand, test_valid, expected_taken, expected_pc, case_name) in test_vectors:\n        # Apply inputs\n        dut.fetch_rdata_i.value = test_instr\n        dut.fetch_pc_i.value = test_pc\n        dut.register_addr_i.value = test_register_operand\n        dut.fetch_valid_i.value = test_valid\n\n        # Wait for the DUT to process the inputs\n        await Timer(10, units=\"ns\")\n\n        # Capture the outputs\n        actual_taken = dut.predict_branch_taken_o.value\n        actual_pc = dut.predict_branch_pc_o.value\n\n        # Log the test case details\n        dut._log.info(f\"Running test case: {case_name}\")\n        dut._log.info(f\"fetch_rdata_i: {test_instr:08X}, fetch_pc_i: {test_pc:08X}, Register Operand: {test_register_operand:08X}, Valid: {test_valid}\")\n        dut._log.info(f\"Expected Taken: {expected_taken}, Actual Taken: {actual_taken}\")\n        dut._log.info(f\"Expected PC: {expected_pc:08X}, Actual PC: {int(actual_pc):08X}\")  # Fixed the error here\n\n        # Assertions to check if outputs match expectations\n        assert actual_taken == expected_taken, f\"{case_name} - Predict Branch Taken Mismatch: Expected {expected_taken}, Got {actual_taken}\"\n        assert int(actual_pc) == expected_pc, f\"{case_name} - Predict Branch PC Mismatch: Expected {expected_pc:08X}, Got {int(actual_pc):08X}\"\n\n        # Wait for a short time before the next test case\n        await Timer(10, units=\"ns\")\n\n    # Additional random test cases\n    num_random_tests = 10  # Number of random tests to generate\n    for i in range(num_random_tests):\n        # Generate random values for instruction, PC, register operand, and valid signal\n        test_instr = randint(0, 0xFFFFFFFF)\n        test_pc = randint(0, 0xFFFFFFFF)\n        test_register_operand = randint(0, 0xFFFFFFFF)\n        test_valid = randint(0, 1)\n\n        # Apply inputs\n        dut.fetch_rdata_i.value = test_instr\n        dut.fetch_pc_i.value = test_pc\n        dut.register_addr_i.value = test_register_operand\n        dut.fetch_valid_i.value = test_valid\n\n        # Wait for the DUT to process the inputs\n        await Timer(10, units=\"ns\")\n\n        # Capture the outputs\n        actual_taken = dut.predict_branch_taken_o.value\n        actual_pc = dut.predict_branch_pc_o.value\n\n        # Log the random test case details\n        dut._log.info(f\"Random Test Case {i + 1}\")\n        dut._log.info(f\"fetch_rdata_i: {test_instr:08X}, fetch_pc_i: {test_pc:08X}, Register Operand: {test_register_operand:08X}, Valid: {test_valid}\")\n        dut._log.info(f\"Predict Branch Taken: {actual_taken}, Predict Branch PC: {int(actual_pc):08X}\")  # Fixed the error here\n\n        # Randomized cases do not have specific expected values, so only check for consistency of output types and log results\n        assert actual_taken in [0, 1], f\"Random Test Case {i + 1} - Invalid Predict Branch Taken Output: Got {actual_taken}\"\n        assert isinstance(int(actual_pc), int), f\"Random Test Case {i + 1} - Predict Branch PC Output Not Integer: Got {int(actual_pc)}\"\n\n        # Wait for a short time before the next random test case\n        await Timer(10, units=\"ns\")\n\n"}}}
{"id": "cvdp_copilot_swizzler_0023", "categories": ["cid014", "easy"], "input": {"prompt": "Can you add immediate assertions in the RTL design of the `swizzler` module to ensure its correct functionality during simulation? The assertion should cover key aspects of the swizzler\u2019s operation, such as correct mapping of each input bit (`data_in[i]`) to the proper output bit (`data_out[j]`) based on the `MAPPING` parameter. The assertion should display an error message if any output bit does not match its expected value.\n\n---\n\n## **Key Assertions**\n\n### **1. Correct Bit Mapping**\n- **Condition**:  \n  - For each output bit index `i`, `data_out[i]` must be equal to `data_in[map_idx[i]]` when `map_idx[i]` is within the valid range \\([0, N-1]\\).  \n  - If `map_idx[i]` is out of range, `data_out[i]` should be driven to `0`.\n- **Assertion**:  \n  - Check that `data_out[i]` matches the expected bit from `data_in` based on `map_idx[i]`.  \n  - If there\u2019s a mismatch, display an error message with the expected vs. actual values along with relevant inputs (e.g., `data_in`, `map_idx`).\n\n---\n\n## **Interface**\n\n### **Parameters**\n1. `N` : Configurable width of the data path.  \n2. `MAPPING` : Parameter array specifying the bit mapping from input to output.\n\n### **Inputs**\n\n1. `data_in [N-1:0]` : Input bus to be swizzled.\n2. (Optional) Any other control signals you may wish to include for additional debugging or behavior changes.\n\n### **Outputs**\n\n1. `data_out [N-1:0]` : Output bus that reflects the mapped result.\n\n### **Expected Behavior**  \nIf the assertion fails, they should generate an **error message** indicating the incorrect behavior.", "context": {"rtl/swizzler.sv": "`timescale 1ns/1ps\nmodule swizzler #(\n    parameter int N = 8,\n    parameter [N*$clog2(N)-1:0] MAPPING = {\n        3'd7, 3'd5, 3'd6, 3'd4, 3'd3, 3'd1, 3'd2, 3'd0\n    }\n)(\n    input  logic [N-1:0] data_in,\n    output logic [N-1:0] data_out\n);\n    localparam int M = $clog2(N);\n    logic [M-1:0] map_idx [N-1:0];\n\n    genvar j;\n    generate\n        for (j = 0; j < N; j++) begin : lane_mapping\n            assign map_idx[j] = MAPPING[j*M +: M];\n        end\n    endgenerate\n\n    always_comb begin\n        for (int i = 0; i < N; i++) begin : lane_mapping\n            if (map_idx[i] >=0 && map_idx[i] < N) begin\n                data_out[i] = data_in[map_idx[i]];\n            end else begin\n                data_out[i] = 1'b0;\n            end\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/swizzler.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb\n", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/swizzler.sv\nTOPLEVEL        = swizzler\nMODULE          = test_swizzler\nPYTHONPATH      = /src\nHASH            = 23-assertion-generation-for-intial-level-rtl\n", "src/test_runner.py": "import os\nimport re\nimport pytest\nimport subprocess\nfrom cocotb.runner import get_runner\n\n# Read environment variables\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n# Additional parameters\nN_default       = \"8\"\nMAPPING_default = \"{3'd7,3'd5,3'd6,3'd4,3'd3,3'd1,3'd2,3'd0}\"\n\nN_val = os.getenv(\"N\", N_default)\nMAPPING_val = os.getenv(\"MAPPING\", MAPPING_default)\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    runner = get_runner(sim)\n\n    # Pass parameters to the HDL build\n    # For Verilog: these become module parameters in your DUT\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        parameters={\n            \"N\":       N_val,\n            \"MAPPING\": MAPPING_val\n        },\n        build_args=(\n            \"-coverage\",\n            \"all\",\n            \"-covoverwrite\",\n            \"-covtest\",\n            \"test\"\n        ),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(\n        hdl_toplevel=toplevel,\n        test_module=module,\n        waves=True\n    )\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    # Example coverage report command (Mentor/Siemens or Cadence tools vary)\n    cmd = (\n        'imc -load /code/rundir/sim_build/cov_work/scope/test '\n        '-execcmd \"report -metrics assertion -all -aspect sim '\n        '-assertionStatus -overwrite -text -out coverage.log\"'\n    )\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage report generation failed.\"\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {\n            column[i]: info[i].split('%')[0] for i in range(1, len(column))\n        }\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) \\\n            >= float(os.getenv(\"TARGET\", \"90.0\")), \"Coverage below target.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.0, \\\n            \"Assertion coverage below 100%.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) \\\n            >= float(os.getenv(\"TARGET\", \"90.0\")), \"Toggle coverage below target.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) \\\n            >= float(os.getenv(\"TARGET\", \"90.0\")), \"Block coverage below target.\"\n    else:\n        assert False, \"No recognized coverage metric found.\"\n\nif __name__ == \"__main__\":\n    test_simulate()\n", "src/test_swizzler.py": "import os\nimport random\nimport cocotb\nfrom cocotb.triggers import Timer\n\n@cocotb.test()\nasync def test_swizzler_random(dut):\n   \n    N = int(os.getenv(\"N\", \"8\"))\n   \n    cocotb.log.info(f\"Starting swizzler random test with N={N}\")\n    for cycle in range(16):\n        val = random.randint(0, (1 << N) - 1)\n        dut.data_in.value = val\n        await Timer(10, units=\"ns\")\n        cocotb.log.info(f\"Cycle: {cycle}, data_in={val:0{N}b}, data_out={int(dut.data_out.value):0{N}b}\")\n\n    cocotb.log.info(\"All random cycles completed.\")\n"}}}
{"id": "cvdp_copilot_sync_serial_communication_0053", "categories": ["cid014", "medium"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the `sync_serial_communication_tx_rx `module, which integrates a `tx_block`, `rx_block`, `crc_generation`, `crc_detection` and `onebit_ecc`. The module details and design requirements for assertion development are outlined below.\n\n## Specifications\n\n**Interface:**\n\n**Parameters:**\n- `DATA_WIDTH` (default: 16): Width of input and output data.\n- `CODE_WIDTH`:  Encoded width for ECC (`DATA_WIDTH + $clog2(DATA_WIDTH + 1)`)\n- `CRC_WIDTH`: Width of CRC output(`DATA_WIDTH/2`)\n- `POLY`: Polynomial for CRC computation.  Default is 8.\n\n**Inputs:**\n- `clk`: Clock signal that runs at a 50:50 duty cycle. Design works on the Posedge of the clk.\n- `reset_n`: Active LOW asynchronous reset signal.\n- `sel [2:0]`: Selection signal for TX block.\n- `data_in([DATA_WIDTH-1:0])`: Data input for TX block.\n- `received_1([CODE_WIDTH-1:0])`: Received encoded data.\n- `received_2([CODE_WIDTH-1:0])`: Second received encoded data.\n- `enable_crc_error`: Enable bit for CRC error generation.\n\n**Outputs:**\n- `data_out([DATA_WIDTH-1:0])`: Output data from RX block.\n- `done`: Signal indicating completion.\n- `parity_error`: Parity error flag.\n- `encoded_received_TX([CODE_WIDTH-1:0])`: Transmitted ECC-encoded output.\n- `encoded_2([CODE_WIDTH-1:0])`: ECC-encoded output from received data.\n- `crc_out([CRC_WIDTH-1:0])`: CRC output.\n- `error_detected_1`: ECC error detected in transmitter.\n- `error_corrected_1`: ECC error corrected in transmitter.\n- `error_detected_2`: ECC error detected in receiver.\n- `error_corrected_2`: ECC error corrected in receiver.\n- `crc_error_detected`: CRC error detection flag.\n\n## Module Overview\nThe `sync_serial_communication_tx_rx ` module integrates: \n- TX Block (`tx_block`): Serializes data_in, computes a parity bit, and transmits data serially.\n- RX Block (`rx_block`): Receives and deserializes data while checking for parity errors.\n- ECC Generator (`onebit_ecc`): Adds parity bits, detects, and corrects single-bit errors.\n- CRC Generator (`crc_generation`): Computes CRC using POLY for error detection.\n- CRC Detector (`crc_detection`): Verifies received CRC and detects mismatches.\n## Behavioral Specifications\n**1. **Transmisson(`tx_block`)****\nThe `tx_block` serializes the `data_in` based on the `sel` input:\n- `sel == 3'b000`: No transmission, `data_out` remains 0.\n- `sel == 3'b001`: Transmits the 8 least significant bits.\n- `sel == 3'b010`: Transmits the 16 least significant bits.\n- `sel == 3'b011`: Transmits the 32 least significant bits.\n- `sel == 3'b100`: Transmits the entire 64-bit data.\n- A parity bit is computed as the XOR of all transmitted bits (^`data_in`).\n- A done signal is asserted when transmission completes.\n\n**2. **Reception(`rx_block`)****\n- The `rx_block`receives serial data and reconstructs `data_out`.\n- The `parity_error` flag is asserted if the received parity bit does not match the computed parity.\n- The done signal is asserted once deserialization is complete.\n\n**3. **One bit ECC(`onebit_ecc`)****\n- Detects and Corrects single-bit errors (`error_corrected_1`, `error_corrected_2`).\n- The RX block processes the received ECC data and reconstructs the original `data_out`.\n\n**4. **CRC Computation(`crc_generation`)****\n- The CRC generator calculates a cyclic redundancy check (CRC) using the given polynomial (`POLY`).\n- The CRC output (`crc_out`) is used for error detection.\n\n**5. **CRC Detection****\n- The CRC detector verifies whether the received CRC matches the computed CRC.\n- If there is a mismatch, `crc_error_detected` is asserted.\n\n## Assertion Requirements\n\n**1.Validating Parity Bit Positions**\n-  Ensure that parity bits are correctly positioned at power-of-2 indices in data_out.\n\n**2.CRC Detection Without Error**\n- Ensures that when `enable_crc_error` is disabled, the received data must match the original received data.\n\n**3.CRC Detection With Error**\n- Ensures that when `enable_crc_error` is enabled, the received data is set to 1, simulating an error scenario.\n\n**4.No ECC Error Detection When Encoded Data Matches**\n- Ensures that when `encoded_2` is equal to encoded_received_temp, both `error_detected_2` and `error_corrected_2` must remain 0.\n\n**5.ECC Data Integrity Check**\n- Ensures that when the received ECC-encoded data (`encoded_2`) matches the expected encoded data, the ECC-corrected output (`data_out`) must be identical to the original input (`data_in`).\n\n**6.TX Done Signal Correctness**\n- The `done` signal in the TX module must be asserted HIGH when the bit count reaches zero for certain values of `sel` signal, namely `sel = 3b001` ,`sel = 3b010`, `sel = 3b011` and `sel = 3b100`.\n\n**7.RX Data Stability During Reception**\n- Ensures that `data_out` remains unchanged while the reception process is still ongoing (`done == 0`).\n\n**8.No CRC Error Detection When CRC Matches**\n- Ensures that if the computed CRC (`calculated_crc`) matches the received CRC (`received_crc`), the `error_detected` signal must remain 0 (no error).\n\n**9.CRC Error Detection When CRC Mismatch Occurs**\n- Ensures that when `error_detected` is 1, the computed CRC (`calculated_crc`) must not match the received CRC (`received_crc`).\n\n**10.Parity Check**\n- Ensures that when done is HIGH and the parity of `data_in` matches the parity of data_out_rx, the `parity_error` signal must remain LOW.\n\n---\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.", "context": {"rtl/sync_serial_communication_top.sv": "`timescale 1ns / 1ps\nmodule sync_serial_communication_tx_rx#(parameter DATA_WIDTH = 16,\n                                        parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1),\n                                        parameter CRC_WIDTH = ((DATA_WIDTH)/2),\n                                        parameter POLY = 8)(\n    input clk,                                      // Clock signal\n    input reset_n,                                  // Active low reset signal\n    input [2:0] sel,                                // Selection signal for TX block\n    input [DATA_WIDTH-1:0] data_in,                 // 64-bit data input for TX block\n    output [DATA_WIDTH-1:0] data_out,               // 64-bit data output from RX block\n    output done,                                    // Done signal indicating completion\n    output parity_error,                            // parity error flag\n    input [CODE_WIDTH-1:0] received_1,              // Received encoded data\n    input [CODE_WIDTH-1:0] received_2,              // Received encoded data\n    input enable_crc_error,                         // enable bit for crc error  generation \n    output [CODE_WIDTH-1:0] encoded_received_TX,    // Encoded output transmitted_ecc\n    output [CODE_WIDTH-1:0] encoded_2,              // Encoded output of received_ecc\n    output [CRC_WIDTH-1:0] crc_out,                 // crc output\n    output error_detected_1,                        // Error detected flag for ECC transmitter\n    output error_corrected_1,                       // Error corrected flag for ECC transmitter \n    output error_detected_2,                        // Error detected flag for  ECC receiver\n    output error_corrected_2,                        // Error corrected flag for ECC receiver\n    output crc_error_detected                       // Error detected flag for CRC\n);\n\n// Internal signals\nwire tx_out;                       \nwire tx_done;                      \nwire serial_clk_in;  \nwire parity;    \nwire [DATA_WIDTH-1:0] data_out_rx;\nwire [DATA_WIDTH-1:0] data_out1;\nwire [DATA_WIDTH-1:0] data_out2;\nwire [CODE_WIDTH-1:0] encoded_received_temp;\nwire [CODE_WIDTH-1:0] encoded_received_temp2;\nwire [CRC_WIDTH-1:0] crc_out_1;\nreg [CRC_WIDTH-1:0] crc_out_temp;\nreg [DATA_WIDTH-1:0] data_out_rx_temp;\n\n\nonebit_ecc#(.DATA_WIDTH(DATA_WIDTH),.CODE_WIDTH(CODE_WIDTH)) uut_onebit_ecc1 (\n\n    .data_in(data_in),\n    .encoded(encoded_received_TX),\n    .received(encoded_received_temp2),\n    .data_out(data_out1),\n    .error_detected(error_detected_1),\n    .error_corrected(error_corrected_1)\n    );\n\ncrc_generation# (.DATA_WIDTH(DATA_WIDTH),.CRC_WIDTH(CRC_WIDTH),.POLY(POLY)) uut_crc_1 (\n\n    .clk(clk),\n    .rst(!reset_n),\n    .data_in(data_in),\n    .crc_out(crc_out)\n\n);\n\nassign crc_out_1 = crc_out;\n\n// Instantiate the TX block\ntx_block#(.DATA_WIDTH(DATA_WIDTH)) uut_tx_block (\n    .clk(clk),                     // Clock input to TX block\n    .reset_n(reset_n),             // Reset input to TX block\n    .data_in(data_in),             // 64-bit data input to TX block\n    .sel(sel),                     // Selection signal to TX block\n    .serial_out(tx_out),           // Serial data output from TX block\n    .done(tx_done),                // Done signal from TX block\n    .serial_clk(serial_clk_in),    // Serial clock output from TX block\n    .parity(parity)                // parity bit\n);\n\n// Instantiate the RX block\nrx_block#(.DATA_WIDTH(DATA_WIDTH)) uut_rx_block (\n    .clk(clk),                     // Clock input to RX block\n    .serial_clk(serial_clk_in),    // Serial clock input to RX block\n    .reset_n(reset_n),             // Reset input to RX block\n    .sel(sel),                     // Selection signal to RX block\n    .data_in(tx_out),              // Serial data input to RX block\n    .parity_in(parity),            // received parity bit\n    .data_out(data_out_rx),           // 64-bit data output from RX block\n    .done(done),                   // Done signal from RX block\n    .parity_error(parity_error)    // parity error flag\n    \n);\n\nalways@(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n        crc_out_temp    <= 0;\n        data_out_rx_temp <= 0;\n    end\n    else begin\n    if(done == 1) begin\n        if(enable_crc_error == 0) begin\n            crc_out_temp <= crc_out_1;\n            data_out_rx_temp <= data_out_rx;\n        end\n        else begin\n        crc_out_temp <= crc_out_1;\n        data_out_rx_temp <= 1;\n        end\n    end\n    else begin\n        crc_out_temp <= 0;\n        data_out_rx_temp <= 0;\n    end\nend\nend\n\n\nonebit_ecc#(.DATA_WIDTH(DATA_WIDTH),.CODE_WIDTH(CODE_WIDTH)) uut_onebit_ecc2 (\n\n    .data_in(data_out_rx),\n    .encoded(encoded_2),\n    .received(encoded_received_temp),\n    .data_out(data_out),\n    .error_detected(error_detected_2),\n    .error_corrected(error_corrected_2)\n    );\n\ncrc_detection# (.DATA_WIDTH(DATA_WIDTH),.CRC_WIDTH(CRC_WIDTH),.POLY(POLY)) uut_crc_detection (\n\n    .clk(clk),\n    .rst(!reset_n),\n    .data_in(data_out_rx_temp),\n    .received_crc(crc_out_temp),\n    .error_detected(crc_error_detected)\n\n);\n\n\nassign encoded_received_temp = received_2 | encoded_received_temp2;\nassign encoded_received_temp2 = encoded_received_TX;\nendmodule\n\n///// tx_block\nmodule tx_block#(parameter DATA_WIDTH = 8)(\n    input clk,               // Clock input\n    input reset_n,           // Active-low reset input\n    input [DATA_WIDTH-1:0] data_in,    // 64-bit parallel data input\n    input [2:0] sel,         // Selection input to choose data width\n    output reg serial_out,   // Serial data output\n    output reg done,         // Done signal indicating completion of transmission\n    output serial_clk,       // Clock for serial data transmission\n    output reg parity        // parity bit\n);\n\n// Internal registers\nreg [DATA_WIDTH-1:0] data_reg;       \nreg [6:0] bit_count;         \nreg [6:0] reg_count;        \nreg [6:0] temp_reg_count;    \n\n\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        // Reset all values on active-low reset\n        data_reg     <= {DATA_WIDTH{1'b0}};\t\t\t     \t           \n        bit_count    <= 7'h0;\t\t\t     \t           \n        reg_count    <= 7'h0;\t\n        parity       <= 1'b0;\t             \t       \n    end else begin\n        if (done == 1'b1) begin\n            case (sel)\n                3'b000: begin\n                    data_reg  <= 64'h0;             \t   \n                    bit_count <= 7'd0; \n                    parity    <= 1'b0;                    \n                end\n                3'b001: begin\n                    data_reg  <= {56'h0, data_in[7:0] };  \n                    bit_count <= 7'd7;\n                    parity    <= ^data_in[7:0];              \t   \n                end\n                3'b010: begin\n                    if (DATA_WIDTH >= 16) begin\n                        data_reg  <= { {(DATA_WIDTH - 16){1'b0}}, data_in[15:0] }; \n                        bit_count <= 7'd15; \n                        parity    <= ^data_in[15:0];\n                    end             \t   \n                end\n                3'b011: begin\n                    if (DATA_WIDTH >= 32) begin\n                        data_reg  <= { {(DATA_WIDTH - 32){1'b0}}, data_in[31:0] };\n                        bit_count <= 7'd31;  \n                        parity    <= ^data_in[31:0];\n                    end            \t \n                end\n                3'b100: begin\n                    if (DATA_WIDTH >= 64) begin\n                        data_reg  <={data_in[63:0] };   \t   \n                        bit_count <= 7'd63; \n                        parity    <= ^data_in[63:0];\n                    end             \t   \n                end\n                default: begin\n                    data_reg  <= {DATA_WIDTH{1'b0}};             \t   \n                    bit_count <= 7'h0; \n                    parity    <= 1'b0;              \t   \n                end\n            endcase\n           \n        end else if (bit_count > 7'h0) begin\n            data_reg   <= data_reg >> 1;                   \n            bit_count  <= bit_count - 1'b1;                \n            \n        end\n        reg_count <= bit_count;                            \n    end\nend\n\n// Generate serial clock based on reg_count\n//`ifdef SIMULATION\nassign  #1 serial_clk = clk && (temp_reg_count !== 7'd0) ; \n//`else\n//assign  serial_clk = clk && (temp_reg_count !== 7'd0) ;  \n//`endif\n\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n        temp_reg_count <= 7'h0;\t\t\t\t\t           \n    end\n    else begin\n        temp_reg_count <= reg_count;\t\t\t        \n    end\nend\n\n\n\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n\t   serial_out <= 1'b0;\t\t\t\t                \n    end\n    else if(reg_count > 7'h0 || bit_count > 7'h0) begin\n\t   serial_out <= data_reg[0];\t\t\t              \n    end\nend \n\nalways@(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n        done <= 1'b0;\t\t\t\t\t                  \n    end \n    else begin\n     if(bit_count == 7'h0) begin\n\t    done <= 1'b1; \t\t\t                          \n     end\n     else begin \n\t    done <= 1'b0;\t\t\t\t\t                  \n     end\nend\nend\n\n\nendmodule\n\n///// rx_block\nmodule rx_block#(parameter DATA_WIDTH = 8)(\n    input wire clk,  \t\t\t    // clock input\n    input wire reset_n,\t\t\t    // Active-low reset\n    input wire data_in,\t\t\t    // Serial input data\t\n    input wire serial_clk,\t\t    // Clock signal for serial data\n    input wire [2:0] sel,           // Selection output to choose data width\n    input wire parity_in,           // received parity\n    output reg done,\t\t\t    // Done signal to indicate data reception complete\t\t\n    output reg [DATA_WIDTH-1:0] data_out,  \t// Parallel output data after serial operation\n    output reg parity_error         // parity_error flag\n\n);\n\n    // Internal registers\n    reg [DATA_WIDTH-1:0] data_reg;\t\t    \n    reg [7:0] bit_count;\t\t   \n    reg [7:0] count;\t\t    \n\n    \n    always @(posedge serial_clk or negedge  reset_n) begin\n        if (!reset_n) begin\t\t    \n            data_reg <= {DATA_WIDTH{1'b0}};\t\t\n            bit_count <= 8'd0;\t\t\n        end else begin\n            if(done == 1'b1) begin                   \n                bit_count <= 8'b0;\n                data_reg <= {DATA_WIDTH{1'b0}};\n            end\n            else begin\n                 bit_count <= bit_count;\t\t\t\n            end\n                bit_count <= bit_count + 1'b1;\t     \n                data_reg[bit_count]<=data_in; \t     \n           end\n    end  \n    \n    \n    always@(posedge clk or negedge reset_n) begin\n    \tif(!reset_n) begin\t\t\t \t             \n    \t   count <= 8'd0;\t\t\t\t\t         \n           done <= 1'b0;\t\t\t\t\t         \n           data_out <= {DATA_WIDTH{1'b0}};\t\t\t\t\t     \n           parity_error  <= 1'b0;\t\t\t\t \n        end \n        else if(count >= bit_count && count != 8'd0) begin      \n           done <= 1'b1;\t\t\t\t             \n           case(sel)\n            3'b000:begin\n                data_out <= {DATA_WIDTH{1'b0}};\t\n                parity_error <= 1'b0;                   \n            end\n            3'b001:begin\n                if(parity_in == (^data_reg[7:0])) begin\n                    data_out <= {56'h0, data_reg[7:0]};\n                    parity_error <= 1'b0;\n                end    \n                else begin\n                    data_out <= {56'h0, data_reg[7:0]};\n                    parity_error <= 1'b1;\n                end   \n            end\n            3'b010:begin\n                if (DATA_WIDTH >= 16) begin\n                    if(parity_in == (^data_reg[15:0])) begin\n                        data_out <= {48'h0, data_reg[15:0]};    \n                        parity_error <= 1'b0;\n                    end    \n                    else begin\n                        data_out <= {48'h0, data_reg[15:0]}; \n                        parity_error <= 1'b1;\n                    end\n                end       \n            end\n            3'b011:begin\n                if (DATA_WIDTH >= 32) begin\n                    if(parity_in == (^data_reg[31:0])) begin\n                        data_out <= {32'h0, data_reg[31:0]};  \n                        parity_error <= 1'b0;\n                    end    \n                    else begin\n                        data_out <= {32'h0, data_reg[31:0]};  \n                        parity_error <= 1'b1;\n                    end\n                end        \n            end\n            3'b100:begin\n                if (DATA_WIDTH >= 64) begin\n                    if(parity_in == (^data_reg[63:0])) begin\n                        data_out <= {data_reg[63:0]};   \n                        parity_error <= 1'b0;\n                    end    \n                    else begin\n                        data_out <= {data_reg[63:0]}; \n                        parity_error <= 1'b1;\n                    end \n                end             \n            end\n            default:begin\n                data_out <= {DATA_WIDTH{1'b0}};    \n                parity_error <= 1'b0;               \n            end\n           endcase\n        end\n        else if(bit_count > 8'd0) begin              \n           count <= count+ 1'b1;\t\t\t\t     \n           done <= 1'b0;\t\t\t\t\t        \n        end\n        else begin  \t\t\t                     \n           count <= 8'd0;\t\t\t\t\t         \n           done <= 1'b0;\t\t\t\t\t           \n        end \n    end\nendmodule\n\nmodule onebit_ecc #(\n    parameter DATA_WIDTH = 4,                                  // Width of the data input\n    parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1) // Encoded width\n)(\n    input [DATA_WIDTH-1:0] data_in,                     // Input data\n    output reg [CODE_WIDTH-1:0] encoded,                // Encoded output\n    input [CODE_WIDTH-1:0] received,                    // Received encoded data\n    output reg [DATA_WIDTH-1:0] data_out,               // Corrected output\n    output reg error_detected,                          // Error detected flag\n    output reg error_corrected                          // Error corrected flag\n);\n\n    localparam PARITY_BITS = CODE_WIDTH - DATA_WIDTH;   // Number of parity bits\n\n    reg [PARITY_BITS-1:0] syndrome;                     // Syndrome for error detection\n    reg [CODE_WIDTH-1:0] corrected_data;                // Corrected received data\n\n\n    integer idx_i, idx_j, idx_k;\n    integer idx_m, idx_n;\n    integer idx_p, idx_q;\n\n\n    always @(*) begin\n        encoded = 0;\n        idx_k = 0;\n\n\n        for (idx_i = 0; idx_i < CODE_WIDTH; idx_i = idx_i + 1) begin\n            if ((idx_i + 1) & (idx_i)) begin\n                encoded[idx_i] = data_in[idx_k];\n                idx_k = idx_k + 1;\n            end\n        end\n\n\n        for (idx_i = 0; idx_i < PARITY_BITS; idx_i = idx_i + 1) begin\n            encoded[(1 << idx_i) - 1] = 0; \n            for (idx_j = 0; idx_j < CODE_WIDTH; idx_j = idx_j + 1) begin\n                if (((idx_j + 1) & (1 << idx_i)) && ((idx_j + 1) != (1 << idx_i))) begin\n                    encoded[(1 << idx_i) - 1] = encoded[(1 << idx_i) - 1] ^ encoded[idx_j];\n                end\n            end\n        end\n    end\n\n\n    always @(*) begin\n        syndrome = 0; \n        for (idx_m = 0; idx_m < PARITY_BITS; idx_m = idx_m + 1) begin\n            for (idx_n = 0; idx_n < CODE_WIDTH; idx_n = idx_n + 1) begin\n                if ((idx_n + 1) & (1 << idx_m)) begin\n                    syndrome[idx_m] = syndrome[idx_m] ^ received[idx_n];\n                end\n            end\n        end\n    end\n\n  \n    always @(*) begin\n        error_detected = |syndrome; \n    end\n\n    \n    always @(*) begin\n        corrected_data = received;\n        if (error_detected) begin\n            corrected_data[syndrome - 1] = ~corrected_data[syndrome - 1]; \n        end\n    end\n\n \n    always @(*) begin\n        idx_q = 0;\n        for (idx_p = 0; idx_p < CODE_WIDTH; idx_p = idx_p + 1) begin\n            if ((idx_p + 1) & (idx_p)) begin\n                data_out[idx_q] = corrected_data[idx_p];\n                idx_q = idx_q + 1;\n            end\n        end\n    end\n\n\n    always @(*) begin\n        error_corrected = error_detected; \n    end\n\nendmodule\n\nmodule crc_generation #(\n    parameter DATA_WIDTH = 8,       // Width of input data\n    parameter CRC_WIDTH = 4,        // Width of CRC output\n    parameter POLY = 4'b1101        // Polynomial for CRC\n) (\n    input [DATA_WIDTH-1:0] data_in, // Input data\n    input clk,                      // Clock signal\n    input rst,                      // Reset signal\n    output reg [CRC_WIDTH-1:0] crc_out // CRC output\n);\n    integer i;                      // Loop variable\n    reg [CRC_WIDTH-1:0] crc_reg;    // Internal CRC register\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            crc_out <= 0;           \n        end else begin\n            crc_reg = 0;            \n            for (i = DATA_WIDTH - 1; i >= 0; i = i - 1) begin\n                if (crc_reg[CRC_WIDTH-1] ^ data_in[i]) begin\n                    crc_reg = (crc_reg << 1) ^ POLY; \n                end else begin\n                    crc_reg = crc_reg << 1; \n                end\n            end\n            crc_out <= crc_reg;     \n        end\n    end\n\nendmodule\n\nmodule crc_detection #(\n    parameter DATA_WIDTH = 8,           // Width of input data\n    parameter CRC_WIDTH = 4,            // Width of CRC\n    parameter POLY = 4'b1101            // Polynomial for CRC\n) (\n    input [DATA_WIDTH-1:0] data_in,     // Input data\n    input [CRC_WIDTH-1:0] received_crc, // Received CRC\n    input clk,                          // Clock signal\n    input rst,                          // Reset signal\n    output error_detected           // High if error detected\n);\n\n    wire [CRC_WIDTH-1:0] calculated_crc; \n\n    crc_generation #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .CRC_WIDTH(CRC_WIDTH),\n        .POLY(POLY)\n    ) crc_gen (\n        .data_in(data_in),\n        .clk(clk),\n        .rst(rst),\n        .crc_out(calculated_crc)\n    );\n\n    assign error_detected =  ((calculated_crc != received_crc) && (calculated_crc != 0 && received_crc != 0 ))? 1:0;\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sync_serial_communication_top.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sync_serial_communication_top.sv\nTOPLEVEL        = sync_serial_communication_tx_rx\nMODULE          = test_sync_serial_communication\nPYTHONPATH      = /src\nHASH            = c7f1092b8185259c988eabf846e05bd3340e9f51\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n\nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    toplevel = os.getenv(\"TOPLEVEL\")\n    target = float(os.getenv(\"TARGET\"))\n\n    if toplevel in metrics:\n        if \"Overall Average\" in metrics[toplevel]:\n            if metrics[toplevel][\"Overall Average\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n\n        elif \"Assertion\" in metrics[toplevel]:\n            if metrics[toplevel][\"Assertion\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Assertion\"]) >= 100.00, \"Didn't achieve the required coverage result.\"\n\n        elif \"Toggle\" in metrics[toplevel]:\n            if metrics[toplevel][\"Toggle\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Toggle\"]) >= target, \"Didn't achieve the required coverage result.\"\n\n        elif \"Block\" in metrics[toplevel]:\n            if metrics[toplevel][\"Block\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Block\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n        \nif __name__ == \"__main__\":\n    test_simulate()", "src/test_sync_serial_communication.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge,FallingEdge,Timer\nimport harness_library as hrs_lb\nimport random\n\n\n\n\n# Main test for sync_communication top module\n@cocotb.test()\nasync def test_sync_communication(dut):\n    data_wd = int(dut.DATA_WIDTH.value)                                    # Get the data width from the DUT (Device Under Test)\n    crc_width = int(dut.CRC_WIDTH.value)\n    poly = int(dut.POLY.value)\n    # Start the clock with a 10ns time period\n\n    if data_wd == 8:\n        range_value = 8\n        data_in = random.randint(0, 127)\n        sel = 1\n    elif data_wd == 16:\n        range_value = 16\n        data_in = random.randint(0,4196)\n        sel = 2\n    elif data_wd == 32:\n        range_value = 32\n        data_in = random.randint(0,18192)\n        sel = 3\n    elif data_wd == 64:\n        range_value = 64\n        data_in = random.randint(0,154097)\n        sel = 4\n\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n\n    # Ensure all control signals are low initially before starting the test\n    dut.sel.value = 0\n    dut.data_in.value = 0\n    dut.received_1.value = 0\n    dut.received_2.value = 0\n    dut.enable_crc_error.value = 0\n\n    # Main test loop to validate both PISO and SIPO functionality\n    for _ in range(1):\n        await drive_byte(dut,sel,range_value,data_in,data_wd,crc_width,poly)\n        await FallingEdge(dut.clk)\n        await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n        await RisingEdge(dut.clk)\n        await drive_rx_error(dut,sel,range_value,data_in,data_wd,crc_width,poly)\n        await FallingEdge(dut.clk)\n        await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n        await RisingEdge(dut.clk)\n\n    #await inject_parity_error(dut)\n\n\nasync def drive_byte(dut,sel,range_value,data_in,data_wd,crc_width,poly):\n    dut.enable_crc_error.value = 0\n    dut._log.info(f\" DRIVE TRANSACTION NORMAL MODE\")\n    await RisingEdge(dut.clk)\n    dut.data_in.value = data_in  # Assign a random byte (0-127)\n    dut.sel.value  = sel\n    await RisingEdge(dut.clk)\n    data_in_bits = f'{data_in:0{range_value}b}'\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}\")\n    await RisingEdge(dut.clk)\n    encoded_1 = int(dut.encoded_received_TX.value)\n    dut.received_1.value = encoded_1\n    \n    await RisingEdge(dut.clk)\n    #dut.enable_crc_error.value = 0\n    error_corrected_1 = int(dut.error_corrected_1.value)\n    error_detected_1 = int(dut.error_detected_1.value)\n    if error_detected_1:\n            assert error_corrected_1, \"Error detected but not corrected!\"\n    dut._log.info(f\" ecc_hamming_TX = {encoded_1}\")\n    #dut._log.info(f\" data_out1 = {int(dut.uut_onebit_ecc1.data_out.value)}\")\n    await RisingEdge(dut.clk)\n    crc_out = int(dut.crc_out.value)\n    for i in range(range_value):\n        dut.sel.value  = sel\n        await RisingEdge(dut.clk)  \n    await RisingEdge(dut.done)\n    #await RisingEdge(dut.clk) \n    #dut._log.info(f\"  data_out_rx = {int(dut.data_out_rx.value)} \")\n    \n    encoded_2 = int(dut.encoded_received_TX.value)\n    dut.received_2.value = encoded_2\n    \n    \n    await RisingEdge(dut.clk)\n    \n    \n    error_corrected_2 = int(dut.error_corrected_2.value)\n    error_detected_2 = int(dut.error_detected_2.value)\n    await FallingEdge(dut.clk)\n    data_out_rx = int(dut.data_out_rx_temp.value)\n    expected_crc = compute_expected_crc(data_out_rx, data_wd, crc_width, poly)\n    #dut._log.info(f\" CHECK:: crc_out = {crc_out}, expected_crc = {expected_crc}, crc_error_detected = {dut.crc_error_detected.value}\")\n    if error_detected_2:\n            assert error_corrected_2, \"Error detected but not corrected!\"\n    dut._log.info(f\" AFTER RX RECIVED DATA FROM TX\")\n\n    dut._log.info(f\" ecc_hamming_RX = {encoded_2}, ecc_hamming_received_TX = {int(dut.received_2.value)} \")\n    \n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}, data_out = {int(dut.data_out.value)}, done = {dut.done.value}\")\n    \n    \n    expected_data_out = dut.data_in.value\n    assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, expected_data_out = {int(expected_data_out)}, data_out = {int(dut.data_out.value)}\")\n    dut._log.info(f\" enable_crc_error = {dut.enable_crc_error.value} \")\n    dut._log.info(f\" actual_crc_out = {crc_out}, expected_crc = {expected_crc}, actual_crc_error_detected = {dut.crc_error_detected.value}, expected_crc_error_detected = {int(crc_out != expected_crc)}\")\n    assert crc_out == expected_crc, f\" TEST FAILED actual_crc_out = {crc_out}, expected_crc = {expected_crc}\"\n    if crc_out != expected_crc:\n         assert dut.crc_error_detected.value ==1, f\"EST FAILED actual_crc_out = {crc_out}, expected_crc = {expected_crc}\"\n    #await RisingEdge(dut.clk)\n    \n    #assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    data_out = int(dut.data_out.value)\n    data_out_bits = f'{data_out:0{range_value}b}'\n    got_parity = {data_out_bits.count('1') % 2}\n    expected_parity = {data_in_bits.count('1') % 2}\n    #await RisingEdge(dut.clk)\n    \n\n    '''\n    if expected_parity == got_parity:\n        assert dut.parity_error.value == 0, f\"Test passed: Got {dut.parity_error.value}\"\n    else:\n        assert dut.parity_error.value == 1, f\"Test failed: Got {dut.parity_error.value}\" '''\n    \n    \n    dut._log.info(f\" ---------------------------------------------------------------------------------------------------------------------------\")\n    \nasync def drive_tx_error(dut,sel,range_value,data_in,data_wd):\n    \"\"\"Drive a byte of data to the DUT\"\"\"\n    \n    dut._log.info(f\" INJECT ERROR AT BEFORE TX START\")\n    await RisingEdge(dut.clk)\n    dut.data_in.value = data_in  # Assign a random byte (0-127)\n    dut.sel.value  = sel\n    await RisingEdge(dut.clk)\n    data_in_bits = f'{data_in:0{range_value}b}'\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}\")\n    await RisingEdge(dut.clk)\n    encoded_1 = int(dut.encoded_received_TX.value)\n    dut.received_1.value = encoded_1\n    received_1 = int(dut.received_1.value)\n    random_bit_position = random.randint(0, data_wd - 1)\n    received_1 ^= (1 << random_bit_position) \n    dut.received_1.value  = received_1\n    await RisingEdge(dut.clk)\n    error_corrected_1 = int(dut.error_corrected_1.value)\n    error_detected_1 = int(dut.error_detected_1.value)\n    if error_detected_1:\n            assert error_corrected_1, \"Error detected but not corrected!\"\n    dut._log.info(f\" encoded_1 = {encoded_1}, received_1 = {int(dut.received_1.value)}, error_corrected_1 = {error_corrected_1} , error_detected_1 = {error_detected_1}\")\n    dut._log.info(f\" data_out1 = {int(dut.uut_onebit_ecc1.data_out.value)}\")\n    await RisingEdge(dut.clk)\n    for i in range(range_value):\n        dut.sel.value  = sel\n        await RisingEdge(dut.clk)  \n    await RisingEdge(dut.done)\n    dut._log.info(f\"  data_out_rx = {int(dut.data_out_rx.value)} \")\n    encoded_2 = int(dut.encoded_2.value)\n    dut.received_2.value = encoded_2\n    await RisingEdge(dut.clk)\n    error_corrected_2 = int(dut.error_corrected_2.value)\n    error_detected_2 = int(dut.error_detected_2.value)\n    if error_detected_2:\n        assert error_corrected_2, \"Error detected but not corrected!\"\n    dut._log.info(f\" encoded_2 = {encoded_2}, received_2 = {int(dut.received_2.value)} , error_corrected_2 = {error_corrected_2} , error_detected_2 = {error_detected_2}\")\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}, data_out = {int(dut.data_out.value)}, done = {dut.done.value}\")\n\n    expected_data_out = dut.data_in.value\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, expected_data_out = {int(expected_data_out)}, data_out = {int(dut.data_out.value)}\")\n\n    assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    data_out = int(dut.data_out.value)\n    data_out_bits = f'{data_out:0{range_value}b}'\n    got_parity = {data_out_bits.count('1') % 2}\n    expected_parity = {data_in_bits.count('1') % 2}\n    dut._log.info(f\"  expected_parity = {data_in_bits.count('1') % 2}, got_parity = {data_out_bits.count('1') % 2} parity_error = {dut.parity_error.value}\")\n    '''\n    if expected_parity == got_parity:\n        assert dut.parity_error.value == 0, f\"Test passed: Got {dut.parity_error.value}\"\n    else:\n        assert dut.parity_error.value == 1, f\"Test failed: Got {dut.parity_error.value}\" '''\n    dut._log.info(f\" ---------------------------------------------------------------------------------------------------------------------------\")\n    \n\nasync def drive_rx_error(dut,sel,range_value,data_in,data_wd,crc_width,poly):\n    \"\"\"Drive a byte of data to the DUT\"\"\"\n    dut._log.info(f\" INJECT ERROR AT RX\")\n    \n    await RisingEdge(dut.clk)\n    \n    dut.data_in.value = data_in  # Assign a random byte (0-127)\n    dut.sel.value  = sel\n    await RisingEdge(dut.clk)\n    data_in_bits = f'{data_in:0{range_value}b}'\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}\")\n    await RisingEdge(dut.clk)\n    encoded_1 = int(dut.encoded_received_TX.value)\n    dut.received_1.value = encoded_1\n    await RisingEdge(dut.clk)\n    error_corrected_1 = int(dut.error_corrected_1.value)\n    error_detected_1 = int(dut.error_detected_1.value)\n    if error_detected_1:\n            assert error_corrected_1, \"Error detected but not corrected!\"\n    dut._log.info(f\" ecc_hamming_TX = {encoded_1}\")\n    #dut._log.info(f\" data_out1 = {int(dut.uut_onebit_ecc1.data_out.value)}\")\n    await RisingEdge(dut.clk)\n    dut.enable_crc_error.value = 1\n    for i in range(range_value):\n        dut.sel.value  = sel\n        await RisingEdge(dut.clk)   \n    await RisingEdge(dut.done)\n    await FallingEdge(dut.clk) \n    #dut._log.info(f\"  data_out_rx = {int(dut.data_out_rx.value)} \")\n    calculated_crc = int(dut.crc_out.value)\n    encoded_2 = int(dut.encoded_received_TX.value)\n    #dut.received_crc.value = calculated_crc\n    \n    #await RisingEdge(dut.clk)\n    dut.received_2.value = encoded_2\n    received_2 = int(dut.received_2.value)\n    random_bit_position = random.randint(0, data_wd - 1)\n    received_2 ^= (1 << random_bit_position) \n    dut.received_2.value  = received_2\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}, data_out = {int(dut.data_out.value)}, done = {dut.done.value}\")\n    await FallingEdge(dut.clk)\n    data_out_rx_temp = int(dut.data_out_rx_temp.value)\n    dut._log.info(f\" enable_crc_error = {dut.enable_crc_error.value} \")\n    expected_crc = compute_expected_crc(data_out_rx_temp, data_wd, crc_width, poly)\n    await FallingEdge(dut.clk)\n    crc_error_detected = int(dut.crc_error_detected.value)\n    #dut._log.info(f\" check::calculated_crc = {calculated_crc}, expected_crc = {expected_crc}, crc_error_detected = {dut.crc_error_detected.value}\")\n    error_corrected_2 = int(dut.error_corrected_2.value)\n    error_detected_2 = int(dut.error_detected_2.value)\n    if error_detected_2:\n        assert error_corrected_2, \"Error detected but not corrected!\"\n    dut._log.info(f\" AFTER RX RECIVED DATA FROM TX\")\n    dut._log.info(f\" ecc_hamming_RX = {int(encoded_2)}, ecc_hamming_received_TX = {int(dut.received_2.value)}\")\n    dut._log.info(f\" actual_crc = {calculated_crc}, expected_crc = {expected_crc}, actual_crc_error_detected = {crc_error_detected},expected_crc_error_detected = {int(calculated_crc != expected_crc )}\")\n    if calculated_crc == poly:\n        assert calculated_crc == expected_crc, f\"Test failed: calculated_crc =  {calculated_crc}, expected_crc {expected_crc}\"\n        assert crc_error_detected == 0, f\"Test failed: crc_error_detected =  {crc_error_detected}\"\n    elif calculated_crc == 0:\n        assert calculated_crc != expected_crc, f\"Test failed: calculated_crc =  {calculated_crc}, expected_crc {expected_crc}\"\n        assert crc_error_detected == 0, f\"Test failed: crc_error_detected =  {crc_error_detected}\"\n    else:\n        assert calculated_crc != expected_crc, f\"Test failed: calculated_crc =  {calculated_crc}, expected_crc {expected_crc}\"\n        assert crc_error_detected == 1, f\"Test failed: crc_error_detected =  {crc_error_detected}\"\n         \n    expected_data_out = dut.data_in.value\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, expected_data_out = {int(expected_data_out)}, data_out = {int(dut.data_out.value)}\")\n\n    assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    data_out = int(dut.data_out.value)\n    data_out_bits = f'{data_out:0{range_value}b}'\n    got_parity = {data_out_bits.count('1') % 2}\n    expected_parity = {data_in_bits.count('1') % 2}\n    '''\n    if expected_parity == got_parity:\n        assert dut.parity_error.value == 0, f\"Test passed: Got {dut.parity_error.value}\"\n    else:\n        assert dut.parity_error.value == 1, f\"Test failed: Got {dut.parity_error.value}\" '''\n\n    dut._log.info(f\" ---------------------------------------------------------------------------------------------------------------------------\")\n\nasync def inject_parity_error(dut):\n    \"\"\"Simulate injecting a parity error into the communication process.\"\"\"\n    # Initialize DUT signals\n    data_in = random.randint(0, 127)  # Generate random byte data\n    range_value = 8  # Assuming 8 bits for a byte\n    sel = 1          # Corresponding to the byte-level selection\n    corrupted_parity = 0\n\n    dut.sel.value = 0\n    dut.data_in.value = 0\n\n    # Reset the DUT\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n\n    # Drive the byte of data\n    dut.data_in.value = data_in\n    data_in_bits = f\"{data_in:08b}\"\n\n    for _ in range(range_value):\n        dut.sel.value = sel\n        await RisingEdge(dut.clk)\n\n    # Wait for the TX block to signal it's done\n    await RisingEdge(dut.done)\n    \n    # Force corrupt the parity bit (simulate bit flip)\n    #corrupted_parity = not dut.uut_tx_block.parity.value  # Invert the correct parity value\n    if dut.parity.value == 1:\n        corrupted_parity = 0\n    else:\n        corrupted_parity = 1\n\n    dut._log.info(f\"Original parity: {int(dut.parity.value)}, Injecting corrupted parity: {int(corrupted_parity)}\")\n    dut.parity.value = corrupted_parity\n\n    # Wait for RX block to process the corrupted data\n    await RisingEdge(dut.done)\n\n    # Validate the output\n    dut._log.info(f\"SEL: {int(dut.sel.value)}, Data In: {int(dut.data_in.value)}, \"\n                  f\"Data Out: {int(dut.data_out.value)}, Done: {int(dut.done.value)}, \"\n                  f\"Parity Error: {int(dut.parity_error.value)}\")\n\n    # Expecting a parity error\n    assert dut.parity_error.value == 1, f\"Parity error not detected! Parity Error: {int(dut.parity_error.value)}\"\n    dut._log.info(\"Parity error successfully injected and detected.\")\n\ndef compute_expected_crc(data, data_width, crc_width, poly):\n    crc = 0  # Initialize the CRC register\n    #print(f\" data_in = {data}, data_wd = {data_width}, crc_width = {crc_width}, poly = {poly} \")\n    for i in range(data_width - 1, -1, -1):  # Iterate through the data bits\n        msb = (crc >> (crc_width - 1)) & 1  # Get the MSB of the current CRC\n        data_bit = (data >> i) & 1  # Get the current data bit\n        \n        if msb ^ data_bit:  # If XOR of MSB and data bit is 1\n            crc = ((crc << 1) ^ poly) & ((1 << crc_width) - 1)  # XOR with POLY\n        else:\n            crc = (crc << 1) & ((1 << crc_width) - 1)  # Just shift left\n    \n    return crc  # Return the computed CRC\n"}}}
{"id": "cvdp_copilot_sync_serial_communication_0056", "categories": ["cid014", "medium"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the `sync_serial_communication_tx_rx `module, which integrates a `tx_block`, `rx_block`, and `onebit_ecc`. The module details and design requirements for assertion development are outlined below.\n\n## Specifications  \n\n**Interface:**\n\n**Parameters:** \n- `DATA_WIDTH` (default: 8): Width of input and output data.  \n- `CODE_WIDTH`: Encoded width for ECC (`DATA_WIDTH + $clog2(DATA_WIDTH + 1)`).  \n\n**Inputs:** \n- `clk`: Clock signal with a 50:50 duty cycle, active on the rising edge.  \n- `reset_n`: Active-low asynchronous reset signal.  \n- `sel [2:0]`: Selection signal for TX block.  \n- `data_in([DATA_WIDTH-1:0])`: Data input for TX block.  \n- `received_1([CODE_WIDTH-1:0])`: Received encoded data.  \n- `received_2([CODE_WIDTH-1:0])`: Second received encoded data.  \n\n**Outputs:**  \n- `data_out([DATA_WIDTH-1:0])`: Output data from RX block.  \n- `done`: Signal indicating completion.  \n- `parity_error`: Parity error flag.  \n- `encoded_received_TX([CODE_WIDTH-1:0])`: Transmitted ECC-encoded output.  \n- `encoded_2([CODE_WIDTH-1:0])`: ECC-encoded output from received data.  \n- `error_detected_1`: ECC error detected in transmitter.  \n- `error_corrected_1`: ECC error corrected in transmitter.  \n- `error_detected_2`: ECC error detected in receiver.  \n- `error_corrected_2`: ECC error corrected in receiver. \n\n## Module Overview\nThe `sync_serial_communication_tx_rx ` module integrates: \n- TX Block (`tx_block`): Serializes data_in, computes a parity bit, and transmits data serially.\n- RX Block (`rx_block`): Receives and deserializes data while checking for parity errors.\n- ECC Generator (`onebit_ecc`): Adds parity bits, detects, and corrects single-bit errors.\n\n## Behavioral Specifications\n**1. **Transmisson(`tx_block`)****\nThe `tx_block` serializes the `data_in` based on the `sel` input:\n- `sel == 3'b000`: No transmission, `data_out` remains 0.\n- `sel == 3'b001`: Transmits the 8 least significant bits.\n- `sel == 3'b010`: Transmits the 16 least significant bits.\n- `sel == 3'b011`: Transmits the 32 least significant bits.\n- `sel == 3'b100`: Transmits the entire 64-bit data.\n- A parity bit is computed as the XOR of all transmitted bits (^`data_in`).\n- A done signal is asserted when transmission completes.\n\n**2. **Reception(`rx_block`)****\n- The `rx_block`receives serial data and reconstructs `data_out`.\n- The `parity_error` flag is asserted if the received parity bit does not match the computed parity.\n- The done signal is asserted once deserialization is complete.\n\n**3. **One bit ECC(`onebit_ecc`)****\n- Detects and Corrects single-bit errors (`error_corrected_1`, `error_corrected_2`).\n- The RX block processes the received ECC data and reconstructs the original `data_out`.\n\n## Assertion Requirements\n\n**1.No ECC Error Detection When Encoded Data Matches**\n\n- Ensures that if `encoded_2` matches `encoded_received_temp`, both `error_detected_2` and `error_corrected_2` must remain LOW\n\n**2.ECC Data Integrity Check**\n\n- Ensures that when `encoded_2` is equal to `encoded_received_temp`, the ECC-corrected output (`data_out`) must be identical to the original input (`data_in`).\n\n **3.Parity Check**\n\n- Ensures that when `done` is HIGH and the parity of `data_in` matches the parity of `data_out`, the `parity_error` signal must remain LOW.\n\n**4.TX Done Signal Correctness**\n- The `done` signal in the TX module must be asserted HIGH when the bit count reaches zero for certain values of `sel` signal, namely `sel = 3b001` ,`sel = 3b010`, `sel = 3b011` and `sel = 3b100`.\n\n**5.RX Data Stability During Reception**\n- Ensures that `data_out` remains unchanged while the reception process is still ongoing when `done ` is LOW.\n\n---\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.", "context": {"rtl/sync_serial_communication_top.sv": "`timescale 1ns / 1ps\nmodule sync_serial_communication_tx_rx#(parameter DATA_WIDTH = 8,\n                                        parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1))(\n    input clk,                                  // Clock signal\n    input reset_n,                              // Active low reset signal\n    input [2:0] sel,                            // Selection signal for TX block\n    input [DATA_WIDTH-1:0] data_in,             // 64-bit data input for TX block\n    output [DATA_WIDTH-1:0] data_out,           // 64-bit data output from RX block\n    output done,                                // Done signal indicating completion\n    output parity_error,                        // parity error flag\n    input [CODE_WIDTH-1:0] received_1,\n    input [CODE_WIDTH-1:0] received_2,\n    output [CODE_WIDTH-1:0] encoded_received_TX,\n    output [CODE_WIDTH-1:0] encoded_2,\n    output error_detected_1,\n    output error_corrected_1,\n    output error_detected_2,\n    output error_corrected_2\n);\n\n// Internal signals\nwire tx_out;                       \nwire tx_done;                      \nwire serial_clk_in;  \nwire parity;    \nwire [DATA_WIDTH-1:0] data_out_rx;\nwire [DATA_WIDTH-1:0] data_out1;\nwire [DATA_WIDTH-1:0] data_out2;\nwire [CODE_WIDTH-1:0] encoded_received_temp;\nwire [CODE_WIDTH-1:0] encoded_received_temp2;\n\nonebit_ecc#(.DATA_WIDTH(DATA_WIDTH),.CODE_WIDTH(CODE_WIDTH)) uut_onebit_ecc1 (\n\n    .data_in(data_in),\n    .encoded(encoded_received_TX),\n    .received(encoded_received_temp2),\n    .data_out(data_out1),\n    .error_detected(error_detected_1),\n    .error_corrected(error_corrected_1)\n    );\n\n// Instantiate the TX block\ntx_block#(.DATA_WIDTH(DATA_WIDTH)) uut_tx_block (\n    .clk(clk),                     // Clock input to TX block\n    .reset_n(reset_n),             // Reset input to TX block\n    .data_in(data_in),             // 64-bit data input to TX block\n    .sel(sel),                     // Selection signal to TX block\n    .serial_out(tx_out),           // Serial data output from TX block\n    .done(tx_done),                // Done signal from TX block\n    .serial_clk(serial_clk_in),    // Serial clock output from TX block\n    .parity(parity)                // parity bit\n);\n\n// Instantiate the RX block\nrx_block#(.DATA_WIDTH(DATA_WIDTH)) uut_rx_block (\n    .clk(clk),                     // Clock input to RX block\n    .serial_clk(serial_clk_in),    // Serial clock input to RX block\n    .reset_n(reset_n),             // Reset input to RX block\n    .sel(sel),                     // Selection signal to RX block\n    .data_in(tx_out),              // Serial data input to RX block\n    .parity_in(parity),            // received parity bit\n    .data_out(data_out_rx),           // 64-bit data output from RX block\n    .done(done),                   // Done signal from RX block\n    .parity_error(parity_error)    // parity error flag\n    \n);\n\nonebit_ecc#(.DATA_WIDTH(DATA_WIDTH),.CODE_WIDTH(CODE_WIDTH)) uut_onebit_ecc2 (\n\n    .data_in(data_out_rx),\n    .encoded(encoded_2),\n    .received(encoded_received_temp),\n    .data_out(data_out),\n    .error_detected(error_detected_2),\n    .error_corrected(error_corrected_2)\n    );\n\nassign encoded_received_temp = received_2 | encoded_received_temp2;\nassign encoded_received_temp2 = encoded_received_TX;\nendmodule\n\n///// tx_block\nmodule tx_block#(parameter DATA_WIDTH = 8)(\n    input clk,               // Clock input\n    input reset_n,           // Active-low reset input\n    input [DATA_WIDTH-1:0] data_in,    // 64-bit parallel data input\n    input [2:0] sel,         // Selection input to choose data width\n    output reg serial_out,   // Serial data output\n    output reg done,         // Done signal indicating completion of transmission\n    output serial_clk,       // Clock for serial data transmission\n    output reg parity        // parity bit\n);\n\n// Internal registers\nreg [DATA_WIDTH-1:0] data_reg;       \nreg [6:0] bit_count;         \nreg [6:0] reg_count;        \nreg [6:0] temp_reg_count;    \n\n\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        // Reset all values on active-low reset\n        data_reg     <= {DATA_WIDTH{1'b0}};\t\t\t     \t           \n        bit_count    <= 7'h0;\t\t\t     \t           \n        reg_count    <= 7'h0;\t\n        parity       <= 1'b0;\t             \t       \n    end else begin\n        if (done == 1'b1) begin\n            case (sel)\n                3'b000: begin\n                    data_reg  <= 64'h0;             \t   \n                    bit_count <= 7'd0; \n                    parity    <= 1'b0;                    \n                end\n                3'b001: begin\n                    data_reg  <= {56'h0, data_in[7:0] };  \n                    bit_count <= 7'd7;\n                    parity    <= ^data_in[7:0];              \t   \n                end\n                3'b010: begin\n                    if (DATA_WIDTH >= 16) begin\n                        data_reg  <= { {(DATA_WIDTH - 16){1'b0}}, data_in[15:0] }; \n                        bit_count <= 7'd15; \n                        parity    <= ^data_in[15:0];\n                    end             \t   \n                end\n                3'b011: begin\n                    if (DATA_WIDTH >= 32) begin\n                        data_reg  <= { {(DATA_WIDTH - 32){1'b0}}, data_in[31:0] };\n                        bit_count <= 7'd31;  \n                        parity    <= ^data_in[31:0];\n                    end            \t \n                end\n                3'b100: begin\n                    if (DATA_WIDTH >= 64) begin\n                        data_reg  <={data_in[63:0] };   \t   \n                        bit_count <= 7'd63; \n                        parity    <= ^data_in[63:0];\n                    end             \t   \n                end\n                default: begin\n                    data_reg  <= {DATA_WIDTH{1'b0}};             \t   \n                    bit_count <= 7'h0; \n                    parity    <= 1'b0;              \t   \n                end\n            endcase\n           \n        end else if (bit_count > 7'h0) begin\n            data_reg   <= data_reg >> 1;                   \n            bit_count  <= bit_count - 1'b1;                \n            \n        end\n        reg_count <= bit_count;                            \n    end\nend\n\n// Generate serial clock based on reg_count\n//`ifdef SIMULATION\nassign  #1 serial_clk = clk && (temp_reg_count !== 7'd0) ; \n//`else\n//assign  serial_clk = clk && (temp_reg_count !== 7'd0) ;  \n//`endif\n\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n        temp_reg_count <= 7'h0;\t\t\t\t\t           \n    end\n    else begin\n        temp_reg_count <= reg_count;\t\t\t        \n    end\nend\n\n\n\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n\t   serial_out <= 1'b0;\t\t\t\t                \n    end\n    else if(reg_count > 7'h0 || bit_count > 7'h0) begin\n\t   serial_out <= data_reg[0];\t\t\t              \n    end\nend \n\nalways@(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n        done <= 1'b0;\t\t\t\t\t                  \n    end \n    else begin\n     if(bit_count == 7'h0) begin\n\t    done <= 1'b1; \t\t\t                          \n     end\n     else begin \n\t    done <= 1'b0;\t\t\t\t\t                  \n     end\nend\nend\n\n\nendmodule\n\n///// rx_block\nmodule rx_block#(parameter DATA_WIDTH = 8)(\n    input wire clk,  \t\t\t    // clock input\n    input wire reset_n,\t\t\t    // Active-low reset\n    input wire data_in,\t\t\t    // Serial input data\t\n    input wire serial_clk,\t\t    // Clock signal for serial data\n    input wire [2:0] sel,           // Selection output to choose data width\n    input wire parity_in,           // received parity\n    output reg done,\t\t\t    // Done signal to indicate data reception complete\t\t\n    output reg [DATA_WIDTH-1:0] data_out,  \t// Parallel output data after serial operation\n    output reg parity_error         // parity_error flag\n\n);\n\n    // Internal registers\n    reg [DATA_WIDTH-1:0] data_reg;\t\t    \n    reg [7:0] bit_count;\t\t   \n    reg [7:0] count;\t\t    \n\n    \n    always @(posedge serial_clk or negedge  reset_n) begin\n        if (!reset_n) begin\t\t    \n            data_reg <= {DATA_WIDTH{1'b0}};\t\t\n            bit_count <= 8'd0;\t\t\n        end else begin\n            if(done == 1'b1) begin                   \n                bit_count <= 8'b0;\n                data_reg <= {DATA_WIDTH{1'b0}};\n            end\n            else begin\n                 bit_count <= bit_count;\t\t\t\n            end\n                bit_count <= bit_count + 1'b1;\t     \n                data_reg[bit_count]<=data_in; \t     \n           end\n    end  \n    \n    \n    always@(posedge clk or negedge reset_n) begin\n    \tif(!reset_n) begin\t\t\t \t             \n    \t   count <= 8'd0;\t\t\t\t\t         \n           done <= 1'b0;\t\t\t\t\t         \n           data_out <= {DATA_WIDTH{1'b0}};\t\t\t\t\t     \n           parity_error  <= 1'b0;\t\t\t\t \n        end \n        else if(count >= bit_count && count != 8'd0) begin      \n           done <= 1'b1;\t\t\t\t             \n           case(sel)\n            3'b000:begin\n                data_out <= {DATA_WIDTH{1'b0}};\t\n                parity_error <= 1'b0;                   \n            end\n            3'b001:begin\n                if(parity_in == (^data_reg[7:0])) begin\n                    data_out <= {56'h0, data_reg[7:0]};\n                    parity_error <= 1'b0;\n                end    \n                else begin\n                    data_out <= {56'h0, data_reg[7:0]};\n                    parity_error <= 1'b1;\n                end   \n            end\n            3'b010:begin\n                if (DATA_WIDTH >= 16) begin\n                    if(parity_in == (^data_reg[15:0])) begin\n                        data_out <= {48'h0, data_reg[15:0]};    \n                        parity_error <= 1'b0;\n                    end    \n                    else begin\n                        data_out <= {48'h0, data_reg[15:0]}; \n                        parity_error <= 1'b1;\n                    end\n                end       \n            end\n            3'b011:begin\n                if (DATA_WIDTH >= 32) begin\n                    if(parity_in == (^data_reg[31:0])) begin\n                        data_out <= {32'h0, data_reg[31:0]};  \n                        parity_error <= 1'b0;\n                    end    \n                    else begin\n                        data_out <= {32'h0, data_reg[31:0]};  \n                        parity_error <= 1'b1;\n                    end\n                end        \n            end\n            3'b100:begin\n                if (DATA_WIDTH >= 64) begin\n                    if(parity_in == (^data_reg[63:0])) begin\n                        data_out <= {data_reg[63:0]};   \n                        parity_error <= 1'b0;\n                    end    \n                    else begin\n                        data_out <= {data_reg[63:0]}; \n                        parity_error <= 1'b1;\n                    end \n                end             \n            end\n            default:begin\n                data_out <= {DATA_WIDTH{1'b0}};    \n                parity_error <= 1'b0;               \n            end\n           endcase\n        end\n        else if(bit_count > 8'd0) begin              \n           count <= count+ 1'b1;\t\t\t\t     \n           done <= 1'b0;\t\t\t\t\t        \n        end\n        else begin  \t\t\t                     \n           count <= 8'd0;\t\t\t\t\t         \n           done <= 1'b0;\t\t\t\t\t           \n        end \n    end\nendmodule\n\nmodule onebit_ecc #(\n    parameter DATA_WIDTH = 4,                                  // Width of the data input\n    parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1) // Encoded width\n)(\n    input [DATA_WIDTH-1:0] data_in,                     // Input data\n    output reg [CODE_WIDTH-1:0] encoded,                // Encoded output\n    input [CODE_WIDTH-1:0] received,                    // Received encoded data\n    output reg [DATA_WIDTH-1:0] data_out,               // Corrected output\n    output reg error_detected,                          // Error detected flag\n    output reg error_corrected                          // Error corrected flag\n);\n\n    localparam PARITY_BITS = CODE_WIDTH - DATA_WIDTH;   // Number of parity bits\n\n    reg [PARITY_BITS-1:0] syndrome;                     // Syndrome for error detection\n    reg [CODE_WIDTH-1:0] corrected_data;                // Corrected received data\n\n\n    integer idx_i, idx_j, idx_k;\n    integer idx_m, idx_n;\n    integer idx_p, idx_q;\n\n\n    always @(*) begin\n        encoded = 0;\n        idx_k = 0;\n\n\n        for (idx_i = 0; idx_i < CODE_WIDTH; idx_i = idx_i + 1) begin\n            if ((idx_i + 1) & (idx_i)) begin\n                encoded[idx_i] = data_in[idx_k];\n                idx_k = idx_k + 1;\n            end\n        end\n\n\n        for (idx_i = 0; idx_i < PARITY_BITS; idx_i = idx_i + 1) begin\n            encoded[(1 << idx_i) - 1] = 0; \n            for (idx_j = 0; idx_j < CODE_WIDTH; idx_j = idx_j + 1) begin\n                if (((idx_j + 1) & (1 << idx_i)) && ((idx_j + 1) != (1 << idx_i))) begin\n                    encoded[(1 << idx_i) - 1] = encoded[(1 << idx_i) - 1] ^ encoded[idx_j];\n                end\n            end\n        end\n    end\n\n\n    always @(*) begin\n        syndrome = 0; \n        for (idx_m = 0; idx_m < PARITY_BITS; idx_m = idx_m + 1) begin\n            for (idx_n = 0; idx_n < CODE_WIDTH; idx_n = idx_n + 1) begin\n                if ((idx_n + 1) & (1 << idx_m)) begin\n                    syndrome[idx_m] = syndrome[idx_m] ^ received[idx_n];\n                end\n            end\n        end\n    end\n\n  \n    always @(*) begin\n        error_detected = |syndrome; \n    end\n\n    \n    always @(*) begin\n        corrected_data = received;\n        if (error_detected) begin\n            corrected_data[syndrome - 1] = ~corrected_data[syndrome - 1]; \n        end\n    end\n\n \n    always @(*) begin\n        idx_q = 0;\n        for (idx_p = 0; idx_p < CODE_WIDTH; idx_p = idx_p + 1) begin\n            if ((idx_p + 1) & (idx_p)) begin\n                data_out[idx_q] = corrected_data[idx_p];\n                idx_q = idx_q + 1;\n            end\n        end\n    end\n\n\n    always @(*) begin\n        error_corrected = error_detected; \n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/sync_serial_communication_top.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/sync_serial_communication_top.sv\nTOPLEVEL        = sync_serial_communication_tx_rx\nMODULE          = test_sync_serial_communication\nPYTHONPATH      = /src\nHASH            = 18886fab7078f9c484b5ffe7e8d0fc93f0cb3bbc", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 10, active:bool = False):\n    # Restart Interface\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n\nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics[inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    toplevel = os.getenv(\"TOPLEVEL\")\n    target = float(os.getenv(\"TARGET\"))\n\n    if toplevel in metrics:\n        if \"Overall Average\" in metrics[toplevel]:\n            if metrics[toplevel][\"Overall Average\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n\n        elif \"Assertion\" in metrics[toplevel]:\n            if metrics[toplevel][\"Assertion\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Assertion\"]) >= 100.00, \"Didn't achieve the required coverage result.\"\n\n        elif \"Toggle\" in metrics[toplevel]:\n            if metrics[toplevel][\"Toggle\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Toggle\"]) >= target, \"Didn't achieve the required coverage result.\"\n\n        elif \"Block\" in metrics[toplevel]:\n            if metrics[toplevel][\"Block\"].lower() != 'n/a':\n                assert float(metrics[toplevel][\"Block\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n        \nif __name__ == \"__main__\":\n    test_simulate()", "src/test_sync_serial_communication.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge,FallingEdge,Timer\nimport harness_library as hrs_lb\nimport random\n\n\n\n\n# Main test for sync_communication top module\n@cocotb.test()\nasync def test_sync_communication(dut):\n    data_wd = int(dut.DATA_WIDTH.value)                                    # Get the data width from the DUT (Device Under Test)\n    # Start the clock with a 10ns time period\n\n    if data_wd == 8:\n        range_value = 8\n        data_in = random.randint(0, 127)\n        sel = 1\n    elif data_wd == 16:\n        range_value = 16\n        data_in = random.randint(0,4196)\n        sel = 2\n    elif data_wd == 32:\n        range_value = 32\n        data_in = random.randint(0,18192)\n        sel = 3\n    elif data_wd == 64:\n        range_value = 64\n        data_in = random.randint(0,154097)\n        sel = 4\n\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n\n    # Ensure all control signals are low initially before starting the test\n    dut.sel.value = 0\n    dut.data_in.value = 0\n    dut.received_1.value = 0\n    dut.received_2.value = 0\n\n    # Main test loop to validate both PISO and SIPO functionality\n    for _ in range(sel):\n        await drive_byte(dut,sel,range_value,data_in)\n        await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n        await RisingEdge(dut.clk)\n        await drive_rx_error(dut,sel,range_value,data_in,data_wd)\n        await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n        await RisingEdge(dut.clk)\n\n    #await inject_parity_error(dut)\n\n\nasync def drive_byte(dut,sel,range_value,data_in):\n    \"\"\"Drive a byte of data to the DUT\"\"\"\n    dut._log.info(f\" DRIVE TRANSACTION NORMAL MODE\")\n    await RisingEdge(dut.clk)\n    dut.data_in.value = data_in  # Assign a random byte (0-127)\n    dut.sel.value  = sel\n    await RisingEdge(dut.clk)\n    data_in_bits = f'{data_in:0{range_value}b}'\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}\")\n    await RisingEdge(dut.clk)\n    encoded_1 = int(dut.encoded_received_TX.value)\n    dut.received_1.value = encoded_1\n    await RisingEdge(dut.clk)\n    error_corrected_1 = int(dut.error_corrected_1.value)\n    error_detected_1 = int(dut.error_detected_1.value)\n    if error_detected_1:\n            assert error_corrected_1, \"Error detected but not corrected!\"\n    dut._log.info(f\" ecc_hamming_TX = {encoded_1}\")\n    #dut._log.info(f\" data_out1 = {int(dut.uut_onebit_ecc1.data_out.value)}\")\n    await RisingEdge(dut.clk)\n    for i in range(range_value):\n        dut.sel.value  = sel\n        await RisingEdge(dut.clk)  \n    await RisingEdge(dut.done)\n    #await RisingEdge(dut.clk) \n    #dut._log.info(f\"  data_out_rx = {int(dut.data_out_rx.value)} \")\n    encoded_2 = int(dut.encoded_received_TX.value)\n    dut.received_2.value = encoded_2\n    await RisingEdge(dut.clk)\n    error_corrected_2 = int(dut.error_corrected_2.value)\n    error_detected_2 = int(dut.error_detected_2.value)\n    if error_detected_2:\n            assert error_corrected_2, \"Error detected but not corrected!\"\n    dut._log.info(f\" AFTER RX RECIVED DATA FROM TX\")\n\n    dut._log.info(f\" ecc_hamming_RX = {encoded_2}, ecc_hamming_received_TX = {int(dut.received_2.value)} \")\n    \n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}, data_out = {int(dut.data_out.value)}, done = {dut.done.value}\")\n\n    expected_data_out = dut.data_in.value\n    assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, expected_data_out = {int(expected_data_out)}, data_out = {int(dut.data_out.value)}\")\n\n    #assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    data_out = int(dut.data_out.value)\n    data_out_bits = f'{data_out:0{range_value}b}'\n    got_parity = {data_out_bits.count('1') % 2}\n    expected_parity = {data_in_bits.count('1') % 2}\n    \n    '''\n    if expected_parity == got_parity:\n        assert dut.parity_error.value == 0, f\"Test passed: Got {dut.parity_error.value}\"\n    else:\n        assert dut.parity_error.value == 1, f\"Test failed: Got {dut.parity_error.value}\" '''\n    \n    \n    dut._log.info(f\" ---------------------------------------------------------------------------------------------------------------------------\")\n    \nasync def drive_tx_error(dut,sel,range_value,data_in,data_wd):\n    \"\"\"Drive a byte of data to the DUT\"\"\"\n    dut._log.info(f\" INJECT ERROR AT BEFORE TX START\")\n    await RisingEdge(dut.clk)\n    dut.data_in.value = data_in  # Assign a random byte (0-127)\n    dut.sel.value  = sel\n    await RisingEdge(dut.clk)\n    data_in_bits = f'{data_in:0{range_value}b}'\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}\")\n    await RisingEdge(dut.clk)\n    encoded_1 = int(dut.encoded_received_TX.value)\n    dut.received_1.value = encoded_1\n    received_1 = int(dut.received_1.value)\n    random_bit_position = random.randint(0, data_wd - 1)\n    received_1 ^= (1 << random_bit_position) \n    dut.received_1.value  = received_1\n    await RisingEdge(dut.clk)\n    error_corrected_1 = int(dut.error_corrected_1.value)\n    error_detected_1 = int(dut.error_detected_1.value)\n    if error_detected_1:\n            assert error_corrected_1, \"Error detected but not corrected!\"\n    dut._log.info(f\" encoded_1 = {encoded_1}, received_1 = {int(dut.received_1.value)}, error_corrected_1 = {error_corrected_1} , error_detected_1 = {error_detected_1}\")\n    dut._log.info(f\" data_out1 = {int(dut.uut_onebit_ecc1.data_out.value)}\")\n    await RisingEdge(dut.clk)\n    for i in range(range_value):\n        dut.sel.value  = sel\n        await RisingEdge(dut.clk)  \n    await RisingEdge(dut.done)\n    dut._log.info(f\"  data_out_rx = {int(dut.data_out_rx.value)} \")\n    encoded_2 = int(dut.encoded_2.value)\n    dut.received_2.value = encoded_2\n    await RisingEdge(dut.clk)\n    error_corrected_2 = int(dut.error_corrected_2.value)\n    error_detected_2 = int(dut.error_detected_2.value)\n    if error_detected_2:\n        assert error_corrected_2, \"Error detected but not corrected!\"\n    dut._log.info(f\" encoded_2 = {encoded_2}, received_2 = {int(dut.received_2.value)} , error_corrected_2 = {error_corrected_2} , error_detected_2 = {error_detected_2}\")\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}, data_out = {int(dut.data_out.value)}, done = {dut.done.value}\")\n\n    expected_data_out = dut.data_in.value\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, expected_data_out = {int(expected_data_out)}, data_out = {int(dut.data_out.value)}\")\n\n    assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    data_out = int(dut.data_out.value)\n    data_out_bits = f'{data_out:0{range_value}b}'\n    got_parity = {data_out_bits.count('1') % 2}\n    expected_parity = {data_in_bits.count('1') % 2}\n    dut._log.info(f\"  expected_parity = {data_in_bits.count('1') % 2}, got_parity = {data_out_bits.count('1') % 2} parity_error = {dut.parity_error.value}\")\n    '''\n    if expected_parity == got_parity:\n        assert dut.parity_error.value == 0, f\"Test passed: Got {dut.parity_error.value}\"\n    else:\n        assert dut.parity_error.value == 1, f\"Test failed: Got {dut.parity_error.value}\" '''\n    dut._log.info(f\" ---------------------------------------------------------------------------------------------------------------------------\")\n    \n\nasync def drive_rx_error(dut,sel,range_value,data_in,data_wd):\n    \"\"\"Drive a byte of data to the DUT\"\"\"\n    dut._log.info(f\" INJECT ERROR AT RX\")\n    await RisingEdge(dut.clk)\n    dut.data_in.value = data_in  # Assign a random byte (0-127)\n    dut.sel.value  = sel\n    await RisingEdge(dut.clk)\n    data_in_bits = f'{data_in:0{range_value}b}'\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}\")\n    await RisingEdge(dut.clk)\n    encoded_1 = int(dut.encoded_received_TX.value)\n    dut.received_1.value = encoded_1\n    await RisingEdge(dut.clk)\n    error_corrected_1 = int(dut.error_corrected_1.value)\n    error_detected_1 = int(dut.error_detected_1.value)\n    if error_detected_1:\n            assert error_corrected_1, \"Error detected but not corrected!\"\n    dut._log.info(f\" ecc_hamming_TX = {encoded_1}\")\n    #dut._log.info(f\" data_out1 = {int(dut.uut_onebit_ecc1.data_out.value)}\")\n    await RisingEdge(dut.clk)\n    for i in range(range_value):\n        dut.sel.value  = sel\n        await RisingEdge(dut.clk)   \n    await RisingEdge(dut.done)\n    #await RisingEdge(dut.clk) \n    #dut._log.info(f\"  data_out_rx = {int(dut.data_out_rx.value)} \")\n    encoded_2 = int(dut.encoded_received_TX.value)\n    #await RisingEdge(dut.clk)\n    dut.received_2.value = encoded_2\n    received_2 = int(dut.received_2.value)\n    random_bit_position = random.randint(0, data_wd - 1)\n    received_2 ^= (1 << random_bit_position) \n    dut.received_2.value  = received_2\n    await FallingEdge(dut.clk)\n    error_corrected_2 = int(dut.error_corrected_2.value)\n    error_detected_2 = int(dut.error_detected_2.value)\n    if error_detected_2:\n        assert error_corrected_2, \"Error detected but not corrected!\"\n    dut._log.info(f\" AFTER RX RECIVED DATA FROM TX\")\n    dut._log.info(f\" ecc_hamming_RX = {int(encoded_2)}, ecc_hamming_received_TX = {int(dut.received_2.value)}\")\n    \n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, sel = {dut.sel.value}, data_out = {int(dut.data_out.value)}, done = {dut.done.value}\")\n\n    expected_data_out = dut.data_in.value\n    dut._log.info(f\" data_in = {int(dut.data_in.value)}, expected_data_out = {int(expected_data_out)}, data_out = {int(dut.data_out.value)}\")\n\n    assert int(dut.data_out.value) == expected_data_out, f\"Test failed: Expected {expected_data_out}, got {int(dut.data_out.value)}\"\n    data_out = int(dut.data_out.value)\n    data_out_bits = f'{data_out:0{range_value}b}'\n    got_parity = {data_out_bits.count('1') % 2}\n    expected_parity = {data_in_bits.count('1') % 2}\n    '''\n    if expected_parity == got_parity:\n        assert dut.parity_error.value == 0, f\"Test passed: Got {dut.parity_error.value}\"\n    else:\n        assert dut.parity_error.value == 1, f\"Test failed: Got {dut.parity_error.value}\" '''\n\n    dut._log.info(f\" ---------------------------------------------------------------------------------------------------------------------------\")\n\n\nasync def inject_parity_error(dut):\n    \"\"\"Simulate injecting a parity error into the communication process.\"\"\"\n    # Initialize DUT signals\n    data_in = random.randint(0, 127)  # Generate random byte data\n    range_value = 8  # Assuming 8 bits for a byte\n    sel = 1          # Corresponding to the byte-level selection\n    corrupted_parity = 0\n\n    dut.sel.value = 0\n    dut.data_in.value = 0\n\n    # Reset the DUT\n    await hrs_lb.reset_dut(dut.reset_n, duration_ns=25, active=False)\n\n    # Drive the byte of data\n    dut.data_in.value = data_in\n    data_in_bits = f\"{data_in:08b}\"\n\n    for _ in range(range_value):\n        dut.sel.value = sel\n        await RisingEdge(dut.clk)\n\n    # Wait for the TX block to signal it's done\n    await RisingEdge(dut.done)\n    \n    # Force corrupt the parity bit (simulate bit flip)\n    #corrupted_parity = not dut.uut_tx_block.parity.value  # Invert the correct parity value\n    if dut.parity.value == 1:\n        corrupted_parity = 0\n    else:\n        corrupted_parity = 1\n\n    dut._log.info(f\"Original parity: {int(dut.parity.value)}, Injecting corrupted parity: {int(corrupted_parity)}\")\n    dut.parity.value = corrupted_parity\n\n    # Wait for RX block to process the corrupted data\n    await RisingEdge(dut.done)\n\n    # Validate the output\n    dut._log.info(f\"SEL: {int(dut.sel.value)}, Data In: {int(dut.data_in.value)}, \"\n                  f\"Data Out: {int(dut.data_out.value)}, Done: {int(dut.done.value)}, \"\n                  f\"Parity Error: {int(dut.parity_error.value)}\")\n\n    # Expecting a parity error\n    assert dut.parity_error.value == 1, f\"Parity error not detected! Parity Error: {int(dut.parity_error.value)}\"\n    dut._log.info(\"Parity error successfully injected and detected.\")\n"}}}
{"id": "cvdp_copilot_ttc_lite_0013", "categories": ["cid014", "medium"], "input": {"prompt": "Create SystemVerilog Assertions to verify the correct behavior of the `ttc_counter_lite` module, ensuring all key registers and operations function as expected.\n\nThe properties should validate that the counter, match value, reload value, control flags, and interrupt mechanism behave correctly under all conditions. Assertions must be created to verify that after a reset, write, or increment operation, the assigned values do not interfere with the correct functioning of the module. The timer must correctly update, trigger interrupts, and respond to AXI transactions.\n\n## **Expected Behavior**\nEach assertion should validate the respective behavior of the timer registers, interrupt signals, and AXI read/write operations. In the event of a failure, the error message must include relevant details such as the counter value, match flag status, and control register settings for debugging purposes.\n\n## **RTL Specification**\nThe `ttc_counter_lite` module implements a simple timer with configurable match and reload values, supporting an interval mode and an interrupt mechanism. It uses an AXI-compatible interface for control and status updates.\n\n### **Module Name:** `ttc_counter_lite`\n\n### **Ports**\n| **Port Name**  | **Direction** | **Size**  | **Description**                     |\n|----------------|---------------|-----------|-------------------------------------|\n| `clk`          | Input         | 1 bit     | Clock signal                        |\n| `reset`        | Input         | 1 bit     | Asynchronous reset, active high     |\n| `axi_addr`     | Input         | 4 bits    | AXI address for register read/write |\n| `axi_wdata`    | Input         | 32 bits   | AXI write data                      |\n| `axi_write_en` | Input         | 1 bit     | AXI write enable                    |\n| `axi_read_en`  | Input         | 1 bit     | AXI read enable                     |\n| `axi_rdata`    | Output        | 32 bits   | AXI read data                       |\n| `interrupt`    | Output        | 1 bit     | Interrupt signal                    |\n\n### **Registers and Functionality**\n- **`count`** (16-bit): Increments every clock cycle when enabled.\n- **`match_value`** (16-bit): Defines the counter match condition.\n- **`reload_value`** (16-bit): Reload value for interval mode.\n- **`enable`** (1-bit): Enables or disables the counter.\n- **`interval_mode`** (1-bit): Enables interval-based reset.\n- **`interrupt_enable`** (1-bit): Enables interrupt generation.\n- **`match_flag`** (1-bit): Indicates whether the counter has matched `match_value`.\n- **Interrupt** is set when `match_flag` is asserted and `interrupt_enable` is high.\n\n### **Assertions to Cover**\n- **Reset Behavior:** Ensure all registers are reset to zero.\n- **Counter Functionality:** Ensure the counter increments correctly and reloads in interval mode.\n- **AXI Register Writes:** Ensure register values update correctly when written via AXI.\n- **Match and Interrupt Behavior:** Please make sure the match flag and interrupt signal as expected.\n- **AXI Read Consistency:** Ensure reads return the correct values.\n\n---\n", "context": {"rtl/ttc_counter_lite.sv": "module ttc_counter_lite (\n    input wire          clk,                // Clock signal\n    input wire          reset,              // Reset signal\n    input wire [3:0]    axi_addr,           // AXI address for read/write\n    input wire [31:0]   axi_wdata,          // AXI write data\n    input wire          axi_write_en,       // AXI write enable\n    input wire          axi_read_en,        // AXI read enable\n    output reg [31:0]   axi_rdata,          // AXI read data\n    output reg          interrupt           // Interrupt signal\n);\n\n    // Timer registers\n    reg [15:0] count;                       // Counter register\n    reg [15:0] match_value;                 // Match value for interval mode\n    reg [15:0] reload_value;                // Reload value in interval mode\n    reg        enable;                      // Timer enable flag\n    reg        interval_mode;               // Interval mode enable flag\n    reg        interrupt_enable;            // Interrupt enable flag\n\n    // Address map\n    localparam ADDR_COUNT        = 4'b0000; // Counter register (read only)\n    localparam ADDR_MATCH_VALUE  = 4'b0001; // Match value register\n    localparam ADDR_RELOAD_VALUE = 4'b0010; // Reload value register\n    localparam ADDR_CONTROL      = 4'b0011; // Control register\n    localparam ADDR_STATUS       = 4'b0100; // Status register\n\n    // Interrupt flag\n    reg match_flag;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 16'b0; \n        end else if (enable) begin\n            if (interval_mode && match_flag) begin\n                count <= reload_value; \n            end \n            else if (count == match_value) begin\n                count <= count; \n            end else begin\n                count <= count + 16'b1; \n            end\n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            match_flag <= 1'b0; \n        end else begin\n            match_flag <= (count == match_value); \n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            interrupt <= 1'b0; \n        end else if (match_flag && interrupt_enable) begin\n            interrupt <= 1'b1; \n        end else if (axi_write_en && axi_addr == ADDR_STATUS) begin\n            interrupt <= 1'b0; \n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            match_value      <= 16'b0; \n            reload_value     <= 16'b0; \n            enable           <= 1'b0; \n            interval_mode    <= 1'b0; \n            interrupt_enable <= 1'b0; \n        end else if (axi_write_en) begin\n            case (axi_addr)\n                ADDR_MATCH_VALUE:  match_value      <= axi_wdata[15:0]; \n                ADDR_RELOAD_VALUE: reload_value     <= axi_wdata[15:0]; \n                ADDR_CONTROL: begin\n                    enable           <= axi_wdata[0]; \n                    interval_mode    <= axi_wdata[1]; \n                    interrupt_enable <= axi_wdata[2]; \n                end\n                default: ; \n            endcase\n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            axi_rdata <= 32'b0; \n        end else if (axi_read_en) begin\n            case (axi_addr)\n                ADDR_COUNT:        axi_rdata <= {16'b0, count};       \n                ADDR_MATCH_VALUE:  axi_rdata <= {16'b0, match_value}; \n                ADDR_RELOAD_VALUE: axi_rdata <= {16'b0, reload_value}; \n                ADDR_CONTROL:      axi_rdata <= {29'b0, interrupt_enable, interval_mode, enable}; \n                ADDR_STATUS:       axi_rdata <= {31'b0, interrupt};   \n                default:           axi_rdata <= 32'b0;               \n            endcase\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/ttc_counter_lite.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 80\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ttc_counter_lite.sv\nTOPLEVEL        = ttc_counter_lite\nMODULE          = test_ttc_counter_lite\nPYTHONPATH      = /src\nHASH            = 9a63cbc79c9d371f3e89f355abe9824ec5315585\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 2, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_ttc_counter_lite.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_ttc_counter_lite(dut):\n    \"\"\"\n    Cocotb-based testbench for the ttc_counter_lite module.\n    \"\"\"\n    # Generate clock\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Initialize the DUT signals (e.g., reset all values to default 0)\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT\n    dut.reset.value = 1\n    await Timer(20, units=\"ns\")\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)\n\n    # Helper function to write to AXI\n    async def axi_write(addr, data):\n        dut.axi_addr.value = addr\n        dut.axi_wdata.value = data\n        dut.axi_write_en.value = 1\n        await RisingEdge(dut.clk)\n        dut.axi_write_en.value = 0\n        await RisingEdge(dut.clk)\n\n    # Helper function to read from AXI\n    async def axi_read(addr):\n        dut.axi_addr.value = addr\n        dut.axi_read_en.value = 1\n        await RisingEdge(dut.clk)\n        dut.axi_read_en.value = 0\n        await RisingEdge(dut.clk)\n        read_value = int(dut.axi_rdata.value)\n        print(f\"[READ] Address: {addr}, Data: {read_value}\")\n        return read_value\n\n    # Write match value\n    await axi_write(0x1, 0x14)  # Set match value to 20\n    assert int(dut.match_value.value) == 0x14, \"[ERROR] Match value not set correctly\"\n    dut._log.info(f\"[CHECK] Match value correctly set: {int(dut.match_value.value)}\")\n\n    # Write reload value\n    await axi_write(0x2, 0xA)  # Set reload value to 10\n    assert int(dut.reload_value.value) == 0xA, \"[ERROR] Reload value not set correctly\"\n    dut._log.info(f\"[CHECK] Reload value correctly set: {int(dut.reload_value.value)}\")\n\n    # Configure control register\n    await axi_write(0x3, 0x7)  # Enable = 1, Interval mode = 1, Interrupt enable = 1\n    assert dut.enable.value == 1, \"[ERROR] Control register enable not set\"\n    assert dut.interval_mode.value == 1, \"[ERROR] Interval mode not set\"\n    assert dut.interrupt_enable.value == 1, \"[ERROR] Interrupt enable not set\"\n    dut._log.info(f\"[CHECK] Control register configured correctly: Enable={dut.enable.value}, Interval Mode={dut.interval_mode.value}, Interrupt Enable={dut.interrupt_enable.value}\")\n\n    # Observe counting\n    await Timer(200, units=\"ns\")\n    count = int(dut.count.value)\n    reload_value = int(dut.reload_value.value)\n    match_value = int(dut.match_value.value)\n    assert reload_value <= count <= match_value, f\"[ERROR] Counter value {count} is out of range [{reload_value}, {match_value}]\"\n    dut._log.info(f\"[CHECK] Counter is running within range: {count}, Reload Value: {reload_value}, Match Value: {match_value}\")\n\n    # Read counter value\n    count_val = await axi_read(0x0)  # Read counter value\n    assert count_val == int(dut.count.value), f\"[ERROR] Counter value mismatch: read {count_val}, expected {int(dut.count.value)}\"\n    dut._log.info(f\"[INFO] Counter value read: {count_val}\")\n\n    # Wait for interrupt\n    await Timer(50, units=\"ns\")\n    assert dut.interrupt.value == 1, \"[ERROR] Interrupt not asserted\"\n    dut._log.info(f\"[CHECK] Interrupt asserted at match: {dut.interrupt.value}\")\n    # Check interrupt status\n    interrupt_status = await axi_read(0x4)\n    assert interrupt_status == dut.interrupt.value, \"[ERROR] Interrupt status mismatch\"\n    dut._log.info(\"[CHECK] Interrupt status matches expected value\")\n\n    # Clear interrupt\n    await axi_write(0x4, 0x0)  # Clear interrupt\n    assert dut.interrupt.value == 0, \"[ERROR] Interrupt not cleared\"\n    dut._log.info(f\"[CHECK] Interrupt cleared successfully: {dut.interrupt.value}\")\n\n    dut._log.info(\"[INFO] Simulation completed\")\n\n"}}}
{"id": "cvdp_copilot_ttc_lite_0016", "categories": ["cid014", "medium"], "input": {"prompt": "Create SystemVerilog Assertions to verify the functional correctness of the `ttc_counter_lite` module. The properties should ensure that:\n\n- **Interval Mode Reset:**  \n   When `enable` and `interval_mode` are asserted, and `count` reaches `match_value`, the counter must reset to `reload_value` on the next clock cycle.\n\n- **Match Value Write:**  \n   When an AXI write occurs to the `ADDR_MATCH_VALUE` register, the `match_value` register should correctly update to `axi_wdata[15:0]`.\n\n- **Reload Value Write:**  \n   When an AXI write occurs to the `ADDR_RELOAD_VALUE` register, the `reload_value` register should correctly update to `axi_wdata[15:0]`.\n\n- **Control Register Write:**  \n   When an AXI write occurs to the `ADDR_CONTROL` register, the control signals (`enable`, `interval_mode`, `interrupt_enable`, `interrupt_clear`) should correctly update according to `axi_wdata[3:0]`.\n\n- **Counter Range Check:**  \n   When the timer is enabled, `count` should always remain within the range `[reload_value, match_value]` to ensure it does not overflow or underflow unexpectedly.\n\n- **Interrupt Assertion:**  \n   When `count` reaches `match_value` and `interrupt_enable` is set, `interrupt` should assert on the next clock cycle.\n\n- **Fault Flag Handling:**  \n   If an AXI write is attempted to an invalid address (`axi_addr > ADDR_STATUS`), the `fault_flag` must be set to `1'b1`.\n\nEach assertion must provide a detailed failure message, including the expected and actual values of the counter, relevant control signals, and AXI transactions for debugging purposes.\n\n---\n\n## Design Specifications\n\nThe `ttc_counter_lite` module is a lightweight timer/counter with configurable match and reload values. It supports AXI-based configuration and status monitoring. The module operates in both one-shot and interval mode, generating an interrupt when the counter reaches the match value.\n\n**Module Name**:\n`ttc_counter_lite`\n\n### Inputs:\n1. **`clk`** (1 bit): Clock signal for synchronous operation.\n2. **`reset`** (1 bit): Active-high reset signal to initialize the timer.\n3. **`axi_addr`** (4 bits): Address bus for AXI-Lite read/write operations.\n4. **`axi_wdata`** (32 bits): Data bus for AXI-Lite write operations.\n5. **`axi_write_en`** (1 bit): Write enable signal for AXI-Lite writes.\n6. **`axi_read_en`** (1 bit): Read enable signal for AXI-Lite reads.\n\n### Outputs:\n1. **`axi_rdata`** (32 bits): Data bus for AXI-Lite read operations.\n2. **`interrupt`** (1 bit): Interrupt signal, asserted when the counter matches the configured match value.\n3. **`fault_flag`** Signal indicating invalid AXI operations, such as unsupported address accesses.\n4. **`debug_flag[15:0]`** Debug output exposing internal states for real-time monitoring.\n\n---", "context": {"rtl/ttc_counter_lite.sv": "\nmodule ttc_counter_lite (\n    input wire          clk,                // Clock signal\n    input wire          reset,              // Reset signal\n    input wire [3:0]    axi_addr,           // AXI address for read/write\n    input wire [31:0]   axi_wdata,          // AXI write data\n    input wire          axi_write_en,       // AXI write enable\n    input wire          axi_read_en,        // AXI read enable\n    output reg [31:0]   axi_rdata,          // AXI read data\n    output reg          interrupt,          // Interrupt signal\n    output reg          fault_flag,         // Fault flag for invalid operations\n    output reg [15:0]   debug_flag          // Debug flag for internal monitoring\n);\n\n    // Timer registers\n    reg [15:0] count;                       // Counter register\n    reg [15:0] match_value;                 // Match value for interval mode\n    reg [15:0] reload_value;                // Reload value in interval mode\n    reg        enable;                      // Timer enable flag\n    reg        interval_mode;               // Interval mode enable flag\n    reg        interrupt_enable;            // Interrupt enable flag\n    reg        interrupt_clear;             // Interrupt clear signal\n\n    // Address map\n    localparam ADDR_COUNT        = 4'b0000; // Counter register (read only)\n    localparam ADDR_MATCH_VALUE  = 4'b0001; // Match value register\n    localparam ADDR_RELOAD_VALUE = 4'b0010; // Reload value register\n    localparam ADDR_CONTROL      = 4'b0011; // Control register\n    localparam ADDR_STATUS       = 4'b0100; // Status register\n\n    wire match_flag = (count == match_value);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 16'b0; \n        end else if (enable) begin\n            if (interval_mode && match_flag) begin\n                count <= reload_value; \n            end \n            else if (count == match_value) begin\n                count <= count; \n            end else begin\n                count <= count + 16'b1; \n            end\n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            interrupt <= 1'b0;\n        end else if (match_flag && interrupt_enable) begin\n            interrupt <= 1'b1; \n        end else if (interrupt_clear) begin\n            interrupt <= 1'b0; \n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            match_value      <= 16'd50;  \n            reload_value     <= 16'd10;  \n            enable           <= 1'b0; \n            interval_mode    <= 1'b0; \n            interrupt_enable <= 1'b0; \n            interrupt_clear  <= 1'b0; \n            fault_flag       <= 1'b0;   \n        end else if (axi_write_en) begin\n            case (axi_addr)\n                ADDR_MATCH_VALUE:  match_value      <= axi_wdata[15:0];\n                ADDR_RELOAD_VALUE: reload_value     <= axi_wdata[15:0];\n                ADDR_CONTROL: begin\n                    enable           <= axi_wdata[0];\n                    interval_mode    <= axi_wdata[1];\n                    interrupt_enable <= axi_wdata[2];\n                    interrupt_clear  <= axi_wdata[3];\n                end\n                default: fault_flag <= 1'b1; \n            endcase\n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            axi_rdata <= 32'b0;\n        end else if (axi_read_en) begin\n            case (axi_addr)\n                ADDR_COUNT:        axi_rdata <= {16'b0, count}; \n                ADDR_MATCH_VALUE:  axi_rdata <= {16'b0, match_value}; \n                ADDR_RELOAD_VALUE: axi_rdata <= {16'b0, reload_value}; \n                ADDR_CONTROL:      axi_rdata <= {28'b0, interrupt_clear, interrupt_enable, interval_mode, enable};\n                ADDR_STATUS:       axi_rdata <= {30'b0, fault_flag, interrupt}; \n                default:           axi_rdata <= 32'b0;\n            endcase\n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            debug_flag <= 16'b0; \n        end else begin\n            debug_flag <= {enable, interval_mode, interrupt_enable, interrupt_clear, match_flag, count[10:0]};\n        end\n    end\n\nendmodule\n"}}, "output": {"response": "", "context": {"rtl/ttc_counter_lite.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 80\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/ttc_counter_lite.sv\nTOPLEVEL        = ttc_counter_lite\nMODULE          = test_ttc_counter_lite\nPYTHONPATH      = /src\nHASH            = 5d5c075e46d7e91cbc38c65f6940119bfe5bb1e1\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 2, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_ttc_counter_lite.py": "import cocotb\nfrom cocotb.triggers import RisingEdge, Timer\nfrom cocotb.clock import Clock\nimport harness_library as hrs_lb\n\n# Constants for address map\nADDR_MATCH_VALUE = 0x1\nADDR_RELOAD_VALUE = 0x2\nADDR_CONTROL = 0x3\nADDR_STATUS = 0x4\n\n@cocotb.test()\nasync def test_ttc_counter_lite(dut):\n    \n    # Generate a clock signal for the DUT (10 ns period, 100 MHz frequency)\n    cocotb.start_soon(Clock(dut.clk, 10, units=\"ns\").start())\n\n    # Initialize the DUT signals using a helper library (reset all signals to defaults)\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT to ensure a clean start\n    dut.reset.value = 1\n    await Timer(20, units=\"ns\")  # Wait for the reset pulse\n    dut.reset.value = 0\n    await RisingEdge(dut.clk)  # Wait for the next clock edge\n    dut._log.info(\"[INFO] Reset completed and deasserted\")\n\n    # Helper function to write data to a register\n    async def write_register(dut, addr, data):\n       \n        dut.axi_addr.value = addr  # Set the address\n        dut.axi_wdata.value = data  # Set the write data\n        dut.axi_write_en.value = 1  # Enable the write\n        await RisingEdge(dut.clk)  # Wait for one clock cycle\n        dut.axi_write_en.value = 0  # Disable the write\n        await RisingEdge(dut.clk)  # Wait for the next clock edge\n\n    # Helper function to read data from a register\n    async def read_register(dut, addr):\n       \n        dut.axi_addr.value = addr  # Set the address\n        dut.axi_read_en.value = 1  # Enable the read\n        await RisingEdge(dut.clk)  # Wait for one clock cycle\n        dut.axi_read_en.value = 0  # Disable the read\n        await RisingEdge(dut.clk)  # Wait for the next clock edge\n        return dut.axi_rdata.value.integer  # Return the read data as an integer\n\n    # Test: Write match value to the register and verify it\n    await write_register(dut, ADDR_MATCH_VALUE, 0x14)  # Set match_value = 20\n    match_value = await read_register(dut, ADDR_MATCH_VALUE)\n    assert match_value == 0x14, f\"[ERROR] Match value mismatch: {match_value}\"\n    dut._log.info(f\"[CHECK] Match value correctly set to {match_value}\")\n\n    # Test: Write reload value to the register and verify it\n    await write_register(dut, ADDR_RELOAD_VALUE, 0x0A)  # Set reload_value = 10\n    reload_value = await read_register(dut, ADDR_RELOAD_VALUE)\n    assert reload_value == 0x0A, f\"[ERROR] Reload value mismatch: {reload_value}\"\n    dut._log.info(f\"[CHECK] Reload value correctly set to {reload_value}\")\n\n    # Test: Configure control register and verify the settings\n    await write_register(dut, ADDR_CONTROL, 0x7)  # Enable=1, Interval_Mode=1, Interrupt_Enable=1\n    control_value = await read_register(dut, ADDR_CONTROL)\n    assert control_value == 0x7, f\"[ERROR] Control register mismatch: {control_value}\"\n    dut._log.info(f\"[CHECK] Control register configured: Enable={dut.enable.value}, Interval Mode={dut.interval_mode.value}, Interrupt Enable={dut.interrupt_enable.value}\")\n    dut._log.info(\"[CHECK] Control register correctly configured\")\n\n    # Wait and verify counter operation (observe counting within range)\n    await Timer(200, units=\"ns\")  # Allow the counter to run for 200 ns\n    count = int(dut.count.value)  # Read the current counter value\n    reload_value = int(dut.reload_value.value)  # Reload value\n    match_value = int(dut.match_value.value)  # Match value\n    assert reload_value <= count <= match_value, f\"[ERROR] Counter value {count} is out of range [{reload_value}, {match_value}]\"\n    dut._log.info(f\"[CHECK] Counter is running within range: {count}, Reload Value: {reload_value}, Match Value: {match_value}\")\n\n    # Wait and verify interrupt generation when counter matches the match value\n    await Timer(100, units=\"ns\")  # Wait for an interrupt to be generated\n    interrupt_status = await read_register(dut, ADDR_STATUS)\n    assert interrupt_status & 0x1, \"[ERROR] Interrupt not asserted\"\n    dut._log.info(f\"[CHECK] Interrupt asserted at match: {dut.interrupt.value}\")\n    dut._log.info(\"[CHECK] Interrupt correctly asserted at match\")\n\n    # Test: Clear the interrupt and verify it is deasserted\n    await write_register(dut, ADDR_CONTROL, 0x8)  # Set interrupt_clear\n    interrupt_status = await read_register(dut, ADDR_STATUS)\n    assert not (interrupt_status & 0x1), \"[ERROR] Interrupt not cleared\"\n    dut._log.info(f\"[CHECK] Interrupt cleared successfully: {dut.interrupt.value}\")\n    dut._log.info(\"[CHECK] Interrupt cleared successfully\")\n\n    # Test: Write to an invalid address and verify fault flag\n    await write_register(dut, 0xF, 0x1234)  # Write to invalid address\n    fault_status = await read_register(dut, ADDR_STATUS)\n    assert fault_status & 0x2, \"[ERROR] Fault flag not asserted for invalid address\"\n    dut._log.info(f\"[CHECK] Fault flag correctly asserted for invalid address: {dut.fault_flag.value}\")\n\n    # Test: Verify the debug flag for correctness\n    debug_flag = dut.debug_flag.value.integer\n    expected_debug = ((int(dut.enable.value) << 15) |\n                    (int(dut.interval_mode.value) << 14) |\n                    (int(dut.interrupt_enable.value) << 13) |\n                    (int(dut.interrupt_clear.value) << 12) |\n                    (int(dut.match_flag.value) << 11) |\n                    (int(dut.count.value) & 0x7FF))\n    assert debug_flag == expected_debug, f\"[ERROR] Debug flag mismatch: {debug_flag} != {expected_debug}\"\n    dut._log.info(f\"[CHECK] Debug Flag: debug_flag = {int(dut.debug_flag.value)}, expected_debug = {expected_debug}\")\n    dut._log.info(\"[CHECK] Debug flag is functioning correctly\")\n\n    # Final message indicating simulation success\n    dut._log.info(\"[INFO] Simulation finished successfully.\")\n"}}}
{"id": "cvdp_copilot_uart_0013", "categories": ["cid014", "medium"], "input": {"prompt": "\nCan you generate SystemVerilog assertions to validate the behavior and specifications of the `UART`  . The module details and design requirements for assertion development are outlined below.\n\n---\n\n## **Specifications**\n\n### **Interface:**  \n\n**Parameter:**\n\n- `DATA_WIDTH` : Determines the bit width of transmitted and received data. Default is 8.\n- `BAUD_RATE` : Specifies the baud rate for communication. Default is 4800.\n- `CLK_FREQ` : Clock frequency used for UART operations. Default: 50 MHz.\n\n**Inputs:**\n\n- `clk`: 50 MHz system clock. The positive edge of the `clk` controls the design.\n- `reset`: Active HIGH Asynchronous reset signal.\n- `tx_start`: Signal to start data transmission.\n- `tx_data([DATA_WIDTH-1:0])`: Data to be transmitted.\n- `rx`: Received serial data.\n\n**Outputs:**\n\n- `tx`: Transmitted serial data.\n- `tx_ready`: Indicates when the transmitter is ready to accept new data.\n- `rx_data([DATA_WIDTH-1:0])`: Received data output.\n- `rx_ready`: Reception complete flag.\n- `rx_bit_count([3:0])`: Monitor bit counting in reception.\n\n## **Behavioral Requirements** \n\n- **`Transmission`:** If `tx_start` is HIGH then Load `tx_data` into shift register with the formatted frame `start bit`, `tx_data`, `parity` and `stop` bits. Shift out LSB-first at baud rate. TX(`tx`) completes when all bits are sent, setting `tx_ready` is HIGH.\n- **`Reception`:** If `rx` is LOW detected then  Start reception, shift bits into `rx_shift_reg` at baud rate. After receiving `DATA_WIDTH` bits, check parity and stop bit. If valid, `rx_ready` should be HIGH and `rx_data` updates.\n- **`Baud Timing`:**  If `tx_div_counter` and `rx_div_counter` regulate transmission and sampling. `rx_bit_count` tracks received bits.\n\n---\n\n## **Assertion Requirements** \n\n**1. Reset Behavior Verification**\n - Ensures that upon reset `(reset = 1)`:\n - `tx` is set to 1 (idle).\n - `tx_ready = 1` (transmitter ready).\n - `tx_busy = 0`, `rx_ready = 0`, `rx_busy = 0` (UART idle state).\n\n**2. TX Ready & Busy Check**\n- When `tx_ready` is asserted, the transmitter must not be engaged in an ongoing transmission when `tx_busy` has LOW.\n\n**3. RX Start Bit Detection**\n- The UART receiver `rx_busy` should be enabled when a falling edge is detected on `rx` (i.e., rx is LOW while rx_busy is also LOW) and If this condition is met, `rx_busy` must be set HIGH in the next clock cycle for the start of data reception.\n\n**4. RX Data Integrity Check and RX Parity Validation**\n- Ensures that when `rx_ready` is HIGH, `rx_data` correctly shifted into `rx_shift_reg` confirming proper data reception on the receiver side. Also, verifies that the computed parity of `rx_shift_reg` matches the received parity bit, ensuring error detection.\n\n **5. RX Baud Rate Timing Check**\n- Ensures `rx_div_counter` resets correctly at zero and does not exceed BAUD_DIV - 1, maintaining correct bit sampling.\n\n**6. RX Bit Counting Check**\n- Ensures `rx_bit_count_internal` holds its previous value unless a new bit is received during RX operation.\n\n---\n\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.\n\n", "context": {"rtl/UART_RTL.sv": "module UART_RTL#(\n    parameter int DATA_WIDTH = 8,\n    parameter int BAUD_RATE = 4800,\n    parameter int CLK_FREQ = 50000000 // Clock frequency in Hz\n) (\n    input  logic clk,         // Common clock (50 MHz) for both TX and RX\n    input  logic reset,       // Asynchronous reset\n    input  logic tx_start,    // Start transmission\n    input  logic [DATA_WIDTH-1:0] tx_data, // Data to be transmitted\n    output logic tx,          // Transmitted serial data\n    output logic tx_ready,    // Transmitter ready to accept new data\n    input  logic rx,          // Received serial data\n    output logic [DATA_WIDTH-1:0] rx_data, // Data received\n    output logic rx_ready,    // Reception complete flag\n    output logic [3:0] rx_bit_count // To monitor bit counting\n);\n\n    // Calculate baud rate divisor for the transmitter and receiver\n    localparam int BAUD_DIV = CLK_FREQ / BAUD_RATE;\n\n    // Transmitter signals\n    logic [DATA_WIDTH+3:0] tx_shift_reg;\n    logic [15:0] tx_bit_count;\n    logic [15:0] tx_div_counter;\n    logic tx_busy;\n    logic tx_parity;\n\n    // Receiver signals\n    logic [DATA_WIDTH+2:0] rx_shift_reg;\n    logic [3:0] rx_bit_count_internal;\n    logic [15:0] rx_div_counter;\n    logic rx_busy;\n    logic rx_parity;\n    logic [2:0] rx_sample_count; // Counter to determine the middle of a bit\n\n    assign rx_bit_count = rx_bit_count_internal;\n\n    // TX FSM (using clk)\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            tx <= 1'b1;\n            tx_ready <= 1'b1;\n            tx_busy <= 1'b0;\n            tx_div_counter <= 0;\n            tx_bit_count <= 0;\n            tx_parity <= 1'b0; // Initialize parity bit\n        end else begin\n            if (tx_start && tx_ready) begin\n                // Calculate parity bit for even parity\n                tx_parity <= ^tx_data; // XOR all bits in tx_data for even parity\n                // Load data into the shift register with start, parity, and stop bits\n                tx_shift_reg <= {2'b11, tx_parity, tx_data, 1'b0}; // Stop bits, parity, data, start\n                tx_bit_count <= 0;\n                tx_div_counter <= BAUD_DIV - 1;\n                tx_busy <= 1;\n                tx_ready <= 1'b0;\n            end\n\n            if (tx_busy) begin\n                if (tx_div_counter == 0) begin\n                    tx_div_counter <= BAUD_DIV - 1;\n                    if (tx_bit_count < DATA_WIDTH + 3) begin\n                        tx <= tx_shift_reg[0];\n                        tx_shift_reg <= tx_shift_reg >> 1;\n                        tx_bit_count <= tx_bit_count + 1;\n                    end else begin\n                        tx_busy <= 1'b0;\n                        tx_ready <= 1'b1;\n                    end\n                end else begin\n                    tx_div_counter <= tx_div_counter - 1;\n                end\n            end\n        end\n    end\n\n      // RX FSM (using clk)\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            rx_shift_reg <= 0;\n            rx_bit_count_internal <= 0;\n            rx_div_counter <= 0;\n            rx_busy <= 1'b0;\n            rx_data <= 0;\n            rx_ready <= 1'b0;\n            rx_sample_count <= 0;\n        end else begin\n            if (!rx_busy && (rx == 1'b0)) begin // Detect start bit\n                rx_busy <= 1'b1;\n                rx_div_counter <= BAUD_DIV / 2; // Wait to sample in the middle of the start bit\n                rx_bit_count_internal <= 0;\n                rx_sample_count <= 0;\n                rx_ready <= 1'b0; // Clear ready flag\n            end\n\n            if (rx_busy) begin\n                if (rx_div_counter == 0) begin\n                    rx_div_counter <= BAUD_DIV - 1; // Use the same baud divisor for both TX and RX\n\n                    if (rx_bit_count_internal == 0) begin\n                        rx_bit_count_internal <= 1; // Move to the next bit (skip the start bit)\n                    end else if (rx_bit_count_internal <= DATA_WIDTH) begin\n                        rx_shift_reg <= {rx, rx_shift_reg[DATA_WIDTH+1:1]}; // Shift in the received bit\n                        rx_bit_count_internal <= rx_bit_count_internal + 1;\n                    end else if (rx_bit_count_internal == DATA_WIDTH + 1) begin\n                        // Parity bit check (not used in this example, but reserved for future)\n                        rx_parity <= rx; \n                        rx_bit_count_internal <= rx_bit_count_internal + 1;\n                    end else if (rx_bit_count_internal == DATA_WIDTH + 2) begin\n                        // Stop bit check\n                        if (rx == 1'b1) begin // Ensure stop bit is 1\n                            rx_data <= rx_shift_reg[DATA_WIDTH+2:2]; // Load the received data\n                            rx_ready <= 1'b1; // Indicate data reception is complete\n                        end\n                        rx_busy <= 1'b0; // Frame is done\n                    end\n                end else begin\n                    rx_div_counter <= rx_div_counter - 1;\n                end\n            end else begin\n                rx_ready <= 1'b0; // Clear ready flag once data is read\n            end\n        end\n    end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/UART_RTL.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = dut\nTARGET          = 100 \nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nWAVE            = True\nVERILOG_SOURCES = /code/rtl/UART_RTL.sv\nTOPLEVEL        = UART_RTL\nMODULE          = test_uart\nPYTHONPATH      = /src\nHASH            = d15322b3eef7b3e964186bd7b00975b918edffe5", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_uart.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import Timer\n\nasync def fn(dut, reg):\n    \"\"\"UART Transmission and Reception logic.\"\"\"\n    \n    # Register to store RX bits during transmission\n    rx_data_reg = []\n\n    # Start the clock (50 MHz -> 20ns period)\n    cocotb.start_soon(Clock(dut.clk, 20, units='ns').start())\n\n    # Reset the DUT\n    dut.reset.value = 1\n    dut.tx_start.value = 0\n    dut.tx_data.value = 0\n    dut.rx.value = 1  # Set rx to idle state (high)\n    await Timer(100, units='ns')\n    dut.reset.value = 0\n    await Timer(100, units='ns')  \n    \n    # Ensure TX is initially ready\n    assert dut.tx_ready.value == 1, \"TX should be ready initially\"\n\n    # Wait for some cycles before starting transmission\n    await Timer(10, units=\"ns\")\n\n    # Get BAUD_RATE from DUT\n    BAUD_RATE = int(dut.BAUD_RATE.value)\n    \n    # Calculate baud period in nanoseconds\n    baud_period = int(1e9 / BAUD_RATE)  # Baud period in ns\n    dut._log.info(f\"Calculated baud period: {baud_period} ns\")\n\n    # Transmit start bit (0)\n    dut.tx.value = 0  # Start bit (Low)\n    dut.rx.value = 0  # Immediately mirror TX to RX for start bit\n    #rx_data_reg.append(dut.rx.value.to_unsigned())  # Store start bit in rx_data_reg\n    rx_data_reg.append(int(dut.rx.value))\n    await Timer(baud_period, units='ns')  # Wait for the full baud period\n    dut._log.info(f\"TX start bit transmitted: {dut.tx.value}, RX: {dut.rx.value}\")\n\n    # Transmit 8 data bits\n    for bit in reg:\n        dut.tx.value = bit  # Send each bit of the data\n        await Timer(1, units='ns')  # Ensure RX is updated after TX\n        dut.rx.value = dut.tx.value  # Immediately mirror TX to RX\n        #rx_data_reg.append(dut.rx.value.to_unsigned())  # Store RX bits in rx_data_reg\n        rx_data_reg.append(int(dut.rx.value))\n        #dut._log.info(f\"TX bit: {bit}, RX bit: {dut.rx.value.to_unsigned()}\")\n        dut._log.info(f\"TX bit: {bit}, RX bit: {dut.rx.value}\")\n        await Timer(baud_period - 1, units='ns')  # Wait full baud period\n\n    # Calculate even parity (XOR all data bits)\n    parity_bit = 0\n    for bit in reg:\n        parity_bit ^= bit  # XOR operation to calculate even parity\n\n    # Transmit parity bit\n    dut.tx.value = parity_bit\n    await Timer(1, units='ns')  # Ensure RX is updated after TX\n    dut.rx.value = parity_bit  # Mirror TX parity to RX\n    #rx_data_reg.append(dut.rx.value.to_unsigned())  # Store parity bit in rx_data_reg\n    rx_data_reg.append(int(dut.rx.value))\n    dut._log.info(f\"TX parity bit: {parity_bit}\")\n    await Timer(baud_period - 1, units='ns')  # Wait full baud period\n\n    # Transmit stop bit (1)\n    dut.tx.value = 1\n    await Timer(1, units='ns')  # Ensure RX is updated after TX\n    dut.rx.value = dut.tx.value  # Mirror TX stop bit to RX\n    #rx_data_reg.append(dut.rx.value.to_unsigned())  # Store stop bit in rx_data_reg\n    rx_data_reg.append(int(dut.rx.value))\n    dut._log.info(\"TX stop bit transmitted.\")\n    await Timer(baud_period - 1, units='ns')  # Wait full baud period\n\n    dut._log.info(\"UART transmission complete.\")\n\n    # Receiver logic\n    dut._log.info(\"UART Reception started:\")\n\n    # Now print the RX values received from TX\n    for i, rx_bit in enumerate(rx_data_reg):\n        dut._log.info(f\"RX bit {i}: {rx_bit}\")\n\n    # Receiver logic: Use rx_data_reg for receiver processing \n    received_data = rx_data_reg[2:10]  # Exclude parity and stop bit from data\n\n    # Verify received data matches transmitted data\n    transmitted_data = reg\n    assert received_data == transmitted_data, f\"Received data {received_data} does not match transmitted data {transmitted_data}\"\n\n    # Check parity\n    received_parity = rx_data_reg[-2]  # Second-to-last bit is parity bit\n    stop_bit = rx_data_reg[-1]  # Last bit is stop bit\n    expected_parity = 0\n    for bit in transmitted_data:\n        expected_parity ^= bit  # XOR for even parity\n\n   \n    dut._log.info(\"UART Received data matches with Transmitted data.\")\n\n@cocotb.test()\nasync def test_1(dut):\n    \"\"\"Test Case 1: Data = [0,0,0,0,1,1,1,1]\"\"\"\n    reg = [0, 0, 0, 0, 1, 1, 1, 1]\n    await fn(dut, reg)\n\n@cocotb.test()\nasync def test_2(dut):\n    \"\"\"Test Case 2: Data = [1,1,0,0,1,1,0,0]\"\"\"\n    reg = [1, 1, 0, 0, 1, 1, 0, 0]\n    await fn(dut, reg)\n\n@cocotb.test()\nasync def test_3(dut):\n    \"\"\"Test Case 3: Data = [0,0,1,1,0,1,0,0]\"\"\"\n    reg = [0, 0, 1, 1, 0, 1, 0, 0]\n    await fn(dut, reg)"}}}
{"id": "cvdp_copilot_vending_machine_0009", "categories": ["cid014", "medium"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the vending_machine module based on the design specifications provided? Below are the module details and design requirements for assertion development.\n\n## **Interface**\n\n### **Inputs**\n- **clk:** Clock signal for timing and synchronizing state transitions, operating on the rising edge.\n- **rst:** Asynchronous, active-high reset signal that resets all internal states, outputs, and accumulated values, returning the machine to the `IDLE` state.\n- **item_button(1-bit):** Signal indicating that the user has pressed the button to initiate item selection (active high). This acts as a toggle signal and should only register on the rising edge.\n- **item_selected (3-bits,[2:0]):** This input represents the item chosen by the user, with valid values corresponding to the four available items (valid values: `3'b001` to `3'b100`).\n- **coin_input(4-bits,[3:0]):** This input represents the value of the coin inserted, with valid values of 1, 2, 5, or 10 units.\n- **cancel(1-bit):** Signal allowing the user to cancel the current transaction before the item is dispensed (active high).\n\n### **Outputs**\n- **dispense_item(1-bit):** Indicates that the selected item is ready for dispensing after the required amount is met. Active high for one clock cycle when the item is being dispensed.\n- **return_change(1-bit):** Signal that excess coins are being returned as change. Active high for one clock cycle when change is being returned.\n- **item_price(5-bits,[4:0]):** Output displaying the price of the currently selected item.\n- **change_amount(5-bits,[4:0]):** Output representing the amount of change to be returned if excess coins were inserted.\n- **dispense_item_id(3-bits,[2:0]):** Output indicating the ID of the item being dispensed.\n- **error(1-bit):** Indicates that an invalid operation has occurred, such as inserting coins without selecting an item or entering invalid coin values. Active high for one clock cycle during an error condition.\n- **return_money(1-bit):** Indicates that all inserted money should be returned due to cancellation or an error. Active high for one clock cycle when returning money.\n\n# Design Specifications\n\nThe vending machine operates in multiple states, handling item selection, coin validation, and dispensing items accordingly.\n\n## Item Selection and Payment Validation:\n- The user selects an item using `item_button` and `item_selected`.\n- The machine validates whether a selected item is valid (3'b001 to 3'b100).\n- The total amount of inserted coins is accumulated.\n- If the accumulated coins meet or exceed the item's price, the machine transitions to the dispensing state.\n- If an invalid item is selected (3'b000), the machine triggers an error and returns all money.\n- Only valid coin values (1, 2, 5, 10) are accepted. Invalid coin values should trigger an error and return all inserted money.\n\n## Dispensing Items and Change Handling:\n- The machine dispenses an item when sufficient payment is received.\n- If the inserted money exceeds the item price, the excess amount is returned as change.\n- The machine resets to IDLE after completing the transaction.\n\n## Error Handling and Cancellation:\n- Pressing the cancel button at any stage should result in an error and return all inserted money.\n- Any invalid operation should trigger an error and reset the system to IDLE.\n\n# Assertion Requirements\n\nDevelop a set of SystemVerilog assertions to validate the following behaviors:\n\n## 1. Reset Behavior:\nThis assertion ensures that when the reset signal (`rst`) is asserted, the vending machine initializes correctly. \n\n- On the rising edge of `clk`, if `rst` is high, the following conditions must be met:\n  1. `current_state` must be set to IDLE.\n  2. `coins_accumulated` must be cleared.\n  3. `return_money` must be de-asserted.\n\n## 2. Dispense the Correct Item Assertion:\n- Ensures that the dispensed item ID matches the selected item.\n- The assertion is checked one cycle (`##1`) after entering `DISPENSING_ITEM` state.\n- Disabled when `rst` is high.\n\n## 3. Dispense Only When Enough Money is Inserted:\n- Ensures that the vending machine only dispenses an item if enough money has been inserted.\n- If the state is `DISPENSING_ITEM`, then `coins_accumulated` must be at least equal to `item_price`.\n- Disabled when `rst` is high.\n\n## 4. Transition to IDLE After an Error:\n- Ensures that after an error, the vending machine must transition to the IDLE state in the next cycle (`##1`).\n- Disabled when `rst` is high.\n\n## 5. Cancel Should Trigger Error:\n- Ensures that pressing the cancel button results in an error signal being asserted in the next cycle.\n- Disabled when `rst` is high.\n\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry standards for concise, effective verification.", "context": {"rtl/vending_machine.sv": "module vending_machine(\n    input clk,                          // Clock signal\n    input rst,                          // Reset signal\n    input item_button,                  // Signal for item selection button press (active high, rising edge)\n    input [2:0] item_selected,          // 3-bit input to select item (valid: 3'b001 to 3'b100)\n    input [3:0] coin_input,             // 4-bit coin input to represent value of coin inserted (1, 2, 5, or 10)\n    input cancel,                       // Cancel button signal (active high, rising edge)\n    output reg dispense_item,           // Signal to dispense item (active high for one cycle)\n    output reg return_change,           // Signal to return change (active high for one cycle)\n    output reg [4:0] item_price,        // Price of the selected item\n    output reg [4:0] change_amount,     // Amount of change to return\n    output reg [2:0] dispense_item_id,  // ID of item being dispensed\n    output reg error,                   // Error signal if any invalid operation occurs (active high for one cycle)\n    output reg return_money             // Signal to return all money if operation is cancelled or invalid (active high for one cycle)\n);\n\n    // Item Prices (Assume we have 4 items with prices: 5, 10, 15, 20 units)\n    localparam ITEM_1_PRICE = 5'd5;\n    localparam ITEM_2_PRICE = 5'd10;\n    localparam ITEM_3_PRICE = 5'd15;\n    localparam ITEM_4_PRICE = 5'd20;\n\n    // Item IDs or Names\n    localparam NO_ITEM = 3'b000;\n    localparam ITEM_1_ID = 3'b001; // Item 1\n    localparam ITEM_2_ID = 3'b010; // Item 2\n    localparam ITEM_3_ID = 3'b011; // Item 3\n    localparam ITEM_4_ID = 3'b100; // Item 4\n\n    // Internal registers\n    reg [4:0] coins_accumulated;   // Tracks accumulated coins\n    reg [4:0] amount;\n\n    // Define state enum\n    typedef enum logic [3:0] {\n        IDLE                = 4'd0,     // Idle state\n        ITEM_SELECTION      = 4'd1,     // Waiting for item selection\n        PAYMENT_VALIDATION  = 4'd2,     // Validating coin input\n        DISPENSING_ITEM     = 4'd3,     // Dispensing the item\n        RETURN_CHANGE       = 4'd4,     // Returning change\n        RETURN_MONEY        = 4'd5      // Returning all money\n    } state_t;\n\n    state_t current_state, next_state;         // Current and next states of the vending machine\n    reg [4:0] next_coins_accumulated;\n    reg       next_return_change;\n    reg [4:0] next_item_price;\n    reg [4:0] next_change_amount;\n    reg       next_error;\n    reg [2:0] next_dispense_item_id;\n    reg       next_return_money;\n    reg       next_dispense_item;\n    reg [4:0] next_amount;\n\n    // State Machine logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all outputs and internal registers\n            coins_accumulated <= 5'd0;\n            return_change     <= 1'b0;\n            item_price        <= 5'd0;\n            change_amount     <= 5'd0;\n            error             <= 1'b0;\n            dispense_item_id  <= 3'd0;\n            return_money      <= 1'b0;\n            dispense_item     <= 1'b0;\n            current_state     <= IDLE;\n        end else begin\n            current_state       <= next_state;\n            coins_accumulated   <= next_coins_accumulated;\n            item_price          <= next_item_price;\n            change_amount       <= next_change_amount;\n            error               <= next_error;\n            dispense_item_id    <= next_dispense_item_id;\n            return_money        <= next_return_money;\n            dispense_item       <= next_dispense_item;\n            return_change       <= next_return_change;\n            amount              <= next_amount;\n\n        end\n        \n    end\n\n    // Next state logic (combinatorial)\n    always @ (*) begin\n        next_state = current_state;\n        next_coins_accumulated = coins_accumulated;\n        next_item_price        = item_price;\n        next_change_amount     = change_amount;\n        next_error             = error;\n        next_dispense_item_id  = dispense_item_id;\n        next_return_money      = return_money;\n        next_dispense_item     = dispense_item;\n        next_return_change     = return_change;\n        next_amount            = amount;\n        case (current_state)\n            // IDLE State\n            IDLE: begin\n                if (item_button) begin\n                    next_return_money  = 1'b0;\n                    next_return_change = 1'b0; \n                    next_change_amount = 5'd0;\n                    next_coins_accumulated = 5'd0; \n                    next_error   = 1'b0;\n                    next_amount = 5'd0;\n                    next_dispense_item_id = 3'd0;\n                    next_state = ITEM_SELECTION;\n                end else if (coin_input > 0) begin\n                    next_return_change = 1'b0; \n                    next_coins_accumulated =  coin_input;\n                    next_error   = 1'b1;\n                    next_amount = 5'd0;;    \n                    next_dispense_item_id  = 3'd0;\n                    next_state = RETURN_MONEY;\n                end else begin\n                    next_return_money  = 1'b0;\n                    next_return_change = 1'b0; \n                    next_change_amount = 5'd0;\n                    next_error   = 1'b0;\n                    next_amount = 5'd0;\n                    next_dispense_item_id  = 3'd0;\n                end\n            end\n\n            // ITEM_SELECTION State\n            ITEM_SELECTION: begin\n                if (cancel) begin\n                    next_error   = 1'b1;\n                    next_state = RETURN_MONEY;\n                end else if (item_selected >= 3'b000 ) begin\n                    case (item_selected)\n                        3'b001: next_item_price = ITEM_1_PRICE;\n                        3'b010: next_item_price = ITEM_2_PRICE;\n                        3'b011: next_item_price = ITEM_3_PRICE;\n                        3'b100: next_item_price = ITEM_4_PRICE;\n                        default: next_item_price = NO_ITEM;\n                    endcase\n                    next_state = PAYMENT_VALIDATION;\n                end\n            end\n\n            // PAYMENT_VALIDATION State\n            PAYMENT_VALIDATION: begin\n                if (cancel) begin\n                    next_error   = 1'b1;\n                    next_state = RETURN_MONEY;\n                end else if ( item_selected == 3'b000 ) begin\n                    next_error = 1'b1;\n                    next_coins_accumulated = coins_accumulated + coin_input;\n                    next_state = RETURN_MONEY;\n                end else if ( item_price == NO_ITEM ) begin\n                    next_error = 1'b1;\n                    next_coins_accumulated = coins_accumulated + coin_input;\n                    next_state = RETURN_MONEY;\n                end else if (error) begin\n                    next_state = IDLE; \n                end else if (coins_accumulated >= item_price) begin\n                    next_state = DISPENSING_ITEM;\n                    next_dispense_item   = 1'b1;\n                end else if (coin_input > 0) begin\n                    // Validate the coin input (only 1, 2, 5, or 10 is accepted)\n                    if (coin_input == 4'd1 || coin_input == 4'd2 || coin_input == 4'd5 || coin_input == 4'd10) begin\n                        next_coins_accumulated = coins_accumulated + coin_input; \n                        next_state = PAYMENT_VALIDATION;  \n                    end else begin  \n                        next_amount =  coins_accumulated + coin_input;  \n                        next_error = 1'b1; \n                        next_return_money = 1'b1; \n                        next_change_amount = next_amount;\n                        next_state = IDLE;      \n                    end\n                end\n            end\n\n            // DISPENSING_ITEM State\n            DISPENSING_ITEM: begin\n                next_dispense_item = 1'b0;\n                case (item_selected)\n                    3'b001: next_dispense_item_id = ITEM_1_ID;\n                    3'b010: next_dispense_item_id = ITEM_2_ID;\n                    3'b011: next_dispense_item_id = ITEM_3_ID;\n                    3'b100: next_dispense_item_id = ITEM_4_ID;\n                    default: next_dispense_item_id = NO_ITEM;\n                endcase\n\n                if (coins_accumulated > item_price) begin\n                    next_state = RETURN_CHANGE;\n                    next_amount = coins_accumulated - item_price;\n                end else begin\n                    next_coins_accumulated = 5'd0;\n                    next_state = IDLE;\n                end\n                next_coins_accumulated = 5'd0;\n            end\n\n            // RETURN_CHANGE State\n            RETURN_CHANGE: begin\n                next_return_change = 1'b1;\n                next_change_amount = amount;\n                next_error   = 1'b0;\n                next_dispense_item_id  = 3'b000;\n                next_coins_accumulated = 5'b0;\n                next_state = IDLE;\n            end\n\n            // RETURN_MONEY State\n            RETURN_MONEY: begin\n                if (coins_accumulated == 0) begin\n                    next_return_money  = 1'b0;\n                end else if (coins_accumulated > 0) begin\n                    next_return_money  = 1'b1;\n                    next_change_amount = coins_accumulated;\n                end\n                next_error   = 1'b0;\n                next_state = IDLE;\n            end\n\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule\n"}}, "output": {"response": "", "context": {"rtl/vending_machine.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/vending_machine.sv\nTOPLEVEL        = vending_machine\nMODULE          = test_vending_machine\nPYTHONPATH      = /src\nHASH            = d5e3c9ad9b92dd8712ea6229b5f2bb6ac4ffa4ab\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_vending_machine.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, ReadOnly , Timer\n\nimport harness_library as hrs_lb\nimport random\n\n# Task to select item\nasync def select_item(dut, item):\n    await RisingEdge(dut.clk)\n    dut.item_button.value = 1   \n    await RisingEdge(dut.clk)\n    dut.item_selected.value = item\n    dut.item_button.value = 0\n    await RisingEdge(dut.clk)\n\n# Task to insert coins\nasync def insert_coins(dut, amount):\n    dut.coin_input.value = amount\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk)\n\n# Task to simulate cancel button press\nasync def cancel_purchase(dut):\n    dut.cancel.value = 1\n    await RisingEdge(dut.clk)\n    dut.cancel.value = 0\n\n# Task to check if the item is dispensed and no errors occurred\nasync def check_dispense(dut, expected_item_id):\n    await RisingEdge(dut.clk)\n    assert dut.dispense_item.value == 1, f\"Expected item to be dispensed!\"\n    await RisingEdge(dut.clk)\n    assert dut.dispense_item_id.value == expected_item_id, f\"Dispensed item ID mismatch, got {dut.dispense_item_id.value}, expected {expected_item_id}\"\n    assert dut.error.value == 0, f\"Error signal should not be high!\"\n    assert dut.return_change.value == 0, \"Change should not be returned change in this clock cycle\"\n    print(f\"Dispense_item_id  - {int(dut.dispense_item_id.value)} , Error - {int(dut.error.value)} \")\n\n# Task to check if the correct change is returned\nasync def check_change(dut, expected_change): \n    if expected_change > 0:\n        await RisingEdge(dut.clk)\n        assert dut.return_change.value == 1, \"Change should be returned\"\n        print(f\"expected_chang amount - {int(expected_change)}\")\n        print(f\"Return change amount - {int(dut.change_amount.value)}\")\n        assert dut.change_amount.value == expected_change, f\"Expected change {expected_change}, but got {dut.change_amount.value}\"\n    else:\n        assert dut.return_change.value == 0, \"No change should be returned\"\n    await RisingEdge(dut.clk)\n    assert dut.return_change.value == 0, \"Change should not be returned after one cycle\"\n    assert dut.change_amount.value == 0, f\"Expected change {0}, but got {dut.change_amount.value}\"\n\n# Task to randomly buy an item with random coins and validate results\nasync def random_purchase(dut):\n    item_id = random.randint(1, 4)\n    item_prices = {1: 5, 2: 10, 3: 15, 4: 20}\n    expected_price = item_prices[item_id]\n    dut._log.info(f\"Randomly selecting item {item_id}, expected price: {expected_price}\")\n\n    await select_item(dut, item_id)\n\n    # Randomly insert coins until we meet or exceed the price\n    total_inserted = 0\n    while total_inserted < expected_price:\n        coin = random.choice([1, 2, 5, 10])  \n        await insert_coins(dut, coin)\n        total_inserted += coin\n        dut._log.info(f\"Inserted coin: {coin}, total so far: {total_inserted}\")\n\n    await check_dispense(dut, item_id)\n    expected_change = total_inserted - expected_price   \n\n    await check_change(dut, expected_change)\n    await Timer(50, units='ns')\n\n# Task to randomly cancel a purchase\nasync def random_cancel_purchase(dut):\n    item_prices = {1: 5, 2: 10, 3: 15, 4: 20}\n    item_id = random.randint(1, 4)\n    expected_price = item_prices[item_id]\n\n    dut._log.info(f\"Randomly selecting item {item_id} with price {expected_price} and canceling the operation\")\n    await select_item(dut, item_id)\n    dut.coin_input.value = 1\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 2\n    await RisingEdge(dut.clk) \n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk)\n    await cancel_purchase(dut)\n    await RisingEdge(dut.clk)\n    assert dut.error.value == 1, \"Error should be high for cancellation\"\n    await RisingEdge(dut.clk)\n    assert dut.return_money.value == 1, \"Expected money to be returned after cancellation\"\n    assert dut.error.value == 0, \"Error should not be high for cancellation after clock\"\n    await RisingEdge(dut.clk)\n    assert dut.return_money.value == 0, \"when cancle Expected money not be returned after clock\"\n    await Timer(50, units='ns')\n\n# Task to simulate invalid item selection\nasync def invalid_item_selection(dut):\n    invalid_item_id = random.choice([0,5])\n    dut._log.info(f\"Selecting invalid item ID: {invalid_item_id}\")\n    await select_item(dut, invalid_item_id)\n    dut.coin_input.value = 2\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk)\n    assert dut.error.value == 1, \"Error should be high for invalid item selection\"\n    assert dut.dispense_item.value == 0, \"No item should be dispensed\"\n    await insert_coins(dut, 0)\n    assert dut.error.value == 0, \"Error should not be high for invalid item selection after clock\" \n    await Timer(50, units='ns')\n\n# Task to simulate multiple purchases without resetting the machine\nasync def multiple_purchases_without_reset(dut):\n    for _ in range(3):  \n        await random_purchase(dut)\n        await RisingEdge(dut.clk) \n    await Timer(50, units='ns')\n\n# Task to simulate random coin validation\nasync def random_coin_validation(dut):\n    coin = random.choice([1,2,5,10]) \n    dut._log.info(f\"Inserting random coin value: {coin}\")\n\n    await select_item(dut, random.randint(1, 4)) \n    await insert_coins(dut, coin)\n    if coin == 7:\n        assert dut.error.value == 1, \"Expected error for invalid coin input\"\n    else:\n        assert dut.error.value == 0, \"Unexpected error for valid coin input\"\n    await insert_coins(dut, 0)\n    await Timer(50, units='ns')\n\nasync def reset_during_transaction(dut):\n    await select_item(dut, 3)\n    await insert_coins(dut, 5)\n    await insert_coins(dut, 0)\n    dut._log.info(\"Resetting the machine during the transaction.\")\n    dut.rst.value = 1\n    dut.item_selected.value = 0\n    await Timer(30, units='ns')\n\n    assert dut.dispense_item.value == 0, \"No item should be dispensed after reset\"\n    assert dut.return_money.value == 0, \"No money should be returned after reset\"\n    await RisingEdge(dut.clk)\n    dut.rst.value = 0\n    await RisingEdge(dut.clk)\n    dut._log.info(\"reset_during_transaction: Machine successfully reset during transaction.\")\n    await Timer(50, units='ns')\n\n# Task to simulate inserting coins without selecting an item\nasync def insert_coins_without_selecting_item(dut):\n    cocotb.log.info(\"Simulating coin insertion without selecting an item\")\n    await RisingEdge(dut.clk)\n    dut.item_button.value = 1   \n    dut.item_selected.value = 0\n    await RisingEdge(dut.clk)\n    dut.item_button.value = 0\n    await RisingEdge(dut.clk)\n    await insert_coins(dut, 10)\n\n    assert dut.error.value == 1, \"Error should be raised when inserting coins without selecting an item\"\n    await RisingEdge(dut.clk)  \n    assert dut.error.value == 0, \"Error should  not be raised when inserting coins without selecting an item after a clock\"\n    assert dut.return_money.value == 1, \"Money should be returned when no item is selected\"\n    await insert_coins(dut, 0)\n    await RisingEdge(dut.clk)\n\n\n    assert dut.dispense_item.value == 0, \"No item should be dispensed without item selection\"\n    assert dut.return_money.value == 0, \"Money should not be returned when no item is selected after a clock\"\n    cocotb.log.info(\"Simulating coin insertion without selecting an item: Coins returned when no item is selected.\")\n    await Timer(50, units='ns')\n\n# Task to cancel after selecting an item\nasync def cancel_after_selecting_item(dut):\n    item_id = 2\n    await select_item(dut, item_id)\n    dut._log.info(f\"Selected item {item_id}\")\n\n    dut.cancel.value = 1\n    await RisingEdge(dut.clk)\n    dut.cancel.value = 0\n    await RisingEdge(dut.clk)\n    assert dut.error.value == 1, \"Expected error signal to be set after cancellation\"\n    await RisingEdge(dut.clk)\n\n    await RisingEdge(dut.clk)\n    assert dut.error.value == 0, \"Expected error signal not be set in cancellation after a clock  \"\n    await Timer(50, units='ns')   \n\n\n# Task to insert coins without selecting an item\nasync def insert_coins_without_item_button(dut):\n    coin = 5\n    await RisingEdge(dut.clk) \n    dut.item_selected.value = 0\n    await RisingEdge(dut.clk) \n    dut.coin_input.value = coin\n    await RisingEdge(dut.clk)\n    dut.coin_input.value = 0\n    await RisingEdge(dut.clk) \n    assert dut.error.value == 1, \"Expected error signal to be set when coins are inserted without item selection\"\n    dut._log.info(f\"Inserted coin: {coin} without selecting an item\")\n    await RisingEdge(dut.clk)   \n    assert dut.return_money.value == 1, \"Expected return_money signal to be high when no item selected\"\n    assert dut.error.value == 0, \"Expected error signal not be set when coins are inserted without item selection after a clock\"\n    dut._log.info(\"Coins returned successfully when inserted without item selection.\")\n    await RisingEdge(dut.clk) \n    assert dut.return_money.value == 0, \"Expected return_money signal not be high when no item selected after a clock\"\n    await Timer(50, units='ns')\n\n# Task to insert an invalid coin during payment validation\nasync def insert_invalid_coin_during_payment_validation(dut):\n    item_id = 1\n    await select_item(dut, item_id)\n    dut._log.info(f\"Selected item {item_id}\")\n    await insert_coins(dut, 1)\n    dut.coin_input.value = 3\n    await RisingEdge(dut.clk)   \n    dut.coin_input.value = 0 \n    await RisingEdge(dut.clk) \n    assert dut.return_money.value == 1, \"Expected return_money signal to be high after inserting invalid coin\"\n    assert dut.error.value == 1, \"Expected error signal to be set after inserting invalid coin\"\n    dut._log.info(\"Invalid coin insertion handled successfully.\")\n    await RisingEdge(dut.clk) \n\n    assert dut.return_money.value == 0, \"Expected return_money signal not be high after inserting invalid coin after a clock\"\n    assert dut.error.value == 0, \"Expected error signal not be set after inserting invalid coin after a clock\"\n    await Timer(50, units='ns') \n\n\n@cocotb.test()\nasync def test_vending_machine(dut):\n\n    print(\"start of vending machine\")\n\n    # Start the clock with a 10ns time period (100 MHz clock)\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    # Initialize the DUT signals with default 0\n    await hrs_lb.dut_init(dut)\n\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.rst, duration_ns=25, active=False)\n\n    await RisingEdge(dut.clk) \n\n    await random_purchase(dut)\n\n    await random_cancel_purchase(dut)\n\n    await invalid_item_selection(dut)\n\n    await multiple_purchases_without_reset(dut)\n\n    await random_coin_validation(dut)\n\n    await reset_during_transaction(dut)\n\n    await random_purchase(dut)\n\n    await insert_coins_without_selecting_item(dut)\n\n    await cancel_after_selecting_item(dut)\n\n    await insert_coins_without_item_button(dut)\n\n    await insert_invalid_coin_during_payment_validation(dut)\n"}}}
{"id": "cvdp_copilot_wb2ahb_0005", "categories": ["cid014", "medium"], "input": {"prompt": "Create SystemVerilog Assertions (SVA) to verify the correctness of **Wishbone to AHB bridge transactions**. The properties should ensure that Wishbone transactions are correctly translated into AHB transactions and that the interface remains stable and functional under all conditions. Assertions must be created to verify that the bridge operates as expected across different transfer types, alignment scenarios, and handshake signals.\n\n## **Expected Behavior**\nEach assertion should validate the correctness of data transfer, handshake signals, and address alignment. In case of failure, the error message must include relevant details such as address, data, control signals, and handshake status for debugging purposes.\n\n## **RTL Specification**\nThe **Wishbone to AHB Bridge** module converts Wishbone bus transactions into AHB-compliant transactions. It supports single transfers, address alignment, and optional endianness conversion.\n\n### Inputs\n- **Wishbone Ports (from WB Master):**\n  - `clk_i`: Clock signal for Wishbone operations.\n  - `rst_i`: Active-low reset signal to initialize the bridge.\n  - `cyc_i`: Indicates a valid Wishbone transaction cycle.\n  - `stb_i`: Strobe signal for valid data on the Wishbone interface.\n  - `sel_i[3:0]`: Byte enables to select which bytes are active.\n  - `we_i`: Write enable signal.\n  - `addr_i[31:0]`: Address for the Wishbone transaction.\n  - `data_i[31:0]`: Write data from the Wishbone master.\n- **AHB Ports (from AHB Slave):**\n  - `hclk`: Clock signal for AHB operations.\n  - `hreset_n`: Active-low reset signal for the AHB interface.\n  - `hrdata[31:0]`: Read data from the AHB slave.\n  - `hresp[1:0]`: AHB response signal.\n  - `hready`: Indicates when the AHB slave is ready.\n\n### Outputs\n- **Wishbone Outputs:**\n  - `data_o[31:0]`: Read data back to the Wishbone master.\n  - `ack_o`: Acknowledge signal for Wishbone operations.\n- **AHB Outputs:**\n  - `htrans[1:0]`: AHB transaction type.\n  - `hsize[2:0]`: Size of the AHB transfer.\n  - `hburst[2:0]`: Burst type (always single in this design).\n  - `hwrite`: Write enable signal for AHB transactions.\n  - `haddr[31:0]`: Address for the AHB transaction.\n  - `hwdata[31:0]`: Write data to the AHB slave.\n\n---\n\n## **Assertions to be Verified**\nThe following properties should be verified using **SystemVerilog Assertions**:\n\n1. **Write Operation Verification:**  \n\n  - Ensure that when Wishbone requests a write (`cyc_i && stb_i && we_i`), the AHB `hwrite` signal is correctly asserted.\n\n   \n2. **Address Alignment Verification:**  \n\n  - Check that the translated Wishbone address (`wb_adr_fixed`) is properly aligned and matches the AHB address (`haddr`).\n\n3. **Read Operation Verification:**  \n\n  - Ensure that a valid Wishbone read (`cyc_i && stb_i && !we_i`) results in `data_o` receiving the correct `hrdata`.\n\n4. **Data Phase Verification:**  \n\n  - Ensure that once the AHB transaction enters the **data phase**, the `hready` signal is asserted.\n\n5. **AHB Transfer Type Validation:**  \n\n  - Ensure that when a Wishbone transaction is active, the corresponding AHB `htrans` signal is **not IDLE (`2'b00`)**.\n\n6. **Acknowledgment Verification:**  \n\n  - Ensure that every Wishbone transaction (`cyc_i && stb_i`) results in an acknowledgment (`ack_o`).\n\n7. **AHB Response Validation:**  \n\n  - Ensure that AHB does not return an **error response (`hresp != 2'b01`)**.\n\nEach assertion should include a **failure message** with key debugging information in case of assertion failure.", "context": {"rtl/wishbone_to_ahb_bridge.sv": "`timescale 1ns / 1ps\n\nmodule wishbone_to_ahb_bridge\n  // Wishbone ports from WB master\n (\n  input  clk_i,             // Clock input for Wishbone\n  input  rst_i,             // Reset input for Wishbone\n  input  cyc_i,             // Cycle signal from Wishbone master\n  input  stb_i,             // Strobe signal from Wishbone master\n  input  [3:0] sel_i,       // Byte enable signals from Wishbone master\n  input  we_i,              // Write enable signal from Wishbone master\n  input  [31:0] addr_i,     // Address signal from Wishbone master\n  input  [31:0] data_i,     // Data signal from Wishbone master\n  output reg [31:0] data_o, // Data output to Wishbone master\n  output ack_o,             // Acknowledgment signal to Wishbone master\n\n  // AHB ports to AHB slave\n  input  hclk,              // Clock input for AHB\n  input  hreset_n,          // Reset input for AHB (active low)\n  input  [31:0] hrdata,     // Data input from AHB slave\n  input [1:0] hresp,        // Response signal from AHB slave\n  input hready,             // Ready signal from AHB slave\n  output [1:0] htrans,      // Transfer type signal for AHB\n  output [2:0] hsize,       // Transfer size signal for AHB\n  output [2:0] hburst,      // Burst type signal for AHB (always SINGLE)\n  output hwrite,            // Write signal for AHB\n  output [31:0] haddr,      // Address signal for AHB\n  output reg [31:0] hwdata  // Data output to AHB slave\n);\n\n// Internal signals\nreg ahb_prev_addr_hold;  // Holds the address phase state\nreg ahb_data_phase;      // Indicates data phase\nreg [1:0] trans;         // Transfer type (Idle, Non-sequential, etc.)\nreg [2:0] size;          // Transfer size (Byte, Half-word, Word)\nreg [31:0] addr_hold;    // Holds the address during wait states\nreg [1:0] trans_hold;    // Holds transfer type during wait states\nreg [2:0] size_hold;     // Holds transfer size during wait states\nreg write_hold;          // Holds write signal during wait states\nreg [31:0] wb_adr_fixed; // Fixed Wishbone address after alignment\n\n// Fix up the Wishbone address\n// Aligns the Wishbone address based on byte enables (sel_i)\nalways @(*) begin\n  wb_adr_fixed[31:2] = addr_i[31:2]; \n\n  case (sel_i)\n    4'b0001: wb_adr_fixed[1:0] = 2'b00; \n    4'b0010: wb_adr_fixed[1:0] = 2'b01;\n    4'b0100: wb_adr_fixed[1:0] = 2'b10;\n    4'b1000: wb_adr_fixed[1:0] = 2'b11;\n    4'b0011: wb_adr_fixed[1:0] = 2'b00; \n    4'b1100: wb_adr_fixed[1:0] = 2'b10;\n    4'b1111: wb_adr_fixed[1:0] = 2'b00; \n    default: wb_adr_fixed[1:0] = addr_i[1:0]; \n  endcase\nend\n\nalways @(posedge hclk or negedge hreset_n) begin\n  if (!hreset_n)\n    ahb_prev_addr_hold <= 0;\n  else if (!ahb_data_phase & stb_i & cyc_i & !hready)\n    ahb_prev_addr_hold <= 1; \n  else\n    ahb_prev_addr_hold <= 0; \nend\n\nassign haddr  = ahb_prev_addr_hold ? addr_hold : wb_adr_fixed;\nassign htrans = ahb_prev_addr_hold ? trans_hold : trans;\nassign hsize  = ahb_prev_addr_hold ? size_hold : size;\nassign hwrite = ahb_prev_addr_hold ? write_hold : we_i;\nassign ack_o = ahb_data_phase ? hready : 0; \n\nassign hburst = 3'b000; // Fixed burst type (SINGLE)\n\nalways @(*) begin\n  case (sel_i)\n    4'b0001, 4'b0010, 4'b0100, 4'b1000: begin \n      hwdata = { data_i[7:0], data_i[15:8], data_i[23:16], data_i[31:24] };\n      data_o = { hrdata[7:0], hrdata[15:8], hrdata[23:16], hrdata[31:24] };\n    end\n    4'b0011, 4'b1100: begin \n      hwdata = { data_i[15:0], data_i[31:16] };\n      data_o = { hrdata[15:0], hrdata[31:16] };\n    end\n    default: begin \n      hwdata = data_i;\n      data_o = hrdata;\n    end\n  endcase\nend\n\nalways @(posedge hclk or negedge hreset_n) begin\n  if (!hreset_n)\n    ahb_data_phase <= 0;\n  else if (ahb_data_phase & hready)\n    ahb_data_phase <= 0; \n  else if (!ahb_data_phase & cyc_i & stb_i & hready)\n    ahb_data_phase <= 1; \nend\n\nalways @(posedge hclk or negedge hreset_n) begin\n  if (!hreset_n) begin\n    addr_hold  <= 0;\n    trans_hold <= 0;\n    size_hold  <= 0;\n    write_hold <= 0;\n  end else if (!ahb_prev_addr_hold) begin\n    addr_hold  <= wb_adr_fixed;\n    trans_hold <= trans;\n    size_hold  <= size;\n    write_hold <= we_i;\n  end\nend\n\nalways @(*) begin\n  if (ahb_data_phase)\n    trans = 2'b00; \n  else if (cyc_i) begin\n    if (stb_i)\n      trans = 2'b10; \n    else\n      trans = 2'b01; \n  end else\n    trans = 2'b00; \nend\n\nalways @(*) begin\n  case (sel_i)\n    4'b0001, 4'b0010, 4'b0100, 4'b1000: size = 3'b000; \n    4'b0011, 4'b1100: size = 3'b001; \n    4'b1111: size = 3'b010; \n    default: size = 3'b010; \n  endcase\nend\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/wishbone_to_ahb_bridge.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 80\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/wishbone_to_ahb_bridge.sv\nTOPLEVEL        = wishbone_to_ahb_bridge\nMODULE          = test_wishbone_to_ahb_bridge\nPYTHONPATH      = /src\nHASH            = f6dc856cdfaa180c18ddbd0c84acbf3ee1aaa41b\n", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\nasync def reset_dut(reset_n, duration_ns = 2, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)\n            ", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()", "src/test_wishbone_to_ahb_bridge.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nimport harness_library as hrs_lb\n@cocotb.test()\nasync def test_wishbone_to_ahb_bridge(dut):\n    \"\"\"Testbench for Wishbone-to-AHB Bridge\"\"\"\n\n    # Clock generation\n    cocotb.start_soon(Clock(dut.clk_i, 10, units=\"ns\").start())\n    cocotb.start_soon(Clock(dut.hclk, 10, units=\"ns\").start())\n\n    # Initialize inputs\n    dut.rst_i.value = 1\n    dut.cyc_i.value = 0\n    dut.stb_i.value = 0\n    dut.sel_i.value = 0b1111\n    dut.we_i.value = 0\n    dut.addr_i.value = 0\n    dut.data_i.value = 0\n    dut.hreset_n.value = 0\n    dut.hrdata.value = 0\n    dut.hresp.value = 0b00\n    dut.hready.value = 1\n\n    # Reset pulse\n    await Timer(20, units=\"ns\")\n    dut.rst_i.value = 0\n    dut.hreset_n.value = 1\n    await Timer(20, units=\"ns\")\n    dut.rst_i.value = 1\n\n    # Test 1: Write operation\n    await RisingEdge(dut.clk_i)\n    dut.cyc_i.value = 1\n    dut.stb_i.value = 1\n    dut.we_i.value = 1\n    dut.addr_i.value = 0x10000000\n    dut.data_i.value = 0xDEADBEEF\n\n    await RisingEdge(dut.hclk)\n    dut.hready.value = 0  # Simulate wait state\n    await RisingEdge(dut.hclk)\n    dut.hready.value = 1  # Simulate transfer completion\n\n    # Check AHB outputs for write\n    assert dut.hwrite.value == 1, f\"ERROR: hwrite should be 1, got {dut.hwrite.value}\"\n    assert dut.haddr.value == 0x10000000, f\"ERROR: haddr should be 0x10000000, got {hex(dut.haddr.value)}\"\n    assert dut.hwdata.value == 0xDEADBEEF, f\"ERROR: hwdata should be 0xDEADBEEF, got {hex(dut.hwdata.value)}\"\n    dut._log.info(f\"[CHECK] AHB outputs for write correctly set: dut.hwdata.value = {int(dut.hwdata.value)}, dut.hwrite.value = {int(dut.hwrite.value)}, dut.haddr.value = {int(dut.haddr.value)}\")\n\n    cocotb.log.info(\"PASS: Write operation successful\")\n\n    await RisingEdge(dut.clk_i)\n    dut.stb_i.value = 0\n    dut.cyc_i.value = 0\n\n    # Test 2: Read operation\n    await RisingEdge(dut.clk_i)\n    dut.cyc_i.value = 1\n    dut.stb_i.value = 1\n    dut.we_i.value = 0\n    dut.addr_i.value = 0x20000000\n    dut.hrdata.value = 0xCAFEBABE  # AHB slave data\n\n    await RisingEdge(dut.hclk)\n    dut.hready.value = 0  # Simulate wait state\n    await RisingEdge(dut.hclk)\n    dut.hready.value = 1  # Simulate transfer completion\n\n    # Check Wishbone outputs for read\n    assert dut.data_o.value == 0xCAFEBABE, f\"ERROR: data_o should be 0xCAFEBABE, got {hex(dut.data_o.value)}\"\n    dut._log.info(f\"[CHECK] Wishbone outputs for read correctly set: dut.data_o.value = {int(dut.data_o.value)}\")\n\n    cocotb.log.info(\"PASS: Read operation successful\")\n\n    await RisingEdge(dut.clk_i)\n    dut.stb_i.value = 0\n    dut.cyc_i.value = 0\n\n    cocotb.log.info(\"Test complete\")\n"}}}
{"id": "cvdp_copilot_word_change_detector_0015", "categories": ["cid014", "easy"], "input": {"prompt": "Can you generate SystemVerilog assertions to validate the behavior and specifications of the `Word_Change_Pulse` module based on the design specifications provided? Below are the module details and design requirements for assertion development.\n\n## Interface\n\n**Parameters:**\n- `DATA_WIDTH`: Specifies the bit width of the input data word `data_in`. Default is 8. It must be a positive integer greater than or equal to 1.\n\n**Inputs:**\n- `clk`: Clock signal for synchronizing operations. The design is synchronized to the positive edge of this clock.\n- `reset`:Active-high asynchronous reset signal to initialize the module.\n- `data_in [DATA_WIDTH-1:0]`: Input data word whose changes are to be detected.\n- `mask [DATA_WIDTH-1:0]`: Mask signal to enable/disable change detection per bit (1 = detect changes, 0 = ignore changes)\n- `match_pattern [DATA_WIDTH-1:0]`: Pattern to compare against the (masked) input data word.\n- `enable (1-bit)`: Active-high signal, which enables the module\u2019s operation.\n- `latch_pattern (1-bit) `: When high, latches the current match_pattern into an internal register.\n\n**Outputs:**\n- `word_change_pulse (1-bit)`: Output signal that pulses high one clock cycle after any bit in data_in changes.\n- `pattern_match_pulse (1-bit)`: Pulses high to indicate the masked input data word matches the latched pattern.\n- `latched_pattern [DATA_WIDTH-1:0]`: Register that holds the latched pattern for comparison\n\n# Design Specifications\n\nThe `Word_Change_Pulse` module monitors each bit of the input data word by using multiple Bit_Change_Detector instances, one for each bit. Each Bit_Change_Detector watches for changes in its respective bit and signals when a change occurs. The module applies a mask to determine which bits should be actively monitored for changes. When any of the masked bits change, the word_change_pulse is triggered to indicate that a change has been detected. Additionally, the module can latch a specific pattern when the latch_pattern signal is high, and it continuously compares the masked input data against this latched pattern. If the masked input matches the latched pattern, a pattern_match_pulse is generated. The entire operation is controlled by an enable signal, allowing the monitoring functionality to be turned on or off as needed. The module also includes a reset mechanism to initialize or clear all internal states and outputs.\n\n# Assertion Requirements\n\nDevelop a set of SystemVerilog assertions to validate the following behaviors:\n\n## 1. Word Change Pulse Assertion\n- Ensures that `word_change_pulse` is triggered whenever there is a change in the `data_in` signal while the module is active.\n- The change detection is applied only to the bits that are enabled by the mask.\n- When a valid bit transition occurs, the assertion checks whether the `word_change_pulse` is generated within one clock cycle.\n\n## 2. Pattern Match Assertion\n- `pattern_match_pulse` is correctly generated when the `data_in` signal matches the latched pattern, considering only the bits enabled by the mask.\n- The assertion ensures that when the masked `data_in` equals the masked `latched_pattern`, the `pattern_match_pulse` is asserted within one clock cycle.\n\n## 3. No Pulse When Disabled\n- Ensures that no pulses are generated when the module is disabled.\n- It checks that both `word_change_pulse` and `pattern_match_pulse` remain de-asserted when the module is not active.\n\nCan you add SystemVerilog assertions to this RTL design to validate all specified behaviors? Please ensure assertions provide clear error messages for simulation failures and follow industry best practices for concise and effective verification.", "context": {"rtl/Word_Change_Pulse.sv": "// Word_Change_Pulse Module with Maskable Input, Pattern Matching, and Advanced Features\nmodule Word_Change_Pulse #(\n    parameter DATA_WIDTH = 8 // Default word width\n) (\n    input  wire                  clk,               // Clock signal for synchronizing operations\n    input  wire                  reset,             // Reset signal to initialize the module\n    input  wire [DATA_WIDTH-1:0] data_in,           // Input data, width defined by parameter DATA_WIDTH\n    input  wire [DATA_WIDTH-1:0] mask,              // Mask signal to enable/disable change detection for each bit\n    input  wire [DATA_WIDTH-1:0] match_pattern,     // Pattern to match for generating the pulse\n    input  wire                  enable,            // Enable signal to allow module operation\n    input  wire                  latch_pattern,     // Signal to latch the match pattern\n    output reg                   word_change_pulse, // Output signal indicating a change in any bit of data_in\n    output reg                   pattern_match_pulse, // Output signal indicating a match with the pattern\n    output reg [DATA_WIDTH-1:0]  latched_pattern    // Latched pattern for comparison\n);\n\n    wire [DATA_WIDTH-1:0] change_pulses;\n\n    reg [DATA_WIDTH-1:0] masked_data_in;\n    reg [DATA_WIDTH-1:0] masked_change_pulses;\n    reg                  match_detected;\n\n    genvar i;\n    generate\n        for (i = 0; i < DATA_WIDTH; i = i + 1) begin : change_detectors\n            Bit_Change_Detector u_single_bit_change_detector (\n                .clk          (clk),\n                .reset        (reset),\n                .bit_in       (data_in[i]),\n                .change_pulse (change_pulses[i])\n            );\n        end\n    endgenerate\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            masked_data_in <= {DATA_WIDTH{1'b0}};\n            masked_change_pulses <= {DATA_WIDTH{1'b0}};\n            word_change_pulse <= 1'b0;\n            match_detected <= 1'b0;\n            pattern_match_pulse <= 1'b0;\n            latched_pattern <= {DATA_WIDTH{1'b0}};\n        end else if (enable) begin\n            if (latch_pattern) begin\n                latched_pattern <= match_pattern;\n            end\n            if (match_detected) begin\n            pattern_match_pulse <= 1'b1;\n            end else begin \n            pattern_match_pulse <= 1'b0;\n            end\n            masked_data_in <= data_in & mask;\n            masked_change_pulses <= change_pulses & mask;\n            word_change_pulse <= |masked_change_pulses;\n            match_detected <= (masked_data_in == (latched_pattern & mask));\n        end else begin\n            masked_data_in <= {DATA_WIDTH{1'b0}};\n            masked_change_pulses <= {DATA_WIDTH{1'b0}};\n            word_change_pulse <= 1'b0;\n            match_detected <= 1'b0;\n            pattern_match_pulse <= 1'b0;\n            latched_pattern <= {DATA_WIDTH{1'b0}};\n        end\n    end\n\nendmodule\n\n// Bit_Change_Detector Module\nmodule Bit_Change_Detector (\n    input  wire clk,         // Clock signal\n    input  wire reset,       // Reset signal to initialize the module\n    input  wire bit_in,      // Single bit input to detect changes\n    output reg  change_pulse // Pulse signal indicating a change in the input bit\n);\n\n    reg bit_in_d;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            bit_in_d <= 1'b0;\n            change_pulse <= 1'b0;\n        end else begin\n            bit_in_d <= bit_in; \n        end\n    end\n\n    always @(*) begin\n        change_pulse = (bit_in != bit_in_d); \n    end\nendmodule"}}, "output": {"response": "", "context": {"rtl/Word_Change_Pulse.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "INST            = uut\nTARGET          = 100\nSIM             = xcelium\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/Word_Change_Pulse.sv\nTOPLEVEL        = Word_Change_Pulse\nMODULE          = test_Word_Change_Pulse\nPYTHONPATH      = /src\nRANDOM_SEED     = 1739797288\nHASH            = f2b3692399d6fb9d67877f517bea10249f8bac99", "src/harness_library.py": "from cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset_n, duration_ns = 25, active:bool = False):\n    # Restart Interface\n    reset_n.value = 0 if active else 1\n    await Timer(duration_ns, units=\"ns\")\n    reset_n.value = 1 if active else 0\n    await Timer(duration_ns, units='ns')\n    reset_n._log.debug(\"Reset complete\")\n\nasync def duty_cycle(pwm_signal, clock, period):\n    # 0-> time_period, 1-> high_time, 2-> low_time = full_time = high_time\n    pwm = {\"time_period\": period, \"on_time\": 0, \"off_time\": 0}\n    pwm_signal._log.debug(\"Pulse started\")\n    for i in range(period):\n        if pwm_signal.value == 1:\n            pwm[\"on_time\"] += 1\n        await RisingEdge(clock)\n\n    pwm[\"off_time\"] = pwm[\"time_period\"] - pwm[\"on_time\"]\n    pwm_signal._log.debug(\"Time period completed\")\n    return pwm\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n# all the element of array dump in to one verable\ndef ary_2_int(arry: list) -> int:\n    if arry is not None:\n        ary = arry.copy()\n        ary.reverse()\n        ary_byt = int(''.join(format(num, '08b') for num in ary), 2)\n        return ary_byt\n    else:\n        raise ValueError\n    \nasync def rnd_clk_dly (clock, low: int = 50, high: int = 100):\n    for i in range(random.randint(50,100)):\n            await RisingEdge(clock)", "src/test_Word_Change_Pulse.py": "import cocotb \nfrom cocotb.clock import Clock\nfrom cocotb.triggers import RisingEdge, FallingEdge, Timer\nimport random\n\nimport harness_library as hrs_lb\n\n@cocotb.test()\nasync def test_Word_Change_Pulse(dut):\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n\n    cocotb.start_soon(Clock(dut.clk, 10, units='ns').start())\n\n    await hrs_lb.dut_init(dut)\n    await RisingEdge(dut.clk)\n    # Reset the DUT rst_n signal\n    await hrs_lb.reset_dut(dut.reset, duration_ns=25, active=False)\n    await RisingEdge(dut.clk)\n    # Reset all inputs\n    dut.data_in.value = 0\n    dut.mask.value = (1 << DATA_WIDTH) - 1\n    dut.match_pattern.value = 0\n    dut.enable.value = 1\n    dut.latch_pattern.value = 0\n\n    for _ in range(2):\n        await RisingEdge(dut.clk)    \n\n    # Generate an initial rising edge for synchronization\n    await RisingEdge(dut.clk)\n\n    # Ensure word_change_pulse starts low\n    assert dut.word_change_pulse.value == 0, \"Initial word_change_pulse is not 0\"\n\n    # Run tests\n    await random_changes_test(dut, DATA_WIDTH, num_tests=10)\n    await RisingEdge(dut.clk)\n    await test_no_change(dut, DATA_WIDTH)\n    await RisingEdge(dut.clk)\n    await test_single_bit_change(dut, DATA_WIDTH)\n    await RisingEdge(dut.clk)\n    await test_multiple_bits_change(dut, DATA_WIDTH)\n    await RisingEdge(dut.clk)\n    await test_back_to_back_changes(dut, DATA_WIDTH)\n    await RisingEdge(dut.clk)\n    await test_pattern_matching(dut, DATA_WIDTH)\n    await RisingEdge(dut.clk)\n    await test_enable_functionality(dut, DATA_WIDTH)\n    await RisingEdge(dut.clk)\n\n\n    # Log success\n    dut._log.info(\"All tests passed!\")\n\n\nasync def test_pattern_matching(dut, data_width):\n    \"\"\"Test pattern matching functionality with random mask and data_in.\"\"\"\n    # Reset the DUT\n    dut.reset.value = 1\n    await RisingEdge(dut.clk)\n    dut.reset.value = 0    \n\n    # Set a random match pattern and latch it\n    match_pattern = random.randint(0, (1 << data_width) - 1)\n    dut.match_pattern.value = match_pattern\n    dut.latch_pattern.value = 1\n    await RisingEdge(dut.clk)  # Latch the pattern\n    latched_pattern = int(dut.latched_pattern.value)\n    await RisingEdge(dut.clk)\n    # Track previous match status\n    previous_match = 0\n\n    \n\nasync def test_mask_functionality(dut, data_width):\n    \"\"\"Test masking functionality for change detection and pattern matching.\"\"\"\n     # Reset the DUT\n    dut.reset.value = 1\n    await RisingEdge(dut.clk)\n    dut.reset.value = 0  \n    mask = random.randint(0, (1 << data_width) - 1)\n    dut.mask.value = mask\n\n    prev_data = 0\n    used_data = set()\n\n    for _ in range(5):\n        while True:\n            random_data = random.randint(0, (1 << data_width) - 1)\n            if random_data not in used_data:\n                break\n        used_data.add(random_data)\n        dut.data_in.value = random_data\n\n        masked_data = random_data & int(dut.mask.value)\n        previous_masked_data = prev_data & int(dut.mask.value)\n        change_detected = masked_data != previous_masked_data\n        await RisingEdge(dut.clk)\n        await RisingEdge(dut.clk)\n        await FallingEdge(dut.clk)\n        assert int(dut.word_change_pulse.value) == change_detected, (\n            f\"word_change_pulse incorrect for masked data_in {masked_data:#0{data_width+2}b}.\"\n        )\n\n        prev_data = random_data\n\n\n\nasync def test_enable_functionality(dut, data_width):\n    \"\"\"Test enable signal functionality.\"\"\"\n     # Reset the DUT\n    dut.reset.value = 1\n    await RisingEdge(dut.clk)\n    dut.reset.value = 0  \n    dut.enable.value = 0\n\n    for _ in range(5):\n        random_data = random.randint(0, (1 << data_width) - 1)\n        dut.data_in.value = random_data\n        await RisingEdge(dut.clk)\n        await FallingEdge(dut.clk)\n        assert dut.word_change_pulse.value == 0, (\n            \"word_change_pulse should remain low when enable is deasserted.\"\n        )\n        assert dut.pattern_match_pulse.value == 0, (\n            \"pattern_match_pulse should remain low when enable is deasserted.\"\n        )\n\n\nasync def random_changes_test(dut, data_width, num_tests=10):\n    prev_data = 0\n    for _ in range(num_tests):\n        random_data = random.randint(0, (1 << data_width) - 1)\n        dut.data_in.value = random_data\n        await RisingEdge(dut.clk)  \n\n        expected_pulse = 1 if random_data != prev_data else 0\n        await RisingEdge(dut.clk)\n        await FallingEdge(dut.clk)\n        assert dut.word_change_pulse.value == expected_pulse, (\n            f\"word_change_pulse incorrect for data_in change from {prev_data:#0{data_width+2}b} \"\n            f\"to {random_data:#0{data_width+2}b}, expected {expected_pulse}.\"\n        )\n\n        prev_data = random_data\n        await RisingEdge(dut.clk)\n\n\nasync def test_no_change(dut, data_width):\n    random_value = random.randint(0, (1 << data_width) - 1)\n    dut.data_in.value = random_value\n    for _ in range(2):\n        await RisingEdge(dut.clk)  \n\n    for _ in range(5):\n        dut.data_in.value = random_value\n        await RisingEdge(dut.clk)  \n        await FallingEdge(dut.clk)\n        assert dut.word_change_pulse.value == 0, (\n            \"word_change_pulse should remain low when data_in does not change\"\n        )\n\n\nasync def test_single_bit_change(dut, data_width):\n    initial_value = random.randint(0, (1 << data_width) - 1)\n    dut.data_in.value = initial_value\n    await RisingEdge(dut.clk)\n\n    for i in range(data_width):\n        new_value = initial_value ^ (1 << i)\n        dut.data_in.value = new_value\n        expected_pulse = 1 if initial_value != new_value else 0\n        await RisingEdge(dut.clk)  \n        await RisingEdge(dut.clk)\n        await FallingEdge(dut.clk)\n        assert dut.word_change_pulse.value == expected_pulse, (\n            f\"word_change_pulse should be {expected_pulse} when bit {i} changes from {initial_value:#0{data_width+2}b} \"\n            f\"to {new_value:#0{data_width+2}b}.\"\n        )\n        initial_value = new_value\n        await RisingEdge(dut.clk)\n\n\nasync def test_multiple_bits_change(dut, data_width):\n    initial_value = random.randint(0, (1 << data_width) - 1)\n    dut.data_in.value = initial_value\n    await RisingEdge(dut.clk)\n\n    for _ in range(5):\n        new_value = random.randint(0, (1 << data_width) - 1)\n        dut.data_in.value = new_value\n        bitwise_change_detected = initial_value != new_value\n        expected_pulse = 1 if bitwise_change_detected else 0\n        await RisingEdge(dut.clk)  \n        await RisingEdge(dut.clk)\n        await FallingEdge(dut.clk)\n        assert dut.word_change_pulse.value == expected_pulse, (\n            f\"word_change_pulse incorrect for data_in change from {initial_value:#0{data_width+2}b} \"\n            f\"to {new_value:#0{data_width+2}b}, expected {expected_pulse}.\"\n        )\n        initial_value = new_value\n        await RisingEdge(dut.clk) \n\n\nasync def test_back_to_back_changes(dut, data_width):\n    num_iterations = 10\n\n    prev_value = random.randint(0, (1 << data_width) - 1)\n    dut.data_in.value = prev_value\n    await RisingEdge(dut.clk)\n\n    for _ in range(num_iterations):\n        while True:\n            new_value = random.randint(0, (1 << data_width) - 1)\n            if new_value != prev_value:\n                break\n\n        dut.data_in.value = new_value\n        await RisingEdge(dut.clk)\n\n        value1 = prev_value\n        prev_value = new_value\n        await RisingEdge(dut.clk)\n        await FallingEdge(dut.clk)\n\n        expected_pulse = 1 if value1 != prev_value else 0\n        word_change_pulse_val = dut.word_change_pulse.value\n\n        assert word_change_pulse_val == expected_pulse, (\n            f\"word_change_pulse incorrect for change from {value1:#0{data_width+2}b} \"\n            f\"to {prev_value:#0{data_width+2}b}, expected {expected_pulse}.\"\n        )\n\n    dut._log.info(\"All assertions passed successfully for data width {data_width}.\")\n", "src/test_runner.py": "import os\nimport re\nfrom cocotb.runner import get_runner\nimport pytest\nimport subprocess\n\n# Fetch environment variables for Verilog source setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = os.getenv(\"WAVE\")\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    runner = get_runner(sim)\n\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        build_args=(\"-coverage\", \"all\", \"-covoverwrite\", \"-covtest\", \"test\"),\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\"\n    )\n    runner.test(hdl_toplevel=toplevel, test_module=module,waves=True)\n\n# # ----------------------------------------\n# # - Generate Coverage\n# # ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics toggle -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics overall -all -aspect sim -assertionStatus -text -out coverage.log\\\"\"\n    # cmd = \"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics assertion -all -aspect sim -assertionStatus -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\nif __name__ == \"__main__\":\n    test_simulate()"}}}
{"id": "cvdp_copilot_write_buffer_merge_0014", "categories": ["cid014", "easy"], "input": {"prompt": "Add **SystemVerilog Assertions (SVA)** to validate the behavior of the `write_buffer_merge` module. The assertions should ensure that the module correctly handles write operations, maintains address stability, and asserts output signals appropriately.  \n\n## **RTL Design Overview**  \nThe `write_buffer_merge` module is responsible for **buffering and merging write operations** before sending them to memory. It collects multiple small write transactions and outputs a larger, merged write. \n\n### **Key Components of the Module**  \n- **`write_count`**: Tracks the number of write operations stored in the buffer.  \n- **`base_addr`**: Stores the starting address for the merged transaction.  \n- **`merged_data`**: Holds the accumulated write data before output.  \n- **`write_complete`**: Signals when the buffer is full and ready to send data.  \n- **`wr_en_out`**: Indicates that a merged write is available.  \n- **`wr_en_in`**: Indicates that valid input data is available.  \n- **`wr_addr_in` & `wr_data_in`**: Input address and data for the merged write.  \n- **`wr_addr_out` & `wr_data_out`**: Output address and data for the merged write.  \n\n## **Assertion Details**  \nThe assertions should verify the following conditions:  \n- **Write Counter Bounds:** `write_count` should **never exceed** `BUFFER_DEPTH - 1`.  \n- **Base Address Stability:** `base_addr` should **only update** when `write_count == 0` and `wr_en_in == 1`.  \n- **Write Completion Signal:** `write_complete` should **assert correctly** when `write_count == BUFFER_DEPTH - 1` and `wr_en_in` is active.  \n- **Write Enable Output Behavior:** `wr_en_out` should **assert only when** `write_complete` is asserted.  \n\n## **Expected Behavior**  \nIf any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.\n", "context": {"rtl/write_buffer_merge.sv": "module write_buffer_merge #(\n  parameter INPUT_DATA_WIDTH  = 32,                                     // Width of input data\n  parameter INPUT_ADDR_WIDTH  = 16,                                     // Width of input address\n  parameter BUFFER_DEPTH      = 8,                                      // Depth of the write buffer\n  parameter OUTPUT_DATA_WIDTH = INPUT_DATA_WIDTH * BUFFER_DEPTH,        // Width of merged output data\n  parameter OUTPUT_ADDR_WIDTH = INPUT_ADDR_WIDTH - $clog2(BUFFER_DEPTH) // Width of merged output address\n) (\n  input  logic                         clk,          // Clock signal. Design is synchronized to posedge of this.\n  input  logic                         srst,         // Synchronous reset (active high)\n  input  logic                         wr_en_in,     // Active high Write enable input\n  input  logic [INPUT_ADDR_WIDTH-1:0]  wr_addr_in,   // Write address input\n  input  logic [INPUT_DATA_WIDTH-1:0]  wr_data_in,   // Write data input\n  output logic                         wr_en_out,    // Active high Write enable output\n  output logic [OUTPUT_ADDR_WIDTH-1:0] wr_addr_out,  // Write address output\n  output logic [OUTPUT_DATA_WIDTH-1:0] wr_data_out   // Write data output\n);\n\n  logic [$clog2(BUFFER_DEPTH)-1:0]      write_count;\n  logic [OUTPUT_ADDR_WIDTH-1:0]         base_addr;\n  logic [OUTPUT_DATA_WIDTH-1:0]         merged_data;\n  logic                                 write_complete;\n\n  always_ff @(posedge clk) begin\n    if (srst) \n      write_count <= '0;\n    else if (wr_en_in)\n      write_count <= write_count + 1;\n  end\n\n  always_ff @(posedge clk) begin\n    if (srst)\n      base_addr <= '0;\n    else if ((write_count == 0) && wr_en_in)\n      base_addr <= wr_addr_in[INPUT_ADDR_WIDTH-1:$clog2(BUFFER_DEPTH)];\n  end\n\n  always_ff @(posedge clk) begin\n    if (srst)\n      merged_data <= '0;\n    else if (wr_en_in)\n      merged_data <= {wr_data_in, merged_data[OUTPUT_DATA_WIDTH-1:INPUT_DATA_WIDTH]};\n  end\n\n  always_ff @(posedge clk) begin\n    if (srst)\n      write_complete <= 1'b0;\n    else if ((write_count == (BUFFER_DEPTH - 1)) && wr_en_in)\n      write_complete <= 1'b1;\n    else\n      write_complete <= 1'b0;\n  end\n\n  always_ff @(posedge clk) begin\n    if (srst)\n      wr_en_out <= 1'b0;\n    else\n      wr_en_out <= write_complete;\n  end\n\n  always_ff @(posedge clk) begin\n    if (srst)\n      wr_addr_out <= '0;\n    else if (write_complete)\n      wr_addr_out <= base_addr;\n  end\n\n  always_ff @(posedge clk) begin\n    if (srst)\n      wr_data_out <= '0;\n    else if (write_complete)\n      wr_data_out <= merged_data;\n  end\n\nendmodule"}}, "output": {"response": "", "context": {"rtl/write_buffer_merge.sv": ""}}, "harness": {"files": {"Dockerfile": "FROM __VERIF_EDA_IMAGE__\n\nRUN pip3 install cocotb ", "docker-compose.yml": "services:\n\n  xrun:\n    build: .\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/test_runner.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "INST            = dut\nTARGET          = 100\nSIM             = xcelium\nWAVE            = True\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/write_buffer_merge.sv\nTOPLEVEL        = write_buffer_merge\nMODULE          = test_write_buffer_merge\nPYTHONPATH      = /src\nHASH            = 14-rtl-assertion-generation-for-write-buffer-merge", "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nfrom cocotb.runner import get_runner\nimport random\nimport struct\nimport os\nimport subprocess\nimport re\n\ndef runner(module, toplevel, src:list, plusargs:list =[], args:tuple = (), parameter:dict={},\n           wave:bool = False, sim:str = \"icarus\"):\n    runner = get_runner(sim)\n    runner.build(\n        sources=src,\n        hdl_toplevel=toplevel,\n        # Arguments\n        parameters=parameter,\n        # compiler args\n        build_args=args,\n        always=True,\n        clean=True,\n        waves=wave,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"build.log\")\n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs, log_file=\"sim.log\")\n\ndef coverage_report(asrt_type:str):\n    '''asrt_type: assertion, toggle, overall'''\n    cmd = f\"imc -load /code/rundir/sim_build/cov_work/scope/test -execcmd \\\"report -metrics {asrt_type} -all -aspect sim -assertionStatus -overwrite -text -out coverage.log\\\"\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\ndef covt_report_check():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n\n    print(\"Metrics:\")\n    print(metrics)\n\n    if \"Overall Average\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Overall Average\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Assertion\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Assertion\"]) >= 100.00, \"Didn't achieved the required coverage result.\"\n    elif \"Toggle\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Toggle\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    elif \"Block\" in metrics[os.getenv(\"TOPLEVEL\")]:\n        assert float(metrics[os.getenv(\"TOPLEVEL\")][\"Block\"]) >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    else:\n        assert False, \"Couldn't find the required coverage result.\"\n\ndef save_vcd(wave:bool, toplevel:str, new_name:str):\n    if wave:\n        os.makedirs(\"vcd\", exist_ok=True)\n        os.rename(f'./sim_build/{toplevel}.fst', f'./vcd/{new_name}.fst')\n\nasync def reset(dut):\n    await FallingEdge(dut.clock)\n    dut.reset.value = 1\n\n    await FallingEdge(dut.clock)\n    dut.reset.value = 0\n    print(\"[DEBUG] Reset complete\")\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n", "src/test_runner.py": "import os\nimport harness_library as hrs_lb\nimport random\nimport pytest\nimport math\n\n# Environment configuration\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n\ndef call_runner(INPUT_DATA_WIDTH: int=32, INPUT_ADDR_WIDTH: int=16, BUFFER_DEPTH: int=8):\n    parameters = {\n        \"INPUT_DATA_WIDTH\": INPUT_DATA_WIDTH,\n        \"INPUT_ADDR_WIDTH\": INPUT_ADDR_WIDTH,\n        \"BUFFER_DEPTH\": BUFFER_DEPTH,\n    }\n    plusargs = []\n    try:\n        args = []\n        if sim == \"xcelium\":\n            args = (\"-coverage all\", \" -covoverwrite\", \"-sv\", \"-covtest test\", \"-svseed random\")\n\n        hrs_lb.runner(\n            wave=wave,\n            toplevel=toplevel,\n            plusargs=plusargs,\n            module=module,\n            src=verilog_sources,\n            sim=sim,\n            args=args,\n            parameter=parameters\n        )\n        hrs_lb.coverage_report(\"assertion\")\n        hrs_lb.covt_report_check()\n    except SystemExit:\n        # hrs_lb.save_vcd(wave, toplevel, new_name=f\"waveform_test\")\n        raise SystemError(\"simulation failed due to assertion failed in your test\")\n\n# ---------------------------------------------------------------------------\n# Random Parameterized Write Buffer Merge Tests\n# ---------------------------------------------------------------------------\n# Generate random parameters for the write_buffer_merge testbench and run the test multiple times.\n@pytest.mark.parametrize(\"random_test\", range(3))\ndef test_random_write_buffer_merge(random_test):\n  # Generate random parameters\n  INPUT_DATA_WIDTH = random.randint(8, 32)  # Random input data width (8 to 32 bits)\n  INPUT_ADDR_WIDTH = random.randint(8, 32)  # Random input address width (8 to 32 bits)\n  BUFFER_DEPTH = 2**(math.ceil(math.log2(random.randint(2, 8))))\n\n  # Run the test with the generated parameters\n  call_runner(INPUT_DATA_WIDTH=INPUT_DATA_WIDTH, INPUT_ADDR_WIDTH=INPUT_ADDR_WIDTH, BUFFER_DEPTH=BUFFER_DEPTH)\n", "src/test_write_buffer_merge.py": "import cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport random\nimport harness_library as hrs_lb\nimport math\n\n# ----------------------------------------\n# - Write Buffer Merge Test\n# ----------------------------------------\n\nasync def reset_dut(dut, duration_ns=10):\n  \"\"\"\n    Reset the DUT by setting the synchronous reset signal high for a specified duration\n    and then setting it low again.\n\n    During reset, ensure that the DUT's outputs are zero.\n\n    Args:\n        dut: The Design Under Test (DUT).\n        duration_ns: The time duration in nanoseconds for which the reset signal will be held high.\n    \"\"\"\n  dut.srst.value = 1  # Set reset to active high\n  await Timer(duration_ns, units=\"ns\")  # Wait for the specified duration\n\n  # Ensure all outputs are zero\n  assert dut.wr_en_out.value == 0, f\"[ERROR] wr_en_out is not zero after reset: {dut.wr_en_out.value}\"\n  assert dut.wr_addr_out.value == 0, f\"[ERROR] wr_addr_out is not zero after reset: {dut.wr_addr_out.value}\"\n  assert dut.wr_data_out.value == 0, f\"[ERROR] wr_data_out is not zero after reset: {dut.wr_data_out.value}\"\n\n  dut.srst.value = 0  # Deactivate reset (set it low)\n  await Timer(duration_ns, units='ns')  # Wait for the reset to stabilize\n  dut.srst._log.debug(\"Reset complete\")\n\n\n@cocotb.test()\nasync def verify_write_buffer_merge(dut):\n  \"\"\"\n  Verify the write buffer merge functionality.\n  This test checks for the following:\n  - Proper buffering and merging of input data.\n  - Correct output address and data generation.\n  - Proper signaling of `wr_en_out` when the buffer is full.\n  - Handling of resets.\n\n  The test dynamically generates random inputs, tracks expected outputs, \n  and verifies the DUT outputs against expected results.\n  \"\"\"\n\n  # Start the clock with a 2ns period\n  cocotb.start_soon(Clock(dut.clk, 2, units='ns').start())\n\n  # Initialize DUT inputs\n  await hrs_lb.dut_init(dut)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for a few cycles to stabilize\n  for k in range(10):\n    await RisingEdge(dut.clk)\n\n  # Retrieve parameters from the DUT\n  input_data_width = int(dut.INPUT_DATA_WIDTH.value)\n  input_addr_width = int(dut.INPUT_ADDR_WIDTH.value)\n  buffer_depth = int(dut.BUFFER_DEPTH.value)\n  output_data_width = int(dut.OUTPUT_DATA_WIDTH.value)\n  output_addr_width = int(dut.OUTPUT_ADDR_WIDTH.value)\n\n  # Number of outputs and inputs based on buffer depth\n  num_outputs = random.randint(1, 16) \n  num_inputs = num_outputs*buffer_depth\n  continuous_input = random.randint(0, 1)\n\n\n  # Print paramerters for debugging\n  print(f\"INPUT_DATA_WIDTH: {input_data_width}\")\n  print(f\"INPUT_ADDR_WIDTH: {input_addr_width}\")\n  print(f\"BUFFER_DEPTH: {buffer_depth}\")\n  print(f\"NUM_OUTPUTS: {num_outputs}\")\n  \n  # Initialize variables for tracking inputs and outputs\n  i = 0\n  data_in_queue = []\n  addr_in_queue = []\n\n  data_out_queue = []\n  addr_out_queue = []\n  num_outputs_from_dut = 0\n\n  prev_wr_data_out = 0\n  prev_wr_addr_out = 0\n  out_latency = 0\n\n  # Dynamically generate and apply inputs\n  while i < num_inputs:\n    # Generate random inputs\n    if continuous_input == 1:\n      wr_en_in = 1\n    else:\n      wr_en_in = random.randint(0, 1)\n    wr_data_in = random.randint(0, (1<<input_data_width)-1)\n    if (wr_en_in == 1):\n      if ((i%buffer_depth) == 0):\n        # Generate aligned addresses based on buffer depth\n        wr_addr_in = buffer_depth*((random.randint(0, ((1<<input_addr_width)-1)))//buffer_depth)\n      else:\n        wr_addr_in = wr_addr_in + 1\n\n      # Assign the values to DUT inputs\n      dut.wr_en_in.value = wr_en_in\n      dut.wr_data_in.value = wr_data_in\n      dut.wr_addr_in.value = wr_addr_in\n\n      # Store the input for later verification\n      i+=1\n      data_in_queue.append(wr_data_in)\n      if ((i%buffer_depth) == 0):\n        addr_in_queue.append(wr_addr_in)\n\n    await RisingEdge(dut.clk)\n\n    # Capture DUT outputs\n    wr_en_out = int(dut.wr_en_out.value)\n    wr_data_out = int(dut.wr_data_out.value)\n    wr_addr_out = int(dut.wr_addr_out.value)\n    if (wr_en_out == 1):\n      data_out_queue.append(wr_data_out)\n      addr_out_queue.append(wr_addr_out)\n      num_outputs_from_dut+=1\n    else:\n      assert wr_addr_out == prev_wr_addr_out, f\"[ERROR] Output Address Changed when Write Enable Out is Low Prev={prev_wr_addr_out}, Current={wr_addr_out}\"\n      assert wr_data_out == prev_wr_data_out, f\"[ERROR] Output Data Changed when Write Enable Out is Low Prev={prev_wr_data_out}, Current={wr_data_out}\"\n\n    prev_wr_data_out = wr_data_out\n    prev_wr_addr_out = wr_addr_out\n\n    if (wr_en_out == 1):\n      if (buffer_depth == 1):\n        assert out_latency == 1, f\"[ERROR] Output Latency Mismatch Expected=1, Current={out_latency}\"\n      else:\n        assert out_latency == 2, f\"[ERROR] Output Latency Mismatch Expected=2, Current={out_latency}\"\n      out_latency = 0\n\n    if (wr_en_in & (((i-1)%buffer_depth) == (buffer_depth-1))):\n      out_latency = 1\n    elif (out_latency >= 1):\n      out_latency += 1\n\n    # Set wr_en_in low\n    dut.wr_en_in.value = 0\n\n  print(f\"All inputs have been generated!\")\n\n  await RisingEdge(dut.clk)\n  # Wait for remaining outputs from the DUT\n  while num_outputs_from_dut < num_outputs:\n    wr_en_out = int(dut.wr_en_out.value)\n    wr_data_out = int(dut.wr_data_out.value)\n    wr_addr_out = int(dut.wr_addr_out.value)\n    if (wr_en_out == 1):\n      data_out_queue.append(wr_data_out)\n      addr_out_queue.append(wr_addr_out)\n      num_outputs_from_dut+=1\n    await RisingEdge(dut.clk)\n\n  print(f\"All outputs have been received!\")\n\n  # Verify outputs against expected values\n  for i in range(num_outputs):\n    expected_data = 0\n    expected_addr = addr_in_queue.pop(0) >> math.ceil(math.log2(buffer_depth));\n    for j in range(buffer_depth):\n      expected_data |= (data_in_queue.pop(0) << (j * input_data_width))\n\n    rtl_addr = addr_out_queue.pop(0)\n    rtl_data = data_out_queue.pop(0)\n\n\n    # Verify address output\n    assert rtl_addr == expected_addr, f\"[ERROR] Output {i+1}: Address mismatch! Expected={expected_addr}, Got={rtl_addr}\"\n\n    # Verify data output\n    assert rtl_data == expected_data, f\"[ERROR] Output {i+1}: Data mismatch! Expected={expected_data}, Got={rtl_data}\"\n\n    print(f\"Output {i+1} Matched\")\n\n  # Wait for 2 cycles\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n  # Apply reset to DUT\n  await reset_dut(dut)\n\n  # Wait for 2 cycles\n  for k in range(2):\n    await RisingEdge(dut.clk)\n\n"}}}
