{"id": "cvdp_copilot_32_bit_Brent_Kung_PP_adder_0004", "categories": ["cid012", "medium"], "input": {"prompt": "Complete the given partial System Verilog testbench `tb_brent_kung_adder`. The testbench must instantiate the `brent_kung_adder` RTL module and provide input stimulus for it focusing exclusively on generating comprehensive test vectors rather than building a full testbench. A Brent Kung Adder is a parallel prefix adder engineered for efficiently computing the sum of two 32-bit inputs along with a carry input.\n\n## Description :\n### Inputs :\nRegisters :\n- `sum (32-bit,[31:0])`  - 32-bit sum received from the UUT\n- `carry_out(1-bit)` - 1-bit output carry received from the UUT.\n\n### Outputs :\nRegisters :\n- `a (32-bit,[31:0])` - 32-bit augend generated by TB to UUT.\n- `b(32-bit,[31:0])`  - 32-bit addend generated by TB to UUT.\n- `carry_in(1-bit)`    - 1-bit input carry generated by TB to UUT.\n\n## Instantiation :\nThe testbench instantiates the `brent_kung_adder` module as uut and connects the signals between the module and the testbench. Each input and output from the UUT is connected to its corresponding signal in the testbench.\n\n## Input Generation and Validation:\n- Stimulus: Several test cases are applied to simulate various operations of the brent kung adder. These test cases cover a range of scenarios such as adding with smallest non-zero numbers, adding with largest numbers, random addends and augends, etc. For each case, the relevant signals (`sum`, `carry_out`) are followed immediately after the application of inputs (`a`,`b`,`carry_in`).\n\n**Test Case 1: Zero inputs** :\n   - Description: Test the adder with all inputs set to zero, expecting no sum or carry-out.\n\n**Test Case 2: Large positive numbers with no carry** :\n   - Description: Adds two large positive numbers (`0x7FFFFFFF`) with no carry-in, testing for proper addition without overflow.\n \n**Test Case 3: Adding two large negative numbers, carry-out expected** :\n   - Description: Adds two large negative numbers (`0x80000000`), expecting a carry-out as the sum wraps around.\n   \n**Test Case 4: Numbers with different magnitudes**:\n   - Description: Tests the adder with numbers of different magnitudes (0x0000FFFF and 0xFFFF0000) to verify correct handling of mixed inputs.\n   \n**Test Case 5: Large numbers with carry-in** :\n   - Description: Adds two large numbers (`0xFFFFFFFF`) with carry-in, testing for correct propagation of carry during overflow.\n   \n**Test Case 6: Alternating 1's and 0's, no carry-in** :\n   - Description: Tests the adder with alternating 1's and 0's for each operand without a carry-in, verifying correct addition without any carries.\n   \n**Test Case 7: Random values with carry-in** :\n   - Description: Adds random values with carry-in, testing the adder\u2019s ability to handle arbitrary inputs with carry propagation.\n   \n**Test Case 8: Large hexadecimal numbers** :\n   - Description: Adds large hexadecimal numbers (0xF0F0F0F0 and 0x0F0F0F0F) without carry-in, testing how the adder handles large numbers.\n\n**Test Case 9: Random edge case with carry-in** :\n   - Description: Tests a random edge case with carry-in, checking for correct addition when both operands are large random values.\n\n**Test Case 10: Random edge case, carry-out expected** :\n   - Description: Adds two large random values with carry-out expected, verifying that the adder correctly handles large random numbers and carry propagation.\n\n**Test Case 11: Simple increasing values with carry-in** :\n   - Description: Adds simple increasing values (0x11111111 and 0x22222222) with carry-in, testing the adder with straightforward values and carry propagation.\n\n**Test Case 12: Smallest non-zero inputs with carry-in** :\n   - Description: Adds the smallest non-zero values (0x00000001 and 0x00000001) with carry-in, verifying the adder\u2019s handling of small values and carry propagation.\n\n## Module Functionality :\n- The brent-kung adder uses a parallel prefix tree approach to efficiently calculate the carry signals at each stage, which helps to reduce the delay for carry propagation.\n- The adder computes the sum and carry-out by progressively calculating propagate and generate signals across multiple hierarchical stages (from P1/G1 to P6/G6).\n- The carry signals (`C`) are generated in each stage by combining the results of the previous stage's propagate and generate signals.\n- Finally, the sum is computed using the propagate signals XORed with the carry signals, and the carry-out is the final carry from the last stage.\n\nThe **different hierarchical stages of the brent_kung adder and their operations is as follows** :\n\n**First Stage (P1 and G1 generation)**:\n- The first stage computes the propagate (P1) and generate (G1) signals for each bit of a and b. The P1 signal indicates if there will be a carry from the previous bit, while the G1 signal indicates if there is a generate of carry at the current bit.\n   - `P1[i] = a[i] ^ b[i]`: Propagate signal for bit i.\n   - `G1[i] = a[i] & b[i]`: Generate signal for bit i.\n\n**Second Stage (G2 and P2 generation)**:\n- In this stage, the module generates the G2 and P2 signals for pairs of bits. The second stage is a hierarchical combination of G1 and P1 signals from the first stage.\nFor each pair of bits (i and i+1), the following calculations occur:\n  - `G2[i/2] = G1[i+1] | (P1[i+1] & G1[i])`: This computes the G2 signal, which tells if there is a carry generated by this pair of bits.\n  - `P2[i/2] = P1[i+1] & P1[i]`: This computes the P2 signal for the pair.\n\n**Third Stage (G3 and P3 generation)**:\n- The G3 and P3 signals are generated for groups of four bits.\n   - `G3[i/2] = G2[i+1] | (P2[i+1] & G2[i])`: This generates the G3 signal for each group of two G2 signals.\n   - `P3[i/2] = P2[i+1] & P2[i]`: This generates the P3 signal for each pair of P2 signals.\n\n**Fourth Stage (G4 and P4 generation)**:\n- The G4 and P4 signals are generated for groups of eight bits.\n   - `G4[i/2] = G3[i+1] | (P3[i+1] & G3[i])`: Combines G3 and P3 signals to generate G4.\n   - `P4[i/2] = P3[i+1] & P3[i]`: Combines P3 signals to generate P4.\n\n**Fifth Stage (G5 and P5 generation)**:\n- The next stage computes G5 and P5 signals, each for a group of 16 bits.\n  - `G5[i/2] = G4[i+1] | (P4[i+1] & G4[i])`: Combines G4 and P4 to generate G5.\n  - `P5[i/2] = P4[i+1] & P4[i]`: Combines P4 signals to generate P5.\n\n**Sixth Stage (G6 and P6 generation)**:\n- The final stage computes the G6 and P6 signals:\n   - `G6 = G5[1] | (P5[1] & G5[0])`: Combines G5 and P5 to generate G6.\n   - `P6 = P5[1] & P5[0]`: Combines P5 signals to generate P6.\n\n**Carry Propagation (C array)**:\n- The carry signals (C[i]) are computed by combining the G and P signals at each stage.\nFor example:\n  - `C[1] = G1[0] | (P1[0] & carry_in)`: The carry for the first bit is calculated based on the initial carry-in.\n- Each subsequent C[i] is computed using the corresponding G and P signals from the previous stages, ensuring that carries are propagated through the entire adder.\n\n**Final Sum and Carry-Out**:\n- The final sum is computed as the XOR of the propagate signals and the carry signals:\n   - `sum = P1 ^ {C[31:1], carry_in}`: The sum is the bitwise XOR of the propagate signals (P1) and the carry signals (C).\n- The final carry-out is the carry generated at the last stage:\n   - `carry_out = C[32]`: This is the final carry-out value.\n\n\n**Partial Test Stimulus Generator Code** :\n```verilog\n    module tb_brent_kung_adder;\n\n    \n    logic [31:0] a;\n    logic [31:0] b;\n    logic carry_in;\n    logic [31:0] sum;\n    logic carry_out;\n    logic [31:0] start_time;\n    logic [31:0] end_time; \n    \n    brent_kung_adder uut (\n        .a(a),\n        .b(b),\n        .carry_in(carry_in),\n        .sum(sum),\n        .carry_out(carry_out)\n    );\n\n    task measure_latency(input [31:0] start, input [31:0] end_time);\n        begin\n            $display(\"Latency = %t time units\", end_time - start);\n        end\n    endtask\n\n    \n    initial begin\n        \n        a = 32'b0;\n        b = 32'b0;\n        carry_in = 0;\n\n        start_time = $time;  \n        #10;\n        a = 32'b00000000000000000000000000000000;  \n        b = 32'b00000000000000000000000000000000;  \n        carry_in = 0;      \n        #10;\n        end_time = $time;  \n        measure_latency(start_time, end_time);  \n        $display(\"Test Case 1: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);\n\n        \n        start_time = $time;  \n        #10;\n        a = 32'h7FFFFFFF;  \n        b = 32'h7FFFFFFF;  \n        carry_in = 0;      \n        #10;\n        end_time = $time;  \n        measure_latency(start_time, end_time);  \n        $display(\"Test Case 2: a = %h, b = %h, carry_in = %b, expected_sum = %h, expected_carry_out = %b , actual_sum = %h , actual_carry_out = %b\", a, b, carry_in, sum, carry_out,sum,carry_out);       \n\n        // Insert the code for the remaining test stimulus here\n ```       ", "context": {}}, "output": {"response": "", "context": {"verif/tb_brent_kung_adder.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = baf774b3b971bdc4dc0756156ee03da1c42b4ba1\nTARGET = 80\n", "src/brent_kung_adder.sv": "module brent_kung_adder(\n    input  logic [31:0] a,\n    input  logic [31:0] b,\n    input  logic carry_in,\n    output logic [31:0] sum,\n    output logic carry_out\n);\n    logic [31:0] P1, G1;\n    logic [32:1] C;\n    logic [15:0] G2, P2;\n    logic [7:0] G3, P3;\n    logic [3:0] G4, P4;\n    logic [1:0] G5, P5;\n    logic G6, P6;\n    \n    assign P1 = a ^ b;\n    assign G1 = a & b;\n    \n    genvar i;\n    generate\n        for(i=0; i<=30; i=i+2) begin: second_stage  \n            assign G2[i/2] = G1[i+1] | (P1[i+1] & G1[i]);\n            assign P2[i/2] = P1[i+1] & P1[i];\n        end\n    endgenerate\n    \n    generate\n        for(i=0; i<=14; i=i+2) begin: third_stage   \n            assign G3[i/2] = G2[i+1] | (P2[i+1] & G2[i]);\n            assign P3[i/2] = P2[i+1] & P2[i];\n        end\n    endgenerate\n    \n    generate\n        for(i=0; i<=6; i=i+2) begin: fourth_stage  \n            assign G4[i/2] = G3[i+1] | (P3[i+1] & G3[i]);\n            assign P4[i/2] = P3[i+1] & P3[i];\n        end\n    endgenerate\n    \n    generate\n        for(i=0; i<=2; i=i+2) begin: fifth_stage  \n            assign G5[i/2] = G4[i+1] | (P4[i+1] & G4[i]);\n            assign P5[i/2] = P4[i+1] & P4[i];\n        end\n    endgenerate\n        \n    assign G6 = G5[1] | (P5[1] & G5[0]);\n    assign P6 = P5[1] & P5[0];\n       \n    assign C[1] = G1[0] | (P1[0] & carry_in);\n    assign C[2] = G2[0] | (P2[0] & carry_in);\n    assign C[4] = G3[0] | (P3[0] & carry_in);\n    assign C[8] = G4[0] | (P4[0] & carry_in);\n    assign C[16] = G5[0] | (P5[0] & carry_in);\n    assign C[32] = G6 | (P6 & carry_in);\n        \n    assign C[3] = G1[2] | (P1[2] & C[2]);\n    assign C[5] = G1[4] | (P1[4] & C[4]);\n    assign C[6] = G2[2] | (P2[2] & C[4]);\n    assign C[7] = G1[6] | (P1[6] & C[6]);\n    \n    assign C[9] = G1[8] | (P1[8] & C[8]);\n    assign C[10] = G2[4] | (P2[4] & C[8]);\n    assign C[11] = G1[10] | (P1[10] & C[10]);\n    assign C[12] = G3[2] | (P3[2] & C[8]);\n    assign C[13] = G1[12] | (P1[12] & C[12]);\n    assign C[14] = G2[6] | (P2[6] & C[12]);\n    assign C[15] = G1[14] | (P1[14] & C[14]);\n    \n    assign C[17] = G1[16] | (P1[16] & C[16]);\n    assign C[18] = G2[8] | (P2[8] & C[16]);\n    assign C[19] = G1[18] | (P1[18] & C[18]);\n    assign C[20] = G3[4] | (P3[4] & C[16]);\n    assign C[21] = G1[20] | (P1[20] & C[20]);\n    assign C[22] = G2[10] | (P2[10] & C[20]);\n    assign C[23] = G1[22] | (P1[22] & C[22]);\n    assign C[24] = G4[2] | (P4[2] & C[16]);\n    assign C[25] = G1[24] | (P1[24] & C[24]);\n    assign C[26] = G2[12] | (P2[12] & C[24]);\n    assign C[27] = G1[26] | (P1[26] & C[26]);\n    assign C[28] = G3[6] | (P3[6] & C[24]);\n    assign C[29] = G1[28] | (P1[28] & C[28]);\n    assign C[30] = G2[14] | (P2[14] & C[28]);\n    assign C[31] = G1[30] | (P1[30] & C[30]);\n        \n    assign sum = P1 ^ {C[31:1], carry_in};\n    assign carry_out = C[32];\n    \nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n        \n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_Attenuator_0011", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench for the `Attenuator` module, which takes a 5-bit input (`data`) and shifts it out serially after detecting changes, finally latching with `ATTN_LE`.\n\n---\n\n## Description\n\n### Inputs\n\n- **Registers**:\n  - `clk (1 bit)`: Clock signal driving the state machine and internal half-rate clock generation (`clk_div2`).\n  - `reset (1 bit)`: Active-high, synchronous reset. When asserted, all state registers and outputs (`ATTN_CLK`, `ATTN_DATA`, `ATTN_LE`) are forced zero.\n  - `data (5 bits)`: An input register. Any change from the previous value triggers a **LOAD** phase, followed by serial shifting and a final latch.\n\n### Outputs\n\n- **Wires**:\n  - `ATTN_CLK (1 bit)`: A clock-like output pulsed high during the **SHIFT** state to shift bits from the internal register.\n  - `ATTN_DATA (1 bit)`: Serial data output, sending the shifted 5-bit pattern bit by bit.\n  - `ATTN_LE (1 bit)`: Latch enable signal pulsed high for one cycle after shifting completes.\n\n---\n\n## Input Generation\n\n- **Random Input Generation**:  \n  The testbench drives random 5-bit values on `data` to ensure the module sees a range of patterns:\n  - Different bit combinations (e.g., `5'b00000`, `5'b11111`, random).\n  - Consecutive changes that repeatedly trigger LOAD \u2192 SHIFT \u2192 LATCH sequences.\n  - Long intervals without change, remaining in the **IDLE** state.\n\n- **Edge Cases**:  \n  The testbench should also drive specific sequences:\n  - Repeated identical data, ensuring the module stays in **IDLE** (no SHIFT or LATCH).\n  - Patterns that confirm each bit is shifted correctly in order (`ATTN_DATA`) while toggling `ATTN_CLK`.\n  - Observing `ATTN_LE` pulses for one cycle when shifting completes.\n\n---\n\n## Stabilization Period\n\n- The testbench waits a few clock cycles (e.g., 2\u20134 cycles of `clk`) after driving each new `data` value to allow the FSM to step from **LOAD** into **SHIFT** and eventually **LATCH** if 5 bits are shifted.\n\n---\n\n## Instantiation\n\nName the instance of the module as `uut`.\n\n---\n\nFollows the specification for building the RTL of the module, use it as reference for the verification environment too:\n\n### Module Interface\n\n1. **Inputs**:\n   - `clk`: 1-bit clock signal.  \n   - `reset`: 1-bit active-high reset.  \n   - `data [4:0]`: 5-bit register whose changes trigger loading and shifting.\n\n2. **Outputs**:\n   - `ATTN_CLK` (1 bit): Pulsed during SHIFT to clock out each bit.  \n   - `ATTN_DATA` (1 bit): Serial data output from the shift register.  \n   - `ATTN_LE` (1 bit): Asserted for one cycle after all 5 bits shift out, latching the final result externally.\n\n### Module Functionality\n\n- **Clock Division**:  \n  An internal `clk_div2` toggles on every rising edge of `clk`, creating a slower clock domain for shifting.\n\n- **Finite State Machine**:\n  - **IDLE**: Waits if `data == old_data`. On detecting `data != old_data`, transitions to **LOAD**.\n  - **LOAD**: Captures `data` into `shift_reg`, outputs the MSB on `ATTN_DATA`, and prepares for shifting.\n  - **SHIFT**: Toggles `ATTN_CLK` high and left-shifts the remaining bits, decreasing a bit counter until 0.\n  - **LATCH**: Pulses `ATTN_LE` high for one cycle, then returns to **IDLE**.\n\n- **Reset Conditions**:  \n  - While `reset=1`, `current_state` = **IDLE**, `shift_reg` = `5'b00000`, `ATTN_CLK=0`, `ATTN_DATA=0`, `ATTN_LE=0`.\n\n---", "context": {}}, "output": {"response": "", "context": {"verif/Attenuator_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n   xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = c2ed083f1874d8efd5e8d483b74703db7b91de0d\nTARGET          = 90\n", "src/Attenuator.sv": "`timescale 1ns / 1ps\n\nmodule Attenuator (\n    input       clk,\n    input       reset,\n    input [4:0] data,\n    output reg  ATTN_CLK,\n    output reg  ATTN_DATA,\n    output reg  ATTN_LE\n);\n\nreg         clk_div2;\nreg  [1:0]  current_state, next_state;\nreg  [4:0]  shift_reg;\nreg  [2:0]  bit_count;\nreg  [4:0]  old_data;\n\nparameter IDLE  = 2'b00,\n          LOAD  = 2'b01,\n          SHIFT = 2'b10,\n          LATCH = 2'b11;\n\ninitial begin\n    ATTN_CLK  = 1'b0;\n    ATTN_DATA = 1'b0;\n    ATTN_LE   = 1'b0;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        clk_div2 <= 1'b0;\n    end else begin\n        clk_div2 <= ~clk_div2;\n    end\nend\n\nalways @(posedge clk_div2 or posedge reset) begin\n    if (reset) begin\n        current_state <= IDLE;\n        old_data      <= 5'b00000;\n        shift_reg     <= 5'b00000;\n        bit_count     <= 3'd0;\n\n        ATTN_CLK      <= 1'b0;\n        ATTN_DATA     <= 1'b0;\n        ATTN_LE       <= 1'b0;\n    end else begin\n        current_state <= next_state;\n        old_data      <= data;\n\n        ATTN_CLK <= 1'b0;\n        ATTN_LE  <= 1'b0;\n\n        if (current_state == IDLE) begin\n            ATTN_DATA <= 1'b0;\n        end\n\n        case (current_state)\n            LOAD: begin\n                shift_reg <= data;\n                bit_count <= 3'd5;\n\n                ATTN_DATA <= data[4];\n            end\n\n            SHIFT: begin\n                ATTN_CLK <= 1'b1;\n\n                ATTN_DATA = shift_reg[4]; \n                shift_reg = shift_reg << 1; \n                bit_count <= bit_count - 1;\n            end\n\n            LATCH: begin\n                ATTN_LE <= 1'b1;\n            end\n        endcase\n    end\nend\n\nalways @(*) begin\n    next_state = current_state;\n    case (current_state)\n        IDLE:   if (data != old_data) next_state = LOAD;\n        LOAD:   next_state = SHIFT;\n        SHIFT:  if (bit_count == 0)   next_state = LATCH;\n        LATCH:  next_state = IDLE;\n    endcase\nend\n\nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_IIR_filter_0012", "categories": ["cid012", "medium"], "input": {"prompt": "Complete the Given Partial SystemVerilog Testbench `iir_filt_tb`. The testbench must instantiate the `iir_filt` RTL module and provide input stimulus for it, focusing exclusively on generating comprehensive test vectors rather than building a full testbench. The IIR filter processes three input signals and outputs three corresponding filtered signals based on a selectable filter configuration.\n\n---\n\n## **Module Interface**\n### **1. Inputs:**\n- **`clk (1-bit)`**: Active high Clock signal that synchronizes operations within the filter logic.\n- **` reset (1-bit)`**: Active-high Asynchronous reset signal that clears the internal states of the filter.\n- **`in_1 [15:0] (16-bit, signed)`**: First input signal to the filter.\n- **`in_2  [15:0] (16-bit, signed)`**: Second input signal to the filter.\n- **`in_3  [15:0] (16-bit, signed)`**: Third input signal to the filter.\n- **`filter_select [1:0] (2-bit, unsigned)`**: Filter selection signal that determines which filter coefficients are applied.\n\n### **2. Outputs:**\n- **`out_1  [15:0] (16-bit, signed)`**: Filtered output corresponding to `in_1`.\n- **`out_2  [15:0] (16-bit, signed)`**: Filtered output corresponding to `in_2`.\n- **`out_3  [15:0] (16-bit, signed)`**: Filtered output corresponding to `in_3`.\n\n---\n\n## **Instantiation:**\nThe testbench instantiates the `iir_filt` module as `uut` and connects the signals between the module and the testbench. Each input and output from the DUT is connected to its corresponding signal in the testbench.\n\n---\n\n## **Input Generation and:**\n- **Clock Generation:** Active high clock signal `clk` toggles every 5 time units to simulate a 100 MHz clock.\n- **Reset:** The reset signal `reset` is asserted at the beginning of the simulation to initialize the filter to a known state. After 20 time units, the reset is deasserted.\n- **Stimulus:** Several test cases are applied to different filtering operations. These test cases, edge cases, stress conditions, dynamic switching, invalid input handling, to filter coefficient changes.\n\n---\n\n## **Test Cases:**\n### **1. Edge Case Testing**\n- Test extreme values such as maximum (`16'h7FFF`), minimum (`16'h8000`), alternating patterns (`16'hAAAA`), and zero (`16'h0000`).\n\n### **2. Stress Testing**\n- Apply 500 cycles of randomized input signals and `filter_select` values.\n\n### **3. Dynamic Switching Test**\n- Randomly change `filter_select` every 10 cycles while continuously providing input data.\n- Ensure the filter transitions smoothly without abrupt artifacts.\n\n### **4. Invalid `filter_select` Test**\n- Iterate through all possible `filter_select` values (0 to 3), including out-of-range values.\n\n### **5. Step Test**\n- Apply a step input (`16'h1000`) and observe how the filter responds over multiple cycles.\n- Reset input to zero and monitor the settling behavior.\n\n### **6. Coefficient Transition Test**\n- Apply a constant input and cycle through different `filter_select` values to test filter coefficient switching behavior.\n\n### **7. Single Channel Test**\n- Provide input to one channel at a time (`in_1`, `in_2`, `in_3`) while keeping the others zero.\n\n### **8. All-Zero Input Test**\n- Feed all-zero inputs and ensure that outputs remain zero across different filter selections.\n\n### **9. Post-Reset Behavior Test**\n- Apply input after reset, if the filter starts processing correctly.\n\n### **10. Arithmetic Overflow Test**\n- Test filter behavior when inputs are at saturation limits (`16'h7FFF` and `16'h8000`).\n\n### **11. Filter Coefficient Combinations Test**\n- Apply known values to the inputs and cycle through filter selections.\n\n---\n\n## **Module Functionality:**\n- **Reset Handling:** The filter should correctly initialize all internal states upon reset.\n- **Filter Processing:** The selected filter should be applied to the inputs, and the outputs should reflect the processed values.\n- **Coefficient Switching:** Changing `filter_select` should update the filter behavior smoothly.\n- **Input Dependency:** Each output should primarily depend on its respective input (`out_1` on `in_1`, `out_2` on `in_2`, etc.).\n- **Saturation and Stability:** The filter should handle extreme values without causing instability.\n\n---\n```verilog\nmodule iir_filt_tb();\n\n    // DUT Inputs\n    reg clk;\n    reg reset;\n    reg signed [15:0] in_1;\n    reg signed [15:0] in_2;\n    reg signed [15:0] in_3;\n    reg [1:0] filter_select;\n\n    // DUT Outputs\n    wire signed [15:0] out_1;\n    wire signed [15:0] out_2;\n    wire signed [15:0] out_3;\n\n    // Instantiate the DUT\n    iir_filt #(.WIDTH(16)) uut (\n        .clk(clk),\n        .reset(reset),\n        .in_1(in_1),\n        .in_2(in_2),\n        .in_3(in_3),\n        .filter_select(filter_select),\n        .out_1(out_1),\n        .out_2(out_2),\n        .out_3(out_3)\n    );\n\n    // Clock generation\n    initial clk = 0;\n    always #5 clk = ~clk; // 100 MHz clock\n\n    // Test procedure\n    initial begin\n        // Initialize inputs\n        reset = 1;\n        #20;\n        reset = 0;\n        $display(\"[%0t] DUT reset completed\", $time);\n\n        // Edge case testing\n        $display(\"[%0t] Starting edge case testing\", $time);\n        in_1 = 16'h7FFF; in_2 = 16'h8000; in_3 = 16'h7FFF; filter_select = 2'b00; #20;\n        in_1 = -16'h8000; in_2 = -16'h7FFF; in_3 = 16'h7FFF; filter_select = 2'b01; #20;\n        in_1 = 16'hAAAA; in_2 = 16'h5555; in_3 = 16'hAAAA; filter_select = 2'b10; #20;\n        in_1 = 16'h0000; in_2 = 16'h0000; in_3 = 16'h0000; filter_select = 2'b11; #20;\n        in_1 = 16'h1234; in_2 = 16'h5678; in_3 = 16'h9ABC; filter_select = 2'b00; #20;\n        $display(\"[%0t] Edge case testing completed\", $time);\n\n        // Stress testing\n        $display(\"[%0t] Starting stress testing\", $time);\n        reset = 1; #20; reset = 0;\n        repeat (500) begin\n            filter_select = $random % 4;\n            in_1 = $random;\n            in_2 = $random;\n            in_3 = $random;\n            #20;\n        end\n        $display(\"[%0t] Stress testing completed\", $time);\n\n        // Insert the code for the remaining test cases here\n\n\n        // Finish simulation\n        $display(\"[%0t] Testbench simulation completed\", $time);\n        $finish;\n    end\n\nendmodule\n```", "context": {}}, "output": {"response": "", "context": {"verif/tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = dabea0d1a8dd24f3dafa8148110d07f59eba2126\nTARGET = 80\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/iir_filt.sv": "module iir_filt #(parameter WIDTH = 16)(\n    input clk,\n    input reset,\n    input signed [WIDTH-1:0] in_1,\n    input signed [WIDTH-1:0] in_2,\n    input signed [WIDTH-1:0] in_3,\n    input [1:0] filter_select, // 00: Butterworth, 01: Chebyshev, 10: Elliptic\n    output reg signed [WIDTH-1:0] out_1,\n    output reg signed [WIDTH-1:0] out_2,\n    output reg signed [WIDTH-1:0] out_3\n);\n\n    reg signed [WIDTH-1:0] butterworth_a_0, butterworth_a_1;\n    reg signed [WIDTH-1:0] butterworth_b_0, butterworth_b_1;\n\n    reg signed [WIDTH-1:0] chebyshev_a_0, chebyshev_a_1;\n    reg signed [WIDTH-1:0] chebyshev_b_0, chebyshev_b_1;\n\n    reg signed [WIDTH-1:0] elliptic_a_0, elliptic_a_1;\n    reg signed [WIDTH-1:0] elliptic_b_0, elliptic_b_1;\n\n    reg signed [WIDTH-1:0] x_1_0, x_1_1, y_1_0, y_1_1;\n    reg signed [WIDTH-1:0] x_2_0, x_2_1, y_2_0, y_2_1;\n    reg signed [WIDTH-1:0] x_3_0, x_3_1, y_3_0, y_3_1;\n\n    integer i;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Initialize all delay lines and outputs\n            x_1_0 <= 0; x_1_1 <= 0; y_1_0 <= 0; y_1_1 <= 0;\n            x_2_0 <= 0; x_2_1 <= 0; y_2_0 <= 0; y_2_1 <= 0;\n            x_3_0 <= 0; x_3_1 <= 0; y_3_0 <= 0; y_3_1 <= 0;\n\n            out_1 <= 0;\n            out_2 <= 0;\n            out_3 <= 0;\n        end else begin\n            // Shift delay lines\n            x_1_1 <= x_1_0; x_1_0 <= in_1;\n            y_1_1 <= y_1_0;\n\n            x_2_1 <= x_2_0; x_2_0 <= in_2;\n            y_2_1 <= y_2_0;\n\n            x_3_1 <= x_3_0; x_3_0 <= in_3;\n            y_3_1 <= y_3_0;\n\n            case (filter_select)\n                2'b00: begin \n                    y_1_0 <= butterworth_b_0 * x_1_0 + butterworth_b_1 * x_1_1 - butterworth_a_1 * y_1_1;\n                    y_2_0 <= butterworth_b_0 * x_2_0 + butterworth_b_1 * x_2_1 - butterworth_a_1 * y_2_1;\n                    y_3_0 <= butterworth_b_0 * x_3_0 + butterworth_b_1 * x_3_1 - butterworth_a_1 * y_3_1;\n                end\n                2'b01: begin \n                    y_1_0 <= chebyshev_b_0 * x_1_0 + chebyshev_b_1 * x_1_1 - chebyshev_a_1 * y_1_1;\n                    y_2_0 <= chebyshev_b_0 * x_2_0 + chebyshev_b_1 * x_2_1 - chebyshev_a_1 * y_2_1;\n                    y_3_0 <= chebyshev_b_0 * x_3_0 + chebyshev_b_1 * x_3_1 - chebyshev_a_1 * y_3_1;\n                end\n                2'b10: begin \n                    y_1_0 <= elliptic_b_0 * x_1_0 + elliptic_b_1 * x_1_1 - elliptic_a_1 * y_1_1;\n                    y_2_0 <= elliptic_b_0 * x_2_0 + elliptic_b_1 * x_2_1 - elliptic_a_1 * y_2_1;\n                    y_3_0 <= elliptic_b_0 * x_3_0 + elliptic_b_1 * x_3_1 - elliptic_a_1 * y_3_1;\n                end\n                default: begin\n                    y_1_0 <= 0;\n                    y_2_0 <= 0;\n                    y_3_0 <= 0;\n                end\n            endcase\n\n            out_1 <= y_1_0;\n            out_2 <= y_2_0;\n            out_3 <= y_3_0;\n        end\n    end\n\n    always @(*) begin\n        case (filter_select)\n            2'b00: begin \n                butterworth_a_0 = 16'h0000; butterworth_a_1 = 16'h0001;\n                butterworth_b_0 = 16'h0001; butterworth_b_1 = 16'h0002;\n            end\n            2'b01: begin \n                chebyshev_a_0 = 16'h0000; chebyshev_a_1 = 16'h0003;\n                chebyshev_b_0 = 16'h0004; chebyshev_b_1 = 16'h0005;\n            end\n            2'b10: begin\n                elliptic_a_0 = 16'h0000; elliptic_a_1 = 16'h0006;\n                elliptic_b_0 = 16'h0007; elliptic_b_1 = 16'h0008;\n            end\n            default: begin\n                butterworth_a_0 = 0; butterworth_a_1 = 0;\n                butterworth_b_0 = 0; butterworth_b_1 = 0;\n\n                chebyshev_a_0 = 0; chebyshev_a_1 = 0;\n                chebyshev_b_0 = 0; chebyshev_b_1 = 0;\n\n                elliptic_a_0 = 0; elliptic_a_1 = 0;\n                elliptic_b_0 = 0; elliptic_b_1 = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_IIR_filter_0016", "categories": ["cid012", "medium"], "input": {"prompt": "Create a SystemVerilog testbench module named **`iir_filter_tb`** that instantiates the `iir_filter` module and applies stimulus to the instantiated module for different test scenarios. \n\n---\n### **Inputs**  \n\n- **Clock Signal**:  \n  - `clk`: Positive edge-triggered clock signal driving the IIR filter.  \n\n- **Reset Signal**:  \n  - `rst`: Asynchronous active-high reset signal to initialize the module.  \n\n- **Input Sample**:  \n  - `x[15:0]`: A signed **16-bit input signal** representing the input samples to the filter.  \n\n### **Outputs**  \n\n- **Filtered Output**:  \n  - `y[15:0]`: A signed **16-bit output signal** representing the filter's processed output.  \n\n---\n\n## **Input Generation**  \n\n### **Test Stimulus**  \n\nThe testbench systematically has to apply various input waveforms to the IIR filter under different conditions:  \n\n1. **Impulse  Test**  \n   - Apply a single nonzero value (`16'h4000`) followed by zeros.  \n\n2. **Step Test**  \n   - Apply a **constant step input** (`16'h3000`) for a duration.  \n   - filter stabilization and steady-state.  \n\n3. **Sinusoidal Input Test**  \n   - Apply a **sine wave signal** at different frequencies and amplitudes.  \n   - Evaluates frequency and phase shift characteristics.  \n\n4. **Ramp Input Test**  \n   - Apply a **gradually increasing input** from a negative to positive value.  \n   - Observes filter behavior in linear input variations.  \n\n5. **Noise Test**  \n   - Apply **random noise samples** within a predefined amplitude range.  \n   - Ensures the filter does not amplify undesired noise excessively.  \n\n6. **Stability Test**  \n   - Apply a **constant DC input** and monitor output over an extended period.  \n   - Ensures no instability, drift, or oscillations occur.  \n\n7. **Overflow Test**  \n   - Apply **maximum and minimum possible values** (`16'h7FFF` and `16'h8000`).  \n   - saturation handling and prevents wraparound errors.  \n\n8. **Frequency Sweep Test**  \n   - Apply a **gradual frequency sweep** from a low to high frequency.  \n   - Analyzes frequency over the full spectrum.  \n\n9. **Alternating Step Test**  \n   - Alternates between two amplitude levels (`16'h3000` and `-16'h3000`).  \n   - Checks transient to abrupt changes in input.\n      \n10. **Double Impulse Test**  \n    - Sends **two impulses** separated by a specific delay.  \n    - Evaluates filter behavior when multiple transient events occur.\n     \n11. **Max Amplitude Test**  \n    - Continuously apply **maximum amplitude samples** (`16'h7FFF` and `16'h8000`).  \n    - Ensures the filter does not produce unstable behavior.  \n\n---\n\n## **Instantiation**  \n\n- The **`iir_filter`** instance in the testbench is named **`dut`**.  \n\n---\n\n## **Module Interface**  \n\n### **Inputs**  \n\n- `clk`: Clock signal.  \n- `rst`: Asynchronous active-high reset.  \n- `x[15:0]`: 16-bit signed input sample.  \n\n### **Outputs**  \n\n- `y[15:0]`: 16-bit signed output sample.  \n\n---\n\n## **Module Functionality**  \n\n1. **Filter Processing**  \n   - The `iir_filter` processes the input sample `x` and produces a filtered output `y`.  \n\n2. **Reset Behavior**  \n   - When `rst` is HIGH, the filter resets internal states, and `y` is cleared to `0`.  \n\n3. **Edge Cases**  \n   - Handling of large amplitude signals without overflow.  \n   - Stability under constant or repetitive input patterns.  \n\n---", "context": {}}, "output": {"response": "", "context": {"verif/tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 7c483196daf6dbfaa7399ec5ac1882fe1e77bd42\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/iir_filter.sv": "module iir_filter (\n    input logic clk,\n    input logic rst,\n    input logic signed [15:0] x,    // Input sample\n    output logic signed [15:0] y    // Output sample\n);\n\n    // Filter coefficients\n    parameter signed [15:0] b0 = 16'h0F00;\n    parameter signed [15:0] b1 = 16'h0E00;\n    parameter signed [15:0] b2 = 16'h0D00;\n    parameter signed [15:0] b3 = 16'h0C00;\n    parameter signed [15:0] b4 = 16'h0B00;\n    parameter signed [15:0] b5 = 16'h0A00;\n    parameter signed [15:0] b6 = 16'h0900;\n    parameter signed [15:0] a1 = -16'h0800;\n    parameter signed [15:0] a2 = -16'h0700;\n    parameter signed [15:0] a3 = -16'h0600;\n    parameter signed [15:0] a4 = -16'h0500;\n    parameter signed [15:0] a5 = -16'h0400;\n    parameter signed [15:0] a6 = -16'h0300;\n\n    // Explicitly declare each state variable\n    logic signed [15:0] x_prev1, x_prev2, x_prev3, x_prev4, x_prev5, x_prev6;\n    logic signed [15:0] y_prev1, y_prev2, y_prev3, y_prev4, y_prev5, y_prev6;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            x_prev1 <= 0; x_prev2 <= 0; x_prev3 <= 0;\n            x_prev4 <= 0; x_prev5 <= 0; x_prev6 <= 0;\n            y_prev1 <= 0; y_prev2 <= 0; y_prev3 <= 0;\n            y_prev4 <= 0; y_prev5 <= 0; y_prev6 <= 0;\n            y <= 0;\n        end else begin\n            // Calculate the filter output\n            y <= (b0 * x + b1 * x_prev1 + b2 * x_prev2 + b3 * x_prev3 +\n                  b4 * x_prev4 + b5 * x_prev5 + b6 * x_prev6 -\n                  a1 * y_prev1 - a2 * y_prev2 - a3 * y_prev3 -\n                  a4 * y_prev4 - a5 * y_prev5 - a6 * y_prev6) >>> 16;\n\n            // Update the historical data\n            x_prev6 <= x_prev5; x_prev5 <= x_prev4; x_prev4 <= x_prev3;\n            x_prev3 <= x_prev2; x_prev2 <= x_prev1; x_prev1 <= x;\n            y_prev6 <= y_prev5; y_prev5 <= y_prev4; y_prev4 <= y_prev3;\n            y_prev3 <= y_prev2; y_prev2 <= y_prev1; y_prev1 <= y;\n        end\n    end\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_MSHR_0003", "categories": ["cid012", "medium"], "input": {"prompt": "Develop a SystemVerilog module named `tb_cache_mshr` that only generates input stimulus to a `cache_mshr` module. `cache_mshr` module implements Miss Status Handling Registers (MSHR). The MSHR is a critical component of a **non-blocking cache architecture**, enabling the system to handle multiple outstanding cache misses concurrently. \n\n---\n\n## RTL Specification\n\n### **Parameters**\n- **`INSTANCE_ID`** *(default = \"mo_mshr\")*:  \n  A string identifier for the MSHR instance. This parameter allows users to assign a unique name to each instance of the MSHR module.\n\n- **`MSHR_SIZE`** *(default = 32)*:  \n  Specifies the total number of entries available in the MSHR. This defines how many pending requests can be tracked simultaneously.\n\n- **`CS_LINE_ADDR_WIDTH`** *(default = 10)*:  \n  The bit-width required to represent the cache line address. This parameter determines the number of unique cache lines that can be indexed.\n\n- **`WORD_SEL_WIDTH`** *(default = 4)*:  \n  Specifies the number of bits needed to select a specific word within a cache line. For example, with a cache line containing 16 words, ( log<sub>2</sub>(16) = 4 ) bits are required.\n\n- **`WORD_SIZE`** *(default = 4)*:  \n  Word size in **bytes**. It represents the number of bits in the byte enable signal for a word. This indicates which bytes within the word are active during a write operation.\n\n---\n\n### **Derived Parameters**\n- **`TAG_WIDTH`**:  \n  The bit-width of the tag portion of the address. It is calculated as:\n 32 - `CS_LINE_ADDR_WIDTH`+ log2(`WORD_SIZE`) + `WORD_SEL_WIDTH` \n\n- **`CS_WORD_WIDTH`**: \n   word width in bits . It is calculated as WORD_SIZE * 8 \n    \n- **`DATA_WIDTH`**:  \n  Defines the total data width for each MSHR entry. It is calculated as:\n `WORD_SEL_WIDTH` + `WORD_SIZE` + `CS_WORD_WIDTH` + `TAG_WIDTH` \n\n- **`MSHR_ADDR_WIDTH`**:  \n  Defines the number of bits required to address all entries in the MSHR. It is calculated as:\n `$clog2(MSHR_SIZE)` \n---\n\n### Port List\n\n| **Port Name**                           | **Direction** | **Description**                                                                                |\n|-----------------------------------------|---------------|------------------------------------------------------------------------------------------------|\n| `clk`                                   | Input         | Clock signal.  The design registers are triggered on its positive edge.                        |\n| `reset`                                 | Input         | Active high synchronous reset signal                                                           |\n| `allocate_valid`                        | Input         | Active high signal indicating a new core request for allocation.                               |\n| `allocate_addr[CS_LINE_ADDR_WIDTH-1:0]` | Input         | Cache line address of the new request.                                                         |\n| `allocate_data[DATA_WIDTH-1:0]`         | Input         | Request data containing the word address, byte enable signal, write data, and tag information. |\n| `allocate_rw`                           | Input         | Read/write operation type for the new request. 1'b1 = write request, 1'b0 = read request       | \n| `allocate_id[MSHR_ADDR_WIDTH-1:0]`      | Output        | ID of the allocated slot.                                                                      |\n| `allocate_pending`                      | Output        | Active high signal indicating if a new request is for a cache line that is already pending.    |\n| `allocate_previd[MSHR_ADDR_WIDTH-1:0]`  | Output        | ID of the previous entry for the same cache line if `allocate_pending` asserted.               |\n| `allocate_ready`                        | Output        | Active high signal indicating if a new request can be allocated. If MSHR isn't full            |\n| `finalize_valid`                        | Input         | Active high signal indicating a finalize operation is being requested.                         |\n| `finalize_id[MSHR_ADDR_WIDTH-1:0]`      | Input         | ID of the entry being finalized.                                                               |\n\n\n### Functional description:\nThis design should integrate seamlessly into a non-blocking cache system with a 32-bit address system, where tag access and MSHR access occur in parallel.\n- On core request, `allocate_valid`, the MSHR allocates an entry for the incoming core request, regardless of whether it is a hit or miss. `allocate_valid` could only be asserted when `allocate_ready` is asserted, indicating there is an available MSHR entry\n- In the subsequent cycle, the cache tag access determines if the request is a hit or miss. If the request is a cache hit, the allocated MSHR entry is immediately marked invalid. `finalize_valid` will be asserted only on cache hit, `finalize_id` should be one of the allocated indexes.\n\n---\n## Testbench Requirements\n\n### Instantiation\n\nName the instance of the RTL as `dut`.\n\n### Required Stimulus Description:\nThe objective is to achieve **100% code and toggle coverage** for the `cache_mshr` module by systematically exercising its functionality. The stimulus should ensure that all key features and transitions of the module are exercised while maintaining coverage goals.\n- Use a `cache_mshr` instance named `dut` in the testbench. \n- Supply stimulus to ensure that all MSHR entries are allocated during simulation, randomly asserting  `allocate_valid` at random clock negative edges and randomize input signals: `allocate_addr`, `allocate_data`, and `allocate_rw`.\n- Supply stimulus to ensure that all MSHR entries are finalized during simulation, randomly asserting  `finalize_valid` at random clock negative with `finalize_id` one of the allocated slots.\n- Fully exercise state transitions for every entry, including toggling between **write** and **read** operations.\n- Fully exercise cases where each entry points to the next request for the same cache line ( eg: use a fixed cache line)\n- Cover the module\u2019s behavior when the MSHR reaches full capacity, including the deassertion of `allocate_ready`.\n- Cover that `allocate_ready` is reasserted when entries are finalized and space becomes available.\n- Generate stimuli for both cache hit and miss scenarios randomly to ensure proper entry finalization and release.\n\n### Latency:\n- Allocation Requests: The module introduces a latency of 1 clock cycle for each allocation request.\n- Finalize Requests: The module introduces a latency of 1 clock cycle for each finalize release request.", "context": {}}, "output": {"response": "", "context": {"verif/tb_cache_mshr.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = \"feature/verification_dp_1\"\nTARGET = 100\n", "src/cache_mshr.sv": "`define NOTCONNECTED_PIN(x)   /* verilator lint_off PINCONNECTEMPTY */ \\\n                        . x () \\\n                        /* verilator lint_on PINCONNECTEMPTY */\n\nmodule cache_mshr #(\n    parameter INSTANCE_ID            = \"mo_mshr\"             ,\n    parameter MSHR_SIZE                     = 32                    ,\n    parameter CS_LINE_ADDR_WIDTH            = 10                    ,\n    parameter WORD_SEL_WIDTH                = 4                     ,\n    parameter WORD_SIZE                     = 4                     ,\n    // Derived parameters\n    parameter MSHR_ADDR_WIDTH               = $clog2(MSHR_SIZE)     , // default = 5\n    parameter TAG_WIDTH                     = 32 - (CS_LINE_ADDR_WIDTH+ $clog2(WORD_SIZE) + WORD_SEL_WIDTH), // default = 16\n    parameter CS_WORD_WIDTH                 = WORD_SIZE * 8 ,// default = 32 \n    parameter DATA_WIDTH                    = WORD_SEL_WIDTH + WORD_SIZE + CS_WORD_WIDTH + TAG_WIDTH // default =  4 + 4 + 32 + 16 = 56\n\n    ) (\n    input wire clk,\n    input wire reset,\n\n    // allocate\n    input wire                          allocate_valid,\n    output wire                         allocate_ready,\n    input wire [CS_LINE_ADDR_WIDTH-1:0] allocate_addr,\n    input wire                          allocate_rw,\n    input wire [DATA_WIDTH-1:0]         allocate_data,\n    output wire [MSHR_ADDR_WIDTH-1:0]   allocate_id,\n    output wire                         allocate_pending,\n    output wire [MSHR_ADDR_WIDTH-1:0]   allocate_previd,\n\n    // finalize\n    input wire                          finalize_valid,\n    input wire [MSHR_ADDR_WIDTH-1:0]    finalize_id\n);\n\n    reg [CS_LINE_ADDR_WIDTH-1:0] cs_line_addr_table [0:MSHR_SIZE-1];\n    reg [MSHR_SIZE-1:0] entry_valid_table_q, entry_valid_table_d;\n    reg [MSHR_SIZE-1:0] is_write_table;\n\n    reg [MSHR_SIZE-2:0] next_ptr_valid_table_q, next_ptr_valid_table_d;\n    reg [MSHR_ADDR_WIDTH-1:0] next_index_ptr [0:MSHR_SIZE-1]; // ptr to the next index\n\n    reg                         allocate_pending_q, allocate_pending_d;\n\n\n    reg [MSHR_ADDR_WIDTH-1:0] allocate_id_q, allocate_id_d;\n\n\n    \n    wire [MSHR_ADDR_WIDTH-1:0] prev_idx ;\n    reg [MSHR_ADDR_WIDTH-1:0]  prev_idx_q;\n\n    wire allocate_fire = allocate_valid && allocate_ready;\n    \n    // Address lookup to find matches If there is a match ... link the latest req next ptr to the newly allocated idx\n    wire [MSHR_SIZE-1:0] addr_matches;\n    for (genvar i = 0; i < MSHR_SIZE; ++i) begin : g_addr_matches\n        assign addr_matches[i] = entry_valid_table_q[i] && (cs_line_addr_table[i] == allocate_addr) && allocate_fire;\n    end\n\n    wire [MSHR_SIZE-1:0] match_with_no_next = addr_matches & ~next_ptr_valid_table_q ;\n    wire full_d ; \n\n    leading_zero_cnt #(\n            .DATA_WIDTH (MSHR_SIZE),\n            .REVERSE (1)\n    ) allocate_idx (\n            .data   (~entry_valid_table_q),\n            .leading_zeros  (allocate_id_d),\n            .all_zeros (full_d)\n    );\n\n    leading_zero_cnt #(\n            .DATA_WIDTH (MSHR_SIZE),\n            .REVERSE (1)\n    ) allocate_prev_idx (\n            .data   (match_with_no_next),\n            .leading_zeros  (prev_idx),\n            `NOTCONNECTED_PIN(all_zeros) // not connected\n    );\n    \n    always @(*) begin\n        entry_valid_table_d     = entry_valid_table_q;\n        next_ptr_valid_table_d  = next_ptr_valid_table_q;\n        \n    \n        if (finalize_valid) begin\n            entry_valid_table_d[finalize_id] = 0;\n        end\n\n        if (allocate_fire) begin\n            entry_valid_table_d[allocate_id_d] = 1;\n            next_ptr_valid_table_d[allocate_id_d] = 0;\n        end\n\n        if (allocate_pending_d) begin\n            next_ptr_valid_table_d[prev_idx] = 1;\n        end\n    end\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            entry_valid_table_q  <= '0;\n            next_ptr_valid_table_q  <=  0;\n            allocate_pending_q <= 0 ;\n        end else begin\n            entry_valid_table_q  <= entry_valid_table_d;\n            next_ptr_valid_table_q  <= next_ptr_valid_table_d;\n            allocate_pending_q <= allocate_pending_d ; \n        end\n\n        if (allocate_fire) begin\n            cs_line_addr_table[allocate_id_d]   <= allocate_addr;\n            is_write_table[allocate_id_d]       <= allocate_rw;\n        end\n\n        if (allocate_pending_d) begin\n            next_index_ptr[prev_idx] <= allocate_id_d;\n        end\n\n\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            allocate_id_q       <=  0 ;\n            prev_idx_q          <= 0 ;\n        end else begin\n            if (allocate_fire) begin\n                allocate_id_q       <=  allocate_id_d       ;\n                prev_idx_q          <= prev_idx ;\n            end \n        end\n    end\n\n    // SP RAM\n    reg [DATA_WIDTH-1:0] ram [0:MSHR_SIZE-1];\n    always @(posedge clk) begin\n        if (allocate_fire) begin\n            ram[allocate_id_d] <= allocate_data ;\n        end\n    end\n\n    \n    \n    assign  allocate_pending_d = |addr_matches;\n    assign allocate_id = allocate_id_q ;\n    assign allocate_ready = ~full_d ;\n    assign allocate_previd = prev_idx_q;\n\n    assign allocate_pending = allocate_pending_q;\n`ifdef DEBUG_PRINT \n    reg show_table;\n    always @(posedge clk) begin\n        if (reset) begin\n            show_table <= 0;\n        end else begin\n            show_table <= allocate_fire || finalize_valid ;\n        end\n        if (allocate_fire) begin\n            $write(\"%t: %s allocate: addr=0x%0h, id=%0d, pending=%b, prev=%0d \\n\", $time, INSTANCE_ID,\n                allocate_addr, allocate_id, allocate_pending_d, prev_idx) ;\n        end\n        if (finalize_valid ) begin\n            $write(\"%t: %s release: id=%0d \\n\", $time, INSTANCE_ID, finalize_id);\n        end\n        \n        if (show_table) begin\n            $write(\"%t: %s table\", $time, INSTANCE_ID);\n            for (integer i = 0; i < MSHR_SIZE; ++i) begin\n                if (entry_valid_table_q[i]) begin\n                    $write(\" %0d=0x%0h\", i, cs_line_addr_table[i]);\n                    if (is_write_table[i]) begin\n                        $write(\"(w)\");\n                    end else begin\n                        $write(\"(r)\");\n                    end\n                    if (next_ptr_valid_table_q[i])  begin\n                        $write(\"->%d\", next_index_ptr[i] );\n                    end\n                end\n            end\n            $write(\"\\n\");\n        end\n    end\n`endif\n\n\nendmodule\n\n\nmodule leading_zero_cnt #(\n    parameter DATA_WIDTH = 32,\n    parameter REVERSE = 0 \n)(\n    input  [DATA_WIDTH -1:0] data,\n    output  [$clog2(DATA_WIDTH)-1:0] leading_zeros,\n    output all_zeros \n);\n    localparam NIBBLES_NUM = DATA_WIDTH/4 ; \n    reg [NIBBLES_NUM-1 :0] all_zeros_flag ;\n    reg [1:0]  zeros_cnt_per_nibble [NIBBLES_NUM-1 :0]  ;\n\n    genvar i;\n    integer k ;\n    // Assign data/nibble \n    reg [3:0]  data_per_nibble [NIBBLES_NUM-1 :0]  ;\n    generate\n        for (i=0; i < NIBBLES_NUM ; i=i+1) begin\n            always @* begin\n                data_per_nibble[i] = data[(i*4)+3: (i*4)] ;\n            end\n        end\n    endgenerate\n   \n    generate\n        for (i=0; i < NIBBLES_NUM ; i=i+1) begin : g_nibble\n            if (REVERSE) begin : g_trailing\n                always @* begin\n                        zeros_cnt_per_nibble[i] [1] = ~(data_per_nibble[i][1] | data_per_nibble[i][0]); \n                        zeros_cnt_per_nibble[i] [0] = (~data_per_nibble[i][0]) &\n                                                      ((~data_per_nibble[i][2]) | data_per_nibble[i][1]);\n                        all_zeros_flag[i] = (data_per_nibble[i] == 4'b0000);\n                end\n            end else begin :g_leading\n                always @* begin\n                    zeros_cnt_per_nibble[NIBBLES_NUM-1-i][1] = ~(data_per_nibble[i][3] | data_per_nibble[i][2]); \n                    zeros_cnt_per_nibble[NIBBLES_NUM-1-i][0] = (~data_per_nibble[i][3]) &\n                                     ((~data_per_nibble[i][1]) | data_per_nibble[i][2]);\n                    \n                    all_zeros_flag[NIBBLES_NUM-1-i] = (data_per_nibble[i] == 4'b0000);\n                end\n            end\n        end\n    endgenerate\n\n    \n    \n    reg [$clog2(NIBBLES_NUM)-1:0] index ; \n    reg [1:0]    choosen_nibbles_zeros_count ;\n    reg [ $clog2(NIBBLES_NUM*4)-1:0] zeros_count_result ;\n    wire [NIBBLES_NUM-1:0]         all_zeros_flag_decoded;\n    \n    assign all_zeros_flag_decoded[0] = all_zeros_flag[0] ;\n    genvar j;\n        generate\n            for (j=1; j < NIBBLES_NUM; j=j+1) begin\n                assign all_zeros_flag_decoded[j] = all_zeros_flag_decoded[j-1] & all_zeros_flag[j];\n            end\n        endgenerate\n\n    always@ * begin\n        index = 0 ;\n        for ( k =0 ; k< NIBBLES_NUM ; k =k +1) begin\n            index = index + all_zeros_flag_decoded[k] ;\n        end\n    end\n    \n    always@* begin\n        choosen_nibbles_zeros_count = zeros_cnt_per_nibble[index]  ;  \n        zeros_count_result = choosen_nibbles_zeros_count + (index <<2) ; \n    end\n    \n    assign leading_zeros =  zeros_count_result ;\n    assign all_zeros = (data ==0) ;\n\nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Simulation didn't run correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage merge didn't run correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    try:\n        with open(\"/code/rundir/coverage.log\") as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage.log file.\")\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    print(\"Parsed Metrics:\")\n    print(metrics)\n\n    # Ensure TARGET environment variable is set\n    target = os.getenv(\"TARGET\")\n    if not target:\n        raise ValueError(\"TARGET environment variable is not set.\")\n    target = float(target)\n\n    # Check coverage for the DUT or specific key\n    dut = \"dut\"  # Replace this with the DUT key you want to check\n    if dut in metrics and \"Overall Average\" in metrics[dut]:\n        assert float(metrics[dut][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        # Log available keys for debugging\n        print(f\"Available keys in metrics: {metrics.keys()}\")\n        assert False, f\"Coverage data for '{dut}' is not available.\"\n"}}}
{"id": "cvdp_copilot_Serial_Line_Converter_0006", "categories": ["cid012", "easy"], "input": {"prompt": "Complete the given partial SystemVerilog testbench `serial_line_code_converter_tb`. The testbench must instantiate the `serial_line_code_converter` RTL module and provide input stimulus to validate its functionality. This module implements various serial line coding techniques. The testbench should include different input scenarios, such as different encoding schemes, edge cases, and invalid input handling. \n\n---\n\n## Description\n\nThe serial_line_code_converter module is a Verilog-based design that converts serial input data into different encoding formats based on the selected mode. The module utilizes clock division, edge detection, and various encoding techniques to modify the serial input and produce the corresponding encoded serial output.\n\n### Encoding Implementations\n1. **NRZ (Non-Return-to-Zero)**: Direct pass-through of `serial_in`.\n2. **RZ (Return-to-Zero)**: Outputs high only during the first half of the clock cycle when `serial_in` is high.\n3. **Differential Encoding**: Outputs the XOR of the current and previous serial input.\n4. **Inverted NRZ**: Outputs the inverted value of `serial_in`.\n5. **NRZ with Alternating Bit Inversion**: Inverts every alternate bit of `serial_in`.\n6. **Parity Bit Output (Odd Parity)**: Generates an odd parity bit based on the serial input.\n7. **Scrambled NRZ**: XORs `serial_in` with the least significant bit of the clock counter for scrambling.\n8. **Edge-Triggered NRZ**: Detects rising edges of `serial_in` and outputs accordingly.\n\n### Parameters\n- **`CLK_DIV`**: Specifies the clock divider for generating clk_pulse. The default value is 16. It must be a positive integer greater than or equal to 2.\n\n### Inputs:\n- **clk**: System clock signal. The design operates synchronously with the rising edge of `clk`.\n- **reset_n**:  Active-low asynchronous reset signal. When asserted low, it resets all internal states and outputs.\n- **serial_in**:  1-bit Input signal carrying the serial data stream to be encoded according to the selected mode.\n- **mode [2:0]**: A 3-bit input that determines the encoding mode. Possible values:\n  - `000`: NRZ (Non-Return-to-Zero).\n  - `001`: RZ (Return-to-Zero).\n  - `010`: Differential Encoding.\n  - `011`: Inverted NRZ.\n  - `100`: NRZ with Alternating Bit Inversion.\n  - `101`: Parity Bit Output (Odd Parity).\n  - `110`: Scrambled NRZ.\n  - `111`: Edge-Triggered NRZ.\n\n### Outputs:\n- **serial_out**: Encoded  1-bit output signal. The encoding applied to `serial_in` is determined by the value of the `mode` input. The output updates on every clock cycle based on the selected encoding method.\n\n---\n\n## Testbench Setup\n\n### Clock Generation:\n- Generate a clock with a period of 10ns using an `always` block.\n\n### Reset Signal:\n- Apply an active-low reset signal at the beginning of the simulation to initialize the DUT.\n\n### Signal Initialization:\n- Initialize all testbench signals, including registers and tracking signals for the DUT behavior.\n\n### Feature Mode Identification:\n- Maintain an array of strings to define and identify the different encoding techniques implemented in the DUT.\n\n### DUT Instantiation:\n- Create an instance of the `serial_line_code_converter` module with appropriate connections for inputs and outputs.\n\n---\n\n## Behavioral Logic\n\n### Clock Division:\n- Simulate clock division logic in the testbench to mimic DUT timing for certain modes like RZ.\n\n### Previous State Tracking:\n- Track previous input values and states to validate encoding techniques like Differential and Edge-Triggered NRZ.\n\n### Special Mode Handling:\n- Implement specific logic for modes such as Alternate Inversion, Parity-Added, and Scrambled NRZ.\n\n---\n\n## Input Generation \n\n### Stimulus Generation:\n- Randomly generate serial input values (`serial_in`) for each encoding mode.\n- Iterate through all 8 modes, applying input stimuli and observing DUT behavior.\n\n---\n\n## Waveform Analysis\n- Generate a VCD file (`serial_line_code_converter.vcd`) to enable waveform analysis for debugging and verification.\n\n---\n\n## Test Scenarios\n\n### Test All Modes:\n- Test all 8 encoding modes in sequence.\n- For each mode, generate multiple input patterns.\n\n### Edge Case Validation:\n- Generate the inputs for edge cases such as alternating inputs, random noise, and reset behavior.\n\n### Partial Test Stimulus Generator Code :\n\n```verilog\nmodule serial_line_code_converter_tb;\n    parameter CLK_DIV = 6; // Clock division parameter for timing\n\n    // Testbench signals\n    logic clk, reset_n, serial_in, serial_out;\n    logic [2:0] mode;\n\n    // Tracking signals to mimic DUT behavior\n    logic [3:0] tb_counter;\n    logic tb_clk_pulse, tb_prev_serial_in, tb_alt_invert_state, tb_parity_out, tb_prev_value;\n\n    // Instantiate the Device Under Test\n    serial_line_code_converter #(CLK_DIV) dut (\n        .clk(clk),\n        .reset_n(reset_n),\n        .serial_in(serial_in),\n        .mode(mode),\n        .serial_out(serial_out)\n    );\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk; // Clock period of 10ns\n    end\n\n    // Initialize signals\n    initial begin\n        tb_counter = 0;\n        tb_clk_pulse = 0;\n        tb_prev_serial_in = 0;\n        tb_prev_value = 0;\n        tb_alt_invert_state = 0;\n        tb_parity_out = 0;\n        reset_n = 0;\n        serial_in = 0;\n        mode = 3'b000;\n\n        // Apply reset\n        @(negedge clk) reset_n = 1;\n        @(posedge clk);\n    end\n\n    // Insert the code for the remaining test stimulus here\n\nendmodule\n```", "context": {}}, "output": {"response": "", "context": {"verif/serial_line_code_converter_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro \n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 86d1e0a9c5f887d24e620a0a017f8bb02a9bba39\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n", "src/serial_line_code_converter.sv": "module serial_line_code_converter #(parameter CLK_DIV = 16)(\n    input  logic clk,             // System clock\n    input  logic reset_n,         // Active-low reset\n    input  logic serial_in,       // Serial input signal\n    input  logic [2:0] mode,      // Mode selector\n    output logic serial_out       // Serial output signal\n);\n\n    // Internal signals\n    logic [3:0] clk_counter;      // Clock divider counter\n    logic clk_pulse;              // Clock pulse for sampling\n    logic prev_serial_in;         // Previous serial input for edge detection\n    logic prev_value;             // Holds the previous value of serial_in\n    logic nrz_out;                // NRZ encoding output\n    logic rz_out;                 // Return-to-Zero encoding output\n    logic diff_out;               // Differential encoding output\n    logic inv_nrz_out;            // Inverted NRZ output\n    logic alt_invert_out;         // NRZ with alternating bit inversion output\n    logic alt_invert_state;       // State for alternating inversion\n    logic parity_out;             // Parity Bit Output\n    logic scrambled_out;          // Scrambled NRZ output\n    logic edge_triggered_out;     // Edge-Triggered NRZ output\n\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            clk_counter <= 0;\n            clk_pulse <= 0;\n        end else if (clk_counter == CLK_DIV - 1) begin\n            clk_counter <= 0;\n            clk_pulse <= 1;\n        end else begin\n            clk_counter <= clk_counter + 1;\n            clk_pulse <= 0;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            prev_value <= 0;\n            prev_serial_in <= 0;\n        end else begin\n            prev_value <= serial_in;\n            prev_serial_in <= prev_value;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            nrz_out <= 0;\n        end else begin\n            nrz_out <= serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            rz_out <= 0;\n        end else begin\n            rz_out <= serial_in & clk_pulse; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            diff_out <= 0;\n        end else  begin\n            diff_out <= serial_in ^ prev_serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            inv_nrz_out <= 0;\n        end else  begin\n            inv_nrz_out <= ~serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            alt_invert_out <= 0;\n            alt_invert_state <= 0;\n        end else  begin\n            alt_invert_state <= ~alt_invert_state; \n            alt_invert_out <= alt_invert_state ? ~serial_in : serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            parity_out <= 0;\n        end else  begin\n            parity_out <= serial_in ^ parity_out; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            scrambled_out <= 0;\n        end else  begin\n            scrambled_out <= serial_in ^ clk_counter[0]; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            edge_triggered_out <= 0;\n        end else  begin\n            edge_triggered_out <= (serial_in & ~prev_serial_in);\n        end\n    end\n\n    always_comb begin\n        case (mode)\n            3'b000: serial_out = nrz_out;                // NRZ\n            3'b001: serial_out = rz_out;                 // Return-to-Zero\n            3'b010: serial_out = diff_out;               // Differential Encoding\n            3'b011: serial_out = inv_nrz_out;            // Inverted NRZ\n            3'b100: serial_out = alt_invert_out;         // NRZ with alternating bit inversion\n            3'b101: serial_out = parity_out;             // Parity Bit Output\n            3'b110: serial_out = scrambled_out;          // Scrambled NRZ\n            3'b111: serial_out = edge_triggered_out;     // Edge-Triggered NRZ\n            default: serial_out = 0;                     // Default to 0\n        endcase\n    end\n\nendmodule"}}}
{"id": "cvdp_copilot_Synchronous_Muller_C_Element_0003", "categories": ["cid012", "easy"], "input": {"prompt": "Write a SystemVerilog testbench to only generate stimulus for a `sync_muller_c_element` design with configurable inputs and pipeline depth. This design processes input signals through a configurable pipeline and produces a single-bit output based on the state of the inputs in the final pipeline stage, outputting 1 only when all inputs are 1 and 0 only when all inputs are 0, while maintaining its state otherwise. \n\n---\n\n## Design Details\n\n### **Parameterization**\n1. **NUM_INPUT**: Specifies the number of input signals.\n   - Default: 2\n2. **PIPE_DEPTH**: Defines the number of pipeline stages.\n   - Default: 1\n\n### **Functional Behavior**\n1. **Pipeline Operation**:\n   - The pipeline captures and shifts the input states through `PIPE_DEPTH` stages.\n   - Inputs propagate stage by stage until they reach the final stage.\n2. **Output Logic**:\n   - The output signal is set based on the status of propagated input signals at the last pipeline stage.\n3. **Control Signal Behavior**:\n   - **Reset (`srst`)**: Active-high synchronous reset that clears the pipeline and output.\n   - **Clear (`clr`)**: Clears the pipeline and output without resetting.\n   - **Clock Enable (`clk_en`)**: Controls whether the pipeline registers update on the rising edge of the clock.\n\n### **Inputs and Outputs**\n- **Inputs**:\n  - `clk`: Clock signal.\n  - `srst`: Synchronous reset signal (active high).\n  - `clr`: Active high clear signal.\n  - `clk_en`: Active high clock enable signal.\n  - `inp[NUM_INPUT-1:0]`: NUM_INPUT-width vector representing the input signals.\n- **Outputs**:\n  - `out`: Output signal based on the logical state of the inputs in the last pipeline stage.\n\n---\n\n### Testbench Requirements:\n\n#### Instantiation\n\n- **Module Instance**: The `sync_muller_c_element` module must be instantiated as `sync_muller_c_element_inst`, with all input and output signals connected for testing.\n\n---\n\n#### Input Generation\n\n- **Input Patterns**: The testbench should continuously drive various input patterns to `inp` to cover all possibilities including:\n  - All `0`s, all `1`s, alternating patterns, and other corner cases.\n  - Randomized input patterns to exercise pipeline behavior.\n\n- **Control Signals**:\n  - Assert `srst` at the start of the simulation to reset the pipeline and output.\n  - Toggle `clr` during operation to clear the pipeline and output.\n  - Drive `clk_en` high and low during operation to test its effect on pipeline propagation.\n\n- **Output Latency**: Outputs will reflect the processed state of the inputs after a latency of `PIPE_DEPTH + 1` clock cycles. New inputs do not have to wait for this latency and can continue to be applied every clock cycle.", "context": {}}, "output": {"response": "", "context": {"verif/tb_sync_muller_c_element.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 3-create-the-tb-to-test-synchronous-muller-c-element-3\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Simulation didn't run correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage merge didn't run correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    try:\n        with open(\"/code/rundir/coverage.log\") as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage.log file.\")\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    print(\"Parsed Metrics:\")\n    print(metrics)\n\n    # Ensure TARGET environment variable is set\n    target = os.getenv(\"TARGET\")\n    if not target:\n        raise ValueError(\"TARGET environment variable is not set.\")\n    target = float(target)\n\n    # Check coverage for the DUT or specific key\n    dut = \"sync_muller_c_element_inst\"  # Replace this with the DUT key you want to check\n    if dut in metrics and \"Overall Average\" in metrics[dut]:\n        assert float(metrics[dut][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        # Log available keys for debugging\n        print(f\"Available keys in metrics: {metrics.keys()}\")\n        assert False, f\"Coverage data for '{dut}' is not available.\"\n", "src/sync_muller_c_element.sv": "module sync_muller_c_element #(\n  parameter NUM_INPUT  = 2, // Number of input signals\n  parameter PIPE_DEPTH = 1  // Number of pipeline stages\n) (\n  input  logic                  clk   , // Clock signal\n  input  logic                  srst  , // Synchronous reset signal\n  input  logic                  clr   , // Clear pipeline and output\n  input  logic                  clk_en, // Clock enable signal\n  input  logic  [NUM_INPUT-1:0] inp   , // Input signals (NUM_INPUT-width vector)\n  output logic                  out     // Output signal\n);\n\n  // Pipeline to store intermediate states of inputs\n  logic [(PIPE_DEPTH*NUM_INPUT)-1:0] pipe; \n  genvar i;\n\n  // Generate block for pipeline implementation\n  generate\n    for (i = 0; i < PIPE_DEPTH; i = i + 1) begin : pipeline_stage\n      always_ff @(posedge clk) begin\n        if (srst | clr) begin\n          // Reset the pipeline stage\n          pipe[i*NUM_INPUT+:NUM_INPUT] <= '0;\n        end\n        else if (clk_en) begin\n          if (i == 0) begin\n            // Load inputs into the first stage of the pipeline\n            pipe[i*NUM_INPUT+:NUM_INPUT] <= inp;\n          end\n          else begin\n            // Shift data from the previous stage to the current stage\n            pipe[i*NUM_INPUT+:NUM_INPUT] <= pipe[(i-1)*NUM_INPUT+:NUM_INPUT];\n          end\n        end\n      end\n    end\n  endgenerate\n\n  // Always block to compute the output signal\n  always_ff @(posedge clk) begin\n    if (srst | clr) begin\n      // Reset the output signal\n      out <= 1'b0;\n    end\n    else if (clk_en) begin\n      // Output logic: High if all inputs in the last pipeline stage are high\n      // Low if all inputs in the last pipeline stage are low\n      if (&pipe[(PIPE_DEPTH-1)*NUM_INPUT+:NUM_INPUT]) begin\n        out <= 1'b1; \n      end\n      else if (!(|pipe[(PIPE_DEPTH-1)*NUM_INPUT+:NUM_INPUT])) begin\n        out <= 1'b0;\n      end\n    end\n  end\n\nendmodule"}}}
{"id": "cvdp_copilot_adc_data_rotate_0009", "categories": ["cid012", "easy"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named  `adc_data_rotate` module by applying exhaustive test scenarios. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage. The testbench should not create checkers to verify the MUT.\n\n\n---\n## **Instantiation**\nName the instance of the RTL as `dut`.\n\n## **RTL Parameter Inputs - Outputs and Functional behaviour**\n\n### Parameterization\n- The module supports parameterized data width, `DATA_WIDTH`, with a default value of 8 bits. This allows the module to handle various input data sizes.\n\n### Inputs\n- **`i_clk`** (logic): Clock signal to synchronize the module\u2019s operation.\n- **`i_rst_n`** (logic): Active-low reset signal. When asserted (`i_rst_n = 0`), all outputs reset to their idle state.\n- **`i_adc_data_in`** (logic [`DATA_WIDTH`-1:0]): Input data to be rotated.\n- **`i_shift_count`** (logic [3:0]): Specifies the number of bits to rotate. Supports up to 15-bit rotation.\n- **`i_shift_direction`** (logic): Controls the rotation direction:\n  - `0`: Left Rotate\n  - `1`: Right Rotate\n\n### Outputs\n- **`o_processed_data`** (logic [`DATA_WIDTH`-1:0]): The rotated result of the input `i_adc_data_in`.\n- **`o_operation_status`** (logic): Indicates the operation state:\n  - `0`: Reset state\n  - `1`: Active rotation\n\n### Reset Behavior\n- When `i_rst_n` is asserted (`i_rst_n = 0`):\n  - `o_processed_data` resets to `0`.\n  - `o_operation_status` resets to `0`.\n\n### Rotation Behavior\n- On the rising edge of `i_clk` and when `i_rst_n = 1`, the module performs:\n  - **Left Rotate** (`i_shift_direction = 0`): Bits shifted out from the left re-enter on the right.\n  - **Right Rotate** (`i_shift_direction = 1`): Bits shifted out from the right re-enter on the left.\n\n### Operation Status\n- During rotation, `o_operation_status` is set to `1` to indicate an active state.\n## Constraints and Edge Cases\n\n### **Edge Cases**:\n  - Handle rotation amounts of 0 and `DATA_WIDTH` effectively (e.g., rotation by `0` bits should result in no change).\n  - Ensure correct behavior when `i_shift_count` exceeds `DATA_WIDTH`. This means any shift count above **DATA_WIDTH** automatically wraps to the equivalent smaller shift.\n---\n## Stimulus generation\n\n1. Reset and Initialization\n- **Reset Assert/Deassert**: Set `i_rst_n = 0`, then `1`.\n- **Repeated Resets**: Assert/deassert `i_rst_n` multiple times quickly.\n \n 2. No Shift (Shift Count = 0)\n- **Left and Right Directions**: `i_shift_count = 0`, both directions.\n- **Data Patterns**: All-0s, all-1s, and alternating bits (e.g., `10101010`).\n\n3. Single-Bit Shifts\n- **Left Shift by 1**: `i_shift_count = 1`, `i_shift_direction = 0`. \n- **Right Shift by 1**: `i_shift_count = 1`, `i_shift_direction = 1.\n\n4. Multiple Bit Shifts\n- **Mid-Range Counts**: For `i_shift_count` like `3`, `4`, and `7`, apply various `i_adc_data_in` values.\n- **Full-Range Counts**: Sweep `i_shift_count` from `0` to `15`. \n\n5. Special Edge Cases\n- **Shift = Data Width** (e.g., 8): complete rotation.\n- **Shift = 15**: Highest valid count. Wrap-around for both directions.\n- **All 1s / All 0s**: Rotation uniform bit patterns.\n- **Alternating Bits**: Wrap-around (`10101010`, `01010101`) under all shift counts/directions.\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_adc_data_rotate.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 9-tb-stimulus\nTARGET = 92\n", "src/adc_data_rotate.sv": "module adc_data_rotate #(\n    parameter DATA_WIDTH = 8 // Parameterized data width (default = 8)\n)(\n    // Inputs\n    input  logic                     i_clk,             // Clock signal\n    input  logic                     i_rst_n,           // Active-low reset\n    input  logic [DATA_WIDTH-1:0]    i_adc_data_in,     // Input ADC data\n    input  logic [3:0]               i_shift_count,     // Number of bits to rotate\n    input  logic                     i_shift_direction, // Shift direction (0: Left, 1: Right)\n\n    // Outputs\n    output logic [DATA_WIDTH-1:0]    o_processed_data,  // Rotated output data\n    output logic                     o_operation_status // Operation status\n);\n\n    // Internal signal to hold the effective shift count\n    // Taking modulo with DATA_WIDTH ensures correct behavior for shifts > DATA_WIDTH\n    logic [DATA_WIDTH-1:0] shift_count_mod;\n\n    // Calculate effective shift count\n    // Since i_shift_count is 4 bits, the maximum shift count is 15.\n    // We only need to limit it to DATA_WIDTH-1 if DATA_WIDTH < 16.\n    assign shift_count_mod = i_shift_count % DATA_WIDTH;\n\n    // Synchronous logic\n    always_ff @(posedge i_clk or negedge i_rst_n) begin\n        if (!i_rst_n) begin\n            // Reset condition: outputs go to idle states\n            o_processed_data   <= '0;\n            o_operation_status <= 1'b0;\n        end\n        else begin\n            // Set operation_status high to indicate active rotation\n            o_operation_status <= 1'b1;\n\n            // Perform rotation based on i_shift_direction\n            if (i_shift_direction == 1'b0) begin\n                // Left rotate\n                // Bits shifted out of the left re-enter on the right\n                o_processed_data <= (i_adc_data_in << shift_count_mod) |\n                                    (i_adc_data_in >> (DATA_WIDTH - shift_count_mod));\n            end\n            else begin\n                // Right rotate\n                // Bits shifted out of the right re-enter on the left\n                o_processed_data <= (i_adc_data_in >> shift_count_mod) |\n                                    (i_adc_data_in << (DATA_WIDTH - shift_count_mod));\n            end\n        end\n    end\n\nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/adc_data_rotate.sv /code/verif/tb_adc_data_rotate.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_afi_ptr_0004", "categories": ["cid012", "medium"], "input": {"prompt": "Write a SystemVerilog testbench to only generate stimulus for a `cmprs_afi_mux_ptr_tb` module is responsible for managing pointer updates for multiple channels in a memory compression system. It handles resetting pointers, arbitrating between competing channels, and updating pointers based on increments while ensuring correct rollover behavior. \n\n## **Design Specification**\n\nThe **cmprs_afi_mux_ptr** module is responsible for managing pointer updates for multiple channels in a memory compression system. It handles resetting pointers, arbitrating between competing channels, and updating pointers based on increments while ensuring correct rollover behavior. \n\nThe testbench **cmprs_afi_mux_ptr_tb** must generate stimuli to validate the FSM transitions, pointer updates, reset behavior, and interaction with the busy signal for arbitration.\n\n### **Inputs:**\n- `hclk` (1-bit): **Clock signal**, used for synchronous operations.\n- `reset` (1-bit): **Active-high reset**, initializes the system state.\n- `sa_len_di` (27-bit): **Write data** for the `sa_len_ram`.\n- `sa_len_wa` (3-bit): **Write address** for the `sa_len_ram`.\n- `sa_len_we` (1-bit): **Write enable** for `sa_len_ram`.\n- `en` (1-bit): **Enable signal**, determines whether the module is active.\n- `reset_pointers` (4-bit): **Per-channel reset** control for pointers.\n- `pre_busy_w` (1-bit): **Indicates if a write operation is occurring**.\n- `pre_winner_channel` (2-bit): **Channel ID that won arbitration**.\n- `need_to_bother` (1-bit): **Indicates whether an update is required**.\n- `chunk_inc_want_m1` (2-bit): **Increment request value (minus one)**.\n- `last_burst_in_frame` (1-bit): **Indicates the last burst in a frame**.\n- `busy` (4-bit): **Busy flags for different channels**.\n\n### **Outputs:**\n- `ptr_resetting` (1-bit): **Indicates if pointers are resetting**.\n- `chunk_addr` (27-bit): **Computed chunk address**.\n- `max_wlen` (3-bit): **Maximum write length per channel**.\n\n## **FSM States & Behavior**\n- **IDLE**: Waits for reset pointers or arbitration start (`pre_busy_w`).\n- **RESETTING**: Resets the requested channel pointers to zero.\n- **ARBITRATION**: Determines if a pointer update is needed (`need_to_bother`).\n- **UPDATE**: Updates the selected pointer, handling overflow conditions.\n\n---\n\n## **Testbench Requirements**\n\n### **Instantiation**\n- Module Instance: The module **cmprs_afi_mux_ptr** should be instantiated as **uut**, with all input and output signals connected for testing.\n\n### **Input Generation**\n\n#### **1. sa_len_ram Writing**\n- The testbench must write values to all `sa_len_ram` entries.\n- Verify that each entry is correctly stored.\n\n#### **2. Pointer Resetting**\n- The testbench should initiate pointer resets (`reset_pointers`).\n- Verify that only the selected pointers are reset.\n\n#### **3. Arbitration and Pointer Increment**\n- Set `pre_busy_w` to initiate arbitration.\n- Assign a channel (`pre_winner_channel`) and increment (`chunk_inc_want_m1`).\n- Verify that the pointer updates correctly.\n\n#### **4. Rollover Condition Testing**\n- Initialize a pointer close to its maximum value.\n- Assign an increment that causes rollover.\n- Verify that the pointer wraps around correctly.\n\n#### **5. FSM Transition Verification**\n- Ensure that transitions between **IDLE**, **RESETTING**, **ARBITRATION**, and **UPDATE** follow expected conditions.\n- Confirm that after `pre_busy_w` is deasserted, the FSM returns to **IDLE**.\n\n#### **6. Reset During Active Update**\n- Apply `reset` while in the **UPDATE** state.\n- Verify that all registers return to their default values.\n\n---\n\n## **Control Signal Handling**\n- The testbench must ensure that inputs such as `pre_busy_w`, `pre_winner_channel`, `chunk_inc_want_m1`, and `reset_pointers` are asserted at the correct moments.\n- The FSM must be given enough cycles to transition and perform pointer updates before moving to the next test case.\n\nThis testbench will ensure the **cmprs_afi_mux_ptr** module functions correctly under various conditions, including normal operation, pointer resets, and overflow scenarios.", "context": {}}, "output": {"response": "", "context": {"verif/cmprs_afi_mux_ptr_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 9ceda5f77db02367cfe5d44905d09ded7a93a668\nTARGET = 80\n", "src/cmprs_afi_mux_ptr.sv": "`timescale 1ns / 1ps\n\nmodule cmprs_afi_mux_ptr(\n    input                         hclk,                // Clock signal\n    input                         reset,               // Synchronous reset input\n    input                  [26:0] sa_len_di,           // Data input for sa_len_ram\n    input                  [ 2:0] sa_len_wa,           // Write address for sa_len_ram\n    input                         sa_len_we,           // Write enable for sa_len_ram\n    input                         en,                  // Enable signal for FSM\n    input                  [ 3:0] reset_pointers,      // Reset pointers for specific channels\n    input                         pre_busy_w,          // Arbitration start signal\n    input                  [ 1:0] pre_winner_channel,  // Active channel for arbitration\n    input                         need_to_bother,      // Indicates whether an update is required\n    input                   [1:0] chunk_inc_want_m1,   // Increment value for the pointer\n    input                         last_burst_in_frame, // Indicates the last burst in frame\n    input                  [ 3:0] busy,                // Busy signals for channels\n    output                        ptr_resetting,       // Indicates the FSM is in RESETTING state\n    output reg             [26:0] chunk_addr,          // Current pointer address\n    output                 [ 2:0] max_wlen             // Maximum word length\n);\n\n    // Internal signals\n    reg [1:0] state, next_state;         // Current and next states of FSM\n    localparam IDLE        = 2'b00,      // FSM state: IDLE\n               RESETTING   = 2'b01,      // FSM state: RESETTING\n               ARBITRATION = 2'b10,      // FSM state: ARBITRATION\n               UPDATE      = 2'b11;      // FSM state: UPDATE\n\n    reg [26:0] ptr_ram[0:7];             // Pointer values for 8 channels\n    reg [26:0] sa_len_ram[0:7];          // Buffer sizes for 8 channels\n    reg [ 2:0] max_inc_ram[0:3];         // Maximum increment values for 4 channels\n    reg [3:0] reset_rq;                  // Tracks reset requests for pointers\n    reg rollover_flag;                   // Indicates rollover condition for pointer\n\n    integer i;                           // Loop variable for initialization\n\n    assign ptr_resetting = (state == RESETTING); \n    assign max_wlen = max_inc_ram[pre_winner_channel]; \n\n    always @(posedge hclk) begin\n        if (reset) begin\n            for (i = 0; i < 8; i = i + 1) begin\n                ptr_ram[i] <= 27'd0;       \n                sa_len_ram[i] <= 27'd64;  \n            end\n            for (i = 0; i < 4; i = i + 1) begin\n                max_inc_ram[i] <= 3'd0;   \n            end\n            reset_rq <= 4'b0000;          \n            rollover_flag <= 1'b0;        \n            chunk_addr <= 27'd0;          \n            state <= IDLE;                \n        end else begin\n            state <= next_state;          \n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (|reset_pointers)\n                    next_state = RESETTING;\n                else if (pre_busy_w)\n                    next_state = ARBITRATION;\n                else\n                    next_state = IDLE;    \n            end\n            RESETTING: begin\n                if (!reset_rq)\n                    next_state = IDLE;\n                else\n                    next_state = RESETTING; \n            end\n            ARBITRATION: begin\n                if (need_to_bother)\n                    next_state = UPDATE;\n                else\n                    next_state = IDLE;    \n            end\n            UPDATE: begin\n                if (!busy[pre_winner_channel])\n                    next_state = IDLE;\n                else\n                    next_state = UPDATE;\n            end\n            default: next_state = IDLE;    \n        endcase\n    end\n\n    always @(posedge hclk) begin\n        if (!reset) begin \n            case (state)\n                IDLE: begin\n                    if (sa_len_we) begin\n                        sa_len_ram[sa_len_wa] <= sa_len_di;\n                    end\n                    reset_rq <= reset_pointers;\n                end\n                RESETTING: begin\n                    if (reset_rq != 4'b0000) begin\n                        if (reset_rq[0]) ptr_ram[0] <= 27'd0;\n                        if (reset_rq[1]) ptr_ram[1] <= 27'd0;\n                        if (reset_rq[2]) ptr_ram[2] <= 27'd0;\n                        if (reset_rq[3]) ptr_ram[3] <= 27'd0;\n                        reset_rq <= 4'b0000; \n                    end\n                end\n                ARBITRATION: begin\n                    rollover_flag <= (ptr_ram[pre_winner_channel] + chunk_inc_want_m1 >= sa_len_ram[pre_winner_channel]);\n                end\n                UPDATE: begin\n                    if (busy[pre_winner_channel]) begin\n                        if (rollover_flag) begin\n                            ptr_ram[pre_winner_channel] <= ptr_ram[pre_winner_channel] + chunk_inc_want_m1 - sa_len_ram[pre_winner_channel];\n                            chunk_addr <= ptr_ram[pre_winner_channel] + chunk_inc_want_m1 - sa_len_ram[pre_winner_channel];\n                        end else begin\n                            ptr_ram[pre_winner_channel] <= ptr_ram[pre_winner_channel] + chunk_inc_want_m1;\n                            chunk_addr <= ptr_ram[pre_winner_channel] + chunk_inc_want_m1;\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_apb_dsp_op_0006", "categories": ["cid012", "medium"], "input": {"prompt": "Create a SystemVerilog test bench for a module named `apb_dsp_op`. The test bench should systematically generate input vectors, apply them to the design under test (DUT), and aim to achieve 100% coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **apb_dsp_op_dut**.\n\n## **RTL Interface and Parameters**\n\n| Signal     | Width | Samples | In/Out | Description                              |\n|------------|-------|---------|--------|------------------------------------------|\n| clk_dsp    | 1     | 1       | Input  | Faster clock of 500 MHz to DSP operation |\n| en_clk_dsp | 1     | 1       | Input  | Enable faster DSP clock                  |\n| PCLK       | 1     | 1       | Input  | APB clock of 50 MHz                      |\n| PRESETn    | 1     | 1       | Input  | Active low asynchronous APB Reset        |\n| PADDR      | 6     | 1       | Input  | APB address                              |\n| PWRITE     | 1     | 1       | Input  | Write/Read enable                        |\n| PWDATA     | 32    | 1       | Input  | Write data                               |\n| PSEL       | 1     | 1       | Input  | DSP selector                             |\n| PENABLE    | 1     | 1       | Input  | APB enable                               |\n| PRDATA     | 32    | 1       | Output | Read data                                |\n| PREADY     | 1     | 1       | Output | Ready signal                             |\n| PSLVERR    | 1     | 1       | Output | Error signal                             |\n\n### Parameters\n- **ADDR_WIDTH**: Width of the address (6 bits).\n- **DATA_WIDTH**: Width of the data (32 bits).\n\n---\n### Functional Behavior\n\n**Internal Blocks**\n\n1. **Control Unit**: \n   - Is responsible for controlling the APB interface, internal registers, SRAM operations and DSP behavior.\n2. **DSP Processing**: \n   - Can operate with the APB interface clock or with an alternative clock 10 times higher and performs the following operation: O = A * B + C.\n3. **SRAM Memory**: \n   - Has 64 addresses of 32 bits each.\n \n### Register Bank\n| Register       | Address | Default Value | Permission | Description                                              |\n|----------------|---------|---------------|------------|----------------------------------------------------------|\n| REG_OPERAND_A  | 0x00    | 32'h0         | W/R        | Holds the SRAM address to read the value for operand A   |\n| REG_OPERAND_B  | 0x01    | 32'h0         | W/R        | Holds the SRAM address to read the value for operand B   |\n| REG_OPERAND_C  | 0x02    | 32'h0         | W/R        | Holds the SRAM address to read the value for operand C   |\n| REG_OPERAND_O  | 0x03    | 32'h0         | W/R        | Holds the SRAM address to write the value for operand O  |\n| REG_CONTROL    | 0x04    | 32'h0         | W/R        | Holds the value equivalent to the operation control mode |\n| REG_WDATA_SRAM | 0x05    | 32'h0         | W/R        | Holds the data to be written to SRAM                     |\n| REG_ADDR_SRAM  | 0x06    | 32'h0         | W/R        | Holds the address to be read or written to SRAM          |\n\n### Control Modes\n\nThe module's operation has control modes configured according to the value in the internal register ```reg_control```. The operating modes are described below:\n   - 32'd1: Enables writing to SRAM.\n   - 32'd2: Enables reading from SRAM.\n   - 32'd3: Enables reading the A operand.\n   - 32'd4: Enables reading the B operand.\n   - 32'd5: Enables reading the C operand.\n   - 32'd6: Enables writing the O operand.\n   - Other values: Only performs write and read operations on internal registers.\n\n---\n### TB Implementation Notes\n\n1. **APB Interface**\n\nImplement simple APB driver tasks that does the following:\n- Drives PADDR, PWDATA, PWRITE when PSEL is asserted.\n- Asserts PENABLE for the second phase of the transfer.\n- Ensure the testbench stimulates correct read data at the right cycle.\n- Ensure the testbench stimulates out-of-range access.\n\n2. **SRAM Operations**\n\nImplement simple SRAM driver tasks configured by the APB registers:\n- Ensure the testbench stimulates correct read data at the right cycle.\n- Ensure the testbench stimulates out-of-range access.\n- Wait for clock synchronization after writing to SRAM.\n- Waiting for multiple PCLK cycles after SRAM requests.\n\n3. **DSP Processing**\n\nThe testbench ensures proper synchronization between PCLK and clk_dsp by:\n- Waiting for multiple PCLK cycles after DSP control registers are set.\n- Introducing additional @(posedge PCLK); waits before reading computed values.\n- Set different address values for REG_OPERAND_A, REG_OPERAND_B, REG_OPERAND_C, and REG_OPERAND_O before DSP execution.\n\n4. **Invalid Transactions**\n\nThe testbench ensures testing of invalid transactions by:\n- Creating a task for accessing invalid APB register addresses.\n- Creating a task for operating the SRAM at invalid addresses.\n- Creating a task for performing DSP operations using an invalid address.\n\n---\n### Stimulus Generation\n\nThe testbench writes to the following APB registers before initiating DSP operations:\nREG_OPERAND_A (0x00): Stores operand A address.\nREG_OPERAND_B (0x01): Stores operand B address.\nREG_OPERAND_C (0x02): Stores operand C address.\nREG_OPERAND_O (0x03): Stores operand O (result) address.\nREG_CONTROL (0x04): Triggers DSP operations and sets control modes.\nREG_WDATA_SRAM (0x05): Writes a value to SRAM.\nREG_ADDR_SRAM (0x06): Sets the SRAM address for reads and writes.\n\n1. **Basic scripts:**\n- Write to control registers.\n- Write to SRAM address & data registers.\n- Trigger DSP operation.\n- Read back final result.\n\n2. **Invalid Address Stimulus:**\nThe test bench stimulates invalid address by:\n- Writing and reading from an invalid APB register address.\n- Writing and reading from an invalid SRAM address.\n- Performing a DSP operation with an invalid REG_OPERAND_O address.\n\n3. **Signals Stimulus:**\n- Randomize signals when it makes sense.\n- Randomize valid and invalid stimuli across different tasks.\n- Wait for PCLK rising edge after reset deassertion.\n- Wait for CDC synchronization (insert some delay or additional posedge clocks commands in the test).", "context": {"rtl/apb_dsp_op.sv": "// APB DSP Operation Module\nmodule apb_dsp_op #(\n    parameter ADDR_WIDTH = 'd8,\n    parameter DATA_WIDTH = 'd32\n) (\n    input  logic                  clk_dsp,    // Faster clock to DSP operation\n    input  logic                  en_clk_dsp, // Enable DSP operation with faster clock\n    input  logic                  PCLK,       // APB clock\n    input  logic                  PRESETn,    // Active low asynchronous APB Reset\n    input  logic [ADDR_WIDTH-1:0] PADDR,      // APB address\n    input  logic                  PWRITE,     // Write/Read enable\n    input  logic [DATA_WIDTH-1:0] PWDATA,     // Write data\n    input  logic                  PSEL,       // DSP selector\n    input  logic                  PENABLE,    // APB enable\n    output logic [DATA_WIDTH-1:0] PRDATA,     // Read data\n    output logic                  PREADY,     // Ready signal\n    output logic                  PSLVERR     // Error signal\n);\n\n    // Synchronize en_clk_dsp signal to clk_dsp domain to avoid CDC issues\n    logic clk_dsp_sel;\n    logic en_clk_dsp_ff;\n    logic en_clk_dsp_sync_ff;\n\n    always_ff @(posedge clk_dsp or negedge PRESETn) begin\n        if (!PRESETn) begin\n            en_clk_dsp_ff      <= 1'b0;\n            en_clk_dsp_sync_ff <= 1'b0;\n        end else begin\n            en_clk_dsp_ff      <= en_clk_dsp;\n            en_clk_dsp_sync_ff <= en_clk_dsp_ff;\n        end\n    end\n\n    // Clock selection\n    assign clk_dsp_sel = (en_clk_dsp_ff) ? clk_dsp : PCLK;\n\n    // Internal registers address map\n    localparam ADDRESS_A         = 32'h0;  // 0x00\n    localparam ADDRESS_B         = 32'h4;  // 0x04\n    localparam ADDRESS_C         = 32'h8;  // 0x08\n    localparam ADDRESS_O         = 32'hC;  // 0x0C\n    localparam ADDRESS_CONTROL   = 32'h10; // 0x10\n    localparam ADDRESS_WDATA     = 32'h14; // 0x14\n    localparam ADDRESS_SRAM_ADDR = 32'h18; // 0x18\n\n    // Control modes\n    localparam SRAM_WRITE     = 32'd1;\n    localparam SRAM_READ      = 32'd2;\n    localparam DSP_READ_OP_A  = 32'd3;\n    localparam DSP_READ_OP_B  = 32'd4;\n    localparam DSP_READ_OP_C  = 32'd5;\n    localparam DSP_WRITE_OP_O = 32'd6;\n\n    // Internal APB-side registers\n    logic [DATA_WIDTH-1:0] reg_operand_a;\n    logic [DATA_WIDTH-1:0] reg_operand_b;\n    logic [DATA_WIDTH-1:0] reg_operand_c;\n    logic [DATA_WIDTH-1:0] reg_operand_o;\n    logic [DATA_WIDTH-1:0] reg_control;\n    logic [DATA_WIDTH-1:0] reg_wdata_sram;\n    logic [DATA_WIDTH-1:0] reg_addr_sram;\n\n    // DSP-side pipeline regs and signals\n    logic signed [DATA_WIDTH-1:0] dsp_op_a;\n    logic signed [DATA_WIDTH-1:0] dsp_op_b;\n    logic signed [DATA_WIDTH-1:0] dsp_op_c;\n    logic signed [DATA_WIDTH-1:0] dsp_result;\n\n    // SRAM signals\n    logic [DATA_WIDTH-1:0] sram_data_in;\n    logic                  sram_we;\n    logic [DATA_WIDTH-1:0] sram_addr;\n    logic [DATA_WIDTH-1:0] sram_data_out;\n    logic [DATA_WIDTH-1:0] sram_data_out_sync_1;\n    logic [DATA_WIDTH-1:0] sram_data_out_sync_2;\n    \n    // SRAM local memory\n    logic [DATA_WIDTH-1:0] mem [63:0];\n\n    // APB interface logic\n    always_ff @(posedge PCLK or negedge PRESETn) begin\n        if (!PRESETn) begin\n            reg_operand_a  <= 'd0;\n            reg_operand_b  <= 'd0;\n            reg_operand_c  <= 'd0;\n            reg_operand_o  <= 'd0;\n            reg_control    <= 'd0;\n            reg_wdata_sram <= 'd0;\n            reg_addr_sram  <= 'd0;\n            PRDATA         <= 'd0;\n            PREADY         <= 1'b0;\n            PSLVERR        <= 1'b0;\n        end else if (PENABLE & PSEL) begin\n            // Default value\n            PREADY <= 1'b1;\n\n            // Check addresses\n            if (((reg_control == SRAM_WRITE) || (reg_control == DSP_WRITE_OP_O) || (reg_control == SRAM_READ)) && (sram_addr > 63)) begin\n                PSLVERR <= 1'b1;\n            end else begin\n                case (PADDR)\n                    ADDRESS_A         : PSLVERR <= 1'b0;\n                    ADDRESS_B         : PSLVERR <= 1'b0;\n                    ADDRESS_C         : PSLVERR <= 1'b0;\n                    ADDRESS_O         : PSLVERR <= 1'b0;\n                    ADDRESS_CONTROL   : PSLVERR <= 1'b0;\n                    ADDRESS_WDATA     : PSLVERR <= 1'b0;\n                    ADDRESS_SRAM_ADDR : PSLVERR <= 1'b0;\n                    default           : PSLVERR <= 1'b1;\n                endcase\n            end\n\n            // Internal register operation\n            if (PWRITE) begin\n                case (PADDR)\n                    ADDRESS_A         : reg_operand_a  <= PWDATA;\n                    ADDRESS_B         : reg_operand_b  <= PWDATA;\n                    ADDRESS_C         : reg_operand_c  <= PWDATA;\n                    ADDRESS_O         : reg_operand_o  <= PWDATA;\n                    ADDRESS_CONTROL   : reg_control    <= PWDATA;\n                    ADDRESS_WDATA     : reg_wdata_sram <= PWDATA;\n                    ADDRESS_SRAM_ADDR : reg_addr_sram  <= PWDATA;\n                endcase\n            end else begin\n                if (reg_control == SRAM_READ) begin\n                    PRDATA <= sram_data_out_sync_2;\n                end else begin\n                    case (PADDR)\n                        ADDRESS_A         : PRDATA  <= reg_operand_a;\n                        ADDRESS_B         : PRDATA  <= reg_operand_b;\n                        ADDRESS_C         : PRDATA  <= reg_operand_c;\n                        ADDRESS_O         : PRDATA  <= reg_operand_o;\n                        ADDRESS_CONTROL   : PRDATA  <= reg_control;\n                        ADDRESS_WDATA     : PRDATA  <= reg_wdata_sram;\n                        ADDRESS_SRAM_ADDR : PRDATA  <= reg_addr_sram;\n                    endcase\n                end               \n            end\n        end\n    end\n\n    // CDC synchronization for safe SRAM reads\n    always_ff @(posedge clk_dsp_sel or negedge PRESETn) begin\n        if (!PRESETn) begin\n            sram_data_out_sync_1 <= 'd0;\n            sram_data_out_sync_2 <= 'd0;\n        end else begin\n            sram_data_out_sync_1 <= sram_data_out;\n            sram_data_out_sync_2 <= sram_data_out_sync_1;\n        end        \n    end\n\n    // SRAM logic synchronization\n    always_ff @(posedge clk_dsp_sel) begin\n        sram_data_in <= (reg_control == SRAM_WRITE) ? reg_wdata_sram : dsp_result;\n\n        if ((reg_control == SRAM_WRITE) || (reg_control == DSP_WRITE_OP_O)) begin\n            sram_we <= 1'b1;\n        end else begin\n            sram_we <= 1'b0;\n        end\n\n        case (reg_control)\n            DSP_READ_OP_A  : sram_addr <= reg_operand_a;\n            DSP_READ_OP_B  : sram_addr <= reg_operand_b;\n            DSP_READ_OP_C  : sram_addr <= reg_operand_c;\n            DSP_WRITE_OP_O : sram_addr <= reg_operand_o;\n            default        : sram_addr <= reg_addr_sram;\n        endcase\n    end\n\n    // SRAM operation\n    always_ff @(posedge clk_dsp_sel) begin\n        if (sram_we) begin\n            mem[sram_addr] <= sram_data_in;\n        end else begin\n            sram_data_out <= mem[sram_addr];\n        end\n    end\n    \n    // DSP operation\n    always_ff @(posedge clk_dsp_sel) begin\n        case (reg_control)\n            DSP_READ_OP_A  : dsp_op_a <= sram_data_out;\n            DSP_READ_OP_B  : dsp_op_b <= sram_data_out;\n            DSP_READ_OP_C  : dsp_op_c <= sram_data_out;\n        endcase\n    end\n    \n    assign dsp_result = (dsp_op_a * dsp_op_b) + dsp_op_c;\n\nendmodule"}}, "output": {"response": "", "context": {"verif/tb_apb_dsp_op.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 6-tb-stimulus\nTARGET = 100", "src/apb_dsp_op.sv": "// APB DSP Operation Module\nmodule apb_dsp_op #(\n    parameter ADDR_WIDTH = 'd8,\n    parameter DATA_WIDTH = 'd32\n) (\n    input  logic                  clk_dsp,    // Faster clock to DSP operation\n    input  logic                  en_clk_dsp, // Enable DSP operation with faster clock\n    input  logic                  PCLK,       // APB clock\n    input  logic                  PRESETn,    // Active low asynchronous APB Reset\n    input  logic [ADDR_WIDTH-1:0] PADDR,      // APB address\n    input  logic                  PWRITE,     // Write/Read enable\n    input  logic [DATA_WIDTH-1:0] PWDATA,     // Write data\n    input  logic                  PSEL,       // DSP selector\n    input  logic                  PENABLE,    // APB enable\n    output logic [DATA_WIDTH-1:0] PRDATA,     // Read data\n    output logic                  PREADY,     // Ready signal\n    output logic                  PSLVERR     // Error signal\n);\n\n    // Synchronize en_clk_dsp signal to clk_dsp domain to avoid CDC issues\n    logic clk_dsp_sel;\n    logic en_clk_dsp_ff;\n    logic en_clk_dsp_sync_ff;\n\n    always_ff @(posedge clk_dsp or negedge PRESETn) begin\n        if (!PRESETn) begin\n            en_clk_dsp_ff      <= 1'b0;\n            en_clk_dsp_sync_ff <= 1'b0;\n        end else begin\n            en_clk_dsp_ff      <= en_clk_dsp;\n            en_clk_dsp_sync_ff <= en_clk_dsp_ff;\n        end\n    end\n\n    // Clock selection\n    assign clk_dsp_sel = (en_clk_dsp_ff) ? clk_dsp : PCLK;\n\n    // Internal registers address map\n    localparam ADDRESS_A         = 32'h0;  // 0x00\n    localparam ADDRESS_B         = 32'h4;  // 0x04\n    localparam ADDRESS_C         = 32'h8;  // 0x08\n    localparam ADDRESS_O         = 32'hC;  // 0x0C\n    localparam ADDRESS_CONTROL   = 32'h10; // 0x10\n    localparam ADDRESS_WDATA     = 32'h14; // 0x14\n    localparam ADDRESS_SRAM_ADDR = 32'h18; // 0x18\n\n    // Control modes\n    localparam SRAM_WRITE     = 32'd1;\n    localparam SRAM_READ      = 32'd2;\n    localparam DSP_READ_OP_A  = 32'd3;\n    localparam DSP_READ_OP_B  = 32'd4;\n    localparam DSP_READ_OP_C  = 32'd5;\n    localparam DSP_WRITE_OP_O = 32'd6;\n\n    // Internal APB-side registers\n    logic [DATA_WIDTH-1:0] reg_operand_a;\n    logic [DATA_WIDTH-1:0] reg_operand_b;\n    logic [DATA_WIDTH-1:0] reg_operand_c;\n    logic [DATA_WIDTH-1:0] reg_operand_o;\n    logic [DATA_WIDTH-1:0] reg_control;\n    logic [DATA_WIDTH-1:0] reg_wdata_sram;\n    logic [DATA_WIDTH-1:0] reg_addr_sram;\n\n    // DSP-side pipeline regs and signals\n    logic signed [DATA_WIDTH-1:0] dsp_op_a;\n    logic signed [DATA_WIDTH-1:0] dsp_op_b;\n    logic signed [DATA_WIDTH-1:0] dsp_op_c;\n    logic signed [DATA_WIDTH-1:0] dsp_result;\n\n    // SRAM signals\n    logic [DATA_WIDTH-1:0] sram_data_in;\n    logic                  sram_we;\n    logic [DATA_WIDTH-1:0] sram_addr;\n    logic [DATA_WIDTH-1:0] sram_data_out;\n    logic [DATA_WIDTH-1:0] sram_data_out_sync_1;\n    logic [DATA_WIDTH-1:0] sram_data_out_sync_2;\n    \n    // SRAM local memory\n    logic [DATA_WIDTH-1:0] mem [63:0];\n\n    // APB interface logic\n    always_ff @(posedge PCLK or negedge PRESETn) begin\n        if (!PRESETn) begin\n            reg_operand_a  <= 'd0;\n            reg_operand_b  <= 'd0;\n            reg_operand_c  <= 'd0;\n            reg_operand_o  <= 'd0;\n            reg_control    <= 'd0;\n            reg_wdata_sram <= 'd0;\n            reg_addr_sram  <= 'd0;\n            PRDATA         <= 'd0;\n            PREADY         <= 1'b0;\n            PSLVERR        <= 1'b0;\n        end else if (PENABLE & PSEL) begin\n            // Default value\n            PREADY <= 1'b1;\n\n            // Check addresses\n            if (((reg_control == SRAM_WRITE) || (reg_control == DSP_WRITE_OP_O) || (reg_control == SRAM_READ)) && (sram_addr > 63)) begin\n                PSLVERR <= 1'b1;\n            end else begin\n                case (PADDR)\n                    ADDRESS_A         : PSLVERR <= 1'b0;\n                    ADDRESS_B         : PSLVERR <= 1'b0;\n                    ADDRESS_C         : PSLVERR <= 1'b0;\n                    ADDRESS_O         : PSLVERR <= 1'b0;\n                    ADDRESS_CONTROL   : PSLVERR <= 1'b0;\n                    ADDRESS_WDATA     : PSLVERR <= 1'b0;\n                    ADDRESS_SRAM_ADDR : PSLVERR <= 1'b0;\n                    default           : PSLVERR <= 1'b1;\n                endcase\n            end\n\n            // Internal register operation\n            if (PWRITE) begin\n                case (PADDR)\n                    ADDRESS_A         : reg_operand_a  <= PWDATA;\n                    ADDRESS_B         : reg_operand_b  <= PWDATA;\n                    ADDRESS_C         : reg_operand_c  <= PWDATA;\n                    ADDRESS_O         : reg_operand_o  <= PWDATA;\n                    ADDRESS_CONTROL   : reg_control    <= PWDATA;\n                    ADDRESS_WDATA     : reg_wdata_sram <= PWDATA;\n                    ADDRESS_SRAM_ADDR : reg_addr_sram  <= PWDATA;\n                endcase\n            end else begin\n                if (reg_control == SRAM_READ) begin\n                    PRDATA <= sram_data_out_sync_2;\n                end else begin\n                    case (PADDR)\n                        ADDRESS_A         : PRDATA  <= reg_operand_a;\n                        ADDRESS_B         : PRDATA  <= reg_operand_b;\n                        ADDRESS_C         : PRDATA  <= reg_operand_c;\n                        ADDRESS_O         : PRDATA  <= reg_operand_o;\n                        ADDRESS_CONTROL   : PRDATA  <= reg_control;\n                        ADDRESS_WDATA     : PRDATA  <= reg_wdata_sram;\n                        ADDRESS_SRAM_ADDR : PRDATA  <= reg_addr_sram;\n                    endcase\n                end               \n            end\n        end\n    end\n\n    // CDC synchronization for safe SRAM reads\n    always_ff @(posedge clk_dsp_sel or negedge PRESETn) begin\n        if (!PRESETn) begin\n            sram_data_out_sync_1 <= 'd0;\n            sram_data_out_sync_2 <= 'd0;\n        end else begin\n            sram_data_out_sync_1 <= sram_data_out;\n            sram_data_out_sync_2 <= sram_data_out_sync_1;\n        end        \n    end\n\n    // SRAM logic synchronization\n    always_ff @(posedge clk_dsp_sel) begin\n        sram_data_in <= (reg_control == SRAM_WRITE) ? reg_wdata_sram : dsp_result;\n\n        if ((reg_control == SRAM_WRITE) || (reg_control == DSP_WRITE_OP_O)) begin\n            sram_we <= 1'b1;\n        end else begin\n            sram_we <= 1'b0;\n        end\n\n        case (reg_control)\n            DSP_READ_OP_A  : sram_addr <= reg_operand_a;\n            DSP_READ_OP_B  : sram_addr <= reg_operand_b;\n            DSP_READ_OP_C  : sram_addr <= reg_operand_c;\n            DSP_WRITE_OP_O : sram_addr <= reg_operand_o;\n            default        : sram_addr <= reg_addr_sram;\n        endcase\n    end\n\n    // SRAM operation\n    always_ff @(posedge clk_dsp_sel) begin\n        if (sram_we) begin\n            mem[sram_addr] <= sram_data_in;\n        end else begin\n            sram_data_out <= mem[sram_addr];\n        end\n    end\n    \n    // DSP operation\n    always_ff @(posedge clk_dsp_sel) begin\n        case (reg_control)\n            DSP_READ_OP_A  : dsp_op_a <= sram_data_out;\n            DSP_READ_OP_B  : dsp_op_b <= sram_data_out;\n            DSP_READ_OP_C  : dsp_op_c <= sram_data_out;\n        endcase\n    end\n    \n    assign dsp_result = (dsp_op_a * dsp_op_b) + dsp_op_c;\n\nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/apb_dsp_op.sv /code/verif/tb_apb_dsp_op.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"apb_dsp_op_dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_apb_dsp_unit_0003", "categories": ["cid012", "medium"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `apb_dsp_unit`. The module serves as an APB interface for configuring internal registers. These registers specify which memory addresses are used for arithmetic operations (addition or multiplication). The computed result is then made available through a designated register. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameters, Inputs - Outputs and Functional behavior**\n\n\n---\n\n### Register Descriptions\n\n1. **`r_operand_1`**  \n   - **Address:** 0x0  \n   - **Function:** Holds the memory address of the first operand.\n\n2. **`r_operand_2`**  \n   - **Address:** 0x1  \n   - **Function:** Holds the memory address of the second operand.\n\n3. **`r_Enable`**  \n   - **Address:** 0x2  \n   - **Values:**  \n     - `0`: DSP disabled  \n     - `1`: Addition mode  \n     - `2`: Multiplication mode  \n     - `3`: Data Writing mode  \n\n4. **`r_write_address`**  \n   - **Address:** 0x3  \n   - **Function:** Specifies the address in memory where data will be written.  \n   - **Default Value:** 0x00000000  \n   - **Usage:** If `r_Enable` = 3, the data in the `r_write_data` register is written to the address specified by this register.\n\n5. **`r_write_data`**  \n   - **Address:** 0x4  \n   - **Function:** Specifies the data to be written into memory.  \n   - **Default Value:** 0x00000000  \n   - **Usage:** If `r_Enable` = 3, the data in this register is written to the address specified by `r_write_address`.\n\n---\n\n### APB Interface: \n#### Clock & Reset Signals\n- `pclk`: APB clock input for synchronous operations.  \n- `presetn`: Active-low asynchronous reset signal for system initialization.\n\n#### APB Signals\n- `paddr` (input, 10 bits): Address bus for accessing internal CSR registers and Memory.  \n- `pselx` (input): APB select signal, indicating CSR and Memory selection.  \n- `penable` (input): APB enable signal, marking transaction progression.  \n- `pwrite` (input): Write-enable signal, distinguishing read from write operations, high for write and low for read operation.\n- `pwdata` (input, 8 bits): Write data bus for sending data to CSR registers and Memory.  \n- `pready` (output, reg): Ready signal, indicating the completion of a transaction.  \n- `prdata` (output, reg, 8 bits): Read data bus for retrieving data.  \n- `pslverr` (output, reg): Error signal for invalid addresses or unsupported operations.\n\n### SRAM Interface:\n- `sram_valid`: At positive edge of this signal, data in `r_write_data` is latched to address in `r_write_address`.\n\n---\n\n### APB Protocol\n\n1. **Read Operations**  \n   - In the **READ_STATE**, drive `prdata` with the register value corresponding to `paddr`.\n   - After operation, return to **IDLE**.\n\n2. **Write Operations**  \n   - In the **WRITE_STATE**, update the register selected by `paddr` with `pwdata`.  \n   - After updating the register, return to **IDLE**.\n\n3. **Reset Behavior**  \n   - When `presetn` is deasserted (active-low), reset all outputs and internal registers to their default values:\n     - Set `pready` and `pslverr` to 0.  \n     - Clear `prdata`.  \n     - Initialize `r_operand_1`, `r_operand_2`, `r_Enable`, `r_write_address`, and `r_write_data` to 0.\n\n---\n\n### Functional Behavior\n\n1. **APB Interface Control**  \n   - Memory is accessed via the APB interface.  \n   - The operational mode is controlled by **`r_Enable`**:\n     - **Default (0x0):** DSP is disabled.  \n     - **Write Mode (0x3):** Data can be written to memory.  \n     - **Addition Mode (0x1):** Values at the addresses specified by **`r_operand_1`** and **`r_operand_2`** are added. The result is stored at address **0x5**.  \n     - **Multiplication Mode (0x2):** Values at the addresses specified by **`r_operand_1`** and **`r_operand_2`** are multiplied. The result is stored at address **0x5**.  \n   - To read computed data directly via APB, use address **0x5** and retrieve it through **`PRDATA`**.\n\n2. **Error Handling**  \n   - If a read or write operation is attempted on an address outside the defined registers, **`PSLVERR`** is driven high (`1'b1`).\n\n3. **Wait States**  \n   - This design does not support wait states. All APB read/write operations complete in two clock cycles, with **`PREADY`** always driven high (`1'b1`).\n\n4. **Memory Interface**  \n   - A 1 KB SRAM module serves as the memory.\n\n**Note:** Addresses from **0x00** to **0x05** are reserved for configuration registers.\n\n## Test Bench Requirements\n\n### Stimulus Generation\n\n#### 1. **Reset and Initialization**\n\n1. Drive `presetn` low for a defined interval.\n2. Drive `presetn` high to release reset.\n\n#### 2. **APB Write Stimulus**\n\n1. Access each **valid register** address (`0x0` to `0x4`) with:\n   - `pselx` = 1\n   - `penable` toggled appropriately\n   - `pwrite` = 1\n   - Various `pwdata` patterns (e.g., minimum, maximum, random).\n2. Perform **consecutive writes** to different registers in rapid succession.\n3. Issue a **write** to an **invalid address** (greater than `0x5`).\n4. Attempt memory writes under various `r_Enable` states, including values outside the valid range of modes.\n\n#### 3. **APB Read Stimulus**\n\n1. Read from **each valid register** address (`0x0` to `0x5`) with:\n   - `pselx` = 1\n   - `penable` toggled appropriately\n   - `pwrite` = 0\n2. Perform **back-to-back** reads of the same register and different registers.\n3. Issue a **read** to an **invalid address** (greater than `0x5`).\n4. Vary APB handshake signals, including cases with missing or incorrect enable signals.\n\n#### 4. **DSP Arithmetic Stimulus**\n\n### 4.1 **Addition Mode**\n1. Set `r_Enable` to indicate addition mode.\n2. Provide valid addresses in `r_operand_1` and `r_operand_2` that point to memory locations.\n3. Use data-writing transactions to load different data patterns into those memory addresses.\n4. Include minimal, maximal, and intermediate values to explore potential overflow and boundary conditions.\n\n##### 4.2 **Multiplication Mode**\n1. Set `r_Enable` to indicate multiplication mode.\n2. Provide valid addresses in `r_operand_1` and `r_operand_2`.\n3. Use memory transactions to populate these locations with a variety of patterns.\n4. Include edge cases that might trigger overflow scenarios.\n\n#### 5. **Memory Write Stimulus**\n\n1. Set `r_Enable` to indicate write mode.\n2. Vary `r_write_address` and `r_write_data` across:\n   - Low, high, and random valid addresses.\n   - Low, high, and random data values.\n3. Drive `sram_valid` high to trigger the memory-write mechanism.\n4. Attempt writing beyond the valid memory range.\n\n#### 6. **Error Condition Stimulus**\n\n1. Drive **invalid `r_Enable`** values beyond the defined modes.\n2. Perform APB **read/write operations** without correctly asserting `penable` or `pselx`.\n3. Access invalid or out-of-range addresses with and without proper handshake signals.\n\n#### 7. **Stress and Concurrency Stimulus**\n\n1. Issue **rapid sequences** of APB transactions (reads and writes) to valid and invalid addresses.\n2. Continuously switch `r_Enable` among different modes (addition, multiplication, write, disabled, and any invalid code).\n3. Randomize APB signals (within protocol constraints) to test corner cases of back-to-back operations.\n\n#### 8. **Full Coverage Stimulus**\n\n1. Stimulate **every register** in both read and write directions.\n2. Exercise **all operational modes** defined in the design, plus invalid ones.\n3. Drive memory addresses across the **entire valid range** and some out-of-range values.\n4. Include data patterns that explore arithmetic boundary conditions (such as overflow scenarios).\n\n#### 9. Additional Test Cases for Complete Coverage\n\n##### 9.1. Full Bit Toggling on Registers\n- Write `0xFF` and `0x00` to:\n  - `r_operand_1`\n  - `r_operand_2`\n  - `r_enable`\n  - `r_write_address`\n  - `r_write_data`\n\n##### 9.2. Memory Boundary Testing\n- Write to the **maximum valid memory address** (`10'h3FF` = 1023).\n- Attempt an **out-of-range write** (`10'h401` = 1025) when `r_enable = MODE_WRITE`.\n\n##### 9.3. Repeated Reset to Toggle Related Signals\n- Assert and deassert `presetn` **mid-test** to toggle:\n  - `pready`\n  - `pslverr`\n\n##### 9.4. Out-of-Range Address Read\n- **Read from `10'h401`** after an out-of-range write to verify `PSLVERR`.", "context": {}}, "output": {"response": "", "context": {"verif/tb_apb_dsp_unit.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 3-tb-stimulus\nTARGET = 98", "src/apb_dsp_unit.v": "module apb_dsp_unit (\n    // APB clock & reset\n    input  wire         pclk,\n    input  wire         presetn,  // Active-low reset\n\n    // APB signals\n    input  wire [9:0]   paddr,\n    input  wire         pselx,\n    input  wire         penable,\n    input  wire         pwrite,\n    input  wire [7:0]   pwdata,\n    input  wire         sram_valid,\n    output reg          pready,\n    output reg  [7:0]   prdata,\n    output reg          pslverr\n);\n\n    //---------------------------------------------\n    // Parameter Definitions\n    //---------------------------------------------\n    // Register address map\n    localparam ADDR_OPERAND1     = 10'h0;  // 0x0\n    localparam ADDR_OPERAND2     = 10'h1;  // 0x1\n    localparam ADDR_ENABLE       = 10'h2;  // 0x2\n    localparam ADDR_WRITE_ADDR   = 10'h3;  // 0x3\n    localparam ADDR_WRITE_DATA   = 10'h4;  // 0x4\n    localparam ADDR_RESULT       = 10'h5;  // 0x5 (used for storing DSP results)\n\n    // DSP Modes\n    localparam MODE_DISABLED     = 8'h0;   // DSP disabled\n    localparam MODE_ADD          = 8'h1;   // Addition mode\n    localparam MODE_MULT         = 8'h2;   // Multiplication mode\n    localparam MODE_WRITE        = 8'h3;   // Data Writing mode\n\n    // Memory size (1KB = 1024 bytes)\n    localparam MEM_SIZE          = 1024;\n\n    //---------------------------------------------\n    // Internal Registers (CSR)\n    //---------------------------------------------\n    reg [7:0] r_operand_1;\n    reg [7:0] r_operand_2;\n    reg [7:0] r_enable;\n    reg [7:0] r_write_address;\n    reg [7:0] r_write_data;\n\n    //---------------------------------------------\n    // Memory (1 KB SRAM)\n    //---------------------------------------------\n    reg [7:0] sram_mem [0:MEM_SIZE-1];\n\n    //---------------------------------------------\n    // APB Read/Write Logic\n    //---------------------------------------------\n    wire apb_valid;\n    assign apb_valid = pselx & penable;    // Indicates active APB transaction\n\n    // By spec, no wait states => PREADY always high after reset\n    always @(posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            pready   <= 1'b0;\n            pslverr  <= 1'b0;\n        end else begin\n            // PREADY is always asserted (no wait states) once out of reset\n            pready   <= 1'b1;\n            pslverr  <= 1'b0;\n\n            // If transaction is valid, check address range\n            if (apb_valid) begin\n                if(r_enable==MODE_WRITE) begin\n                    if (paddr > MEM_SIZE) begin\n                        pslverr <= 1'b1;\n                    end\n                end\n                else begin\n                    // Check if address is valid (0x0 through 0x5 are used, everything else => PSLVERR)\n                    if (paddr > ADDR_RESULT) begin\n                        pslverr <= 1'b1;\n                    end\n                end\n            end\n        end\n    end\n\n    // Handle writes to CSR or memory\n    // Note: The design writes immediately in the cycle when penable=1.\n    always @(posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            // Reset all registers\n            r_operand_1    <= 8'h00;\n            r_operand_2    <= 8'h00;\n            r_enable       <= 8'h00;\n            r_write_address<= 8'h00;\n            r_write_data   <= 8'h00;\n        end else begin\n            if (apb_valid && pwrite) begin\n                case (paddr)\n                    ADDR_OPERAND1:     r_operand_1     <= pwdata;\n                    ADDR_OPERAND2:     r_operand_2     <= pwdata;\n                    ADDR_ENABLE:       r_enable        <= pwdata;\n                    ADDR_WRITE_ADDR:   r_write_address <= pwdata;\n                    ADDR_WRITE_DATA:   r_write_data    <= pwdata;\n                    // If the address is outside defined range => PSLVERR is set, no write\n                endcase\n            end\n        end\n    end\n\n    // Handle read from CSR or memory\n    always @(posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            prdata <= 8'h00;\n        end else begin\n            if (apb_valid && !pwrite) begin\n                if(r_enable==MODE_WRITE) begin\n                    prdata <= sram_mem[paddr];\n                end\n                else begin\n                    case (paddr)\n                        ADDR_OPERAND1:     prdata <= r_operand_1;\n                        ADDR_OPERAND2:     prdata <= r_operand_2;\n                        ADDR_ENABLE:       prdata <= r_enable;\n                        ADDR_WRITE_ADDR:   prdata <= r_write_address;\n                        ADDR_WRITE_DATA:   prdata <= r_write_data;\n                        ADDR_RESULT:       prdata <= sram_mem[ADDR_RESULT];  // Read the result from memory[0x5]\n                        default:           prdata <= 8'h00; // Invalid => PSLVERR, but can set prdata to 0\n                    endcase\n                end\n            end else if (!apb_valid) begin\n                // When no valid read, clear prdata (optional behavior)\n                prdata <= 8'h00;\n            end\n        end\n    end\n\n    //---------------------------------------------\n    // SRAM write Behavior\n    //---------------------------------------------\n    always @(posedge sram_valid or negedge presetn) begin\n        if (!presetn) begin\n            // Initialize memory location for result\n            sram_mem[ADDR_RESULT] <= 8'h00;\n        end else begin\n            // If r_Enable = WRITE (0x3), write r_write_data into memory[r_write_address]\n            if (r_enable == MODE_WRITE) begin\n                // Write data to memory at r_write_address\n                sram_mem[r_write_address] <= r_write_data;\n            end\n        end\n    end\n\n    //---------------------------------------------\n    // DSP Functional Behavior\n    //---------------------------------------------\n    always @(posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            // Initialize memory location for result\n            sram_mem[ADDR_RESULT] <= 8'h00;\n        end else begin\n            // If r_Enable = ADD (0x1), add contents of memory[r_operand_1] and memory[r_operand_2]\n            if (r_enable == MODE_ADD) begin\n                sram_mem[ADDR_RESULT] <= sram_mem[r_operand_1] + sram_mem[r_operand_2];\n            end\n            // If r_Enable = MULT (0x2), multiply contents of memory[r_operand_1] and memory[r_operand_2]\n            else if (r_enable == MODE_MULT) begin\n                sram_mem[ADDR_RESULT] <= sram_mem[r_operand_1] * sram_mem[r_operand_2];\n            end\n            // If r_Enable = DISABLED (0x0), no operation\n            // else do nothing\n        end\n    end\n\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/apb_dsp_unit.v /code/verif/tb_apb_dsp_unit.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_apb_history_shift_register_0003", "categories": ["cid012", "medium"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `APBGlobalHistoryRegister`. The register updates synchronously on every gated rising edge of the `history_shift_valid` clock, shifting in predicted outcomes or restoring history on mispredictions. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameters, Inputs - Outputs and Functional behavior**\n\n---\n\n### 1. Interface\n\n#### 1.1 Clock & Reset Signals\n- **`pclk`** (input): APB clock input used for all synchronous operations.  \n- **`presetn`** (input, active-low): Asynchronous reset for system initialization.\n\n#### 1.2 APB Signals\n- **`paddr`** (input, 10 bits): Address bus for accessing internal CSR registers.  \n- **`pselx`** (input): APB select signal, indicates CSR/memory selection.  \n- **`penable`** (input): APB enable signal, marks transaction progression.  \n- **`pwrite`** (input): Write-enable signal. High for writes, low for reads.  \n- **`pwdata`** (input, 8 bits): Write data bus for sending data to CSR registers or memory.  \n- **`pready`** (output, reg): Ready signal, driven high to indicate the end of a transaction.  \n- **`prdata`** (output, reg, 8 bits): Read data bus for retrieving data from the module.  \n- **`pslverr`** (output, reg): Error signal, asserted on invalid addresses.\n\n#### 1.3 History Shift Interface\n- **`history_shift_valid`** (input): On the rising edge of this signal, the values in `control_register` and `train_history` are considered valid and will trigger an update of the predict_history register.\n#### 1.4 Clock Gating Enable\n- **`clk_gate_en`** (input): Signal in domain of `pclk`, which will be toggle only on negative edge of `pclk` to avoid glitches. Assertion of this signal will gate the `pclk` internally to minimize switching power.\n#### 1.4 Status & Interrupt Signals\n- **`history_full`** (output): Indicates if the 8-bit shift register is full (all bits set to 1).\n- **`history_empty`** (output): Indicates if the 8-bit shift register is empty (all bits cleared to 0).\n- **`error_flag`** (output): Indicates detected errors for invalid address.\n- **`interrupt_full`** (output): Asserted high to signal an interrupt when history_full is set.\n- **`interrupt_error`** (output): Asserted high to signal an interrupt when error_flag is set.\n---\n\n### 2. Register Descriptions\n\n1. **`control_register`**  \n   - **Address:** `0x0`  \n   - Bit fields (from LSB to MSB):\n     - `predict_valid` (control_register[0]): Indicates a valid branch prediction.  \n     - `predict_taken` (control_register[1]): Predicted direction of the branch (1 = taken, 0 = not taken).  \n     - `train_mispredicted` (control_register[2]): Indicates a branch misprediction occurred.  \n     - `train_taken` (control_register[3]): Actual direction of the mispredicted branch (1 = taken, 0 = not taken).  \n     - control_register[7:4]: Reserved and will be read 0.\n     - Read and write register.\n2. **`train_history`**  \n   - **Address:** `0x1`  \n   - 7 bits (`train_history[6:0]`) representing the recorded branch history prior to the mispredicted branch.\n   - train_history[7]: Reserved and will be read 0.\n   - Read and write register.\n\n3. **`predict_history`**  \n   - **Address:** `0x2`  \n   - 8-bit register representing the current state of the branch history shift register.\n   - Updated only on the rising edge of `history_shift_valid`.\n   - Can be read via the APB interface (using `prdata`).\n   - Can't be written via APB interface.\n\n---\n\n### 3. Functional Description\n\n#### 3.1 APB Protocol\n\n1. **Read Operations**  \n   - In the **READ_STATE**:  \n     - Drive `prdata` with the register value corresponding to `paddr`.  \n   - After the read completes, return to **IDLE**.\n\n2. **Write Operations**  \n   - In the **WRITE_STATE**:  \n     - Update the register selected by `paddr` with `pwdata`.  \n   - After the write completes, return to **IDLE**.\n\n3. **Reset Behavior**  \n   - When `presetn` is deasserted (active-low):  \n     - Reset `pready` and `pslverr` to 0.  \n     - Clear `prdata`.  \n     - Initialize `control_register` and `train_history` to 0.  \n     - Reset the shift register to zero (`predict_history = 8'b0`).\n\n#### 3.2 APB Interface Control\n\n1. **Basics**  \n   - Registers are accessed via the APB interface using `paddr`.  \n   - To read the computed prediction history, use address **0x2**; the data is returned on `prdata`.\n\n2. **Error Handling**  \n   - If `paddr` does not correspond to a valid register, assert `pslverr` (`1'b1`).\n\n3. **Wait States**  \n   - This design does not support wait states. All read/write operations complete in two clock cycles, and `pready` is always driven high (`1'b1`).\n\n---\n\n### 4. Prediction Update Logic\n\n1. **Normal Update**  \n   - If `predict_valid = 1` and no misprediction occurs (`train_mispredicted = 0`), the shift register updates by shifting in `predict_taken` from the least significant bit (LSB). The youngest branch direction is stored in `predict_history[0]`.\n\n2. **Misprediction Handling**  \n   - If `train_mispredicted = 1`, the shift register is updated synchronously with `history_shift_valid` to load the concatenation of `train_history` (7 bits) with `train_taken` (1 bit). This restores the history state before the mispredicted branch while incorporating the actual outcome of the mispredicted branch.\n\n\n3. **Priority**  \n   - If both `predict_valid` and `train_mispredicted` are asserted simultaneously, `train_mispredicted` takes precedence. The misprediction state overrides any prediction to ensure correct recovery of the pipeline state.\n\n4. **Output Behavior**  \n   - `predict_history` (the shift register) is updated only on the rising edge of `history_shift_valid`.\n   - `history_full` is asserted if predict_history contains all ones (8'hFF) else it will be deasserted.\n   - `history_empty` is asserted if predict_history contains all zeros (8'h00)  else it will be deasserted.\n   - `interrupt_full` is directly driven by history_full.\n   - `interrupt_error` is directly driven by error_flag.\n\nNote: Need not to worry about mixing synchronous (pclk) and asynchronous (history_shift_valid) control which can lead to metastability and timing issues. The history_shift_valid will trigger only in absense of pclk.\n\n## Test Bench Requirements\n\n### Stimulus Generation\n\n## 1. **Reset & Initialization Stimuli**\n\n- **Apply and Release Reset**  \n  1. Deassert the active-low reset (`presetn`) after a certain period while the clock toggles, ensuring all internal registers begin at default states.  \n  2. Keep clock transitions valid during reset deassertion.\n\n---\n\n## 2. **APB Interface Stimuli**\n\n### 2.1 **Valid Register Accesses**\n\n- **Write to Control Register**  \n  1. Present the address corresponding to `control_register` on `paddr`.  \n  2. Drive APB signals (`pselx`, `penable`, `pwrite`) for a valid write transaction.  \n  3. Provide varied data patterns on `pwdata` that affect bits `[3:0]` of `control_register`.\n\n- **Write to Train History Register**  \n  1. Present the address corresponding to `train_history` on `paddr`.  \n  2. Drive valid APB write signals.  \n  3. Send multiple data patterns that affect bits `[6:0]`.\n\n- **Read from Control/Register/Train History/Predict History**  \n  1. Present each valid address in turn (`0x0`, `0x1`, `0x2`).  \n  2. Drive APB signals for read transactions.  \n\n### 2.2 **Invalid Register Access**\n\n- **Access Addresses Beyond Valid Range**  \n  1. Set `paddr` to a value beyond the defined valid set (greater than `0x2`).  \n  2. Drive an APB read or write cycle.  \n\n---\n\n## 3. **Clock Gating Stimuli**\n\n- **Toggle `clk_gate_en`**  \n  1. Drive `clk_gate_en` active and inactive at different moments, including while issuing valid APB transactions.  \n  2. Ensure transitions occur on safe clock edges, demonstrating partial or no internal updates under gating.\n\n---\n\n## 4. **Shift Register Update Stimuli**\n\n### 4.1 **No Update Condition**\n\n- **Drive Control Bits for No-Action**  \n  1. Set `predict_valid` and `train_mispredicted` to inactive states.  \n  2. Pulse the `history_shift_valid` signal.\n\n### 4.2 **Normal Prediction Updates**\n\n- **Drive Valid Prediction**  \n  1. Set `predict_valid` active in `control_register`.  \n  2. Alternate the predicted direction bit (`predict_taken`) across multiple pulses of `history_shift_valid`.  \n  3. Repeat for various patterns of taken/not-taken.\n\n### 4.3 **Misprediction Handling**\n\n- **Restore from Train History**  \n  1. Write desired values into `train_history`.  \n  2. Set `train_mispredicted` active, along with a chosen `train_taken` bit.  \n  3. Drive `history_shift_valid` to force the restore path.\n\n- **Simultaneous Valid Prediction & Misprediction**  \n  1. Set both `predict_valid` and `train_mispredicted` active in the same cycle.  \n  2. Pulse `history_shift_valid`.\n\n---\n\n## 5. **Edge Conditions for the Shift Register**\n\n- **All-Zero to All-One Transitions**  \n  1. Repeatedly provide inputs (via normal prediction or misprediction) so that the shift register transitions from all zeros to all ones.  \n  2. Similarly, drive it back from all ones to all zeros with a series of stimuli.\n\n---\n\n## 6. **Error & Interrupt Stimuli**\n\n- **Trigger Invalid APB Transactions**  \n  1. Provide out-of-range addresses and drive write or read cycles.  \n\n- **Generate Interrupt Conditions**  \n  1. Fill the shift register to all ones (to drive any \u201cfull\u201d interrupt).  \n  2. Cause invalid address access (to drive error interrupt).\n\n---\n\n## 7. **Combined Complex Sequences**\n\n- **Integrated Flow**  \n  1. Begin with reset cycling.  \n  2. Perform valid reads and writes to internal registers.  \n  3. Toggle `clk_gate_en`.  \n  4. Issue valid predictions and a series of mispredictions.  \n  5. Drive the shift register from empty to full.  \n  6. Include at least one invalid address access mid-sequence.  \n\n## 8. **Additional Test Scenarios**  \n\n- **Reset During Operation** \u2013 Ensures the system can reinitialize correctly when reset is asserted dynamically, not just at startup.  \n\n- **Reserved Bit Handling** \u2013 Toggles unused register fields to confirm they remain stable and do not interfere with functionality.  \n\n- **Expanded Address Access** \u2013 Interacts with a broader address range to verify correct handling of both valid and invalid accesses.  \n\n- **Repeated Prediction History Reads** \u2013 Ensures the stored history updates correctly and all bits are exercised across different states.  \n\n- **Response Signal Validation** \u2013 Checks readiness and status transitions across reset, transactions, and different operating conditions.  ", "context": {}}, "output": {"response": "", "context": {"verif/tb_APBGlobalHistoryRegister.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 3-tb-stimulus\nTARGET = 98", "src/APBGlobalHistoryRegister.v": "module APBGlobalHistoryRegister (\n    // APB clock & reset\n    input  wire         pclk,\n    input  wire         presetn,  // Active-low reset\n\n    // APB signals\n    input  wire [9:0]   paddr,\n    input  wire         pselx,\n    input  wire         penable,\n    input  wire         pwrite,\n    input  wire [7:0]   pwdata,\n    input  wire         history_shift_valid,\n    input  wire         clk_gate_en,\n    output reg          pready,\n    output reg  [7:0]   prdata,\n    output reg          pslverr,\n    output reg          history_full,\n    output reg          history_empty,\n    output reg          error_flag,\n    output reg          interrupt_full,\n    output reg          interrupt_error\n);\n\n    //---------------------------------------------\n    // Parameter Definitions\n    //---------------------------------------------\n    // Register address map\n    localparam ADDR_CTRL_REG     = 10'h0;  // 0x0\n    localparam ADDR_TRAIN_HIS    = 10'h1;  // 0x1\n    localparam ADDR_PREDICT_HIS  = 10'h2;  // 0x2\n\n    localparam WIDTH             = 8;\n\n    //---------------------------------------------\n    // Internal Registers (CSR)\n    //---------------------------------------------\n    reg [WIDTH-1:0] control_register;\n    reg [WIDTH-1:0] train_history;\n    reg [WIDTH-1:0] predict_history;\n    //---------------------------------------------\n    // Internal wires\n    //---------------------------------------------\n    wire        predict_valid;\n    wire        predict_taken;\n    wire        train_mispredicted;\n    wire        train_taken;\n    //---------------------------------------------\n    // APB Read/Write Logic\n    //---------------------------------------------\n    wire apb_valid;\n    assign apb_valid = pselx & penable;    // Indicates active APB transaction\n    assign pclk_gated = !clk_gate_en&pclk;\n    // By spec, no wait states => PREADY always high after reset\n    always @(posedge pclk_gated or negedge presetn) begin\n      if (!presetn) begin\n        pready   <= 1'b0;\n        pslverr  <= 1'b0;\n      end else begin\n        // PREADY is always asserted (no wait states) once out of reset\n        pready   <= 1'b1;\n        // If transaction is valid, check address range\n        if (apb_valid) begin\n          // Check if address is valid (0x0 through 0x2 are used, everything else => PSLVERR)\n          if (paddr > ADDR_PREDICT_HIS) begin\n            pslverr <= 1'b1;\n          end\n          else begin\n            pslverr  <= 1'b0;\n          end\n        end\n      end\n    end\n\n    // Handle writes to CSR or memory\n    // Note: The design writes immediately in the cycle when penable=1.\n    always @(posedge pclk_gated or negedge presetn) begin\n      if (!presetn) begin\n        // Reset all registers\n        control_register  <= 0;\n        train_history     <= 0;\n      end else begin\n        if (apb_valid && pwrite) begin\n          case (paddr)\n              ADDR_CTRL_REG:    control_register[3:0]  <= pwdata[3:0];\n              ADDR_TRAIN_HIS:   train_history[6:0]     <= pwdata[6:0];\n              // If the address is outside defined range => PSLVERR is set, no write\n          endcase\n        end\n      end\n    end\n\n    // Handle read from CSR or memory\n    always @(posedge pclk_gated or negedge presetn) begin\n      if (!presetn) begin\n        prdata <= 0;\n      end \n      else begin\n        if (apb_valid) begin\n          case (paddr)\n            ADDR_CTRL_REG:    prdata <= {4'b0,control_register[3:0]};\n            ADDR_TRAIN_HIS:   prdata <= {1'b0,train_history[6:0]};\n            ADDR_PREDICT_HIS: prdata <= predict_history;\n            default:          prdata <= 0; // Invalid => PSLVERR, but can set prdata to 0\n          endcase\n        end\n        else begin\n          // When no valid read, clear prdata\n          prdata <= 0;\n        end\n      end\n    end\n\n\n    //---------------------------------------------\n    // GHSR Behavior\n    //---------------------------------------------\n\n    assign  predict_valid       = control_register[0];     // valid branch prediction\n    assign  predict_taken       = control_register[1];     // predicted direction (1=taken, 0=not taken)\n    assign  train_mispredicted  = control_register[2];     // branch misprediction occurred\n    assign  train_taken         = control_register[3];     // actual branch direction for mispredicted branch\n\n\n\n    always @(posedge history_shift_valid or negedge presetn) begin\n      if (!presetn) begin\n        // 1) active low Asynchronous reset\n        //    Clear the entire history register.\n        predict_history <= 0;\n      end\n      else begin\n        // 2) Misprediction Handling (highest priority)\n        //    If a misprediction is flagged, restore the old history from train_history\n        //    and incorporate the correct outcome (train_taken) as the newest bit.\n        if (train_mispredicted) begin\n          predict_history <= {train_history[WIDTH-2:0], train_taken};\n        end\n        // 3) Normal Prediction Update\n        //    If the prediction is valid and there is no misprediction,\n        //    shift in predict_taken at the LSB (bit[0] is the youngest branch).\n        else if (predict_valid) begin\n          // \"Shifting in from the LSB\" while keeping the newest branch in predict_history[0]\n          // is typically done by moving predict_history[31:1] up one bit\n          // and placing predict_taken in bit[0].\n          predict_history <= {predict_history[WIDTH-2:0], predict_taken};\n        end\n      end\n    end\n    \n    always @(*) begin\n      error_flag=pslverr;\n      interrupt_error=pslverr;\n      if(predict_history==8'hff) begin\n        history_full=1'b1;\n        interrupt_full=1'b1;\n        history_empty=1'b0;\n      end\n      else if (predict_history==8'h00) begin\n        history_full=1'b0;\n        interrupt_full=1'b0;\n        history_empty=1'b1;\n      end\n      else begin\n        history_full=1'b0;\n        interrupt_full=1'b0;\n        history_empty=1'b0;\n      end\n    end\n\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/APBGlobalHistoryRegister.v /code/verif/tb_APBGlobalHistoryRegister.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_asyc_reset_0004", "categories": ["cid012", "easy"], "input": {"prompt": "Create a **testbench** to apply **stimulus** to the `async_reset` module. This module implements an asynchronous reset mechanism along with a countdown counter. The counter initializes to `5'h1F` upon reset and decrements on each clock cycle until reaching zero. The module also provides gated clock and reset release signals based on specific counter thresholds.\n\n---\n\n### **Inputs:**\n\n- `clk`: **Clock input** for driving the module\u2019s sequential logic.\n- `reset`: **Active-high, asynchronous reset signal**. When asserted, the counter resets to `5'h1F`.\n\n### **Outputs:**\n\n- `cnt_q [4:0]`: **5-bit counter output**, representing the current counter value.\n- `gate_clk_o`: **Gated clock output**, enabled when the counter is greater than zero and less than `5'hE`.\n- `release_reset_o`: **Reset release output**, active when the counter is less than `5'h8`.\n\n---\n\n### **Instantiation**\n\nThe testbench must instantiate a single instance of the `async_reset` module:\n\n- **Asynchronous Reset Module (`dut`)**: Instantiated with its default configuration to verify correct counter behavior and reset handling.\n\n---\n\n### **Testbench Requirements**\n\nThe testbench must apply a **wide range of test patterns** to verify the module\u2019s response to various reset and counter conditions:\n\n1. **Clock Generation:**\n   - `clk` must toggle every **5 time units**, ensuring a **10 ns clock period**.\n\n2. **Reset Handling:**\n   - `reset` must be **asserted for multiple clock cycles** before being de-asserted.\n   - The module must correctly initialize `cnt_q` to `5'h1F` when `reset` is de-asserted.\n\n3. **Stimulus Generation Strategy:**\n   - The testbench **must not verify outputs** (only generate inputs).\n   - The following test sequences must be executed:\n     - **Counter decrement sequence**: Verify decrement from `5'h1F` to `0`.\n     - **Mid-count reset**: Apply reset when `cnt_q = 5'hF` and ensure re-initialization.\n     - **Gate clock boundary**: Ensure `gate_clk_o` transitions correctly when `cnt_q` moves from `5'hE` to `5'hD`.\n     - **Release reset boundary**: Validate `release_reset_o` activation when `cnt_q` moves below `5'h8`.\n     - **Counter stability at zero**: Ensure `cnt_q` holds at `0` after reaching the minimum value.\n     - **Reset during critical transitions**: Apply reset at `cnt_q = 5'hE` and `cnt_q = 5'h8`.\n\n4. **Handling Continuous and Edge Cases:**\n   - The testbench must ensure a **full countdown cycle** occurs correctly.\n   - **Edge case transitions** must be included to verify correct signal toggling.\n\n5. **Waveform Generation:**\n   - The testbench must generate a `.vcd` waveform file to allow waveform analysis.\n\n---\n\n### **Coverage and Compliance**\n\n- The testbench must ensure **high coverage** across all counter states and transitions.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n\n---\n\n### **Test Plan Overview**\n\nThe testbench must ensure **comprehensive RTL coverage** by applying:\n\n- **Full counter sequence testing** (from `5'h1F` to `0`).\n- **Timing-based reset checks** (handling valid reset during key transitions).\n- **Mid-count resets** to ensure proper re-initialization.\n- **Boundary conditions** for `gate_clk_o` and `release_reset_o`.\n- **Reset handling** to verify asynchronous behavior and re-initialization integrity.\n\nThis testbench will provide a **comprehensive input stimulus environment** for `async_reset`, ensuring correct operation under various test conditions.\n\n---\n\n### **Note:**\n- The testbench **must only generate stimulus** without verifying outputs.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n- **Ensure the maximum possible input coverage** without adding assertions or comparisons.\n\nCan you implement a **SystemVerilog testbench** with the above stimulus requirements?\n", "context": {}}, "output": {"response": "", "context": {"verif/async_reset_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 4-tb-for-async-reset-rtl\nTARGET = 100", "src/async_reset.sv": "module async_reset (\n  input   logic        clk,\n  input   logic        reset,\n\n  output  logic        release_reset_o,\n  output  logic        gate_clk_o,\n  output  logic [4:0]  cnt_q\n);\n\n// --------------------------------------------------------\n// Asynchronous reset and counter logic\n// --------------------------------------------------------\nalways_ff @(posedge clk or posedge reset) begin\n  if (reset) begin\n    cnt_q <= 5'h1F; // Initialize to 31\n  end else begin\n    if (cnt_q > 0) begin\n      cnt_q <= cnt_q - 1;\n    end else begin\n      cnt_q <= cnt_q; // Hold at 0\n    end\n  end\nend\n\n// --------------------------------------------------------\n// Output assignments\n// --------------------------------------------------------\nassign gate_clk_o      = (cnt_q < 5'hE) && (cnt_q != 0); // (cnt_q < 14) && (cnt_q != 0)\nassign release_reset_o = (cnt_q < 5'h8);                  // (cnt_q < 8)\n\nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_bcd_adder_0007", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench to generate stimulus for the `bcd_adder` module, which performs Binary Coded Decimal (BCD) addition on two 4-bit inputs, a and b. \n\n## Testbench Description\n\n### Inputs\n- Registers: a and b are 4-bit registers that provide the two BCD numbers to be added.\n\n### Outputs\n- The outputs from the BCD adder include a 4-bit sum (`sum`) and a carry-out signal (`cout`).\n\n### Instantiation\n- The bcd_adder module is instantiated as uut, with the input and output signals connected for testing.\n\n## Input Generation \n- Input Data Generation: The testbench generates all possible combinations of a and b in the range from 0 to 9 (since the inputs are BCD digits).\n\n---\nFollows the specification for building the RTL of the module, use it as a reference for the verification environment too:\n\n### Inputs\n- [3:0] a: 4-bit input representing a BCD value.\n- [3:0] b: 4-bit input representing another BCD value.\n\n### Outputs\n- [3:0] sum: 4-bit output representing the BCD-corrected sum of `a` and `b`.\n- cout: Single-bit output indicating if a carry is generated during the BCD addition.\n\n---\n### Design Description\nThe `bcd_adder` module performs Binary Coded Decimal (BCD) addition. It consists of three primary blocks:\n\n1. **Binary Adder:** A 4-bit binary adder calculates the intermediate sum (`binary_sum`) and carry (`binary_cout`).\n2. **Logic Block:** Detects whether BCD correction is needed based on the upper bits of the intermediate binary sum.\n3. **BCD Correction:** If correction is required, adds 6 to the intermediate sum to produce the final BCD-corrected output.\n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_bcd_adder.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro \n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 25ea6d785482e96e616407411d8d1405833db4d9\nTARGET = 95", "src/bcd_adder.sv": "module bcd_adder(                \n                 input  [3:0] a,             // 4-bit BCD input\n                 input  [3:0] b,             // 4-bit BCD input\n                 output [3:0] sum,           // The corrected 4-bit BCD result of the addition\n                 output       cout           // Carry-out to indicate overflow beyond BCD range (i.e., when the result exceeds 9)\n                );\n    \nwire [3:0] binary_sum;         // Intermediate binary sum\nwire binary_cout;              // Intermediate binary carry\nwire z1, z2;                   // Intermediate wires for BCD correction\nwire carry;                    // Carry for the second adder\n   \n// Instantiate the first four-bit adder for Binary Addition\nfour_bit_adder adder1(         \n                      .a(a),            \n                      .b(b),            \n                      .cin(1'b0),       \n                      .sum(binary_sum), \n                      .cout(binary_cout) \n                     );\n       \n// Logic to determine BCD correction condition\nassign z1 = (binary_sum[3] & binary_sum[2]); \nassign z2 = (binary_sum[3] & binary_sum[1]); \nassign cout = (z1 | z2 | binary_cout);        \n\n// Instantiate the second four-bit adder for BCD correction\nfour_bit_adder adder2(         \n                      .a(binary_sum),     \n                      .b({1'b0, cout, cout, 1'b0}), \n                      .cin(1'b0),         \n                      .sum(sum),          \n                      .cout(carry)        \n                     );\n\nendmodule     \n\n\n//module of four_bit_adder\nmodule four_bit_adder(        \n                      input [3:0] a,           // 4-bit input a\n                      input [3:0] b,           // 4-bit input b\n                      input cin,               // Carry input\n                      output [3:0] sum,        // 4-bit sum output\n                      output cout              // Carry output\n                     );\n\n  wire [2:0] carry;         // Intermediate carry wires\n\n  genvar i;                 // Declare a variable for the generate loop\n\n  generate\n    for (i = 0; i < 4; i = i + 1) begin: adder \n\n      if (i == 0) begin\n        // Instantiate the first full adder\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(cin),          \n                       .sum(sum[i]),       \n                       .cout(carry[i])     \n                      );\n      end \n\n      else if (i < 3) begin\n        // Instantiate the full adder for intermediate bits\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(carry[i-1]),   \n                       .sum(sum[i]),       \n                       .cout(carry[i])     \n                      );\n      end\n\n      else begin\n        // Instantiate the last full adder\n        full_adder fa (       \n                       .a(a[i]),           \n                       .b(b[i]),           \n                       .cin(carry[i-1]),   \n                       .sum(sum[i]),       \n                       .cout(cout)         \n                     );\n      end\n    end\n  endgenerate\n\nendmodule     \n\n//module of full_adder\nmodule full_adder(       \n                  input a,     // First Addend input\n                  input b,     // Second Addend input\n                  input cin,   // Carry input\n                  output sum,  // Sum output\n                  output cout  // Carry output\n                );\n                  \n  assign sum = a ^ b ^ cin;                      // Calculate sum using XOR\n  assign cout = (a & b) | (b & cin) | (a & cin); // Calculate carry-out\n  \nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/bcd_adder.sv /code/verif/tb_bcd_adder.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        while len(info) < 3:\n            info.append(\"0%\")\n\n        inst = re.sub(r'[\\W]', '', info[0])\n\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'dut' is missing in the coverage log.\")\n\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))  \n\n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['dut']['Average']}, Target: {target}\"\n\n"}}}
{"id": "cvdp_copilot_binary_search_tree_sorting_0015", "categories": ["cid012", "medium"], "input": {"prompt": "Write a SystemVerilog testbench named `bst_sort_tb` that generates only stimulus for a binary search tree (BST) based sorting algorithm design `binary_search_tree_sort` that processes an array of unsigned integers with a parameterizable size, ARRAY_SIZE (number of elements in the array, will be greater than 0).  The stimulus should be generated for a design that sorts an input array in ascending order using the BST insertion and in-order traversal logic. The sorting process should be driven by control signals and should be tested for various input arrays. \n\nA BST is a data structure where each node has a key, and its left child contains keys less than or equal to the node, while its right child contains keys greater than the node and thereby constructs a tree. The algorithm organizes the integers into a binary search tree and traverses the tree to produce a sorted output array.\n\n### Design Details\n\n**Parameterization**\n\n- **ARRAY_SIZE**: Specifies the number of elements in the input array.\n  - Default: 7\n- **DATA_WIDTH**: Specifies the bit-width of each array element.\n  - Default: 8\n\n**Functionality**\n\n- **Array Processing**:\n The design takes an unsorted array and constructs a binary search tree (BST). It then performs an in-order tree traversal to produce a sorted array. The sorting process is controlled using the start and done signals. The input array, **data_in**, should remain unchanged once the sorting process begins. Any changes to the input during the sorting operation would not be considered.\n\n- **Control Signals**: \n  - **start**: An active-high signal indicating the start of the sorting operation. When asserted, the sorting begins.\n  - **done**: An active-high signal that indicates the sorting operation has been completed. It is asserted after the sorting process is finished.\n  \n**Inputs and Outputs**\n\n**Inputs:**\n\n- **clk**: Clock signal for synchronization. The design is synchronized to the positive edge of this clock.\n- **reset**: Active-high asynchronous reset.When asserted, it immediately resets all outputs (**sorted_out** array and **done**) to zero.\n- **start**: Active-high signal for 1 clock cycle to initiate the sorting process.\n- **data_in [ARRAY_SIZE*DATA_WIDTH-1:0]**: The unsorted input array that will be sorted by the BST-based algorithm.\n\n**Outputs:**\n\n- **done**: An active high signal for 1 clock cycle indicates when the sorting operation is complete.\n- **sorted_out [ARRAY_SIZE*DATA_WIDTH-1:0]**: The sorted array output in ascending order, such that the smallest element is at index 0 and the largest element is at index ARRAY_SIZE-1.\n\n### Requirements:\n\n**Instantiation**\n\n- **Module Instance**: The BST-based sorting module should be instantiated as `dut`, with all input and output signals connected for testing.\n\n**Input Generation and Validation**\n\n- **Array Generation**: The testbench must generate multiple test cases with different values for **data_in**, including edge cases such as an array with all elements the same, an already sorted array, and a reverse-sorted array.\n  \n**Control Signal Handling**:\n\n- The **start** signal should be asserted to trigger the sorting process, and the testbench must wait until the **done** signal is asserted (to wait for the sorting to be completed).\n- The new input **data_in** along with the start signal must only be asserted after the **done**  signal for the previous input array is asserted to high (after **done** asserts and deasserts). This process must be repeated to cover different sequences of input_data. It must be noted that while the done signal is high, the new input **data_in**  and **start** must not be asserted to avoid loss of **start** and new input **data_in**. \n\n**Test Coverage**\n\n- Test with all possible combinations of elements within input array **data_in** via randomization as well as corner cases such as :\n  - **data_in** with all values equal.\n  - **data_in** that is already sorted.\n  - **data_in** in descending order.", "context": {}}, "output": {"response": "", "context": {"verif/bst_sort_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = d9fad48979f519bae3ac26519d78d8dc887a3810\nTARGET = 97\n", "src/binary_search_tree_sort.sv": "module binary_search_tree_sort #(\n    parameter DATA_WIDTH = 32,\n    parameter ARRAY_SIZE = 15\n) (\n    input clk,\n    input reset,\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in, // Input data to be sorted\n    input start,\n    output reg [ARRAY_SIZE*DATA_WIDTH-1:0] sorted_out, // Sorted output\n    output reg done\n);\n\n    // Parameters for top-level FSM states\n    parameter IDLE = 2'b00, BUILD_TREE = 2'b01, SORT_TREE = 2'b10;\n\n    // Parameters for nested FSM states (Build Tree)\n    parameter INIT = 2'b00, INSERT = 2'b01, TRAVERSE = 2'b10, COMPLETE = 2'b11;\n\n    // Parameters for nested FSM states (Sort Tree)\n    parameter S_INIT = 2'b00, S_SORT_LEFT_RIGHT = 2'b01, S_MERGE_RESULTS = 2'b10;\n    // Registers for FSM states\n    reg [1:0] top_state, build_state, sort_state;\n\n    // BST representation\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] data_in_copy;\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys; // Array to store node keys\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child; // Left child pointers\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child; // Right child pointers\n    reg [$clog2(ARRAY_SIZE):0] root; // Root node pointer\n    reg [$clog2(ARRAY_SIZE)-1:0] next_free_node; // Pointer to the next free node\n\n    // Working registers\n    reg [$clog2(ARRAY_SIZE)-1:0] current_node; // Current node being processed\n    reg [$clog2(ARRAY_SIZE):0] input_index; // Index for input data\n    reg [DATA_WIDTH-1:0] temp_data; // Temporary data register\n\n    // Intermediate buffers for storing sorted values of left and right subtrees\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] left_sorted;  // Buffer for left subtree sorted values\n    reg [ARRAY_SIZE*DATA_WIDTH-1:0] right_sorted; // Buffer for right subtree sorted values\n\n    // Stack and pointers for left and right subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_stack; // Stack for left subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_stack; // Stack for right subtree traversal\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_left; // Stack pointer for left subtree\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_right; // Stack pointer for right subtree\n\n    // Current node pointers for left and right subtrees\n    reg [$clog2(ARRAY_SIZE):0] current_left_node; // Current node in left subtree\n    reg [$clog2(ARRAY_SIZE):0] current_right_node; // Current node in right subtree\n\n    // Flags to indicate when sorting of left and right subtrees is done\n    reg left_done; // Flag for completion of left subtree sorting\n    reg right_done; // Flag for completion of right subtree sorting\n\n    // Output indices for left and right subtree buffers\n    reg [$clog2(ARRAY_SIZE)-1:0] left_output_index; // Output index for left_sorted buffer\n    reg [$clog2(ARRAY_SIZE)-1:0] right_output_index; // Output index for right_sorted buffer\n\n    // Initialize all variables\n    integer i, j;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all states and variables\n            top_state <= IDLE;\n            build_state <= INIT;\n            sort_state <= S_INIT;\n            root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; ; // Null pointer\n            next_free_node <= 0;\n            input_index <= 0;\n            done <= 0;\n\n            // Clear tree arrays\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                left_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                right_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n            end\n\n        end \n        else begin\n            case (top_state)\n                IDLE: begin\n                    done <= 0;\n                    input_index <= 0;\n                    root <= {($clog2(ARRAY_SIZE)+1){1'b1}}; ; // Null pointer\n                    next_free_node <= 0;\n                    for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                        keys[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        left_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}}; \n                        right_child[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        left_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        right_sorted[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                        sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= 0;\n                    end\n                    if (start) begin\n                        // Load input data into input array\n                        top_state <= BUILD_TREE;\n                        build_state <= INIT;\n                        data_in_copy <= data_in;\n                    end\n                end\n\n                BUILD_TREE: begin\n                    case (build_state)\n                        INIT: begin\n                            if (input_index < ARRAY_SIZE) begin\n                                temp_data <= data_in_copy[input_index*DATA_WIDTH +: DATA_WIDTH]; \n                                input_index <= input_index + 1;\n                                build_state <= INSERT;\n                            end else begin\n                                build_state <= COMPLETE;\n                            end\n                        end\n\n                        INSERT: begin\n                            if (root == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                // Tree is empty, insert at root\n                                root <= next_free_node;\n                                keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                next_free_node <= next_free_node + 1; \n                                build_state <= INIT;\n                            end else begin\n                                // Traverse the tree to find the correct position\n                                current_node <= root; \n                                build_state <= TRAVERSE;\n                            end\n                        end\n\n                        TRAVERSE: begin      \n                            if ((temp_data < keys[current_node*DATA_WIDTH +: DATA_WIDTH]) || (temp_data == keys[current_node*DATA_WIDTH +: DATA_WIDTH])) begin\n                                if (left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                    left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                                    keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data;\n                                    next_free_node <= next_free_node + 1;\n                                    build_state <= INIT;\n                                end else begin\n                                    current_node <= left_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                                end\n                            end else begin\n                                if (right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin \n                                    right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= next_free_node; \n                                    keys[next_free_node*DATA_WIDTH +: DATA_WIDTH] <= temp_data; \n                                    next_free_node <= next_free_node + 1;\n                                    build_state <= INIT;\n                                end else begin\n                                    current_node <= right_child[current_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]; \n                                end\n                            end\n                        end\n\n                        COMPLETE: begin\n                            // Tree construction complete\n                            top_state <= SORT_TREE;\n                            sort_state <= S_INIT;\n                        end\n\n                    endcase\n                end\n\n                SORT_TREE: begin\n                    case (sort_state)\n                        S_INIT: begin\n                            // Start parallel sorting for left and right subtrees\n                            left_output_index <= 0;\n                            right_output_index <= 0;\n                            sp_left <= 0;\n                            sp_right <= 0;\n                            left_done <= 0;\n                            right_done <= 0;\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            current_right_node <= right_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            sort_state <= S_SORT_LEFT_RIGHT;\n                        end\n\n                        S_SORT_LEFT_RIGHT: begin\n                            // Sort left subtree in parallel\n                            if (!left_done && current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                                sp_left <= sp_left + 1;\n                                current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!left_done && sp_left > 0) begin\n                                sp_left <= sp_left - 1;\n                                current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                left_sorted[left_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH];\n                                left_output_index <= left_output_index + 1;\n                                current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!left_done) begin\n                                left_done <= 1;\n                            end\n\n                            // Sort right subtree in parallel\n                            if (!right_done && current_right_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                right_stack[sp_right*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_right_node;\n                                sp_right <= sp_right + 1;\n                                current_right_node <= left_child[current_right_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!right_done && sp_right > 0) begin\n                                sp_right <= sp_right - 1;\n                                current_right_node <= right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                right_sorted[right_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH];\n                                right_output_index <= right_output_index + 1;\n                                current_right_node <= right_child[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end else if (!right_done) begin\n                                right_done <= 1;\n                            end\n\n                            // Transition to merging once both left and right sorting are done\n                            if (left_done && right_done) begin\n                                sort_state <= S_MERGE_RESULTS;\n                            end\n                        end\n\n                        S_MERGE_RESULTS: begin\n\n                            // Merge left_sorted, root, and right_sorted into final sorted output\n                            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                                if (i < left_output_index) begin\n                                    sorted_out[i*DATA_WIDTH +: DATA_WIDTH] <= left_sorted[i*DATA_WIDTH +: DATA_WIDTH];\n                                end\n                            end\n\n                            // Insert the root into `sorted_out`\n                            sorted_out[left_output_index*DATA_WIDTH +: DATA_WIDTH] <= keys[root*DATA_WIDTH +: DATA_WIDTH];\n\n                            // Copy `right_sorted` into `sorted_out`\n                            for (j = 0; j < ARRAY_SIZE; j = j + 1) begin\n                                if (j < right_output_index) begin\n                                    sorted_out[(left_output_index + 1 + j)*DATA_WIDTH +: DATA_WIDTH] <= right_sorted[j*DATA_WIDTH +: DATA_WIDTH];\n                                end\n                            end\n\n                            done <= 1; // Sorting complete\n                            top_state <= IDLE;\n\n                        end\n\n                        default: begin\n                            sort_state <= S_INIT; // Reset to initial sort state\n                        end\n                    endcase\n                end\n\n                default: begin\n                    top_state <= IDLE; // Default behavior for top-level FSM\n                end\n                \n            endcase\n        end\n    end\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Simulation didn't run correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage merge didn't run correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    try:\n        with open(\"/code/rundir/coverage.log\") as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage.log file.\")\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    print(\"Parsed Metrics:\")\n    print(metrics)\n\n    # Ensure TARGET environment variable is set\n    target = os.getenv(\"TARGET\")\n    if not target:\n        raise ValueError(\"TARGET environment variable is not set.\")\n    target = float(target)\n\n    # Check coverage for the DUT or specific key\n    dut = \"dut\"  # Replace this with the DUT key you want to check\n    if dut in metrics and \"Overall Average\" in metrics[dut]:\n        assert float(metrics[dut][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        # Log available keys for debugging\n        print(f\"Available keys in metrics: {metrics.keys()}\")\n        assert False, f\"Coverage data for '{dut}' is not available.\"\n"}}}
{"id": "cvdp_copilot_binary_search_tree_sorting_0030", "categories": ["cid012", "medium"], "input": {"prompt": "Implement a System Verilog testbench named `binary_search_tree_search_node_tb` to generate stimuli for a `search_binary_search_tree` module that performs a search for a given key in a binary search tree (BST). \n\n## Design Specification:\n\nThe BST is a structure formed where each node contains a key, with its `left_child` containing `keys` less than or equal to the node, and its `right_child` containing `keys` greater than the node. The module locates the position of the `search_key` in the array sorted with the constructed BST. The position where the `search_key` is located is based on its **position in the sorted array** (sorted such that the smallest element is at index 0 and the largest element is at index `ARRAY_SIZE`-1). The array is not sorted in this module. However, the BST is constructed in a way that traversing to the nodes results in a sorted array. The module doesn't wait for the complete BST to be traversed. As soon as the `search_key` is found and its position is located, the module stops its search and transitions to the final state. \n\n**Parameterization**\n\n- **ARRAY_SIZE**: Specifies the number of elements in the input array.\n  - Default: 15\n- **DATA_WIDTH**: Specifies the bit-width of each array element.\n  - Default: 16\n\n### Inputs:\n- `[ARRAY_SIZE*DATA_WIDTH-1:0] keys`: A packed array containing the node values of the BST.\n- `[ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child`: A packed array containing the left child pointers for each node in the BST.\n- `[ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child`: A packed array containing the right child pointers for each node in the BST.\n- `[$clog2(ARRAY_SIZE):0] root`: The index of the root node (always 0 except for an empty BST, assuming the BST is constructed such that the first element in the arrays corresponds to the root node).  For an empty BST, `root` is assigned an invalid index where all bits are set to 1; Eg: 15 (for ARRAY_SIZE = 7) \n- `[DATA_WIDTH-1:0] search_key`: The key to search for in the BST.\n- `start`: 1-Bit active high signal to initiate the search (1 clock cycle in duration).\n- `clk`: Clock Signal. The design is synchronized to the positive edge of this clock.\n- `reset`: Asynchronous active high reset to reset all control signal outputs to zero and `key_position` to null pointer (all 1s).\n\n### Outputs\n- `[$clog2(ARRAY_SIZE):0] key_position`: The position of the `search_key` in the BST with respect to its sorted position. Updated at the same time when the `complete_found` is asserted.  If the `search_key` is not found in the constructed BST or if the tree is empty (indicated by all entries in `left_child`, `right_child` being null pointers, and all `keys` being zero) the module sets all the bits of `key_position` to 1 (null position)\n- `complete_found`: 1-Bit active high signal that is asserted once the search is complete, indicating that the key was found (1 clock cycle in duration). If the `search_key` is not found in the constructed BST or if the tree is empty `complete_found` remains at 0.\n- `search_invalid`: 1-bit Active high signal that is asserted when the BST is empty or when the `search_key` doesn't exist in the given BST (1 clock cycle in duration). \n\n### Testbench Requirements:\n\n**Instantiation**\n\n- **Module Instance**: The module `search_binary_search_tree` should be instantiated as `dut`, with all input and output signals connected for testing.\n\n**Input Generation**\n\n- **BST Generation**: \n    - The testbench must generate multiple test cases with different random values for `keys`, `left_child`, and `right_child` which abides by the structure of the BST where each node contains a key, with its `left_child` containing `keys` less than the node, and its `right_child` containing `keys` greater than the node. \n    - To accurately construct a BST including `keys`, `left_child`, and `right_child`, create a separate submodule that generates different BSTs based on the input array provided. \n    - To generate a BST, different input arrays can be provided as input to the new submodule responsible for constructing the BST.\n    - Test with all possible combinations to achieve maximum coverage. Include the corner cases, such as input arrays with all values equal and already sorted arrays in ascending or descending order.\n    - Testbench must also include a scenario with an empty tree where all bits of `root`, `left_child`, and `right_child` are set to one, and `keys` are set to 0.\n \n- **Search Key (`search_key`) Generation**: \n    - The testbench must generate different random values of `search_key` where the random values generated must be one of the values in the `keys` for a given BST input. To be able to traverse the tree in worst-case scenarios, tests should include `search_key` generation for the smallest, largest value in the given BST. \n    - To handle the invalid case (`search_invalid`), the testbench must generate `search_key`, which is not present within the given BST. \n  \n**Control Signal Handling**:\n\n- The `start` signal should be asserted to trigger the searching process, and the testbench must wait until the `complete_found` signal is asserted (to wait for the searching to be completed) when the search is valid or wait until the `search_invalid` is asserted when the `search_key` is not found within the tree or when the tree is empty. \n- The new inputs `keys`, `left_child`,  `right_child`, and `search_key`  along with the `start` signal must only be asserted after the `complete_found` or `search_invalid` signal for the previous input array is asserted to high. This process must be repeated to cover different sequences of input array, which means different BSTs will be generated. It must be noted that while the `complete_found` or `search_invalid` signal is high, the new input `keys`, `left_child`, `right_child`, `search_key`, and `start` must not be asserted to avoid loss of `start` and new inputs. ", "context": {}}, "output": {"response": "", "context": {"verif/binary_search_tree_search_node_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 30-tb-stimulus-search-node-in-binary-search-tree\nTARGET = 96\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/search_binary_search_tree.sv /code/verif/binary_search_tree_search_node_tb.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/search_binary_search_tree.sv": "module search_binary_search_tree #(\n    parameter DATA_WIDTH = 16,         // Width of the data\n    parameter ARRAY_SIZE = 15          // Maximum number of elements in the BST\n) (\n\n    input clk,                         // Clock signal\n    input reset,                       // Reset signal\n    input reg start,                   // Start signal to initiate the search\n    input reg [DATA_WIDTH-1:0] search_key, // Key to search in the BST\n    input reg [$clog2(ARRAY_SIZE):0] root, // Root node of the BST\n    input reg [ARRAY_SIZE*DATA_WIDTH-1:0] keys, // Node keys in the BST\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child, // Left child pointers\n    input reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child, // Right child pointers\n    output reg [$clog2(ARRAY_SIZE):0] key_position, // Position of the found key\n    output reg complete_found,         // Signal indicating search completion\n    output reg search_invalid\n);\n                                                                                                                                        \n    // Parameters for FSM states\n    parameter S_IDLE = 3'b000,                 // Idle state\n              S_INIT = 3'b001,                 // Initialization state\n              S_SEARCH_LEFT = 3'b010,          // Search in left subtree\n              S_SEARCH_LEFT_RIGHT = 3'b011,    // Search in both left and right subtrees\n              S_COMPLETE_SEARCH = 3'b100;      // Search completion state\n   \n    // Registers to store the current FSM state\n    reg [2:0] search_state;\n\n    // Variables to manage traversal\n    reg [$clog2(ARRAY_SIZE):0] position;       // Position of the current node\n    reg found;                                 // Indicates if the key is found\n\n    reg left_done, right_done;                 // Flags to indicate completion of left and right subtree traversals\n\n    // Stacks for managing traversal of left and right subtrees\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_stack;  // Stack for left subtree traversal\n    reg [ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_stack; // Stack for right subtree traversal\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_left;         // Stack pointer for left subtree\n    reg [$clog2(ARRAY_SIZE)-1:0] sp_right;        // Stack pointer for right subtree\n\n    // Pointers for the current nodes in left and right subtrees\n    reg [$clog2(ARRAY_SIZE):0] current_left_node;  // Current node in the left subtree\n    reg [$clog2(ARRAY_SIZE):0] current_right_node; // Current node in the right subtree\n\n    // Output indices for traversal\n    reg [$clog2(ARRAY_SIZE)-1:0] left_output_index;  // Output index for left subtree\n    reg [$clog2(ARRAY_SIZE)-1:0] right_output_index; // Output index for right subtree\n\n    // Integer for loop iterations\n    integer i;\n\n    // Always block triggered on the rising edge of the clock or reset signal\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all states and variables\n            search_state <= S_IDLE;  // Set state to IDLE\n            found <= 0;              // Reset found flag\n            position <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Invalid position\n            complete_found <= 0;     // Reset complete_found signal\n            key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}}; // Invalid key position\n            left_output_index <= 0;  // Reset left output index\n            right_output_index <= 0; // Reset right output index\n            sp_left <= 0;            // Reset left stack pointer\n            sp_right <= 0;           // Reset right stack pointer\n            left_done <= 0;          // Reset left_done flag\n            right_done <= 0;         // Reset right_done flag\n            search_state <= S_IDLE;  // Set state to IDLE\n            search_invalid <= 0;        // Set invalid_key to 0\n            \n            // Clear the stacks\n            for (i = 0; i < ARRAY_SIZE; i = i + 1) begin\n                left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n            end\n\n        end else begin\n            // Main FSM logic\n            case (search_state)\n                S_IDLE: begin\n                    // Reset intermediate variables\n                    for (i = 0; i < ARRAY_SIZE+1; i = i + 1) begin\n                        left_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        right_stack[i*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                    end\n                    complete_found <= 0;\n                    search_invalid <= 0;\n\n                    if (start) begin\n                        // Start the search\n                        left_output_index <= 0;\n                        right_output_index <= 0;\n                        sp_left <= 0;\n                        sp_right <= 0;\n                        left_done <= 0;\n                        right_done <= 0;\n                        found <= 0;\n                        position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        search_state <= S_INIT; // Move to INIT state\n                        $display(\"ROOT NODE: %0h\", root);\n                    end\n                end\n\n                S_INIT: begin\n                    if (root != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        // Compare the search key with the root key\n                        if (search_key == keys[root*DATA_WIDTH +: DATA_WIDTH]) begin\n                            found <= 1;\n                            if (left_child[0*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] == {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                                position <= 0;\n                                search_state <= S_COMPLETE_SEARCH; // Move to complete search state\n                            end else begin\n                                search_state <= S_SEARCH_LEFT; // Search in the left subtree\n                                current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            end\n                        end else if (keys[0*DATA_WIDTH +: DATA_WIDTH] > search_key) begin\n                            search_state <= S_SEARCH_LEFT;\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else begin\n                            current_left_node <= left_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            current_right_node <= right_child[root*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                            search_state <= S_SEARCH_LEFT_RIGHT; // Search in both left and right subtrees\n                        end\n                    end else begin\n                        search_state <= S_COMPLETE_SEARCH; // Root is null\n                    end\n                end\n\n                S_SEARCH_LEFT: begin\n                    // Traverse the left subtree\n                    if (current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                        sp_left <= sp_left + 1;\n                        current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (sp_left > 0) begin\n                        sp_left <= sp_left - 1;\n                        current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        if (search_key == keys[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]) begin\n                            found <= 1;\n                            position <= left_output_index;   \n                            search_state <= S_COMPLETE_SEARCH; // Move to complete search state\n                        end\n                        left_output_index <= left_output_index + 1;\n                        current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else begin //if (!left_done) begin\n                        if (found == 1) begin\n                            position <= left_output_index;\n                        end \n                        left_done <= 1;\n                        search_state <= S_COMPLETE_SEARCH;\n                    end\n                end\n\n                S_SEARCH_LEFT_RIGHT: begin\n                    // Traverse both left and right subtrees\n                    if (!left_done && current_left_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                        left_stack[sp_left*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_left_node;\n                        sp_left <= sp_left + 1;\n                        current_left_node <= left_child[current_left_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done && sp_left > 0) begin\n                        sp_left <= sp_left - 1;\n                        current_left_node <= left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        left_output_index <= left_output_index + 1;\n                        current_left_node <= right_child[left_stack[(sp_left - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                    end else if (!left_done) begin\n                        left_done <= 1;\n                    end\n\n                    if (!found) begin\n                        if (!right_done && current_right_node != {($clog2(ARRAY_SIZE)+1){1'b1}}) begin\n                            right_stack[sp_right*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)] <= current_right_node;\n                            sp_right <= sp_right + 1;\n                            current_right_node <= left_child[current_right_node*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else if (!right_done && sp_right > 0) begin\n                            sp_right <= sp_right - 1;\n                            current_right_node <= right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                                if (search_key == keys[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*DATA_WIDTH +: DATA_WIDTH]) begin\n                                    found <= 1;\n                                end\n                            right_output_index <= right_output_index + 1;\n                            current_right_node <= right_child[right_stack[(sp_right - 1)*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)]*($clog2(ARRAY_SIZE)+1) +: ($clog2(ARRAY_SIZE)+1)];\n                        end else if (!right_done) begin\n                            right_done <= 1;\n                        end\n\n                    end else if (left_done) begin\n                        position <= left_output_index + right_output_index;\n                        search_state <= S_COMPLETE_SEARCH;  \n                    end\n\n                    if (right_done && left_done && !found) begin\n                        search_state <= S_COMPLETE_SEARCH;\n                    end\n                end\n\n                S_COMPLETE_SEARCH: begin\n                    // Complete the search\n                    if (!found) begin\n                        complete_found <= 0;\n                        key_position <= {($clog2(ARRAY_SIZE)+1){1'b1}};\n                        search_invalid <= 1;\n                    end else begin\n                        complete_found  <= 1;\n                        key_position <= position;\n                        search_invalid <= 0;\n                    end\n                    search_state <= S_IDLE; // Return to IDLE state\n                end\n\n                default: begin\n                    search_state <= S_IDLE; // Default to IDLE state\n                end\n            endcase\n        end\n    end\n\nendmodule\n"}}}
{"id": "cvdp_copilot_binary_to_BCD_0030", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench for `binary_to_bcd` module, which converts an 8-bit binary input into a 12-bit BCD output using the Double Dabble algorithm, ensuring correct shifting, adjustment, and final conversion while validating that each BCD digit remains within the valid range (0-9). The testbench must have the instantiation of RTL module and generate stimulus for various test conditions.\n\n___\nThe interface of `binary_to_bcd` RTL module is given below:\n\n**Input:**\n  - `binary_in` [7:0] [8-Bit]: The binary number to be converted into BCD.\n  \n**Output:**\n  - `bcd_out` [11:0] [12-Bit]: The corresponding BCD output where each 4-bit group represents a decimal digit.\n\n___\n\n### Input Generation and Validation\n**Input Generation:**\n\n1. Fixed Test Cases:\n    - Test a variety of binary inputs, including boundary values, random values, and power-of-two values to validate correct behavior.\n    - Example test values: `0`, `1`,`9`, `10`, `15`, `45`, `99`, `123`, `200`, `255`.\n2. Randomized Testing:\n    - Generate random binary values within the range `0\u2013255` and compare against a reference function.\n\n3. Edge Cases:\n    - Minimum input (`binary_in = 0`):  BCD output `0000 0000 0000` (0).\n    - Maximum input (`binary_in = 255`):  BCD output `0010 0101 0101` (255).\n    - Near-boundary conditions (`binary_in` = `9`, `10`, `99`, `100`, `199`) to verify correct BCD adjustments.\n\n___\n### Instantiation\nName the instance of RTL as `uut`.\n\n##\n### Module Functionality\n**Shift and Adjust Logic:**\n  - Shift Register:\n    - The module uses a 20-bit shift register where the lower 8 bits hold the binary input, and the upper 12 bits store the BCD result.\n  - Adjustment Condition (`>= 5`):\n    - Before each shift, BCD digits are checked; if `\u2265 5`, `+3` is added to prevent invalid values.\n  - Final Output Extraction:\n    - After 8 shifts, the upper 12 bits of the shift register (`shift_reg[19:8]`) contain the final BCD result.", "context": {}}, "output": {"response": "", "context": {"verif/tb_binary_to_bcd.sv": ""}}, "harness": {"files": {"docker-compose.yml": "\nservices:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = d9425cbf44311ca8ccf0b0f82c28e8097057c086\nTARGET = 90\n", "src/binary_to_bcd.sv": "`timescale 1ns / 1ps\n\nmodule binary_to_bcd (\n    input logic [7:0] binary_in,  // 8-bit binary input\n    output logic [11:0] bcd_out  // 12-bit BCD output (3 digits)\n);\n\n  // Intermediate shift register to hold binary and BCD values\n  logic [19:0] shift_reg;  // 20-bit register: 12 for BCD and 8 for binary input\n  integer i;\n\n  always_comb begin\n    // Step 1: Initialize the shift register\n    shift_reg = {12'd0, binary_in};  // Concatenate 12 zeros and binary input\n\n    // Step 2: Perform the Double Dabble process\n    for (i = 0; i < 8; i = i + 1) begin\n      // Check if each BCD digit is 5 or greater; if so, add 3\n      if (shift_reg[11:8] >= 5) shift_reg[11:8] = shift_reg[11:8] + 3;\n      if (shift_reg[15:12] >= 5) shift_reg[15:12] = shift_reg[15:12] + 3;\n      if (shift_reg[19:16] >= 5) shift_reg[19:16] = shift_reg[19:16] + 3;\n\n      // Shift the entire register left by 1 bit\n      shift_reg = shift_reg << 1;\n    end\n\n    // Step 3: Assign the upper 12 bits of the shift register to BCD output\n    bcd_out = shift_reg[19:8];\n  end\n\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\r\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\r\nimport re\r\nimport subprocess\r\nimport pytest\r\n\r\n# ----------------------------------------\r\n# - Simulate\r\n# ----------------------------------------\r\n\r\n@pytest.mark.usefixtures(scope='session')\r\ndef test_simulate():\r\n\r\n    cmd = \"xrun -coverage all /src/binary_to_bcd.sv /code/verif/tb_binary_to_bcd.sv -covtest test -seed random -covoverwrite\"\r\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\r\n\r\n# ----------------------------------------\r\n# - Generate Coverage\r\n# ----------------------------------------\r\n\r\n@pytest.mark.usefixtures(scope='test_simulate')\r\ndef test_coverage():\r\n\r\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\r\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\r\n\r\n# ----------------------------------------\r\n# - Report\r\n# ----------------------------------------\r\n\r\n@pytest.mark.usefixtures(scope='test_coverage')\r\ndef test_report():\r\n\r\n    metrics = {}\r\n\r\n    with open(\"/code/rundir/coverage.log\") as f:\r\n        lines = f.readlines()\r\n\r\n    # ----------------------------------------\r\n    # - Evaluate Report\r\n    # ----------------------------------------\r\n\r\n    for line in lines[2:]:\r\n        info = line.split()\r\n\r\n        inst = info [0]\r\n        avg  = info [1]\r\n        cov  = info [2]\r\n\r\n        inst = re.sub(r'[\\W]', '', inst)\r\n\r\n        metrics [inst] = {\r\n            \"Average\" : float(avg[:-1]),\r\n            \"Covered\" : float(cov[:-1])\r\n        }\r\n\r\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_cdc_pulse_synchronizer_0017", "categories": ["cid012", "easy"], "input": {"prompt": "Complete the given SystemVerilog testbench for the `cdc_pulse_synchronizer` module. The testbench currently instantiates the UUT and should include a stimulus generator (`stimulus_generator`) that dynamically produces a wide range of test scenarios to ensure 100% functional and code coverage. The stimulus generator should validate the design under various conditions, including the below module functionality.\n\n---\n## Description\n\n### Inputs\n\n  - `src_clock`: Source clock signal driving the source domain(positive edge triggered). \n  - `des_clock`: The destination clock signal drives the destination domain(positive edge triggered).\n  - `rst_in`: The Asynchronous reset signal (active high) to reset the synchronizer.\n  - `src_pulse`: The input pulse signal is generated in the source clock domain. High for one clock cycle.\n\n### Outputs\n\n  - `des_pulse`: Synchronized pulse output in the destination clock domain. High for one des_clock cycle.\n\n\n## Input Generation\n\n### Input Generation\n\n- **Clock Frequencies**:\n  - Generate random frequencies for `src_clock` and `des_clock` to cover a wide range, including:\n    - Low frequencies (e.g., 1 MHz).\n    - High frequencies (e.g., 250 MHz).\n    - Closely matched frequencies (e.g., 90 MHz vs. 100 MHz).\n    - Extreme frequency disparities (e.g., 1 MHz vs. 100 MHz).\n\n- **Random Scenarios**:\n  - Create diverse patterns for `src_pulse`, such as:\n    - Random Frequencies.\n\n- **Reset Behavior**:\n  - Apply resets during various states, including:\n    - Idle state.\n    - Active pulse synchronization.\n    - Clock alignment and misalignment scenarios.\n\n---\n\nFollows the specification for building the RTL of the module, use it as a reference for the verification environment too:\n\n## Module Functionality\n\n1. **Pulse Synchronization**:\n   - The module uses a toggle flip-flop mechanism in the source domain and a double flip-flop synchronizer in the destination domain to synchronize `src_pulse` with `des_clock`.\n\n2. **Reset Behavior**:\n   - When `rst_in` is asserted, all internal states (`pls_toggle`, `pls_toggle_synca`, `pls_toggle_syncb`, and `pls_toggle_syncc`) are cleared to zero, ensuring proper initialization.\n\n3. **Edge Cases**:\n   - Correct synchronization under extreme clock frequency mismatches.\n   - Reset during pulse synchronization and at random intervals.\n\n---\n```verilog\nmodule tb_cdc_pulse_synchronizer;\n\n    // Testbench signals\n    logic src_clock;\n    logic des_clock;\n    logic rst_in;\n    logic src_pulse;\n    logic des_pulse;\n\n    // Instantiate the DUT\n    cdc_pulse_synchronizer uut (\n        .src_clock(src_clock),\n        .des_clock(des_clock),\n        .rst_in(rst_in),\n        .src_pulse(src_pulse),\n        .des_pulse(des_pulse)\n    );\n\n    // Insert the code here to generate stimulus generation logic\n\nendmodule\n```", "context": {}}, "output": {"response": "", "context": {"verif/tb_cdc_pulse_synchronizer.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = f1c831e3c00dea1a289c5a4754b9079cf5db6efb\nTARGET = 100\n", "src/cdc_pulse_synchronizer.sv": "module cdc_pulse_synchronizer (\n    input  logic src_clock,   // Source Clock Domain\n    input  logic des_clock,   // Destination Clock Domain\n    input  logic rst_in,      // Reset\n    input  logic src_pulse,   // Source Pulse\n    output logic des_pulse    // Destination Pulse\n);\n\n    logic pls_toggle;      \n    logic pls_toggle_synca;\n    logic pls_toggle_syncb;\n    logic pls_toggle_syncc;\n\n    //--------------------------------------------------\n    //   Toggle Flop Circuit\n    //---------------------------------------------------\n\n    always_ff @(posedge src_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle <= 1'b0;\n        end else if (src_pulse) begin\n            pls_toggle <= ~pls_toggle;\n        end else begin\n            pls_toggle <= pls_toggle;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Double Flop Bit Synchronizer\n    //---------------------------------------------------\n\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle_synca <= 1'b0;\n            pls_toggle_syncb <= 1'b0;\n        end else begin\n            pls_toggle_synca <= pls_toggle;\n            pls_toggle_syncb <= pls_toggle_synca;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Delay Logic of Output signal\n    //---------------------------------------------------\n\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle_syncc <= 1'b0;\n        end else begin\n            pls_toggle_syncc <= pls_toggle_syncb;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Assign Statement for posedge and negedge detection\n    //---------------------------------------------------\n\n    assign des_pulse = pls_toggle_syncc ^ pls_toggle_syncb;\n\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_cellular_automata_0002", "categories": ["cid012", "easy"], "input": {"prompt": "Complete the given partial System Verilog testbench `tb_pseudoRandGenerator_ca`.The testbench must instantiate the `pseudoRandGenerator_ca`  RTL module and provide input stimulus for it, focusing exclusively on generating test vectors rather than building a full testbench.\nThe `pseudoRandGenerator_ca` module simulates a simple pseudo-random number generator using a cellular automata algorithm with a 16-bit seed input.\n\n## Description:\n### **Inputs** :\n\nRegisters :\n`CA_out` (16-bit,[15:0]): 16-bit pseudo-random output received from the **DUT**.\n\n### **Outputs** :\n\nRegisters :\n`clock (1-bit)`: Posedge Clock signal that toggles every 10ns (100 MHz) supplied to the **DUT** \n`reset (1-bit)`: Active-high synchronous reset signal that resets the output  of **DUT** to the initial seed value\n`CA_seed` (16-bit,[15:0]): 16-bit seed value for initializing the cellular automata **DUT**.\n\n## **Instantiation**:\nThe testbench instantiates the `pseudoRandGenerator_ca` module as dut and connects the signals between the module and the testbench. Each input and output from the **DUT** is connected to its corresponding signal in the testbench.\n\n## **Input Generation and Validation**:\n**Clock Generation**: \nThe clock signal clock is generated using an always block that toggles the clock every 10ns.\n\n**Reset**: \nThe reset signal reset is asserted at the beginning of the simulation to ensure the DUT initializes to the correct seed. After a short period (150ns), the reset is de-asserted.\n\n**Stimulus**: \nMultiple test cases are applied to simulate various initial seed values for the Cellular Automata algorithm. The output from the DUT is monitored to ensure the proper sequence of pseudo-random numbers is generated.\n \n-  **Test Case 1:**\n         **CA_Seed**: 16'hA5A5\n         This case tests the cellular automata algorithm with a specific seed to observe the random output.\n-  **Test Case 2:**\n         **CA_Seed**: 16'h3C3C\n         This case tests a different seed to ensure the correct random sequence is generated.\n-  **Test Case 3:**\n          **CA_Seed**: 16'h1234\n          This case checks the behavior of the generator with a hexadecimal seed value.\n-  **Test Case 4:**\n          **CA_Seed**: 16'h4444\n           This case evaluates the algorithm with another specific seed.\n-  **Test Case 5:**\n           **CA_Seed**: 16'h5BEF\n           Testing with a random 16-bit seed value to observe variation in the random output.\n-  **Test Case 6:**\n           **CA_Seed**: 16'h0001\n           Verifies edge case where the seed is the smallest non-zero value.\n-  **Test Case 7:**\n          **CA_Seed**: 16'hFFFF\n          Verifies the upper boundary seed to ensure the algorithm handles high values correctly.\n-  **Test Case 8:**\n           CA_Seed: 16'hAAAA\n           Verifies the cellular automata's ability to handle seeds with alternating bits.\n-  **Test Case 9:**\n            **CA_Seed**: 16'h5555\n            Similar to the previous case, but with alternating low/high bits.\n\n\n## **Reset Handling**:\nAfter running the test cases, a reset is asserted again to ensure the generator is properly reset to its initial seed state and the output is as expected.\n\n**Partial Test Stimulus Generator Code** :\n```verilog\nmodule tb_pseudoRandGenerator_ca;\n\nlogic clk;\nlogic reset;\nlogic [15:0] CA_seed;      // 16-bit seed input\nlogic [15:0] CA_out;       // 16-bit output for Cellular Automata\n\n\npseudoRandGenerator_ca dut (\n    .clock(clk),       \n    .reset(reset),     \n    .CA_seed(CA_seed), \n    .CA_out(CA_out)    \n);\n\n\nalways begin\n    #10 clk = ~clk; \nend\n\n\ntask initialization();\n    begin\n        clk = 1'b0;\n        reset = 1'b1;  \n        CA_seed = 16'hA5A5;  \n    end\nendtask\n\n\ntask drive_reset();\n    begin\n        reset = 1'b1;  \n    end\nendtask\n\n\ntask clear_reset();\n    begin\n        reset = 1'b0;  \n    end\nendtask\n\n\ntask run_test_case(input [15:0] test_seed);\n    begin\n        CA_seed = test_seed;  \n        #1000;                \n        $display(\"Test case with seed %h finished\", test_seed);\n    end\nendtask\n\n\ninitial begin\n    $dumpfile(\"tb_pseudoRandGenerator_ca.vcd\");\n    $dumpvars(0, tb_pseudoRandGenerator_ca);  \n\n    initialization();  \n    #150;\n    clear_reset();\n    run_test_case(16'hA5A5);  \n    // Insert the code for the remaining test cases here\n```    \n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_pseudoRandGenerator_ca.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = fcc6f07e2b215bcbd7f1090a50190bceefbecb13\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n        \n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n", "src/pseudoRandGenerator_ca.sv": "module pseudoRandGenerator_ca (\n    input  logic       clock,    // Clock input\n    input  logic       reset,    // Active-high synchronous Reset\n    input  logic [15:0] CA_seed,  // 16-bit Cellular Automata seed\n    output logic [15:0] CA_out    // 16-bit Cellular Automata output\n);\n\n    logic q1, q2, q3, q4, q5, q6, q7, q8;\n    logic q9, q10, q11, q12, q13, q14, q15, q16;\n\n    assign q1  = CA_out[14];                             \n    assign q2  = CA_out[15] ^ CA_out[13];                \n    assign q3  = CA_out[14] ^ CA_out[13] ^ CA_out[12];   \n    assign q4  = CA_out[13] ^ CA_out[11];                \n    assign q5  = CA_out[12] ^ CA_out[11] ^ CA_out[10];   \n    assign q6  = CA_out[11] ^ CA_out[9];                 \n    assign q7  = CA_out[10] ^ CA_out[9] ^ CA_out[8];     \n    assign q8  = CA_out[9] ^ CA_out[7];                  \n    assign q9  = CA_out[8] ^ CA_out[7] ^ CA_out[6];      \n    assign q10 = CA_out[7] ^ CA_out[5];                  \n    assign q11 = CA_out[6] ^ CA_out[5] ^ CA_out[4];      \n    assign q12 = CA_out[5] ^ CA_out[3];                  \n    assign q13 = CA_out[4] ^ CA_out[3] ^ CA_out[2];      \n    assign q14 = CA_out[3] ^ CA_out[1];                  \n    assign q15 = CA_out[2] ^ CA_out[1] ^ CA_out[0];      \n    assign q16 = CA_out[1];                              \n\n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            CA_out <= CA_seed;\n        end else begin\n            CA_out[15] <= q1;\n            CA_out[14] <= q2;\n            CA_out[13] <= q3;\n            CA_out[12] <= q4;\n            CA_out[11] <= q5;\n            CA_out[10] <= q6;\n            CA_out[9]  <= q7;\n            CA_out[8]  <= q8;\n            CA_out[7]  <= q9;\n            CA_out[6]  <= q10;\n            CA_out[5]  <= q11;\n            CA_out[4]  <= q12;\n            CA_out[3]  <= q13;\n            CA_out[2]  <= q14;\n            CA_out[1]  <= q15;\n            CA_out[0]  <= q16;\n        end\n    end\n\nendmodule"}}}
{"id": "cvdp_copilot_concatenate_0003", "categories": ["cid012", "easy"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `enhanced_fsm_signal_processor` module by applying exhaustive test scenarios. The module uses a finite state machine (FSM) to manage signal processing operations, handle fault conditions, and report the FSM's current status. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage. The testbench should not create checkers to verify the MUT.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameter Inputs - Outputs and Functional behaviour**\n\n### **Inputs**  \n- `i_clk`: Clock signal for sequential operation.  \n- `i_rst_n`: Active-low reset signal that resets the FSM and clears outputs.  \n- `i_enable`(1 bit): Enable signal to start processing; when low, the FSM remains in IDLE.  \n- `i_clear`(1 bit): Signal to clear outputs and reset the fault state.  \n- `i_ack`(1 bit): Acknowledgment signal to transition the FSM from READY to IDLE after processing is complete. It will be a pulse of 1 clock cycle. \n- `i_fault`(1 bit): Signal indicating a fault condition during operation.  \n- `i_vector_1`: 5-bit input vector.  \n- `i_vector_2`: 5-bit input vector.  \n- `i_vector_3`: 5-bit input vector.  \n- `i_vector_4`: 5-bit input vector.  \n- `i_vector_5`: 5-bit input vector.  \n- `i_vector_6`: 5-bit input vector.  \n\n### **Outputs**  \n- `o_ready`(1 bit): Signal that indicates when outputs are valid and processing is complete. Default 0.\n- `o_error`(1 bit): Signal that asserts when a fault condition is detected. Default 0.\n- `o_fsm_status`(2 bits): Current FSM state, encoded as a 2-bit signal, representing one of the FSM states: IDLE(00), PROCESS(01), READY(10), or FAULT(11). Default is IDLE.\n- `o_vector_1`: 8-bit output vector. Default 0.\n- `o_vector_2`: 8-bit output vector. Default 0.\n- `o_vector_3`: 8-bit output vector. Default 0.\n- `o_vector_4`: 8-bit output vector. Default 0.\n\n---\n\n### **FSM States and Functionality**  \n\n#### **States**  \n1. **IDLE**:  \n   - Default state. \n   - FSM waits for `i_enable` to assert high to transition to PROCESS. \n   - If `i_fault` is detected, FSM transitions to FAULT.  \n\n2. **PROCESS**:  \n   - Concatenates six 5-bit input vectors into a single 30-bit bus, appends two `1` bits at the LSB to form a 32-bit bus, and splits it into four 8-bit output vectors.  \n   - `o_vector_1` to `o_vector_4` maps from MSB to LSB of concatenation bus.\n   - If `i_fault` is detected during this state, FSM transitions to FAULT.  \n\n3. **READY**:  \n   - Indicates processing is complete by asserting `o_ready`.  \n   - FSM waits for `i_ack` to transition back to IDLE.  \n   - If `i_fault` is detected, FSM transitions to FAULT.  \n\n4. **FAULT**:  \n   - Asserts `o_error` to indicate a fault condition.  \n   - Outputs are set to default.\n   - FSM transitions to IDLE only when `i_clear` is asserted and `i_fault` is deasserted.\n\n---\n\n### **Operational Rules**  \n- The FSM must progress through states sequentially, synchronized to `i_clk`.  \n- When `i_rst_n` is low, FSM resets to IDLE, clears outputs, and resets the fault state.  \n- When in FAULT, the `i_clear` signal must clear the fault condition and reset the FSM to IDLE.  \n- Outputs (`o_vector_1`, `o_vector_2`, `o_vector_3`, `o_vector_4`) must strictly adhere to the concatenation and splitting logic specified.  \n- Fault handling (`o_error` and FAULT state) must take precedence over other operations.  \n- All the outputs are synchronous to `i_clk`.\n- `i_fault` always take precedence over any other input except `i_clk` and `i_rst_n`.\n- All the input are synchronous to `i_clk`.\n\n## Stimulus Generation\n\n### **Test Case 1: Reset and Idle Check**\n\n- **Stimulus**  \n  1. `i_rst_n=0` (active-low reset), `i_enable=0`, `i_clear=0`, `i_ack=0`, `i_fault=0`  \n  2. Release reset: `i_rst_n=1`\n\n---\n\n### **Test Case 2: Basic Enable \u2192 Process \u2192 Ready \u2192 Acknowledge \u2192 Idle**\n\n- **Stimulus**  \n  1. From IDLE, set example inputs (five-bit vectors).  \n     - For instance:\n       - `i_vector_1 = 5'b00111`\n       - `i_vector_2 = 5'b01010`\n       - `i_vector_3 = 5'b10101`\n       - `i_vector_4 = 5'b11100`\n       - `i_vector_5 = 5'b00001`\n       - `i_vector_6 = 5'b11000`\n  2. `i_enable=1` \u2192 transitions to PROCESS.  \n  3. After one PROCESS cycle, FSM moves to READY (`o_ready=1`).  \n  4. Pulse `i_ack=1` \u2192 returns FSM to IDLE.\n\n---\n\n### **Test Case 3: Fault in IDLE State**\n\n- **Stimulus**  \n  1. FSM in IDLE (`i_enable=0`, etc.).  \n  2. Assert `i_fault=1`.\n\n- **Sample Input Vectors**  \n  - Can be any values;\n\n---\n\n### **Test Case 4: Fault in PROCESS State**\n\n- **Stimulus**  \n  1. From IDLE, assert `i_enable=1` to enter PROCESS.  \n  2. While in PROCESS, assert `i_fault=1`.\n\n- **Sample Input Vectors**  \n  - Similar to Test Case 2 or any other 5-bit patterns;\n\n\n---\n\n### **Test Case 5: Fault in READY State**\n\n- **Stimulus**  \n  1. Complete a normal PROCESS \u2192 READY cycle.  \n  2. While `o_ready=1`, assert `i_fault=1`.\n  3. Hold the FSM is explicitly in the READY state by not asserting i_ack immediately, then i_fault is pulsed. This ensures that the READY -> FAULT transition is covered.\n\n- **Sample Input Vectors**  \n  - Use any 5-bit patterns leading into READY. Then trigger fault.\n\n\n---\n\n### **Test Case 6: Clear from FAULT State**\n\n- **Stimulus**  \n  1. Enter FAULT (any prior scenario).  \n  2. Assert `i_clear=1` but keep `i_fault=1` \u2192 still in FAULT.  \n  3. Deassert `i_fault=0` (with `i_clear=1`) \u2192 FSM \u2192 IDLE.\n\n- **Sample Input Vectors**  \n  - Irrelevant once in FAULT; \n\n---\n\n### **Test Case 7: Repeated Enable Pulses**\n\n- **Stimulus**  \n  1. Rapidly toggle `i_enable` (1\u21920\u21921\u21920) starting from IDLE.  \n  2. Check FSM behavior in PROCESS or READY; it should ignore extra enables.\n\n- **Sample Input Vectors**  \n  - Use any stable 5-bit inputs;\n---\n\n### **Test Case 8: Repeated Fault Pulses**\n\n- **Stimulus**  \n  1. Cause a FAULT (any state).  \n  2. Rapidly toggle `i_fault` high/low without clearing.\n\n- **Sample Input Vectors**  \n  - Not critical here;\n---\n\n### **Test Case 9: Data Path Validation**\n\n- **Stimulus**  \n  1. Vary each `i_vector_n` (5 bits) across these patterns:\n     - **All-zero**: `5'b00000`\n     - **All-ones**: `5'b11111`\n     - **Mixed**: e.g. `5'b10101`, `5'b01010`\n     - **Boundary**: e.g. `5'b00001`, `5'b10000`\n  2. For each pattern, do IDLE \u2192 PROCESS \u2192 READY cycle.\n", "context": {}}, "output": {"response": "", "context": {"verif/enhanced_fsm_signal_processor_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 3-tb-stimulus\nTARGET = 99", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/enhanced_fsm_signal_processor.v": "// Verilog RTL Design for enhanced_fsm_signal_processor\n\nmodule enhanced_fsm_signal_processor (\n    input wire i_clk,            // Clock signal\n    input wire i_rst_n,          // Active-low reset signal\n    input wire i_enable,         // Enable signal to start processing\n    input wire i_clear,          // Signal to clear fault state and reset outputs\n    input wire i_ack,            // Acknowledge signal to transition from READY to IDLE\n    input wire i_fault,          // Fault condition signal\n    input wire [4:0] i_vector_1, // Input vector 1\n    input wire [4:0] i_vector_2, // Input vector 2\n    input wire [4:0] i_vector_3, // Input vector 3\n    input wire [4:0] i_vector_4, // Input vector 4\n    input wire [4:0] i_vector_5, // Input vector 5\n    input wire [4:0] i_vector_6, // Input vector 6\n\n    output reg o_ready,          // Indicates when processing is complete\n    output reg o_error,          // Indicates fault condition\n    output reg [1:0] o_fsm_status, // Current FSM state\n    output reg [7:0] o_vector_1, // Processed output vector 1\n    output reg [7:0] o_vector_2, // Processed output vector 2\n    output reg [7:0] o_vector_3, // Processed output vector 3\n    output reg [7:0] o_vector_4  // Processed output vector 4\n);\n\n// FSM state definitions\nlocalparam IDLE   = 2'b00;\nlocalparam PROCESS = 2'b01;\nlocalparam READY   = 2'b10;\nlocalparam FAULT   = 2'b11;\n\n// Internal registers\nreg [1:0] current_state, next_state;\nreg [31:0] concatenated_vector;\n\n// Synchronous state transition and reset handling\nalways @(posedge i_clk or negedge i_rst_n) begin\n    if (!i_rst_n) begin\n        current_state <= IDLE;   // Reset state to IDLE\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        IDLE: begin\n            if (i_fault) begin\n                next_state = FAULT;\n            end \n            else begin\n                if (i_enable) begin\n                next_state = PROCESS;\n                end\n                else next_state = current_state;\n            end\n        end\n        PROCESS: begin\n            if (i_fault) begin\n                next_state = FAULT;\n            end else begin\n                next_state = READY;\n            end\n        end\n        READY: begin\n            if (i_fault) begin\n                next_state = FAULT;\n            end \n            else begin\n                if (i_ack) begin\n                    next_state = IDLE;\n                end\n                else next_state = current_state;\n            end\n        end\n        FAULT: begin\n            if (i_clear && !i_fault) begin\n                next_state = IDLE;\n            end\n            else next_state = current_state;\n        end\n    endcase\nend\n\n// Output logic and processing\nalways @(posedge i_clk or negedge i_rst_n) begin\n    if (!i_rst_n) begin\n        o_ready <= 0;\n        o_error <= 0;\n        o_fsm_status <= IDLE;\n        o_vector_1 <= 0;\n        o_vector_2 <= 0;\n        o_vector_3 <= 0;\n        o_vector_4 <= 0;\n        concatenated_vector <= 0;\n    end else begin\n        o_fsm_status <= current_state;  // Update FSM status\n        case (current_state)\n            IDLE: begin\n                o_ready <= 0;\n                o_error <= 0;\n                o_vector_1 <= 0;\n                o_vector_2 <= 0;\n                o_vector_3 <= 0;\n                o_vector_4 <= 0;\n            end\n            PROCESS: begin\n                concatenated_vector <= {i_vector_1, i_vector_2, i_vector_3, i_vector_4, i_vector_5, i_vector_6, 2'b11};\n                end\n            READY: begin\n                o_vector_1 <= concatenated_vector[31:24]; // MSB\n                o_vector_2 <= concatenated_vector[23:16];\n                o_vector_3 <= concatenated_vector[15:8];\n                o_vector_4 <= concatenated_vector[7:0];  // LSB\n                o_ready <= 1;\n            end\n            FAULT: begin\n                o_error <= 1;\n                o_ready <= 0;\n                o_vector_1 <= 0;\n                o_vector_2 <= 0;\n                o_vector_3 <= 0;\n                o_vector_4 <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/enhanced_fsm_signal_processor.v /code/verif/enhanced_fsm_signal_processor_tb.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_csr_using_apb_0005", "categories": ["cid012", "medium"], "input": {"prompt": "Write a SystemVerilog testbench to only generate stimulus for a `csr_apb_interface` module, which is responsible for data transactions over the Advanced Peripheral Bus (APB) interface.\n\n## Interface: **csr_using_apb**\n\n**Clock & Reset**:\n`pclk`: APB clock input for synchronous operations.\n`presetn`: Active-low asynchronous reset signal, used to initialize the system.\n\n**Inputs & Outputs Ports**:\n**APB Signals:**\n`paddr` (input, 32 bits): Address bus to access the internal CSR registers.\n`pselx` (input): APB select signal, indicates CSR selection.\n`penable` (input): APB enable signal, signals transaction progression.\n`pwrite` (input): Write enable signal, differentiating read and write operations.\n`pwdata` (input, 32 bits): Write data bus to send data to CSR registers.\n`pready` (output, reg): Ready signal indicating transaction completion.\n`prdata` (output, reg, 32 bits): Read data bus for CSR data retrieval.\n`pslverr` (output, reg): Error signal for invalid addresses or unsupported operations.\n\n**Internal Registers**:\n\n`DATA_REG (0x10)`: Stores two 10-bit values, data1 and data2, and a 12-bit reserved section.\n`CONTROL_REG (0x14)`: Contains a control enable bit, mode bit, and 30 reserved bits.\n`INTERRUPT_REG (0x18)`: Holds interrupt enable flags for various conditions and 28 reserved bits.\n\n## Specifications\n\n**Read Operations**:\n\n- During the READ_STATE, assert pready and load prdata with the register value based on paddr.\n\n- Return to IDLE after asserting pready for one cycle.\n\n**Write Operations**:\n\n- During the WRITE_STATE, assert pready and update the register selected by paddr with pwdata.\n\n- For DATA_REG, split pwdata into fields for data1, data2, and the reserved section.\n\n- For CONTROL_REG and INTERRUPT_REG, update only specified bits.\n\n- Return to IDLE after asserting pready for one cycle.\n\n**Reset Behavior**:\n\n- On presetn deassertion, reset all outputs and internal registers to their default values:\n\n- Set pready and pslverr to 0.\n\n- Clear prdata.\n\n- Initialize data1, data2, overflow_ie, sign_ie, parity_ie, and zero_ie to 0.\n\n---\n\n## **Testbench Requirements**\n### **Instantiation**\n- **Module Instance:** The **csr_apb_interface** module is instantiated as `uut`, with all input and output signals connected.\n\n---\n\n### **Input Generation**\n#### **1. Writing to `DATA_REG`**\n- The testbench writes a **random 32-bit value** to `DATA_REG`.\n\n#### **2. Reading from `DATA_REG`**\n- A read operation is performed from `DATA_REG`.\n\n#### **3. Writing and Reading from `CONTROL_REG`**\n- A **random 32-bit value** is written to `CONTROL_REG`.\n- The value is read back.\n\n#### **4. Writing and Reading from `INTERRUPT_REG`**\n- A **random 32-bit value** is written to `INTERRUPT_REG`.\n- The value is read back.\n\n#### **5. Invalid Address Access**\n- A write is attempted to an **unknown address (`0x20`)**.\n\n#### **6. Read Transaction Without `pselx` Asserted**\n- A read is attempted from `DATA_REG` **without asserting `pselx`**.\n\n#### **7. Write Transaction Without `penable` Asserted**\n- A write is performed to `CONTROL_REG` **without `penable` assertion**.\n\n#### **8. Corner Cases for Write Data**\n- **All 1s (`0xFFFFFFFF`)** and **all 0s (`0x00000000`)** are written to `DATA_REG`.\n\n#### **9. Reset Behavior**\n- The reset signal (`presetn = 0`) is applied in the middle of operations.\n\n---", "context": {}}, "output": {"response": "", "context": {"verif/csr_apb_interface_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 27d0484bbda710c62a7f87ce0a03f0926a77d91b\nTARGET = 90", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/csr_apb_interface.sv": "`timescale 1ns / 1ps\nmodule csr_apb_interface (\n    input                    pclk,              // Clock input for synchronization\n    input                    presetn,           // Active-low asynchronous reset input\n    input [31:0]             paddr,             // APB address bus, 32-bit for register addressing\n    input                    pselx,             // APB peripheral select signal\n    input                    penable,           // APB enable signal for transactions\n    input                    pwrite,            // APB write enable signal\n    input [31:0]             pwdata,            // APB write data bus\n\n    output reg               pready,            // APB ready signal, indicates end of transaction\n    output reg [31:0]        prdata,            // APB read data bus\n    output reg               pslverr            // APB slave error signal\n);\n\n    // Define register addresses\n    localparam DATA_REG      = 32'h10; // Data register\n    localparam CONTROL_REG   = 32'h14; // Control register\n    localparam INTERRUPT_REG = 32'h18; // Interrupt configuration register\n\n    // Define state machine states\n    localparam IDLE          = 2'b00;\n    localparam SETUP         = 2'b01;\n    localparam READ_STATE    = 2'b10;\n    localparam WRITE_STATE   = 2'b11;\n\n    // Internal state registers\n    reg [1:0]                present_state, next_state;\n\n    // Signals for state transitions and outputs\n    reg                      next_pready;\n    reg [31:0]               next_prdata;\n    reg                      next_pslverr;\n\n    // Internal storage registers and next-state values\n    reg [9:0]                data1, next_data1;\n    reg [9:0]                data2, next_data2;\n    reg [11:0]               data_reserived, data_next_reserived;\n\n    // Control register bits and their next-state values\n    reg                      enable;            // Control register: Enable bit\n    reg                      mode;              // Control register: Mode selection bit\n    reg [29:0]               CONTROL_reserived; // Reserved bits in control register\n\n    // Interrupt flags and next-state values\n    reg                      overflow_ie, next_overflow_ie;\n    reg                      sign_ie, next_sign_ie;\n    reg                      parity_ie, next_parity_ie;\n    reg                      zero_ie, next_zero_ie;\n    reg [27:0]               INTERRUPT_reserived, next_INTERRUPT_reserived;\n\n    // Combinational logic to determine next state and outputs\n    always @ (*) begin\n        // Set default values for the next state outputs\n        next_pready = pready;\n        next_prdata = prdata;\n        next_pslverr = pslverr;\n\n        next_data1 = data1;\n        next_data2 = data2;\n        next_overflow_ie = overflow_ie;\n        next_sign_ie = sign_ie;\n        next_parity_ie = parity_ie;\n        next_zero_ie = zero_ie;\n        next_state = present_state;\n        next_INTERRUPT_reserived = INTERRUPT_reserived;\n        data_next_reserived = data_reserived;\n\n        // State machine handling APB interface operations\n        case (present_state)\n            IDLE: begin\n                if (pselx)\n                    next_state = SETUP; // Transition to setup on select\n            end\n            \n            SETUP: begin\n                if (penable && pwrite)\n                    next_state = WRITE_STATE; // Handle write transactions\n                else if (penable)\n                    next_state = READ_STATE; // Handle read transactions\n            end\n\n            READ_STATE: begin\n                if (pready) begin\n                    next_state = IDLE; // Return to IDLE after read\n                    next_pready = 1'b0;\n                end else begin\n                    next_pready = 1'b1;\n                    case (paddr) // Output data based on address\n                        DATA_REG:      next_prdata = {data_reserived, data1, data2};\n                        CONTROL_REG:   next_prdata = {CONTROL_reserived, enable, mode};\n                        INTERRUPT_REG: next_prdata = {INTERRUPT_reserived, overflow_ie, sign_ie, parity_ie, zero_ie};\n                        default:       next_pslverr = 1'b1; // Unknown address error\n                    endcase\n                end\n            end\n\n            WRITE_STATE: begin\n                if (pready) begin\n                    next_state = IDLE; // Return to IDLE after write\n                    next_pready = 1'b0;\n                end else begin\n                    next_pready = 1'b1;\n                    case (paddr) // Handle data based on address\n                        DATA_REG: begin\n                            next_data1 = pwdata[19:10];\n                            next_data2 = pwdata[9:0];\n                            data_next_reserived = pwdata[31:20];\n                        end\n                        CONTROL_REG: begin\n                            enable = pwdata[1];\n                            mode = pwdata[0];\n                            CONTROL_reserived = pwdata[31:2];\n                        end\n                        INTERRUPT_REG: begin\n                            next_overflow_ie = pwdata[3];\n                            next_sign_ie = pwdata[2];\n                            next_parity_ie = pwdata[1];\n                            next_zero_ie = pwdata[0];\n                            next_INTERRUPT_reserived = pwdata[31:4];\n                        end\n                        default: next_pslverr = 1'b1; \n                    endcase\n                end\n            end\n        endcase\n    end\n\n    // Sequential logic to update state and outputs at clock edges or reset\n    always @ (posedge pclk or negedge presetn) begin\n        if (!presetn) begin\n            // Initialize registers on reset\n            pready          <= 1'b0;\n            prdata          <= 32'h0;\n            pslverr         <= 1'b0;\n\n            data1           <= 10'd0;\n            data2           <= 10'd0;\n            overflow_ie     <= 1'b0;\n            sign_ie         <= 1'b0;\n            parity_ie       <= 1'b0;\n            zero_ie         <= 1'b0;\n            INTERRUPT_reserived       <= 28'b0;\n            data_reserived       <= 12'b0;\n\n            present_state   <= IDLE;\n        end else begin\n            // Update internal state and outputs based on next state values\n            pready          <= next_pready;\n            prdata          <= next_prdata;\n            pslverr         <= next_pslverr;\n\n            data1           <= next_data1;\n            data2           <= next_data2;\n            overflow_ie     <= next_overflow_ie;\n            sign_ie         <= next_sign_ie;\n            parity_ie       <= next_parity_ie;\n            zero_ie         <= next_zero_ie;\n            data_reserived  <= data_next_reserived;\n            INTERRUPT_reserived  <= next_INTERRUPT_reserived;\n\n            present_state   <= next_state;\n        end\n    end\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_decode_firstbit_0017", "categories": ["cid012", "medium"], "input": {"prompt": "Create a **testbench** to apply **stimulus** to the `cvdp_copilot_decode_firstbit` module. This module detects the first set bit in a **32-bit binary input** and outputs its position in either **binary or one-hot encoding**. The testbench must generate a diverse set of input patterns while ensuring compliance with the module\u2019s **clocking, reset, and pipeline behavior**.\n\n---\n\n### **Inputs:**\n\n- `Clk`: **1-bit clock signal**, toggling every **5 time units** (100MHz operation).\n- `Rst`: **Active-high reset signal** to initialize the module.\n- `In_Data`: **32-bit input bus** for data values.\n- `In_Valid`: **Signal indicating valid input data**.\n\n### **Outputs:**\n\n- `Out_FirstBit`: **Position of the first set bit** (Binary or One-Hot encoded).\n- `Out_Found`: **Indicates if a set bit was found**.\n- `Out_Valid`: **Indicates valid output data**.\n\n---\n\n### **Module Specifications for Stimulus Generation**\n\nThe `cvdp_copilot_decode_firstbit` module supports configurable first-bit detection with the following key parameters:\n\n- **Input Processing:**\n  - Detects **first set bit** from LSB to MSB.\n  - Supports **optional input registers (`InReg_g`)**.\n- **Output Processing:**\n  - Provides index in **Binary or One-Hot encoding (`OutputFormat_g`)**.\n  - Supports **optional output registers (`OutReg_g`)**.\n- **Pipeline Stages:**\n  - Configurable **pipeline registers (`PlRegs_g`)** for adjustable latency.\n- **Clock and Reset Behavior:**\n  - Operates on the **rising edge** of `Clk`.\n  - Initializes internal registers upon `Rst` assertion.\n\n---\n\n### **Instantiation**\n\nThe testbench must instantiate a single instance of the `cvdp_copilot_decode_firstbit` module with instantiation name `dut`:\n\n- **Decode First Bit Module (`dut`)**: Instantiated with the following parameter values:\n  - `InWidth_g = 32`\n  - `InReg_g = 0`\n  - `OutReg_g = 0`\n  - `PlRegs_g = 0`\n  - `OutputFormat_g = 0` (Binary Encoding)\n\n---\n\n### **Testbench Requirements**\n\nThe testbench must apply a **wide range of test patterns** covering various input scenarios:\n\n1. **Clock Generation:**\n   - `Clk` must toggle every **5 time units**, ensuring a **100MHz clock period**.\n\n2. **Reset Handling:**\n   - `Rst` must be **asserted at the beginning** of the simulation for **three cycles**.\n   - The module must be **initialized properly** before input stimulus is applied.\n\n3. **Stimulus Generation Strategy:**\n   - The testbench **must not verify outputs** (only generate inputs).\n   - Generate input patterns covering:\n     - **Single-bit set inputs**.\n     - **All-zero inputs**.\n     - **Multiple-bit patterns**.\n     - **Random bit patterns**.\n     - **First-bit at different positions**.\n     - **First and last bit set**.\n     - **Changing valid input sequences**.\n     - **Pipeline latency variations**.\n\n4. **Handling Consecutive and Random Inputs:**\n   - The testbench must ensure **continuous valid input scenarios** are covered.\n   - Include **randomized sequences** to simulate realistic DUT behavior.\n\n5. **Reset in Mid-Operation:**\n   - The testbench should **toggle reset during execution** to ensure the module properly re-initializes.\n\n---\n\n### **Coverage and Compliance**\n\n- The testbench must ensure **high coverage** across all input variations.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n- The **RTL should not be in context** but will be provided in `/harness/<issue number>/src/`.\n\n---\n\n### **Test Plan Overview**\n\n- **Basic input cases** (all zeros, single-bit set, multiple bits set).\n- **Timing-based tests** (handling valid input over consecutive cycles).\n- **Randomized patterns** to ensure robustness.\n- **Pipeline configuration tests** to validate latency effects.\n- **Reset handling** to verify re-initialization integrity.\n\nThis testbench should provide a **comprehensive input stimulus environment** for `cvdp_copilot_decode_firstbit`, ensuring correct operation across multiple configurations.\n\n---\n\n### **Note:**\n- The testbench **must only generate stimulus** without verifying outputs.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n- **Ensure the maximum possible input coverage** without adding assertions or comparisons.\n\nCan you implement a **SystemVerilog testbench** with the above stimulus requirements?\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_cvdp_copilot_decode_firstbit.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 17-tb-stimulus-generation\nTARGET = 90 ", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite\n\n# Merge multiple coverage databases\nmerge {test_*} -out merged_cov -overwrite \n\n# Load the merged coverage database\nload merged_cov\n\n# Generate a coverage report\nreport -text -out merged_cov_report.txts", "src/cvdp_copilot_decode_firstbit.sv": "module cvdp_copilot_decode_firstbit #(\n    parameter integer InWidth_g = 32,\n    parameter InReg_g = 1,\n    parameter OutReg_g = 1,\n    parameter integer PlRegs_g = 1,\n    parameter OutputFormat_g = 0  // 0: Binary, 1: One-Hot Encoding\n)(\n    input wire Clk,\n    input wire Rst,\n    input wire [InWidth_g-1:0] In_Data,\n    input wire In_Valid,\n\n    output reg [InWidth_g-1:0] Out_FirstBit,   // Binary index or one-hot bit\n    output reg Out_Found,\n    output reg Out_Valid\n);\n\n    // Local parameters\n    localparam integer BinBits_c = $clog2(InWidth_g);\n\n    // Internal signals\n    reg [InWidth_g-1:0] In_Data_r;\n    reg In_Valid_r;\n    reg [PlRegs_g:0] Valid_pipeline;\n    reg [PlRegs_g:0] Found_pipeline;\n    reg [BinBits_c-1:0] FirstBit_pipeline [PlRegs_g:0];\n    reg [InWidth_g-1:0] OneHotBit_pipeline [PlRegs_g:0];\n\n    // Optional input register\n    generate\n    if (InReg_g == 1) begin : input_reg_block\n        always @(posedge Clk or posedge Rst) begin\n            if (Rst) begin\n                In_Data_r <= {InWidth_g{1'b0}};\n                In_Valid_r <= 1'b0;\n            end else begin\n                In_Data_r <= In_Data;\n                In_Valid_r <= In_Valid;\n            end\n        end\n    end else begin : no_input_reg_block\n        always @(*) begin\n            In_Data_r = In_Data;\n            In_Valid_r = In_Valid;\n        end\n    end\n    endgenerate\n\n    // Function to find the index of the first '1' bit from LSB to MSB\n    function [BinBits_c-1:0] find_first_one(input [InWidth_g-1:0] data_in);\n        integer i;\n        reg found;\n        begin\n            find_first_one = {BinBits_c{1'b0}};\n            found = 0;\n            for (i = 0; i < InWidth_g; i = i + 1) begin\n                if (!found && data_in[i]) begin\n                    find_first_one = i[BinBits_c-1:0];\n                    found = 1;\n                end\n            end\n        end\n    endfunction\n\n    // Function to generate one-hot encoding of the first set bit\n    function [InWidth_g-1:0] one_hot_encode(input [BinBits_c-1:0] binary_index);\n        begin\n            one_hot_encode = {InWidth_g{1'b0}};\n            one_hot_encode[binary_index] = 1'b1;\n        end\n    endfunction\n\n    // Stage 0: Compute the first '1' bit position and its one-hot encoding\n    always @(posedge Clk or posedge Rst) begin\n        if (Rst) begin\n            Valid_pipeline[0] <= 1'b0;\n            Found_pipeline[0] <= 1'b0;\n            FirstBit_pipeline[0] <= {BinBits_c{1'b0}};\n            OneHotBit_pipeline[0] <= {InWidth_g{1'b0}};\n        end else begin\n            Valid_pipeline[0] <= In_Valid_r;\n            Found_pipeline[0] <= |In_Data_r;\n            if (|In_Data_r) begin\n                FirstBit_pipeline[0] <= find_first_one(In_Data_r);\n                OneHotBit_pipeline[0] <= one_hot_encode(find_first_one(In_Data_r));\n            end else begin\n                FirstBit_pipeline[0] <= {BinBits_c{1'b0}};\n                OneHotBit_pipeline[0] <= {InWidth_g{1'b0}};\n            end\n        end\n    end\n\n    // Pipeline stages\n    genvar k;\n    generate\n        for (k = 1; k <= PlRegs_g; k = k + 1) begin : pipeline_stages\n            always @(posedge Clk or posedge Rst) begin\n                if (Rst) begin\n                    Valid_pipeline[k] <= 1'b0;\n                    Found_pipeline[k] <= 1'b0;\n                    FirstBit_pipeline[k] <= {BinBits_c{1'b0}};\n                    OneHotBit_pipeline[k] <= {InWidth_g{1'b0}};\n                end else begin\n                    Valid_pipeline[k] <= Valid_pipeline[k-1];\n                    Found_pipeline[k] <= Found_pipeline[k-1];\n                    FirstBit_pipeline[k] <= FirstBit_pipeline[k-1];\n                    OneHotBit_pipeline[k] <= OneHotBit_pipeline[k-1];\n                end\n            end\n        end\n    endgenerate\n\n    // Optional output register\n    generate\n    if (OutReg_g == 1) begin : output_reg_block\n        always @(posedge Clk or posedge Rst) begin\n            if (Rst) begin\n                Out_Valid <= 1'b0;\n                Out_Found <= 1'b0;\n                Out_FirstBit <= {InWidth_g{1'b0}};\n            end else begin\n                Out_Valid <= Valid_pipeline[PlRegs_g];\n                Out_Found <= Found_pipeline[PlRegs_g];\n                if (OutputFormat_g == 0) begin\n                    // Binary encoding: Zero-extend to match width\n                    Out_FirstBit <= {{(InWidth_g - BinBits_c){1'b0}}, FirstBit_pipeline[PlRegs_g]};\n                end else begin\n                    // One-hot encoding\n                    Out_FirstBit <= OneHotBit_pipeline[PlRegs_g];\n                end\n            end\n        end\n    end else begin : no_output_reg_block\n        always @(*) begin\n            Out_Valid = Valid_pipeline[PlRegs_g];\n            Out_Found = Found_pipeline[PlRegs_g];\n            if (OutputFormat_g == 0) begin\n                // Binary encoding: Zero-extend to match width\n                Out_FirstBit = {{(InWidth_g - BinBits_c){1'b0}}, FirstBit_pipeline[PlRegs_g]};\n            end else begin\n                // One-hot encoding\n                Out_FirstBit = OneHotBit_pipeline[PlRegs_g];\n            end\n        end\n    end\n    endgenerate\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    # Check the process return code instead of just the object\n    sim_result = subprocess.run(cmd, shell=True)\n    assert sim_result.returncode == 0, \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    cov_result = subprocess.run(cmd, shell=True)\n    assert cov_result.returncode == 0, \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    # Start parsing from the third line to skip headers and separators\n    for line in lines[2:]:\n        info = line.split()\n\n        # Skip lines that don't have at least three columns\n        if len(info) < 3:\n            continue\n\n        # Skip lines if the second or third columns do not end with '%'\n        # (which indicates they do not contain valid coverage data)\n        if not info[1].endswith('%') or not info[2].endswith('%'):\n            continue\n\n        inst = info[0]\n        avg  = info[1]\n        cov  = info[2]\n\n        # Clean up instance name (remove special chars/pipes/dashes)\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics[inst] = {\n            \"Average\": float(avg[:-1]),   # remove '%' and convert to float\n            \"Covered\": float(cov[:-1])    # remove '%' and convert to float\n        }\n\n    # Finally, ensure the coverage for 'dut' is at least the target\n    assert metrics[\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_digital_stopwatch_0017", "categories": ["cid012", "easy"], "input": {"prompt": "Complete the given partial SystemVerilog testbench`dig_stopwatch_tb`. The testbench must instantiate the `dig_stopwatch` RTL module and provide input stimulus to observe its behavior. This module implements a parameterized stopwatch with seconds, minutes, and hour tracking functionality. The testbench should include different input scenarios like start, stop, and reset operations.\n\n## **Description**\n\nThe `dig_stopwatch` module is a stopwatch that tracks elapsed time with inputs for clock, reset, and a start/stop control signal. It provides outputs for seconds, minutes, and hours, with appropriate rollovers and tracking behavior. The module operates based on a parameterized clock frequency (`CLK_FREQ`), which determines the timebase of the stopwatch.\n\n## **Parameters**\n- **CLK_FREQ**: Defines the input clock frequency in Hz, with a default value of 200 Hz. This frequency should be an integer value in Hz greater than the minimum value of 1 Hz. The clock divider within the module uses this parameter to generate a one-second pulse (`one_sec_pulse`).\n\n---\n\n## **Inputs**\n- **`clk`**: Clock signal for synchronizing operations. The design is synchronized to the positive edge of this clock.\n- **`reset`**: Asynchronous active-high reset signal to reset all counters to zero.\n- **`start_stop`**: Start/stop is a 1 bit control signal that controls if the stopwatch is running or paused. \n\n---\n\n## **Outputs**\n- **`seconds [5:0] `**: 6-bit output representing seconds (range: 0\u201359).\n- **`minutes [5:0]`**: 6-bit output representing minutes (range: 0\u201359).\n- **`hour`**: Represents a one-bit signal that updates to 1 when one hour has passed.\n\n---\n### **PERIOD Calculation**\nThe `PERIOD` is calculated using the formula `PERIOD = (1_000_000_000 / CLK_FREQ)`, where:\n- `1_000_000_000` represents 1 second in nanoseconds.\n- `CLK_FREQ` is the input clock frequency in Hz.\n- For `CLK_FREQ = 200`, the resulting `PERIOD = 5_000_000` nanoseconds (5 ms per clock cycle).\n\n## **Testbench Verification Features**\n\n### **Instantiation**\nThe `dig_stopwatch` module is instantiated as `uut`, with its inputs and outputs connected to corresponding testbench signals. The parameter `CLK_FREQ` is set explicitly for the testbench to validate the module under different clock frequency conditions.\n\n\n### **Clock Generation**:\n   - A clock signal is generated with a period of `PERIOD`, ensuring a frequency of `CLK_FREQ`.\n\n### **Reset Operation**:\n   - `reset` is asserted at the beginning to initialize the stopwatch and deasserted after 100 nanoseconds.\n\n### **Start and Stop Operations**:\n   - The stopwatch starts with `start_stop = 1` and stops with `start_stop = 0`.\n\n### **Wait for Specific Duration**:\n   - The testbench uses the one-second pulse from the stopwatch to simulate precise elapsed time durations.\n\n### **Test Sequences**:\n   - **Run for 1000 seconds**: The stopwatch runs with `start_stop = 1`.\n   - **Pause for 200 clock cycles**: The stopwatch is paused with `start_stop = 0`.\n   - **Run for 3000 seconds**: The stopwatch resumes operation.\n   - **Pause for 500 clock cycles**: The stopwatch is paused again.\n   - **Reset during operation**: The `reset` signal is asserted for 5 clock cycles to reset the counters.\n   - **Run for 100 seconds**: After the reset, the stopwatch resumes.\n\n### **Waveform Dumping**:\n   - Simulation data is saved to a `.vcd` file for waveform analysis.\n\n### Partial Test Stimulus Generator Code :\n``` verilog\nmodule dig_stopwatch_tb;\n\n    // Parameters\n    parameter  CLK_FREQ = 200;              //  200 Hz clock \n    localparam PERIOD = (1_000_000_000 / CLK_FREQ);\n\n    // Testbench Signals\n    reg clk;\n    reg reset;\n    reg start_stop;\n    wire [5:0] seconds;\n    wire [5:0] minutes;\n    wire hour;\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #(PERIOD/2) clk = ~clk;\n    end\n\n    // Instantiate the stopwatch module\n    dig_stopwatch #(\n        .CLK_FREQ(CLK_FREQ)\n    ) uut (\n        .clk(clk),\n        .reset(reset),\n        .start_stop(start_stop),\n        .seconds(seconds),\n        .minutes(minutes),\n        .hour(hour)\n    );\n\n    // Task to wait for a specific number of seconds\n    task wait_seconds(input integer num_seconds);\n        integer i;\n        begin\n            for (i = 0; i < num_seconds; i = i + 1) begin\n                @(posedge uut.one_sec_pulse);  \n                $display(\"Hour = %0d, Minutes = %0d , Seconds= %0d \", hour,minutes,seconds);\n            end\n        end\n    endtask\n    \n    // Insert the code for the remaining test stimulus here\n\nendmodule\n```\n", "context": {}}, "output": {"response": "", "context": {"verif/dig_stopwatch_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro \n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = f9b2a65e91a681af690aa937070032192e2e7567\nTARGET = 85\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nadd_scope -name dig_stopwatch*", "src/dig_stopwatch.sv": "module dig_stopwatch #(\n    parameter CLK_FREQ = 50000000  // Default clock frequency is 50 MHz\n)(\n    input wire clk,                // Input clock (parameterized frequency)\n    input wire reset,              // Reset signal\n    input wire start_stop,         // Start/Stop control\n    output reg [5:0] seconds,      // Seconds counter (0-59)\n    output reg [5:0] minutes,      // Minutes counter (0-59)\n    output reg hour                // Hour counter \n);\n\n    localparam COUNTER_MAX = CLK_FREQ - 1;  // Calculate max counter value\n    reg [$clog2(COUNTER_MAX):0] counter;    // Clock divider counter width based on CLK_FREQ\n    reg one_sec_pulse;                      // One second pulse signal\n\n    // Clock divider to create a 1 Hz clock pulse from parameterized frequency\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter <= 0;\n            one_sec_pulse <= 0;\n        end else begin\n            if (start_stop) begin\n                if (counter == COUNTER_MAX) begin\n                    counter <= 0;\n                    one_sec_pulse <= 1'b1;        // Generate a pulse every second\n                end else begin\n                    counter <= counter + 1;\n                    one_sec_pulse <= 1'b0;\n                end\n            end else begin\n                one_sec_pulse <= 1'b0;           // Ensure one_sec_pulse is cleared if paused\n            end\n        end\n    end\n\n    // Stopwatch logic\n    always @(posedge one_sec_pulse or posedge reset) begin\n        if (reset) begin\n            seconds <= 5'b0;\n            minutes <= 5'b0;\n            hour <= 1'b0;\n        end else if (start_stop == 1 && hour == 0) begin\n            if (seconds < 59) begin\n                seconds <= seconds + 1'b1;\n            end else begin\n                seconds <= 5'b0;\n                if (minutes < 59) begin\n                    minutes <= minutes + 1'b1;\n                end else begin\n                    minutes <= 5'b0;\n                    hour <= 1'b1;\n                end\n            end\n        end\n    end\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all -define CLK_FREQ=200 /src/dig_stopwatch.sv /code/verif/dig_stopwatch_tb.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_encoder_8b10b_0026", "categories": ["cid012", "medium"], "input": {"prompt": "Create a SystemVerilog testbench module named `tb_encoder_8b10b` that instantiates the `encoder_8b10b` module as the Unit Under test (UUT). This testbench module must include the `stimulus generation` logic only, which systematically drives different input conditions to the `encoder_8b10b` module to achieve **100% functional and code coverage**.  The `encoder_8b10b` module supports encoding of control and data symbols as given in the below functionality.\n\n---\n## **Input Stimulus Generation**\n\n### **Encoder Inputs**\n- Generate diverse patterns for `encoder_in`, including:\n  - Standard **control symbols** (`8'h1C`, `8'h3C`, `8'h5C`, `8'h7C`, etc.).\n  - Random **valid data symbols** (`8'h00` to `8'hFF`).\n  - Repeated control symbols.\n  - Invalid control inputs.\n  - **Imbalanced** control symbols to check running disparity handling.\n  - **Continuous data symbols** covering the entire range.\n  - **Sequential and random data symbols**.\n\n### **Edge Case Testing**\n- Drive encoder inputs with:\n  - **Repeated** control symbol sequences.\n  - **Back-to-back** transitions between control and data symbols.\n  - **Random invalid 8-bit values** fed into the encoder.\n\n### **Stabilization Period**\n- **Wait 1 clock cycle** after each input change before checking `encoder_out` and `disparity_out` to ensure stable results.\n\n---\n\n## **Instantiation**\n- The instance of the **RTL module** should be named **`uut`**.\n\nFollowing the RTL specification for building the RTL of the module, and using it as a reference for the testbench environment too:\n\n---\n\n## **Module Interface**\n\n### **Inputs**\n- `clk_in`: **Rising-edge triggered clock** signal with a 50% duty cycle.\n- `reset_in`: **Active-HIGH asynchronous reset**.\n- `control_in`: **1-bit input**, HIGH for control symbols, LOW for data symbols.\n- `encoder_in[7:0]`: **8-bit input symbol** to be encoded.\n- `disparity_data_in`: **1-bit input**, representing the current running disparity.\n\n### **Outputs**\n- `encoder_out[9:0]`: **10-bit encoded output**.\n- `disparity_out`: **1-bit output**, representing the running disparity after encoding.\n\n---\n\n## **Module Functionality**  \n\nAn 8b10b encoder is a digital circuit that converts an 8-bit word into a 10-bit encoded codeword, used in telecommunications to maintain Digital Control (DC) balance (equal number of 1s and 0s) and provide error detection capabilities. The encoder is extended to support **data symbols**, which are standard data inputs distinct from control symbols.\n\n1. **Control and Data Symbol Encoding**:\n   - When `control_in` is HIGH: Encode `encoder_in` as a control character based on predefined control symbols and update the running disparity for control encoding.\n   - When `control_in` is LOW: Encode `encoder_in` as a data symbol based on the 8b/10b data encoding scheme. Use `disparity_data_in` to run disparity tracking and generate a valid 10-bit encoded data symbol while updating the running disparity.\n\n2. **Latency**:\n   - Ensure the module introduces a single clock cycle latency for control or data symbol encoding.\n\n3. **Control Encoding Compatibility**:\n   - Maintain compatibility with existing control symbol encoding implementation.\n   - Use modular components to handle control and data symbol encoding separately for maintainability.\n\nBelow are the 5b/6b and 3b/4b encoding tables used for encoding data symbols in the design.\n\n### **5b/6b Encoding Table**\n\nThe lower 5 bits of the 8-bit input are mapped to 6 bits based on the current running disparity (`RD`).\n\n| Input 5-bit(LSB) | RD = 0 | RD = 1  |\n|------------------|--------|---------|\n| 00000            | 100111 | 011000  |\n| 00001            | 011101 | 100010  |\n| 00010            | 101101 | 010010  |\n| 00011            | 110001 | 110001  |\n| 00100            | 110101 | 001010  |\n| 00101            | 101001 | 101001  |\n| 00110            | 011001 | 011001  |\n| 00111            | 111000 | 000111  |\n| 01000            | 111001 | 000110  |\n| 01001            | 100101 | 100101  |\n| 01010            | 010101 | 010101  |\n| 01011            | 110100 | 110100  |\n| 01100            | 001101 | 001101  |\n| 01101            | 101100 | 101100  |\n| 01110            | 011100 | 011100  |\n| 01111            | 010111 | 101000  |\n| 10000            | 011011 | 100100  |\n| 10001            | 100011 | 100011  |\n| 10010            | 010011 | 010011  |\n| 10011            | 110010 | 110010  |\n| 10100            | 001011 | 001011  |\n| 10101            | 101010 | 101010  |\n| 10110            | 011010 | 011010  |\n| 10111            | 111010 | 000101  |\n| 11000            | 110011 | 001100  |\n| 11001            | 100110 | 100110  |\n| 11010            | 010110 | 010110  |\n| 11011            | 110110 | 001001  |\n| 11100            | 001110 | 001110  |\n| 11101            | 101110 | 010001  |\n| 11110            | 011110 | 100001  |\n| 11111            | 101011 | 010100  |\n\n### **3b/4b Encoding Table**\n\nThe upper 3 bits of the 8-bit input are mapped to 4 bits based on the current running disparity (`RD`).\n\n| Input (MSB) | RD = 0  | RD = 1  |\n|-------------|---------|---------|\n| 000         | 0100    | 1011    |\n| 001         | 1001    | 1001    |\n| 010         | 0101    | 0101    |\n| 011         | 0011    | 1100    |\n| 100         | 0010    | 1101    |\n| 101         | 1010    | 1010    |\n| 110         | 0110    | 0110    |\n| 111         | 1110    | 0001    |\n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_encoder_8b10b.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = c98c7c91f06a3ddcbc54f442017cf310ac99d7a9\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite\n", "src/encoder_8b10b.sv": "module encoder_8b10b (\n    input  logic        clk_in,           // Trigger on rising edge\n    input  logic        reset_in,         // Reset, assert HI\n    input  logic        control_in,       // Control character, assert HI for control words\n    input  logic        disparity_data_in,// Current running disparity input for data\n    input  logic [7:0]  encoder_in,       // 8-bit input\n    output logic        disparity_out,    // Running disparity: HI = +1, LO = 0\n    output logic [9:0]  encoder_out       // 10-bit codeword output\n);\n\n    logic disparity_control_out;\n    logic disparity_data_out;\n    logic [9:0] encoder_control_out;\n    logic [9:0] encoder_data_out;\n\n    assign disparity_out = control_in ? disparity_control_out : disparity_data_out;\n    assign encoder_out   = control_in ? encoder_control_out : encoder_data_out;\n\n    encoder_8b10b_control enc_control (\n        .clk_in(clk_in),\n        .reset_in(reset_in),\n        .control_in(control_in),\n        .encoder_in(encoder_in),\n        .disparity_out(disparity_control_out),\n        .encoder_out(encoder_control_out)\n    );\n    \n    encoder_8b10b_data enc_data (\n        .clk_in(clk_in),\n        .reset_in(reset_in),\n        .control_in(control_in),\n        .encoder_in(encoder_in),\n        .ein_rd(disparity_data_in),\n        .disparity_out(disparity_data_out),\n        .encoder_out(encoder_data_out)\n    );\n\nendmodule\n\nmodule encoder_8b10b_control (\n    input  logic        clk_in,\n    input  logic        reset_in,\n    input  logic        control_in,\n    input  logic [7:0]  encoder_in,\n    output logic        disparity_out,\n    output logic [9:0]  encoder_out\n);\n\n    typedef enum logic [1:0] {RD_MINUS, RD_PLUS} t_state_type;\n    t_state_type current_disparity;\n\n    parameter [31:0] disparity_table_6b = 32'b11101000100000011000000110010111;\n    parameter [7:0]  disparity_table_4b = 8'b10001001;\n\n    logic        disparity_track;\n    logic [7:0]  registered_input;\n    logic        registered_control;\n    logic [2:0]  index_3b;\n    logic        disparity_4b;\n    logic [4:0]  index_5b;\n    logic        disparity_6b;\n\n    assign index_3b     = registered_input[7:5];\n    assign disparity_4b = disparity_table_4b[index_3b];\n    assign index_5b     = registered_input[4:0];\n    assign disparity_6b = disparity_table_6b[index_5b];\n    assign disparity_out = disparity_track;\n\n    always_comb begin\n        logic [9:0] control_code;\n\n        if (registered_control) begin\n            case (registered_input)\n                8'h1C: control_code = 10'b0011110100;\n                8'h3C: control_code = 10'b0011111001;\n                8'h5C: control_code = 10'b0011110101;\n                8'h7C: control_code = 10'b0011110011;\n                8'h9C: control_code = 10'b0011110010;\n                8'hBC: control_code = 10'b0011111010;\n                8'hDC: control_code = 10'b0011110110;\n                8'hFC: control_code = 10'b0011111000;\n                8'hF7: control_code = 10'b1110101000;\n                8'hFB: control_code = 10'b1101101000;\n                8'hFD: control_code = 10'b1011101000;\n                8'hFE: control_code = 10'b0111101000;\n                default: control_code = 10'b0000000000;\n            endcase\n\n            if (current_disparity == RD_MINUS) begin\n                encoder_out = control_code;\n                disparity_track = 1'b0;\n            end else begin\n                encoder_out = ~control_code;\n                disparity_track = 1'b1;\n            end\n        end else begin\n            encoder_out = 10'b0000000000;\n            control_code = 10'b0;\n            disparity_track = 1'b0;\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            current_disparity <= RD_MINUS;\n        end else begin\n            if ((registered_input[1:0] != 2'b00) && registered_control) begin\n                current_disparity <= current_disparity;\n            end else begin\n                case (current_disparity)\n                    RD_MINUS: begin\n                        if ((registered_control ^ disparity_6b ^ disparity_4b) != 1'b0) begin\n                            current_disparity <= RD_PLUS;\n                        end\n                    end\n                    RD_PLUS: begin\n                        if ((registered_control ^ disparity_6b ^ disparity_4b) != 1'b0) begin\n                            current_disparity <= RD_MINUS;\n                        end\n                    end\n                    default: current_disparity <= RD_MINUS;\n                endcase\n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            registered_input  <= 8'b00000000;\n            registered_control <= 1'b0;\n        end else begin\n            registered_input  <= encoder_in;\n            registered_control <= control_in;\n        end\n    end\n\nendmodule\n\nmodule encoder_8b10b_data (\n    input  logic        clk_in,\n    input  logic        reset_in,\n    input  logic        control_in,\n    input  logic        ein_rd,\n    input  logic [7:0]  encoder_in,\n    output logic        disparity_out,\n    output logic [9:0]  encoder_out\n);\n\n    wire [7:0] encoder_in_w;\n    wire K;\n\n    wire is_all_low;\n    wire is_three_low;\n    wire is_two_low_two_high;\n    wire is_three_high;\n    wire is_all_high;\n\n    wire disparity_case_0;\n    wire disparity_case_1;\n    wire disparity_case_2;\n    wire disparity_case_3;\n    wire invert_a_i;\n    wire disp4, disp5, disp6, invert_fj;\n    \n    logic a_w, b_w, c_w, d_w, e_w, i_w, f_w, g_w, h_w, j_w;\n    logic a, b, c, d, e, i, f, g, h, j;\n    logic rd1_part, rd1;\n    logic disparity_reg;\n    logic SorK;\n\n    assign encoder_in_w = encoder_in;\n    assign K = control_in;\n    assign is_all_low          = (!encoder_in_w[0] & !encoder_in_w[1] & !encoder_in_w[2] & !encoder_in_w[3]);\n    assign is_three_low        = (!encoder_in_w[0] & !encoder_in_w[1] & !encoder_in_w[2] &  encoder_in_w[3]) |\n                                 (!encoder_in_w[0] & !encoder_in_w[1] &  encoder_in_w[2] & !encoder_in_w[3]) |\n                                 (!encoder_in_w[0] &  encoder_in_w[1] & !encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] & !encoder_in_w[1] & !encoder_in_w[2] & !encoder_in_w[3]);\n    assign is_two_low_two_high = (!encoder_in_w[0] & !encoder_in_w[1] &  encoder_in_w[2] &  encoder_in_w[3]) |\n                                 (!encoder_in_w[0] &  encoder_in_w[1] &  encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] &  encoder_in_w[1] & !encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] & !encoder_in_w[1] &  encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] & !encoder_in_w[1] & !encoder_in_w[2] &  encoder_in_w[3]) |\n                                 (!encoder_in_w[0] &  encoder_in_w[1] & !encoder_in_w[2] &  encoder_in_w[3]);\n    assign is_three_high       = ( encoder_in_w[0] &  encoder_in_w[1] &  encoder_in_w[2] & !encoder_in_w[3]) |\n                                 ( encoder_in_w[0] &  encoder_in_w[1] & !encoder_in_w[2] &  encoder_in_w[3]) |\n                                 ( encoder_in_w[0] & !encoder_in_w[1] &  encoder_in_w[2] &  encoder_in_w[3]) |\n                                 (!encoder_in_w[0] &  encoder_in_w[1] &  encoder_in_w[2] &  encoder_in_w[3]);\n    assign is_all_high         = ( encoder_in_w[0] &  encoder_in_w[1] &  encoder_in_w[2] &  encoder_in_w[3]);\n\n    assign disparity_case_0    = (!is_two_low_two_high & !is_three_high & !encoder_in_w[4]);\n    assign disparity_case_1    = (is_three_high & !encoder_in_w[3] & !encoder_in_w[4]);\n    assign disparity_case_2    = (is_three_low &  encoder_in_w[3] &  encoder_in_w[4]);\n    assign disparity_case_3    = (!is_two_low_two_high & !is_three_low &  encoder_in_w[4]);\n    assign invert_a_i          = !(ein_rd ? (disparity_case_3 | disparity_case_1 | K) : (disparity_case_0 | disparity_case_2));\n\n    always_comb begin\n        a_w = !encoder_in_w[0];\n        b_w = ((is_all_low) ? 1'b0 : (is_all_high) ? 1'b1 : !encoder_in_w[1]);\n        c_w = ((is_all_low) ? 1'b0 : (is_three_low & encoder_in_w[3] & encoder_in_w[4]) ? 1'b0 : !encoder_in_w[2]);\n        d_w = ((is_all_high) ? 1'b1 : !encoder_in_w[3]);\n        e_w = ((is_three_low & !encoder_in_w[4]) ? 1'b0 : (is_three_low & encoder_in_w[3] & encoder_in_w[4]) ? 1'b1 : !encoder_in_w[4]);\n        i_w = ((is_two_low_two_high & !encoder_in_w[4]) ? 1'b0 : (is_all_low & encoder_in_w[4]) ? 1'b0 : \n               (is_three_low & !encoder_in_w[3] & encoder_in_w[4]) ? 1'b0 : (is_all_high & encoder_in_w[4]) ? 1'b0 : \n               (is_two_low_two_high & K) ? 1'b0 : 1'b1);\n\n        rd1_part = (disparity_case_0 | disparity_case_2 | disparity_case_3);\n        rd1 = (rd1_part | K) ^ ein_rd;\n    end\n\n    assign {a, b, c, d, e, i} = (~invert_a_i) ? {a_w, b_w, c_w, d_w, e_w, i_w} : ~{a_w, b_w, c_w, d_w, e_w, i_w};\n\n    always_comb begin\n        SorK = (e & i & !rd1) | (!e & !i & rd1) | K;\n    end\n\n    assign disp4 = (!encoder_in_w[5] & !encoder_in_w[6]);\n    assign disp5 = (encoder_in_w[5] & encoder_in_w[6]);\n    assign disp6 = ((encoder_in_w[5] ^ encoder_in_w[6])) | K;\n    assign invert_fj = !(rd1 ? disp5 : (disp4 | disp6));\n\n    always_comb begin\n        f_w = ((encoder_in_w[5] & encoder_in_w[6] & encoder_in_w[7] & SorK) ? 1'b1 : !encoder_in_w[5]);\n        g_w = ((!encoder_in_w[5] & !encoder_in_w[6] & !encoder_in_w[7]) ? 1'b0 : !encoder_in_w[6]);\n        h_w = !encoder_in_w[7];\n        j_w = (((encoder_in_w[5] ^ encoder_in_w[6]) & !encoder_in_w[7]) ? 1'b0 : (encoder_in_w[5] & encoder_in_w[6] & encoder_in_w[7] & SorK) ? 1'b0 : 1'b1);\n    end\n\n    assign {f, g, h, j} = (invert_fj | disp6) ? ~{f_w, g_w, h_w, j_w} : {f_w, g_w, h_w, j_w};\n\n    assign disparity_reg = (reset_in) ? 1'b0 : (disp4 | (encoder_in_w[5] & encoder_in_w[6] & encoder_in_w[7])) ^ rd1;\n\n    always_ff @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            disparity_out <= 1'b0;\n            encoder_out <= 10'b0000000000;\n        end else begin\n            if (!control_in) begin\n                disparity_out <= disparity_reg;\n                encoder_out <= {a, b, c, d, e, i, f, g, h, j};\n            end else begin\n                disparity_out <= 1'b0;\n                encoder_out <= 10'b0000000000;\n            end\n        end\n    end\n\nendmodule\n\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    for line in lines[2:]:\n        info = line.split()\n        while len(info) < 3:\n            info.append(\"0%\")\n        inst = re.sub(r'[\\W]', '', info[0])\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'uut' is missing in the coverage log.\")\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))\n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['uut']['Average']}, Target: {target}\"\n"}}}
{"id": "cvdp_copilot_endian_swapper_0004", "categories": ["cid012", "medium"], "input": {"prompt": "Develop a **SystemVerilog testbench** to generate **input stimulus** for the **`endian_swapper`** module with **DATA_BYTES = 8** (64-bit data). The testbench must systematically **apply input sequences** to exercise different functional behaviors of the DUT, ensuring that **all edge cases, control signals, and buffering mechanisms are triggered**. The testbench **must not include any checker logic or pass/fail criteria**\u2014it is purely **stimulus-driven**.\n\n---\n\n## **Design Details**  \n\n### **1. Functional Behavior**  \n\nThe endian swapper module processes input data and optionally swaps byte order based on control register settings. It follows an AXI Stream-based handshake mechanism to handle input and output transactions while maintaining buffering for flow control.\n\n#### **1.1 Parameters**  \n- **`DATA_BYTES = 8`** \u2192 Defines the **byte width** of the data stream (`64 bits`).  \n- **`CLK_PERIOD = 10 ns`** \u2192 The system runs at **100 MHz** (`clk` toggles every `5 ns`).  \n- **`TIMEOUT = 1000`** \u2192 Defines the **maximum wait cycles** for handshake events.  \n\n#### **1.2 Input Ports**  \n- `clk` \u2192 **100 MHz clock** controlling data transfer.  \n- `reset_n` \u2192 **Active-low reset** for DUT initialization.  \n- `stream_in_data [63:0]` \u2192 **64-bit input data bus**.  \n- `stream_in_empty [2:0]` \u2192 **Indicates number of unused bytes** in input.  \n- `stream_in_valid` \u2192 **Asserted when input data is valid**.  \n- `stream_in_startofpacket` \u2192 **Marks start of packet** in input stream.  \n- `stream_in_endofpacket` \u2192 **Marks end of packet** in input stream.  \n- `stream_out_ready` \u2192 **Downstream ready signal** for output transfer.  \n- `csr_address [1:0]` \u2192 **CSR register address**.  \n- `csr_read` \u2192 **CSR read enable**.  \n- `csr_write` \u2192 **CSR write enable**.  \n- `csr_writedata [31:0]` \u2192 **32-bit CSR write data**.  \n\n#### **1.3 Output Ports**  \n- `stream_in_ready` \u2192 **DUT ready to accept input data**.  \n- `stream_out_data [63:0]` \u2192 **64-bit output data bus**.  \n- `stream_out_empty [2:0]` \u2192 **Number of unused bytes** in output.  \n- `stream_out_valid` \u2192 **Asserted when output data is valid**.  \n- `stream_out_startofpacket` \u2192 **Start of packet in output stream**.  \n- `stream_out_endofpacket` \u2192 **End of packet in output stream**.  \n- `csr_readdata [31:0]` \u2192 **CSR readback value**.  \n- `csr_readdatavalid` \u2192 **Indicates valid CSR read response**.  \n- `csr_waitrequest` \u2192 **Indicates CSR access is stalled**.  \n\n---\n\n## **Testbench Structure**  \n\n### **1. Clock Generation**  \n- Generate a **100 MHz clock** (`clk`) by toggling it **every 5 ns** (`CLK_PERIOD/2`).  \n\n### **2. Reset Sequencing**  \n- Assert `reset_n = 0` for a few clock cycles, then deassert it to **initialize the DUT**.  \n\n### **3. DUT Instantiation**  \n- Instantiate the `endian_swapper` module with **DATA_BYTES = 8** and connect all required input/output signals.  \n\n### **4. Stimulus Sequences**  \nThe testbench must **apply a variety of test cases** to exercise input conditions, buffer behavior, and CSR interactions.\n\n#### **4.1 AXI Stream Data Transfers**  \n- **Basic Operation (No Swap)** \u2192 Send a **64-bit word** with byte-swapping disabled.  \n- **Byte Swapping Enabled** \u2192 Enable byte-swapping via CSR and resend test data.  \n- **Packet Boundary Handling** \u2192 Send **multi-word packets** with `startofpacket` and `endofpacket` signals toggling.  \n\n#### **4.2 Flow Control and Buffering**  \n- **Flow Control Handling** \u2192 Deassert `stream_out_ready` while sending data, then re-enable it to test backpressure handling.  \n- **Buffering Mechanism** \u2192 Send **multiple packets** while `stream_out_ready` is **low**, then assert it to drain data.  \n\n#### **4.3 CSR Operations**  \n- **CSR Read/Write** \u2192 Perform CSR **write and readback** operations to configure DUT settings.  \n- **CSR Access in Middle of Packet** \u2192 Issue a **CSR read while data transfer is ongoing**, ensuring the DUT handles CSR operations correctly.  \n\n#### **4.4 Edge Cases**  \n- **Zero Data Handling** \u2192 Send an **all-zero 64-bit word** and observe behavior.  \n- **Maximum Data Handling** \u2192 Send an **all-ones 64-bit word** (`0xFFFFFFFFFFFFFFFF`).  \n- **Partial Empty Bytes** \u2192 Vary `stream_in_empty` values and observe how the DUT processes incomplete words.  \n\n---\n\n## **Simulation Requirements**  \n\n### **1. Waveform Generation**  \n- Generate a **VCD waveform file** (`endian_swapper_tb.vcd`) for **post-simulation analysis**.  \n\n### **2. AXI Stream transactions**  \n- Ensure **proper handshake mechanisms** (`valid`-`ready` interactions) during **data transfer sequences**.  \n\n### **3. CSR and Data Processing Interactions**  \n- The testbench should **issue CSR commands mid-packet** and observe how the DUT handles **simultaneous control and data operations**.  \n\n---\n\nDevelop a **testbench** that:  \n- **Generates stimulus** to exercise `endian_swapper` across multiple functional scenarios.  \n- **Ensures input variations cover** normal operation, byte-swapping, packet boundaries, flow control, and CSR interactions.  \n- **Executes all predefined stimulus sequences** without assertions, output verification, or pass/fail conditions.  ", "context": {}}, "output": {"response": "", "context": {"verif/endian_swapper_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 4-tb-stimulus\nTARGET = 92 ", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite\n", "src/endian_swapper.sv": "module endian_swapper #(\n    parameter DATA_BYTES = 8\n) (\n    input  wire                          clk,\n    input  wire                          reset_n,\n\n    input  wire [(DATA_BYTES*8)-1:0]     stream_in_data,\n    input  wire [$clog2(DATA_BYTES)-1:0] stream_in_empty,\n    input  wire                          stream_in_valid,\n    input  wire                          stream_in_startofpacket,\n    input  wire                          stream_in_endofpacket,\n    output reg                           stream_in_ready,\n\n    output reg [(DATA_BYTES*8)-1:0]      stream_out_data,\n    output reg [$clog2(DATA_BYTES)-1:0]  stream_out_empty,\n    output reg                           stream_out_valid,\n    output reg                           stream_out_startofpacket,\n    output reg                           stream_out_endofpacket,\n    input  wire                          stream_out_ready,\n\n    input  wire [1:0]                    csr_address,\n    output reg  [31:0]                   csr_readdata,\n    output reg                           csr_readdatavalid,\n    input  wire                          csr_read,\n    input  wire                          csr_write,\n    output reg                           csr_waitrequest,\n    input  wire [31:0]                   csr_writedata\n);\n\n////////////////////////////////////////////////////////////////////////////////\n// Localparams to define bit widths explicitly\n////////////////////////////////////////////////////////////////////////////////\nlocalparam DATA_WIDTH  = DATA_BYTES * 8;\nlocalparam EMPTY_WIDTH = $clog2(DATA_BYTES);\n\n// --------------------------------------------------------------------\n// Internal Signals\n// --------------------------------------------------------------------\n\n// TWO-slot buffering\nreg [DATA_WIDTH-1:0]   buffer0_data, buffer1_data;\nreg [EMPTY_WIDTH-1:0]  buffer0_empty, buffer1_empty;\nreg                    buffer0_start, buffer0_end, buffer1_start, buffer1_end;\nreg                    buffer0_valid, buffer1_valid;\n\n// CSR-related\nreg                    byteswapping;\nreg [31:0]             packet_count;\nreg                    in_packet;\nreg                    csr_waitrequest_reg;\n\n// --------------------------------------------------------------------\n// stream_in_ready: at least one buffer slot is free\n// --------------------------------------------------------------------\nalways @* begin\n    if ((buffer0_valid == 1'b0) || (buffer1_valid == 1'b0))\n        stream_in_ready = 1'b1;\n    else\n        stream_in_ready = 1'b0;\nend\n\n// --------------------------------------------------------------------\n// TWO-BUFFER Storage & Shifting\n// --------------------------------------------------------------------\n// Each cycle:\n// 1) If we are consuming the data in buffer0 (stream_out_ready & valid),\n//    then shift buffer1 into buffer0 (if buffer1_valid).\n// 2) If stream_in_valid & stream_in_ready, accept new data into\n//    whichever buffer slot is free (0 if free, else 1).\n// --------------------------------------------------------------------\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        // Clear Buffer0\n        buffer0_valid <= 1'b0;\n        buffer0_data  <= {DATA_WIDTH{1'b0}};\n        buffer0_empty <= {EMPTY_WIDTH{1'b0}};\n        buffer0_start <= 1'b0;\n        buffer0_end   <= 1'b0;\n\n        // Clear Buffer1\n        buffer1_valid <= 1'b0;\n        buffer1_data  <= {DATA_WIDTH{1'b0}};\n        buffer1_empty <= {EMPTY_WIDTH{1'b0}};\n        buffer1_start <= 1'b0;\n        buffer1_end   <= 1'b0;\n    end\n    else begin\n        //-----------------------------------------\n        // 1) Pop / Shift if buffer0 is consumed\n        //-----------------------------------------\n        if ((stream_out_ready == 1'b1) && (stream_out_valid == 1'b1) && (buffer0_valid == 1'b1)) begin\n            if (buffer1_valid == 1'b1) begin\n                // SHIFT buffer1 -> buffer0 (blocking assignment)\n                buffer0_data  <= buffer1_data;\n                buffer0_empty <= buffer1_empty;\n                buffer0_start <= buffer1_start;\n                buffer0_end   <= buffer1_end;\n                buffer0_valid <= 1'b1;\n\n                // Clear buffer1\n                buffer1_valid <= 1'b0;\n                buffer1_data  <= {DATA_WIDTH{1'b0}};\n                buffer1_empty <= {EMPTY_WIDTH{1'b0}};\n                buffer1_start <= 1'b0;\n                buffer1_end   <= 1'b0;\n            end\n            else begin\n                // Buffer1 empty => buffer0 now empty\n                buffer0_valid <= 1'b0;\n            end\n        end\n\n        //-----------------------------------------\n        // 2) Accept new data if there's a free slot\n        //-----------------------------------------\n        if ((stream_in_ready == 1'b1) && (stream_in_valid == 1'b1)) begin\n            // If buffer0 is free, store in buffer0\n            if (buffer0_valid == 1'b0) begin\n                buffer0_valid <= 1'b1;\n                buffer0_data  <= stream_in_data;\n                buffer0_empty <= stream_in_empty;\n                buffer0_start <= stream_in_startofpacket;\n                buffer0_end   <= stream_in_endofpacket;\n            end\n            // Else if buffer1 is free, store in buffer1\n            else if (buffer1_valid == 1'b0) begin\n                buffer1_valid <= 1'b1;\n                buffer1_data  <= stream_in_data;\n                buffer1_empty <= stream_in_empty;\n                buffer1_start <= stream_in_startofpacket;\n                buffer1_end   <= stream_in_endofpacket;\n            end\n            // else: both full => no-op\n        end\n    end\nend\n\n// --------------------------------------------------------------------\n// Packet Counting\n//   - We watch SOP/EOP on output side to track # of packets\n// --------------------------------------------------------------------\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        in_packet    <= 1'b0;\n        packet_count <= 32'd0;\n    end\n    else begin\n        if ((stream_out_valid == 1'b1) && (stream_out_ready == 1'b1)) begin\n            // Start-of-packet\n            if (stream_out_startofpacket == 1'b1) begin\n                packet_count <= packet_count + 32'd1;\n                in_packet    <= 1'b1;\n            end\n            // End-of-packet\n            if (stream_out_endofpacket == 1'b1) begin\n                in_packet <= 1'b0;\n            end\n        end\n    end\nend\n\n// --------------------------------------------------------------------\n// Output Data & Control\n//   - If buffer0_valid => output from buffer0\n//   - If byteswapping=1 => test expects empty=0\n// --------------------------------------------------------------------\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        stream_out_data          <= {DATA_WIDTH{1'b0}};\n        stream_out_empty         <= {EMPTY_WIDTH{1'b0}};\n        stream_out_valid         <= 1'b0;\n        stream_out_startofpacket <= 1'b0;\n        stream_out_endofpacket   <= 1'b0;\n    end\n    else begin\n        if (buffer0_valid == 1'b1) begin\n            // Drive buffer0 contents\n            stream_out_valid <= 1'b1;\n            if (byteswapping == 1'b1) begin\n                for (int i = 0; i < DATA_BYTES; i = i + 1) begin\n                    stream_out_data[i*8 +: 8] <= buffer0_data[(DATA_BYTES-1-i)*8 +: 8];\n                end            \n                stream_out_empty <= {EMPTY_WIDTH{1'b0}};\n            end else begin\n                stream_out_data  <= buffer0_data;\n                stream_out_empty <= buffer0_empty;\n            end\n            stream_out_startofpacket <= buffer0_start;\n            stream_out_endofpacket   <= buffer0_end;\n        end\n        else begin\n            // No data => invalid\n            stream_out_valid         <= 1'b0;\n            stream_out_data          <= {DATA_WIDTH{1'b0}};\n            stream_out_empty         <= {EMPTY_WIDTH{1'b0}};\n            stream_out_startofpacket <= 1'b0;\n            stream_out_endofpacket   <= 1'b0;\n        end\n    end\nend\n\n// --------------------------------------------------------------------\n// CSR Interface\n// --------------------------------------------------------------------\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        byteswapping         <= 1'b0;\n        csr_readdata         <= 32'd0;\n        csr_readdatavalid    <= 1'b0;\n        csr_waitrequest_reg  <= 1'b1;\n    end\n    else begin\n        // The testbench checks that we stall CSR if we're in_packet\n        csr_waitrequest_reg <= in_packet;\n\n        csr_readdatavalid <= 1'b0;\n        // CSR Read\n        if ((csr_read == 1'b1) && (csr_waitrequest_reg == 1'b0)) begin\n            csr_readdatavalid <= 1'b1;\n            case (csr_address)\n                2'b00: csr_readdata <= {31'b0, byteswapping};\n                2'b01: csr_readdata <= packet_count;\n                default: csr_readdata <= 32'd0;\n            endcase\n        end\n\n        // CSR Write\n        if ((csr_write == 1'b1) && (csr_waitrequest_reg == 1'b0)) begin\n            case (csr_address)\n                2'b00: byteswapping <= csr_writedata[0];\n                // 2'b01 => read-only, ignore\n            endcase\n        end\n    end\nend\n\n// Waitrequest output\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n)\n        csr_waitrequest <= 1'b1;\n    else\n        csr_waitrequest <= csr_waitrequest_reg;\nend\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_events_to_apb_0021", "categories": ["cid012", "medium"], "input": {"prompt": "Write a SystemVerilog testbench named `tb_apb_controller` that only generates stimuli for an `apb_controller` module. The testbench should generate input stimuli for different operating conditions and sequences, including the handling of multiple simultaneous events (Event A, Event B, and Event C), proper prioritization, and the built-in timeout mechanism.\n\n---\n\n### Module Overview\n\nThe `apb_controller` is an Advanced Peripheral Bus (APB) write controller that manages write transactions triggered by three independent events (A, B, and C). Each event carries its 32-bit address and 32-bit data input. The controller follows the APB protocol with a three-phase state machine consisting of **IDLE**, **SETUP**, and **ACCESS** phases. Events are triggered by  `select_a_i`, `select_b_i`, and `select_c_i` signals for events A, B, and C respectively. Additionally, it implements a timeout mechanism to prevent indefinite stalling if the peripheral fails to respond within a specified period. it supports multiple event queuing and prioritization, ensuring that events are processed in order while dynamically adjusting their priority based on previous transactions.\n\n---\n\n#### Inputs:\n- **`clk`**: System clock. The design is synchronized to the positive edge of this clock.\n- **`reset_n`**: Active-low asynchronous reset signal that resets the controller to the `IDLE` state, clears the timeout counter, and sets all registers and outputs to 0.\n- **`select_a_i`**: Active-high control signal to initiate a transaction for Event A.\n- **`select_b_i`**: Active-high control signal to initiate a transaction for Event B.\n- **`select_c_i`**: Active-high control signal to initiate a transaction for Event C.\n- **`addr_a_i [31:0]`**: Address input for Event A.\n- **`data_a_i [31:0]`**: Data input for Event A.\n- **`addr_b_i [31:0]`**: Address input for Event B.\n- **`data_b_i [31:0]`**: Data input for Event B.\n- **`addr_c_i [31:0]`**: Address input for Event C.\n- **`data_c_i [31:0]`**: Data input for Event C.\n- **`apb_pready_i`**:  Ready signal from the peripheral, active high. It indicates when the peripheral is ready to complete the transaction. The controller checks this signal in the `ACCESS` phase to determine transaction completion.\n\n#### Outputs:\n- **`apb_psel_o`**: An active-high signal, asserted during `SETUP`, to select the peripheral for an APB transaction.\n- **`apb_penable_o`**: An active-high signal, asserted during the `ACCESS` phase, indicating the transaction is in progress.\n- **`apb_pwrite_o`**: An active-high signal indicating a write operation, asserted during the `SETUP` and maintained in the `ACCESS` phase.\n- **`apb_paddr_o [31:0]`**: 32-bit address output for the transaction, determined by the selected event's address input (`addr_a_i`, `addr_b_i`, or `addr_c_i`). Defaults to 0 in the `IDLE` state.\n- **`apb_pwdata_o [31:0]`**: 32-bit data output for the write operation, based on the selected event's data input (`data_a_i`, `data_b_i`, or `data_c_i`). Defaults to 0 in the `IDLE` state.\n\n### Multiple Simultaneous Behaviour Handling:\n\n#### **1. Event Queuing**\n- The module can track multiple simultaneous events (select_a_i, select_b_i, select_c_i) in an event queue. \n- Once a transaction for a higher-priority event is granted, it gets the lowest priority if triggered again before the queue is emptied.\n\n#### **2. Event Processing**\n- The module processes **one event at a time** from the queue.\n- After completing an event's APB transaction, it is removed from the queue and then the module proceeds to the next event. \n\n#### Transaction Flow and Timing:\n\nThe transactions follow a three-state flow:\n\n1. **IDLE**:\n     - If multiple select signals are asserted simultaneously, the controller prioritizes them as `select_a_i` (highest priority), followed by `select_b_i`, and then `select_c_i` (lowest priority).\n     - Evaluates the event queue to determine the next event to process.\n     - Transition to the `SETUP` state when an event is available.\n     - The **IDLE** phase lasts for one clock cycle when the queue is not empty. \n     - The default state is **IDLE** state, which it enters after a reset and remains in when no transactions are active   \n\n2. **SETUP**:\n   - After the **IDLE** phase, the controller transitions to the **SETUP** phase.\n   - in the **SETUP** phase the controller asserts `apb_psel_o`, and `apb_pwrite_o` and set up `apb_paddr_o` and `apb_pwdata_o` with the selected address and data.\n   - In this phase, `apb_penable_o` remains de-asserted.\n   - The **SETUP** phase lasts for one clock cycle.\n\n3. **ACCESS**:\n   - After the **SETUP** phase, the controller transitions to the **ACCESS** phase.\n   - In **ACCESS**, `apb_penable_o` is asserted high to signal that the data transfer is in progress.\n   - The controller remains in this phase, waiting for `apb_pready_i` from the peripheral to be asserted high.\n   - In **ACCESS** phase, the signals `apb_psel_o`, `apb_pwrite_o`, `apb_paddr_o`, and `apb_pwdata_o` remains stable.\n   - **Write Transfer with Wait**: If `apb_pready_i` is delayed, the controller stays in **ACCESS** until `apb_pready_i` goes high.\n   - **Write Transfer without Wait**: If  `apb_pready_i` goes high in the same clock cycle that the controller enters the **ACCESS** phase, the controller completes the transaction within the same cycle.\n   - **Timeout Mechanism**:\n       - In the **ACCESS** phase, a 4-bit timeout counter increments each clock cycle if `apb_pready_i` remains low.\n       - If `apb_pready_i` is not asserted within 15 cycles after entering the **ACCESS** state, the timeout counter resets the controller to the **IDLE** state and sets all outputs to 0 at the next positive edge, effectively aborting the transaction and preventing indefinite stalling.\n       - The timeout counter resets to zero after a successful transaction or when the controller returns to the **IDLE** state.\n   - After a successful transaction (when `apb_pready_i` is asserted), the controller returns to the **IDLE** state, with both `apb_psel_o` and `apb_penable_o` getting deasserted.\n   - After returning to the IDLE state after the APB transaction of a specific event gets completed (timeout or assertion of `apb_pready_i` to 1) the design processes the next event in the queue in case of multiple simultaneous events and the queue is not empty. If the queue is empty, a new transaction can only start by asserting a select signal (`select_a_i`, `select_b_i`, or `select_c_i`) while both `apb_psel_o` and `apb_penable_o` are low.\n\n### Total Latency for the Transaction:\n\n- **Minimum Latency**: From the triggering of an event when the queue is empty, the latency from the event assertion to the `apb_psel_o` assertion is **3 clock cycles**. (1 cycle each for latching the event signal, updating the queue, and asserting `apb_psel_o` for the triggered event).\n- However, when the queue is not empty, the latency for the `apb_psel_o` assertion for the next event to be processed is **1 clock cycle** after the completion of the first transaction (after de-assertion of all output signals).\n- When an event is retriggered after the completion of its previous APB transaction while the last event in the queue has just started, the latency for asserting `apb_psel_o` for the next event to be processed is 2. This is because the event signal is latched previously (at trigger) and only updating the queue and asserting `apb_psel_o` is required. \n- Signals `apb_pwrite_o`, `apb_paddr_o` and `apb_pwdata_o` are asserted in **SETUP** phase along with `apb_psel_o` and thus have similar latency as `apb_psel_o`.\n- Signal `apb_penable_o` takes one additional clock cycle than `apb_psel_o` as ` apb_penable_o` is asserted one clock cycle later (in the **ACCESS** state).\n- When the event queue is not empty, each STATE requires one cycle except if `apb_pready_i` is delayed, additional cycles are spent in the `ACCESS` state until the peripheral is ready or a timeout occurs\n- After an APB Transaction is completed, it takes 1 cycle to de-assert signals and to return to `IDLE`.\n\n### Constraints:\n- Assume that event signals `select_a_i`, `select_b_i`, and `select_c_i` are pulse signals high for one clock cycle and are synchronous to the clock.\n- Assume that input data and addresses will be stable inputs when the events are triggered.\n- If multiple events are triggered simultaneously, the highest-priority event will be processed first, followed by the other events based on their priority.\n- If any event (`select_a_i`, `select_b_i`, `select_c_i`) is asserted, the same input will not reassert until at least one clock cycle after its previous APB transaction is completed. Once the previous event from a specific input is completed, the next event from the same input can trigger at any time and will be added to the queue for execution after all previously queued events.\n\n---\n\n### Stimulus Generation Requirements:\n\nInstantiate the `apb_controller` module as the `dut` with all required ports connected. The testbench must cover all possible scenarios to achieve 100% coverage.\n\n#### 1. Clock and Reset:\n- Generate a continuous `clk` signal.\n- Drive an active-low asynchronous reset signal to initialize the `dut` in the **IDLE** state.\n\n#### 2. Event Triggering and Priority:\n- Create pulse stimuli for the event select inputs (`select_a_i`, `select_b_i`, and `select_c_i`) that are one clock cycle wide.\n- Generate random stimuli for different scenarios, including simultaneous assertion of multiple event signals (for internal prioritization) and isolated single-event activations (for one event at a time).\n- Generate stimuli for the 32-bit address and data signals for each event (`addr_a_i`, `data_a_i`, `addr_b_i`, `data_b_i`, `addr_c_i`, and `data_c_i`) with fixed or varying values.\n\n#### 3. APB Peripheral Ready Signal:\n- Generate stimuli of the `apb_pready_i` input for:\n    - When `apb_pready_i` is asserted quickly (immediate response) to mimic minimum transaction latency.\n    - When `apb_pready_i` is delayed, causing the `dut` to remain longer in the **ACCESS** state and eventually leading to the timeout mechanism.\n\n---\n\n**Deliverables:**\n\nA SystemVerilog testbench that generates varied input stimuli for the `apb_controller` module according to the above specifications and allows different corner cases for extended testing scenarios.", "context": {}}, "output": {"response": "", "context": {"verif/tb_apb_controller.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 21-tb-stimulus-apb-1\nTARGET = 99\n", "src/apb_controller.sv": "module apb_controller(\n    input  logic         clk,              // Clock signal\n    input  logic         reset_n,          // Active low asynchronous reset signal\n    input  logic         select_a_i,       // Select signal for event A\n    input  logic         select_b_i,       // Select signal for event B\n    input  logic         select_c_i,       // Select signal for event C\n    input  logic [31:0]  addr_a_i,         // 32-bit address for event A transaction\n    input  logic [31:0]  data_a_i,         // 32-bit data for event A transaction\n    input  logic [31:0]  addr_b_i,         // 32-bit address for event B transaction\n    input  logic [31:0]  data_b_i,         // 32-bit data for event B transaction\n    input  logic [31:0]  addr_c_i,         // 32-bit address for event C transaction\n    input  logic [31:0]  data_c_i,         // 32-bit data for event C transaction\n    output logic         apb_psel_o,       // APB select signal\n    output logic         apb_penable_o,    // APB enable signal\n    output logic [31:0]  apb_paddr_o,      // 32-bit APB address output\n    output logic         apb_pwrite_o,     // APB write signal\n    output logic [31:0]  apb_pwdata_o,     // 32-bit APB write data output\n    input  logic         apb_pready_i      // APB ready signal from the peripheral\n);\n\n    // State definitions\n    typedef enum logic [1:0] {\n       IDLE,   \n       SETUP,  \n       ACCESS\n    } state_t; \n\n    logic [3:0]  count;\n    logic [2:0]  event_sel; \n    logic [2:0]  event_sel_ff; \n    logic [2:0]  event_list;    \n    state_t      current_state, next_state;\n    logic [31:0] sel_addr_next, sel_data_next;  \n    logic [31:0] sel_addr, sel_data;          \n    logic select_a_pulse, select_b_pulse, select_c_pulse;\n\n    assign apb_psel_o    = (current_state == SETUP || current_state == ACCESS) ? 1'b1 : 1'b0;\n    assign apb_penable_o = (current_state == ACCESS) ? 1'b1 : 1'b0;\n    assign apb_pwrite_o  = (current_state == SETUP || current_state == ACCESS) ? 1'b1 : 1'b0;\n    assign apb_paddr_o   = (current_state == SETUP || current_state == ACCESS) ? sel_addr : 32'b0;\n    assign apb_pwdata_o  = (current_state == SETUP || current_state == ACCESS) ? sel_data : 32'b0;\n\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            current_state <= IDLE;\n            event_list    <= 3'b000; \n            event_sel_ff    <= 3'b000; \n            select_a_pulse  <= 1'b0;  \n            select_b_pulse  <= 1'b0; \n            select_c_pulse  <= 1'b0;             \n        end else begin\n            select_a_pulse <= (select_a_i) ? 1'b1 : select_a_pulse;\n            select_b_pulse <= (select_b_i) ? 1'b1 : select_b_pulse;\n            select_c_pulse <= (select_c_i) ? 1'b1 : select_c_pulse;      \n            event_sel_ff   <= event_sel;              \n            current_state  <= next_state;\n            if (current_state == IDLE) begin\n               event_list <= (select_a_pulse ? 3'b001 : 3'b000) | \n                               (select_b_pulse ? 3'b010 : 3'b000) |\n                               (select_c_pulse ? 3'b100 : 3'b000); \n            end \n            else if (next_state == IDLE) begin\n               select_a_pulse <= (event_sel[0]) ? 1'b0 : select_a_pulse;\n               select_b_pulse <= (event_sel[1]) ? 1'b0 : select_b_pulse;\n               select_c_pulse <= (event_sel[2]) ? 1'b0 : select_c_pulse;    \n               event_list   <= event_list & ~event_sel; \n            end            \n        end\n    end\n\n\n    always @(*) begin\n        // Default values\n        next_state = current_state;\n        event_sel  = event_sel_ff; \n        case (current_state)\n            IDLE: begin\n                if (event_list[0]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b001;\n                end else if (event_list[1]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b010;\n                end else if (event_list[2]) begin\n                   next_state = SETUP;\n                   event_sel  = 3'b100;\n                end else begin\n                   next_state = IDLE;\n                   event_sel  = 3'b000;\n                end\n            end\n            SETUP: begin\n                next_state = ACCESS;\n            end\n            ACCESS: begin\n                if (apb_pready_i || count == 15) begin\n                    next_state = IDLE;\n                end    \n            end\n            default: begin\n                next_state = IDLE; \n                event_sel  = 3'b000;                 \n            end    \n        endcase\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            count <= 0;\n        end else if (current_state == ACCESS && !apb_pready_i) begin\n            count <= count + 1;\n        end else begin\n            count <= 0;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            sel_addr <= 32'b0;\n            sel_data <= 32'b0;\n        end else if (current_state == IDLE) begin\n            sel_addr <= sel_addr_next;\n            sel_data <= sel_data_next;\n        end\n    end\n    \n    always @(*) begin\n        if (!reset_n) begin\n           sel_addr_next = sel_addr;\n           sel_data_next = sel_data;       \n        end \n        else begin \n            if (next_state == SETUP || next_state == ACCESS) begin\n                case (event_sel)\n                    3'b001: begin    \n                       sel_addr_next = addr_a_i; \n                       sel_data_next = data_a_i;                     \n                    end    \n                    3'b010: begin                    \n                       sel_addr_next = addr_b_i; \n                       sel_data_next = data_b_i;    \n                    end\n                    3'b100: begin                      \n                       sel_addr_next = addr_c_i; \n                       sel_data_next = data_c_i; \n                    end\n                    default: begin\n                       sel_addr_next = 32'b0; \n                       sel_data_next = 32'b0;                     \n                    end \n                endcase           \n            end     \n        end        \n    end    \n\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    print(\"average\",metrics [\"dut\"][\"Average\"])\n    print(\"target\",float(os.getenv(\"TARGET\")))\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_fixed_arbiter_0004", "categories": ["cid012", "easy"], "input": {"prompt": "Write a SystemVerilog testbench to generate stimulus for the `fixed_priority_arbiter` module. The testbench should validate the priority-based grant mechanism by applying different request patterns, including single, multiple, and no request scenarios. Additionally, it should verify the reset functionality and ensure the grant signal is correctly assigned based on priority.\n\n\n## Design Details\n\n1. **Inputs**:  \n   - `clk`: 1-bit clock signal for synchronization.  \n   - `reset`: 1-bit active-high reset signal to initialize the arbiter.  \n   - `req`: 8-bit request signal, where each bit represents a request from a unique source.  \n\n2. **Output**:  \n   - `grant`: 8-bit grant signal, where one bit is set high to indicate the granted request based on a **fixed priority scheme**.  \n\n3. **Module Functionality**:  \n  \n    - **Single Request Handling**:  \n         - Assert one request bit at a time in `req` and verify the corresponding bit in `grant` is set high.  \n    - **Multiple Requests Handling**:  \n        - Simultaneously assert multiple request bits and verify that the arbiter grants access to the **highest-priority request**.  \n    - **No Requests**:  \n        - Assert `req = 8'b00000000` and verify that `grant` is cleared to `8'b00000000`.  \n    - **Reset Behavior**:  \n        - Apply an active reset (`reset = 1`) during active requests and verify that `grant` is cleared to `8'b00000000`.  \n\n---\n\n## **Testbench Requirements**\n\n### **Instantiation**\nThe testbench must instantiate the **fixed_priority_arbiter** module as **dut** with proper connections for all signals.\n\n### **Input Generation**\nThe testbench should generate different request patterns to verify correct priority handling, including:\n- Single Requests: Apply requests one at a time to check correct grant assignment.\n- Multiple Requests: Apply overlapping requests to ensure the arbiter always grants the highest-priority request.\n- No Requests: Ensure the grant signal remains `00000000` when no requests are present.\n- Reset Behavior: Apply reset during active requests to verify that `grant` is cleared.\n\n### **Tasks for Test Stimulus**\n- Apply Reset (`apply_reset`)  \n  - A task to assert `reset`, wait for a few clock cycles, and deassert it to verify correct initialization.\n- Drive Request (`drive_request`)  \n  - A task to apply a specific request pattern, hold it for a few cycles, and check the corresponding grant output.\n\n---\n\nThis testbench will validate the **fixed_priority_arbiter** functionality and ensure its behavior under various input conditions.\n\n", "context": {}}, "output": {"response": "", "context": {"verif/fixed_priority_arbiter_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 1d85e9e4f08880640add8d58fe50caa12b7be21a\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/fixed_priority_arbiter.sv": "`timescale 1ns / 1ps\n\nmodule fixed_priority_arbiter(\n    input clk,             // Clock signal\n    input reset,           // Active high reset signal\n    input [7:0] req,       // 8-bit request signal; each bit represents a request from a different source\n    output reg [7:0] grant // 8-bit grant signal; only one bit will be set high based on priority\n); \n  \n    always @(posedge clk or posedge reset) begin\n    \n        if (reset) \n            grant <= 8'b00000000;\n        else begin\n            if (req[0])\n                grant <= 8'b00000001;\n            else if (req[1])\n                grant <= 8'b00000010;\n            else if (req[2])\n                grant <= 8'b00000100;\n            else if (req[3])\n                grant <= 8'b00001000;\n            else if (req[4])\n                grant <= 8'b00010000;\n            else if (req[5])\n                grant <= 8'b00100000;\n            else if (req[6])\n                grant <= 8'b01000000;\n            else if (req[7])\n                grant <= 8'b10000000;\n            else\n                grant <= 8'b00000000;\n        end\n    end\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_gaussian_rounding_div_0014", "categories": ["cid012", "easy"], "input": {"prompt": "Write a testbench to only generate stimulus for a `divider` that performs non-restoring division for two unsigned positive integer inputs, and generates the output `quotient`, `remainder` and `valid` when computation is completed for the inputs `dividend` and `divisor` when `start` is asserted. In this design, the outputs are generated after WIDTH + 2 clock cycles and the output is considered valid when `valid` is asserted.\n\nThe non-restoring division is a division technique for unsigned binary values that simplifies the procedure by eliminating the restoring phase.\n\n## Design Details\n\n### Parameters\n\n- **`WIDTH`**  \n  - *Default*: 32\n  - *Constraint*: Must be greater than 1  \n  - *Description*: Bit-width of the `dividend` and `divisor`, and thus of the `quotient` and `remainder`.\n\n---\n\n### Port List\n\n| **Port Name**  | **Direction** | **Width**       | **Description and Constraints**                                                                                                                                                             |\n|----------------|---------------|-----------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **`clk`**      | input         | 1 bit           | Main clock input. All operations occur on the rising edge of this signal.                                                                                                                   |\n| **`rst_n`**    | input         | 1 bit           | Active-low asynchronous reset. When asserted (0), resets the internal state machine, outputs and registers to their initial states.                                                         |\n| **`start`**    | input         | 1 bit           | When asserted high, it indicates that valid inputs (`dividend` and `divisor`) are available and a new division operation should begin on the next rising clock edge.                        |\n| **`dividend`** | input         | `WIDTH` bits    | Dividend (the numerator) for the division operation. Must be greater than or equal to 0 and Less than 2<sup>(WIDTH)</sup>-1                                                                 |\n| **`divisor`**  | input         | `WIDTH` bits    | Divisor (the denominator) for the division operation. Must be greater than 0 and Less than 2<sup>(WIDTH-1)</sup>-1.                                                                         |\n| **`quotient`** | output        | `WIDTH` bits    | The integer division result, valid once the module completes the division and `valid` is asserted. The output value is held till the computation of the next set of inputs is completed.    |\n| **`remainder`**| output        | `WIDTH` bits    | The remainder from the division, valid once the module completes the division and `valid` is asserted. The output value is held till the computation of the next set of inputs is completed.|\n| **`valid`**    | output        | 1 bit           | Asserted high when the output (`quotient` and `remainder`) is valid. Remains asserted after the calculation is completed till the `start` input is driven low.                              |\n\n---\n\n## The design follows the following Finite-State Machine (FSM) for division\n\n1. **IDLE**  \n   - **Default/Reset state**.  \n   - Waits for `start` to be asserted.  \n   - On `start`, loads the `dividend` and `divisor` into internal registers, resets the `quotient` and `remainder` registers, and transitions to **BUSY**.\n\n2. **BUSY**  \n   - Performs the **non-restoring** algorithm for `WIDTH` clock cycles.  \n\n3. **DONE**  \n   - Asserts `valid` to indicate outputs are ready.  \n   - Stays in **DONE** until `start` is de-asserted, then returns to **IDLE**.\n\n---\n\n### Latency Considerations of the DUT\nTotal Latency = WIDTH + 2 cycles\n\n### Notes:\n- Division by 0 is not handled in this design\n- When `start` signal is is asserted, the design latches the input `dividend` and `divisor` at the next clock edge.\n- Inputs `dividend` and `divisor` will remain stable until the calculation is complete.\n \n## Testbench requirements:\n\n### Instantiation\n\n- Module Instance: The `divider` module is instantiated as `dut`, with the input and output signals connected for testing.\n---\n\n### Input Generation\n\n- Input Generation: The testbench must generate inputs of WIDTH-bit binary values for `dividend` and `divisor` and 1-bit `start` to cover all possibilities, including the corner cases.\n- Computation Period: After setting each pair of inputs, the testbench waits till assertion of `valid` to ensure the outputs have stabilized, before asserting new values.", "context": {}}, "output": {"response": "", "context": {"verif/divider_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 14-tb-stimulus-non-restoring-divison\nTARGET = 99\n", "src/coverage.cmd": "report -metrics overall -out coverage.log -overwrite\nreport -html -metrics all -out coverage_html -overwrite", "src/divider.sv": "`timescale 1ns/1ps\nmodule divider #\n(\n    parameter WIDTH = 32\n)\n(\n    input  wire                  clk,\n    input  wire                  rst_n,      // Active-low asynchronous reset\n    input  wire                  start,      // Start signal for new operation\n    input  wire [WIDTH-1 : 0]    dividend,   // Dividend (numerator)\n    input  wire [WIDTH-1 : 0]    divisor,    // Divisor (denominator)\n    output wire [WIDTH-1 : 0]    quotient,   // Result of the division\n    output wire [WIDTH-1 : 0]    remainder,  // Remainder after division\n    output wire                  valid       // Indicates output is valid\n);\n\n    // Simple 3-state FSM\n    localparam IDLE = 2'b00;\n    localparam BUSY = 2'b01;\n    localparam DONE = 2'b10;\n\n    reg [1:0] state_reg, state_next;\n\n    // A+Q combined into one 2*WIDTH register:\n    reg [2*WIDTH-1:0] aq_reg, aq_next;\n\n    // Divisor register\n    reg [WIDTH-1:0] m_reg, m_next;\n\n    // Iterate exactly WIDTH times\n    reg [$clog2(WIDTH)-1:0] n_reg, n_next;\n\n    // Final outputs\n    reg [WIDTH-1:0] quotient_reg, quotient_next;\n    reg [WIDTH-1:0] remainder_reg, remainder_next;\n    reg valid_reg, valid_next;\n\n    // Assign the top-level outputs\n    assign quotient  = quotient_reg;\n    assign remainder = remainder_reg;\n    assign valid     = valid_reg;\n\n    //------------------------------------------------\n    // SEQUENTIAL: State & register updates\n    //------------------------------------------------\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg     <= IDLE;\n            aq_reg        <= 0;\n            m_reg         <= 0;\n            n_reg         <= 0;\n            quotient_reg  <= 0;\n            remainder_reg <= 0;\n            valid_reg     <= 0;\n        end\n        else begin\n            state_reg     <= state_next;\n            aq_reg        <= aq_next;\n            m_reg         <= m_next;\n            n_reg         <= n_next;\n            quotient_reg  <= quotient_next;\n            remainder_reg <= remainder_next;\n            valid_reg     <= valid_next;\n        end\n    end\n\n    //------------------------------------------------\n    // COMBINATIONAL: Next-state logic\n    //------------------------------------------------\n    always @* begin\n        // Default \"hold\" behavior\n        state_next     = state_reg;\n        aq_next        = aq_reg;\n        m_next         = m_reg;\n        n_next         = n_reg;\n        quotient_next  = quotient_reg;\n        remainder_next = remainder_reg;\n        valid_next     = valid_reg;\n\n        case (state_reg)\n        //---------------------------------------------\n        // IDLE: Wait for start\n        //---------------------------------------------\n        IDLE: begin\n            // Outputs not valid yet\n            valid_next = 1'b0;\n\n            if (start) begin\n                // Step-1: Initialize\n                // A=0 => top WIDTH bits of aq_reg = 0\n                // Q=dividend => lower WIDTH bits\n                aq_next  = { {WIDTH{1'b0}}, dividend };\n                m_next   = divisor;\n                n_next   = WIDTH;\n                // We do not set the final quotient/remainder yet\n                // Move to BUSY\n                state_next = BUSY;\n            end\n        end\n\n        //---------------------------------------------\n        // BUSY: Perform the N iterations\n        //---------------------------------------------\n        BUSY: begin\n            // 1) SHIFT LEFT\n            aq_next = aq_reg << 1;\n\n            // 2) If sign bit of old A == 1 => add M; else => subtract M.\n            if (aq_reg[2*WIDTH-1] == 1'b1) begin\n                aq_next[2*WIDTH-1 : WIDTH] = aq_next[2*WIDTH-1 : WIDTH] + m_reg;\n            end\n            else begin\n                aq_next[2*WIDTH-1 : WIDTH] = aq_next[2*WIDTH-1 : WIDTH] - m_reg;\n            end\n\n            // 3) Check the new sign bit of A (after the add/sub).\n            //    If sign(A) = 1 => Q[0] = 0; else => Q[0] = 1.\n            if (aq_next[2*WIDTH-1] == 1'b1) begin\n                aq_next[0] = 1'b0;\n            end\n            else begin\n                aq_next[0] = 1'b1;\n            end\n\n            // Decrement iteration count\n            n_next = n_reg - 1;\n\n            // Step-7: if n != 0 => repeat, else => next step\n            if (n_next == 0) begin\n                state_next = DONE;\n            end\n        end\n\n        //---------------------------------------------\n        // DONE: Final correction + output\n        //---------------------------------------------\n        DONE: begin\n            // Step-8: If sign bit of A == 1 => A = A + M\n            if (aq_reg[2*WIDTH-1] == 1'b1) begin\n                aq_next = aq_reg;  // default\n                aq_next[2*WIDTH-1 : WIDTH] = aq_reg[2*WIDTH-1 : WIDTH] + m_reg;\n            end\n\n            // Step-9: \n            //   - The final quotient is the lower WIDTH bits of aq_reg\n            //   - The final remainder is the upper WIDTH bits of aq_reg\n            quotient_next  = aq_next[WIDTH-1 : 0];\n            remainder_next = aq_next[2*WIDTH-1 : WIDTH];\n\n            // Output becomes valid\n            valid_next = 1'b1;\n\n            // Return to IDLE when 'start' goes low\n            if (!start) begin\n                state_next = IDLE;\n            end else begin\n                state_next = DONE;\n            end\n        end\n\n        default: begin\n            state_next = IDLE;\n        end\n        endcase\n    end\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Simulation didn't run correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage merge didn't run correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    try:\n        with open(\"/code/rundir/coverage.log\") as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage.log file.\")\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    print(\"Parsed Metrics:\")\n    print(metrics)\n\n    # Ensure TARGET environment variable is set\n    target = os.getenv(\"TARGET\")\n    if not target:\n        raise ValueError(\"TARGET environment variable is not set.\")\n    target = float(target)\n\n    # Check coverage for the DUT or specific key\n    dut = \"dut\"  # Replace this with the DUT key you want to check\n    if dut in metrics and \"Overall Average\" in metrics[dut]:\n        assert float(metrics[dut][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        # Log available keys for debugging\n        print(f\"Available keys in metrics: {metrics.keys()}\")\n        assert False, f\"Coverage data for '{dut}' is not available.\""}}}
{"id": "cvdp_copilot_gcd_0028", "categories": ["cid012", "easy"], "input": {"prompt": "Write a testbench to only generate stimulus for a `gcd_3_ip` that calculates the greatest common divisor (GCD) for three signed inputs, using the Euclidean algorithm, and generates the output `OUT` and `done` sequentially when `go` is asserted and inputs `A`, `B` and `C` are applied. In this design, the `OUT` output is generated over multiple clock cycles, and the output is considered valid when `done` is asserted.\n\nThe Euclidean algorithm calculates the GCD by iteratively replacing the larger of two numbers with the difference between the two numbers. This process is repeated, reducing the larger number each time, until the two numbers become equal. At this point, the value of either number is the GCD of the original inputs.\n\n## Design Details\n\n**Parameterization**  \n- `WIDTH` (Default 32, must be greater than 0 and less than 33): Bit-width of `A`, `B`, `C` and `OUT `.\n- `SIGNED_EN` (Default 1):  Enable (SIGNED_EN=1) or disable (SIGNED_EN=0) signed input handling.\n\n**Functionality**  \n1. **Computation, Accumulation, and Output Stage**\n   - Computes the GCD of the three inputs and assigns to `OUT`, making it available as the final output.\n\n2. **Done Signal Behavior**\n   - The `done` signal goes high after the `OUT` is fully computed and valid.\n\n3. **Reset Behavior**\n   - `rst`: Active-high synchronous reset. When asserted high, it immediately clears all registers and outputs to 0, including `OUT`, `done`.\n\n### Inputs and Outputs\n- **Inputs**:\n  - `clk`: Clock signal. The design should be synchronized to the positive edge of this clock signal..\n  - `rst`: Active high synchronous reset signal.\n  - `A [WIDTH-1:0]`: Input value A.\n  - `B [WIDTH-1:0]`: Input value B.\n  - `C [WIDTH-1:0]`: Input value C.\n  - `go`: Start signal to initiate GCD calculation. Active high.\n\n- **Outputs**:\n  - `OUT [WIDTH-1:0]`: Output for the calculated GCD.\n  - `done`: Active high signal that indicates when the computation is complete. \n\n### Additional Details\n\n- **Control Signal Behavior**:\n  - Both `go` and `done` are asserted high for one cycle.\n  - Once `done` is asserted, new inputs will be fed to the system on the current rising edge of `clk` following this assertion. \n\n\n## Testbench requirements:\n\n**Instantiation**\n\n- Module Instance: The gcd_3_ip module should be instantiated as `dut`, with the input and output signals connected for testing.\n---\n\n**Input Generation**\n\n- Input Generation: The testbench must generate inputs of WIDTH-bit binary values for `A`, `B` and `C` and 1-bit `go`  to cover all possibilities, including the corner cases. Include negative values if SIGNED_EN is 1. Also test for input value 0.\n- Computation Period: After setting each pair of inputs, the testbench should wait till assertion of `done` to ensure the outputs have stabilized, before asserting new values.", "context": {}}, "output": {"response": "", "context": {"verif/gcd_top_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 28-tb-for-gcd-3-ip-with-0-and-signed-input\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log -overwrite\nreport -html -metrics all -out coverage_html -overwrite", "src/gcd_top.sv": "`timescale 1ns/1ps\nmodule gcd_3_ip #(\n   parameter WIDTH = 32,\n   parameter SIGNED_EN = 1\n   )(\n   input                     clk,\n   input                     rst,\n   input  [WIDTH-1:0]        A,\n   input  [WIDTH-1:0]        B,\n   input  [WIDTH-1:0]        C,\n   input                     go,\n   output logic  [WIDTH-1:0] OUT,\n   output logic              done\n);\n\nlogic [WIDTH-1:0] gcd_ab;\nlogic [WIDTH-1:0] gcd_bc;\nlogic             go_abc;\nlogic             done_ab;\nlogic             done_bc;\nlogic             done_ab_latched;\nlogic             done_bc_latched;\n\n// GCD is calculated for AB and BC in parallel. The GCD for two numbers is lower than the numbers themselves in most cases.\n// And calculating GCD for smaller numbers is comparatively faster using the implemented algorithm.\n// Hence in order to reduce GCD computation latency the calculation is broken up in this fashion.\n\ngcd_top\n#( .WIDTH(WIDTH),\n   .SIGNED_EN(SIGNED_EN)\n) gcd_A_B_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (A),\n   .B             (B),\n   .go            (go),\n   .OUT           (gcd_ab),\n   .done          (done_ab)\n);\n\ngcd_top\n#( .WIDTH(WIDTH),\n   .SIGNED_EN(SIGNED_EN)\n) gcd_B_C_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (B),\n   .B             (C),\n   .go            (go),\n   .OUT           (gcd_bc),\n   .done          (done_bc)\n);\n\ngcd_top\n#( .WIDTH(WIDTH),\n   .SIGNED_EN(SIGNED_EN)\n) gcd_ABC_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (gcd_ab),\n   .B             (gcd_bc),\n   .go            (go_abc),\n   .OUT           (OUT),\n   .done          (done)\n);\n\nalways_ff @ (posedge clk) begin\n   if (rst) begin\n      done_ab_latched    <= 0;\n      done_bc_latched    <= 0;\n   end else begin\n      if(done_ab) begin\n         done_ab_latched <= done_ab;\n      end else if (go_abc) begin\n         done_ab_latched <= 0;\n      end\n\n      if(done_bc) begin\n         done_bc_latched <= done_bc;\n      end else if (go_abc) begin\n         done_bc_latched <= 0;\n      end\n   end\nend\n\nassign go_abc = done_ab_latched & done_bc_latched;\n\nendmodule\n\nmodule gcd_top #(\n   parameter WIDTH = 32,              // Parameter to define the bit-width of the input and output data\n   parameter SIGNED_EN = 1\n   )(\n   input                     clk,   // Clock signal\n   input                     rst,   // Active High Synchronous reset signal\n   input  [WIDTH-1:0]        A,     // Input operand A\n   input  [WIDTH-1:0]        B,     // Input operand B\n   input                     go,    // Start signal to begin GCD computation\n   output logic  [WIDTH-1:0] OUT,   // Output for the GCD result\n   output logic              done   // Signal to indicate completion of computation\n);\n\n   // Internal signals to communicate between control path and data path\n   logic equal;                     // Signal indicating A == B\n   logic greater_than;              // Signal indicating A > B\n   logic [1:0] controlpath_state;   // Current state of the control FSM\n\n   // Instantiate the control path module\n   gcd_controlpath gcd_controlpath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .go                (go),                // Connect go signal\n      .equal             (equal),             // Connect equal signal from datapath\n      .greater_than      (greater_than),      // Connect greater_than signal from datapath\n      .controlpath_state (controlpath_state), // Output current state to datapath\n      .done              (done)               // Output done signal\n   );\n\n   // Instantiate the data path module\n   gcd_datapath\n   #( .WIDTH(WIDTH),\n      .SIGNED_EN(SIGNED_EN)\n   ) gcd_datapath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .A                 (A),                 // Connect input A\n      .B                 (B),                 // Connect input B\n      .controlpath_state (controlpath_state), // Connect current state from control path\n      .equal             (equal),             // Output equal signal to control path\n      .greater_than      (greater_than),      // Output greater_than signal to control path\n      .OUT               (OUT)                // Output GCD result\n   );\nendmodule\n\n\n// Datapath module for GCD computation\nmodule gcd_datapath  #(\n   parameter WIDTH = 32,                           // Bit-width of operands\n   parameter SIGNED_EN = 1\n   )(\n   input                     clk,                // Clock signal\n   input                     rst,                // Active High Synchronous reset\n   input  [WIDTH-1:0]        A,                  // Input operand A\n   input  [WIDTH-1:0]        B,                  // Input operand B\n   input  [1:0]              controlpath_state,  // Current state from control path\n   output logic              equal,              // Signal indicating A_ff == B_ff\n   output logic              greater_than,       // Signal indicating A_ff > B_ff\n   output logic  [WIDTH-1:0] OUT                 // Output GCD result\n);\n\n   // Registers to hold intermediate values of A and B\n   logic [WIDTH-1:0] A_ff;\n   logic [WIDTH-1:0] B_ff;\n   logic [WIDTH-1:0] A_abs;\n   logic [WIDTH-1:0] B_abs;\n\n   // State encoding for control signals\n   localparam S0 = 2'd0;    // State 0: Initialization state\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff, subtract B_ff from A_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff, subtract A_ff from B_ff\n\n   always_comb begin\n      A_abs = A[WIDTH-1]? -A : A;\n      B_abs = B[WIDTH-1]? -B : B;\n   end\n\n   // Sequential logic to update registers based on controlpath_state\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         // On reset, initialize registers to zero\n         A_ff <= 'b0;\n         B_ff <= 'b0;\n         OUT  <= 'b0;\n      end else begin\n         case (controlpath_state)\n            S0: begin\n                // In state S0, load input values into registers\n                A_ff  <= SIGNED_EN? A_abs : A;\n                B_ff  <= SIGNED_EN? B_abs : B;\n             end\n            S1: begin\n                // In state S1, computation is done, output the result\n                OUT  <= A_ff;\n             end\n            S2: begin\n                // In state S2, A_ff > B_ff, subtract B_ff from A_ff\n                if (greater_than) begin\n                   if (~|B_ff) begin\n                       B_ff <= A_ff;\n                   end else begin\n                       A_ff <= A_ff - B_ff;\n                   end\n                end\n            end\n            S3: begin\n               // In state S3, B_ff > A_ff, subtract A_ff from B_ff\n               if (!equal & !greater_than) begin\n                  if(~|A_ff) begin\n                     A_ff <= B_ff;\n                  end else begin\n                     B_ff <= B_ff - A_ff;\n                  end\n               end\n            end\n            default: begin\n                A_ff <= 'b0;\n                B_ff <= 'b0;\n                OUT <= 'b0;\n            end\n         endcase\n      end\n   end\n\n   // Generating control response signals for the control path FSM\n   always_comb begin\n      case(controlpath_state)\n         S0: begin\n            // In state S0, compare initial input values A and B\n            if(SIGNED_EN) begin\n               equal        = (A_abs == B_abs)? 1'b1 : 1'b0;\n               greater_than = (A_abs >  B_abs)? 1'b1 : 1'b0;\n            end else begin\n               equal        = (A == B)? 1'b1 : 1'b0;\n               greater_than = (A >  B)? 1'b1 : 1'b0;\n            end\n         end\n         default: begin\n            // In other states, compare the current values in registers A_ff and B_ff\n            equal        = (A_ff == B_ff)? 1'b1 : 1'b0;\n            greater_than = (A_ff >  B_ff)? 1'b1 : 1'b0;\n         end\n      endcase\n   end\nendmodule\n\n// Control path module for GCD computation FSM\nmodule gcd_controlpath (\n   input                    clk,               // Clock signal\n   input                    rst,               // Active High Synchronous reset\n   input                    go,                // Start GCD calculation signal\n   input                    equal,             // From Datapath: A_ff equals B_ff\n   input                    greater_than,      // From Datapath: A_ff is greater than B_ff\n   output logic [1:0]       controlpath_state, // Current state to Datapath\n   output logic             done               // Indicates completion of GCD calculation\n);\n\n   // Internal state registers\n   logic [1:0] curr_state;  // Current state of FSM\n   logic [1:0] next_state;  // Next state of FSM\n\n   // State encoding\n   localparam S0 = 2'd0;    // State 0: Initialization or waiting for 'go' signal\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff\n\n   // State latching logic: Update current state on clock edge\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         curr_state   <= S0;   // On reset, set state to S0\n      end else begin\n         curr_state   <= next_state;   // Transition to next state\n      end\n   end\n\n   // State transition logic: Determine next state based on current state and inputs\n   always_comb begin\n      case(curr_state)\n         S0: begin\n            // State S0: Waiting for 'go' signal\n            if(!go)\n               next_state = S0;         // Remain in S0 until 'go' is asserted\n            else if (equal)\n               next_state = S1;         // If A == B, computation is complete\n            else if (greater_than)\n               next_state = S2;         // If A > B, go to state S2\n            else\n               next_state = S3;         // If B > A, go to state S3\n         end\n         S1: begin\n            // State S1: Computation complete, output the result\n            next_state = S0;           // Return to S0 after completion\n         end\n         S2: begin\n            // State S2: A_ff > B_ff, subtract B_ff from A_ff\n            if(equal)\n               next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n            else if (greater_than)\n               next_state = S2;         // If A_ff > B_ff, stay in S2\n            else\n               next_state = S3;         // If B_ff > A_ff, go to S3\n         end\n         S3: begin\n            // State S3: B_ff > A_ff, subtract A_ff from B_ff\n            if (equal)\n               next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n            else if (greater_than)\n               next_state = S2;         // If A_ff > B_ff, go to S2\n            else\n               next_state = S3;         // If B_ff > A_ff, stay in S3\n         end\n         default: begin\n             next_state = S0;\n         end\n      endcase\n   end\n\n   // Output logic: Generate 'done' signal when computation is complete\n   always_ff @ (posedge clk) begin\n      if(rst) begin\n         done <= 1'b0;               // On reset, 'done' is low\n      end else begin\n         done <= (curr_state == S1); // 'done' is asserted when in state S1\n      end\n   end\n\n   // Assign current state to output for datapath\n   assign controlpath_state = curr_state;\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Simulation didn't run correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage merge didn't run correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    try:\n        with open(\"/code/rundir/coverage.log\") as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage.log file.\")\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    print(\"Parsed Metrics:\")\n    print(metrics)\n\n    # Ensure TARGET environment variable is set\n    target = os.getenv(\"TARGET\")\n    if not target:\n        raise ValueError(\"TARGET environment variable is not set.\")\n    target = float(target)\n\n    # Check coverage for the DUT or specific key\n    dut = \"dut\"  # Replace this with the DUT key you want to check\n    if dut in metrics and \"Overall Average\" in metrics[dut]:\n        assert float(metrics[dut][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        # Log available keys for debugging\n        print(f\"Available keys in metrics: {metrics.keys()}\")\n        assert False, f\"Coverage data for '{dut}' is not available.\""}}}
{"id": "cvdp_copilot_generic_nbit_counter_0013", "categories": ["cid012", "easy"], "input": {"prompt": "Create a `tb_generic_counter` module that serves as the top-level testbench. This module should instantiate and include a `stimulus_generator` module, which must be developed to systematically drive different input conditions to the `generic_counter` module. The `stimulus_generator` should be designed to achieve 100% functional and code coverage by exercising all counting modes implemented in the `generic_counter`. These counting modes include binary up/down counting, modulo-N counting, Johnson counting, Gray code counting, and Ring counting. The counter operates based on an enable signal, a mode signal, and a configurable reference modulo value.\n\n---\n\nFollows the interface description of the RTL module.\n\n## **Inputs** \n \n- **Parameter**:  \n  - `N`: A configurable Parameter Value. The default Value is 8. \n\n- **Control Signals**:  \n  - `mode_in [2:0]`: A 3-bit register selecting the counter mode.  \n  - `enable_in`: A 1-bit register enabling the counter operation.  \n\n- **Clock Signal**:  \n  - `clk_in`: The counter updates its value on the rising edge of this clock signal.  \n\n- **Reset Signal**:  \n  - `rst_in`: A 1-bit asynchronous, active-high reset signal. When asserted HIGH, the counter resets to zero.  \n\n- **Reference Modulo Value**:  \n  - `ref_modulo [N-1:0]`: A configurable N-bit reference value used for modulo-N counting.  \n\n\n## **Outputs**  \n\n- **Registers**:  \n  - `o_count [N-1:0]`: An N-bit output representing the current counter value.  \n\n---\n\n## **Instantiation**  \n\n- **Module Instance**:  \n  - The `generic_counter` module is instantiated as `uut` in the testbench, with its inputs and outputs connected for testing.  \n\n---\n\n## **Input Generation**  \n\n1. **Mode Coverage**:  \n   - The testbench must ensure that all counting modes are exercised:  \n     - `BINARY_UP`: Counts up sequentially.  \n     - `BINARY_DOWN`: Counts down sequentially.  \n     - `MODULO_256`: Resets when `o_count == ref_modulo`.  \n     - `JOHNSON`: Implements Johnson's counter behavior.  \n     - `GRAY`: Converts binary count to Gray code.  \n     - `RING`: Implements a rotating one-hot sequence.  \n\n2. **Enable Behavior**:  \n   - Toggle `enable_in` dynamically and ensure that counting stops when `enable_in = 0`.  \n\n3. **Modulo-N Counting**:  \n   - Provide various `ref_modulo` values to the module.  \n\n4. **Reset Behavior**:  \n   - Test asynchronous reset by asserting `rst_in` during different counter states.  \n   - Ensure that `o_count` resets to zero when `rst_in` is active.  \n\n5. **Edge Cases**:  \n   - There will be a random transition between different counting modes during operation.  \n   - Initialize the RTL `count` register to a random value and run it in different modes.\n\n6. **Timing Requirements**:  \n   - After applying inputs, the testbench waits for a stabilization period of **300 clock cycles** before asserting new values.\n\n7. **Stimulus Generator IO Ports**:  \n\n- **`clk` (input, 1-bit)**: Clock signal synchronizes the stimulus generation process.\n- **`rst` (output, 1-bit)**: Active-high reset signal that initializes the `generic_counter` module.\n- **`mode` (output, 3-bit)**: Specifies the counting mode for the `generic_counter`. Different values correspond to different counting modes such as binary up/down, modulo-N, Johnson, Gray code, and Ring counting.\n- **`enable` (output, 1-bit)**: Enables the `generic_counter` operation when asserted high.\n- **`check_sync` (output, 1-bit)**: Indicates when to check the correctness of the counter output.\n- **`ref_modulo` (output, N-bit)**: Configurable modulo value, primarily used in modulo-N counting mode to define the counting range.\n\n---\n\n## **Module Functionality**  \n\n1. **Asynchronous Reset**:  \n   - When `rst_in` is asserted HIGH, `o_count` is reset to `0`.  \n\n2. **Counting Modes**:  \n   - The counter updates `o_count` based on `mode_in`:  \n     - **Binary Up/Down Counting**: Increments or decrements the counter.  \n     - **Modulo Counting**: Resets `o_count` when reaching `ref_modulo`.  \n     - **Johnson Counter**: Implements shift-and-invert behavior.  \n     - **Gray Code Counter**: Converts binary count to Gray code.  \n     - **Ring Counter**: Circulates a single `1` through the bit positions.  \n\n3. **Enable Control**:  \n   - If `enable_in = 0`, `o_count` remains unchanged.  \n\n---\n\n## **Testbench Features**  \n\n- **Input Scenarios**:  \n  - Cover all possible counter modes.  \n  - Randomize `mode_in`, `enable_in`, and `ref_modulo` to simulate diverse use cases.  \n\n- **Simulation Observations**:  \n  - Use `$monitor` to log counter transitions, mode changes, and reset events for debugging.  ", "context": {}}, "output": {"response": "", "context": {"verif/tb_generic_counter.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = f6bd528da7c299af11aceb77f495e5c4820a2dd2\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite\n", "src/generic_counter.sv": "\r\nmodule generic_counter #(parameter N = 8) (\r\n    input logic clk_in,          // Clock input\r\n    input logic rst_in,          // Active HIGH Reset input\r\n    input logic [2:0] mode_in,   // Mode input (3 bits)\r\n    input logic enable_in,       // Enable input\r\n    input logic [N-1:0] ref_modulo, // Reference modulo value for Modulo-N counter\r\n    output logic [N-1:0] o_count   // Output count (N bits)\r\n);\r\n\r\n    parameter BINARY_UP = 3'b000;\r\n    parameter BINARY_DOWN = 3'b001;\r\n    parameter MODULO_256 = 3'b010;\r\n    parameter JOHNSON = 3'b011;\r\n    parameter GRAY = 3'b100;\r\n    parameter RING = 3'b101;\r\n\r\n    logic [N-1:0] count;\r\n\r\n    always_ff @(posedge clk_in or posedge rst_in) begin\r\n        if (rst_in) begin\r\n            count <= {N{1'b0}};\r\n        end else if (enable_in) begin\r\n            case (mode_in)\r\n                BINARY_UP: begin\r\n                    count <= count + 1;\r\n                end\r\n                \r\n\t\tBINARY_DOWN: begin\r\n                    count <= count - 1;\r\n                end\r\n                \r\n\t\tMODULO_256: begin\r\n                    if (count == ref_modulo) begin\r\n                        count <= {N{1'b0}};\r\n                    end else begin\r\n                        count <= count + 1;\r\n                    end\r\n                end\r\n                \r\n\t\tJOHNSON: begin\r\n                    count <= {~count[0], count[N-1:1]};\r\n                end\r\n                \r\n\t\tGRAY: begin\r\n                    count <= count + 1;\r\n                end\r\n                \r\n\t\tRING: begin\r\n                    if (count == {N{1'b0}}) begin\r\n                        count <= {{(N-1){1'b0}}, 1'b1};\r\n                    end else begin\r\n                        count <= {count[N-2:0], count[N-1]};\r\n                    end\r\n                end\t\t\r\n                \r\n\t\tdefault: begin\r\n                    count <= {N{1'b0}};\r\n                end\r\n            endcase\r\n        end\r\n    end\r\n\r\n    \r\n    assign o_count = (mode_in == GRAY) ? ((count) ^ (count >> 1)) : count;\r\n\r\nendmodule\r\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_gf_multiplier_0047", "categories": ["cid012", "medium"], "input": {"prompt": "Create a testbench to generate stimuli for the `gf_mac` module, which computes a byte-wide Galois Field (2<sup>8</sup>) multiply-accumulate function over two `WIDTH`-bit inputs (`a` and `b`). The module also supports a passthrough mode and provides status signals for validity, readiness, and error indication.\n\n---\n## Description\n\nThe `gf_mac` module processes two input values by breaking them into 8-bit segments and multiplies each corresponding segment in GF(2<sup>8</sup>). The partial products are then XORed together to form an 8-bit accumulation result (`result`). A passthrough mode is included, allowing direct output of `a[7:0]` instead of the GF multiply-accumulate result. The module provides the `valid_result` and `ready` signals to indicate when the output can be sampled, and sets `error_flag` if the specified `WIDTH` is not a multiple of 8.\n\n---\n## Inputs\n\n### **1. Parameters**\n- **`WIDTH`**  \n  - **Type**: Integer parameter  \n  - **Default / Typical**: 32  \n  - **Purpose**: Defines the bit width of inputs `a` and `b`. Must be a multiple of 8 for proper GF(2<sup>8</sup>) segmentation.  \n  - **Impact**: If `WIDTH` is not divisible by 8, the module asserts `error_flag` and forces the result output to `8'b0`.  \n\n### **2. Registers / Signals for Stimulus**\n- **`reset`**  \n  - **Bit Width**: 1  \n  - **Purpose**: Asynchronous reset signal. When asserted, internal registers and outputs are forced to their default state.  \n  - **Usage**: Drives the module to initialize or clear state before applying new inputs.\n\n- **`enable`**  \n  - **Bit Width**: 1  \n  - **Purpose**: Activation signal to start the multiply-accumulate process. When low, the outputs remain at default values.  \n  - **Usage**: Driven high for normal operation or low to hold outputs in an inactive state.\n\n- **`pass_through`**  \n  - **Bit Width**: 1  \n  - **Purpose**: Mode selector. When set, the module outputs `a[7:0]` directly, bypassing the GF multiply-accumulate logic.  \n  - **Usage**: Driven high or low to test both normal GF MAC operation and pass-through behavior.\n\n- **`a [WIDTH-1:0]`**  \n  - **Bit Width**: `WIDTH` (e.g., 32 bits by default)  \n  - **Purpose**: First input operand for the GF MAC calculation or direct source (when `pass_through` is set).  \n  - **Usage**: Driven with a variety of patterns (random, edge, corner cases) to exercise the internal GF segments.\n\n- **`b [WIDTH-1:0]`**  \n  - **Bit Width**: `WIDTH` (e.g., 32 bits by default)  \n  - **Purpose**: Second input operand for the GF MAC calculation, partitioned into 8-bit segments for multiplication.  \n  - **Usage**: Driven alongside `a` to cover different multiply-accumulate scenarios in GF(2<sup>8</sup>).\n\n---\n## Outputs\n\n- **`result [7:0]`**  \n  - **Bit Width**: 8  \n  - **Purpose**: Final 8-bit accumulation of GF(2<sup>8</sup>) partial products or direct pass-through from `a[7:0]` when `pass_through` is set.  \n  - **Usage**: Observed after applying stimulus to determine the outcome of the GF MAC or pass-through operation.\n\n- **`valid_result`**  \n  - **Bit Width**: 1  \n  - **Purpose**: Indicates that `result` is valid when `enable` is asserted and `WIDTH` is a multiple of 8.  \n  - **Usage**: Sampled to confirm that the output is ready and valid in the current cycle.\n\n- **`ready`**  \n  - **Bit Width**: 1  \n  - **Purpose**: Mirrors `valid_result` in this design. Signals the environment that the module has produced the final output.  \n  - **Usage**: Observed to coordinate data flow, especially if additional handshake logic is applied.\n\n- **`error_flag`**  \n  - **Bit Width**: 1  \n  - **Purpose**: Asserts high when `WIDTH` is not divisible by 8. Remains low if `WIDTH` is valid.  \n  - **Usage**: Checked to detect or log configuration errors or unsupported widths during stimulus application.\n\n---\n## Instantiation\n\nA single instance of the `gf_mac` module can be created, supplying `reset`, `enable`, `pass_through`, `a`, and `b` as stimulus inputs and capturing `result`, `valid_result`, `ready`, and `error_flag` as outputs. The parameter `WIDTH` can be set to 32 or other multiples of 8 to explore different valid configurations, or to a non-multiple of 8 to observe the `error_flag` behavior.\n\n---\n## Input Generation and Observations\n\n1. **Deterministic Stimuli**  \n   - **Zero Inputs**: Apply `a=0`, `b=0` with `enable=1`, checking if the module outputs `0x00`.  \n   - **Simple Patterns**: Use known 8-bit segments repeated across `a` and `b` (e.g., `0x00000001`, `0xFFFFFFFF`) to observe repeated partial multiplications.  \n   - **Pass-Through Mode**: Set `pass_through=1` and apply different values to `a` to confirm that `result` matches `a[7:0]`.\n\n2. **Toggle Reset**  \n   - Assert `reset` for a period before releasing it, ensuring the module clears its outputs to default and deasserts `error_flag` unless `WIDTH` is invalid.\n\n3. **Valid and Invalid `WIDTH` Tests**  \n   - Use a `WIDTH` multiple of 8 (e.g., 32) to keep `error_flag` low and observe proper GF MAC operation.  \n   - Optionally modify `WIDTH` to a non-multiple of 8 in a separate simulation run to observe `error_flag` assertion and forced zero output.\n\n4. **Random Stimuli**  \n   - Generate random patterns for `a` and `b` to stress the partial products across the 8-bit segments.  \n   - Randomly switch `enable` and `pass_through` to exercise state transitions while capturing the resultant behavior.\n\n5. **Timing Intervals**  \n   - Change inputs at defined or random time steps (e.g., 5\u201310 time units) to capture the module\u2019s combinational output.  \n   - Log and compare results after each stimulus to observe the correlation with input patterns.\n\n---\n## Module Interface\n\n### **Inputs**\n- **`reset` (1 bit)**: Active-high reset for the internal state.\n- **`enable` (1 bit)**: Activates the GF MAC operation when high.\n- **`pass_through` (1 bit)**: Selects direct pass of `a[7:0]` vs. GF MAC accumulation.\n- **`a [WIDTH-1:0]`**: First operand for the GF(2<sup>8</sup>) accumulate or pass-through data.\n- **`b [WIDTH-1:0]`**: Second operand for the GF(2<sup>8</sup>) accumulate.\n\n### **Outputs**\n- **`result [7:0]`**: 8-bit GF MAC output or direct pass of `a[7:0]`.\n- **`valid_result` (1 bit)**: Indicates a valid `result` when `enable` is high and `WIDTH` is valid.\n- **`ready` (1 bit)**: Mirrors the `valid_result` signal.\n- **`error_flag` (1 bit)**: High if `WIDTH` is invalid (not multiple of 8), otherwise low.\n\n---\n## Module Functionality\n\n- **GF MAC Calculation**  \n  - When `enable` is high and `pass_through` is low, the module slices `a` and `b` into 8-bit segments and multiplies each pair using a GF(2<sup>8</sup>) multiplier. The partial products are XORed to produce `result`.\n\n- **Pass-Through Mode**  \n  - When `pass_through` is high and `enable` is high, the 8-bit portion `a[7:0]` is directly mapped to `result`. \n\n- **Readiness & Validity**  \n  - The signals `valid_result` and `ready` both indicate that the output is finalized and stable under valid conditions (`WIDTH % 8 == 0`).\n\n- **Error Indication**  \n  - The signal `error_flag` is asserted if `WIDTH` is not divisible by 8. In that case, `result` is forced to `8'b0`, and `valid_result` remains low.\n\n---\n## Additional Notes\n\n- **GF Multiplier Usage**: Internally, the module instantiates multiple `gf_multiplier` blocks (one per 8-bit segment of `a` and `b`) to compute partial products.\n- **Coverage of Corner Cases**: Stimuli can include values with alternating bits, large or small decimal representations, and identical inputs for both `a` and `b` to exercise the reduction logic in the GF multipliers.\n- **Scalability**: The parameterizable `WIDTH` allows the environment to explore larger or smaller inputs, provided the requirement (`WIDTH % 8 == 0`) is satisfied.", "context": {}}, "output": {"response": "", "context": {"verif/gf_mac_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = d6607a8bd6315fd792b07574d43b38cdd1cd3bab\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/gf_mac.sv": "`timescale 1ns/1ps\nmodule gf_mac#(parameter WIDTH=32)(\n    input reset,\n    input enable,\n    input pass_through,\n    input [WIDTH-1:0] a,\n    input [WIDTH-1:0] b,\n    output [7:0] result,\n    output valid_result,\n    output ready,\n    output error_flag\n);\n    localparam WIDTH_VALID = (WIDTH % 8 == 0);\n\n    reg [7:0] result_reg;\n    reg [7:0] mux_result;\n\n    assign error_flag = (reset) ? 1'b0 : (!WIDTH_VALID);\n    assign valid_result = (reset) ? 1'b0 : ((enable && WIDTH_VALID) ? 1'b1 : 1'b0);\n    assign ready = (reset) ? 1'b0 : ((enable && WIDTH_VALID) ? 1'b1 : 1'b0);\n    assign result = (reset) ? 8'b0 : mux_result;\n\n    generate\n        if (WIDTH_VALID) begin : gen_valid\n            integer i;\n            reg [7:0] temp_result;\n            wire [7:0] partial_results[(WIDTH/8)-1:0];\n            genvar j;\n            for (j = 0; j < WIDTH/8; j = j + 1) begin: gen_segments\n                gf_multiplier u_gf_multiplier(\n                    .A(a[(j+1)*8-1 : j*8]),\n                    .B(b[(j+1)*8-1 : j*8]),\n                    .result(partial_results[j])\n                );\n            end\n            always @(*) begin\n                temp_result = 8'b0;\n                if (!reset && enable && !pass_through) begin\n                    for (i = 0; i < WIDTH/8; i = i + 1) begin\n                        temp_result = temp_result ^ partial_results[i];\n                    end\n                end\n                result_reg = temp_result;\n            end\n        end\n    endgenerate\n\n    always @(*) begin\n        if (!WIDTH_VALID) begin\n            result_reg = 8'b0;\n        end\n        if (!reset && enable && pass_through && WIDTH_VALID) begin\n            mux_result = a[7:0];\n        end else if (!reset && enable && WIDTH_VALID) begin\n            mux_result = result_reg;\n        end else begin\n            mux_result = 8'b0;\n        end\n    end\nendmodule\n\n\nmodule gf_multiplier(\n    input [7:0] A,\n    input [7:0] B,\n    output reg [7:0] result\n);\n    reg [7:0] temp_result;\n    reg [8:0] multiplicand;\n    localparam [8:0] IRREDUCIBLE_POLY = 9'b100011011;\n    integer i;\n    always @(*) begin\n        temp_result = 8'b0;\n        multiplicand = {1'b0, A};\n        for (i = 0; i < 8; i = i + 1) begin\n            if (B[i]) begin\n                temp_result = temp_result ^ multiplicand[7:0];\n            end\n            multiplicand = multiplicand << 1;\n            if (multiplicand[8]) begin\n                multiplicand = multiplicand ^ IRREDUCIBLE_POLY;\n            end\n        end\n        result = temp_result;\n    end\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    for line in lines[2:]:\n        info = line.split()\n        while len(info) < 3:\n            info.append(\"0%\")\n        inst = re.sub(r'[\\W]', '', info[0])\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'dut' is missing in the coverage log.\")\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))\n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['dut']['Average']}, Target: {target}\""}}}
{"id": "cvdp_copilot_gray_to_binary_0014", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench for the `gray_to_binary` module, which converts an N-bit Gray code input into its N-bit binary equivalent using combinational logic. The testbench must have the instantiation of RTL module and generate stimulus for various test conditions.\n\n### Interface of gray_to_binary RTL Module\n\n**Parameter:**\n  - `WIDTH`: Width of the Gray code(`Default: 4`)\n\n**Inputs:**\n  - `gray_in [WIDTH-1:0]`: The Gray code input that needs to be converted into binary.\n\n**Outputs:**\n  - `binary_out [WIDTH-1:0]`: The corresponding binary output derived from the Gray code input.\n\n## \n### Input Generation and Validation\n\n1. Fixed Test Cases\n    - Test a variety of Gray code inputs, including:\n      - Boundary values (0, `max value`)\n      - Alternating bit patterns (`0101`, `1010`)\n      - Power-of-two values to check conversion correctness.\n    - Example test values:\n      - `0000`, `0001`, `0011`, `0110`, `1111`, `1000`, `1100`, `1010`.\n\n2. Randomized Testing\n    - Generate random Gray code values and compare them against a reference binary conversion function.\n\n3. Edge Cases\n    - Minimum Input (`gray_in = 0`) \u2192 Expected Binary Output: `0000`\n    - Maximum Input (`gray_in = 1111`) \u2192 Expected Binary Output: `1000`\n    - One-bit change transitions:\n      - `0001 \u2192 0000`\n      - `0011 \u2192 0010`\n      - `0111 \u2192 0100`\n    - Ensures that only one bit changes at a time.\n___\n### Instantiation\nInstantiate the RTL module inside the testbench and name the instance as `uut`.\n\n##\n### Module Functionality\n\n1. XOR-Based Conversion Logic\n    - The MSB of `binary_out` is directly assigned from gray_in's MSB.\n    - Each subsequent bit is computed as:\n                `B[i]=B[i+1] XOR G[I]`\n\n2. Test One-Bit Change Property\n    - Ensure that each successive Gray code value only changes one bit when converted back to binary.\n   ", "context": {}}, "output": {"response": "", "context": {"verif/tb_gray_to_binary.sv": ""}}, "harness": {"files": {"docker-compose.yml": "\nservices:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 0eef2298523a980bd1d86b2705da865b3e91f662\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/gray_to_binary.sv": "`timescale 1ns / 1ps\n\nmodule gray_to_binary #(\n    parameter WIDTH = 4\n) (\n    input  logic [WIDTH-1:0] gray_in,    // Gray code input\n    output logic [WIDTH-1:0] binary_out  // Binary output\n);\n\n  always @* begin\n    binary_out[WIDTH-1] = gray_in[WIDTH-1];\n    for (int i = WIDTH - 2; i >= 0; i = i - 1) begin\n      binary_out[i] = binary_out[i+1] ^ gray_in[i];\n    end\n  end\n\nendmodule\n\n", "src/process.py": "import os\r\nimport re\r\nimport subprocess\r\nimport pytest\r\n\r\n# ----------------------------------------\r\n# - Simulate\r\n# ----------------------------------------\r\n\r\n@pytest.mark.usefixtures(scope='session')\r\ndef test_simulate():\r\n\r\n    cmd = \"xrun -coverage all /src/gray_to_binary.sv /code/verif/tb_gray_to_binary.sv -covtest test -seed random -covoverwrite\"\r\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\r\n\r\n# ----------------------------------------\r\n# - Generate Coverage\r\n# ----------------------------------------\r\n\r\n@pytest.mark.usefixtures(scope='test_simulate')\r\ndef test_coverage():\r\n\r\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\r\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\r\n\r\n# ----------------------------------------\r\n# - Report\r\n# ----------------------------------------\r\n\r\n@pytest.mark.usefixtures(scope='test_coverage')\r\ndef test_report():\r\n\r\n    metrics = {}\r\n\r\n    with open(\"/code/rundir/coverage.log\") as f:\r\n        lines = f.readlines()\r\n\r\n    # ----------------------------------------\r\n    # - Evaluate Report\r\n    # ----------------------------------------\r\n\r\n    for line in lines[2:]:\r\n        info = line.split()\r\n\r\n        inst = info [0]\r\n        avg  = info [1]\r\n        cov  = info [2]\r\n\r\n        inst = re.sub(r'[\\W]', '', inst)\r\n\r\n        metrics [inst] = {\r\n            \"Average\" : float(avg[:-1]),\r\n            \"Covered\" : float(cov[:-1])\r\n        }\r\n\r\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_hamming_code_tx_and_rx_0029", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench that only supplies stimulus to a `hamming_code_tx_for_4bit` module, which encodes 4-bit input data `data_in` into an 8-bit output `data_out` using Hamming code principles for error detection and correction. Hamming code helps generate parity bits, which are combined with the original data to detect and correct single-bit errors.\n\n\n---\n## **Testbench Description**\n\n**Inputs**\n\n- Registers: `data_in` is a 4-bit register that provides binary inputs to the module.\n\n**Outputs**\n\n- Wire: An 8-bit wire, `data_out`, with 4 data bits, 3 parity bits and an extra redundant bit added to pad the output to 8 bits.\n\n---\n\n## **Instantiation**\n\n- Module Instance: The `hamming_code_tx_for_4bit` module should be instantiated as **uut_transmitter**, with the input and output signals connected for testing.\n\n---\n\n## **Input Generation and Validation**\n\n- Input Generation: The testbench must generate pairs of 4-bit binary values for `data_in` to cover all possibilities, including corner cases.\n- Corner cases Input Generation: The testbench must generate pairs of 4-bit binary values from minimum value 0 to maximum 2<sup>4</sup> - 1\n- Stabilization Period: After setting each pair of inputs, the testbench waits 10 time units to ensure the outputs have stabilized before asserting new values.\n\n---\n\n## **RTL Specification:**\n\n1. **Module interface:** \n\n- Input:\n     `data_in[3:0]`: A 4-bit input signal representing the original data to be transmitted.\n- Output:\n     `data_out[7:0]`: An 8-bit output signal representing the encoded data.\n\n\n2. **Module Functionality**:\n\nThe module encodes the data based on the following steps:\n\n1. `data_out[0]`: This bit is fixed to 0 as a redundant bit.\n2. `data_out[1]`, `data_out[2]` `data_out[4]`: Parity bits , calculated using the XOR operation to ensure even parity of specific input bits.\n3. `data_out[3]`, `data_out[5]`, `data_out[6]`, `data_out[7]`: These are assigned `data_in[0]`, `data_in[1]`, `data_in[2]`, `data_in[3]` respectively, preserving the order of the input data.\n   \n3 **Timing and Synchronization:**\n- This design is purely combinational. The output must be immediately updated with a change in the input.", "context": {}}, "output": {"response": "", "context": {"verif/testbench_for_tx.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 7d500602776b97b13e1cc97c3218c229ab1483b4\nTARGET = 91\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html\n", "src/hamming_code_tx_for_4bit.sv": "module hamming_code_tx_for_4bit( \n  input[3:0] data_in,\n  output[7:0] data_out\n);\n  assign data_out[0] = 1'b0;\n  assign data_out[1] = data_in[0] ^ data_in[1] ^ data_in[3]; // 2^0\n  assign data_out[2] = data_in[0] ^ data_in[2] ^ data_in[3]; // 2^1\n  assign data_out[3] = data_in[0];\n  assign data_out[4] = data_in[1] ^ data_in[2] ^ data_in[3]; // 2^2\n  assign data_out[5] = data_in[1];\n  assign data_out[6] = data_in[2];\n  assign data_out[7] = data_in[3];\nendmodule \n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/hamming_code_tx_for_4bit.sv /code/verif/testbench_for_tx.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut_transmitter\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_hamming_code_tx_and_rx_0031", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench to only supply stimulus to a `hamming_code_receiver` module. This module decodes an 8-bit input signal and detects single-bit errors using Hamming code principles. The receiver performs \"even parity checks\" to identify single-bit errors in `data_in` and provides corrected 4-bit data through the output port `data_out[3:0]`.\n\n---\n\n### **RTL Specification**\n\n#### 1. **Module Interface**\n\n**Inputs:**  \n- `data_in[7:0]` \u2013 An 8-bit input signal containing 4 data bits, 3 parity bits, and 1 redundant bit.\n\n**Output:**  \n- `data_out[3:0]` \u2013 A 4-bit output signal containing the corrected data if an error is detected. If no error is detected, the output mirrors the data bits in the input (`data_in`).\n\n#### 2. **Module Functionality**\n\nThe module uses Hamming code principles to detect and correct single-bit errors in the 8-bit input (`data_in`). The organization of bits in the input is as follows:  \n- **Parity Bits:** Placed at positions that are powers of 2 in `data_in`:\n  - `data_in[1]` (2<sup>0</sup> = 1),  \n  - `data_in[2]` (2<sup>1</sup> = 2),  \n  - `data_in[4]` (2<sup>2</sup> = 4).  \n- **Data Bits:** Placed sequentially in positions that are not powers of 2:\n  - `data_in[3]`, `data_in[5]`, `data_in[6]`, and `data_in[7]`.\n\n#### 2.1. **Error Detection and Correction**\n\n- The module calculates three syndrome bits (`c1`, `c2`, `c3`) using XOR operations on specific data and parity bits from `data_in`. These syndrome bits indicate the position of any error within the 7 most significant bits (`data_in[7:1]`).\n- If an error is detected, the incorrect bit is corrected.  \n\n#### 2.2. **Output Assignment**\n\n- After error correction, the module retrieves the 4 data bits from the corrected input and assigns them to the output port `data_out[3:0]`.  \n- The positions of the data bits in the input correspond to:\n  - `data_in[3]`, `data_in[5]`, `data_in[6]`, and `data_in[7]`.\n\n#### 3. **Timing and Synchronization**\n\n- The design is purely combinational, meaning the output is updated immediately after any change in the input.\n\n\n\n---\n\n### **Testbench Requirements**\n\n- **Module Instance:** The `hamming_code_receiver` module should be instantiated as **`uut_receiver`**, with input and output signals connected for testing.\n\n---\n\n### **Input Generation and Validation**\n\n1. **Input Generation:**  \n   - The testbench should generate all possible 4-bit binary values for input data (ranging from the minimum value (0) to the maximum value (2<sup>4</sup> - 1)) and extend it to include encoding bits before supplying the stimulus to the design, ensuring coverage of both typical cases and edge cases.  \n\n3. **Golden Encoder Logic:**  \n   - Inputs provided to the module should follow a specific pattern similar to data generated from a transmitter following hamming code principles. It should also ensure that erroneous input data is supplied with only single-bit errors (as the RTL is capable of correcting only single-bit errors)\n   - The testbench should encode the generated 4-bit data into an 8-bit data (golden encoded data) using Hamming code principles for error detection.  \n   - The encoding process based on Hamming code principles is as follows:  (Assume the 4-bit data generated internally is `data_in` and it is extended to `golden_data_out`)\n     1. **`golden_data_out[0]`**: A redundant bit, fixed at 0.  \n     2. **`golden_data_out[1]`**: Parity bit ensuring even parity (XOR) for the input bits at positions `data_in[0]`, `data_in[1]`, and `data_in[3]`.  \n     3. **`golden_data_out[2]`**: Parity bit ensuring even parity (XOR) for the input bits at positions `data_in[0]`, `data_in[2]`, and `data_in[3]`.  \n     4. **`golden_data_out[4]`**: Parity bit ensuring even parity (XOR) for the input bits at positions `data_in[1]`, `data_in[2]`, and `data_in[3]`.  \n     5. **`golden_data_out[3]`, `golden_data_out[5]`, `golden_data_out[6]`, `golden_data_out[7]`**: These are the data bits `data[0]`, `data[1]`, `data[2]`, and `data[3]` respectively, in the same order.  \n   - To simulate errors, a single bit in the **golden encoded data** must be randomly modified. This modified data should then be assigned to the input of the design under test (**`uut_receiver`**).  \n\n4. **Stabilization Period:**  \n   - After assigning each input value, the testbench must wait for 10 time units to ensure that the outputs have stabilized before asserting new values.  \n\n---", "context": {}}, "output": {"response": "", "context": {"verif/testbench_for_hamming_rx.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 72ca8649c47feda1ef5faa77f8121b7d54429dac\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html\n", "src/hamming_code_receiver.sv": "module hamming_code_receiver (\n  input[7:0] data_in,\n  output [3:0] data_out\n);\n \n  wire c1,c2,c3,error;\n  reg[7:0] correct_data;\n \n \n  assign c3 =  data_in[1] ^ data_in[3] ^ data_in[5] ^ data_in[7];\n  assign c2 =  data_in[2] ^ data_in[3] ^ data_in[6] ^ data_in[7];\n  assign c1 =  data_in[4] ^ data_in[5] ^ data_in[6] ^ data_in[7];\n \n  assign error = ({c3,c2,c1}==3'b000) ? 1'b0 : 1'b1;\n \n  always@(*)\n  begin\n    correct_data = 0;\n    if(error)\n    begin\n      correct_data             = data_in;\n      correct_data[{c1,c2,c3}] = ~correct_data[{c1,c2,c3}];\n    end\n    else\n    begin\n      correct_data             = data_in;\n    end\n  end\n \n assign data_out = {correct_data[7],correct_data[6],correct_data[5],correct_data[3]};\n \nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/hamming_code_receiver.sv /code/verif/testbench_for_hamming_rx.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut_receiver\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_hamming_code_tx_and_rx_0037", "categories": ["cid012", "easy"], "input": {"prompt": "Develop a SystemVerilog testbench named `testbench_for_hamming_rx` to only supply stimuli to and achieve maximum possible coverage for an RTL design named  `hamming_rx` . The module is a **parameterized Hamming code receiver** that takes an encoded input signal (`data_in`), which contains **data bits, parity bits, and a redundant bit**, and detects and corrects **only single-bit errors**. The corrected data is then assigned to `data_out`. Error detection and correction are performed using Hamming code principles, specifically **even parity checks (XOR operations)**.  \n\n---\n### **RTL Specification for `hamming_rx`**\n\n#### Parameterization:\n- **DATA_WIDTH**: Specifies the width of the data input, configurable by the user. The default is 4 and should be greater than 0.\n- **PARITY_BIT**: Specifies the number of parity bits, also configurable by the user. The default is 3.\n  - The **number of parity bits** should be the minimum integer value that satisfies the Hamming code formula:\n    [2<sup>p</sup>  >= (p + m) + 1], where m is the number of data bits and p is the number of parity bits.\n    For example, if `m = 4`:\n    - `p = 0` results in \\(2<sup>0</sup>  >= 0 + 5\\), which is false.\n    - `p = 1` results in \\(2<sup>1</sup>  >= 1 + 5\\), which is false.\n    - `p = 2` results in \\(2<sup>2</sup>  >= 2 + 5\\), which is false.\n    - `p = 3` results in \\(2<sup>3</sup>  >= 3 + 5\\), which is true and the minimum value to satisfy the condition\n- **ENCODED_DATA**: Calculated as the sum of `PARITY_BIT + DATA_WIDTH + 1`, representing the total input width according to the Hamming code formula.\n    - `+1` accounts for the \"no error\" state in the input (`data_in`) by adding a redundant bit as the least significant bit.\n    - For example, if `m = 4` and `p = 3`, then `ENCODED_DATA = 8`.\n- **ENCODED_DATA_BIT**: Calculated as the minimum number of bits required to index `ENCODED_DATA`.\n  - For example, if `m = 4`, `p = 3`, and `ENCODED_DATA = 8`, then `ENCODED_DATA_BIT = 3`.\n\n#### Input/Output Specifications:\n- **Inputs:**\n  - `data_in[ENCODED_DATA-1:0]`: Encoded data containing the redundant bit, original data, and parity bits.\n- **Outputs:**\n  - `data_out[DATA_WIDTH-1:0]`: An output signal containing the corrected data if an error is detected. If no error is detected, this output will mirror the data bits in the Encoded input (`data_in`).\n\n#### Behavioral Definitions:\n   - The number of parity bits is determined based on the configured `PARITY_BIT` parameter.  \n   - Each parity bit is calculated by performing an XOR operation over specific bits in `data_in`.\n   - Individual parity bits are combined into an error detection code, which represents the parity check result.  \n   - Based on the parity check result  \n       - The design locates and inverts the erroneous bit position at the error location.  \n       - Note: The redundant bit at position 0 is not inverted.  \n4. **Output Assignment**:\n      - The data bits are retrieved from the internal **corrected data** and assigned to `data_out` from least significant bit (LSB) to most significant bit (MSB), with the lowest-index bit picked from the corrected data mapped to the LSB of `data_out`, progressing to the MSB. This ensures that `data_out` contains only the **corrected data bits, excluding the parity bits and the redundant bit**. \n\n### **Testbench Description**\n\n#### **Instantiation**\n\n- **Module Instance:** The `hamming_rx` module should be instantiated as **`uut_receiver`**, with parameters, input and output signals connected for testing.\n\n--- \n### **Input Generation and Validation**\n\n1. **Input Generation:**  \n   - The testbench should generate all possible DATA_WIDTH-bit binary values for input data (ranging from the minimum value (0) to the maximum value (2<sup>DATA_WIDTH</sup> - 1)) and extend it to include encoding bits before supplying the stimulus to the design, ensuring coverage of both typical cases and edge cases.  \n\n3. **Golden Encoder Logic:**  \n   - Inputs provided to the module should follow a specific pattern similar to data generated from a transmitter following Hamming code principles. It should also ensure that erroneous input data is supplied with only single-bit errors (as the RTL is capable of correcting only single-bit errors)\n   \n   - The testbench should encode the generated DATA_WIDTH-bit data into an ENCODED_DATA-bit data (golden encoded data). The encoding process based on Hamming code principles is explained in the Hamming code transmitter specification given below.  \n   \n        **Hamming code transmitter function:** This function takes an input `[DATA_WIDTH-1:0] input_data` and generates an encoded output `[ENCODED_DATA-1:0] temp_data`.\n        \n        1. **Step 1**: Clear all internal registers to 0, including an internal PARITY_BIT-width array named `parity` for holding calculated parity bit values.\n        2. **Step 2**: Assign `input_data` to `temp_data`.\n           - Parity bits are placed at `temp_data` positions corresponding to powers of 2. (e.g., indices 2<sup>0</sup> = 1, 2<sup>1</sup> = 2, 2<sup>2</sup> = 4, etc.) and  `temp_data[0]` is a redundant bit which is always set to 1'b0.\n           - The bits of `input_data` are mapped sequentially, starting from the least significant bit (LSB) to the most significant bit (MSB), into the non-parity and non-redundant positions of `temp_data`. The LSB of `input_data` aligns with the lowest-index non-parity and non-redundant position in `temp_data`, and the order of the bits is preserved.\n           - Example:\n             - For `DATA_WIDTH = 4` and `PARITY_BIT = 3`, `ENCODED_DATA` is 8, and `ENCODED_DATA_BIT` is 3:\n             - The `temp_data` assignment is as follows:\n               - `temp_data[0]` - position 000 - assign **1'b0**.\n               - `temp_data[1]` - position 001 - reserve for **parity[0]**.\n               - `temp_data[2]` - position 010 - reserve for **parity[1]**.\n               - `temp_data[3]` - position 011 - assign `input_data[0]`.\n               - `temp_data[4]` - position 100 - reserve for **parity[2]**.\n               - `temp_data[5]` - position 101 - assign `input_data[1]`.\n               - `temp_data[6]` - position 110 - assign `input_data[2]`.\n               - `temp_data[7]` - position 111 - assign `input_data[3]`.\n        3. **Step 3**: Calculate the even parity bits based on the Hamming code principle.\n           - Define **PARITY_BIT** (e.g., for `PARITY_BIT = 3`, calculate `parity[0]`, `parity[1]`, and `parity[2]`).\n           - Each parity bit calculation: For each parity bit `parity[n]` (where n ranges from 0 to PARITY_BIT-1), determine its value by performing an XOR operation on the bits in `temp_data` located at indices where the n<sup>th</sup> bit (counting from the least significant bit) of the binary index is 1. For example:\n             -  `parity[0]` includes all indices where the least significant bit (LSB) of the binary index is 1. (positions 00**1**, 01**1**, 10**1**, and 11**1** in `temp_data`).\n                 - Calculation: `parity[0] = XOR of temp_data[1], temp_data[3], temp_data[5], temp_data[7]`.\n             -   `parity[1]` includes indices where the second bit from the LSB of the binary index is 1, and so forth. (positions 0**1**0, 0**1**1, 1**1**0, and 1**1**1 in `temp_data`).\n                 - Calculation: `parity[1] = XOR of temp_data[2], temp_data[3], temp_data[6], temp_data[7]`.\n        4. **Step 4**: Insert the calculated parity bits into `temp_data` at positions corresponding to powers of 2.\n          \n   - To simulate errors, a single bit in the **golden encoded data** (generated from the transmitter function above) should be randomly modified. This modified data is then assigned to the input `data_in[ENCODED_DATA-1:0]` of the design under test (**`uut_receiver`**).  \n\n4. **Stabilization Period:**  \n   - After assigning each input value, the testbench should wait for at least 10 time units to ensure that the outputs have stabilized before asserting new values.  ", "context": {}}, "output": {"response": "", "context": {"verif/testbench_for_hamming_rx.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 37-tb_for_stimulus_tx\nTARGET = 97\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite\n", "src/hamming_rx.sv": "module hamming_rx \n#(\n  parameter DATA_WIDTH   = 4,\n  parameter PARITY_BIT   = 3,\n  parameter ENCODED_DATA = PARITY_BIT + DATA_WIDTH + 1,\n  parameter ENCODED_DATA_BIT = $clog2(ENCODED_DATA)\n)\n(\n  input  [ENCODED_DATA-1:0] data_in, \n  output reg [DATA_WIDTH-1:0] data_out\n);\n  \n  localparam PARITY = $clog2(PARITY_BIT);\n  \n  reg [PARITY_BIT-1:0] parity;\n  reg [PARITY:0] j;\n  reg [$clog2(DATA_WIDTH)-1:0] count;\n  reg [ENCODED_DATA-1:0] corrected_data;\n\n  reg [ENCODED_DATA_BIT:0] i,k;\n  \n  always @(*) \n  begin\n    parity        = {PARITY_BIT{1'b0}};\n    data_out      = {DATA_WIDTH{1'b0}};\n    i             = {1'b1,{ENCODED_DATA_BIT{1'b1}}};\n    j             = {1'b1,{PARITY{1'b1}}};\n    k             = {1'b1,{ENCODED_DATA_BIT{1'b1}}};\n    count         = 0;\n    corrected_data = data_in;\n\n\n    for (j = 0; j < PARITY_BIT; j = j + 1) \n    begin\n      for (i = 1; i < ENCODED_DATA; i = i + 1) \n      begin\n        if ((i & (1 << j)) != 0) \n        begin\n          parity[j] = parity[j] ^ data_in[i];\n        end\n      end\n    end\n    \n    corrected_data[parity] = (|parity) ? ~corrected_data[parity] : corrected_data[parity];\n\n    for (k = 1; k < ENCODED_DATA; k = k + 1) \n    begin\n      if ((k & (k - 1)) != 0) \n      begin \n        data_out[count] = corrected_data[k];\n        count = count + 1;\n      end\n    end\n  end\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/hamming_rx.sv /code/verif/testbench_for_hamming_rx.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut_receiver\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_hebbian_rule_0020", "categories": ["cid012", "medium"], "input": {"prompt": "Create a SystemVerilog testbench module named `tb_hebb_gates` that instantiates the `hebb_gates` module as the Unit Under Test (UUT). The testbench must include a stimulus generator that systematically drives various input conditions to achieve a minimum of 95% code and functional coverage for the `hebb_gates` module. The `hebb_gates` implements a Moore Finite State Machine (FSM) to train a Hebbian learning model. The module takes signed 4-bit inputs (`a` and `b`), a 2-bit gate selector, and control signals for starting the FSM and resetting the system. It sequentially performs training steps such as weight initialization, target selection, weight/bias updates, and convergence checks using the Hebbian learning rule. The module outputs the updated weights (`w1` and `w2`), bias, and the FSM's current and next state. The system uses a gate selection module to determine the target outputs based on logical gate operations for training.\n\n## Design Specifications:\n- Hebbian rule is a type of unsupervised neural network learning algorithm\n\n## Abstract Algorithm:\n- The hebbian or hebb rule works based on the following algorithm\n\n-  **Step 1**: Initialize all the weights and bias to zero.\n                                  w<sub>I</sub> = 0 for i = 1 to n, n is the number of input vectors\n\n- **Step 2**: For each input training vector and target output pair, do the following:\n\n    - **Step 2a**: Set activation for input units\n                         x<sub>i</sub>=s<sub>i</sub>, x is a register to store the input vector, where x is a register to store the input vector\n\n    -  **Step 2b**: Set activation for output unit\n                            y = t, where t is the target vector and y is the output vector\n\n    -  **Step 2c**: Adjust the weights and bias\n                         w<sub>i</sub>(new) = w<sub>i</sub>(old) + delta_w\n                         bias(new) = bias(old) + delta_b\n                          Where:\n                            delta_w = x<sub>I</sub> * t\n                            delta_b = t\n                   \n## Inputs and Outputs:\n## Inputs:\n- `clk` (1-bit): Posedge Clock signal.\n- `rst` (1-bit): Asynchronous Negedge Reset signal. When asserted LOW , the FSM is initialized to State_0 and iteration counter is initialized to 0.\n- `start `(1-bit): Active HIGH Signal to initiate the FSM.\n- `a`, `b` (4-bit each, [3:0], signed): Bipolar input signals [-1 ,1]. Only -1 and 1 have to be considered as valid inputs\n- `target_select`(2-bit,[1:0]): Selector to specify the target for a given gate.\n- `gate_select` (2-bit,[1:0]): Selector to specify the given gate\n## Outputs:\n- `w1`, `w2` (4-bit each,[3:0], signed): Trained weights for the inputs.\n- `bias` (4-bit, signed,[3:0]): Trained bias value.\n- `present_state`, `next_state` (4-bit each,[3:0]): Current and next states of the Training FSM.\n\n**Instantiation** :\nThe testbench instantiates the `hebb_gates` module as uut and connects the signals between the module and the testbench. Each input and output from the uut is connected to its corresponding signal in the testbench.\n\n## **Input Generation and Validation**:\n**Stimulus**: The test bench should employ multiple tasks to simulate training epochs for different gate selections, each applying a sequence of input stimuli. Each task should correspond to one epoch for a given gate configuration and varies the input combinations of signals' a and `b`, along with control signals `gate_select` and `target_select`.\n\n**Gate 00 (gate_select = 2\u2019b00) Epochs**:\n\n**Test Case 1: First Epoch for Gate 00**:\n- Control: `gate_select` should be set to 00, `target_select` should be set to 00, and `start` should be asserted HIGH.\n- Inputs: A sequence where (a, b) takes on values: (1, 1) \u2192 (1, \u20131) \u2192 (\u20131, 1) \u2192 (\u20131, \u20131).\n\n**Test Case 2: Second Epoch for Gate 00**:\n- Control: `gate_select` should be set to 00, and `target_select` should be set to 01.\n- Inputs: The sequence is modified to start with (\u20131, \u20131) and then vary through (\u20131, 1), (1, \u20131), and (1, 1).\n\n**Test Case 3: Third Epoch for Gate 00**:\n- Control: `gate_select` should be set to 00, `target_select` should be set to 10.\n- Inputs: Similar to previous epochs but with a different ordering of input polarity to test consistency in weight and state transitions.\n\n**Test Case 4: Fourth Epoch for Gate 00**:\n- Control: `gate_select` should be set to 00, `target_select` should be set to 11.\n- Inputs: Another permutation of input values is applied to verify module behavior further.\n\n**Test Case 5: Fifth Epoch for Gate 00 (Invalid Target)**:\n- Control: `gate_select` should be set to 00, `target_select` should be set to an unknown value (2\u2019bxx).\n- Inputs: Standard sequence similar to the first epoch.\n\n**Gate 01 (gate_select = 2\u2019b01), Gate 10 (gate_select = 2\u2019b10), and Gate 11 (gate_select = 2\u2019b11) Epochs**:\n- For each valid gate (01, 10, 11), the testbench defines four epochs with explicitly defined target selections (00, 01, 10, 11) and a fifth epoch using an unknown target (2\u2019bxx).\n- In each epoch, the tasks apply a similar method: a sequence of input combinations is applied to a and b with specific delays (#60, #70, #80, etc.) to mimic realistic timing conditions.\n\n**Invalid Gate Epochs**:\n **Test Case: Invalid Epochs 1\u20135**\n- Control: `gate_select` should be set to an unknown value (2\u2019bxx), with target selections both valid (00\u201311) and completely unknown (2\u2019bxx).\nInputs: A variety of input patterns (including zeros and mixed values) are applied.\n\n## Learning Logic:\n- Weights (w1, w2) and bias are updated incrementally based on the input values and a computed error:\n    delta_w1 = x1 * target\n    delta_w2 = x2 * target\n    delta_b = target \n    w1 = w1 + delta_w1\n    w2 = w2 + delta_w2\n    bias = bias + delta_b\n\n- Target values are determined using a `gate_target` submodule based on `gate_select`:\n  - gate_select = 2'b00: AND gate behavior.\n  - gate_select = 2'b01: OR gate behavior.\n  - gate_select = 2'b10: NAND gate behavior.\n  - gate_select = 2'b11: NOR gate behavior.\n\n## FSM Design:\nThere are 11 states handled by Moore FSM.\n- State_0: Reset state.\n- State_1: Capture inputs.\n- State_2-State_6: Assign targets based on the selected gate.\n- State_7: Compute deltas for weights and bias.\n- State_8: Update weights and bias.\n- State_9: Loop through training iterations.\n- State_10: Return to the initial state.\n\n## Functional Requirements:\n- Weight adjustment must follow the Hebbian learning rule.\n- The FSM must support multiple training iterations for every possible input combination of a two-input logic gate.\n- Outputs (`w1`, `w2`, `bias`) should reflect trained values at the end of the process.", "context": {}}, "output": {"response": "", "context": {"verif/tb_hebb_gates.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 9fbf672af52ebe98412cf75e6fc8214c80787a70\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/hebb_gates.sv": "`timescale 1ns/1ps\nmodule hebb_gates(\n   input  logic               clk,          // Posedge clk\n   input  logic               rst,          // Asynchronous negedge rst\n   input  logic               start,        // To start the FSM\n   input  logic         [1:0] target_select,// To select different targets for a given gate\n   input  logic  signed [3:0] a,            // First Input\n   input  logic  signed [3:0] b,            // Second Input\n   input  logic         [1:0] gate_select,  // To select a given gate\n   output logic  signed [3:0] w1,           // Weight 1 obtained by training\n   output logic  signed [3:0] w2,           // Weight 2 obtained by training\n   output logic  signed [3:0] bias,         // Bias obtained by training\n   output logic       [3:0] present_state,  // Present State of the Training FSM\n   output logic       [3:0] next_state      // Next_State of the Training FSM\n);\n   logic signed [3:0] t1;\n   logic signed [3:0] t2;\n   logic signed [3:0] t3;\n   logic signed [3:0] t4;\n   \n   gate_target dut (\n      .gate_select   (gate_select),\n      .target_select (target_select),\n      .o_1           (t1),\n      .o_2           (t2),\n      .o_3           (t3),\n      .o_4           (t4)\n   );\n   \n   \n   localparam [3:0] State_0  = 4'd0;\n   localparam [3:0] State_1  = 4'd1;\n   localparam [3:0] State_2  = 4'd2;\n   localparam [3:0] State_3  = 4'd3;\n   localparam [3:0] State_4  = 4'd4;\n   localparam [3:0] State_5  = 4'd5;\n   localparam [3:0] State_6  = 4'd6;\n   localparam [3:0] State_7  = 4'd7;\n   localparam [3:0] State_8  = 4'd8;\n   localparam [3:0] State_9  = 4'd9;\n   localparam [3:0] State_10 = 4'd10;\n   \n   \n   logic [2:0]          iteration;\n   logic signed [3:0]   x1;\n   logic signed [3:0]   x2;\n   logic signed [3:0]   delta_w1;\n   logic signed [3:0]   delta_w2;\n   logic signed [3:0]   delta_b;\n   logic signed [3:0]   w1_reg;\n   logic signed [3:0]   w2_reg;\n   logic signed [3:0]   bias_reg;\n   logic signed [1:0]   target;\n   logic                delta_en;\n   logic                sum_en;\n   logic                clr_en;\n   logic                cap_en;\n  \n   \n   always @(*) begin\n      if (cap_en) begin\n         x1 = a;\n         x2 = b;\n      end else begin\n         x1 = x1 + 4'h0;\n         x2 = x2 + 4'h0;\n      end\n   end\n   \n   \n   always @(*) begin\n      if (delta_en) begin\n         delta_w1 = x1 * target;\n         delta_w2 = x2 * target;\n         delta_b  = target;\n      end else begin\n         delta_w1 = delta_w1 + 4'h0;\n         delta_w2 = delta_w2 + 4'h0;\n         delta_b  = delta_b + 4'h0;\n      end\n   end\n   \n   \n   always @(*) begin\n      if (sum_en) begin\n         w1_reg   = w1_reg + delta_w1;\n         w2_reg   = w2_reg + delta_w2;\n         bias_reg = bias_reg + delta_b;\n      end else begin\n         w1_reg   = w1_reg + 4'h0;\n         w2_reg   = w2_reg + 4'h0;\n         bias_reg = bias_reg + 4'h0;\n      end\n   end\n   \n   \n   always @(*) begin\n      if (clr_en) begin\n         w1_reg   = 0;\n         w2_reg   = 0;\n         bias_reg = 0;\n      end else begin\n         w1_reg   = w1_reg + 4'h0;\n         w2_reg   = w2_reg + 4'h0;\n         bias_reg = bias_reg + 4'h0;\n      end\n   end\n   \n   \n   always @(posedge clk or negedge rst) begin\n      if (!rst) begin\n         present_state <= State_0;\n         iteration     <= 0;\n      end else begin\n         present_state <= next_state;\n      end\n   end\n   \n   \n   always @(*) begin\n      next_state = present_state;\n      case (present_state)\n         State_0: begin \n            if (start)\n               next_state = State_1;\n            else\n               next_state = State_0;\n         end\n         State_1: begin \n            next_state = State_2;\n         end\n         State_2: begin \n            if (iteration == 0)\n               next_state = State_3;\n            else if (iteration == 1)\n               next_state = State_4;\n            else if (iteration == 2)\n               next_state = State_5;\n            else \n               next_state = State_6;\n         end\n         State_3: begin \n            next_state = State_7;\n         end\n         State_4: begin \n            next_state = State_7;\n         end\n         State_5: begin \n            next_state = State_7;\n         end\n         State_6: begin \n            next_state = State_7;\n         end\n         State_7: begin\n            next_state = State_8;\n         end\n         State_8: begin\n            next_state = State_9;\n         end\n         State_9: begin\n            if (iteration < 4)\n               next_state = State_1;\n            else\n               next_state = State_10;\n         end\n         State_10: begin\n            next_state = State_0;\n         end\n         default: ;\n      endcase\n   end \n   \n   \n   always @(*) begin    \n      case (present_state)\n         State_0: begin\n            clr_en    = 1;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = 0;\n            target    = target + 4'h0;\n         end \n         State_1: begin\n            clr_en    = 0;\n            cap_en    = 1;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = target + 4'h0;\n         end\n         State_2: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = target + 4'h0;\n         end\n         State_3: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = t1;\n         end\n         State_4: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = t2;\n         end     \n         State_5: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = t3;\n         end  \n         State_6: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = t4;\n         end        \n         State_7: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 1;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = target + 4'h0;\n         end\n         State_8: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 1;\n            iteration = iteration + 1;\n            target    = target + 4'h0;\n         end\n         State_9: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = target + 4'h0;\n         end  \n         State_10: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = iteration + 0;\n            target    = target + 4'h0;\n         end\n         default: begin\n            clr_en    = 0;\n            cap_en    = 0;\n            delta_en  = 0;\n            sum_en    = 0;\n            iteration = 0;\n            target    = target + 4'h0;\n         end\n      endcase\n   end\n   \n   \n   assign w1   = w1_reg;\n   assign w2   = w2_reg;\n   assign bias = bias_reg;\n   \nendmodule\n\n\n`timescale 1ns/1ps\nmodule gate_target(\n   input  logic        [1:0] gate_select,\n   input  logic        [1:0] target_select,\n   output logic signed [3:0] o_1,\n   output logic signed [3:0] o_2,\n   output logic signed [3:0] o_3,\n   output logic signed [3:0] o_4\n);\n   always @(*) begin\n      case (gate_select)\n         2'b00: begin \n            case (target_select)\n               2'b00: begin\n                  o_1 =  4'b0001; \n                  o_2 = -4'b0001; \n                  o_3 = -4'b0001; \n                  o_4 = -4'b0001; \n               end\n               2'b01: begin\n                  o_1 = -4'b0001;\n                  o_2 = -4'b0001;\n                  o_3 = -4'b0001;\n                  o_4 =  4'b0001;\n               end\n               2'b10: begin\n                  o_1 = -4'b0001;\n                  o_2 =  4'b0001;\n                  o_3 = -4'b0001;\n                  o_4 = -4'b0001;\n               end\n               2'b11: begin\n                  o_1 = -4'b0001;\n                  o_2 = -4'b0001;\n                  o_3 =  4'b0001;\n                  o_4 = -4'b0001;\n               end\n               default: begin\n                  o_1 = 4'b0000; \n                  o_2 = 4'b0000; \n                  o_3 = 4'b0000; \n                  o_4 = 4'b0000; \n               end\n            endcase\n         end\n         2'b01: begin \n            case (target_select)\n               2'b00: begin  \n                  o_1 =  4'b0001; \n                  o_2 =  4'b0001; \n                  o_3 =  4'b0001; \n                  o_4 = -4'b0001; \n               end\n               2'b01: begin  \n                  o_1 =  4'b0001; \n                  o_2 =  4'b0001; \n                  o_3 = -4'b0001; \n                  o_4 =  4'b0001;\n               end\n               2'b10: begin  \n                  o_1 =  4'b0001; \n                  o_2 = -4'b0001; \n                  o_3 =  4'b0001; \n                  o_4 =  4'b0001;\n               end\n               2'b11: begin  \n                  o_1 = -4'b0001; \n                  o_2 =  4'b0001; \n                  o_3 =  4'b0001; \n                  o_4 =  4'b0001;\n               end \n               default: begin\n                  o_1 = 4'b0000; \n                  o_2 = 4'b0000; \n                  o_3 = 4'b0000; \n                  o_4 = 4'b0000; \n               end\n            endcase\n         end                \n         2'b10: begin \n            case (target_select)\n               2'b00: begin\n                  o_1 =  4'b0001; \n                  o_2 =  4'b0001; \n                  o_3 =  4'b0001; \n                  o_4 = -4'b0001; \n               end\n               2'b01: begin\n                  o_1 =  4'b0001;\n                  o_2 =  4'b0001;\n                  o_3 = -4'b0001;\n                  o_4 =  4'b0001;\n               end\n               2'b10: begin\n                  o_1 =  4'b0001;\n                  o_2 = -4'b0001;\n                  o_3 =  4'b0001;\n                  o_4 =  4'b0001;\n               end\n               2'b11: begin\n                  o_1 = -4'b0001;\n                  o_2 =  4'b0001;\n                  o_3 =  4'b0001;\n                  o_4 =  4'b0001;\n               end\n               default: begin\n                  o_1 = 4'b0000; \n                  o_2 = 4'b0000; \n                  o_3 = 4'b0000; \n                  o_4 = 4'b0000; \n               end\n            endcase\n         end\n         2'b11: begin \n            case (target_select)\n               2'b00: begin \n                  o_1 =  4'b0001; \n                  o_2 = -4'b0001; \n                  o_3 = -4'b0001; \n                  o_4 = -4'b0001; \n               end\n               2'b01: begin\n                  o_1 = -4'b0001; \n                  o_2 =  4'b0001; \n                  o_3 = -4'b0001; \n                  o_4 = -4'b0001;\n               end\n               2'b10: begin\n                  o_1 = -4'b0001; \n                  o_2 = -4'b0001; \n                  o_3 =  4'b0001; \n                  o_4 = -4'b0001;\n               end\n               2'b11: begin\n                  o_1 = -4'b0001; \n                  o_2 = -4'b0001; \n                  o_3 = -4'b0001; \n                  o_4 =  4'b0001; \n               end\n               default: begin\n                  o_1 = 4'b0000; \n                  o_2 = 4'b0000; \n                  o_3 = 4'b0000; \n                  o_4 = 4'b0000; \n               end\n            endcase\n         end\n         default: begin\n            o_1 = 4'b0000; \n            o_2 = 4'b0000; \n            o_3 = 4'b0000; \n            o_4 = 4'b0000; \n         end\n      endcase\n   end\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    for line in lines[2:]:\n        info = line.split()\n        while len(info) < 3:\n            info.append(\"0%\")\n        inst = re.sub(r'[\\W]', '', info[0])\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'uut' is missing in the coverage log.\")\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))\n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['uut']['Average']}, Target: {target}\"\n    \n"}}}
{"id": "cvdp_copilot_hill_cipher_0012", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench to generate the stimuli for the `hill_cipher` module, which applies a 3\u00d73 key matrix to a 3-letter (15-bit) plaintext vector, computing the ciphertext (also 3 letters, 15 bits) modulo 26.\n\n---\n\n## Description\n\n### Inputs\n\n- **Registers**:\n  - `clk (1 bit)`: Clock signal that drives the internal finite state machine (FSM) and arithmetic logic.\n  - `reset (1 bit)`: Active-high, synchronous reset that clears all registers and returns the module to the `IDLE` state.\n  - `start (1 bit)`: A strobe signal indicating the module should begin computing the ciphertext for the provided `plaintext` and `key`.\n  - `plaintext (15 bits)`: Three letters, each 5 bits, forming the message to encrypt.\n  - `key (45 bits)`: A 3\u00d73 matrix of 9 elements, each 5 bits, used to multiply the plaintext vector in the Hill Cipher algorithm.\n\n### Outputs\n\n- **Wires**:\n  - `ciphertext (15 bits)`: The resulting 3-letter (5 bits per letter) encrypted output.\n  - `done (1 bit)`: Goes high for one cycle when the module finishes encryption, signaling the `ciphertext` is valid.\n\n---\n\n## Input Generation\n\n- **Random Input Generation**:  \n  The testbench provides random 15-bit values for `plaintext` (covering possible 3-letter combinations) and 45-bit values for `key` (covering random 3\u00d73 matrices). These random tests help uncover boundary issues and verify the FSM\u2019s transitions.\n\n- **Directed Patterns**:  \n  The testbench also applies specific edge-case values for `plaintext` and `key`, such as:\n  - `plaintext = 15'h0000` (all zeros).\n  - `key = 45'h0000000000` (all zeros).\n  - Maximal or near-maximal values to ensure the modulo operations function correctly.\n  - Sequences that check if multiple consecutive encryption requests work as intended.\n\n---\n\n## Stabilization Period\n\n- The testbench asserts `start` for **one clock cycle** after setting `plaintext` and `key`.  \n- It then waits until `done` goes high, indicating the FSM has advanced through `COMPUTE`, `COMPUTE_MOD`, and finally `DONE`.  \n- Once `done=1`, the testbench samples `ciphertext` and logs the result.\n\n---\n\n## Instantiation\n\nName the instance of the module as `uut`.\n\n---\n\nFollows the specification for building the RTL of the module, use it as reference for the verification environment too:\n\n### Module Interface\n\n1. **Inputs**:\n   - `clk (1 bit)`\n   - `reset (1 bit)`\n   - `start (1 bit)`\n   - `plaintext [14:0]`\n   - `key [44:0]`\n\n2. **Outputs**:\n   - `ciphertext [14:0]`\n   - `done`\n\n### Module Functionality\n\nInstead of viewing the key as a matrix, consider it as **9 separate 5-bit key elements**, grouped in **3 sets** (each set has 3 elements). The `plaintext` is **3 letters**, each 5 bits. The module computes each output letter as follows:\n\n1. **Multiply & Sum**:  \n   For one of the 3 output letters, the module multiplies each of the 3 plaintext letters (5 bits each) by the corresponding key element in that set. It then adds these 3 products together.\n\n2. **Modulo Operation**:  \n   Because we want each letter to stay in the range `0\u201325` (the alphabet size), the module takes the sum **modulo 26**. This final value (0\u201325) becomes one letter of the encrypted output.\n\n3. **Three Times**:  \n   The module repeats Steps 1 and 2 for each of the **3 sets** of key elements, creating **3 encrypted letters**.  \n\n4. **Finite State Machine**:  \n   - **IDLE**: Waits until `start` is asserted.  \n   - **COMPUTE**: Calculates partial sums (multiply-and-add) for each of the 3 output letters.  \n   - **COMPUTE_MOD**: Finalizes each sum modulo 26, storing the results in internal registers for `ciphertext`.  \n   - **DONE**: Pulses `done=1` for one clock cycle to signal the `ciphertext` is valid, then returns to IDLE.\n\n5. **Reset**:  \n     When `reset` is asserted, the FSM returns to `IDLE`, and internal registers are cleared. The outputs (`ciphertext`, `done`) remain in their initial states (zeros) until the next valid compute cycle. \n\n---", "context": {}}, "output": {"response": "", "context": {"verif/hill_cipher_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n   xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 5c145b95e5e2c6caf039151222ef4630ff5dcaf8\nTARGET          = 90\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/hill_cipher.sv": "`timescale 1ns/1ps\n\nmodule hill_cipher (\n    input logic clk,\n    input logic reset,\n    input logic start,\n    input logic [14:0] plaintext,   // 3 letters, 5 bits each\n    input logic [44:0] key,         // 9 elements, 5 bits each\n    output logic [14:0] ciphertext, // 3 letters, 5 bits each \n    output logic done\n);\n\n    logic [4:0] P0, P1, P2;\n    logic [4:0] K00, K01, K02;\n    logic [4:0] K10, K11, K12;\n    logic [4:0] K20, K21, K22;\n\n    logic [5:0] temp0, temp1, temp2;\n    logic [4:0] C0_reg, C1_reg, C2_reg;\n\n    typedef enum logic [1:0] {\n        IDLE        = 2'b00,\n        COMPUTE     = 2'b01,\n        COMPUTE_MOD = 2'b10,\n        DONE        = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    assign P0 = plaintext[14:10];\n    assign P1 = plaintext[9:5];\n    assign P2 = plaintext[4:0];\n\n    assign K00 = key[44:40];\n    assign K01 = key[39:35];\n    assign K02 = key[34:30];\n    assign K10 = key[29:25];\n    assign K11 = key[24:20];\n    assign K12 = key[19:15];\n    assign K20 = key[14:10];\n    assign K21 = key[9:5];\n    assign K22 = key[4:0];\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    always_comb begin\n        next_state = current_state;\n        done = 1'b0;\n\n        case (current_state)\n            IDLE: begin\n                if (start)\n                    next_state = COMPUTE;\n            end\n            COMPUTE: begin\n                next_state = COMPUTE_MOD;\n            end\n            COMPUTE_MOD: begin\n                next_state = DONE;\n            end\n            DONE: begin\n                done = 1'b1;\n                next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            temp0 <= 12'b0;\n            temp1 <= 12'b0;\n            temp2 <= 12'b0;\n            C0_reg <= 5'b0;\n            C1_reg <= 5'b0;\n            C2_reg <= 5'b0;\n        end\n        else begin\n            case (current_state)\n                COMPUTE: begin\n                    temp0 <= (K00 * P0)%26 + (K01 * P1)%26 + (K02 * P2)%26;\n                    temp1 <= (K10 * P0)%26 + (K11 * P1)%26 + (K12 * P2)%26;\n                    temp2 <= (K20 * P0)%26 + (K21 * P1)%26 + (K22 * P2)%26;\n                end\n                COMPUTE_MOD: begin\n                    C0_reg <= temp0%26;\n                    C1_reg <= temp1%26;\n                    C2_reg <= temp2%26;\n                end\n                default: begin\n                    temp0 <= 12'b0;\n                    temp1 <= 12'b0;\n                    temp2 <= 12'b0;\n                    C0_reg <= 5'b0;\n                    C1_reg <= 5'b0;\n                    C2_reg <= 5'b0;\n                end\n            endcase\n        end\n    end\n\n    assign ciphertext = {C0_reg, C1_reg, C2_reg};\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_image_stego_0014", "categories": ["cid012", "medium"], "input": {"prompt": "Develop a SystemVerilog module named `tb_image_stego` that generates input stimulus to verify the `image_stego` module. The `image_stego` module embeds bits of data into an image. Each pixel is 8 bits, and up to 4 bits can be embedded according to a `mask` control. The data bits are first XOR-encrypted by an 8-bit key. The purpose of `tb_image_stego` is to thoroughly test all features of the `image_stego` module, achieving complete functional and toggle coverage.\n\n---\n\n## Module Interface\n\n### **Parameters**\n- **`row`** *(default = 2)*  \n  Number of rows in the image.\n\n- **`col`** *(default = 2)*  \n  Number of columns in the image.\n\n- **`EMBED_COUNT_WIDTH`** *(default = 3)*  \n  Width of the `embedded_pixel_count` output.\n\n*(Each pixel is 8 bits, so total bits in `img_in` and `img_out` is `row * col * 8`.)*\n\n---\n\n## Port List\n\n| **Port Name**                                | **Direction** | **Width**                     | **Description**                                                                                                                      |\n|----------------------------------------------|---------------|-------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|\n| `img_in[(row*col*8)-1:0]`                    | **Input**     | `row*col*8` bits              | Contains the original image data, 8 bits per pixel.                                                                                  |\n| `data_in[(row*col*4)-1:0]`                   | **Input**     | `row*col*4` bits              | Data bits to be embedded, allowing up to 4 bits per pixel.                                                                           |\n| `bpp[2:0]`                                   | **Input**     | 3 bits                        | Indicates how many bits per pixel to embed: `000=1`, `001=2`, `010=3`, `011=4`. Other values are invalid and result in no embedding. |\n| `encryption_key[7:0]`                        | **Input**     | 8 bits                        | Key used for XOR encryption of `data_in`.                                                                                            |\n| `mask[(row*col)-1:0]`                        | **Input**     | `row*col` bits                | Pixel-wise mask enabling embedding: `1=embed`, `0=pass-through`.                                                                     |\n| `img_out[(row*col*8)-1:0]`                   | **Output**    | `row*col*8` bits              | Image data after embedding the specified bits into some (or none) of the pixels.                                                     |\n| `error_out`                                  | **Output**    | 1 bit                         | Indicates odd parity in `data_in`.                                                                                                   |\n| `embedded_pixel_count[EMBED_COUNT_WIDTH-1:0]`| **Output**    | `EMBED_COUNT_WIDTH` bits      | Holds the total count of pixels in which data was actually embedded.                                                                 |\n| `embedding_done[1:0]`                        | **Output**    | 2 bits                        | Reflects the embedding status: `00=Idle`, `01=In-progress`, `10=Done`, `11=No-embed`.                                                |\n\n---\n\n## Functional Description\n\n1. **Parity Checking**  \n   - The module calculates the XOR of all bits in `data_in`. If an **odd** number of bits in `data_in` is set to 1, `error_out` is driven high (`1`).  \n   - This ensures the system can detect if the embedded data has non-even parity.\n\n2. **Encryption**  \n   - The bits of `data_in` are split into 8-bit blocks. Each block is XORed with the 8-bit `encryption_key`.  \n   - This process creates an **encrypted** data stream, referred to internally as `data_in_encrypted`.\n\n3. **Embedding**  \n   - The image has `(row * col)` pixels, each indexed by `i` ranging from `0` to `row * col - 1`.  \n   - For each pixel `i`, if `mask[i]` is `1`, the module replaces the **lowest** bits (based on `bpp`) in `img_in[i*8 +: 8]` with bits from `data_in_encrypted`.  \n   - **Incrementing Embedded Pixel Count**:  \n     - Each time a pixel is modified, `embedded_pixel_count` is incremented by `1`.  \n   - **`embedding_done` Transitions**:  \n     - **`2'b01` (In-progress)**: Once embedding starts (i.e., at least one `mask[i] == 1` pixel is encountered).  \n     - **`2'b10` (Done)**: Set when at least one pixel has been embedded successfully.  \n     - **`2'b11` (No-embed)**: If `mask != 0` but no bits actually get embedded (e.g., because `bpp` is invalid).\n\n4. **Idle vs. Non-Idle**  \n   - **Idle**: If `mask == 0`, the module does not modify any pixels, so `img_out` equals `img_in`.  \n   - **Non-Idle**: If `mask != 0`, embedding logic attempts to modify pixels. However, if it results in no modified pixels for some reason (e.g., `bpp` is invalid), `embedding_done` becomes `2'b11`.\n\n---\n\n## Instantiation\n\nUse an instance of `image_stego` named `uut` within the testbench `tb_image_stego`.\n\n---\n\n## Required Stimulus Description\n\nThe objective is to achieve **100% code and toggle coverage** for the `image_stego` module by systematically exercising its functionality. The stimulus should ensure that all key features, edge cases, and status transitions of the design are thoroughly tested to maintain coverage goals.\n\n| **Test Condition**          | **Purpose**                                                                                                                                                                            |\n|-----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **BPP Variations**          | Embedding for `bpp = 000, 001, 010, 011`, ensuring the correct number of bits are replaced in each pixel. Other `bpp` values should result in no embedding to cover the `2'b11` state. |\n| **Mask Patterns**           | Embedding for different mask patterns (e.g., all zeros, all ones, partial patterns).                                                                                                   |\n| **Encryption Keys**         | Ensure the XOR process covers various `encryption_key` values (0x00, 0xFF, random, etc.).                                                                                              |\n| **Parity Checks**           | Provide even and odd `data_in` to check proper assertion of `error_out`.                                                                                                               |\n| **Pixel Count**             | `embedded_pixel_count` increments only for pixels that are actually embedded.                                                                                                          |\n| **Embedding Done States**   | Test `embedding_done` transitions: `00 (Idle)` \u2192 `01 (In-progress)` \u2192 `10 (Done)` or `11 (No-embed)`.                                                                                  |\n| **Randomized Scenarios**    | Randomize `img_in`, `data_in`, `bpp`, `encryption_key`, and `mask` to cover unexpected corner cases.                                                                                   |", "context": {}}, "output": {"response": "", "context": {"verif/image_stego_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 94311fe0c984ef0e3b64652a0c4a45c16b8e389a\nTARGET = 100", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/image_stego.sv": "`timescale 1ns/1ps\nmodule image_stego #(\n  parameter row = 2,\n  parameter col = 2,\n  parameter EMBED_COUNT_WIDTH = 3\n)(\n  input [(row*col*8)-1:0] img_in,\n  input [(row*col*4)-1:0] data_in,\n  input [2:0] bpp,\n  input [7:0] encryption_key,\n  input [(row*col)-1:0] mask,\n  output reg [(row*col*8)-1:0] img_out,\n  output reg error_out,\n  output reg [EMBED_COUNT_WIDTH-1:0] embedded_pixel_count,\n  output reg [1:0] embedding_done\n);\n\ninteger p;\nreg parity;\nalways @(*) begin\n  parity = 0;\n  for (p = 0; p < (row*col*4); p = p + 1) begin\n    parity = parity ^ data_in[p];\n  end\n  error_out = (parity == 1);\nend\n\nreg [(row*col*4)-1:0] data_in_encrypted;\ninteger block;\nalways @(*) begin\n  data_in_encrypted = 0;\n  for (block = 0; block < (row*col*4); block = block + 8) begin\n    data_in_encrypted[block +: 8] = data_in[block +: 8] ^ encryption_key;\n  end\nend\n\ninteger i;\nalways @(*) begin\n  img_out = img_in;\n  embedded_pixel_count = 0;\n  embedding_done = 2'b00;\n  if (mask != 0) begin\n    embedding_done = 2'b01;\n    for (i = 0; i < (row*col); i = i + 1) begin\n      if (mask[i]) begin\n        case (bpp)\n          3'b000: img_out[i*8 +: 8] = {img_in[i*8 + 1 +: 7], data_in_encrypted[i]};\n          3'b001: img_out[i*8 +: 8] = {img_in[i*8 + 2 +: 6], data_in_encrypted[(2*i) +: 2]};\n          3'b010: img_out[i*8 +: 8] = {img_in[i*8 + 3 +: 5], data_in_encrypted[(3*i) +: 3]};\n          3'b011: img_out[i*8 +: 8] = {img_in[i*8 + 4 +: 4], data_in_encrypted[(4*i) +: 4]};\n          default: img_out[i*8 +: 8] = img_in[i*8 +: 8];\n        endcase\n        if (bpp <= 3'b011) begin\n          embedded_pixel_count = embedded_pixel_count + 1;\n        end\n      end\n    end\n    if (embedded_pixel_count > 0) begin\n      embedding_done = 2'b10;\n    end else begin\n      embedding_done = 2'b11;\n    end\n  end\nend\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_manchester_enc_0009", "categories": ["cid012", "easy"], "input": {"prompt": "Complete the given SystemVerilog testbench for the `top_manchester` module. The testbench currently instantiates the UUT and should include stimulus generation logic that dynamically produces a wide range of test scenarios to ensure 100% functional and code coverage. The stimulus generation logic should drive the design under various conditions, including the module functionality below.\n\n---\n\n## Description\n\n### Parameter\n- **`N`**: Input Parameter Value, Default value is 8.\n\n### Inputs\n\n- **`clk_in`**: Clock signal driving the design (positive edge triggered).\n- **`rst_in`**: Asynchronous reset signal (active high) to reset the encoder and decoder.\n- **`enc_valid_in`**: 1-bit Input valid signal for the encoder.\n- **`enc_data_in[N-1:0]`**: N-bit input data for the encoder.\n- **`dec_valid_in`**: 1-bit Input valid signal for the decoder.\n- **`dec_data_in[2*N-1:0]`**: 2N-bit input data for the decoder.\n\n### Outputs\n\n- **`enc_valid_out`**: 1-bit Output valid signal for the encoder.\n- **`enc_data_out[2*N-1:0]`**: 2N-bit Manchester-encoded output data from the encoder.\n- **`dec_valid_out`**: 1-bit Output valid signal for the decoder.\n- **`dec_data_out[N-1:0]`**: N-bit decoded output data from the decoder.\n\n---\n\n## Input Generation\n\n### Input Generation\n\n- **Clock and Reset**:\n  - Generate a clock signal (`clk_in`) with a configurable period.\n  - Apply reset (`rst_in`) at the beginning and during random intervals to test reset behavior.\n\n- **Encoder Inputs**:\n  - Generate diverse patterns for `enc_data_in`, such as:\n    - Incremental data (e.g., 0, 1, 2, ...).\n    - Random data patterns.\n    - Edge cases (e.g., all zeros, all ones, alternating patterns).\n  - Toggle `enc_valid_in` to test valid and invalid input scenarios.\n\n- **Decoder Inputs**:\n  - Generate diverse patterns for `dec_data_in`, such as:\n    - Valid Manchester-encoded data (e.g., 0x5AA5, 0xC33C).\n    - Invalid Manchester-encoded data (e.g., 0xFFFF, 0x0000).\n    - Incremental data (e.g., 0, 1, 2, ...).\n    - Random data patterns.\n  - Toggle `dec_valid_in` to test valid and invalid input scenarios.\n\n## **Instantiation**  \n\n- The instance of the RTL should be named **`uut`**.  \n\n---\n\nFollows the specification for building the RTL of the module, use it as a reference for the verification environment too: \n## Module Functionality\n\n1. **Encoder Functionality**:\n   - The encoder converts N-bit input data (`enc_data_in`) into 2N-bit Manchester-encoded data (`enc_data_out`).\n   - The encoding logic follows the Manchester encoding scheme:\n     - `1` is encoded as `01`.\n     - `0` is encoded as `10`.\n\n2. **Decoder Functionality**:\n   - The decoder converts 2N-bit Manchester-encoded data (`dec_data_in`) into N-bit decoded data (`dec_data_out`).\n   - The decoding logic follows the Manchester decoding scheme:\n     - `01` is decoded as `1`.\n     - `10` is decoded as `0`.\n     - Invalid patterns (e.g., `00` or `11`) are decoded as `0`.\n\n3. **Reset Behavior**:\n   - When `rst_in` is asserted, all outputs (`enc_data_out`, `enc_valid_out`, `dec_data_out`, `dec_valid_out`) are cleared to zero.\n\n---\n\n```verilog\nmodule tb_top_manchester;\n\n    parameter N = 8;  // Width of input and output data\n    parameter CLK_PERIOD = 10;  // Clock period in ns\n\n    // Testbench signals\n    logic clk_in;\n    logic rst_in;\n    logic enc_valid_in;\n    logic [N-1:0] enc_data_in;\n    logic dec_valid_out;\n    logic dec_valid_in;\n    logic [N-1:0] dec_data_out;\n    logic [2*N-1:0] enc_data_out; // 2N-bit Manchester encoded data\n    logic [2*N-1:0] dec_data_in; // 2N-bit Manchester encoded data\n    logic enc_valid_out;          // Encoded data valid signal\n\n    // Instantiate the top module\n    top_manchester #(\n        .N(N)\n    ) uut (\n        .clk_in(clk_in),\n        .rst_in(rst_in),\n        \n        .enc_valid_in(enc_valid_in),\n        .enc_data_in(enc_data_in),\n        .enc_valid_out(enc_valid_out),\n        .enc_data_out(enc_data_out),\n        \n        .dec_valid_in(dec_valid_in),\n        .dec_data_in(dec_data_in),\n        .dec_valid_out(dec_valid_out),\n        .dec_data_out(dec_data_out)\n        \n    );\n\n    // Insert the code here to generate stimulus generation logic\n\nendmodule\n```", "context": {}}, "output": {"response": "", "context": {"verif/tb_top_manchester.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 6287c4b82cca1a6847ec1472e026f940b4ffdb3f\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n", "src/top_manchester.sv": "module top_manchester #(\r\n    parameter N = 8  // Default width of input and output data\r\n) (\r\n    input  logic           clk_in,          // Clock input\r\n    input  logic           rst_in,          // Active high reset input\r\n    \r\n    // Encoder Signals\r\n    input  logic           enc_valid_in,    // Input valid signal\r\n    input  logic [N-1:0]   enc_data_in,     // N-bit input data\r\n    output logic           enc_valid_out,   // Output valid signal\r\n    output logic [2*N-1:0] enc_data_out,    // 2*N-bit encoder output data\r\n    \r\n    // Decoder Signals\r\n    input  logic           dec_valid_in,    // Input valid signal\r\n    input  logic [2*N-1:0] dec_data_in,     // 2*N-bit input data\r\n    output logic           dec_valid_out,   // Output valid signal\r\n    output logic [N-1:0]   dec_data_out     // N-bit output decoded data\r\n);\r\n\r\n    always_ff @(posedge clk_in) begin\r\n        if (rst_in) begin\r\n            enc_data_out  <= '0; \r\n            enc_valid_out <= 1'b0; \r\n        end else if (enc_valid_in) begin\r\n            for (int i = 0; i < N; i++) begin\r\n                if (enc_data_in[i] == 1'b1) begin\r\n                    enc_data_out[2*i]   <= 1'b1;\r\n                    enc_data_out[2*i+1] <= 1'b0;\r\n                end else begin\r\n                    enc_data_out[2*i]   <= 1'b0;\r\n                    enc_data_out[2*i+1] <= 1'b1;\r\n                end\r\n            end\r\n            enc_valid_out <= 1'b1;\r\n        end else begin\r\n            enc_data_out  <= 'd0;\r\n            enc_valid_out <= 1'b0;\r\n        end\r\n    end\r\n\r\n    always_ff @(posedge clk_in) begin\r\n        if (rst_in) begin\r\n            dec_data_out  <= '0; \r\n            dec_valid_out <= 1'b0;\r\n        end else if (dec_valid_in) begin\r\n            for (int i = 0; i < N; i++) begin\r\n                if (dec_data_in[2*i] == 1'b1 && dec_data_in[2*i+1] == 1'b0) begin\r\n                    dec_data_out[i] <= 1'b1;\r\n                end else if (dec_data_in[2*i] == 1'b0 && dec_data_in[2*i+1] == 1'b1) begin\r\n                    dec_data_out[i] <= 1'b0;\r\n                end else begin\r\n                    dec_data_out[i] <= 1'b0;\r\n                end\r\n            end\r\n            dec_valid_out <= 1'b1;\r\n        end else begin\r\n            dec_data_out  <= '0;\r\n            dec_valid_out <= 1'b0;\r\n        end\r\n    end\r\n\r\nendmodule\r\n"}}}
{"id": "cvdp_copilot_matrix_multiplier_0022", "categories": ["cid012", "easy"], "input": {"prompt": "Write a testbench for the `matrix_multiplier` module, which performs matrix multiplication for configurable dimensions. The testbench should focus only on generating stimuli to exercise all key features of the module.\n\n---\n\n## Design Details\n\n### **Parameterization**\n1. **ROW_A**: Number of rows in Matrix A. (Default=4)\n2. **COL_A**: Number of columns in Matrix A. (Default=4)\n3. **ROW_B**: Number of rows in Matrix B. (Default=4)\n4. **COL_B**: Number of columns in Matrix B. (Default=4)\n5. **INPUT_DATA_WIDTH**: Bit-width of the input matrix elements. (Default=8)\n6. **OUTPUT_DATA_WIDTH**: Bit-width of the output matrix elements, calculated as `(INPUT_DATA_WIDTH * 2) + $clog2(COL_A)`.\n\n### **Inputs and Outputs**\n- **Inputs**:\n  - `clk`: Clock signal (positive edge-triggered).\n  - `srst`: Active-high synchronous reset signal.\n  - `valid_in`: Active high signal, indicates that `matrix_a` and `matrix_b` contain valid inputs.\n  - `[(ROW_A*COL_A*INPUT_DATA_WIDTH)-1:0] matrix_a`: Flattened 1D representation of input Matrix A.\n  - `[(ROW_B*COL_B*INPUT_DATA_WIDTH)-1:0] matrix_b`: Flattened 1D representation of input Matrix B.\n- **Outputs**:\n  - `valid_out`: Active high signal, indicates that the output matrix `matrix_c` is valid.\n  - `[(ROW_A*COL_B*OUTPUT_DATA_WIDTH)-1:0] matrix_c`: Flattened 1D representation of the result Matrix C.\n\n### Example of Matrix Flattening:\n\nSuppose you have two input matrices A and B to multiply:\n\n- **Matrix A (2x3)**:\n\n```text\n| a11  a12  a13 |\n| a21  a22  a23 |\n```\n\n- **Matrix B (3x2)**:\n\n```text\n| b11  b12 |\n| b21  b22 |\n| b31  b32 |\n```\n\nThe resulting output matrix from the multiplication of the above matrices would be:\n\n- **Matrix C (2x2)**:\n\n```text\n| c11  c12 |\n| c21  c22 |\n```\n\nThe flattened representation of these matrices will be as follows:\n\n- **Flattened Matrix A (2x3)**:\n\n```text\nmatrix_a = {a23, a22, a21, a13, a12, a11}\n```\n\n- **Flattened Matrix B (3x2)**:\n\n```text\nmatrix_b = {b32, b31, b22, b21, b12, b11}\n```\n\n- **Flattened Matrix C (2x2)**:\n\n```text\nmatrix_c = {c22, c21, c12, c11}\n```\n\n- **Note** : The design enables the processing of a new input set (matrix_a, matrix_b, and valid_in) in every clock cycle while maintaining a latency of $clog2(COL_A) + 2 clock cycles from valid_in to valid_out.\n---\n\n### Testbench Requirements\n\n#### Instantiation\n\n- Instantiate the `matrix_multiplier` module as `matrix_multiplier_inst`, connecting all input and output signals.\n- Support configurable matrix sizes using defines:\n  - **`MATRIX_MULT_2x2`**: Sets `ROW_A = 2`, `COL_A = 2`, `ROW_B = 2`, `COL_B = 2`.\n  - **`MATRIX_MULT_3x3`**: Sets `ROW_A = 3`, `COL_A = 3`, `ROW_B = 3`, `COL_B = 3`.\n  - **`NON_SQUARE_MATRIX_MULT`**: Sets `ROW_A = 2`, `COL_A = 3`, `ROW_B = 3`, `COL_B = 2`.\n  - **`MATRIX_MULT_1x1`**: Sets `ROW_A = 1`, `COL_A = 1`, `ROW_B = 1`, `COL_B = 1`.\n  - **Default Configuration**: If no define is enabled, use `ROW_A = 4`, `COL_A = 4`, `ROW_B = 4`, `COL_B = 4`.\n\n---\n\n### **Stimulus Generation**\n1. **Randomized Inputs**:\n   - Generate random values for `matrix_a` and `matrix_b` based on their respective dimensions (`ROW_A x COL_A` for Matrix A and `ROW_B x COL_B` for Matrix B).\n   - Randomly toggle the `valid_in` signal to mimic varying input availability.\n\n2. **Control Signals**:\n   - Assert `srst` at the start of the simulation to reset the pipeline and output.\n   - Randomly toggle `valid_in` during operation to simulate intermittent valid input availability.\n\n3. **Continuous Stimulus**:\n   - Continuously provide randomized `matrix_a` and `matrix_b` inputs for the duration of the simulation to ensure complete coverage of the RTL.", "context": {}}, "output": {"response": "", "context": {"verif/tb_matrix_multiplier.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 56f99b2422ec76b41bd1663f641a7b97399bc84b\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/matrix_multiplier.sv": "module matrix_multiplier #(\n  parameter ROW_A             = 4                                                   , // Number of rows in matrix A\n  parameter COL_A             = 4                                                   , // Number of columns in matrix A\n  parameter ROW_B             = 4                                                   , // Number of rows in matrix B\n  parameter COL_B             = 4                                                   , // Number of columns in matrix B\n  parameter INPUT_DATA_WIDTH  = 8                                                   , // Bit-width of input data\n  parameter OUTPUT_DATA_WIDTH = (INPUT_DATA_WIDTH * 2) + $clog2(COL_A)                // Bit-width of output data\n) (\n  input  logic                                       clk      , // Clock input\n  input  logic                                       srst     , // Active-high Synchronous reset\n  input  logic                                       valid_in , // Indicates valid input matrices\n  input  logic [ (ROW_A*COL_A*INPUT_DATA_WIDTH)-1:0] matrix_a , // Input matrix A in 1D form\n  input  logic [ (ROW_B*COL_B*INPUT_DATA_WIDTH)-1:0] matrix_b , // Input matrix B in 1D form\n  output logic                                       valid_out, // Indicates valid output matrix\n  output logic [(ROW_A*COL_B*OUTPUT_DATA_WIDTH)-1:0] matrix_c   // Output matrix C in 1D form\n);\n\n\n  localparam MODIFIED_COL_A      = 1<<($clog2(COL_A));\n  localparam HALF_MODIFIED_COL_A = MODIFIED_COL_A/2  ;\n\n  generate\n    logic [                                             $clog2(COL_A):0] valid_out_reg;\n    logic [     (ROW_A*COL_B*MODIFIED_COL_A*(INPUT_DATA_WIDTH * 2))-1:0] mult_stage   ;\n\n    always_ff @(posedge clk)\n      if (srst)\n        {valid_out, valid_out_reg} <= '0;\n      else\n        {valid_out, valid_out_reg} <= {valid_out_reg, valid_in}; \n\n    always_ff @(posedge clk)\n      for (int i = 0 ; i < ROW_A ; i++) begin: mult_row_a_gb\n        for (int j = 0 ; j < COL_B ; j++) begin: mult_col_b_gb\n          for (int k = 0 ; k < MODIFIED_COL_A ; k++) begin: mult_gb\n              if (srst)\n                mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+k)*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)] <= '0; \n              else\n                mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+k)*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)] <=  (k < COL_A) ? matrix_a[((i*COL_A)+k)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH] * matrix_b[((k*COL_B)+j)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH] : '0; \n          end\n        end\n      end\n\n    if (HALF_MODIFIED_COL_A > 0) begin\n      logic [($clog2(COL_A)*ROW_A*COL_B*HALF_MODIFIED_COL_A*OUTPUT_DATA_WIDTH)-1:0] add_stage    ; \n      always_ff @(posedge clk)\n        for (int i = 0 ; i < ROW_A ; i++) begin: accum_row_a_gb\n          for (int j = 0 ; j < COL_B ; j++) begin: accum_col_b_gb\n            for (int k = 0 ; k < HALF_MODIFIED_COL_A ; k++) begin: accum_gb\n              for (int l = 0 ; l < $clog2(COL_A) ; l++) begin: pipe_gb\n                if (l == 0) begin\n                  if (srst)\n                    add_stage[((0*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+k))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0; \n                  else if (valid_out_reg[0])\n                    add_stage[((0*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+k))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+(2*k))*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)] + mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+((2*k)+1))*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)];\n                end\n                else begin\n                  if (srst)\n                    add_stage[((l*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+k))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0; \n                  else if ((HALF_MODIFIED_COL_A > 1) && (k < (HALF_MODIFIED_COL_A/2)))\n                    add_stage[((l*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+k))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= add_stage[(((l-1)*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+(2*k)))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] + add_stage[(((l-1)*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+((2*k)+1)))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH];\n                end\n              end\n            end\n          end\n        end\n\n      always_ff @(posedge clk)\n        for (int i = 0 ; i < ROW_A ; i++) begin: out_row_a_gb\n          for (int j = 0 ; j < COL_B ; j++) begin: out_col_b_gb\n            for (int k = 0 ; k < MODIFIED_COL_A ; k++) begin: out_add_gb\n              if (srst)\n                matrix_c[((i*COL_B)+j)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0;\n              else if (valid_out_reg[$clog2(COL_A)])\n                matrix_c[((i*COL_B)+j)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= add_stage[((($clog2(COL_A)-1)*ROW_A*COL_B*HALF_MODIFIED_COL_A)+((((i*COL_B)+j)*HALF_MODIFIED_COL_A)+0))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH]; \n            end\n          end\n        end\n    end\n    else begin\n      always_ff @(posedge clk)\n        for (int i = 0 ; i < ROW_A ; i++) begin: out_row_a_gb\n          for (int j = 0 ; j < COL_B ; j++) begin: out_col_b_gb\n            for (int k = 0 ; k < MODIFIED_COL_A ; k++) begin: out_mult_gb\n              if (srst)\n                matrix_c[((i*COL_B)+j)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0;\n              else if (valid_out_reg[$clog2(COL_A)])\n                matrix_c[((i*COL_B)+j)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= mult_stage[((((i*COL_B)+j)*MODIFIED_COL_A)+0)*(INPUT_DATA_WIDTH * 2)+:(INPUT_DATA_WIDTH * 2)]; \n            end\n          end\n        end\n    end\n\n  endgenerate\n\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Simulation didn't run correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    result = subprocess.run(cmd, shell=True)\n    assert result.returncode == 0, \"Coverage merge didn't run correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n    try:\n        with open(\"/code/rundir/coverage.log\") as f:\n            lines = f.readlines()\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Couldn't find the coverage.log file.\")\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    column = re.split(r'\\s{2,}', lines[0].strip())\n    for line in lines[2:]:\n        info = re.split(r'\\s{2,}', line.strip())\n        inst = info[0].lstrip('|-')\n        metrics [inst] = {column[i]: info[i].split('%')[0] for i in range(1, len(column))}\n    print(\"Parsed Metrics:\")\n    print(metrics)\n\n    # Ensure TARGET environment variable is set\n    target = os.getenv(\"TARGET\")\n    if not target:\n        raise ValueError(\"TARGET environment variable is not set.\")\n    target = float(target)\n\n    # Check coverage for the DUT or specific key\n    dut = \"matrix_multiplier_inst\"  # Replace this with the DUT key you want to check\n    if dut in metrics and \"Overall Average\" in metrics[dut]:\n        assert float(metrics[dut][\"Overall Average\"]) >= target, \"Didn't achieve the required coverage result.\"\n    else:\n        # Log available keys for debugging\n        print(f\"Available keys in metrics: {metrics.keys()}\")\n        assert False, f\"Coverage data for '{dut}' is not available.\""}}}
{"id": "cvdp_copilot_microcode_sequencer_0028", "categories": ["cid012", "medium"], "input": {"prompt": "Complete the given partial System Verilog Testbench `tb_microcode_sequencer`.The testbench must instantiate the `microcode_sequencer` RTL module and provide input stimulus for it, apply various input combinations representing different instructions and conditions such as resetting, fetching instructions, loading data, pushing/popping from the stack, jumping, conditional holds, and program suspensions and edge cases with invalid instructions and test conditional failures rather than building a full testbench. \n\nThe module interface is given below :\n## **Module Interface** :\n### Inputs:\n- `clk`(1-bit): The positive edge-triggered clock signal required for the sequential components.\n- `c_n_in`(1-bit): Carry-in signal for the ripple carry adder.\n- `c_inc_in`(1-bit): Carry-in for the program counter incrementer.\n- `r_en`(1-bit): ACTIVE LOW auxiliary register enable signal.\n- `cc`(1-bit): ACTIVE LOW condition code input for instruction decoding.\n- `ien`(1-bit): ACTIVE LOW instruction enable signal.\n- `d_in`(4-bit , [3:0]): A 4-bit data input bus.\n- `instr_in`(5-bit, [4:0]): A 5-bit opcode representing the instruction.\n- `oen`(1-bit): ACTIVE LOW output enable for the data output path.\n\n### Outputs:\n- `d_out`(4-bit,[3:0]): A 4-bit address output bus.\n- `c_n_out`(1-bit): Carry-out signal from the ripple carry adder. LOGIC HIGH in this signal indicates the presence of carry.\n- `c_inc_out`(1-bit): Carry-out signal from the program counter incremented. LOGIC HIGH in this signal indicates the presence of carry.\n- `full`(1-bit): ACTIVE HIGH signal indicates if the Last In First Out (LIFO) stack is full.\n- `empty`(1-bit): ACTIVE HIGH signal indicates if the LIFO stack is empty.\n- `g_n_out`: Group generate signal from the arithmetic unit.\n- `p_n_out`: Group propagate signal from the arithmetic unit.\n- `g_inc_out`: Group generate signal from the program counter incrementer.\n- `p_inc_out`: Group propagate signal from the program counter incrementer.\n\n## Instantiation :\nThe testbench instantiates the `microcode_sequencer` module as **uut** and connects the signals between the module and the testbench. Each input and output from the **uut** is connected to its corresponding signal in the testbench.\n\n## Input Generation and Validation:\n**Stimulus**: \nSeveral test cases are applied to simulate various operations of the microcode_sequencer. These test cases cover a wide range of scenarios such as different types of instructions (reset, fetch, load, push, pop, jump, etc.), as well as conditional and unconditional instruction executions. For each test case, the relevant outputs (`d_out`, `c_n_out`, `c_inc_out`, `full`, `empty`, `g_n_out`, `p_n_out`, `g_inc_out`, `p_inc_out`) are monitored immediately after the application of inputs to validate the functionality.\n\n**Test Case 1: Instruction Disable** :\n- Description: This test case disables the instruction input (`5'bxxxxx`). With no valid instruction provided, the microcode sequencer should remain idle and output default values, reflecting no operation being performed. The outputs should show that the sequencer is in a non-operational state with the `uut.pc_out_w` value remaining at 0000. \n\n**Test Case 2: Reset Instruction** :\n- The test applies a reset instruction (`5'b00000`), which should clear all registers and reset the state of the sequencer. The outputs should reflect the sequencer being reset, with `d_out`, `c_n_out`, `c_inc_out`, and `uut.pc_out_w` values showing their initial conditions (`0000` for `d_out`, `0000` for `uut.pc_out_w`, and `full` set to `0`, `empty` set to `1`).\n\n**Test Case 3: Fetch PC Instruction** :\n- This test case applies a fetch PC instruction (`5'b00001`), where the program counter (PC) is fetched. The sequencer should output the program counter incremented by 1. In this case, the expected output for uut.pc_out_w is `0001`, with `d_out` reflecting the fetched value.\n\n**Test Case 4: Fetch R Instruction** :\n- The sequencer applies a fetch R instruction (`5'b00010`), which fetches the value from register R. The expected outcome is that the value in `d_out` should be the value of register R (`101` in this case) with `uut.pc_out_w` incrementing accordingly (`0010`).\n\n**Test Case 5: Fetch D Instruction** :\n- This test case applies a fetch D instruction (`5'b00011`). The sequencer fetches the value from the D input(`d_in`), with `d_out` reflecting the value of D (`110`) and `uut.pc_out_w` incrementing as expected (`0011`).\n\n**Test Case 6: Fetch R + D Instruction** :\n- A fetch R + D instruction (`5'b00100`) is applied, where the sequencer fetches and combines data from both the auxiliary register and `d_in`. The expected result is `d_out` showing the combined data (111), and `uut.pc_out_w` reflecting the expected increment (`0100`).\n\n**Test Case 7: Fetch PC + D Instruction** :\n- This test case applies a fetch PC + D instruction (`5'b00101`), which combines the values of the program counter (PC) and the `d_in`. The d_out value should reflect the combination (`1100`), and `uut.pc_out` should increment to `0101`.\n\n**Test Case 8: Fetch PC + R Instruction** :\n- The test applies a fetch PC + R instruction (`5'b00110`), where the sequencer fetches both the program counter (PC) and the Auxiliary register. The expected output for `d_out` should be a combination of the content of the PC and auxiliary register (`1101`), and `pc_out `increments accordingly to `0110`.\n\n**Test Case 9: Fetch PC to R Instruction** :\n- A fetch PC to R instruction (`5'b01000`) is applied, where the program counter (`PC`) is transferred to the auxiliary register. The expected output should show `d_out` reflecting the PC value (`111`), and `pc_out` incrementing as expected (`0111`).\n\n**Test Case 10: Fetch R+D to R Instruction** :\n- This case applies a fetch R + D to R instruction (`5'b01001`), where the data from both the auxiliary register and `d_in` are fetched, added, and transferred to the auxiliary register. The expected output should reflect this combination (`11` for `d_out`), and the program counter should increment (`1000` for `uut.pc_out_w`).\n\n**Test Case 11: Load R Instruction** :\n- A load R instruction (`5'b01010`) is applied, where data from an`d_in` is loaded into the auxiliary register. The output should reflect the `uut.pc_out_w` value (`1001` for `d_out`), and the program counter (`uut.pc_out_w`) should be incremented accordingly (`1001`).\n\n**Test Case 12: Push PC Instruction** :\n- A push PC instruction (`5'b01011`) is tested, where the program counter (`PC`) is pushed onto the stack. The output shows the updated stack (`d_out` as `1010`) and empty flag reflecting the stack status (`0`).\n\n**Test Case 13: Pop PC Instruction** :\n- A pop PC instruction (`5'b01110`) is applied, where the program counter (PC) is popped from the stack. The expected output shows the popped value (`1011`) in d_out and the updated program counter (`uut.pc_out_w` as `1101`).\n\n**Test Case 14: Push D Instruction** :\n- A push D instruction (`5'b01100`) is tested, where data from the `d_in` is pushed onto the stack. The expected output is that `d_out` reflects the pushed value and 1uut.pc_out_w1 should increment appropriately.\n\n**Test Case 15: Pop Stack Instruction** :\n- A pop stack instruction (`5'b01101`) tests the sequencer's ability to pop data from the stack. The expected outputs should show the data being popped correctly (`d_out` reflects the popped value) and the stack's status with empty being checked.\n\n**Test Case 16: HOLD** :\n- A hold instruction (`5'b01111`) is applied to check that the sequencer halts its operation. The expected behavior is that the sequencer should not move to the next instruction and `uut.pc_out_w` stays in the current state.\n\n**Test Case 17: Fail Conditional Instruction** :\n- This test applies an invalid instruction (`5'b1xxxx`) with conditional failure (`cc` = `1`). The sequencer should fail to process the instruction and output appropriate values (`d_out` reflecting updated `uut.pc_out_w` value).\n\n**Test Case 18: Jump R Instruction** :\n- A jump R instruction (`5'b10000`) is applied, where the sequencer performs a jump using the auxiliary register value. The expected output shows a jump action with `d_out` reflecting the jump address.\n\n**Test Case 19: Jump D Instruction** :\n- A jump D instruction (`5'b10001`) tests the sequencer\u2019s ability to jump based on the `d_in` value. The expected outcome is that `d_out` reflects the jump address based on the value of `d_in`.\n\n**Test Case 20: Jump 0 Instruction** :\n- A jump 0 instruction (`5'b10010`) applies a jump to address `0`. The output should reflect this jump, with `uut.pc_out_w` updated to `0000`.\n\n**Test Case 21: Jump R+D Instruction** :\n- A jump R+D instruction (`5'b10011`) applies a jump based on the sum of the auxiliary register and `d_in`. The expected output should reflect the sum.\n\n**Test Case 22: Jump PC+D Instruction** :\n- A jump PC+D instruction (`5'b10100`) applies a jump based on the sum of PC and `d_in`. The expected behavior is that `d_out `reflects the result of PC and `d_in` combined.\n\n**Test Case 23: Jump PC+R Instruction** :\n- A jump PC+R instruction (`5'b10101`) applies a jump based on the sum of PC and auxiliary register. The expected output should reflect this combination in `d_out`.\n\n**Test Case 24: JSB R Instruction** :\n- A JSB R instruction (`5'b10110`) applies a jump to a subroutine based on the auxiliary register. The output should show the subroutine jump address in `d_out`.\n\n**Test Case 25: JSB D Instruction** :\n- A JSB D instruction (`5'b10111`) applies a jump to the subroutine address based on the `d_in`. The sequencer should handle the jump correctly by appropriately updating `d_out`.\n\n**Test Case 26: JSB 0 Instruction** :\n- A JSB 0 instruction (`5'b11000`) applies a jump to a subroutine at address 0. The expected output should reflect the jump to address 0.\n\n**Test Case 27: JSB R+D Instruction** :\n- A JSB R+D instruction (5'b11001) applies a jump to the subroutine address based on the sum of the auxiliary register and `d_in`. The sequencer should perform the jump correctly.\n\n**Test Case 28: JSB PC+D Instruction** : \n - A JSB PC+D instruction (`5'b11010`) applies a jump to the subroutine address based on the sum of PC and `d_in`. The expected outcome should reflect the subroutine jump at `d_out`.\n\n**Test Case 29: Fetch S+D Instruction** :\n- This test applies a fetch S+D instruction (`5'b00111`), where the sequencer fetches and adds values of popped stack value (S) with `d_in`. The expected output should reflect the appropriate address at `d_out`.\n\n**Test Case 30: Return S Instruction** :\n- The return S instruction (`5'b11100`) tests the sequencer\u2019s ability to return from a subroutine. The expected outcome should show the return address at `d_out`.\n\n**Test Case 31: Return S+D Instruction** :\n- The return S+D instruction (`5'b11101`) checks the sequencer\u2019s ability to return from a subroutine with the sum of popped value from the stack and `d_in`. The expected output should be reflected at `d_out`.\n\n**Test Case 32: Conditional Hold** :\n- The conditional hold instruction (`5'b11110`) tests the sequencer\u2019s ability to hold execution based on a condition. The expected outcome should show that the sequencer halts.\n\n**Test Case 33: Program Suspend** :\n- The program suspend instruction (`5'b11111`) checks the sequencer\u2019s ability to suspend its program flow. The expected behavior is that the sequencer stops and no further instructions are executed.\n\n## Module Functionality :\n**Microcode Sequencer Module (microcode_sequencer)** :\nPurpose: This module controls the operation of a microprocessor by sequencing operations based on the instructions it receives. It interacts with other modules (like stack, program counter, arithmetic operations, and instruction decoder) to control the flow of data.\nIt contains the following components :\n\n**LIFO Stack Module (lifo_stack)** :\n**Purpose**: Implements a stack with push and pop functionality, allowing data to be stored and retrieved in a last-in-first-out \norder.\n**Components**:\n- **Stack Pointer**: Tracks the current position in the stack and controls whether the stack is full or empty.\n- **Stack RAM**: Stores the actual stack data.\n- **Stack Data Mux**: Selects which data (either from the program counter or data input) should be pushed onto the stack.\n\n**Program Counter Module (program_counter)** :\n**Purpose**: Handles the program counter (PC), which keeps track of the next instruction to execute. It can increment \nbased on different conditions.\n**Components**:\n- **PC Mux**: Selects the input for the program counter (either from the adder or program counter).\n- **PC Incrementer**: Performs the actual increment of the program counter based on carry and increment signals.\n- **PC Register**: Stores the current value of the program counter.\n\n**Instruction Decoder (instruction_decoder)** :\n**Purpose**: Decodes the incoming instruction (instr_in) and generates control signals for various operations like \nincrement, push, pop, stack operations, etc.\n   \n**Microcode Arithmetic Module (microcode_arithmetic)**\n**Purpose**: Performs arithmetic operations like addition using a carry lookahead adder. It uses data from various inputs \n(program counter, stack, data input) and processes it based on the instruction.\n\n**Components**:\n**Auxiliary Register**: Stores data that can be modified based on the control signals (rsel, rce).\n**MUXes**: Control the selection of data from different sources (registers, stack, program counter) to be used in arithmetic \noperations.\n**Full Adder**: Performs the actual arithmetic operations and generates the result, carry, group, generate, and propagate \nsignals. It is implemented using 4-bit carry-lookahead logic.  \n\n**Partial Test Stimulus Generator Code** :\n```verilog\nmodule tb_microcode_sequencer;\n\n  // Inputs to the DUT\n  logic clk;\n  logic c_n_in;\n  logic c_inc_in;\n  logic r_en;\n  logic cc;\n  logic ien;\n  logic [3:0] d_in;\n  logic [4:0] instr_in;\n  logic oen;\n\n  // Outputs from the DUT\n  logic [3:0] d_out;\n  logic c_n_out;\n  logic c_inc_out;\n  logic full;\n  logic empty;\n  logic g_n_out;\n  logic p_n_out;\n  logic g_inc_out;\n  logic p_inc_out;\n  \n  \n    \n  microcode_sequencer uut (\n    .clk(clk),\n    .c_n_in(c_n_in),\n    .c_inc_in(c_inc_in),\n    .r_en(r_en),\n    .cc(cc),\n    .ien(ien),\n    .d_in(d_in),\n    .instr_in(instr_in),\n    .oen(oen),\n    .d_out(d_out),\n    .c_n_out(c_n_out),\n    .c_inc_out(c_inc_out),\n    .full(full),\n    .empty(empty),\n    .g_n_out(g_n_out),\n    .p_n_out(p_n_out),\n    .g_inc_out(g_inc_out),\n    .p_inc_out(p_inc_out)\n  );\n\n  \n  initial begin\n    clk = 0;\n    forever #10 clk = ~clk;\n  end\n\n  // Task to test specific cases\n  task run_test_case(\n    input logic [4:0] test_instr,          // Instruction input\n    input logic test_carry_in,            // Carry input\n    input logic test_carry_inc,           // Carry increment input\n    input logic test_reg_en,              // Register enable\n    input logic test_cond_code,           // Condition code\n    input logic test_instr_en,            // Instruction enable\n    input logic [3:0] test_data_in,       // Data input\n    input logic test_output_en,           // Output enable\n    input string case_name                // Name of the test case\n  ); \n    begin\n      // Apply inputs\n      instr_in = test_instr;\n      c_n_in = test_carry_in;\n      c_inc_in = test_carry_inc;\n      r_en = test_reg_en;\n      cc = test_cond_code;\n      ien = test_instr_en;\n      d_in = test_data_in;\n      oen = test_output_en;\n\n      #20;  \n      $display(\"Running test case: %s\", case_name);\n      $display(\"time = %0t , Inputs: instr_in = %0b, c_n_in = %b, c_inc_in = %b, r_en = %b, cc = %b, ien = %b, d_in = %0b, oen = %b\",\n               $time,test_instr, test_carry_in, test_carry_inc, test_reg_en, test_cond_code, test_instr_en, test_data_in, test_output_en);\n      $display(\"time = %0t , d_out = %0b, c_n_out = %b, c_inc_out = %b, full = %b, empty = %b, g_n_out = %b, p_n_out = %b, g_inc_out = %b, p_inc_out = %b , pc_out = %b\",\n               $time,d_out, c_n_out, c_inc_out, full, empty, g_n_out, p_n_out, g_inc_out, p_inc_out,uut.pc_data_w);\n               \n      end\n  endtask\n\n  \n  initial begin\n    $dumpfile(\"microcode_sequencer.vcd\");  \n    $dumpvars(0, tb_microcode_sequencer);  \n\n    $display(\"Starting testbench for microcode_sequencer...\");\n\n        \n    run_test_case(5'bxxxxx, 1'b0, 1'b0, 1'b0, 1'b1, 1'b1, 4'bxxxx, 1'b0, \"Instruction Disable\");\n    run_test_case(5'b00000, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 4'bxxxx, 1'b0, \"Reset Instruction\");\n    run_test_case(5'b00001, 1'b0, 1'b1, 1'b0, 1'b0, 1'b0, 4'bxxxx, 1'b0, \"Fetch PC Instruction\");\n    run_test_case(5'b00010, 1'b0, 1'b1, 1'b0, 1'b0, 1'b0, 4'b0101, 1'b0, \"Fetch R Instruction\");\n    run_test_case(5'b00010, 1'b0, 1'b1, 1'b0, 1'b0, 1'b0, 4'b0110, 1'b0, \"Fetch R Instruction\");\n    run_test_case(5'b00011, 1'b0, 1'b1, 1'b0, 1'b0, 1'b0, 4'b0110, 1'b0, \"Fetch D Instruction\");\n    run_test_case(5'b00011, 1'b0, 1'b0, 1'b0, 1'b1, 1'b1, 4'b0110, 1'b0, \"Fetch D Instruction\"); \n    run_test_case(5'b00011, 1'b0, 1'b1, 1'b0, 1'b0, 1'b0, 4'b0111, 1'b0, \"Fetch D Instruction\");\n    // Insert the code for remaining test cases here\n```\n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_microcode_sequencer.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 212f03ed20beb93d25a4509a8d1341b23428fc6e\nTARGET = 90\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/microcode_sequencer.sv": "module microcode_sequencer (\n   // Inputs\n   input logic clk, // Input Clock\n   input logic c_n_in,  // Input Carry for Carry Lookahead Adder\n   input logic c_inc_in, // Input Carry for Carry Lookahead Program Counter Incrementer\n   input logic r_en, // Auxiliary Register enable\n   input logic cc, // Condition Code\n   input logic ien, // Instruction Enable\n   input logic [3:0] d_in, // Data Input\n   input logic [4:0] instr_in, // 5-bit Instruction Opcode\n   input logic oen, // Output Enable\n\n   // Outputs\n   output logic [3:0] d_out, // Data Output\n   output logic c_n_out , // Output Carry from Carry Lookahead Adder\n   output logic c_inc_out, // Output Carry from Program Counter Incrementer\n   output logic full, // Stack Full Condition\n   output logic empty, // Stack Empty Condition\n\n   // Additional Outputs\n   output logic g_n_out, // Group Generate output from  Carry Lookahead adder\n   output logic p_n_out, // Group Propagate output from Carry Lookahead adder\n   output logic g_inc_out, // Group Generate output from Carry Lookahead Program Counter Incrementer\n   output logic p_inc_out  // Group Propagate output from Carry Lookahead Program Counter Incrementer\n );\n\n \n logic [3:0] pc_data_w;\n logic stack_reset_w;\n logic [3:0] stack_data_w;\n logic [3:0] fa_out_w;\n logic [3:0] data_out_w;\n  \n logic rsel_w;\n logic rce_w;\n logic [1:0] a_mux_sel_w;\n logic [1:0] b_mux_sel_w;\n logic cen_w;\n logic rst_w;\n logic stack_push_w;\n logic stack_pop_w;\n logic pc_mux_sel_w;\n logic stack_mux_sel_w;\n logic stack_we_w;\n logic stack_re_w;\n logic inc_w;\n logic oen_w;\n logic out_en_w;\n \n lifo_stack dut_1 (\n    .clk              (clk),\n    .stack_data_1_in  (d_in),\n    .stack_data_2_in  (pc_data_w),\n    .stack_reset      (rst_w),\n    .stack_push       (stack_push_w),\n    .stack_pop        (stack_pop_w),\n    .stack_mux_sel    (stack_mux_sel_w),\n    .stack_we         (stack_we_w),\n    .stack_re         (stack_re_w),\n    .stack_data_out   (stack_data_w),\n    .full_o           (full),\n    .empty_o          (empty)\n );\n\n program_counter dut_2 (\n    .clk               (clk),\n    .full_adder_data_i (fa_out_w),\n    .pc_c_in           (c_inc_in),\n    .inc               (inc_w),\n    .pc_mux_sel        (pc_mux_sel_w),\n    .pc_out            (pc_data_w),\n    .pc_c_out          (c_inc_out),\n    .pc_g_out          (g_inc_out),\n    .pc_p_out          (p_inc_out)\n );\n \n microcode_arithmetic dut_3(\n    .clk              (clk),\n    .fa_in            (data_out_w),\n    .d_in             (d_in),\n    .stack_data_in    (stack_data_w),\n    .pc_data_in       (pc_data_w),\n    .reg_en           (r_en),\n    .oen              (oen_w),\n    .rsel             (rsel_w),\n    .rce              (rce_w),\n    .cen              (cen_w),\n    .a_mux_sel        (a_mux_sel_w),\n    .b_mux_sel        (b_mux_sel_w),\n    .arith_cin        (c_n_in),\n    .arith_cout       (c_n_out),\n    .arith_g_out      (g_n_out),\n    .arith_p_out      (p_n_out),\n    .oe               (oen),\n    .d_out            (fa_out_w)\n );\n \n instruction_decoder dut_4 (\n    .instr_in         (instr_in),\n    .cc_in            (cc),\n    .instr_en         (ien),\n    .cen              (cen_w), \n    .rst              (rst_w), \n    .oen              (oen_w), \n    .inc              (inc_w), \n    .rsel             (rsel_w), \n    .rce              (rce_w),  \n    .pc_mux_sel       (pc_mux_sel_w), \n    .a_mux_sel        (a_mux_sel_w), \n    .b_mux_sel        (b_mux_sel_w), \n    .push             (stack_push_w),\n    .pop              (stack_pop_w), \n    .src_sel          (stack_mux_sel_w),\n    .stack_we         (stack_we_w),\n    .stack_re         (stack_re_w),\n    .out_ce           (out_ce_w)\n);\n\n result_register dut_5 (\n   .clk     (clk),\n   .data_in (fa_out_w),\n   .out_ce  (out_ce_w),\n   .data_out(data_out_w)\n );\nassign d_out = fa_out_w;\nendmodule\n \nmodule stack_pointer (\n  input logic clk,\n  input logic rst,\n  input logic push,\n  input logic pop,\n  output logic [4:0] stack_addr,\n  output logic full,\n  output logic empty\n);\nlogic [4:0] stack_addr_reg;\nlogic full_r;\nlogic empty_r;\nassign full_r     = (stack_addr_reg == 5'b10000);\nassign empty_r    = (stack_addr_reg == 5'b00000);\nalways_ff@(posedge clk) begin\n   if(rst)\n     stack_addr_reg <= 5'b00000;\n   else if(push && !full_r) begin\n     stack_addr_reg <= stack_addr_reg + 5'b00001;\n   end else if(pop && !empty_r) begin\n     stack_addr_reg <= stack_addr_reg - 5'b00001;\n   end \n   \nend\nassign full       = full_r;\nassign empty      = empty_r;\nassign stack_addr = stack_addr_reg; \nendmodule\n\nmodule stack_ram (\n  input logic clk,\n  input logic  [4:0] stack_addr,\n  input logic  [3:0] stack_data_in,\n  input logic  stack_we,\n  input logic  stack_re,\n  output logic [3:0] stack_data_out\n);\n\nlogic [3:0] stack_arr [16:0];\nalways_ff@(posedge clk) begin\n  if(stack_we) begin\n    stack_arr[stack_addr] = stack_data_in;\n  end\nend\n\nassign stack_data_out = stack_re ? stack_arr[stack_addr] : '0; \nendmodule\n\nmodule stack_data_mux (\n  input  logic [3:0] data_in,\n  input  logic [3:0] pc_in,\n  input  logic stack_mux_sel,\n  output logic [3:0] stack_mux_out\n);\nassign stack_mux_out = stack_mux_sel ? data_in : pc_in;\nendmodule\n\nmodule lifo_stack (\n  input  logic clk,\n  input  logic [3:0] stack_data_1_in,\n  input  logic [3:0] stack_data_2_in,\n  input  logic stack_reset,\n  input  logic stack_push,\n  input  logic stack_pop,\n  input  logic stack_mux_sel,\n  input  logic stack_we,\n  input  logic stack_re,\n  output logic [3:0] stack_data_out,\n  output logic full_o,\n  output logic empty_o\n);\n\nlogic [3:0] stack_data_in_w;\nlogic [4:0] stack_addr_w;\n\nstack_data_mux dut_1(\n    .data_in       (stack_data_1_in),\n    .pc_in         (stack_data_2_in),\n    .stack_mux_sel (stack_mux_sel),\n    .stack_mux_out (stack_data_in_w)\n);\n\nstack_pointer dut_2 (\n     .clk        (clk),\n     .rst        (stack_reset),\n     .push       (stack_push),\n     .pop        (stack_pop),\n     .stack_addr (stack_addr_w),\n     .full       (full_o),\n     .empty      (empty_o)\n);\n\nstack_ram dut_3 (\n     .clk            (clk),\n     .stack_addr     (stack_addr_w),\n     .stack_data_in  (stack_data_in_w),\n     .stack_we       (stack_we),\n     .stack_re       (stack_re),\n     .stack_data_out (stack_data_out)\n);\nendmodule\n\nmodule pc_mux (\n    input logic [3:0] full_adder_data,\n    input logic [3:0] pc_data,\n    input logic pc_mux_sel,\n    output logic [3:0] pc_mux_out\n);\nassign pc_mux_out = pc_mux_sel ? pc_data : full_adder_data;\nendmodule\n\n\nmodule pc_incrementer (\n  input  logic pc_c_in,         \n  input  logic inc,             \n  input  logic [3:0] pc_data_in,\n  output logic [3:0] pc_inc_out,\n  output logic pc_c_out,        \n  output logic pc_g_out,        \n  output logic pc_p_out         \n);\n  \n    logic g[3:0];\n    logic p[3:0];\n    logic c[4:0];\n\n    assign g[0]  = 1'b0;\n    assign g[1]  = 1'b0;\n    assign g[2]  = 1'b0;\n    assign g[3]  = 1'b0;\n\n    assign p[0]  = pc_data_in[0] ^ 1'b0; \n    assign p[1]  = pc_data_in[1] ^ 1'b0; \n    assign p[2]  = pc_data_in[2] ^ 1'b0; \n    assign p[3]  = pc_data_in[3] ^ 1'b0; \n    \n    assign c[0]  = pc_c_in;\n    assign c[1]  = (p[0] & c[0]);\n    assign c[2]  = (c[0] & p[0] & p[1]);\n    assign c[3]  = (c[0] & p[0] & p[1] & p[2]);\n    assign c[4]  = (c[0] & p[0] & p[1] & p[2] & p[3]);\n\n    assign pc_inc_out[0]  = inc ? p[0] ^ c[0] : p[0];\n    assign pc_inc_out[1]  = inc ? p[1] ^ c[1] : p[1];\n    assign pc_inc_out[2]  = inc ? p[2] ^ c[2] : p[2];\n    assign pc_inc_out[3]  = inc ? p[3] ^ c[3] : p[3];\n    assign pc_p_out = p[0] & p[1] & p[2] & p[3];\n    assign pc_g_out = 1'b0;\n    assign pc_c_out = c[4];\nendmodule\n\n\nmodule pc_reg (\n input logic clk,\n input logic[3:0] pc_data_in,\n output logic [3:0] pc_data_out\n);\nalways_ff@(posedge clk) begin\n   pc_data_out <= pc_data_in;\n   \nend\nendmodule\n\nmodule program_counter(\n  input logic clk,\n  input logic [3:0] full_adder_data_i,\n  input logic pc_c_in,\n  input logic inc,\n  input logic pc_mux_sel,\n  output logic [3:0] pc_out,\n  output logic pc_c_out,\n  output logic pc_g_out,\n  output logic pc_p_out\n);\n \n logic [3:0] pc_out_w;\n logic [3:0] pc_mux_out_w;\n logic [3:0] pc_inc_out_w;\n logic pc_c_out_w;\n \n \npc_mux dut_1 (\n   .full_adder_data(full_adder_data_i),\n   .pc_data(pc_out_w),\n   .pc_mux_sel(pc_mux_sel),\n   .pc_mux_out(pc_mux_out_w)\n);\n\npc_incrementer dut_2 (\n  .pc_c_in(pc_c_in),\n  .inc(inc),\n  .pc_data_in(pc_mux_out_w),\n  .pc_inc_out(pc_inc_out_w),\n  .pc_c_out(pc_c_out_w),\n  .pc_g_out(pc_g_out),\n  .pc_p_out(pc_p_out)\n);\n\npc_reg dut_3 (\n   .clk(clk),\n   .pc_data_in(pc_inc_out_w),\n   .pc_data_out(pc_out_w)\n);\n\nassign pc_out = pc_out_w;\nassign pc_c_out = pc_c_out_w;\nendmodule\n\nmodule instruction_decoder(\n    input logic [4:0] instr_in,\n    input logic cc_in,\n    input logic instr_en,\n    output logic cen, \n    output logic rst, \n    output logic oen, \n    output logic inc, \n    output logic rsel, \n    output logic rce,  \n    output logic pc_mux_sel, \n    output logic [1:0] a_mux_sel, \n    output logic [1:0] b_mux_sel, \n    output logic push,\n    output logic pop, \n    output logic src_sel,\n    output logic stack_we,\n    output logic stack_re,\n    output logic out_ce\n );\n\n always_comb begin\n    casex({instr_in,cc_in,instr_en})\n       7'bxxxxxx1 : begin  \n                      rst        = 1'b0;\n                      out_ce     = 1'b0;\n                      rsel       = 1'b0;\n                      rce        = 1'b0;\n                      cen        = 1'b0;\n                      stack_re   = 1'b0;\n                      pop        = 1'b0;\n                      a_mux_sel  = 2'b10;\n                      b_mux_sel  = 2'b10;\n                      oen        = 1'b1;\n                      pc_mux_sel = 1'b0;\n                      inc        = 1'b0;\n                      src_sel    = 1'b0;\n                      push       = 1'b0;\n                      stack_we   = 1'b0;\n                   end\n      7'b00000x0 : begin  \n                      rst        = 1'b1;\n                      out_ce     = 1'b0;\n                      rsel       = 1'b0;\n                      rce        = 1'b1; \n                      cen        = 1'b1;  \n                      stack_re   = 1'b0;\n                      pop        = 1'b0;\n                      a_mux_sel  = 2'b10;  \n                      b_mux_sel  = 2'b10;  \n                      oen        = 1'b1;  \n                      pc_mux_sel = 1'b0; \n                      inc        = 1'b1; \n                      src_sel    = 1'b0; \n                      push       = 1'b0;\n                      stack_we   = 1'b0;\n                   end\n      7'b00001x0 : begin  \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                   end\n      7'b00010x0 : begin  \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b01; \n                     b_mux_sel   = 2'b10;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                   end\n      7'b00011x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0;  \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00; \n                     b_mux_sel   = 2'b10;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b00100x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1;  \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00; \n                     b_mux_sel   = 2'b11;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b00101x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00; \n                     b_mux_sel   = 2'b00;  \n                     oen         = 1'b1;  \n                     pc_mux_sel  = 1'b1;  \n                     inc         = 1'b1;  \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b00110x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b01; \n                     b_mux_sel   = 2'b00;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b00111x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b1;\n                     pop         = 1'b1;\n                     a_mux_sel   = 2'b00; \n                     b_mux_sel   = 2'b01;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b01000x0 : begin  \n                     rst         = 1'b0;\n                     out_ce      = 1'b1;\n                     rsel        = 1'b1;\n                     rce         = 1'b0;\n                     cen         = 1'b0; \n                     stack_re    = 1'b0; \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b01001x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b1;\n                     rsel        = 1'b0;\n                     rce         = 1'b1;\n                     cen         = 1'b1; \n                     stack_re    = 1'b0;  \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00; \n                     b_mux_sel   = 2'b11; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0; \n                     stack_we    = 1'b0;\n                  end                    \n     7'b01010x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b1;\n                     rce         = 1'b0;\n                     cen         = 1'b0; \n                     stack_re    = 1'b0;  \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b01011x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0;\n                     rce         = 1'b1;\n                     cen         = 1'b0; \n                     stack_re    = 1'b0;  \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0; \n                     push        = 1'b1; \n                     stack_we    = 1'b1; \n                  end   \n     7'b01100x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0;\n                     rce         = 1'b1;\n                     cen         = 1'b0; \n                     stack_re    = 1'b0; \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b1; \n                     push        = 1'b1; \n                     stack_we    = 1'b1; \n                  end\n     7'b01101x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0;\n                     rce         = 1'b1;\n                     cen         = 1'b0; \n                     stack_re    = 1'b1; \n                     pop         = 1'b1; \n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b01; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0; \n                     push        = 1'b0; \n                     stack_we    = 1'b0; \n                  end    \n    7'b01110x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0;\n                     rce         = 1'b1;\n                     cen         = 1'b0; \n                     stack_re    = 1'b1; \n                     pop         = 1'b1; \n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b01; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0; \n                     push        = 1'b0; \n                     stack_we    = 1'b0; \n                 end    \n    7'b01111x0 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0;\n                     rce         = 1'b1;\n                     cen         = 1'b0; \n                     stack_re    = 1'b1; \n                     pop         = 1'b1; \n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b0; \n                     src_sel     = 1'b0; \n                     push        = 1'b0; \n                     stack_we    = 1'b0; \n                  end\n     7'b1xxxx10 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10; \n                     b_mux_sel   = 2'b00;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                   end \n     7'b1000000 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b01;\n                     b_mux_sel   = 2'b10;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n     7'b1000100 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00;\n                     b_mux_sel   = 2'b10;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end\n    7'b1001000 :  begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10;\n                     b_mux_sel   = 2'b10; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                  end  \n    7'b1001100 :  begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00;\n                     b_mux_sel   = 2'b11;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;  \n                  end\n    7'b1010000 :  begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00;\n                     b_mux_sel   = 2'b00;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0; \n                  end  \n                   \n    7'b1010100 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b01;\n                     b_mux_sel   = 2'b00;  \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;  \n                 end                    \n    7'b1011000 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b01;\n                     b_mux_sel   = 2'b10; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b1;\n                     stack_we    = 1'b1;\n                 end\n    7'b1011100 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00;\n                     b_mux_sel   = 2'b10; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b1;\n                     stack_we    = 1'b1; \n                 end\n    7'b1100000 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10;\n                     b_mux_sel   = 2'b10; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b1;\n                     stack_we    = 1'b1; \n                 end\n    7'b1100100 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00;\n                     b_mux_sel   = 2'b11; \n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b1;\n                     stack_we    = 1'b1;\n                 end\n    7'b1101000 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b00;\n                     b_mux_sel   = 2'b00;\n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b1;\n                     stack_we    = 1'b1; \n                 end\n    7'b1101100 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b0;\n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b01;\n                     b_mux_sel   = 2'b00;\n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b1;\n                     stack_we    = 1'b1; \n                end \n   7'b1110000 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b1;\n                     pop         = 1'b1;\n                     a_mux_sel   = 2'b10;\n                     b_mux_sel   = 2'b01;\n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0; \n                end\n   7'b1110100 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b1; \n                     stack_re    = 1'b1; \n                     pop         = 1'b1;\n                     a_mux_sel   = 2'b00;\n                     b_mux_sel   = 2'b01;\n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b1; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;  \n               end\n  7'b1111000 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0; \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10;\n                     b_mux_sel   = 2'b00;\n                     oen         = 1'b1; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b0; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0; \n               end\n  7'b1111100 : begin \n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b1; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0; \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10;\n                     b_mux_sel   = 2'b00;\n                     oen         = 1'b0; \n                     pc_mux_sel  = 1'b1; \n                     inc         = 1'b0; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                end        \n    default   : begin\n                     rst         = 1'b0;\n                     out_ce      = 1'b0;\n                     rsel        = 1'b0; \n                     rce         = 1'b0; \n                     cen         = 1'b0; \n                     stack_re    = 1'b0; \n                     pop         = 1'b0;\n                     a_mux_sel   = 2'b10;\n                     b_mux_sel   = 2'b10;\n                     oen         = 1'b0; \n                     pc_mux_sel  = 1'b0; \n                     inc         = 1'b0; \n                     src_sel     = 1'b0;\n                     push        = 1'b0;\n                     stack_we    = 1'b0;\n                   end \n     endcase\n  end\nendmodule\n\n\nmodule full_adder (\n    input  logic [3:0] a_in,\n    input  logic [3:0] b_in,\n    input  logic cen,\n    input  logic c_in,\n    output logic [3:0] y_out,\n    output logic c_out,\n    output logic g_out,\n    output logic p_out\n);\n    \n    logic g[3:0];\n    logic p[3:0];\n    logic c[4:0];\n\n    assign g[0]  = a_in[0] & b_in[0];\n    assign g[1]  = a_in[1] & b_in[1];\n    assign g[2]  = a_in[2] & b_in[2];\n    assign g[3]  = a_in[3] & b_in[3];\n\n    assign p[0]  = a_in[0] ^ b_in[0];\n    assign p[1]  = a_in[1] ^ b_in[1];\n    assign p[2]  = a_in[2] ^ b_in[2];\n    assign p[3]  = a_in[3] ^ b_in[3];\n    \n    assign c[0]  = c_in;\n    assign c[1]  = g[0] | (p[0] & c[0]);\n    assign c[2]  = g[1] | (g[0] & p[1]) | (c[0] & p[0] & p[1]);\n    assign c[3]  = g[2] | (g[1] & p[2]) | (g[0] & p[1] & p[2]) | (c[0] & p[0] & p[1] & p[2]);\n    assign c[4]  = g[3] | (g[2] & p[3]) | (g[1] & p[2] & p[3]) | (g[0] & p[1] & p[2] & p[3]) | (c[0] & p[0] & p[1] & p[2] & p[3]);\n\n    assign y_out[0]  = cen ? p[0] ^ c[0] : p[0];\n    assign y_out[1]  = cen ? p[1] ^ c[1] : p[1];\n    assign y_out[2]  = cen ? p[2] ^ c[2] : p[2];\n    assign y_out[3]  = cen ? p[3] ^ c[3] : p[3];\n    assign p_out = p[0] & p[1] & p[2] & p[3];\n    assign g_out = g[3] | (g[2] & p[3]) | (g[1] & p[3] & p[2]) | (g[0] & p[3] & p[2] & p[1]);\n    assign c_out = c[4];\nendmodule\n\nmodule aux_reg_mux (\n  input logic [3:0] reg1_in, \n  input logic [3:0] reg2_in, \n  input logic rsel,\n  input logic re,\n  output logic [3:0] reg_mux_out\n);\n\nassign reg_mux_out = (~re & rsel) ? reg1_in : reg2_in;\nendmodule\n\nmodule aux_reg (\n    input logic clk,\n    input logic [3:0] reg_in,\n    input logic rce,\n    input logic re,\n    output logic [3:0] reg_out\n);\n always_ff@(posedge clk) begin\n   if(rce | ~re) \n    reg_out <= reg_in;\n end\nendmodule\n\nmodule a_mux (\n  input logic [3:0] register_data,\n  input logic [3:0] data_in,\n  input logic [1:0] a_mux_sel,\n  output logic [3:0] a_mux_out\n);\nalways_comb begin\n  case(a_mux_sel) \n      2'b00 : a_mux_out = data_in;\n      2'b01 : a_mux_out = register_data;\n      2'b10 : a_mux_out = 4'b0000;\n      default : a_mux_out = 4'b0000;\n  endcase\nend\nendmodule\n\nmodule b_mux (\n  input logic [3:0] register_data,\n  input logic [3:0] stack_data,\n  input logic [3:0] pc_data,\n  input logic [1:0] b_mux_sel,\n  output logic [3:0] b_mux_out\n);\n\nalways_comb begin\n    case(b_mux_sel)\n      2'b00 : b_mux_out = pc_data;\n      2'b01 : b_mux_out = stack_data;\n      2'b10 : b_mux_out = 4'b0000;\n      2'b11 : b_mux_out = register_data;\n      default : ;\n    endcase\nend\nendmodule\n\nmodule microcode_arithmetic ( \n  input  logic clk,\n  input  logic [3:0] fa_in,\n  input  logic [3:0] d_in,\n  input  logic [3:0] stack_data_in,\n  input  logic [3:0] pc_data_in,\n  input  logic       reg_en,\n  input  logic       oen,\n  input  logic       rsel,\n  input  logic       rce,\n  input  logic       cen,\n  input  logic [1:0] a_mux_sel,\n  input  logic [1:0] b_mux_sel,\n  input  logic       arith_cin,\n  output logic       arith_cout,\n  output logic       arith_g_out,\n  output logic       arith_p_out,\n  input  logic       oe,\n  output logic [3:0] d_out\n);\n\nlogic [3:0] fa_out_w;\nlogic [3:0] reg_mux_out_w;\nlogic [3:0] reg_out_w;\nlogic [3:0] a_mux_out_w;\nlogic [3:0] b_mux_out_w;\n\n\naux_reg_mux dut_1 (\n  .reg1_in     (fa_in),\n  .reg2_in     (d_in),\n  .rsel        (rsel),\n  .re          (reg_en),\n  .reg_mux_out (reg_mux_out_w)\n);\n\naux_reg dut_2 (\n    .clk     (clk),\n    .reg_in  (reg_mux_out_w),\n    .rce     (rce),\n    .re      (reg_en),\n    .reg_out (reg_out_w)\n);\n\na_mux dut_3(\n  .register_data(reg_out_w),\n  .data_in      (d_in),\n  .a_mux_sel    (a_mux_sel),\n  .a_mux_out    (a_mux_out_w)\n);\n\nb_mux dut_4(\n  .register_data  (reg_out_w),\n  .stack_data     (stack_data_in),\n  .pc_data        (pc_data_in),\n  .b_mux_sel      (b_mux_sel),\n  .b_mux_out      (b_mux_out_w)\n);\n\nfull_adder dut_5 (\n  .a_in  (a_mux_out_w),\n  .b_in  (b_mux_out_w),\n  .cen   (cen),\n  .c_in  (arith_cin),\n  .y_out (fa_out_w),\n  .c_out (arith_cout),\n  .g_out (arith_g_out),\n  .p_out (arith_p_out)\n);\nassign d_out = oen & ~oe ? fa_out_w : 4'bzzzz;\nendmodule\n \nmodule result_register ( \n  input  logic clk,\n  input  logic [3:0] data_in,\n  input  logic out_ce,\n  output logic [3:0] data_out\n);\nalways_latch begin\n   if(out_ce)\n     data_out = data_in;\nend\nendmodule    \n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    for line in lines[2:]:\n        info = line.split()\n        while len(info) < 3:\n            info.append(\"0%\")\n        inst = re.sub(r'[\\W]', '', info[0])\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'dut' is missing in the coverage log.\")\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))\n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['dut']['Average']}, Target: {target}\"\n"}}}
{"id": "cvdp_copilot_morse_code_0027", "categories": ["cid012", "easy"], "input": {"prompt": "Complete the given partial SystemVerilog testbench `morse_encoder_tb`. The testbench must instantiate the `morse_encoder` **RTL** module and provide input stimulus for it, focusing exclusively on generating test vectors rather than building a full testbench.  \n\nThe `morse_encoder` module converts an **8-bit ASCII input** into a **6-bit Morse code output** along with the **length** of the Morse representation.\n\n---\n\n## **Description:**\n### **Inputs**:\n\nRegisters:  \n- `ascii_in` (8-bit, `[7:0]`): ASCII character input supplied to the **DUT**.  \n\n### **Outputs**:\n\nRegisters:  \n- `morse_out` (6-bit, `[5:0]`): Encoded Morse representation received from the **DUT**.  \n- `morse_length` (4-bit, `[3:0]`): Length of the Morse code sequence for the given input character.\n\n---\n\n## **Instantiation:**  \nThe testbench instantiates the `morse_encoder` module as **dut** and connects the signals between the module and the testbench.  \nEach input and output from the **DUT** is connected to its corresponding signal in the testbench.\n\n---\n\n## **Input Generation and Validation:**  \n### **Stimulus Generation:**  \nMultiple test cases are applied to verify Morse encoding for different ASCII characters. The output from the **DUT** is monitored using `$display`.\n\n### **Test Cases:**  \n\n- **Alphabet (Uppercase)**  \n  - `ascii_in = 8'h41;` // 'A'  \n  - `ascii_in = 8'h42;` // 'B'  \n  - `ascii_in = 8'h43;` // 'C'  \n  - `ascii_in = 8'h44;` // 'D'  \n  - `ascii_in = 8'h45;` // 'E'  \n  - `ascii_in = 8'h46;` // 'F'  \n  - `ascii_in = 8'h47;` // 'G'  \n  - `ascii_in = 8'h48;` // 'H'  \n  - `ascii_in = 8'h49;` // 'I'  \n  - `ascii_in = 8'h4A;` // 'J'  \n  - `ascii_in = 8'h4B;` // 'K'  \n  - `ascii_in = 8'h4C;` // 'L'  \n  - `ascii_in = 8'h4D;` // 'M'  \n  - `ascii_in = 8'h4E;` // 'N'  \n  - `ascii_in = 8'h4F;` // 'O'  \n  - `ascii_in = 8'h50;` // 'P'  \n  - `ascii_in = 8'h51;` // 'Q'  \n  - `ascii_in = 8'h52;` // 'R'  \n  - `ascii_in = 8'h53;` // 'S'  \n  - `ascii_in = 8'h54;` // 'T'  \n  - `ascii_in = 8'h55;` // 'U'  \n  - `ascii_in = 8'h56;` // 'V'  \n  - `ascii_in = 8'h57;` // 'W'  \n  - `ascii_in = 8'h58;` // 'X'  \n  - `ascii_in = 8'h59;` // 'Y'  \n  - `ascii_in = 8'h5A;` // 'Z'  \n\n- **Numbers (0-9)**  \n  - `ascii_in = 8'h30;` // '0'  \n  - `ascii_in = 8'h31;` // '1'  \n  - `ascii_in = 8'h32;` // '2'  \n  - `ascii_in = 8'h33;` // '3'  \n  - `ascii_in = 8'h34;` // '4'  \n  - `ascii_in = 8'h35;` // '5'  \n  - `ascii_in = 8'h36;` // '6'  \n  - `ascii_in = 8'h37;` // '7'  \n  - `ascii_in = 8'h38;` // '8'  \n  - `ascii_in = 8'h39;` // '9'  \n\n- **Punctuation and Special Characters**  \n  - `ascii_in = 8'h2E;` // '.'  \n  - `ascii_in = 8'h2C;` // ','  \n  - `ascii_in = 8'h3F;` // '?'  \n  - `ascii_in = 8'h27;` // \"'\"  \n  - `ascii_in = 8'h21;` // '!'  \n  - `ascii_in = 8'h2F;` // '/'  \n  - `ascii_in = 8'h28;` // '('  \n  - `ascii_in = 8'h29;` // ')'  \n  - `ascii_in = 8'h26;` // '&'  \n  - `ascii_in = 8'h3A;` // ':'  \n  - `ascii_in = 8'h3B;` // ';'  \n  - `ascii_in = 8'h3D;` // '='  \n  - `ascii_in = 8'h2B;` // '+'  \n  - `ascii_in = 8'h2D;` // '-'  \n  - `ascii_in = 8'h22;` // '\"'  \n  - `ascii_in = 8'h40;` // '@'  \n\n- **Edge Cases and Invalid Inputs**  \n  - `ascii_in = 8'h00;` // NULL  \n  - `ascii_in = 8'hFF;` // Maximum 8-bit value  \n  - `ascii_in = 8'h7B;` // '{'  \n  - `ascii_in = 8'h7F;` // DEL  \n  - `ascii_in = 8'h5D;` // ']'  \n  - `ascii_in = 8'h5B;` // '['  \n  - `ascii_in = 8'h7A;` // 'z' (Lowercase)  \n  - `ascii_in = 8'h7C;` // '|'  \n\n---\n\n## **Reset Handling:**  \nAt the beginning of the test, an **initial condition** is set to ensure the **DUT** starts in a known state. The testbench then applies each test case sequentially.  \n\n---\n\n```verilog\nmodule morse_encoder_tb;\n\n    reg [7:0] ascii_in;\n    wire [5:0] morse_out; \n    wire [3:0] morse_length;\n\n    morse_encoder dut (\n        .ascii_in(ascii_in),\n        .morse_out(morse_out),\n        .morse_length(morse_length)\n    );\n\n    initial begin\n        $display(\"Starting Testbench...\");\n\n       // Insert code here for Test bench \n\nendmodule\n```\n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 208ecc090e1758e03fab1e8fb9fa33c670aef92d\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/morse_encoder.sv": "module morse_encoder (\n    input wire [7:0] ascii_in,       // ASCII input character\n    output reg [5:0] morse_out,      // Morse code output \n    output reg [3:0] morse_length    // Length of the Morse code sequence\n);\n\n    always @(*) begin\n        case (ascii_in)\n            8'h41: begin morse_out = 6'b000001; morse_length = 2; end  \n            8'h42: begin morse_out = 6'b100000; morse_length = 4; end  \n            8'h43: begin morse_out = 6'b101000; morse_length = 4; end  \n            8'h44: begin morse_out = 6'b010000; morse_length = 3; end  \n            8'h45: begin morse_out = 6'b000001; morse_length = 1; end  \n            8'h46: begin morse_out = 6'b001000; morse_length = 4; end  \n            8'h47: begin morse_out = 6'b110000; morse_length = 3; end  \n            8'h48: begin morse_out = 6'b000000; morse_length = 4; end  \n            8'h49: begin morse_out = 6'b000001; morse_length = 2; end  \n            8'h4A: begin morse_out = 6'b011100; morse_length = 4; end  \n            8'h4B: begin morse_out = 6'b101000; morse_length = 3; end  \n            8'h4C: begin morse_out = 6'b010000; morse_length = 4; end  \n            8'h4D: begin morse_out = 6'b110000; morse_length = 2; end  \n            8'h4E: begin morse_out = 6'b100000; morse_length = 2; end  \n            8'h4F: begin morse_out = 6'b111000; morse_length = 3; end  \n            8'h50: begin morse_out = 6'b011000; morse_length = 4; end  \n            8'h51: begin morse_out = 6'b110100; morse_length = 4; end  \n            8'h52: begin morse_out = 6'b010000; morse_length = 3; end  \n            8'h53: begin morse_out = 6'b000000; morse_length = 3; end  \n            8'h54: begin morse_out = 6'b000001; morse_length = 1; end  \n            8'h55: begin morse_out = 6'b001000; morse_length = 3; end  \n            8'h56: begin morse_out = 6'b000100; morse_length = 4; end  \n            8'h57: begin morse_out = 6'b011000; morse_length = 3; end  \n            8'h58: begin morse_out = 6'b100100; morse_length = 4; end  \n            8'h59: begin morse_out = 6'b101100; morse_length = 4; end  \n            8'h5A: begin morse_out = 6'b110000; morse_length = 4; end  \n            8'h30: begin morse_out = 6'b111111; morse_length = 5; end  \n            8'h31: begin morse_out = 6'b011111; morse_length = 5; end  \n            8'h32: begin morse_out = 6'b001111; morse_length = 5; end  \n            8'h33: begin morse_out = 6'b000111; morse_length = 5; end  \n            8'h34: begin morse_out = 6'b000011; morse_length = 5; end  \n            8'h35: begin morse_out = 6'b000001; morse_length = 5; end  \n            8'h36: begin morse_out = 6'b100000; morse_length = 5; end  \n            8'h37: begin morse_out = 6'b110000; morse_length = 5; end  \n            8'h38: begin morse_out = 6'b111000; morse_length = 5; end  \n            8'h39: begin morse_out = 6'b111100; morse_length = 5; end  \n            8'h2E: begin morse_out = 6'b010101; morse_length = 6; end  \n            8'h2C: begin morse_out = 6'b110011; morse_length = 6; end  \n            8'h3F: begin morse_out = 6'b001100; morse_length = 6; end  \n            8'h27: begin morse_out = 6'b011110; morse_length = 6; end  \n            8'h21: begin morse_out = 6'b101011; morse_length = 6; end  \n            8'h2F: begin morse_out = 6'b100010; morse_length = 5; end  \n            8'h28: begin morse_out = 6'b101100; morse_length = 5; end  \n            8'h29: begin morse_out = 6'b101101; morse_length = 6; end  \n            8'h26: begin morse_out = 6'b010000; morse_length = 5; end  \n            8'h3A: begin morse_out = 6'b111000; morse_length = 6; end  \n            8'h3B: begin morse_out = 6'b101010; morse_length = 6; end  \n            8'h3D: begin morse_out = 6'b100001; morse_length = 5; end  \n            8'h2B: begin morse_out = 6'b010100; morse_length = 5; end  \n            8'h2D: begin morse_out = 6'b100001; morse_length = 6; end  \n            8'h22: begin morse_out = 6'b010010; morse_length = 6; end  \n            8'h40: begin morse_out = 6'b011010; morse_length = 6; end  \n            default: begin\n                morse_out = 6'b000000;                 \n                morse_length = 4'b0000;\n            end\n        endcase\n    end\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_nbit_swizzling_0009", "categories": ["cid012", "easy"], "input": {"prompt": "Write a SystemVerilog testbench for a `nbit_swizzling` module that performs bitwise operations on input data based on a selection signal(`sel`). The testbench should only provide a sequence of test cases to the instantiated RTL module for nbit-swizzling transformations based on the selection signal and ensure proper synchronization of different input signals.\n\n## Description\n**Parameters:**\n\n- `DATA_WIDTH`: Defines the data width of the input and output signals. (default: 16)\n\n**Inputs:**\n\n  - `data_in ([DATA_WIDTH-1:0])`: The input data to be swizzled.\n  - `sel ([1:0])`: Selection signal controlling the swizzling mode.\n\n**Outputs:**\n\n  - `data_out([DATA_WIDTH-1:0])`: The swizzled output data.\n\n## Module Description\n\nThe `nbit_swizzling` module takes an N-bit input (`data_in`) and performs different bit-swizzling transformations based on the selection signal (`sel`).\n\nThe behavior of `nbit_swizzling` is controlled by `sel`:   \n\n- **`sel = 2'b00`**: Complete bitwise reversal of `data_in`.  \n- **`sel = 2'b01`**:  Swap upper and lower halves of `data_in`.  \n- **`sel = 2'b10`**:  Swap quarter sections of `data_in`.  \n- **`sel = 2'b11`**:  Swap eighth sections of `data_in`.  \n- **`Default:`** `data_out` equals to `data_in`.\n\n**Edge Cases:**\n\n- `DATA_WIDTH` must be at least 16 and a multiple of 8.\n- The design(`nbit_swizzling`) must be implemented as combinational logic.\n\n## Testbench Requirements\n\n### Module Instantiation:\n\n- The `nbit_swizzling` module should be instantiated as uut, with all input and output signals properly connected. The testbench must achieve **100% coverage** by covering all input cases.\n\n### Input Stimulus Generation\nThe testbench implements six test cases, each designed to validate a specific functionality:\n\n**Test 1: full_reverse**\n- Repeat 1000 times. Set `sel` = 2'b00.\n- Apply random values of `data_in` value in the range 0 to (2**`DATA_WIDTH`)-1.\n\n**Test 2: half_reverse**\n- Repeat 1000 times. Set `sel` = 2'b01.\n- Apply random values of `data_in` value in the range 0 to (2**`DATA_WIDTH`)-1.\n\n**Test 3: quarter_reverse**\n- Repeat 1000 times. Set `sel` = 2'b10.\n- Apply random values of `data_in` value in the range 0 to (2**`DATA_WIDTH`)-1.\n\n**Test 4: eighth_reverse**\n- Repeat 1000 times. Set `sel` = 2'b11.\n- Apply random values of `data_in` value in the range 0 to (2**`DATA_WIDTH`)-1.\n\n**Test 5: unknown_test**\n- Repeat 1000 times. Randomize `data_in`. Set `sel` = 2'bxx.\n- Validate the module's stability across different input patterns.\n\n**Test 6: random_test**\n- Repeat 1000 times. Randomize `sel` and `data_in`.\n- Validate the module's stability across different input patterns.\n\n**Synchronization**\n- After applying the new randomized inputs(`data_in` and `sel`), wait for **#10ns** before checking the outputs.\n\nCan you implement a SystemVerilog testbench with the above specifications to thoroughly validate all test cases?", "context": {}}, "output": {"response": "", "context": {"verif/nbit_swizzling_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n   xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = 2ffe2ca151ffbcff09abe53bb2adc5a6ba0d869a\nTARGET          = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/nbit_swizzling.sv": "module nbit_swizzling #(parameter DATA_WIDTH = 64)(\n    input [DATA_WIDTH-1:0] data_in,                                         // Input data of size DATA_WIDTH \n    input [1:0] sel,                \t                                    //  2-bit selection signal \n    output reg [DATA_WIDTH-1:0] data_out                                    // Output data of size DATA_WIDTH \n);\n\ninteger i; //Loop counter\n\nalways @(*) begin\n    case(sel)\n        2'b00: begin\n            for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH-1-i];                      \n            end\n        end\n        \n        2'b01: begin\n            for (i = 0; i < DATA_WIDTH/2; i = i + 1) begin\n                data_out[i]                = data_in[DATA_WIDTH/2-1-i];     \n                data_out[DATA_WIDTH/2 + i] = data_in[DATA_WIDTH-1-i];       \n            end\n        end\n        \n        2'b10: begin\n            for (i = 0; i < DATA_WIDTH/4; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH/4-1-i]; \t\t            \n                data_out[DATA_WIDTH/4 + i]   = data_in[DATA_WIDTH/2-1-i];  \n                data_out[DATA_WIDTH/2 + i]   = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n        end\n        \n        2'b11: begin\n            for (i = 0; i < DATA_WIDTH/8; i = i + 1) begin\n                data_out[i]                  = data_in[DATA_WIDTH/8-1-i];   \n                data_out[DATA_WIDTH/8 + i]   = data_in[DATA_WIDTH/4-1-i];   \n                data_out[DATA_WIDTH/4 + i]   = data_in[3*DATA_WIDTH/8-1-i]; \n                data_out[3*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[5*DATA_WIDTH/8-1-i]; \n                data_out[5*DATA_WIDTH/8 + i] = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[7*DATA_WIDTH/8-1-i]; \n                data_out[7*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n        end\n\n        default: begin\n            data_out = data_in;\t\t\t\t\t\t                        \n        end\n    endcase\nend\n\nendmodule ", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/nbit_swizzling.sv /code/verif/nbit_swizzling_tb.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_perceptron_0018", "categories": ["cid012", "medium"], "input": {"prompt": "Create a SystemVerilog testbench module named `tb_perceptron_gates` that instantiates the `perceptron_gates` module as the Unit Under Test (UUT). The testbench must include a stimulus generator only that systematically drives various input conditions to achieve a minimum of 80% code and functional coverage for the `perceptron_gates` module. The `perceptron_gates` module implements a microcoded controller to train a perceptron model. The module takes signed 4-bit inputs (`x1` and `x2`), a 4-bit threshold, a 1-bit learning rate, and a 2-bit gate selector to determine the target output based on logical gate operations. It uses a microcode ROM to sequentially execute actions like weight initialization, output computation, target selection, weight/bias updates, and convergence checks. The module outputs the updated weights, bias, perceptron response (`y`), and a stop signal when training converges.\n\n## Design Specification:\nThe `perceptron_gates` module handles weight initialization, computation of perceptron outputs, target selection based on input indexes, and weight and bias updates. It features a microcoded approach for defining operational states, ensuring flexibility and reusability for perceptron-based learning tasks.\n\n## Interface\n## Inputs\n- `clk` (1-bit): Positive edge-triggered clock signal for calculating the microcode ROM address.\n- `rst_n` (1-bit): Negative edge-triggered reset signal. When ACTIVE LOW, `present_addr` is initialized to `4'd0`.\n- `x1`, `x2` (4-bit,[3:0], signed): Perceptron inputs. Can take only Bipolar values [`4'd1`,`-4'd1`]\n- `learning_rate` (1-bit): Learning rate for weight and bias updates.\n- `threshold` (4-bit,[3:0], signed): Threshold value for response calculation.\n- `gate_select` (2-bit,[1:0]): Specifies the gate type for determining target outputs.\n\n## Outputs\n- `percep_w1`, `percep_w2` (4-bit, [3:0], signed): Current weights of the perception. Can take Bipolar Values [`4'd1`,`-4'd1`]\n- `percep_bias` (4-bit,[3:0], signed): Current bias of the perception.Can take Bipolar Values [`4'd1`,`-4'd1`]\n- `present_addr` (4-bit,[3:0]): Current microcode ROM address.\n- `stop` (1-bit): Indicates the end of training.\n- `input_index` (3-bit,[2:0]): Tracks the current target value selected during an iteration. Can take values from 3'd0 to 3'd3.\n- `y_in` (4-bit,[3:0] signed): Computed perception output. Can take Bipolar values [`4'd1`,`-4'd1`]\n- `y` (4-bit, [3:0], signed): Perceptron output after applying the threshold.Can take three different values [`4'd1`,`4'd0`,`-4'd1`]\n- `prev_percep_wt_1`, `prev_percep_wt_2`, `prev_percep_bias` (4-bit, [3:0], signed): Weights and Bias during a previous iteration. Can take Bipolar values [`4'd1`, `-4'd1`]\n\n**Instantiation** :\nThe testbench instantiates the `perceptron_gates` module as uut and connects the signals between the module and the testbench. Each input and output from the uut is connected to its corresponding signal in the testbench.\n\n## **Input Generation and Validation**\n**Stimulus**: \n  The testbench continuously drives the clock (`clk`) and applies a reset (`rst_n`). Once out of reset, it goes through two main \u201ctraining sets,\u201d each one iterating over the four possible gate_select values (00, 01, 10, 11). For each `gate_select`, `target_select` is either 0 or 1 depending on whether it is in the \u201cfirst training set\u201d or \u201csecond training set.\u201d Within each gate configuration, multiple input patterns of `x1` and `x2` (both + 1 and - 1) are driven in sequence to stimulate the `perceptron_gates` module.\n\n\n## **1. Gate 00 (gate_select = 2\u2019b00) Training**:\nThe code treats `gate_select` = 2\u2019b00 as an AND-like gate.\n\n**1.Test Case 1 (First Training Set)**:\nControl:\n- `gate_select` = 2\u2019b00\n- `target_select` = 1\u2019b0\n- `rst_n` should be asserted (HIGH), meaning the circuit is active.\n\nInputs:\nThe sequence for '\ud835\udc651','\ud835\udc652' is given by:\n1.  (1, 1)\n2.  (1, \u20131)\n3.  (\u20131, 1)\n4.  (\u20131, \u20131)\n5.  Repeat with similar pairs to check how weights evolve (e.g., cycling through (1, 1), (1, \u20131), (\u20131, 1), (\u20131, \u20131) again with different delays).\n\n**2. Test Case 2 (Second Training Set)** :\nControl:\n- gate_select = 2\u2019b00\n- target_select = 1\u2019b1\n- A reset (rst_n=0) and re-assertion (rst_n=1) should happen right before starting this second training set.\n\nInputs:\n- After the reset, \u2018x1\u2018, and \u2018x2\u2018 should be driven as a series of + 1 and -1 pairs, but in a slightly different order to verify that the perceptron updates (`weights` and `bias`) can handle new input patterns under the new `target_select` value:\n  (\u20131, 1), (1, \u20131), (\u20131, \u20131), (1, 1), etc.\n\n## **2. Gate 01 (gate_select = 2\u2019b01) Training**\nThe code treats `gate_select` = 2\u2019b00 as an `OR-like gate`.\n\n**1. Test Case 1 (First Training Set)**:\nControl:\n- `gate_select` = 2\u2019b01\n- `target_select` = 1\u2019b0\n- `rst_n` should be asserted (HIGH), meaning the circuit is active.\nInputs:\nPatterns of (1, 1), (\u20131, 1), (1, \u20131), (\u20131, \u20131), each separated by delays (#90, #95, etc.).\n\n**2. Test Case 2 (Second Training Set)**:\nControl:\n- `gate_select` = 2\u2019b01\n- `target_select` = 1\u2019b1\nInputs:\nAgain, multiple +1 and -1 combinations should be applied in sequence after a reset, ensuring that the perceptron\u2019s weights adapt to the new target criterion.\n\n## **3. Gate 10 (`gate_select = 2\u2019b10`) Training**\nThe code treats `gate_select` = 2\u2019b00 as a `NAND-like Gate`.\n\n**1.Test Case 1 (First Training Set)**:\nControl:\n- gate_select = 2\u2019b10\n- target_select = 1\u2019b0\nInputs:\nThe testbench should apply (\u20131, \u20131), (\u20131, 1), (1, \u20131), (1, 1), etc., checking that the `perceptron_gates` module updates correctly.\n\n**2. Test Case 2 (Second Training Set)**:\nControl:\n- gate_select = 2\u2019b10\n- target_select = 1\u2019b1\nInputs:\nAfter another reset, the same style of + 1 and -1 inputs should be repeated, but with `target_select` changed to test the  NAND-like behavior.\n\n## **4.Gate 11 (`gate_select = 2\u2019b11`) Training**\nThe code treats `gate_select` = 2\u2019b00 as a `NOR-like Gate`.\n\n**1. Test Case 1 (First Training Set)**:\nControl:\n- `gate_select` = 2\u2019b11\n- `target_select` = 1\u2019b0\nInputs:\nSimilar to the other gates, the code should drive (\u20131, \u20131), (\u20131, 1), (1, \u20131), and (1, 1) in various sequences.\n\n**2. Test Case 2 (Second Training Set)**\nControl:\n- `gate_select` = 2\u2019b11\n- `target_select` = 1\u2019b1\nInputs:\nOnce reset, the same pattern of inputs should be repeated, but with a different `target_select` to test whether the perceptron properly re-learns the new target.\n\n## **Module Functionality**:\n## Submodule Overview\n### 1. Gate Target (`gate_target`)\nGenerates target outputs (`t1`, `t2`, `t3`, `t4`) based on the selected gate type.\n- Inputs: `gate_select` (2-bit,[1:0]).\n- Outputs : `o_1`, `o_2`, `o_3`, `o_4` (4-bit, [3:0],signed).\n- Gates implemented: AND, OR, NAND, and NOR gates.\n   - `gate_select`:\n         - `2'b00` : AND Gate    ; target values : (`4'd1`,`-4'd1`,`-4'd1`,`-4'd1`)\n         - `2'b01` : OR Gate      ; target values : (`4'd1`, `4'd1`, `4'd1`,`-4'd1`)\n         - `2'b10` : NAND Gate ; target values : (`4'd1`, `4'd1`, `4'd1`,`-4'd1`) \n         - `2'b11` : NOR Gate   ;  target values : (`4'd1`, `-4'd1`, `-4'd1`,`-4'd1`) \n         \n### 2. Microcode ROM\n- Defines a sequence of 6 micro-instructions, specifying actions such as weight initialization, output computation, target selection, and weight/bias updates.\n\n## Algorithm Steps for Perceptron Learning\n- Initialization: All weights, biases, and counters are set to zero.\n- Compute Output: Compute `y_in` = `bias` + (`x1` * `w1`) + (`x2` * `w2`) and compare with the threshold to determine `y`.\n- Select Target: Based on `gate_select` and` input_index`, pick the desired target value\n- Update Weights and Bias: Adjust weights and bias  based on the condition (`y` != `target`)\n  -  If the condition is satisfied\n        - `wt1_update` = `learning_rate` * `x1` * `target`\n        - `wt2_update` = `learning_rate` * `x2` * `target`\n        - `bias_update` = `learning_rate` * `target`\n   - If the condition is not satisfied\n        - `wt1_update` = 0\n        - `wt2_update` = 0\n        - `bias_update` = 0\n  - The value of current weights and bias is calculated as follows :\n       - `percep_wt1` = `percep_w1` + `wt1_update`\n       - `percep_wt2` = `percep_wt2` + `wt2_update`\n       - `percep_bias` = `percep_bias` + `bias_update`\n- Check if the `wt1_update`, `wt2_update` , and `bias_update` values are equal to their previous iteration values. If the condition is satisfied, stop the learning. Otherwise assign the `wt1_update`, `wt2_update`, and `bias_update` values to their previous iteration values and continue learning.\n                                                 \n## Control Flow\n### Microcoded Actions\n- Action 0: Initialize weights and bias to zero.\n- Action 1: Compute `y_in` (weighted sum + bias) and `y` (thresholded output).\n- Action 2: Select target value based on `input_index `and `gate type`.\n- Action 3: Update weights and bias if the perceptron output differs from the target.\n- Action 4: Compare current and previous weights and bias to determine convergence.\n- Action 5: Finalize updates and prepare for the next epoch.\n**An epoch is the time taken to train the perceptron for a given combination of four input values**\n\n## Key Features\n- Microcoded Sequencing: Flexible execution of training steps using `microcode ROM`.\n- Dynamic Target Selection: Allows gate-based logic outputs for versatile applications.\n- Sequential Updates: Tracks and applies weight changes across iterations.\n- Convergence Monitoring: Halts training when weights stabilize.", "context": {}}, "output": {"response": "", "context": {"verif/tb_perceptron_gates.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 679b3627e94df8904125beaa1248a22474a8fc42\nTARGET = 80\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/perceptron_gates.sv": "`timescale 1ns/1ps\nmodule perceptron_gates (\n    input  logic clk,// Posedge clock\n    input  logic rst_n,// Negedge reset\n    input  logic signed [3:0] x1, // First Input of the Perceptron\n    input  logic signed [3:0] x2, // Second Input of the Perceptron\n    input  logic learning_rate, // Learning rate (alpha)\n    input  logic signed [3:0] threshold, // Threshold value\n    input  logic [1:0] gate_select, // Gate selection during a specific training\n    input  logic       target_select,// Target Selection for a specific training\n    output logic signed [3:0] percep_w1, // Trained Weight 1 \n    output logic signed [3:0] percep_w2, // Trained Weight 2\n    output logic signed [3:0] percep_bias, // Trained Bias\n    output logic [3:0] present_addr, // Current address in microcode ROM\n    output logic stop, // Condition to indicate no learning has occurred(i.e. no weight change between iterations)\n    output logic [2:0] input_index,// Vector to track the selection of target for a given input combination for a gate\n    output logic signed [3:0] y_in, // Calculated Response\n    output logic signed [3:0] y, // Calculated Response obtained by comparing y_in against a threshold value\n    output logic signed [3:0] prev_percep_wt_1,//Value of Weight 1 during a previous iteration\n    output logic signed [3:0] prev_percep_wt_2,//Value of Weight 2 during a previous iteration\n    output logic signed [3:0] prev_percep_bias // Value of Bias during a previous iteration\n);\n\n    logic [15:0] microcode_rom [0:5];\n    logic [3:0]  next_addr;\n    logic [3:0]  train_action;\n    logic [3:0]  microcode_addr;\n    logic [15:0] microinstruction;\n    logic signed [3:0] t1, t2, t3, t4;\n   \n    gate_target dut (\n        .gate_select(gate_select),\n        .target_select(target_select),\n        .o_1(t1),\n        .o_2(t2),\n        .o_3(t3),\n        .o_4(t4)\n    );\n\n    logic signed [3:0] percep_wt_1_reg;\n    logic signed [3:0] percep_wt_2_reg;\n    logic signed [3:0] percep_bias_reg;\n\n    logic signed [3:0] target;\n    logic signed [3:0] prev_wt1_update;\n    logic signed [3:0] prev_wt2_update;\n    logic signed [3:0] prev_bias_update;\n   \n    logic signed [3:0] wt1_update;\n    logic signed [3:0] wt2_update;\n    logic signed [3:0] bias_update;\n    logic [7:0] epoch_counter;\n   \n    assign prev_percep_wt_1 = prev_wt1_update;\n    assign prev_percep_wt_2 = prev_wt2_update;\n    assign prev_percep_bias = prev_bias_update;\n\n    initial begin \n        microcode_rom[0] = 16'b0001_0000_0000_0000; \n        microcode_rom[1] = 16'b0010_0001_0000_0000; \n        microcode_rom[2] = 16'b0011_0010_0000_0000; \n        microcode_rom[3] = 16'b0100_0011_0000_0000; \n        microcode_rom[4] = 16'b0101_0100_0000_0000; \n        microcode_rom[5] = 16'b0000_0101_0000_0000; \n    end  \n   \n    always @(*) begin\n        microinstruction = microcode_rom[microcode_addr];\n        next_addr        = microinstruction[15:12];\n        train_action     = microinstruction[11:8];\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            present_addr    <= 4'd0;\n            microcode_addr  <= 4'd0;\n            percep_wt_1_reg <= 4'd0;\n            percep_wt_2_reg <= 4'd0;\n            percep_bias_reg <= 4'd0;\n            input_index     <= 2'd0;\n            stop            <= 1'b0;\n        end else begin\n            present_addr    <= next_addr;\n            microcode_addr  <= present_addr;\n        end\n    end\n\n    always @(*) begin\n        case (train_action)\n            4'd0: begin \n                percep_wt_1_reg  = 4'd0;\n                percep_wt_2_reg  = 4'd0;\n                percep_bias_reg  = 4'd0;\n                stop             = 1'b0;\n                next_addr        = next_addr + 4'd0;\n                y_in             = 4'd0;\n                y                = 4'd0;\n                prev_wt1_update  = 4'd0;\n                prev_wt2_update  = 4'd0;\n                prev_bias_update = 4'd0;\n                input_index      = 0;\n                target           = 0;\n                wt1_update       = 0;\n                wt2_update       = 0;\n                bias_update      = 0;\n                epoch_counter    = 0;\n            end\n            4'd1: begin \n                y_in = percep_bias_reg + (x1 * percep_wt_1_reg) + (x2 * percep_wt_2_reg); \n                if (y_in > threshold)\n                    y = 4'd1;\n                else if (y_in >= -threshold && y_in <= threshold)\n                    y = 4'd0;\n                else\n                    y = -4'd1;\n                \n                percep_wt_1_reg  = percep_wt_1_reg  + 4'd0;\n                percep_wt_2_reg  = percep_wt_2_reg  + 4'd0;\n                percep_bias_reg  = percep_bias_reg  + 4'd0;\n                prev_wt1_update  = prev_wt1_update  + 4'd0;\n                prev_wt2_update  = prev_wt2_update  + 4'd0;\n                prev_bias_update = prev_bias_update + 4'd0;\n                input_index      = input_index + 0;\n                next_addr        = next_addr + 4'd0;\n                stop             = stop + 1'b0;\n                target           = target + 4'd0;\n                wt1_update       = wt1_update + 4'd0 ;\n                wt2_update       = wt2_update + 4'd0 ;\n                bias_update      = bias_update + 4'd0 ;\n                epoch_counter    = epoch_counter + 0;\n            end\n            4'd2: begin\n                if (input_index == 0)\n                    target = t1;\n                else if (input_index == 1)\n                    target = t2;\n                else if (input_index == 2)\n                    target = t3;\n                else if (input_index == 3)\n                    target = t4;\n                else begin\n                    input_index = 0;\n                    target      = 0;\n                end\n                stop             = stop + 1'b0;\n                input_index      = input_index + 0;\n                next_addr        = next_addr + 4'd0;\n                target           = target + 4'd0;\n                prev_wt1_update  = prev_wt1_update  + 4'd0;\n                prev_wt2_update  = prev_wt2_update  + 4'd0;\n                prev_bias_update = prev_bias_update + 4'd0;\n                   \n                percep_wt_1_reg  = percep_wt_1_reg + 4'd0;\n                percep_wt_2_reg  = percep_wt_2_reg + 4'd0;\n                percep_bias_reg  = percep_bias_reg + 4'd0;\n                y_in             = y_in + 4'd0;\n                y                = y + 4'd0;\n                wt1_update       = wt1_update + 4'd0 ;\n                wt2_update       = wt2_update + 4'd0 ;\n                bias_update      = bias_update + 4'd0 ;\n                epoch_counter    = epoch_counter + 0;\n            end\n            4'd3: begin\n                if (y != target) begin\n                    wt1_update  = learning_rate * x1 * target ;\n                    wt2_update  = learning_rate * x2 * target ;\n                    bias_update = learning_rate * target ; \n                end else begin\n                    wt1_update  = 0 ;\n                    wt2_update  = 0 ;\n                    bias_update = 0 ;     \n                end    \n                percep_wt_1_reg = percep_wt_1_reg + wt1_update;\n                percep_wt_2_reg = percep_wt_2_reg + wt2_update;\n                percep_bias_reg = percep_bias_reg + bias_update;\n                prev_wt1_update  = prev_wt1_update  + 4'd0;\n                prev_wt2_update  = prev_wt2_update  + 4'd0;\n                prev_bias_update = prev_bias_update + 4'd0;\n                y_in             = y_in + 4'd0;\n                y                = y + 4'd0;\n                stop             = stop + 1'b0;\n                input_index      = input_index + 0;\n                next_addr        = next_addr + 4'd0;\n                target           = target + 4'd0;\n                epoch_counter    = epoch_counter + 0;\n            end\n            4'd4: begin\n                if ((prev_wt1_update == wt1_update) & (prev_wt2_update == wt2_update) & (input_index == 4'd3)) begin \n                    epoch_counter    = 0;\n                    stop            = 1'b1; \n                    input_index     = 0;\n                    next_addr       = 4'd0;\n                    percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                    percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                    percep_bias_reg = percep_bias_reg + 4'd0;\n                    prev_wt1_update = prev_wt1_update + 4'd0;\n                    prev_wt2_update = prev_wt2_update + 4'd0;\n                    prev_bias_update= prev_bias_update + 4'd0;\n                    y_in            = y_in + 4'd0;\n                    y               = y + 4'd0;\n                    target          = target + 4'd0;\n                    wt1_update      = wt1_update + 4'd0 ;\n                    wt2_update      = wt2_update + 4'd0 ;\n                    bias_update     = bias_update + 4'd0 ;\n                end else begin\n                    stop             = 1'b0; \n                    input_index      = input_index + 0;\n                    epoch_counter    = epoch_counter + 1;    \n                    next_addr        = 4'd5;    \n                    percep_wt_1_reg  = percep_wt_1_reg + 4'd0;\n                    percep_wt_2_reg  = percep_wt_2_reg + 4'd0;\n                    percep_bias_reg  = percep_bias_reg + 4'd0;\n                    prev_wt1_update  = prev_wt1_update + 4'd0;\n                    prev_wt2_update  = prev_wt2_update + 4'd0;\n                    prev_bias_update = prev_bias_update + 4'd0;\n                    y_in             = y_in + 4'd0;\n                    y                = y + 4'd0;\n                    target           = target + 4'd0;\n                    wt1_update       = wt1_update + 4'd0 ;\n                    wt2_update       = wt2_update + 4'd0 ;\n                    bias_update      = bias_update + 4'd0 ;\n                end\n            end\n            4'd5: begin\n                percep_wt_1_reg  = percep_wt_1_reg + 4'd0;\n                percep_wt_2_reg  = percep_wt_2_reg + 4'd0;\n                percep_bias_reg  = percep_bias_reg + 4'd0;\n                prev_wt1_update  = wt1_update;\n                prev_wt2_update  = wt2_update;\n                prev_bias_update = bias_update;\n                next_addr        = 4'd1;\n                input_index      = input_index + 1;\n                stop             = stop + 1'b0;\n                epoch_counter    = epoch_counter + 0;\n                y_in             = y_in + 4'd0;\n                y                = y + 4'd0;\n                target           = target + 4'd0;\n                wt1_update       = wt1_update + 4'd0;\n                wt2_update       = wt2_update + 4'd0;\n                bias_update      = bias_update + 4'd0;\n            end   \n            default: begin\n                next_addr         = next_addr + 4'd0;\n                percep_wt_1_reg   = percep_wt_1_reg + 4'd0;\n                percep_wt_2_reg   = percep_wt_2_reg + 4'd0;\n                percep_bias_reg   = percep_bias_reg + 4'd0;\n                prev_wt1_update   = prev_wt1_update + 4'd0;\n                prev_wt2_update   = prev_wt2_update + 4'd0;\n                prev_bias_update  = prev_bias_update + 4'd0;\n                stop              = stop + 1'b0;\n                y_in              = y_in + 4'd0;\n                y                 = y + 4'd0;\n                input_index       = input_index + 0;\n                target            = target + 4'd0;\n                wt1_update        = wt1_update + 4'd0 ;\n                wt2_update        = wt2_update + 4'd0 ;\n                bias_update       = bias_update + 4'd0 ;\n                epoch_counter     = epoch_counter + 0;\n            end\n        endcase\n    end\n\n    assign percep_w1   = percep_wt_1_reg;\n    assign percep_w2   = percep_wt_2_reg;\n    assign percep_bias = percep_bias_reg;\n\nendmodule\n\n`timescale 1ns/1ps\nmodule gate_target(\n    input  logic        [1:0] gate_select,\n    input  logic              target_select,\n    output logic signed [3:0] o_1,\n    output logic signed [3:0] o_2,\n    output logic signed [3:0] o_3,\n    output logic signed [3:0] o_4\n);\n    always @(*) begin\n        case (gate_select)\n            2'b00: begin \n                case (target_select)\n                    1'b0: begin\n                        o_1 =  4'b0001; \n                        o_2 = -4'b0001; \n                        o_3 = -4'b0001; \n                        o_4 = -4'b0001; \n                    end\n                    1'b1: begin\n                        o_1 = -4'b0001;\n                        o_2 = -4'b0001;\n                        o_3 = -4'b0001;\n                        o_4 =  4'b0001;\n                    end\n                    default: begin\n                        o_1 = 4'b0000; \n                        o_2 = 4'b0000; \n                        o_3 = 4'b0000; \n                        o_4 = 4'b0000; \n                    end\n                endcase\n            end\n            2'b01: begin \n                case (target_select)\n                    1'b0: begin  \n                        o_1 =  4'b0001; \n                        o_2 =  4'b0001; \n                        o_3 =  4'b0001; \n                        o_4 = -4'b0001; \n                    end\n                    1'b1: begin  \n                        o_1 =  4'b0001; \n                        o_2 =  4'b0001; \n                        o_3 = -4'b0001; \n                        o_4 =  4'b0001;\n                    end\n                    default: begin\n                        o_1 = 4'b0000; \n                        o_2 = 4'b0000; \n                        o_3 = 4'b0000; \n                        o_4 = 4'b0000; \n                    end\n                endcase\n            end                \n            2'b10: begin \n                case (target_select)\n                    1'b0: begin\n                        o_1 =  4'b0001; \n                        o_2 =  4'b0001; \n                        o_3 =  4'b0001; \n                        o_4 = -4'b0001; \n                    end\n                    1'b1: begin\n                        o_1 =  4'b0001;\n                        o_2 =  4'b0001;\n                        o_3 = -4'b0001;\n                        o_4 =  4'b0001;\n                    end\n                    default: begin\n                        o_1 = 4'b0000; \n                        o_2 = 4'b0000; \n                        o_3 = 4'b0000; \n                        o_4 = 4'b0000; \n                    end\n                endcase\n            end\n            2'b11: begin \n                case (target_select)\n                    1'b0: begin \n                        o_1 =  4'b0001; \n                        o_2 = -4'b0001; \n                        o_3 = -4'b0001; \n                        o_4 = -4'b0001; \n                    end\n                    1'b1: begin\n                        o_1 = -4'b0001; \n                        o_2 =  4'b0001; \n                        o_3 = -4'b0001; \n                        o_4 = -4'b0001;\n                    end\n                    default: begin\n                        o_1 = 4'b0000; \n                        o_2 = 4'b0000; \n                        o_3 = 4'b0000; \n                        o_4 = 4'b0000; \n                    end\n                endcase\n            end\n            default: begin\n                o_1 = 4'b0000; \n                o_2 = 4'b0000; \n                o_3 = 4'b0000; \n                o_4 = 4'b0000; \n            end\n        endcase\n    end\nendmodule\n\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n    for line in lines[2:]:\n        info = line.split()\n        while len(info) < 3:\n            info.append(\"0%\")\n        inst = re.sub(r'[\\W]', '', info[0])\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'uut' is missing in the coverage log.\")\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))\n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['uut']['Average']}, Target: {target}\"\n    \n"}}}
{"id": "cvdp_copilot_ping_pong_buffer_0004", "categories": ["cid012", "easy"], "input": {"prompt": "Complete the Ping-Pong Buffer Testbench in SystemVerilog. The testbench must instantiate the `ping_pong_buffer` RTL module and provide input stimulus for it, focusing exclusively on generating test vectors rather than building a full testbench.  \nThe `ping_pong_buffer` module simulates a dual-buffer system that allows concurrent read/write operations while alternating between two buffers.\n\n---\n\n## **Description**:\n### **Inputs** :\n\n- **Registers**:\n  - `clk` (1-bit): Active high Clock signal that toggles every **10 ns** (100 MHz) and is supplied to the **DUT**.\n  - `rst_n` (1-bit): **Active-low** asynchronous reset signal that resets the buffer and control logic of the **DUT**.\n  - `write_enable` (1-bit): Enables writing of data into the buffer.\n  - `read_enable` (1-bit): Enables reading of data from the buffer.\n  - `data_in` (8-bit, `[7:0]`): 8-bit input data that is written into the buffer.\n\n### **Outputs** :\n\n- **Registers**:\n  - `data_out` (8-bit, `[7:0]`): 8-bit output data read from the buffer.\n  - `buffer_full` (1-bit): Indicates whether the buffer is full.\n  - `buffer_empty` (1-bit): Indicates whether the buffer is empty.\n  - `buffer_select` (1-bit): Indicates the currently active buffer.\n\n---\n\n## **Instantiation**:\nThe testbench instantiates the `ping_pong_buffer` module as `dut` and connects the signals between the module and the testbench. Each input and output from the **DUT** is connected to its corresponding signal in the testbench.\n\n---\n\n## **Input Generation and Validation**:\n### **Clock Generation**:  \nThe Active high clock signal `clk` is generated using an `always` block that toggles every **10 ns**.\n\n### **Reset**:  \nThe Asynchronous reset signal `rst_n` is **asserted** at the beginning of the simulation to ensure the **DUT** initializes correctly. After a short period (**150 ns**), the reset is **de-asserted**.\n\n### **Stimulus**:  \nMultiple test cases are applied to simulate various buffer conditions and validate the correct behavior of the **ping-pong buffer**:\n\n- **Test Case 1: Basic Write and Read**\n  - **Write** values sequentially into the buffer.\n  - **Read** them back to verify correct data storage and retrieval.\n\n- **Test Case 2: Buffer Alternation**\n  - Write `DEPTH` elements to trigger **buffer switch**.\n  - Ensure correct alternation between ping and pong buffers.\n\n- **Test Case 3: Writing to Full Buffer**\n  - Fill the buffer.\n  - Attempt an extra write and verify **buffer_full** signal.\n\n- **Test Case 4: Reading from Empty Buffer**\n  - Ensure `buffer_empty` is asserted when reading beyond available data.\n\n- **Test Case 5: Reset Handling**\n  - Apply **reset** during active operations.\n  - Ensure buffer returns to **initial state**.\n\n- **Test Case 6: Edge Case - Minimum Data**\n  - Write and read a **single byte**.\n  - Ensure correct behavior in minimal operation scenarios.\n\n- **Test Case 7: Edge Case - Maximum Data**\n  - Write **DEPTH** elements.\n  - Read all data and verify **buffer alternation**.\n\n---\n\n## **Reset Handling**:\nAfter running the test cases, a **reset is asserted again** to verify that the buffer properly resets and returns to the **initial state**, with `buffer_empty` asserted.\n\n---\n\n```systemverilog\nmodule tb_ping_pong_buffer;\n\n    localparam DEPTH = 256;\n\n    logic clk;\n    logic rst_n;\n    logic write_enable;\n    logic read_enable;\n    logic [7:0] data_in;\n    logic [7:0] data_out;\n    logic buffer_full;\n    logic buffer_empty;\n    logic buffer_select;\n\n    // Instantiate the DUT\n    ping_pong_buffer dut (\n        .clk(clk),\n        .rst_n(rst_n),\n        .write_enable(write_enable),\n        .read_enable(read_enable),\n        .data_in(data_in),\n        .data_out(data_out),\n        .buffer_full(buffer_full),\n        .buffer_empty(buffer_empty),\n        .buffer_select(buffer_select)\n    );\n\n    // Clock generation\n    always #5 clk = ~clk;\n\n    initial begin\n        // Initialize signals\n        clk = 0;\n        rst_n = 0;\n        write_enable = 0;\n        read_enable = 0;\n        data_in = 0;\n\n        $display(\"Applying Reset...\");\n        #10 rst_n = 1;\n\n        $display(\"Testing Basic Write and Read Operations...\");\n        for (int i = 0; i < 10; i++) begin\n            @(posedge clk);\n            write_enable = 1;\n            data_in = i;\n            @(posedge clk);\n            write_enable = 0;\n            @(posedge clk);\n            read_enable = 1;\n            @(posedge clk);\n            read_enable = 0;\n            @(posedge clk);\n        end\n\n        // Insert code here to complete the Testbench\n\nendmodule\n```", "context": {}}, "output": {"response": "", "context": {"verif/tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 7383cb8040a89816460bf534da92ebf67c6a6e21\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/ping_pong_buffer.sv": "module ping_pong_buffer (\n    input logic clk,\n    input logic rst_n,\n    input logic write_enable,\n    input logic read_enable,\n    input logic [7:0] data_in,\n    output logic [7:0] data_out,\n    output logic buffer_full,\n    output logic buffer_empty,\n    output reg buffer_select\n);\n\n    localparam DEPTH = 256; \n    localparam ADDR_WIDTH = 8; \n\n    logic [ADDR_WIDTH-1:0] write_ptr, read_ptr; \n    logic [7:0] data_out0, data_out1; \n\n    // Memory 0\n    dual_port_memory memory0 (\n        .clk(clk),\n        .we(write_enable && !buffer_select && !buffer_full),\n        .write_addr(write_ptr),\n        .din(data_in),\n        .read_addr(read_ptr),\n        .dout(data_out0)\n    );\n\n    // Memory 1\n    dual_port_memory memory1 (\n        .clk(clk),\n        .we(write_enable && buffer_select && !buffer_full),\n        .write_addr(write_ptr),\n        .din(data_in),\n        .read_addr(read_ptr),\n        .dout(data_out1)\n    );\n\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            write_ptr <= 0;\n            read_ptr <= 0;\n            buffer_select <= 0;\n            buffer_full <= 0;\n            buffer_empty <= 1;\n        end else begin\n            // Write operation logic\n            if (write_enable && !buffer_full) begin\n                write_ptr <= (write_ptr + 1) % DEPTH;\n                if (write_ptr == DEPTH - 1) begin\n                    buffer_full <= 1; \n                end\n            end\n\n            if (read_enable && !buffer_empty) begin\n                read_ptr <= (read_ptr + 1) % DEPTH;\n                buffer_empty <= (read_ptr == write_ptr); \n                if (read_ptr == DEPTH - 1) begin\n                    buffer_select <= !buffer_select; \n                end\n            end\n\n            buffer_full <= (write_ptr + 1) % DEPTH == read_ptr;\n            buffer_empty <= read_ptr == write_ptr;\n        end\n    end\n\n    assign data_out = buffer_select ? data_out1 : data_out0;\nendmodule\nmodule dual_port_memory (\n    input logic clk,\n    input logic we,\n    input logic [7:0] write_addr,\n    input logic [7:0] din,\n    input logic [7:0] read_addr,\n    output logic [7:0] dout\n);\n\n    logic [7:0] mem [255:0];\n\n    always_ff @(posedge clk) begin\n        if (we) begin\n            mem[write_addr] <= din; \n        end\n        dout <= mem[read_addr]; \n    end\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        while len(info) < 3:\n            info.append(\"0%\")\n\n        inst = re.sub(r'[\\W]', '', info[0])\n\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n\n    # Check if the required key exists in the metrics\n    if \"dut\" not in metrics:\n        raise KeyError(\"Metrics data for 'dut' is missing in the coverage log.\")\n\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))  \n    assert metrics[\"dut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['dut']['Average']}, Target: {target}\"\n"}}}
{"id": "cvdp_copilot_prim_max_0005", "categories": ["cid012", "medium"], "input": {"prompt": "Create a **testbench** to apply **stimulus** to the `prim_max_find` module. This module implements a **binary tree-based maximum value finder** that determines the highest value from multiple input sources and provides the corresponding index. The testbench must apply a range of test cases to validate correct maximum value selection, index resolution, and handling of various input conditions.\n\n---\n\n### **Inputs:**\n\n- `clk_i`: **Clock signal with a 10ns period.**\n- `rst_ni`: **Active-low reset signal.**\n- `values_i`: **Flattened `NumSrc * Width`-bit wide input containing all values.**\n- `valid_i`: **`NumSrc`-bit wide signal indicating which inputs are valid.**\n\n### **Outputs:**\n\n- `max_value_o`: **`Width`-bit output representing the maximum value among valid inputs.**\n- `max_idx_o`: **`SrcWidth`-bit output indicating the index of the maximum value.**\n- `max_valid_o`: **Indicates whether any valid inputs were provided.**\n\n---\n\n### **Instantiation**\n\nThe testbench must instantiate a single instance of the `prim_max_find` module:\n\n- **Maximum Finder Module (`dut`)**: Instantiated with `NumSrc=8` and `Width=8` to test typical input conditions.\n\n---\n\n### **Testbench Requirements**\n\nThe testbench must apply a **wide range of test patterns** to ensure correct operation under all input conditions:\n\n1. **Clock Generation:**\n   - `clk_i` must toggle every **5 time units**, ensuring a **10 ns clock period**.\n\n2. **Reset Handling:**\n   - `rst_ni` must be **asserted for multiple cycles** before deasserting.\n   - The module must correctly initialize outputs when `rst_ni` is released.\n\n3. **Stimulus Generation Strategy:**\n   - The testbench **must not verify outputs** (only generate inputs).\n   - The following test sequences must be executed:\n     - **All Invalid Inputs**: Assign `valid_i = 0` for all inputs.\n     - **Single Valid Input**: One valid source with all others invalid.\n     - **Multiple Valid Inputs (Distinct Values)**: Various active sources with different values.\n     - **Multiple Valid Inputs (Duplicate Maximums)**: Multiple sources with the same highest value.\n     - **Maximum Value at First and Last Index**: Ensures correct tie-breaking at input boundaries.\n     - **Sequentially Increasing and Decreasing Values**: Tests proper priority handling.\n     - **Alternating Valid Input Patterns**: Exercises irregular valid signal transitions.\n     - **Extended Randomized Testing**: Generates **20 iterations** of randomized valid inputs and values.\n\n4. **Handling Continuous and Edge Cases:**\n   - The testbench must ensure **robust performance** under all valid/invalid input conditions.\n   - **Pipeline behavior** must be properly exercised through random valid signal transitions.\n   - **Valid input bursts and sporadic input toggling** must be tested.\n\n5. **Waveform Generation:**\n   - The testbench must generate a `.vcd` waveform file to allow waveform analysis.\n\n---\n\n### **Coverage and Compliance**\n\n- The testbench must ensure **high coverage** across all possible input combinations.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n\n---\n\n### **Test Plan Overview**\n\nThe testbench must ensure **96%+ input stimulus coverage** by applying:\n\n- **Valid data selection** across different test cases.\n- **Edge case handling** for minimum, maximum, and undefined values.\n- **Randomized input variations** to ensure robustness.\n- **Pipeline behavior verification** to confirm proper propagation of results.\n- **Handling of multiple maximum values** to ensure correct index selection.\n\nThis testbench will provide a **comprehensive input stimulus environment** for `prim_max_find`, ensuring correct operation under various test conditions.\n\n---\n\n### **Note:**\n- The testbench **must only generate stimulus** without verifying outputs.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n- **Ensure the maximum possible input coverage** without adding assertions or comparisons.\n\nCan you implement a **SystemVerilog testbench** with the above stimulus requirements?", "context": {}}, "output": {"response": "", "context": {"verif/prim_max_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 5-tb-stimulus-generation\nTARGET = 96", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/prim_max_find.sv": "module prim_max_find #(\n  parameter int NumSrc = 8,\n  parameter int Width = 8,\n  // Derived parameters\n  localparam int SrcWidth = $clog2(NumSrc),\n  localparam int NumLevels = $clog2(NumSrc),\n  localparam int NumNodes = 2**(NumLevels+1)-1\n) (\n  input                         clk_i,\n  input                         rst_ni,\n  input [Width*NumSrc-1:0]      values_i,    // Flattened Input values\n  input [NumSrc-1:0]            valid_i,     // Input valid bits\n  output wire [Width-1:0]       max_value_o, // Maximum value\n  output wire [SrcWidth-1:0]    max_idx_o,   // Index of the maximum value\n  output wire                   max_valid_o  // Whether any of the inputs is valid\n);\n\n  reg [NumNodes-1:0]                vld_tree [0:NumLevels];\n  reg [SrcWidth-1:0]                 idx_tree [0:NumLevels][NumNodes-1:0];\n  reg [Width-1:0]                    max_tree [0:NumLevels][NumNodes-1:0];\n\n  generate\n    for (genvar level = 0; level <= NumLevels; level++) begin : gen_tree\n      localparam int Base0 = (2**level)-1;\n      localparam int Base1 = (2**(level+1))-1;\n\n      for (genvar offset = 0; offset < 2**level; offset++) begin : gen_level\n        localparam int Pa = Base0 + offset;\n        localparam int C0 = Base1 + 2*offset;\n        localparam int C1 = Base1 + 2*offset + 1;\n\n        if (level == NumLevels) begin : gen_leafs\n          if (offset < NumSrc) begin : gen_assign\n            always @(posedge clk_i or negedge rst_ni) begin\n              if (!rst_ni) begin\n                vld_tree[level][Pa] <= 1'b0;\n                idx_tree[level][Pa] <= '0;\n                max_tree[level][Pa] <= '0;\n              end else begin\n                vld_tree[level][Pa] <= valid_i[offset];\n                idx_tree[level][Pa] <= offset;\n                max_tree[level][Pa] <= values_i[(offset+1)*Width-1 : offset*Width];\n              end\n            end\n          end else begin : gen_tie_off\n            always @(posedge clk_i or negedge rst_ni) begin\n              if (!rst_ni) begin\n                vld_tree[level][Pa] <= 1'b0;\n                idx_tree[level][Pa] <= '0;\n                max_tree[level][Pa] <= '0;\n              end\n            end\n          end\n        end\n\n        else begin : gen_nodes\n          reg sel; \n          always @(posedge clk_i or negedge rst_ni) begin\n            if (!rst_ni) begin\n              vld_tree[level][Pa] <= 1'b0;\n              idx_tree[level][Pa] <= '0;\n              max_tree[level][Pa] <= '0;\n            end else begin\n              sel = (~vld_tree[level+1][C0] & vld_tree[level+1][C1]) |\n                    (vld_tree[level+1][C0] & vld_tree[level+1][C1] & (max_tree[level+1][C1] > max_tree[level+1][C0]));\n\n              vld_tree[level][Pa] <= (sel) ? vld_tree[level+1][C1] : vld_tree[level+1][C0];\n              idx_tree[level][Pa] <= (sel) ? idx_tree[level+1][C1] : idx_tree[level+1][C0];\n              max_tree[level][Pa] <= (sel) ? max_tree[level+1][C1] : max_tree[level+1][C0];\n            end\n          end\n        end\n      end : gen_level\n    end : gen_tree\n  endgenerate\n\n  assign max_valid_o = vld_tree[0][0];\n  assign max_idx_o   = idx_tree[0][0];\n  assign max_value_o = max_tree[0][0];\n\nendmodule\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert subprocess.run(cmd, shell=True), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert subprocess.run(cmd, shell=True), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # Regular expression to capture the three columns.\n    # It expects:\n    #   - a name field (which may include tree markers)\n    #   - a percentage (or \"n/a\") for overall average\n    #   - a percentage (or \"n/a\") for overall covered\n    regex = re.compile(\n        r'^(?P<name>.*?)\\s+(?P<avg>(?:\\d+\\.\\d+%|n/a))\\s+(?P<cov>(?:\\d+\\.\\d+%|n/a))'\n    )\n\n    # Process each line (skip header/separator lines)\n    for line in lines[2:]:\n        match = regex.match(line)\n        if not match:\n            continue  # Skip lines that do not match our expected format\n\n        inst = match.group(\"name\").strip()\n        # Remove any tree markers (e.g. \"|--\") by splitting on '--'\n        if '--' in inst:\n            inst = inst.split('--')[-1].strip()\n\n        avg_str = match.group(\"avg\")\n        cov_str = match.group(\"cov\")\n\n        # Convert the percentages (remove the '%' if present)\n        avg_val = float(avg_str.rstrip('%')) if avg_str != \"n/a\" else 0.0\n        cov_val = float(cov_str.rstrip('%')) if cov_str != \"n/a\" else 0.0\n\n        metrics[inst] = {\n            \"Average\": avg_val,\n            \"Covered\": cov_val\n        }\n\n    # For DUT, check that the overall average meets the TARGET env variable.\n    required = float(os.getenv(\"TARGET\", \"0\"))\n    assert metrics[\"dut\"][\"Average\"] >= required, \"Didn't achieved the required coverage result.\"\n"}}}
{"id": "cvdp_copilot_restoring_division_0006", "categories": ["cid012", "easy"], "input": {"prompt": "Write a testbench to generate stimulus only for the `restoring_division` module, which performs restoring division on two unsigned positive integer inputs. The module generates the output `quotient`, `remainder`, and `valid` once the computation is completed for the given `dividend` and `divisor` when the `start` signal is asserted.\n\n## **Design Details**\n\n### **Parameterization**\n- **WIDTH**: Specifies the bit-width of the dividend and divisor.\n  - **Default**: 6 bits\n\n### **Functionality**\nThe **restoring_division** module implements division using a shift-subtract approach:\n- The division process must finish within WIDTH clock cycles if WIDTH is a power of 2 (2^n) to ensure all data is processed; otherwise (if WIDTH is not a power of 2), it will take WIDTH+1 clock cycles.\n- The FSM governs the state transitions and ensures proper computation.\n- The division process begins when `start` is asserted and completes when `valid` is high.\n\n## **Signal Behavior**\n\n### Inputs:\n- **`clk`**: 1-bit clock signal, toggles every 5 time units.\n- **`rst`**: Active-low reset signal to initialize the module.\n- **`start`**: Start signal to begin the division process.\n- **`dividend`**: `WIDTH`-bit input representing the dividend.\n- **`divisor`**: `WIDTH`-bit input representing the divisor.\n\n### Outputs:\n- **`quotient`**: `WIDTH`-bit result of the division operation.\n- **`remainder`**: `WIDTH`-bit remainder of the division operation.\n- **`valid`**: 1-bit signal indicating completion of division.\n\n---  \n\n## **Testbench Requirements**\n\n### **Instantiation**\n- **Module Instance**: The **restoring_division** module should be instantiated as `uut`, with all inputs and outputs properly connected.\n\n### **Input Generation and Validation**\n1. **Clock Generation**:  \n   - The testbench must generate a clock signal with a 10 ns period.\n   - The clock should toggle every **5 time units**.\n\n2. **Reset Behavior**:  \n   - The reset signal should be asserted low initially.\n   - After 10 ns, reset should be de-asserted (set high) to allow normal operation.\n\n3. **Division Test Cases**:  \n   - A **task** named `run_test` should be used to apply test cases dynamically.\n   - The testbench should generate **random** values for `dividend` and `divisor`.\n   - The **divisor should never be zero** (handled by ensuring divisor \u2265 1).\n   - The division process should be started by asserting `start` high for one cycle.\n   - The testbench must **wait for `valid`** to be asserted before capturing the results.\n   - The computed **quotient and remainder** should be displayed for debugging.\n\n---", "context": {}}, "output": {"response": "", "context": {"verif/restore_division_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = e6ec70444b3c24b08834396a6d33ac8f5d9ed945\nTARGET = 95", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/restore_division.sv": "`timescale 1ns / 1ps\n\nmodule restoring_division #(parameter WIDTH = 6) (\n    input clk,                          // Clock signal\n    input rst,                          // Reset signal (active low)\n    input start,                        // Start signal to begin the division process\n    input [WIDTH-1:0] dividend,         // Dividend input\n    input [WIDTH-1:0] divisor,          // Divisor input\n    output [WIDTH-1:0] quotient,        // Quotient output\n    output [WIDTH-1:0] remainder,       // Remainder output\n    output reg valid                    // Valid output indicating completion of division\n);\n    //registers width declaration\n    localparam COUNT_WIDTH = $clog2(WIDTH);\n    localparam ACCUMULATOR_WIDTH = 2*WIDTH;\n     // FSM state encoding\n    localparam IDLE  = 1'd0;                                    // Idle state\n    localparam START = 1'd1;                                    // Start state (active division)\n    reg [ACCUMULATOR_WIDTH-1:0] accumulator;                    // Accumulator to store intermediate results\n    reg [ACCUMULATOR_WIDTH-1:0] next_accumulator;               // Next state of the accumulator\n    reg [ACCUMULATOR_WIDTH-1:0] accumulator_temp;               // Temporary register for accumulator shifting\n    reg [ACCUMULATOR_WIDTH-1:0] accumulator_temp1;              // Temporary register for subtraction and concatenation\n    reg next_state, present_state;                              // FSM states for control logic\n    reg [COUNT_WIDTH-1:0] count;                                // Counter for tracking the number of shifts\n    reg [COUNT_WIDTH-1:0] next_count;                           // Next state of the counter\n    reg next_valid;                                             // Next state of the valid signal\n  \n    // Combinational logic block to determine the next state and outputs\n    always @ (*) begin                  \n        case(present_state)\n        IDLE: begin\n            next_count = {COUNT_WIDTH{1'd0}};                    // Reset the counter to 0\n            next_valid = 1'd0;                                   // Clear the valid signal\n\n            if (start) begin\n                next_state = START;                               // Transition to START state\n                next_accumulator = { {WIDTH{1'd0}}, dividend };   // Initialize the accumulator with the dividend\n            end else begin\n                next_state = present_state;                       // Remain in IDLE state\n                next_accumulator = {ACCUMULATOR_WIDTH{1'd0}};     // Keep the accumulator cleared\n            end\n        end\n        START: begin\n            if (next_count == WIDTH) begin             // Check if the division process is complete\n                next_count = {COUNT_WIDTH{1'd0}};      // Reset the counter\n                next_state =  present_state ;          // Transition back to IDLE or present_state state\n                next_valid = 1'd1;                     // Set the valid signal to indicate completion\n            end else begin\n                next_count = count + 1'd1;            // Increment the counter\n                // Perform shift and subtraction operation\n                accumulator_temp = accumulator << 1; // Left shift the accumulator\n                accumulator_temp1 = {accumulator_temp[ACCUMULATOR_WIDTH-1:WIDTH] - divisor, accumulator_temp[WIDTH-1:0]}; // Subtract divisor and concatenate\n                // Update the accumulator based on the subtraction result\n                next_accumulator = accumulator_temp1[ACCUMULATOR_WIDTH-1] ? \n                                   {accumulator_temp[ACCUMULATOR_WIDTH-1:WIDTH], accumulator_temp[WIDTH-1:1], 1'd0} :\n                                   {accumulator_temp1[ACCUMULATOR_WIDTH-1:WIDTH], accumulator_temp[WIDTH-1:1], 1'd1}; \n                next_valid = (&count) ? 1'd1 : 1'd0;         // Set valid signal if all bits have been processed\n                next_state = (valid) ? IDLE : present_state; // Transition to IDLE if done, otherwise stay in START\n            end\n        end\n        endcase\n    end\n    // Sequential logic block to update the current state and outputs on the clock edge or reset\n    always @ (posedge clk or negedge rst) begin\n        if (!rst) begin\n            accumulator   <= {ACCUMULATOR_WIDTH{1'd0}};        // Clear the accumulator on reset\n            valid         <= 1'd0;                             // Clear the valid signal on reset\n            present_state <= IDLE;                             // Set the FSM to IDLE state on reset\n            count         <= {COUNT_WIDTH{1'd0}};              // Reset the counter on reset\n        end else begin\n            accumulator   <= next_accumulator;                 // Update the accumulator\n            valid         <= next_valid;                       // Update the valid signal\n            present_state <= next_state;                       // Update the FSM state\n            count         <= next_count;                       // Update the counter\n        end\n    end\n    // Assign outputs for quotient and remainder based on the accumulator value\n    assign remainder = accumulator[ACCUMULATOR_WIDTH-1:WIDTH]; // Upper half of the accumulator is the remainder\n    assign quotient  = accumulator[WIDTH-1:0];                 // Lower half of the accumulator is the quotient\nendmodule"}}}
{"id": "cvdp_copilot_restoring_division_0034", "categories": ["cid012", "easy"], "input": {"prompt": "Write a testbench to generate stimulus only for the `restoring_division` module, which performs restoring division on two unsigned positive integer inputs. The module produces the `quotient`, `remainder`, and asserts the `valid` signal upon computation completion. Additionally, it sets the `divisor_valid_result` flag to indicate whether the divisor was valid (nonzero) when the `start` signal is asserted with the `dividend` and `divisor` inputs.\n\n---\n\n## **Design Details**\n### **Parameterization**\n- **WIDTH**: Specifies the bit-width of the dividend and divisor.\n  - **Default**: 6\n\n### **Functionality**\nThe **restoring_division** module performs unsigned integer division using a sequential **restoring division algorithm**. The quotient and remainder are computed iteratively over multiple clock cycles.\n\n#### **Division Process and Output Behavior**\n- The computation is **iterative** and progresses bit-by-bit over **WIDTH** clock cycles.\n- The division process must finish within WIDTH clock cycles if WIDTH is a power of 2 (2^n) to ensuring all data is processed; otherwise (if WIDTH is not a power of 2), it will take WIDTH+1 clock cycles.\n- Once the computation is complete, the **valid** signal is asserted high to indicate that the **quotient** and **remainder** outputs are stable and valid.\n- The **divisor_valid_result** signal ensures that valid results are only produced when the divisor is nonzero.\n\n### **Inputs:**  \n- `clk` (1-bit): Clock signal, toggles every 5 time units (**100MHz operation**).  \n- `rst` (1-bit): **Active-low** reset signal to initialize the module.  \n- `start` (1-bit): Start signal to begin the division process.  \n- `dividend` (6-bit): Dividend input value.  \n- `divisor` (6-bit): Divisor input value.  \n\n### **Outputs:**  \n- `quotient` (6-bit): Computed quotient output.  \n- `remainder` (6-bit): Computed remainder output.  \n- `valid` (1-bit): Signal indicating division completion.  \n- `divisor_valid_result` (1-bit): Signal indicating if divisor was valid (not zero).  \n\n---\n\n## **Testbench Requirements**\n### **Instantiation**\n- The **restoring_division** module should be instantiated as **uut** (Unit Under Test), with all input and output signals connected.\n\n### **Input Generation and Validation**\n- **Randomized Inputs**: The testbench must generate multiple test cases, covering:\n  - **Random dividend & random nonzero divisor**\n  - **Dividend = 0** (Edge case)\n  - **Divisor = 0** (Edge case, division by zero)\n  - **Dividend < Divisor** (Ensuring the quotient is 0 and remainder = dividend)\n- **Stabilization Period**: After applying inputs, the testbench must wait until the **valid** signal is asserted before checking outputs.\n\n### **Control Signal Behavior**\n- The **start** signal should be asserted high for **one clock cycle** before being de-asserted.\n- The testbench must ensure that **valid** is asserted only after the computation is complete.\n\n\n---\n\nThis testbench will verify the **correctness, stability, and edge-case behavior** of the **restoring_division** module. It ensures that the division process adheres to the restoring division algorithm and produces accurate results across all test scenarios.", "context": {}}, "output": {"response": "", "context": {"verif/restore_division_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 62c7703bfd6cf99ace3d73bd88ca23fedbb5d3c9\nTARGET = 95", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/restore_division.sv": "`timescale 1ns / 1ps\nmodule restoring_division #(parameter WIDTH = 6) (\n    input        clk,                       // Clock signal\n    input        rst,                       // Reset signal (active low)\n    input        start,                     // Start signal to begin the division process\n    input  [WIDTH-1:0] dividend,            // Dividend input\n    input  [WIDTH-1:0] divisor,             // Divisor input\n    output [WIDTH-1:0] quotient,            // Quotient output\n    output [WIDTH-1:0] remainder,           // Remainder output\n    output reg        valid,                // Valid output indicating completion of division\n    output reg        divisor_valid_result  // Divisor divisor_valid_result signal\n);\n    // Registers width declaration\n    localparam COUNT_WIDTH = $clog2(WIDTH);\n    localparam ACCUMULATOR_WIDTH = 2*WIDTH;\n    // FSM state encoding\n    localparam IDLE  = 1'b0;                                    // Idle state\n    localparam START = 1'b1;                                    // Start state (active division)\n    reg [ACCUMULATOR_WIDTH-1:0] accumulator;                    // Accumulator to store intermediate results\n    reg [ACCUMULATOR_WIDTH-1:0] next_accumulator;               // Next state of the accumulator\n    reg [ACCUMULATOR_WIDTH-1:0] accumulator_temp;               // Temporary register for accumulator shifting\n    reg [ACCUMULATOR_WIDTH-1:0] accumulator_temp1;              // Temporary register for subtraction and concatenation\n    reg                        next_state, present_state;       // FSM states for control logic\n    reg [COUNT_WIDTH-1:0]      count;                           // Counter for tracking the number of shifts\n    reg [COUNT_WIDTH-1:0]      next_count;                      // Next state of the counter\n    reg                        next_valid;                      // Next state of the valid signal\n    reg                        next_divisor_valid_result;       // Divisor next_divisor_valid_result signal\n   \n    // Combinational logic block to determine the next state and outputs\n    always @ (*) begin                  \n        case(present_state)\n            IDLE: begin\n                next_count = {COUNT_WIDTH{1'b0}};                               // Reset the counter to 0\n                next_valid = 1'b0;                                              // Clear the valid signal\n                next_divisor_valid_result  = 1'b1;                              // Clear the divisor_valid_result     \n                if (start) begin\n                    // Special cases\n                    if (divisor == 0) begin                                     // Division by zero case\n                        next_state = IDLE;\n                        next_valid = 1'b1;\n                        next_accumulator = {dividend, {WIDTH{1'b0}}};\n                        next_divisor_valid_result = 1'b0;\n                    end \n                    else if (dividend == 0) begin                               // Dividend is zero case\n                        next_state = IDLE;\n                        next_valid = 1'b1;\n                        next_accumulator = {ACCUMULATOR_WIDTH{1'b0}};           // Both quotient and remainder are zero\n                        next_divisor_valid_result = 1'b1;\n                    end \n                    else if (dividend < divisor) begin                          // Dividend is less than divisor case\n                        next_state = IDLE;\n                        next_valid = 1'b1;\n                        next_accumulator = {dividend, {WIDTH{1'b0}}};           // Quotient is zero, remainder is the dividend\n                        next_divisor_valid_result = 1'b1;\n                    end \n                    else begin                                                  // Valid division process\n                        next_state = START;\n                        next_accumulator = { {WIDTH{1'b0}}, dividend };         // Initialize the accumulator with the dividend\n                    end\n                end \n                else begin\n                    next_state = present_state;                                 // Remain in IDLE state\n                    next_accumulator = {ACCUMULATOR_WIDTH{1'b0}};               // Keep the accumulator cleared\n                end\n            end\n            START: begin\n                if (next_count == WIDTH) begin                                  // Check if the division process is complete\n                    next_count = {COUNT_WIDTH{1'b0}};                           // Reset the counter\n                    next_state = present_state;                                 // Transition back to IDLE or present_state state\n                    next_valid = 1'b1;                                          // Set the valid signal to indicate completion\n                    next_divisor_valid_result = 1'b1;                           // Set the divisor_valid_result signal to indicate completion\n                end else begin\n                    next_count = count + 1'b1;                                  // Increment the counter\n                    accumulator_temp = accumulator << 1;                        // Left shift the accumulator\n                    accumulator_temp1 = {accumulator_temp[ACCUMULATOR_WIDTH-1:WIDTH] - divisor, accumulator_temp[WIDTH-1:0]}; // Subtract divisor and concatenate\n                    // Update the accumulator based on the subtraction result\n                    next_accumulator = accumulator_temp1[ACCUMULATOR_WIDTH-1] ? \n                                       {accumulator_temp[ACCUMULATOR_WIDTH-1:WIDTH], accumulator_temp[WIDTH-1:1], 1'b0} :\n                                       {accumulator_temp1[ACCUMULATOR_WIDTH-1:WIDTH], accumulator_temp[WIDTH-1:1], 1'b1}; \n                    next_valid = (&count) ? 1'b1 : 1'b0;                        // Set valid signal if all bits have been processed\n                    next_state = (valid) ? IDLE : present_state;                // Transition to IDLE if done, otherwise stay in START\n                end\n            end\n        endcase\n    end\n    \n    // Sequential logic block to update the current state and outputs on the clock edge or reset\n    always @ (posedge clk or negedge rst) begin\n        if (!rst) begin\n            accumulator            <= {ACCUMULATOR_WIDTH{1'b0}};                // Clear the accumulator on reset\n            valid                  <= 1'b0;                                     // Clear the valid signal on reset\n            present_state          <= IDLE;                                     // Set the FSM to IDLE state on reset\n            count                  <= {COUNT_WIDTH{1'b0}};                      // Reset the counter on reset \n            divisor_valid_result   <= 1'b0;                                     // Clear the divisor_valid_result signal on reset\n        end else begin\n            accumulator            <= next_accumulator;                         // Update the accumulator\n            valid                  <= next_valid;                               // Update the valid signal\n            present_state          <= next_state;                               // Update the FSM state\n            count                  <= next_count;                               // Update the counter\n            divisor_valid_result   <= next_divisor_valid_result;                // Update the divisor_valid_result signal\n        end\n    end\n    \n    // Assign outputs for quotient and remainder based on the accumulator value\n    assign remainder = accumulator[ACCUMULATOR_WIDTH-1:WIDTH];                  // Upper half of the accumulator is the remainder\n    assign quotient  = accumulator[WIDTH-1:0];                                  // Lower half of the accumulator is the quotient\nendmodule"}}}
{"id": "cvdp_copilot_ring_token_0004", "categories": ["cid012", "easy"], "input": {"prompt": "Create a SystemVerilog testbench module named **`tb_token_ring_fsm`** that instantiates the `token_ring_fsm` module as the Unit Under Test (UUT). The testbench must include a **stimulus generator** that systematically drives various input conditions to achieve **100% code and functional coverage** for the `token_ring_fsm`. The `token_ring_fsm` implements a **Finite State Machine (FSM)-based token-passing mechanism** in a four-node ring network, ensuring controlled data transmission between nodes. The stimulus should cover **all state transitions, token passing, data transmission scenarios, and asynchronous reset conditions** while logging outputs for debugging and verification.  \n\n---\n\n## **Description**  \n\n### **Inputs**  \n\n- **Clock Signal**:  \n  - `clk`: Positive edge-triggered clock signal driving the FSM.  \n\n- **Reset Signal**:  \n  - `rst`: Asynchronous active-high reset signal that initializes the FSM.  \n\n- **Data and Control Inputs**:  \n  - `data_in [3:0]`: A 4-bit input representing binary data for transmission by the current node.  \n  - `has_data_to_send`: A 1-bit signal indicating whether the current node has data to send.  \n\n### **Outputs**  \n\n- **Data and Token Outputs**:  \n  - `data_out [3:0]`: A 4-bit output representing the data transmitted by the current node.  \n  - `token_received [3:0]`: A 4-bit one-hot encoded signal indicating which node currently holds the token.  \n  - `token [3:0]`: A 4-bit one-hot encoded signal representing the token being passed to the next node.  \n\n---\n\n## **Input Generation**  \n\n### **State Transitions and Token Passing**  \n\n- Drive the FSM through all four states:  \n  - `NODE0 to NODE1 to NODE2 to NODE3 to NODE0` in a cyclic manner.  \n  - Ensure that `token_received` correctly identifies the node holding the token.  \n\n- Simulate token passing by shifting the `token` signal across nodes and verifying correct cycling.  \n\n### **Data Transmission Stimulus**  \n\n- Generate various patterns for `data_in` and toggle `has_data_to_send` to simulate:  \n  - Nodes transmitting data when they hold the token.  \n  - Nodes idling when `has_data_to_send` is LOW.  \n  - Different data values being sent across nodes.  \n\n### **Edge Case Testing**  \n\n- **Reset Behavior**:  \n  - Apply `rst` at different states to ensure FSM returns to `NODE0`.  \n  - Verify that `token_received` is set to `4'b0001` and `data_out`, `token` are cleared.  \n\n- **Token Handling**:  \n  - Simulate idle conditions where no node is ready to send data.  \n  - Inject forced token values using `force` and `release` commands to verify FSM recovery.  \n\n- **Overlapping Data Transmission**:  \n  - Test scenarios where multiple nodes attempt to send data consecutively.  \n  - Ensure only the node holding the token transmits data.  \n  \n---\n\n## **Instantiation**  \n\n- The instance of the RTL should be named **`uut`**.  \n\n---\n\n## **Module Interface**  \n\n### **Inputs**  \n\n- `clk`: Clock signal.  \n- `rst`: Asynchronous active-high reset signal.  \n- `data_in [3:0]`: Data input for transmission.  \n- `has_data_to_send`: Indicates whether the node has data to send.  \n\n### **Outputs**  \n\n- `data_out [3:0]`: Transmitted data output.  \n- `token_received [3:0]`: Indicates the node currently holding the token.  \n- `token [3:0]`: Indicates the token being passed to the next node.  \n\n---\n\n## **Module Functionality**  \n\n1. **Token Passing Mechanism**:  \n   - The FSM cycles through the four nodes, passing the token sequentially.  \n   - The node with the token is allowed to transmit data if `has_data_to_send` is HIGH.  \n\n2. **Data Transmission**:  \n   - When a node holds the token and `has_data_to_send` is HIGH, `data_out` reflects `data_in`.  \n   - If no node is ready to send, `data_out` remains `4'b0000`.  \n\n3. **Reset Behavior**:  \n   - When `rst` is asserted HIGH, the FSM resets to `NODE0`, `token_received` is set to `4'b0001`, and other outputs are cleared.  \n\n4. **Edge Cases**:  \n   - Idle conditions where no node transmits data.  \n   - Forced invalid states and token values to test FSM recovery.  \n   - Multiple data transmissions in consecutive cycles.  \n\n---\n", "context": {}}, "output": {"response": "", "context": {"verif/tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 464ad3e0d0a1fd65faee6270396c378c7382e372\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/token_ring_fsm.sv": "module token_ring_fsm (\n    input logic clk,              // Clock input\n    input logic rst,              // Reset input\n    input logic [3:0] data_in,    // Data input from node\n    output reg [3:0] data_out,    // Data output to node\n    input logic has_data_to_send, // Signal indicating data is ready to send\n    output reg [3:0] token_received, // Token received status for nodes\n    output reg [3:0] token        // Token status being passed between nodes\n);\n\ntypedef enum logic [1:0] {\n    NODE0 = 2'b00,\n    NODE1 = 2'b01,\n    NODE2 = 2'b10,\n    NODE3 = 2'b11\n} state_t;\n\nstate_t current_state, next_state;\n\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        current_state <= NODE0;\n        token <= 4'b0001;\n        token_received <= 4'b0001;\n        data_out <= 4'b0000;\n    end else begin\n        case (current_state)\n            NODE0: begin\n                token_received <= 4'b0001;\n                token <= 4'b0010;\n                next_state = NODE1;\n            end\n            NODE1: begin\n                token_received <= 4'b0010;\n                token <= 4'b0100;\n                next_state = NODE2;\n            end\n            NODE2: begin\n                token_received <= 4'b0100;\n                token <= 4'b1000;\n                next_state = NODE3;\n            end\n            NODE3: begin\n                token_received <= 4'b1000;\n                token <= 4'b0001;\n                next_state = NODE0;\n            end\n            default: begin\n                next_state = NODE0;\n            end\n        endcase\n\n        if (token_received[current_state] && has_data_to_send) begin\n            data_out <= data_in;\n        end else begin\n            data_out <= 4'b0000;\n        end\n\n        current_state <= next_state;\n    end\nend\n\nendmodule"}}}
{"id": "cvdp_copilot_secure_read_write_bus_0005", "categories": ["cid012", "medium"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `secure_read_write_bus_interface`. It support both read and write operations, with authorization based on a comparison between the input key and an internal parameterized key. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameters, Inputs - Outputs and Functional behavior**\n\n### Functional Requirements\n1. **Read and Write Operations**:\n   - The bus performs read or write actions based on an enable signal.\n   - Access is authorized only if the provided key matches an internal key, with errors flagged otherwise.\n\n### Inputs\n- `i_addr` (`p_addr_width bit`): Specifies the target address for read or write operations.\n- `i_data_in` (`p_data_width` bit): Data to be written during a write operation.\n- `i_key_in` (`8-bit`): Key provided by the initiator for operation authorization.\n- `i_read_write_enable` (`1-bit`): Specifies the requested operation; `1` for read, `0` for write.\n- `i_capture_pulse` (`1-bit`): Qualifies input capture for `i_addr`, `i_data_in`, `i_key_in`, and `i_read_write_enable`.\n- `i_reset_bar` (`1-bit`): Asynchronous, active-low reset to initialize internal states and registers.\n\n### Outputs\n- `o_data_out` (`p_data_width` bit): Data output during a read operation, valid only if the input key matches the internal key.\n- `o_error` (`1-bit`): Asserted if the input key is incorrect and dessert if input key is correct.\n\n### Behavioral Requirements\n\n#### Write Operation\n- If `i_read_write_enable` is **0**, the bus interprets the operation as a write request.\n- At the rising edge of `i_capture_pulse`:\n  - If `i_key_in` matches the internal 8-bit configurable key, `i_data_in` is written to the address specified by `i_addr`.\n  - If `i_key_in` does not match the internal key:\n    - `o_error` is set to **1**.\n    - `o_data_out` is set to **0** (default).\n\n#### Read Operation\n- If `i_read_write_enable` is **1**, the bus interprets the operation as a read request.\n- At the rising edge of `i_capture_pulse`:\n  - If `i_key_in` matches the internal key, data from address `i_addr` is output on `o_data_out`, and `o_error` is **0**.\n  - If `i_key_in` does not match:\n    - `o_error` is set to **1**.\n    - `o_data_out` remains **0**.\n\n### Parameterization Requirements\n- `p_configurable_key`: Internal 8-bit key, default value `8'hAA`.\n- `p_data_width`: Configurable data width, default is **8 bits**.\n- `p_addr_width`: Configurable address width, default is **8 bits**.\n\n### Additional Requirements\n1. **Edge Case Handling**:\n   - `i_reset_bar` reset signal should clear all internal registers and outputs when asserted low.\n   - Ensure that outputs default to `0` upon reset or when unauthorized access occurs.\n2. **Clocking and Timing**:\n   - Operations are gated by the positive edge of `i_capture_pulse` for both read and write actions.\n   - Timing for signal latching and error assertions should align with rising edges of `i_capture_pulse`.\n\n### Assumptions\n  - Assume all the inputs are synchronous to the `i_capture_pulse`\n\n## Test Bench Requirements\n\n### Stimulus Generation\n\n## **1. Reset Behavior**\n- The system should be tested under reset conditions.  \n- Reset is released.\n\n---\n\n## **2. Write Operations**\n### **2.1 Writing Data Under Normal Conditions**\n- A write operation should be performed when the interface is enabled for writing.  \n\n### **2.2 Unauthorized Write Attempt**\n- An attempt should be made to write data while using an incorrect authentication key.  \n\n### **2.3 Writing at the Lower Address Boundary**\n- A write operation should be performed at the smallest possible address in the addressable range.  \n\n### **2.4 Writing at the Upper Address Boundary**\n- A write operation should be performed at the largest possible address in the addressable range.\n\n### **2.5 Randomized Write Operations**\n- Multiple write operations should be performed at various random addresses with different data values.  \n\n---\n\n## **3. Read Operations**\n### **3.1 Reading Data Under Normal Conditions**\n- A read operation is requested, and the correct authentication key is provided.\n\n### **3.2 Unauthorized Read Attempt**\n- A read request should be made using an incorrect authentication key.\n\n### **3.3 Reading from an Uninitialized Memory Location**\n- An attempt should be made to read from an address where no data has been written, ensuring predictable behavior.\n\n### **3.4 Reading at the Lower Address Boundary**\n- A read operation should be performed at the smallest possible address.\n\n### **3.5 Reading at the Upper Address Boundary**\n- A read operation should be performed at the largest possible address in the addressable range to ensure boundary handling.\n\n---\n\n## **4. Error Handling & Corner Cases**\n### **4.1 Switching Between Correct and Incorrect Authentication Keys**\n- The system should be tested by performing multiple read and write operations while alternating between valid and invalid authentication keys.\n\n### **4.2 Writing Without Initiating the Operation**\n- An attempt should be made to write data without properly triggering the operation.\n\n### **4.3 Reading Without Initiating the Operation**\n- A read request should be simulated without properly triggering the operation.\n\n### **4.4 Unauthorized Read Followed by an Authorized Write**\n- An unauthorized read should be performed first, followed by an attempt to write data using the correct authentication key.\n\n### **4.5 Unauthorized Write Followed by an Authorized Read**\n- An unauthorized write should be attempted first, followed by an authorized read to ensure no incorrect data modifications occur.\n\n### **4.6 Rapid Switching Between Read and Write**\n- The interface should be tested with rapid consecutive read and write operations to check for any inconsistencies or race conditions.\n\n---\n\n## **5. Reset and System Initialization**\n### **5.1 System Behavior During Reset**\n- The system should be reset in the middle of operations.\n\n### **5.2 Operations After Reset**\n- Once reset is deactivated, read and write operations resumes.\n\n---\n\n## **6. Stress Testing**\n### **6.1 Consecutive Writes**\n- A series of consecutive write operations should be performed to different addresses.\n\n### **6.2 Consecutive Reads**\n- Multiple read operations should be executed in succession.\n\n### **6.3 Immediate Read After Write**\n- Data should be written to a location, and an immediate read request should be performed at the same address.\n\n### **6.4 Frequent Changes in Authentication Key**\n- Successive read and write operations should be tested while frequently changing the authentication key.\n\n### **6.5 Combining Edge Cases**\n- A complex test scenario should be created by combining multiple conditions, such as alternating between valid and invalid keys, performing reads and writes at boundary addresses, and introducing reset signals.", "context": {}}, "output": {"response": "", "context": {"verif/tb_secure_read_write_bus_interface.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 5-tb-stimulus\nTARGET = 100", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/secure_read_write_bus_interface.v /code/verif/tb_secure_read_write_bus_interface.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/secure_read_write_bus_interface.v": "module secure_read_write_bus_interface #(\n    parameter p_configurable_key = 8'hAA,      // Default key\n    parameter p_data_width       = 8,         // Data width\n    parameter p_addr_width       = 8          // Address width\n)(\n    input  wire [p_addr_width-1:0] i_addr,            // Address input\n    input  wire [p_data_width-1:0] i_data_in,         // Data to write\n    input  wire [7:0]              i_key_in,         // Input key for authentication\n    input  wire                    i_read_write_enable, // 1: Read, 0: Write\n    input  wire                    i_capture_pulse,  // Qualifies input capture\n    input  wire                    i_reset_bar,      // Active-low reset\n    output reg  [p_data_width-1:0] o_data_out,       // Data output during read\n    output reg                     o_error           // Error flag for unauthorized access\n);\n\n    // Internal memory declaration\n    reg [p_data_width-1:0] memory [(2**p_addr_width)-1:0]; // Memory array\n\n    // Internal key comparison logic\n    wire key_match = (i_key_in == p_configurable_key); // Check if keys match\n\n    // Sequential logic: Operates on i_capture_pulse edge or asynchronous reset\n    always @(posedge i_capture_pulse or negedge i_reset_bar) begin\n        if (!i_reset_bar) begin\n            // Reset all outputs and states\n            o_data_out <= {p_data_width{1'b0}};\n            o_error    <= 1'b0;\n        end else begin\n            // Handle Read/Write operations based on enable signal\n            if (key_match) begin\n                o_error <= 1'b0; // Clear error flag if key matches\n                if (i_read_write_enable) begin\n                    // Read operation\n                    o_data_out <= memory[i_addr];\n                end else begin\n                    // Write operation\n                    memory[i_addr] <= i_data_in;\n                    o_data_out     <= {p_data_width{1'b0}}; // Clear output during write\n                end\n            end else begin\n                // Key mismatch: Raise error and clear outputs\n                o_error    <= 1'b1;\n                o_data_out <= {p_data_width{1'b0}};\n            end\n        end\n    end\nendmodule\n"}}}
{"id": "cvdp_copilot_secure_read_write_register_bank_0006", "categories": ["cid012", "medium"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `secure_read_write_register_bank`. It allows read and write operations only after unlocking, which requires specific values written to the first two addresses in sequence.The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameters, Inputs - Outputs and Functional behaviour**\n\n### Parameter\n1.  **p_address_width**: The address width parameter with default value of 8 bits. It will be used to create the addressable space of register bank module.\n2.  **p_data_width**: The data width parameter with default value of 8 bits.\n3. **p_unlock_code_0**: The unlock code to be written at address zero. The default value is 0xAB.\n4. **p_unlock_code_1**: The unlock code to be written at address one. The default value is 0xCD.\n\n\n### Inputs\n1. **i_addr**: `p_addr_width`-bit input. Specifies the target address for read or write operations.\n2. **i_data_in**: `p_data_width`-bit input. Data input to be written to the register bank during a write operation.\n3. **i_read_write_enable**: 1-bit input control signal. Determines the operation type:\n   - `0`: Write operation.\n   - `1`: Read operation.\n4. **i_capture_pulse**: 1-bit capture pulse signal. Triggers the read or write operation on positive edge of this signal. It will act as clock for register bank.\n5.  **i_rst_n**: 1-bit asynchronous active low reset, to reset the unlock state machine\n\n### Outputs\n1. **o_data_out**: `p_data_width`-bit output. Data output bus that reflects the value read from the register bank during a read operation.\n\n### Functional Requirements\n\n#### 1. Write Operation\n   - If **i_read_write_enable** is `0`, the module interprets this as a write operation.\n   - On the **rising edge** of **i_capture_pulse**, the value of **i_data_in** is written to the register at the address specified by **i_addr**.\n   - **o_data_out** should output `0` during write operations as a default state.\n\n#### 2. Read Operation\n   - If **i_read_write_enable** is `1`, the module interprets this as a read operation.\n   - On the **rising edge** of **i_capture_pulse**, **o_data_out** outputs the data stored at the address specified by **i_addr**.\n   - **o_data_out** only reflects the read data during read operations.\n\n### Security Access Requirements\n1. **Unlocking Mechanism**:\n   - **To unlock the register bank**, two sequential operations must be completed:\n     - First, the specific **parameterized unlock code** (matching **p_data_width**) must be written to address `0`.\n     - Then, a specific **parameterized trigger code** must be written to address `1`.\n   - If both conditions are met, the register bank unlocks, enabling access to read and write for all addresses.\n   - If, at any positive edge of i_capture_pulse, values are written to address 0 or 1 does not equal to given parameterized unlock code, the register bank will reset, resulting in lock of register bank. User needs to unlock the register bank once again.\n   - If the unlock sequence is incomplete, access to other addresses will remain restricted as follows:\n     - **Read Operation**: Outputs `0` on **o_data_out**.\n     - **Write Operation**: Prevents writing to any address except `0` and `1`.\n   - When i_rst_n goes low, then this unlocking mechanism resets and user needs to unlock the register bank once again.\n\n2. **Restricted Access Addresses**:\n   - Addresses `0` and `1` are write-only and cannot be read.\n   - Other addresses remain inaccessible for both read and write until the unlock sequence is completed.\n\n### Constraints and Edge Cases\n- Ensure that addresses `0` and `1` cannot be read.\n- Any read or write attempt on other addresses before unlocking should default **o_data_out** to `0` and prevent writing, respectively.\n- The writing of address `0` and address `1` should be concurrent, else register bank should be locked.\n\n## Test Bench Requirements\n\n### Stimulus Generation\n1. **Reset and Initialization:**  \n   - Assert the asynchronous reset signal briefly and then release it.\n\n2. **Locked State \u2013 Write Operation to a General Register:**  \n   - While the module is locked, perform a write operation to a register that is not part of the unlock sequence.\n\n3. **Locked State \u2013 Read Operation from a General Register:**  \n   - In the locked state, perform a read operation from a register outside the unlock sequence.\n\n4. **Locked State \u2013 Read Operation from the Unlock Addresses:**  \n   - While locked, attempt to read from the registers reserved for the unlock sequence.\n\n5. **Successful Unlock Sequence and General Access:**  \n   - Perform the unlock sequence by writing the appropriate unlock code to the first designated address followed by writing the corresponding unlock code to the second designated address, with both operations synchronized to the capture pulse.\n   - Once unlocked, perform a write to a general register and then read from that register.\n\n6. **Unlock Failure \u2013 Incorrect Code in the First Step:**  \n   - Attempt to start the unlock sequence by writing an incorrect code to the first designated address.\n   - Continue by performing the expected operation at the second designated address.\n\n7. **Unlock Failure \u2013 Incorrect Code in the Second Step:**  \n   - Initiate the unlock sequence correctly at the first designated address.\n   - Then write an incorrect code to the second designated address.\n\n8. **Out-of-Sequence Write Aborting Unlock:**  \n   - Begin the unlock sequence by writing the proper code to the first designated address.\n   - Instead of proceeding to the second designated address, write to a different register.\n\n9. **Unlocked State \u2013 Incorrect Write to Unlock Address Causes Relock:**  \n   - After achieving the unlocked state, perform a write operation with an incorrect code to one of the designated unlock addresses.\n   - Perform additional write/read operations on a general register to ensure that access remains restricted.\n\n10. **Unlocked State \u2013 Read Operation from Unlock Addresses:**  \n    - In the unlocked state, attempt to read from the registers used for the unlock sequence.\n\n11. **Boundary Register Operation:**  \n    - Once unlocked, perform a write operation to the highest addressable register in the bank.\n    - Follow this with a read from that boundary register.\n\n12. **Capture Pulse Synchronization:**  \n    - Modify control inputs (such as address selection, data to be written, or operation type) between capture pulses.\n\n13. **Reset During Active Operation:**  \n    - While the module is unlocked, perform a write operation to a general register.\n    - Assert the asynchronous reset during the operation and then de-assert it.\n    - Attempt a read from the previously written register.\n\n14. **Incorrect Unlock Sequence Order:**  \n    - Attempt to initiate the unlock sequence by writing to the second designated address before writing to the first designated address.\n\n15. **Multiple Sequential Unlock Attempts:**  \n    - First, attempt an unlock sequence that intentionally fails by providing an incorrect code in one of the steps.\n    - Then, retry the unlock sequence using the proper codes in the correct order.", "context": {}}, "output": {"response": "", "context": {"verif/tb_secure_read_write_register_bank.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 6-tb-stimulus\nTARGET = 96", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/secure_read_write_register_bank.v /code/verif/tb_secure_read_write_register_bank.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/secure_read_write_register_bank.v": "// -----------------------------------------------------------------------------\n// Module Name: secure_read_write_register_bank\n// Description: \n// This module implements a secure, parameterized register bank with access \n// control. It uses a state machine to enforce an unlocking mechanism for \n// read/write access. Access to the register bank is allowed only after a \n// two-step unlock sequence is completed by writing specific unlock codes to \n// predefined addresses. The register bank operates in a restricted mode until \n// the correct unlock sequence is performed.\n// \n// Key Features:\n// - Parameterized address and data widths\n// - Configurable unlock codes for security\n// - Read and write access controlled by a security FSM\n// - Addresses `0` and `1` are restricted to write-only operations\n// - Reset mechanism to relock the register bank\n// \n// -----------------------------------------------------------------------------\n\nmodule secure_read_write_register_bank #(\n    parameter p_address_width = 8,                // Address width parameter (default 8 bits)\n    parameter p_data_width = 8,                   // Data width parameter (default 8 bits)\n    parameter p_unlock_code_0 = 8'hAB,            // Unlock code for address 0\n    parameter p_unlock_code_1 = 8'hCD             // Unlock code for address 1\n)(\n    input  wire                         i_rst_n,            // Asynchronous active-low reset\n    input  wire [p_address_width-1:0]   i_addr,             // Address input for read/write operations\n    input  wire [p_data_width-1:0]      i_data_in,          // Data input for write operations\n    input  wire                         i_read_write_enable, // Control signal: 1 = Read, 0 = Write\n    input  wire                         i_capture_pulse,    // Capture pulse (acts as clock for the register bank)\n    output reg  [p_data_width-1:0]      o_data_out          // Data output for read operations\n);\n\n    // -------------------------------------------------------------------------\n    // Internal Memory: Register Bank\n    // -------------------------------------------------------------------------\n    // A 2^p_address_width-sized register bank to hold data. Each register is \n    // p_data_width bits wide. This memory is accessed using the `i_addr` signal.\n    reg [p_data_width-1:0] r_register_bank [0:(1<<p_address_width)-1];\n    \n    // -------------------------------------------------------------------------\n    // Unlock State Machine\n    // -------------------------------------------------------------------------\n    // Tracks the state of the unlock mechanism:\n    // - LOCKED: No access to register bank except for write-only access to \n    //   addresses 0 and 1 to attempt unlocking.\n    // - UNLOCK_STEP1: First step of the unlock sequence completed.\n    // - UNLOCKED: Full access granted.\n    reg [1:0] r_unlock_state;  // Unlock FSM state\n\n    // State Encoding\n    localparam p_STATE_LOCKED       = 2'b00; // Locked state (initial state)\n    localparam p_STATE_UNLOCK_STEP1 = 2'b01; // First unlock step complete\n    localparam p_STATE_UNLOCKED     = 2'b11; // Register bank fully unlocked\n\n    // -------------------------------------------------------------------------\n    // Unlock FSM Logic\n    // -------------------------------------------------------------------------\n    // The FSM transitions between LOCKED, UNLOCK_STEP1, and UNLOCKED states \n    // based on the address and data written to the register bank. Incorrect \n    // unlock codes or incorrect sequences reset the FSM back to LOCKED.\n    always @(posedge i_capture_pulse or negedge i_rst_n) begin\n        if (!i_rst_n) begin\n            // Reset the FSM to the locked state on active-low reset\n            r_unlock_state <= p_STATE_LOCKED;\n        end else begin\n            case (r_unlock_state)\n                p_STATE_LOCKED: begin\n                    // Check if the first unlock code is written to address 0\n                    if ((i_addr == 0) && (i_data_in == p_unlock_code_0) && (!i_read_write_enable)) begin\n                        r_unlock_state <= p_STATE_UNLOCK_STEP1; // Move to step 1\n                    end\n                end\n\n                p_STATE_UNLOCK_STEP1: begin\n                    // Check if the second unlock code is written to address 1\n                    if ((i_addr == 1) && (i_data_in == p_unlock_code_1) && (!i_read_write_enable)) begin\n                        r_unlock_state <= p_STATE_UNLOCKED; // Unlock successful\n                    end \n                    // If any other address is tried to be written, reset to LOCKED\n                    else begin\n                        r_unlock_state <= p_STATE_LOCKED;\n                    end\n                end\n\n                p_STATE_UNLOCKED: begin\n                    // If incorrect code is written to address 0 or 1, relock the register bank\n                    if (((i_addr == 1) && (i_data_in != p_unlock_code_1) && (!i_read_write_enable)) ||\n                        ((i_addr == 0) && (i_data_in != p_unlock_code_0) && (!i_read_write_enable))) begin\n                        r_unlock_state <= p_STATE_LOCKED;\n                    end\n                end\n\n                default: begin\n                    r_unlock_state <= p_STATE_LOCKED; // Default to LOCKED\n                end\n            endcase\n        end\n    end\n\n    // -------------------------------------------------------------------------\n    // Read and Write Operations\n    // -------------------------------------------------------------------------\n    always @(posedge i_capture_pulse) begin\n        if (r_unlock_state == p_STATE_UNLOCKED) begin\n            // Unlocked: Full access to the register bank\n            if (i_read_write_enable) begin\n                // Read operation\n                if (i_addr == 0 || i_addr == 1) begin\n                    o_data_out <= 0; // Addresses 0 and 1 are write-only\n                end else begin\n                    o_data_out <= r_register_bank[i_addr]; // Output data at address\n                end\n            end else begin\n                // Write operation\n                r_register_bank[i_addr] <= i_data_in; // Write data to register\n                o_data_out <= 0; // Default output during write\n            end\n        end else begin\n            // Locked: Restricted access\n            if (i_read_write_enable) begin\n                o_data_out <= 0; // Locked state: read outputs 0\n            end else begin\n                // Allow writes only to addresses 0 and 1\n                if (i_addr == 0 || i_addr == 1) begin\n                    r_register_bank[i_addr] <= i_data_in;\n                end\n                o_data_out <= 0; // Default output during write\n            end\n        end\n    end\n\nendmodule\n"}}}
{"id": "cvdp_copilot_secure_variable_timer_0006", "categories": ["cid012", "medium"], "input": {"prompt": "Create a self-checking test bench in SystemVerilog for a Verilog module named `secure_variable_timer`. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameters, Inputs - Outputs and Functional behavior**\n\n| **Port Name**      | **Direction** | **Width** | **Description**                                                              |\n|--------------------|---------------|-----------|------------------------------------------------------------------------------|\n| `i_clk`            | Input         | 1         | Clock signal, rising-edge triggered.                                         |\n| `i_rst_n`          | Input         | 1         | Active-low synchronous reset signal.                                         |\n| `i_data_in`        | Input         | 1         | Serial data input for detecting the start pattern and configuring the delay. |\n| `o_time_left`      | Output        | 4         | 4-bit output showing remaining time during the counting phase.               |\n| `o_processing`     | Output        | 1         | Asserted high when the timer is actively counting.                           |\n| `o_completed`      | Output        | 1         | Asserted high when the timer completes its delay cycle.                      |\n| `i_ack`            | Input         | 1         | Acknowledgment signal from the user to reset the timer after completion.     |\n\n---\n\n### Functional Requirements\n\nThe module operates as a timer with the following behavior:\n\n1. **Start Sequence Detection**:\n   - The timer begins when the serial data input (`i_data_in`) detects the bit sequence `1101` in the incoming stream.\n\n2. **Delay Duration Configuration**:\n   - After detecting the `1101` sequence, the module reads the next 4 bits (most significant bit first) from the `i_data_in` input.\n   - These 4 bits define the delay value (`delay[3:0]`), which determines the timer duration.\n\n3. **Counting Phase**:\n   - The timer counts for exactly ((delay[3:0] + 1) * 1000) clock cycles:\n     - Example: If `delay = 0`, the timer counts for 1000 cycles; if `delay = 5`, the timer counts for 6000 cycles.\n   - During this phase:\n     - The `o_processing` output is asserted high.\n     - The `o_time_left` output decrements as follows:\n       - Starts at `delay` for the first 1000 cycles.\n       - Decrements by 1 every subsequent 1000 cycles until reaching 0.\n\n4. **Completion and Reset**:\n   - Once the counting phase completes:\n     - The `o_completed` signal is asserted high to notify the user.\n     - The module waits for the `i_ack` signal to reset itself and begin searching for the next `1101` sequence.\n\n5. **Idle State**:\n   - When not actively counting:\n     - The `o_time_left` output is a don't-care value.\n     - The module resumes searching the `i_data_in` input for the `1101` sequence.\n\n---\n\n### Design Constraints\n\n- **Clock and Reset**:\n  - On reset, the module enters the idle state, ready to search for the `1101` sequence.\n\n- **Input Handling**:\n  - The `i_data_in` input is ignored during the counting phase.\n  - Only transitions to the configuration phase when the `1101` sequence is detected.\n\n- **Output Behavior**:\n  - The `o_time_left` output is only valid during the counting phase and must correctly represent the remaining time as described.\n\n---\n\n### Implementation Notes\n\n1. **State Machine Design**:\n   - Implement a finite state machine (FSM) to manage the following states:\n     - **Idle**: Search for the `1101` pattern in the `i_data_in` input.\n     - **Configure Delay**: Shift in the next 4 bits to set the delay value (`delay[3:0]`).\n     - **Counting**: Count for \\((\\text{delay[3:0]} + 1) \\times 1000\\) clock cycles.\n     - **Done**: Assert the `o_completed` output and wait for `i_ack` before resetting.\n     \n2. **Counting Logic**:\n   - Use a counter to count the total clock cycles required for the delay.\n   - Maintain a decrementing `o_time_left` output to reflect the remaining time.\n\n---\n## Stimulus generation\n1. **Reset & Idle**\n   - Assert `i_rst_n=0`, then drive high.\n\n2. **No Start Sequence**\n   - Feed random bits avoiding `1101`.\n\n3. **Start Sequence Detection**\n   - Provide `1101` immediately, then incomplete 4-bit delay.\n\n4. **Various Delay Values**\n   - After `1101`, supply 4-bit delays from `0000` to `1111`.\n\n5. **Completion & Acknowledgment**\n   - Feed `1101 + valid_delay`; wait for `o_completed=1`.\n   - Assert `i_ack`; \n\n6. **Overlapping Start Sequence**\n   - Input bit patterns like `11101` or `1101101`.\n\n7. **Spurious Input During Count**\n   - Once counting, feed random `i_data_in`.\n\n8. **Reset Mid-Count**\n   - While counting, assert `i_rst_n=0`.\n   - \n\n9. **Consecutive Timers**\n   - Drive multiple `1101 + 4-bit` sequences back-to-back.", "context": {}}, "output": {"response": "", "context": {"verif/tb_secure_variable_timer.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 6-tb-stimulus\nTARGET = 98", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/secure_variable_timer.v /code/verif/tb_secure_variable_timer.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/secure_variable_timer.v": "module secure_variable_timer (\n    input  wire        i_clk,         // Clock signal (rising-edge triggered)\n    input  wire        i_rst_n,       // Active-low synchronous reset signal\n    input  wire        i_data_in,     // Serial data input\n    output reg  [3:0]  o_time_left,   // 4-bit output showing remaining time (during counting phase)\n    output reg         o_processing,  // Asserted high when the timer is actively counting\n    output reg         o_completed,   // Asserted high when the timer completes its delay\n    input  wire        i_ack          // Acknowledgment signal to reset after completion\n);\n\n    //--------------------------------------------------------------------\n    // 1) State Definitions\n    //--------------------------------------------------------------------\n    localparam  STATE_IDLE       = 2'b00;  // Waiting for 1101 pattern\n    localparam  STATE_DELAY_CFG  = 2'b01;  // Reading 4 bits of delay\n    localparam  STATE_COUNT      = 2'b10;  // Counting phase\n    localparam  STATE_DONE       = 2'b11;   // Timer done, waiting for i_ack\n\n    reg [1:0] current_state;\n    reg [1:0] next_state;\n\n    //--------------------------------------------------------------------\n    // 2) Internal Registers\n    //--------------------------------------------------------------------\n    // Shift register for detecting start pattern (1101)\n    reg [3:0] pattern_shift;\n    // Counter to know how many bits of delay have been read\n    reg [1:0] delay_bit_count;\n    // Temporary shift register for the 4-bit delay value\n    reg [3:0] delay_shift;\n\n\n    // Sub-counter for 1000-cycle chunks\n    // Counts from 0 to 999, then resets\n    reg [9:0] sub_count;\n\n    //--------------------------------------------------------------------\n    // 3) State Machine - Sequential Logic\n    //--------------------------------------------------------------------\n    always @(posedge i_clk or negedge i_rst_n) begin\n        if (!i_rst_n) begin\n            // Synchronous reset (active low)\n            current_state   <= STATE_IDLE;\n            pattern_shift   <= 4'b0;\n            delay_bit_count <= 2'd0;\n            delay_shift     <= 4'b0;\n            sub_count       <= 10'd0;\n            o_time_left     <= 4'b0;\n        end\n        else begin\n            current_state <= next_state;\n\n            case (current_state)\n\n            //--------------------------------------------------------------\n            // STATE_IDLE: Search for the 1101 pattern in i_data_in\n            //--------------------------------------------------------------\n            STATE_IDLE: begin\n                // Shift in the new bit each clock\n                // pattern_shift[3] is the oldest bit, pattern_shift[0] is the newest\n                pattern_shift <= {pattern_shift[2:0], i_data_in};\n\n                // Once we detect the pattern 1101, we\u2019ll move to STATE_DELAY_CFG\n                // (We can check the pattern right after we shift in the new bit.)\n                if (pattern_shift == 4'b1101) begin\n                    // Prepare for delay configuration\n                    delay_bit_count <= 2'd0;\n                    delay_shift     <= 4'b0;\n                end\n            end\n\n            //--------------------------------------------------------------\n            // STATE_DELAY_CFG: Read next 4 bits as the delay\n            //--------------------------------------------------------------\n            STATE_DELAY_CFG: begin\n                // Shift in the next bit from i_data_in\n                delay_shift <= {delay_shift[2:0], i_data_in};\n                delay_bit_count <= delay_bit_count + 1'b1;\n                // Once we have collected 4 bits, latch them as the final delay\n                if (delay_bit_count == 2'd2) begin\n                    o_time_left <= {delay_shift[2:0], i_data_in}; \n                    \n                end\n            end\n\n            //--------------------------------------------------------------\n            // STATE_COUNT: Counting phase\n            //--------------------------------------------------------------\n            STATE_COUNT: begin\n                // Sub-counter increments every clock\n                sub_count <= sub_count + 1'b1;\n                // After 1000 cycles, sub_count resets and o_time_left decrements\n                if (sub_count == 10'd999) begin\n                    sub_count   <= 10'd0;\n                    // Decrement time_left if not already zero\n                    if (o_time_left != 4'd0)\n                        o_time_left <= o_time_left - 1'b1;\n                end\n            end\n\n            //--------------------------------------------------------------\n            // STATE_DONE: Timer complete, o_completed=1, waiting for i_ack\n            //--------------------------------------------------------------\n            STATE_DONE: begin\n                pattern_shift   <= 4'b0;\n                delay_bit_count <= 2'd0;\n                delay_shift     <= 4'b0;\n                // Remain here until i_ack is seen\n                // (No special sequential logic needed here.)\n            end\n\n            endcase\n        end\n    end\n\n    //--------------------------------------------------------------------\n    // 4) State Machine - Combinational Next-State Logic\n    //--------------------------------------------------------------------\n    always @* begin\n\n        case (current_state)\n\n        //--------------------------------------------------------------\n        // STATE_IDLE\n        //--------------------------------------------------------------\n        STATE_IDLE: begin\n            // Remain in IDLE unless we detect '1101' in pattern_shift\n            if (pattern_shift == 4'b1101) begin\n                next_state = STATE_DELAY_CFG;\n                o_completed = 1'b0; \n                o_processing = 1'b0;\n            end\n            else begin\n                next_state = STATE_IDLE;\n                o_completed = 1'b0; \n                o_processing = 1'b0;\n            end\n        end\n\n        //--------------------------------------------------------------\n        // STATE_DELAY_CFG\n        //--------------------------------------------------------------\n        STATE_DELAY_CFG: begin\n            // Wait until we've read 4 bits total (delay_bit_count = 4)\n            if (delay_bit_count == 2'd3) begin\n                // Move to COUNT state\n                next_state = STATE_COUNT;\n                o_processing = 1'b1; // During counting phase, we set o_processing=1\n                o_completed = 1'b0; \n            end\n            else begin\n                next_state = STATE_DELAY_CFG;\n                o_completed = 1'b0; \n                o_processing = 1'b0;\n            end\n        end\n\n        //--------------------------------------------------------------\n        // STATE_COUNT\n        //--------------------------------------------------------------\n        STATE_COUNT: begin\n            \n\n            // We count for (delay_reg + 1) * 1000 cycles\n            // The easiest check: if o_time_left == 0 AND sub_count == 999,\n            // then we have just finished the final chunk of 1000 cycles.\n            if ((o_time_left == 4'd0) && (sub_count == 10'd999)) begin\n                // Counting complete\n                next_state = STATE_DONE;\n                o_completed = 1'b1; // Signal completion\n                o_processing = 1'b0;\n            end\n            else begin\n                next_state = STATE_COUNT;\n                o_processing = 1'b1;\n                o_completed = 1'b0; \n            end\n        end\n\n        //--------------------------------------------------------------\n        // STATE_DONE\n        //--------------------------------------------------------------\n        STATE_DONE: begin\n\n            // Once i_ack is asserted, go back to STATE_IDLE\n            // to look for next 1101 pattern\n            if (i_ack == 1'b1) begin\n                next_state = STATE_IDLE;\n                o_processing = 1'b0;\n                o_completed = 1'b0;\n            end\n            else begin\n                next_state = STATE_DONE;\n                o_completed = 1'b1;\n                o_processing = 1'b0;\n            end\n        end\n\n        endcase\n    end\n\n\n\nendmodule"}}}
{"id": "cvdp_copilot_signed_adder_0003", "categories": ["cid012", "medium"], "input": {"prompt": "Create a stimulus generating test bench in SystemVerilog for a Verilog module named `signedadder` that add or subtract two signed 2's complement numbers, controlled by input signals and a state machine. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n \n## 1. Instantiation\n\nName the instance of the RTL as dut.\n\n## 2. DESIGN UNDER TEST (DUT)\n\nThe DUT is a **signed 2\u2019s complement adder/subtractor** with a built-in state machine. It can:\n\n- **Add** (`i_mode = 0`) or **Subtract** (`i_mode = 1`) two `DATA_WIDTH`-bit signed operands.  \n- **Detect Overflow** for signed operations.  \n- Operate in a **four-state** machine (IDLE \u2192 LOAD \u2192 COMPUTE \u2192 OUTPUT).  \n- **Parameter**: `DATA_WIDTH` (e.g., 8 bits)  \n\n### High-Level Data Flow\n\n1. **IDLE**: Waits for `i_enable` and `i_start`.  \n2. **LOAD**: Latches `i_operand_a` and `i_operand_b`.  \n3. **COMPUTE**: Performs the requested arithmetic operation.  \n4. **OUTPUT**: Updates the outputs, asserts `o_ready`, then returns to **IDLE**.\n\n---\n\n## 3. INPUT AND OUTPUT EXPLANATION\n\n### Inputs\n\n1. **`i_clk`**  \n   - **Function**: Clock for synchronous logic.  \n   - **Usage**: Triggers all state transitions.\n\n2. **`i_rst_n`** (Active-Low Reset)  \n   - **Function**: Asynchronously resets the design.  \n   - **Usage**: Forces module to **IDLE** state, clears registers, and zeroes outputs.\n\n3. **`i_start`**  \n   - **Function**: Triggers loading of operands when high (if `i_enable` is also asserted).  \n   - **Usage**: Must be pulsed high while in **IDLE** to move the state machine to **LOAD**.\n\n4. **`i_enable`**  \n   - **Function**: Global enable for the module.  \n   - **Usage**: If deasserted, the design will ignore `i_start` and revert or stay in **IDLE**.\n\n5. **`i_mode`**  \n   - **Function**: Selects the arithmetic operation.  \n   - **Usage**:  \n     - `0` \u2192 Addition (`o_resultant_sum = i_operand_a + i_operand_b`)  \n     - `1` \u2192 Subtraction (`o_resultant_sum = i_operand_a - i_operand_b`)\n\n6. **`i_clear`**  \n   - **Function**: Immediately clears outputs and resets the state machine to **IDLE**.  \n   - **Usage**: When high, forces result to 0 and moves to **IDLE**.\n\n7. **`i_operand_a`, `i_operand_b`**  \n   - **Function**: Signed 2\u2019s complement inputs.  \n   - **Usage**: Values to be added or subtracted.\n\n### Outputs\n\n1. **`o_resultant_sum`**  \n   - **Function**: Provides the computed result (in signed 2\u2019s complement).  \n   - **Usage**: Valid only in **OUTPUT** state or once `o_ready` is high.\n\n2. **`o_overflow`**  \n   - **Function**: High if a **signed overflow** is detected.  \n   - **Usage**: Check this after the **COMPUTE** cycle completes.\n\n3. **`o_ready`**  \n   - **Function**: Indicates that `o_resultant_sum` and `o_overflow` are valid.  \n   - **Usage**: High in **OUTPUT** state, then returns low in **IDLE**.\n\n4. **`o_status`** (2 bits)  \n   - **Function**: Encodes the current state of the module.  \n   - **Usage**:\n     - `00`: IDLE  \n     - `01`: LOAD  \n     - `10`: COMPUTE  \n     - `11`: OUTPUT  \n\n---\n\n## 4. BEHAVIOR EXPLANATION\n\n1. **Reset Behavior**  \n   - When `i_rst_n` is deasserted (low), internal registers and outputs are cleared, and the module returns to the **IDLE** state.  \n   - The reset is asynchronous: the design responds immediately to `i_rst_n`.\n\n2. **State Machine Flow**  \n   - **IDLE (00)**: Default/wait state. The design transitions to **LOAD** if `i_enable` and `i_start` are high.  \n   - **LOAD (01)**: Latches `i_operand_a` and `i_operand_b` into internal registers, preparing for computation.  \n   - **COMPUTE (10)**: Performs addition or subtraction based on `i_mode`. Internal overflow logic is used to set `o_overflow`.  \n   - **OUTPUT (11)**: Updates `o_resultant_sum` and `o_overflow`, asserts `o_ready`, and then goes back to **IDLE**.\n\n3. **Overflow Detection**  \n   - Triggered when the sign of the result indicates a signed overflow:  \n     - Both operands positive, result negative.  \n     - Both operands negative, result positive.  \n   - `o_overflow` goes high if either condition is met.\n\n4. **Clear Behavior**  \n   - When `i_clear` is high, the design resets outputs and returns to **IDLE** no matter the current state.\n\n---\n\n## 5. STIMULUS LIST FOR 100% COVERAGE\n\nBelow is an outline of test scenarios and input sequences to exhaustively check each design feature, state, and boundary condition. **No actual code is provided**; only the conceptual approach to drive and observe the design is described.\n\n### A. Reset and Basic State Transition Coverage\n\n1. **Asserting `i_rst_n = 0` During Operation**  \n   - **Objective**: Immediate reset to **IDLE**. \n   - **Process**:  \n     - Start in **IDLE**.  \n     - Assert `i_start` and `i_enable` to move to **LOAD**.  \n     - While in **LOAD** or **COMPUTE**, drive `i_rst_n` low.  \n     - \n2. **Using `i_clear`**  \n   - **Objective**: Immediate clear function at each state.  \n   - **Process**:  \n     - Begin in **IDLE** with `i_enable = 1`.  \n     - Assert `i_start`, capture some operands in **LOAD**.  \n     - Deassert `i_start`, go to **COMPUTE**, then drive `i_clear` high.  \n\n### B. Normal Addition Operations\n\n3. **Simple Positive Addition**  \n   - **Objective**: Correct addition for small positive numbers.  \n   - **Process**:  \n     - `i_operand_a = 5`, `i_operand_b = 10`, `i_mode = 0`, `i_start = 1`, `i_enable = 1`.  \n\n4. **Positive + Negative (No Overflow)**  \n   - **Objective**: Sign handling when operands have opposite signs.  \n   - **Process**:  \n     - `i_operand_a = 15`, `i_operand_b = -5`, `i_mode = 0`.  \n5. **Boundaries with No Overflow**  \n   - **Objective**: Approach boundary without triggering overflow.  \n   - **Process**:  \n     - For an 8-bit example: `i_operand_a = 127`, `i_operand_b = 0`, `i_mode = 0`.  \n\n### C. Overflow in Addition\n\n6. **Positive Overflow**  \n   - **Objective**: Detect overflow when adding two large positive numbers.  \n   - **Process**:  \n     - For 8-bit: `i_operand_a = 127`, `i_operand_b = 1`, `i_mode = 0`.  \n\n7. **Negative Overflow**  \n   - **Objective**: Detect overflow with large negative numbers.  \n   - **Process**:  \n     - For 8-bit: `i_operand_a = -128` (0x80), `i_operand_b = -1`, `i_mode = 0`.  \n\n### D. Subtraction Operations\n\n8. **Basic Positive Subtraction**  \n   - **Objective**: standard subtraction.  \n   - **Process**:  \n     - `i_operand_a = 20`, `i_operand_b = 5`, `i_mode = 1`.  \n\n9. **Negative Result Subtraction**  \n   - **Objective**: Check correct negative outcome.  \n   - **Process**:  \n     - `i_operand_a = 5`, `i_operand_b = 20`, `i_mode = 1`.  \n\n10. **Overflow in Subtraction**  \n    - **Objective**: Trigger overflow from subtracting.  \n    - **Process**:  \n      - For 8-bit: `i_operand_a = 127`, `i_operand_b = -1`, `i_mode = 1`.  \n\n11. **No-Operation Cases**  \n    - **Objective**:  `i_enable = 0`, no transitions occur.  \n    - **Process**:  \n      - Keep `i_enable = 0`, pulse `i_start`.\n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_signedadder.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 3-tb-stimulus\nTARGET = 99", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/signedadder.v /code/verif/tb_signedadder.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/signedadder.v": "module signedadder #(parameter DATA_WIDTH = 8)(\n    input i_clk,\n    input i_rst_n,\n    input i_start,\n    input i_enable,\n    input i_mode,\n    input i_clear,\n    input [DATA_WIDTH-1:0] i_operand_a,\n    input [DATA_WIDTH-1:0] i_operand_b,\n    output reg [DATA_WIDTH-1:0] o_resultant_sum,\n    output reg o_overflow,\n    output reg o_ready,\n    output [1:0] o_status\n);\n\n    // State encoding\n    localparam IDLE    = 2'b00;\n    localparam LOAD    = 2'b01;\n    localparam COMPUTE = 2'b10;\n    localparam OUTPUT  = 2'b11;\n\n    // Internal registers\n    reg [DATA_WIDTH-1:0] reg_operand_a;\n    reg [DATA_WIDTH-1:0] reg_operand_b;\n    reg [1:0] state;\n    reg [DATA_WIDTH-1:0] result;\n    reg signed_overflow;\n\n    assign o_status = state;\n    // Synchronous reset and state transitions\n    always @(posedge i_clk or negedge i_rst_n) begin\n        if (!i_rst_n) begin\n            state <= IDLE;\n            o_resultant_sum <= 0;\n            o_overflow <= 0;\n            o_ready <= 0;\n            reg_operand_a <= 0;\n            reg_operand_b <= 0;\n        end else begin\n            if (i_clear) begin\n                o_resultant_sum <= 0;\n                state <= IDLE;\n            end else begin\n                case (state)\n                    IDLE: begin\n                        o_ready <= 0;\n                        o_overflow <= 0;\n                        if (i_enable && i_start) begin\n                            state <= LOAD;\n                        end\n                    end\n\n                    LOAD: begin\n                        if (i_enable) begin\n                            reg_operand_a <= i_operand_a;\n                            reg_operand_b <= i_operand_b;\n                            state <= COMPUTE;\n                        end else begin\n                            state <= IDLE;\n                        end\n                    end\n\n                    COMPUTE: begin\n                        if (i_enable) begin\n                            if (i_mode == 0) begin\n                                result = reg_operand_a + reg_operand_b;\n                                signed_overflow = \n                                    (~reg_operand_a[DATA_WIDTH-1] & ~reg_operand_b[DATA_WIDTH-1] & result[DATA_WIDTH-1]) | \n                                    (reg_operand_a[DATA_WIDTH-1] & reg_operand_b[DATA_WIDTH-1] & ~result[DATA_WIDTH-1]);\n                            end else begin\n                                result = reg_operand_a - reg_operand_b;\n                                signed_overflow = \n                                    (~reg_operand_a[DATA_WIDTH-1] & reg_operand_b[DATA_WIDTH-1] & result[DATA_WIDTH-1]) | \n                                    (reg_operand_a[DATA_WIDTH-1] & ~reg_operand_b[DATA_WIDTH-1] & ~result[DATA_WIDTH-1]);\n                            end\n                            state <= OUTPUT;\n                        end else begin\n                            state <= IDLE;\n                        end\n                    end\n\n                    OUTPUT: begin\n                        if (i_enable) begin\n                            o_resultant_sum <= result;\n                            o_overflow <= signed_overflow;\n                            o_ready <= 1;\n                            state <= IDLE;\n                        end else begin\n                            state <= IDLE;\n                        end\n                    end\n                endcase\n            end\n        end\n    end\nendmodule\n"}}}
{"id": "cvdp_copilot_simple_spi_0003", "categories": ["cid012", "medium"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `spi_fsm`. The module handles data transmission in a serial format from a 16-bit input vector (`i_data_in`) using an SPI protocol. The design includes proper state transitions, signal handling, and timing synchronization to ensure accurate data transmission. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameters, Inputs - Outputs and Functional behavior**\n\n\n### Inputs\n1. **`i_clk`** (1-bit, Input):  \n   - System clock signal for synchronous operations.  \n\n2. **`i_rst_b`** (1-bit, Input):  \n   - Active-low asynchronous reset. Upon activation, the system must reset all internal states and outputs.  \n\n3. **`i_data_in`** (16-bit, Input):  \n   - Input data vector to be serialized and transmitted through the SPI bus.  \n\n4. **`i_enable`** (1-bit, Input):  \n   - Control signal to enable or disable the block.  \n     - High (`1`): The block operates normally, and data transmission occurs.  \n     - Low (`0`): The block resets to the idle state, disabling transmission.  \n\n5. **`i_fault`** (1-bit, Input):  \n   - Indicates a fault condition. If asserted, the FSM transitions to an error state, halts all activity, and drives outputs to safe defaults.  \n\n6. **`i_clear`** (1-bit, Input):  \n   - Forces the FSM to immediately clear the current transaction, clear counters, and transition to the idle state.  \n\n---\n\n### Outputs\n1. **`o_spi_cs_b`** (1-bit, Output):  \n   - Active-low SPI chip select signal to indicate the start and end of a transmission. Default is logic high when idle.  \n\n2. **`o_spi_clk`** (1-bit, Output):  \n   - SPI clock signal for synchronizing data transfers. The clock signal toggles during transmission. Default is logic low when idle or disabled.  \n\n3. **`o_spi_data`** (1-bit, Output):  \n   - Serialized SPI data output derived from the `i_data_in` input vector. Default is logic low when idle or disabled.  \n\n4. **`o_bits_left`** (5-bit, Output):  \n   - Tracks the number of bits remaining to be transmitted during the SPI session. Default is `0x10` (all bits remaining).  \n\n5. **`o_done`** (1-bit, Output):  \n   - Pulses high for exactly one clock cycle when a transaction is successfully completed or the FSM transitions to an error state.  \n\n6. **`o_fsm_state`** (2-bit, Output):  \n   - Reflects the internal FSM state for external monitoring:  \n     - `00` = Idle  \n     - `01` = Transmit  \n     - `10` = Clock Toggle  \n     - `11` = Error \n\n---\n\n### Behavioral Requirements\n\n1. **FSM States**:  \n   - **Idle** (`00`): Initialize SPI signals (`o_spi_cs_b = 1`, `o_spi_clk = 0`) and wait for `i_enable = 1` to begin transmission.  \n   - **Transmit** (`01`): Activate SPI signals (`o_spi_cs_b = 0`), load the MSB of `i_data_in` into `o_spi_data`, and start shifting the bits out sequentially.  \n   - **Clock Toggle** (`10`): Toggle `o_spi_clk` to latch `o_spi_data` externally, decrement `o_bits_left`, and determine if more bits remain to be transmitted. If all bits are sent, assert `o_done` and transition to Idle.  \n   - **Error** (`11`): Entered upon assertion of `i_fault`. All SPI outputs are driven to safe values (`o_spi_cs_b = 1`, `o_spi_clk = 0`, `o_spi_data = 0`,`o_done`=0,`o_bits_left=10`), and the FSM remains here until cleared or reset.  \n\n2. **Control Signals**:  \n   - **Enable (`i_enable`)**:  \n     - If asserted (`1`): FSM proceeds through normal transmission states (`Transmit` and `Clock Toggle`).  \n     - If deasserted (`0`): FSM immediately transitions to Idle and resets all active outputs.  \n   - **Clear (`i_clear`)**:  \n     - When asserted, FSM immediately transitions to Idle, resetting all counters and outputs regardless of the current state.  \n\n3. **Done Signal (`o_done`)**:  \n   - Asserted (high) for one clock cycle upon successful completion of transmission.\n\n4. **FSM State Output (`o_fsm_state`)**:  \n   - Reflects the current FSM state in real-time for external monitoring.  \n\n## Test Bench Requirements\n\n### Stimulus Generation\n\n**1. Reset and Initialization**\n- Apply the reset is applied.\n\n**2. Normal SPI Transmission**\n- Enable the FSM and provide a valid data input to initiate a transmission. \n- Introduce multiple consecutive transmissions without disabling the FSM to check if data is continuously processed as expected.\n- Attempt to modify the input data while transmission is ongoing to ensure that changes do not interfere with the current operation.\n\n**3. Control Signal Handling**\n- Disable the FSM while a transmission is in progress.\n- Force the FSM to clear its current operation while actively transmitting to confirm that it returns to idle without completing the remaining shifts.\n\n**4. Error Handling**\n- Introduce an error condition during transmission.\n- Attempt to recover from the error by applying a reset-like condition.\n\n**5. Clock and Edge Case Behavior**\n- Make the FSM to properly toggle the SPI clock signal during transmission, synchronizing data shifts.\n- Test the handling of extreme data values, including cases where only a single bit is set.\n- Execute back-to-back transmissions with varying data patterns.", "context": {}}, "output": {"response": "", "context": {"verif/tb_spi_fsm.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 3-tb-stimulus\nTARGET = 94", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/spi_fsm.v /code/verif/tb_spi_fsm.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/spi_fsm.v": "module spi_fsm (\n    input  wire         i_clk,       // System clock\n    input  wire         i_rst_b,     // Active-low async reset\n    input  wire [15:0]  i_data_in,   // Parallel 16-bit data to transmit\n    input  wire         i_enable,    // Enable block\n    input  wire         i_fault,     // Fault indicator\n    input  wire         i_clear,     // Forces FSM to clear/idle\n    \n    output reg          o_spi_cs_b,  // SPI chip select (active-low)\n    output reg          o_spi_clk,   // SPI clock\n    output reg          o_spi_data,  // Serialized SPI data out\n    output reg [4:0]    o_bits_left, // Bits left to transmit\n    output reg          o_done,      // Single-cycle pulse when done or error\n    output reg [1:0]    o_fsm_state  // FSM state for external monitoring\n);\n    \n    //--------------------------------------------------------------------------\n    // Parameter Definitions\n    //--------------------------------------------------------------------------\n    localparam [1:0] ST_IDLE         = 2'b00,  // Idle state\n                     ST_TRANSMIT     = 2'b01,  // Load/shift bits out\n                     ST_CLOCK_TOGGLE = 2'b10,  // Toggle clock & shift data\n                     ST_ERROR        = 2'b11;  // Fault state\n    \n    //--------------------------------------------------------------------------\n    // Internal Signals\n    //--------------------------------------------------------------------------\n    reg [1:0]  curr_state, next_state;\n    reg [15:0] shift_reg;        // Holds data to be shifted out\n    reg [4:0]  next_bits_left;\n    reg        next_done;\n    \n    //--------------------------------------------------------------------------\n    // Synchronous State & Data Registers\n    //--------------------------------------------------------------------------\n    always @(posedge i_clk or negedge i_rst_b) begin\n        if (!i_rst_b) begin\n            curr_state   <= ST_IDLE;\n            shift_reg    <= 16'd0;\n            o_bits_left  <= 5'h10;\n            o_done       <= 1'b0;\n        end\n        else begin\n            // Update FSM state\n            curr_state   <= next_state;\n            \n            // Update shift register (only in states that shift data)\n            if (curr_state == ST_TRANSMIT ) begin\n                shift_reg <= { shift_reg[14:0], 1'b0 }; // shift left\n                o_bits_left <= next_bits_left;\n            end\n            else if ((curr_state==ST_IDLE) && i_enable) begin\n                shift_reg <= i_data_in;\n            end\n            // else if(curr_state == ST_CLOCK_TOGGLE) begin\n                \n            // end\n                        \n            \n            // Update 'done' (one-cycle pulse)\n            o_done      <= next_done;\n        end\n    end\n    \n    //--------------------------------------------------------------------------\n    // Next-State and output Logic (Combinational)\n    //--------------------------------------------------------------------------\n    always @(*) begin\n        \n        if(!i_rst_b) begin\n            o_spi_cs_b     = 1'b1;       // Default de-asserted (active-low)\n            o_spi_clk      = 1'b0;       // Default clock low when idle\n            o_spi_data     = 1'b0;       // Default data low when idle\n            o_fsm_state    = ST_IDLE;\n            next_state     = ST_IDLE;\n            next_bits_left  = 5'h10;\n            next_done       = 1'b0;\n        end\n        else begin\n            // If either clear or !enable is active, force IDLE\n            if (!i_enable) begin\n                o_spi_cs_b     = 1'b1;       // Default de-asserted (active-low)\n                o_spi_clk      = 1'b0;       // Default clock low when idle\n                o_spi_data     = 1'b0;       // Default data low when idle\n                o_fsm_state    = ST_IDLE;\n                next_state      = ST_IDLE;\n                next_bits_left  = 5'h10;     // Reset bits_left to full (16 bits => 0x10; 0x10 can be a placeholder)\n                next_done       = 1'b0;\n            end\n            // If fault is asserted, go to ERROR\n            else if (i_fault) begin\n                o_spi_cs_b     = 1'b1;       // Default de-asserted (active-low)\n                o_spi_clk      = 1'b0;       // Default clock low when idle\n                o_spi_data     = 1'b0;       // Default data low when idle\n                next_state      = ST_ERROR;\n                next_done       = 1'b0;\n                o_fsm_state = ST_ERROR;\n                next_bits_left  = 5'h10;     // Reset bits_left to full (16 bits => 0x10; 0x10 can be a placeholder)\n                // Remain in ERROR until i_clear\n                if (i_clear) begin\n                    next_state     = ST_IDLE;\n                    o_fsm_state    = ST_IDLE; // Reflect the current FSM state\n                        \n                end\n                else begin\n                    next_state     = ST_ERROR;\n                    o_fsm_state = ST_ERROR;\n                end\n            end\n            else begin\n                case (curr_state)\n                    //--------------------------------------------------------------\n                    // IDLE State\n                    //--------------------------------------------------------------\n                    ST_IDLE: begin\n                        o_spi_cs_b     = 1'b1;       // Default de-asserted (active-low)\n                        o_spi_clk      = 1'b0;       // Default clock low when idle\n                        o_spi_data     = 1'b0;       // Default data low when idle\n                        o_fsm_state    = ST_IDLE; // Reflect the current FSM state\n                        if (i_enable && !i_fault && !i_clear) begin\n                            // Move to TRANSMIT to load the shift register\n                            next_state     = ST_TRANSMIT;\n                            next_done      = 1'b0;\n                            next_bits_left = 5'd16;  // 16 bits to send\n                        end\n                        else begin\n                            next_state     = ST_IDLE;\n                            next_bits_left = 5'h10;\n                            next_done      = 1'b0;\n                        end\n                    end\n                    \n                    //--------------------------------------------------------------\n                    // TRANSMIT State\n                    //--------------------------------------------------------------\n                    ST_TRANSMIT: begin\n                        o_spi_cs_b  = 1'b0;\n                        o_spi_clk   = 1'b0;\n                        o_spi_data  = shift_reg[15];\n                        o_fsm_state = ST_TRANSMIT;\n                        // Immediately move to CLOCK_TOGGLE to begin shifting\n                        next_done       = 1'b0;\n                        next_bits_left  = o_bits_left;\n                        next_state      = ST_CLOCK_TOGGLE;\n                        // Decrement bits_left after shifting out\n                        next_bits_left = (o_bits_left == 5'd0)\n                                        ? 5'd0\n                                        : o_bits_left - 5'b1;\n                    end\n                    \n                    //--------------------------------------------------------------\n                    // CLOCK TOGGLE State\n                    //--------------------------------------------------------------\n                    ST_CLOCK_TOGGLE: begin\n                        o_spi_cs_b  = 1'b0;\n                        o_spi_clk   = 1'b1;\n                        o_spi_data  = shift_reg[15];\n                        o_fsm_state = ST_CLOCK_TOGGLE;\n                        \n                        \n                        // If all bits have been shifted out, return to IDLE\n                        // and pulse `o_done` for one clock.\n                        if (o_bits_left == 5'd1) begin\n                            // This was the last bit\n                            next_state = ST_IDLE;\n                            next_done  = 1'b1;\n                        end\n                        else begin\n                            // Go back to TRANSMIT to shift out next bit\n                            next_done       = 1'b0;\n                            next_state      = ST_TRANSMIT;\n                        end\n                    end\n                    \n                    //--------------------------------------------------------------\n                    // ERROR State\n                    //--------------------------------------------------------------\n                    ST_ERROR: begin\n                        // Remain in ERROR until i_clear\n                        o_spi_cs_b  = 1'b1;\n                        o_spi_clk   = 1'b0;\n                        o_spi_data  = 1'b0;\n                        o_fsm_state = ST_ERROR;\n                        next_done       = 1'b0; \n                        next_bits_left  = 5'h10;     // Reset bits_left to full (16 bits => 0x10; 0x10 can be a placeholder)\n                        if (i_clear) begin\n                            next_state     = ST_IDLE;\n                        end\n                        else begin\n                            next_state     = ST_ERROR;\n                        end\n                    end\n                    \n                    default: begin\n                        // Should never happen; default to IDLE\n                        next_state = ST_IDLE;\n                    end\n                endcase\n            end\n        end\n    end\n    \nendmodule\n"}}}
{"id": "cvdp_copilot_single_cycle_arbiter_0004", "categories": ["cid012", "medium"], "input": {"prompt": "Create a **testbench** to apply **stimulus** to the `single_cycle_arbiter` module. This module implements a **fixed-priority, single-cycle arbitration** mechanism that grants exactly one request per cycle based on a priority scheme where **Port 0 has the highest priority** and **Port N-1 has the lowest priority**. The testbench must validate arbitration logic and priority enforcement and ensure proper handling of various request patterns, including edge cases.\n\n---\n\n### **Inputs:**\n\n- `clk`: **Clock signal with a 10ns period.**\n- `reset`: **Active-high reset signal.**\n- `req_i`: **Request signal, `N`-bit wide, where each bit represents a request from a different source.**\n\n### **Outputs:**\n\n- `gnt_o`: **Grant signal, `N`-bit wide, indicating which request has been granted.**\n\n---\n\n### **Instantiation**\n\nThe testbench must instantiate a single instance of the `single_cycle_arbiter` module:\n\n- **Primary Arbiter Module (`uut`)**: Instantiated with `N=8` to test typical request/grant scenarios.\n\n---\n\n### **Testbench Requirements**\n\nThe testbench must apply a **wide range of test patterns** covering various arbitration conditions:\n\n1. **Clock Generation:**\n   - `clk` must toggle every **5 time units**, ensuring a **10 ns clock period**.\n\n2. **Reset Handling:**\n   - `reset` must be **asserted for multiple cycles** before deasserting.\n   - The module must correctly initialize its outputs upon reset.\n\n3. **Stimulus Generation Strategy:**\n   - The testbench **must not verify outputs** (only generate inputs).\n   - The following test sequences must be executed:\n     - **No Requests**: Ensure `gnt_o` remains inactive.\n     - **Single Request Activation**: Apply requests to individual ports one at a time.\n     - **Simultaneous Requests**: Apply multiple requests and observe prioritization.\n     - **Sequential Requests**: Shift requests sequentially over cycles to verify shifting behavior.\n     - **Randomized Testing**: Generate **50 iterations** of randomized request patterns.\n     - **Edge Cases**:\n       - **Simultaneous Multiple-Level Requests**: Activate requests at non-adjacent positions (e.g., `8'b11000110`).\n       - **Even-Indexed Requests Active**: Ensure correct arbitration for `8'b10101010`.\n       - **Odd-Indexed Requests Active**: Ensure correct arbitration for `8'b01010101`.\n       - **Alternating Request Patterns**: Exercise `8'b10011001`.\n       - **Back-to-Back Requests Across Cycles**: Apply requests in consecutive cycles while ensuring arbitration propagates.\n     - **Mid-Run Reset Handling**:\n       - Apply reset **during an ongoing arbitration sequence**.\n       - Apply new requests after reset to verify proper reinitialization.\n\n4. **Handling Continuous and Edge Cases:**\n   - The testbench must ensure arbitration operates **correctly across all request patterns**.\n   - **High-frequency toggling** of requests must be exercised.\n\n5. **Waveform Generation:**\n   - The testbench must generate a `.vcd` waveform file to allow waveform analysis.\n\n---\n\n### **Coverage and Compliance**\n\n- The testbench must ensure **high coverage** across all possible arbitration conditions.\n- The **DUT instance name `uut` must be explicitly used** for instantiation.\n\n---\n\n### **Test Plan Overview**\n\nThe testbench must ensure **96%+ input stimulus coverage** by applying:\n\n- **Request arbitration testing** across different scenarios.\n- **Edge case handling** for alternating and simultaneous requests.\n- **Randomized input variations** to ensure robustness.\n- **Pipeline behavior verification** to confirm proper priority enforcement.\n- **Handling of multiple active requests** to validate correct grant selection.\n\nThis testbench will provide a **comprehensive input stimulus environment** for `single_cycle_arbiter`, ensuring correct operation under various test conditions.\n\n---\n\n### **Note:**\n- The testbench **must only generate stimulus** without verifying outputs.\n- The **DUT instance name `uut` must be explicitly used** for instantiation.\n- **Ensure the maximum possible input coverage** without adding assertions or comparisons.\n\nCan you implement a **SystemVerilog testbench** with the above stimulus requirements?", "context": {}}, "output": {"response": "", "context": {"verif/tb_single_cycle_arbiter.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 4-tb-stimulus-generation\nTARGET = 96", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/single_cycle_arbiter.sv": "module single_cycle_arbiter #(\n  parameter N = 32\n) (\n  input   logic          clk,\n  input   logic          reset,\n  input   logic [N-1:0]  req_i,\n  output  logic [N-1:0]  gnt_o\n);\n\n  // --------------------------------------------------------\n  // Internal wire and regs\n  // --------------------------------------------------------\n  logic [N-1:0] priority_req;\n\n  // --------------------------------------------------------\n  // Arbitration logic\n  // --------------------------------------------------------\n  assign priority_req[0] = 1'b0;\n  if (N > 1) begin : PR_GEN\n    for (genvar i = 0; i < N-1; i++) begin\n      // Port[0] highest priority\n      assign priority_req[i+1] = priority_req[i] | req_i[i];\n    end\n  end\n\n  // -------------------------------------------------------\n  // Output assignments\n  // --------------------------------------------------------\n  assign gnt_o[N-1:0] = req_i[N-1:0] & ~priority_req[N-1:0];\n\nendmodule\n"}}}
{"id": "cvdp_copilot_skid_register_0004", "categories": ["cid012", "medium"], "input": {"prompt": "Create a **testbench** to apply **stimulus** to the `skid_register` module. This module serves as a pipeline register with a skid buffer to handle backpressure. The testbench must simulate various scenarios to verify data flow, handshake mechanisms, and buffer operations.\n\n---\n\n### **Inputs:**\n\n- `clk`: **1-bit clock signal**, toggling every **5 time units** (100MHz operation).\n- `rst`: **Active-high reset signal** to initialize the module.\n- `up_bus`: **8-bit data input from upstream**.\n- `up_val`: **Valid signal from upstream indicating data presence**.\n- `dn_rdy`: **Ready signal from downstream indicating it can accept data**.\n\n### **Outputs:**\n\n- `up_rdy`: **Ready signal from the module for upstream communication**.\n- `dn_bus`: **8-bit data output to the downstream**.\n- `dn_val`: **Valid signal for downstream data**.\n\n---\n\n### **Instantiation**\n\nThe testbench must instantiate a single instance of the `skid_register` module:\n\n- **Skid Register Module (`dut`)**: Instantiated with its default configuration to verify data buffering and pipeline behavior.\n\n---\n\n### **Testbench Requirements**\n\nThe testbench must apply a **wide range of test patterns** covering various operating conditions of the `skid_register` module:\n\n1. **Clock Generation:**\n   - `clk` must toggle every **5 time units**, ensuring a **10 ns clock period**.\n\n2. **Reset Handling:**\n   - `rst` must be **asserted at the beginning** of the simulation for **three cycles**.\n   - The module must correctly initialize internal registers when `rst` is de-asserted.\n\n3. **Stimulus Generation Strategy:**\n   - The testbench **must not verify outputs** (only generate inputs).\n   - The following test sequences must be executed:\n     - **No Backpressure (50 cycles)**: `dn_rdy` asserted while `up_val` and `up_bus` receive random values.\n     - **Full Backpressure (20 cycles)**: `dn_rdy` de-asserted to stall downstream data flow.\n     - **Random Backpressure (100 cycles)**: `dn_rdy` toggles randomly while `up_val` sends variable data.\n     - **Pipeline Flush (20 cycles)**: Ensure buffered data is correctly forwarded when `dn_rdy` remains asserted.\n     - **Multiple Data Transactions**: Apply various input patterns to check how the module buffers and forwards data.\n     - **Randomized Data Sequences**: Generate multiple upstream and downstream handshake variations.\n     - **Continuous Streaming Mode**: Test without stalls to check smooth data flow.\n     - **Pipeline Stall and Restart**: Temporarily hold `dn_rdy` low and later assert it to observe how the module resumes.\n     - **Edge Case Timing Conditions**: Stress test with fast-changing `up_val` and `dn_rdy` transitions.\n\n4. **Handling Continuous and Edge Cases:**\n   - The testbench must ensure a **full range of data transactions** occur correctly.\n   - **Edge cases of data buffering** must be exercised to verify stall and release conditions.\n\n5. **Waveform Generation:**\n   - The testbench must generate a `.vcd` waveform file to allow waveform analysis.\n\n---\n\n### **Coverage and Compliance**\n\n- The testbench must ensure **high coverage** across all pipeline behaviors and backpressure conditions.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n\n---\n\n### **Test Plan Overview**\n\nThe testbench must ensure **comprehensive RTL coverage** by applying:\n\n- **Valid data transfers** under continuous downstream availability.\n- **Stall conditions** when downstream is blocked.\n- **Randomized test scenarios** for data and handshake signals.\n- **Buffer management validation** under varied input sequences.\n- **Reset handling** to verify asynchronous initialization integrity.\n- **High-frequency toggling of control signals** to test robustness.\n- **Back-to-back input bursts and sporadic handshakes** to assess real-world performance.\n\nThis testbench should provide a **comprehensive input stimulus environment** for `skid_register`, ensuring correct operation under various test conditions.\n\n---\n\n### **Note:**\n- The testbench **must only generate stimulus** without verifying outputs.\n- The **DUT instance name `dut` must be explicitly used** for instantiation.\n- **Ensure the maximum possible input coverage** without adding assertions or comparisons.\n\nCan you implement a **SystemVerilog testbench** with the above stimulus requirements?", "context": {}}, "output": {"response": "", "context": {"verif/tb_skid_register.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    working_dir: /code/rundir\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 4-test-stimulus-generation-for-skid_register\nTARGET = 98 ", "src/coverage.cmd": "report -metrics overall -out coverage.log\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/skid_register.sv": "module skid_register\n  #(parameter DATA_WIDTH = 32)\n(\n    input  wire                     clk,\n    input  wire                     rst,\n\n    // Upstream (source) side\n    input  wire [DATA_WIDTH-1:0]    up_bus,\n    input  wire                     up_val,\n    output reg                      up_rdy,\n\n    // Downstream (sink) side\n    output reg  [DATA_WIDTH-1:0]    dn_bus,\n    output reg                      dn_val,\n    input  wire                     dn_rdy\n);\n\n    // Internal regs/wires\n    reg  [DATA_WIDTH-1:0]   skid_bus;   // Skid\u2010buffered data\n    reg                     skid_val;   // True if skid_bus holds valid data\n    wire                    dn_active;  // True if we can move data into dn_bus\n    wire                    dn_val_i;   // The \"next\" valid going into dn_val\n    wire [DATA_WIDTH-1:0]   dn_bus_i;   // The \"next\" data going into dn_bus\n\n    // Downstream \"active\" logic\n    assign dn_active = ~dn_val | dn_rdy;\n\n    // Upstream ready logic\n    always @(posedge clk) begin\n        if (rst) begin\n            up_rdy <= 1'b1; \n        end\n        else begin\n            up_rdy <= dn_active;\n        end\n    end\n\n    // Skid\u2010bus and skid\u2010val tracking\n    always @(posedge clk) begin\n        if (rst) begin\n            skid_val <= 1'b0;\n        end \n        else begin\n            skid_val <= dn_val_i & ~dn_active;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            skid_bus <= {DATA_WIDTH{1'b0}};\n        end \n        else if (~dn_active & dn_val_i) begin\n            skid_bus <= dn_bus_i;\n        end\n    end\n\n    // Mux logic: direct or skid\u2010buffered\n    assign dn_bus_i = up_rdy ? up_bus : skid_bus;\n    assign dn_val_i = up_rdy ? up_val : skid_val;\n\n    // Downstream valid/data\n    always @(posedge clk) begin\n        if (rst) begin\n            dn_val <= 1'b0;\n        end\n        else if (dn_active) begin\n            dn_val <= dn_val_i;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dn_bus <= {DATA_WIDTH{1'b0}};\n        end\n        else if (dn_active) begin\n            dn_bus <= dn_bus_i;\n        end\n    end\n\nendmodule\n"}}}
{"id": "cvdp_copilot_sobel_filter_0015", "categories": ["cid012", "easy"], "input": {"prompt": "Write a SystemVerilog testbench for a Sobel filter module named `sobel_filter` that performs edge detection on a stream of pixel data. The Sobel filter calculates the gradient magnitude using a 3x3 pixel window and determines whether the edge strength exceeds a predefined threshold `THRESHOLD`. The testbench should only provide stimuli for the design across various input scenarios, including edge cases, and ensure proper synchronization of different input signals.\n\n#### Inputs:\n- `clk`: Clock signal for synchronization. The design is synchronized to the positive edge of this clock.\n- `rst_n`: Active-low asynchronous reset. Clears internal buffers, counters, and outputs.\n- `pixel_in [7:0]`: 8-bit input pixel data.\n- `valid_in`: An active-high signal that indicates the validity of the `pixel_in` data.\n\n#### Outputs:\n- `edge_out [7:0]`: 8-bit output indicating the presence of an edge (255 for an edge, 0 otherwise).\n- `valid_out`: An active-high signal that indicates when `edge_out` is valid.\n\n### Overview of the Design:\n\nThe Sobel filter detects edges in an image by first computing the gradients in the horizontal (`Gx`) and vertical (`Gy`) directions, then calculating the gradient magnitude (`|Gx| + |Gy|`) and comparing it to a threshold to determine whether a pixel is part of an edge. The `THRESHOLD` is set to a default value of 128, which defines the threshold for edge detection. Pixels with gradient magnitudes greater than this value are classified as edges.  \n\nA 3x3 window of pixels is sent as a continuous stream of inputs through `pixel_in`, and `valid_in` remains high while pixels are supplied. The module uses a 3x3 buffer to store pixel data, ensuring it only outputs valid results (`valid_out` and `edge_out`) once the buffer is fully populated with 9 pixels. Pixels are shifted sequentially to store new incoming pixels. (The input is sent row by row, left to right. Starting from the top row, the traversal proceeds to the bottom row.) The filter performs convolution when the buffer is fully populated and outputs the result. After processing each window, the module clears the buffer and waits for the next set of 9 pixels. The buffer is also cleared when reset is asserted. Assume that the handling of overlapping windows is handled externally, and this design processes each window as a new one (no storing of pixels from the previous window).\n\n---\n\n### Testbench Requirements:\n\n#### Module Instantiation:\n- The Sobel filter module should be instantiated as `dut`, with all input and output signals properly connected. The testbench must cover all possible input scenarios to achieve 100% coverage. \n\n#### Input Stimulus Generation:\n1. **Pixel Stream Generation:**\n   - The testbench should generate a stream of 8-bit pixel values (`pixel_in`) and assert `valid_in` when pixel data is valid.\n   - Include edge cases like:\n     - Uniform pixel values (all zeros, all maximum values).\n     - Pixel gradients (e.g., increasing or decreasing values across the 3x3 window).\n     - Random pixel values to simulate real-world scenarios.\n2. **Synchronization:**\n   - The RTL design maintains a continuous stream of valid pixels by monitoring the assertion of `valid_in`. When `valid_in` remains consistently asserted after a full window is completed, the module resets the count and begins loading a new set of pixels. Therefore, the test case must be designed to reset `valid_in` after loading a 3\u00d73 block of pixels and also to continuously assert `valid_in` for multiple input windows. Additionally, it should be capable of resetting `valid_in` mid-stream to cover all possible scenarios.\n3. Reset Testing:\n- Set the reset (`rst_n`) to clear all internal states (e.g., pixel buffer, counters, outputs) between input windows to create a scenario where the module receives inputs after the reset is de-asserted.", "context": {}}, "output": {"response": "", "context": {"verif/sobel_filter_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 15bb4ff89afa86ec54a214f623981f68bbfe5ac9\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/sobel_filter.sv": "module sobel_filter (\n    input   logic           clk,\n    input   logic           rst_n,\n    input   logic   [7:0]   pixel_in,\n    input   logic           valid_in,\n    output  logic   [7:0]   edge_out,\n    output  logic           valid_out\n);\n \n    logic signed [10:0]  Gx, Gy; \n    logic        [7:0]   pixel_buffer  [8:0]; \n    logic        [3:0]   pixel_count; \n    localparam THRESHOLD = 11'd128;\n    integer i;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        for ( i = 0; i < 9; i = i + 1) begin\n            pixel_buffer[i] <= 8'd0;\n        end\n    end else if (valid_in) begin\n        for ( i = 8; i > 0; i = i - 1) begin\n            pixel_buffer[i] <= pixel_buffer[i-1];\n        end\n        pixel_buffer[0] <= pixel_in;\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n       pixel_count <= 4'd0;\n    end else if (valid_in)begin\n        pixel_count <= pixel_count + 1;\n        if (pixel_count == 4'd9) begin\n          pixel_count <= 4'd0;\n        end\n    end else begin\n       pixel_count <= 0;\n    end    \nend\n\nalways @(*) begin    \n    Gx = 11'sd0;\n    Gy = 11'sd0;\n    edge_out = 8'd0;\n    valid_out = 1'b0;\n    if (pixel_count == 4'd9 ) begin\n        valid_out = 1'b1;\n        Gx = (pixel_buffer[0]) + (-(pixel_buffer[2])) + (pixel_buffer[3] << 1) + (-(pixel_buffer[5] << 1)) + (pixel_buffer[6]) + (-pixel_buffer[8]);        \n        Gy = (pixel_buffer[0]) + ((pixel_buffer[1] << 1)) + (pixel_buffer[2]) + (-pixel_buffer[6]) + (-(pixel_buffer[7] << 1)) + (-pixel_buffer[8]);        \n        edge_out = ((Gx < 0 ? -Gx : Gx) + (Gy < 0 ? -Gy : Gy)) > THRESHOLD ? 8'd255 : 8'd0;\n    end \nend\nendmodule"}}}
{"id": "cvdp_copilot_sram_fd_0024", "categories": ["cid012", "easy"], "input": {"prompt": "Generate a SystemVerilog testbench named `cvdp_sram_fd_tb` that only generates stimulus, to systematically drive input signals to a **cvdp_sram_fd** module. The stimulus should comprehensively cover all valid read and write operations with constraints as mentioned below. \n\n---\n\n## Module Overview:\nThe **cvdp_sram_fd** module is a full-duplex, dual-port static RAM (SRAM) with independent read and write access on two separate ports (**Port A** and **Port B**). The memory has a configurable data width (`DATA_WIDTH`) and address width (`ADDR_WIDTH`). \n\n**Key Features:**\n- **Dual-port architecture**: Supports concurrent read/write operations on both ports.\n- **Synchronous operation**: Inputs are sampled on the rising edge of `clk`.\n- **Read-First behavior**: If a read and write happens at the same address in the same cycle, the read returns the old data before the write updates it.\n\n--- \n\n### **Parameters:**\n- `DATA_WIDTH (default: 8)`: Width of the data bus.\n- `ADDR_WIDTH (default: 4)`: Width of the address bus.\n- `RAM_DEPTH`: Determines the depth of the memory. It is derived using the `ADDR_WIDTH` parameter to match the full range of unique addresses possible with the given address width.\n\n### **Ports:**\n\n#### 1. Clock and Control Signal Inputs:\n- `clk`: System clock. All input transitions are synchronized to the **rising edge** of `clk`.  \n- `ce`: Chip enable (active high).\n   -  When `ce` is **low**, the memory ignores all inputs and does not perform read or write operations (`a_rdata` and `b_rdata` are set to zero).\n   -  When `ce` is **high**, the memory operates normally.\n\n#### 2. Port A:\n**Inputs:**\n- `a_we`: Write enable (active high).\n- `a_oe`: Read enable (active high).\n- `a_addr [ADDR_WIDTH-1:0]`: Address bus.\n- `a_wdata [DATA_WIDTH-1:0]`: Write data.\n\n**Output:**\n- `a_rdata [DATA_WIDTH-1:0]`: Read data output.\n\n#### 3. Port B:\n**Inputs:**\n- `b_we`: Write enable (active high).\n- `b_oe`: Read enable (active high).\n- `b_addr [ADDR_WIDTH-1:0]`: Address bus.\n- `b_wdata [DATA_WIDTH-1:0]`: Write data.\n\n**Output:**\n- `b_rdata [DATA_WIDTH-1:0]`: Read data output.\n\n\n#### 4.  Memory Array:\n   - The module consist of an internal memory array `mem` with depth `RAM_DEPTH` and width `DATA_WIDTH`.\n\n#### 5. Operational Behavior:\n\n   - **Port A Operations:**\n     - **Write Operation:**\n       - Occurs when `ce` and `a_we` are high.\n       - The data on `a_wdata` is written to the memory location specified by `a_addr`.\n     - **Read Operation:**\n       - Occurs when `ce` is high,  and `a_oe` is high.\n       - The data from the memory location specified by `a_addr` is loaded into `a_rdata`.\n       - `a_rdata` retains its previous value if `a_oe` is low while `ce` is high\n     - **Priority:**\n       - If both `a_we` and `a_oe` are high, the read operation takes precedence, where data previously stored at the address appears on the output while the input data is being stored in memory.\n     - **Timing:**\n       - **Write Latency:** 1 clock cycle.\n       - **Read Latency:** 1 clock cycle.\n\n   - **Port B Operations:**\n     - This port behaves same as Port A. The signals controlling this port are `b_we`, `b_oe`, `b_addr`, `b_wdata` and the output is driven on `b_rdata`.\n\n#### 6. Simultaneous Access Handling:\n   - The memory supports simultaneous operations on both ports, including:\n     - Reads on both ports.\n     - Writes on both ports.\n     - A read on one port and a write on the other.\n   - **Same Address Access:**\n     - **If both ports access the same address:**\n       - Read and write: Follow a \"read-first\" approach which means that if a write and read occur at the same address simultaneously, data previously stored at the address appears on the output while the input data is being stored in memory.\n       - Reads on both ports: Should be supported with both ports providing the same output data.\n       - It is assumed that the write access will not occur for the same address on both ports together. Such a collision is not handled. \n\n#### 7. Assumptions and Constraints:\n   - All inputs are synchronous and are sampled on the rising edge of `clk`.\n   - Input addresses (`a_addr`, `b_addr`) are within the valid range (`0` to `RAM_DEPTH - 1`).\n   - Data inputs (`a_wdata`, `b_wdata`) are valid when write enables (`a_we`, `b_we`) are high.\n   - If neither read nor write is enabled for a port during a clock cycle (with `ce` high), the port maintains its previous output state.\n\n#### 8. Boundary Conditions:\n - `DATA_WIDTH` and `ADDR_WIDTH` must be positive integers greater than zero.\n\n--- \n\n## **Testbench Requirements:**\n\n### **Module Instantiation:**\nThe **cvdp_sram_fd** module should be instantiated as `DUT`, with all input and output signals properly connected. The testbench must cover all possible scenarios to achieve 100% coverage.\n\n\n### **Stimuli Generation for Dual-Port SRAM Testbench:**  \n\n#### 1. Clock and Enable Control:\n- Generate a continuous clock signal with a period of 10 time units.  \n- Toggle `ce` periodically to simulate active/inactive states.  \n\n#### 2. Address and Data Generation:\n- **Address Sequences**  \n  - Use randomized or structured address sequences for `a_addr` and `b_addr`  for read and write operations.  \n\n- **Data Sequences**  \n  - Generate randomized `a_wdata` and `b_wdata` values.  \n  - Drive valid data only when write enable (`a_we`, `b_we`) is high.  \n\n#### 3. Different Scenarios:\n\n- **A.Independent Operations**\n  - **Single Port Write-Read:** Generate stimuli for Port A to write to a given address and read from the same address after the write is complete. Perform the same operation on port B\n\n- **B. Simultaneous Operations**  \n  - **Simultaneous Writes:** \n      - Generate stimuli to simultaneously write and read from the same port and from the same address.  \n      - Generate stimuli to simultaneously write from one port and read from the other at the same address.  \n      - Generate stimuli to simultaneously write from one port and read from the other at different addresses. \n\n- **C. Special Cases**  \n  - **Boundary Testing:** Generate stimuli to write at minimum (`0`) and maximum (`RAM_DEPTH-1`) addresses.  \n  - **Chip Enable Disabled:** Generate stimuli for `ce = 0`.  \n  - **Chip Enabled with no operation:** Generate stimuli for `ce = 1` with no read/write operations on either port. \n\n---\n\n**Expected Output:** \n\nA SystemVerilog testbench that generates varied input stimuli for the **cvdp_sram_fd** module according to the above specifications and allows different corner cases for extended testing scenarios. ", "context": {}}, "output": {"response": "", "context": {"verif/cvdp_sram_fd_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 24-tb-stimulus-sram_fd\nTARGET = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/cvdp_sram_fd.sv": "/**************************************************************************\nFILENAME:    cvdp_sram_fd.sv\nDESCRIPTION: This file contains the RTL for a full-duplex dual-port RAM in SystemVerilog.\nLATENCY:     Write latency = 1 clk cycle\n             Read  latency = 1 clk cycle\n**************************************************************************/\nmodule cvdp_sram_fd #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 4\n)(\n    input                         clk     , // clock input\n    input                         ce      , // chip enable\n    input                         a_we    , // channel A write enable\n    input                         a_oe    , // channel A output enable\n    input        [ADDR_WIDTH-1:0] a_addr  , // channel A address\n    input        [DATA_WIDTH-1:0] a_wdata , // channel A write data\n    output logic [DATA_WIDTH-1:0] a_rdata , // channel A read data out\n    input                         b_we    , // channel B write enable\n    input                         b_oe    , // channel B output enable\n    input        [ADDR_WIDTH-1:0] b_addr  , // channel B address\n    input        [DATA_WIDTH-1:0] b_wdata , // channel B write data\n    output logic [DATA_WIDTH-1:0] b_rdata   // channel B read data out\n);\n    // Setup RAM_DEPTH parameter\n    localparam RAM_DEPTH = 1 << ADDR_WIDTH;\n    // Memory array\n    logic [DATA_WIDTH-1:0] mem [0:RAM_DEPTH-1];\n    // Channel A operations\n    always_ff @(posedge clk) begin\n        if (ce) begin\n            if (a_oe) begin\n                a_rdata     <= mem[a_addr];\n            end\n            if (a_we) begin\n                mem[a_addr] <= a_wdata;\n            end\n        end else begin\n            a_rdata         <= 'b0;\n        end\n    end\n    // Channel B operations\n    always_ff @(posedge clk) begin\n        if (ce) begin\n            if (b_oe) begin\n                b_rdata     <= mem[b_addr];\n            end \n            if (b_we) begin\n                mem[b_addr] <= b_wdata;\n            end\n        end else begin\n            b_rdata         <= 'b0;\n        end\n    end\nendmodule", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/cvdp_sram_fd.sv /code/verif/cvdp_sram_fd_tb.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"DUT\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\""}}}
{"id": "cvdp_copilot_static_branch_predict_0035", "categories": ["cid012", "medium"], "input": {"prompt": "Create a SystemVerilog testbench module named `tb_static_branch_predict` that instantiates the `static_branch_predict` module as the Unit Under Test (UUT). The testbench must include a stimulus generator that systematically drives various input conditions to achieve a minimum of 95% code and functional coverage for the `static_branch_predict` module.  The `static_branch_predict` takes a 32-bit branch or jump RISC-V instruction as input and predicts whether that branch will occur based on the conditions indicated in the instruction.\n\n## Design Specification:\nThe `static_branch_predict` module takes in a 32-bit RV32I (RISC V 32-bit base Integer ISA) conditional branch and unconditional jump instructions as input. This module generally exists as part of the Instruction Fetch Stage of a pipelined processor. The branch and jump instruction can be either from the RV32I Instruction Set or from the RV32C Instruction Set. The branch and jump instructions as part of the RV32I Instruction Set are 32-bit in width, whereas those belonging to the RV32C Instruction Set are 16-bit in width. The 16-bit RV32C branch and jump instructions are converted into an equivalent 32-bit RV32I instruction using a specialized circuit called Instruction Decompresser before being applied to this module. For the module to recognize the 32-bit equivalent of the 16-bit branch and jump instructions, the inputs are properly formatted into a 32-bit value and applied. The Instruction Decompresser is not instantiated into the branch predictor module. Based on the instruction's offset in the case of the branch instruction and based on instruction in the case of a jump instruction, the branch predictor outputs two signals (i) a 1-bit signal to indicate whether the branching will occur for a given instruction or not (ii) If branching occurs, to which 32-bit address it has to get branched.\n\n## Key Assumptions and Constraints:\n- Only uncompressed 32-bit instructions are applied as input to this module.\n- The module operates in a purely combinational manner without requiring any state elements such as registers.\n- The Instruction Decompressor is outside the scope of this module, and the equivalent 32-bit uncompressed instruction is \n  given as input.\n\n### Introduction to RISC V:\nRISC-V is a royalty-free open-source instruction set architecture, which anyone can utilize to implement a processor microarchitecture (i.e. processor hardware). The RISC-V ISA consists of three variants of Integer ISA namely RV32I (32-bit instructions to handle 32-bit data), RV64I (32-bit instructions to handle 64-bit data), and RV128I (32-bit instructions to handle 128-bit data). In addition to these, there are 14 extensions. One of the extensions that will be considered in this module is RV32C (16-bit ISA called Compressed RISC-V ISA)\n\n## RV32I Branch and Jump Instructions\nThe RISC-V RV32I instruction set includes both unconditional jump and conditional branch instructions. Below, we describe the encodings and behaviors for these types of instructions.\n### Unconditional Jump Instructions(JAL and JALR)\n`JAL` (Jump and Link instruction):\n    -  Branches to an address obtained by adding the 32-bit program counter (pc) to a sign-extended 20-bit offset encoded in the instruction.\n    -  Returns to resume execution from the address stored in the 32-bit link register (x1 or x5) after completing the branched subroutine. A link register (also called a return address register) is the one that holds the address from where the processor has to resume its execution after returning from a subroutine. \n**Instruction Encoding**:\n\n**|   31 -  imm[20]   |    30:21 - imm[10:1]    |     20 - imm[11]       |       19 : 12 - imm[19:12]      | 11 : 7 - rd   | 6 : 0  - 7'h6F   |**\n\n            \nAssembler syntax for JAL instruction :  jal  rd ,  imm[20:1]\n           \nTarget Address  calculated for this instruction : \n\nrd <--- pc + {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 };\n\nwhere {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 } - 32-bit sign extended offset or immediate. \nHere, `rd` is a 5-bit number to identify the 32-bit destination register; `pc` - 32-bit program counter.\n  \n`JALR` (Jump and Link Register instruction): \n - Branches to an address obtained by adding the 32-bit program counter to a sign-extended 12-bit offset present in a register specified in the instruction.\n\nThe instruction encoding for 32-bit uncompressed JALR instruction \n**Instruction Encoding**:\n \n**|   31 :20 -  imm[11:0]   |    19:15 - rs1   |     14:12 - 000      |      11 : 7 - rd      | 11 : 7 - rd   | 6 : 0  - 7'h67   |**             \n            \nAssembler syntax for JAL instruction:  jalr  rd,  rs1, imm[11:0]  \n\nTarget address calculated for this instruction : \nrd <-pc + {{20{instr[31]}}, instr[31:20]} + rs1\n                           \nwhere \n {{20{instr[31]}}, instr[31:20]} + rs1 - 32-bit sign extended offset or immediate                          \nHere `rd` is the 5-bit number to identify a 32-bit destination register; `rs1` is the 5-bit number to identify the 32-bit source register; `pc` - 32-bit program counter\n                           \n### Conditional Branch Instructions (BXXX) :\n  - Takes in two operands (rs1 and rs2), compares them, and branches based on the comparison result.\n  - The target address is obtained by adding the pc to a sign-extended 12-bit offset encoded in the instruction.\n\n The instruction encoding for the 32-bit uncompressed Branch instruction\n\n**Instruction Encoding**:\n \n**| 31 -  imm[12]|30:25 - imm[10:5]|24:20 - rs2 | 14 : 12 - func3| 11 : 8 -  imm[4:1]|7 - imm[11]| 6 : 0  - 7'h63   |**          \n      \nAssembler syntax for Branch instruction:  bxxx rs1, rs2, offset\n        \nHere `rs1` and `rs2`  are the 5-bit numbers to identify the 32-bit source registers which will be used for comparison\n        \nTarget address calculated for this instruction : \npc + { {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 };\n\nwhere,\n{ {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 } - 32-bit sign extended offset or immediate; `pc` - 32-bit program counter\n\nThe different types of branch instruction :\n- beq       rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b000)\n- bne       rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b001)\n- blt         rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b100)\n- bltu       rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b110)\n- bge       rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b101)\n- bgeu     rd , rs1 , rs2 , imm[12:1]  (func3 = 3'b111)\n                               \n ## RV32C Branch and Jump Instructions :\n The RV32C compressed instructions are 16-bit wide, but before applying them to this module, they are converted to their equivalent 32-bit uncompressed form using an external decompressor circuit. The following sections describe how these instructions are handled.\n \n   \n ### C.J / C.JAL Instructions: \n  - Equivalent to the RV32I JAL instruction, with different function codes.\n    \nThe instruction encoding for the 16-bit compressed jump instruction is given below:\n**Instruction Encoding**:\n**| 15 : 13 - func3 | 12:2- imm[11:1]| 1 : 0 - 01 |**              \n  \nAssembler syntax for C.J  instruction:   c.j offset[11:1]\nAssembler syntax for C.JAL instruction:  c.jal offset [11:1]\n             \n`func3` is a 3-bit code that differentiates between C.J and C.JAL instruction.\nThe 3-bit function code for C.J is 101 and C.JAL is 001.\n  \nIts equivalent 32-bit uncompressed instruction encoding is given by :\n**Instruction Encoding**:\n \n**| 31  -  instr_c[12] | 30 -instr_c[8] | 29 : 28 - instr_c[10:9]| 27 -  instr_c[6]| 26-  instr_c[7]| 25 - instr_c[2] | 24- instr_c[11]|**\n\n**| 23 :  21 -  instr_c[5:3]  | 20 : 12  - {9{instr_c[12]}}| 11 : 8 - 4'b0000 | 7 - ~instr_c[15] | 6 : 0 - 7'h6F   |**              \n   \n   Only C.J and C.JAL instructions are supported by this module.\n   \n   Other Compressed Jump Instructions that RV32C supports are C.JR and C.JALR, but these are not being tested by the module.\n   \n### C.BEQZ / C.BNEZ Instructions:\n\nEquivalent to the RV32I BXXX instructions but check whether the content of the specified register(rs1') is zero or not.\n                                               \nThe instruction encoding for the 16-bit compressed branch instruction is given below:\n**Instruction Encoding**:\n**| 15 : 13 - func3 | 12 : 10 - imm[8:6]    | 9 : 7 - rs1'  | 6 : 3 -  imm[4:1]| 2 -  imm[5]| 1 : 0 - 01  |**\n\n- func3 is a 3-bit code that differentiates between C.BEQZ and C.BNEZ instruction\n- The 3-bit function code for Compressed Branch EQual Zero (C.BEQZ) is 110 and that of Compressed Branch Not \n   Equal Zero (C.BNEZ) is 111\n \n Assembler syntax for C.BEQZ instruction:  c.beqz rs1' , offset[8:1]\n Assembler syntax for C.BNEZ instruction:  c.bnez rs1', offset[8:1]\n          \n Its equivalent 32-bit uncompressed instruction encoding is given by :\n**Instruction Encoding**:\n**| 31 : 28 - {4{instr_c[12]}} | 27 : 26 - instr_c[6:5] | 25 - instr_c[2]| 24 : 20 - 5'b00000 | 19 : 18 - 2'b01 | 17 : 15 - instr_c[9:7] |**\n\n**| 14 :  13 - 2'b00  | 12  - instr_c[13] | 11 : 10 -  instr_c[11:10] | 9 : 8 - instr_c[4:3] | 7 -  instr_c[12]  | 6 : 0 - 7'h63  |**\n\n### Only Supported Instructions\n- The following instructions are supported by this module:\n\n  - Uncompressed Instructions: JAL, JALR, BXXX.\n  - Compressed Instructions: C.J, C.JAL, C.BEQZ, C.BNEZ.\n  - For all other instructions, fetch_valid_i will be 0, indicating that they will not be predicted as taken.\n\n\n \n### Concept of Sign Extension of Immediate(or Offset) in the RISC V Control Transfer Instruction :\n\nSign extension refers to identifying the sign bit of an operand and replicating it at the higher significant positions to increase the operand width to the desired value.\nIllustration :\nSuppose there is 8-bit data, data[7:0], say 8'b0110_1110. Suppose this has to be stored in a 32-bit register rd.\n\n\n| Bit Position : Bit Value    | 7 : 0  | 6 : 1  | 5 : 1  | 4: 0  | 3 : 1  | 2 : 1  | 1 : 1 | 0 : 0 |\n                \nHere the bit at position 7 is called sign-bit; Since it is 0, it indicates that it is a positive value. Hence, will be replicated in the higher 24-bit positions (i.e. from bit position 8 to bit position 31) to form a 32-bit value. This is represented in shorthand as\n                                                      rd <---  {{24{0}} , data_i[7:0]};\n                                                      \n### Static Branch Prediction Algorithm :\n### For Branch Instruction:\n- Immediate Extraction:\n    Extract the immediate value from the branch instruction.\n- Sign Extension:\n    Sign extend the immediate to 32 bits.\n- Prediction Logic and Target Address Calculation:\n   If the sign bit of the immediate is 1, the branch is predicted to be taken.\n   Otherwise, it is predicted as not taken.\n   The 32-bit program counter is added to the sign-extended offset or sign-extended immediate to form the target address\n\n### For Jump Instruction:\n- Immediate Extraction:\n   Extract the immediate value from the jump instruction.\n- Sign Extension:\n  Sign extend the immediate to 32 bits.\n- Prediction Logic and Target Address Calculation:\n   Always predict jumps (JAL, JALR, C.J, C.JAL) as taken.\n   The 32-bit program counter is added to the sign-extended offset or sign-extended immediate to form the target address\n\n## What do the words `taken` and `not-taken` signify in case of branch prediction :\n- Taken: The branch will occur, and execution will continue at the target address.   \n- Not-Taken: The branch will not occur, and execution continues sequentially.\n\n### Interface :\n\n#### Inputs:\n- `fetch_rdata_i` ([31:0], 32-bit): The fetched instruction data from the instruction memory or pipeline.\n- `fetch_pc_i` ([31:0], 32-bit): Program counter (PC) value of the fetched instruction.\n- `fetch_valid_i` (1-bit): Active HIGH Indicates the validity of the fetched instruction.\n\n#### Outputs:\n- `predict_branch_taken_o` (1-bit): Active HIGH indicates whether the branch or jump is predicted as taken.\n- `predict_branch_pc_o` ([31:0], 32-bit): Predicted target address for a taken branch or jump instruction\n\n### Internal registers and parameters:\n\n#### Localparams :\n -  OPCODE_BRANCH = 7'h63\n -  OPCODE_JAL          = 7'h6F;\n -  OPCODE_JALR       = 7'h67;\n\n#### Immediate:\n- `imm_j_type` ([31:0], 32-bit): Immediate for uncompressed jump (JAL) instructions, sign-extended.\n- `imm_b_type` ([31:0], 32-bit): Immediate for uncompressed branch instructions, sign-extended.\n- `imm_cj_type` ([31:0], 32-bit): Immediate for compressed jump instructions, sign-extended.\n- `imm_cb_type` ([31:0], 32-bit): Immediate for compressed branch instructions, sign-extended.\n- `branch_imm` ([31:0], 32-bit): One of the immediate values: `imm_j_type` or `imm_b_type` or `imm_cj_type` or `imm_cb_type`.\n\n### Signals and Logic :\n#### Control Signals:\n- `instr` ([31:0], 32-bit): Alias for the input `fetch_rdata_i` to simplify the code.\n- `instr_j`, `instr_b`, `instr_cj`, `instr_cb` (1-bit each): Signals to identify specific branch or jump types in compressed and uncompressed formats.\n- `instr_b_taken` (1-bit): Indicates whether an uncompressed or compressed branch offset is negative, implying that the branch is taken.\n\n**Instantiation** :\nThe testbench instantiates the `static_branch_predict` module as `uut` and connects the signals between the module and the testbench. Each input and output from the `uut` is connected to its corresponding signal in the testbench.\n\n## **Input Generation and Validation**:\n- Stimulus: Several test cases must be applied to simulate various operations of the static branch predictor. These test cases should cover a range of scenarios, including branch instructions with positive and negative offsets, jump instructions (both JAL and JALR), compressed jump and branch instructions, as well as invalid fetch conditions and non\u2010branch operations. For each case, the relevant signals (`predict_branch_taken_o`, `predict_branch_pc_o`) have to be displayed immediately after the application of inputs (`fetch_rdata_i`, `fetch_pc_i`, `register_addr_i`, `fetch_valid_i`).\n\n- **Test Case 1: Branch taken, PC offset negative (B-type) [BEQ]**\nTest a BEQ instruction with a negative offset, expecting the branch to be taken with the target PC computed accordingly.\n\n- **Test Case 2: Branch taken, PC offset positive (B-type) [BEQ]**\nTest a BEQ instruction with a positive offset, ensuring correct branch prediction and target PC calculation for a forward branch.\n\n- **Test Case 3: Jump taken (J-type) with negative offset [JAL]**\nApply a JAL instruction with a negative offset to validate that the jump is correctly predicted and the computed PC reflects a backward jump.\n\n- **Test Case 4: Jump taken (J-type) with positive offset [JAL]**\nUse a JAL instruction with a positive offset to verify the proper prediction of a forward jump with the correct target PC.\n\n- **Test Case 5: Jump with valid false (JAL)**\nApply a JAL instruction with fetch_valid_i deasserted, ensuring that no branch prediction is produced.\n\n- **Test Case 6: Jump Register (JALR) taken with negative offset (reg = 0) [JALR]**\nTest a JALR instruction with a negative offset using a zero register operand to confirm correct target PC computation.\n\n- **Test Case 7: Jump Register (JALR) taken with positive offset (reg = 0) [JALR]**\nTest a JALR instruction with a positive offset using a zero register operand.\n\n- **Test Case 8: Jump Register (JALR) taken with negative offset (nonzero reg) [JALR]**\nApply a JALR instruction with a negative offset using a nonzero register operand to exercise immediate addition.\n\n- **Test Case 9: Jump Register (JALR) taken with positive offset (nonzero reg) [JALR]**\nApply a JALR instruction with a positive offset using a nonzero register operand to verify proper computation.\n\n- **Test Case 10: Jump Register (JALR) with valid false [JALR]**\nTest a JALR instruction with fetch_valid_i deasserted, ensuring no prediction is produced.\n\n- **Test Case 11: Compressed Jump taken (C.J) with positive offset [C.J]**\nTest a compressed jump instruction with encoding 3'b101 and bit12 = 0, yielding a positive immediate for jump target calculation.\n\n- **Test Case 12: Compressed Jump taken (C.J) with negative offset [C.J]**\nTest a compressed jump instruction with encoding 3'b001 and bit12 = 1, producing a negative immediate for a backward jump.\n\n- **Test Case 13: Compressed Branch not taken (C.BEQZ) with 3'b110 encoding [C.BEQZ]**\nTest a compressed branch instruction with encoding 3'b110 and bit12 = 0, expecting the branch not to be taken.\n\n- **Test Case 14: Compressed Branch taken (C.BEQZ) with 3'b110 encoding [C.BEQZ]**\nTest a compressed branch instruction with encoding 3'b110 and bit12 = 1, expecting the branch to be taken.\n\n- **Test Case 15: Compressed Branch not taken (C.BEQZ) with 3'b111 encoding [C.BEQZ]**\nTest a compressed branch instruction with encoding 3'b111 and bit12 = 0, ensuring the branch is not taken.\n\n- **Test Case 16: Compressed Branch taken (C.BEQZ) with 3'b111 encoding [C.BEQZ]**\nTest a compressed branch instruction with encoding 3'b111 and bit12 = 1, expecting the branch to be taken.\n\n- **Test Case 17: Default non\u2010branch (zero instruction)**\nApply an all\u2011zeros instruction to verify that no branch or jump is predicted.\n\n- **Test Case 18: Default non\u2010branch (random instruction)**\nApply a random non\u2011branch instruction, confirming that the predictor remains inactive.\n\n- **Test Case 19: Default non\u2010branch with valid false**\nApply a non\u2011branch instruction with 1fetch_valid_i1 deasserted, ensuring no prediction occurs.\n\n- **Test Case 20: Default non\u2010branch (all ones)**\nApply an instruction of all ones, verifying default non\u2011branch behavior.\n\n- **Test Case 21: Default non\u2010branch (instruction with lower 2 bits \u2260 01)**\nTest an instruction that does not meet the compressed instruction format, confirming non\u2011branch operation.\n\n- **Test Case 22: Default non\u2010branch (random pattern)**\nApply a random instruction that does not correspond to any branch or jump, ensuring default behavior.\n\n- **Test Case 23: Default non\u2010branch (random pattern with valid false)**\nApply a random non\u2011branch instruction with fetch_valid_i deasserted.\n\n- **Test Case 24: Custom JAL with positive immediate [JAL custom]**\nTest a custom JAL instruction with a positive immediate (with instr[31] = 0) to verify proper immediate generation.\n\n- **Test Case 25: Custom JAL with negative immediate [JAL custom]**\nTest a custom JAL instruction with a negative immediate (with instr[31] = 1).\n\n- **Test Case 26: Custom JALR with positive immediate [JALR custom]**\nTest a custom JALR instruction with a positive immediate (with instr[31] = 0).\n\n- **Test Case 27: Custom JALR with negative immediate [JALR custom]**\nTest a custom JALR instruction with a negative immediate (with instr[31] = 1).\n\n- **Test Case 28: Custom BEQ with positive offset [BEQ custom]**\nTest a custom BEQ instruction with a positive offset (with instr[31] = 0) to verify correct prediction.\n\n- **Test Case 29: Custom BEQ with negative offset [BEQ custom]**\nTest a custom BEQ instruction with a negative offset (with instr[31] = 1).\n\n- **Test Case 30: Custom Compressed Jump with varied immediate [CJ custom]**\nTest a custom compressed jump instruction (CJ) with varied immediate fields (using encoding 3'b101).\n\n- **Test Case 31: Custom Compressed Branch taken [CB custom]**\nTest a custom compressed branch instruction (CB) with encoding 3'b110 and bit12 = 1, expecting the branch to be taken.\n\n- **Test Case 32: Custom Compressed Branch not taken [CB custom]**\nTest a custom compressed branch instruction (CB) with encoding 3'b110 and bit12 = 0, expecting the branch not to be taken.\n\n- **Test Case 33: JALR with large register operand**\nTest a JALR instruction with a large register operand to exercise potential arithmetic overflow in immediate addition.\n\n- **Test Case 34: Default non\u2010branch (pattern with lower 2 bits \u2260 01)**\nApply a default instruction pattern where the lower two bits are not 01, confirming non\u2011branch operation.\n\n- **Test Case 35: JALR with nonzero register and valid false**\nTest a JALR instruction with a nonzero register operand but with fetch_valid_i deasserted, ensuring no prediction is produced.\n\n- **Test Case 36: Default case with non\u2011matching compressed encoding**\nApply an instruction with lower 2 bits equal to 01 and bits [15:13] that do not match any CJ or CB encoding, thereby exercising the default branch in the case statement.\n\n- **Test Case 37: JALR with register operand causing potential overflow**\nTest a JALR instruction with a register operand that may cause arithmetic overflow during the immediate addition.\n\n- **Test Case 38: JALR with positive offset and register causing overflow**\nTest a JALR instruction with a positive offset and a register value that leads to overflow in addition.\n\n- **Test Case 39: Custom JAL with varied immediate fields**\nTest a custom JAL instruction specifically constructed to exercise the full concatenation of the JAL immediate fields.\n\n- **Test Case 40: JALR with negative register operand**\nTest a JALR instruction with a negative (two\u2019s complement) register operand to further verify the immediate addition in JALR.\n\n- **Test Case 41: BEQ with valid false**\nApply a BEQ instruction with fetch_valid_i deasserted to ensure that even a branch instruction is suppressed.\n\n- **Test Case 42: Compressed Branch with valid false**\nApply a compressed branch instruction (CB) with fetch_valid_i deasserted, ensuring no branch prediction is produced.\n\n- **Test Case 43: Default branch (non\u2011matching compressed encoding)**\nTest an instruction with lower 2 bits equal to 01 and bits [15:13] equal to 000\u2014which does not match any CJ or CB encoding\u2014ensuring that the default branch in the case statement is exercised.\n\n- **Test Case 44: JALR with minimal nonzero register operand**\nTest a JALR instruction with a minimal nonzero register operand to confirm proper handling of small register values.\n\n- **Test Case 45: Compressed Jump taken (C.J) with negative offset [C.J]**\nTest a compressed jump instruction with encoding 3'b101 and bit12 = 1, forcing a negative immediate for a backward jump.\n\n- **Test Case 46: Custom Compressed Branch with unique immediate fields**\nTest a custom compressed branch (CB) instruction with unique immediate field settings to exercise additional bit slices in CB decoding.\n\n- **Test Case 47: Custom Compressed Jump with unique immediate fields**\nTest a custom compressed jump (CJ) instruction with unique immediate field values to cover remaining combinational logic in CJ decoding.\n\n- **Test Case 48: Custom Compressed Jump with unique immediate fields (CJ)**\nTest a custom compressed jump (CJ) instruction\u2014crafted from a 16\u2010bit pattern (0x2D6D extended to 32 bits)\u2014that specifically sets the lower 2 bits to 01, bits [15:13] to 001, and forces distinct values in bits [12], [11], [10:9], [8], and the lower nibble.\n\n\n## Module Functionality: \n#### Combinational Logic\n- `Immediate Extraction`: The immediate branches and jumps are extracted from the instruction, with an appropriate sign extension based on the instruction type.\n- `Instruction Type Decoding`: Decodes whether the instruction is an uncompressed branch (instr_b), an uncompressed jump (instr_j), a compressed branch (instr_cb), or a compressed jump (instr_cj) based on opcode and bit patterns.\n- `Target Address Calculation`: Determines the branch offset and computes the target PC for the predicted branch or jump.\n\n#### Branch Prediction:\n\n-  `Uncompressed Branch/Jump Detection`: Detection of uncompressed instructions (JAL, JALR, BXXX) uses opcode\n   matching to identify the instruction type.\n\n- `Compressed Branch/Jump Detection`: Compressed branch/jump instructions (C.J, C.JAL, C.BEQZ, C.BNEZ) are provided\n  in their 32-bit uncompressed form. This module directly uses opcodes and fields from the uncompressed equivalent\n  to determine the offset and perform the prediction.\n  \n- `Offset-Based Prediction ': Branches are predicted as taken if the offset is negative. These predictions are assigned to \n   the signal `instr_b_taken`.\n\n\n#### Branch or Jump Prediction:\n\n- For jumps (`instr_j`, `instr_cj`), the module always predicts the instruction as taken.\n- For branches, the module uses the `instr_b_taken` signal to decide.\n\n#### Output Prediction Logic:\n\n- `predict_branch_taken_o` is asserted(active-high) if the instruction is predicted to be taken.\n- `predict_branch_pc_o` is calculated by adding `fetch_pc_i` to `branch_imm`, giving the predicted target address.", "context": {}}, "output": {"response": "", "context": {"verif/tb_static_branch_predict.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 670d5442d1727a032598e6d80037688df979ac70\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/static_branch_predict.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n        \n        \n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n", "src/static_branch_predict.sv": "module static_branch_predict (\n  \n  // Instruction from fetch stage\n  input  logic [31:0] fetch_rdata_i,\n  input  logic [31:0] fetch_pc_i,\n  input  logic [31:0] register_addr_i,\n  input  logic        fetch_valid_i,\n\n  // Prediction for supplied instruction\n  output logic        predict_branch_taken_o,\n  output logic [31:0] predict_branch_pc_o\n);\n  logic [31:0] reg_addr;\n  logic [31:0] imm_jal_type;\n  logic [31:0] imm_jalr_type;\n  logic [31:0] imm_b_type;\n  logic [31:0] imm_cj_type;\n  logic [31:0] imm_cb_type;\n\n  logic [31:0] branch_imm;\n\n  logic [31:0] instr;\n\n  logic instr_jal;\n  logic instr_jalr;\n  logic instr_b;\n  logic instr_cj;\n  logic instr_cb;\n\n  logic instr_b_taken;\n  \n    \n  localparam OPCODE_BRANCH = 7'h63;\n  localparam OPCODE_JAL    = 7'h6F;\n  localparam OPCODE_JALR   = 7'h67;\n\n  \n  assign instr = fetch_rdata_i;\n  assign reg_addr = register_addr_i;\n\n  assign imm_jal_type = { {12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 };\n  assign imm_jalr_type = {{20{instr[31]}}, instr[31:20]}+reg_addr;\n  assign imm_b_type = { {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 };\n\n  \n  assign imm_cj_type = { {20{instr[12]}}, instr[12], instr[8], instr[10:9], instr[6], instr[7],\n    instr[2], instr[11], instr[5:3], 1'b0 };\n\n  assign imm_cb_type = { {23{instr[12]}}, instr[12], instr[6:5], instr[2], instr[11:10],\n    instr[4:3], 1'b0};\n\n  assign instr_b    = instr[6:0] == OPCODE_BRANCH;\n  assign instr_jal  = instr[6:0] == OPCODE_JAL;\n  assign instr_jalr = instr[6:0] == OPCODE_JALR;\n\n  \n  assign instr_cb = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b110) | (instr[15:13] == 3'b111));\n  assign instr_cj = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b101) | (instr[15:13] == 3'b001));\n\n  always_comb begin\n    branch_imm = imm_b_type;\n\n    case(1'b1)\n      instr_jal  : branch_imm = imm_jal_type;\n      instr_jalr : branch_imm = imm_jalr_type;\n      instr_b    : branch_imm = imm_b_type;\n      instr_cj   : branch_imm = imm_cj_type;\n      instr_cb   : branch_imm = imm_cb_type;\n      default    : ;\n    endcase\n  end\n\n  assign instr_b_taken = (instr_b & imm_b_type[31]) | (instr_cb & imm_cb_type[31]);\n  assign predict_branch_taken_o = fetch_valid_i & (instr_jal | instr_jalr | instr_cj | instr_b_taken);\n  assign predict_branch_pc_o    = fetch_pc_i + branch_imm;\nendmodule\n"}}}
{"id": "cvdp_copilot_sync_serial_communication_0009", "categories": ["cid012", "easy"], "input": {"prompt": "Write a SystemVerilog testbench for a `sync_serial_communication_tx_rx` module, which simulates the `tx_block` and `rx_block` modules and performs data transfer operations with a focus on ensuring the proper handling of data values, selection signals(`sel`), and asynchronous resets. The testbench must apply a sequence of test cases to the instantiated RTL module, focusing on data transfer operations.\n\n## Description\n\n**Inputs:**\n\n- `clk`: Clock signal for synchronization. Design works on the posedge of `clk`.\n- `reset_n`: Active-low asynchronous reset signal.\n- `sel [2:0]`:  Controls the data width for the transmitter (TX):\n    - `3'h0:` 0 bits. No transmission happens\n    - `3'h1:` 8 bits. `data_in [7:0]` is the valid data to be transmitted.\n    - `3'h2:` 16 bits. `data_in [15:0]` is the valid data to be transmitted.\n    - `3'h3:` 32 bits. `data_in [31:0]` is the valid data to be transmitted.\n    - `3'h4:` 64 bits. `data_in [63:0]` is the valid data to be transmitted.\n    - Default: 0 bits\n- `data_in [63:0]`: Input data signal.\n\n**Outputs:**\n\n- `data_out [63:0]`: Output data received from the communication module.\n- `done`: Signal indicating transmission completion.\n\n## Module Description\n\nThe `sync_serial_communication_tx_rx` module simulates serial communication behavior with configurable selection modes (`sel`).  \n- **Transmission block(`tx_block`):**\n    - The transmitter(TX) and receiver (RX) operate synchronously, driven by the same clock signal (`clk`) and reset (`reset_n`).\n    - Upon reset (reset_n) became LOW, all internal counters and registers are reset to their initial values.\n    - The transmitter (TX) is responsible for serializing 8, 16, 32, or 64-bit data input based on the `sel` signal and produces serial data.\n    - During data transfer, a gated clock signal serial_clk which operates at the frequency of clk has to be transmitted to the receiver (RX) alongside the serial data. When no data is transmitted, it remains at a fixed logic state of either HIGH or LOW.\n    - The transmitter (TX) generates the serial clock signal serial_clk that is used by both the transmitter (TX) and receiver (RX) for synchronized communication to transmit and receive one bit each during the positive edge of the clock.\n- **Receiver block(`rx_block`):**\n    - Data sampling in the receiver (RX) is valid whenever serial_clk is active.\n    - The `sel` in the RX module receives the same value of sel maintained by the TX module\n    - The receiver (RX) receives the serial data from the transmitter (TX) and reconstructs it into a 64-bit parallel output (`data_out`). \n    - The `data_out` will have the following data based on the `sel` value\n        - If `sel` is 000, `data_out` = 64'h0\n        - If `sel` is 001, `data_out` = {56'h0,data_in[7:0]}\n        - If `sel` is 010, `data_out` = {48'h0,data_in[15:0]}\n        - If `sel` is 011, `data_out` = {32'h0,data_in[31:0]}\n        - If `sel` is 100, `data_out` = data_in[63:0]\n        - default: 64'h0\n    - The `done` signal High indicates the valid output.\n- Reset behavior ensures that the system initializes correctly before starting new data transactions.\n\n## Testbench Requirements\n\n### Module Instantiation:\n\n- The `sync_serial_communication_tx_rx` module should be instantiated as uut, with all input and output signals properly connected. The testbench must achieve **100% coverage** by covering all input cases.\n\n### Input Stimulus Generation\nThe testbench implements task designed to validate a specific functionality:\n\n**drive_data task:**\n- Accepts three integer inputs: sel_mode, range, and data_in_val.\n- Waits for a positive edge of the `clk` signal.\n- Based on sel_mode, assigns different portions of data_in_val to data_in:\n    - If sel_mode == 1, assign the least significant 8 bits ([7:0]).\n    - If sel_mode == 2, assign the least significant 16 bits ([15:0]).\n    - If sel_mode == 3, assign the least significant 32 bits ([31:0]).\n    - If sel_mode == 4, assign the full 64-bit value ([63:0]).\n    - Otherwise, set range_value = 8 and data_in_rand = 64'd0.\n- Assign `data_in` = data_in_val and iterate range times, setting `sel` = sel_mode[2:0] at each iteration, synchronized to `clk`.\n- Wait for the `done` signal to be asserted.\n- Print a message displaying the values of `sel`, `data_in`, `data_out`, and `done`.\n\n**initial block:**\n- Asserts `reset_n` and initializes `data_in` to zero.\n- Calls a reset procedure.\n- Repeats a random test sequence 10,000 times:\n- Randomly selects a sel_value between 1 to 4.\n- Sets range_value and data_in_rand based on sel_value:\n    - **sel_value == 1:** range_value = 8, data_in_rand is a random 7-bit number.\n    - **sel_value == 2:** range_value = 16, data_in_rand is a random 16-bit number.\n    - **sel_value == 3:** range_value = 32, data_in_rand is a random 31-bit number.\n    - **sel_value == 4:** range_value = 64, data_in_rand is a random 64-bit number.\n    - Otherwise, range_value = 8, data_in_rand = 64'd0.\n- Calls the `drive_data` task with the generated values.\n- Calls the reset procedure.\n- After completion, waits **100 ns** and terminates the simulation.\n\nCan you implement a SystemVerilog testbench with the above specifications to thoroughly validate the task?", "context": {}}, "output": {"response": "", "context": {"verif/sync_serial_communication_top.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n   xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH            = b372e535ca8d53442368e0b4a1243fd3fa001576\nTARGET          = 100\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/sync_serial_communication_top.sv /code/verif/sync_serial_communication_top.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n    metrics = {}\n\n    # Open the coverage log file\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # Iterate through lines, starting from the 3rd line (index 2)\n    for line in lines[2:]:\n        try:\n            # Split the line into components\n            info = line.split()\n\n            # Ensure the line has at least 3 components\n            if len(info) < 3:\n                print(f\"Skipping malformed line: {line.strip()}\")\n                continue\n\n            # Extract and clean the module name\n            inst = re.sub(r'[\\W|]', '', info[0])  # Remove non-alphanumeric and special characters\n            avg = info[1].replace('%', '')       # Remove percentage symbol from average coverage\n            cov = info[2].replace('%', '')       # Remove percentage symbol from covered coverage\n\n            # Convert the average and covered percentages to floats\n            metrics[inst] = {\n                \"Average\": float(avg),\n                \"Covered\": float(cov)\n            }\n\n        except ValueError as e:\n            # Skip malformed lines that cannot be parsed\n            print(f\"Error parsing line: {line.strip()} - {e}\")\n            continue\n\n    # Check the target coverage for the module\n    target = float(os.getenv(\"TARGET\", \"80\"))  # Default target coverage is 90%\n    assert metrics.get(\"uut\", {}).get(\"Average\", 0) >= target, \\\n        f\"Didn't achieve the required coverage result. Expected: {target}, Got: {metrics.get('uut_sync_communication_top', {}).get('Average', 0)}\"", "src/sync_serial_communication_top.sv": "`timescale 1ns / 1ps\nmodule sync_serial_communication_tx_rx(\n    input clk,                     // Clock signal\n    input reset_n,                 // Active low reset signal\n    input [2:0] sel,               // Selection signal for TX block\n    input [63:0] data_in,          // 64-bit data input for TX block\n    output [63:0] data_out,        // 64-bit data output from RX block\n    output done                    // Done signal indicating completion\n);\n\n// Internal signals\nwire tx_out;                       // Serial data output from TX block\nwire tx_done;                      // Done signal from TX block\nwire serial_clk_in;                // Serial clock generated by TX block\n\n// Instantiate the TX block\ntx_block uut_tx_block (\n    .clk(clk),                     // Clock input to TX block\n    .reset_n(reset_n),             // Reset input to TX block\n    .data_in(data_in),             // 64-bit data input to TX block\n    .sel(sel),                     // Selection signal to TX block\n    .serial_out(tx_out),           // Serial data output from TX block\n    .done(tx_done),                // Done signal from TX block\n    .serial_clk(serial_clk_in)     // Serial clock output from TX block\n);\n\n// Instantiate the RX block\nrx_block uut_rx_block (\n    .clk(clk),                     // Clock input to RX block\n    .serial_clk(serial_clk_in),    // Serial clock input to RX block\n    .reset_n(reset_n),             // Reset input to RX block\n    .sel(sel),                     // Selection signal to RX block\n    .data_in(tx_out),              // Serial data input to RX block\n    .data_out(data_out),           // 64-bit data output from RX block\n    .done(done)                    // Done signal from RX block\n);\n\nendmodule\n\n///// tx_block\nmodule tx_block(\n    input clk,               // Clock input\n    input reset_n,           // Active-low reset input\n    input [63:0] data_in,    // 64-bit parallel data input\n    input [2:0] sel,         // Selection input to choose data width\n    output reg serial_out,   // Serial data output\n    output reg done,         // Done signal indicating completion of transmission\n    output serial_clk        // Clock for serial data transmission\n);\n\n// Internal registers\nreg [63:0] data_reg;         // Register to hold the data being transmitted\nreg [6:0] bit_count;         // Counter to track number of bits to transmit\nreg [6:0] reg_count;         // Register for counting bits for serial clock control\nreg [6:0] temp_reg_count;    // Temporary register to track reg_count\n\n// Sequential block for state control and data selection\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        // Reset all values on active-low reset\n        data_reg     <= 64'h0;\t\t\t     \t           // Clear the data register\n        bit_count    <= 7'h0;\t\t\t     \t           // Reset bit count to zero\n        reg_count    <= 7'h0;\t\t             \t       // Reset reg_count to zero\n    end else begin\n        if (done == 1'b1) begin\n\t    // Case block to determine the width of data to transmit based on the 'sel' input\n            case (sel)\n                3'b000: begin\n                    data_reg  <= 64'h0;             \t   // No data selected\n                    bit_count <= 7'd0;                     // No bits to transmit\n                end\n                3'b001: begin\n                    data_reg  <= {56'h0, data_in[7:0]};    // Transmit lowest 8 bits\n                    bit_count <= 7'd7;              \t   // 8 bits to transmit\n                end\n                3'b010: begin\n                    data_reg  <= {48'h0, data_in[15:0]};   // Transmit lowest 16 bits\n                    bit_count <= 7'd15;             \t   // 16 bits to transmit\n                end\n                3'b011: begin\n                    data_reg  <= {32'h0, data_in[31:0]};   // Transmit lowest 32 bits\n                    bit_count <= 7'd31;             \t   // 32 bits to transmit\n                end\n                3'b100: begin\n                    data_reg  <= data_in[63:0];     \t   // Transmit all 64 bits\n                    bit_count <= 7'd63;             \t   // 64 bits to transmit\n                end\n                default: begin\n                    data_reg  <= 64'h0;             \t   // Default case: no data\n                    bit_count <= 7'h0;              \t   // No bits to transmit\n                end\n            endcase\n           \n        end else if (bit_count > 7'h0) begin\n            data_reg   <= data_reg >> 1;                   // Shift the data to the right\n            bit_count  <= bit_count - 1'b1;                // Decrement the bit count\n            \n        end\n        reg_count <= bit_count;                            // Update reg_count for serial clock control\n    end\nend\n\n// Generate serial clock based on reg_count\n//`ifdef SIMULATION\nassign  #1 serial_clk = clk && (temp_reg_count !== 7'd0) ;  // To avoid SImulator issue \n//`else\n//assign  serial_clk = clk && (temp_reg_count !== 7'd0) ;  \n//`endif\n\n// Register to keep track of reg_count and use for clock gating\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n        temp_reg_count <= 7'h0;\t\t\t\t\t           // Reset temporary reg_count\n    end\n    else begin\n        temp_reg_count <= reg_count;\t\t\t           // Update temp_reg_count with current reg_count\n    end\nend\n\n\n// Sequential logic to drive the serial_out signal based on reg_count and bit_count\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n\t   serial_out <= 1'b0;\t\t\t\t                  // Reset serial output\n    end\n    else if(reg_count > 7'h0 || bit_count > 7'h0) begin\n\t   serial_out <= data_reg[0];\t\t\t              // Output the least significant bit of data_reg\n    end\nend\n\n// Set the done signal when transmission is complete (bit_count reaches zero)\nalways@(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n        done <= 1'b0;\t\t\t\t\t                  // Reset done output\n    end \n    else begin\n     if(bit_count == 7'h0) begin\n\t    done <= 1'b1; \t\t\t                          // Set done signal high when transmission is done\n     end\n     else begin \n\t    done <= 1'b0;\t\t\t\t\t                  // Clear done signal during transmission\n     end\nend\nend\n\n\nendmodule\n\n///// rx_block\nmodule rx_block(\n    input wire clk,  \t\t\t    // clock input\n    input wire reset_n,\t\t\t    // Active-low reset\n    input wire data_in,\t\t\t    // Serial input data\t\n    input wire serial_clk,\t\t    // Clock signal for serial data\n    input wire [2:0] sel,           // Selection output to choose data width\n    output reg done,\t\t\t    // Done signal to indicate data reception complete\t\t\n    output reg [63:0] data_out  \t// Parallel output data after serial operation\n\n);\n\n    // Internal registers\n    reg [63:0] data_reg;\t\t    // Register to hold incoming serial data\n    reg [7:0] bit_count;\t\t    // Counter for the number of bits received\t\n    reg [7:0] count;\t\t\t    // General purpose counter to sync with bit_count\n\n\n    // Sequential logic block to capture serial data on the rising edge of serial_clk\n    always @(posedge serial_clk or negedge  reset_n) begin\n        if (!reset_n) begin\t\t    // Reset all registers on reset_n (active low)\n            data_reg <= 64'h0;\t\t// Clear the data register\n            bit_count <= 8'd0;\t\t// Clear the bit counter\n        end else begin\n            if(done == 1'b1) begin                   // If done signal is asserted, reset the bit counter and data register  \n                bit_count <= 8'b0;\n                data_reg <= 64'h0;\n            end\n            else begin\n                 bit_count <= bit_count;\t\t\t // Maintain the bit counter if not done\n            end\n                bit_count <= bit_count + 1'b1;\t     // Increment bit count\n                data_reg[bit_count]<=data_in; \t     // Store the incoming data bit \n           end\n    end  \n    \n    // Sequential logic block to monitor the completion of data reception and update outputs\n    always@(posedge clk or negedge reset_n) begin\n    \tif(!reset_n) begin\t\t\t \t             // Reset all registers on reset_n (active low)\n    \t   count <= 8'd0;\t\t\t\t\t         // Clear the bit counter\n           done <= 1'b0;\t\t\t\t\t         // Deassert done signal\n           data_out <= 64'h0;\t\t\t\t\t     // Clear the output data register\t\t\t\t\t \n        end \n        else if(count >= bit_count && count != 8'd0) begin       // When the count reaches the bit_count, assert done and output the data\n           done <= 1'b1;\t\t\t\t             // Set done to indicate transmission complete\n           case(sel)\n            3'b000:begin\n                data_out <= 64'h0;                   // no bits to transmit\n            end\n            3'b001:begin\n                data_out <= {56'h0,data_reg};        // 8 bits of data_reg \n            end\n            3'b010:begin\n                data_out <= {48'h0,data_reg};        // 16 bits of data_reg\n            end\n            3'b011:begin\n                data_out <= {32'h0,data_reg};        // 32 bits of data_reg\n            end\n            3'b100:begin\n                data_out <= data_reg;                // 64 bits of data_reg\n            end\n            default:begin\n                data_out <= 64'h0;                   // no bits to transmit, default state\n            end\n           endcase\n        end\n        else if(bit_count > 8'd0) begin              // If bits are being received, increment the count and deassert done\n           count <= count+ 1'b1;\t\t\t\t     // Increment count\n           done <= 1'b0;\t\t\t\t\t         // Clear done signal while receiving\n        end\n        else begin  \t\t\t                     // If no bits have been received, reset the count and deassert done\n           count <= 8'd0;\t\t\t\t\t         // Reset count\n           done <= 1'b0;\t\t\t\t\t         // Clear done signal   \n        end \n    end\n\nendmodule"}}}
{"id": "cvdp_copilot_thermostat_0003", "categories": ["cid012", "medium"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `thermostat`. It automatically switches between heating and cooling based on temperature feedback. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameter Inputs - Outputs and Functional behaviour**\n\n### Inputs\n\n1. **6-bit**: `i_temp_feedback[5:0]`  \n   Each bit represents a distinct temperature condition :\n   - `i_temp_feedback[5]` : `i_full_cold`  (1 = too cold)  \n   - `i_temp_feedback[4]` : `i_medium_cold` (1 = medium cold)  \n   - `i_temp_feedback[3]` : `i_low_cold`   (1 = low cold)  \n   - `i_temp_feedback[2]` : `i_low_hot`    (1 = low hot)  \n   - `i_temp_feedback[1]` : `i_medium_hot` (1 = medium hot)  \n   - `i_temp_feedback[0]` : `i_full_hot`   (1 = too hot)  \n\n2. **1-bit**: `i_fan_on`  \n   - User control to turn the fan on manually (`1` = fan on, `0` = fan off).\n\n3. **1-bit**: `i_enable`  \n   - Enables or disables the thermostat.  \n   - When `i_enable = 0`, all thermostat outputs must be forced to `0` regardless of temperature feedback.\n\n4. **1-bit**: `i_fault`  \n   - Signals a fault/error condition.  \n   - When `i_fault = 1`, all outputs must be forced to `0` (overridden), ignoring normal FSM logic.\n\n5. **1-bit**: `i_clr`  \n   - Clears the error state set by `i_fault`. Upon assertion, the thermostat should return to `AMBIENT`.\n6. **Clock/Reset**  \n   - `i_clk`: Clock for sequential logic.\n   - `i_rst`: Asynchronous active-low reset.\n---\n\n### Outputs\n\n1. **Heating Control (1-bit each)**  \n   - `o_heater_full`  \n   - `o_heater_medium`  \n   - `o_heater_low`  \n\n2. **Cooling Control (1-bit each)**  \n   - `o_aircon_full`  \n   - `o_aircon_medium`  \n   - `o_aircon_low`  \n\n3. **Fan Control (1-bit)**  \n   - `o_fan`  \n\n4. **FSM Output State (3-bit)**  \n   - `o_state[2:0]`: Indicates the current FSM state among the seven valid states:\n     - `3'b000` = `HEAT_LOW`\n     - `3'b001` = `HEAT_MED`\n     - `3'b010` = `HEAT_FULL`\n     - `3'b011` = `AMBIENT`\n     - `3'b100` = `COOL_LOW`\n     - `3'b101` = `COOL_MED`\n     - `3'b110` = `COOL_FULL`\n\n---\n\n### Reset/Idle Behavior\n\n- **Asynchronous Reset (`i_rst` active low)**  \n  - When `i_rst` is asserted (`0`), force the FSM to `AMBIENT` and all outputs to `0`.\n- **Idle/Default State**  \n  - `AMBIENT` state when no heating or cooling is required.  \n  - When `i_clr` is asserted (to clear a fault), the FSM should go back to `AMBIENT` on the next rising clock edge if `i_rst` is not active.\n\n---\n### Fault Handling\n\n- If `i_fault = 1`, **all outputs** (`o_heater_full`, `o_heater_medium`, `o_heater_low`, `o_aircon_full` , `o_aircon_medium`, `o_aircon_low`, `o_fan`) must be forced to `0`, overriding any state-based or feedback logic.\n- Once a fault is signaled, the thermostat remains forced off until `i_clr` is asserted to clear the fault.  \n  - After clearing the fault (`i_clr = 1`), the controller returns to `AMBIENT` state on the next rising clock edge.\n\n---\n\n### Enable Control\n\n- If `i_enable = 0`, the thermostat is turned off.  \n  - Force **all outputs** to `0` (similar to a disable override).  \n  - Internally, the FSM move to `AMBIENT`.\n\n---\n\n## FSM State Transition Logic\n\nOn each rising edge of `i_clk` (while `i_rst = 1` and no fault override), the FSM evaluates the temperature feedback bits to determine the next state:\n\n1. **Cold Conditions** (highest priority first)\n   - If `i_full_cold = 1`: transition to `HEAT_FULL`.  \n   - Else if `i_medium_cold = 1`: transition to `HEAT_MED`.  \n   - Else if `i_low_cold = 1`: transition to `HEAT_LOW`.\n\n2. **Hot Conditions** (highest priority first)\n   - If `i_full_hot = 1`: transition to `COOL_FULL`.  \n   - Else if `i_medium_hot = 1`: transition to `COOL_MED`.  \n   - Else if `i_low_hot = 1`: transition to `COOL_LOW`.\n\n3. **Ambient Condition**\n   - If none of the cold/hot feedback bits are asserted, transition to `AMBIENT`.\n\n> **Note**: The bits `i_full_cold`, `i_medium_cold`, `i_low_cold` are mutually exclusive with `i_full_hot`, `i_medium_hot`, `i_low_hot`, meaning they will never be asserted at the same time.\n\n---\n\n## Output Logic\n\nThe output will be synchronous to `i_clk`, and should get asynchronously reset.\nGiven the current FSM state **(unless overridden by `i_fault` or disabled by `i_enable`)**:\n\n- **Heating States**  \n  - `HEAT_FULL`  \n    - `o_heater_full = 1`, all other heater/cooler outputs = 0  \n  - `HEAT_MED`  \n    - `o_heater_medium = 1`, all other heater/cooler outputs = 0  \n  - `HEAT_LOW`  \n    - `o_heater_low = 1`, all other heater/cooler outputs = 0  \n\n- **Cooling States**  \n  - `COOL_FULL`  \n    - `o_aircon_full = 1`, all other heater/cooler outputs = 0  \n  - `COOL_MED`  \n    - `o_aircon_medium = 1`, all other heater/cooler outputs = 0  \n  - `COOL_LOW`  \n    - `o_aircon_low = 1`, all other heater/cooler outputs = 0  \n\n- **AMBIENT**  \n  - All heater/aircon outputs = 0  \n\n- **Fan Control** (`o_fan`)  \n  - `o_fan = 1` if any heater or air conditioner output is active in the current state **OR** if `i_fan_on = 1`.  \n  - Otherwise, `o_fan = 0`.\n\n---\n\n## Overriding Conditions Summary\n\n1. **Reset (`i_rst = 0`)**  \n   - Highest-priority override: sets FSM to `AMBIENT`, outputs = 0 immediately (asynchronous).  \n\n2. **Fault (`i_fault = 1`)**  \n   - Next-highest priority: overrides *all outputs* to 0, regardless of state or temperature feedback.\n\n3. **Disable (`i_enable = 0`)**  \n   - Next priority: thermostat outputs forced off (0). The FSM logic may remain in its current state internally, but no heat/cool/fan outputs are driven.\n\n4. **Normal Operation**  \n   - When `i_rst=1`, `i_fault=0`, and `i_enable=1`, the FSM outputs follow the state-based transitions and normal fan logic.\n\n5. **Clearing Fault (`i_clr = 1`)**  \n   - On the next rising clock edge, if `i_fault` is deasserted, the FSM moves to `AMBIENT` and resumes normal functionality.\n   - \n## 4. Test Bench Requirements\n\n### 4.1 Stimulus Generation\n\n1. **Asynchronous Reset Scenario**  \n   - Initiate a reset condition while the system is active.\n\n2. **Idle Operation Scenario**  \n   - Set up a condition where no temperature deviation is detected, the thermostat is enabled, there is no fault, and manual fan control is inactive. \n\n3. **Extreme Cold Condition**  \n   - Simulate a situation where the temperature feedback indicates a severe cold condition. \n\n4. **Moderate Cold Condition**  \n   - Create a scenario where the environment is moderately cold. \n5. **Mild Cold Condition**  \n   - Emulate a condition with only a slight drop in temperature. \n\n6. **Extreme Hot Condition**  \n   - Simulate a severe hot condition using temperature feedback. \n\n7. **Moderate Hot Condition**  \n   - Establish a scenario where the temperature feedback indicates moderate heat. \n\n8. **Mild Hot Condition**  \n   - Create a condition where there is only a slight increase in temperature. \n9. **Conflicting Temperature Conditions**  \n   - Provide simultaneous indications of severe cold and severe heat to test the system\u2019s ability to prioritize among conflicting temperature conditions.\n\n10. **Transition from Active Control to Ambient**  \n    - First, simulate a temperature deviation that leads to active heating or cooling. Then remove the deviation so that the system naturally transitions back to an ambient (idle) state.\n\n11. **Manual Fan Activation in Ambient Environment**  \n    - In an ambient condition with no heating or cooling demand, manually activate the fan control. \n\n12. **Disable Thermostat Operation**  \n    - Under conditions that would normally trigger heating or cooling, disable the thermostat functionality. \n\n13. **Fault Condition Enforcement**  \n    - Introduce a fault during normal operation with active temperature deviation. \n\n14. **Fault Clearance and Recovery**  \n    - After inducing a fault condition, simulate the process of clearing the fault. \n\n15. **Systematic Branch Testing:**\n  - **For Each FSM State:**\n    - Drive the thermostat naturally from AMBIENT into each of its 7 states (AMBIENT, HEAT_FULL, COOL_FULL, HEAT_MED, COOL_MED, HEAT_LOW, COOL_LOW) using specific temperature feedback vectors.\n  - **Within Each State:**\n    - Apply 7 distinct temperature feedback patterns that correspond to each branch in the state's nested decision logic (full cold, full hot, medium cold, medium hot, low cold, low hot, and default).\n  - **Reset Between Tests:**\n    - Return to AMBIENT between branch tests to ensure each condition is applied from a known starting point.\n\n\n\n", "context": {}}, "output": {"response": "", "context": {"verif/tb_thermostat.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 3-tb-stimulus\nTARGET = 100", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/thermostat.v /code/verif/tb_thermostat.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/thermostat.v": "module thermostat (\n    input wire [5:0] i_temp_feedback, // Temperature feedback bits\n    input wire i_fan_on,             // Manual fan control\n    input wire i_enable,             // Enable thermostat\n    input wire i_fault,              // Fault signal\n    input wire i_clr,                // Clear fault signal\n    input wire i_clk,                // Clock input\n    input wire i_rst,                // Asynchronous reset (active-low)\n\n    output reg o_heater_full,\n    output reg o_heater_medium,\n    output reg o_heater_low,\n    output reg o_aircon_full,\n    output reg o_aircon_medium,\n    output reg o_aircon_low,\n    output reg o_fan,\n    output reg [2:0] o_state         // FSM state output\n);\n\n// State encoding\nlocalparam [2:0] HEAT_LOW  = 3'b000,\n                 HEAT_MED  = 3'b001,\n                 HEAT_FULL = 3'b010,\n                 AMBIENT   = 3'b011,\n                 COOL_LOW  = 3'b100,\n                 COOL_MED  = 3'b101,\n                 COOL_FULL = 3'b110;\n\n// Internal signals\nreg [2:0] current_state, next_state; // FSM state registers\nreg heater_full, heater_medium, heater_low;\nreg aircon_full, aircon_medium, aircon_low;\nreg fan;\nalways @(*) begin\n    o_state = current_state;\nend\n// Sequential logic for state transitions and registered outputs\nalways @(posedge i_clk or negedge i_rst) begin\n    if (!i_rst) begin\n        // Asynchronous reset\n        current_state <= AMBIENT;\n        o_heater_full <= 0;\n        o_heater_medium <= 0;\n        o_heater_low <= 0;\n        o_aircon_full <= 0;\n        o_aircon_medium <= 0;\n        o_aircon_low <= 0;\n        o_fan <= 0;\n    end else begin\n        // Normal state transition\n        current_state <= next_state;\n        // Update registered outputs\n        o_heater_full <= heater_full;\n        o_heater_medium <= heater_medium;\n        o_heater_low <= heater_low;\n        o_aircon_full <= aircon_full;\n        o_aircon_medium <= aircon_medium;\n        o_aircon_low <= aircon_low;\n        o_fan <= fan || i_fan_on;\n    end\nend\n\n// Combinational logic for next state and intermediate outputs\nalways @(*) begin\n    if (!i_enable || i_fault) begin\n        // Handle fault or disable\n        next_state = AMBIENT;\n        heater_full = 0;\n        heater_medium = 0;\n        heater_low = 0;\n        aircon_full = 0;\n        aircon_medium = 0;\n        aircon_low = 0;\n        fan = 0;\n    end else begin\n        case (current_state)\n            // Heating states\n            HEAT_LOW: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 1;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            HEAT_MED: begin\n                heater_full = 0;\n                heater_medium = 1;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            HEAT_FULL: begin\n                heater_full = 1;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            // Cooling states\n            COOL_LOW: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 1;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            COOL_MED: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 1;\n                aircon_low = 0;\n                fan = 1;\n                aircon_medium = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            COOL_FULL: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 1;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 1;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            // Ambient state\n            AMBIENT: begin\n                heater_full = 0;\n                heater_medium = 0;\n                heater_low = 0;\n                aircon_full = 0;\n                aircon_medium = 0;\n                aircon_low = 0;\n                fan = 0;\n                if (i_temp_feedback[5]) begin \n                    next_state = HEAT_FULL; \n                end// Full cold\n                else if (i_temp_feedback[0]) begin // Full hot\n                    next_state = COOL_FULL;\n                end\n                else begin\n                    if (i_temp_feedback[4]) begin \n                        next_state = HEAT_MED; \n                    end// Medium cold\n                    else if (i_temp_feedback[1]) begin // Medium hot\n                        next_state = COOL_MED;\n                    end\n                    else begin\n                        if (i_temp_feedback[3]) begin \n                            next_state = HEAT_LOW; \n                        end// Low cold\n                        else if (i_temp_feedback[2]) begin // Low hot\n                            next_state = COOL_LOW;\n                        end\n                        else begin\n                            next_state = AMBIENT;\n                        end\n                    end\n                end\n            end\n\n            default: next_state = AMBIENT; // Safety fallback\n        endcase\n    end\nend\n\nendmodule\n"}}}
{"id": "cvdp_copilot_traffic_light_controller_0007", "categories": ["cid012", "medium"], "input": {"prompt": "Create a test bench in SystemVerilog for a Verilog module named `traffic_controller_fsm`. Based on sensor inputs and timing signals, the FSM manages the traffic lights for both a main road and a side road. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.\n\n---\n## Instantiation\n\nName the instance of the RTL as **dut**.\n\n## **RTL Parameter Inputs - Outputs and Functional behaviour**\n\n---\n### Inputs and Outputs\n\n| Signal                       | Direction | Bit Width | Active Level | Description                                                                             |\n|------------------------------|-----------|-----------|--------------|-----------------------------------------------------------------------------------------|\n| **`i_clk`**                  | Input     | 1         | \u2014            | System clock signal, with FSM transitions occurring on the rising edge.                 |\n| **`i_rst_b`**                | Input     | 1         | Active-low   | Asynchronous reset signal. When asserted (`0`), FSM resets to its initial state.        |\n| **`i_vehicle_sensor_input`** | Input     | 1         | Active-high  | Detects vehicle presence on the side road. High (`1`) when a vehicle is detected.       |\n| **`i_short_timer`**          | Input     | 1         | Active-high  | Indicates the expiration of the short timer. High (`1`) when the short timer expires.   |\n| **`i_long_timer`**           | Input     | 1         | Active-high  | Indicates the expiration of the long timer. High (`1`) when the long timer expires.     |\n| **`o_short_trigger`**        | Output    | 1         | Active-high  | Initiates the short timer. Set to high (`1`) to start the short timer.                  |\n| **`o_long_trigger`**         | Output    | 1         | Active-high  | Initiates the long timer. Set to high (`1`) to start the long timer.                    |\n| **`o_main[2:0]`**            | Output    | 3         | \u2014            | Controls main road traffic lights: Red (`3'b100`), Yellow (`3'b010`), Green (`3'b001`). |\n| **`o_side[2:0]`**            | Output    | 3         | \u2014            | Controls side road traffic lights: Red (`3'b100`), Yellow (`3'b010`), Green (`3'b001`). |\n\n### FSM Output Table\n\n| State | Description                           | `o_main`          | `o_side`          | `o_short_trigger` | `o_long_trigger` |\n|-------|---------------------------------------|-------------------|-------------------|-------------------|------------------|\n| **S1** | Main road green, side road red       | `3'b001` (Green)  | `3'b100` (Red)    | 0                 | 1                |\n| **S2** | Main road yellow, side road red      | `3'b010` (Yellow) | `3'b100` (Red)    | 1                 | 0                |\n| **S3** | Main road red, side road green       | `3'b100` (Red)    | `3'b001` (Green)  | 0                 | 1                |\n| **S4** | Main road red, side road yellow      | `3'b100` (Red)    | `3'b010` (Yellow) | 1                 | 0                |\n\n### FSM Transition Logic\n- **S1 \u2192 S2**: Transition when a vehicle is detected (`i_vehicle_sensor_input = 1`) and the long timer expires (`i_long_timer = 1`).\n- **S2 \u2192 S3**: Transition upon short timer expiration (`i_short_timer = 1`).\n- **S3 \u2192 S4**: Transition when either vehicle is detected (`i_vehicle_sensor_input = 1`) or the long timer expires (`i_long_timer = 1`).\n- **S4 \u2192 S1**: Transition upon short timer expiration (`i_short_timer = 1`).\n\n### Requirements\n1. **Reset Behavior**: When the reset signal is active (`i_rst_b = 0`), the FSM should reset to **State S1** with the following initial values:\n   - **`o_main`** set to `3'b000` (main road lights off).\n   - **`o_side`** set to `3'b000` (side road lights off).\n   - **`o_long_trigger`** set to `1'b0` (long timer trigger reset).\n   - **`o_short_trigger`** set to `1'b0` (short timer trigger reset).\n2. **Clocked Transitions**: The FSM should transition between states on the rising edge of the clock (`i_clk`).\n3. **Synchronized Outputs**: Ensure the traffic light outputs (`o_main` and `o_side`) and the timer triggers (`o_long_trigger`, `o_short_trigger`) are properly synchronized with state transitions.\n\n\n## 4. Test Bench Requirements\n\n### 4.1 Stimulus Generation\n1. **Reset and Initialization Stimulus**  \n   1.1. Assert the asynchronous reset by driving the active-low reset signal to its active state for several clock cycles while keeping all other inputs inactive.  \n   1.2. Deassert the reset by returning the active-low reset signal to its inactive state and wait one clock cycle for system initialization.\n\n2. **Stimulus for the State with Main Road Green and Side Road Red (S1)**  \n   2.1. **No Transition Conditions:**  \n   \u2003\u20032.1.1. Apply stimulus with the sensor input inactive and the long timer signal inactive for several clock cycles.  \n   \u2003\u20032.1.2. Apply stimulus with the sensor input active and the long timer signal inactive for several clock cycles.  \n   \u2003\u20032.1.3. Apply stimulus with the sensor input inactive and the long timer signal active for several clock cycles.  \n   2.2. **Transition Condition:**  \n   \u2003\u20032.2.1. Apply stimulus with both the sensor input and the long timer signal active for one clock cycle.\n\n3. **Stimulus for the State with Main Road Yellow and Side Road Red (S2)**  \n   3.1. **No Transition Condition:**  \n   \u2003\u20033.1.1. Maintain the short timer signal inactive for several clock cycles.  \n   3.2. **Transition Condition:**  \n   \u2003\u20033.2.1. Provide a one-clock-cycle pulse on the short timer signal.\n\n4. **Stimulus for the State with Main Road Red and Side Road Green (S3)**  \n   4.1. **No Transition Condition:**  \n   \u2003\u20034.1.1. Apply stimulus with the sensor input active and the long timer signal inactive for several clock cycles.  \n   4.2. **Transition Conditions:**  \n   \u2003\u20034.2.1. Transition Branch A: Apply stimulus with the sensor input inactive (with the long timer signal inactive) for one clock cycle.  \n   \u2003\u20034.2.2. Transition Branch B: Alternatively, apply stimulus with the sensor input active and the long timer signal active for one clock cycle.\n\n5. **Stimulus for the State with Main Road Red and Side Road Yellow (S4)**  \n   5.1. **No Transition Condition:**  \n   \u2003\u20035.1.1. Maintain the short timer signal inactive for several clock cycles.  \n   5.2. **Transition Condition:**  \n   \u2003\u20035.2.1. Provide a one-clock-cycle pulse on the short timer signal.\n\n6. **Clock and Synchronization Stimulus**  \n   6.1. Generate a continuous clock signal.  \n   6.2. Ensure that any changes to the input signals are applied between clock edges so that state transitions occur on the rising edge of the clock.\n\n7. **Timer Pulse Width Stimulus**  \n   7.1. Apply one-clock-cycle pulses to the short timer and long timer signals to simulate timer expiration events.  \n   7.2. In separate scenarios, hold the short timer and long timer signals active for multiple clock cycles.\n\n8. **Comprehensive Sequence Stimulus**  \n   8.1. Start with the reset sequence as described in section 1.  \n   8.2. Progress through the full state cycle by sequentially applying stimulus to:  \n   \u2003\u20038.2.1. The state with main road green and side road red (S1), including both no transition and transition conditions.  \n   \u2003\u20038.2.2. The state with main road yellow and side road red (S2), including both no transition and transition conditions.  \n   \u2003\u20038.2.3. The state with main road red and side road green (S3), including both no transition and transition conditions using both branches.  \n   \u2003\u20038.2.4. The state with main road red and side road yellow (S4), including both no transition and transition conditions.", "context": {}}, "output": {"response": "", "context": {"verif/tb_traffic_controller_fsm.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 7-tb-stimulus\nTARGET = 97", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/traffic_light_controller.sv /code/verif/tb_traffic_controller_fsm.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"", "src/traffic_light_controller.sv": "module traffic_controller_fsm ( \n    input i_clk,                     // System clock input\n    input i_rst_b,                   // Active-low reset signal\n    input i_vehicle_sensor_input,     // High when a vehicle is present on the side road\n    input i_short_timer,              // High when the short timer expires\n    input i_long_timer,               // High when the long timer expires\n    output reg o_short_trigger,       // Trigger for the short timer (active high)\n    output reg o_long_trigger,        // Trigger for the long timer (active high)\n    output reg [2:0] o_main,          // Main road traffic lights (3-bit: Red, Yellow, Green)\n    output reg [2:0] o_side           // Side road traffic lights (3-bit: Red, Yellow, Green)\n);\n    \nlocalparam p_state_S1 = 2'd0 ;       \nlocalparam p_state_S2 = 2'd1 ;       \nlocalparam p_state_S3 = 2'd2 ;       \nlocalparam p_state_S4 = 2'd3 ;       \n\nreg [1:0]   r_state;                 \nreg [1:0]   r_next_state;            \n\n//-----------------------------------------------------------------------------\n// Next State Logic\n//-----------------------------------------------------------------------------\nalways @(*) begin\n    if (!i_rst_b) begin              \n        r_next_state = p_state_S1;   \n    end else begin\n        case (r_state)\n        p_state_S1: begin\n            if (i_vehicle_sensor_input & i_long_timer) begin\n                r_next_state = p_state_S2;  \n            end else begin\n                r_next_state = p_state_S1;  \n            end\n        end\n        p_state_S2: begin\n            if (i_short_timer) begin\n                r_next_state = p_state_S3;  \n            end else begin\n                r_next_state = p_state_S2;  \n            end\n        end\n        p_state_S3: begin\n            if ((!i_vehicle_sensor_input) | i_long_timer) begin\n                r_next_state = p_state_S4;  \n            end else begin\n                r_next_state = p_state_S3;  \n            end\n        end\n        p_state_S4: begin\n            if (i_short_timer) begin\n                r_next_state = p_state_S1;  \n            end else begin\n                r_next_state = p_state_S4;  \n            end\n        end\n        endcase\n    end\nend\n\nalways @(posedge i_clk or negedge i_rst_b) begin\n    if (!i_rst_b) begin                  \n        r_state <= p_state_S1;           \n    end else begin\n        r_state <= r_next_state;         \n    end\nend\n\n\nalways @(posedge i_clk or negedge i_rst_b) begin\n    if (!i_rst_b) begin                   \n        o_main <= 3'd0;                  \n        o_side <= 3'd0;                  \n        o_long_trigger <= 1'b0;          \n        o_short_trigger <= 1'b0;         \n    end else begin\n        case (r_state)\n        p_state_S1: begin\n            o_main <= 3'b001;            \n            o_side <= 3'b100;            \n            o_long_trigger <= 1'b1;      \n            o_short_trigger <= 1'b0;     \n        end\n        p_state_S2: begin\n            o_main <= 3'b010;             \n            o_side <= 3'b100;             \n            o_long_trigger <= 1'b0;       \n            o_short_trigger <= 1'b1;     \n        end\n        p_state_S3: begin\n            o_main <= 3'b100;            \n            o_side <= 3'b001;            \n            o_long_trigger <= 1'b1;      \n            o_short_trigger <= 1'b0;     \n        end\n        p_state_S4: begin\n            o_main <= 3'b100;             \n            o_side <= 3'b010;             \n            o_long_trigger <= 1'b0;       \n            o_short_trigger <= 1'b1;     \n        end\n        endcase\n    end\nend\n\nendmodule\n"}}}
{"id": "cvdp_copilot_vending_machine_0006", "categories": ["cid012", "medium"], "input": {"prompt": "Complete the given partial SystemVerilog testbench `serial_line_code_converter_tb`. The testbench must instantiate the `serial_line_code_converter` RTL module and provide input stimulus for various testcases. This testbench simulates a vending machine that processes item selection, coin insertion, item dispensing, change return, and purchase cancellation. \n## Description\nThe vending machine operates using a finite state machine (FSM) with distinct states to ensure a structured transaction flow. It begins in the IDLE state, awaiting item selection before allowing coin insertion. The machine validates inserted coins, dispenses the item upon sufficient payment, and returns change if necessary. Errors trigger the RETURN_MONEY state, ensuring incorrect transactions are handled properly, and a reset clears all internal states, preparing the machine for a new transaction.\n\n## **Interface**\n\n### **Inputs**\n- **clk:** Clock signal for timing and synchronizing state transitions, operating on the rising edge.\n- **rst:** Asynchronous, active-high reset signal that resets all internal states, outputs, and accumulated values, returning the machine to the `IDLE` state.\n- **item_button(1-bit):** Signal indicating that the user has pressed the button to initiate item selection (active high). This acts as a toggle signal and should only register on the rising edge.\n- **item_selected (3-bits, [2:0]):** This input represents the item chosen by the user, with valid values corresponding to the four available items (valid values: `3'b001` to `3'b100`).\n- **coin_input(4-bits, [3:0]):** This input represents the value of the coin inserted, with valid values of 1, 2, 5, or 10 units.\n- **cancel (1-bit):** Signal allowing the user to cancel the current transaction before the item is dispensed (active high).\n\n### **Outputs**\n- **dispense_item(1-bit):** Indicates that the selected item is ready for dispensing after the required amount is met. Active high for one clock cycle when the item is being dispensed.\n- **return_change(1-bit):** Signal that excess coins are being returned as change. Active high for one clock cycle when change is being returned.\n- **item_price(5-bits,[4:0]):** Output displaying the price of the currently selected item.\n- **change_amount(5-bits,[4:0]):** Output representing the amount of change to be returned if excess coins were inserted.\n- **dispense_item_id(3-bits,[2:0]):** Output indicating the ID of the item being dispensed.\n- **error(1-bit):** Indicates that an invalid operation has occurred, such as inserting coins without selecting an item or entering invalid coin values. Active high for one clock cycle during an error condition.\n- **return_money(1-bit):** Indicates that all inserted money should be returned due to cancellation or an error. Active high for one clock cycle when returning money.\n\n## Instantiation\n\nThe testbench instantiates the `vending_machine` module as `uut` (unit under test) and connects the signals accordingly.\n\n### Input Generation and Validation\n\n#### Clock Generation\nThe `clk` signal should toggle every 5 time units, simulating a 100MHz clock.\n\n#### Reset Handling\nThe `rst` signal should be high at the beginning of the simulation for at least three clock cycles. \n\n### Test Scenarios\n\nThe testbench should generate multiple real-world scenarios involving purchases, cancellations, and error handling.\n\n#### 1. System Initialization\n-  Generate a clock signal and assert the reset signal for multiple cycles to initialize the system in a defined state.e.\n\n#### 2. Selecting an Item\n-  Assert and de-assert the selection button within a clock cycle while setting the selected item ID.\n\n#### 3. Inserting Coins\n- A value representing the coin input is assigned, and after a clock cycle, it is reset to zero.\n\n#### 4. Cancelling a Purchase\n - The cancel button is asserted and de-asserted within one clock cycle.\n\n#### 5. Purchasing an Item with Exact Coins\n- Select an item 1 and insert the exact required amount (5) in a single step.\n\n#### 6. Purchasing an Item with Multiple Coin Insertions\n- Select item 2 and insert a partial amount (5), followed by the remaining balance (5) in subsequent cycles.\n\n#### 7. Purchasing an Item with Extra Coins and Getting Change\n- Select item 2 and insert more than the required amount and ensure a change is computed.\n\n#### 8. Cancelling a Purchase After Inserting Some Coins\n- Select an item, insert partial coins, then assert cancel.\n\n#### 9. Cancelling Immediately After Selecting an Item\n- Select an item and immediately trigger cancellation.\n\n#### 10. Purchasing an Expensive Item with Multiple Small Coin Insertions\n- Insert small denominations over multiple steps to accumulate the required price.\n\n#### 11. Inserting Coins Without Selecting an Item\n- Insert money without item selection.\n\n#### 12. Resetting the System After Inserting Coins or Selecting an Item\n- Initiate a transaction, assert reset, and verify system restart.\n\n#### 13. Rapid Successive Coin Insertions\n- Insert multiple small denominations in quick succession.\n\n#### 14. Rapid Coin Insertion Handling\n - The same coin value is inserted multiple times in quick succession.\n\n#### 15. Selecting an Invalid Item ID\n - A non-existent item ID is chosen.\n\n#### 16. Returning Money When No Item Is Selected\n- Insert money and verify refund without selection.\n\n#### 17. Transition from Dispensing an Item to Returning Change\n- Overpay and verify that dispensing occurs before change return.\n\n#### 18. Transition from Returning Change Back to Idle\n-  Complete a purchase with a change return and verify system readiness.\n\n#### 19. Cancelling After Pressing the Item Selection Button\n- Select an item and cancel before inserting money.\n\n### Final Steps\n\n- **Simulation End**: After all tests, wait for a few cycles and call `$finish`.\n- **Waveform Dump**: Generate a VCD file for offline analysis.\n\n### Partial Test Stimulus Generator Code:\n\n```verilog\nmodule vending_machine_tb;\n\n    reg clk;                    // Clock signal\n    reg rst;                    // Reset signal\n    reg item_button;            // Signal for item selection button press\n    reg [2:0] item_selected;    // Input to select one of 4 items\n    reg [3:0] coin_input;       // Coin input\n    reg cancel;                 // Cancel button signal\n\n    wire dispense_item;         // Signal to dispense item\n    wire return_change;         // Signal to return change\n    wire error;                 // Error signal if any invalid operation occurs\n    wire return_money;          // Signal to return all money if operation is cancelled\n    wire [4:0] item_price;      // Price of the selected item\n    wire [4:0] change_amount;   // Amount of change to return\n    wire [2:0] dispense_item_id;// ID of item being dispensed\n\n    // Instantiate the vending machine module\n    vending_machine uut (\n        .clk(clk),\n        .rst(rst),\n        .item_button(item_button),\n        .item_selected(item_selected),\n        .coin_input(coin_input),\n        .dispense_item(dispense_item),\n        .return_change(return_change),\n        .item_price(item_price),\n        .change_amount(change_amount),\n        .dispense_item_id(dispense_item_id),\n        .error(error),\n        .cancel(cancel),\n        .return_money(return_money)\n    );\n\n    // Clock generator: Clock signal toggles every 5 time units\n    always #5 clk = ~clk;\n\n    // Task to initialize the testbench (reset and initial conditions)\n    task initialize;\n    begin\n        clk = 0;\n        rst = 1;              \n        item_button = 0;\n        item_selected = 3'b000;\n        coin_input = 0;\n        cancel = 0;\n        @(posedge clk) rst = 0;          \n    end\n    endtask\n\n    // Task to select an item\n    task select_item(input [2:0] item);\n    begin\n        @(posedge clk)\n        item_button = 1;     \n        @(posedge clk) item_button = 0;\n        item_selected = item;\n        @(posedge clk);\n    end\n    endtask\n\n    // Insert the code for the remaining test stimulus here\n\nendmodule\n\n\n```", "context": {}}, "output": {"response": "", "context": {"verif/vending_machine_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro \n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 76091a14c1d5d7926f0b7a471c78b7f9cf8ad22b\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        while len(info) < 3:\n            info.append(\"0%\")\n\n        inst = re.sub(r'[\\W]', '', info[0])\n\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'uut' is missing in the coverage log.\")\n\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))  \n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['uut']['Average']}, Target: {target}\"", "src/vending_machine.sv": "module vending_machine(\n    input clk,                          // Clock signal\n    input rst,                          // Reset signal\n    input item_button,                  // Signal for item selection button press (active high, rising edge)\n    input [2:0] item_selected,          // 3-bit input to select item (valid: 3'b001 to 3'b100)\n    input [3:0] coin_input,             // 4-bit coin input to represent value of coin inserted (1, 2, 5, or 10)\n    input cancel,                       // Cancel button signal (active high, rising edge)\n    output reg dispense_item,           // Signal to dispense item (active high for one cycle)\n    output reg return_change,           // Signal to return change (active high for one cycle)\n    output reg [4:0] item_price,        // Price of the selected item\n    output reg [4:0] change_amount,     // Amount of change to return\n    output reg [2:0] dispense_item_id,  // ID of item being dispensed\n    output reg error,                   // Error signal if any invalid operation occurs (active high for one cycle)\n    output reg return_money             // Signal to return all money if operation is cancelled or invalid (active high for one cycle)\n);\n\n    // Item Prices (Assume we have 4 items with prices: 5, 10, 15, 20 units)\n    localparam ITEM_1_PRICE = 5'd5;\n    localparam ITEM_2_PRICE = 5'd10;\n    localparam ITEM_3_PRICE = 5'd15;\n    localparam ITEM_4_PRICE = 5'd20;\n\n    // Item IDs or Names\n    localparam NO_ITEM = 3'b000;\n    localparam ITEM_1_ID = 3'b001; // Item 1\n    localparam ITEM_2_ID = 3'b010; // Item 2\n    localparam ITEM_3_ID = 3'b011; // Item 3\n    localparam ITEM_4_ID = 3'b100; // Item 4\n\n    // Internal registers\n    reg [4:0] coins_accumulated;   // Tracks accumulated coins\n    reg [4:0] amount;\n\n    // Define state enum\n    typedef enum logic [3:0] {\n        IDLE                = 4'd0,     // Idle state\n        ITEM_SELECTION      = 4'd1,     // Waiting for item selection\n        PAYMENT_VALIDATION  = 4'd2,     // Validating coin input\n        DISPENSING_ITEM     = 4'd3,     // Dispensing the item\n        RETURN_CHANGE       = 4'd4,     // Returning change\n        RETURN_MONEY        = 4'd5      // Returning all money\n    } state_t;\n\n    state_t current_state, next_state;         // Current and next states of the vending machine\n    reg [4:0] next_coins_accumulated;\n    reg       next_return_change;\n    reg [4:0] next_item_price;\n    reg [4:0] next_change_amount;\n    reg       next_error;\n    reg [2:0] next_dispense_item_id;\n    reg       next_return_money;\n    reg       next_dispense_item;\n    reg [4:0] next_amount;\n\n    // State Machine logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all outputs and internal registers\n            coins_accumulated <= 5'd0;\n            return_change     <= 1'b0;\n            item_price        <= 5'd0;\n            change_amount     <= 5'd0;\n            error             <= 1'b0;\n            dispense_item_id  <= 3'd0;\n            return_money      <= 1'b0;\n            dispense_item     <= 1'b0;\n            current_state     <= IDLE;\n        end else begin\n            current_state       <= next_state;\n            coins_accumulated   <= next_coins_accumulated;\n            item_price          <= next_item_price;\n            change_amount       <= next_change_amount;\n            error               <= next_error;\n            dispense_item_id    <= next_dispense_item_id;\n            return_money        <= next_return_money;\n            dispense_item       <= next_dispense_item;\n            return_change       <= next_return_change;\n            amount              <= next_amount;\n\n        end\n        \n    end\n\n    // Next state logic (combinatorial)\n    always @ (*) begin\n        next_state = current_state;\n        next_coins_accumulated = coins_accumulated;\n        next_item_price        = item_price;\n        next_change_amount     = change_amount;\n        next_error             = error;\n        next_dispense_item_id  = dispense_item_id;\n        next_return_money      = return_money;\n        next_dispense_item     = dispense_item;\n        next_return_change     = return_change;\n        next_amount            = amount;\n        case (current_state)\n            // IDLE State\n            IDLE: begin\n                if (item_button) begin\n                    next_return_money  = 1'b0;\n                    next_return_change = 1'b0; \n                    next_change_amount = 5'd0;\n                    next_coins_accumulated = 5'd0; \n                    next_error   = 1'b0;\n                    next_amount = 5'd0;\n                    next_dispense_item_id = 3'd0;\n                    next_state = ITEM_SELECTION;\n                end else if (coin_input > 0) begin\n                    next_return_change = 1'b0; \n                    next_coins_accumulated =  coin_input;\n                    next_error   = 1'b1;\n                    next_amount = 5'd0;;    \n                    next_dispense_item_id  = 3'd0;\n                    next_state = RETURN_MONEY;\n                end else begin\n                    next_return_money  = 1'b0;\n                    next_return_change = 1'b0; \n                    next_change_amount = 5'd0;\n                    next_error   = 1'b0;\n                    next_amount = 5'd0;\n                    next_dispense_item_id  = 3'd0;\n                end\n            end\n\n            // ITEM_SELECTION State\n            ITEM_SELECTION: begin\n                if (cancel) begin\n                    next_error   = 1'b1;\n                    next_state = RETURN_MONEY;\n                end else if (item_selected >= 3'b000 ) begin\n                    case (item_selected)\n                        3'b001: next_item_price = ITEM_1_PRICE;\n                        3'b010: next_item_price = ITEM_2_PRICE;\n                        3'b011: next_item_price = ITEM_3_PRICE;\n                        3'b100: next_item_price = ITEM_4_PRICE;\n                        default: next_item_price = NO_ITEM;\n                    endcase\n                    next_state = PAYMENT_VALIDATION;\n                end\n            end\n\n            // PAYMENT_VALIDATION State\n            PAYMENT_VALIDATION: begin\n                if (cancel) begin\n                    next_error   = 1'b1;\n                    next_state = RETURN_MONEY;\n                end else if ( item_selected == 3'b000 ) begin\n                    next_error = 1'b1;\n                    next_coins_accumulated = coins_accumulated + coin_input;\n                    next_state = RETURN_MONEY;\n                end else if ( item_price == NO_ITEM ) begin\n                    next_error = 1'b1;\n                    next_coins_accumulated = coins_accumulated + coin_input;\n                    next_state = RETURN_MONEY;\n                end else if (error) begin\n                    next_state = IDLE; \n                end else if (coins_accumulated >= item_price) begin\n                    next_state = DISPENSING_ITEM;\n                    next_dispense_item   = 1'b1;\n                end else if (coin_input > 0) begin\n                    // Validate the coin input (only 1, 2, 5, or 10 is accepted)\n                    if (coin_input == 4'd1 || coin_input == 4'd2 || coin_input == 4'd5 || coin_input == 4'd10) begin\n                        next_coins_accumulated = coins_accumulated + coin_input; \n                        next_state = PAYMENT_VALIDATION;  \n                    end else begin  \n                        next_amount =  coins_accumulated + coin_input;  \n                        next_error = 1'b1; \n                        next_return_money = 1'b1; \n                        next_change_amount = next_amount;\n                        next_state = IDLE;      \n                    end\n                end\n            end\n\n            // DISPENSING_ITEM State\n            DISPENSING_ITEM: begin\n                next_dispense_item = 1'b0;\n                case (item_selected)\n                    3'b001: next_dispense_item_id = ITEM_1_ID;\n                    3'b010: next_dispense_item_id = ITEM_2_ID;\n                    3'b011: next_dispense_item_id = ITEM_3_ID;\n                    3'b100: next_dispense_item_id = ITEM_4_ID;\n                    default: next_dispense_item_id = NO_ITEM;\n                endcase\n\n                if (coins_accumulated > item_price) begin\n                    next_state = RETURN_CHANGE;\n                    next_amount = coins_accumulated - item_price;\n                end else begin\n                    next_coins_accumulated = 5'd0;\n                    next_state = IDLE;\n                end\n                next_coins_accumulated = 5'd0;\n            end\n\n            // RETURN_CHANGE State\n            RETURN_CHANGE: begin\n                next_return_change = 1'b1;\n                next_change_amount = amount;\n                next_error   = 1'b0;\n                next_dispense_item_id  = 3'b000;\n                next_coins_accumulated = 5'b0;\n                next_state = IDLE;\n            end\n\n            // RETURN_MONEY State\n            RETURN_MONEY: begin\n                if (coins_accumulated == 0) begin\n                    next_return_money  = 1'b0;\n                end else if (coins_accumulated > 0) begin\n                    next_return_money  = 1'b1;\n                    next_change_amount = coins_accumulated;\n                end\n                next_error   = 1'b0;\n                next_state = IDLE;\n            end\n\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule\n\n"}}}
{"id": "cvdp_copilot_wb2ahb_0004", "categories": ["cid012", "medium"], "input": {"prompt": "Write a System Verilog testbench to generate stimulus for a `wishbone_to_ahb_bridge_tb` module, which is responsible for bridging transactions between a Wishbone master and an AHB slave. \n\n## **Design Specification**\nThe `wishbone_to_ahb_bridge` module serves as a bridge between the Wishbone bus and the AMBA AHB bus, facilitating data transfers between a Wishbone master and an AHB slave. The bridge is responsible for handling address alignment, transfer size selection, and acknowledgment signaling, ensuring compatibility between the two protocols.\n\n### **Functionality**\n- The bridge takes Wishbone signals (`cyc_i`, `stb_i`, `we_i`, `sel_i`, `addr_i`, `data_i`) as inputs and converts them into AHB-compatible signals (`haddr`, `hwrite`, `hsize`, `htrans`, `hwdata`).\n- The bridge properly aligns **Wishbone byte enables (`sel_i`)** to the corresponding **AHB address and data phase transactions**.\n- Acknowledgment (`ack_o`) is generated when the **AHB slave is ready (`hready`)**, ensuring correct transaction completion.\n- Supports **single transfers** with **variable transfer sizes** (`byte`, `half-word`, `word`).\n- Includes **address holding logic** to maintain proper transactions in case of stalled AHB responses.\n\n---\n\n### Inputs\n- **Wishbone Ports (from WB Master):**\n  - `clk_i`: Clock signal for Wishbone operations.\n  - `rst_i`: Active-low reset signal to initialize the bridge.\n  - `cyc_i`: Indicates a valid Wishbone transaction cycle.\n  - `stb_i`: Strobe signal for valid data on the Wishbone interface.\n  - `sel_i[3:0]`: Byte enables to select which bytes are active.\n  - `we_i`: Write enable signal.\n  - `addr_i[31:0]`: Address for the Wishbone transaction.\n  - `data_i[31:0]`: Write data from the Wishbone master.\n- **AHB Ports (from AHB Slave):**\n  - `hclk`: Clock signal for AHB operations.\n  - `hreset_n`: Active-low reset signal for the AHB interface.\n  - `hrdata[31:0]`: Read data from the AHB slave.\n  - `hresp[1:0]`: AHB response signal.\n  - `hready`: Indicates when the AHB slave is ready.\n\n### Outputs\n- **Wishbone Outputs:**\n  - `data_o[31:0]`: Read data back to the Wishbone master.\n  - `ack_o`: Acknowledge signal for Wishbone operations.\n- **AHB Outputs:**\n  - `htrans[1:0]`: AHB transaction type.\n  - `hsize[2:0]`: Size of the AHB transfer.\n  - `hburst[2:0]`: Burst type (always single in this design).\n  - `hwrite`: Write enable signal for AHB transactions.\n  - `haddr[31:0]`: Address for the AHB transaction.\n  - `hwdata[31:0]`: Write data to the AHB slave.\n\n---\n\n## **Testbench Requirements**\n### **Instantiation**\n- The `wishbone_to_ahb_bridge` module must be instantiated as **DUT (Device Under Test)**.\n- All input and output signals should be properly connected for functional verification.\n\n### **Test Scenarios**\n#### **Clock and Reset Generation**\n- Generate two separate clocks:\n  - `clk_i` for the Wishbone interface.\n  - `hclk` for the AHB interface.\n- Implement an asynchronous reset (`rst_i` for Wishbone, `hreset_n` for AHB) at the start of the test.\n\n#### **Wishbone Transactions**\n##### **Write Transactions**\n- Perform multiple write operations using different addresses, data values, and byte enable (`sel_i`) configurations.\n- Validate the correct Wishbone to AHB conversion by checking:\n  - Address alignment\n  - Transfer size selection (`hsize`)\n  - Data transfer correctness (`hwdata`)\n  - Acknowledgment (`ack_o`)\n- Include test cases for:\n  - Byte writes (`sel_i = 4'b0001, 4'b0010, 4'b0100, 4'b1000`)\n  - Half-word writes (`sel_i = 4'b0011, 4'b1100`)\n  - Word writes (`sel_i = 4'b1111`)\n\n##### **Read Transactions**\n- Perform read operations using different addresses.\n- Ensure correct data retrieval from the AHB slave (`hrdata` \u2192 `data_o`).\n- Verify acknowledgment timing.\n\n#### **Address Alignment and Endianness Handling**\n- Check how the bridge modifies Wishbone addresses to match AHB alignment rules.\n- Ensure that byte and half-word transfers properly align data in `hwdata` and `data_o`.\n\n#### **AHB Protocol Compliance**\n- Validate the AHB transaction type (`htrans`) for different Wishbone operations:\n  - Idle (2'b00)\n  - Non-sequential (2'b10)\n  - Sequential (2'b11) \u2013 if burst support is added in the future\n- Verify proper operation of:\n  - AHB Ready Handling (`hready`):\n    - Ensure bridge correctly waits for `hready` before transferring data.\n  - AHB Response Handling (`hresp`):\n    - Include test cases where the AHB slave returns an error response (`hresp = 2'b01`).\n    - Check whether the bridge correctly stalls and recovers from such conditions.\n\n#### **Error and Recovery Handling**\n- AHB Error (`hresp = 2'b01`)\n  - Ensure the bridge correctly halts and resets the transaction.\n- AHB Busy Handling (`hready = 0`)\n  - Verify that the bridge waits and resumes when `hready` becomes `1`.\n\n---", "context": {}}, "output": {"response": "", "context": {"verif/wishbone_to_ahb_bridge_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n      ", "src/.env": "HASH   = 79a49dacf494628b34940c5fff404004e443b3af\nTARGET = 95\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html\n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n\n    assert metrics [\"uut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n    ", "src/wishbone_to_ahb_bridge.sv": "`timescale 1ns / 1ps\n\nmodule wishbone_to_ahb_bridge\n  // Wishbone ports from WB master\n (\n  input  clk_i,             // Clock input for Wishbone\n  input  rst_i,             // Reset input for Wishbone\n  input  cyc_i,             // Cycle signal from Wishbone master\n  input  stb_i,             // Strobe signal from Wishbone master\n  input  [3:0] sel_i,       // Byte enable signals from Wishbone master\n  input  we_i,              // Write enable signal from Wishbone master\n  input  [31:0] addr_i,     // Address signal from Wishbone master\n  input  [31:0] data_i,     // Data signal from Wishbone master\n  output reg [31:0] data_o, // Data output to Wishbone master\n  output ack_o,             // Acknowledgment signal to Wishbone master\n\n  // AHB ports to AHB slave\n  input  hclk,              // Clock input for AHB\n  input  hreset_n,          // Reset input for AHB (active low)\n  input  [31:0] hrdata,     // Data input from AHB slave\n  input [1:0] hresp,        // Response signal from AHB slave\n  input hready,             // Ready signal from AHB slave\n  output [1:0] htrans,      // Transfer type signal for AHB\n  output [2:0] hsize,       // Transfer size signal for AHB\n  output [2:0] hburst,      // Burst type signal for AHB (always SINGLE)\n  output hwrite,            // Write signal for AHB\n  output [31:0] haddr,      // Address signal for AHB\n  output reg [31:0] hwdata  // Data output to AHB slave\n);\n\n// Internal signals\nreg ahb_prev_addr_hold;  // Holds the address phase state\nreg ahb_data_phase;      // Indicates data phase\nreg [1:0] trans;         // Transfer type (Idle, Non-sequential, etc.)\nreg [2:0] size;          // Transfer size (Byte, Half-word, Word)\nreg [31:0] addr_hold;    // Holds the address during wait states\nreg [1:0] trans_hold;    // Holds transfer type during wait states\nreg [2:0] size_hold;     // Holds transfer size during wait states\nreg write_hold;          // Holds write signal during wait states\nreg [31:0] wb_adr_fixed; // Fixed Wishbone address after alignment\n\n// Fix up the Wishbone address\n// Aligns the Wishbone address based on byte enables (sel_i)\nalways @(*) begin\n  wb_adr_fixed[31:2] = addr_i[31:2]; \n\n  case (sel_i)\n    4'b0001: wb_adr_fixed[1:0] = 2'b00; \n    4'b0010: wb_adr_fixed[1:0] = 2'b01;\n    4'b0100: wb_adr_fixed[1:0] = 2'b10;\n    4'b1000: wb_adr_fixed[1:0] = 2'b11;\n    4'b0011: wb_adr_fixed[1:0] = 2'b00; \n    4'b1100: wb_adr_fixed[1:0] = 2'b10;\n    4'b1111: wb_adr_fixed[1:0] = 2'b00; \n    default: wb_adr_fixed[1:0] = addr_i[1:0]; \n  endcase\nend\n\nalways @(posedge hclk or negedge hreset_n) begin\n  if (!hreset_n)\n    ahb_prev_addr_hold <= 0;\n  else if (!ahb_data_phase & stb_i & cyc_i & !hready)\n    ahb_prev_addr_hold <= 1; \n  else\n    ahb_prev_addr_hold <= 0; \nend\n\nassign haddr  = ahb_prev_addr_hold ? addr_hold : wb_adr_fixed;\nassign htrans = ahb_prev_addr_hold ? trans_hold : trans;\nassign hsize  = ahb_prev_addr_hold ? size_hold : size;\nassign hwrite = ahb_prev_addr_hold ? write_hold : we_i;\nassign ack_o = ahb_data_phase ? hready : 0; \n\nassign hburst = 3'b000; // Fixed burst type (SINGLE)\n\nalways @(*) begin\n  case (sel_i)\n    4'b0001, 4'b0010, 4'b0100, 4'b1000: begin \n      hwdata = { data_i[7:0], data_i[15:8], data_i[23:16], data_i[31:24] };\n      data_o = { hrdata[7:0], hrdata[15:8], hrdata[23:16], hrdata[31:24] };\n    end\n    4'b0011, 4'b1100: begin \n      hwdata = { data_i[15:0], data_i[31:16] };\n      data_o = { hrdata[15:0], hrdata[31:16] };\n    end\n    default: begin \n      hwdata = data_i;\n      data_o = hrdata;\n    end\n  endcase\nend\n\nalways @(posedge hclk or negedge hreset_n) begin\n  if (!hreset_n)\n    ahb_data_phase <= 0;\n  else if (ahb_data_phase & hready)\n    ahb_data_phase <= 0; \n  else if (!ahb_data_phase & cyc_i & stb_i & hready)\n    ahb_data_phase <= 1; \nend\n\nalways @(posedge hclk or negedge hreset_n) begin\n  if (!hreset_n) begin\n    addr_hold  <= 0;\n    trans_hold <= 0;\n    size_hold  <= 0;\n    write_hold <= 0;\n  end else if (!ahb_prev_addr_hold) begin\n    addr_hold  <= wb_adr_fixed;\n    trans_hold <= trans;\n    size_hold  <= size;\n    write_hold <= we_i;\n  end\nend\n\nalways @(*) begin\n  if (ahb_data_phase)\n    trans = 2'b00; \n  else if (cyc_i) begin\n    if (stb_i)\n      trans = 2'b10; \n    else\n      trans = 2'b01; \n  end else\n    trans = 2'b00; \nend\n\nalways @(*) begin\n  case (sel_i)\n    4'b0001, 4'b0010, 4'b0100, 4'b1000: size = 3'b000; \n    4'b0011, 4'b1100: size = 3'b001; \n    4'b1111: size = 3'b010; \n    default: size = 3'b010; \n  endcase\nend\n\nendmodule"}}}
{"id": "cvdp_copilot_word_change_detector_0012", "categories": ["cid012", "medium"], "input": {"prompt": "\nComplete the Given Partial System Verilog Testbench `tb_Word_Change_Pulse`.  The testbench must instantiate the `Word_Change_Pulse` RTL module and provide input stimulus to validate its behavior. This module detects word changes and pattern matches in a DATA_WIDTH-bit data stream based on a specified mask and pattern.\n\n## Description\n\n**Parameters:**\n- `DATA_WIDTH`: Specifies the bit width of the input data word `data_in`. Default is 8. It must be a positive integer greater than or equal to 1.\n\n**Inputs:**\n- `clk`: Clock signal for synchronizing operations. The design is synchronized to the positive edge of this clock.\n- `reset`:Active-high asynchronous reset signal to initialize the module.\n- `data_in [DATA_WIDTH-1:0]`: Input data word whose changes are to be detected.\n- `mask [DATA_WIDTH-1:0]`: Mask signal to enable/disable change detection per bit (1 = detect changes, 0 = ignore changes)\n- `match_pattern [DATA_WIDTH-1:0]`: Pattern to compare against the (masked) input data word.\n- `enable`: Active-high signal, which enables the module\u2019s operation.\n- `latch_pattern`: When high, latches the current match_pattern into an internal register.\n\n**Outputs:**\n- `word_change_pulse`: Output signal that pulses high one clock cycle after any bit in data_in changes.\n- `pattern_match_pulse`: Pulses high to indicate the masked input data word matches the latched pattern.\n- `latched_pattern [DATA_WIDTH-1:0]`: Register that holds the latched pattern for comparison\n\n## Module Functionality\nThe Word_Change_Pulse module should perform the following:\n- **Pattern Latching**: When latch_pattern is asserted, match_pattern should be stored in latched_pattern.\n- **Word Change Detection**: The word_change_pulse should be asserted if any masked bit in data_in differs from data_in_prev.\n- **Pattern Match Detection**: The pattern_match_pulse should be asserted if the masked bits of data_in match latched_pattern.\n- **Enable Control**: If enable = 0, pulses should not be generated.\n- **Reset Behavior**: Upon assertion of reset, all outputs should be initialized to zero.\n\n## Instantiation\nThe testbench should instantiate the Word_Change_Pulse module as `uut` and connect the signals accordingly.\n\n## Input Generation \n\n### Clock Generation\nThe clk signal should toggle every 5 time units, resulting in a 100MHz operation.\n\n### Reset Handling\nThe reset signal should be asserted at the beginning of the simulation for three cycles. It should then be de-asserted, ensuring the DUT starts in a known state.\n\n### Stimulus \nSeveral test cases are applied to simulate different operations of the Word_Change_Pulse module. These cases cover a range of scenarios, including detecting word changes, pattern matching, masking behavior, enable-based operations, and edge cases.\n\n### Test Phases\nThe testbench should consist of multiple test phases, each targeting different behaviors of the module:\n\n#### Phase 1: Default Pattern Latching\nLatch a pattern of all zeros (00000000).  \n\n#### Phase 2: Word Change Pulse Tests\n- All bits transition from 0 \u2192 1.\n- All bits transition from 1 \u2192 0.\n- Single-bit flips (LSB, MSB).\n- Alternating bit patterns.\n- No changes in data_in (pulse should not be triggered).\n\n#### Phase 3: Pattern Match Pulse Tests\nLatch a specific pattern. \nApply data_in values that:\n- Match the pattern with the full mask.\n- Mismatch with full mask.\n- Partial match with partial mask.\n\n#### Phase 4: Masking Behavior\n- **Full Mask**: mask = 8'b11111111\n- **No Mask**: mask = 8'b00000000 (should suppress pulses).\n- **Random Mask Values**: Generate correct selective comparison.\n\n#### Phase 5: Enable Control\nRun tests with enable = 0 to ensure no pulses are generated.\n\n#### Phase 6: Generate Word Change and Pattern Match Pulses with Masking\n- No Change Scenario.\n- Single-Bit Transitions.\n-  Multiple-Bit Transitions.\n- Fully Masked Changes.\n- Pattern Match Case Without Changes.\n- Partial Mask and Upper Bits Transition.\n\n#### Phase 7: Stress Testing\n- Apply randomized data sequences over 100 cycles.\n- Introduce delays and glitches.\n\n### Final Steps \n- Waveform Dump: Generate a VCD file (Word_Change_Pulse.vcd) for visualization.\n\n### Partial Test Stimulus Generator Code :\n\n\n```verilog\nmodule tb_Word_Change_Pulse;\n\n    // Parameters\n    parameter DATA_WIDTH = 8;\n\n    // Testbench Signals\n    reg clk;\n    reg reset;\n    reg enable;\n    reg latch_pattern;\n    reg [DATA_WIDTH-1:0] data_in;\n    reg [DATA_WIDTH-1:0] mask;\n    reg [DATA_WIDTH-1:0] match_pattern;\n    reg [DATA_WIDTH-1:0] data_in_prev;\n    wire word_change_pulse;\n    wire pattern_match_pulse;\n    wire [DATA_WIDTH-1:0] latched_pattern;\n\n\n    // Instantiate the DUT\n    Word_Change_Pulse #(\n        .DATA_WIDTH(DATA_WIDTH)\n    ) dut (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .latch_pattern(latch_pattern),\n        .data_in(data_in),\n        .mask(mask),\n        .match_pattern(match_pattern),\n        .word_change_pulse(word_change_pulse),\n        .pattern_match_pulse(pattern_match_pulse),\n        .latched_pattern(latched_pattern)\n    );\n\n    // Clock Generation\n    initial clk = 0;\n    always #5 clk = ~clk;\n\n    task run_test(\n        input [DATA_WIDTH-1:0] test_data,\n        input [DATA_WIDTH-1:0] test_mask,\n        input [DATA_WIDTH-1:0] test_pattern,\n        input string testcase_name,\n        input reg test_enabled\n    );\n        begin\n            @(posedge clk);\n            data_in = test_data;\n            mask = test_mask;\n            match_pattern = test_pattern;\n            enable = test_enabled;\n            @(posedge clk);\n            $display(\"%s: data_in=%b, mask=%b, enable=%b -> word change pulse=%b\", \n                         testcase_name, test_data, test_mask, enable, word_change_pulse);\n        end\n    endtask\n\n    // Insert the code for the remaining test stimulus here\n\nendmodule\n```", "context": {}}, "output": {"response": "", "context": {"verif/tb_WordChangePulseGenerator.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro \n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = cd333cb68f0c2cced622013cbe0e25f802d5e693\nTARGET = 90\n", "src/Word_Change_Pulse.sv": "// Word_Change_Pulse Module with Maskable Input, Pattern Matching, and Advanced Features\nmodule Word_Change_Pulse #(\n    parameter DATA_WIDTH = 8 // Default word width\n) (\n    input  wire                  clk,               // Clock signal for synchronizing operations\n    input  wire                  reset,             // Reset signal to initialize the module\n    input  wire [DATA_WIDTH-1:0] data_in,           // Input data, width defined by parameter DATA_WIDTH\n    input  wire [DATA_WIDTH-1:0] mask,              // Mask signal to enable/disable change detection for each bit\n    input  wire [DATA_WIDTH-1:0] match_pattern,     // Pattern to match for generating the pulse\n    input  wire                  enable,            // Enable signal to allow module operation\n    input  wire                  latch_pattern,     // Signal to latch the match pattern\n    output reg                   word_change_pulse, // Output signal indicating a change in any bit of data_in\n    output reg                   pattern_match_pulse, // Output signal indicating a match with the pattern\n    output reg [DATA_WIDTH-1:0]  latched_pattern    // Latched pattern for comparison\n);\n\n    wire [DATA_WIDTH-1:0] change_pulses;\n\n    reg [DATA_WIDTH-1:0] masked_data_in;\n    reg [DATA_WIDTH-1:0] masked_change_pulses;\n    reg                  match_detected;\n\n    genvar i;\n    generate\n        for (i = 0; i < DATA_WIDTH; i = i + 1) begin : change_detectors\n            Bit_Change_Detector u_single_bit_change_detector (\n                .clk          (clk),\n                .reset        (reset),\n                .bit_in       (data_in[i]),\n                .change_pulse (change_pulses[i])\n            );\n        end\n    endgenerate\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            masked_data_in <= {DATA_WIDTH{1'b0}};\n            masked_change_pulses <= {DATA_WIDTH{1'b0}};\n            word_change_pulse <= 1'b0;\n            match_detected <= 1'b0;\n            pattern_match_pulse <= 1'b0;\n            latched_pattern <= {DATA_WIDTH{1'b0}};\n        end else if (enable) begin\n            if (latch_pattern) begin\n                latched_pattern <= match_pattern;\n            end\n            if (match_detected) begin\n            pattern_match_pulse <= 1'b1;\n            end else begin \n            pattern_match_pulse <= 1'b0;\n            end\n            masked_data_in <= data_in & mask;\n            masked_change_pulses <= change_pulses & mask;\n            word_change_pulse <= |masked_change_pulses;\n            match_detected <= (masked_data_in == (latched_pattern & mask));\n        end else begin\n            masked_data_in <= {DATA_WIDTH{1'b0}};\n            masked_change_pulses <= {DATA_WIDTH{1'b0}};\n            word_change_pulse <= 1'b0;\n            match_detected <= 1'b0;\n            pattern_match_pulse <= 1'b0;\n            latched_pattern <= {DATA_WIDTH{1'b0}};\n        end\n    end\n\nendmodule\n\n// Bit_Change_Detector Module\nmodule Bit_Change_Detector (\n    input  wire clk,         // Clock signal\n    input  wire reset,       // Reset signal to initialize the module\n    input  wire bit_in,      // Single bit input to detect changes\n    output reg  change_pulse // Pulse signal indicating a change in the input bit\n);\n\n    reg bit_in_d;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            bit_in_d <= 1'b0;\n            change_pulse <= 1'b0;\n        end else begin\n            bit_in_d <= bit_in; \n        end\n    end\n\n    always @(*) begin\n        change_pulse = (bit_in != bit_in_d); \n    end\nendmodule\n", "src/coverage.cmd": "report -metrics overall -out coverage.log\nreport -html -metrics all -out coverage_html -overwrite", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        while len(info) < 3:\n            info.append(\"0%\")\n\n        inst = re.sub(r'[\\W]', '', info[0])\n\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n\n    # Check if the required key exists in the metrics\n    if \"uut\" not in metrics:\n        raise KeyError(\"Metrics data for 'uut' is missing in the coverage log.\")\n\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))  \n    assert metrics[\"uut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['uut']['Average']}, Target: {target}\"\n"}}}
{"id": "cvdp_copilot_word_reducer_0012", "categories": ["cid012", "easy"], "input": {"prompt": "Create a testbench named `tb_Bit_Difference_Counter` using SystemVerilog to generate stimulus for the `Bit_Difference_Counter` module, which calculates the hamming distance (bitwise difference) between two inputs of equal bit width. The testbench should apply edge-case scenarios and random input patterns to thoroughly exercise the module. The testbench should only contain stimulus generator.\n\n## Module: `Bit_Difference_Counter`\n\n### Parameters:\n- **BIT_WIDTH**: Defines the width of the input vectors, with a default value of 3. This parameter must be a positive integer greater than or equal to 1.\n- **COUNT_WIDTH**: The expression calculates $clog2(BIT_WIDTH + 1), which is the width required to represent the maximum possible number of differing bits.\n### Inputs\n1. **`[BIT_WIDTH-1:0] input_A`**:  A binary input signal.\n2. **`[BIT_WIDTH-1:0] input_B`**:  A binary input signal of the same width as `input_A`.\n\n### Output\n1. **`[COUNT_WIDTH-1:0] bit_difference_count`**: The output indicates the Hamming distance between `input_A` and `input_B`. The Hamming distance is the number of differing bits between the two inputs.\n\n## Testbench Design\n\n### Instantiation\nThe `Bit_Difference_Counter` module is instantiated as `dut`, with the following connections:\n- **Inputs**: `input_A` and `input_B`\n- **Output**: `bit_difference_count`\n\n## Input Generation \n\n### Edge Case Testing\n1. **All Zero Inputs**:  Generate a test case where both inputs are composed entirely of zeros (0).\n2. **All One Inputs**:  Generate a test case where both inputs are composed entirely of ones (1).\n3. **Completely Different Inputs**:  Generate a test case where one input is all zeros and the other is all ones.\n4. **Single Bit Differences**:  For each bit position in the input, generate test cases where the inputs differ by only that single bit.\n\n### Randomized Testing\n- Randomly generates 100 test cases for `input_A` and `input_B`, covering various combinations of differing bits.\n", "context": {}}, "output": {"response": "", "context": {"verif/Data_Reduction_tb.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro \n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true", "src/.env": "HASH   = 788fbf7f1c84e1f87b2ee2554fce9da07d1987fd\nTARGET = 100\n", "src/Data_Reduction.sv": "`timescale 1ns / 1ps\n\nmodule Bit_Difference_Counter\n#(\n    parameter BIT_WIDTH    = 3,                          // Defines the width of the input vectors.\n    localparam COUNT_WIDTH = $clog2(BIT_WIDTH + 1)       // Calculates the width required to represent the count of differing bits.\n)\n(\n    input  wire [BIT_WIDTH-1:0] input_A,                // First input vector.\n    input  wire [BIT_WIDTH-1:0] input_B,                // Second input vector.\n    output reg  [COUNT_WIDTH-1:0] bit_difference_count  // Count of differing bits (Hamming distance).\n);\n\n    wire [BIT_WIDTH-1:0] different_bits;\n    integer idx;\n\n    // Instantiate the Data_Reduction module to compute bitwise XOR between input_A and input_B.\n    Data_Reduction\n    #(\n        .REDUCTION_OP (3'b010), // XOR operation\n        .DATA_WIDTH  (BIT_WIDTH),\n        .DATA_COUNT  (2)\n    )\n    compare_bits\n    (\n        .data_in      ({input_A, input_B}),\n        .reduced_data_out   (different_bits)\n    );\n\n    // Count set bits in different_bits to compute Hamming distance\n    always @(*) begin\n        bit_difference_count = 0;\n        for (idx = 0; idx < BIT_WIDTH; idx = idx + 1) begin\n            bit_difference_count = bit_difference_count + different_bits[idx];\n        end\n    end\n\nendmodule\n\nmodule Data_Reduction\n#(\n    parameter [2:0] REDUCTION_OP = 3'b000, // Default operation: AND\n    parameter DATA_WIDTH         = 4,      // Width of each data element\n    parameter DATA_COUNT         = 4,      // Number of data elements\n    localparam TOTAL_INPUT_WIDTH = DATA_WIDTH * DATA_COUNT\n)\n(\n    input  wire [TOTAL_INPUT_WIDTH-1:0] data_in,\n    output reg  [DATA_WIDTH-1:0]        reduced_data_out\n);\n\n    generate\n        genvar bit_index;\n\n        for (bit_index = 0; bit_index < DATA_WIDTH; bit_index = bit_index + 1) begin : bit_processing\n            wire [DATA_COUNT-1:0] extracted_bits;\n\n            genvar data_index;\n            for (data_index = 0; data_index < DATA_COUNT; data_index = data_index + 1) begin : bit_extraction\n                assign extracted_bits[data_index] = data_in[(data_index * DATA_WIDTH) + bit_index];\n            end\n\n            Bitwise_Reduction\n            #(\n                .REDUCTION_OP (REDUCTION_OP),\n                .BIT_COUNT    (DATA_COUNT)\n            )\n            reducer_instance\n            (\n                .input_bits  (extracted_bits),\n                .reduced_bit (reduced_data_out[bit_index])\n            );\n        end\n    endgenerate\n\nendmodule\n\n\nmodule Bitwise_Reduction\n#(\n    parameter [2:0] REDUCTION_OP = 3'b000, // Default operation: AND\n    parameter BIT_COUNT          = 4       // Number of bits to reduce\n)\n(\n    input  wire [BIT_COUNT-1:0] input_bits,\n    output reg                  reduced_bit\n);\n\n    // Reduction Operation Codes\n    localparam [2:0] AND_OP  = 3'b000;\n    localparam [2:0] OR_OP   = 3'b001;\n    localparam [2:0] XOR_OP  = 3'b010;\n    localparam [2:0] NAND_OP = 3'b011;\n    localparam [2:0] NOR_OP  = 3'b100;\n    localparam [2:0] XNOR_OP = 3'b101;\n\n    int i;\n    reg temp_result; \n\n    always @(*) begin\n        temp_result = input_bits[0];\n\n        for (i = 1; i < BIT_COUNT; i = i + 1) begin\n            case (REDUCTION_OP)\n                AND_OP, NAND_OP  : temp_result = temp_result & input_bits[i];\n                OR_OP,  NOR_OP   : temp_result = temp_result | input_bits[i];\n                XOR_OP, XNOR_OP  : temp_result = temp_result ^ input_bits[i];\n                default          : temp_result = temp_result & input_bits[i];\n            endcase\n        end\n\n        case (REDUCTION_OP)\n            NAND_OP : reduced_bit = ~temp_result;\n            NOR_OP  : reduced_bit = ~temp_result;\n            XNOR_OP : reduced_bit = ~temp_result;\n            default : reduced_bit = temp_result;\n        endcase\n    end\nendmodule", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/Data_Reduction.sv /code/verif/Data_Reduction_tb.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        while len(info) < 3:\n            info.append(\"0%\")\n\n        inst = re.sub(r'[\\W]', '', info[0])\n\n        try:\n            avg = float(info[1].rstrip('%')) if '%' in info[1] else 0.0\n            cov = float(info[2].rstrip('%')) if '%' in info[2] else 0.0\n        except ValueError:\n            avg = 0.0\n            cov = 0.0\n\n        # Store the metrics\n        metrics[inst] = {\n            \"Average\": avg,\n            \"Covered\": cov\n        }\n\n    # Check if the required key exists in the metrics\n    if \"dut\" not in metrics:\n        raise KeyError(\"Metrics data for 'dut' is missing in the coverage log.\")\n\n    # Assert the average coverage for 'dut' is above the target\n    target = float(os.getenv(\"TARGET\", 100.0))  \n    assert metrics[\"dut\"][\"Average\"] >= target, f\"Didn't achieve the required coverage result. Achieved: {metrics['dut']['Average']}, Target: {target}\"\n"}}}
{"id": "cvdp_copilot_write_through_data_direct_mapped_cache_0001", "categories": ["cid012", "medium"], "input": {"prompt": "Complete the given partial System Verilog Testbench `tb_ddm_cache`.The testbench must instantiate the `ddm_cache` RTL module and provide input stimulus for it, focusing exclusively on generating comprehensive test vectors rather than building a full testbench. The data cache handles read and write operations from the CPU, along with memory access operations. The module supports both cached memory accesses and uncached I/O port accesses.\n\n## Module Interface\n## 1. Inputs:\n\n- `clk(1-bit)`: Clock signal. The module operates on the rising edge of `clk`. It synchronizes the operations within the cache logic.\n\n- `rst_n(1-bit)`: 1-bit asynchronous, active-low reset signal. This is triggered on a negedge (falling edge) of the reset signal. When rst_n is asserted (`rst_n` = 0), all the cache locations are invalidated\n\n- `cpu_addr (32-bit,[31:0])`: A 32-bit input representing the memory address issued by the CPU for a read or write operation. This address is used by the cache to determine if a cache hit or miss occurs.\n\n- `cpu_dout (32-bit,[31:0])`: A 32-bit input that carries data emitted by the CPU when writing to memory.\n\n- `cpu_strobe(1-bit)`: A ACTIVE HIGH signal indicating that the CPU wants to perform a read or write operation.\n\n- `cpu_rw:(1-bit)` A control signal indicating the type of operation to be performed by the CPU. cpu_rw = 1 represents a memory write operation, while cpu_rw = 0 represents a memory read operation.\n\n- `uncached(1-bit)`: A control signal where uncached = 1 indicates that the operation is accessing an uncached I/O port (instead of memory). When uncached = 0, a regular memory operation is performed.\n\n- `mem_dout(32-bit, [31:0])`: A 32-bit input that carries data from memory. This data is provided to the cache when there is a cache miss and is forwarded to the CPU if it is a read operation.\n\n- `mem_ready(1-bit)`: A signal indicating that memory is ready with the data to be provided to the cache\n\n## 2. Outputs:\n\n- `cpu_din (32-bit, [31:0])`: A 32-bit output that carries data to the CPU during a read operation. This can either be data from the cache or from memory in the event of a cache miss.\n\n- `mem_din(32-bit, [31:0])`: A 32-bit output carrying data from the CPU to memory when via cache during a write operation\n\n- `cpu_ready(1-bit)`: A signal indication from the cache that data is ready for the CPU to be read.\n\n- `mem_strobe(1-bit)`: A signal that indicates that the memory is going to be accessed by the cache for a read or write operation\n\n- `mem_rw`: The read/write control signal for memory. It reflects the cpu_rw signal, indicating whether the operation is a read (0) or write (1) to memory.\n\n- `mem_addr(32-bit ,[31:0])`: A 32-bit output representing the memory address sent to the memory during the read/write operation from the cache.\n\n- `cache_hit(1-bit)` - A ACTIVE HIGH signal indicating memory location is available in Cache.\n\n- `cache_miss(1-bit)` - A ACTIVE HIGH signal indicating memory location is not available in Cache.\n\n- `d_data_out(32-bit,[31:0])` - Data at a particular index(location) of the cache.\n\n\n## Instantiation :\nThe testbench instantiates the `ddm_cache` module as dut and connects the signals between the module and the testbench. Each input and output from the DUT is connected to its corresponding signal in the testbench.\n\n## Input Generation and Validation:\n\n- Clock Generation: The clock signal `clk` is generated using an always block that toggles the clock every 5 time units.\n\n- Reset: The reset signal `rst_n` is asserted at the beginning of the simulation to ensure the cache is initialized in a known state. After a short period (10 time units), the reset is deasserted.\n\n- Stimulus: Several test cases are applied to simulate various operations of the cache. These test cases cover a range of scenarios such as cache misses, cache writes, and uncached accesses. For each case, the relevant signals (address, data, control signals) are set, followed by a brief wait period to allow the DUT to respond.\n\n  - Test Case 1: A cache read miss occurs when the CPU accesses address 0x00000000. The memory provides data (0x11111111), and the CPU reads this data from memory after the cache miss.\n\n  - Test Case 2: A cache write occurs when the CPU accesses address 0x00000004 and writes data (0xAABBCCDD) into the cache.\n\n  - Test Case 3: A cache read hit occurs when the CPU accesses address 0x00000000. The cache provides the previously cached data (0x11111111) without needing to access memory.\n\n  - Test Case 4: A cache write and read after reset occur when the CPU writes to address 0x00000010 and then reads the data back from the cache after a reset.\n\n  - Test Case 5: An edge case occurs when the CPU writes to address 0x00000014 with two different values (0xDEADBEEF and 0xFACEFEED), followed by a read operation. The cache should return the most recent value (0xFACEFEED).\n\n   - Test Case 6: A cache miss and cache write with different memory delays occur when the CPU performs a write operation at address 0x00000018 while memory readiness (`mem_ready`) changes. The cache should handle these delays properly.\n\n   - Test Case 7: An uncached IO port access occurs when the CPU writes to IO port address 0xF0000000. This access bypasses the cache and directly interacts with the IO port.\n\n   - Test Case 8: Cache read and write operations with randomized addresses occur when the CPU performs random read and write operations. The cache should handle these operations correctly.\n\n   - Test Case 9: A cache invalidation occurs when the CPU writes data (0xDEADBEAF) to address 0x00000020, and then performs a read, resulting in a cache miss. The cache fetches new data (0xBBBBBBBB) from memory.\n\n   - Test Case 10: Boundary address tests occur when the CPU accesses the first (0x00000000) and last (0xFFFFFFFC) cacheable addresses. These boundary cases are tested to ensure correct cache handling at the limits of the address space.\n   \n   - Test Case 11: Multiple cache misses and hits in sequence occur when the CPU performs operations at sequential addresses (0x00000024, 0x00000028). The cache should handle the misses and hits correctly.\n\n   - Test Case 12: A memory read with a cache miss and delayed memory readiness occurs when the CPU reads from address 0x00000050. The memory is initially not ready (`mem_ready` = 0), causing a delay before the CPU can read the data after the cache miss. The memory readiness flag is toggled to allow the read after a short delay.\n\n## Module Functionality:\n- Asynchronous Reset: When `rst_n` is asserted (`rst_n = 0`), all cache locations are invalidated This ensures the cache is reset to a known state.\n\n- Cache Operation: On each rising edge of clk, the cache processes the incoming requests from the CPU:\n\n   - Cache Read: If the CPU issues a read request and the address is present in the cache (`cache hit`), the corresponding data is returned to the CPU without accessing memory.\n\n  - Cache Miss: If the CPU accesses a memory address that is not cached (`cache miss`), the cache issues a memory read request to the memory. Once the data is retrieved from memory, it is stored in the cache for future accesses.\n\n - Cache Write: If the CPU writes data, the cache writes the data into the cache entry corresponding to the address. If the operation is not cached (i.e., `uncached = 1`), the data is written directly to memory instead of the cache.\n\n - Cache Management: Each cache entry has a valid bit, a tag, and data. The tag is used to determine whether a cache entry matches the requested address, and the valid bit indicates whether the entry contains valid data. When a write operation occurs, the corresponding cache entry is updated with the new tag and data.\n\n - Memory Read/Write: If a cache miss occurs, the module performs a memory read operation (if `cpu_rw = 0`), waits for the memory to become ready (`mem_ready`), and then forwards the data to the CPU. Similarly, for write operations (`cpu_rw = 1`), the data is written to memory after it is cached.\n\n - Cache Write Signal: The cache write signal (`cache_write`) is asserted when a write operation occurs, either because the CPU is performing a write or because the cache is updating its contents after a cache miss.\n\n**Partial Test Stimulus Generator Code :**\n``` verilog\nmodule tb_ddm_cache;\n\n  logic clk;\n  logic rst_n;\n  logic [31:0] cpu_addr;\n  logic [31:0] cpu_dout;\n  logic cpu_strobe;\n  logic cpu_rw;\n  logic uncached;\n  logic [31:0] mem_dout;\n  logic mem_ready;\n  logic [31:0] cpu_din;\n  logic [31:0] mem_din;\n  logic cpu_ready;\n  logic mem_strobe;\n  logic mem_rw;\n  logic [31:0] mem_addr;\n  logic cache_hit;\n  logic cache_miss;\n  logic [31:0] d_data_dout;\n\n  ddm_cache dut (\n    .clk(clk),\n    .rst_n(rst_n),\n    .cpu_addr(cpu_addr),\n    .cpu_dout(cpu_dout),\n    .cpu_strobe(cpu_strobe),\n    .cpu_rw(cpu_rw),\n    .uncached(uncached),\n    .mem_dout(mem_dout),\n    .mem_ready(mem_ready),\n    .cpu_din(cpu_din),\n    .mem_din(mem_din),\n    .cpu_ready(cpu_ready),\n    .mem_strobe(mem_strobe),\n    .mem_rw(mem_rw),\n    .mem_addr(mem_addr),\n    .cache_hit(cache_hit),\n    .cache_miss(cache_miss),\n    .d_data_dout(d_data_dout)\n  );\n\n  always begin\n    #5 clk = ~clk;\n  end\n\n  \n  initial begin\n    clk = 0;\n    rst_n = 0;\n    cpu_addr = 32'h00000000;\n    cpu_dout = 32'h12345678;\n    cpu_strobe = 0;\n    cpu_rw = 0;\n    uncached = 0;\n    mem_dout = 32'h00000000;\n    mem_ready = 1;\n\n    #10 rst_n = 1;\n    #10;\n\n    $display(\"Test case 1: Cache Read Miss (CPU address 0x00000000)\");\n    cpu_addr = 32'h00000000;\n    cpu_dout = 32'h12345678;\n    cpu_strobe = 1;\n    cpu_rw = 0;\n    uncached = 0;\n    mem_dout = 32'h11111111;\n    #10;\n    cpu_strobe = 0;\n    #50;\n    \n    $display(\"Test case 2: Cache Write (CPU address 0x00000004)\");\n    cpu_addr = 32'h00000004;\n    cpu_dout = 32'hAABBCCDD;\n    cpu_strobe = 1;\n    cpu_rw = 1;\n    uncached = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;\n    \n    $display(\"Test case 3: Cache Read Hit (CPU address 0x00000000, should hit cached data)\");\n    cpu_addr = 32'h00000000;\n    cpu_strobe = 1;\n    cpu_rw = 0;\n    uncached = 0;\n    #10;\n    cpu_strobe = 0;\n    #10;\n        \n    // Insert the code for the remaining test cases here\n   ```", "context": {}}, "output": {"response": "", "context": {"verif/tb_ddm_cache.sv": ""}}, "harness": {"files": {"docker-compose.yml": "services:\n\n  xrun:\n    image: __VERIF_EDA_IMAGE__\n    volumes:\n      - ./src/:/src/:ro # Infrastructure location\n    env_file : ./src/.env\n    command: pytest /src/process.py -v -s\n    networks:\n      - licnetwork\n\nnetworks:\n  licnetwork:\n      name: licnetwork\n      external: true\n", "src/.env": "HASH   = 8964898c83fa98eb898b95bbe0d73de7203c7e67\nTARGET = 85\n", "src/coverage.cmd": "report -metrics overall -out coverage.log", "src/ddm_cache.sv": "module ddm_cache (\n  input  logic        clk,           // Posedge clock\n  input  logic        rst_n,         // Asynchronous Negedge reset\n  input  logic [31:0] cpu_addr,      // Memory address emitted by the CPU\n  input  logic [31:0] cpu_dout,      // Data emitted by CPU\n  input  logic        cpu_strobe,    // CPU status signal to Cache to indicate it is going to perform a read or write operation\n  input  logic        cpu_rw,        // cpu_rw == 1, Memory Write Operation ; cpu_rw == 0 , Memory Read Operation\n  input  logic        uncached,      // uncached == 1 , IO port is accessed ; uncached == 0, Memory is accessed\n  input  logic [31:0] mem_dout,      // Data emitted by memory\n  input  logic        mem_ready,     // Memory is ready with the read data\n  output logic [31:0] cpu_din,       // CPU Data coming from Memory through Cache\n  output logic [31:0] mem_din,       // Memory Data coming from CPU through Cache\n  output logic        cpu_ready,     // Cache is ready with data to be provided to CPU\n  output logic        mem_strobe,    // Cache Status signal to Memory to indicate it is going to perform a read or write operation\n  output logic        mem_rw,        // mem_rw == 1, Memory Write Operation ; mem_rw == 0 , Memory Read Operation\n  output logic [31:0] mem_addr,      // Memory address to be accessed, emitted by the Cache\n  output logic        cache_hit,     // Indicates a memory location is available in the cache\n  output logic        cache_miss,    // Indicates a memory location is not available in the cache\n  output logic [31:0] d_data_dout     // Data at a cache index\n);\n\n  logic         d_valid [0:63];\n  logic [23:0]  d_tags  [0:63];\n  logic [31:0]  d_data  [0:63];\n  \n  logic [23:0] tag;\n  logic [5:0]  index;\n  \n  logic [31:0] cache_din;   \n  logic        cache_write; \n  logic [23:0] d_tag_out;\n  logic  valid;\n  \n  integer i;\n  \n  assign tag   = cpu_addr[31:8];\n  assign index = cpu_addr[7:2]; \n  assign cache_write = ~uncached & (cpu_rw | cache_miss & mem_ready); \n  \n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        for (i = 0; i < 64; i = i + 1) begin\n            d_valid[i] <= 0;\n        end\n    end else if (cache_write) begin\n            d_valid[index] <= 1;\n    end\n  end\n\n  assign cache_din = cpu_rw ? cpu_dout : mem_dout;\n  always_ff@(posedge clk) begin\n       if(cache_write) begin\n         d_tags [index] <= tag;\n         d_data [index] <= cache_din;\n      end else begin\n         d_tags [index] <= d_tags[index] + 32'd0;\n         d_data [index] <= d_data[index] + 32'd0;\n       end\n  end  \n  \n  assign valid          = d_valid[index];\n  assign d_tag_out      = d_tags [index];\n  assign cache_dout     = d_data [index];\n  assign cache_hit      = cpu_strobe & valid & (d_tag_out == tag);\n  assign cache_miss     = cpu_strobe & (!valid | (d_tag_out != tag));\n  assign mem_din        = cpu_dout;\n  assign mem_addr       = cpu_addr;\n  assign mem_rw         = cpu_rw;\n  assign mem_strobe     = cpu_strobe | cache_miss;\n  assign cpu_ready      = ~cpu_rw & cache_hit | (cache_miss | cpu_rw) & mem_ready;\n  assign cpu_din        = cache_hit ? cache_dout : mem_dout;\n  assign d_data_out     = cache_dout;\nendmodule  \n", "src/process.py": "import os\nimport re\nimport subprocess\nimport pytest\n\n# ----------------------------------------\n# - Simulate\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='session')\ndef test_simulate():\n\n    cmd = \"xrun -coverage all /src/*.sv /code/verif/*.sv -covtest test -seed random -covoverwrite\"\n    assert(subprocess.run(cmd, shell=True)), \"Simulation didn't ran correctly.\"\n\n# ----------------------------------------\n# - Generate Coverage\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_simulate')\ndef test_coverage():\n\n    cmd = \"imc -load /code/rundir/cov_work/scope/test -exec /src/coverage.cmd\"\n    assert(subprocess.run(cmd, shell=True)), \"Coverage merge didn't ran correctly.\"\n\n# ----------------------------------------\n# - Report\n# ----------------------------------------\n\n@pytest.mark.usefixtures(scope='test_coverage')\ndef test_report():\n\n    metrics = {}\n\n    with open(\"/code/rundir/coverage.log\") as f:\n        lines = f.readlines()\n\n    # ----------------------------------------\n    # - Evaluate Report\n    # ----------------------------------------\n\n    for line in lines[2:]:\n        info = line.split()\n\n        inst = info [0]\n        avg  = info [1]\n        cov  = info [2]\n\n        inst = re.sub(r'[\\W]', '', inst)\n\n        metrics [inst] = {\n            \"Average\" : float(avg[:-1]),\n            \"Covered\" : float(cov[:-1])\n        }\n        \n\n    assert metrics [\"dut\"][\"Average\"] >= float(os.getenv(\"TARGET\")), \"Didn't achieved the required coverage result.\"\n"}}}
